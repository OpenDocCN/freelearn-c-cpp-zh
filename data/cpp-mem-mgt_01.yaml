- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Objects, Pointers, and References
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象、指针和引用
- en: Before we start discussing memory management in C++, let’s make sure we understand
    each other and agree on a common vocabulary. If you’re a long-time C++ programmer,
    you probably have your own ideas about what pointers, objects, and references
    are. Your ideas will stem from a wealth of experience. If you are coming to this
    book from another language, you might also have your own ideas as to what these
    terms mean in C++ and how they relate to memory and memory management.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论C++中的内存管理之前，让我们确保我们彼此理解，并就一个共同的词汇达成一致。如果你是经验丰富的C++程序员，你可能有自己的关于指针、对象和引用的想法。你的想法将源于丰富的经验。如果你是从其他语言转向这本书，你也可能对这些术语在C++中的含义以及它们与内存和内存管理的关系有自己的看法。
- en: 'In this chapter, we are going to make sure we have a common understanding of
    some basic (but profound) ideas so that we can build on this shared understanding
    for the rest of our adventure together. Specifically, we will explore questions
    such as the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将确保我们对一些基本（但深刻）的概念有一个共同的理解，以便我们可以在接下来的冒险中共同建立在这个共享理解的基础上。具体来说，我们将探讨以下问题：
- en: How is memory represented in C++? What exactly is that thing we call memory,
    at least in the context of the C++ language?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中内存是如何表示的？我们所说的内存究竟是什么，至少在C++语言的环境中？
- en: What are objects, pointers, and references? What do we mean by those terms in
    C++? What are the lifetime rules of objects? How do they relate to memory?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象、指针和引用是什么？在C++中，我们通过这些术语意味着什么？对象的生存期规则是什么？它们如何与内存相关？
- en: What are arrays in C++? In this language, arrays are a low-level but highly
    efficient construct represented in a way that directly impacts memory management.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++中，数组是什么？在这种语言中，数组是一种底层但效率极高的结构，其表示方式直接影响到内存管理。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This book assumes that readers have some basic knowledge of C++ or of syntactically
    similar languages such as C, Java, C#, or JavaScript. For this reason, we will
    not explain the basics of variable declarations, loops, `if` statements, or functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设读者对C++或与C、Java、C#或JavaScript语法相似的语言有一些基本知识。因此，我们不会解释变量声明、循环、`if`语句或函数的基本知识。
- en: We will, however, use some aspects of the C++ language in this chapter that
    some readers might be less comfortable with. Please refer to [*Annexure*](B21071_16.xhtml#_idTextAnchor221)*:*
    *Things You Should Know*, before reading this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中，我们将使用一些读者可能不太熟悉的C++语言的某些方面。在阅读本书之前，请参阅[*附录*](B21071_16.xhtml#_idTextAnchor221)*:*
    *你应该知道的事情*。
- en: Some of the examples use C++20 or C++23, so make sure that your compiler supports
    this version of the standard to get the most out of them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例使用了C++20或C++23，所以请确保你的编译器支持这个标准的版本，以便充分利用它们。
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter1](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter1).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter1](https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/tree/main/chapter1)。
- en: Representation of memory in C++
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中内存的表示
- en: This is a book on memory management. You, readers, are trying to figure out
    what it means, and I, as the author, am trying to convey what it means.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一本关于内存管理的书。读者们正在试图弄清楚这意味着什么，而我作为作者，正在试图传达它的含义。
- en: The way in which the standard describes memory can be seen in [[wg21.link/basic.memobj](http://wg21.link/basic.memobj)].
    Essentially, memory in C++ is expressed as one or more sequences of contiguous
    bytes. This opens up the possibility of memory expressed as a set of discontinuous
    blocks of contiguous memory because, historically, C++ has supported memories
    made of various distinct segments. Every byte in a C++ program has a unique address.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 标准对内存的描述可以在[[wg21.link/basic.memobj](http://wg21.link/basic.memobj)]中看到。本质上，C++中的内存被表达为一或多个连续字节的序列。这为将内存表达为一系列不连续的连续内存块的可能性打开了大门，因为从历史上看，C++支持由各种不同段组成的内存。C++程序中的每个字节都有一个唯一的地址。
- en: Memory in a C++ program is populated with various entities such as objects,
    functions, references, and so on. Managing memory efficiently requires grasping
    what these entities mean and how programs can make use of them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++程序中的内存被各种实体填充，如对象、函数、引用等。有效地管理内存需要掌握这些实体的含义以及程序如何利用它们。
- en: The meaning of the word byte is important in C++. As detailed in [[wg21.link/intro.memory](http://wg21.link/intro.memory)],
    bytes are the fundamental storage unit in C++. The number of bits in a byte is
    implementation-defined in C++. The standard does state, however, that a byte has
    to be wide enough to contain both the ordinary literal encoding of any element
    of the basic literal character set and the eight-bit code units of the UTF-8 encoding
    form. It also states that a byte is made of a contiguous sequence of bits.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，单词“字节”的含义非常重要。正如[[wg21.link/intro.memory](http://wg21.link/intro.memory)]中详细说明的那样，字节是C++中的基本存储单元。在C++中，一个字节中的位数是实现定义的。然而，标准确实声明，一个字节必须足够宽，以包含基本字面字符集中的任何元素的普通字面编码以及UTF-8编码形式的八位代码单元。它还指出，一个字节是由连续位序列组成的。
- en: 'What often surprises people is that in C++, a byte is not necessarily an octet:
    a byte consists of at least eight bits but could be made of more (something that’s
    useful on some exotic hardware). This might change in the future, as the standard
    committee might constrain that definition someday, but this is the situation at
    the time of the publication of this book. The key idea here is that a byte is
    the smallest addressable unit of memory in a program.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，在C++中，一个字节不一定是八位：一个字节由至少八个位组成，但可能由更多位组成（这在某些异构硬件上很有用）。这种情况可能会在未来改变，因为标准委员会可能会在某个时候限制这个定义，但这是本书出版时的状况。这里的关键思想是，字节是程序中最小的可寻址内存单元。
- en: Objects, pointers, and references
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象、指针和引用
- en: We tend to use words such as object, pointer, and reference informally, without
    thinking too much about what they mean. In a language such as C++, these words
    have precise meanings that define and delimit what we can do in practice.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们倾向于非正式地使用诸如对象、指针和引用之类的词语，而不太考虑它们的含义。在C++这样的语言中，这些词语有精确的含义，定义并界定了我们在实践中可以做什么。
- en: Before we get our hands dirty, so to speak, let’s examine the formal meaning
    of these terms in C++.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们动手操作之前，让我们来考察一下这些术语在C++中的正式含义。
- en: Objects
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象
- en: If we polled programmers working with different languages and asked them how
    they would define the term object, we could probably expect such answers as “something
    that groups together variables and related functions” or “an instance of a class,”
    which correspond to traditional takes on that term from the realm of object-oriented
    programming.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对使用不同语言的程序员进行民意调查，并询问他们如何定义“对象”这个术语，我们可能会得到诸如“将变量和相关函数组合在一起的东西”或“类的实例”之类的答案，这对应于从面向对象编程领域对这一术语的传统理解。
- en: 'C++ as a language tries to provide homogeneous support for user-defined types
    such as structs or classes. It also provides support for fundamental types such
    as `int` or `float`. Thus, it probably should not be surprising that, for C++,
    the definition of an object is expressed in terms of its properties, not in terms
    of what the word means, and that this definition includes the most fundamental
    types. The definition of an object in C++ is described in [[wg21.link/intro.object](http://wg21.link/intro.object)]
    and takes the following factors into account:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: C++作为一种语言，试图为用户定义的类型（如struct或class）提供同质支持。它还提供了对基本类型（如`int`或`float`）的支持。因此，对于C++来说，对象的定义是以其属性来表达的，而不是以这个词语的含义来表达的，并且这个定义包括最基本的数据类型。C++中对象的定义在[[wg21.link/intro.object](http://wg21.link/intro.object)]中描述，并考虑以下因素：
- en: How the object is created explicitly, such as when defining the object or constructing
    it through one of the many variations of `operator new`. The object may also be
    created implicitly such as when creating a temporary object as the result of some
    expression or when changing the active member of a `union`.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象如何被显式创建，例如在定义对象或通过`operator new`的多种变体之一构造它时。对象也可能被隐式创建，例如在创建临时对象作为某些表达式的结果时，或者当改变`union`的当前成员时。
- en: The fact that an object is somewhere (it has an address) and occupies a region
    of storage of non-zero size, from the start of its construction to the end of
    its destruction.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象存在于某个地方（它有一个地址）并且占据一个非零大小的存储区域，从其构造开始到其销毁结束。
- en: Other properties of an object, including its name (if it has one), its type,
    and its storage duration (`automatic`, `static`, `thread_local`, and so on.).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的其他属性，包括其名称（如果有的话）、其类型和其存储持续时间（`自动`、`静态`、`thread_local`等）。
- en: The C++ standard explicitly calls out functions as not being objects, even if
    a function has an address and occupies storage.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准明确指出函数不是对象，即使函数有一个地址并占用存储空间。
- en: 'From this, we can infer that even a humble `int` is an object, but a function
    is not. You can see already, dear reader, that the book you’re reading will touch
    on fundamental topics, since lifetime and the storage occupied by objects are
    part of the fundamental properties of these entities we use in our programs every
    day. Such things as lifetime and storage are clearly part of what memory management
    is about. You can convince yourself of that fact with this simple program:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个事实中，我们可以推断出即使是普通的`int`也是一个对象，但函数不是。亲爱的读者，您已经可以看到，您正在阅读的这本书将涉及基本主题，因为对象的生命周期和占用的存储空间是我们在日常程序中使用这些实体时的基本属性的一部分。诸如生命周期和存储空间这样的东西显然是内存管理的一部分。您可以通过这个简单的程序来证实这一事实：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What is an object? It’s something that has a lifetime and occupies storage.
    Controlling these characteristics is part of the reasons why this book exists.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是对象？它是有生命周期并占用存储空间的东西。控制这些特性是这本书存在的原因之一。
- en: Pointers
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指针
- en: There are numerous (around 2,000) mentions of the word “pointer” in the text
    of the C++ standard, but if you open an electronic copy of that document and search
    through it, you’ll find that a formal definition is surprisingly hard to come
    by. This can be surprising given the fact that people tend to associate that idea
    with C and (by extension) C++.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++标准的文本中，有无数（大约2,000次）提到了“指针”这个词，但如果你打开该文档的电子版并搜索，你会发现正式的定义出奇地难以找到。考虑到人们倾向于将这个想法与C语言以及（通过扩展）C++语言联系起来，这一点可能会让人感到惊讶。
- en: 'Let us try to offer a useful yet informal definition, then: a pointer is a
    typed address. It associates a type with what is found at some location in memory.
    For that reason, in code like the following, one reads that `n` is an `int` object
    and that `p` points to an `int` object that happens to be the address of the `n`
    object:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试给出一个有用而又非正式的定义：指针是一个类型化的地址。它将一个类型与内存中某个位置的存储内容关联起来。因此，在如下代码中，我们可以看到`n`是一个`int`对象，而`p`指向一个`int`对象，恰好是`n`对象的地址：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It’s important to understand here that `p` indeed points to an `int`, unless
    `p` is left uninitialized, `p` points to `nullptr`, or programmers have played
    tricks with the type system and made `p` point to something else deliberately.
    Of course, pointer `p` is an object, as it respects all the rules to that effect.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里理解这一点很重要，即`p`确实指向一个`int`，除非`p`被未初始化，`p`指向`nullptr`，或者程序员在类型系统中玩弄技巧，故意让`p`指向其他内容。当然，指针`p`是一个对象，因为它遵守了所有相关的规则。
- en: 'Much of the (syntactic) confusion about pointers probably comes from the contextual
    meaning of the `*` and `&` symbols. The trick is to remember that they have different
    roles when they appear in the introduction of a name and when they are used on
    an existing object:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于指针的许多（语法上的）困惑可能源于`*`和`&`符号的上下文意义。关键是要记住，当它们出现在名称的引入部分和用于现有对象时，它们有不同的角色：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, when introducing an object, `*` means “pointer to.” On an existing
    object, it means “what that pointer points to” (the pointee). Similarly, when
    introducing a name, `&` means “reference to” (something we will discuss imminently).
    On an existing object, it means “address of” and yields a pointer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在引入对象时，`*`表示“指向”。在现有对象上，它表示“指针指向的内容”（即被指对象）。同样，在引入名称时，`&`表示“引用”（我们很快就会讨论）。在现有对象上，它表示“地址”并产生一个指针。
- en: 'Pointers allow us to do arithmetic, but that’s (legitimately) seen as a dangerous
    operation, as it can take us to arbitrary locations in a program and can therefore
    lead to serious damage. Arithmetic on a pointer depends on its type:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 指针允许我们进行算术运算，但这（合法地）被视为一种危险的操作，因为它可以带我们到程序中的任意位置，因此可能导致严重损坏。指针的算术运算取决于其类型：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Of course, accessing the contents of arbitrary addresses is just asking for
    trouble. This is because it would mean invoking undefined behavior (described
    in [*Chapter 2*](B21071_02.xhtml#_idTextAnchor027)), and if you do that, you’re
    on your own. Please do not do such things in real code, as you could hurt programs
    – or worse, people. C++ is powerful and flexible, but if you program in C++, you’re
    expected to behave responsibly and professionally.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，访问任意地址的内容只是自找麻烦。这是因为这意味着调用未定义的行为（在[*第 2 章*](B21071_02.xhtml#_idTextAnchor027)中描述），如果你这样做，那么你将独自承担后果。请在实际代码中不要这样做，因为这可能会伤害程序——或者更糟，伤害人们。C++
    强大而灵活，但如果你用 C++ 编程，你被期望要负责任和专业。
- en: 'C++ has four special types for pointer manipulation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 有四种用于指针操作的专用类型：
- en: '`void*` means “address with no specific (type-related) semantics.” A `void*`
    is an address with no associated type. All pointers (if we discount the `const`
    and `volatile` qualifiers) are implicitly convertible to `void*`; an informal
    way to read this is as “all pointers, regardless of type, really are addresses.”
    The converse does not hold. For example, it’s not true that all addresses are
    implicitly convertible to `int` pointers.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void*` 表示“没有特定（类型相关）语义的地址。”一个 `void*` 是一个没有关联类型的地址。所有指针（如果我们不考虑 `const` 和
    `volatile` 修饰符）都可以隐式转换为 `void*`；一种非正式的阅读方式是“所有指针，无论类型如何，实际上都是地址。”反之则不成立。例如，并不是所有地址都可以隐式转换为
    `int` 指针。'
- en: '`char*` means “pointer to a byte.” Due to the C language roots of C++, a `char*`
    can alias any address in memory (the `char` type, regardless of its name, which
    evocates “character”, really means “byte” in C and, by extension, in C++). There
    is an ongoing effort in C++ to give `char` the meaning of “character,” but as
    of this writing, a `char*` can alias pretty much anything in a program. This hampers
    some compiler optimization opportunities (it is hard to constrain or reason about
    something that can lead to literally anything in memory).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char*` 表示“字节的指针。”由于 C++ 的 C 语言根源，一个 `char*` 可以与内存中的任何地址别名（无论其名称如何，它唤起的“字符”在
    C 和 C++ 中实际上意味着“字节”）。在 C++ 中，有一个持续的努力给 `char` 赋予“字符”的意义，但截至本文写作时，`char*` 可以与程序中的几乎所有内容别名。这阻碍了一些编译器优化机会（很难约束或推理可能导致内存中任何内容的东西）。'
- en: '`std::byte*` is the new “pointer to a byte,” at least since C++17\. The (long-term)
    intent of `byte*` is to replace `char*` in those functions that do byte-per-byte
    manipulation or addressing, but since there’s so much code that uses `char*` to
    that effect, this will take time.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::byte*` 是新的“字节的指针”，至少从 C++17 开始。`byte*` 的（长期）意图是替换那些进行字节对字节操作或寻址的函数中的
    `char*`，但由于有大量代码使用 `char*` 来实现这一目的，这需要时间。'
- en: 'For an example of conversion from and to `void*`, consider the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个从 `void*` 转换到和从 `void*` 转换的示例：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following example, which is somewhat more elaborate, uses `const char*`
    (but could use `const byte*` instead). It shows that one can compare the byte-per-byte
    representation of two objects, at least in some circumstances, to see whether
    they are equivalent:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例，相对较为详细，使用了 `const char*`（但也可以使用 `const byte*`）。它表明，在某些情况下，可以比较两个对象的字节对字节表示，以查看它们是否等效：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `has_unique_object_representations` trait is true for types uniquely defined
    by their values, that is, types exempt of padding bits.. That’s sometimes important
    as C++ does not say what happens to padding bits in an object, and performing
    a bit-per-bit comparison of two objects might yield surprising results. Note that
    objects of floating point types are not considered uniquely defined by their values
    as there are many distinct values that qualify as NaN, or “not a number”.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`has_unique_object_representations` 特性对于唯一由其值定义的类型是真实的，也就是说，免于填充位的类型。这有时很重要，因为
    C++ 没有说明对象中的填充位会发生什么，并且对两个对象进行位对位的比较可能会产生令人惊讶的结果。请注意，浮点类型的对象不被认为是唯一由其值定义的，因为有许多不同的值可以被认为是
    NaN，或“不是一个数字”。'
- en: References
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'The C++ language supports two related families of indirections: pointers and
    references. Like their cousins, the pointers, references are often mentioned by
    the C++ standard (more than 1,800 times) but it’s hard to find a formal definition
    for them.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 语言支持两个相关的间接引用家族：指针和引用。与它们的表亲指针一样，引用在 C++ 标准中经常被提及（超过 1,800 次），但很难找到它们的正式定义。
- en: 'We will try once again to provide an informal but operational definition: a
    reference can be seen as an alias for an existing entity. We deliberately did
    not use object, since one could refer to a function and we already know that a
    function is not an object.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次尝试提供一个非正式但实用的定义：引用可以被视为现有实体的别名。我们故意没有使用对象，因为可以引用函数，而且我们已经知道函数不是对象。
- en: 'Pointers are objects. As such, they occupy storage. References, on the other
    hand, are not objects and use no storage of their own, even though an implementation
    could simulate their existence with pointers. Compare `std::is_object_v<int*>`
    with `std::is_object_v<int&>`: the former is `true`, and the latter is `false`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是对象。因此，它们占用存储空间。另一方面，引用不是对象，不使用自己的存储空间，尽管实现可以用指针来模拟它们的存在。比较`std::is_object_v<int*>`与`std::is_object_v<int&>`：前者为`true`，后者为`false`。
- en: The `sizeof` operator, applied to a reference, will yield the size of what it
    refers to. Consequently, taking the address of a reference yields the address
    of what it refers to.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将`sizeof`运算符应用于引用，将返回它所引用的大小。因此，取引用的地址将返回它所引用的地址。
- en: 'In C++, a reference is always bound to an object and remains bound to that
    object until the end of the reference’s lifetime. A pointer, on the other hand,
    can point to numerous distinct objects during its lifetime, as we have seen before:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，引用始终绑定到对象，并且直到引用的生命周期结束都绑定到该对象。另一方面，指针在其生命周期内可以指向许多不同的对象，正如我们之前所看到的：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Another difference between pointers and references is that, contrary to the
    situation that prevails with pointers, there is no such thing as reference arithmetic.
    This makes references somewhat safer than pointers. There is room for both kinds
    of indirections in a program (and we will use them both in this book!), but for
    everyday programming, a good rule of thumb is to use references if possible and
    to use pointers if necessary.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 指针和引用之间的另一个区别是，与指针的情况不同，没有引用算术这样的东西。这使得引用比指针更安全。程序中可以容纳这两种类型的间接引用（我们将在本书中使用它们！），但对于日常编程，一个很好的经验法则是尽可能使用引用，必要时使用指针。
- en: Now that we have examined the representation of memory and taken a look at how
    C++ defines some fundamental ideas such as a byte, an object, a pointer, or a
    reference, we can delve a little deeper into some important defining properties
    of objects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了内存的表示，并查看C++如何定义一些基本概念，如字节、对象、指针或引用，我们可以深入探讨对象的一些重要定义属性。
- en: Understanding the fundamental properties of objects
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解对象的基本属性
- en: We saw earlier that in C++, an object has a type and an address. It also occupies
    a region of storage from the beginning of its construction to the end of its destruction.
    We will now examine these fundamental properties in more detail in order to understand
    how these properties affect the ways in which we write programs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，在C++中，一个对象有一个类型和一个地址。它从构造开始到销毁结束，占据一段存储空间。现在，我们将更详细地研究这些基本属性，以便了解这些属性如何影响我们编写程序的方式。
- en: Object lifetime
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象生命周期
- en: One of C++’s strengths, but also one reason for its relative complexity, arises
    from the control one has over the lifetime of objects. In C++, generally speaking,
    automatic objects are destructed at the end of their scope in a well-defined order.
    Static (global) objects are destructed on program termination in a somewhat well-defined
    order (in a given file, the order of destruction is clear, but it’s more complicated
    for static objects in different files). Dynamically allocated objects are destructed
    “when your program says so” (there are many nuances to this).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: C++的一个优点，但也是其相对复杂性的原因之一，来自于对对象生命周期的控制。在C++中，一般来说，自动对象在其作用域结束时按定义好的顺序被销毁。静态（全局）对象在程序终止时按某种定义好的顺序被销毁（在给定文件中，销毁顺序是清晰的，但对于不同文件中的静态对象来说更复杂）。动态分配的对象在“你的程序说的时候”被销毁（这里有很多细微差别）。
- en: 'Let’s examine some aspects of object lifetime with the following (very) simple
    program:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下（非常）简单的程序来检查对象生命周期的某些方面：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When executed, that program will print the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序执行时，将打印以下内容：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The fact that the number of constructors and destructors do not match is a sign
    that we did something wrong. More specifically, in this example, we manually created
    an object (pointed to by `p1`) with `operator new` but never manually destructed
    that object afterward.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和析构函数的数量不匹配是一个迹象，表明我们做错了什么。更具体地说，在这个例子中，我们手动使用`operator new`创建了一个对象（由`p1`指向），但之后从未手动销毁该对象。
- en: One common source of confusion for programmers unfamiliar with C++ is the distinction
    between pointer and pointee. In this program, `p0` and `p1` are both destructed
    when reaching the end of their scope (by the closing brace of the `main()` function),
    just as `xmain` will be. However, since `p0` and `p1` point to dynamically allocated
    objects, the pointees have to be explicitly destructed, something we did for `p0`
    but (deliberately, for the sake of the example) neglected to do for `p1`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉C++的程序员来说，指针和被指对象之间的区别是一个常见的混淆来源。在这个程序中，`p0`和`p1`都在到达它们的范围末尾时被销毁（由`main()`函数的闭合括号），就像`xmain`一样。然而，由于`p0`和`p1`指向动态分配的对象，被指对象必须显式地被销毁，我们为`p0`做了这件事，但（为了示例的目的，故意）没有为`p1`做。
- en: 'What happens to `p1`’s pointee then? Well, it has been manually constructed
    and has not been manually destructed. As such, it floats in memory where no one
    can access it anymore. This is what people often call a memory leak: a chunk of
    memory your program allocated but never deallocated.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`p1`的指针对象会发生什么？嗯，它已经被手动构造，但尚未手动销毁。因此，它在内存中漂浮，没有人可以再访问它。这就是人们通常所说的内存泄露：程序分配但从未释放的内存块。
- en: Worse than leaking the storage for the `X` object pointed to by `p1`, however,
    is the fact that the pointee’s destructor will never be called, which can cause
    all sorts of resource leaks (files not closed, database connections not closed,
    system handles not released, and so on). In [*Chapter 4*](B21071_04.xhtml#_idTextAnchor062),
    *Using Destructors*, we will examine how it is possible to avoid such situations
    and write clean, simple code at the same time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，比泄露由`p1`指向的`X`对象的存储空间更糟糕的是，被指向对象的析构函数永远不会被调用，这可能导致各种资源泄露（文件未关闭、数据库连接未关闭、系统句柄未释放等）。在[*第4章*](B21071_04.xhtml#_idTextAnchor062)《使用析构函数》中，我们将探讨如何避免这种情况，并同时编写干净、简单的代码。
- en: Object size, alignment, and padding
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象大小、对齐和填充
- en: 'Since each object occupies storage, the space associated with an object is
    an important (if low-level) property of C++ types. For example, look at the following
    code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个对象都占用存储空间，与对象关联的空间是C++类型的一个重要（如果说是低级）属性。例如，看看以下代码：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In that example, trying to define the `D` class would not compile. This is because
    in order to create a `D` object, the compiler needs to reserve enough space for
    a `D` object, but a `D` object is also a `B` object, and as such we cannot know
    the size of a `D` object without knowing the size of a `B` object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，尝试定义`D`类将无法编译。这是因为为了创建一个`D`对象，编译器需要为`D`对象预留足够的空间，但`D`对象也是一个`B`对象，因此我们不知道`D`对象的大小，除非我们知道`B`对象的大小。
- en: 'The size of an object or, equivalently, of a type can be obtained through the
    `sizeof` operator. This operator yields a compile-time, non-zero unsigned integral
    value corresponding to the number of bytes required to store an object:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象的大小，或者说一个类型的大小，可以通过`sizeof`运算符获得。这个运算符产生一个编译时非零无符号整数值，对应存储对象所需的字节数：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, the `Tiny` class is empty because it has no data member.
    A class could have member functions and still be empty. Empty classes that expose
    member functions are very commonly used in C++.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`Tiny`类是空的，因为它没有数据成员。一个类可以具有成员函数，但仍然是空的。在C++中，暴露成员函数的空类非常常见。
- en: A C++ object always occupies at least one byte of storage, even in the case
    of empty classes such as `Tiny`. That’s because if an object’s size was zero,
    that object could be at the same memory location as its immediate neighbor, which
    would be somewhat hard to reason about.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: C++对象总是至少占用一个字节的存储空间，即使在像`Tiny`这样的空类的情况下也是如此。这是因为如果对象的大小为零，那么该对象可以与它的直接邻居位于相同的内存位置，这会很难理解。
- en: 'C++ differs from many other languages in that it does not standardize the size
    of all fundamental types. For example, `sizeof(int)` can yield different values
    depending on the compiler and platform. Still, there are rules concerning the
    size of objects:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: C++与许多其他语言不同，它没有标准化所有基本类型的大小。例如，`sizeof(int)`的值可能因编译器和平台而异。尽管如此，关于对象大小的规则仍然存在：
- en: The size reported by operator `sizeof` for objects of type `signed char`, `unsigned
    char` and `char` is 1, and the same goes for `sizeof(std::byte)` as each of these
    types can be used to represent a single byte.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符 `sizeof` 报告的类型为 `signed char`、`unsigned char` 和 `char` 的对象的大小是 1，同样 `sizeof(std::byte)`
    也是如此，因为这些类型都可以用来表示一个字节。
- en: Expressions `sizeof(short)>=sizeof(char)` and `sizeof(int)>=sizeof(short)` will
    hold on all platforms, which means that there might be cases where `sizeof(char)`
    and `sizeof(int)` are both 1\. In terms of width (i.e., bits used in the value
    representation) of fundamental types, the C++ standard limits itself to stating
    the minimum width for each type. The list can be found at [[wg21.link/tab:basic.fundamental.width](http://wg21.link/tab:basic.fundamental.width)].
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式 `sizeof(short)>=sizeof(char)` 和 `sizeof(int)>=sizeof(short)` 在所有平台上都成立，这意味着可能存在
    `sizeof(char)` 和 `sizeof(int)` 都为 1 的情况。在基本类型宽度的方面（即值表示中使用的位数），C++ 标准仅限于声明每种类型的最低宽度。该列表可以在
    [[wg21.link/tab:basic.fundamental.width](http://wg21.link/tab:basic.fundamental.width)]
    找到。
- en: As we have already said, expression `sizeof(T)>0` holds for any type `T`. In
    C++, there are no zero-sized objects, not even objects of empty classes.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，表达式 `sizeof(T)>0` 对任何类型 `T` 都成立。在 C++ 中，没有零大小的对象，即使是空类也没有。
- en: The size occupied by an object of any `struct` or `class` cannot be less than
    the sum of the size of its data members (but there are caveats).
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何 `struct` 或 `class` 类型的对象占用的空间不能小于其数据成员的大小之和（但有一些例外）。
- en: 'This last rule deserves an explanation. Consider the following situation:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一条规则值得解释。考虑以下情况：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The line marked `<-- here` might be intriguing. Why would `sizeof(Y)` be equal
    to `sizeof(X)` if every `Y` object contains an `X` object? Remember that `sizeof(X)`
    is greater than `0` even though `X` is an empty class because every C++ object
    has to occupy at least one byte of storage. However, in the case of `Y`, which
    is not an empty class, each `Y` object already occupies storage due to its `x`
    data member. There’s no reason to somewhat artificially add storage space to objects
    of that type.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为 `<-- here` 的行可能很有趣。为什么如果每个 `Y` 对象都包含一个 `X` 对象，`sizeof(Y)` 会等于 `sizeof(X)`？记住，即使
    `X` 是一个空类，`sizeof(X)` 仍然大于 `0`，因为每个 C++ 对象都必须至少占用一个字节的存储空间。然而，在 `Y` 的情况下，它不是一个空类，每个
    `Y` 对象由于其 `x` 数据成员已经占用了存储空间。没有必要为这种类型的对象人为地增加存储空间。
- en: 'Now, consider this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑这一点：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The same reasoning applies again: an object of type `X` occupies the same amount
    of storage space as its only data member (of type `char`), and an object of type
    `Y` occupies the same amount of storage space as its only data member (of type
    `X`).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的推理再次适用：类型为 `X` 的对象占用的存储空间与其唯一的数据成员（类型为 `char`）相同，类型为 `Y` 的对象占用的存储空间与其唯一的数据成员（类型为
    `X`）相同。
- en: 'Continuing this exploration, consider this :'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 继续这一探索，考虑这一点：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is the rule we mentioned earlier but expressed formally for a specific
    type. In this situation, supposing that `sizeof(X)`being equal to `1` is highly
    probable, one could even reasonably expect that `sizeof(Y)`would be equal to the
    sum of`sizeof(char)`and `sizeof(X)`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前提到的规则，但以正式的方式针对特定类型进行了表达。在这种情况下，假设 `sizeof(X)` 等于 `1` 是高度可能的，甚至可以合理地预期 `sizeof(Y)`
    将等于 `sizeof(char)` 和 `sizeof(X)` 的总和。
- en: 'Finally, consider this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，考虑这一点：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We moved from having an object of class `X` being a data member of `Y` to `X`
    being a base class of `Y`. This has an interesting consequence: since the base
    class `X` is empty, and since we know from definition that objects of the derived
    class `Y` will occupy at least one byte of storage, the base class can be flattened
    into the derived class for `Y` objects. This is a useful optimization called the
    **empty base optimization**. You can reasonably expect compilers to perform this
    optimization in practice, at least in the case of single inheritance relationships.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `X` 类型的对象作为 `Y` 类型的数据成员，转变为 `X` 成为 `Y` 的基类。这有一个有趣的结果：由于基类 `X` 是空的，并且根据定义我们知道派生类
    `Y` 的对象将至少占用一个字节的存储空间，因此可以将基类 `X` 融合到派生类 `Y` 中。这是一种有用的优化，称为 **空基优化**。你可以合理地预期编译器在实际中会执行这种优化，至少在单继承关系中是这样。
- en: Note that since the presence of an `X` in a `Y` is an implementation detail,
    not something that participates in the interface of class `Y`, we used private
    inheritance in this example. The empty base optimization would apply with public
    or protected inheritance too, but in this case, private inheritance preserves
    the fact that the `X` part of a `Y` is something that only the `Y` knows about.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`X`在`Y`中的存在是一个实现细节，而不是参与类`Y`接口的东西，所以我们在这个例子中使用了私有继承。空基优化在公共或保护继承中同样适用，但在这个情况下，私有继承保留了`Y`的`X`部分是只有`Y`知道的事实。
- en: 'Since C++20, if you think composition would be more appropriate than inheritance
    to describe the relation between two classes such as `X` and `Y`, you can mark
    a data member as `[[no_unique_address]]` to inform the compiler that this member,
    if it is an object of an empty class, does not have to occupy storage within the
    enclosing object. Compilers are not forced to comply, since attributes can be
    ignored, so make sure to verify that your chosen compilers implement this before
    writing code that relies on this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++20以来，如果你认为组合比继承更适合描述类`X`和`Y`等两个类之间的关系，你可以将数据成员标记为`[[no_unique_address]]`，以通知编译器，如果这个成员是一个空类对象，它不需要在封装对象内占用存储空间。编译器不必强制遵守，因为属性可以被忽略，所以请确保在编写依赖于此的代码之前，验证你选择的编译器实现了这一功能：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'All of the examples so far have been very simple, using classes with zero,
    one, or two very small data members. Code is rarely so simple. Consider the following
    program:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的所有示例都非常简单，使用了具有零、一个或两个非常小的数据成员的类。代码很少这么简单。考虑以下程序：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Supposing that the first two static assertions hold, which is probable but not
    guaranteed, we know that `sizeof(X)` will be at least `7` (the sum of the sizes
    of its data members). In practice, however, you will probably see that `sizeof(X)`
    is equal to 8\. Now, this might seem surprising at first, but it’s a logical consequence
    of something called **alignment**.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前两个静态断言成立，这是很可能的但并非保证，我们知道`sizeof(X)`至少会是`7`（其数据成员大小的总和）。然而，在实践中，你可能会看到`sizeof(X)`等于`8`。现在，这可能会让人一开始感到惊讶，但这却是被称为**对齐**的某种逻辑结果。
- en: The alignment of an object (or of its type) tells us where that object can be
    placed in memory. The `char` type has an alignment of `1`, and as such one can
    place a `char` object literally anywhere (as long as one can access that memory).
    For an alignment of `2` (which is likely for type `short`), objects can only be
    placed at addresses that are a multiple of 2\. More generally, if a type has an
    alignment of `n`, then objects of that type must be placed at an address that
    is a multiple of `n`. Note that alignment has to be a strictly positive power
    of 2; not respecting this rule incurs undefined behavior. Of course, your compiler
    will not put you in that position, but you might put yourself in such trouble
    if you’re not careful, given some of the tricks we will be using in this book.
    With great control comes great responsibility.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的对齐（或其类型的对齐）告诉我们该对象可以在内存中的哪个位置。`char`类型具有`1`的对齐，因此可以将`char`对象直接放置在任何地方（只要可以访问该内存）。对于`2`的对齐（对于`short`类型可能是这种情况），对象只能放置在地址是`2`的倍数的位置。更普遍地说，如果一个类型具有`n`的对齐，那么该类型的对象必须放置在地址是`n`的倍数的位置。请注意，对齐必须是严格正的2的幂；不遵守此规则会导致未定义行为。当然，你的编译器不会让你陷入这种境地，但如果你不小心，考虑到我们将在本书中使用的某些技巧，你可能会陷入这样的麻烦。权力越大，责任越大。
- en: 'The C++ language offers two operators related to alignment:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言提供了两个与对齐相关的运算符：
- en: The `alignof` operator, which yields the natural alignment of a type `T` or
    of an object of that type.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alignof`运算符，它返回类型`T`或该类型对象的自然对齐。'
- en: The `alignas` operator, which lets programmers impose the alignment of an object.
    This is often useful when playing tricks with memory (as we will) or when interfacing
    with exotic hardware (the term “exotic” here can be taken in a very broad sense).
    Of course, `alignas` can only reasonably increase the natural alignment of a type,
    not reduce it.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alignas`运算符，它允许程序员强制对齐对象。这在玩弄内存（正如我们将要做的那样）或与异构硬件（这里的“异构”可以非常广泛地理解）接口时非常有用。当然，`alignas`只能合理地增加类型的自然对齐，而不能减少它。'
- en: 'For some fundamental type `T`, one can expect the assertion that `sizeof(T)`
    is equal to `alignof(T)` to hold, but that assertion does not generalize to composite
    types. For example, consider the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些基本类型`T`，可以期望断言`sizeof(T)`等于`alignof(T)`成立，但这个断言并不适用于复合类型。例如，考虑以下情况：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Generally speaking, for a composite type, the alignment will correspond to the
    worst alignment of its data members. Here, “worst” means “biggest.” For class
    `X`, the worst-aligned data member is `n` of type `int` and as such, `X` objects
    will be aligned on boundaries of `alignof(int)` bytes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，对于复合类型，对齐将对应其数据成员的最坏对齐。在这里，“最坏”意味着“最大”。对于类`X`，最坏对齐的数据成员是`n`类型的`int`，因此，`X`对象将对齐在`alignof(int)`字节边界上。
- en: 'You might wonder now why we can expect the assertion that `sizeof(X)` is equal
    to `8` to hold if `sizeof(short)==2` and `sizeof(int)==4`. Let’s look at the probable
    layout for objects of the `X` type:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能想知道，如果`sizeof(short)==2`和`sizeof(int)==4`，我们为什么可以期望断言`sizeof(X)`等于`8`成立。让我们看看`X`类型对象的可能布局：
- en: '![Figure 1.1 – Compact layout of an object of type X in memory](img/B21071_01_01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 内存中类型X对象的紧凑布局](img/B21071_01_01.jpg)'
- en: Figure 1.1 – Compact layout of an object of type X in memory
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 内存中类型X对象的紧凑布局
- en: Each box in this figure is a byte in memory. As we can see, there’s a `?` between
    `c` and the first byte of `s`. That comes from alignment. If `alignof(short)==2`
    and `alignof(int)==4`, then the only correct layout for an `X` object places its
    `n` member at a boundary of `4`. This means that there will be a padding byte
    (a byte that does not participate in the value representation of `X`) between
    `c` and `s` to align `s` on a two-byte boundary and to align `n` on a four-byte
    boundary.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的每个方框都是内存中的一个字节。正如我们所见，`c`和`s`的第一个字节之间有一个`?`。这来自于对齐。如果`alignof(short)==2`和`alignof(int)==4`，那么`X`对象的唯一正确布局是将其`n`成员放置在`4`字节边界上。这意味着在`c`和`s`之间将有一个填充字节（一个不参与`X`值表示的字节）来对齐`s`在两个字节边界上，并将`n`对齐在四个字节边界上。
- en: 'What might seem more surprising is that the order in which data members are
    laid out in a class impacts the size of the objects of that class. For example,
    consider the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更令人惊讶的是，在类中数据成员的布局顺序会影响该类对象的大小。例如，考虑以下情况：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That often surprises people, but it’s true, and something to think about. With
    this example, the probable layout for an `X` object would be as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常会让人们感到惊讶，但这是真的，值得思考。通过这个例子，`X`对象的可能布局如下：
- en: '![Figure 1.2 – Less compact layout for an object of type X in memory](img/B21071_01_02.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 内存中类型X对象的非紧凑布局](img/B21071_01_02.jpg)'
- en: Figure 1.2 – Less compact layout for an object of type X in memory
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 内存中类型X对象的非紧凑布局
- en: By now, the two `?` “squares” between `s` and `n` are probably clear, but the
    three trailing `?` “squares” might seem surprising. After all, why add padding
    at the end of an object?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，`s`和`n`之间的两个`?`“方块”可能已经很清楚，但三个尾随的`?`“方块”可能看起来有些令人惊讶。毕竟，为什么在对象的末尾添加填充？
- en: The answer is *because of arrays*. As we will soon discuss, elements of an array
    are contiguous in memory, and for that reason, it is important that each element
    of an array is properly aligned. In a case such as this, the trailing padding
    bytes in an object of class `X` ensure that if an element in an array of `X` objects
    is properly aligned, then the next element will be properly aligned too.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是**由于数组**。正如我们很快将要讨论的，数组的元素在内存中是连续的，因此，确保数组的每个元素都正确对齐是很重要的。在这种情况下，类`X`对象尾部的填充字节确保如果`X`对象数组中的某个元素被正确对齐，那么下一个元素也将被正确对齐。
- en: Now that you know about alignment, consider that just changing the order of
    elements from one version of class `X` to another resulted in a memory consumption
    increase of 50% for each object of that type. That hurts your program’s memory
    space consumption and its speed all at once. C++ compilers cannot reorder your
    data members for you, as your code sees the addresses of objects. Changing the
    relative position of data members could break users’ code, so it’s up to programmers
    to be careful with their chosen layouts. Note that keeping objects small is not
    the only factor that can influence the choice of layout in an object, especially
    in multithreaded code (where sometimes keeping two objects at a distance from
    one another can lead to better cache usage), so one should remember that layout
    is important, but not something to take on naïvely.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了对齐，考虑一下，仅仅改变类`X`的一个版本到另一个版本中元素顺序，就导致该类型每个对象的内存消耗增加了50%。这同时损害了你的程序内存空间消耗和速度。C++编译器不能为你重新排序数据成员，因为你的代码看到了对象的地址。改变数据成员的相对位置可能会破坏用户的代码，因此程序员需要小心选择他们的布局。请注意，保持对象小并不是影响对象布局选择的唯一因素，特别是在多线程代码中（有时将两个对象彼此隔开可以导致更好的缓存使用），因此应该记住布局很重要，但不是一件可以天真对待的事情。
- en: Copy and movement
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拷贝和移动
- en: At this point, we need to say a few words about copy and movement, two fundamental
    considerations in a language such as C++ where there are actual objects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要对拷贝和移动这两个在像C++这样的有实际对象的语言中的基本考虑因素说几句话。
- en: 'The C++ language considers six member functions as special. These functions
    will be automatically generated for your types unless you take steps to prevent
    it. These are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言认为六个成员函数是特殊的。除非你采取措施防止它，否则这些函数将自动为你生成。这些如下：
- en: '**The default constructor**: It’s probably the least special of all six, as
    it’s only implicitly generated if you write no constructor of your own.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认构造函数**：可能是六个中最不特殊的一个，因为它只有在你没有编写自己的构造函数时才会隐式生成。'
- en: '**The destructor**: This is called at the end of an object’s lifetime.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**析构函数**：在对象的生命周期结束时被调用。'
- en: '**The copy constructor**: It is called when constructing an object with a single
    object of the same type as argument.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拷贝构造函数**：当使用与同一类型的单个对象作为参数来构造对象时被调用。'
- en: '**The copy assignment**: It is called when replacing the contents of an existing
    object with a copy of the contents of another object.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拷贝赋值操作**：当用另一个对象的副本替换现有对象的内容时会被调用。'
- en: '`std::move()`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::move()`.'
- en: '**The move assignment**: It behaves like copy assignment but is applied when
    the argument passed to the assignment operator is something one can move from.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动赋值操作**：它的行为类似于拷贝赋值，但应用于当传递给赋值运算符的参数是可以移动的时候。'
- en: 'When a type does not explicitly manage any resources on its own, one can usually
    write none of these special functions, as the ones generated by the compiler will
    be exactly what one wants. For example, consider the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类型没有在其自身上显式管理任何资源时，通常可以不写这些特殊函数，因为编译器生成的将正好是想要的。例如，考虑以下：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, type `Point2D` represents a 2D coordinate that has no invariants (all
    values are fine for its `x` and `y` data members). Since we used default initializers
    for `x` and `y` that set these data members to 0, a default `Point2D` object will
    represent coordinate `(0,0)` and the six special member functions will behave
    as expected. The copy constructor will call the data members’ copy constructors,
    the copy assignment will call their copy assignment operators, the destructor
    will be trivial, and move operations will behave like copy operations since the
    data members are of fundamental types.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，类型`Point2D`代表一个没有不变量（`x`和`y`数据成员的所有值都是可接受的）的2D坐标。由于我们为`x`和`y`使用了默认初始化器，将这些数据成员设置为0，因此默认的`Point2D`对象将代表坐标`(0,0)`，并且六个特殊成员函数将按预期工作。拷贝构造函数将调用数据成员的拷贝构造函数，拷贝赋值将调用它们的拷贝赋值运算符，析构函数将是平凡的，并且移动操作将像拷贝操作一样行为，因为数据成员是基本类型。
- en: 'Should we decide to add a parametric constructor to explicitly let user code
    initialize the `x` and `y` data members to other values than our chosen defaults,
    we can do so. However, this will cost us our implicit default constructor:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定添加一个参数化构造函数来显式允许用户代码将`x`和`y`数据成员初始化为除我们选择的默认值之外的其他值，我们可以这样做。然而，这将使我们失去隐式默认构造函数：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can of course fix this. One way to do so is by writing the details of a
    default constructor explicitly:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以解决这个问题。一种方法是通过显式编写默认构造函数的细节：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another approach is to delegate work from the default constructor to the parametric
    constructor:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是，将默认构造函数的工作委托给参数化构造函数：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Another even better approach is to inform the compiler that we want to retain
    the default behavior even though we did something (writing another constructor)
    that would otherwise prevent it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更好的方法是通知编译器，尽管我们做了某些事情（编写另一个构造函数），否则会阻止它，但我们仍然希望保留默认行为：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The latter option will usually lead to the best generated code, as compilers
    are really good at getting maximal results from minimal effort when they understand
    the programmer’s intent. In this case, `=default` makes the intent very explicit:
    *please do what you would have done normally if my code had* *not interfered*.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 后者通常会导致生成的代码质量最好，因为当编译器理解程序员的意图时，它们在从最小的努力中获得最大结果方面非常出色。在这种情况下，`=default`使得意图非常明确：*请按照通常情况下如果我的代码没有*
    *干扰* *我会做的事情来做*。
- en: A note about these constructors
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些构造函数的说明
- en: We added parametric constructors to `Point2D` for the sake of this example,
    but it’s not necessary in this case as `Point2D` is an aggregate. These types
    have special initialization support, but that’s beside the point for our illustration.
    Aggregate types are types that comply with several restrictions (no user-declared
    or inherited constructors, no private non-static data members, no virtual bases
    classes, and so on) and that usually have no invariants to maintain, but can be
    initialized very efficiently by your compiler.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为了这个例子在`Point2D`中添加了参数化构造函数，但在这个情况下并不必要，因为`Point2D`是一个聚合类型。这些类型有特殊的初始化支持，但这并不是我们演示的重点。聚合类型是符合几个限制的类型（没有用户声明的或继承的构造函数，没有私有非静态数据成员，没有虚拟基类等），并且通常没有需要维护的不变量，但可以非常高效地由编译器初始化。
- en: 'When a class explicitly manages resources, the default-generated special functions
    rarely do what we would want. Indeed, how could the compiler know about our intents
    in such a situation? Suppose we make a naïve `string`-like class of our own, starting
    with the following (incomplete) excerpt:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类显式管理资源时，默认生成的特殊函数很少做我们想要的事情。实际上，编译器在这种情况下如何知道我们的意图呢？假设我们创建了一个类似`string`的简单类，从以下（不完整）的摘录开始：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Naïve as it is, this class clearly does explicit resource allocation by allocating
    a chunk of `size()+1` bytes to hold a copy of the sequence of characters starting
    at `p`. For that reason, the compiler-provided special member functions will not
    do the right thing for our class. For example, the default-generated copy constructor
    will copy pointer `p`, but that means we will have two pointers (the original
    `p` and `p` in the copy) sharing a common pointee, which is probably not what
    we want. The default-generated destructor will destroy the pointer, but we also
    want to deallocate the pointee and avoid a memory leak, and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个类很简单，但它显然通过分配一个`size()+1`字节的块来显式地分配资源，以存储从`p`开始的字符序列的副本。因此，编译器提供的特殊成员函数不会为我们这个类做正确的事情。例如，默认生成的复制构造函数会复制指针`p`，但这意味着我们将有两个指针（原始的`p`和副本中的`p`）共享一个共同的指向，这可能不是我们想要的。默认生成的析构函数会销毁指针，但我们还希望释放指向的资源，避免内存泄漏，等等。
- en: In a case such as this, we want to implement the so-called rule of three and
    code the destructor as well as the two copy operations (the copy constructor and
    the copy assignment). Before the arrival of move semantics in C++11, that was
    sufficient to properly implement resource management for our types. It technically
    still is today but considering move semantics too will help us get a more efficient
    type in many ways. In contemporary code, when discussing code that implements
    the two move operations in addition to the rule of three, we typically speak of
    the rule of five.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望实现所谓的“三法则”，并编码析构函数以及两个复制操作（复制构造函数和复制赋值操作）。在C++11引入移动语义之前，这已经足够正确地实现我们类型资源管理了。从技术上讲，现在仍然是这样的，但考虑到移动语义将帮助我们以多种方式获得更有效的类型。在当代代码中，当讨论实现“三法则”以及两个移动操作（除了“三法则”）的代码时，我们通常称之为“五法则”。
- en: Destruction
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 析构
- en: 'As our `naive_string` type does resource management with the dynamically allocated
    array pointed to by `p`, the destructor for that class will be simple, as its
    role will be limited to deallocating the chunk of memory pointed to by `p`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`naive_string`类型使用`p`所指向的动态分配数组进行资源管理，因此该类的析构函数将很简单，因为它的作用仅限于释放`p`所指向的内存块：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that there is no need to check that `p` is non-null (`delete nullptr;`
    does nothing in C++ and is inherently non-dangerous). Also note that we are using
    `delete[]`, not `delete`, as we allocated the chunk of memory with `new[]`, not
    `new`. The nuances between these operations will be explained in [*Chapter 7*](B21071_07.xhtml#_idTextAnchor116).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有必要检查`p`是否非空（在C++中，`delete nullptr;`什么也不做，并且本质上是无害的）。另外，请注意我们使用的是`delete[]`而不是`delete`，因为我们使用`new[]`而不是`new`来分配内存块。这些操作之间的细微差别将在[*第7章*](B21071_07.xhtml#_idTextAnchor116)中解释。
- en: Copy operations
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制操作
- en: 'The copy constructor is the function called when constructing an object of
    the `naive_string` class with an argument that is another object of that class.
    For example, consider the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数是在使用另一个该类的对象作为参数构造`naive_string`类的对象时调用的函数。例如，考虑以下：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For our `naive_string` class, a correct copy constructor could be written as
    follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`naive_string`类，一个正确的复制构造函数可以写成如下：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Copy assignments could be written in numerous ways, but many of them are complicated
    or just plain dangerous. For example, consider the following example…but do not
    write your assignment operator like this!:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 复制赋值可以以多种方式编写，但其中许多都是复杂的或者直接危险。例如，考虑以下示例……但不要像这样编写你的赋值运算符！：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, this might seem reasonable (if a bit long-winded), but if we look at the
    line where memory allocation is performed, one has to wonder: what will happen
    if this fails? Indeed it could. For example, it might fail if the process is running
    low on available memory and `other.size()` is too much for whatever resources
    are left. In C++, by default, allocation with `operator new` throws an exception
    on failure. This would complete the execution of our copy assignment function,
    leaving `*this` in an incorrect (and dangerous!) state whereby `p` is non-null
    and `nelems` is non-zero but `p` points to what most would call garbage: memory
    we do not own and whose contents would lead to undefined behavior if used.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这看起来可能合理（如果有点冗长），但如果我们看看执行内存分配的行，我们不禁要问：如果失败了会怎样？确实可能会。例如，如果进程正在耗尽可用内存，而`other.size()`对于剩余的资源来说太大，它可能会失败。在C++中，默认情况下，使用`operator
    new`在失败时抛出异常。这将完成复制赋值函数的执行，使`*this`处于一个不正确（并且危险！）的状态，其中`p`非空且`nelems`非零，但`p`指向的内存大多数情况下被认为是垃圾：我们不再拥有的内存，如果使用其内容会导致未定义的行为。
- en: 'We could claim that we can do better and write even more code trying to fix
    this bug. The recommendation to avoid writing your copy assignment operators like
    this holds also in this case:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声称我们可以做得更好，并编写更多的代码来尝试修复这个错误。避免以这种方式编写复制赋值运算符的建议也适用于这种情况：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This looks safer on the surface, as we do not try to clean up the existing
    state of `*this` until we are sure that the allocation has worked. It might even
    pass most of your tests – until someone crafts the following test:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看这似乎更安全，因为我们不会尝试清理`*this`的现有状态，直到我们确定分配已经成功。它甚至可能通过大多数测试——直到有人构建以下测试：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With this use case, our copy assignment will behave very badly. After allocating
    a properly sized chunk of memory pointed to by `q`, it will delete what `p` points
    to. Unfortunately, this also happens to be what `other.p` points to, destroying
    the actual source data we are aiming to copy from. What follows that step reads
    from memory we do not own anymore, and the program stops making sense.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个用例中，我们的复制赋值操作将表现得非常糟糕。在为`q`分配了适当大小的内存块之后，它将删除`p`所指向的内容。不幸的是，这也正是`other.p`所指向的内容，破坏了我们试图从其复制的实际源数据。接下来的步骤将从我们不再拥有的内存中读取，程序将变得没有意义。
- en: 'We can still try to patch this, and even make it work, but beware:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以尝试修复这个问题，甚至让它工作，但请注意：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This fix is a pessimization, since we will be making every copy assignment call
    pay for that `if` branch that, in practice, should almost never be used. Brute-force
    problem-solving led us to complicated code that works (though it’s not necessarily
    self-evident) and that will need to be reconsidered with every resource-managing
    class we write.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修复是一个pessimization，因为我们将使每个复制赋值调用都为实际上几乎从未使用过的`if`分支付费。 brute-force问题解决方法使我们编写了复杂的代码，尽管它工作得很好（尽管它不一定显而易见），并且我们需要在编写每个资源管理类时重新考虑它。
- en: About the word pessimization
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 关于词语pessimization
- en: 'The word *pessimization* is generally used as the opposite of *optimization*,
    referring to a programming maneuver or technique that makes program behavior less
    efficient than it should be. The preceding case is a well-known example of such
    a maneuver: everyone will pay for the potential branch introduced by the `if`
    statement even though it’s only required for rare and degenerate cases – things
    that should not happen.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 词语*pessimization*通常用作*optimization*的反义词，指的是一种编程策略或技术，使得程序行为不如应有的效率。前面的例子是这种策略的一个著名例子：每个人都会为`if`语句引入的潜在分支付费，即使它只为罕见和异常情况所必需——这些情况本不应该发生。
- en: When faced with a “pessimization” opportunity, it’s often worth it to take a
    step back and reconsider. Maybe we’ve been taking the wrong angle when approaching
    the problem.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 面对一个“pessimization”机会时，后退一步重新考虑通常是值得的。也许我们在处理问题时采取了错误的角度。
- en: 'Luckily, there is a well-known idiom in C++ called the **safe assignment idiom**,
    colloquially known as copy-and-swap. The trick is to recognize that the assignment
    is made of two parts: a destructive part that cleans up the existing state owned
    by the destination object (the left side of the assignment) and a constructive
    part that copies the state from a source object (right side of the assignment)
    to the destination object. The destructive part is generally equivalent to the
    code found in the type’s destructor, and the constructive part is generally equivalent
    to the code found in the type’s copy constructor.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C++中有一个著名的习语，称为**安全赋值习语**，口语上称为复制-交换。技巧在于认识到赋值由两部分组成：一个破坏性部分，它清理目标对象拥有的现有状态（赋值的左侧），以及一个构建性部分，它从源对象复制状态到目标对象（赋值的右侧）。破坏性部分通常等同于类型析构器中的代码，而构建性部分通常等同于类型复制构造器中的代码。
- en: 'The informal copy-and-swap name for that technique comes from the fact that
    it is usually implemented through a combination of the type’s copy constructor,
    its destructor, and a `swap()` member function that swaps member variables one
    by one:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的非正式复制-交换名称来源于它通常是通过类型复制构造器、析构器和`swap()`成员函数的组合来实现的，该函数逐个交换成员变量：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That idiom is extremely useful to know and use as it’s exception-safe, simple,
    and works for almost all types. The line that does all the work performs three
    steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个习语非常实用，值得了解和使用，因为它具有异常安全性、简单性，并且适用于几乎所有的类型。执行所有工作的那一行执行了三个步骤：
- en: First, it constructs an anonymous copy of `other` using that type’s copy constructor.
    Now, that might fail if an exception is thrown, but if it does, `*this` has not
    been modified and thus remains uncorrupted.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它使用该类型的复制构造器构建`other`的匿名副本。现在，如果抛出异常，这可能会失败，但如果真的发生了，`*this`没有被修改，因此保持未损坏。
- en: Second, it swaps that anonymous temporary’s contents (holding what we want to
    put in `*this`) with the destination object’s contents (putting the now-unneeded
    state in that anonymous temporary object).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，它交换了那个匿名临时变量的内容（包含我们要放入`*this`中的内容）与目标对象的内容（将现在不再需要的状态放入那个匿名临时对象中）。
- en: Finally, the anonymous temporary object is destroyed at the end of the expression
    (being anonymous), leaving `*this` holding a copy of the state of `other`.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在表达式的末尾销毁匿名临时对象（因为它是匿名的），留下`*this`持有`other`的状态副本。
- en: This idiom even works safely for self-assignment. It incurs an unneeded copy,
    but it trades an `if` branch that every call would have paid but almost none would
    have benefitted from for a copy that will rarely be useless.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个习语甚至可以安全地用于自我赋值。它会产生不必要的复制，但它将每个调用都会支付但几乎没有人从中受益的`if`分支，与很少会无用的复制进行了交易。
- en: You might notice `noexcept` preceding the opening brace of the `swap()` member
    function. We will return to this later, but for now, the important point is that
    we can claim that this function (swapping objects of fundamental types as it does)
    will never throw an exception. This information will help us achieve some precious
    optimizations later in this book.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到`swap()`成员函数开头的大括号前的`noexcept`。我们稍后会回到这个问题，但就目前而言，重要的观点是我们可以声称这个函数（因为它操作的是基本类型的对象）永远不会抛出异常。这个信息将帮助我们在这本书的后面部分实现一些宝贵的优化。
- en: Move operations
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动操作
- en: Our `naive_string`, which is augmented by its destructor, copy constructor,
    and copy assignment member functions, now manages resources appropriately. It
    could, however, be made faster, and sometimes even safer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过其析构函数、复制构造函数和复制赋值成员函数增强的`naive_string`现在适当地管理资源。然而，它可以变得更快，有时甚至更安全。
- en: 'Consider the following non-member string concatenation operator that someone
    could want to add to complement our class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下某人可能想要添加到我们的类中以补充的非成员字符串连接运算符：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'An operation like this could be used in user code such as the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的操作可以用在以下用户代码中：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The expression that follows the `return` statement first performs a call to
    `operator+()` and creates an unnamed `naive_string` object from the concatenation
    of `s0` and `name`. Then, that unnamed object is passed as the first argument
    to another call to `operator+()` that yields another unnamed object created from
    the concatenation of the first unnamed object and `s1`. With our current implementation,
    each unnamed object incurs an allocation, a copy of the data held in its buffer,
    a destruction, and more. It’s more costly than it looks at first glance and is
    made even worse by the fact that each allocation could throw an exception.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`return`语句之后的表达式首先调用`operator+()`，并从`s0`和`name`的连接中创建一个未命名的`naive_string`对象。然后，这个未命名的对象作为另一个调用`operator+()`的第一个参数传递，该调用从第一个未命名的对象和`s1`的连接中创建另一个未命名的对象。根据我们当前的实施，每个未命名的对象都会产生分配、其缓冲区中数据的复制、销毁以及更多操作。这比乍一看要昂贵，而且由于每个分配都可能抛出异常，所以情况变得更糟。
- en: Still, it works.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，它仍然有效。
- en: 'Since C++11, we can make such code significantly more efficient through move
    semantics. In addition to the traditional rule of three functions we just discussed,
    one can augment a class such as `naive_string` with a move constructor and a move
    assignment operator. These will kick in implicitly when the compiler operates
    on objects it knows will not be used anymore. Consider the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++11以来，我们可以通过移动语义使此类代码的效率显著提高。除了我们刚才讨论的传统三法则函数之外，我们还可以通过添加移动构造函数和移动赋值运算符来增强像`naive_string`这样的类。当编译器操作它知道将不再使用的对象时，这些操作会隐式地启动。考虑以下内容：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This translates to the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以翻译为以下内容：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It then translates to the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它翻译为以下内容：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When one thinks about it, the reason for copy operations is to keep the source
    object intact in case we need it later. Temporary objects that have no name do
    not need to be preserved from further modifications as they cannot be referred
    to later. For that reason, we can be more aggressive with these and essentially
    move their contents instead of copying them. The rule we are asked to follow by
    the standard is to leave the moved-from object in a valid-yet-indeterminate state.
    Essentially, the moved-from object has to be in such a state that it can be safely
    destroyed or assigned to, and its invariants should still hold. In practice, that
    often amounts to leaving the moved-from object in something equivalent to its
    default state.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们仔细思考时，复制操作的原因是为了在需要时保持源对象完整。没有名称的临时对象不需要从进一步的修改中保留，因为它们以后无法被引用。因此，我们可以对这些操作更加激进，实际上是将它们的内容移动而不是复制。标准要求我们遵循的规则是，将移动后的对象留在有效但不确定的状态。本质上，移动后的对象必须处于一种可以安全销毁或赋值的状态，并且其不变性仍然保持。在实践中，这通常意味着将移动后的对象留在类似于其默认状态的东西。
- en: 'For our `naive_string` type, a move constructor could look like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`naive_string`类型，移动构造函数可能看起来像这样：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The calls to `std::move()` in this specific case could be avoided (moving objects
    of fundamental types is equivalent to copying them), but it’s probably more hygienic
    to make sure that the intent to move those objects is inscribed explicitly in
    the source code. We’ll look cursorily at `std::move()` later in this section,
    but the important thing to remember is that `std::move()` does not move anything.
    It marks an object as movable in the eyes of the compiler. In other words, *it’s*
    *a cast*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定情况下，可以避免调用 `std::move()`（移动基本类型对象等同于复制它们），但可能更卫生的做法是确保在源代码中明确表达移动这些对象的意图。我们将在本节稍后简要地看看
    `std::move()`，但重要的是要记住，`std::move()` 并不移动任何东西。它只是向编译器标记一个对象是可移动的。换句话说，*它* *是一个类型转换*。
- en: 'The important things to note with our move constructor are as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的移动构造函数，需要注意的重要事项如下：
- en: The argument is of type `naive_string&&`. This means it is a reference to an
    `rvalue`, with `rvalue` itself informally meaning “something one could find on
    the right side of an assignment operator.”
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数的类型是 `naive_string&&`。这意味着它是一个对 `rvalue` 的引用，其中 `rvalue` 非正式地意味着“可以在赋值运算符的右侧找到的东西。”
- en: Like `swap()`, it is marked `noexcept` to express the fact that no exception
    will be thrown during its execution.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `swap()` 一样，它被标记为 `noexcept`，以表达在执行过程中不会抛出异常的事实。
- en: It’s effectively transferring state from the source object, `other`, to the
    object under construction, `*this`. After the completion of this transfer, we
    leave `other` in a valid state (equivalent to what we would have with a default
    `naive_string` object), respecting the standard’s recommendation.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这实际上是将状态从源对象 `other` 转移到正在构建的对象 `*this`。在完成这次转移后，我们将 `other` 留在有效状态（相当于默认的 `naive_string`
    对象），遵循标准的建议。
- en: 'One could write this function in a slightly terser manner with a small but
    quite useful function found in the `<utility>` header and named `std::exchange()`.
    Indeed, consider the following expression:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一个在 `<utility>` 头文件中找到的名为 `std::exchange()` 的小巧但非常有用的函数，以稍微简略的方式编写这个函数。确实，考虑以下表达式：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This expression means “assign to `a` the value of `b` but replace the value
    of `b` with the value of `c`.” This is a very common sequence of operations in
    real code. With this function, our move constructor becomes the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式意味着“将 `b` 的值赋给 `a`，但将 `b` 的值替换为 `c` 的值。”这在实际代码中是一个非常常见的操作序列。使用这个函数，我们的移动构造函数变成了以下形式：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That form is idiomatic C++ and can lead to some interesting optimizations in
    some circumstances.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式是典型的 C++ 代码，在某些情况下可能导致一些有趣的优化。
- en: 'What about the move assignment? Well, we can take note of the idiomatic copy
    assignment we discussed at some length earlier and express it as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，移动赋值又如何呢？嗯，我们可以参考我们之前详细讨论过的典型复制赋值，并如下表达：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Following the path set by our copy assignment operator, we expressed the move
    assignment operator as a combination of `swap()`, a destructor, and a move constructor.
    The general logic behind both idioms is the same.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着我们的复制赋值运算符设定的路径，我们将移动赋值运算符表达为 `swap()`、析构函数和移动构造函数的组合。这两个惯用语的背后逻辑是相同的。
- en: Arrays
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: We have used arrays in our preceding examples, but we have not really provided
    a formal definition for that useful-yet-low-level construct. Note that in this
    section, the term “array” refers to raw, built-in arrays, not to other very useful
    but higher-level constructs such as `std::vector<T>` or `std::array<T,N>`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的例子中使用了数组，但并没有真正提供一个正式的定义来描述这个有用但低级的结构。注意，在本节中，“数组”一词指的是原始的内置数组，而不是其他非常有用但更高级的结构，如
    `std::vector<T>` 或 `std::array<T,N>`。
- en: 'Quite simply, in C++, an array is a contiguous sequence of elements of the
    same type. Thus, in the following excerpt, the `a0` object occupies `10*sizeof(int)`
    bytes in memory, whereas the `a1` object occupies `20*sizeof(std::string)` bytes:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，在 C++ 中，数组是相同类型元素的连续序列。因此，在以下摘录中，`a0` 对象在内存中占用 `10*sizeof(int)` 字节，而 `a1`
    对象占用 `20*sizeof(std::string)` 字节：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The number of bytes between elements at indices `i` and `i+1` in an array of
    some type `T` is precisely equal to `sizeof(T)`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个类型 `T` 的数组中，索引 `i` 和 `i+1` 之间的字节数恰好等于 `sizeof(T)`。
- en: 'Consider the following expression, which would be used in C++, as in C, for
    some array `arr`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下表达式，这在 C++ 中，就像在 C 中一样，用于某个数组 `arr`：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It evaluates to the same address as the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 它计算出的地址与以下相同：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Since pointer arithmetic is typed, the `+ i` part in this expression means “plus
    `i` elements” or “plus `i` times the size of an element in bytes.”
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于指针运算是有类型的，这个表达式中的`+ i`部分意味着“加上`i`个元素”或者“加上`i`个元素的字节大小”。
- en: 'Array sizes are positive but cannot be 0 unless the array is dynamically allocated:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的大小必须是正数，除非数组是动态分配的：
- en: '[PRE45]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Each call to `operator new[]` has to yield a different address, even if the
    array’s size is 0\. Each call technically returns the address of a different object.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`operator new[]`都必须产生不同的地址，即使数组的大小是0。每次调用在技术上都会返回不同对象的地址。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we took a look at fundamental ideas of the C++ language such
    as: what is an object? What are pointers and references? What do we mean when
    we talk about the size and alignment of an object or of a type? Why are there
    no zero-size objects in C++? What are the special members of a class and when
    do we need to write them explicitly? This non-exhaustive list of topics gave us
    a common vocabulary from which to build what you, dear reader, will find in the
    chapters to come.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了C++语言的基本概念，例如：什么是对象？指针和引用是什么？当我们谈论对象或类型的尺寸和对齐时，我们指的是什么？为什么C++中没有零大小对象？类的特殊成员是什么，我们何时需要显式地编写它们？这个非详尽的主题列表为我们提供了一个共同词汇表，从其中我们可以构建你，亲爱的读者，将在接下来的章节中找到的内容。
- en: With this, we are ready to get our hands dirty, so to speak. We have given ourselves
    a set of low-level tools and ideas from which to build higher-level abstractions,
    but we have to give ourselves some measure of discipline.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就可以动手实践了。我们已经给自己提供了一套低级工具和思想，用于构建高级抽象，但我们必须给自己一些自律。
- en: The next chapter will discuss some things we need to avoid. Those include undefined
    behavior, implementation-defined behavior (to a lesser extent), ill-formed no-diagnostic-required
    code, buffer overflows, and other unrecommendable behaviors.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论我们需要避免的一些事情。这包括未定义的行为、实现定义的行为（程度较小）、不规范的代码（不需要诊断），缓冲区溢出以及其他不推荐的行为。
- en: Then, we will follow with a chapter describing C++ casts, and how they can help
    us express clear ideas even when we feel the need to eschew some of the rules
    set out for us by the language’s type system.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将接着介绍一个章节，描述C++类型转换，以及它们如何帮助我们表达清晰的想法，即使在我们觉得需要规避语言类型系统为我们设定的某些规则时。
- en: After that, we will start to build beautiful and powerful abstractions that
    will help us with our stated goal of safely and efficiently managing resources
    in general and managing memory in particular.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将开始构建美丽而强大的抽象，这将帮助我们实现我们的目标，即安全有效地管理资源，特别是管理内存。
