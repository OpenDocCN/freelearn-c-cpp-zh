- en: Chapter 3. Memory Management and Exception Safety
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。内存管理和异常安全
- en: C++ has a great deal of compatibility with the C programming language. C++ retains
    pointers for representing and accessing specific memory addresses and provides
    manual memory management primitives via the `new` and `delete` operators. You
    can also seamlessly access from C++, the C Standard Library functions and C system
    calls or platform APIs of most major operating systems. Naturally, C++ code often
    deals with *handles* to various OS resources, like heap memory, open files, sockets,
    threads, and shared memory. Acquiring such resources and failing to release them
    could have undesirable consequences for your programs, showing up as insidious
    bugs, including memory leaks and deadlocks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C++与C编程语言有很高的兼容性。C++保留了指针来表示和访问特定的内存地址，并通过`new`和`delete`运算符提供了手动内存管理原语。您还可以无缝地从C++访问C标准库函数和大多数主要操作系统的C系统调用或平台API。自然地，C++代码经常处理对各种OS资源的*句柄*，如堆内存、打开的文件、套接字、线程和共享内存。获取这些资源并未能释放它们可能会对您的程序产生不良后果，表现为隐匿的错误，包括内存泄漏和死锁。
- en: In this chapter, we look at ways of encapsulating pointers to dynamically-allocated
    objects using **smart pointers** to ensure that they are automatically deallocated
    when they are no longer needed. We then extend these techniques to non-memory
    resources. In the process, we develop an understanding of what is meant by exception-safe
    code and use smart pointers to write such code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使用**智能指针**封装动态分配对象的指针的方法，以确保在不再需要时它们会自动释放。然后我们将这些技术扩展到非内存资源。在这个过程中，我们将理解什么是异常安全的代码，并使用智能指针来编写这样的代码。
- en: 'These topics are divided into the following sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题分为以下几个部分：
- en: Dynamic memory allocation and exception safety
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态内存分配和异常安全
- en: Smart pointers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能指针
- en: Unique ownership semantics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一所有权语义
- en: Shared ownership semantics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享所有权语义
- en: For some sections of this chapter, you will need access to a compiler with C++11
    support. This will be called out with additional instructions in individual sections.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的某些部分，您将需要使用支持C++11的编译器。这将在各个部分中附加说明。
- en: Dynamic memory allocation and exception safety
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态内存分配和异常安全
- en: Imagine that you have to write a program to rotate images. Your program takes
    the name of the file and the angle of rotation as input, reads the contents of
    the file, performs the processing, and returns the output. Here is some sample
    code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您需要编写一个程序来旋转图像。您的程序接受文件名和旋转角度作为输入，读取文件的内容，执行处理，并返回输出。以下是一些示例代码。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The actual work of rotating the image is done by an imaginary C++ API called
    `img_rotate` (line 20). The `img_rotate` function takes three parameters: the
    contents of the image as an array of bytes, the size of the array in a non-const
    reference, and the angle of rotation. It returns the contents of the rotated image
    as a dynamically-allocated byte array. The size of this array is returned via
    the reference passed as the third parameter. This is an imperfect code, more reminiscent
    of C. Code like this is surprisingly common "in the wild" and that''s why it is
    important to know its pitfalls. So, let us dissect the problem.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转图像的实际工作是由一个名为`img_rotate`的虚构的C++ API完成的（第20行）。`img_rotate`函数接受三个参数：图像内容作为字节数组，数组的大小以非const引用的形式，以及旋转角度。它返回旋转后图像的内容作为动态分配的字节数组。通过作为第三个参数传递的引用返回该数组的大小。这是一个不完美的代码，更像是C语言。这样的代码在“野外”中非常常见，这就是为什么了解它的缺陷很重要。因此，让我们来剖析一下问题。
- en: In order to read the contents of the image file, we first determine the size
    of the file (lines 12-13), and then allocate a byte array `img` just big enough
    to hold the entire data in the file (line 16). We read the image contents (line
    18), and after performing rotation of the image through a call to `img_rotate`,
    we delete the buffer `img` containing the original image (line 22). Finally, we
    return the byte array with the rotated image (line 24). For simplicity, we do
    not check for read errors (line 18).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取图像文件的内容，我们首先确定文件的大小（第12-13行），然后分配一个足够大的字节数组`img`来容纳文件中的所有数据（第16行）。我们读取图像内容（第18行），并在通过调用`img_rotate`进行图像旋转后，删除包含原始图像的缓冲区`img`（第22行）。最后，我们返回旋转后的图像的字节数组（第24行）。为简单起见，我们没有检查读取错误（第18行）。
- en: There are two glaring issues in the preceding code. If the rotation of the image
    failed (line 19) and `img_rotate` threw an exception, then the function `rotateImage`
    would return without deallocating the byte buffer `img`, which would thus be *leaked*.
    This is a definitive example of code that is not well-behaved in the face of exceptions,
    that is, it is not *exception-safe*. Moreover, even if everything went right,
    the function would return the rotated buffer (line 24), which itself was dynamically-allocated.
    So we leave its deallocation entirely at the caller's mercy with no guarantees
    whatsoever. We ought to do better.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中有两个明显的问题。如果图像旋转失败（第19行）并且`img_rotate`抛出异常，那么`rotateImage`函数将在不释放字节缓冲区`img`的情况下返回，这样就会*泄漏*。这是一个明显的例子，说明在面对异常时代码的行为不佳，也就是说，它不是*异常安全*的。此外，即使一切顺利，该函数也会返回旋转后的缓冲区（第24行），这本身是动态分配的。因此，我们完全将其释放的责任留给调用者，没有任何保证。我们应该做得更好。
- en: There is a third less obvious problem. The `img_rotate` function ought to have
    documented how it allocates memory for us to know how to free it—by calling the
    array delete (`delete []`) operator (line 22). But what if there was a more efficient
    custom memory management scheme that the developers of `img_rotate` found and
    wanted to use in the next version? They would avoid doing so; otherwise all of
    their client code would break as the `delete []` operator may no longer be the
    correct way to deallocate that memory. Ideally, this is one detail that the clients
    of the `img_rotate` API should never have had to bother about.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个不太明显的问题。 `img_rotate`函数应该已经记录了它如何分配内存，以便我们知道如何释放它——通过调用数组删除（`delete []`）运算符（第22行）。但是，如果开发`img_rotate`找到了更有效的自定义内存管理方案，并希望在下一个版本中使用呢？他们会避免这样做；否则，所有客户端代码都会中断，因为`delete
    []`运算符可能不再是正确的释放内存的方式。理想情况下，`img_rotate` API的客户端不应该为此烦恼。
- en: Exception safety and RAII
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常安全和RAII
- en: 'In the previous example, we looked informally at the concept of exception safety.
    We saw that a potential exception thrown from the `img_rotate` API could leak
    resources in the `rotateImage` function. It turns out that you can reason about
    the behavior of your code in the face of exceptions in terms of a set of criteria
    called **The Abrahams Exception Safety Guarantees**. They are named after Dave
    Abrahams, the Boost cofounder and an eminent C++ Standards Committee member, who
    formalized these guarantees in 1996\. They have since been refined further by
    others, including notably Herb Sutter, and are listed below:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们非正式地看了一下异常安全的概念。我们看到`img_rotate` API可能抛出的潜在异常可能会在`rotateImage`函数中泄漏资源。事实证明，您可以根据一组标准称为**The
    Abrahams Exception Safety Guarantees**来推断代码在面对异常时的行为。它们以Dave Abrahams的名字命名，他是Boost的联合创始人和杰出的C++标准委员会成员，他在1996年正式化了这些保证。此后，它们已经被其他人进一步完善，包括特别是Herb
    Sutter，并列在下面：
- en: '**Basic guarantee**: An operation terminated midway preserves invariants and
    does not leak resources'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本保证**：中途终止的操作保留不变，并且不会泄漏资源'
- en: '**Strong guarantee**: An operation terminated midway will not have any effect,
    that is, the operation is atomic'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强保证**：中途终止的操作不会产生任何影响，即操作是原子的'
- en: '**No-throw guarantee**: An operation that cannot fail'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无异常保证**：无法失败的操作'
- en: An operation that does not satisfy any of these criteria is said to be "not
    exception-safe" or more colloquially, exception-unsafe. The appropriate level
    of exception safety for an operation is the programmer's prerogative but exception-unsafe
    code is rarely acceptable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不满足这些标准的操作被称为“不安全的异常”或更通俗地说，不安全的异常。操作的适当异常安全级别是程序员的特权，但不安全的异常代码很少被接受。
- en: 'The most fundamental and effective C++ technique for making code exception-safe
    goes by the curious name **Resource Acquisition is Initialization** (**RAII**).
    The RAII idiom proposes the following model for encapsulating resources that require
    manual management:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 用于使代码具有异常安全性的最基本和有效的C++技术是名为**Resource Acquisition is Initialization**（**RAII**）的奇特名称。
    RAII习惯提出了封装需要手动管理的资源的以下模型：
- en: Encapsulate resource acquisition in the constructor of a wrapper object.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包装对象的构造函数中封装资源获取。
- en: Encapsulate resource release in the destructor of the wrapper object.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包装对象的析构函数中封装资源释放。
- en: Additionally, define consistent copy and move semantics for the wrapper object
    or disable them.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，为包装对象定义一致的复制和移动语义，或者禁用它们。
- en: 'If the wrapper object is created on the stack, its destructor is called for
    normal scope exit as well as exit due to exceptions. Otherwise, the wrapper object
    itself should be managed by the RAII idiom. Loosely speaking, you either create
    your objects on the stack or manage them using RAII. At this point, some examples
    are in order, and we can go straight back to the image rotation example and fix
    it using RAII:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包装对象是在堆栈上创建的，则其析构函数也会在正常范围退出以及由于异常退出时调用。否则，包装对象本身应该由RAII习惯管理。粗略地说，您可以在堆栈上创建对象，也可以使用RAII来管理它们。在这一点上，我们需要一些例子，然后我们可以直接回到图像旋转示例并使用RAII进行修复：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code is a modest attempt that makes the `rotateImage` function
    exception-safe, provided the `img_rotate` function itself is exception-safe. First
    up we define a `struct` called `ScopeGuard` (lines 1-9) for encapsulating character
    arrays allocated by the array `new operator`. It takes a pointer to an allocated
    array as its constructor argument and sets the data member `data_` to this pointer
    (line 3). Its destructor deallocates the array pointed to by its `data_` member
    using the array `delete` operator (line 4). The `get` member function (line 6)
    provides a way to get the underlying pointer from a `ScopeGuard` object.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是一个谦虚的尝试，使`rotateImage`函数在`img_rotate`函数本身是异常安全的情况下是异常安全的。首先，我们定义了一个名为`ScopeGuard`（第1-9行）的`struct`，用于封装由数组`new
    operator`分配的字符数组。它以分配的数组指针作为其构造函数参数，并将数据成员`data_`设置为该指针（第3行）。它的析构函数使用数组`delete`运算符（第4行）释放其`data_`成员指向的数组。`get`成员函数（第6行）提供了一种从`ScopeGuard`对象获取底层指针的方法。
- en: Inside the `rotateImage` function, we instantiate a `ScopeGuard` object called
    `img`, wrapping the byte array allocated using array `new` operator (line 23).
    We call `read` on the open file stream and pass to it the raw byte array obtained
    by calling the `get` method on `img` (line 25). We assume read always succeeds
    but, in production code, we should always have proper error checks in place. Finally,
    we call the `img_rotate` API and return the rotated image it returns (line 27).
    As we exit the scope, the `ScopeGuard` destructor is called and automatically
    deallocates the encapsulated byte array (line 28). Even if `img_rotate` threw
    an exception, the `ScopeGuard` destructor would still be called as part of stack
    unwinding. Through the use of RAII via the `ScopeGuard` class, we are able to
    claim that the `rotateImage` function can never leak the buffer containing the
    image data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在`rotateImage`函数内部，我们实例化了一个名为`img`的`ScopeGuard`对象，它包装了使用数组`new`运算符分配的字节数组（第23行）。我们调用打开文件流的`read`方法，并将`img`的`get`方法获取的原始字节数组传递给它（第25行）。我们假设读取总是成功的，但在生产代码中，我们应该始终进行适当的错误检查。最后，我们调用`img_rotate`
    API并返回它返回的旋转图像（第27行）。当我们退出作用域时，`ScopeGuard`析构函数被调用，并自动释放封装的字节数组（第28行）。即使`img_rotate`抛出异常，`ScopeGuard`析构函数仍将在堆栈展开的过程中被调用。通过使用`ScopeGuard`类的RAII，我们能够声明`rotateImage`函数永远不会泄漏包含图像数据的缓冲区。
- en: On the other hand, the buffer containing the rotated image returned by `rotateImage`
    *could* be leaked, unless the caller takes care to assign it to a pointer and
    then duly release it in an exception-safe way. The `ScopeGuard` class in its current
    form is no good there. It turns out that Boost ships different kinds of smart
    pointer templates to address various use cases like these, and it is worthwhile
    to understand these smart pointers and the patterns of resource acquisition, and
    the exception safety problems they help solve.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，由`rotateImage`返回的旋转图像的缓冲区*可能*会泄漏，除非调用者注意将其分配给指针，然后以异常安全的方式释放它。`ScopeGuard`类在其当前形式下并不适用。事实证明，Boost提供了不同类型的智能指针模板来解决这些问题，值得理解这些智能指针以及它们帮助解决的资源获取模式和异常安全问题。
- en: Smart pointers
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能指针
- en: A smart pointer, definitively, is a class that encapsulates access to a pointer
    and often manages memory associated with the pointer. If you paid attention, you
    would have noticed the similarity smart pointers have with pineapples—smart pointers
    are classes, not pointers, just as pineapples aren't really apples. Moving away
    from fruit analogies, different types of smart pointers often have additional
    features like bounds-checking, null-checking, and access control, among others.
    In C++, smart pointers usually overload the dereference operator (`operator->`),
    which allows any method calls invoked on the smart pointer using `operator->`
    to be bound to the underlying pointer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针，明确地说，是一个封装指针访问并经常管理与指针相关的内存的类。如果你注意到了，你会注意到智能指针与菠萝的相似之处——智能指针是类，而不是指针，就像菠萝并不是真正的苹果一样。摆脱水果类比，不同类型的智能指针通常具有额外的功能，如边界检查、空指针检查和访问控制等。在C++中，智能指针通常重载解引用运算符（`operator->`），这允许使用`operator->`在智能指针上调用的任何方法调用都绑定到底层指针上。
- en: Boost includes a set of four different smart pointers with differing semantics.
    Also, because C++ often uses pointers to identify and manipulate arrays of objects,
    Boost provides two different smart array templates that encapsulate array access
    via pointers. In the following sections, we study the different classes of smart
    pointers from Boost and their semantics. We will also look at `std::unique_ptr`,
    a C++11 smart pointer class that supersedes one of the Boost smart pointers and
    supports semantics not readily available from Boost.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Boost包括四种不同语义的智能指针。此外，由于C++经常使用指针来标识和操作对象数组，Boost提供了两种不同的智能数组模板，它们通过指针封装了数组访问。在接下来的章节中，我们将研究Boost中不同类别的智能指针及其语义。我们还将看看`std::unique_ptr`，这是一个C++11智能指针类，它取代了Boost的一个智能指针，并支持Boost中不容易获得的语义。
- en: Unique ownership semantics
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独占所有权语义
- en: 'Consider the following code snippet for instantiating an object and calling
    a method on it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段来实例化一个对象并调用其方法：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we saw in the previous section, the preceding code is not exception-safe.
    Exceptions thrown from operations after the `Widget` object is constructed on
    dynamic memory (line 7) and before the `Widget` object is destroyed (line 11),
    can cause the dynamically-allocated memory for the `Widget` object to leak. To
    fix this, we need something akin to the `ScopeGuard` class we wrote in the previous
    section, and Boost obliges with the `boost::scoped_ptr` template.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中看到的，前面的代码并不具有异常安全性。在动态内存上构造`Widget`对象（第7行）之后和销毁`Widget`对象（第11行）之前抛出的异常可能导致为`Widget`对象动态分配的内存泄漏。为了解决这个问题，我们需要类似于我们在前一节中编写的`ScopeGuard`类，而Boost则提供了`boost::scoped_ptr`模板。
- en: boost::scoped_ptr
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: boost::scoped_ptr
- en: 'Here is the preceding example fixed using `scoped_ptr`. The `scoped_ptr` template
    is available from the header file `boost/scoped_ptr.hpp`. It is a header-only
    library, and you don''t need to link your program against any other libraries:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`scoped_ptr`修复的前面的示例。`scoped_ptr`模板可以从头文件`boost/scoped_ptr.hpp`中获得。它是一个仅包含头文件的库，你不需要将你的程序链接到任何其他库：
- en: '**Listing 3.1: Using scoped_ptr**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单3.1：使用scoped_ptr**'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, `wgt` is an object of type `scoped_ptr<Widget>`, which
    is a drop-in replacement for the `Widget*` pointer. We initialize it with a dynamically-allocated
    `Widget` object (line 8) and drop the call to `delete`. These are the only two
    changes needed to make this code exception-safe.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`wgt`是`scoped_ptr<Widget>`类型的对象，它是`Widget*`指针的替代品。我们用动态分配的`Widget`对象对其进行初始化（第8行），并且省略了`delete`的调用。这是使这段代码具有异常安全性所需的唯一两个更改。
- en: Smart pointers like `scoped_ptr` and others from Boost, take care of calling
    `delete` on the encapsulated pointer in their destructor. When `useWidget` completes
    or if an exception terminates it midway, the destructor of the `scoped_ptr` instance
    `wgt` will be invoked and will destroy the `Widget` object and release its memory.
    The overloaded dereference operator (`operator->`) in `scoped_ptr` allows `Widget`
    members to be accessed via the `wgt` smart pointer (lines 9-11).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 像`scoped_ptr`和Boost中的其他智能指针一样，在它们的析构函数中调用`delete`来释放封装的指针。当`useWidget`完成或者如果异常中止它，`scoped_ptr`实例`wgt`的析构函数将被调用，并且将销毁`Widget`对象并释放其内存。`scoped_ptr`中的重载解引用运算符（`operator->`）允许通过`wgt`智能指针访问`Widget`成员（第9-11行）。
- en: The destructor of `boost::scoped_ptr` template uses `boost::checked_delete`
    to release the dynamically-allocated memory that the encapsulated pointer points
    to. Thus, the type of the object pointed to by the encapsulated pointer must be
    completely defined at the point the `boost::scoped_ptr` instance goes out of scope;
    otherwise, the code will fail to compile.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::scoped_ptr`模板的析构函数使用`boost::checked_delete`来释放封装指针指向的动态分配内存。因此，在`boost::scoped_ptr`实例超出范围时，封装指针指向的对象的类型必须在完全定义；否则，代码将无法编译。'
- en: The `boost::scoped_ptr` is the simplest of Boost's smart pointers. It takes
    ownership of the dynamically-allocated pointer passed and calls `delete` on it
    inside its own destructor. This binds the life of the underlying object to the
    scope in which the encapsulating `scoped_ptr` operates—hence, the name `scoped_ptr`.
    Essentially, it implements RAII on the encapsulated pointer. Moreover, `scoped_ptr`
    cannot be copied. This means that a dynamically-allocated object can only be wrapped
    by one `scoped_ptr` instance at any given point in time. Thus, `scoped_ptr` is
    said to exhibit *unique ownership semantics*. Note that `scoped_ptr` instances
    cannot be stored in Standard Library containers because they can neither be copied
    nor moved from in the C++11 sense.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::scoped_ptr`是Boost智能指针中最简单的一个。它接管传递的动态分配指针，并在自己的析构函数中调用`delete`。这将使底层对象的生命周期绑定到封装`scoped_ptr`操作的范围，因此称为`scoped_ptr`。本质上，它在封装的指针上实现了RAII。此外，`scoped_ptr`不能被复制。这意味着动态分配的对象在任何给定时间点只能被一个`scoped_ptr`实例包装。因此，`scoped_ptr`被认为具有*唯一所有权语义*。请注意，`scoped_ptr`实例不能存储在标准库容器中，因为它们在C++11意义上既不能被复制也不能被移动。'
- en: 'In the following example, we explore some more features of `scoped_ptr`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们探索了`scoped_ptr`的一些更多特性：
- en: '**Listing 3.2: scoped_ptr in detail**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单3.2：详细介绍scoped_ptr**'
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we first construct an object of type `scoped_ptr<Widget>` using
    its default constructor (line 9). This creates a `scoped_ptr` containing a null
    pointer. Any attempts to dereference such a smart pointer will result in undefined
    behavior typically leading to a crash. `scoped_ptr` supports implicit conversion
    to a Boolean value; so we can use a `scoped_ptr` object like `wgt` in Boolean
    contexts to check whether the encapsulated pointer is null or not. In this case,
    we know that it should be null because it is default-constructed; hence, we assert
    on `wgt` being null (line 10).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先使用默认构造函数（第9行）构造了一个`scoped_ptr<Widget>`类型的对象。这创建了一个包含空指针的`scoped_ptr`。任何尝试对这样一个智能指针进行解引用的行为都会导致未定义的行为，通常会导致崩溃。`scoped_ptr`支持隐式转换为布尔值；因此我们可以在布尔上下文中像`wgt`这样使用`scoped_ptr`对象来检查封装的指针是否为空。在这种情况下，我们知道它应该为空，因为它是默认构造的；因此，我们断言`wgt`为空（第10行）。
- en: There are two ways to change the pointer contained inside a `scoped_ptr` and
    one of them is to use the `reset` member method of `scoped_ptr`. When we call
    `reset` on a `scoped_ptr`, the encapsulated pointer is deallocated and `scoped_ptr`
    takes ownership of the newly passed pointer in its place. Thus, we can use `reset`
    to change the pointer owned by a `scoped_ptr` instance (line 12). Following this,
    `scoped_ptr` contains a non-null pointer, and we assert as much using the ability
    to implicitly convert `scoped_ptr` to a Boolean value (line 13). Next, we call
    `reset` again to store a new pointer in `wgt` (line 15). In this case, the earlier
    stored pointer is deallocated, and the underlying object is destroyed before the
    new pointer is stored.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以改变`scoped_ptr`中包含的指针，其中一种是使用`scoped_ptr`的`reset`成员方法。当我们在`scoped_ptr`上调用`reset`时，封装的指针被释放，并且`scoped_ptr`接管新传递的指针。因此，我们可以使用`reset`来改变`scoped_ptr`实例所拥有的指针（第12行）。随后，`scoped_ptr`包含一个非空指针，并且我们使用隐式转换`scoped_ptr`为布尔值的能力进行断言（第13行）。接下来，我们再次调用`reset`来在`wgt`中存储一个新的指针（第15行）。在这种情况下，先前存储的指针被释放，并且在存储新指针之前底层对象被销毁。
- en: We can get at the underlying pointer by calling the `get` member function of
    `scoped_ptr` (line 18). We can also get a reference to the object pointed to by
    the smart pointer by dereferencing the smart pointer (line 19). We assert the
    fact that this reference and the pointer returned by `get` both point to the same
    object (line 20).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`scoped_ptr`的`get`成员函数（第18行）来获取底层指针。我们还可以通过对智能指针进行解引用（第19行）来获取指向的对象的引用。我们断言这个引用和`get`返回的指针都指向同一个对象（第20行）。
- en: There is of course a second way to change the pointer contained inside a `scoped_ptr`.
    By swapping two `scoped_ptr` objects, their encapsulated pointers are swapped
    (lines 24-26). This is the only way to change the owning `scoped_ptr` of a dynamically-allocated
    object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，改变`scoped_ptr`中包含的指针的第二种方法是交换两个`scoped_ptr`对象，它们的封装指针被交换（第24-26行）。这是改变动态分配对象的拥有`scoped_ptr`的唯一方法。
- en: In summary, we can say that once you have wrapped an object in a `scoped_ptr`,
    it can never be detached from a `scoped_ptr`. The `scoped_ptr` could destroy the
    object and take on a new object (using the `reset` member function), or it could
    swap its pointer with that in another `scoped_ptr`. In that sense, `scoped_ptr`
    exhibits unique, transferrable ownership semantics.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们可以说一旦你用`scoped_ptr`包装了一个对象，它就永远不能从`scoped_ptr`中分离出来。`scoped_ptr`可以销毁对象并接管一个新对象（使用`reset`成员函数），或者它可以与另一个`scoped_ptr`中的指针交换。在这个意义上，`scoped_ptr`表现出独特的、可转移的所有权语义。
- en: Uses of scoped_ptr
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: scoped_ptr的用途
- en: '`scoped_ptr` is a lightweight and versatile smart pointer that is capable of
    more than just acting as a scope guard. Here is a look at how it can be used in
    code.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoped_ptr`是一个轻量级且多功能的智能指针，它不仅可以作为作用域保护器，还可以用于其他用途。下面是它在代码中的使用方式。'
- en: Creating exception-safe scopes
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建异常安全的作用域
- en: '`scoped_ptr` is useful in creating exception-safe scopes, when objects are
    dynamically-allocated in some scope. C++ allows objects to be created on the stack
    and often that is the route you would take to create objects instead of allocating
    them dynamically. But, in some cases, you would need to instantiate an object
    by calling factory functions that return pointers to the dynamically-allocated
    objects. This could be from some legacy library and `scoped_ptr` can be a handy
    wrapper for such pointers. In the following example, `makeWidget` is one such
    factory function that returns a dynamically-allocated `Widget`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoped_ptr`在创建异常安全的作用域时非常有用，当对象在某个作用域中动态分配。C++允许对象在堆栈上创建，通常这是你会采取的创建对象的方式，而不是动态分配它们。但是，在某些情况下，你需要通过调用返回指向动态分配对象的指针的工厂函数来实例化对象。这可能来自某个旧库，`scoped_ptr`可以成为这些指针的方便包装器。在下面的例子中，`makeWidget`就是一个这样的工厂函数，它返回一个动态分配的`Widget`：'
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In general, `useWidget` in the preceding form would be exception-safe, provided
    the function `makeWidget` called from within `useWidget` also is exception-safe.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，前面形式中的`useWidget`将是异常安全的，只要从`useWidget`中调用的`makeWidget`函数也是异常安全的。
- en: Transferring object ownership across functions
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在函数之间转移对象所有权
- en: As non-copyable objects, `scoped_ptr` objects cannot be passed or returned by
    value from functions. One may pass a non-const reference to a `scoped_ptr` as
    an argument to a function, which resets its contents and puts a new pointer into
    the `scoped_ptr` object.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为不可复制的对象，`scoped_ptr`对象不能从函数中以值传递或返回。可以将`scoped_ptr`的非const引用作为参数传递给函数，这将重置其内容并将新指针放入`scoped_ptr`对象中。
- en: '**Listing 3.3: Ownership transfer using scoped_ptr**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单3.3：使用scoped_ptr进行所有权转移**'
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `makeNewWidget` function uses the `scoped_ptr<Widget>` reference passed
    to it as an out parameter using it to return the dynamically-allocated object
    (line 5). Each call to `makeNewWidget` (line 12, 15) replaces its previous content
    with a new `Widget` object allocated dynamically and deletes the previous object.
    This is one way to transfer ownership of an object allocated dynamically inside
    a function to a scope outside the function. It is not frequently used, and there
    are more idiomatic ways of achieving the same effect in C++11 using `std::unique_ptr`,
    as discussed in the next section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeNewWidget`函数使用传递给它的`scoped_ptr<Widget>`引用作为输出参数，用它来返回动态分配的对象（第5行）。每次调用`makeNewWidget`（第12、15行）都用新的动态分配的`Widget`对象替换其先前的内容，并删除先前的对象。这是一种将在函数内动态分配的对象所有权转移到函数外作用域的方法。这种方法并不经常使用，在C++11中使用`std::unique_ptr`有更多成语化的方法来实现相同的效果，这将在下一节中讨论。'
- en: As a class member
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 作为类成员
- en: Among the smart pointers from Boost, `scoped_ptr` is often used only as a local
    scope guard in functions, when in fact, it can be a useful tool for ensuring exception
    safety as a class member as well.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Boost的智能指针中，`scoped_ptr`通常只被用作函数中的本地作用域保护，但实际上，它也可以作为类成员来确保异常安全，是一个有用的工具。
- en: Consider the following code in which the class `DatabaseHandler` creates two
    dynamically-allocated objects of the imaginary types `FileLogger` and `DBConnection`
    for logging to a file and connecting to a database. `FileLogger` and `DBConnection`
    as well as their constructor parameters are imaginary classes that are used for
    illustrative purposes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，其中类`DatabaseHandler`为了记录到文件和连接到数据库创建了两个虚构类型`FileLogger`和`DBConnection`的动态分配对象。`FileLogger`和`DBConnection`以及它们的构造函数参数都是用于说明目的的虚构类。
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code is the listing for the `DatabaseHandler` class definition
    in the header file `DatabaseHandler.h`. `FileLogger` and `DBConnection` are incomplete
    types having only been forward-declared. We only declare pointers to them, and
    since the size of pointers is not dependent on the size of the underlying types,
    the compiler does not need to know the definitions of `FileHandler` and `DBConnection`
    to determine the total size of the `DatabaseHandler` class in terms of its pointer
    constituents.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是`DatabaseHandler`类在头文件`DatabaseHandler.h`中的定义清单。`FileLogger`和`DBConnection`是不完整的类型，只被前向声明过。我们只声明了指向它们的指针，由于指针的大小不依赖于底层类型的大小，编译器不需要知道`FileHandler`和`DBConnection`的定义来确定`DatabaseHandler`类的总大小，而是以其指针成员的总大小来确定。
- en: 'There is an advantage to designing classes like this. The clients of `DatabaseHandler`
    include the `DatabaseHandler.h` file listed earlier but do not depend on the actual
    definitions of `FileLogger` or `DBConnection`. If their definitions change, the
    clients remain unaffected and do not need to recompile. This, in essence, is the
    idiom that Herb Sutter popularized as the **Pimpl Idiom**. The actual implementation
    of the class is abstracted in a separate source file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 设计类的这种方式有一个优势。`DatabaseHandler`的客户端包括前面列出的`DatabaseHandler.h`文件，但不依赖于`FileLogger`或`DBConnection`的实际定义。如果它们的定义发生变化，客户端保持不受影响，无需重新编译。这本质上就是Herb
    Sutter所推广的**Pimpl Idiom**。类的实际实现被抽象在一个单独的源文件中：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this source file, we have access to the concrete definitions of `FileLogger`
    and `DBConnection`. Even if these definitions and other parts of our implementation
    change, the clients of `DatabaseHandler` need not change or recompile as long
    as `DatabaseHandler`'s public methods and the class layout do not change.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个源文件中，我们可以访问`FileLogger`和`DBConnection`的具体定义。即使这些定义和我们的实现的其他部分发生了变化，只要`DatabaseHandler`的公共方法和类布局没有发生变化，`DatabaseHandler`的客户端就不需要改变或重新编译。
- en: But this code is very brittle and can potentially leak memory and other resources.
    Consider what happens if the `FileLogger` constructor throws an exception (line
    26). The memory allocated for the `logger_` pointer is freed automatically and
    no further damage is done. The exception propagates from the `DatabaseHandler`
    constructor to the calling context and no object of `DatabaseHandler` is instantiated;
    so far so good.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但这段代码非常脆弱，可能会泄漏内存和其他资源。考虑一下如果`FileLogger`构造函数抛出异常会发生什么（第26行）。为`logger_`指针分配的内存会自动释放，不会造成进一步的损害。异常从`DatabaseHandler`构造函数传播到调用上下文，`DatabaseHandler`的对象不会被实例化；目前为止一切都很好。
- en: Now consider if the `FileLogger` object was constructed successfully and then
    the `DBConnection` constructor threw an exception (line 27). In this case, upon
    the exception the memory allocated for the `dbconn_` pointer would be automatically
    freed, but not the memory allocated for the `logger_` pointer. When an exception
    occurs destructors of any fully constructed members of non-POD types would be
    called. But `logger_` is a raw pointer, which is a POD-type and therefore it does
    not have a destructor. Thus, the memory pointed to by `logger_` is leaked.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑如果`FileLogger`对象成功构造，然后`DBConnection`构造函数抛出异常（第27行）。在这种情况下，异常发生时为`dbconn_`指针分配的内存会自动释放，但为`logger_`指针分配的内存不会被释放。当异常发生时，任何非POD类型的完全构造成员的析构函数都会被调用。但`logger_`是一个原始指针，它是一个POD类型，因此它没有析构函数。因此，`logger_`指向的内存泄漏了。
- en: 'In general, if your class has multiple pointers pointing to dynamically-allocated
    objects, ensuring exception safety becomes a challenge, and most procedural solutions
    around using try/catch blocks scale quite badly. A smart pointer is the perfect
    ingredient to fix these kinds of problems with very little code that scales. We
    use a `scoped_ptr` below to fix the preceding example. Here is the header file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果你的类有多个指向动态分配对象的指针，确保异常安全性就变得很具挑战性，大多数围绕使用try/catch块的过程性解决方案都不太好扩展。智能指针是解决这类问题的完美工具，只需很少的代码就可以解决。我们在下面使用`scoped_ptr`来修复前面的例子。这是头文件：
- en: '**Listing 3.4: Using scoped_ptr as class members**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单3.4：将scoped_ptr用作类成员**'
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `logger_` and `dbconn_` are now `scoped_ptr` instances rather than raw
    pointers (lines 19 and 20). On the flip side, `scoped_ptr` being non-copyable,
    the compiler cannot generate the default copy constructor and copy assignment
    operator. We could either disable them like we have done here (line 22 and 23)
    or define them ourselves. In general, defining copy semantics for `scoped_ptr`
    would make sense only when the encapsulated type is copyable. On the other hand,
    move semantics might be easier to define using the `swap` member function of `scoped_ptr`.
    Let us now look at the changes to the source file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`logger_`和`dbconn_`现在是`scoped_ptr`实例，而不是原始指针（第19行和第20行）。另一方面，由于`scoped_ptr`是不可复制的，编译器无法生成默认的复制构造函数和复制赋值运算符。我们可以像这里做的那样禁用它们（第22行和第23行），或者自己定义它们。一般来说，为`scoped_ptr`定义复制语义只有在封装类型可复制时才有意义。另一方面，使用`scoped_ptr`的`swap`成员函数可能更容易定义移动语义。现在让我们看看源文件的变化：'
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We initialize the two `scoped_ptr` instances in the constructor initializer
    lists (lines 26 and 27). If the `DBConnection` constructor throws (line 27), the
    destructor of `logger_`, which is a `scoped_ptr`, is invoked, and it cleanly deallocates
    the dynamically-allocated `FileLogger` object it encapsulated.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构造函数初始化列表中初始化了两个`scoped_ptr`实例（第26行和第27行）。如果`DBConnection`构造函数抛出异常（第27行），则会调用`logger_`的析构函数，它会清理动态分配的`FileLogger`对象。
- en: The `DatabaseHandler` destructor is empty (line 31) because there are no POD-type
    members, and the destructors of the `scoped_ptr` members are automatically invoked.
    But we still have to define the destructor. Can you guess why? If we left it to
    the compiler to generate a definition, it would have generated the destructor
    definition in the scope of the class definition in the header file. In that scope,
    `FileLogger` and `DBConnection` were not completely defined, and the `scoped_ptr`
    destructors would have failed to compile, as they use `boost::checked_delete`
    ([Chapter 2](ch02.html "Chapter 2. The First Brush with Boost's Utilities"), *The
    First Brush with Boost's Utilities*)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatabaseHandler`析构函数为空（第31行），因为没有POD类型的成员，而`scoped_ptr`成员的析构函数会自动调用。但我们仍然必须定义析构函数。你能猜到为什么吗？如果让编译器生成定义，它会在头文件中的类定义范围内生成析构函数定义。在那个范围内，`FileLogger`和`DBConnection`没有完全定义，`scoped_ptr`的析构函数将无法编译通过，因为它们使用`boost::checked_delete`（[第2章](ch02.html
    "第2章。与Boost实用工具的初次接触")，“与Boost实用工具的初次接触”）'
- en: boost::scoped_array
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: boost::scoped_array
- en: The `scoped_ptr` class template works great for single, dynamically-allocated
    objects. Now if you remember our motivating example of writing an image rotation
    utility, we needed to wrap a dynamic array in our custom `ScopeGuard` class to
    make the `rotateImage` function exception-safe. Boost provides the `boost::scoped_array`
    template as an array analogue for `boost::scoped_ptr`. The semantics of `boost::scoped_array`
    are identical to those of `boost::scoped_ptr`, except that this one has an overloaded
    subscript operator (`operator[]`) to access individual elements of the wrapped
    array and does not provide overloaded operators for other forms of indirection
    (`operator*` and `operator->`). Rewriting the `rotateImage` function using `scoped_array`
    will be instructive at this point.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoped_ptr` 类模板非常适用于单个动态分配的对象。现在，如果您还记得我们的激励示例，即编写图像旋转实用程序，我们需要在我们自定义的 `ScopeGuard`
    类中包装一个动态数组，以使 `rotateImage` 函数具有异常安全性。Boost 提供了 `boost::scoped_array` 模板作为 `boost::scoped_ptr`
    的数组类似物。`boost::scoped_array` 的语义与 `boost::scoped_ptr` 完全相同，只是它有一个重载的下标运算符 (`operator[]`)
    用于访问封装数组的单个元素，并且不提供其他形式的间接操作符的重载 (`operator*` 和 `operator->`)。在这一点上，使用 `scoped_array`
    重写 `rotateImage` 函数将是有益的。'
- en: '**Listing 3.5: Using scoped_array**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 3.5：使用 scoped_array**'
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now use `boost::scoped_array` template in place of our `ScopeGuard` class
    to wrap the dynamically-allocated array (line 16). Upon scope exit, due to normal
    execution or exception, the destructor of `scoped_array` will invoke the array
    delete operator (`delete[]`) on the contained dynamic array and deallocate it
    in an exception-safe way. To highlight the ability to access array elements from
    the `scoped_array` interface, we access the first byte using the overloaded `operator[]`
    of `scoped_array` (line 20).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用 `boost::scoped_array` 模板来代替我们的 `ScopeGuard` 类，以包装动态分配的数组（第16行）。在作用域退出时，由于正常执行或异常，`scoped_array`
    的析构函数将调用包含动态数组的数组删除运算符 (`delete[]`) 并以异常安全的方式释放它。为了突出从 `scoped_array` 接口访问数组元素的能力，我们使用
    `scoped_array` 的重载 `operator[]` 来访问第一个字节（第20行）。
- en: The `scoped_array` template is mainly useful while dealing with legacy code
    with lots of dynamic arrays. Thanks to the overloaded subscript operator, `scoped_array`s
    are a drop-in replacement for dynamically-allocated arrays. Boxing up the dynamic
    arrays in `scoped_array`s is thus a fast path to exception safety. C++ advocates
    using `std::vector`s over dynamic arrays and that might be your eventual goal.
    Yet as wrappers with hardly any space overhead compared to vectors, `scoped_array`s
    could help transition faster to exception-safe code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoped_array` 模板主要用于处理大量动态数组的遗留代码。由于重载下标运算符，`scoped_array` 可以直接替换动态分配的数组。因此，将动态数组封装在
    `scoped_array` 中是实现异常安全的快速途径。C++ 倡导使用 `std::vector` 而不是动态数组，这可能是你最终的目标。然而，作为几乎没有与向量相比的空间开销的包装器，`scoped_array`
    可以帮助更快地过渡到异常安全的代码。'
- en: std::unique_ptr
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::unique_ptr
- en: C++ 11 introduces the `std::unique_ptr` smart pointer template, which supersedes
    the deprecated `std::auto_ptr`, supports the functionality of `boost::scoped_ptr`
    and `boost::scoped_array`, and can be stored in Standard Library containers. It
    is defined in the standard header file `memory` along with other smart pointers
    introduced in C++11.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 11 引入了 `std::unique_ptr` 智能指针模板，它取代了已弃用的 `std::auto_ptr`，支持 `boost::scoped_ptr`
    和 `boost::scoped_array` 的功能，并且可以存储在标准库容器中。它在标准头文件 `memory` 中定义，与 C++11 中引入的其他智能指针一起。
- en: 'The member functions of `std::unique_ptr` are easily mapped to those of `boost::scoped_ptr`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr` 的成员函数很容易映射到 `boost::scoped_ptr` 的成员函数：'
- en: A default-constructed `unique_ptr` contains a null pointer (`nullptr`) just
    like a default-constructed `scoped_ptr`.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认构造的 `unique_ptr` 包含一个空指针（`nullptr`），就像默认构造的 `scoped_ptr` 一样。
- en: You can call the `get` member function to access the contained pointer.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以调用 `get` 成员函数来访问包含的指针。
- en: The `reset` member function frees the older pointer and takes ownership of a
    new pointer (which could be null).
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset` 成员函数释放旧指针并接管新指针的所有权（可以是空指针）。'
- en: The `swap` member function swaps contents of two `unique_ptr` instances and
    always succeeds.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swap` 成员函数交换两个 `unique_ptr` 实例的内容，并且始终成功。'
- en: You can dereference non-null `unique_ptr` instances with `operator*` and access
    members using `operator->`.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用 `operator*` 对非空的 `unique_ptr` 实例进行解引用，并使用 `operator->` 访问成员。
- en: You can use `unique_ptr` instances in Boolean contexts to check for nullness
    just like `scoped_ptr` instances.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在布尔上下文中使用 `unique_ptr` 实例来检查是否为空，就像 `scoped_ptr` 实例一样。
- en: However, `std::unique_ptr` is more versatile than `boost::scoped_ptr` in certain
    matters.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，在某些方面，`std::unique_ptr` 比 `boost::scoped_ptr` 更灵活。
- en: A `unique_ptr` is movable, unlike `scoped_ptr`. Thus, it can be stored in C++11
    Standard Library containers and returned from functions.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique_ptr` 是可移动的，不像 `scoped_ptr`。因此，它可以存储在 C++11 标准库容器中，并且可以从函数中返回。'
- en: You can detach the pointer owned by a `std::unique_ptr` and manage it manually
    if you have to.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果必须，您可以分离 `std::unique_ptr` 拥有的指针并手动管理它。
- en: There is a `unique_ptr` partial specialization available for dynamically-allocated
    arrays. `scoped_ptr` does not support arrays, and you have to use the `boost::scoped_array`
    template for this purpose.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个用于动态分配数组的 `unique_ptr` 部分特化。`scoped_ptr` 不支持数组，您必须使用 `boost::scoped_array`
    模板来实现这一目的。
- en: Ownership transfer using unique_ptr
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 unique_ptr 进行所有权转移
- en: The `std::unique_ptr` smart pointer can be used as a scope guard just like the
    `boost::scoped_ptr`. Like `boost::scoped_ptr`, the type of the object pointed
    to by the encapsulated pointer must be completely known at the point where `unique_ptr`
    goes out of scope. However, unlike `boost::scoped_ptr`, `a unique_ptr instance`
    need not be bound to a single scope and can be moved from one scope to another.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr` 智能指针可以像 `boost::scoped_ptr` 一样用作作用域保护。与 `boost::scoped_ptr`
    不同，`unique_ptr 实例` 不需要绑定到单个作用域，可以从一个作用域移动到另一个作用域。'
- en: 'The `std::unique_ptr` smart pointer template cannot be copied but does support
    move semantics. Support for move semantics makes it possible to use `std::unique_ptr`
    as a function return value that transfers ownership of dynamically-allocated objects
    across functions. Here is such an example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_ptr`智能指针模板不能被复制，但支持移动语义。支持移动语义使得可以将`std::unique_ptr`用作函数返回值，从而在函数之间传递动态分配的对象的所有权。以下是一个这样的例子：'
- en: '**Listing 3.6a: Using unique_ptr**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表3.6a：使用unique_ptr**'
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `make_logger` function is a factory function that returns a new instance
    of `Logger`, wrapped in a `unique_ptr` (line 14). A function could use `make_logger`
    this way:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_logger`函数是一个工厂函数，返回一个包装在`unique_ptr`中的`Logger`的新实例（第14行）。一个函数可以这样使用`make_logger`：'
- en: '**Listing 3.6b: Using unique_ptr**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表3.6b：使用unique_ptr**'
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In function `doLogging`, the local variable `logger` is move-initialized by
    the `unique_ptr` returned from `make_logger` (line 6). So the contents of the
    `unique_ptr` instance created inside `make_logger` are moved into the variable
    `logger`. When `logger` goes out of scope as `doLogging` returns (line 8), its
    destructor destroys the underlying `Logger` instance and deallocates its memory.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数`doLogging`中，局部变量`logger`通过从`make_logger`返回的`unique_ptr`进行移动初始化（第6行）。因此，`make_logger`内部创建的`unique_ptr`实例的内容被移动到变量`logger`中。当`logger`超出范围时，即`doLogging`返回时（第8行），它的析构函数将销毁底层的`Logger`实例并释放其内存。
- en: Wrapping arrays in unique_ptr
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在`unique_ptr`中包装数组
- en: 'To illustrate the use of `unique_ptr` for wrapping dynamic arrays, we will
    rewrite the image rotation example (listing 3.5) yet again, replacing `scoped_ptr`
    with `unique_ptr`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '为了说明使用`unique_ptr`包装动态数组的用法，我们将再次重写图像旋转示例（列表3.5），将`scoped_ptr`替换为`unique_ptr`： '
- en: '**Listing 3.7: Using unique_ptr to wrap arrays**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表3.7：使用unique_ptr包装数组**'
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Apart from including a different header file (`memory` in place of `boost/scoped_ptr.hpp`),
    there is only one other line of code that needed an edit. In place of `boost::scoped_array<byte>`,
    the declared type of `img` is changed to `std::unique_ptr<byte[]>` (line 16)—a
    definitive drop-in replacement. The overloaded `operator[]` is available only
    for the array-specialization of `unique_ptr` and is used to refer to elements
    of the array.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包含不同的头文件（`memory`代替`boost/scoped_ptr.hpp`）之外，只需要编辑一行代码。在`boost::scoped_array<byte>`的位置，`img`的声明类型更改为`std::unique_ptr<byte[]>`（第16行）-
    一个明确的替换。重载的`operator[]`仅适用于`unique_ptr`的数组特化，并用于引用数组的元素。
- en: make_unique in C++14
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在C++14中使用make_unique
- en: 'The C++14 Standard Library contains a function template `std::make_unique`,
    which is a factory function for creating an instance of an object on dynamic memory
    and wrap it in `std::unique_ptr`. The following example is a rewrite of listing
    3.6b that illustrates the use of `make_unique`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C++14标准库包含一个函数模板`std::make_unique`，它是一个用于在动态内存上创建对象实例并将其包装在`std::unique_ptr`中的工厂函数。以下示例是对列表3.6b的重写，用于说明`make_unique`的用法：
- en: '**Listing 3.8: Using make unique**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表3.8：使用make unique**'
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `std::make_unique` function template takes the type of the underlying object
    to construct as a template argument and the arguments to the object''s constructor
    as function arguments. We directly pass to `make_unique`, the filename argument,
    which it forwards to the constructor of `Logger` (line 7). `make_unique` is a
    variadic template; it takes a variable number of arguments that match the constructor
    parameters of the type instantiated, in number and type. If there was a two-parameter
    constructor of `Logger`, say one that took a filename and a default log level,
    we would pass two arguments to `make_unique`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::make_unique`函数模板将要构造的基础对象的类型作为模板参数，并将对象的构造函数的参数作为函数参数。我们直接将文件名参数传递给`make_unique`，它将其转发给`Logger`的构造函数（第7行）。`make_unique`是一个可变模板；它接受与实例化类型的构造函数参数匹配的变量数量和类型。如果`Logger`有一个两个参数的构造函数，比如一个接受文件名和默认日志级别的构造函数，我们将向`make_unique`传递两个参数：'
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Assuming `loglevel_t` describes the type used to represent log levels, and `DEBUG`
    describes a valid value for that type, the preceding snippet illustrates the use
    of `make_unique` with multiple constructor arguments.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`loglevel_t`描述用于表示日志级别的类型，`DEBUG`描述该类型的一个有效值，前面的片段说明了使用`make_unique`与多个构造函数参数的用法。
- en: If you have moved your codebase to C++11, you should prefer using `std::unique_ptr`
    to `boost::scoped_ptr`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已将代码库迁移到C++11，应优先使用`std::unique_ptr`而不是`boost::scoped_ptr`。
- en: Shared ownership semantics
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享所有权语义
- en: Unique ownership semantics with the ability to transfer ownership is good enough
    for most purposes that you would use a smart pointer for. But in some real-world
    applications, you will need to share resources across multiple contexts without
    any of these contexts being a clear owner. Such a resource can be released only
    when all of the contexts holding references to the shared resource release them.
    When and where this happens cannot be determined in advance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 具有转移所有权能力的独特所有权语义对于大多数您使用智能指针的目的来说已经足够好了。但在一些现实世界的应用中，您需要在多个上下文中共享资源，而这些上下文中没有一个是明确的所有者。这样的资源只有在持有对共享资源的引用的所有上下文释放它们时才能释放。这种释放的时间和地点无法提前确定。
- en: Let us understand this with a concrete example. Two threads in a single process
    read data from different sections of the same dynamically-allocated region in
    memory. Each thread does some processing on the data and then reads more data.
    We need to ensure that the dynamically-allocated memory region is cleanly deallocated
    when the last thread terminates. Either thread could terminate before the other;
    so who deallocates the buffer?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的例子来理解这一点。在单个进程中，两个线程从内存中的同一动态分配区的不同部分读取数据。每个线程对数据进行一些处理，然后再读取更多数据。我们需要确保当最后一个线程终止时，动态分配的内存区域能够被清理释放。任何一个线程都可能在另一个线程之前终止；那么谁来释放缓冲区呢？
- en: By encapsulating the buffer in a smart wrapper that can keep a count of the
    number of contexts referring to it, and deallocating the buffer only when the
    count goes to zero, we can encapsulate the logic of deallocation completely. The
    users of the buffer should switch to using a smart wrapper, which they can freely
    copy, and when all copies go out of scope, the reference count goes to zero and
    the buffer is deallocated.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将缓冲区封装在一个智能包装器中，该包装器可以保持对其的引用计数，并且仅当计数变为零时才释放缓冲区，我们可以完全封装释放逻辑。缓冲区的用户应该切换到使用智能包装器，他们可以自由复制，并且当所有副本超出范围时，引用计数变为零并且缓冲区被释放。
- en: boost::shared_ptr and std::shared_ptr
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: boost::shared_ptr和std::shared_ptr
- en: The `boost::shared_ptr` smart pointer template provides reference-counted shared
    ownership semantics. It keeps track of the number of references to it using a
    shared reference count that it maintains alongside the wrapped, dynamically-allocated
    object. Like other smart pointer templates we have seen so far, it implements
    the RAII idiom, taking responsibility of destroying and deallocating the wrapped
    object in its destructor, but it does so only when all references to it are destroyed,
    that is, the reference count goes to zero. It is a header-only library made available
    by including `boost/shared_ptr.hpp`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::shared_ptr`智能指针模板提供了引用计数的共享所有权语义。它使用共享引用计数来跟踪对它的引用次数，该引用计数与包装的动态分配对象一起维护。与我们迄今为止看到的其他智能指针模板一样，它实现了RAII习语，负责在其析构函数中销毁和释放包装的对象，但只有当所有对它的引用都被销毁时才这样做，也就是说，引用计数变为零。它是一个仅包含头文件的库，通过包括`boost/shared_ptr.hpp`可用。'
- en: '`shared_ptr` was included in C++ Standards Committee Technical Report in 2007
    (colloquially TR1), which was a precursor to the C++11 standard and was made available
    as `std::tr1::shared_ptr`. It is now part of the C++11 Standard Library as `std::shared_ptr`
    available through the standard C++ header file `memory`. If you have moved your
    codebase to C++11, you should use `std::shared_ptr`. Much of the discussion in
    this section applies to both versions; differences, if any, are called out.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`于2007年被包含在C++标准委员会技术报告（俗称TR1）中，这是C++11标准的前身，并作为`std::tr1::shared_ptr`提供。它现在是C++11标准库的一部分，作为`std::shared_ptr`通过标准C++头文件`memory`提供。如果您将代码库迁移到C++11，应该使用`std::shared_ptr`。本节中的大部分讨论都适用于两个版本；如果有任何区别，都会被指出。'
- en: 'You create `shared_ptr` instances to take ownership of a dynamically-allocated
    object. Unlike `boost::scoped_ptr` and `std::unique_ptr`, you can copy `shared_ptr`
    instances. `std::shared_ptr` also supports move semantics. It stores the dynamically-allocated
    pointer and a shared reference count object. Each time `shared_ptr` is copied
    via copy construction, the pointer and the reference count object are shallow-copied.
    Copying `shared_ptr` instances causes reference counts to be bumped up. `shared_ptr`
    instances going out of scope causes reference counts to be decremented. The `use_count`
    member function can be used to get the current reference counts. Here is an example
    that shows `shared_ptr` in action:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建`shared_ptr`实例来拥有动态分配的对象。与`boost::scoped_ptr`和`std::unique_ptr`不同，您可以复制`shared_ptr`实例。`std::shared_ptr`还支持移动语义。它存储动态分配的指针和共享引用计数对象。每次通过复制构造函数复制`shared_ptr`时，指针和引用计数对象都会被浅复制。复制`shared_ptr`实例会导致引用计数增加。`shared_ptr`实例超出范围会导致引用计数减少。`use_count`成员函数可用于获取当前引用计数。以下是一个展示`shared_ptr`的示例：
- en: '**Listing 3.9: shared_ptr in action**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单3.9：`shared_ptr`的示例**'
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, we define a class `Foo` with a default constructor and
    a destructor that prints some message (lines 5-9). We include `boost/shared_ptr.hpp`
    (line 1), which provides the `boost::shared_ptr` template.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们定义了一个带有默认构造函数和打印一些消息的析构函数的`Foo`类（第5-9行）。我们包括了`boost/shared_ptr.hpp`（第1行），它提供了`boost::shared_ptr`模板。
- en: In the main function, we define two `shared_ptr<Foo>` instances `f1` (line 15)
    and `f3` (line 25), initialized with two different dynamically-allocated instances
    of class `Foo`. Note that the `shared_ptr` constructor is explicit and thus, you
    cannot use an assignment expression to copy-initialize `shared_ptr` using implicit
    conversion (line 16). The reference count of each `shared_ptr<Foo>` instance after
    construction is 1 (lines 17 and 25). Next, we create `f2` as a copy of `f1` (line
    20) and `f4` as a copy of `f3` (line 26). The copying causes the reference counts
    to bump up. The `get` member function of `shared_ptr` returns the encapsulated
    pointer, and the `use_count` member function of `shared_ptr` returns the current
    reference count. Using `use_count`, we assert that `f1` and `f2` have the same
    reference count, and using `get`, we assert that they contain the same pointer
    (lines 21-22). Similar assertions hold true for `f3` and `f4` (line 27).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数中，我们定义了两个`shared_ptr<Foo>`实例`f1`（第15行）和`f3`（第25行），初始化为`Foo`类的两个不同动态分配的实例。请注意，`shared_ptr`构造函数是显式的，因此您不能使用赋值表达式使用隐式转换来复制初始化`shared_ptr`（第16行）。每个`shared_ptr<Foo>`实例在构造后的引用计数为1（第17行和第25行）。接下来，我们创建`f2`作为`f1`的副本（第20行），并创建`f4`作为`f3`的副本（第26行）。复制会导致引用计数增加。`shared_ptr`的`get`成员函数返回封装的指针，`use_count`成员函数返回当前引用计数。使用`use_count`，我们断言`f1`和`f2`具有相同的引用计数，并使用`get`，我们断言它们包含相同的指针（第21-22行）。对于`f3`和`f4`也是如此（第27行）。
- en: Next, we copy-assign `f1` to `f4` (line 31). As a result, `f4` now contains
    the same pointer as `f1` and `f2`, and no longer shares a pointer with `f3`. Now
    `f1`, `f2`, and `f4` are three `shared_ptr<Foo>` instances pointing to the same
    pointer and their shared reference count goes to 3 (lines 32-33). `f3` no longer
    shares its pointer with another instance, so its reference count goes to 1 (line
    34).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`f1`复制分配给`f4`（第31行）。结果，`f4`现在包含与`f1`和`f2`相同的指针，并且不再与`f3`共享指针。现在，`f1`，`f2`和`f4`是指向相同指针的三个`shared_ptr<Foo>`实例，它们的共享引用计数变为3（第32-33行）。`f3`不再与另一个实例共享其指针，因此其引用计数变为1（第34行）。
- en: 'Running the preceding code, you can expect the following output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码，您可以期望以下输出：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The reference counts duly go to zero at the end of the `main` function, and
    both the dynamically created instances of `Foo` are destroyed by the `shared_ptr`
    destructors.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数在`main`函数结束时确实变为零，并且`shared_ptr`析构函数销毁了动态创建的`Foo`实例。
- en: Uses of shared_ptr
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`shared_ptr`的用途'
- en: In pre-C++11 code, `boost::shared_ptr` or `std::tr1::shared_ptr` tends to be
    the default choice for a smart pointer owing to its flexibility and ease of use,
    compared to `boost::scoped_ptr`. It is used for purposes beyond pure shared-ownership
    semantics and this makes it the best-known smart pointer template. In C++11, such
    pervasive use should be curbed in favor of `std::unique_ptr`, and `shared_ptr`
    should only be used to model true shared-ownership semantics.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前的代码中，由于其灵活性和易用性，`boost::shared_ptr`或`std::tr1::shared_ptr`往往是智能指针的默认选择，而不是`boost::scoped_ptr`。它用于超出纯共享所有权语义的目的，这使其成为最知名的智能指针模板。在C++11中，应该遏制这种普遍使用，而应该优先使用`std::unique_ptr`，`shared_ptr`应该仅用于模拟真正的共享所有权语义。
- en: As a class member
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 作为类成员
- en: 'Consider a scenario where multiple components of an application may share a
    single database connection for better performance. Such a connection could be
    created the first time it is requested and cached as long as there is some component
    using it. When all components are done using it, the connection ought to be closed.
    This is definitive of shared-ownership semantics and `shared_ptr` is useful in
    this scenario. Let us see how an application component might use `shared_ptr`
    to encapsulate a shared database connection:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，应用程序的多个组件可以共享单个数据库连接以获得更好的性能。只要有一些组件在使用它，就可以在首次请求时创建这样的连接并将其缓存。当所有组件都使用完毕后，连接应该被关闭。这是共享所有权语义的定义，`shared_ptr`在这种情况下非常有用。让我们看看应用程序组件如何使用`shared_ptr`来封装共享数据库连接：
- en: '**Listing 3.10: Using shared_ptr as class members**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单3.10：将shared_ptr用作类成员**'
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `AppComponent` is a component of the application that uses a database connection
    wrapped in a `shared_ptr` (line 20). The default-constructed `AppComponent` creates
    a new database connection (line 4), but you can always create an `AppComponent`
    instance by passing it an existing database connection wrapped in a `shared_ptr`
    (lines 7-9). The `getConnection` member function retrieves the shared pointer-wrapped
    `DatabaseConnection` object wrapped in a shared_ptr (line 16). Here is an example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppComponent`是应用程序的一个组件，它使用包装在`shared_ptr`（第20行）中的数据库连接。默认构造的`AppComponent`创建一个新的数据库连接（第4行），但您始终可以通过传递包装在`shared_ptr`（第7-9行）中的现有数据库连接来创建`AppComponent`实例。`getConnection`成员函数检索包装在shared_ptr中的`DatabaseConnection`对象（第16行）。以下是一个例子：'
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we create two `AppComponent` instances `c1` and `c2` that share
    the same database connection. The second instance is created using the `shared_ptr`-wrapped
    database connection cached by the first instance, obtained using the `getConnection`
    method. Irrespective of the order in which `c1` and `c2` are destroyed, the shared
    connection is destroyed only when the last of the two is destroyed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们创建了两个`AppComponent`实例`c1`和`c2`，它们共享相同的数据库连接。第二个实例是使用第一个实例缓存的`shared_ptr`包装的数据库连接通过`getConnection`方法获得的。无论`c1`和`c2`的销毁顺序如何，只有当两者中的最后一个被销毁时，共享连接才会被销毁。
- en: Storing dynamically-allocated objects in Standard Library containers
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在标准库容器中存储动态分配的对象
- en: Objects stored by Standard Library containers are copied or moved into the container
    and are destroyed with the container. Objects are retrieved too by copying or
    moving. Prior to C++11, there was no support for move semantics and copying was
    the sole mechanism for storing objects in containers. Standard Library containers
    do not support reference semantics. You may store pointers to dynamically-allocated
    objects in containers but, at the end of its life cycle, the container not attempt
    to destroy and deallocate these objects via their pointers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库容器存储的对象被复制或移动到容器中，并随容器一起销毁。对象也通过复制或移动来检索。在C++11之前，没有支持移动语义，复制是在容器中存储对象的唯一机制。标准库容器不支持引用语义。您可以将动态分配对象的指针存储在容器中，但在其生命周期结束时，容器不会尝试通过指针销毁和释放这些对象。
- en: 'You can wrap dynamically-allocated objects in `shared_ptr` or `unique_ptr`
    and store them in containers. Assuming that you can use C++11, `std::unique_ptr`
    is good enough if storing them in a single container is all you are ever going
    to need. But if you need to store the same dynamically-allocated object across
    multiple containers, `shared_ptr` is the best choice for the wrapper. When the
    container is destroyed, the destructor of each `shared_ptr` instance is called
    and the reference count of that `shared_ptr` is decremented. If the reference
    count goes to zero for any `shared_ptr`, the underlying dynamic object stored
    in it is deallocated. The following example illustrates how objects wrapped in
    `shared_ptr` can be stored in multiple STL containers:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将动态分配的对象包装在`shared_ptr`或`unique_ptr`中并将它们存储在容器中。假设您可以使用C++11，如果将它们存储在单个容器中就足够了，那么`std::unique_ptr`就足够好了。但是，如果需要在多个容器中存储相同的动态分配对象，`shared_ptr`是包装器的最佳选择。当容器被销毁时，将调用每个`shared_ptr`实例的析构函数，并将该`shared_ptr`的引用计数减少。如果任何`shared_ptr`的引用计数为零，则其中存储的底层动态对象将被释放。以下示例说明了如何将`shared_ptr`中包装的对象存储在多个STL容器中：
- en: '**Listing 3.11: Storing shared_ptr in containers**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单3.11：在容器中存储shared_ptr**'
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, let us assume that there is a class called `Person`
    (line 1). Now, given a list of objects of type `Person`, we would like to create
    a mapping of names to `Person` objects. Assume that `Person` objects cannot be
    copied, and so they need to be stored in containers as pointers. We define a type
    alias called `PersonPtr` for `shared_ptr<Person>` (line 2). We also define the
    data structures for storing a list of `Person` objects, (`std::vector<PersonPtr>`
    (line 3)) and the mapping of `Person` names to `Person` objects (`std::multimap<std::string,
    PersonPtr>` (line 4)). Finally, we construct the mapping from the list (lines
    7-9).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，让我们假设有一个名为`Person`的类（第1行）。现在，给定一个类型为`Person`的对象列表，我们想要创建一个将名称映射到`Person`对象的映射。假设`Person`对象不能被复制，因此它们需要以指针的形式存储在容器中。我们为`shared_ptr<Person>`定义了一个类型别名称为`PersonPtr`（第2行）。我们还定义了用于存储`Person`对象列表的数据结构（`std::vector<PersonPtr>`（第3行））和将`Person`名称映射到`Person`对象的映射（`std::multimap<std::string,
    PersonPtr>`（第4行））。最后，我们从列表构造映射（第7-9行）。
- en: Each entry into the `personNameMap` container is created as a `std::pair` of
    the name of a person and the `PersonPtr` object (using `std::make_pair`). Each
    such entry is inserted into the `multimap` using its `insert` member function
    (line 9). We assume that there is a member function in `Person` called `name`.
    The `PersonPtr` object being a `shared_ptr` is shared across the `vector` and
    the `multimap` containers. The `Person` objects are destroyed when the last of
    the two containers is destroyed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`personNameMap`容器中的每个条目都被创建为一个人的名称和`PersonPtr`对象的`std::pair`（使用`std::make_pair`）。每个这样的条目都使用其`insert`成员函数插入到`multimap`中（第9行）。我们假设`Person`中有一个名为`name`的成员函数。`PersonPtr`对象作为`shared_ptr`在`vector`和`multimap`容器之间共享。当两个容器中的最后一个被销毁时，`Person`对象也将被销毁。'
- en: Besides `shared_ptr`, Boost's Pointer Containers provide an alternative means
    of storing dynamically-allocated objects in containers. We cover Pointer Containers
    in [Chapter 5](ch05.html "Chapter 5. Effective Data Structures beyond STL"), *Effective
    Data Structures beyond STL*. In [Chapter 9](ch09.html "Chapter 9. Files, Directories,
    and IOStreams"), *Files, Directories, and IOStreams*, which deals with Boost Threads,
    we will see how `shared_ptr` instances can be shared across threads.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`shared_ptr`，Boost的指针容器提供了一种在容器中存储动态分配对象的替代方法。我们将在[第5章](ch05.html "第5章。超越STL的有效数据结构")中介绍指针容器，*超越STL的有效数据结构*。在[第9章](ch09.html
    "第9章。文件、目录和IOStreams")中，*文件、目录和IOStreams*，处理Boost线程，我们将看到`shared_ptr`实例如何在线程之间共享。
- en: Nonowning aliases – boost::weak_ptr and std::weak_ptr
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 非拥有别名 - boost::weak_ptr和std::weak_ptr
- en: In the last section, one of the examples we looked at was that of a database
    connection shared among multiple application components. This form of use has
    certain shortcomings. While instantiating application components that are meant
    to reuse the open database connection, you need to refer to another existing component
    that uses the connection and pass that connection to the constructor of the new
    object. A more scalable approach is to decouple the connection creation and application
    component creation so that application components are not even aware of whether
    they got a new connection or an existing reusable connection. But the requirement
    still remains that the connection must be shared across all clients, and it must
    be closed when the last reference to it has gone.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到的一个例子是多个应用程序组件共享的数据库连接。这种使用方式有一定的缺点。在实例化旨在重用打开的数据库连接的应用程序组件时，您需要引用另一个使用连接的现有组件，并将该连接传递给新对象的构造函数。更可扩展的方法是解耦连接创建和应用程序组件创建，以便应用程序组件甚至不知道它们是否获得了新连接或现有可重用连接。但要求仍然是连接必须在所有客户端之间共享，并且在最后一个引用它消失时必须关闭连接。
- en: 'One approach to building such a mechanism is to use a database connection factory,
    which creates connections to a specific database instance based on connection
    parameters passed by the caller. It then passes the connection back to the caller
    wrapped in a `shared_ptr` and also stores it in a map that can be looked up. When
    a new client requests a connection to the same instance for the same database
    user, the factory can simply look up the existing connection from the map and
    return it wrapped in a `shared_ptr`. The following and illustrative code implements
    this logic. It assumes that all information needed to connect to a database instance
    is encapsulated in a `DBCredentials` object:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 构建这样一种机制的一种方法是使用数据库连接工厂，它根据调用者传递的连接参数创建到特定数据库实例的连接。然后将连接包装在`shared_ptr`中返回给调用者，并将其存储在可以查找的映射中。当新的客户端请求连接到相同数据库用户的相同实例时，工厂可以简单地从映射中查找现有连接并将其包装在`shared_ptr`中返回。以下是说明此逻辑的代码。它假设连接到数据库实例所需的所有信息都封装在`DBCredentials`对象中：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, `DBConnectionFactory` provides a static method called
    `connect` that takes a `DBCredentials` object and returns a `shared_ptr`-wrapped
    `DatabaseConnection` (`DBConnectionPtr`) (lines 8-19). We call `DBConnectionFactory::connect`
    twice, passing the same credentials. The first call (line 28) should result in
    the creation of a new connection (line 15), while the second call should just
    look up and return the same connection (lines 10-13).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`DBConnectionFactory`提供了一个名为`connect`的静态方法，它接受一个`DBCredentials`对象并返回一个`shared_ptr`包装的`DatabaseConnection`（`DBConnectionPtr`）（第8-19行）。我们调用`DBConnectionFactory::connect`两次，传递相同的凭据。第一次调用（第28行）应该导致创建一个新的连接（第15行），而第二次调用应该只是查找并返回相同的连接（第10-13行）。
- en: 'There is one major problem with this code: `DBConnectionFactory` stores the
    connection wrapped in a `shared_ptr` inside a static `std::map` called `conn_map_`
    (line 21). As a result, its reference count goes to 0 only at the end of the program,
    when the `conn_map_` is destroyed. Otherwise, even when there are no contexts
    using the connection, the reference count remains at 1\. We require that, when
    all contexts using the shared connection exit or expire, the connection should
    be destroyed. This is clearly not met.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码存在一个主要问题：`DBConnectionFactory`将连接存储在静态的`std::map` `conn_map_`（第21行）中的`shared_ptr`中。结果是，只有在程序结束时`conn_map_`被销毁时，引用计数才会变为0。否则，即使没有上下文使用连接，引用计数仍保持为1。我们要求，当所有使用共享连接的上下文退出或过期时，连接应该被销毁。显然这个要求没有得到满足。
- en: Storing the raw pointer (`DatabaseConnection*`) instead of the `shared_ptr`
    (`DBConnectionPtr`) in the map would be no good because, we need the first `shared_ptr`
    instance we gave out for the connection, to be able to create more `shared_ptr`
    instances for that connection. Even with ways to get around this problem (as we
    will see later with `enable_shared_from_this`), by just looking up the raw pointer
    in the connection map we would not know whether it is still in use or has already
    been deallocated.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图中存储原始指针（`DatabaseConnection*`）而不是`shared_ptr`（`DBConnectionPtr`）是不好的，因为我们需要为连接创建更多的`shared_ptr`实例时，能够使用我们分发的第一个`shared_ptr`实例。即使有方法可以解决这个问题（正如我们将在`enable_shared_from_this`中看到的），通过在连接映射中查找原始指针，我们也无法知道它是否仍在使用或已经被释放。
- en: 'The `boost::weak_ptr` template, also available in C++11 as `std::weak_ptr`,
    is the right tool to fix this problem. You can refer to a `shared_ptr` instance
    using one or more `weak_ptr` instances, without contributing to the reference
    count that determines its lifetime. Using the `weak_ptr` instances, you can safely
    determine whether the `shared_ptr` it refers to is still active or expired. If
    not expired, you can use the `weak_ptr` instance to also create another `shared_ptr`
    instance referring to the same object. We will now rewrite the preceding example
    using `weak_ptr`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::weak_ptr`模板，也可以在C++11中作为`std::weak_ptr`使用，是解决这个问题的正确工具。您可以使用一个或多个`weak_ptr`实例引用`shared_ptr`实例，而不会增加决定其生命周期的引用计数。使用`weak_ptr`实例，您可以安全地确定它所引用的`shared_ptr`是否仍然活动或已过期。如果没有过期，您可以使用`weak_ptr`实例来创建另一个引用相同对象的`shared_ptr`实例。现在我们将使用`weak_ptr`重写前面的示例：'
- en: '**Listing 3.12: Using weak_ptr**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单3.12：使用weak_ptr**'
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, we alter the definition of `ConnectionMap` to store `weak_ptr<DatabaseConnection>`
    instead of `shared_ptr<DatabaseConnection>` (line 6-7). When the `DBConnectionFactory::connect`
    function is called with appropriate credentials, the code looks up the entry (line
    10), and on failure, creates a new database connection, wraps it in a `shared_ptr`
    (line 17), and stores it as a `weak_ptr` in the map (line 18). Note that we assign
    a `shared_ptr` to a `weak_ptr` using the copy assignment operator. The newly constructed
    `shared_ptr` is returned (line 19). If the lookup succeeded, it calls the `lock`
    method on the retrieved `weak_ptr` in an attempt to construct a `shared_ptr` from
    it (line 12). If the retrieved `weak_ptr` represented by `it->second` refers to
    a valid `shared_ptr`, the `lock` call will automatically return another `shared_ptr`
    referring to the same object and this would be assigned to the `connptr` variable
    and returned (line 15). Otherwise, the `lock` call will return a null `shared_ptr`,
    and we will create a new connection in the `else` block, as described earlier.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们修改了`ConnectionMap`的定义，将`shared_ptr<DatabaseConnection>`存储为`weak_ptr<DatabaseConnection>`（第6-7行）。当调用`DBConnectionFactory::connect`函数时，代码查找条目（第10行），失败时，创建一个新的数据库连接，将其包装在`shared_ptr`中（第17行），并将其存储为地图中的`weak_ptr`（第18行）。请注意，我们使用复制赋值运算符将`shared_ptr`分配给`weak_ptr`。新构造的`shared_ptr`被返回（第19行）。如果查找成功，它会尝试从中检索的`weak_ptr`上调用`lock`方法来构造一个`shared_ptr`（第12行）。如果由`it->second`表示的检索的`weak_ptr`引用一个有效的`shared_ptr`，`lock`调用将自动返回另一个引用相同对象的`shared_ptr`，并将其分配给`connptr`变量并返回（第15行）。否则，`lock`调用将返回一个空的`shared_ptr`，我们将在`else`块中创建一个新的连接，就像之前描述的那样。
- en: If you just wanted to check whether the `weak_ptr` instance refers to a valid
    `shared_ptr` or not without creating a new `shared_ptr` referent, just call the
    `expired` method on the `weak_ptr`. It will return `false` only if at least one
    `shared_ptr` instance is still around.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想检查`weak_ptr`实例是否引用有效的`shared_ptr`，而不创建一个新的`shared_ptr`引用对象，只需在`weak_ptr`上调用`expired`方法。只有当至少有一个`shared_ptr`实例仍然存在时，它才会返回`false`。
- en: 'How does the `weak_ptr` achieve this? Actually, `shared_ptr` and `weak_ptr`
    are designed to work with each other. Each `shared_ptr` instance has two pieces
    of memory: the dynamically-allocated object it encapsulates and a chunk of memory
    called the shared counter, which contains not one but two atomic reference counts.
    Both chunks of memory are shared between all related `shared_ptr` instances. The
    shared counter chunk is also shared with all `weak_ptr` instances that refer to
    these `shared_ptr` instances.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`weak_ptr`是如何实现这一点的？实际上，`shared_ptr`和`weak_ptr`是设计为相互配合使用的。每个`shared_ptr`实例都有两块内存：它封装的动态分配的对象和一个名为共享计数器的内存块，其中包含两个原子引用计数而不是一个。这两块内存都在所有相关的`shared_ptr`实例之间共享。共享计数器块也与引用这些`shared_ptr`实例的所有`weak_ptr`实例共享。'
- en: The first reference count in the shared counter, the *use count*, keeps a count
    of the number of references to the `shared_ptr`. When this count goes to zero,
    the encapsulated, dynamically-allocated object is deleted and the `shared_ptr`
    expires. The second reference count, the *weak count*, is the number of `weak_ptr`
    references, plus one if and only if there are `shared_ptr` instances around. The
    shared counter chunk is deleted only when the weak count goes to zero, that is,
    when all `shared_ptr` and `weak_ptr` instances have expired. Thus, any remaining
    `weak_ptr` instance is able to tell whether the `shared_ptr` has expired by checking
    the use count, which is still accessible to it, and seeing if it is 0\. The `lock`
    method of `weak_ptr` atomically checks the use count and increments it only if
    it is non-zero, returning a valid `shared_ptr` wrapping the encapsulated pointer.
    If the use count was already zero, lock returns an empty `shared_ptr`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 共享计数器中的第一个引用计数，*使用计数*，保持对`shared_ptr`的引用数量的计数。当此计数变为零时，封装的动态分配对象将被删除，`shared_ptr`将过期。第二个引用计数，*弱引用计数*，是`weak_ptr`引用的数量，加上1（仅当有`shared_ptr`实例存在时）。只有当弱引用计数变为零时，也就是当所有`shared_ptr`和`weak_ptr`实例都过期时，共享计数块才会被删除。因此，任何剩余的`weak_ptr`实例都可以通过检查使用计数来判断`shared_ptr`是否已过期，并查看它是否为0。`weak_ptr`的`lock`方法会原子地检查使用计数，并仅在它不为零时递增它，返回一个包装封装指针的有效`shared_ptr`。如果使用计数已经为零，`lock`将返回一个空的`shared_ptr`。
- en: A shared_ptr critique – make_shared and enable_shared_from_this
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个shared_ptr的批评 - make_shared和enable_shared_from_this
- en: '`shared_ptr` has been used widely, beyond its appropriate use case for shared-ownership
    semantics. This is partly due to its availability as part of the C++ **Technical
    Report 1** (**TR1**) release in 2007, whereas other viable options like Boost''s
    Pointer Containers (see [Chapter 5](ch05.html "Chapter 5. Effective Data Structures
    beyond STL"), *Effective Data Structures beyond STL*) were not part of the TR1\.
    But `shared_ptr` requires an extra allocation for the shared counter, because
    of which construction and destruction is slower than it is for `unique_ptr` and
    `scoped_ptr`. The shared counter itself is an object containing two atomic integers.
    If you never need shared-ownership semantics but use `shared_ptr`, you pay for
    one extra allocation of the shared counter and for the increment and decrement
    operations on atomic counters, which make copying `shared_ptr` slower. If you
    need shared-ownership semantics but don''t care about `weak_ptr` observers, you
    pay for the extra space occupied by the weak reference counter that you would
    not need.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`已被广泛使用，超出了适当使用共享所有权语义的用例。这在一定程度上是由于它作为C++ **技术报告1**（**TR1**）发布的一部分而可用，而其他可行的选项，如Boost的指针容器（参见[第5章](ch05.html
    "第5章。超出STL的有效数据结构")，*超出STL的有效数据结构*）并不是TR1的一部分。但是`shared_ptr`需要额外的分配来存储共享计数，因此构造和销毁比`unique_ptr`和`scoped_ptr`慢。共享计数本身是一个包含两个原子整数的对象。如果您从不需要共享所有权语义但使用`shared_ptr`，则需要为共享计数支付额外的分配，并且需要为原子计数的递增和递减操作付费，这使得复制`shared_ptr`变慢。如果您需要共享所有权语义但不关心`weak_ptr`观察者，那么您需要为弱引用计数占用的额外空间付费，而这是您不需要的。'
- en: 'One way to mitigate this problem is to somehow coalesce the two allocations—one
    for the object and one for the shared counter—into one. The `boost::make_shared`
    function template (also `std::make_shared` in C++11) is a variadic function template
    that does exactly this. Here is how you would use it:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解这个问题的一种方法是以某种方式将两个分配（一个用于对象，一个用于共享计数）合并为一个。`boost::make_shared`函数模板（C++11中也有`std::make_shared`）是一个可变函数模板，正是这样做的。以下是您将如何使用它的方式：
- en: '**Listing 3.13: Using make_shared**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单3.13：使用make_shared**'
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `boost::make_shared` function template takes the type of object as a template
    argument and the arguments to the object's constructor as function arguments.
    We call `make_shared<Foo>`, passing it the arguments we want to construct the
    `Foo` object with (lines 8-9). The function then allocates a single block of memory
    in which it lays out the object and also appends the two atomic counts, in one
    fell swoop. Note that you need to include the header file `boost/make_shared.hpp`
    to use `make_shared`. This is not as perfect as it seems but might be a good enough
    trade-off. It is not perfect because now it is a single block of memory not two,
    and is shared between all `shared_ptr` and `weak_ptr` referents.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::make_shared`函数模板将对象的类型作为模板参数，并将对象的构造函数的参数作为函数参数。我们调用`make_shared<Foo>`，将要用来构造`Foo`对象的参数传递给它（第8-9行）。然后函数会在内存中分配一个单一的内存块，其中放置对象，并一次性附加两个原子计数。请注意，您需要包含头文件`boost/make_shared.hpp`才能使用`make_shared`。这并不像看起来那么完美，但可能是一个足够好的折衷方案。这并不完美，因为现在它是一个单一的内存块而不是两个，并且在所有`shared_ptr`和`weak_ptr`引用之间共享。'
- en: Even when all the `shared_ptr` referents are gone and the object destructed,
    its memory is reclaimed only when the last `weak_ptr` is gone. Again, this is
    a problem only if you use lingering `weak_ptr` instances and your object size
    is large enough to be a worry.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 即使所有`shared_ptr`引用都消失并且对象被销毁，只有当最后一个`weak_ptr`消失时，其内存才会被回收。同样，只有在使用持久的`weak_ptr`实例并且对象大小足够大以至于成为一个问题时，这才是一个问题。
- en: 'There is yet another problem with `shared_ptr` that we briefly looked at earlier.
    If we create two independent `shared_ptr` instances from the same raw pointer,
    then they have independent reference counts and both try to delete the encapsulated
    object in due course. The first will succeed, but the destructor of the second
    instance will most likely crash, trying to delete an already deleted entity. Also,
    any attempts to dereference the object through the second `shared_ptr` after the
    first goes out of scope would be equally disastrous. The general solution to this
    problem is to not use `shared_ptr` at all but rather use `boost::intrusive_ptr`—something
    that we explore in the next section. An alternate way to get around the problem
    is to equip an instance method of the wrapped class to return a `shared_ptr` using
    the `this` pointer. For this, your class must derive from the `boost::enable_shared_from_this`
    class template. Here is an example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前简要讨论过`shared_ptr`的另一个问题。如果我们从同一个原始指针创建两个独立的`shared_ptr`实例，那么它们将有独立的引用计数，并且两者都会尝试在适当的时候删除封装的对象。第一个会成功，但第二个实例的析构函数很可能会崩溃，试图删除一个已经删除的实体。此外，在第一个实例超出范围后，通过第二个`shared_ptr`尝试解引用对象的任何尝试都将同样灾难性。解决这个问题的一般方法是根本不使用`shared_ptr`，而是使用`boost::intrusive_ptr`——这是我们在下一节中探讨的内容。解决这个问题的另一种方法是为包装类的实例方法提供返回`shared_ptr`的能力，使用`this`指针。为此，你的类必须从`boost::enable_shared_from_this`类模板派生。下面是一个例子：
- en: '**Listing 3.14: Using enable_shared_from_this**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单3.14：使用enable_shared_from_this**'
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding code, the class `CanBeShared` derives from `boost:: enable_shared_from_this<CanBeShared>`
    (line 7). If you are wondering how come `CanBeShared` inherits from a class template
    instantiation, which takes `CanBeShared` itself as a template argument, let me
    refer you to the Curiously Recurring Template Pattern, a C++ idiom you can read
    more about on the Web. Now, `CanBeShared` defines a member function called `share`
    that returns the `this` pointer wrapped in a `shared_ptr` (line 13). It does so
    using the member function `shared_from_this` (line 15), which it inherits from
    its base class.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，类`CanBeShared`派生自`boost::enable_shared_from_this<CanBeShared>`（第7行）。如果你想知道为什么`CanBeShared`继承自一个类模板实例，该实例以`CanBeShared`本身作为模板参数，那么我建议你查阅一下奇异递归模板模式，这是一个C++习惯用法，你可以在网上了解更多。现在，`CanBeShared`定义了一个名为`share`的成员函数，它返回包装在`shared_ptr`中的`this`指针（第13行）。它使用了它从基类继承的成员函数`shared_from_this`（第15行）来实现这一点。
- en: In the `main` function, we create an instance `cbs` of `CanBeSharedPtr` (which
    is a `typedef` for `boost::shared_ptr<CanBeShared>`) from a dynamically-allocated
    object of type `CanBeShared` (line 31). Next, we call the function `doWork` passing
    it the raw pointer inside `cbs` (line 32). The `doWork` function is passed a reference
    (`obj`) to `CanBeShared`, and calls the `share` method on it to get a `shared_ptr`
    wrapper of the same object (line 23). The reference count of this `shared_ptr`
    goes to 2 now (line 25), and the pointer it contains points to `obj` (line 26).
    Once `doWork` returns, the usage count on `cbs` goes back to 1 (line 34).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们从类型为`CanBeShared`的动态分配对象（第31行）创建了`CanBeSharedPtr`的实例`cbs`（它是`boost::shared_ptr<CanBeShared>`的`typedef`）。接下来，我们调用`doWork`函数，将`cbs`中的原始指针传递给它（第32行）。`doWork`函数被传递了一个对`CanBeShared`的引用（`obj`），并调用了它的`share`方法来获取相同对象的`shared_ptr`包装（第23行）。这个`shared_ptr`的引用计数现在变成了2（第25行），它包含的指针指向`obj`（第26行）。一旦`doWork`返回，`cbs`上的使用计数就会回到1（第34行）。
- en: The `shared_ptr` instance that is returned from the call to `shared_from_this`
    is constructed from a `weak_ptr` member instance in the `enable_shared_from_this<>`
    base and is only constructed at the end of the constructor of the wrapped object.
    Thus, if you called `shared_from_this` inside the constructor of your class, you
    would encounter a runtime error. You should also avoid calling it on raw pointers
    that are not already wrapped in a `shared_ptr` object or objects that are not
    dynamically constructed to start with. The C++11 Standard standardizes this facility
    as `std::enable_shared_from_this` available through the standard header file `memory`.
    We use `enable_shared_from_this` extensively while writing asynchronous TCP servers
    in [Chapter 11](ch11.html "Chapter 11. Network Programming Using Boost Asio"),
    *Network Programming Using Boost Asio*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从对`shared_from_this`的调用返回的`shared_ptr`实例是从`enable_shared_from_this<>`基类中的`weak_ptr`成员实例构造的，并且仅在包装对象的构造函数结束时构造。因此，如果你在类的构造函数中调用`shared_from_this`，你将遇到运行时错误。你还应该避免在尚未包装在`shared_ptr`对象中的原始指针上调用它，或者在开始时就不是动态构造的对象上调用它。C++11标准将这一功能标准化为`std::enable_shared_from_this`，可以通过标准头文件`memory`使用。我们在编写异步TCP服务器时广泛使用`enable_shared_from_this`，详见[第11章](ch11.html
    "第11章 网络编程使用Boost Asio") *网络编程使用Boost Asio*。
- en: If you are eagle-eyed, you would have noticed that we included just a single
    header file `boost/smart_ptr.hpp`. This is a convenient header file that brings
    together all the available smart pointer functionality into a single header file
    so that you don't have to remember to include multiple headers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有雄辩的眼力，你会注意到我们只包含了一个头文件`boost/smart_ptr.hpp`。这是一个方便的头文件，将所有可用的智能指针功能集成到一个头文件中，这样你就不必记得包含多个头文件。
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you can use C++11, then you should use `std::unique_ptr` in the majority
    of cases, and use `shared_ptr` only when you need shared ownership. If you are
    still on C++03 for some reason, you should look to leverage `boost::scoped_ptr`
    wherever possible, or use `boost::shared_ptr` with `boost::make_shared` for better
    performance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以使用C++11，那么在大多数情况下应该使用`std::unique_ptr`，只有在需要共享所有权时才使用`shared_ptr`。如果出于某种原因仍在使用C++03，你应该尽可能利用`boost::scoped_ptr`，或者使用`boost::shared_ptr`和`boost::make_shared`以获得更好的性能。
- en: Intrusive smart pointers – boost::intrusive_ptr
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 侵入式智能指针 - boost::intrusive_ptr
- en: Consider what happens when you wrap the same pointer in two different `shared_ptr`
    instances that are not copies of each other.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下当你将同一个指针包装在两个不是彼此副本的`shared_ptr`实例中会发生什么。
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, we created a `shared_ptr<Foo>` instance (line 5) and
    a second independent instance of `shared_ptr<Foo>`, using the same pointer as
    for the first one (line 6). The net effect is that two `shared_ptr<Foo>` instances
    both have a reference count of 1 (asserts on line 8) and both contain the same
    pointer (asserts on line 9). At the end of the scope, reference counts of both
    `f1` and `f2` go to zero and both try to call `delete` on the same pointer (line
    10). The code almost certainly crashes as a result of the double delete. The code
    is well-formed in the sense that it compiles, but hardly well-behaved. You need
    to guard against such usage of `shared_ptr<Foo>` but it also points to a limitation
    of `shared_ptr`. The limitation is due to the fact that there is no mechanism,
    given just the raw pointer, to tell whether it is already referenced by some smart
    pointer. The shared reference count is outside the `Foo` object and not part of
    it. `shared_ptr` is said to be nonintrusive.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`shared_ptr<Foo>`实例（第5行）和第二个独立的`shared_ptr<Foo>`实例，使用与第一个相同的指针（第6行）。其结果是两个`shared_ptr<Foo>`实例都具有引用计数为1（第8行的断言），并且都包含相同的指针（第9行的断言）。在作用域结束时，`f1`和`f2`的引用计数都变为零，并且都尝试在相同的指针上调用`delete`（第10行）。由于双重删除的结果，代码几乎肯定会崩溃。从编译的角度来看，代码是完全合法的，但行为却不好。您需要防范对`shared_ptr<Foo>`的这种使用，但这也指出了`shared_ptr`的一个局限性。这个局限性是由于仅凭借原始指针，无法判断它是否已被某个智能指针引用。共享引用计数在`Foo`对象之外，不是其一部分。`shared_ptr`被称为非侵入式。
- en: An alternative is to maintain the reference count as part of the object itself.
    This may not be feasible in some cases but will be perfectly acceptable in others.
    There may even be existing objects that actually maintain such reference counts.
    If you have ever used Microsoft's Component Object Model, you have used such objects.
    The `boost::intrusive_ptr` template is an intrusive alternative to `shared_ptr`
    that puts the onus of maintaining reference counts on the user, and uses user-provided
    hooks to increment and decrement the reference counts. If the user so wishes,
    the reference count could be part of the class layout. This has two advantages.
    The object and the reference count are located next to each other in memory, so
    there is better cache performance. Secondly, all instances of `boost::intrusive_ptr`
    use the same reference count to manage the life cycle of the object. Thus, independent
    `boost::intrusive_ptr` instances don't create any problems of double deletion.
    In fact, you can potentially use multiple different smart pointer wrappers for
    the same object at the same time as long as they use the same intrusive reference
    count.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将引用计数作为对象本身的一部分进行维护。在某些情况下可能不可行，但在其他情况下将是完全可接受的。甚至可能存在实际维护这种引用计数的现有对象。如果您曾经使用过Microsoft的组件对象模型，您就使用过这样的对象。`boost::intrusive_ptr`模板是`shared_ptr`的一种侵入式替代品，它将维护引用计数的责任放在用户身上，并使用用户提供的钩子来增加和减少引用计数。如果用户愿意，引用计数可以成为类布局的一部分。这有两个优点。对象和引用计数在内存中相邻，因此具有更好的缓存性能。其次，所有`boost::intrusive_ptr`实例使用相同的引用计数来管理对象的生命周期。因此，独立的`boost::intrusive_ptr`实例不会造成双重删除的问题。实际上，您可以潜在地同时为同一个对象使用多个不同的智能指针包装器，只要它们使用相同的侵入式引用计数。
- en: Using intrusive_ptr
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用intrusive_ptr
- en: 'To manage dynamically-allocated instances of type `X`, you create `boost::intrusive_ptr<X>`
    instances just as you would create other smart pointer instances. You just need
    to make sure that two global functions `intrusive_ptr_add_ref(X*)` and `intrusive_ptr_release(X*)`
    are available that take care of incrementing and decrementing the reference counts,
    and calling `delete` on the dynamically-allocated object if the reference count
    goes to zero. If `X` be part of a namespace, the two global functions too should
    ideally be defined in the same namespace to facilitate Argument Dependent Lookup.
    Thus, the reference counting and deletion mechanisms are both in control of the
    user, and `boost::intrusive_ptr` provides an RAII framework, which they are hooked
    into. Do note how the reference count is maintained is the user''s prerogative
    and incorrect implementations could cause leaks, crashes, or at the very least,
    inefficient code. Finally, here is some sample code that uses `boost::intrusive_ptr`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理类型为`X`的动态分配实例，您创建`boost::intrusive_ptr<X>`实例，就像创建其他智能指针实例一样。您只需要确保有两个全局函数`intrusive_ptr_add_ref(X*)`和`intrusive_ptr_release(X*)`可用，负责增加和减少引用计数，并在引用计数变为零时调用`delete`删除动态分配的对象。如果`X`是命名空间的一部分，那么这两个全局函数最好也应该在相同的命名空间中定义，以便进行参数相关查找。因此，用户控制引用计数和删除机制，并且`boost::intrusive_ptr`提供了一个RAII框架，它们被连接到其中。请注意，如何维护引用计数是用户的权利，不正确的实现可能会导致泄漏、崩溃，或者至少是低效的代码。最后，这里是一些使用`boost::intrusive_ptr`的示例代码：
- en: '**Listing 3.15: Using intrusive_ptr**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单3.15：使用intrusive_ptr**'
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We use `boost::intrusive_ptr` to wrap dynamically-allocated objects of class
    `Bar` (line 31). We can also copy one `intrusive_ptr<NS::Bar>` instance into another
    (line 32). The class `Bar` maintains its reference count in a member variable
    `refcount_` of type `unsigned long` (line 14). The `intrusive_ptr_add_ref` and
    `intrusive_ptr_release` functions are declared as friends of the class `Bar` (lines
    10 and 11) and are in the same namespace `NS` as `Bar` (lines 3-26). `intrusive_ptr_add_ref`
    increments `refcount_` each time it is called. `intrusive_ptr_release` decrements
    `refcount_` and calls `delete` on the pointer argument passed to it once `refcount_`
    goes to zero.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`boost::intrusive_ptr`来包装类`Bar`的动态分配对象（第31行）。我们还可以将一个`intrusive_ptr<NS::Bar>`实例复制到另一个实例中（第32行）。类`Bar`在成员变量`refcount_`中维护其引用计数，类型为`unsigned
    long`（第14行）。`intrusive_ptr_add_ref`和`intrusive_ptr_release`函数被声明为类`Bar`的友元（第10和11行），并且在与`Bar`相同的命名空间`NS`中（第3-26行）。`intrusive_ptr_add_ref`每次调用时都会增加`refcount_`。`intrusive_ptr_release`会减少`refcount_`并在`refcount_`变为零时对其参数指针调用`delete`。
- en: The class `Bar` initializes the variable `refcount_` to zero. We pass `true`
    for the Boolean second argument to the `intrusive_ptr` constructor so that the
    constructor increments `Bar`'s `refcount_` through a call to `intrusive_ptr_add_ref(NS::Bar*)`
    (line 31). This is the default behavior, and the Boolean second argument to the
    `intrusive_ptr` constructor defaults to `true`, so we did not really need to pass
    it explicitly. On the other hand, if we were dealing with a class that sets its
    reference count to 1 on initialization, not 0 as `Bar` does, then we would not
    like the constructor to increment the reference count again. In such cases, we
    should pass `false` for the second parameter to the `intrusive_ptr` constructor.
    The copy constructor always increments the reference count via a call to `intrusive_ptr_add_ref`.
    The destructor of each `intrusive_ptr` instance calls `intrusive_ptr_release`,
    passing it the encapsulated pointer.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Bar`将变量`refcount_`初始化为零。我们将布尔值的第二个参数传递给`intrusive_ptr`构造函数，以便构造函数通过调用`intrusive_ptr_add_ref(NS::Bar*)`来增加`Bar`的`refcount_`（第31行）。这是默认行为，`intrusive_ptr`构造函数的布尔值第二个参数默认为`true`，因此我们实际上不需要显式传递它。另一方面，如果我们处理的是一个在初始化时将其引用计数设置为1而不是0的类，那么我们不希望构造函数再次增加引用计数。在这种情况下，我们应该将第二个参数传递给`intrusive_ptr`构造函数为`false`。复制构造函数总是通过调用`intrusive_ptr_add_ref`增加引用计数。每个`intrusive_ptr`实例的析构函数调用`intrusive_ptr_release`，并将封装的指针传递给它。
- en: 'While the preceding example illustrates how you can use the `boost::intrusive_ptr`
    template, Boost provides some conveniences if you are managing dynamically-allocated
    objects. The `boost::intrusive_ref_counter` wraps some generic boilerplate code
    so that you don''t have to roll out so much of it yourself. The following example
    illustrates this use:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的示例说明了如何使用`boost::intrusive_ptr`模板，但如果你要管理动态分配的对象，Boost提供了一些便利。`boost::intrusive_ref_counter`包装了一些通用的样板代码，这样你就不必自己编写那么多了。以下示例说明了这种用法：
- en: '**Listing 3.16: Lesser code with intrusive_ptr**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单3.16：使用intrusive_ptr减少代码**'
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Instead of maintaining reference counts and providing namespace level overloads
    for `intrusive_ptr_add_ref` and `intrusive_ptr_release`, we just publicly inherit
    the class `Bar` from `boost::intrusive_ref_counter<Bar>`. This is all we need
    to do. This also makes it easy to get the reference count at any point, using
    the `use_count()` public member inherited from `intrusive_ref_counter<>` into
    `Bar`. Note that `use_count()` is not a member function of `intrusive_ptr` itself,
    so we have to use the dereference operator (`operator->`) to invoke it (lines
    21-24).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再维护引用计数，并为`intrusive_ptr_add_ref`和`intrusive_ptr_release`提供命名空间级别的重载，而是直接从`boost::intrusive_ref_counter<Bar>`公开继承类`Bar`。这就是我们需要做的全部。这也使得可以轻松地在任何时候获取引用计数，使用从`intrusive_ref_counter<>`继承到`Bar`的`use_count()`公共成员。请注意，`use_count()`不是`intrusive_ptr`本身的成员函数，因此我们必须使用解引用运算符(`operator->`)来调用它（第21-24行）。
- en: 'The reference counter used in the preceding example is not thread-safe. If
    you want to ensure reference count thread safety, edit the example to use the
    `boost::thread_safe_counter` policy class as the second type argument to `boost::intrusive_ref_counter`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中使用的引用计数器不是线程安全的。如果要确保引用计数的线程安全性，请编辑示例，使用`boost::thread_safe_counter`策略类作为`boost::intrusive_ref_counter`的第二个类型参数：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Curiously, `Bar` inherits from an instantiation of the `boost::intrusive_ref_counter`
    template, which takes `Bar` itself as a template argument. This is once again
    the Curiously Recurring Template Pattern at work.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`Bar`继承自`boost::intrusive_ref_counter`模板的一个实例化，该模板将`Bar`本身作为模板参数。这再次展示了奇特的递归模板模式的工作原理。
- en: shared_array
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: shared_array
- en: Just like `boost::scoped_ptr` had a corresponding template for specifically
    managing dynamically-allocated arrays, there is a template called `boost::shared_array`
    that can be used to wrap dynamically-allocated arrays and manage them with shared
    ownership semantics. Like `scoped_array`, `boost::shared_array` has an overloaded
    subscript operator (`operator[]`). Like `boost::shared_ptr`, it uses a shared
    reference count to manage the lifetime of the encapsulated array. Unlike `boost::shared_ptr`,
    there is no `weak_array` for `shared_array`. It is a convenient abstraction that
    can be used as a reference counted vector. I leave it to you to explore this further.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`boost::scoped_ptr`有一个专门用于管理动态分配数组的模板一样，有一个名为`boost::shared_array`的模板，可以用来包装动态分配的数组，并使用共享所有权语义来管理它们。与`scoped_array`一样，`boost::shared_array`有一个重载的下标运算符(`operator[]`)。与`boost::shared_ptr`一样，它使用共享引用计数来管理封装数组的生命周期。与`boost::shared_ptr`不同的是，`shared_array`没有`weak_array`。这是一个方便的抽象，可以用作引用计数的向量。我留给你进一步探索。
- en: Managing non-memory resources using smart pointers
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用智能指针管理非内存资源
- en: All the smart pointer classes we have seen so far assume that their resource
    is dynamically-allocated using the C++ `new` operator and requires deletion using
    the `delete` operator. The `scoped_array` and `shared_array` classes as well as
    `unique_ptr`'s array partial specialization assume that their resources are dynamically-allocated
    arrays and use the array `delete` operator (`delete[]`) to deallocate them. Dynamic
    memory is not the only resource that a program needs to manage in an exception-safe
    way, and smart pointers would be remiss to ignore this use case.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所见过的所有智能指针类都假设它们的资源是使用C++的`new`运算符动态分配的，并且需要使用`delete`运算符进行删除。`scoped_array`和`shared_array`类以及`unique_ptr`的数组部分特化都假设它们的资源是动态分配的数组，并使用数组`delete`运算符(`delete[]`)来释放它们。动态内存不是程序需要以异常安全方式管理的唯一资源，智能指针忽视了这种情况。
- en: 'The `shared_ptr` and `std::unique_ptr` templates can work with alternative
    user-specified deletion policies. This makes them fit to manage not just dynamic
    memory but almost any resource with explicit APIs for creation and deletion, such
    as C-style heap memory allocation and deallocation using `malloc` and `free`,
    open file streams, Unix open file descriptors and sockets, platform-specific synchronization
    primitives, Win32 API handles to various resources, and even user-defined abstractions.
    Here is a short example to round off the chapter:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`和`std::unique_ptr`模板可以使用替代的用户指定的删除策略。这使它们适用于管理不仅是动态内存，而且几乎任何具有显式创建和删除API的资源，例如使用`malloc`和`free`进行C风格堆内存分配和释放，打开文件流，Unix打开文件描述符和套接字，特定于平台的同步原语，Win32
    API句柄到各种资源，甚至用户定义的抽象。以下是一个简短的例子来结束本章：'
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We wrap the `FILE` pointer returned by `fopen` in a `shared_ptr<FILE>` object
    (line 18). However, the `shared_ptr` template knows nothing about `FILE` pointers,
    so we must also specify the deletion policy. For this, we define a function object
    called `FILEDeleter` (line 5), whose overloaded function call operator (`operator()`,
    line 7) takes a parameter of type `FILE` and calls `fclose` on it if it is not
    null (line 10). A temporary instance of `FILEDeleter` is passed to the constructor
    of `shared_ptr<FILE>` as a second, deleter argument (line 19). The destructor
    of `shared_ptr<FILE>` invokes the overloaded function call operator on the passed
    deleter object, passing the stored `FILE` pointer as argument. There is little
    use of the overloaded `operator->` in this case, so all operations on the wrapped
    pointer are performed by accessing the raw pointer using the `get` member function
    (line 24). We can also use a lambda expression in place of the `FILEDeleter` function
    object. We introduce lambda expressions in [Chapter 7](ch07.html "Chapter 7. Higher
    Order and Compile-time Programming"), *Higher Order and Compile-time Programming*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`fopen`返回的`FILE`指针包装在`shared_ptr<FILE>`对象中（第18行）。但是，`shared_ptr`模板对`FILE`指针一无所知，因此我们还必须指定删除策略。为此，我们定义了一个名为`FILEDeleter`的函数对象（第5行），它的重载函数调用运算符（`operator()`，第7行）接受`FILE`类型的参数，并在其上调用`fclose`（如果不为空）（第10行）。临时的`FILEDeleter`实例作为第二个删除器参数（第19行）传递给`shared_ptr<FILE>`的构造函数。`shared_ptr<FILE>`的析构函数调用传递的删除器对象上的重载函数调用运算符，将存储的`FILE`指针作为参数传递。在这种情况下，重载的`operator->`几乎没有用处，因此通过使用`get`成员函数访问原始指针执行包装指针的所有操作（第24行）。我们还可以在`FILEDeleter`函数对象的位置使用lambda表达式。我们在[第7章](ch07.html
    "第7章。高阶和编译时编程")中介绍Lambda表达式，*高阶和编译时编程*。
- en: 'If you have access to C++11, it is always better to use `std::unique_ptr` for
    such purposes. With `std::unique_ptr`, you have to specify a second template argument
    for the type of the deleter. The preceding example will use a `std::unique_ptr`
    with just the following edits:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以访问C++11，最好始终使用`std::unique_ptr`来实现这些目的。使用`std::unique_ptr`，您必须为删除器的类型指定第二个模板参数。前面的例子将使用一个`std::unique_ptr`，只需进行以下编辑：
- en: '[PRE31]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We include the C++ standard header file `memory` instead of `boost/shared_ptr.hpp`
    (line 1), and wrap the `FILE` pointer returned by the call to `fopen` in a `unique_ptr`
    instance (line 18), passing it a temporary instance of `FILEDeleter` (line 19).
    The only additional detail is the second type argument to the `unique_ptr` template,
    specifying the type of the deleter. We can also use a C++ 11 Lambda expression
    in place of the FILEDeleter function object. We will look at such use in later
    chapters, after we have introduced Lambda expressions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括C++标准头文件`memory`，而不是`boost/shared_ptr.hpp`（第1行），并将`fopen`调用返回的`FILE`指针包装在`unique_ptr`实例中（第18行），传递给它一个临时的`FILEDeleter`实例（第19行）。唯一的额外细节是`unique_ptr`模板的第二个类型参数，指定删除器的类型。我们还可以在FILEDeleter函数对象的位置使用C++
    11 Lambda表达式。在介绍Lambda表达式之后的章节中，我们将看到这种用法。
- en: Self-test questions
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'For multiple choice questions, choose all options that apply:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多项选择题，选择所有适用的选项：
- en: What are the Abraham's Exception Safety Guarantees?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 亚伯拉罕的异常安全性保证是什么？
- en: a. Basic, weak, and strong
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: a. 基本的，弱的，和强的
- en: b. Basic, strong, and no-throw
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: b. 基本的，强的，不抛出异常
- en: c. Weak, strong, and no-throw
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: c. 弱的，强的，不抛出异常
- en: d. None, basic, and strong
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: d. 无，基本的，和强的
- en: What are the main differences between `boost::scoped_ptr` and `std::unique_ptr`?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`boost::scoped_ptr`和`std::unique_ptr`之间的主要区别是什么？'
- en: a. `boost::scoped_ptr` does not support move semantics
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: a. `boost::scoped_ptr`不支持移动语义
- en: b. `std::scoped_ptr` has no partial specialization for arrays
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: b. `std::scoped_ptr`没有数组的部分特化
- en: c. `std::unique_ptr` can be stored in STL containers
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: c. `std::unique_ptr`可以存储在STL容器中
- en: d. `std::unique_ptr` supports custom deleters
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: d. `std::unique_ptr`支持自定义删除器
- en: Why is `boost::shared_ptr` heavier than other smart pointers?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么`boost::shared_ptr`比其他智能指针更重？
- en: a. It uses a shared reference counter
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: a. 它使用共享引用计数
- en: b. It supports both copy and move semantics
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: b. 它支持复制和移动语义
- en: c. It uses two allocations per encapsulated object
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: c. 它使用每个封装对象的两个分配
- en: d. It is not heavier than other smart pointers
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: d. 它不比其他智能指针更重
- en: What is the disadvantage of using `boost::make_shared` to create a `shared_ptr`?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`boost::make_shared`创建`shared_ptr`的缺点是什么？
- en: a. It is slower than directly instantiating `boost::shared_ptr`
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: a. 它比直接实例化`boost::shared_ptr`慢
- en: b. It is not thread safe
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: b. 它不是线程安全的
- en: c. It does not release object memory until all `weak_ptr` referents expire
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: c. 它直到所有`weak_ptr`引用过期才释放对象内存
- en: d. It is not available in C++11 Standard
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: d. 它在C++11标准中不可用
- en: What are the primary differences between `boost::shared_ptr` and `std::unique_ptr`?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`boost::shared_ptr`和`std::unique_ptr`之间的主要区别是什么？'
- en: a. `std::unique_ptr` does not support copy semantics
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: a. `std::unique_ptr`不支持复制语义
- en: b. `std::unique_ptr` does not support move semantics
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: b. `std::unique_ptr`不支持移动语义
- en: c. `boost::shared_ptr` does not support custom deleters
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: c. `boost::shared_ptr`不支持自定义删除器
- en: d. `boost::shared_ptr` cannot be used for arrays
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: d. `boost::shared_ptr`不能用于数组
- en: If you want to return a `shared_ptr<X>` wrapping the `this` pointer from a member
    function of class `X`, which of the following would work?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想从类`X`的成员函数中返回包装`this`指针的`shared_ptr<X>`，以下哪个会起作用？
- en: a. `return boost::shared_ptr<X>(this)`
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: a. `return boost::shared_ptr<X>(this)`
- en: b. `boost::enable_shared_from_this`
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: b. `boost::enable_shared_from_this`
- en: c. `boost::make_shared`
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: c. `boost::make_shared`
- en: d. `boost::enable_shared_from_raw`
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: d. `boost::enable_shared_from_raw`
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter formalized the requirements for exception safety of a piece of
    code, and then defined various means of managing dynamically-allocated objects
    in an exception-safe way using smart pointers. We looked at smart pointer templates
    both from Boost and ones that have been introduced by the new C++11 Standard,
    and understood the different ownership semantics and intrusive and nonintrusive
    reference counting. We also got a chance to look at ways of adapting some of the
    smart pointer templates for managing non-memory resources.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本章明确了代码异常安全性的要求，然后定义了使用智能指针以异常安全的方式管理动态分配对象的各种方法。我们研究了来自Boost和新的C++11标准引入的智能指针模板，并理解了不同的所有权语义以及侵入式和非侵入式引用计数。我们还有机会看看如何调整一些智能指针模板来管理非内存资源。
- en: Hopefully, you have understood the various ownership semantics and would be
    able to judiciously apply the techniques in this chapter to such scenarios. There
    are facilities in the smart pointer library that we did not cover in any significant
    detail, like `boost::shared_array` and `boost::enable_shared_from_raw`. You should
    explore them further on your own, focusing on their applicability and their pitfalls.
    In the next chapter, we will learn about some nifty and useful techniques for
    dealing with text data using Boost's string algorithms.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您已经理解了各种所有权语义，并能够明智地将本章中的技术应用于这些场景。在智能指针库中有一些我们没有详细介绍的功能，比如`boost::shared_array`和`boost::enable_shared_from_raw`。您应该自行进一步探索它们，重点关注它们的适用性和缺陷。在下一章中，我们将学习使用Boost的字符串算法处理文本数据的一些巧妙而有用的技术。
- en: References
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Rule of Zero: [http://en.cppreference.com/w/cpp/language/rule_of_three](http://en.cppreference.com/w/cpp/language/rule_of_three)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零规则：[http://en.cppreference.com/w/cpp/language/rule_of_three](http://en.cppreference.com/w/cpp/language/rule_of_three)
- en: '*Designing C++ Interfaces - Exception Safety*, *Mark Radford*: [http://accu.org/index.php/journals/444](http://accu.org/index.php/journals/444)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设计C++接口-异常安全性*，*Mark Radford*：[http://accu.org/index.php/journals/444](http://accu.org/index.php/journals/444)'
- en: '*Exception Safety Analysis*, *Andrei Alexandrescu and David B. Held*: [http://erdani.com/publications/cuj-2003-12.pdf](http://erdani.com/publications/cuj-2003-12.pdf)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*异常安全性分析*，*Andrei Alexandrescu和David B. Held*：[http://erdani.com/publications/cuj-2003-12.pdf](http://erdani.com/publications/cuj-2003-12.pdf)'
