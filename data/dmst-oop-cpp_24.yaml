- en: '*Chapter 20*: Removing Implementation Details Using the pImpl Pattern'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第20章*：使用pImpl模式去除实现细节'
- en: This chapter will wrap up our quest to expand your C++ programming repertoire
    beyond core OOP concepts, with the objective of further empowering you to solve
    recurring types of coding problems, utilizing common design patterns. Incorporating
    design patterns in your coding can not only provide refined solutions but also
    contribute to easier code maintenance and provide the potential for code reuse.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将结束我们扩展您的C++编程技能的探索，超越核心面向对象编程概念，旨在进一步赋予您解决重复类型的编码问题的能力，利用常见的设计模式。在编码中应用设计模式不仅可以提供精炼的解决方案，还可以有助于更轻松地维护代码，并提供代码重用的潜力。
- en: The next design pattern that we will learn how to implement effectively in C++
    is the **pImpl pattern**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何在C++中有效实现**pImpl模式**的下一个设计模式。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Comprehending the pImpl pattern and how it reduces compile-time dependencies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解pImpl模式以及它如何减少编译时的依赖关系
- en: Understanding how to implement the pImpl pattern in C++ using association and
    unique pointers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何在C++中使用关联和唯一指针实现pImpl模式
- en: Recognizing performance issues relating to pImpl and necessary trade-offs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别与pImpl相关的性能问题和必要的权衡
- en: By the end of this chapter, you will understand the pImpl pattern and how it
    can be used to separate implementation details from a class interface to reduce
    compiler dependencies. Adding an additional design pattern to your skillset will
    help you become a more valuable programmer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，您将了解pImpl模式以及如何使用它来将实现细节与类接口分离，以减少编译器依赖性。将额外的设计模式添加到您的技能集中将帮助您成为更有价值的程序员。
- en: Let's increase our programming skillset by examining another common design pattern,
    the pImpl pattern.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过研究另一个常见的设计模式，pImpl模式，来增强我们的编程技能。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Online code for full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter20` in a file named `Chp20-Ex1.cpp` under the aforementioned GitHub directory.
    Some programs are in applicable subdirectories as indicated in the examples.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下GitHub URL找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20)。每个完整程序示例都可以在GitHub存储库中找到，位于相应章节标题（子目录）下的文件中，文件名与所在章节编号相对应，后跟破折号，再跟随该章节中的示例编号。例如，本章的第一个完整程序可以在名为`Chp20-Ex1.cpp`的文件中的`Chapter20`子目录中找到上述GitHub目录。一些程序位于适用的子目录中，如示例中所示。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/2OT5K1W](https://bit.ly/2OT5K1W).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下链接观看：[https://bit.ly/2OT5K1W](https://bit.ly/2OT5K1W)。
- en: Understanding the pImpl pattern
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解pImpl模式
- en: The **pImpl pattern** (**p**ointer to **Impl**ementation idiom) is a structural
    design pattern that separates the implementation of a class from its public interface.
    This pattern was originally known as the **Bridge pattern** by the **Gang of Four**
    (**GofF**) and is also known as the **Cheshire Cat**, **compiler-firewall idiom**,
    **d-pointer**, **opaque pointer**, or **Handle pattern**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**pImpl模式**（**p**ointer to **Impl**ementation idiom）是一种结构设计模式，它将类的实现与其公共接口分离。这种模式最初被**四人组**（**GofF**）称为**桥接模式**，也被称为**切尔西猫**，**编译器防火墙习惯**，**d指针**，**不透明指针**或**句柄模式**。'
- en: The primary purpose of this pattern is to minimize compile-time dependencies.
    The result of reducing compile-time dependencies is that changes in a class definition
    (most notably, the private access region) will not send a wave of timely recompilations
    throughout a developing or deployed application. Instead, the necessary recompiled
    code can be isolated to the *implementation* of the class itself. The other pieces
    of the application that depend on the class definition will no longer be affected
    by a recompile.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式的主要目的是最小化编译时的依赖关系。减少编译时的依赖关系的结果是，类定义（尤其是私有访问区域）的更改不会在开发或部署的应用程序中引发及时的重新编译。相反，必要的重新编译代码可以被隔离到类本身的*实现*中。依赖于类定义的应用程序的其他部分将不再受重新编译的影响。
- en: Private members within a class definition can affect a class with respect to
    re-compilation. This is because changing the data members can alter the size of
    an instance of that type. Also, private member functions must be matched by signature
    to function calls for overloading resolution as well as potential type conversions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义中的私有成员可能会影响类的重新编译。这是因为更改数据成员可能会改变该类型的实例的大小。此外，私有成员函数必须与函数调用的签名匹配，以进行重载解析以及潜在的类型转换。
- en: The manner in which traditional header (`.h`) and source code files (`.cpp`)
    specify dependencies triggers re-compilation. By removing the class inner implementation
    details from a class header file (and placing these details in a source file),
    we can remove many dependencies. We can change which header files are included
    in other header and source code files, streamlining the dependencies and hence
    the re-compilation burden.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的头文件（`.h`）和源代码文件（`.cpp`）指定依赖关系的方式会触发重新编译。通过将类内部实现细节从类头文件中移除（并将这些细节放在源文件中），我们可以消除许多依赖关系。我们可以更改其他头文件在其他头文件和源代码文件中的包含方式，简化依赖关系，从而减轻重新编译的负担。
- en: 'The pImpl pattern will compel the following adjustments to a class definition:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: pImpl模式将迫使对类定义进行以下调整：
- en: Private (non-virtual) members will instead be replaced by a pointer to a nested
    class type that includes the former private data members and methods. A forward
    declaration to the nested class will also be necessary.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有（非虚拟）成员将被替换为指向嵌套类类型的指针，该类型包括以前的私有数据成员和方法。嵌套类的前向声明也是必要的。
- en: The pointer to the implementation (`pImpl`) will be an association to which
    method calls of the class implementation will be delegated.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向实现的指针（`pImpl`）将是一个关联，类实现的方法调用将被委托给它。
- en: The revised class definition will exist in a header file for the class embracing
    this idiom. Any formerly included header files that this header file once depended
    upon will now be moved to instead be inclusions in the source code file for this
    class.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修订后的类定义将存在于一个采用这种习惯用法的类的头文件中。以前包含在这个头文件中的任何头文件现在将被移动到该类的源代码文件中。
- en: Other classes including the header file of a pImpl class will now not face re-compilation
    should the implementation of the class within its private access region be modified.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，其他类包括pImpl类的头文件将不会面临重新编译，如果类的实现在其私有访问区域内被修改。
- en: To effectively manage dynamic memory resources of the associated object that
    represents the implementation, we will use a unique pointer (smart pointer).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了有效地管理代表实现的关联对象的动态内存资源，我们将使用一个唯一指针（智能指针）。
- en: The compilation freedom within the revised class definition takes advantage
    of the fact that pointers only require a forward declaration of the class type
    of the pointer to compile.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 修订后的类定义中的编译自由度利用了指针只需要类类型的前向声明才能编译的事实。
- en: Let's move forward to examine a basic, then a refined, implementation of the
    pImpl pattern.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续检查pImpl模式的基本实现，然后是精炼的实现。
- en: Implementing the pImpl pattern
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现pImpl模式
- en: In order to implement the pImpl pattern, we will need to revisit the typical
    header and source file composition. We will then replace the private members in
    a typical class definition with a pointer to the implementation, taking advantage
    of an association. The implementation will be encapsulated within a nested class
    of our target class. Our pImpl pointer will delegate all requests to our associated
    object, which provides the inner class details or implementation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现pImpl模式，我们需要重新审视典型的头文件和源文件组成。然后，我们将用指向实现的指针替换典型类定义中的私有成员，利用关联。实现将被封装在我们目标类的嵌套类中。我们的pImpl指针将把所有请求委托给我们的关联对象，该对象提供内部类的详细信息或实现。
- en: The inner (nested) class will be referred to as the **implementation class**.
    The original, now outer, class will be referred to as the **target** or **interface
    class**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 内部（嵌套）类将被称为**实现类**。原始的、现在是外部的类将被称为**目标**或**接口类**。
- en: We will start by reviewing the typical (non-pImpl pattern) file composition
    containing class definitions and member function definitions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先回顾典型（非pImpl模式）文件组成，其中包含类定义和成员函数定义。
- en: Organizing file and class contents to apply the pattern basics
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织文件和类内容以应用模式基础知识
- en: Let's first review the organization strategy of the typical C++ class with respect
    to file placement regarding the class definition and member function definitions.
    We will next consider the revised organization strategy of a class utilizing the
    pImpl pattern.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们回顾一下典型的C++类的组织策略，关于类定义和成员函数定义的文件放置。接下来，我们将考虑使用pImpl模式的类的修订组织策略。
- en: Reviewing typical file and class layout
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回顾典型的文件和类布局
- en: Let's take a look at a typical class definition and how we previously have organized
    a class with respect to source and header files, such as in our discussions in
    [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199), *Exploring Classes
    in Detail*, and in [*Chapter 15*](B15702_15_Final_NM_ePub.xhtml#_idTextAnchor572),
    *Testing OO Programs and Components*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下典型的类定义，以及我们以前如何组织类与源文件和头文件相关的内容，比如我们在[*第5章*]（B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199）中的讨论，*详细探讨类*，以及[*第15章*]（B15702_15_Final_NM_ePub.xhtml#_idTextAnchor572），*测试OO程序和组件*。
- en: 'Recall, we organized each class into a header (`.h`) file, containing the class
    definition and inline function definitions, plus a corresponding source code (`.cpp`)
    file containing the non-inline member function definitions. Let''s review a familiar
    sample class definition, `Person`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们将每个类组织成一个头（`.h`）文件，其中包含类定义和内联函数定义，以及一个相应的源代码（`.cpp`）文件，其中包含非内联成员函数定义。让我们回顾一个熟悉的样本类定义，`Person`：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the aforementioned header file (`Person.h`), we have included our class definition
    for `Person` as well as inline function definitions for the class. Any larger
    inline function definitions not appearing within the class definition (indicated
    with the keyword `inline` in the prototype) would also appear in this file, after
    the class definition itself. Notice the use of preprocessor directives to ensure
    that a class definition is only included once per compilation unit.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的头文件（`Person.h`）中，我们已经包含了我们的`Person`类的类定义，以及类的内联函数定义。任何不在类定义中出现的较大的内联函数定义（在原型中使用关键字`inline`表示）也会出现在这个文件中，在类定义本身之后。请注意使用预处理指令来确保每个编译单元只包含一次类定义。
- en: 'Let''s next review the contents of the corresponding source code file, `Person.cpp`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们回顾相应的源代码文件`Person.cpp`的内容：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previously defined source code file, we define all the non-inline member
    functions for the class, `Person`. Though not all methods are shown, all can be
    found in our GitHub code. Also, should the class definition contain any static
    data members, the definition of the external variable, designating the memory
    for this member, should be included in the source code file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前定义的源代码文件中，我们为类`Person`定义了所有非内联成员函数。虽然并非所有方法都显示出来，但所有方法都可以在我们的GitHub代码中找到。此外，如果类定义包含任何静态数据成员，应该在源代码文件中包含外部变量的定义，指定这个成员的内存。
- en: Let's now consider how we can remove the implementation details from the `Person`
    class definition and its corresponding header file, by applying the pImpl pattern.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑如何通过应用pImpl模式，从`Person`类定义及其对应的头文件中删除实现细节。
- en: Applying the pImpl pattern with revised class and file layout
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用修订后的类和文件布局的pImpl模式
- en: To employ the pImpl pattern, we will reorganize our class definition and its
    respective implementation. We will add a nested class within our existing class
    definition to represent the private members of our original class and the core
    of its implementation. Our outer class will include a pointer of the inner class
    type, serving as an association to our implementation. Our outer class will delegate
    all implementation requests to the inner, associated object. We will restructure
    the placement of classes and source code within the header and source code files.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用pImpl模式，我们将重新组织我们的类定义及其相应的实现。我们将在现有类定义中添加一个嵌套类，以表示原始类的私有成员和其实现的核心。我们的外部类将包括一个指向内部类类型的指针，作为与我们实现的关联。我们的外部类将把所有实现请求委托给内部关联对象。我们将重新构造头文件和源代码文件中类和源代码的放置方式。
- en: 'Let''s take a closer look at our revised implementation for our class to understand
    each new detail required to implement the pImpl pattern. This example, comprised
    of a source file `PersonImpl.cpp` and one header file `Person.h`, can be found
    in the same directory as a simple driver to test the pattern in our GitHub repository.
    To make a complete executable, you will need to compile and link together `PersonImp.cpp`
    and `Chp20-Ex1.cpp` (the driver), found in this same directory. Here is the GitHub
    repository URL for the driver:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看一下我们修订后的类的实现，以了解实现pImpl模式所需的每个新细节。这个例子由一个源文件`PersonImpl.cpp`和一个头文件`Person.h`组成，可以在与我们的GitHub存储库中测试该模式的简单驱动程序相同的目录中找到。为了创建一个完整的可执行文件，您需要编译和链接`PersonImp.cpp`和`Chp20-Ex1.cpp`（驱动程序），这两个文件都在同一个目录中。以下是驱动程序的GitHub存储库URL：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20/Chp20-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20/Chp20-Ex1.cpp)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20/Chp20-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20/Chp20-Ex1.cpp)'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our aforementioned revised class definition for `Person`, notice that we
    have removed the data members in the private access region. Any non-virtual private
    methods, had they existed, would have also been removed. Instead, we include a
    forward declaration to our nested class with `class PersonImpl;`. We also declare
    a pointer to the implementation using `PersonImpl *pImpl;`, which represents an
    association to the nested class members encapsulating the implementation. In our
    initial implementation, we will use a native (raw) C++ pointer to specify the
    association to the nested class. We will subsequently revise our implementation
    to utilize a *unique pointer*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面提到的`Person`的修订类定义中，请注意我们已经删除了私有访问区域中的数据成员。任何非虚拟的私有方法，如果存在的话，也将被删除。相反，我们使用`class
    PersonImpl;`对我们的嵌套类进行了前向声明。我们还声明了一个指向实现的指针，使用`PersonImpl *pImpl;`，它代表了封装实现的嵌套类成员的关联。在我们的初始实现中，我们将使用一个本地（原始的）C++指针来指定与嵌套类的关联。随后我们将修改我们的实现以利用*unique
    pointer*。
- en: Notice that our public interface for `Person` is much as before. All of our
    existing public and protected methods exist as expected, interface-wise. We notice,
    however, that the inline functions (which depend on the implementation of the
    data members) have been replaced with non-inline member function prototypes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的`Person`的公共接口与以前大致相同。所有现有的公共和受保护的方法都存在于预期的接口中。然而，我们注意到依赖于数据成员实现的内联函数已被替换为非内联成员函数原型。
- en: 'Let''s move forward to see the class definition for our nested class, `PersonImpl`,
    as well as the placement of the member functions of `PersonImpl` and `Person`
    in a common source code file, `PersonImpl.cpp`. We will start with the nested
    `PersonImpl` class definition:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看一下我们嵌套类`PersonImpl`的类定义，以及`PersonImpl`和`Person`的成员函数在一个共同的源代码文件`PersonImpl.cpp`中的放置。我们将从嵌套`PersonImpl`类定义开始：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previously mentioned nested class definition for `PersonImpl`, notice
    that this class looks surprisingly similar to the original class definition for
    `Person`. We have private data members and a full host of member function prototypes,
    even some inline functions written for brevity (which won't actually be inlined
    because they are virtual). `PersonImpl` represents the implementation for `Person`,
    so it is crucial that this class can access all data and implement each method
    fully. Notice that the scope resolution operator (`::`) in the definition of `class
    Person::PersonImpl` is used to specify that `PersonImpl` is a nested class of
    `Person`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面提到的`PersonImpl`的嵌套类定义中，请注意这个类看起来与`Person`的原始类定义非常相似。我们有私有数据成员和一整套成员函数原型，甚至为了简洁起见编写了一些内联函数（实际上不会被内联，因为它们是虚拟的）。`PersonImpl`代表了`Person`的实现，因此这个类能够访问所有数据并完全实现每个方法是至关重要的。请注意，在`class
    Person::PersonImpl`的定义中，作用域解析运算符(`::`)用于指定`PersonImpl`是`Person`的嵌套类。
- en: 'Let''s continue by taking a look at the member function definitions for `PersonImpl`,
    which will appear in the same source file, `PersonImpl.cpp`, as the class definition.
    Though some methods have been abbreviated, their full online code is available
    in our GitHub repository:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看一下`PersonImpl`的成员函数定义，它们将出现在与类定义相同的源文件`PersonImpl.cpp`中。尽管一些方法已经被缩写，但它们的完整在线代码在我们的GitHub存储库中是可用的：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the aforementioned code, we see the implementation for the overall `Person`
    class using the nested class `PersonImpl`. We see the member function definitions
    for `PersonImpl` and notice that the bodies of these methods are exactly how we
    previously implemented the methods in our original `Person` class without the
    pImpl pattern. Again, we notice the use of the scope resolution operator (`::`)
    to specify the class name for each member function definition, such as `void Person::PersonImpl::Print()
    const`. Here, `Person::PersonImpl` indicates the nested class of `PersonImpl`
    within the `Person` class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们看到了使用嵌套类`PersonImpl`实现整体`Person`类的代码。我们看到了`PersonImpl`的成员函数定义，并注意到这些方法的实现方式与我们之前在原始`Person`类中实现方法的方式完全相同，而没有使用pImpl模式。同样，我们注意到使用了作用域解析运算符(`::`)来指定每个成员函数定义的类名，比如`void
    Person::PersonImpl::Print() const`。在这里，`Person::PersonImpl`表示`Person`类中的`PersonImpl`嵌套类。
- en: 'Next, let''s take a moment to review the member function definitions for `Person`,
    our class employing the pImpl pattern. These methods will additionally contribute
    to the `PersonImpl.cpp` source code file and can be found in our GitHub repository:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们花一点时间来审查`Person`的成员函数定义，我们的类使用了pImpl模式。这些方法还将为`PersonImpl.cpp`源代码文件做出贡献，并且可以在我们的GitHub存储库中找到：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the aforementioned member function definitions for `Person`, we notice that
    all methods delegate the required work to the nested class via the association
    `pImpl`. In our constructors, we allocate the associated `pImpl` object and initialize
    it appropriately (using the member initialization list of each constructor). Our
    destructor is responsible for deleting the associated object using `delete pImpl;`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述`Person`的成员函数定义中，我们注意到所有方法都通过关联`pImpl`委托所需的工作给嵌套类。在我们的构造函数中，我们分配了关联的`pImpl`对象并适当地初始化它（使用每个构造函数的成员初始化列表）。我们的析构函数负责使用`delete
    pImpl;`删除关联对象。
- en: Our `Person` copy constructor will set member `pImpl` to the newly allocated
    memory, while invoking the `PersonImpl` copy constructor for the nested object
    creation and initialization, passing `*(pers.pImpl)` to the nested object's copy
    constructor. That is, `pers.pImpl` is a pointer so we dereference the pointer
    using `*` to obtain a referenceable object for the `PersonImpl` copy constructor.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Person`复制构造函数将会将成员`pImpl`设置为新分配的内存，同时调用嵌套对象的`PersonImpl`复制构造函数进行对象的创建和初始化，将`*(pers.pImpl)`传递给嵌套对象的复制构造函数。也就是说，`pers.pImpl`是一个指针，所以我们使用`*`对指针进行解引用，以获得可引用的对象，用于`PersonImpl`的复制构造函数。
- en: We use a similar strategy in our overloaded assignment operator for `Person`.
    That is, there are no data members other than `pImpl` to perform a deep assignment,
    so we merely call the `PersonImpl` assignment operator on associated object `pImpl`,
    again passing in `*(p.pImpl)` as the right-hand value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Person`的重载赋值运算符中使用了类似的策略。也就是说，除了`pImpl`之外，没有其他数据成员来执行深度赋值，因此我们只是在关联对象`pImpl`上调用`PersonImpl`的赋值运算符，再次将`*(p.pImpl)`作为右值传入。
- en: Finally, let us consider a sample driver to demonstrate our pattern in action.
    Interestingly, our driver will work with either our originally specified non-pattern
    class (source and header files) or with our revised pImpl pattern-specific source
    and header files!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑一个示例驱动程序，以演示我们模式的运行情况。有趣的是，我们的驱动程序将使用我们最初指定的非模式类（源文件和头文件）或我们修改后的pImpl模式特定源文件和头文件！
- en: Bringing the pattern components together
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将模式组件组合在一起
- en: 'Let''s finally take a look at our `main()` function in our driver source file,
    `Chp20-Ex1.cpp`, to see how our pattern is orchestrated:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看我们驱动程序源文件`Chp20-Ex1.cpp`中的`main()`函数：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Reviewing our aforementioned `main()` function, we simply dynamically allocate
    several `Person` instances, call `Person` method(s) on the instances, and then
    delete each instance. We have included the `Person.h` header file, as expected,
    to be able to utilize this class. From the Client's point of view, everything
    looks *as usual* and pattern unspecific.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 审查我们上述的`main()`函数，我们只是动态分配了几个`Person`实例，调用了实例的`Person`方法，然后删除了每个实例。我们已经包含了`Person.h`头文件，如预期的那样，以便能够使用这个类。从客户端的角度来看，一切看起来*像往常一样*，并且与模式无关。
- en: Note that we separately compile `PersonImp.cpp` and `Chp20-Ex1.cpp`, linking
    the object files together into an executable. However, due to the pImpl pattern,
    if we change the implementation for `Person`, the change will be encapsulated
    by its implementation in the `PersonImp` nested class. Only `PersonImp.cpp` will
    require recompilation. The Client will not need to be recompiled in the driver,
    `Chp20-Ex1.cpp`, because the changes will not have occurred in the `Person.h`
    header file (which the driver depends on).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们分别编译`PersonImp.cpp`和`Chp20-Ex1.cpp`，将对象文件链接在一起成为可执行文件。然而，由于pImpl模式，如果我们改变了`Person`的实现，这种改变将被封装在`PersonImp`嵌套类的实现中。只有`PersonImp.cpp`需要重新编译。客户端不需要在驱动程序`Chp20-Ex1.cpp`中重新编译，因为更改不会发生在驱动程序依赖的`Person.h`头文件中。
- en: 'Let''s take a look at the output for this program:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个程序的输出。
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the aforementioned output, we see the expected results of our simple driver.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们看到了我们简单驱动程序的预期结果。
- en: Let's move forward to consider how we may improve our implementation of the
    pImpl pattern using a unique pointer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续考虑如何通过使用独特指针来改进我们的pImpl模式的实现。
- en: Improving the pattern with a unique pointer
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用独特指针改进模式
- en: Our initial implementation using an association with a native C++ pointer relieves
    many compiler dependencies. This is because the compiler only needs to see a forward
    class declaration of the pImpl pointer type in order to compile successfully.
    So far, we have achieved the core goal of using the pImpl pattern – reducing recompilation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与本机C++指针关联的关联来实现的初始实现减轻了许多编译器依赖。这是因为编译器只需要看到pImpl指针类型的前向类声明，才能成功编译。到目前为止，我们已经实现了使用pImpl模式的核心目标-减少重新编译。
- en: However, there is always criticism of using native or *raw* pointers. We are
    responsible for managing the memory ourselves, including remembering to delete
    the allocated nested class type in our outer class destructor. Memory leaks, memory
    misuse, and memory errors are potential drawbacks of managing memory resources
    ourselves with raw pointers. For that reason, it is customary to implement the
    pImpl pattern using **smart pointers**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，总是有人批评使用本机或*原始*指针。我们需要自己管理内存，包括记住在外部类析构函数中删除分配的嵌套类类型。内存泄漏、内存滥用和内存错误是使用原始指针自己管理内存资源的潜在缺点。因此，习惯上使用**智能指针**来实现pImpl模式。
- en: We will continue our quest to implement pImpl by examining a key component often
    used with the pImpl pattern – smart pointers, more specifically, the `unique_ptr`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续实现pImpl的任务，通过检查通常与pImpl模式一起使用的关键组件——智能指针，更具体地说是`unique_ptr`。
- en: Let's start by understanding smart pointer basics.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从理解智能指针的基础知识开始。
- en: Understanding smart pointers
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解智能指针
- en: To implement the pImpl pattern customarily, we must first understand smart pointers.
    A **smart pointer** is a small wrapper class that encapsulates a raw pointer,
    ensuring that the pointer it contains is automatically deleted when the wrapper
    object goes out of scope. The class implementing the smart pointer can be implemented
    using templates to create a smart pointer for any data type.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了习惯性地实现pImpl模式，我们必须首先了解智能指针。**智能指针**是一个小的包装类，封装了一个原始指针，确保它包含的指针在包装对象超出范围时自动删除。实现智能指针的类可以使用模板来为任何数据类型创建智能指针。
- en: 'Here is a very simple example of a smart pointer. This example can be found
    in our GitHub:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的智能指针示例。这个示例可以在我们的GitHub上找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20/Chp20-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20/Chp20-Ex2.cpp)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20/Chp20-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20/Chp20-Ex2.cpp)'
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the previously defined, straightforward `SmartPointer` class, we simply encapsulate
    a raw pointer. The key benefit is that the `SmartPointer` destructor will ensure
    that the raw pointer is destructed when the wrapper object is popped off the stack
    (for local instances) or before the program terminates (for static and extern
    instances). Certainly, this class is basic, and we must determine the desired
    behaviors for the copy constructor and the assignment operator. That is, allow
    shallow copies/assignment, require deep copies/assignment, or disallow all copies/assignment.
    Nonetheless, we can now visualize the concept of a smart pointer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前定义的简单`SmartPointer`类中，我们只是封装了一个原始指针。关键好处是，当包装对象从堆栈中弹出（对于局部实例）或在程序终止之前（对于静态和外部实例）时，`SmartPointer`析构函数将确保原始指针被销毁。当然，这个类很基础，我们必须确定复制构造函数和赋值运算符的期望行为。也就是说，允许浅复制/赋值，要求深复制/赋值，或者禁止所有复制/赋值。尽管如此，我们现在可以想象智能指针的概念。
- en: 'Here is the output for our smart pointer example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们智能指针示例的输出：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The aforementioned output shows that the memory for each object contained within
    a `SmartPointer` is managed for us. We can quite easily see with the `"SmartPtr
    Destructor"` output strings that the destructor for each object is called on our
    behalf when the local objects in `main()` go out of scope and are popped off the
    stack.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，`SmartPointer` 中包含的每个对象的内存都是由我们管理的。我们可以很容易地通过`"SmartPtr Destructor"`输出字符串看到，当`main()`中的局部对象超出范围并从堆栈中弹出时，每个对象的析构函数会代表我们被调用。
- en: Understanding unique pointers
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解唯一指针
- en: A `unique_ptr` in the Standard C++ Library, is a type of smart pointer that
    encapsulates exclusive ownership and access to a given heap memory resource. A
    `unique_ptr` cannot be duplicated; the owner of a `unique_pointer` will have sole
    use of that pointer. Owners of unique pointers can choose to move these pointers
    to other resources, but the repercussions are that the original resource will
    no longer contain the `unique_pointer`. We must `#include <memory>` to include
    the definition for `unique_ptr`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C++库中的`unique_ptr`是一种智能指针，它封装了对给定堆内存资源的独占所有权和访问权限。`unique_ptr`不能被复制；`unique_pointer`的所有者将独占该指针的使用权。唯一指针的所有者可以选择将这些指针移动到其他资源，但后果是原始资源将不再包含`unique_pointer`。我们必须`#include
    <memory>`来包含`unique_ptr`的定义。
- en: 'Modifying our smart pointer program to instead utilize `unique_pointer`, we
    now have:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 修改我们的智能指针程序，改用`unique_pointer`，现在我们有：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our output will be similar to the `SmartPointer` example; the difference is
    that no `"SmartPtr Destructor"` call message will be displayed (as we are using
    a `unique_ptr` instead). Notice that because we included `using namespace std;`,
    we did not need to qualify `unique_ptr` with `std::` in the unique pointer declaration.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出将类似于`SmartPointer`示例；不同之处在于不会显示`"SmartPtr Destructor"`调用消息（因为我们使用的是`unique_ptr`）。请注意，因为我们包含了`using
    namespace std;`，所以在唯一指针声明中我们不需要用`std::`来限定`unique_ptr`。
- en: With this knowledge, let's add unique pointers to our pImpl pattern.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个知识，让我们将唯一指针添加到我们的pImpl模式中。
- en: Adding unique pointers to the pattern
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将唯一指针添加到模式中
- en: 'To implement the pImpl pattern using a `unique_ptr`, we will make minimal changes
    to our previous implementation, starting with our `Person.h` header file. The
    full program example of our pImpl pattern utilizing a `unique_ptr` can be found
    in our GitHub repository and will additionally include a revised file for `PersonImpl.cpp`.
    Here is the URL for the driver, `Chp20-Ex3.cpp`; note the subdirectory in our
    GitHub repository for this complete example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`unique_ptr`实现pImpl模式，我们将对先前的实现进行最小的更改，从我们的`Person.h`头文件开始。我们的pImpl模式利用`unique_ptr`的完整程序示例可以在我们的GitHub存储库中找到，并且还将包括一个修订后的`PersonImpl.cpp`文件。这是驱动程序`Chp20-Ex3.cpp`的URL；请注意我们的GitHub存储库中的子目录，用于这个完整示例：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20/unique/Chp20-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20/unique/Chp20-Ex3.cpp)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20/unique/Chp20-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter20/unique/Chp20-Ex3.cpp)'
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice, in the revised aforementioned class definition for `Person`, the unique
    pointer declaration of `std::unique_ptr<PersonImpl> pImpl;`. Here, we use the
    `std::` qualifier because the standard namespace has not been explicitly included
    in our header file. We also `#include <memory>` to gain the definition for `unique_ptr`.
    The remainder of the class is identical to our initial implementation of pImpl
    using an association implemented with a raw pointer.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面修改过的`Person`类定义中，有`std::unique_ptr<PersonImpl> pImpl;`的独占指针声明。在这里，我们使用`std::`限定符，因为标准命名空间没有在我们的头文件中明确包含。我们还`#include
    <memory>`来获取`unique_ptr`的定义。类的其余部分与我们最初使用原始指针实现的pImpl实现是相同的。
- en: 'Next, let''s understand the extent to which our source code needs to be modified
    from our initial pImpl implementation. Let''s now take a look at the necessary
    modified member functions in our source file, `PersonImpl.cpp`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解一下我们的源代码需要从最初的pImpl实现中进行多少修改。现在让我们来看一下我们源文件`PersonImpl.cpp`中需要修改的成员函数：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Taking a look at the aforementioned member functions requiring modification,
    we see that it is only the `Person` destructor! Because we are using a unique
    pointer to implement the association to the nested class implementation, we no
    longer need to manage the memory for this resource ourselves. That's pretty nice!
    With these minor changes, our pImpl pattern now features a `unique_ptr` to designate
    the implementation of the class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面提到需要修改的成员函数，我们发现只有`Person`的析构函数！因为我们使用了一个独占指针来实现对嵌套类实现的关联，我们不再需要自己管理这个资源的内存。这非常好！通过这些小的改变，我们的pImpl模式现在使用`unique_ptr`来指定类的实现。
- en: Next, let's examine some of the performance issues relating to using the pImpl
    pattern.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来检查一些与使用pImpl模式相关的性能问题。
- en: Understanding pImpl pattern trade-offs
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解pImpl模式的权衡取舍。
- en: Incorporating the pImpl pattern into production code has both benefits and disadvantages.
    Let's review each so that we can better understand the circumstances that may
    warrant deploying this pattern.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将pImpl模式纳入生产代码中既有好处又有缺点。让我们分别审查一下，以便更好地理解可能需要部署这种模式的情况。
- en: The negligible performance issues encompass most of the disadvantages. That
    is, nearly every request made of the target (interface) class will need to be
    delegated to its nested implementation class. The only requests that can be handled
    by the outer class will be those not involving any data members; those circumstances
    will be extraordinarily rare! Another disadvantage includes slightly higher memory
    requirements of instances to accommodate the added pointer as part of the pattern
    implementation. These issues will be paramount in embedded software systems and
    those requiring peak performance, but relatively minor otherwise.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 可忽略的性能问题包括大部分的缺点。也就是说，几乎每个对目标（接口）类的请求都需要委托给其嵌套实现类。唯一可以由外部类处理的请求是那些不涉及任何数据成员的请求；这种情况将非常罕见！另一个缺点包括实例需要更高的内存需求来容纳作为模式实现的一部分添加的指针。这些问题在嵌入式软件系统和需要最佳性能的系统中将是至关重要的，但在其他情况下相对较小。
- en: Maintenance will be a little more difficult for classes employing the pImpl
    pattern, an unfortunate disadvantage. Each target class is now paired with an
    extra (implementation) class, including a set of forwarding methods to delegate
    requests to the implementation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用pImpl模式的类来说，维护将会更加困难，这是一个不幸的缺点。每个目标类现在都与一个额外的（实现）类配对，包括一组转发方法来将请求委托给实现。
- en: A few implementation difficulties may also arise. For example, if any of the
    private members (now in the nested implementation class) need to access any of
    the protected or public methods of the outer interface class, we will need to
    include a backlink from the nested class to the outer class to access that member.
    Why? The `this` pointer in the inner class will be of the nested object type.
    Yet the protected and public methods in the outer object will expect a `this`
    pointer to the outer object – even if those public methods will then re-delegate
    the request to a call a private, nested class method for help. This backlink will
    also be required to call public virtual functions of the interface from the scope
    of the inner class (implementation). Keep in mind, however, that we impact performance
    with another added pointer per object and with delegation to call each method
    in the associated object.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能会出现一些实现困难。例如，如果任何私有成员（现在在嵌套实现类中）需要访问外部接口类的受保护或公共方法中的任何一个，我们将需要在嵌套类中包含一个反向链接，以便访问该成员。为什么？内部类中的`this`指针将是嵌套对象类型的。然而，外部对象中的受保护和公共方法将期望一个`this`指针指向外部对象
    - 即使这些公共方法将重新委托请求调用私有的嵌套类方法来帮助。还需要这个反向链接来从内部类（实现）的范围内调用接口的公共虚函数。然而，请记住，我们通过每个对象添加的另一个指针和委托来影响性能，这将影响性能。
- en: The advantages of utilizing the pImpl pattern are several, offering important
    considerations. Of most importance, recompile time during development and maintenance
    of code decreases significantly. Additionally, the compiled binary interface of
    a class becomes independent of the underlying implementation of the class. Changing
    the implementation of a class only requires the nested implementation class to
    be recompiled and linked in. Users of the outer class are unaffected. As a bonus,
    the pImpl pattern provides a way to hide the underlying private details of a class,
    which may be useful when distributing class libraries or other proprietary code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 利用pImpl模式的优势有很多，提供了重要的考虑因素。其中最重要的是，在开发和维护代码期间重新编译的时间显著减少。此外，类的编译二进制接口变得独立于类的底层实现。更改类的实现只需要重新编译和链接嵌套实现类。外部类的用户不受影响。作为一个额外的好处，pImpl模式提供了一种隐藏类的底层私有细节的方法，这在分发类库或其他专有代码时可能会有用。
- en: An advantage of including a `unique_pointer` in our pImpl implementation is
    that we have guaranteed proper destruction of the associated implementation class.
    We also have the potential to save inadvertent programmer-introduced pointer and
    memory mishaps!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的pImpl实现中包含`unique_pointer`的一个优势是，我们保证了关联实现类的正确销毁。我们还有可能避免程序员引入的指针和内存错误！
- en: The use of the pImpl pattern is a trade-off. Careful analysis of each class
    and of the application at hand will help determine whether the pImpl pattern is
    appropriate in your design.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pImpl模式是一种权衡。对每个类和所涉及的应用进行仔细分析将有助于确定pImpl模式是否适合您的设计。
- en: We have now seen implementations of the pImpl pattern initially using a raw
    pointer, and then applying a `unique_pointer`. Let us now briefly recap what we
    have learned relating to patterns before concluding our last chapter of this book.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了最初使用原始指针的pImpl模式的实现，然后应用了`unique_pointer`。让我们现在简要回顾一下我们在结束本书的最后一章之前所学到的与模式相关的内容。
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have advanced our objective of becoming more indispensable
    C++ programmers by furthering our programming skills with another core design
    pattern. We have explored the pImpl pattern with an initial implementation using
    native C++ pointers and association and then improved our implementation by using
    a unique pointer. By examining the implementation, we easily understand how the
    pImpl pattern reduces compile-time dependencies and can make our code more implementation-dependent.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过进一步提高我们的编程技能，探索了另一个核心设计模式，进一步推进了成为更不可或缺的C++程序员的目标。我们通过使用本地C++指针和关联来探索了pImpl模式的初始实现，然后通过使用unique指针来改进我们的实现。通过检查实现，我们很容易理解pImpl模式如何减少编译时的依赖，并且可以使我们的代码更依赖于实现。
- en: Making use of core design patterns, such as the pImpl pattern, will help you
    more easily contribute to reusable, maintainable code that is understood by other
    programmers familiar with common design patterns. Your software solutions will
    be based on creative and well-tested design solutions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 利用核心设计模式，比如pImpl模式，将帮助您更轻松地为其他熟悉常见设计模式的程序员理解的可重用、可维护的代码做出贡献。您的软件解决方案将基于创造性和经过良好测试的设计解决方案。
- en: We have now completed our final design pattern together, wrapping up a long
    journey of understanding OOP in C++. You now have a multitude of skills, including
    a deep understanding of OOP, extended language features, and core design patterns,
    all of which make you a more valuable programmer.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在一起完成了我们的最后一个设计模式，结束了对C++面向对象编程的长期探索。您现在拥有了许多技能，包括对面向对象编程的深入理解、扩展的语言特性和核心设计模式，这些都使您成为了一名更有价值的程序员。
- en: Though C++ is an intricate language with additional features, supplemental techniques,
    and additional design patterns to discover, you have more than a solid basis and
    level of expertise to easily navigate and acquire any additional language features,
    libraries, and patterns you may wish to embrace. You've come a long way; this
    has been an adventurous journey together! I have enjoyed every minute of our quest
    and I hope you have as well.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C++是一种复杂的语言，具有额外的特性、补充技术和额外的设计模式需要探索，但您已经具备了坚实的基础和专业水平，可以轻松地掌握和获取任何额外的语言特性、库和模式。您已经走了很长的路；这是一次充满冒险的旅程！我享受我们的探索过程的每一分钟，希望您也一样。
- en: We began by reviewing basic language syntax and understanding C++ essentials
    necessary to serve as building blocks for our then-upcoming OOP journey. We then
    embraced C++ as an OOP language together, learning not only essential OO concepts
    but also how to implement them with either C++ language features, coding techniques,
    or both. We then extended your skills by adding knowledge of exception handling,
    friends, operator overloading, templates, STL basics, and testing OO classes and
    components. We then ventured into sophisticated programming techniques by embracing
    core design patterns, delving into code by applying each pattern of interest.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从审查基本语言语法和理解C++基础知识开始，这些知识对我们即将开始的面向对象编程之旅至关重要。然后，我们一起将C++作为面向对象的语言，不仅学习了基本的面向对象概念，还学会了如何使用C++语言特性、编码技巧或两者都使用来实现它们。然后，我们通过添加异常处理、友元、运算符重载、模板、STL基础知识以及测试面向对象类和组件来扩展您的技能。然后，我们通过应用感兴趣的每个模式深入代码，进入了复杂的编程技术。
- en: Each of these acquired skill-segments represents a new tier of C++ knowledge
    and mastery. Each will help you to create more easily maintainable and robust
    code. Your future as a well-versed, skilled OO programmer in C++ awaits. Now,
    let's get programming!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些所获得的技能段代表了C++知识和掌握的新层次。每一个都将帮助您更轻松地创建可维护和健壮的代码。您作为一名精通的、熟练的C++面向对象程序员的未来正在等待。现在，让我们开始编程吧！
- en: Questions
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Modify the pImpl pattern example in this chapter that uses a unique pointer
    to additionally introduce unique pointers within the implementation of the nested
    class.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改本章中使用unique指针的pImpl模式示例，另外在嵌套类的实现中引入unique指针。
- en: Revise your `Student` class from a previous chapter solution to simply inherit
    from the `Person` class in this chapter that embraces the pImpl pattern. What
    difficulties, if any, do you have? Now, modify your `Student` class to additionally
    utilize the pImpl pattern with a unique pointer. Now, what difficulties, if any,
    do you have?
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您以前章节解决方案中的`Student`类简单地继承自本章中采用pImpl模式的`Person`类。您遇到了什么困难吗？现在，修改您的`Student`类，另外利用独特指针实现pImpl模式。现在，您遇到了什么困难吗？
- en: What other examples can you imagine that might reasonably incorporate the pImpl
    pattern for relative implementation independence?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能想象其他什么例子可能合理地将pImpl模式纳入相对独立的实现中？
