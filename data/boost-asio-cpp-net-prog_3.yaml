- en: Chapter 3. Introducing the Boost C++ Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 介绍Boost C++库
- en: 'Many programmers use libraries since this simplifies the programming process.
    Because they do not need to write the function from scratch anymore, using a library
    can save much code development time. In this chapter, we are going to get acquainted
    with Boost C++ libraries. Let us prepare our own compiler and text editor to prove
    the power of Boost libraries. As we do so, we will discuss the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员使用库，因为这简化了编程过程。使用库可以节省大量的代码开发时间，因为他们不再需要从头开始编写函数。在本章中，我们将熟悉Boost C++库。让我们准备自己的编译器和文本编辑器，以证明Boost库的强大功能。在这样做的过程中，我们将讨论以下主题：
- en: Introducing the C++ standard template library
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍C++标准模板库
- en: Introducing the Boost libraries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Boost库
- en: Preparing the Boost C++ libraries in MinGW compiler
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在MinGW编译器中准备Boost C++库
- en: Building the Boost libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Boost库
- en: Compiling code that contains Boost C++ libraries
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译包含Boost C++库的代码
- en: Introducing the C++ standard template library
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍C++标准模板库
- en: The C++ **Standard Template Library** (**STL**) is a generic template-based
    library that offers generic containers, among other things. Instead of dealing
    with dynamic arrays, linked lists, binary trees, or hash tables, programmers can
    easily use an algorithm that is provided by STL.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: C++ **标准模板库**（**STL**）是一个基于模板的通用库，提供了通用容器等功能。程序员可以轻松使用STL提供的算法，而不是处理动态数组、链表、二叉树或哈希表。
- en: 'The STL is structured by containers, iterators, and algorithms, and their roles
    are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: STL由容器、迭代器和算法构成，它们的作用如下：
- en: '**Containers**: Their main role is to manage the collection of objects of certain
    kinds, such as arrays of integers or linked lists of strings.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：它们的主要作用是管理某种类型的对象的集合，例如整数数组或字符串链表。'
- en: '**Iterators**: Their main role is to step through the element of the collections.
    The working of an iterator is similar to that of a pointer. We can increment the
    iterator by using the `++` operator and access the value by using the `*` operator.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器**：它们的主要作用是遍历集合的元素。迭代器的工作方式类似于指针。我们可以使用`++`运算符递增迭代器，并使用`*`运算符访问值。'
- en: '**Algorithms**: Their main role is to process the element of collections. An
    algorithm uses an iterator to step through all elements. After it iterates the
    elements, it processes each element, for example, modifying the element. It can
    also search and sort the element after it finishes iterating all the elements.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法**：它们的主要作用是处理集合的元素。算法使用迭代器遍历所有元素。在迭代元素后，它处理每个元素，例如修改元素。它还可以在迭代所有元素后搜索和排序元素。'
- en: 'Let us examine the three elements that structure STL by creating the following
    code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建以下代码来检查STL结构的三个元素：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Name the preceding code `stl.cpp`, and run the following command to compile
    it:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码命名为`stl.cpp`，并运行以下命令进行编译：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Before we dissect this code, let us run it to see what happens. This program
    will ask users to enter as many as integer they want, and then it will sort the
    numbers. To stop the input and ask the program to start sorting, the user has
    to input `0`. This means that `0` will not be included in the sorting process.
    Since we do not prevent users from entering non-integer numbers such as 3.14,
    the program will soon stop waiting for the next number after the user enters a
    non-integer number. The code yields the following output:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解剖这段代码之前，让我们运行它看看会发生什么。这个程序将要求用户输入尽可能多的整数，然后对数字进行排序。要停止输入并要求程序开始排序，用户必须输入`0`。这意味着`0`不会包括在排序过程中。由于我们没有阻止用户输入非整数数字，比如3.14，程序很快就会停止等待用户输入下一个数字。代码产生以下输出：
- en: '![Introducing the C++ standard template library](img/00015.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![介绍C++标准模板库](img/00015.jpeg)'
- en: 'We have entered six integers: `43`, `7`, `568`, `91`, `2240`, and `56`. The
    last entry is `0` in order to stop the input process. Then the program starts
    to sort the numbers and we get the numbers sorted in sequential order: `7`, `43`,
    `56`, `91`, `568`, and `2240`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输入了六个整数：`43`，`7`，`568`，`91`，`2240`和`56`。最后一个输入是`0`，以停止输入过程。然后程序开始对数字进行排序，我们得到了按顺序排序的数字：`7`，`43`，`56`，`91`，`568`和`2240`。
- en: 'Now, let us examine our code to identify the containers, iterators, and algorithms
    that are contained in the STL:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查我们的代码，以确定STL中包含的容器、迭代器和算法：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `begin()` and `end()` functions in the preceding code are algorithms in
    STL. They play the role of processing the data in the containers that are used
    to get the first and the last elements in the container. Before that, we can see
    the `push_back()` function, which is used to append an element to the container:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的`begin()`和`end()`函数是STL中的算法。它们的作用是处理容器中的数据，用于获取容器中的第一个和最后一个元素。在此之前，我们可以看到`push_back()`函数，用于将元素追加到容器中：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding `for` block will iterate each element of the integer that is called
    as `collection`. Each time the element is iterated, we can process the element
    separately. In the preceding example, we showed the number to the user. That is
    how the iterators in STL play their role.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`for`块将迭代称为`collection`的整数的每个元素。每次迭代元素时，我们可以单独处理元素。在前面的示例中，我们向用户显示了数字。这就是STL中迭代器发挥作用的方式。
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We include vector definition to define all `vector` functions and `algorithm`
    definition to invoke the `sort()` function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括向量定义以定义所有`vector`函数和`algorithm`定义以调用`sort()`函数。
- en: Introducing the Boost C++ libraries
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Boost C++库
- en: The Boost C++ libraries is a set of libraries to complement the C++ standard
    libraries. The set contains more than a hundred libraries that we can use to increase
    our productivity in C++ programming. It is also used when our requirements go
    beyond what is available in the STL. It provides source code under Boost Licence,
    which means that it allows us to use, modify, and distribute the libraries for
    free, even for commercial use.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Boost C++库是一组库，用于补充C++标准库。该集合包含100多个库，我们可以使用它们来提高C++编程的生产力。当我们的需求超出STL提供的范围时，也可以使用它。它以Boost许可证提供源代码，这意味着它允许我们免费使用、修改和分发这些库，甚至用于商业用途。
- en: The development of Boost is handled by the Boost community, which consists of
    C++ developers from around the world. The mission of the community is to develop
    high-quality libraries as a complement to STL. Only proven libraries will be added
    to the Boost libraries.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Boost的开发由来自世界各地的C++开发人员组成的Boost社区处理。社区的使命是开发高质量的库，作为STL的补充。只有经过验证的库才会被添加到Boost库中。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For detailed information about Boost libraries, go to [www.boost.org](http://www.boost.org).
    And if you want to contribute developing libraries to Boost, you can join the
    developer mailing list at [lists.boost.org/mailman/listinfo.cgi/boost](http://lists.boost.org/mailman/listinfo.cgi/boost).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Boost库的详细信息，请访问[www.boost.org](http://www.boost.org)。如果您想为Boost开发库做出贡献，可以加入开发者邮件列表[lists.boost.org/mailman/listinfo.cgi/boost](http://lists.boost.org/mailman/listinfo.cgi/boost)。
- en: The entire source code of the libraries is available on the official GitHub
    page at [github.com/boostorg](http://github.com/boostorg).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有库的完整源代码都可以在官方GitHub页面[github.com/boostorg](http://github.com/boostorg)上找到。
- en: Advantages of Boost libraries
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost库的优势
- en: 'As we know, using Boost libraries will increase programmer productivity. Moreover,
    by using Boost libraries, we will get advantages such as these:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，使用Boost库将提高程序员的生产力。此外，通过使用Boost库，我们将获得诸如以下优势：
- en: It is open source, so we can inspect the source code and modify it if needed.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是开源的，所以我们可以检查源代码并在需要时进行修改。
- en: Its license allows us to develop both open source and close source projects.
    It also allows us to commercialize our software freely.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的许可证允许我们开发开源和闭源项目。它还允许我们自由商业化我们的软件。
- en: It is well documented and we can find it libraries all explained, along with
    sample code from the official site.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有很好的文档，并且我们可以在官方网站上找到所有库的解释，以及示例代码。
- en: It supports almost any modern operating system, such as Windows and Linux. It
    also supports many popular compilers.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持几乎所有现代操作系统，如Windows和Linux。它还支持许多流行的编译器。
- en: It is a complement to STL instead of a replacement. It means using Boost libraries
    will ease those programming processes that are not handled by STL yet. In fact,
    many parts of Boost are included in the standard C++ library.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是STL的补充而不是替代。这意味着使用Boost库将简化那些STL尚未处理的编程过程。实际上，Boost的许多部分都包含在标准C++库中。
- en: Preparing Boost libraries for the MinGW compiler
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为MinGW编译器准备Boost库
- en: Before we go through to program our C++ application by using Boost libraries,
    the libraries need to be configured in order to be recognized by MinGW compiler.
    Here, we are going to prepare our programming environment so that our compiler
    is able use Boost libraries.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Boost库编写C++应用程序之前，需要配置库以便MinGW编译器能够识别。在这里，我们将准备我们的编程环境，以便我们的编译器能够使用Boost库。
- en: Downloading Boost libraries
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载Boost库
- en: The best source from which to download Boost is the official download page.
    We can go there by pointing our internet browser to [www.boost.org/users/download](http://www.boost.org/users/download).
    Find the **Download** link in **Current Release** section. At the time of writing,
    the current version of Boost libraries is 1.58.0, but when you read this book,
    the version may have changed. If so, you can still choose the current release
    because the higher version must be compatible with the lower. However, you have
    to adjust as we're going to talk about the setting later. Otherwise, choosing
    the same version will make it easy for you to follow all the instructions in this
    book.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下载Boost的最佳来源是官方下载页面。我们可以通过将互联网浏览器指向[www.boost.org/users/download](http://www.boost.org/users/download)来访问该页面。在**当前版本**部分找到**下载**链接。在撰写本书时，Boost库的当前版本是1.58.0，但当您阅读本书时，版本可能已经更改。如果是这样，您仍然可以选择当前版本，因为更高的版本必须与更低的版本兼容。但是，您必须根据我们稍后将要讨论的设置进行调整。否则，选择相同的版本将使您能够遵循本书中的所有说明。
- en: 'There are four file formats to be choose from for download; they are `.zip`,
    `.tar.gz`, `.tar.bz2`, and `.7z`. There is no difference among the four files
    but their file size. The largest file size is of the ZIP format and the lowest
    is that of the 7Z format. Because of the file size, Boost recommends that we download
    the 7Z format. See the following image for comparison:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种文件格式可供选择进行下载；它们是`.zip`、`.tar.gz`、`.tar.bz2`和`.7z`。这四个文件之间没有区别，只是文件大小不同。ZIP格式的文件大小最大，而7Z格式的文件大小最小。由于文件大小，Boost建议我们下载7Z格式。请参考以下图片进行比较：
- en: '![Downloading Boost libraries](img/00016.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![下载Boost库](img/00016.jpeg)'
- en: From the preceding image, we can see the size of ZIP version is 123.1 MB while
    the size of the 7Z version is 65.2 MB. It means that the size of the ZIP version
    is almost twice that of the 7Z version. Therefore, they suggest that you choose
    the 7Z format to reduce download and decompression time. Let us choose `boost_1_58_0.7z`
    to be downloaded and save it to our local storage.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图可以看出，ZIP版本的大小为123.1 MB，而7Z版本的大小为65.2 MB。这意味着ZIP版本的大小几乎是7Z版本的两倍。因此，他们建议您选择7Z格式以减少下载和解压时间。让我们选择`boost_1_58_0.7z`进行下载，并将其保存到本地存储中。
- en: Deploying Boost libraries
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署Boost库
- en: After we have got `boost_1_58_0.7z` in our local storage, decompress it using
    the 7ZIP application and save the decompression files to `C:\boost_1_58_0`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地存储中获得`boost_1_58_0.7z`后，使用7ZIP应用程序对其进行解压，并将解压文件保存到`C:\boost_1_58_0`。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The 7ZIP application can be grabbed from [www.7-zip.org/download.html](http://www.7-zip.org/download.html).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 7ZIP应用程序可以从[www.7-zip.org/download.html](http://www.7-zip.org/download.html)获取。
- en: 'The directory then should contain file structures as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该目录应包含以下文件结构：
- en: '![Deploying Boost libraries](img/00017.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![部署Boost库](img/00017.jpeg)'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of browsing to the Boost download page and searching for the Boost version
    manually, we can go directly to [sourceforge.net/projects/boost/files/boost/1.58.0](http://sourceforge.net/projects/boost/files/boost/1.58.0).
    It will be useful when the 1.58.0 version is no longer the current release.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与其直接浏览到Boost下载页面并手动搜索Boost版本，不如直接转到[sourceforge.net/projects/boost/files/boost/1.58.0](http://sourceforge.net/projects/boost/files/boost/1.58.0)。当1.58.0版本不再是当前版本时，这将非常有用。
- en: Using Boost libraries
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Boost库
- en: 'Most libraries in Boost are **header-only**; this means that all declarations
    and definitions of functions, including namespaces and macros, are visible to
    the compiler and there is no need to compile them separately. We can now try to
    use Boost with the program to convert the string into `int` value as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Boost中的大多数库都是**仅头文件**；这意味着所有函数的声明和定义，包括命名空间和宏，都对编译器可见，无需单独编译它们。现在我们可以尝试使用Boost与程序一起将字符串转换为`int`值，如下所示：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Open the Notepad++ application, type the preceding code, and save it as `lexical.cpp`
    in `C:\CPP`—the directory we had created in [Chapter 1](part0015_split_000.html#page
    "Chapter 1. Simplifying Your Network Programming in C++"), *Simplifying Your Network
    Programming in C++*. Now open the command prompt, point the active directory to
    `C:\CPP`, and then type the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Notepad++应用程序，输入上述代码，并将其保存为`lexical.cpp`，保存在`C:\CPP`目录中——这是我们在[第1章](part0015_split_000.html#page
    "第1章。简化C++中的网络编程")中创建的目录，*简化C++中的网络编程*。现在打开命令提示符，将活动目录指向`C:\CPP`，然后输入以下命令：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have a new option here, which is `–I` (the "include" option). This option
    is used along with the full path of the directory to inform the compiler that
    we have another header directory that we want to include to our code. Since we
    store our Boost libraries in `c:\ boost_1_58_0`, we can use `–Ic:\boost_1_58_0`
    as an additional parameter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有一个新选项，即`-I`（“包含”选项）。此选项与目录的完整路径一起使用，以通知编译器我们有另一个要包含到我们的代码中的头文件目录。由于我们将Boost库存储在`c:\
    boost_1_58_0`中，我们可以使用`-Ic:\boost_1_58_0`作为附加参数。
- en: In `lexical.cpp`, we apply `boost::lexical_cast` to convert `string` type data
    into `int` type data. The program will ask the user to input two numbers and will
    then automatically find the sum of both numbers. If a user inputs an inappropriate
    number, it will inform them that an error has occurred.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lexical.cpp`中，我们应用`boost::lexical_cast`将`string`类型数据转换为`int`类型数据。程序将要求用户输入两个数字，然后自动找到这两个数字的和。如果用户输入不合适的数字，程序将通知他们发生了错误。
- en: 'The `Boost.LexicalCast` library is provided by Boost for casting one data type
    to another (converting numeric types such as `int`, `double`, or `floats` into
    `string` types, and vice versa). Now, let us dissect `lexical.cpp` to for a more
    detailed understanding of what it does:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.LexicalCast`库由Boost提供，用于将一种数据类型转换为另一种数据类型（将数值类型（如`int`、`double`或`float`）转换为字符串类型，反之亦然）。现在，让我们解剖`lexical.cpp`，以便更详细地了解它的功能：'
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We include `boost/lexical_cast.hpp` in order to be able to invoke `boost::lexical_cast`
    function since the function is declared in `lexical_cast.hpp`. Also we use `string`
    header to apply `std::string` function as well as `iostream` header to apply `std::cin`,
    `std::cout` and `std::cerr` function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括`boost/lexical_cast.hpp`，以便能够调用`boost::lexical_cast`函数，因为该函数在`lexical_cast.hpp`中声明。此外，我们使用`string`头文件来应用`std::string`函数，以及使用`iostream`头文件来应用`std::cin`、`std::cout`和`std::cerr`函数。
- en: 'Other functions, such as `std::cin` and `std::cout`, have been talked about
    in [Chapter 1](part0015_split_000.html#page "Chapter 1. Simplifying Your Network
    Programming in C++"), *Simplifying Your Network Programming in C++*, and we saw
    what their functions are so we can skip those lines:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 其他函数，如`std::cin`和`std::cout`，在[第1章](part0015_split_000.html#page "第1章。简化C++中的网络编程")中已经讨论过，我们知道它们的功能，因此可以跳过这些行：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We used the preceding two separate lines to convert the user-provided input
    `string` into the `int` data type. Then, after converting the data type, we summed
    up both of the `int` values.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用上述两个单独的行将用户提供的输入`string`转换为`int`数据类型。然后，在转换数据类型后，我们对这两个`int`值进行求和。
- en: We can also see the `try-catch` block in the preceding code. It is used to catch
    the error if user inputs an inappropriate number, except 0 to 9.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在上述代码中看到`try-catch`块。它用于捕获错误，如果用户输入不合适的数字，除了0到9。
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now let us run the application by typing `lexical` at the command prompt. We
    will get output like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过在命令提示符中输入`lexical`来运行应用程序。我们将得到以下输出：
- en: '![Using Boost libraries](img/00018.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![使用Boost库](img/00018.jpeg)'
- en: 'I put `10` for first input and `20` for the second input. The result is `30`
    because it just sums up both input. But what will happen if I put in a non-numerical
    value, for instance `Packt`. Here is the output to try that condition:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我为第一个输入放入了`10`，为第二个输入放入了`20`。结果是`30`，因为它只是对两个输入求和。但是如果我输入一个非数字值，例如`Packt`，会发生什么呢？以下是尝试该条件的输出：
- en: '![Using Boost libraries](img/00019.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![使用Boost库](img/00019.jpeg)'
- en: 'Once the application found the error, it will ignore the next statement and
    go directly to the `catch` block. By using the `e.what()` function, the application
    can get the error message and show it to the user. In our example, we obtain `bad
    lexical cast: source type value could not be interpreted` as target as the error
    message because we try to assign the `string` data to `int` type variable.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦应用程序发现错误，它将忽略下一个语句并直接转到`catch`块。通过使用`e.what()`函数，应用程序可以获取错误消息并显示给用户。在我们的示例中，我们获得了`bad
    lexical cast: source type value could not be interpreted`作为错误消息，因为我们尝试将`string`数据分配给`int`类型变量。'
- en: Building Boost libraries
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建Boost库
- en: 'As we discussed previously, most libraries in Boost are header-only, but not
    all of them. There are some libraries that have to be built separately. They are:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，Boost中的大多数库都是仅头文件的，但并非所有库都是如此。有一些库必须单独构建。它们是：
- en: '`Boost.Chrono`: This is used to show the variety of clocks, such as current
    time, the range between two times, or calculating the time passed in the process.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Chrono`：用于显示各种时钟，如当前时间、两个时间之间的范围，或者计算过程中经过的时间。'
- en: '`Boost.Context`: This is used to create higher-level abstractions, such as
    coroutines and cooperative threads.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Context`：用于创建更高级的抽象，如协程和协作线程。'
- en: '`Boost.Filesystem`: This is used to deal with files and directories, such as
    obtaining the file path or checking whether a file or directory exists.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Filesystem`：用于处理文件和目录，例如获取文件路径或检查文件或目录是否存在。'
- en: '`Boost.GraphParallel`: This is an extension to the **Boost Graph Library**
    (**BGL**) for parallel and distributed computing.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.GraphParallel`：这是**Boost图形库**（**BGL**）的并行和分布式计算扩展。'
- en: '`Boost.IOStreams`: This is used to write and read data using stream. For instance,
    it loads the content of a file to memory or writes compressed data in GZIP format.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.IOStreams`：用于使用流写入和读取数据。例如，它将文件的内容加载到内存中，或者以GZIP格式写入压缩数据。'
- en: '`Boost.Locale`: This is used to localize the application, in other words, translate
    the application interface to user''s language.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Locale`：用于本地化应用程序，换句话说，将应用程序界面翻译成用户的语言。'
- en: '`Boost.MPI`: This is used to develop a program that executes tasks concurrently.
    **MPI itself stands for Message Passing Interface**.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.MPI`：用于开发可以并行执行任务的程序。**MPI本身代表消息传递接口**。'
- en: '`Boost.ProgramOptions`: This is used to parse command-line options. Instead
    of using the `argv` variable in the `main` parameter, it uses double minus (`--`)
    to separate each command-line option.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.ProgramOptions`：用于解析命令行选项。它使用双减号（`--`）来分隔每个命令行选项，而不是使用`main`参数中的`argv`变量。'
- en: '`Boost.Python`: This is used to parse Python language in C++ code.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Python`：用于在C++代码中解析Python语言。'
- en: '`Boost.Regex`: This is used to apply regular expression in our code. But if
    our development supports C++11, we do not depend on the `Boost.Regex` library
    anymore since it is available in the `regex` header file.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Regex`：用于在我们的代码中应用正则表达式。但如果我们的开发支持C++11，我们不再依赖于`Boost.Regex`库，因为它已经在`regex`头文件中可用。'
- en: '`Boost.Serialization`: This is used to convert objects into a series of bytes
    that can be saved and then restored again into the same object.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Serialization`：用于将对象转换为一系列字节，可以保存，然后再次恢复为相同的对象。'
- en: '`Boost.Signals`: This is used to create signals. The signal will trigger an
    event to run a function on it.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Signals`：用于创建信号。信号将触发事件来运行一个函数。'
- en: '`Boost.System`: This is used to define errors. It contains four classes: `system::error_code`,
    `system::error_category`, `system::error_condition`, and `system::system_error`.
    All of these classes are inside the `boost` namespace. It is also supported in
    the C++11 environment, but because many Boost libraries use `Boost.System`, it
    is necessary to keep including `Boost.System`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.System`：用于定义错误。它包含四个类：`system::error_code`、`system::error_category`、`system::error_condition`和`system::system_error`。所有这些类都在`boost`命名空间中。它也支持C++11环境，但由于许多Boost库使用`Boost.System`，因此有必要继续包含`Boost.System`。'
- en: '`Boost.Thread`: This is used to apply threading programming. It provides classes
    to synchronize access on multiple-thread data. In C++11 environments, the `Boost.Thread`
    library offers extensions, so we can interrupt thread in `Boost.Thread`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Thread`：用于应用线程编程。它提供了用于同步多线程数据访问的类。在C++11环境中，`Boost.Thread`库提供了扩展，因此我们可以在`Boost.Thread`中中断线程。'
- en: '`Boost.Timer`: This is used to measure the code performance by using clocks.
    It measures time passed based on usual clock and CPU time, which states how much
    time has been spent to execute the code.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Timer`：用于使用时钟来测量代码性能。它基于通常的时钟和CPU时间来测量经过的时间，这表明执行代码所花费的时间。'
- en: '`Boost.Wave`: This provides a reusable C preprocessor that we can use in our
    C++ code.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Wave`：提供了一个可重用的C预处理器，我们可以在我们的C++代码中使用。'
- en: 'There are also a few libraries that have optional, separately compiled binaries.
    They are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些具有可选的、单独编译的二进制文件的库。它们如下：
- en: '`Boost.DateTime`: It is used to process time data; for instance, calendar dates
    and time. It has a binary component that is only needed if we use `to_string`,
    `from_string`, or serialization features. It is also needed if we target our application
    in Visual C++ 6.x or Borland.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.DateTime`：用于处理时间数据；例如，日历日期和时间。它有一个二进制组件，只有在使用`to_string`、`from_string`或序列化功能时才需要。如果我们将应用程序定位到Visual
    C++ 6.x或Borland，也是必需的。'
- en: '`Boost.Graph`: It is used to create two-dimensional graphics. It has a binary
    component that is only needed if we intend to parse `GraphViz` files.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Graph`：用于创建二维图形。它有一个二进制组件，只有在我们打算解析`GraphViz`文件时才需要。'
- en: '`Boost.Math`: It is used to deal with mathematical formulas. It has binary
    components for `cmath` functions.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Math`：用于处理数学公式。它有用于`cmath`函数的二进制组件。'
- en: '`Boost.Random`: It is used to generate random numbers. It has a binary component,
    which is only needed if we want to use `random_device`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Random`：用于生成随机数。它有一个二进制组件，只有在我们想要使用`random_device`时才需要。'
- en: '`Boost.Test`: It is used to write and organize test programs and their runtime
    execution. It can be used in header-only or separately compiled mode, but separate
    compilation is recommended for serious use.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Test`：用于编写和组织测试程序及其运行时执行。它可以以仅头文件或单独编译模式使用，但对于严肃的使用，建议使用单独编译。'
- en: '`Boost.Exception`: It is used to add data to an exception after it has been
    thrown. It provides non-intrusive implementation of `exception_ptr` for 32-bit
    `_MSC_VER==1310` and `_MSC_VER==1400`, which requires a separately compiled binary.
    This is enabled by `#define BOOST_ENABLE_NON_INTRUSIVE_EXCEPTION_PTR`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Exception`：它用于在抛出异常后向异常添加数据。它为32位`_MSC_VER==1310`和`_MSC_VER==1400`提供了`exception_ptr`的非侵入式实现，这需要单独编译的二进制文件。这是通过`#define
    BOOST_ENABLE_NON_INTRUSIVE_EXCEPTION_PTR`启用的。'
- en: 'Let us try to recreate the random number generator program we created in [Chapter
    1](part0015_split_000.html#page "Chapter 1. Simplifying Your Network Programming
    in C++"), *Simplifying Your Network Programming in C++*. But now we will use the
    `Boost.Random` library instead of `std::rand()` from the C++ standard function.
    Let us take a look at the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重新创建我们在[第1章](part0015_split_000.html#page "第1章。简化C++网络编程")中创建的随机数生成器程序。但现在我们将使用`Boost.Random`库，而不是C++标准函数中的`std::rand()`。让我们看一下以下代码：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can compile the preceding source code by using the following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令编译前面的源代码：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let us run the program. Unfortunately, for the three times that I ran
    the program, I always obtained the same random number as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行程序。不幸的是，在我运行程序的三次中，我总是得到相同的随机数，如下所示：
- en: '![Building Boost libraries](img/00020.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![构建Boost库](img/00020.jpeg)'
- en: As we can see from this example, we always get number 8\. This is because we
    apply Mersenne Twister, a **Pseudorandom Number Generator** (**PRNG**), which
    uses the default seed as a source of randomness so it will generate the same number
    every time the program is run. And, of course, it is not the program that we expect.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从这个例子中看到的，我们总是得到数字8。这是因为我们应用了Mersenne Twister，一个**伪随机数生成器**（**PRNG**），它使用默认种子作为随机性的来源，因此每次运行程序时都会生成相同的数字。当然，这不是我们期望的程序。
- en: 'Now, we will rework the program once again, just in two lines. First, find
    the following line:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将再次修改程序，只需两行。首先，找到以下行：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Change it as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改如下：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, find the following line:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，找到以下行：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Change it as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改如下：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, save the file as `rangen2_boost.cpp` and compile the `rangen2_boost.cpp`
    file by using the command like we compiled `rangen_boost.cpp`. The command will
    look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将文件保存为`rangen2_boost.cpp`，并使用与我们编译`rangen_boost.cpp`相同的命令来编译`rangen2_boost.cpp`文件。命令将如下所示：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Sadly, there will be something wrong and the compiler will show the following
    error message:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，会出现一些问题，编译器将显示以下错误消息：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is because, as we saw earlier, the `Boost.Random` library needs to be compiled
    separately if we want to use the `random_device` attribute.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，正如我们之前看到的，如果我们想要使用`random_device`属性，`Boost.Random`库需要单独编译。
- en: 'Boost libraries have a system to compile or build Boost itself, called `Boost.Build`
    library. There are two steps we have to achieve to install the `Boost.Build` library.
    First, run **Bootstrap** by pointing the active directory at the command prompt
    to `C:\boost_1_58_0` and typing the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Boost库有一个系统来编译或构建Boost本身，称为`Boost.Build`库。我们必须完成两个步骤来安装`Boost.Build`库。首先，通过将命令提示符中的活动目录指向`C:\boost_1_58_0`，并键入以下命令来运行**Bootstrap**：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We use our MinGW compiler we had installed in [Chapter 1](part0015_split_000.html#page
    "Chapter 1. Simplifying Your Network Programming in C++"), *Simplifying Your Network
    Programming in C++*, as our toolset in compiling the Boost library. Wait a second
    and then we will get the following output if the process is a success:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们在[第1章](part0015_split_000.html#page "第1章。简化C++网络编程")中安装的MinGW编译器作为我们在编译Boost库时的工具集。等一下，如果过程成功，我们将得到以下输出：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this step, we will find four new files in the Boost library''s root directory.
    They are:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们将在Boost库的根目录中找到四个新文件。它们是：
- en: '`b2.exe`: This is an executable file to build Boost libraries'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b2.exe`：这是一个可执行文件，用于构建Boost库'
- en: '`bjam.exe`: This is exactly the same as `b2.exe` but it is a legacy version'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bjam.exe`：这与`b2.exe`完全相同，但它是一个旧版本'
- en: '`bootstrap.log`: This contains logs from the `bootstrap` process'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap.log`：这包含了`bootstrap`过程的日志'
- en: '`project-config.jam`: This contains a setting that will be used in the building
    process when we run `b2.exe`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project-config.jam`：这包含了在运行`b2.exe`时将用于构建过程的设置'
- en: We also find that this step creates a new directory in `C:\boost_1_58_0\tools\build\src\engine\bin.ntx86`
    , which contains a bunch of `.obj` files associated with Boost libraries that
    needed to be compiled.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现，这一步在`C:\boost_1_58_0\tools\build\src\engine\bin.ntx86`中创建了一个新目录，其中包含与需要编译的Boost库相关的一堆`.obj`文件。
- en: 'After that, run the second step by typing the following command at the command
    prompt:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在命令提示符下键入以下命令来运行第二步：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Grab yourself a cup of coffee after running that command because it will take
    about twenty to fifty minutes to finish the process, depending on your system
    specifications. The last output we will get will be as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行该命令后，喝杯咖啡，因为这个过程将花费大约二十到五十分钟的时间，这取决于您的系统规格。我们将得到的最后输出将如下所示：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This means that the process is complete and we have now built the Boost libraries.
    If we check in our explorer, the `Boost.Build` library adds `C:\boost_1_58_0\stage\lib`,
    which contains a collection of static and dynamic libraries that we can use directly
    in our program.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着过程已经完成，我们现在已经构建了Boost库。如果我们在资源管理器中检查，`Boost.Build`库将添加`C:\boost_1_58_0\stage\lib`，其中包含一系列静态和动态库，我们可以直接在我们的程序中使用。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`bootstrap.bat` and `b2.exe` use `msvc` (Microsoft Visual C++ compiler) as
    the default toolset, and many Windows developers already have `msvc` installed
    on their machines. Since we have installed the GCC compiler, we set the `mingw`
    and `gcc` toolset options in Boost''s build. If you also have `mvsc` installed
    and want to use it in Boost''s build, the toolset options can be omitted.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`bootstrap.bat`和`b2.exe`使用`msvc`（Microsoft Visual C++编译器）作为默认工具集，许多Windows开发人员已经在他们的机器上安装了`msvc`。由于我们安装了GCC编译器，我们在Boost的构建中设置了`mingw`和`gcc`工具集选项。如果您也安装了`mvsc`并希望在Boost的构建中使用它，可以省略工具集选项。'
- en: 'Now, let us try to compile the `rangen2_boost.cpp` file again, but now with
    the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次尝试使用以下命令编译`rangen2_boost.cpp`文件：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have two new options here, they are `–L` and `–l`. The `-L` option is used
    to define the path that contains the library file if it is not in the active directory.
    The `–l` option is used to define the name of library file but omitting the first
    `lib` word in front of the file name. In this case, the original library file
    name is `libboost_random-mgw49-mt-1_58.a`, and we omit the `lib` phrase and the
    file extension for option `-l`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个新选项，它们是`-L`和`-l`。`-L`选项用于定义包含库文件的路径，如果库文件不在活动目录中。`-l`选项用于定义库文件的名称，但省略文件名前面的`lib`单词。在这种情况下，原始库文件名为`libboost_random-mgw49-mt-1_58.a`，我们省略了`lib`短语和选项`-l`的文件扩展名。
- en: The new file called `rangen2_boost.exe` will be created in `C:\CPP`. But before
    we can run the program, we have to ensure that the directory that the program
    installed has contained two library files which the program is dependent on. These
    are `libboost_random-mgw49-mt-1_58.dll` and `libboost_system-mgw49-mt-1_58.dll`,
    and we can get them from the library directory `c:\boost_1_58_0_1\stage\lib`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 新文件`rangen2_boost.exe`将在`C:\CPP`中创建。但在运行程序之前，我们必须确保程序安装的目录包含程序所依赖的两个库文件。这些是`libboost_random-mgw49-mt-1_58.dll`和`libboost_system-mgw49-mt-1_58.dll`，我们可以从库目录`c:\boost_1_58_0_1\stage\lib`中获取它们。
- en: 'Just to make it easy for us to run that program, run the following `copy` command
    to copy the two library files to `C:\CPP`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便我们运行该程序，运行以下`copy`命令将两个库文件复制到`C:\CPP`：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And now the program should run smoothly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序应该可以顺利运行了。
- en: In order to create a network application, we are going to use the `Boost.Asio`
    library. We do not find `Boost.Asio`—the library that we are going to use to create
    a network application—in the non-header-only library. It seems that we do not
    need to build the Boost library since `Boost.Asio` is header-only library. This
    is true, but since `Boost.Asio` depends on `Boost.System` and `Boost.System` needs
    to be built before being used, it is important to build Boost first before we
    can use it to create our network application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个网络应用程序，我们将使用`Boost.Asio`库。我们在非仅头文件库中找不到`Boost.Asio`——我们将用它来创建网络应用程序的库。看来我们不需要构建Boost库，因为`Boost.Asio`是仅头文件库。这是正确的，但由于`Boost.Asio`依赖于`Boost.System`，而`Boost.System`需要在使用之前构建，因此在创建网络应用程序之前，首先构建Boost是很重要的。
- en: Tip
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For option `–I` and `–L`, the compiler does not care if we use backslash (\)
    or slash (/) to separate each directory name in the path because the compiler
    can handle both Windows and Unix path styles.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选项`-I`和`-L`，编译器不在乎我们在路径中使用反斜杠（\）还是斜杠（/）来分隔每个目录名称，因为编译器可以处理Windows和Unix路径样式。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We saw that Boost C++ libraries were developed to complement the standard C++
    library. We have also been able to set up our MinGW compiler in order to compile
    the code that contains Boost libraries and build the binaries of libraries that
    have to be compiled separately. In the next chapter, which talks about the `Boost.Asio`
    library (the library we are going to use to develop network applications), we
    will delve into Boost libraries specifically. Please remember that although we
    can use the `Boost.Asio` library as a header-only library, it would be better
    to build all Boost libraries by using the `Boost.Build` library. It will be easy
    for us to use all libraries without worrying about compiling failure.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到Boost C++库是为了补充标准C++库而开发的。我们还能够设置我们的MinGW编译器，以便编译包含Boost库的代码，并构建必须单独编译的库的二进制文件。在下一章中，我们将深入研究Boost库，特别是关于`Boost.Asio`库（我们将用它来开发网络应用程序）。请记住，尽管我们可以将`Boost.Asio`库作为仅头文件库使用，但最好使用`Boost.Build`库构建所有Boost库。这样我们就可以轻松使用所有库，而不必担心编译失败。
