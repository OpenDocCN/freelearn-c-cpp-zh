- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Using Super Builds to Simplify Onboarding
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用超级构建简化入门
- en: In this chapter, we’re going to return to simplifying and streamlining our project
    setup. There is a natural push/pull relationship during development between adding
    functionality and taming the added complexity. In [*Chapter 7*](B21152_07.xhtml#_idTextAnchor170),
    *Adding Install Support for Your Libraries*, we spent a lot of time changing directories
    and running CMake commands. To build our application, we need to navigate through
    at least five folders (`third-party`, `array`, `draw`, `gol`, and `app`), running
    a myriad of CMake commands along the way. This is a fantastic way to learn CMake,
    but not much fun when you want to get stuff done. It can also prevent unaccustomed
    users from accessing or contributing to your project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回到简化和精简项目设置的工作中。在开发过程中，添加功能和应对随之而来的复杂性之间总有一种自然的推拉关系。在[*第 7 章*](B21152_07.xhtml#_idTextAnchor170)《为你的库添加安装支持》中，我们花了大量时间切换目录并运行
    CMake 命令。为了构建我们的应用程序，我们需要穿越至少五个文件夹（`third-party`、`array`、`draw`、`gol` 和 `app`），并在途中运行大量
    CMake 命令。这是学习 CMake 的一种极好的方式，但当你想要完成工作时，这并不有趣。它还可能阻碍不熟悉的用户访问或贡献你的项目。
- en: It’s now time to address this. The skills you’ll learn in this chapter will
    help reduce the number of manual steps needed to get up and running with your
    project. This chapter will show you how to remove platform-specific scripts and
    automate more of the build process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解决这个问题了。你将在本章中学到的技能将有助于减少启动和运行项目所需的手动步骤。本章将向你展示如何去除平台特定的脚本，并自动化更多的构建过程。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要内容：
- en: Using `ExternalProject_Add` with your own libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ExternalProject_Add`与你自己的库
- en: Configuring a super build
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置超级构建
- en: Automating scripts with CMake
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CMake 自动化脚本
- en: Setting options in nested files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在嵌套文件中设置选项
- en: Installing an application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装应用程序
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along, please ensure you have met the requirements outlined in [*Chapter
    1*](B21152_01.xhtml#_idTextAnchor019), *Getting Started*. These include the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本教程，请确保已满足[*第 1 章*](B21152_01.xhtml#_idTextAnchor019)《入门》的要求。这些要求包括以下内容：
- en: A Windows, Mac, or Linux machine with an up-to-date **Operating** **System**
    (**OS**)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行最新**操作**系统（**OS**）的 Windows、Mac 或 Linux 机器
- en: A working C/C++ compiler (a system default is recommended for each platform
    if you don’t already have this)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可用的 C/C++ 编译器（如果你还没有，建议使用每个平台的系统默认编译器）
- en: 'The code examples in this chapter can be found by following this link: [https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以通过以下链接找到：[https://github.com/PacktPublishing/Minimal-CMake](https://github.com/PacktPublishing/Minimal-CMake)。
- en: Using ExternalProject_Add with your own libraries
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ExternalProject_Add 与你自己的库
- en: 'In the previous chapter, we stuck largely to manual CMake build and install
    commands (along with a bit of help from CMake presets) to increase our familiarity
    with CMake, and to work at a slightly lower level of abstraction to understand
    what CMake is doing behind the scenes. Now that we’re a bit more comfortable with
    these concepts, it’s time to remove the tedium of navigating to each individual
    library folder and running the familiar CMake commands that follow:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们主要依靠手动 CMake 构建和安装命令（以及一些 CMake 预设的帮助）来增加我们对 CMake 的熟悉度，并以稍低的抽象层次工作，以理解
    CMake 在后台所做的事情。现在我们对这些概念已经更加熟悉，是时候去除在每个单独的库文件夹中导航并运行以下熟悉的 CMake 命令的乏味工作了：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can start updating our project to take advantage of the more useful features
    that CMake provides. To start with, we’re going to update our existing third-party
    `CMakeLists.txt` file to bring in not only SDL 2 and bgfx but also the libraries
    we created and depend on. This will remove the need for us to manually install
    them and allow us to run a single pair of CMake commands (configure and build/install)
    to retrieve all the dependencies we need for our *Game of* *Life* application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始更新项目，利用 CMake 提供的更多有用功能。首先，我们将更新现有的第三方 `CMakeLists.txt` 文件，不仅引入 SDL 2
    和 bgfx，还包括我们创建并依赖的库。这将消除我们手动安装这些库的需要，并允许我们运行一对 CMake 命令（配置和构建/安装）来获取我们所需的所有依赖项，以支持我们的*生命游戏*应用程序。
- en: Let’s start by looking at `ch8/part-1/third-party/CMakeLists.txt`. The file
    is largely the same as before, only underneath our existing `ExternalProject_Add`
    commands, we’ve added references to our libraries found in `ch8/part-1/lib`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先查看`ch8/part-1/third-party/CMakeLists.txt`。该文件与之前大致相同，只是在现有的`ExternalProject_Add`命令下，我们添加了对位于`ch8/part-1/lib`中的库的引用。
- en: 'Here is an example of the `mc-array` library:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`mc-array`库的示例：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The command should look remarkably similar to those we covered in [*Chapter
    6*](B21152_06.xhtml#_idTextAnchor152), *Installing Dependencies and ExternalProject_Add*.
    The only real difference is the reference to `SOURCE_DIR`. Given the slightly
    unconventional layout of this book’s repository, we can reference the source folder
    directly, as the library source code is stored in the same repository:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令看起来与我们在[*第6章*](B21152_06.xhtml#_idTextAnchor152)中讲解的非常相似，*安装依赖项和ExternalProject_Add*。唯一的真正不同之处是对`SOURCE_DIR`的引用。由于本书仓库的布局稍显不传统，我们可以直接引用源文件夹，因为库的源代码存储在同一仓库中：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ExternalProject_Add(
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ExternalProject_Add(
- en: mc-array
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: mc-array
- en: GIT_REPOSITORY https://github.com/PacktPublishing/Minimal-CMake.git
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: GIT_REPOSITORY https://github.com/PacktPublishing/Minimal-CMake.git
- en: GIT_TAG 18535c9d140e828895c57dbb39b97a3307f846ab
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: GIT_TAG 18535c9d140e828895c57dbb39b97a3307f846ab
- en: SOURCE_SUBDIR ch8/part-1/lib/array
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: SOURCE_SUBDIR ch8/part-1/lib/array
- en: '...'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ExternalProject_Add(
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ExternalProject_Add(
- en: bgfxt
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: bgfxt
- en: GIT_REPOSITORY https://github.com/bkaradzic/bgfx.cmake.git
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: GIT_REPOSITORY https://github.com/bkaradzic/bgfx.cmake.git
- en: GIT_TAG v1.127.8710-464
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: GIT_TAG v1.127.8710-464
- en: '...'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: ExternalProject_Get_Property(bgfxt SOURCE_DIR)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ExternalProject_Get_Property(bgfxt SOURCE_DIR)
- en: ExternalProject_Add(
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ExternalProject_Add(
- en: bgfx
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: bgfx
- en: URL "file://${SOURCE_DIR}"
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: URL "file://${SOURCE_DIR}"
- en: DEPENDS bgfxt
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: DEPENDS bgfxt
- en: '...'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: cmake -B build -G "Ninja Multi-Config"
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: cmake -B build -G "Ninja Multi-Config"
- en: cmake --build build --config Release
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --build build --config Release
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: cmake --preset multi-ninja
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --preset multi-ninja
- en: cmake --build build/multi-ninja --config Release
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --build build/multi-ninja --config Release
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ./compile-shader-<platform>.sh/bat
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ./compile-shader-<platform>.sh/bat
- en: ./build/multi-ninja/Release/minimal-cmake_game-of-life_window
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ./build/multi-ninja/Release/minimal-cmake_game-of-life_window
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: .
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: ├── app
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ├── app
- en: │   └── third-party
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: │   └── third-party
- en: └── lib
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: └── lib
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: .
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: ├── app
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ├── app
- en: ├── third-party
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ├── third-party
- en: └── lib
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: └── lib
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: option(SUPERBUILD "Perform a superbuild (or not)" OFF)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: option(SUPERBUILD "执行超级构建（或不执行）" OFF)
- en: if(SUPERBUILD)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: if(SUPERBUILD)
- en: add_subdirectory(third-party)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: add_subdirectory(third-party)
- en: return()
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: return()
- en: endif()
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: endif()
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: if(SUPERBUILD AND NOT PROJECT_IS_TOP_LEVEL)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: if(SUPERBUILD AND NOT PROJECT_IS_TOP_LEVEL)
- en: set(PREFIX_DIR ${CMAKE_CURRENT_SOURCE_DIR}/build)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: set(PREFIX_DIR ${CMAKE_CURRENT_SOURCE_DIR}/build)
- en: else()
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: else()
- en: set(PREFIX_DIR ${CMAKE_CURRENT_BINARY_DIR})
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: set(PREFIX_DIR ${CMAKE_CURRENT_BINARY_DIR})
- en: endif()
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: endif()
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: set(THIRD_PARTY_BINARY_DIR
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: set(THIRD_PARTY_BINARY_DIR
- en: '"${CMAKE_SOURCE_DIR}/build-third-party"'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '"${CMAKE_SOURCE_DIR}/build-third-party"'
- en: CACHE STRING "Third-party build folder")
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: CACHE STRING "第三方构建文件夹")
- en: if(NOT IS_ABSOLUTE ${THIRD_PARTY_BINARY_DIR})
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: if(NOT IS_ABSOLUTE ${THIRD_PARTY_BINARY_DIR})
- en: set(THIRD_PARTY_BINARY_DIR
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: set(THIRD_PARTY_BINARY_DIR
- en: '"${CMAKE_SOURCE_DIR}/${THIRD_PARTY_BINARY_DIR}")'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '"${CMAKE_SOURCE_DIR}/${THIRD_PARTY_BINARY_DIR}")'
- en: endif()
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: endif()
- en: set(PREFIX_DIR ${THIRD_PARTY_BINARY_DIR})
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: set(PREFIX_DIR ${THIRD_PARTY_BINARY_DIR})
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ExternalProject_Add(
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ExternalProject_Add(
- en: <name>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <name>
- en: '...'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: PREFIX ${PREFIX_DIR}/<name>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: PREFIX ${PREFIX_DIR}/<name>
- en: BINARY_DIR ${PREFIX_DIR}/<name>/build/${build_type_dir}
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: BINARY_DIR ${PREFIX_DIR}/<name>/build/${build_type_dir}
- en: INSTALL_DIR ${CMAKE_CURRENT_SOURCE_DIR}/install
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: INSTALL_DIR ${CMAKE_CURRENT_SOURCE_DIR}/install
- en: '...)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '...)'
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: if(SUPERBUILD AND NOT PROJECT_IS_TOP_LEVEL)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: if(SUPERBUILD AND NOT PROJECT_IS_TOP_LEVEL)
- en: ExternalProject_Add(
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ExternalProject_Add(
- en: ${CMAKE_PROJECT_NAME}_superbuild
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ${CMAKE_PROJECT_NAME}_superbuild
- en: DEPENDS SDL2 bgfx mc-gol mc-draw
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: DEPENDS SDL2 bgfx mc-gol mc-draw
- en: SOURCE_DIR ${CMAKE_SOURCE_DIR}
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: SOURCE_DIR ${CMAKE_SOURCE_DIR}
- en: BINARY_DIR ${CMAKE_BINARY_DIR}
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: BINARY_DIR ${CMAKE_BINARY_DIR}
- en: CMAKE_ARGS -DCMAKE_PREFIX_PATH=${CMAKE_PREFIX_PATH}
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CMAKE_ARGS -DCMAKE_PREFIX_PATH=${CMAKE_PREFIX_PATH}
- en: -DSUPERBUILD=OFF ${build_type_arg}
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: -DSUPERBUILD=OFF ${build_type_arg}
- en: INSTALL_COMMAND "")
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: INSTALL_COMMAND "")
- en: endif()
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: endif()
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '"name": "super",'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "super",'
- en: '"hidden": true,'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '"hidden": true,'
- en: '"cacheVariables": {'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '"cacheVariables": {'
- en: '"SUPERBUILD": "ON"'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '"SUPERBUILD": "ON"'
- en: '}'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '"name": "multi-ninja-super",'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "multi-ninja-super",'
- en: '"inherits": ["multi-ninja", "super"]'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '"inherits": ["multi-ninja", "super"]'
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: cmake --preset multi-ninja-super
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --preset multi-ninja-super
- en: cmake --build build/multi-ninja-super
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --build build/multi-ninja-super
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: build preset
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建预设
- en: '"name": "multi-ninja-super",'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "multi-ninja-super",'
- en: '"configurePreset": "multi-ninja-super"'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '"configurePreset": "multi-ninja-super"'
- en: workflow preset
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作流预设
- en: '"name": "multi-ninja-super",'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "multi-ninja-super",'
- en: '"steps": ['
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '"steps": ['
- en: '{'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"type": "configure",'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "configure",'
- en: '"name": "multi-ninja-super"'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "multi-ninja-super"'
- en: '},'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '{'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"type": "build",'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '"type": "build",'
- en: '"name": "multi-ninja-super"'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "multi-ninja-super"'
- en: '}'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ']'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: cmake --workflow --preset multi-ninja-super
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --workflow --preset multi-ninja-super
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ./compile-shaders-<platform>.sh/bat
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ./compile-shaders-<platform>.sh/bat
- en: ./build/multi-ninja-super/Release/minimal-cmake_game-of-life_window
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ./build/multi-ninja-super/Release/minimal-cmake_game-of-life_window
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'build/multi-ninja-super # super build'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'build/multi-ninja-super # 超级构建'
- en: 'build/multi-ninja # regular build'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'build/multi-ninja # 常规构建'
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: defaults to Debug
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认构建为Debug
- en: cmake --preset multi-ninja-super
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --preset multi-ninja-super
- en: builds everything as Debug
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Debug模式下构建所有内容
- en: cmake --build build/multi-ninja-super
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --build build/multi-ninja-super
- en: only builds application in Release
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅在Release模式下构建应用程序
- en: cmake --build build/multi-ninja-super --config Release
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --build build/multi-ninja-super --config Release
- en: must rerun configure first
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必须先重新运行配置
- en: cmake --preset multi-ninja-super
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --preset multi-ninja-super
- en: now builds everything as Release
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在以Release模式构建所有内容
- en: cmake --build build/multi-ninja-super --config Release
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --build build/multi-ninja-super --config Release
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: app/build
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: app/build
- en: app/build-third-party
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: app/build-third-party
- en: app/third-party/install
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: app/third-party/install
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: hello-world.cmake
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hello-world.cmake
- en: message(STATUS "Hello, World!")
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: message(STATUS "Hello, World!")
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: -- Hello, World!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: -- Hello, World!
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: cmake -DA_USEFUL_SETTING=ON -P cmake-script.cmake
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: cmake -DA_USEFUL_SETTING=ON -P cmake-script.cmake
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: cmake_path(
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: cmake_path(
- en: GET CMAKE_SCRIPT_MODE_FILE PARENT_PATH
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: GET CMAKE_SCRIPT_MODE_FILE PARENT_PATH
- en: COMPILE_SHADER_DIR)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: COMPILE_SHADER_DIR)
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: cmake_path(
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: cmake_path(
- en: GET COMPILE_SHADER_DIR PARENT_PATH
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: GET COMPILE_SHADER_DIR PARENT_PATH
- en: COMPILE_SHADER_WORKING_DIR)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: COMPILE_SHADER_WORKING_DIR)
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: file(
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: file(
- en: MAKE_DIRECTORY
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: MAKE_DIRECTORY
- en: ${COMPILE_SHADER_WORKING_DIR}/shader/build)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ${COMPILE_SHADER_WORKING_DIR}/shader/build)
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: execute_process(
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: execute_process(
- en: COMMAND
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: COMMAND
- en: third-party/install/bin/shaderc
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: third-party/install/bin/shaderc
- en: -f shader/vs_vertcol.sc
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: -f shader/vs_vertcol.sc
- en: -o shader/build/vs_vertcol.bin
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: -o shader/build/vs_vertcol.bin
- en: --platform osx --type vertex
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: --platform osx --type vertex
- en: -i ./ -p metal --verbose
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: -i ./ -p metal --verbose
- en: WORKING_DIRECTORY ${COMPILE_SHADER_WORKING_DIR})
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: WORKING_DIRECTORY ${COMPILE_SHADER_WORKING_DIR})
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: option(
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: option(
- en: USE_VERBOSE_SHADER_OUTPUT
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: USE_VERBOSE_SHADER_OUTPUT
- en: '"Show output from shader compilation" OFF)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '"显示着色器编译输出" OFF)'
- en: if(USE_VERBOSE_SHADER_OUTPUT)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果(USE_VERBOSE_SHADER_OUTPUT)
- en: set(VERBOSE_SHADER_OUTPUT --verbose)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: set(VERBOSE_SHADER_OUTPUT --verbose)
- en: endif()
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: endif()
- en: execute_process(
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: execute_process(
- en: COMMAND
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: COMMAND
- en: '...'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: ${VERBOSE_SHADER_OUTPUT}
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ${VERBOSE_SHADER_OUTPUT}
- en: WORKING_DIRECTORY ${COMPILE_SHADER_WORKING_DIR})
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: WORKING_DIRECTORY ${COMPILE_SHADER_WORKING_DIR})
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: cmake --verbose, shaderc still outputs some information to the terminal, which
    can clutter the normal CMake build output. To hide this as well, we can introduce
    one more CMake variable called QUIET_SHADER_OUTPUT, and then set it to ERROR_QUIET
    (or OUTPUT_QUIET on Linux) to suppress all output from the execute_process command
    (OUTPUT_QUIET and ERROR_QUIET map to standard output and error output, e.g., fprintf,
    stdout and stderr in C and std::cout and std::cerr in C++).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: cmake --verbose，shaderc仍然会将一些信息输出到终端，这可能会干扰正常的CMake构建输出。为了隐藏这些信息，我们可以引入另一个CMake变量叫做QUIET_SHADER_OUTPUT，然后将其设置为ERROR_QUIET（或在Linux上设置为OUTPUT_QUIET）以抑制`execute_process`命令的所有输出（OUTPUT_QUIET和ERROR_QUIET分别对应标准输出和标准错误输出，例如C语言中的`fprintf`，`stdout`和`stderr`，以及C++中的`std::cout`和`std::cerr`）。
- en: 'Our final code looks like this:'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的最终代码如下：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This does mean that we can’t currently have non-verbose output; it’s all or
    nothing, but this is usually sufficient for how we would want to invoke these
    scripts. The changes across all `compile-shader-<platform>.cmake` files are nearly
    identical and we’re now ready to look at how to invoke these scripts from our
    app’s `CMakeLists.txt` file.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着我们目前无法拥有非详细输出；要么全开，要么全关，但这通常足以满足我们调用这些脚本的需求。所有`compile-shader-<platform>.cmake`文件中的变化几乎是相同的，现在我们已经准备好查看如何从我们应用的`CMakeLists.txt`文件中调用这些脚本。
- en: Invoking the CMake script from CMakeLists.txt
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从CMakeLists.txt调用CMake脚本
- en: 'Our script is now ready to be invoked from our `CMakeLists.txt` file. The first
    thing we need to do is refer to the right file depending on the platform we’re
    building for. We can do this with a simple conditional check:'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的脚本现在可以从`CMakeLists.txt`文件中调用。首先，我们需要根据构建的平台引用正确的文件。我们可以通过简单的条件检查来实现：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now reference `COMPILE_SHADER_SCRIPT` to get the correct file for our
    platform. There are then two different options to automatically invoke our scripts.
    One possibility is to use `include` to bring the script directly into our `CMakeLists.txt`
    file:'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们可以引用`COMPILE_SHADER_SCRIPT`来获取适合我们平台的文件。接下来有两种不同的方式可以自动调用我们的脚本。一个方法是使用`include`将脚本直接引入到我们的`CMakeLists.txt`文件中：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Unfortunately, our existing `compile-shader-<platform>.cmake` files won’t work
    as-is with this approach. We need to update how we populate `COMPILE_SHADER_WORKING_DIR`.
    We can achieve this with the following check:'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不幸的是，现有的`compile-shader-<platform>.cmake`文件不能直接与此方法一起使用。我们需要更新如何填充`COMPILE_SHADER_WORKING_DIR`。我们可以通过以下检查来实现：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`CMAKE_SCRIPT_MODE_FILE` will not be set (also called populated) when a CMake
    script is invoked as part of a `CMakeLists.txt` file, and `CMAKE_PARENT_LIST_FILE`
    is the full path to the CMake file that included it. By using these two checks
    we can ensure the first branch will only be taken when the file is run in script
    mode and when it is not included by another file. If we know that the file is
    being invoked from a `CMakeLists.txt` file, we can simply set `COMPILE_SHADER_WORKING_DIR`
    to `CMAKE_SOURCE_DIR` (which will be the folder containing our root `CMakeLists.txt`
    file), and things will work as expected.'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当CMake脚本作为`CMakeLists.txt`文件的一部分被调用时，`CMAKE_SCRIPT_MODE_FILE`不会被设置（也叫填充），而`CMAKE_PARENT_LIST_FILE`是包含它的CMake文件的完整路径。通过使用这两个检查，我们可以确保只有在文件以脚本模式运行且未被其他文件包含时，才会执行第一个分支。如果我们知道该文件是从`CMakeLists.txt`文件中调用的，我们可以简单地将`COMPILE_SHADER_WORKING_DIR`设置为`CMAKE_SOURCE_DIR`（它将是包含根`CMakeLists.txt`文件的文件夹），这样一切就会按预期工作。
- en: 'With this approach, the shaders will be built every time we configure. There
    is an alternative approach that can be used instead of using `include`, and that
    is using a CMake command we’ve come across before, `add_custom_command`. With
    `add_custom_command`, we can specify a target and the time the command should
    be run (in the example that follows, we use `POST_BUILD` to invoke the command
    after our application is built). The full command is as follows:'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用这种方法时，每次配置时都会构建着色器。还有一种替代方法可以代替使用`include`，那就是使用我们之前遇到过的CMake命令`add_custom_command`。通过`add_custom_command`，我们可以指定一个目标和命令执行的时机（在下面的示例中，我们使用`POST_BUILD`在应用程序构建完成后调用该命令）。完整的命令如下：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This command is very convenient for our users and ensures that the shaders are
    compiled before the application is run. The downside is that right now, the command
    will likely run more often than is strictly necessary, which may become a problem
    in the future if the command grows and starts to take longer to run.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个命令对我们的用户非常方便，并确保在应用程序运行之前先编译着色器。缺点是，目前该命令可能比严格必要时运行得更频繁，如果命令变得更复杂并开始需要更长时间运行，将来可能会成为一个问题。
- en: There is an alternative version of `add_custom_command`, which, instead of accepting
    a target (`TARGET`), takes an output file (`OUTPUT`). It’s possible to list dependencies
    with the `DEPENDS` argument to have the command only run when the output files
    need updating. This can be very efficient but unfortunately is a little more complex
    to set up, and as the preceding command in its current form is fast to run, the
    simpler version is used instead (to learn more about `add_custom_command`, see
    [https://cmake.org/cmake/help/latest/command/add_custom_command.html](https://cmake.org/cmake/help/latest/command/add_custom_command.html)).
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还有一个`add_custom_command`的替代版本，它不是接受一个目标（`TARGET`），而是接受一个输出文件（`OUTPUT`）。通过`DEPENDS`参数可以列出依赖项，只有在输出文件需要更新时，命令才会执行。这种方法非常高效，但遗憾的是，设置起来稍微复杂一些，而由于前面的命令执行较快，当前使用的是较简单的版本（要了解更多关于`add_custom_command`的信息，请查看[https://cmake.org/cmake/help/latest/command/add_custom_command.html](https://cmake.org/cmake/help/latest/command/add_custom_command.html)））。
- en: 'With our new command added, we have everything we need to build our entire
    application and accompanying resources (shaders) with one command. From `ch8/part-3/app`,
    run the following:'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加新命令后，我们已经拥有了使用一个命令构建整个应用程序和附带资源（着色器）所需的一切。从`ch8/part-3/app`目录下，运行以下命令：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once the build completes, all that’s left is to run the application itself:'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦构建完成，剩下的就是运行应用程序本身：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It is, of course, also possible to configure and build separately as we’ve done
    before using CMake’s `--preset` and `--build` arguments. Taking advantage of `--workflow`
    is particularly convenient here, though.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，我们也可以像之前一样使用CMake的`--preset`和`--build`参数分别进行配置和构建。不过，利用`--workflow`在这里特别方便。
- en: 'Review the `ch8/part-3/app/CMakeLists.txt` and `ch8/part-3/app/cmake/compile-shader-<platform>.cmake`
    files to see everything in context. One small change you may notice is a simplified
    check at the top of every `compile-shader-<platform>.cmake` file to ensure they
    must be run in script mode:'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 审查`ch8/part-3/app/CMakeLists.txt`和`ch8/part-3/app/cmake/compile-shader-<platform>.cmake`文件，查看上下文中的所有内容。你可能会注意到一个小变化，那就是在每个`compile-shader-<platform>.cmake`文件的顶部，加入了一个简化的检查，以确保它们必须在脚本模式下运行：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As a reminder, the `ch8/part-2/app` and `ch8/part-3/app`.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提醒一下，`ch8/part-2/app`和`ch8/part-3/app`。
- en: Setting options in nested files
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在嵌套文件中设置选项
- en: The steps we’ve taken to streamline and simplify building our application have
    made a world of difference and will save time and mental energy in the future.
    We have unfortunately lost one thing in the process though, and that’s the ability
    to adjust how our dependencies are built. Previously, when we were using `FetchContent`
    and were building the dependencies directly, we could pass through the various
    build options to set whether to build a particular library as static or shared.
    In [*Chapter 7*](B21152_07.xhtml#_idTextAnchor170), *Adding Install Support for
    Your Libraries*, when we looked at building our libraries separately and installing
    them manually, we could also decide how to build them. Unfortunately, with our
    use of `ExternalProject_Add`, we’ve lost some of that flexibility as it’s not
    possible to pass through options directly to an `ExternalProject_Add` command
    without a little extra scaffolding.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们为简化和精简应用程序构建所采取的步骤已经带来了巨大的变化，并将在未来节省时间和精力。然而，我们在这个过程中不幸失去了一样东西，那就是调整依赖项构建方式的能力。之前，当我们使用`FetchContent`并直接构建依赖项时，我们可以传递各种构建选项来设置是否将特定库构建为静态库或共享库。在[*第7章*](B21152_07.xhtml#_idTextAnchor170)中，*为库添加安装支持*，当我们考虑单独构建库并手动安装时，我们也可以决定如何构建它们。不幸的是，通过使用`ExternalProject_Add`，我们失去了一些灵活性，因为没有额外的支撑框架，无法直接将选项传递给`ExternalProject_Add`命令。
- en: Fortunately, the loss of flexibility is not too difficult to restore. All that’s
    needed is to create our own CMake options, and then forward them to the internal
    `ExternalProject_Add` command as part of the `CMAKE_ARGS` argument.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 幸运的是，失去的灵活性并不难恢复。所需的仅仅是创建我们自己的CMake选项，然后将它们作为`CMAKE_ARGS`参数的一部分转发给内部的`ExternalProject_Add`命令。
- en: 'For example, if we look at `ch8/part-4/app/third-party/CMakeLists.txt`, we
    can see, at the top of the file, that we’ve added two new options:'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，如果我们查看`ch8/part-4/app/third-party/CMakeLists.txt`，我们可以看到在文件顶部，我们添加了两个新选项：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We’ve used the same names that exist in the libraries themselves for consistency,
    but we’re free to adjust the naming if we choose to group the variables with the
    application we’re building. We then pass these new values to `ExternalProject_Add`,
    which looks like this:'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用了与库中实际存在的名称相同的名称，以保持一致性，但如果我们选择将变量与我们正在构建的应用程序分组，仍然可以自由调整命名。然后，我们将这些新值传递给`ExternalProject_Add`，其形式如下：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This allows us to decide whether to build our dependencies as static or shared
    even when using `ExternalProject_Add` to bring them in. Any other options exposed
    by the library we do not wish to change can be hardcoded.
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这使我们即使在使用`ExternalProject_Add`引入依赖项时，也能决定是否将其构建为静态库或共享库。我们不希望更改的库暴露的其他选项可以硬编码。
- en: 'We also need to do the same thing for our `compile-shader-<platform>.cmake`
    scripts. The `USE_VERBOSE_SHADER_OUTPUT` setting won’t be automatically detected
    because of the way we’re calling the script from our `CMakeLists.txt` file (if
    we’d used `include`, it would have been picked up and added to the main project’s
    `CMakeCache.txt` file). To work around this, we simply need to add the setting
    to our `CMakeLists.txt` file and then send it to the invocation of the script:'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要对`compile-shader-<platform>.cmake`脚本做同样的事情。由于我们从`CMakeLists.txt`文件调用脚本的方式，`USE_VERBOSE_SHADER_OUTPUT`设置不会自动检测到（如果我们使用`include`，它会被拾取并添加到主项目的`CMakeCache.txt`文件中）。为了解决这个问题，我们只需将该设置添加到`CMakeLists.txt`文件中，然后将其传递给脚本的调用：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: See `ch8/part-4/app/CMakeLists.txt` for the complete example.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参阅`ch8/part-4/app/CMakeLists.txt`以获取完整示例。
- en: The need for this kind of variable forwarding predominantly comes up with `ExternalProject_Add`.
    When using super builds, we need to remember to follow the same approach to pass
    through options to our nested application. This is why sometimes, having a normal
    non-super build project can be useful (see the `multi-ninja` and `multi-ninja-super`
    CMake presets in `ch8/part-4/app/CMakePresets.json` for an example). The number
    of options to configure for an application will usually be small, and you can
    set the remaining options that aren’t expected to change directly in the `ExternalProject_Add`
    calls themselves, but it’s useful to sometimes offer a way to change these if
    needed.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种变量传递的需求主要出现在`ExternalProject_Add`中。当使用超级构建时，我们需要记住遵循相同的方法，将选项传递到嵌套的应用程序中。这就是为什么有时使用普通的非超级构建项目会很有用（请参见`ch8/part-4/app/CMakePresets.json`中的`multi-ninja`和`multi-ninja-super`
    CMake预设作为示例）。配置应用程序的选项数量通常较少，您可以将剩余的、不需要更改的选项直接设置在`ExternalProject_Add`调用中，但有时提供一种更改这些选项的方法会很有用。
- en: Installing an application
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装应用程序
- en: Rounding out this chapter, we’re going to look at one final addition, and that’s
    how to add install support to our application. This is to help prepare for packaging
    and ensure that our application is portable.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本章的最后，我们将看一个最终的添加内容，那就是如何为我们的应用程序添加安装支持。这有助于为打包做好准备，并确保我们的应用程序具有可移植性。
- en: 'The first change we’ll make is to add a `CMAKE_INSTALL_PREFIX` variable to
    our app’s `CMakePresets.json` file to ensure that our application is installed
    in a location relative to our project:'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们要做的第一个更改是将一个`CMAKE_INSTALL_PREFIX`变量添加到我们应用程序的`CMakePresets.json`文件中，以确保我们的应用程序安装在相对于项目的路径中：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The following changes are then reserved exclusively for `ch8/part-5/app/CMakeLists.txt`.
    We first need to include `GNUInstallDirs` as we did for our libraries to gain
    access to standard CMake install locations (in this example, we only really care
    about `CMAKE_INSTALL_BINDIR`).
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来的一些更改将专门针对`ch8/part-5/app/CMakeLists.txt`。首先，我们需要像为库一样包含`GNUInstallDirs`，以访问标准的CMake安装位置（在这个例子中，我们只关心`CMAKE_INSTALL_BINDIR`）。
- en: The high-level goal we want to achieve is to have a relocatable folder containing
    the executable of our application, shared libraries that need to be loaded by
    the app, and resources needed at runtime (our compiled shader files). We can achieve
    this with the following CMake install commands.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们想要实现的高层目标是拥有一个可重定位的文件夹，包含我们的应用程序可执行文件、需要由应用程序加载的共享库以及运行时所需的资源（我们编译的着色器文件）。我们可以通过以下CMake安装命令来实现这一目标。
- en: 'The first is simple; it copies the application executable to the `install`
    folder:'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个步骤很简单，它将应用程序的可执行文件复制到`install`文件夹：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We provide the target to copy and the `RUNTIME` type to refer to executables,
    along with the destination to copy the file to (this will more than likely be
    `bin` and will be relative to the `CMAKE_INSTALL_PREFIX` variable we provided
    in our `CMakePresets.json` file).
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们提供目标以复制，并使用`RUNTIME`类型来指代可执行文件，同时指定复制目标路径（这通常是`bin`，并且会相对于我们在`CMakePresets.json`文件中提供的`CMAKE_INSTALL_PREFIX`变量）。
- en: 'Next, we need to copy the shared library files that our application will need
    to load when it starts. As we’re developing a cross-platform application, for
    simplicity, we’re going to copy all shared library files (`.dll` on Windows, `.dylib`
    on macOS, and `.so` on Linux) to the same folder as our application. This is remarkably
    like what we were doing before on Windows, but we’re now going to do the same
    for all platforms for consistency. An abridged install command to copy these files
    looks like the following:'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们需要复制应用程序启动时需要加载的共享库文件。由于我们正在开发一个跨平台应用程序，为了简化起见，我们将所有共享库文件（Windows上的`.dll`、macOS上的`.dylib`和Linux上的`.so`）复制到与应用程序相同的文件夹。这与我们之前在Windows上做的非常相似，但现在我们将在所有平台上做同样的事，以保持一致性。复制这些文件的简化安装命令如下所示：
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As our *Game of Life* and *Draw* libraries can be compiled as either static
    or shared (dynamic) libraries, we need to check that the target is the right type
    before copying it, otherwise, we’d wind up copying the `.lib`/`.a` static library
    files unnecessarily.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们的*生命游戏*和*绘图*库可以编译为静态库或共享（动态）库，我们需要检查目标是否是正确的类型，然后再复制它，否则我们将不必要地复制`.lib`/`.a`静态库文件。
- en: 'We can do this with the generator expression shown here:'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过这里显示的生成器表达式来实现：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: set_target_properties(
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: set_target_properties(
- en: ${PROJECT_NAME}
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ${PROJECT_NAME}
- en: PROPERTIES
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: PROPERTIES
- en: INSTALL_RPATH
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: INSTALL_RPATH
- en: '"$<$<PLATFORM_ID:Linux>:$ORIGIN>$<$<PLATFORM_ID:Darwin>:@loader_path>"'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '"$<$<PLATFORM_ID:Linux>:$ORIGIN>$<$<PLATFORM_ID:Darwin>:@loader_path>"'
- en: BUILD_RPATH property, we update the INSTALL_RPATH property to resolve to $ORIGIN
    on Linux, and @loader_path on macOS (this is to cause the executable to search
    for shared libraries in the same folder as itself). Since we want the same behavior
    for the normally built targets and installed targets, we also set BUILD_WITH_INSTALL_RPATH
    to TRUE, which is roughly equivalent to passing the same generator expression
    to BUILD_RPATH as we did before (we’re saying that BUILD_RPATH should be the same
    as INSTALL_RPATH).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 BUILD_RPATH 属性，我们将 INSTALL_RPATH 属性更新为在 Linux 上解析为 $ORIGIN，在 macOS 上解析为 @loader_path（这样做是为了使可执行文件在与自身相同的文件夹中查找共享库）。由于我们希望正常构建的目标和已安装的目标表现一致，因此我们还将
    BUILD_WITH_INSTALL_RPATH 设置为 TRUE，这大致相当于将相同的生成器表达式传递给 BUILD_RPATH，就像之前一样（我们在这里的意思是
    BUILD_RPATH 应该与 INSTALL_RPATH 相同）。
- en: We’ll now get the same behavior between built and installed targets as we’re
    copying the shared libraries to the build and install folders, respectively. We
    can safely remove the installed dependencies (the installed library files in `app/third-party/install`)
    after building and continue to run the application (this will, however, break
    our ability to compile and build again without first restoring the third-party
    dependencies by generating a new super build or configuring and building from
    the `third-party` folder).
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，通过将共享库分别复制到构建和安装文件夹中，我们实现了构建目标和安装目标之间的相同行为。构建完成后，我们可以安全地移除已安装的依赖项（即在 `app/third-party/install`
    中的已安装库文件），并继续运行应用程序（然而，这样会破坏我们重新编译和构建的能力，因为在没有先通过生成新的超级构建或配置并从 `third-party` 文件夹构建的情况下，无法恢复第三方依赖项）。
- en: '`RPATH` handling is a complex topic, and the solution presented here is only
    one way to handle installing shared libraries. To learn more, please refer to
    `RPATH`-related variables on the CMake properties documentation page ([https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html](https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html))
    and the `RPATH` handling section on the CMake community wiki ([https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling](https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling)).'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RPATH` 处理是一个复杂的话题，这里提供的解决方案只是处理共享库安装的一种方法。要了解更多内容，请参考 CMake 属性文档页面上的与 `RPATH`
    相关的变量（[https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html](https://cmake.org/cmake/help/latest/manual/cmake-properties.7.html)）以及
    CMake 社区 Wiki 上关于 `RPATH` 处理的部分（[https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling](https://gitlab.kitware.com/cmake/community/-/wikis/doc/cmake/RPATH-handling)）。'
- en: To ensure full cross-platform compatibility, there’s one more addition needed
    to correctly handle installing the SDL 2 dependency for our application on Linux.
    When SDL 2 is built on Linux, it provides several files as part of the shared
    library. These are related to `libSDL2-2.0.so.0.3000.2`, but this isn’t the file
    the dynamic linker looks for. The `libSDL2-2.0.so.0` file is a symbolic link to
    `libSDL2-2.0.so.0.3000.2` and is what is used by the dynamic linker when looking
    for the SDL 2 library. It’s important that we install both files; otherwise, our
    application will not be able to find the shared library at runtime.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了确保完全的跨平台兼容性，还需要进行最后一个添加，才能正确处理在 Linux 上为我们的应用程序安装 SDL 2 依赖项。当 SDL 2 在 Linux
    上构建时，它会提供作为共享库的一部分的多个文件。这些文件与 `libSDL2-2.0.so.0.3000.2` 相关，但这不是动态链接器查找的文件。`libSDL2-2.0.so.0`
    文件是指向 `libSDL2-2.0.so.0.3000.2` 的符号链接，它是动态链接器在查找 SDL 2 库时使用的文件。确保我们安装这两个文件非常重要；否则，应用程序将在运行时找不到共享库。
- en: 'To support this, we just need to add one more rule to our `add_custom_command`
    and `install` calls, and that is to install `TARGET_NAME_SOFILE` in addition to
    `TARGET_FILE`, as shown here:'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了支持这一点，我们只需要在 `add_custom_command` 和 `install` 调用中再添加一条规则，那就是除了 `TARGET_FILE`
    之外，还需要安装 `TARGET_NAME_SOFILE`，如下所示：
- en: '[PRE47]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We also add a conditional generator expression to only evaluate this if we’re
    on Linux as it is not needed on other platforms.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还添加了一个条件生成器表达式，只有在 Linux 平台上才会评估此表达式，因为在其他平台上不需要。
- en: 'Finally, there’s one last set of files we need to install and that’s our compiled
    shaders. We install them to the same relative location as when we launch from
    the `app` folder. The CMake `install` command to achieve this is as follows:'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们需要安装的最后一组文件是我们编译的着色器。我们将它们安装到与从 `app` 文件夹启动时相同的相对位置。实现这一目标的 CMake `install`
    命令如下所示：
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We copy the `build` directory under `shader` to the same folder we’ve installed
    our executable and shared library files into. This is so it appears at the same
    relative position when running our application from `ch8/part-5/app/install/bin`
    as when we ran it from `ch8/part-5/app` before.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将`shader`下的`build`目录复制到我们安装可执行文件和共享库文件的相同文件夹中。这样，当我们从`ch8/part-5/app/install/bin`运行应用程序时，它在相对位置上看起来与之前从`ch8/part-5/app`运行时相同。
- en: 'With that final change, we have everything we need to install our application.
    We now just need to run the following command to build and install our application
    from the `ch8/part-5/app` folder:'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 经过最后的更改，我们拥有了安装应用程序所需的一切。我们现在只需要运行以下命令，从`ch8/part-5/app`文件夹构建并安装我们的应用程序：
- en: '[PRE49]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When building from the super build directory (`multi-ninja-super`), because
    we’re using `ExternalProject_Add` to wrap our project (`${CMAKE_PROJECT_NAME}_superbuild`
    at the end of `app/third-party/CMakeLists.txt`), the install operation will happen
    automatically when running `cmake --build build/multi-ninja-super` (like when
    we build our third-party dependencies directly from the `third-party` folder).
    The first time we build after configuring, there is no need to pass `--target
    install` (attempting to pass it will, in fact, cause an error, as the install
    target won’t be found). Subsequent builds or builds from a normal build folder
    (e.g., `build/multi-ninja`) will need the `--target install` argument, as the
    install target will be available. Lastly, running the configure command again
    (e.g., `cmake --preset multi-ninja-super`) will reset this behavior for the following
    build.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当从超级构建目录（`multi-ninja-super`）构建时，由于我们使用`ExternalProject_Add`来包装我们的项目（在`app/third-party/CMakeLists.txt`的末尾为`${CMAKE_PROJECT_NAME}_superbuild`），安装操作会在运行`cmake
    --build build/multi-ninja-super`时自动发生（就像我们直接从`third-party`文件夹构建第三方依赖一样）。在配置后首次构建时，无需传递`--target
    install`（尝试传递该参数实际上会导致错误，因为找不到安装目标）。之后的构建或从普通构建文件夹（例如`build/multi-ninja`）构建时，将需要`--target
    install`参数，因为安装目标将可用。最后，再次运行配置命令（例如`cmake --preset multi-ninja-super`）将重置此行为，以便用于后续的构建。
- en: 'If we’d previously built our application with the `--workflow` preset, we could
    also use the CMake `--install` command instead:'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们之前使用`--workflow`预设构建了我们的应用程序，我们也可以改用CMake的`--install`命令：
- en: '[PRE50]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To launch the application, after installing, change directory to `ch8/part-5/app/install/bin`
    and run `./minimal-cmake_game-of-life_window`. Feel free to explore the contents
    of `ch8/part-5/app` to see everything in context and experiment by running the
    different CMake commands we’ve covered so far (starting with `cmake --preset list`
    and then running `cmake --preset <preset>` is a good place to start). Also, try
    copying or moving the `app/install/bin` folder to a new location (or machine,
    with a matching OS and architecture) to verify that the application still launches
    and runs successfully.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要启动应用程序，安装完成后，切换到`ch8/part-5/app/install/bin`目录并运行`./minimal-cmake_game-of-life_window`。可以自由地探索`ch8/part-5/app`的内容，以查看所有上下文，并通过运行我们到目前为止介绍的不同CMake命令进行实验（从`cmake
    --preset list`开始，然后运行`cmake --preset <preset>`是一个不错的起点）。还可以尝试将`app/install/bin`文件夹复制或移动到新的位置（或与之匹配的操作系统和架构的计算机上），以验证应用程序是否仍然能够启动并成功运行。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总结
- en: It’s time to take another well-deserved breather and let everything we’ve covered
    sink in. We touched on some advanced CMake features, so don’t fret if your head
    is spinning. The more you practice and experiment with these concepts, the more
    things will click.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是时候再休息一下，让我们所涵盖的内容稍微消化一下了。我们触及了一些高级CMake特性，如果你感到有些头晕也不用担心。你练习和实验这些概念的次数越多，理解会越来越清晰。
- en: In this chapter, we moved from installing our own libraries manually to leveraging
    `ExternalProject_Add` to automate the installation process. This takes a lot of
    the tedium out of setting up our project and is a useful strategy to apply to
    future projects. We then looked at setting up a super build for our project to
    offer a way to build everything with a single command without losing any of the
    flexibility we’ve come to expect. This technique further streamlines project configuration
    and is a fantastic default to provide users with when creating applications.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中，我们从手动安装自己的库转向利用`ExternalProject_Add`来自动化安装过程。这大大减少了设置项目时的繁琐步骤，并且是一种适用于未来项目的有用策略。接着，我们查看了为项目设置超级构建的过程，这提供了一种使用单个命令构建所有内容的方式，同时不失去我们所期望的灵活性。这种技术进一步简化了项目配置，是为用户创建应用程序时提供的极好的默认设置。
- en: Afterward, we saw how CMake can be used to replace cross-platform scripts and
    automate external processes such as shader compilation to make them part of the
    core build, and not an afterthought. This can save a lot of overhead when it comes
    to creating and supporting custom per-platform scripts. We next spent some time
    understanding how to expose customization points in our nested dependencies to
    continue to give users control over how they build their libraries. Without this,
    users may have to resort to editing `CMakeLists.txt` files in place, causing yet
    another maintenance headache. Finally, we walked through installing our application
    to make sharing it a breeze. This gets us one step closer to a fully distributable
    application and away from relying on the project layout to run the code.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后，我们了解了 CMake 如何替代跨平台脚本，并自动化外部过程，如着色器编译，将其纳入核心构建，而不是事后考虑的事情。这可以节省很多在创建和支持定制的每个平台脚本时的开销。接下来，我们花了一些时间理解如何暴露嵌套依赖中的自定义点，以继续让用户控制他们如何构建库。没有这一点，用户可能不得不编辑
    `CMakeLists.txt` 文件，进而带来另一个维护难题。最后，我们演示了如何安装应用程序，使其共享变得轻松。这使我们更接近一个完全可分发的应用程序，并摆脱了依赖项目布局来运行代码的束缚。
- en: In the next chapter, we’re going to cover a companion tool that comes bundled
    with CMake called CTest. CTest is an incredibly useful tool that helps streamline
    running many kinds of tests. We’ll look at adding tests to our libraries and applications
    and see how to share test results using another CMake tool called CDash.
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一章，我们将介绍一个与 CMake 一起捆绑的配套工具——CTest。CTest 是一个非常有用的工具，帮助简化执行各种测试。我们将学习如何将测试添加到我们的库和应用程序中，并了解如何使用另一个
    CMake 工具——CDash 来共享测试结果。
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
