- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Beyond Classes – Fundamental C++ Concepts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越类 – 基本C++概念
- en: Historically, C++ started as C with classes, making classes one of the first
    concepts for developers with a C background to learn. In the previous chapter,
    we covered classes in detail, and before proceeding with more advanced concepts,
    we will cover other fundamental C++ concepts that make it so much more than C
    with classes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，C++ 是从 C 语言加上类开始的，这使得类成为具有 C 背景的开发者要学习的第一个概念。在前一章中，我们详细介绍了类，在继续探讨更高级的概念之前，我们将介绍其他使
    C++ 远远超出具有类的 C 的基本 C++ 概念。
- en: 'Before we move on to more advanced topics, it’s important to explore other
    fundamental concepts that make C++ distinct. In this chapter, we’re going to cover
    the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续探讨更高级的主题之前，探索使 C++ 独特的其他基本概念是很重要的。在本章中，我们将涵盖以下主要主题：
- en: Namespaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Function overloading
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数重载
- en: Interoperability with C
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 C 的互操作性
- en: References
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用
- en: Standard library containers and algorithms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库容器和算法
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get the most out of this chapter, I strongly recommend using Compiler Explorer
    ([https://godbolt.org/](https://godbolt.org/)) as you read through the examples.
    Select GCC as your compiler and target x86 architecture. This will allow you to
    see standard output (stdio) results and better observe the code’s behavior. As
    we are using modern C++ features make sure to select C++23 standard, by adding
    `-std=c++23` in compiler options box.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章内容，我强烈建议你在阅读示例时使用 Compiler Explorer ([https://godbolt.org/](https://godbolt.org/))。选择
    GCC 作为你的编译器，并针对 x86 架构。这将允许你看到标准输出（stdio）结果，并更好地观察代码的行为。由于我们使用的是现代 C++ 功能，请确保选择
    C++23 标准，通过在编译器选项框中添加 `-std=c++23`。
- en: Compiler Explorer makes it easy to try out the code, tweak it, and immediately
    see how it affects the output and generated assembly. The examples are available
    at GitHub ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter06](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter06)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Compiler Explorer 使得尝试代码、调整代码并立即看到它如何影响输出和生成的汇编变得容易。示例可在 GitHub 上找到 ([https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter06](https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter06))。
- en: Namespaces
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: '**Namespaces** in C++ are used as scope specifiers for accessing type names,
    functions, variables, and so on. They allow us to more easily differentiate types
    and function names in large code bases that use many software components and where
    there are often similar identifiers.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**C++ 中的命名空间**用作访问类型名称、函数、变量等的作用域指定符。它们允许我们在使用许多软件组件且经常有相似标识符的大型代码库中更容易地区分类型和函数名称。'
- en: 'In C, we usually add a prefix to types and functions to make it easier to differentiate,
    for example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中，我们通常会给类型和函数添加前缀，以便更容易区分，例如：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In C++, we can use namespaces instead of C-style identifier prefixes to organize
    code in logical groups, as shown in the following example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，我们可以使用命名空间而不是 C 风格的标识符前缀来组织代码的逻辑组，如下面的示例所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'All members of the `hal` namespace are accessible unqualified from within the
    namespace. To access identifiers from the `hal` namespace, in code outside of
    it, we use the namespace as a qualifier followed by scope resolution operator
    (`::`), as shown in the following example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`hal` 命名空间的所有成员都可以在命名空间内部无修饰地访问。要访问 `hal` 命名空间中的标识符，在命名空间外部的代码中，我们使用命名空间作为限定符，后跟作用域解析运算符（`::`），如下面的示例所示：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, beside the `hal` namespace, we also see the `std` namespace,
    which we used in previous examples. C++ standard library types and functions are
    declared in the `std` namespace.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，除了 `hal` 命名空间外，我们还看到了 `std` 命名空间，我们在前面的例子中使用过它。C++ 标准库类型和函数在 `std` 命名空间中声明。
- en: 'We can use the `using` directive to access an identifier without qualifiers,
    as shown in the following example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `using` 指令来访问无修饰的标识符，如下面的示例所示：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `using` directive can also be used for the entire namespace, as shown in
    the following example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 指令也可以用于整个命名空间，如下面的示例所示：'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is recommended to use `using` directive sparingly, especially with `std`,
    using it for a limited scope, or even better, to bring in individual identifiers
    only.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 建议谨慎使用 `using` 指令，特别是与 `std` 一起使用，用于有限的作用域，或者更好的做法是仅引入单个标识符。
- en: The same namespace can be used across different header files to declare identifiers.
    For example, `std::vector` is declared in `vector.h`, and `std::array` is declared
    in `array.h` header files. This allows us to organize code from different headers
    that logically belong to the same group in a namespace.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个命名空间可以在不同的头文件中使用来声明标识符。例如，`std::vector` 在 `vector.h` 头文件中声明，而 `std::array`
    在 `array.h` 头文件中声明。这允许我们将属于同一逻辑组的来自不同头文件的代码组织在命名空间中。
- en: 'Functions and types that are not declared within an explicit namespace are
    part of a global namespace. It is a good practice to organize all code in namespaces.
    The only function that can’t be declared within a namespace and must be in a global
    namespace is `main`. To access the identifier from the global namespace, we use
    the scope resolution operator, as shown in the following example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 未在显式命名空间内声明的函数和类型是全局命名空间的一部分。将所有代码组织在命名空间中是一种良好的做法。唯一不能在命名空间内声明而必须位于全局命名空间中的函数是
    `main`。要访问全局命名空间中的标识符，我们使用作用域解析运算符，如下面的示例所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The line `return ::ret_val;` uses the scope resolution operator, `::`, without
    specifying a namespace. This means it refers to the global namespace. So, `::ret_val`
    accesses the `ret_val` variable defined outside of any function or class—that
    is, at the global scope.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 代码行 `return ::ret_val;` 使用了作用域解析运算符 `::`，但没有指定命名空间。这意味着它引用的是全局命名空间。因此，`::ret_val`
    访问的是在函数或类外部定义的 `ret_val` 变量——即在全局作用域中。
- en: Unnamed namespaces
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未命名的命名空间
- en: 'A namespace can be declared without the name qualifier. This allows us to declare
    functions and types that are local to the translation unit they are declared in.
    In the following example, we can see an example of an unnamed namespace:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间可以不使用名称限定符进行声明。这允许我们声明属于它们声明的翻译单元本地的函数和类型。在下面的示例中，我们可以看到一个未命名的命名空间的例子：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the code, we have an unnamed namespace with a few variables declared in it.
    They have **internal linkage**, meaning they cannot be accessed by code from other
    translation units. We can achieve the same effect both in C and C++ by using the
    `static` storage specifier.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们有一个包含一些变量声明的未命名的命名空间。它们具有**内部链接**，这意味着它们不能被来自其他翻译单元的代码访问。我们可以在C和C++中使用
    `static` 存储指定符来实现相同的效果。
- en: Nested namespaces
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套命名空间
- en: 'Namespaces can also be nested. We can have a namespace within a namespace,
    as shown in the following example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间也可以嵌套。我们可以在一个命名空间内部有另一个命名空间，如下面的示例所示：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this example, we have organized sensors in namespaces. We have a top-level
    namespace, `sensors`, which has two namespaces: `environmental` and `indoor_air_quality`.
    C++17 standard allows us to write namespaces, as shown in the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们已经在命名空间中组织了传感器。我们有一个顶级命名空间 `sensors`，它包含两个命名空间：`environmental` 和 `indoor_air_quality`。C++17标准允许我们编写命名空间，如下面的示例所示：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Namespaces are a good way to make the code more readable, as they allow us to
    keep identifiers short, without C-style prefixes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是使代码更易读的好方法，因为它们允许我们保持标识符短，而不需要C风格的前缀。
- en: Function overloading
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数重载
- en: 'In the previous chapter, when we discussed inheritance, we mentioned **static
    binding**. We saw that we can have the same function names for functions that
    belong to different classes. However, we can also have the same function names
    for different function parameters, as shown in the following example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，当我们讨论继承时，我们提到了**静态绑定**。我们看到了可以为属于不同类的函数使用相同的函数名。然而，我们也可以为不同的函数参数使用相同的函数名，如下面的示例所示：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we have two `print` functions. One of them has an `int` as
    a parameter and the second one has a `float`. On the call site, the compiler will
    pick a `print` function based on the arguments passed to the function call.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个 `print` 函数。其中一个有一个 `int` 类型的参数，另一个有一个 `float` 类型的参数。在调用位置，编译器将根据传递给函数调用的参数选择一个
    `print` 函数。
- en: Functions with the same names within the same scope are called **overloaded
    functions**. Instead of having two different names, such as `print_int` and `print_float`,
    we can use the same name for both these functions and let the compiler decide
    which function to call.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一作用域内具有相同名称的函数称为**重载函数**。我们不需要为这两个函数使用两个不同的名称，如 `print_int` 和 `print_float`，我们可以为这两个函数使用相同的名称，让编译器决定调用哪个函数。
- en: 'To distinguish between the two overloaded `print` functions – one accepting
    an `int` parameter and the other a `float` – the compiler employs a technique
    called **name mangling**. Name mangling modifies function names by encoding additional
    information, such as parameter types, into them. This ensures that each overloaded
    function has a unique symbol in the compiled code. If we examine the assembly
    output of the previous example, we can observe these mangled names:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分两个重载的 `print` 函数——一个接受 `int` 参数，另一个接受 `float`——编译器采用了一种称为 **名称修饰** 的技术。名称修饰通过将额外的信息，如参数类型，编码到函数名称中，来修改函数名称。这确保了每个重载函数在编译代码中都有一个唯一的符号。如果我们检查上一个示例的汇编输出，我们可以观察到这些修饰过的名称：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We see that the compiler assigned `_Z5printi` and `_Z5printf` labels to `print`
    functions with `int` and `float` parameters respectively. This allows it to dispatch
    function calls according to argument matching.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到编译器将 `_Z5printi` 和 `_Z5printf` 标签分配给了具有 `int` 和 `float` 参数的 `print` 函数。这使得它能够根据参数匹配来调度函数调用。
- en: 'Overloaded functions can have a different number of arguments. Return types
    cannot be used for function overloading. Two functions with the same name and
    same arguments cannot have different return types. The following code would result
    in a compile error:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重载函数可以有不同数量的参数。不能使用返回类型进行函数重载。具有相同名称和相同参数的两个函数不能有不同的返回类型。以下代码将导致编译错误：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code would be treated by the compiler as a function redeclaration and would
    result in an error.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将被编译器视为函数重新声明，并导致错误。
- en: Function overloading is a basic but powerful feature of C++ that provides a
    mechanism for compile-time or static polymorphism.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载是C++的一个基本但强大的特性，它提供了一种在编译时或静态多态的机制。
- en: Interoperability with C
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与C的互操作性
- en: Code examples from previous chapters that you were able to run in a Renode simulator
    are using both C++ and C code. We used vendor provided HAL library and **Common
    Microcontroller Software Interface Standard** (**CMSIS**) by Arm, both written
    in C and contained in the `platform` folder.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你能够在Renode模拟器中运行的上一章的代码示例使用了C++和C代码。我们使用了供应商提供的HAL库和Arm的 **通用微控制器软件接口标准** (**CMSIS**)，两者都是用C编写的，并包含在
    `platform` 文件夹中。
- en: 'If you take a look at the `CMakeLists.txt` file and the `add_executable` function
    in it, you will see listed C files from the `platform` folder and just a few C++
    files. Building a project will provide the following console output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `CMakeLists.txt` 文件以及其中的 `add_executable` 函数，你会看到列出了来自 `platform` 文件夹的C文件以及仅有的几个C++文件。构建项目将提供以下控制台输出：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Every C and C++ file is treated as a translation unit and built separately by
    C and C++ compilers respectively. After compilation, both C and C++ object files
    are linked into a single ELF file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个C和C++文件都被视为一个翻译单元，并由各自的C和C++编译器分别单独构建。编译完成后，C和C++目标文件将被链接成一个单一的ELF文件。
- en: External and Language Linkage in C++
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++中的外部和语言链接
- en: 'Variables and functions that can be referred to from other translation units
    have **external linkage**. This allows them to be linked with code in other files
    provided that the compiler has access to declarations. They also have a property
    called **language linkage**. This property allows linking C++ with C code. C language
    linkage in C++ is declared using the following syntax:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从其他翻译单元引用的变量和函数具有 **外部链接**。这允许它们与在其他文件中提供的代码链接，前提是编译器可以访问声明。它们还有一个称为 **语言链接**
    的属性。这个属性允许C++与C代码链接。在C++中使用C语言链接的语法如下：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Declaration with C language linkage will be linked according to C language linkage
    conventions, preventing name mangling (among other things) to ensure proper linking
    with code compiled within a C translation unit.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C语言链接的声明将根据C语言链接约定进行链接，以防止名称修饰（以及其他事项），确保与C翻译单元内编译的代码正确链接。
- en: C standard library in C++
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++中的C标准库
- en: C++ wraps the C standard library and provides header files with the same name
    as the C language version but with a `c` prefix and no extension. For example,
    the C++ equivalent for the C language header file `<stdlib.h>` is `<cstdlib>`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: C++封装了C标准库，并提供与C语言版本同名但带有 `c` 前缀且无扩展名的头文件。例如，C语言头文件 `<stdlib.h>` 的C++等价文件是 `<cstdlib>`。
- en: 'In GCC, implementation C++ wrappers include C standard library headers; for
    example, `<cstdio>` includes `<stdio.h>`. If you dive into `<stdio.h>`, you can
    see that it guards function declarations with `__BEGIN_DECLS` and `__END_DECLS`
    macros. Here’s the definition of these macros:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在GCC中，实现C++包装器包括C标准库头文件；例如，`<cstdio>`包括`<stdio.h>`。如果你深入研究`<stdio.h>`，你可以看到它使用`__BEGIN_DECLS`和`__END_DECLS`宏保护函数声明。以下是这些宏的定义：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we can see that standard C library headers take care of C++ compatibility
    by adding a language linkage specifier if a C++ compiler is used. This practice
    is also used in many HAL implementations provided by microcontroller vendors.
    If you open any C header file in `platform/STM32F0xx_HAL_Driver/Inc`, you will
    see that declarations are guarded with a C language linkage specifier when they
    are accessed by the C++ compiler, as shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到标准C库头文件通过添加语言链接指定符来处理C++兼容性，如果使用C++编译器。这种做法也被许多微控制器供应商提供的许多HAL实现所采用。如果你打开`platform/STM32F0xx_HAL_Driver/Inc`中的任何C头文件，你会看到当它们被C++编译器访问时，声明被C语言链接指定符保护，如下所示：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'C libraries are often used by C++ programs, especially in the embedded domain,
    so it is always a good idea to guard them with a language linkage specifier. If
    we are using a C library in a C++ program in which headers are not guarded internally,
    we can guard the headers at the `include` site, as shown here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: C库通常被C++程序使用，尤其是在嵌入式领域，因此总是用语言链接指定符保护它们是个好主意。如果我们在一个C++程序中使用C库，并且头文件没有内部保护，我们可以在`include`位置保护头文件，如下所示：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The language linkage specifier for C language ensures proper linking of C++
    code that is using C code, which is often a case in embedded projects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的语言链接指定符确保了使用C代码的C++代码的正确链接，这在嵌入式项目中通常是这种情况。
- en: References
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用
- en: In the previous chapter, we briefly mentioned references without explaining
    them in detail. References are object aliases; that is, they refer to objects
    and as such they must be immediately initialized. They are not objects, so there
    are no pointers to references or arrays of references.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们简要提到了引用，但没有详细解释。引用是对象的别名；也就是说，它们指向对象，因此它们必须立即初始化。它们不是对象，所以没有指向引用的指针或引用数组。
- en: 'There are two different types of references in C++: **lvalue** and **rvalue**
    references.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: C++中有两种不同的引用类型：**左值**和**右值**引用。
- en: Value categories
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类别
- en: C++ expressions have either lvalue or rvalue value categories. There is a more
    detailed division of value categories, but we will stay with this simple one which
    has a historical origin.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C++表达式要么是左值要么是右值值类别。值类别有更详细的划分，但我们将保持这个简单的类别，它有一个历史起源。
- en: '**Lvalues** usually appear on the left side of the assignment expression, but
    this is not always the case. Lvalues have an address that the program can access.
    Here are some examples of lvalues:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**左值**通常出现在赋值表达式的左侧，但这并不总是如此。左值有一个程序可以访问的地址。以下是一些左值的示例：'
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Rvalues** usually appear on the right side of the assignment expression.
    Examples are literals, function calls that do not return references, and built-in
    operator calls. We can think of them as temporary values. Some rvalues are shown
    in the following example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**右值**通常出现在赋值表达式的右侧。例如，字面量、不返回引用的函数调用和内置运算符调用。我们可以把它们看作是临时值。以下是一个右值的示例：'
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is another, full example to help you better understand rvalues:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个完整的示例，帮助你更好地理解右值：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding example, we can see the `my_struct()` rvalue expression on
    the left side of the assignment operator. The output of the example is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到赋值运算符左侧的`my_struct()`右值表达式。示例的输出如下：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the first `printf` call, we make a call to the constructor of `my_struct`,
    which returns a temporary object, and we access the `a_` member. In the next line,
    we have the following expression: `my_struct()=my_struct(16)`. On the left side
    of this expression, we have a call to the default constructor, which returns a
    temporary object. Then we assign the result of the call to a constructor that
    accepts `int` to a temporary object on the left side, which will copy one temporary
    object to the other one.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个`printf`调用中，我们调用`my_struct`的构造函数，它返回一个临时对象，并访问`a_`成员。在下一行，我们有以下表达式：`my_struct()=my_struct(16)`。在这个表达式的左侧，我们有一个对默认构造函数的调用，它返回一个临时对象。然后我们将构造函数接受`int`的结果赋值给左侧的临时对象，这将把一个临时对象复制到另一个临时对象中。
- en: Lvalue references
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 左值引用
- en: '**Lvalue references** are used as aliases for existing objects. They can also
    be const-qualified. We declare them by adding `&` to type names. The following
    code demonstrates the usage of lvalue references:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**左值引用**用于现有对象的别名。它们也可以是const限定。我们通过在类型名称中添加`&`来声明它们。以下代码演示了左值引用的用法：'
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As shown in the example, we can manipulate the object using the reference. In
    the case of a constant reference, any attempts to change the value will result
    in a compiler error.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，我们可以使用引用来操作对象。在常量引用的情况下，任何尝试更改值的操作都将导致编译器错误。
- en: Rvalue references
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 右值引用
- en: '**Rvalue references** are used to extend the lifetime of temporary rvalues.
    We declare them using `&&` next to the type name. Here are example usages of rvalue
    references:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**右值引用**用于扩展临时右值的生命周期。我们通过在类型名称旁边使用`&&`来声明它们。以下是一些右值引用的示例用法：'
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Rvalue references cannot be bound to lvalues. Attempting to do so will result
    in a compiler error. Rvalue references are important for resource management,
    and they are used in move semantics, which allow resources to be moved from one
    object to another.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 右值引用不能绑定到左值。尝试这样做将导致编译器错误。右值引用对于资源管理很重要，并且它们用于移动语义，这允许资源从一个对象移动到另一个对象。
- en: 'If we take a look at the documentation for the `push_back` method of `std::vector`,
    we will see two declarations:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`std::vector`的`push_back`方法的文档，我们将看到两个声明：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first declaration is used to initialize a new vector member by copying
    `value`. The second declaration with rvalue reference will move `value`, meaning
    that a new vector member will take ownership of dynamically allocated resources
    from the `value` object. Let’s take a look at the following example to understand
    the basics of move semantics:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个声明用于通过复制`value`来初始化新的向量成员。带有右值引用的第二个声明将移动`value`，这意味着新的向量成员将接管`value`对象从动态分配的资源。让我们看一下以下示例，以了解移动语义的基本知识：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, we have two calls to the `push_back` method of `std::vector<std::string>`.
    The first call, `v.push_back(str);`, performs a copy of `str` into the vector.
    After this operation, the original str remains unchanged, which is confirmed by
    the output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们对`std::vector<std::string>`的`push_back`方法进行了两次调用。第一次调用`v.push_back(str);`将`str`复制到向量中。在此操作之后，原始的`str`保持不变，这由输出得到证实：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second call, `v.push_back(std::move(str));`, uses `std::move` to cast `str`
    to an rvalue reference. This signals to the compiler that the resources of `str`
    can be moved rather than copied. As a result, the internal data of `str` is transferred
    to the new string in the vector, and `str` is left in a valid but unspecified
    state, often becoming empty:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用`v.push_back(std::move(str));`使用`std::move`将`str`转换为右值引用。这向编译器表明`str`的资源可以被移动而不是复制。因此，`str`的内部数据被转移到向量中的新字符串，而`str`被留下处于有效但未指定的状态，通常变为空：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding output, we are also printing addresses of the string’s underlying
    character arrays using `s.data()` and `str.data()`.Here’s what’s happening:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们还使用`s.data()`和`str.data()`打印了字符串底层字符数组的地址。以下是发生的情况：
- en: The original `str` has its data at address `0x84c2b0`
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始的`str`其数据位于地址`0x84c2b0`
- en: After copying str into the vector, the first element, `v[0]`, has its own copy
    of the data at a different address (`0x84d330`), confirming that a deep copy was
    made
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将字符串`str`复制到向量中后，第一个元素`v[0]`拥有其数据的不同地址的副本（`0x84d330`），这证实了一个深拷贝已被创建
- en: After the move, the second element, `v[1]`, in the vector now points to the
    original data address, `0x84c2b0`. This indicates that the internal data of `str`
    was moved into `v[1]` without copying. This is just a glimpse into move semantics;
    there is much more to it, but as it is used mostly for managing dynamically allocated
    resources, we will not cover it in more detail.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 移动之后，向量中的第二个元素`v[1]`现在指向原始数据地址`0x84c2b0`。这表明`str`的内部数据被移动到`v[1]`而没有复制。这只是移动语义的一瞥；还有更多内容，但由于它主要用于管理动态分配的资源，我们不会更详细地介绍它。
- en: Standard library containers and algorithms
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库容器和算法
- en: We have already discussed some of the containers from the C++ library, such
    as `std::vector` and `std::array`, in previous chapters. As `std::vector` relies
    on dynamic memory allocation, `std::array` is usually the container of choice
    in embedded applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的章节中讨论了一些C++库中的容器，例如`std::vector`和`std::array`。由于`std::vector`依赖于动态内存分配，`std::array`通常在嵌入式应用中是首选的容器。
- en: Array
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: Arrays from the standard library allocate a contiguous block of memory on the
    stack. We can consider an array as a simple wrapper of a C-style array that contains
    the size of the array inside the type. It is a templated type that is instantiated
    with an underlying data type and size.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的数组在栈上分配一个连续的内存块。我们可以将数组视为一个简单的包装器，它包含一个C风格数组的类型，并在其中包含数组的大小。它是一个模板类型，使用底层数据类型和大小实例化。
- en: We can access members of the array using a method that will throw an exception
    if indexed with an out-of-bounds index. This makes it a safer option than a C-style
    array as it allows us to catch out-of-bounds access runtime errors and handle
    them. If exceptions are disabled, we can set a global terminate handler with our
    functionality. We had the opportunity to see this in [*Chapter 2*](Chapter_02.xhtml)
    of this book when we were discussing exceptions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个方法来访问数组成员，如果使用越界索引访问，它将抛出一个异常。这使得它比C风格数组更安全，因为它允许我们在运行时捕获越界访问错误并处理它们。如果禁用了异常，我们可以设置一个全局终止处理程序来执行我们的功能。我们有机会在本书的[*第2章*](Chapter_02.xhtml)中看到这一点，当时我们正在讨论异常。
- en: 'We can use `std:array` to create a vector-like container that we can use with
    container adaptors such as `std::stack` or a `std::priority` queue. We will call
    our new type `fixed_vector`. It will inherit from `std::array` and implement the
    `push_back`, `pop_back`, `empty`, and `end` methods. Here is an implementation
    of our new type using an array from the standard library:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `std::array` 创建一个类似向量的容器，我们可以使用它与容器适配器，如 `std::stack` 或 `std::priority`
    队列。我们将我们的新类型称为 `fixed_vector`。它将继承自 `std::array` 并实现 `push_back`、`pop_back`、`empty`
    和 `end` 方法。以下是使用标准库中的数组实现我们的新类型的示例：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our new type, `fixed_vector`, exploits the underlying `std::array` and implements
    the `push_back` function to add elements at the end of the array. If we want to
    add more elements than is possible, it will fail silently. This behavior can be
    adjusted as per the application’s requirements. It also implements the `back`
    method, which returns an lvalue reference to the last element, and `pop_back`,
    which decrements the private member, `cnt_`, used to keep track of the number
    of elements stored in the container.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新类型 `fixed_vector` 利用底层的 `std::array` 并实现 `push_back` 函数来向数组的末尾添加元素。如果我们尝试添加比可能更多的元素，它将静默失败。此行为可以根据应用程序的要求进行调整。它还实现了
    `back` 方法，该方法返回对最后一个元素的左值引用，以及 `pop_back`，它递减用于跟踪容器中存储的元素数量的私有成员 `cnt_`。
- en: We can use our new container type, `fixed_vector`, as an underlying container
    type for container adaptors such as stacks and priority queues.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的新容器类型 `fixed_vector` 作为容器适配器（如栈和优先队列）的底层容器类型。
- en: Container adaptors
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器适配器
- en: 'Stack is a simple **Last In-First Out** (**LIFO**) container adaptor, and the
    priority queue will sort the elements when inserting them. We can see how to use
    them with `fixed_vector` in the following example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一个简单的**后进先出（LIFO**）容器适配器，优先队列在插入元素时会对其进行排序。我们可以在以下示例中看到如何使用 `fixed_vector`：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this example, we are using `fixed_vector` to instantiate `std::stack` and
    `std::priority_queue` templated types. If we run this program, we will get the
    following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `fixed_vector` 实例化 `std::stack` 和 `std::priority_queue` 模板类型。如果我们运行这个程序，我们将得到以下输出：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see from the output, elements in the priority queue are sorted, and
    those in the stack are popped by the LIFO principle.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从输出中看到的，优先队列中的元素是排序的，而栈中的元素是按照后进先出（LIFO）原则弹出的。
- en: The standard library provides a variety of containers, and we have just scratched
    the surface of the possibilities that it provides. It also provides algorithms
    that operate on containers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了各种容器，我们刚刚触及了它提供的可能性的一角。它还提供了在容器上操作的算法。
- en: Algorithms
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法
- en: C++ standard library offers a huge set of templated algorithm functions contained
    in the `algorithm` header that play well with different container types. We will
    go through some of them now.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 标准库提供了包含在 `algorithm` 头文件中的大量模板算法函数，这些函数与不同的容器类型配合良好。我们现在将介绍其中的一些。
- en: std::copy and std::copy_if
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::copy 和 std::copy_if
- en: '`std::copy` and `std::copy_if` are used to copy elements from one container
    to another. `std::copy_if` also accepts a predicate function that controls whether
    a member is copied or not, as shown in the following example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::copy` 和 `std::copy_if` 用于将元素从一个容器复制到另一个容器。`std::copy_if` 还接受一个谓词函数，用于控制是否复制成员，如下面的示例所示：'
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, we use `std::iota` from the numeric header to initialize the
    `src` array with incrementing values, starting with `0`. Then, we copy all elements
    from the `src` array to the `dst` array that are larger than 3 using `std::copy_if`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `std::iota` 从数值头文件初始化 `src` 数组，以递增的值开始，从 `0` 开始。然后，我们使用 `std::copy_if`
    将 `src` 数组中所有大于 3 的元素复制到 `dst` 数组中。
- en: std::sort
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: std::sort
- en: '`std::sort` is used to sort elements in a container. In the following example,
    we will generate elements randomly and sort them:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::sort` 用于对容器中的元素进行排序。在下面的例子中，我们将生成随机元素并对其进行排序：'
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this example, we populate the `src` array using `std::transform`, which
    applies a `rand` lambda to every member of the `src` array. We used types from
    the `random` header to generate random numbers between 1 and 6\. After we populate
    the array with random numbers, we sort it using `std::sort`. A possible output
    of this program is shown here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用 `std::transform` 来填充 `src` 数组，它将 `rand` lambda 应用到 `src` 数组的每个成员上。我们使用了
    `random` 头文件中的类型来生成介于 1 和 6 之间的随机数。在我们用随机数填充数组之后，我们使用 `std::sort` 对其进行排序。这个程序的可能的输出如下所示：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We first see values in the array before sorting and then applying `std::sort`.
    We could have populated the initial array in a `for` loop, but we used the opportunity
    to demonstrate `std:transform` here.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看到排序和应用 `std::sort` 之前的数组中的值。我们本可以用 `for` 循环来填充初始数组，但我们利用这个机会在这里展示了 `std::transform`。
- en: These were some of the algorithms from the C++ standard library; there are many
    more that can be used to effectively solve common tasks in containers.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是从 C++ 标准库中的一些算法；还有更多可以用来有效地解决容器中常见任务的算法。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered C++ fundamentals such as namespaces, function overloading,
    references, and standard library containers and algorithms. We also learned how
    C interoperability is implemented and used in C++ programs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 C++ 的基础知识，例如命名空间、函数重载、引用以及标准库容器和算法。我们还学习了如何在 C++ 程序中实现和使用 C 兼容性。
- en: In the next chapter, we will learn about error-handling mechanisms in C++.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习 C++ 中的错误处理机制。
