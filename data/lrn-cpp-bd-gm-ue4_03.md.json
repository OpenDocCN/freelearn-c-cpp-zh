["```cpp\nint x = 5; // as you know, we use one equals sign  \nint y = 4; // for assignment.. \n// but we need to use two equals signs  \n// to check if variables are equal to each other \ncout << \"Is x equal to y? C++ says: \" << (x == y) << endl; \n```", "```cpp\nIs x equal to y? C++ says: 0  \n```", "```cpp\ncout << \"Is x equal to y? C++ says: \" << boolalpha <<  \n        (x == y) << endl; \n```", "```cpp\nbool isHungry = true;  // can set this to false if not \n                       // hungry! \nif( isHungry == true ) // only go inside { when isHungry is true \n{ \n  cout << \"Preparing snack..\" << endl; \n  cout << \"Eating .. \" << endl; \n} \ncout << \"Sitting on the couch..\" << endl; \n```", "```cpp\nif( isHungry == true )\n```", "```cpp\nint x = 4, y = 5; \ncout << \"Is x equal to y? C++ says: \" << (x = y) << endl; //bad! \n// above line overwrote value in x with what was in y, \n// since the above line contains the assignment x = y \n// we should have used (x == y) instead. \ncout << \"x = \" << x << \", y = \" << y << endl; \n```", "```cpp\nIs x equal to y? C++ says: 5 \nx = 5, y = 5 \n```", "```cpp\nbool isHungry = true; \nif( isHungry )      // notice == true is implied! \n{ \n  cout << \"Preparing snack..\" << endl; \n  cout << \"Eating .. \" << endl; \n} \nelse                // we go here if isHungry is FALSE \n{ \n  cout << \"I'm not hungry\" << endl; \n} \ncout << \"Sitting on the couch..\" << endl; \n```", "```cpp\nint x = 9; \nint y = 7; \n```", "```cpp\ncout << \"Is x greater than y? \" << (x > y) << endl; \ncout << \"Is x greater than OR EQUAL to y? \" << (x >= y) << endl; \ncout << \"Is x less than y? \" << (x < y) << endl; \ncout << \"Is x less than OR EQUAL to y? \" << (x <= y) << endl; \ncout << \"Is x not equal to y? \" << (x != y) << endl; \n```", "```cpp\nbool wearingSocks = true; \nif( !wearingSocks ) // same as if( false == wearingSocks ) \n{\n         cout << \"Get some socks on!\" << endl;\n } \nelse \n{ \n        cout << \"You already have socks\" << endl; \n} \n```", "```cpp\nbool hidden = true; \nbool isVisible = !hidden; \n```", "```cpp\nbool wearingSocks = true; \nbool wearingClothes = false; \nif( wearingSocks && wearingClothes )// && requires BOTH to be true \n{ \n        cout << \"You are dressed!\" << endl; \n} \nelse \n{ \n        cout << \"You are not dressed yet\" << endl; \n} \n```", "```cpp\nbool foundStar = false; \nfloat levelCompleteTime = 25.f; \nfloat maxTimeForBonus = 60.f; \n// || requires EITHER to be true to get in the { below \nif( foundStar || (levelCompleteTime < maxTimeForBonus) ) \n{ \n        cout << \"Bonus awarded!\" << endl; \n} \nelse \n{ \n        cout << \"No bonus.\" << endl; \n} \n```", "```cpp\nint x, y; \ncout << \"Enter two numbers (integers), separated by a space \" << endl; \ncin >> x >> y; \nif( x < y )  \n{ \n  cout << \"x is less than y\" << endl; \n} \nelse \n{ \n  cout << \"x is greater than y\" << endl; \n} \n```", "```cpp\nif( some condition is true ) \n{ \n  execute this; \n} \nelse // otherwise \n{ \n  execute that; \n} \n```", "```cpp\n#include <iostream> \nusing namespace std; \nint main() \n{ \n  enum Item  // This is how enums come in handy!\n  { \n    Coin, Key, Sanddollar // variables of type Item can have  \n    // any one of these 3 values \n  };\n  Item itemInHand = Key;  // Try changing this value to Coin,  \n                          // Sanddollar \n  if( itemInHand == Key ) \n  { \n    cout << \"The key has a lionshead on the handle.\" << endl; \n    cout << \"You got into a secret room using the Key!\" << endl; \n  } \n  else if( itemInHand == Coin ) \n  { \n    cout << \"The coin is a rusted brassy color. It has a picture  \n     of a lady with a skirt.\" << endl; \n    cout << \"Using this coin you could buy a few things\" << endl; \n  } \n  else if( itemInHand == Sanddollar ) \n  { \n    cout << \"The sanddollar has a little star on it.\" << endl; \n    cout << \"You might be able to trade it for something.\" <<  \n     endl; \n  } \n  return 0;  \n} \n```", "```cpp\n#include <iostream> \nusing namespace std; \nint main() \n{ \n  int x; \n  int y; \n  cout << \"Enter an integer value for x:\" << endl; \n  cin >> x; // This will read in a value from the console \n  // The read in value will be stored in the integer  \n  // variable x, so the typed value better be an integer! \n  cout << \"Enter an integer value for y:\" << endl; \n  cin >> y; \n  cout << \"x = \" << x << \", y = \" << y << endl; \n  // *** Write new lines of code here \n} \n```", "```cpp\nif( x == y ) \n{ \n  cout << \"x and y are equal\" << endl; \n} \nelse \n{ \n  cout << \"x and y are not equal\" << endl; \n} \n```", "```cpp\nif( x > y ) \n{ \n  cout << \"x is greater than y\" << endl; \n} \nelse if( x < y ) \n{ \n  cout << \"y is greater than x\" << endl; \n} \nelse // in this case neither x > y nor y > x \n{ \n  cout << \"x and y are equal\" << endl; \n} \n```", "```cpp\n#include <iostream> \nusing namespace std; \nenum Food  // enums are very useful with switch! \n{ \n  // a variable of type Food can have any of these values \n  Fish, \n  Bread, \n  Apple, \n  Orange \n}; \nint main() \n{ \n  Food food = Bread; // Change the food here \n  switch( food ) \n  { \n    case Fish: \n      cout << \"Here fishy fishy fishy\" << endl; \n      break; \n    case Bread: \n      cout << \"Chomp! Delicious bread!\" << endl; \n      break; \n    case Apple: \n      cout << \"Mm fruits are good for you\" << endl; \n      break; \n    case Orange: \n      cout << \"Orange you glad I didn't say banana\" << endl; \n      break; \n    default:  // This is where you go in case none \n              // of the cases above caught \n      cout << \"Invalid food\" << endl; \n      break; \n  } \n  return 0; \n} \n```", "```cpp\nenum Vegetables { Potato, Cabbage, Broccoli, Zucchini }; \n```", "```cpp\nVegetable veg = Zucchini;\n\nswitch( veg ) \n{ \ncase Zucchini:             // zucchini falls through because no break \ncase Broccoli:             // was written here \n  cout << \"Greens!\" << endl; \n  break; \ndefault: \n  cout << \"Not greens!\" << endl; \n  break; \n} \n```", "```cpp\nswitch( veg ) \n{ \ncase Zucchini:              // zucchini no longer falls due to break \n  cout << \"Zucchini is a green\" << endl; \n  break;// stops case zucchini from falling through \ncase Broccoli:               // was written here \n  cout << \"Broccoli is a green\" << endl; \n  break; \ndefault: \n  cout << \"Not greens!\" << endl; \n  break; \n} \n```", "```cpp\n#include <iostream> \nusing namespace std; \nenum Mount \n{ \n  Horse=1, Mare, Mule, Sheep, Chocobo \n  // Since Horse=1, Mare=2, Mule=3, Sheep=4, and Chocobo=5\\. \n}; \nint main() \n{ \n  int mount;  // We'll use an int variable for mount \n              // so cin works \n  cout << \"Choose your mount:\" << endl; \n  cout << Horse << \" Horse\" << endl; \n  cout << Mare << \" Mare\" << endl; \n  cout << Mule << \" Mule\" << endl; \n  cout << Sheep << \" Sheep\" << endl; \n  cout << Chocobo << \" Chocobo\" << endl; \n  cout << \"Enter a number from 1 to 5 to choose a mount\" << endl; \n  cin >> mount; \n    // Describe what happens \n    // when you mount each animal in the switch below \n  switch( mount ) \n  { \n    default: \n      cout << \"Invalid mount\" << endl; \n      break; \n  } \nreturn 0; \n} \n```", "```cpp\nenum   WindowProperties   \n{   \n    Bordered    = 1 << 0, // binary 001   \n    Transparent = 1 << 1, // binary 010   \n    Modal       = 1 << 2  // binary 100   \n};   \n```", "```cpp\n//   bitwise OR combines properties   \nWindowProperties   wp = Bordered | Modal;   \n```", "```cpp\n//   bitwise AND checks to see if wp is Modal   \nif( wp   & Modal )   \n{   \n    cout << \"You are looking at a modal window\" << endl;\n}   \n```", "```cpp\nvoid APuzzleBlock::BlockClicked(UPrimitiveComponent* ClickedComp, FKey ButtonClicked)\n```", "```cpp\n/** Pointer to blue material used on inactive blocks */\n  UPROPERTY()\n  class UMaterialInstance* BlueMaterial;\n\n  /** Pointer to orange material used on active blocks */\n  UPROPERTY()\n  class UMaterialInstance* OrangeMaterial;\n```", "```cpp\nBlueMaterial = ConstructorStatics.BlueMaterial.Get();\nOrangeMaterial = ConstructorStatics.OrangeMaterial.Get()\n```", "```cpp\nvoid APuzzleBlock::BlockClicked(UPrimitiveComponent* ClickedComp, FKey ButtonClicked) \n{ \n  // --REPLACE FROM HERE-- \n  bIsActive = !bIsActive; // flip the value of bIsActive \n  // (if it was true, it becomes false, or vice versa) \n  if ( bIsActive ) \n  { \n    BlockMesh->SetMaterial(0, OrangeMaterial); \n  } \n  else \n  { \n    BlockMesh->SetMaterial(0, BlueMaterial); \n  } \n  // Tell the Grid \n  if(OwningGrid != NULL) \n  { \n    OwningGrid->AddScore(); \n  } \n  // --TO HERE-- \n}\n```", "```cpp\nbIsActive = !bIsActive; // flip the value of bIsActive \n```", "```cpp\nif ( bIsActive ) \n  { \n    BlockMesh->SetMaterial(0, OrangeMaterial); \n  } \n  else \n  { \n    BlockMesh->SetMaterial(0, BlueMaterial); \n  } \n```"]