["```cpp\n/* connectsync.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/bind.hpp>\n#include <boost/lexical_cast.hpp>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" Start.\\n\";\n  global_stream_lock.unlock();\n\n  while(true) {\n    try {\n      boost::system::error_code ec;\n      iosvc->run(ec);\n      if(ec) {\n        global_stream_lock.lock();\n        std::cout << \"Message: \" << ec << \".\\n\";\n        global_stream_lock.unlock();\n      }\n      break;\n    }\n    catch(std::exception &ex) {\n      global_stream_lock.lock();\n      std::cout << \"Message: \" << ex.what() << \".\\n\";\n      global_stream_lock.unlock();\n    }\n  }\n\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" End.\\n\";\n  global_stream_lock.unlock();\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n  boost::shared_ptr<boost::asio::io_service::strand> strand(\n    new boost::asio::io_service::strand(*io_svc)\n  );\n\n  global_stream_lock.lock();\n  std::cout << \"Press ENTER to exit!\\n\";\n  global_stream_lock.unlock();\n\n  boost::thread_group threads;\n  for(int i=1; i<=2; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  boost::asio::ip::tcp::socket sckt(*io_svc);\n\n  try {\n    boost::asio::ip::tcp::resolver resolver(*io_svc);\n    boost::asio::ip::tcp::resolver::query query(\"www.packtpub.com\", \n      boost::lexical_cast<std::string>(80)\n    );\n    boost::asio::ip::tcp::resolver::iterator iterator = resolver.resolve(query);\n    boost::asio::ip::tcp::endpoint endpoint = *iterator;\n\n    global_stream_lock.lock();\n    std::cout << \"Connecting to: \" << endpoint << std::endl;\n    global_stream_lock.unlock();\n\n    sckt.connect(endpoint); \n    std::cout << \"Connected!\\n\";\n  }\n  catch(std::exception &ex) {\n    global_stream_lock.lock();\n    std::cout << \"Message: \" << ex.what() << \".\\n\";\n    global_stream_lock.unlock();\n  }\n\n  std::cin.get();\n\n  boost::system::error_code ec;\n  sckt.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n  sckt.close(ec);\n\n  io_svc->stop();\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 connectsync.cpp -o connectsync -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l libboost_thread-mgw49-mt-1_58\n\n```", "```cpp\nboost::asio::ip::tcp::socket sckt(*io_svc);\n\n```", "```cpp\nboost::asio::ip::tcp::resolver resolver(*io_svc);\nboost::asio::ip::tcp::resolver::query query(\"www.packtpub.com\",\n boost::lexical_cast<std::string>(80)\n);\nboost::asio::ip::tcp::resolver::iterator iterator =\nresolver.resolve(query);\n\n```", "```cpp\nboost::asio::ip::tcp::endpoint endpoint = *iterator;\n\n```", "```cpp\nsckt.connect(endpoint);\n\n```", "```cpp\nboost::system::error_code ec;\nsckt.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\nsckt.close(ec);\n\n```", "```cpp\nboost::asio::ip::tcp::resolver::query query(\"www.packtpub.com\",\n boost::lexical_cast<std::string>(110)\n);\n\n```", "```cpp\n/* connectasync.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/bind.hpp>\n#include <boost/lexical_cast.hpp>\n#include <iostream>\n#include <string>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" Start.\\n\";\n  global_stream_lock.unlock();\n\n  while(true) {\n    try {\n      boost::system::error_code ec;\n      iosvc->run(ec);\n      if(ec) {\n        global_stream_lock.lock();\n        std::cout << \"Message: \" << ec << \".\\n\";\n        global_stream_lock.unlock();\n      }\n      break;\n    }\n    catch(std::exception &ex) {\n      global_stream_lock.lock();\n      std::cout << \"Message: \" << ex.what() << \".\\n\";\n      global_stream_lock.unlock();\n    }\n  }\n\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" End.\\n\";\n  global_stream_lock.unlock();\n}\n\nvoid OnConnect(const boost::system::error_code &ec) {\n  if(ec) {\n    global_stream_lock.lock();\n    std::cout << \"OnConnect Error: \" << ec << \".\\n\";\n    global_stream_lock.unlock();\n  }\n  else {\n    global_stream_lock.lock();\n    std::cout << \"Connected!.\\n\";\n    global_stream_lock.unlock();\n  }\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  boost::shared_ptr<boost::asio::io_service::strand> strand(\n    new boost::asio::io_service::strand(*io_svc)\n  );\n\n  global_stream_lock.lock();\n  std::cout << \"Press ENTER to exit!\\n\";\n  global_stream_lock.unlock();\n\n  boost::thread_group threads;\n  for(int i=1; i<=2; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  boost::shared_ptr<boost::asio::ip::tcp::socket> sckt(\n    new boost::asio::ip::tcp::socket(*io_svc)\n  );\n\n  try {\n    boost::asio::ip::tcp::resolver resolver(*io_svc);\n    boost::asio::ip::tcp::resolver::query query(\"www.packtpub.com\",\n      boost::lexical_cast<std::string>(80)\n    );\n    boost::asio::ip::tcp::resolver::iterator iterator = resolver.resolve( query );\n    boost::asio::ip::tcp::endpoint endpoint = *iterator;\n\n    global_stream_lock.lock();\n    std::cout << \"Connecting to: \" << endpoint << std::endl;\n    global_stream_lock.unlock();\n\n    sckt->async_connect(endpoint, boost::bind(OnConnect, _1));\n  }\n  catch(std::exception &ex) {\n    global_stream_lock.lock();\n    std::cout << \"Message: \" << ex.what() << \".\\n\";\n    global_stream_lock.unlock();\n  }\n\n  std::cin.get();\n\n  boost::system::error_code ec;\n  sckt->shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n  sckt->close(ec);\n\n  io_svc->stop();\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 connectasync.cpp -o connectasync -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l libboost_thread-mgw49-mt-1_58\n\n```", "```cpp\n/* serverasync.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/bind.hpp>\n#include <boost/lexical_cast.hpp>\n#include <iostream>\n#include <string>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" Start.\\n\";\n  global_stream_lock.unlock();\n\n  while(true) {\n    try {\n      boost::system::error_code ec;\n      iosvc->run(ec);\n      if(ec) {\n        global_stream_lock.lock();\n        std::cout << \"Message: \" << ec << \".\\n\";\n        global_stream_lock.unlock();\n      }\n      break;\n    }\n    catch(std::exception &ex) {\n      global_stream_lock.lock();\n      std::cout << \"Message: \" << ex.what() << \".\\n\";\n      global_stream_lock.unlock();\n    }\n  }\n\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" End.\\n\";\n  global_stream_lock.unlock();\n}\n\nvoid OnAccept(const boost::system::error_code &ec) {\n  if(ec) {\n    global_stream_lock.lock();\n    std::cout << \"OnAccept Error: \" << ec << \".\\n\";\n    global_stream_lock.unlock();\n  }\n  else {\n    global_stream_lock.lock();\n    std::cout << \"Accepted!\" << \".\\n\";\n    global_stream_lock.unlock();\n  }\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  boost::shared_ptr<boost::asio::io_service::strand> strand(\n    new boost::asio::io_service::strand(*io_svc)\n  );\n\n  global_stream_lock.lock();\n  std::cout << \"Press ENTER to exit!\\n\";\n  global_stream_lock.unlock();\n\n  boost::thread_group threads;\n  for(int i=1; i<=2; i++)\n    threads.create_thread(boost::bind(&WorkerThread, io_svc, i));\n\n  boost::shared_ptr< boost::asio::ip::tcp::acceptor > acceptor(\n    new boost::asio::ip::tcp::acceptor(*io_svc)\n  );\n\n  boost::shared_ptr<boost::asio::ip::tcp::socket> sckt(\n    new boost::asio::ip::tcp::socket(*io_svc)\n  );\n\n  try {\n    boost::asio::ip::tcp::resolver resolver(*io_svc);\n    boost::asio::ip::tcp::resolver::query query(\n      \"127.0.0.1\", \n      boost::lexical_cast<std::string>(4444)\n    );\n    boost::asio::ip::tcp::endpoint endpoint = *resolver.resolve(query);\n    acceptor->open(endpoint.protocol());\n    acceptor->set_option(\n      boost::asio::ip::tcp::acceptor::reuse_address(false));\n    acceptor->bind(endpoint);\n    acceptor->listen(boost::asio::socket_base::max_connections);\n    acceptor->async_accept(*sckt, boost::bind(OnAccept, _1));\n\n    global_stream_lock.lock();\n    std::cout << \"Listening on: \" << endpoint << std::endl;\n    global_stream_lock.unlock();\n  }\n  catch(std::exception &ex) {\n    global_stream_lock.lock();\n    std::cout << \"Message: \" << ex.what() << \".\\n\";\n    global_stream_lock.unlock();\n  }\n\n  std::cin.get();\n\n  boost::system::error_code ec;\n  acceptor->close(ec);\n\n  sckt->shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n  sckt->close(ec);\n\n  io_svc->stop();\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 serverasync.cpp -o serverasync -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l libboost_thread-mgw49-mt-1_58 \u2013l mswsock\n\n```", "```cpp\nacptor->open(endpoint.protocol());\nacptor->set_option\n(boost::asio::ip::tcp::acceptor::reuse_address(false));\nacptor->bind(endpoint);\nacptor->listen(boost::asio::socket_base::max_connections);\nacptor->async_accept(*sckt, boost::bind(OnAccept, _1));\n\n```", "```cpp\nopen() function to open the acceptor by using the protocol that is retrieved from the endpoint variable. Then, by using the set_option function, we set an option on the acceptor to not reuse the address. The acceptor is also bound to the endpoint using the bind() function. After that, we invoke the listen() function to put the acceptor into the state where it will listen for new connections. Finally, the acceptor will accept new connections by using the async_accept() function, which will start an asynchronous accept.\n```", "```cpp\n/* readwritesocket.cpp */\n#include <boost/asio.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/thread.hpp>\n#include <boost/thread/mutex.hpp>\n#include <boost/bind.hpp>\n#include <boost/lexical_cast.hpp>\n#include <boost/cstdint.hpp>\n#include <boost/enable_shared_from_this.hpp>\n#include <iostream>\n#include <string>\n\nboost::mutex global_stream_lock;\n\nvoid WorkerThread(boost::shared_ptr<boost::asio::io_service> iosvc, int counter) {\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" Start.\\n\";\n  global_stream_lock.unlock();\n\n  while(true) {\n    try {\n      boost::system::error_code ec;\n      iosvc->run(ec);\n      if(ec) {\n        global_stream_lock.lock();\n        std::cout << \"Message: \" << ec << \".\\n\";\n        global_stream_lock.unlock();\n      }\n      break;\n    }\n    catch(std::exception &ex) {\n      global_stream_lock.lock();\n      std::cout << \"Message: \" << ex.what() << \".\\n\";\n      global_stream_lock.unlock();\n    }\n  }\n\n  global_stream_lock.lock();\n  std::cout << \"Thread \" << counter << \" End.\\n\";\n  global_stream_lock.unlock();\n}\n\nstruct ClientContext : public boost::enable_shared_from_this<ClientContext> {\n  boost::asio::ip::tcp::socket m_socket;\n\n  std::vector<boost::uint8_t> m_recv_buffer;\n  size_t m_recv_buffer_index;\n\n  std::list<std::vector<boost::uint8_t> > m_send_buffer;\n\n  ClientContext(boost::asio::io_service & io_service)\n  : m_socket(io_service), m_recv_buffer_index(0) {\n    m_recv_buffer.resize(4096);\n  }\n\n  ~ClientContext() {\n  }\n\n  void Close() {\n    boost::system::error_code ec;\n    m_socket.shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec);\n    m_socket.close(ec);\n  }\n\n  void OnSend(const boost::system::error_code &ec, std::list<std::vector<boost::uint8_t> >::iterator itr) {\n    if(ec) {\n      global_stream_lock.lock();\n      std::cout << \"OnSend Error: \" << ec << \".\\n\";\n      global_stream_lock.unlock();\n\n      Close();\n    }\n    else {\n      global_stream_lock.lock();\n      std::cout << \"Sent \" << (*itr).size() << \" bytes.\" << std::endl;\n      global_stream_lock.unlock();\n    }\n    m_send_buffer.erase(itr);\n\n    // Start the next pending send\n    if(!m_send_buffer.empty()) {\n      boost::asio::async_write(\n        m_socket,\n        boost::asio::buffer(m_send_buffer.front()),\n        boost::bind(\n          &ClientContext::OnSend,\n          shared_from_this(),\n          boost::asio::placeholders::error,\n          m_send_buffer.begin()\n        )\n      );\n    }\n  }\n\n  void Send(const void * buffer, size_t length) {\n    bool can_send_now = false;\n\n    std::vector<boost::uint8_t> output;\n    std::copy((const boost::uint8_t *)buffer, (const boost::uint8_t *)buffer + length, std::back_inserter(output));\n\n    // Store if this is the only current send or not\n    can_send_now = m_send_buffer.empty();\n\n    // Save the buffer to be sent\n    m_send_buffer.push_back(output);\n\n    // Only send if there are no more pending buffers waiting!\n    if(can_send_now) {\n      // Start the next pending send\n      boost::asio::async_write(\n        m_socket,\n        boost::asio::buffer(m_send_buffer.front()),\n        boost::bind(\n          &ClientContext::OnSend,\n          shared_from_this(),\n          boost::asio::placeholders::error,\n          m_send_buffer.begin()\n        )\n      );\n    }\n  }\n\n  void OnRecv(const boost::system::error_code &ec, size_t bytes_transferred) {\n    if(ec) {\n      global_stream_lock.lock();\n      std::cout << \"OnRecv Error: \" << ec << \".\\n\";\n      global_stream_lock.unlock();\n\n      Close();\n    }\n    else \t{\n      // Increase how many bytes we have saved up\n      m_recv_buffer_index += bytes_transferred;\n\n      // Debug information\n      global_stream_lock.lock();\n      std::cout << \"Recv \" << bytes_transferred << \" bytes.\" << std::endl;\n      global_stream_lock.unlock();\n\n      // Dump all the data\n      global_stream_lock.lock();\n      for(size_t x = 0; x < m_recv_buffer_index; ++x) {\n\n        std::cout << (char)m_recv_buffer[x] << \" \";\n        if((x + 1) % 16 == 0) {\n          std::cout << std::endl;\n        }\n      }\n      std::cout << std::endl << std::dec;\n      global_stream_lock.unlock();\n\n      // Clear all the data\n      m_recv_buffer_index = 0;\n\n      // Start the next receive cycle\n      Recv();\n    }\n  }\n\n  void Recv() {\n    m_socket.async_read_some(\n      boost::asio::buffer(\n        &m_recv_buffer[m_recv_buffer_index],\n        m_recv_buffer.size() - m_recv_buffer_index),\n      boost::bind(&ClientContext::OnRecv, shared_from_this(), _1, _2)\n    );\n  }\n};\n\nvoid OnAccept(const boost::system::error_code &ec, boost::shared_ptr<ClientContext> clnt) {\n  if(ec) {\n    global_stream_lock.lock();\n    std::cout << \"OnAccept Error: \" << ec << \".\\n\";\n    global_stream_lock.unlock();\n  }\n  else {\n    global_stream_lock.lock();\n    std::cout << \"Accepted!\" << \".\\n\";\n    global_stream_lock.unlock();\n\n    // 2 bytes message size, followed by the message\n    clnt->Send(\"Hi there!\", 9);\n    clnt->Recv();\n  }\n}\n\nint main(void) {\n  boost::shared_ptr<boost::asio::io_service> io_svc(\n    new boost::asio::io_service\n  );\n\n  boost::shared_ptr<boost::asio::io_service::work> worker(\n    new boost::asio::io_service::work(*io_svc)\n  );\n\n  boost::shared_ptr<boost::asio::io_service::strand> strand(\n    new boost::asio::io_service::strand(*io_svc)\n  );\n\n  global_stream_lock.lock();\n  std::cout << \"Press ENTER to exit!\\n\";\n  global_stream_lock.unlock();\n\n  // We just use one worker thread \n  // in order that no thread safety issues\n  boost::thread_group threads;\n  threads.create_thread(boost::bind(&WorkerThread, io_svc, 1));\n\n  boost::shared_ptr< boost::asio::ip::tcp::acceptor > acceptor(\n    new boost::asio::ip::tcp::acceptor(*io_svc)\n  );\n\n  boost::shared_ptr<ClientContext> client(\n    new ClientContext(*io_svc)\n  );\n\n  try {\n    boost::asio::ip::tcp::resolver resolver(*io_svc);\n    boost::asio::ip::tcp::resolver::query query(\n      \"127.0.0.1\",\n      boost::lexical_cast<std::string>(4444)\n    );\n    boost::asio::ip::tcp::endpoint endpoint = *resolver.resolve(query);\n    acceptor->open(endpoint.protocol());\n    acceptor->set_option(boost::asio::ip::tcp::acceptor::reuse_address(false));\n    acceptor->bind(endpoint);\n    acceptor->listen(boost::asio::socket_base::max_connections);\n    acceptor->async_accept(client->m_socket, boost::bind(OnAccept, _1, client));\n\n    global_stream_lock.lock();\n    std::cout << \"Listening on: \" << endpoint << std::endl;\n    global_stream_lock.unlock();\n  }\n  catch(std::exception &ex) {\n    global_stream_lock.lock();\u2029    std::cout << \"Message: \" << ex.what() << \".\\n\";\n    global_stream_lock.unlock();\n  }\n\n  std::cin.get();\n\n  boost::system::error_code ec;\n  acceptor->close(ec);\n\n  io_svc->stop();\n\n  threads.join_all();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 readwritesocket.cpp -o readwritesocket -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l libboost_thread-mgw49-mt-1_58 -l mswsock\n\n```", "```cpp\n/* echoserver.cpp */\n#include \"wrapper.h\"\n#include <conio.h>\n#include <boost/thread/mutex.hpp>\n\nboost::mutex global_stream_lock;\n\nclass MyConnection : public Connection {\nprivate:\n  void OnAccept(const std::string &host, uint16_t port) {\n    global_stream_lock.lock();\n    std::cout << \"[OnAccept] \" << host << \":\" << port << \"\\n\";\n    global_stream_lock.unlock();\n\n    Recv();\n  }\n\n  void OnConnect(const std::string & host, uint16_t port) {\n    global_stream_lock.lock();\n    std::cout << \"[OnConnect] \" << host << \":\" << port << \"\\n\";\n    global_stream_lock.unlock();\n\n    Recv();\n  }\n\n  void OnSend(const std::vector<uint8_t> & buffer) {\n    global_stream_lock.lock();\n    std::cout << \"[OnSend] \" << buffer.size() << \" bytes\\n\";\n    for(size_t x=0; x<buffer.size(); x++) {\n\n      std::cout << (char)buffer[x];\n      if((x + 1) % 16 == 0)\n        std::cout << std::endl;\n    }\n    std::cout << std::endl;\n    global_stream_lock.unlock();\n  }\n\n  void OnRecv(std::vector<uint8_t> &buffer) {\n    global_stream_lock.lock();\n    std::cout << \"[OnRecv] \" << buffer.size() << \" bytes\\n\";\n    for(size_t x=0; x<buffer.size(); x++) {\n\n      std::cout << (char)buffer[x];\n      if((x + 1) % 16 == 0)\n        std::cout << std::endl;\n    }\n    std::cout << std::endl;\n    global_stream_lock.unlock();\n\n    // Start the next receive\n    Recv();\n\n    // Echo the data back\n    Send(buffer);\n  }\n\n  void OnTimer(const boost::posix_time::time_duration &delta) {\n    global_stream_lock.lock();\n    std::cout << \"[OnTimer] \" << delta << \"\\n\";\n    global_stream_lock.unlock();\n  }\n\n  void OnError(const boost::system::error_code &error) {\n    global_stream_lock.lock();\n    std::cout << \"[OnError] \" << error << \"\\n\";\n    global_stream_lock.unlock();\n  }\n\npublic:\n  MyConnection(boost::shared_ptr<Hive> hive)\n    : Connection(hive) {\n  }\n\n  ~MyConnection() {\n  }\n};\n\nclass MyAcceptor : public Acceptor {\nprivate:\n  bool OnAccept(boost::shared_ptr<Connection> connection, const std::string &host, uint16_t port) {\n    global_stream_lock.lock();\n    std::cout << \"[OnAccept] \" << host << \":\" << port << \"\\n\";\n    global_stream_lock.unlock();\n\n    return true;\n  }\n\n  void OnTimer(const boost::posix_time::time_duration &delta) {\n    global_stream_lock.lock();\n    std::cout << \"[OnTimer] \" << delta << \"\\n\";\n    global_stream_lock.unlock();\n  }\n\n  void OnError(const boost::system::error_code &error) {\n    global_stream_lock.lock();\n    std::cout << \"[OnError] \" << error << \"\\n\";\n    global_stream_lock.unlock();\n  }\n\npublic:\n  MyAcceptor(boost::shared_ptr<Hive> hive)\n    : Acceptor(hive) {\n  }\n\n  ~MyAcceptor() {\n  }\n};\n\nint main(void) {\n  boost::shared_ptr<Hive> hive(new Hive());\n\n  boost::shared_ptr<MyAcceptor> acceptor(new MyAcceptor(hive));\n  acceptor->Listen(\"127.0.0.1\", 4444);\n\n  boost::shared_ptr<MyConnection> connection(new MyConnection(hive));\n  acceptor->Accept(connection);\n\n  while(!_kbhit()) {\n    hive->Poll();\n    Sleep(1);\n  }\n\n  hive->Stop();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 wrapper.cpp echoserver.cpp -o echoserver -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 -l libboost_thread-mgw49-mt-1_58 -l mswsock\n\n```", "```cpp\n/* clienthttpget.cpp */\n#include \"wrapper.h\"\n#include <conio.h>\n#include <boost/thread/mutex.hpp>\n\nboost::mutex global_stream_lock;\n\nclass MyConnection : public Connection {\nprivate:\n  void OnAccept(const std::string &host, uint16_t port) {\n    global_stream_lock.lock();\n    std::cout << \"[OnAccept] \" << host << \":\" << port << \"\\n\";\n    global_stream_lock.unlock();\n\n    // Start the next receive\n    Recv();\n  }\n\n  void OnConnect(const std::string &host, uint16_t port) {\n    global_stream_lock.lock();\n    std::cout << \"[OnConnect] \" << host << \":\" << port << \"\\n\";\n    global_stream_lock.unlock();\n\n    // Start the next receive\n    Recv();\n\n    std::string str = \"GET / HTTP/1.0\\r\\n\\r\\n\";\n\n    std::vector<uint8_t> request;\n    std::copy(str.begin(), str.end(), std::back_inserter(request));\n    Send(request);\n  }\n\n  void OnSend(const std::vector<uint8_t> &buffer) {\n    global_stream_lock.lock();\n    std::cout << \"[OnSend] \" << buffer.size() << \" bytes\\n\";\n    for(size_t x=0; x<buffer.size(); x++) {\n\n      std::cout << (char)buffer[x];\n      if((x + 1) % 16 == 0)\n        std::cout << \"\\n\";\n    }\n    std::cout << \"\\n\";\n    global_stream_lock.unlock();\n  }\n\n  void OnRecv(std::vector<uint8_t> &buffer) {\n    global_stream_lock.lock();\n    std::cout << \"[OnRecv] \" << buffer.size() << \" bytes\\n\";\n    for(size_t x=0; x<buffer.size(); x++) {\n\n      std::cout << (char)buffer[x];\n      if((x + 1) % 16 == 0)\n        std::cout << \"\\n\";\n    }\n    std::cout << \"\\n\";\n    global_stream_lock.unlock();\n\n    // Start the next receive\n    Recv();\n  }\n\n  void OnTimer(const boost::posix_time::time_duration &delta) {\n    global_stream_lock.lock();\n    std::cout << \"[OnTimer] \" << delta << std::endl;\n    global_stream_lock.unlock();\n  }\n\n  void OnError(const boost::system::error_code &error) {\n    global_stream_lock.lock();\n    std::cout << \"[OnError] \" << error << \"\\n\";\n    global_stream_lock.unlock();\n  }\n\npublic:\n  MyConnection(boost::shared_ptr<Hive> hive)\n    : Connection(hive) {\n  }\n\n  ~MyConnection() {\n  }\n};\n\nint main(void) {\n  boost::shared_ptr<Hive> hive(new Hive());\n\n  boost::shared_ptr<MyConnection> connection(new MyConnection(hive));\n  connection->Connect(\"www.packtpub.com\", 80);\n\n  while(!_kbhit()) {\n    hive->Poll();\n    Sleep(1);\n  }\n\n  hive->Stop();\n\n  return 0;\n}\n```", "```cpp\ng++ -Wall -ansi -I ../boost_1_58_0 wrapper.cpp clienthttpget.cpp -o clienthttpget -L ../boost_1_58_0/stage/lib -l boost_system-mgw49-mt-1_58 -l ws2_32 \u2013l libboost_thread-mgw49-mt-1_58 -l mswsock\n\n```", "```cpp\nstd::string str = \"GET / HTTP/1.0\\r\\n\\r\\n\";\nstd::vector<uint8_t> request;\nstd::copy(str.begin(), str.end(), std::back_inserter(request));\nSend(request)\n\n```", "```cpp\nSend() function is as follows:\n```", "```cpp\nm_io_strand.post(boost::bind(&Connection::DispatchSend, shared_from_this(), buffer));\n\n```", "```cpp\nm_io_service.poll();\n\n```"]