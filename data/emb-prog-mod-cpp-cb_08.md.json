["```cpp\n#include <fstream>\n#include <iostream>\n#include <thread>\n#include <vector>\n\n#include <unistd.h>\n\nstd::string kSharedFile = \"/tmp/test.bin\";\n\ntemplate<class T>\nclass Writer {\n  private:\n    std::ofstream out;\n  public:\n    Writer(std::string& name):\n      out(name, std::ofstream::binary) {}\n\n    void Write(const T& data) {\n      out.write(reinterpret_cast<const char*>(&data), sizeof(T));\n    }\n};\n```", "```cpp\ntemplate<class T>\nclass Reader {\n  private:\n    std::ifstream in;\n  public:\n    Reader(std::string& name) {\n      for(int count=10; count && !in.is_open(); count--) {\n        in.open(name, std::ifstream::binary);\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n      }\n    }\n\n    T Read() {\n      int count = 10;\n      for (;count && in.eof(); count--) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n      }\n\n      T data;\n      in.read(reinterpret_cast<char*>(&data), sizeof(data));\n      if (!in) {\n        throw std::runtime_error(\"Failed to read a message\");\n      }\n      return data;\n    }\n};\n```", "```cpp\nstruct Message {\n  int x, y;\n};\n\nstd::ostream& operator<<(std::ostream& o, const Message& m) {\n  o << \"(x=\" << m.x << \", y=\" << m.y << \")\";\n}\n```", "```cpp\nvoid DoWrites() {\n  std::vector<Message> messages {{1, 0}, {0, 1}, {1, 1}, {0, 0}};\n  Writer<Message> writer(kSharedFile);\n  for (const auto& m : messages) {\n    std::cout << \"Write \" << m << std::endl;\n    writer.Write(m);\n  }\n}\n\nvoid DoReads() {\n  Reader<Message> reader(kSharedFile);\n  try {\n    while(true) {\n      std::cout << \"Read \" << reader.Read() << std::endl;\n    }\n  } catch (const std::runtime_error& e) {\n    std::cout << e.what() << std::endl;\n  }\n}\n\nint main(int argc, char** argv) {\n  if (fork()) {\n    DoWrites();\n  } else {\n    DoReads();\n  }\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(ipc1)\nadd_executable(ipc1 ipc1.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nWriter(std::string& name):\n      out(name, std::ofstream::binary) {}\n```", "```cpp\nout.write(reinterpret_cast<const char*>(&data), sizeof(T));\n```", "```cpp\nfor(int count=10; count && !in.is_open(); count--) {\n        in.open(name, std::ifstream::binary);\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n      }\n```", "```cpp\nin.read(reinterpret_cast<char*>(&data), sizeof(data));\n```", "```cpp\n      for (;count && in.eof(); count--) {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n      }\n```", "```cpp\n      if (!in) {\n        throw std::runtime_error(\"Failed to read a message\");\n      }\n```", "```cpp\nstruct Message {\n  int x, y;\n};\n```", "```cpp\nstd::ostream& operator<<(std::ostream& o, const Message& m) {\n  o << \"(x=\" << m.x << \", y=\" << m.y << \")\";\n}\n```", "```cpp\n  std::vector<Message> messages {{1, 0}, {0, 1}, {1, 1}, {0, 0}};\n  Writer<Message> writer(kSharedFile);\n```", "```cpp\n  for (const auto& m : messages) {\n    std::cout << \"Write \" << m << std::endl;\n    writer.Write(m);\n  }\n```", "```cpp\n while(true) {\n      std::cout << \"Read \" << reader.Read() << std::endl;\n    }\n```", "```cpp\n  } catch (const std::runtime_error& e) {\n    std::cout << e.what() << std::endl;\n  }\n```", "```cpp\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n```", "```cpp\n    void Write(const T& data) {\n      out.write(reinterpret_cast<const char*>(&data), sizeof(T));\n out.flush();\n    }\n```", "```cpp\ntemplate<class T>\nclass Reader {\n  private:\n    std::ifstream in;\n  public:\n    Reader(std::string& name):\n      in(name, std::ofstream::binary) {}\n\n    T Read() {\n      T data;\n      in.read(reinterpret_cast<char*>(&data), sizeof(data));\n      if (!in) {\n        throw std::runtime_error(\"Failed to read a message\");\n      }\n      return data;\n    }\n};\n```", "```cpp\nvoid DoWrites() {\n  std::vector<Message> messages {{1, 0}, {0, 1}, {1, 1}, {0, 0}};\n  Writer<Message> writer(kSharedFile);\n  for (const auto& m : messages) {\n    std::cout << \"Write \" << m << std::endl;\n    writer.Write(m);\n std::this_thread::sleep_for(std::chrono::milliseconds(10));\n  }\n}\n```", "```cpp\nint main(int argc, char** argv) {\n int ret = mkfifo(kSharedFile.c_str(), 0600);\n if (!ret) {\n throw std::runtime_error(\"Failed to create named pipe\");\n }\n  if (fork()) {\n    DoWrites();\n  } else {\n    DoReads();\n  }\n}\n```", "```cpp\n int ret = mkfifo(kSharedFile.c_str(), 0600);\n```", "```cpp\n std::this_thread::sleep_for(std::chrono::milliseconds(10));\n```", "```cpp\n#include <unistd.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <mqueue.h>\n\nstd::string kQueueName = \"/test\";\n```", "```cpp\nclass MessageQueue {\n  private:\n    mqd_t handle;\n  public:\n    MessageQueue(const std::string& name, int flags) {\n      handle = mq_open(name.c_str(), flags);\n      if (handle < 0) {\n        throw std::runtime_error(\"Failed to open a queue for \n         writing\");\n      }\n    }\n\n    MessageQueue(const std::string& name, int flags, int max_count, \n     int max_size) {\n      struct mq_attr attrs = { 0, max_count, max_size, 0 };\n      handle = mq_open(name.c_str(), flags | O_CREAT, 0666, \n       &attrs);\n      if (handle < 0) {\n        throw std::runtime_error(\"Failed to create a queue\");\n      }\n    }\n\n    ~MessageQueue() {\n      mq_close(handle);\n    }\n\n```", "```cpp\n    void Send(const char* data, size_t len) {\n      if (mq_send(handle, data, len, 0) < 0) {\n        throw std::runtime_error(\"Failed to send a message\");\n      }\n    }\n\n    void Receive(char* data, size_t len) {\n      if (mq_receive(handle, data, len, 0) < len) {\n        throw std::runtime_error(\"Failed to receive a message\");\n      }\n    }\n};\n```", "```cpp\ntemplate<class T>\nclass Writer {\n  private:\n    MessageQueue queue;\n  public:\n    Writer(std::string& name):\n      queue(name, O_WRONLY) {}\n\n    void Write(const T& data) {\n      queue.Send(reinterpret_cast<const char*>(&data), sizeof(data));\n    }\n};\n```", "```cpp\ntemplate<class T>\nclass Reader {\n  private:\n    MessageQueue queue;\n  public:\n    Reader(std::string& name):\n      queue(name, O_RDONLY) {}\n\n    void Run() {\n      T data;\n      while(true) {\n        queue.Receive(reinterpret_cast<char*>(&data), \n          sizeof(data));\n        Callback(data);\n      }\n    }\n\n  protected:\n    virtual void Callback(const T& data) = 0;\n};\n```", "```cpp\nclass CoordLogger : public Reader<Message> {\n  using Reader<Message>::Reader;\n\n  protected:\n    void Callback(const Message& data) override {\n      std::cout << \"Received coordinate \" << data << std::endl;\n    }\n};\n```", "```cpp\nvoid DoWrites() {\n  std::vector<Message> messages {{1, 0}, {0, 1}, {1, 1}, {0, 0}};\n  Writer<Message> writer(kQueueName);\n  for (const auto& m : messages) {\n    std::cout << \"Write \" << m << std::endl;\n    writer.Write(m);\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n  }\n}\n```", "```cpp\nvoid DoReads() {\n CoordLogger logger(kQueueName);\n logger.Run();\n}\n```", "```cpp\nint main(int argc, char** argv) {\n  MessageQueue q(kQueueName, O_WRONLY, 10, sizeof(Message));\n  pid_t pid = fork();\n  if (pid) {\n    DoWrites();\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    kill(pid, SIGTERM);\n  } else {\n    DoReads();\n  }\n}\n```", "```cpp\ntarget_link_libraries(ipc3 rt)\n```", "```cpp\n  MessageQueue q(kQueueName, O_WRONLY, 10, sizeof(Message));\n```", "```cpp\n      while(true) {\n        queue.Receive(reinterpret_cast<char*>(&data), sizeof(data));\n        Callback(data);\n      }\n```", "```cpp\n  protected:\n    virtual void Callback(const T& data) = 0;\n```", "```cpp\n  protected:\n    void Callback(const Message& data) override {\n      std::cout << \"Received coordinate \" << data << std::endl;\n    }\n```", "```cpp\n  using Reader<Message>::Reader;\n```", "```cpp\n  CoordLogger logger(kQueueName);\n  logger.Run();\n```", "```cpp\ntemplate<class T>\nclass Reader {\n  private:\n    MessageQueue queue;\n    void (*func)(const T&);\n  public:\n    Reader(std::string& name, void (*func)(const T&)):\n      queue(name, O_RDONLY), func(func) {}\n\n    void Run() {\n      T data;\n      while(true) {\n        queue.Receive(reinterpret_cast<char*>(&data), \n         sizeof(data));\n        func(data);\n      }\n    }\n};\n```", "```cpp\nvoid DoReads() {\n  Reader<Message> logger(kQueueName, [](const Message& data) {\n    std::cout << \"Received coordinate \" << data << std::endl;\n  });\n  logger.Run();\n}\n```", "```cpp\nReader(std::string& name, void (*func)(const T&)):\n```", "```cpp\nvoid (*func)(const T&);\n```", "```cpp\nqueue.Receive(reinterpret_cast<char*>(&data), sizeof(data));\nfunc(data);\n```", "```cpp\n  Reader<Message> logger(kQueueName, [](const Message& data) {\n std::cout << \"Received coordinate \" << data << std::endl;\n });\n```", "```cpp\n#include <iostream>\n#include <sstream>\n#include <list>\n\nstruct Point {\n  int x, y;\n};\n\nstruct Paths {\n  Point source;\n  std::list<Point> destinations;\n};\n```", "```cpp\nstd::ostream& operator<<(std::ostream& o, const Point& p) {\n  o << p.x << \" \" << p.y << \" \";\n  return o;\n}\n\nstd::istream& operator>>(std::istream& is, Point& p) {\n  is >> p.x;\n  is >> p.y;\n  return is;\n}\n```", "```cpp\nstd::ostream& operator<<(std::ostream& o, const Paths& paths) {\n  o << paths.source << paths.destinations.size() << \" \";\n  for (const auto& x : paths.destinations) {\n    o << x;\n  }\n  return o;\n}\n\nstd::istream& operator>>(std::istream& is, Paths& paths) {\n  size_t size;\n  is >> paths.source;\n  is >> size;\n  for (;size;size--) {\n    Point tmp;\n    is >> tmp;\n    paths.destinations.push_back(tmp);\n  }\n  return is;\n}\n```", "```cpp\nint main(int argc, char** argv) {\n  Paths paths = {{0, 0}, {{1, 1}, {0, 1}, {1, 0}}};\n\n  std::stringstream in;\n  in << paths;\n  std::string serialized = in.str();\n  std::cout << \"Serialized paths into the string: [\"\n            << serialized << \"]\" << std::endl;\n\n  std::stringstream out(serialized);\n  Paths paths2;\n  out >> paths2;\n  std::cout << \"Original: \" << paths.destinations.size()\n            << \" destinations\" << std::endl;\n  std::cout << \"Restored: \" << paths2.destinations.size()\n            << \" destinations\" << std::endl;\n\n  return 0;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(stream)\nadd_executable(stream stream.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\n  o << paths.source << paths.destinations.size() << \" \";\n```", "```cpp\n  for (const auto& x : paths.destinations) {\n    o << x;\n  }\n```", "```cpp\nPaths paths = {{0, 0}, {{1, 1}, {0, 1}, {1, 0}}};\n```", "```cpp\n  std::stringstream in;\n  in << paths;\n  std::string serialized = in.str();\n```", "```cpp\n  Paths paths2;\n  out >> paths2;\n```", "```cpp\n# cmake .\n# make\n# make install\n```", "```cpp\n struct Message {\n x: int;\n y: int;\n}\n```", "```cpp\n$ flatc --cpp message.fbs\n```", "```cpp\n#include <mqueue.h>\n\n#include \"message_generated.h\"\n```", "```cpp\n std::ostream& operator<<(std::ostream& o, const Message& m) {\n  o << \"(x=\" << m.x() << \", y=\" << m.y() << \")\";\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(flat)\nadd_executable(flat ipc1.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS_RELEASE \"--std=c++11\")\nSET(CMAKE_CXX_FLAGS_DEBUG \"${CMAKE_CXX_FLAGS_RELEASE} -g -DDEBUG\")\ntarget_link_libraries(flat rt flatbuffers)\n\nset(CMAKE_C_COMPILER /usr/bin/arm-linux-gnueabi-gcc)\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n\nset(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)\nset(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)\nset(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)\n```", "```cpp\n# su - user\n$\n```", "```cpp\n  x: int;\n  y: int;\n```", "```cpp\n#include \"message_generated.h\"\n```", "```cpp\n  o << \"(x=\" << m.x() << \", y=\" << m.y() << \")\";\n```"]