- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Coroutines with Boost.Cobalt
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Boost.Cobalt 的协程
- en: The previous chapters introduced C++20 coroutines and the Boost.Asio library,
    which is the foundation for writing asynchronous **input/output** ( **I/O** )
    operations using Boost. In this chapter, we will explore Boost.Cobalt, a high-level
    abstraction based on Boost.Asio that simplifies asynchronous programming with
    coroutines.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章介绍了 C++20 协程和 Boost.Asio 库，后者是使用 Boost 编写异步 **输入/输出** ( **I/O** ) 操作的基础。在本章中，我们将探讨
    Boost.Cobalt，这是一个基于 Boost.Asio 的高级抽象，它简化了使用协程的异步编程。
- en: Boost.Cobalt allows you to write clear, maintainable asynchronous code while
    avoiding the complexities of manually implementing coroutines in C++ (as covered
    in [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164) ). Boost.Cobalt is fully compatible
    with Boost.Asio, allowing you to seamlessly combine both libraries in your projects.
    By using Boost.Cobalt, you can focus on building your application without worrying
    about the low-level details of coroutines.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Cobalt 允许你编写清晰、可维护的异步代码，同时避免在 C++ 中手动实现协程的复杂性（如第 [*第 8 章*](B22219_08.xhtml#_idTextAnchor164)
    中所述）。Boost.Cobalt 与 Boost.Asio 完全兼容，允许你在项目中无缝结合这两个库。通过使用 Boost.Cobalt，你可以专注于构建你的应用程序，而无需担心协程的低级细节。
- en: 'In this chapter, we will cover the following Boost.Cobalt topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下 Boost.Cobalt 主题：
- en: Introducing the Boost.Cobalt library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Boost.Cobalt 库
- en: Boost.Cobalt generators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost.Cobalt 生成器
- en: Boost.Cobalt tasks and promises
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost.Cobalt 任务和承诺
- en: Boost.Cobalt channels
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost.Cobalt 通道
- en: Boost.Cobalt synchronization functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost.Cobalt 同步函数
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To build and execute the code examples from this chapter, a compiler that supports
    C++20 is required. We have used both Clang **18** and GCC **14.2** .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和执行本章的代码示例，需要一个支持 C++20 的编译器。我们使用了 Clang **18** 和 GCC **14.2**。
- en: Make sure you use Boost version 1.84 or newer and that your Boost library was
    compiled with C++20 support. At the time of writing this book, Cobalt support
    is rather fresh in Boost and not all precompiled distributions may provide this
    component. The situation will generally improve by the time of reading this book.
    If, for any reason, the Boost library in your system does not meet these requirements,
    you have to build it from its source. Compiling with an earlier version, such
    as C++17, won’t include Boost.Cobalt since it relies heavily on C++20 coroutines.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你使用的是 Boost 版本 1.84 或更高版本，并且你的 Boost 库是用 C++20 支持编译的。在撰写本书时，Cobalt 在 Boost
    中的支持相对较新，并非所有预编译的分发版都可能提供此组件。在阅读本书时，情况通常会得到改善。如果由于任何原因，你系统中的 Boost 库不满足这些要求，你必须从其源代码构建它。使用更早的版本，如
    C++17，编译将不会包含 Boost.Cobalt，因为它严重依赖于 C++20 协程。
- en: 'You can find the complete code in the following GitHub repository:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下 GitHub 仓库中找到完整的代码：
- en: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)'
- en: The examples for this chapter are located under the **Chapter_10** folder.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例位于 **Chapter_10** 文件夹下。
- en: Introducing the Boost.Cobalt library
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Boost.Cobalt 库
- en: 'We introduced how C++20 supports coroutines in [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164)
    . It was made obvious that writing coroutines is not an easy task due to two main
    reasons:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第 8 章*](B22219_08.xhtml#_idTextAnchor164) 中介绍了 C++20 对协程的支持。很明显，由于两个主要原因，编写协程并不是一件容易的事情：
- en: Writing coroutines in C++ requires a certain amount of code to make the coroutine
    work but is not related to the functionality we want to implement. For example,
    the coroutine we wrote to generate the Fibonacci sequence was quite simple, but
    we had to implement the wrapper type, the promise, and all the functions required
    for it to be usable.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++ 中编写协程需要一定量的代码才能使协程工作，但这与我们要实现的功能无关。例如，我们编写的用于生成斐波那契序列的协程相当简单，但我们必须实现包装类型、承诺以及所有使其可用的函数。
- en: The development of plain C++20 coroutines requires a good knowledge of the low-level
    aspects of how coroutines are implemented in C++, how the compiler transforms
    our code to implement all the mechanisms necessary to keep the coroutine state,
    and details about how the functions we must implement are called and when.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 plain C++20 协程需要了解 C++ 中协程实现的底层细节，包括编译器如何将我们的代码转换为实现保持协程状态所需的所有机制，以及我们必须实现的功能的调用方式和时机。
- en: Asynchronous programming is difficult enough without all those many details.
    It would be much better if we could focus on our program and be isolated from
    the lower-level concepts and code. We saw how C++23 introduced **std::generator**
    precisely to achieve this. Let us write just the generator code, and let the C++
    Standard Library and compiler take care of the rest. It is expected that this
    coroutine support will improve in the next C++ version.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程本身就足够复杂，无需那么多细节。如果我们能专注于我们的程序，并从底层概念和代码中隔离出来，那就更好了。我们看到了 C++23 如何引入 **std::generator**
    来实现这一点。让我们只写生成器代码，让 C++ 标准库和编译器处理其余部分。预计在下一个 C++ 版本中，这种协程支持将得到改进。
- en: Boost.Cobalt, one of the libraries included in the Boost C++ libraries, allows
    us to do just that – avoid the coroutines details. Boost.Cobalt was introduced
    in Boost 1.84 and requires C++20 because it relies on the language coroutines
    features. It is based on Boost.Asio, and we can use both libraries in our programs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Cobalt 是 Boost C++ 库中包含的库之一，它允许我们做到这一点——避免协程的细节。Boost.Cobalt 在 Boost 1.84
    中引入，并需要 C++20，因为它依赖于语言协程功能。它基于 Boost.Asio，我们可以在程序中使用这两个库。
- en: The goal of Boost.Cobalt is to allow us to write simple single-threaded asynchronous
    code using coroutines – applications that can do multiple things simultaneously
    in a single thread. Of course, by simultaneously, we mean concurrently, not in
    parallel, because there is only one thread. By using Boost.Asio multithreading
    features, we can execute coroutines in different threads, but in this chapter,
    we will focus on single-threaded applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Cobalt 的目标是让我们能够使用协程编写简单的单线程异步代码——可以在单个线程中同时执行多项任务的应用程序。当然，当我们说“同时”时，我们是指并发，而不是并行，因为只有一个线程。通过使用
    Boost.Asio 的多线程功能，我们可以在不同的线程中执行协程，但在这个章节中，我们将专注于单线程应用程序。
- en: Eager and lazy coroutines
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**急切协程和懒协程**'
- en: 'Before we introduce the coroutine types implemented by Boost.Cobalt, we need
    to define the two kinds of coroutines:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍 Boost.Cobalt 实现的协程类型之前，我们需要定义两种协程类型：
- en: '**Eager coroutines** : An eager coroutine begins execution as soon as it is
    called. This means that the coroutine logic starts running immediately, and it
    progresses through its sequence until it hits a suspension point (such as **co_await**
    or **co_yield** ). The creation of the coroutine effectively starts its processing,
    and any side effects in its body will execute right away.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**急切协程**：急切协程在调用时立即开始执行。这意味着协程逻辑会立即开始运行，并一直运行到遇到挂起点（例如 **co_await** 或 **co_yield**）。协程的创建实际上启动了其处理过程，并且其主体中的任何副作用都会立即执行。'
- en: Eager coroutines are beneficial when you want the coroutine to initiate its
    work immediately upon being created, such as starting asynchronous network operations
    or preparing data.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你希望协程在创建时立即开始其工作，急切协程是有益的，例如启动异步网络操作或准备数据。
- en: '**Lazy coroutines** : A lazy coroutine defers its execution until is explicitly
    awaited or used. The coroutine object can be created without any of its body running
    until the caller decides to interact with it (usually by awaiting it with **co_await**
    ).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**懒协程**：懒协程会延迟其执行，直到被显式地等待或使用。协程对象可以在其主体中的任何代码运行之前被创建，直到调用者决定与之交互（通常是通过使用**co_await**来等待它）。'
- en: Lazy coroutines are useful when you want to set up a coroutine but delay its
    execution until a certain condition is met or when you need to coordinate its
    execution with other tasks.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你需要设置一个协程但希望延迟其执行，直到满足某个条件，或者需要与其他任务协调其执行时，懒协程非常有用。
- en: After defining eager and lazy coroutines we will describe the different types
    of coroutines implemented in Boost.Cobalt.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了急切协程和懒协程之后，我们将描述 Boost.Cobalt 中实现的不同类型的协程。
- en: Boost.Cobalt coroutine types
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost.Cobalt 协程类型
- en: 'Boost.Cobalt implements four types of coroutines. We will introduce them in
    this section, and then see some examples later in the chapter:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Cobalt 实现了四种类型的协程。我们将在本节中介绍它们，并在本章后面的部分给出一些示例：
- en: '**Promise** : This is the main coroutine type in Boost.Cobalt. It is used to
    implement asynchronous operations that return a single value (calling **co_return**
    ). It is an eager coroutine. It supports **co_await** , allowing asynchronous
    suspension and continuation. For example, a promise can be used to execute a network
    call that, when complete, will return its result without blocking other operations.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**承诺**：这是 Boost.Cobalt 中的主要协程类型。它用于实现返回单个值的异步操作（调用 **co_return**）。它是一个急切协程。它支持
    **co_await**，允许异步挂起和继续。例如，承诺可以用来执行网络调用，当完成时，将返回其结果而不会阻塞其他操作。'
- en: '**Task** : Task is the lazy version of the promise. It will not begin execution
    until is explicitly awaited. It provides more flexibility in controlling when
    and how a coroutine runs. When awaited, the task starts execution, allowing for
    delayed processing of asynchronous operations.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务**：任务是对承诺的懒实现。它将不会开始执行，直到被显式等待。它提供了更多的灵活性来控制协程何时以及如何运行。当被等待时，任务开始执行，允许延迟处理异步操作。'
- en: '**Generator** : In Boost.Cobalt, a generator is the only type of coroutine
    that can yield values. Each value is yielded individually using **co_yield.**
    Its functionality is like **std::generator** in C++23 but it allows waiting with
    **co_await** ( **std::generator** doesn’t).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成器**：在 Boost.Cobalt 中，生成器是唯一可以产生值的协程类型。每个值都是通过 **co_yield** 单独产生的。它的功能类似于
    C++23 中的 **std::generator**，但它允许使用 **co_await** 等待（**std::generator** 不支持）。'
- en: '**Detached** : This is an eager coroutine that can use **co_await** but not
    **co_return** values. It cannot be resumed and usually is not awaited.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分离的**：这是一个急切协程，可以使用 **co_await** 但不能返回 **co_return** 值。它不能被恢复，通常也不被等待。'
- en: So far, we introduced Boost.Cobalt. We defined what eager and lazy coroutines
    are and then we defined the four main types of coroutines in the library.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们介绍了 Boost.Cobalt。我们定义了急切和懒协程是什么，然后我们定义了库中的四种主要协程类型。
- en: In the next section, we will dive into one of the most important topics related
    to Boost.Cobalt – generators. We will also implement a few simple examples of
    generators.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨与 Boost.Cobalt 相关的最重要的主题之一——生成器。我们还将实现一些简单的生成器示例。
- en: Boost.Cobalt generators
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boost.Cobalt 生成器
- en: As discussed in [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164) , **generator
    coroutines** are specialized coroutines designed to yield values incrementally.
    After each value is yielded, the coroutine suspends itself until the caller requests
    the next value. In Boost.Cobalt, generators work in the same way. They are the
    only coroutine type that can yield values. This makes generators essential when
    you need a coroutine to produce multiple values over time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如在第 [*第8章*](B22219_08.xhtml#_idTextAnchor164) 中所述，**生成器协程**是专门设计的协程，用于逐步产生值。在产生每个值之后，协程会暂停自身，直到调用者请求下一个值。在
    Boost.Cobalt 中，生成器以相同的方式工作。它们是唯一可以产生值的协程类型。这使得生成器在您需要协程在一段时间内产生多个值时变得至关重要。
- en: One key characteristic of Boost.Cobalt generators is that they are eager by
    default, meaning they start execution immediately after being called. Additionally,
    these generators are asynchronous, allowing them to use **co_await** , an important
    difference from **std::generator** introduced in C++23, which is lazy and doesn’t
    support **co_await** .
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Cobalt 生成器的一个关键特性是它们默认是急切的，这意味着它们在被调用后立即开始执行。此外，这些生成器是异步的，允许它们使用 **co_await**，这是与
    C++23 中引入的 **std::generator** 的重要区别，后者是懒的且不支持 **co_await**。
- en: Looking at a basic example
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看基本示例
- en: 'Let’s begin with the simplest Boost.Cobalt program. This example is not that
    of a generator, but we will explain some important details with its help:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的 Boost.Cobalt 程序开始。这个例子不是生成器的例子，但我们将借助它解释一些重要细节：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we observe the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们观察到以下内容：
- en: To use Boost.Cobalt, the **<boost/cobalt.hpp>** header file must be included.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用 Boost.Cobalt，必须包含 **<boost/cobalt.hpp>** 头文件。
- en: 'You also must link the Boost.Cobalt library to your application. We supply
    a **CMakeLists.txt** file to do just that, not only for Boost.Cobalt but for all
    the required Boost libraries. To link Boost.Cobalt explicitly (that is, not all
    the required Boost libraries), just add the following line to your **CMakeLists.txt**
    file:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还必须将 Boost.Cobalt 库链接到您的应用程序。我们提供了一个 **CMakeLists.txt** 文件来完成这项工作，不仅适用于 Boost.Cobalt，还适用于所有必需的
    Boost 库。要显式地链接 Boost.Cobalt（即不是所有必需的 Boost 库），只需将以下行添加到您的 **CMakeLists.txt** 文件中：
- en: '[PRE1]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Use of the **co_main** function. Instead of the usual **main** function, Boost.Cobalt
    introduces a coroutine-based entry point called **co_main** . This function can
    use coroutine-specific keywords such as **co_return** . Boost.Cobalt implements
    the required **main** function internally.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**co_main**函数。与常规的**main**函数不同，Boost.Cobalt引入了一个基于协程的入口点，称为**co_main**。这个函数可以使用协程特定的关键字，如**co_return**。Boost.Cobalt内部实现了所需的**main**函数。
- en: Using **co_main** will let you implement the **main** function (entry point)
    of your program as a coroutine, thus being able to call **co_await** and **co_return**
    . Remember from [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164) that the **main**
    function cannot be a coroutine.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用**co_main**将允许您将程序的**main**函数（入口点）实现为协程，从而能够调用**co_await**和**co_return**。记住，从[*第8章*](B22219_08.xhtml#_idTextAnchor164)中，**main**函数不能是协程。
- en: 'If you cannot change your current **main** function, it is possible to use
    Boost.Cobalt. You just need to call a function, which will be the top-level function
    of your asynchronous code using Boost.Cobalt, from **main** . In fact, this is
    what Boost.Cobalt is doing: it implements a **main** function, which is the entry
    point of the program, and that (hidden to you) **main** function calls **co_main**
    .'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您无法更改当前的**主**函数，可以使用Boost.Cobalt。您只需从**main**函数中调用一个函数，这个函数将成为您使用Boost.Cobalt的异步代码的最高级函数。实际上，这正是Boost.Cobalt所做的事情：它实现了一个**主**函数，这是程序的入口点，并且（对您隐藏的）这个**主**函数调用了**co_main**。
- en: 'The easiest way to use your own **main** function would be something like this:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用您自己的**main**函数的最简单方法可能如下所示：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The example simply prints a greeting message and then returns 0 calling **co_await**
    . In all future examples, we will follow this pattern: including the **<boost/cobalt.hpp>**
    header file and using **co_main** instead of **main** .'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 示例简单地打印一条问候消息，然后通过调用**co_await**返回0。在所有未来的例子中，我们将遵循这个模式：包含**<boost/cobalt.hpp>**头文件，并使用**co_main**而不是**main**。
- en: Boost.Cobalt simple generators
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boost.Cobalt简单生成器
- en: 'Armed with the knowledge from our previous basic example, we will implement
    a very simple generator coroutine:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的基本例子中获得的知识的基础上，我们将实现一个非常简单的生成器协程：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code shows a simple generator that yields an integer value (using
    **co_yield** ) and returns another one ( using **co_return** ).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了一个简单的生成器，它产生一个整数值（使用**co_yield**）并返回另一个值（使用**co_return**）。
- en: '**cobalt::generator** is a **struct** template:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**cobalt::generator**是一个**struct**模板：'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The two parameter types are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 两个参数类型如下：
- en: '**Yield** : The generated object type'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Yield**：生成的对象类型'
- en: '**Push** : The input parameter type (defaults to **void** )'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Push**：输入参数类型（默认为**void**）'
- en: The **co_main** function prints both numbers after getting them using **co_await**
    (the caller waits for the values to be available). We have introduced some delays
    to simulate the processing a generator must do to generate the numbers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**co_main**函数在通过**co_await**获取数值后打印这两个数（调用者等待数值可用）。我们已经引入了一些延迟来模拟生成器必须执行的处理以生成这些数字。'
- en: 'Our second generator will yield the square of an integer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个生成器将产生一个整数的平方：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, **square_generator** yields the square of the **x** parameter.
    This shows how we can *push* values to a Boost.Cobalt generator. In Boost.Cobalt,
    pushing values to a generator means passing parameters (in the preceding example,
    the passed parameters are integers).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**square_generator**产生**x**参数的平方。这展示了我们如何将值推送到Boost.Cobalt生成器。在Boost.Cobalt中，将值推送到生成器意味着传递参数（在先前的例子中，传递的参数是整数）。
- en: 'The generator in this example, though correct, can be confusing. Take a look
    at the following line of code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，尽管生成器是正确的，但可能会令人困惑。请看以下代码行：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This creates the generator object with **10** as the initial value. Then, look
    at the following line of code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个初始值为**10**的生成器对象。然后，看看以下代码行：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will print the square of **10** and will push **4** to the generator. As
    you can see, the printed values are not the squares of the values passed to the
    generator. This is because the generator is initialized with one value (in this
    example, **10** ), and it generates the squared value when the caller calls **co_await**
    to pass another value. The generator will yield **100** when receiving the new
    value, **4** , then it will yield **16** when receiving the value of **12** ,
    and so on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印**10**的平方并将**4**推送到生成器。正如你所看到的，打印的值不是传递给生成器的值的平方。这是因为生成器初始化时有一个值（在这个例子中，**10**），当调用者调用**co_await**传递另一个值时，它将生成平方值。当接收到新值**4**时，生成器将产生**100**，然后当接收到**12**的值时，它将产生**16**，依此类推。
- en: 'We said that Boost.Cobalt generators are eager, but it is possible to make
    them wait ( **co_await** ) as soon as they start executing. The following example
    shows how to do it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过，Boost.Cobalt生成器是急切的，但它们在开始执行时可以等待（**co_await**）。以下示例展示了如何做到这一点：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code is very similar to the previous example, but there are some differences:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与上一个示例非常相似，但有一些不同：
- en: 'We create the generator without any parameter being passed to it:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建生成器时没有传递任何参数给它：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Take a look at the first line of the generator’s code:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看一下生成器代码的第一行：
- en: '[PRE10]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This makes the generator wait for the first pushed integer. This behaves as
    a lazy generator (in fact, it starts executing immediately because the generator
    is eager, but the first thing it does is wait for an integer).
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这使得生成器等待第一个推入的整数。这表现得像一个惰性生成器（实际上，它立即开始执行，因为生成器是急切的，但它首先做的事情是等待一个整数）。
- en: 'The yielded values are what we would expect from the code:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产生的值是我们从代码中期望得到的：
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will print **100** instead of the square of the previously pushed integer.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将打印**100**而不是之前推入整数的平方。
- en: 'Let’s summarize here what the example does: the **co_main** function calls
    the **square_generator** coroutine to generate the square of an integer value.
    The generator coroutine suspends itself at the beginning waiting for the first
    integer and it suspends itself after yielding each square. The example is easy
    on purpose, just to illustrate how to write a generator using Boost.Cobalt.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里总结一下示例做了什么：**co_main**函数调用**square_generator**协程生成整数的平方。生成器协程在开始时挂起等待第一个整数，并在产生每个平方后再次挂起。这个例子故意简单，只是为了说明如何使用Boost.Cobalt编写生成器。
- en: An important feature of the preceding program is that it runs in a single thread.
    This means that **co_main** and the generator coroutine run one after another.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个程序的一个重要特性是它在单个线程中运行。这意味着**co_main**和生成器协程一个接一个地运行。
- en: A Fibonacci sequence generator
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个斐波那契数列生成器
- en: In this section, we will implement a Fibonacci sequence generator like the one
    we implemented in [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164) . This will
    let us see how much easier is writing generator coroutines with Boost.Cobalt than
    with pure C++20 without using any coroutines library.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个类似于我们在[*第8章*](B22219_08.xhtml#_idTextAnchor164)中实现的斐波那契数列生成器。这将让我们看到使用Boost.Cobalt编写生成器协程比使用纯C++20（不使用任何协程库）要容易多少。
- en: 'We have written two versions of the generator. The first one calculates an
    arbitrary term of the Fibonacci sequence. We push the term we want to generate,
    and we get it. This generator uses a lambda as a Fibonacci calculator:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了两个版本的生成器。第一个计算斐波那契数列的任意项。我们推入我们想要生成的项，然后我们得到它。这个生成器使用lambda作为斐波那契计算器：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, we see that this generator is very similar to the one
    we implemented in the previous section to calculate the square of a number. At
    the beginning of the coroutine, we have the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到这个生成器与我们之前章节中用于计算数字平方的生成器非常相似。在协程的开始，我们有以下内容：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This line of code suspends the coroutine to wait for the first input value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使协程挂起以等待第一个输入值。
- en: 'And then we have the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有以下内容：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This generates the requested Fibonacci sequence term and suspends itself until
    the next term is requested. While the requested term is not equal to **-1** ,
    we can go on requesting more values until pushing **-1** terminates the coroutine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成所需的斐波那契数列项，并在请求下一个项之前挂起。当请求的项不等于**-1**时，我们可以继续请求更多值，直到推入**-1**终止协程。
- en: 'The next version of the Fibonacci generator will yield an infinite number of
    terms as they are requested. By *infinite* we mean *potentially infinite* . Think
    about this generator as always ready to yield one more Fibonacci sequence number:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个版本的斐波那契生成器将在需要时产生无限多个项。当我们说“无限”时，我们是指“潜在无限”。将这个生成器想象成总是准备好产生下一个斐波那契数列的数字：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code is easy to understand: the coroutine yields a value and
    suspends itself until another one is requested and the coroutine calculates the
    new value and yields it and suspends itself again in an infinite loop.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码很容易理解：协程产生一个值并暂停自己，直到另一个值被请求，然后协程计算新值并产生它，再次在无限循环中暂停自己。
- en: 'In this case, we can see the advantage of a coroutine: we can generate the
    terms of the Fibonacci sequence, one after another, whenever we need them. We
    don’t need to keep any state to generate the next term because the state is kept
    in the coroutine.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以看到协程的优势：我们可以在需要时逐个生成斐波那契数列的项。我们不需要保持任何状态来生成下一个项，因为状态被保存在协程中。
- en: Also note that even if the function executes an infinite loop, because it is
    a coroutine, it suspends and resumes again and again, avoiding blocking the current
    thread.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，即使函数执行了无限循环，因为它是一个协程，它会暂停并再次恢复，从而避免阻塞当前线程。
- en: Boost.Cobalt tasks and promises
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boost.Cobalt任务和承诺
- en: As we have already seen in this chapter, Boost.Cobalt promises are eager coroutines
    that return one value and Boost.Cobalt tasks are the lazy version of promises.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中已经看到的，Boost.Cobalt的承诺是急切协程，它们返回一个值，而Boost.Cobalt的任务是承诺的懒版本。
- en: We can see them as just functions that don’t yield multiple values like generators
    do. We can call a promise repeatedly to get more than one value, but the state
    won’t be kept between calls (as in generators). Basically, a promise is a coroutine
    that can use **co_await** (it can use **co_return** too).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其视为只是函数，不像生成器那样产生多个值。我们可以多次调用承诺以获取多个值，但调用之间不会保持状态（就像生成器中那样）。基本上，承诺是一个可以使用**co_await**（它也可以使用**co_return**）的协程。
- en: Different use cases of promises would be a socket listener to receive network
    packets, process them, make queries to a database, and then generate some results
    from the data. In general, their functionality requires asynchronously waiting
    for some result and then performing some processing on that result (or maybe just
    returning it to the caller).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺的不同用法可能是一个套接字监听器，用于接收网络数据包，处理它们，对数据库进行查询，然后从数据中生成一些结果。一般来说，它们的功能需要异步等待某个结果，然后对该结果进行一些处理（或者可能只是将其返回给调用者）。
- en: 'Our first example is a simple promise that generates one random number (this
    can be done with a generator too):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子是一个简单的承诺，它生成一个随机数（这也可以用生成器来完成）：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding code, we have written three coroutines:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已经编写了三个协程：
- en: '**co_main** : Remember that in Boost.Cobalt, **co_main** is a coroutine and
    it calls **co_return** to return a value.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**co_main**：记住在Boost.Cobalt中，**co_main**是一个协程，它调用**co_return**来返回一个值。'
- en: '**random()** : This coroutine returns a random number to the caller. It calls
    **random()** with **co_await** to generate the random number. It asynchronously
    waits for the random number to be generated.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**random()**：这个协程返回一个随机数给调用者。它使用**co_await**调用**random()**来生成随机数。它异步等待随机数的生成。'
- en: '**random_number()** : This coroutine generates a uniformly distributed random
    number between two values, **min** and **max** , and returns it to the caller.
    **random_number()** is also a promise.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**random_number()**：这个协程生成两个值**min**和**max**之间的均匀分布随机数，并将其返回给调用者。**random_number()**也是一个承诺。'
- en: 'The following coroutine returns a **std::vector<int>** of random numbers. **co_await
    random_number()** is called in a loop to generate a vector of **n** random numbers:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的协程返回一个包含随机数的**std::vector<int>**。在循环中调用**co_await random_number()**来生成一个包含**n**个随机数的向量：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding function returns a promise of **std::vector<int>** . To access
    the vector, we need to call **get()** :'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数返回一个**std::vector<int>**的承诺。要访问这个向量，我们需要调用**get()**：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous code prints the elements of the **v** vector. To access the vector,
    we need to call **v.get()** .
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码打印了**v**向量的元素。要访问这个向量，我们需要调用**v.get()**。
- en: 'We are going to implement a second example to illustrate how the execution
    of promises and tasks differ:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现第二个示例来展示承诺和任务的执行有何不同：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this example, we have implemented two coroutines: a promise and a task.
    As we have already said, the promise is eager and it starts executing as soon
    as it’s called. The task is lazy and it’s suspended after being called.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们实现了两个协程：一个承诺（promise）和一个任务（task）。正如我们之前所说的，承诺是急切的，它一旦被调用就开始执行。任务则是懒加载的，在被调用后会被挂起。
- en: When we run the program, it prints all the messages, which let us know exactly
    how the coroutines execute.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，它会打印出所有消息，这让我们确切地知道协程是如何执行的。
- en: 'After the first three lines of **co_main()** are executed, the printed output
    is the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完 **co_main()** 的前三行后，打印的输出如下：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: From these messages, we know that the promise has been executed until the call
    to **co_return** .
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些消息中，我们知道承诺已经执行到调用 **co_return** 的位置。
- en: 'After the next three lines of **co_main()** are executed, the printed output
    has these new messages:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完 **co_main()** 的下一三行后，打印的输出有这些新消息：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we see that the task has not been executed. It is a lazy coroutine and,
    for this reason, it just suspends immediately after being called and no messages
    are printed by this coroutine just yet.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到任务尚未执行。它是一个懒加载的协程，因此，在被调用后立即挂起，并且这个协程还没有打印任何消息。
- en: 'Three more lines of **co_main()** are executed, and these are the new messages
    in the program’s output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 执行了三行更多的 **co_main()** 代码，这些是新消息，程序输出的内容如下：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The call to **co_await** on the promise gives us its result (in this case, set
    to **1** ) and its execution ends.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在承诺上调用 **co_await** 会给我们其结果（在这个例子中，设置为 **1**）并且执行结束。
- en: 'Finally, we call **co_await** on the task, and it then executes and returns
    its value (which, in this case, is set to **2** ). The output is the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在任务上调用 **co_await**，然后它执行并返回其值（在这个例子中，设置为 **2**）。输出如下：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This example shows how tasks are lazy and start suspended and only resume executing
    when the caller calls **co_await** on them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了任务是如何懒加载的，开始时是挂起的，并且只有在调用者对它们调用 **co_await** 时才会恢复执行。
- en: In this section, we have seen that, as in the case of generators, it is much
    easier to write promise and task coroutines using Boost.Cobalt than just using
    plain C++. We don’t need to write all the support code that C++ requires to implement
    coroutines. We have also seen the main difference between tasks and promises.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了，就像生成器的情况一样，使用 Boost.Cobalt 比仅仅使用纯 C++ 更容易编写承诺和任务协程。我们不需要编写 C++ 实现协程所需的所有支持代码。我们也看到了任务和承诺之间的主要区别。
- en: In the next section, we will study an example of a channel, a communication
    mechanism between two coroutines in a producer/consumer model.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将研究一个通道的例子，这是一个在生产者/消费者模型中两个协程之间的通信机制。
- en: Boost.Cobalt channels
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boost.Cobalt 通道
- en: In Boost.Cobalt, channels provide a way for coroutines to communicate asynchronously,
    allowing data transfer between a producer and a consumer coroutine in a safe and
    efficient manner. They are inspired by Golang channels and allow communication
    through message passing, promoting a *share-memory-by-communicating* paradigm.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Boost.Cobalt 中，通道为协程提供了异步通信的方式，允许生产者和消费者协程之间以安全且高效的方式进行数据传输。它们受到了 Golang 通道的启发，并允许通过消息传递进行通信，促进了一种“通过通信共享内存”的范式。
- en: 'A **channel** is a mechanism through which values are asynchronously passed
    from one coroutine (the producer) to another (the consumer). This communication
    is non-blocking, which means that coroutines can suspend their execution when
    they wait for data to be available on the channel or when they write data to a
    channel that has limited capacity. Let’s clarify this: both reading and writing
    operations may be blocking, depending on the buffer size if, by *blocking* , we
    mean coroutines are suspended, but on the other hand, from the point of view of
    threads, these operations don’t block the thread.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**通道**是一种机制，通过它，值可以从一个协程（生产者）异步地传递到另一个协程（消费者）。这种通信是非阻塞的，这意味着协程在等待通道上有可用数据时可以挂起它们的执行，或者在向具有有限容量的通道写入数据时也可以挂起。让我们澄清一下：如果“阻塞”意味着协程被挂起，那么读取和写入操作可能会根据缓冲区大小而阻塞，但另一方面，从线程的角度来看，这些操作不会阻塞线程。'
- en: If the buffer size is zero, a read and a write will need to occur at the same
    time and act as a rendezvous (synchronous communication). If the channel size
    is bigger than zero and the buffer is not full, the write operation will not suspend
    the coroutine. Likewise, if the buffer is not empty, the read operation will not
    suspend.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缓冲区大小为零，读取和写入将需要同时发生并作为 rendezvous（同步通信）。如果通道大小大于零且缓冲区未满，写入操作不会挂起协程。同样，如果缓冲区不为空，读取操作也不会挂起。
- en: Similar to Golang channels, Boost.Cobalt channels are strongly typed. A channel
    is defined for a specific type, and only that type can be sent through it. For
    example, a channel of the **int** type ( **boost::cobalt::channel<int>** ) can
    only transmit integers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Golang 的通道，Boost.Cobalt 的通道是强类型的。通道为特定类型定义，并且只能通过它发送该类型的数据。例如，**int** 类型的通道（**boost::cobalt::channel<int>**）只能传输整数。
- en: 'Let’s now see an example of a channel:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看一个通道的示例：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, we create a size **0** channel and two coroutines: the **producer**
    promise and **co_main()** , which acts as the consumer. The producer writes integers
    to the channel and the consumer reads them back and prints them squared.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个大小为 **0** 的通道和两个协程：**生产者**承诺和作为消费者的 **co_main()**。生产者将整数写入通道，消费者读取它们并将它们平方后打印出来。
- en: 'We added **std::this_thread::sleep** to delay the program execution and, hence,
    be able to see what happens as the program runs. Let’s see an excerpt of the example’s
    output to see how it works:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了 `**std::this_thread::sleep**` 来延迟程序执行，从而能够看到程序运行时的状态。让我们看看示例输出的摘录，看看它是如何工作的：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Both the consumer and the producer wait for the next action to happen. The producer
    will always wait for the consumer to request the next item. This is basically
    how generators work, and it is a very common pattern in asynchronous code using
    coroutines.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者和生产者都等待下一个动作发生。生产者将始终等待消费者请求下一个项目。这基本上是生成器的工作方式，并且在使用协程的异步代码中是一个非常常见的模式。
- en: 'The consumer executes the following line of code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者执行以下代码行：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, the producer writes the next number to the channel and waits for the
    next request. This is done in the following line of code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，生产者将下一个数字写入通道并等待下一个请求。这是在以下代码行中完成的：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can see in the fourth line of the previous output excerpt how the producer
    goes back to waiting for the next request.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在上一段输出摘录的第四行中看到生产者如何返回等待下一个请求。
- en: Boost.Cobalt channels make writing this kind of asynchronous code very clean
    and easy to understand.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Cobalt 通道使得编写这种异步代码非常清晰且易于理解。
- en: The example shows both coroutines communicating through a channel.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 示例显示了两个协程通过通道进行通信。
- en: That wraps up this section. The next one will introduce synchronization functions
    – mechanisms to wait for more than one coroutine.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分内容就到这里。下一部分将介绍同步函数——等待多个协程的机制。
- en: Boost.Cobalt synchronization functions
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boost.Cobalt 同步函数
- en: Previously, we implemented coroutines, and, in every case in which we called
    **co_await** , we did it for just one coroutine. This means we waited for the
    result of only one coroutine. Boost.Cobalt has mechanisms that allow us to wait
    on more than one coroutine. These mechanisms are called **synchronization functions**
    .
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们实现了协程，并且在每次调用 `**co_await**` 的时候，我们只为一个协程调用。这意味着我们只等待一个协程的结果。Boost.Cobalt
    有机制允许我们等待多个协程。这些机制被称为 **同步函数**。
- en: 'There are four synchronization functions implemented in Boost.Cobalt:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Boost.Cobalt 实现了四个同步函数：
- en: '**race** : The **race** function waits for one coroutine out of a set to complete,
    but it does so in a pseudo-random manner. This mechanism helps avoid starvation
    of coroutines, ensuring that one coroutine doesn’t dominate the execution flow
    over others. When you have multiple asynchronous operations and you want the first
    to finish to determine the flow, **race** will allow any coroutine that becomes
    ready to proceed in a non-deterministic order.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**race**：**race** 函数等待一组协程中的一个完成，但它以伪随机的方式进行。这种机制有助于避免协程的饥饿，确保一个协程不会在执行流程上主导其他协程。当你有多个异步操作，并且想要第一个完成以确定流程时，**race**
    将允许任何准备就绪的协程以非确定性的顺序继续执行。'
- en: When you have multiple tasks (tasks in the generic sense, not Boost.Cobalt tasks)
    and are interested in completing one first, without preference as to which one,
    but want to prevent one coroutine from always winning in situations where readiness
    is simultaneous, you will use **race** .
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你有多个任务（在通用意义上，不是Boost.Cobalt任务）并且对完成其中一个感兴趣，没有偏好哪个，但想要防止在准备就绪同时发生的情况下一个协程总是获胜时，你会使用**race**。
- en: '**join** : The **join** function waits for all the coroutines in a given set
    to complete and return their results as values. If any of the coroutines throws
    an exception, **join** will propagate the exception to the caller. It’s a way
    to gather results from multiple asynchronous operations that must all finish before
    proceeding.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**join**：**join**函数等待给定集合中的所有协程完成，并返回它们的值。如果任何一个协程抛出异常，**join**将把异常传播给调用者。这是一种从多个异步操作中收集结果的方法，这些操作必须在继续之前全部完成。'
- en: You will use **join** when you need the result of multiple asynchronous operations
    together and want to throw an error if any of them fail.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你需要多个异步操作的结果一起，并且如果任何一个操作失败则想要抛出错误时，你会使用**join**。
- en: '**gather** : The **gather** function, like **join** , waits for a set of coroutines
    to complete, but it handles exceptions differently. Instead of throwing an exception
    immediately when one of the coroutines fails, **gather** captures each coroutine’s
    result individually. This means that you can inspect the outcome (success or failure)
    of each coroutine independently.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gather**：与**join**类似，**gather**函数等待一组协程完成，但它处理异常的方式不同。当其中一个协程失败时，**gather**不会立即抛出异常，而是单独捕获每个协程的结果。这意味着你可以独立检查每个协程的输出（成功或失败）。'
- en: When you need all asynchronous operations to complete but you want to capture
    all results and exceptions individually to handle them separately, you will use
    **gather** .
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你需要所有异步操作都完成，但想要单独捕获所有结果和异常以分别处理时，你会使用**gather**。
- en: '**left_race** : The **left_race** function is like **race** but with deterministic
    behavior. It evaluates the coroutines from left to right and waits for the first
    coroutine to become ready. This can be useful when the order of coroutine completion
    matters, and you want to ensure a predictable outcome based on the order in which
    they were provided.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**left_race**：**left_race**函数类似于**race**，但具有确定性行为。它从左到右评估协程，并等待第一个协程准备好。当协程完成的顺序很重要，并且你想要基于它们提供的顺序确保可预测的结果时，这可能很有用。'
- en: When you have multiple potential results and need to favor the first available
    coroutine in the order provided, making the behavior more predictable than **race**
    , you will use **left_race** .
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你有多个潜在的结果，并且需要优先考虑提供的顺序中的第一个可用的协程，使行为比**race**更可预测时，你会使用**left_race**。
- en: In this section, we will explore examples of both **join** and **gather** functions.
    As we have seen, both functions wait for a set of coroutines to finish. The difference
    between them is that **join** throws an exception if any of the coroutines throw
    an exception, and **gather** always returns the results for all the awaited coroutines.
    In the case of the **gather** function, the result for each coroutine will either
    be an error (absent value) or a value. **join** returns a tuple of values or throws
    an exception; **gather** returns a tuple of optional values that have no value
    in the event of an exception (the optional variables are not initialized).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨**join**和**gather**函数的示例。正如我们所见，这两个函数都等待一组协程完成。它们之间的区别在于，如果任何一个协程抛出异常，**join**将抛出一个异常，而**gather**总是返回所有等待的协程的结果。在**gather**函数的情况下，每个协程的结果将要么是一个错误（缺失值），要么是一个值。**join**返回一个值元组或抛出一个异常；**gather**返回一个可选值元组，在发生异常的情况下没有值（可选变量未初始化）。
- en: The full code for the following example is in the GitHub repo. We will focus
    here on the main sections.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例的完整代码在GitHub仓库中。在这里，我们将关注主要部分。
- en: 'We have defined a simple function to simulate data processing, which is just
    a delay. The function throws an exception if we pass a delay bigger than 5,000
    milliseconds:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个简单的函数来模拟数据处理，它仅仅是一个延迟。如果传递的延迟大于5,000毫秒，该函数将抛出一个异常：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The function is a Boost.Cobalt promise.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数是一个Boost.Cobalt承诺。
- en: 'Now, in the next section of the code, we will wait for three instances of this
    promise to run:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在代码的下一节中，我们将等待这个承诺的三个实例运行：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding code calls **join** to wait for the completion of three coroutines
    and then prints the time they took. As you can see, the result is a tuple, and
    to make the code as simple as possible, we just call **std::get<i>(result)** for
    each element. In this case, all the processing times are inside the valid range
    and no exception is thrown, so we can get the result for all the executed coroutines.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码调用**join**等待三个协程完成，然后打印它们所花费的时间。正如你所看到的，结果是元组，为了使代码尽可能简单，我们只为每个元素调用**std::get<i>(result)**。在这种情况下，所有处理时间都在有效范围内，没有抛出异常，因此我们可以获取所有已执行协程的结果。
- en: 'If an exception is thrown, then we won’t get any value:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出异常，则我们不会得到任何值：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code will throw an exception because the second coroutine receives
    a processing time outside of the valid range. It will print an error message.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将抛出异常，因为第二个协程接收到的处理时间超出了有效范围。它将打印一条错误信息。
- en: When calling the **join** function, we want all the coroutines to be considered
    as part of processing and, in the event of an exception, the full processing fails.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用**join**函数时，我们希望所有协程都被视为处理的一部分，并且在发生异常的情况下，整个处理失败。
- en: 'If we need to get all the results for each coroutine, we will use the **gather**
    function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要获取每个协程的所有结果，我们将使用**gather**函数：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have put the code inside a **try-catch** block but no exception is thrown.
    The **gather** function returns a tuple of optional values, and we need to check
    whether each coroutine returned a value or not (the optional has a value or not).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将代码放在了**try-catch**块中，但没有抛出异常。**gather**函数返回一个可选值的元组，我们需要检查每个协程是否返回了值（可选值是否有值）。
- en: We use **gather** when we want the coroutines to return a value if they are
    executed successfully.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望协程在成功执行时返回一个值时，我们使用**gather**。
- en: These examples of **join** and **gather** functions conclude our introduction
    to the Boost.Cobalt synchronization functions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些**join**和**gather**函数的例子结束了我们对Boost.Cobalt同步函数的介绍。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to implement coroutines using the Boost.Cobalt library.
    It was added to Boost only recently, and there is not much information about it.
    It simplifies the development of asynchronous code with coroutines, avoiding writing
    the low-level code necessary for C++20 coroutines.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用Boost.Cobalt库实现协程。它最近才被添加到Boost中，关于它的信息并不多。它简化了使用协程异步代码的开发，避免了编写C++20协程所需的底层代码。
- en: We studied the main library concepts and developed some simple examples to understand
    them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了主要库概念，并开发了一些简单的示例来理解它们。
- en: With Boost.Cobalt, writing asynchronous code using coroutines is simplified.
    All the low-level details of writing coroutines in C++ are implemented by the
    library and we can focus just on the functionality we want to implement in our
    programs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Boost.Cobalt，使用协程编写异步代码变得简单。C++中编写协程的所有底层细节都由库实现，我们可以专注于我们想要在程序中实现的功能。
- en: In the next chapter, we will see how to debug asynchronous code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何调试异步代码。
- en: Further reading
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Boost.Cobalt reference: *Boost.Cobalt reference* *guide* ( [https://www.boost.org/doc/libs/1_86_0/libs/cobalt/doc/html/index.html#overview](https://www.boost.org/doc/libs/1_86_0/libs/cobalt/doc/html/index.html#overview)
    )'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost.Cobalt参考：*Boost.Cobalt参考* *指南* ([https://www.boost.org/doc/libs/1_86_0/libs/cobalt/doc/html/index.html#overview](https://www.boost.org/doc/libs/1_86_0/libs/cobalt/doc/html/index.html#overview)
    )
- en: 'A YouTube video on Boost.Cobalt: *Using coroutines with* *Boost.Cobalt* ( [https://www.youtube.com/watch?v=yElSdUqEvME](https://www.youtube.com/watch?v=yElSdUqEvME)
    )'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个关于Boost.Cobalt的YouTube视频：*使用Boost.Cobalt进行协程* ([https://www.youtube.com/watch?v=yElSdUqEvME](https://www.youtube.com/watch?v=yElSdUqEvME)
    )
- en: 'Part 5: Debugging, Testing, and Performance Optimization in Asynchronous Programming'
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5部分：异步编程中的调试、测试和性能优化
- en: In this final part, we focus on the essential practices of debugging, testing,
    and optimizing the performance of multithreaded and asynchronous programs. We
    will begin by using logging and advanced debugging tools and techniques, including
    reverse debugging and code sanitizers, to identify and resolve subtle bugs in
    asynchronous applications, such as crashes, deadlocks, race conditions, memory
    leaks, and thread safety issues, followed by testing strategies tailored for asynchronous
    code using the GoogleTest framework. Finally, we will dive into performance optimization,
    understanding key concepts such as cache sharing, false sharing, and how to mitigate
    performance bottlenecks. Mastering these techniques will provide us with a comprehensive
    toolkit for identifying, diagnosing, and improving the quality and performance
    of asynchronous applications.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本最终部分，我们专注于调试、测试和优化多线程和异步程序性能的基本实践。我们将首先使用日志记录和高级调试工具和技术，包括反向调试和代码清理器，来识别和解决异步应用程序中的微妙错误，例如崩溃、死锁、竞态条件、内存泄漏和线程安全问题，随后使用GoogleTest框架针对异步代码制定测试策略。最后，我们将深入性能优化，理解诸如缓存共享、伪共享以及如何缓解性能瓶颈等关键概念。掌握这些技术将为我们提供一套全面的工具集，用于识别、诊断和改进异步应用程序的质量和性能。
- en: 'This part has the following chapters:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 11*](B22219_11.xhtml#_idTextAnchor228) , *Logging and Debugging Asynchronous
    Software*'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B22219_11.xhtml#_idTextAnchor228) ，*异步软件的日志记录和调试*'
- en: '[*Chapter 12*](B22219_12.xhtml#_idTextAnchor243) , *Sanitizing and Testing
    Asynchronous Software*'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B22219_12.xhtml#_idTextAnchor243) ，*清理和测试异步软件*'
- en: '[*Chapter 13*](B22219_13.xhtml#_idTextAnchor267) , *Improving Asynchronous
    Software Performance*'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B22219_13.xhtml#_idTextAnchor267) ，*提高异步软件性能*'
