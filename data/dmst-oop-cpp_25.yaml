- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: 'The programming solutions for each chapters'' questions can be found in our
    GitHub repository at the following URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master).
    Each full program solution can be found in the GitHub under the appropriate chapter
    heading (subdirectory, such as `Chapter01`) in the subdirectory `Assessments`,
    in a file that corresponds to the chapter number, followed by a dash, followed
    by the solution number in the chapter at hand. For example, the solution for question
    3 in chapter 1 can be found in the subdirectory `Chapter01/Assessments` in a file
    named `Chp1-Q3.cpp` under the aforementioned GitHub directory.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每章的编程解决方案可以在我们的GitHub存储库的以下URL找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/tree/master)。每个完整的程序解决方案可以在GitHub的适当章节标题下（子目录，如`Chapter01`）的`Assessments`子目录中找到，文件名对应于章节编号，后跟着该章节中的解决方案编号的破折号。例如，第1章问题3的解决方案可以在GitHub目录中的`Chapter01/Assessments`子目录中的名为`Chp1-Q3.cpp`的文件中找到。
- en: The written responses for non-programming questions can be found in the following
    sections. Should an exercise have a programming portion and a follow-up question,
    the answer to the follow-up question may be found both in the next sections and
    in a comment at the top of the programming solution on GitHub (as it may be appropriate
    to review the solution in order to fully understand the answer to the question).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 非编程问题的书面答复可以在以下部分找到。如果一个练习有编程部分和后续问题，后续问题的答案可以在下一部分和GitHub上编程解决方案的顶部评论中找到（因为可能需要查看解决方案才能完全理解问题的答案）。
- en: Chapter 1 – Understanding Basic C++ Assumptions
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 - 理解基本的C++假设
- en: A `flush` may be useful, rather than an `endl`, for clearing the contents of
    a buffer associated with `cout` for the situations where you do not wish the cursor
    to be advanced to the next line for output. Recall, an `endl` manipulator is merely
    a newline character plus a buffer flush.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不希望光标移到下一行进行输出的情况下，使用`flush`可能比`endl`更有用，用于清除与`cout`相关的缓冲区的内容。请记住，`endl`操作符仅仅是一个换行字符加上一个缓冲区刷新。
- en: Choosing a pre versus a post increment for a variable, such as `++i` (versus
    `i++`), will have an impact on the code when used in conjunction with a compound
    expression. A typical example would be `result = array[i++];` versus `result =
    array[++i];`. With the post-increment (`i++`), the contents of `array[i]` will
    be assigned to `result` and then `i` is incremented. With the pre-increment, `i`
    is first incremented and then `result` will have the value of `array[i]` (that
    is, using the new value of `i` as an index).
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择变量的前置增量还是后置增量，比如`++i`（与`i++`相比），将影响与复合表达式一起使用时的代码。一个典型的例子是`result = array[i++];`与`result
    = array[++i];`。使用后置增量（`i++`），`array[i]`的内容将被赋给`result`，然后`i`被增加。使用前置增量，`i`首先被增加，然后`result`将具有`array[i]`的值（即，使用`i`的新值作为索引）。
- en: Please see `Chapter01/Assessments/Chp1-Q3.cpp` in the GitHub repository.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub存储库中的`Chapter01/Assessments/Chp1-Q3.cpp`。
- en: Chapter 2 – Adding Language Necessities
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 - 添加语言必需品
- en: The signature of a function is the function's name plus its type and number
    of arguments (no return type). This relates to name mangling as the signature
    helps the compiler provide a unique, internal name for each function. For example,
    `void Print(int, float);` may have mangled name of `Print_int_float();`. This
    facilitates overloaded functions by giving each function a unique name so that
    when a call is made, it is evident by the internal function name as to which function
    is being invoked.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的签名是函数的名称加上其类型和参数数量（没有返回类型）。这与名称修饰有关，因为签名帮助编译器为每个函数提供一个唯一的内部名称。例如，`void Print(int,
    float);`可能有一个名称修饰为`Print_int_float();`。这通过为每个函数提供一个唯一的名称来促进重载函数，因此当调用被执行时，可以根据内部函数名称明确调用哪个函数。
- en: "`Chapter02/Assessments/Chp2-Q2.cpp` in the \LGitHub repository."
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter02/Assessments/Chp2-Q2.cpp`。
- en: 'Chapter 3 – Indirect Addressing: Pointers'
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 - 间接寻址：指针
- en: '`Chapter03/Assessments/Chp3-Q1.cpp` in the GitHub repository.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter03/Assessments/Chp3-Q1.cpp`。
- en: '`Print(Student)` is less efficient than `Print(const Student *)` as the initial
    version of this function passes an entire object on the stack, whereas the overloaded
    version passes only a pointer on the stack.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Print(Student)`比`Print(const Student *)`效率低，因为这个函数的初始版本在堆栈上传递整个对象，而重载版本只在堆栈上传递一个指针。'
- en: 'Assuming we have an existing pointer to an object of type `Student`, such as:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个指向`Student`类型对象的现有指针，比如：
- en: '`Student *s0 = new Student;` (this `Student` is not yet initialized with data)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Student *s0 = new Student;`（这个`Student`还没有用数据初始化）'
- en: '`const Student *s1;` (does not require initialization)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`const Student *s1;`（不需要初始化）'
- en: '`Student *const s2 = s0;` (requires initialization)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Student *const s2 = s0;`（需要初始化）'
- en: '`const Student *const s3 = s0;` (also requires initialization)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`const Student *const s3 = s0;`（也需要初始化）'
- en: Passing an argument of type `const Student *` to `Print()` would allow a pointer
    to a `Student` to be passed into `Print()` for speed, yet the object pointed to
    could not be dereferenced and modified. Yet passing a `Student * const` as a parameter
    to `Print()` would not make sense because a copy of the pointer would be passed
    to `Print()`. Marking that copy additionally as `const` (meaning not allowing
    changing where the pointer points) would then be meaningless as disallowing a
    *copy* of a pointer to be changed has no effect on the original pointer itself.
    The original pointer was never in jeopardy of its address being changed within
    the function.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类型为`const Student *`的参数传递给`Print()`将允许将`Student`的指针传递给`Print()`以提高速度，但指向的对象不能被取消引用和修改。然而，将`Student
    * const`作为`Print()`的参数传递是没有意义的，因为指针的副本将被传递给`Print()`。将该副本标记为`const`（意味着不允许更改指针的指向）将是没有意义的，因为不允许更改指针的*副本*对原始指针本身没有影响。原始指针从未面临在函数内部更改其地址的风险。
- en: There are many programming situations that might use a dynamically allocated
    3-D array. For example, if an image is stored in a 2-D array, a collection of
    images might be stored in a 3-D array. Having a dynamically allocated 3-D array
    allows for any number of images to be read in from a filesystem and stored internally.
    Of course, you'd need to know how many images you'll be reading in before making
    the 3-D array allocation. For example, a 3-D array might hold 30 images, where
    30 is the third dimension to collect the images in a set. To conceptualize a 4-D
    array, perhaps you would like to organize sets of the aforementioned 3-D arrays.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有许多编程情况可能使用动态分配的3-D数组。例如，如果一个图像存储在2-D数组中，一组图像可能存储在3-D数组中。动态分配的3-D数组允许从文件系统中读取任意数量的图像并在内部存储。当然，在进行3-D数组分配之前，你需要知道要读取多少图像。例如，一个3-D数组可能包含30张图像，其中30是第三维，用于收集图像集。为了概念化一个4-D数组，也许你想要组织前述3-D数组的集合。
- en: For example, perhaps you have a set of 31 images for the month of January. That
    set of January images is a 3-D array (2-D for the image and the third dimension
    for the set of 31 images comprising January). You may wish to do the same for
    every month. Rather than having separate 3-D array variables for each month's
    image set, we can create a fourth dimension to collect the years' worth of data
    into one set. The fourth dimension would have an element for each of the 12 months
    of the year. How about a 5-D array? You can extend this image idea by making the
    fifth dimension a way to collect various years of data, such as collecting images
    for a century (fifth dimension). Now we have images organized by century, then
    organized by year, then by month, and then by image (the image requiring the first
    two dimensions).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，也许你有一个包含31张图片的一月份的图片集。这组一月份的图片是一个3-D数组（2-D用于图像，第三维用于包含一月份的31张图片的集合）。你可能希望对每个月都做同样的事情。我们可以创建一个第四维来将一年的数据收集到一个集合中，而不是为每个月的图像集创建单独的3-D数组变量。第四维将为一年的12个月中的每个月都有一个元素。那么5-D数组呢？你可以通过将第五维作为收集各年数据的方式来扩展这个图像的想法，比如收集一个世纪的图像（第五维）。现在我们有了按世纪组织的图像，然后按年份组织，然后按月份组织，最后按图像组织（图像需要前两个维度）。
- en: 'Chapter 4 – Indirect Addressing: References'
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 - 间接寻址：引用
- en: '`Chapter04/Assessments/Chp4-Q1.cpp` in the GitHub repository.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter04/Assessments/Chp4-Q1.cpp`。
- en: '`ReadData(Student *)` that accepts a pointer to a `Student` and reference variables
    need not only call the version of `ReadData(Student &)` that accepts a reference
    to a `Student`. For example, a pointer variable may be dereferenced with `*` and
    then call the version that accepts a reference. Likewise, a reference variable
    may have its address taken using `&` and then call the version that accepts a
    pointer (though this is less commonly done). You simply need to make the data
    types match with respect to what you are passing and what the function expects.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadData(Student *)`接受一个指向`Student`的指针和引用变量不仅需要调用接受`Student`引用的`ReadData(Student
    &)`版本。例如，指针变量可以使用`*`取消引用，然后调用接受引用的版本。同样，引用变量可以使用`&`取其地址，然后调用接受指针的版本（尽管这种情况较少见）。你只需要确保传递的数据类型与函数期望的匹配。'
- en: Chapter 5 – Exploring Classes in Detail
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 - 详细探讨类
- en: '`Chapter05/Assessments/Chp5-Q1.cpp` in the GitHub repository.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter05/Assessments/Chp5-Q1.cpp`。
- en: Chapter 6 – Implementing Hierarchies with Single Inheritance
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 - 使用单继承实现层次结构
- en: '`Chapter06/Assessments/Chp6-Q1.cpp` in the GitHub repository.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter06/Assessments/Chp6-Q1.cpp`。
- en: '`Chapter06/Assessments/Chp6-Q2.cpp` in the GitHub repository.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter06/Assessments/Chp6-Q2.cpp`。
- en: Chapter 7 – Utilizing Dynamic Binding through Polymorphism
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 - 通过多态性利用动态绑定
- en: '`Chapter07/Assessments/Chp7-Q1.cpp` in the GitHub repository.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter07/Assessments/Chp7-Q1.cpp`。
- en: Chapter 8 – Mastering Abstract Classes
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 - 掌握抽象类
- en: '`Chapter08/Assessments/Chp8-Q1.cpp` in the GitHub repository.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter08/Assessments/Chp8-Q1.cpp`。
- en: '`Shape` class may or may not be considered an interface class. If your implementation
    is an abstract class that contains no data members and only abstract methods (pure
    virtual functions), your `Shap`e implementation is considered an interface class.
    If your `Shape` class, however, stores `area` as a data member once it has been
    calculated by the overridden `Area()` method in the derived classes, it is then
    just an abstract base class.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shape`类可能被视为接口类，也可能不是。如果你的实现是一个不包含数据成员，只包含抽象方法（纯虚函数）的抽象类，那么你的`Shape`实现被认为是一个接口类。然而，如果你的`Shape`类在派生类中的重写`Area()`方法计算出`area`后将其存储为数据成员，那么它只是一个抽象基类。'
- en: Chapter 9 – Exploring Multiple Inheritance
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 - 探索多重继承
- en: Please see `Chapter09/Assessments/Chp9-Q1.cpp` in the GitHub repository.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub存储库中的`Chapter09/Assessments/Chp9-Q1.cpp`。
- en: '`LifeForm` sub-object.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`LifeForm`子对象。'
- en: '`LifeForm` constructor and destructor are each invoked once.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`LifeForm`构造函数和析构函数各被调用一次。'
- en: '`LifeForm` would be invoked if the specifications of an alternate constructor
    of `LifeForm(1000)` was removed in the member initialization list of the `Centaur`
    constructor.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Centaur`构造函数的成员初始化列表中删除了`LifeForm(1000)`的替代构造函数的规范，则将调用`LifeForm`。
- en: Please see `Chapter09/Assessments/Chp9-Q2.cpp` in the GitHub repository.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请在GitHub存储库中查看`Chapter09/Assessments/Chp9-Q2.cpp`。
- en: '`LifeForm` sub-objects.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`LifeForm`子对象。'
- en: '`LifeForm` constructor and destructor are each invoked twice.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`LifeForm`构造函数和析构函数各被调用两次。'
- en: Chapter 10 – Implementing Association, Aggregation, and Composition
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章-实现关联、聚合和组合
- en: Please see `Chapter10/Assessments/Chp10-Q1.cpp` in the GitHub repository.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请在GitHub存储库中查看`Chapter10/Assessments/Chp10-Q1.cpp`。
- en: (follow-up question) Once you have overloaded a constructor that accepts a `University
    &` as a parameter, this version may be invoked using a `University *` by first
    dereferencing the pointer to the `University` within the constructor call (to
    make a referenceable object).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: (后续问题)一旦您重载了一个接受`University &`作为参数的构造函数，可以通过首先取消引用构造函数调用中的`University`指针来调用这个版本（使其成为可引用的对象）。
- en: '`Chapter10/Assessments/Chp10-Q2.cpp` in the GitHub repository.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter10/Assessments/Chp10-Q2.cpp`。
- en: '`Chapter10/Assessments/Chp10-Q3.cpp` in the GitHub repository.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter10/Assessments/Chp10-Q3.cpp`。
- en: Chapter 11 – Handling Exceptions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章-处理异常
- en: '`Chapter11/Assessments/Chp11-Q1.cpp` in the GitHub repository.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter11/Assessments/Chp11-Q1.cpp`。
- en: Chapter 12 – Friends and Operator Overloading
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章-友元和运算符重载
- en: Please see `Chapter12/Assessments/Chp12-Q1.cpp` in the GitHub repository.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请在GitHub存储库中查看`Chapter12/Assessments/Chp12-Q1.cpp`。
- en: Please see `Chapter12/Assessments/Chp12-Q2.cpp` in the GitHub repository.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请在GitHub存储库中查看`Chapter12/Assessments/Chp12-Q2.cpp`。
- en: Please see `Chapter12/Assessments/Chp12-Q3.cpp` in the GitHub repository.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请在GitHub存储库中查看`Chapter12/Assessments/Chp12-Q3.cpp`。
- en: Chapter 13 – Working with Templates
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章-使用模板
- en: '`Chapter13/Assessments/Chp13-Q1.cpp` in the GitHub repository.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter13/Assessments/Chp13-Q1.cpp`。
- en: Please see `Chapter13/Assessments/Chp13-Q2.cpp` in the GitHub repository.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请在GitHub存储库中查看`Chapter13/Assessments/Chp13-Q2.cpp`。
- en: Chapter 14 – Understanding STL Basics
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章-理解STL基础
- en: '`Chapter14/Assessments/Chp14-Q1.cpp` in the GitHub repository.'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter14/Assessments/Chp14-Q1.cpp`。
- en: Please see `Chapter14/Assessments/Chp14-Q2.cpp` in the GitHub repository.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请在GitHub存储库中查看`Chapter14/Assessments/Chp14-Q2.cpp`。
- en: Please see `Chapter14/Assessments/Chp14-Q3.cpp` in the GitHub repository.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请在GitHub存储库中查看`Chapter14/Assessments/Chp14-Q3.cpp`。
- en: Please see `Chapter14/Assessments/Chp14-Q4.cpp` in the GitHub repository.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请在GitHub存储库中查看`Chapter14/Assessments/Chp14-Q4.cpp`。
- en: Chapter 15 – Testing Classes and Components
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章-测试类和组件
- en: '**a**: Your classes follow orthodox canonical class form if they each include
    a (user-specified) default constructor, copy constructor, overloaded assignment
    operator, and a virtual destructor. Your classes additionally follow extended
    canonical class form if they also include a move copy constructor and an overloaded
    move assignment operator.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**a**：如果每个类都包括（用户指定的）默认构造函数、复制构造函数、重载的赋值运算符和虚析构函数，则您的类遵循正统的规范类形式。如果它们还包括移动复制构造函数和重载的移动赋值运算符，则您的类还遵循扩展的规范类形式。'
- en: '**b**: Your class will be considered robust if it follows canonical class form
    and ensures that all instances of a class have the means to be fully-constructed.
    Testing a class can ensure robustness.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**b**：如果您的类遵循规范类形式，并确保类的所有实例都具有完全构造的手段，则您的类将被视为健壮的。测试类可以确保健壮性。'
- en: '`Chapter15/Assessments/Chp15-Q2.cpp` in the GitHub repository.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter15/Assessments/Chp15-Q2.cpp`。
- en: Please see `Chapter15/Assessments/Chp15-Q3.cpp` in the GitHub repository.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请在GitHub存储库中查看`Chapter15/Assessments/Chp15-Q3.cpp`。
- en: Chapter 16 – Using the Observer Pattern
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章-使用观察者模式
- en: '`Chapter16/Assessments/Chp16-Q1.cpp` in the GitHub repository.'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter16/Assessments/Chp16-Q1.cpp`。
- en: Other examples which may easily incorporate the Observer pattern include any
    application requiring customers to receive a notification of backordered products
    that they desire. For example, many people may wish to receive the Covid-19 vaccine
    and wish to be on a waiting list at a vaccine distribution site. Here, a `VaccineDistributionSite`
    (the subject of interest) can be inherited from `Subject` and contain a list of
    `Person` objects, where `Person` inherits from `Observer`. The `Person` objects
    will contain a pointer to the `VaccineDistributionSite`. Once enough supply for
    the vaccine exists at a given `VaccineDistributionSite` (that is, a distribution
    event has occurred), `Notify()` can be called to update the `Observer` instances
    (people on the wait-list). Each `Observer` will be sent an `Update()`, which will
    be the means to allow that person to schedule an appointment. If the `Update()`
    returns success and the person has been scheduled for an appointment, the `Observer`
    can release itself from the waiting list with the `Subject`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他很容易包含观察者模式的例子包括任何需要顾客接收所需产品缺货通知的应用程序。例如，许多人可能希望接种Covid-19疫苗，并希望在疫苗分发站的等候名单上。在这里，`VaccineDistributionSite`（感兴趣的主题）可以从`Subject`继承，并包含一个`Person`对象列表，其中`Person`继承自`Observer`。`Person`对象将包含一个指向`VaccineDistributionSite`的指针。一旦在给定的`VaccineDistributionSite`上存在足够的疫苗供应（即，分发事件已发生），就可以调用`Notify()`来更新`Observer`实例（等候名单上的人）。每个`Observer`将收到一个`Update()`，这将是允许该人安排约会的手段。如果`Update()`返回成功并且该人已经安排了约会，`Observer`可以通过`Subject`从等候名单中释放自己。
- en: Chapter 17 – Applying the Factory Pattern
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章-应用工厂模式
- en: '`Chapter17/Assessments/Chp17-Q1.cpp` in the GitHub repository.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter17/Assessments/Chp17-Q1.cpp`。
- en: Other examples which may easily incorporate the Factory Method pattern include
    many types of applications in which various derived classes may need to be instantiated
    based upon the specific values provided at construction. For example, a payroll
    application may require various types of `Employee` instances, such as `Manager`,
    `Engineer`, `Vice-President`, and so on. A factory method can provide a way to
    instantiate the various types of `Employee` based on the information provided
    when the `Employee` is hired. The Factory Method pattern is a pattern that can
    be applied to many types of applications.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他可能很容易融入工厂方法模式的例子包括许多类型的应用程序，其中根据提供的特定值实例化各种派生类可能是必要的。例如，工资单应用程序可能需要各种类型的`Employee`实例，如`Manager`、`Engineer`、`Vice-President`等。工厂方法可以根据雇佣`Employee`时提供的信息来实例化各种类型的`Employee`。工厂方法模式是一种可以应用于许多类型的应用程序的模式。
- en: Chapter 18 – Applying the Adapter Pattern
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章 - 应用适配器模式
- en: '`Chapter18/Assessments/Chp18-Q1.cpp` in the GitHub repository.'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitHub存储库中的`Chapter18/Assessments/Chp18-Q1.cpp`。
- en: Other examples which may easily incorporate the Adapter pattern include many
    examples of repurposing existing, well-tested non-OO code to provide an OO interface
    (that is, a wrapper type of Adapter). Other examples include creating an Adapter
    to convert a formerly used class into a currently needed class (again with the
    idea of reusing previously created and well-tested components). An example is
    to adapt a `Car` class that has been previously used to represent gasoline engine
    cars into a class that models an `ElectricCar`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他可能很容易融入适配器模式的例子包括许多重用现有、经过充分测试的非面向对象代码以提供面向对象接口（即适配器的包装类型）的例子。其他例子包括创建一个适配器，将以前使用的类转换为当前需要的类（再次使用先前创建和经过充分测试的组件的想法）。一个例子是将以前用于表示汽油发动机汽车的`Car`类改编为模拟`ElectricCar`的类。
- en: Chapter 19 – Using the Singleton Pattern
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章 - 使用单例模式
- en: '`Chapter19/Assessments/Chp19-Q1.cpp`'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Chapter19/Assessments/Chp19-Q1.cpp`'
- en: We cannot label the `static instance()` method as virtual in `Singleton` and
    override it in `President` simply because static methods can never be virtual.
    They are statically bound and also never receive a `this` pointer. Also, the signature
    may need to be different (and no one likes an un-intentional function hiding situation).
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能将`Singleton`中的`static instance()`方法标记为虚拟的，并在`President`中重写它，因为静态方法永远不可能是虚拟的。它们是静态绑定的，也永远不会接收到`this`指针。此外，签名可能需要不同（没有人喜欢无意的函数隐藏情况）。
- en: Other examples which may easily incorporate the Singleton pattern include creating
    a Singleton `CEO` of a company or a Singleton `TreasuryDepartment` for a country
    or a Singleton `Queen` of a nation. Each of these Singleton instances offers the
    opportunity to establish a registry to keep track of multiple Singleton objects.
    That is, many countries may have a single `Queen`. In this case, the registry
    would allow not just one Singleton per object type, but one Singleton per other
    qualifiers, such as *nation*. This is an example of the rare case where more than
    one Singleton object of a given type can occur (but always a controlled number
    of such objects).
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他例子可能很容易地融入单例模式，包括创建一个公司的单例`CEO`，或者一个国家的单例`TreasuryDepartment`，或者一个国家的单例`Queen`。这些单例实例都提供了建立注册表以跟踪多个单例对象的机会。也就是说，许多国家可能只有一个`Queen`。在这种情况下，注册表不仅允许每种对象类型有一个单例，而且还允许每个其他限定符（如*国家*）有一个单例。这是一个罕见的例子，其中同一类型的单例对象可能会出现多个（但始终是受控数量的对象）。
- en: Chapter 20 – Removing Implementation Details Using the pImpl Pattern
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第20章 - 使用pImpl模式去除实现细节
- en: Please see `Chapter20/Assessments/Chp20-Q1.cpp` in the GitHub repository.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub存储库中的`Chapter20/Assessments/Chp20-Q1.cpp`。
- en: Please see `Chapter20/Assessments/Chp20-Q2.cpp` in the GitHub repository.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请参阅GitHub存储库中的`Chapter20/Assessments/Chp20-Q2.cpp`。
- en: (Follow-up question) Simply inheriting `Student` from the `Person` class in
    this chapter that embraces the pImpl pattern presents no logistical difficulties.
    Additionally, modifying the `Student` class to also employ the pImpl pattern and
    utilize a unique pointer is more challenging. Various approaches may run across
    various difficulties, including dealing with inline functions, down-casting, avoiding
    explicit calls to the underlying implementation, or requiring back pointers to
    help invoke virtual functions. Please see the online solution for details.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: （后续问题）在本章中，从`Person`类中简单地继承`Student`，这个类采用了pImpl模式，不会出现后勤上的困难。此外，修改`Student`类以使用pImpl模式并利用独特指针更具挑战性。各种方法可能会遇到各种困难，包括处理内联函数、向下转型、避免显式调用底层实现，或需要反向指针来帮助调用虚拟函数。有关详细信息，请参阅在线解决方案。
- en: Other examples which may easily incorporate the pImpl pattern for relative implementation
    independence include creating generic GUI components, such as for `Window`, `Scrollbar`,
    `Textbox`, and so on, for various platforms (derived classes). The implementation
    details can easily be hidden. Other examples include proprietary commercial classes
    that the developer wishes to hide the implementation details that might otherwise
    be seen in a header file.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他可能很容易融入pImpl模式以实现相对独立的实现的例子包括创建通用的GUI组件，比如`Window`、`Scrollbar`、`Textbox`等，用于各种平台（派生类）。实现细节可以很容易地隐藏起来。其他例子包括希望隐藏在头文件中可能看到的实现细节的专有商业类。
