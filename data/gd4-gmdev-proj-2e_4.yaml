- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Jungle Jump – Running and Jumping in a 2D Platformer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热带跳跃 – 在 2D 平台游戏中奔跑和跳跃
- en: In this chapter, you’ll build a *platformer* game in the tradition of classics
    such as *Super Mario Bros*. Platform games are a very popular genre, and understanding
    how they work can help you make a variety of different game styles. If you’ve
    never attempted making one before, the player movement in platformers can be surprisingly
    complex to implement, and you’ll see how Godot’s `CharacterBody2D` node has features
    to help you in that process.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将按照经典游戏如**超级马里奥兄弟**的传统构建一个**平台游戏**。平台游戏是一个非常受欢迎的游戏类型，了解它们的工作原理可以帮助你制作各种不同的游戏风格。如果你之前从未尝试过制作这样的游戏，平台游戏中的玩家动作实现可能会出人意料地复杂，你将看到
    Godot 的 `CharacterBody2D` 节点如何帮助你完成这个过程。
- en: 'In this project, you will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将学习以下内容：
- en: Using the `CharacterBody2D` node
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `CharacterBody2D` 节点
- en: Using the `Camera2D` node
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Camera2D` 节点
- en: Combining animations and user input to produce complex character behavior
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合动画和用户输入以产生复杂的角色行为
- en: Designing levels using `TileMap`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `TileMap` 设计关卡
- en: Creating an infinitely scrolling background using `ParallaxLayer`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `ParallaxLayer` 创建无限滚动的背景
- en: Transitioning between scenes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景之间切换
- en: Organizing your project and planning for expansion
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织你的项目和规划扩展
- en: 'Here is a screenshot of the completed game:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完成游戏的截图：
- en: '![Figure 4.1: Completed game screenshot](img/B19289_04_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：完成的游戏截图](img/B19289_04_01.jpg)'
- en: 'Figure 4.1: Completed game screenshot'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：完成的游戏截图
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with the previous projects, you’ll start by downloading the art assets for
    the game, which can be found here: [https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的项目一样，你将首先下载游戏的美术资源，这些资源可以在以下链接找到：[https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-Engine-Game-Development-Projects-Second-Edition/tree/main/Downloads)
- en: 'You can also find the complete code for this chapter on GitHub at: [https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter04%20-%20Jungle%20Jump](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter04%20-%20Jungle%20Jump)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 GitHub 上找到本章的完整代码：[https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter04%20-%20Jungle%20Jump](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter04%20-%20Jungle%20Jump)
- en: Setting up the project
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: To create a new project, start by opening **Project Settings** so that you can
    configure the defaults that you’ll need.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新项目，首先打开**项目设置**，以便你可以配置所需的默认设置。
- en: 'The art assets for this game use a **pixel art** style, which means they look
    best when the images are not smoothed, which is Godot’s default setting for **texture
    filtering**:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本游戏的美术资源采用**像素艺术**风格，这意味着当图像未进行平滑处理时它们看起来最好，这是 Godot 对**纹理过滤**的默认设置：
- en: '![Figure 4.2: Texture filtering](img/B19289_04_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2：纹理过滤](img/B19289_04_02.jpg)'
- en: 'Figure 4.2: Texture filtering'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：纹理过滤
- en: While it’s possible to set this on each `Sprite2D`, it’s more convenient to
    specify the default setting. Click the **Advanced** toggle in the top right and
    find the **Rendering/Textures** section on the left. In the settings list, scroll
    to the bottom and find the **Canvas Textures/Default Texture Filter** setting.
    Change it from **Linear** to **Nearest**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以在每个 `Sprite2D` 上设置此选项，但指定默认设置更为方便。点击右上角的**高级**切换按钮，然后在左侧找到**渲染/纹理**部分。在设置列表中滚动到最底部，找到**画布纹理/默认纹理过滤**设置。将其从**线性**更改为**最近**。
- en: Then, under **Display/Window**, change **Stretch/Mode** to **canvas items**
    and **Aspect** to **expand**. These settings will allow the user to resize the
    game window while preserving the image’s quality. Once the project is complete,
    you’ll be able to see the effects of this setting.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在**显示/窗口**下，将**拉伸/模式**更改为**画布项**，并将**纵横比**更改为**扩展**。这些设置将允许用户在保持图像质量的同时调整游戏窗口的大小。一旦项目完成，你将能够看到此设置的成效。
- en: 'Next, you can set up the collision layers. Because this game will have several
    different types of collision objects that need to interact in different ways,
    you’ll use Godot’s **collision layer** system to help organize them. The layers
    will be more convenient to use if they’re assigned names, so go to the **Layer
    Names | 2D Physics** section and name the first four layers like this (by typing
    directly in the box next to the layer number):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以设置碰撞层。因为这款游戏将有几种不同类型的碰撞对象，它们需要以不同的方式交互，所以你会使用 Godot 的 **碰撞层** 系统来帮助组织它们。如果它们被分配了名称，那么使用起来会更方便，所以前往
    **层名称 | 2D 物理** 部分，并将前四个层命名为如下（直接在层编号旁边的框中键入）：
- en: '![Figure 4.3: Setting physics layer names](img/B19289_04_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3：设置物理层名称](img/B19289_04_03.jpg)'
- en: 'Figure 4.3: Setting physics layer names'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：设置物理层名称
- en: 'Finally, add the following actions for the player controls to the **Input**
    **Map** area:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下动作添加到 **输入** **映射** 区域的玩家控制中：
- en: '| **Action name** | **Key(s)** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **动作名称** | **按键** |'
- en: '| `right` | *D*, → |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `right` | *D*, → |'
- en: '| `left` | *A*, ← |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `left` | *A*, ← |'
- en: '| `jump` | Space |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `jump` | 空格键 |'
- en: '| `up` | *S*, ↑ |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `up` | *S*, ↑ |'
- en: '| `down` | *W*, ↓ |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `down` | *W*, ↓ |'
- en: Make sure you use the exact names for the input actions since you’ll be referencing
    them in code later.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你使用确切的名称来命名输入动作，因为你稍后会在代码中引用它们。
- en: That’s all you need to set in **Project Settings**. But before you start making
    the player scene, you need to learn about a different type of physics node.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要在 **项目设置** 中设置的所有内容。但在你开始制作玩家场景之前，你需要了解不同类型的物理节点。
- en: Introducing kinematic bodies
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍运动学物体
- en: A platformer requires gravity, collisions, jumping, and other physics behavior,
    so you might think that `RigidBody2D` would be the perfect choice to implement
    the character’s movement. In practice, you’ll find that the more realistic physics
    of the rigid body are not desirable for a platform character. To the player, realism
    is less important than responsive control and an action feel. So, as the developer,
    you want to have precise control over the character’s movements and collision
    response. For this reason, a **kinematic** style of physics is usually the better
    choice for a platform character.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 平台游戏需要重力、碰撞、跳跃和其他物理行为，所以你可能认为 `RigidBody2D` 是实现角色移动的完美选择。在实践中，你会发现刚体的更真实物理特性对于平台角色来说并不理想。对于玩家来说，现实感不如响应控制感和动作感重要。因此，作为开发者，你希望对角色的移动和碰撞响应有精确的控制。因此，对于平台角色来说，**运动学**风格的物理通常是更好的选择。
- en: The `CharacterBody2D` node is designed for implementing physics bodies that
    are to be controlled directly via code. These nodes detect collisions with other
    bodies when they move but are not affected by global physics properties such as
    gravity or friction. This doesn’t mean that they can’t be affected by gravity
    and other forces – just that you must calculate those forces and their effects
    in code; the physics engine will not move a `CharacterBody2D` node automatically.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`CharacterBody2D` 节点是为了实现那些需要通过代码直接控制的物理体而设计的。当它们移动时，这些节点会检测与其他物体的碰撞，但不会受到全局物理属性（如重力或摩擦）的影响。这并不意味着它们不能受到重力和其他力的作用——只是你必须计算这些力及其在代码中的效果；物理引擎不会自动移动
    `CharacterBody2D` 节点。'
- en: When moving a `CharacterBody2D` node as with `RigidBody2D`, you should not set
    its `position` property directly. Instead, you must use the `move_and_collide()`
    or `move_and_slide()` methods provided by the body. These methods move the body
    along a given vector and instantly stop it if a collision is detected with another
    body. It’s then up to you to decide on any **collision response**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当移动 `CharacterBody2D` 节点，就像使用 `RigidBody2D` 一样，你不应该直接设置其 `position` 属性。相反，你必须使用由物体提供的
    `move_and_collide()` 或 `move_and_slide()` 方法。这些方法沿着给定的向量移动物体，并在检测到与其他物体的碰撞时立即停止。然后，由你来决定任何
    **碰撞响应**。
- en: Collision response
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞响应
- en: 'After a collision, you may want the body to bounce, slide along a wall, or
    alter the properties of the object it hit. The way you handle collision response
    depends on which method you use to move the body:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞发生后，你可能想让物体弹跳、沿着墙壁滑动，或者改变它撞击物体的属性。处理碰撞响应的方式取决于你使用哪种方法来移动物体：
- en: move_and_collide()
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: move_and_collide()
- en: When using this method, the function returns a `KinematicCollision2D` object
    upon collision. This object contains information about the collision and the colliding
    body. You can use this information to determine the response. Note that the function
    returns `null` when movement is completed successfully with no collision.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这种方法时，在碰撞发生时函数会返回一个`KinematicCollision2D`对象。这个对象包含有关碰撞和碰撞体的信息。你可以使用这些信息来确定响应。请注意，当没有碰撞且移动成功完成时，函数返回`null`。
- en: 'For example, if you want the body to bounce off the colliding object, you could
    use the following script:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想使身体从碰撞对象上弹开，你可以使用以下脚本：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: move_and_slide()
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: move_and_slide()
- en: Sliding is a very common option for collision response. Imagine a player moving
    along a wall in a top-down game, or running along the ground in a platformer.
    While it’s possible to code the response yourself after using `move_and_collide()`,
    `move_and_slide()` provides a convenient way to implement sliding movement. When
    using this method, the body will automatically slide along the surface of a colliding
    object. In addition, sliding collisions will allow you to detect the orientation
    of the surface using methods such as `is_on_floor()`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动是碰撞响应中一个非常常见的选项。想象一下在一个俯视角游戏中，玩家沿着墙壁移动，或者在平台游戏中沿着地面奔跑。在使用`move_and_collide()`之后，你可以自己编写代码来实现响应，但`move_and_slide()`提供了一个方便的方式来实现滑动移动。当使用这种方法时，身体会自动沿着碰撞对象的表面滑动。此外，滑动碰撞将允许你使用`is_on_floor()`等方法检测表面的方向。
- en: Since this project will require you to allow the player character to run along
    the ground and up/down slopes, `move_and_slide()` is going to play a large role
    in your player’s movement.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个项目需要你允许玩家角色在地面和上下坡道上奔跑，`move_and_slide()`将在你的玩家移动中扮演重要角色。
- en: Now that you have an understanding of what kinematic bodies are, you’ll use
    one to make the character for this game.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了运动学身体是什么，你将使用一个来制作这个游戏的角色。
- en: Creating the player scene
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建玩家场景
- en: The Godot node that implements kinematic movement and collision is called `CharacterBody`
    `2D`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 实现运动学移动和碰撞的Godot节点被称为`CharacterBody` `2D`。
- en: Open a new scene and add a `CharacterBody2D` node named `Player` as the root
    and save the scene. Don’t forget to click the `Player` scene, you should also
    create a new folder to contain it. This will help keep your project folder organized
    as you add more scenes and scripts.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的场景，并添加一个名为`Player`的`CharacterBody2D`节点作为根节点，并保存场景。别忘了点击`Player`场景，你还应该创建一个新的文件夹来包含它。这有助于在你添加更多场景和脚本时保持你的项目文件夹组织有序。
- en: Look at the properties of `CharacterBody2D` in the Inspector. Notice the default
    values of **Motion Mode** and **Up Direction**. “Grounded” mode means the body
    will consider one collision direction as the “floor,” the opposite wall as the
    “ceiling,” and any others as “walls” – which one is determined by **Up Direction**.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Inspector中`CharacterBody2D`的属性。注意**运动模式**和**向上方向**的默认值。“地面”模式意味着身体将考虑一个碰撞方向作为“地板”，相对的墙壁作为“天花板”，其他任何作为“墙壁”——哪一个由**向上方向**决定。
- en: As you’ve done in previous projects, you’ll include all the nodes the player
    character needs to function in the Player scene. For this game, that means handling
    collisions with various game objects, including platforms, enemies, and collectibles;
    displaying animations for actions, such as running or jumping; and attaching a
    camera to follow the player around the level.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在之前的项目中做的那样，你将在玩家场景中包含玩家角色需要的功能节点。对于这个游戏，这意味着处理与各种游戏对象的碰撞，包括平台、敌人和可收集物品；显示动作动画，如奔跑或跳跃；并将相机附加到跟随玩家在关卡中移动。
- en: Scripting the various animations can quickly become unmanageable, so you’ll
    need to use a **finite-state machine** (**FSM**) to manage and track the player’s
    state. See [*Chapter* *3*](B19289_03.xhtml#_idTextAnchor066) to review how a simplified
    FSM can be built. You’ll follow a similar pattern for this project.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 编写各种动画的脚本可能会很快变得难以管理，所以你需要使用一个**有限状态机**（**FSM**）来管理和跟踪玩家的状态。参见[*第3章*](B19289_03.xhtml#_idTextAnchor066)回顾如何构建简化的FSM。你将遵循类似的项目模式。
- en: Collision layers and masks
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞层和掩码
- en: A body’s `Player` needs to be assigned to the “player” layer (which you named
    in **Project Settings**). Similarly, **Collision/Mask** sets which layers the
    body can “see” or interact with. If an object is on a layer that is not in the
    player’s **Mask**, then the player won’t interact with it at all.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个身体的`Player`需要分配到“player”层（您在**项目设置**中命名的层）。同样，**碰撞/遮罩**设置身体可以“看到”或与之交互的层。如果一个对象在一个不在玩家**遮罩**中的层上，那么玩家根本不会与之交互。
- en: 'Set the player’s **Layer** to **player** and **Mask** to **environment**, **enemies**,
    and **items**. Click the three dots to the right to open a list of checkboxes
    showing the names you’ve assigned to the layers:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将玩家的**层**设置为**player**，**遮罩**设置为**环境**、**敌人**和**物品**。点击右侧的三个点以打开一个复选框列表，显示您分配给层的名称：
- en: '![Figure 4.4: Setting collision layers](img/B19289_04_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4：设置碰撞层](img/B19289_04_04.jpg)'
- en: 'Figure 4.4: Setting collision layers'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：设置碰撞层
- en: This will ensure that the player is on the “player” layer so that other objects
    can be configured to detect the player or not. Setting the **Mask** value to all
    three layers means the player will be able to interact with objects on any of
    those layers.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保玩家位于“player”层，以便其他对象可以配置为检测玩家或不检测玩家。将**遮罩**值设置为所有三个层意味着玩家将能够与这些层上的任何对象交互。
- en: About AnimationPlayer
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于AnimationPlayer
- en: Earlier in this book, you used `AnimatedSprite2D` to display the frame-based
    animations of your characters. This is a great tool, but it’s only useful for
    animating the visual texture of a node. What if you want to also animate any of
    a node’s other properties?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期，您使用了`AnimatedSprite2D`来显示角色的基于帧的动画。这是一个很好的工具，但它仅适用于动画节点的视觉纹理。如果您还想动画化节点上的其他任何属性怎么办？
- en: This is where `AnimationPlayer` comes in. This node is a very powerful tool
    for creating animations that can affect multiple nodes at once; you can modify
    any of their properties.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`AnimationPlayer`发挥作用的地方。这个节点是一个非常强大的工具，可以一次性影响多个节点创建动画；你可以修改它们的任何属性。
- en: Animations
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画
- en: 'To set up the character’s animations, follow these steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置角色的动画，请按照以下步骤操作：
- en: 'Add a `Sprite2D` node to `Player`. Drag the `res://assets/player_sheet.png`
    file from the **FileSystem** dock and drop it into the **Texture** property. The
    player animation will be saved in the form of a sprite sheet:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`Sprite2D`节点添加到`Player`中。从**FileSystem**面板拖动`res://assets/player_sheet.png`文件并将其放入**Texture**属性。玩家动画将以精灵图集的形式保存：
- en: '![](img/B19289_04_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19289_04_05.jpg)'
- en: 'Figure 4.5: Sprite sheet'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：精灵图集
- en: You’ll use `AnimationPlayer` to handle the animations, so, in the `Sprite2D`,
    set `19`. Then, set `7` to see the player standing. Finally, move `Sprite2D` upward
    until its feet are standing on the ground by setting `(0, -16)`. This will make
    it easier to code the player’s interactions later because you will know that the
    player’s `position` property represents the location of its feet.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将使用`AnimationPlayer`来处理动画，因此，在`Sprite2D`中设置`19`。然后，将`7`设置为查看玩家站立。最后，通过将`(0,
    -16)`设置为向上移动`Sprite2D`，使其脚部站在地面上。这将使您在稍后编码玩家的交互时更容易，因为您将知道玩家的`position`属性代表其脚部的位置。
- en: Add an `AnimationPlayer` node to the scene. You’ll use this node to change the
    `Sprite2D` to the appropriate values for each animation.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`AnimationPlayer`节点添加到场景中。您将使用此节点来更改每个动画的`Sprite2D`的适当值。
- en: 'Before you start, review the different parts of the **Animation** panel:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始之前，请回顾一下**动画**面板的不同部分：
- en: '![Figure 4.6: The Animation panel](img/B19289_04_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6：动画面板](img/B19289_04_06.jpg)'
- en: 'Figure 4.6: The Animation panel'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：动画面板
- en: Click the `idle`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`idle`。
- en: Set its `0.4` seconds. Click the **Loop** icon to make the animation loop, and
    set the track’s **Update Mode** to **Continuous**.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其`0.4`秒。点击**循环**图标以使动画循环，并将轨道的**更新模式**设置为**连续**。
- en: 'Change the `Sprite2D` to `7`, which is the first frame of the idle animation,
    and click the **keyframe** icon next to the property to add an animation track
    with a new keyframe:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Sprite2D`更改为`7`，这是空闲动画的第一帧，并点击属性旁边的**关键帧**图标以添加一个带有新关键帧的动画轨道：
- en: '![Figure 4.7: Adding a keyframe](img/B19289_04_07.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7：添加关键帧](img/B19289_04_07.jpg)'
- en: 'Figure 4.7: Adding a keyframe'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：添加关键帧
- en: Slide the play scrubber to `0.3` (you can adjust the zoom slider in the bottom
    right to make it easier to find). Add a keyframe for frame `10`, which is the
    last frame of **idle**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将播放刮擦器滑到`0.3`（您可以在右下角的缩放滑块中调整以使其更容易找到）。为第`10`帧添加一个关键帧，这是`idle`的最后一帧。
- en: Press the `7` and ended on frame `10`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按`7`键并结束在第`10`帧。
- en: 'Now, repeat this process for the other animations. See the following table
    for a list of their settings:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为其他动画重复此过程。以下表格列出了它们的设置：
- en: '| **Name** | **Length** | **Frames** | **Looping** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **长度** | **帧数** | **循环** |'
- en: '| `idle` | `0.4` | `7` → `10` | On |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `idle` | `0.4` | `7` → `10` | 开启 |'
- en: '| `run` | `0.5` | `13` →`18` | On |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `run` | `0.5` | `13` →`18` | 开启 |'
- en: '| `hurt` | `0.2` | `5` → `6` | On |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `hurt` | `0.2` | `5` → `6` | 开启 |'
- en: '| `jump_up` | `0.1` | `11` | Off |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `jump_up` | `0.1` | `11` | 关闭 |'
- en: '| `jump_down` | `0.1` | `12` | Off |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `jump_down` | `0.1` | `12` | 关闭 |'
- en: There are also animations in the sprite sheet for crouching and climbing, but
    you can add those later, once the basic movement is completed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵图中也有蹲下和攀爬的动画，但可以在基本移动完成后添加这些动画。
- en: Collision shape
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞形状
- en: As with other bodies, `CharacterBody2D` needs a shape assigned to define its
    collision bounds. Add a `CollisionShape2D` node and create a new `RectangleShape2D`
    inside it. When sizing the shape, you want it to reach the bottom of the image
    (the player’s feet) but be a little bit narrower than the player’s image. In general,
    making the shape a bit smaller than the image will result in a better feel when
    playing, avoiding the experience of hitting something that looks like it wouldn’t
    result in a collision.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他身体一样，`CharacterBody2D` 需要一个形状来定义其碰撞边界。添加一个 `CollisionShape2D` 节点并在其中创建一个新的
    `RectangleShape2D`。在调整形状大小时，你希望它达到图像的底部（玩家的脚），但比玩家的图像略窄。一般来说，使形状比图像略小会在游戏中产生更好的感觉，避免击中看起来不会导致碰撞的东西的经验。
- en: 'You’ll also need to offset the shape a small amount to make it fit. Setting
    the `CollisionShape2D` node’s `(0, -10)` works well. When you’re done, it should
    look approximately like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要稍微偏移形状以使其适合。设置 `CollisionShape2D` 节点的 `(0, -10)` 会很有效。完成时，它应该看起来大约是这样的：
- en: '![Figure 4.8: Player collision shape](img/B19289_04_08.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8：玩家碰撞形状](img/B19289_04_08.jpg)'
- en: 'Figure 4.8: Player collision shape'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：玩家碰撞形状
- en: Multiple shapes
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 多个形状
- en: In some cases, depending on the complexity of your character and its interactions
    with other objects, you may want to add multiple shapes to the same object. You
    might have one shape at the player’s feet to detect ground collisions, another
    on its body to detect damage, and yet another covering the player’s front to detect
    contact with walls.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，根据你的角色复杂性和与其他对象的交互，你可能想向同一对象添加多个形状。你可能在玩家的脚下有一个形状来检测地面碰撞，另一个在其身体上检测伤害，还有一个覆盖玩家前部来检测与墙壁的接触。
- en: Finishing the player scene
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成玩家场景
- en: Add a `Camera2D` node to the `Player` scene. This node will keep the game window
    centered on the player as it moves around the level. You can also use it to zoom
    in on the player since pixel art is relatively small compared to the game window’s
    size. Remember, since you set the filtering option in **Project Settings**, the
    player’s texture will remain pixelated and blocky when zoomed in.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Camera2D` 节点添加到 `Player` 场景中。此节点将在玩家在关卡中移动时保持游戏窗口在玩家周围居中。你也可以用它来放大玩家，因为像素艺术相对于游戏窗口的大小来说相对较小。记住，由于你在
    **项目设置** 中设置了过滤选项，当放大时，玩家的纹理将保持像素化和块状。
- en: To enable the camera, set the `(2.5, 2.5)`. Values smaller than 1 zoom the camera
    out, while larger values zoom it in.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用相机，设置 `(2.5, 2.5)`。小于 1 的值会使相机缩小，而较大的值会使相机放大。
- en: You’ll see a pinkish-purple rectangle surrounding the player. That’s the camera’s
    **screen rectangle** and it shows what the camera will see. You can adjust the
    **Zoom** property to increase or decrease its size to see more or less of the
    world around the player.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个围绕玩家的粉紫色矩形。那是相机的 **屏幕矩形**，它显示了相机将看到的内容。你可以调整 **缩放** 属性来增加或减少其大小，以便看到更多或更少的玩家周围的世界。
- en: Player states
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家状态
- en: The player character has a wide variety of behaviors, such as jumping, running,
    and crouching. Coding such behaviors can become very complex and hard to manage.
    One solution is to use Boolean variables (`is_jumping` or `is_running`, for example),
    but this leads to possibly confusing states (what if `is_crouching` and `is_jumping`
    are both `true`?) and quickly leads to `_spaghetti_ code`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家角色有多种行为，例如跳跃、奔跑和蹲下。编码这些行为可能会变得非常复杂且难以管理。一个解决方案是使用布尔变量（例如 `is_jumping` 或 `is_running`），但这可能导致可能令人困惑的状态（如果
    `is_crouching` 和 `is_jumping` 都为 `true` 会怎样？）并且很快就会导致 `_spaghetti_ 代码`。
- en: A better solution to this problem is to use a state machine to handle the player’s
    current state and control the transition to other states. This concept was introduced
    in [*Chapter 3*](B19289_03.xhtml#_idTextAnchor066), and you’ll expand on it in
    this project.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的更好方法是使用状态机来处理玩家的当前状态并控制到其他状态的转换。这个概念在[*第3章*](B19289_03.xhtml#_idTextAnchor066)中介绍过，您将在本项目中对其进行扩展。
- en: 'Here is a diagram of the player’s states and the transitions between them:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是玩家状态及其之间转换的图示：
- en: '![Figure 4.9: Player state diagram](img/B19289_04_09.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9：玩家状态图](img/B19289_04_09.jpg)'
- en: 'Figure 4.9: Player state diagram'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：玩家状态图
- en: As you can see, state diagrams can become quite complex, even with a relatively
    small number of states.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，状态图可能会变得相当复杂，即使是在相对较少的状态下。
- en: Other states
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 其他状态
- en: Note that while the sprite sheet contains animations for them, the `CROUCH`
    and `CLIMB` states are not included here. This is to keep the number of states
    manageable at the beginning of the project. Later, you’ll have the opportunity
    to add them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然精灵图包含它们的动画，但`CROUCH`和`CLIMB`状态不包括在内。这是为了在项目开始时保持状态数量可管理。稍后，您将有机会添加它们。
- en: Player script
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家脚本
- en: Attach a new script to the `Player` node. Note that the dialog shows a **Template**
    property with Godot’s default **Basic Movement** for this node type. Uncheck the
    **Template** box – you won’t need that example code for this project.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个新的脚本附加到`Player`节点上。注意，对话框显示了一个**模板**属性，这是Godot为此节点类型提供的默认**基本移动**。取消选择**模板**框——您不需要这个示例代码来完成这个项目。
- en: 'Add the following code to start setting up the player’s state machine. As in
    the *Space Rocks* game, you can use an `enum` type to define the allowed states
    for the system. When you want to change the player’s state, you can call `change_state()`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到开始设置玩家状态机。与*太空岩石*游戏一样，您可以使用`enum`类型来定义系统的允许状态。当您想要更改玩家的状态时，您可以调用`change_state()`：
- en: '[PRE1]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For now, the script only changes which animation is playing, but you’ll add
    more state functionality later.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，脚本只更改正在播放的动画，但您将在稍后添加更多状态功能。
- en: Player movement
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家移动
- en: 'The player needs three controls: left, right, and jump. Comparing the current
    state to which keys are pressed will trigger a state change if the transition
    is allowed by the state diagram’s rules. Add the `get_input()` function to process
    the inputs and determine the result. Each `if` condition represents one of the
    transitions in the state diagram:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家需要三个控制键：左、右和跳跃。比较当前状态和按下的键，如果状态图规则允许转换，则会触发状态变化。添加`get_input()`函数来处理输入并确定结果。每个`if`条件代表状态图中的一个转换：
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the jump check is using `is_action_just_pressed()` rather than `is_action_pressed()`.
    While the latter returns `true` so long as the key is held down, the former is
    only `true` in the frame after the key was pressed. This means that the player
    must press the jump key each time they want to jump.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，跳跃检查使用的是`is_action_just_pressed()`而不是`is_action_pressed()`。虽然后者只要按键被按下就会返回`true`，但前者只有在按键被按下的那一帧才是`true`。这意味着玩家每次想要跳跃时都必须按下跳跃键。
- en: 'Call this function from `_physics_process()`, add the pull of gravity to the
    player’s `velocity`, and call the `move_and_slide()` method to move:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从`_physics_process()`函数调用此函数，将重力拉力添加到玩家的`velocity`中，并调用`move_and_slide()`方法来移动：
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Remember, since the `(0, -1)`, any collision below the player’s feet will be
    considered the “floor,” and `is_on_floor()` will be set to `true` by `move_and_slide()`.
    You can use this fact to detect when the jump ends by adding this right after
    `move_and_slide()`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，由于`(0, -1)`，任何在玩家脚下的碰撞都将被视为“地板”，并且`is_on_floor()`将由`move_and_slide()`设置为`true`。您可以使用这个事实来检测跳跃何时结束，在`move_and_slide()`之后添加以下代码：
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The jump will look better if the animation switches from `jump_up` to `jump_down`
    when falling:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果动画在掉落时从`jump_up`切换到`jump_down`，跳跃看起来会更好：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Later, once the level is complete, the player will be passed a spawn location.
    To handle this, add this function to the script:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，一旦关卡完成，玩家将获得一个出生位置。为了处理这个问题，将以下函数添加到脚本中：
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With that, you have finished adding movement, and the correct animation should
    play for each situation. This would be a good point to stop and test the player
    to make sure everything is working. You can’t just run the scene, though, because
    the player will just start falling without any surface to stand on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你已经完成了移动的添加，并且每种情况都应播放正确的动画。这是一个很好的停止点来测试玩家，以确保一切正常工作。但是，你不能只是运行场景，因为玩家会开始无任何立足之地的下落。
- en: Testing the movement
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试移动
- en: 'Create a new scene and add a `Node` object called `Main` (later, this will
    become your main scene). Add an instance of `Player`, then add a `StaticBody2D`
    node with a rectangular collision shape. Stretch the collision shape horizontally
    so that it’s wide enough to walk back and forth on, and place it below the character:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并添加一个名为 `Main` 的 `Node` 对象（稍后，这将成为你的主场景）。添加一个 `Player` 实例，然后添加一个具有矩形碰撞形状的
    `StaticBody2D` 节点。将碰撞形状水平拉伸，使其足够宽，可以来回行走，并将其放置在角色下方：
- en: '![Figure 4.10: Test scene with a platform](img/B19289_04_10.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10：带有平台的测试场景](img/B19289_04_10.jpg)'
- en: 'Figure 4.10: Test scene with a platform'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：带有平台的测试场景
- en: Since it doesn’t have a `Sprite2D` node, the static body will be invisible if
    you run the game. In the menu, choose **Debug** > **Visible Collision Shapes**.
    This is a useful debug setting that will draw the collision shapes while the game
    is running. You can turn it on whenever you need to test or troubleshoot collisions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它没有 `Sprite2D` 节点，静态身体在运行游戏时将是不可见的。在菜单中，选择 **调试** > **可见碰撞形状**。这是一个有用的调试设置，可以在游戏运行时绘制碰撞形状。你可以在需要测试或排除故障时随时打开它。
- en: Press `idle` animation when it hits the static body.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当它撞击静态身体时，按下 `idle` 动画。
- en: Before moving on, make sure that all the movements and animations are working
    correctly. Run and jump in all directions and check that the correct animations
    are playing whenever the state changes. If you find any problems, review the previous
    sections and make sure you didn’t miss a step.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保所有移动和动画都正常工作。在所有方向上跑和跳，并检查状态改变时是否播放了正确的动画。如果你发现任何问题，请回顾前面的部分，并确保你没有错过任何步骤。
- en: Player health
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家健康
- en: Eventually, the player is going to encounter danger, so you should add a damage
    system. The player will start with three hearts and lose one each time they are
    damaged.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，玩家会遇到危险，因此你应该添加一个伤害系统。玩家开始时有三个心形生命值，每次受到伤害就会失去一个。
- en: 'Add the following to the top of the script (just after the `extends` line):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到脚本顶部（在 `extends` 行之后）：
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You’ll emit the `life_changed` signal whenever the value of `life` changes,
    notifying the display to update. `dead` will be emitted when `life` reaches `0`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 `life` 的值发生变化时，你将发出 `life_changed` 信号，通知显示更新。当 `life` 达到 `0` 时，将发出 `dead`
    信号。
- en: Add `life = 3` to the `reset()` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `reset()` 函数中添加 `life = 3`。
- en: 'There are two possible ways for the player to be hurt: running into a spike
    object in the environment or being hit by an enemy. In either event, the following
    function can be called:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家受伤有两种可能的方式：撞到环境中的尖刺物体或被敌人击中。在任何一种情况下，都可以调用以下函数：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code is being nice to the player: if they’re already hurt, they can’t
    get hurt again (at least for a brief time until the `hurt` animation has stopped
    playing). Without this, it’s easy to get stuck in a loop of getting hurt, resulting
    in a quick death.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对玩家很友好：如果他们已经受伤，他们就不能再次受伤（至少在 `hurt` 动画停止播放的短时间内不能）。如果没有这个，很容易陷入受伤的循环，导致快速死亡。
- en: 'There are a few things to do when the state changes to `HURT` in the `change_state()`
    function you created earlier:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在之前创建的 `change_state()` 函数中将状态更改为 `HURT` 时，有一些事情要做：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When they’re hurt, not only do they lose one `life`, but they are also bounced
    up and away from the damaging object. After a short time, the state changes back
    to `IDLE`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当他们受伤时，不仅会失去一个 `生命值`，而且还会被弹起并远离造成伤害的物体。经过一段时间后，状态会变回 `IDLE`。
- en: 'Also, the input should be disabled during the `HURT` state. Add this to the
    beginning of `get_input()`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 `HURT` 状态期间应禁用输入。将以下内容添加到 `get_input()` 的开头：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, the player is ready to take damage once the rest of the game has been set
    up. Next, you will create the objects that the player will collect in the game.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦游戏的其他部分设置完成，玩家就可以开始受到伤害。接下来，你将创建玩家在游戏中可以收集的物体。
- en: Collectible items
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可收集物品
- en: 'Before you start making the level, you need to create some items that the player
    can collect, since those will be part of the level as well. The `assets/sprites`
    folder contains sprite sheets for two types of collectibles: cherries and gems.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始制作关卡之前，你需要创建一些玩家可以收集的物品，因为那些也将是关卡的一部分。`assets/sprites` 文件夹包含两种类型可收集物品的精灵图集：樱桃和宝石。
- en: 'Rather than make a separate scene for each type of item, you can use a single
    scene and swap out the `texture` property in the script. Both objects have the
    same behavior: animating in place and disappearing when collected by the player.
    You can also add a `tween` effect for the collection (see [*Chapter 2*](B19289_02.xhtml#_idTextAnchor030)).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是为每种类型的物品创建一个单独的场景，你可以使用一个场景并在脚本中交换 `texture` 属性。这两个对象具有相同的行为：在原地动画并在被玩家收集时消失。你还可以为收集添加一个
    `tween` 效果（见 [*第2章*](B19289_02.xhtml#_idTextAnchor030)）。
- en: Scene setup
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景设置
- en: Start the new scene with `Area2D` and name it `Item`. Save the scene in a new
    `items` folder.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Area2D` 开始新的场景并将其命名为 `Item`。将场景保存在新的 `items` 文件夹中。
- en: An area is a good choice for these objects because you want to detect when the
    player contacts them, but you don’t need a collision response from them. In the
    Inspector, set `collectibles` (layer 4) and `player` (layer 2). This will ensure
    that only the `Player` node will be able to collect them, while the enemies will
    pass right through.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象是一个好选择，因为你想要检测玩家何时接触它们，但你不需要从它们那里获得碰撞响应。在检查器中设置 `collectibles`（第4层）和 `player`（第2层）。这将确保只有
    `Player` 节点能够收集它们，而敌人将直接穿过。
- en: 'Add three child nodes: `Sprite2D`, `CollisionShape2D`, and `AnimationPlayer`.
    Drag `res://assets/sprites/cherry.png` into the `Sprite2D` node’s `5`. Then, add
    a circle shape to `CollisionShape2D` and size it appropriately:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 添加三个子节点：`Sprite2D`、`CollisionShape2D` 和 `AnimationPlayer`。将 `res://assets/sprites/cherry.png`
    拖入 `Sprite2D` 节点的 `5` 位置。然后，在 `CollisionShape2D` 中添加一个圆形形状并适当调整其大小：
- en: '![Figure 4.11: Item with collision](img/B19289_04_11.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11：具有碰撞的物品](img/B19289_04_11.jpg)'
- en: 'Figure 4.11: Item with collision'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：具有碰撞的物品
- en: Choosing a collision size
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 选择碰撞大小
- en: As a general rule, you should size your collision shapes so that they benefit
    the player. This means that enemy hitboxes should be a little smaller than the
    image, while the hitboxes of beneficial items should be slightly oversized. This
    reduces player frustration and results in a better gameplay experience.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，你应该调整你的碰撞形状的大小，以便它们对玩家有益。这意味着敌人的击中框应该比图像略小，而有益物品的击中框应该略微放大。这减少了玩家的挫败感，并导致更好的游戏体验。
- en: Add a new animation to `AnimationPlayer` (you only need one, so you can name
    it anything you like). Set `1.6` seconds, `0.2` seconds, and **Looping** to **on**.
    Click the **Autoplay on Load** button so that the animation will start automatically.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `AnimationPlayer` 添加一个新的动画（你只需要一个，所以你可以给它起任何名字）。设置 `1.6` 秒、`0.2` 秒，并将 **Looping**
    设置为 **开启**。点击 **加载时自动播放** 按钮，以便动画将自动开始。
- en: 'Set the `Sprite2D` node’s `0` and click the key button to create the track.
    This sprite sheet only contains half the animation, so the animation needs to
    play the frames in the following order:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `Sprite2D` 节点的 `0` 并点击键按钮以创建轨迹。这个精灵图集只包含动画的一半，因此动画需要按以下顺序播放帧：
- en: '*0 -> 1 -> 2 -> 3 -> 4 -> 3 -> 2 -> 1*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*0 -> 1 -> 2 -> 3 -> 4 -> 3 -> 2 -> 1*'
- en: Drag the scrubber to time `0.8` and key `4`. Then, key `1` at time `1.4`. Set
    `res://assets/sprites/coin.png` image into **Texture** and it will work just the
    same since it has the same number of frames. This will make it easy to spawn both
    cherries and gems in your game.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将滑块拖到时间 `0.8` 并键入 `4`。然后，在时间 `1.4` 处键入 `1`。将 `res://assets/sprites/coin.png`
    图像设置为 **Texture**，它将同样工作，因为它有相同数量的帧。这将使你在游戏中生成樱桃和宝石变得容易。
- en: Collectible script
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可收集物品脚本
- en: 'The `Item` script needs to do two things:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item` 脚本需要完成两件事：'
- en: Set the start conditions (which `texture` and `position`)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置起始条件（哪个 `texture` 和 `position`）
- en: Detect when the player overlaps
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测玩家何时重叠
- en: 'For the first part, add the following code to your new item script:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一部分，将以下代码添加到你的新物品脚本中：
- en: '[PRE11]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You’ll emit the `picked_up` signal when the player collects the item. In the
    `textures` dictionary, you will find a list of the item types and their corresponding
    image files. Note that you can quickly paste those paths into the script by dragging
    the file from **FileSystem** and dropping it into the script editor.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家收集物品时，你会发出 `picked_up` 信号。在 `textures` 字典中，你可以找到一个物品类型及其对应图像文件的列表。注意，你可以通过将文件从
    **FileSystem** 拖动并放入脚本编辑器来快速粘贴这些路径。
- en: Next, the `init()` function sets `texture` and `position`. Your level script
    will use this to spawn all the items that you’ve placed in your level map.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`init()`函数设置`texture`和`position`。你的关卡脚本将使用这些信息来生成你在关卡地图中放置的所有物品。
- en: 'Finally, connect the `body_entered` signal of `Item` and add this code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，连接`Item`的`body_entered`信号并添加以下代码：
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This signal will allow the game’s main script to react to the item being picked
    up. It can add to the score, increase the player’s health, or any other effect
    you want the item to apply.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信号将允许游戏的主脚本对拾取物品做出反应。它可以增加分数，提高玩家的健康值，或者实现你希望物品产生的任何其他效果。
- en: You might have noticed that these collectible items are set up very much like
    the coins from *Coin Dash* were. Areas are very useful for any type of item where
    you need to know when it’s been touched. In the next section, you’ll start laying
    out the level scene so that you can place these collectibles.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这些可收集物品的设置与*Coin Dash*中的硬币非常相似。区域对于任何需要知道何时被触摸的物品类型都非常有用。在下一节中，你将开始布置关卡场景，以便放置这些可收集物品。
- en: Designing the level
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计关卡
- en: For most of you, this section will take up the largest chunk of your time. Once
    you start designing a level, you’ll find it’s a lot of fun to lay out all the
    pieces and create challenging jumps, secret paths, and dangerous encounters.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数人来说，这一部分将占用你大部分的时间。一旦你开始设计关卡，你会发现布置所有部件并创建挑战性跳跃、秘密路径和危险遭遇非常有趣。
- en: First, you’ll create a generic `Level` scene containing all the nodes and code
    that is common to all levels. You can then create any number of `Level` scenes
    that inherit from this master level.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将创建一个包含所有节点和代码的通用`Level`场景，这些节点和代码对所有关卡都是通用的。然后你可以创建任意数量的继承自这个主级别的`Level`场景。
- en: Using TileMaps
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`TileMap`
- en: Create a new scene and add a `Node2D` node named `LevelBase`. Save the scene
    in a new folder called `levels`. This is where you’ll save all the levels you
    create, and they will all inherit functionality from this `level_base.tscn` scene.
    They’ll all have the same node hierarchy – only the layout will be different.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景并添加一个名为`LevelBase`的`Node2D`节点。将场景保存在名为`levels`的新文件夹中。这是你将保存所有创建的关卡的地方，它们都将继承自这个`level_base.tscn`场景的功能。它们将具有相同的节点层次结构——只有布局不同。
- en: A tilemap is a common tool for designing game environments using a grid of tiles.
    They allow you to draw a level layout by painting the tiles onto the grid rather
    than placing many individual nodes one at a time. They are also more efficient
    because they batch all the individual tile textures and collision shapes into
    a single game object.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 瓦片地图是使用瓦片网格设计游戏环境的常用工具。它们允许你通过在网格上绘制瓦片来绘制关卡布局，而不是逐个放置许多单独的节点。它们也更有效率，因为它们将所有单个瓦片纹理和碰撞形状批处理到单个游戏对象中。
- en: Add a `TileMap` node; a new **TileMap** panel will appear at the bottom of the
    editor window. Note that it says **The edited TileMap has no** **TileSet resource**.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`TileMap`节点；在编辑器窗口底部将出现一个新的**TileMap**面板。注意，它说**编辑的TileMap没有** **TileSet资源**。
- en: About TileSets
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于`TileSet`
- en: To draw a map using `TileMap`, it must have `TileSet` assigned. This `TileSet`
    contains all the individual tile textures, along with any collision shapes they
    may have.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`TileMap`绘制地图，它必须分配了`TileSet`。这个`TileSet`包含所有单个瓦片纹理，以及它们可能具有的任何碰撞形状。
- en: Depending on how many tiles you may have, it can be time-consuming to create
    `TileSet`, especially for the first time. For that reason, some pre-generated
    tilesets have been included in the `assets` folder. Feel free to use those instead,
    but do read through the following section. It contains useful information to help
    you understand how `TileSet` works. If you’d rather use the provided tilesets,
    skip to the *Using the provided* *TileSets* section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你可能拥有的瓦片数量，创建`TileSet`可能很耗时，尤其是第一次。因此，`assets`文件夹中包含了一些预生成的瓦片集。你可以自由使用这些瓦片集，但请阅读以下部分。它包含有用的信息，帮助你理解`TileSet`的工作原理。如果你更愿意使用提供的瓦片集，请跳转到*使用提供的*
    *TileSets*部分。
- en: Creating a TileSet
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个`TileSet`
- en: In Godot, `TileSet` is a type of `Resource`. Examples of other resources include
    `Texture`, `Animation`, and `RectangleShape2D`. They are not nodes; instead, they
    are containers that hold a certain type of data and are usually saved as `.``tres`
    files.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在Godot中，`TileSet`是一种`Resource`类型。其他资源的例子包括`Texture`、`Animation`和`RectangleShape2D`。它们不是节点；相反，它们是包含特定类型数据的容器，通常保存为`.tres`文件。
- en: 'These are the steps for creating a `TileSet` container:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`TileSet`容器的步骤如下：
- en: Click `TileMap`. You’ll see that you now have a **TileSet** panel available,
    which you can select at the bottom of the editor window. You can click the two
    upward arrows, ![](img/B19289_04_12.png), to make the panel fill the editor screen.
    Click it again to shrink the panel.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`TileMap`。你会看到现在有一个**TileSet**面板可用，你可以在编辑器窗口底部选择它。你可以点击两个向上的箭头，![](img/B19289_04_12.png)，使面板填满编辑器屏幕。再次点击它以缩小面板。
- en: 'The `TileSet` panel is where you can place the textures that you want to slice
    up into tiles. Drag `res://assets/environment/tileset.png` into this box. A popup
    will appear, asking if you’d like to automatically create tiles. Select `16x16`
    pixel tiles in the image:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TileSet`面板是你可以放置想要切割成瓦片的纹理的地方。将`res://assets/environment/tileset.png`拖入此框。将出现一个弹出窗口，询问你是否想自动创建瓦片。在图像中选择`16x16`像素的瓦片：'
- en: '![Figure 4.12: Adding a TileSet](img/B19289_04_13.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图4.12：添加TileSet](img/B19289_04_13.jpg)'
- en: 'Figure 4.12: Adding a TileSet'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：添加TileSet
- en: 'Try selecting the **TileMap** panel at the bottom and then select the grass
    block image in the top left of the tiles. Then, click in the editor window to
    draw some tiles by left-clicking in the editor window. You can right-click on
    a tile to clear it:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试选择底部的**TileMap**面板，然后选择瓦片左上角的草地块图像。然后，在编辑器窗口中点击以通过在编辑器窗口中左键点击来绘制一些瓦片。你可以在瓦片上右键点击以清除它：
- en: '![Figure 4.13: Drawing with TileMaps](img/B19289_04_14.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13：使用TileMaps绘制](img/B19289_04_14.jpg)'
- en: 'Figure 4.13: Drawing with TileMaps'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：使用TileMaps绘制
- en: If all you wanted to do was draw a background, you’d be done. However, you also
    need to add collisions to these tiles so that the player can stand on them.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想绘制背景，那么你就完成了。然而，你还需要将这些瓦片添加碰撞，以便玩家可以站在上面。
- en: 'Open the **TileSet** panel again and, in the Inspector, find the **PhysicsLayers**
    property and click **Add Element**:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开**TileSet**面板，在检查器中找到**PhysicsLayers**属性并点击**添加元素**：
- en: '![Figure 4.14: Adding a physics layer to TileSet](img/B19289_04_15.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图4.14：向TileSet添加物理层](img/B19289_04_15.jpg)'
- en: 'Figure 4.14: Adding a physics layer to TileSet'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：向TileSet添加物理层
- en: Since these tiles will be in the `environment` layer, you don’t need to change
    the layer/mask settings.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些瓦片将位于`环境`层，你不需要更改图层/掩码设置。
- en: 'Click `Physics` `Layer 0`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Physics` `Layer 0`：
- en: '![Figure 4.15: Adding collisions to tiles](img/B19289_04_16.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图4.15：向瓦片添加碰撞](img/B19289_04_16.jpg)'
- en: 'Figure 4.15: Adding collisions to tiles'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：向瓦片添加碰撞
- en: Start clicking on the tiles to add the default square collision shape to them.
    If you want to edit a tile’s collision shape, you can do so – click the tile again
    to apply the changes. If you get stuck with a shape you don’t like, click the
    three dots and choose **Reset to default** **tile shape**.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始点击瓦片以向它们添加默认的方形碰撞形状。如果你想编辑瓦片的碰撞形状，你可以这样做——再次点击瓦片以应用更改。如果你卡在一个你不喜欢的外形上，点击三个点并选择**重置为默认**
    **瓦片形状**。
- en: You can also drag the `props.png` image into the texture list for some decorative
    items to spice up your level.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将`props.png`图像拖入纹理列表，为一些装饰物品增添你的关卡色彩。
- en: Using the provided TileSets
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用提供的TileSets
- en: 'Pre-configured tilesets have been included in the `assets` download for this
    project. There are three to be added to three different `TileMap` nodes:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 预配置的瓦片集已包含在此项目的`assets`下载中。有三个需要添加到三个不同的`TileMap`节点：
- en: '`World` – `tiles_world.tres`: Ground and platform tiles'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`世界` – `tiles_world.tres`：地面和平台瓦片'
- en: '`Items` – `tiles_items.tres`: Markers for spawning collectibles'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Items` – `tiles_items.tres`：生成可收集物品的标记'
- en: '`Danger` – `tiles_spikes.tres`: Items that cause damage on collision'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`危险` – `tiles_spikes.tres`：碰撞时造成伤害的物品'
- en: Create the `Items` and `Danger` tilemaps and add the associated tileset to the
    **Tile** **Set** property.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Items`和`Danger`瓦片地图，并将相关的瓦片集添加到**Tile** **Set**属性。
- en: Add an instance of the `Player` scene and a `Marker2D` node named `SpawnPoint`.
    You can use this node to mark where in your level you want the player to start.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`Player`场景实例和一个名为`SpawnPoint`的`Marker2D`节点。你可以使用此节点来标记玩家在关卡中开始的位置。
- en: 'Attach a script to the `Level` node:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本附加到`Level`节点：
- en: '[PRE13]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Later, you’ll be scanning the `Items` map to spawn collectibles in the designated
    locations. This map layer shouldn’t be seen, so you could set it as hidden in
    the scene. However, this is easy to forget, so `_ready()` ensures that it’s not
    visible during gameplay.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将扫描`Items`地图以在指定位置生成可收集物品。这个地图层不应该被看到，所以你可以将其设置为场景中的隐藏。然而，这很容易忘记，所以`_ready()`确保在游戏过程中它不可见。
- en: Designing the first level
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计第一个关卡
- en: Now, you’re ready to start drawing the level! Click `level_base.tscn`. Name
    the root node `Level01` and save it (in the `levels` folder). Notice that the
    child nodes are colored yellow, indicating that they are `level_base.tscn`. If
    you make changes to that original scene, those changes will also appear in this
    scene.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好开始绘制等级了！点击`level_base.tscn`。将根节点命名为`Level01`并保存（在`levels`文件夹中）。注意，子节点被涂成黄色，表示它们是`level_base.tscn`。如果你对原始场景进行了更改，这些更改也会出现在这个场景中。
- en: Start with the `World` map and be creative. Do you like lots of jumps, or twisty
    tunnels to explore? Long runs or careful upward climbs?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从`世界`地图开始，发挥创意。你喜欢很多跳跃，还是曲折的隧道去探索？长跑还是小心翼翼的向上攀登？
- en: Before going too far with your level design, make sure you experiment with jump
    distance. You can change the player’s `jump_speed`, `run_speed`, and `gravity`
    properties to alter how high and how far they can jump. Set up some different
    gap sizes and run the scene to try them out. Don’t forget to drag the `SpawnPoint`
    node to the place you want the player to start.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入进行等级设计之前，请确保你尝试了跳跃距离。你可以更改玩家的`jump_speed`、`run_speed`和`gravity`属性来改变他们可以跳多高和多远。设置不同大小的间隙并运行场景来尝试它们。别忘了将`SpawnPoint`节点拖到玩家开始的地方。
- en: How you set the player’s movement properties will have a big impact on how your
    level should be laid out. Make sure you’re happy with your settings before spending
    too much time on the full design.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你设置玩家移动属性的方式将对你的等级布局产生重大影响。在花费太多时间在完整设计之前，请确保你对你的设置感到满意。
- en: Once you have the `World` map set up, use the `Items` map to mark the locations
    where you’d like to spawn the cherries and gems. The tiles that mark the spawn
    locations are drawn with a magenta background to make them stand out. Remember,
    they’ll be replaced at runtime and the tiles themselves won’t be seen.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了`世界`地图，使用`物品`地图来标记你想要生成樱桃和宝石的位置。标记生成位置的瓦片以洋红色背景绘制，以便突出显示。记住，它们将在运行时被替换，瓦片本身将不会被看到。
- en: 'Once you have your level laid out, you can limit the horizontal scrolling of
    the player camera to match the size of the map (plus a small buffer on each end).
    Add this code to `level_base.gd`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定了你的等级布局，你可以限制玩家摄像机的水平滚动以匹配地图的大小（并在两端各添加一个小缓冲区）。将以下代码添加到`level_base.gd`文件中：
- en: '[PRE14]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The script also needs to scan the `Items` map and look for the item markers.
    Collecting items will add to the player’s score, so you can add a variable to
    track that as well:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本还需要扫描`物品`地图并查找物品标记。收集物品将增加玩家的分数，因此你可以添加一个变量来跟踪这一点：
- en: '[PRE15]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `spawn_items()` function uses `get_used_cells()` to get a list of which
    cells in `TileMap` are not empty. These cells are in `_map coordinates_`, not
    pixel coordinates, so later, when you spawn the item, you can use `map_to_local()`
    to convert the values.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn_items()`函数使用`get_used_cells()`来获取一个列表，列出`TileMap`中哪些单元格不为空。这些单元格位于`_地图坐标_`，而不是像素坐标，因此，当你生成物品时，你可以使用`map_to_local()`来转换这些值。'
- en: The marker tiles have a `gem` or `cherry`. That’s then used to tell the new
    instance which type of item it should be.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 标记瓦片有一个`宝石`或`樱桃`。这被用来告诉新实例它应该是什么类型的物品。
- en: The `score` variable is there to keep track of how many items the player has
    collected. You could have this trigger completion of the level, give a bonus,
    and so on.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`score`变量用于跟踪玩家收集了多少物品。你可以使用这个触发器来完成等级，提供奖励等等。'
- en: Add `spawn_items()` to `_ready()` and try running the level. You should see
    gems and cherries appear wherever you’ve added them. Also, check that they disappear
    when you collect them.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将`spawn_items()`添加到`_ready()`并尝试运行等级。你应该会看到你在添加的地方出现了宝石和樱桃。同时，检查它们在你收集它们时是否消失。
- en: Adding dangerous objects
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加危险物体
- en: The `Danger` map layer is designed to hold the spike objects that will harm
    the player when touched. Any tile on this `TileMap` will cause damage to the player!
    Try placing a few of them where you can easily test running into them.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`危险`地图层被设计用来存放当被触碰时会伤害玩家的尖刺物体。这个`TileMap`上的任何瓦片都会对玩家造成伤害！尝试将几个它们放置在你容易测试撞到它们的地方。'
- en: In the `Danger` tilemap to a group called `danger` so that you can easily identify
    it when colliding. This will also allow you to make other harmful objects upon
    adding them to the same group.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在`危险`瓦地图中将其添加到名为`danger`的组中，这样你就可以在碰撞时轻松识别它。这还将允许你在将它们添加到同一组时创建其他有害物体。
- en: About slide collisions
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于滑动碰撞
- en: When a `CharacterBody2D` node is moved with `move_and_slide()`, it may collide
    with more than one object in the same frame’s movement. For example, when running
    into a corner, the body may hit the wall and the floor at the same time. You can
    use the `get_slide_collision_count()` function to find out how many collisions
    occurred; then, you can get information about each collision using `get_slide_collision()`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当`CharacterBody2D`节点使用`move_and_slide()`移动时，它可能在同一帧的移动中与多个对象发生碰撞。例如，当撞到角落时，身体可能会同时撞到墙和地板。你可以使用`get_slide_collision_count()`函数来找出发生了多少次碰撞；然后，你可以使用`get_slide_collision()`获取每次碰撞的信息。
- en: 'In the case of `Player`, you want to detect when a collision occurs against
    the `Danger` tilemap. You can do this just after using `move_and_slide()` in `player.gd`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Player`，你想要检测当与`Danger`瓦片地图发生碰撞时。你可以在`player.gd`中使用`move_and_slide()`之后这样做：
- en: '[PRE16]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that before checking for a collision with the `danger` group, you can first
    check if the player is already in the `HURT` state. If they are, you can skip
    checking to see if they are colliding with a dangerous object.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在检查与`danger`组发生碰撞之前，你可以首先检查玩家是否已经处于`HURT`状态。如果是，你可以跳过检查他们是否与危险物体发生碰撞。
- en: The `for` loop iterates through the number of collisions given by `get_slide_collision_count()`
    to check each one for an object in the danger group.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环遍历由`get_slide_collision_count()`给出的碰撞次数，以检查每个碰撞中的危险组对象。'
- en: Play your scene and try running into one of the spikes. You should see the player
    change to the `HURT` state (playing the animation) for a brief time before returning
    to `IDLE`. After three hits, the player will enter the `DEAD` state, which currently
    only hides the player.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 播放你的场景，并尝试撞到其中一个尖刺。你应该看到玩家在短暂地变为`HURT`状态（播放动画）后返回到`IDLE`状态。经过三次打击后，玩家将进入`DEAD`状态，目前这只会隐藏玩家。
- en: Scrolling background
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动背景
- en: 'There are two background images in the `res://assets/environment/` folder:
    `back.png` and `middle.png`, for the far and near background, respectively. By
    placing these images behind the tilemap and scrolling them at different speeds
    relative to the camera, you can create an attractive illusion of depth in the
    background:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在`res://assets/environment/`文件夹中有两个背景图像：`back.png`和`middle.png`，分别用于远背景和近背景。通过将这些图像放置在瓦片地图后面，并以相对于相机的不同速度滚动，你可以在背景中创建一个吸引人的深度错觉：
- en: Add a `ParallaxBackground` node to the `LevelBase` scene (so that it will be
    present on all inherited levels). This node works with the camera to create a
    scrolling effect. Drag this node to the top of the scene tree so that it will
    be drawn behind the rest of the nodes. Next, add a `ParallaxLayer` node as its
    child. `ParallaxBackground` can have any number of `ParallaxLayer` children, allowing
    you to make multiple independently scrolling layers.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ParallaxBackground`节点添加到`LevelBase`场景中（这样它就会出现在所有继承的级别中）。这个节点与相机一起创建滚动效果。将此节点拖到场景树的最顶部，以便它会在其他节点之后被绘制。接下来，添加一个`ParallaxLayer`节点作为其子节点。`ParallaxBackground`可以有任意数量的`ParallaxLayer`子节点，允许你创建多个独立滚动的层。
- en: Add a `Sprite2D` node as a child of `ParallaxLayer` and drag the `back.png`
    image into its `Sprite2D` node’s `(``1.5, 1.5)`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Sprite2D`节点添加为`ParallaxLayer`的子节点，并将`back.png`图像拖放到其`Sprite2D`节点的`(``1.5,
    1.5)`。
- en: On `ParallaxLayer`, set `(0.2, 1)` (you’ll need to click the `x` and `y` values
    to be set separately). This setting controls how fast the background scrolls concerning
    the camera movement. By setting it to a number less than `1`, the image will only
    move a small amount as the player moves left and right.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ParallaxLayer`上设置`(0.2, 1)`（你需要分别点击`x`和`y`值来单独设置）。这个设置控制背景相对于相机移动的速度。通过将其设置为小于`1`的数字，当玩家左右移动时，图像只会移动一小段距离。
- en: You need to be sure the image repeats if your level is wider than the size of
    the image, so set `(576, 0)`. This is exactly the width of the image (`384` times
    `1.5`), so the image will be repeated when it has moved by that number of pixels.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你水平方向上的关卡宽度大于图像的大小，你需要确保图像重复，所以设置`(576, 0)`。这正好是图像的宽度（`384`乘以`1.5`），所以当图像移动了这么多像素时，它将会重复。
- en: Note that this background image is designed for levels that are wide rather
    than tall. If you jump too high, you’ll see the top of the image. You can fix
    this by setting the top limit of the camera. If you haven’t moved the background’s
    position, its top-left corner will still be at (`0, 0)`, so you can set the `0`.
    If you have moved `ParallaxLayer` or its `Sprite2D` node, you can find the correct
    value to use by looking at the `y` value of the node’s **Position**.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，这个背景图像是为宽度较宽而不是高度较高的关卡设计的。如果你跳得太高，你会看到图像的顶部。你可以通过设置摄像机的顶部限制来修复这个问题。如果你没有移动背景的位置，其左上角仍然在
    (`0, 0)`，所以你可以设置 `0`。如果你已经移动了 `ParallaxLayer` 或其 `Sprite2D` 节点，你可以通过查看节点 `Position`
    的 `y` 值来找到正确的值。
- en: Try playing the level and running left and right. You should see the background
    moving by a small amount compared to how far you run.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试播放关卡并左右移动。你应该会看到背景相对于你跑的距离移动了一小部分。
- en: Add another `ParallaxLayer` (also as a child of `ParallaxBackground`) and give
    it a `Sprite2D` child. This time, use the `middle.png` image. This image is much
    narrower than the sky image, so you’ll need to adjust some settings to make it
    repeat properly. This is because `ParallaxBackground` needs to have images that
    are at least as big as the viewport area.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个 `ParallaxLayer`（也作为 `ParallaxBackground` 的子节点），并给它一个 `Sprite2D` 子节点。这次，使用
    `middle.png` 图像。这个图像比天空图像窄得多，所以你需要调整一些设置来使其正确重复。这是因为 `ParallaxBackground` 需要图像至少与视口区域一样大。
- en: Find the `Sprite2D` node’s `Mirror`. Then, expand the `(880, 368)`. `880` is
    the width of the image (`176`) multiplied by `5`, so you will now see five repetitions
    of the image, each one a mirror of the last.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 `Sprite2D` 节点的 `Mirror`。然后，扩展 `(880, 368)`。`880` 是图像宽度 (`176`) 乘以 `5`，所以你现在将看到五个图像的重复，每个都是上一个图像的镜像。
- en: 'Move the `Sprite2D` node so that the image overlaps the bottom half of the
    ocean/sky image:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Sprite2D` 节点移动，使图像与海洋/天空图像的下半部分重叠：
- en: '![Figure 4.16: Parallax background setup](img/B19289_04_17.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16：平行背景设置](img/B19289_04_17.jpg)'
- en: 'Figure 4.16: Parallax background setup'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16：平行背景设置
- en: Set the second `ParallaxLayer` node’s `(0.6, 1)` and `880, 0)`. Using a higher
    scale factor means that this layer will scroll a little bit faster than the cloud
    layer behind it. Play the scene to test the effect.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置第二个 `ParallaxLayer` 节点的 `(0.6, 1)` 和 `880, 0)`。使用更高的缩放因子意味着这个层将比它后面的云层滚动得更快。播放场景以测试效果。
- en: 'Your `Level` scene’s node tree should now look like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `Level` 场景的节点树现在应该看起来像这样：
- en: '![Figure 4.17: Level scene nodes](img/B19289_04_18.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.17：关卡场景节点](img/B19289_04_18.jpg)'
- en: 'Figure 4.17: Level scene nodes'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17：关卡场景节点
- en: 'Your level scene now has all the pieces you need to create your level design.
    Do you want your player to have to make very precise jumps (a parkour level),
    run through a series of winding passages trying to find all the items (a maze
    level), or some combination of the two? This is your chance to try out some creative
    ideas, but make sure you leave some room for the next object you’ll make: enemies.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你的关卡场景现在拥有了创建关卡设计所需的所有部件。你希望玩家必须进行非常精确的跳跃（跑酷关卡），穿过一系列蜿蜒的通道试图找到所有物品（迷宫关卡），或者两者的组合？这是你尝试一些创意想法的机会，但请确保为下一个要创建的对象（敌人）留出一些空间。
- en: Adding enemies
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加敌人
- en: There are many different behaviors you could add for an enemy. For this game,
    the enemy will walk along a platform in a straight line and change direction when
    hitting an obstacle.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为敌人添加许多不同的行为。对于这个游戏，敌人将沿着一个平台直线行走，并在碰到障碍物时改变方向。
- en: Scene setup
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景设置
- en: 'As before, you’ll need to create a new scene to represent the enemy:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你需要创建一个新的场景来表示敌人：
- en: 'Start with a `CharacterBody2D` node named `Enemy` and give it three children:
    `Sprite2D`, `CollisionShape2D`, and `AnimationPlayer`.'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个名为 `Enemy` 的 `CharacterBody2D` 节点开始，并给它三个子节点：`Sprite2D`、`CollisionShape2D`
    和 `AnimationPlayer`。
- en: Save the scene in a folder called `enemies`. If you decide to add more enemy
    types to the game, you can save them all here.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `enemies` 的文件夹中保存场景。如果你决定为游戏添加更多敌人类型，你都可以在这里保存。
- en: Set the body’s collision **Layer** to **enemies** and its **Mask** to **environment**,
    **player**, and **enemies**. As with the player, this determines which types of
    objects the enemy will collide with.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将身体的碰撞 **层** 设置为 **敌人**，其 **遮罩** 设置为 **环境**、**玩家** 和 **敌人**。与玩家一样，这决定了敌人会与哪些类型的对象发生碰撞。
- en: It’s also useful to group enemies together, so click the `enemies`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将敌人分组在一起也很有用，所以点击 `enemies`。
- en: Add `res://assets/sprites/opossum.png` to `6`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `res://assets/sprites/opossum.png` 添加到 `6`。
- en: 'Add a rectangular collision shape that covers most (but not all) of the image,
    making sure that the bottom of the collision shape is aligned with the bottom
    of the opossum’s feet:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个矩形碰撞形状，覆盖图像的大部分（但不是全部），确保碰撞形状的底部与负鼠的脚底对齐：
- en: '![Figure 4.18: Enemy collision shape](img/B19289_04_19.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图4.18：敌人碰撞形状](img/B19289_04_19.jpg)'
- en: 'Figure 4.18: Enemy collision shape'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：敌人碰撞形状
- en: Add a new animation to `AnimationPlayer` called `walk`. Set `0.6` seconds and
    turn **Looping** and **Autoplay on** **Load** on.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`AnimationPlayer`添加一个新的动画，命名为`walk`。设置为`0.6`秒，并开启**循环**和**加载时自动播放**。
- en: 'The `walk` animation needs to have two tracks: one that sets the `Sprite2D`
    node and one that changes its `0` at time zero, and `5` at time `0.5`. Don’t forget
    to change **Update Mode** to **Continuous**.'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`walk`动画需要有两个轨道：一个设置`Sprite2D`节点，另一个在时间零时将其`0`设置为`5`。别忘了将**更新模式**改为**连续**。'
- en: 'When finished, your animation should look like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你的动画应该看起来像这样：
- en: '![Figure 4.19: Enemy animations](img/B19289_04_20.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图4.19：敌人动画](img/B19289_04_20.jpg)'
- en: 'Figure 4.19: Enemy animations'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19：敌人动画
- en: Scripting the enemy
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敌人脚本编写
- en: 'By now, moving a `CharacterBody2D` node be familiar to you. Look at this script
    and try to understand what it’s doing before reading the explanation provided
    after:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，移动`CharacterBody2D`节点应该已经熟悉了。看看这个脚本，在阅读解释之前尝试理解它在做什么：
- en: '[PRE17]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this script, the `facing` variable keeps track of the movement in the `x`
    direction, either `1` or `-1`. As with the player, after moving, you must check
    the slide collisions. If the colliding object is the player, you must call its
    `hurt()` function.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，`facing`变量跟踪`x`方向上的移动，要么是`1`要么是`-1`。与玩家一样，移动后你必须检查滑动碰撞。如果碰撞的对象是玩家，你必须调用它的`hurt()`函数。
- en: Next, you must check whether the colliding body’s `x` component that isn’t `0`.
    This means it points to the left or right, which means it is a wall or other obstacle.
    The direction of the normal is then used to set the new facing. Giving the body
    a small upward velocity will give the enemy a small bounce effect when turning
    around, which will look more appealing.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你必须检查碰撞体的`x`分量是否不为`0`。这意味着它指向左边或右边，这意味着它是一堵墙或其他障碍物。然后使用法线方向设置新的朝向。给身体一个小的向上速度，当敌人转身时会有一个小弹跳效果，这会使它看起来更吸引人。
- en: Lastly, if for some reason the enemy falls off a platform, you don’t want the
    game to have to track it falling forever, so you must delete any enemy whose `y`
    coordinate becomes too large.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果由于某种原因敌人从平台上掉下来，你不想让游戏必须跟踪它永远掉落，所以你必须删除任何`y`坐标变得太大的敌人。
- en: Add an instance of `Enemy` to your level scene. Make sure it has some obstacles
    on either side and play the scene. Check that the enemy walks back and forth between
    the obstacles. Try putting the player in its path and verify that the player’s
    `hurt()` function is called.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Enemy`实例添加到你的关卡场景中。确保它两侧有一些障碍物，并播放场景。检查敌人是否在障碍物之间来回走动。尝试将玩家放在它的路径上，并验证玩家的`hurt()`函数是否被调用。
- en: You may notice that if you jump on top of the enemy, nothing happens. We will
    handle that part next.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，如果你跳到敌人身上，什么也不会发生。我们将在下一部分处理这个问题。
- en: Damaging the enemy
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伤害敌人
- en: It’s not fair if the player can’t hit back, so in the tradition of Mario, jumping
    on top of the enemy will defeat it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家不能反击，那就太不公平了，所以按照马里奥的传统，跳到敌人上方可以击败它。
- en: Start by adding a new animation to the enemy’s `AnimationPlayer` node called
    `death`. Set `0.3` and `0.05`. Don’t turn on looping for this animation.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，向敌人的`AnimationPlayer`节点添加一个新的动画，命名为`death`。设置为`0.3`和`0.05`。不要为这个动画开启循环。
- en: The `death` animation will also set both `res://assets/sprites/enemy_death.png`
    image into the sprite’s `0` and `5` values of **Frame** at the start and end of
    the animation. Remember to set **Update Mode** to **Continuous**.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`死亡`动画也会在动画的开始和结束时将`res://assets/sprites/enemy_death.png`图像设置为精灵的`Frame`的`0`和`5`值。请记住将**更新模式**设置为**连续**。'
- en: 'Add the following code to `enemy.gd` so that you have a way to trigger the
    death animation on the enemy:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`enemy.gd`中，以便你有触发敌人死亡动画的方法：
- en: '[PRE18]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When the player hits the enemy under the right conditions, it will call `take_damage()`,
    which plays the `death` animation, disables collision, and halts movement.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家在正确条件下击中敌人时，它会调用`take_damage()`函数，播放`死亡`动画，禁用碰撞，并停止移动。
- en: 'When the death animation finishes playing, it’s OK to remove the enemy, so
    connect the `animation_finished` signal of `AnimationPlayer`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当死亡动画播放完毕后，可以移除敌人，因此连接 `AnimationPlayer` 的 `animation_finished` 信号：
- en: '![Figure 4.20: AnimationPlayer’s signals](img/B19289_04_21.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.20：AnimationPlayer 的信号](img/B19289_04_21.jpg)'
- en: 'Figure 4.20: AnimationPlayer’s signals'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20：AnimationPlayer 的信号
- en: 'This signal is called every time any animation finishes, so you need to check
    if it’s the correct one:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此信号在每次任何动画播放完毕时都会被调用，因此你需要检查它是否是正确的：
- en: '[PRE19]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To complete this process, go to the `player.gd` script and add the following
    code to the section of `_physics_process()` where you check the collisions. This
    code will check if the player hit an enemy from above:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此过程，请转到 `player.gd` 脚本，并在检查碰撞的 `_physics_process()` 部分添加以下代码。此代码将检查玩家是否从上方击中敌人：
- en: '[PRE20]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code compares the `y` position of the player’s feet to the enemy’s `y`
    position to see if the player is above the enemy. If they are, the enemy should
    be hurt; otherwise, the player should be.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码比较玩家脚跟的 `y` 位置和敌人的 `y` 位置，以查看玩家是否在敌人上方。如果是，敌人应该受伤；否则，玩家应该受伤。
- en: Run the level again and try jumping on the enemy to check that everything is
    working as expected.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行关卡并尝试跳到敌人身上以检查一切是否按预期工作。
- en: Player script
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家脚本
- en: 'You’ve made several additions to the player’s script. Here’s what the full
    script should look like now:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经对玩家的脚本做了几个添加。现在完整的脚本应该看起来像这样：
- en: '[PRE21]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you’re having any trouble with the player code, try to think about what part
    could be the problem. Is it the movement? The hit detection when running into
    an enemy? If you can narrow down the problem, it’ll help you determine which part
    of the script you should be focusing on.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在玩家代码方面遇到任何问题，试着想想可能出问题的部分。是移动？遇到敌人时的碰撞检测？如果你能缩小问题范围，这将帮助你确定应该关注脚本的哪个部分。
- en: Make sure you’re satisfied with how the player is behaving before moving on
    to the next section.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续到下一节之前，确保你对玩家的行为满意。
- en: Game UI
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏用户界面
- en: As in the previous projects you’ve worked on, you’ll need a HUD to display information
    during gameplay. Collecting items will increase the player’s score, so that number
    should be displayed, as well as the player’s remaining life value, which will
    be shown as a series of hearts.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在之前的项目中所做的那样，你需要一个 HUD 来在游戏过程中显示信息。收集物品会增加玩家的分数，因此应该显示这个数字，以及玩家的剩余生命值，这将以一系列心形图案显示。
- en: Scene setup
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景设置
- en: Create a new scene with a `MarginContainer` root node named `HUD` and save it
    in a new `ui` folder. Set `50` and the top/bottom margins to `20`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，根节点为 `MarginContainer` 并命名为 `HUD`，将其保存在一个新的 `ui` 文件夹中。设置左右边距为 `50`，上下边距为
    `20`。
- en: Add an `HBoxContainer` node to keep things aligned and give it two children,
    `Label` and `HBoxContainer`, named `Score` and `LifeCounter`, respectively.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `HBoxContainer` 节点以保持对齐并给它两个子节点，分别命名为 `Label` 和 `HBoxContainer`，分别是 `Score`
    和 `LifeCounter`。
- en: On the `Score` label, set the `100` and in the Inspector, under `res://assets/Kenney
    Thick.ttf` into the `48`. Under `16` and `100` displayed in white with a black
    outline.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Score` 标签上设置 `100`，并在检查器中，在 `res://assets/Kenney Thick.ttf` 中将其设置为 `48`。在
    `16` 和 `100` 显示为白色，带有黑色轮廓。
- en: 'For `LifeCounter`, add a `TextureRect` child and name it `L1`. Drag `res://assets/heart.png`
    into its `L1` and duplicate (*Ctrl* + *D*) it four times so that you have a row
    of five hearts:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `LifeCounter`，添加一个 `TextureRect` 子节点并命名为 `L1`。将 `res://assets/heart.png`
    拖入其 `L1` 并复制 (*Ctrl* + *D*) 四次，以便你有一排五个心形图案：
- en: '![Figure 4.21: HUD node setup](img/B19289_04_22.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.21：HUD 节点设置](img/B19289_04_22.jpg)'
- en: 'Figure 4.21: HUD node setup'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.21：HUD 节点设置
- en: 'When you’re finished, your HUD should look like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，你的 HUD 应该看起来像这样：
- en: '![Figure 4.22: HUD preview](img/B19289_04_23.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.22：HUD 预览](img/B19289_04_23.jpg)'
- en: 'Figure 4.22: HUD preview'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22：HUD 预览
- en: The next step will be to add a script so that the HUD can update during the
    game.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是添加一个脚本，以便在游戏过程中更新 HUD。
- en: Scripting the HUD
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 HUD 脚本
- en: 'This script needs two functions that can be called to update the two values
    being displayed:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本需要两个可以调用的函数来更新显示的两个值：
- en: '[PRE22]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that, in `update_life()`, you calculate how many hearts to display by setting
    `visible` to `false` if the number of that heart is less than the life amount.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 `update_life()` 中，你通过将心形图案的数量设置为 `false` 来计算显示多少心形图案，如果该心形图案的数量小于生命值。
- en: Attaching the HUD
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接 HUD
- en: Open `level_base.tscn` (the base level scene, not your `Level01` scene) and
    add `CanvasLayer`. Add an instance of `HUD` as a child of this `Canvaslayer`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`level_base.tscn`（基础场景，不是你的`Level01`场景）并添加`CanvasLayer`。将`HUD`实例作为此`Canvaslayer`的子节点添加。
- en: 'Select the level’s `Player` instance and connect its `life_changed` signal
    to the HUD’s `update_life()` method:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`Player`实例并连接其`life_changed`信号到HUD的`update_life()`方法：
- en: '![Figure 4.23: Connecting a signal](img/B19289_04_24.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图4.23：连接信号](img/B19289_04_24.jpg)'
- en: 'Figure 4.23: Connecting a signal'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23：连接信号
- en: Do the same with the `score_changed` signal of the `Level` node, connecting
    it to the HUD’s `update_score()` method.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以相同的方式处理`Level`节点的`score_changed`信号，将其连接到HUD的`update_score()`方法。
- en: 'Note that if you don’t want to use the scene tree to connect the signals, or
    if you find the signal connection window confusing or difficult to use, you can
    accomplish the same thing in your script by adding these lines to the `_ready()`
    function of `level.gd`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你不想使用场景树来连接信号，或者如果你觉得信号连接窗口令人困惑或难以使用，你可以在`level.gd`的`_ready()`函数中添加这些行来完成相同的事情：
- en: '[PRE23]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Play the game and verify that you can see the HUD and that it updates correctly.
    Make sure you collect some items and let the enemy hit you. Is your score increasing?
    When you’re hit, do you lose one heart? Once you’ve checked this, you can continue
    to the next section and make the title screen.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏并验证你能否看到HUD并且它是否正确更新。确保你收集一些物品并让敌人攻击你。你的分数是否在增加？当你被击中时，你是否失去一颗心？一旦你检查了这些，你就可以继续到下一节并制作标题屏幕。
- en: Title screen
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标题屏幕
- en: The title screen is the first thing the player will see, and the game will return
    to this screen when the player dies and the game ends.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 标题屏幕是玩家首先看到的内容，当玩家死亡和游戏结束时，游戏将返回到这个屏幕。
- en: Scene setup
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景设置
- en: Start with a `Control` node and set `TextureRect` node using the `back.png`
    image. Set **Layout** to **Full Rect** and **Stretch Mode** to **Keep** **Aspect
    Covered**.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个`Control`节点开始，并使用`back.png`图像设置`TextureRect`节点。将**布局**设置为**全矩形**，将**拉伸模式**设置为**保持**
    **纵横比**。
- en: Add another `TextureRect`, this time using `middle.png` and setting **Stretch
    Mode** to **Tile**. Drag the width of the rectangle until it’s wider than the
    screen and arrange it so that it covers the bottom half.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 添加另一个`TextureRect`，这次使用`middle.png`并将**拉伸模式**设置为**平铺**。拖动矩形的宽度直到它比屏幕宽，并调整它以覆盖下半部分。
- en: Add two `Label` nodes named `Title` and `Message` and set their `Jungle Jump`
    and `Press Space to Play`, respectively. Add the font to each one as you’ve done
    before, setting the title to size `72` and the message to size `48`. Set the title’s
    layout to **Centered** and the message’s layout to **Center Bottom**.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 添加两个名为`Title`和`Message`的`Label`节点，分别设置它们的`Jungle Jump`和`Press Space to Play`。像之前一样为每个添加字体，将标题的大小设置为`72`，将消息的大小设置为`48`。将标题的布局设置为**居中**，将消息的布局设置为**居中底部**。
- en: 'When you’re finished, the scene should look like this:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，场景应该看起来像这样：
- en: '![Figure 4.24: Title screen](img/B19289_04_25.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图4.24：标题屏幕](img/B19289_04_25.jpg)'
- en: 'Figure 4.24: Title screen'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24：标题屏幕
- en: To make the title screen more interesting, add an `AnimationPlayer` node to
    it. Create a new animation named `intro` and set it to autoplay. In this animation,
    you can animate the elements of the screen to make them move, appear, fade in,
    or any other effect you like.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要使标题屏幕更有趣，向其中添加一个`AnimationPlayer`节点。创建一个名为`intro`的新动画并将其设置为自动播放。在这个动画中，你可以动画化屏幕的元素，使它们移动、出现、淡入或任何你喜欢的效果。
- en: For example, keyframe the current `Title` at time `0.5`. Then, at time `0`,
    drag `Title` off the top of the screen and add another keyframe. Now, the title
    will drop onto the screen when you play the scene.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在时间`0.5`处为当前的`Title`设置关键帧。然后，在时间`0`处将`Title`拖离屏幕顶部并添加另一个关键帧。现在，当你播放场景时，标题将掉落到屏幕上。
- en: 'Feel free to add tracks that animate the other nodes’ properties. For example,
    here is an animation that drops the title down, fades in the two textures, and
    then makes the message appear:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 随意添加可以动画化其他节点属性的轨道。例如，这里有一个动画，将标题向下移动，淡入两个纹理，然后使消息出现：
- en: '![Figure 4.25: Title screen animations](img/B19289_04_26.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图4.25：标题屏幕动画](img/B19289_04_26.jpg)'
- en: 'Figure 4.25: Title screen animations'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.25：标题屏幕动画
- en: This title screen has been kept simple, but you should feel free to add to it
    if you’d like. You could show an example of some platforms, add an animation of
    the character running across the screen, or some other game art. But what happens
    when the player hits “start”? For this, you need to load the first level in the
    main scene.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标题屏幕被保持得很简单，但如果你愿意，可以自由地添加内容。你可以展示一些平台示例，添加一个角色在屏幕上奔跑的动画，或者一些其他游戏艺术作品。但是当玩家点击“开始”时会发生什么？为此，你需要加载主场景中的第一个关卡。
- en: Setting up the main scene
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置主场景
- en: You’ve made some level scenes, but eventually, you’re going to want to make
    more than one. How does the game know which one to load? Your `Main` scene is
    going to take care of that.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一些关卡场景，但最终你将想要创建更多。游戏如何知道加载哪一个？你的`Main`场景将负责处理这个问题。
- en: Delete any extra nodes you added to `main.tscn` when you were testing the player’s
    movement. This scene will now be responsible for loading the current level. Before
    it can do that, however, you need a way to keep track of the current level. You
    can’t keep track of that variable in the level scene because that will be replaced
    with a newly loaded level when it ends. To keep track of data that needs to be
    carried from scene to scene, you can use an **autoload**.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试玩家移动时，删除你添加到`main.tscn`中的任何额外节点。现在这个场景将负责加载当前关卡。然而，在它能够这样做之前，你需要一种方法来跟踪当前关卡。你无法在关卡场景中跟踪这个变量，因为当它结束时，它将被新加载的关卡所替换。为了跟踪需要从场景到场景携带的数据，你可以使用**自动加载**。
- en: About autoloads
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 关于自动加载
- en: In Godot, you can configure a script or scene as an autoload. This means that
    the engine will automatically load it at all times. Even if you change the current
    scene in `SceneTree`, the autoloaded node will remain. You can also refer to that
    autoloaded scene by name from any other node in your game.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在Godot中，你可以配置一个脚本或场景作为自动加载。这意味着引擎将始终自动加载它。即使你更改了`SceneTree`中的当前场景，自动加载的节点也将保持。你还可以从游戏中的任何其他节点通过名称引用该自动加载的场景。
- en: 'In the `game_state.gd` and add the following code:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在`game_state.gd`中添加以下代码：
- en: '[PRE24]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You should set `num_levels` to the number of levels you’ve created in the `levels`
    folder. Make sure you name them consistently as `level_01.tscn`, `level_02.tscn`,
    and so on so that they can be found easily.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将`num_levels`设置为你在`levels`文件夹中创建的关卡数量。确保它们被一致地命名为`level_01.tscn`、`level_02.tscn`等等，这样它们就可以很容易地被找到。
- en: To add this script as an autoload, open `game_state.gd` and then click the **Add**
    button.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此脚本作为自动加载添加，打开`game_state.gd`然后点击**添加**按钮。
- en: 'Next, add this script to your `Main` scene:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将此脚本添加到你的`Main`场景：
- en: '[PRE25]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, whenever the `Main` scene is loaded, it will include the level scene that
    corresponds to the current level.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次加载`Main`场景时，它将包括与当前关卡相对应的关卡场景。
- en: 'The title screen needs to transition to the game scene, so attach this script
    to the `Title` node:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 标题屏幕需要过渡到游戏场景，所以将此脚本附加到`Title`节点：
- en: '[PRE26]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, you can call the `restart()` function when the player dies by adding
    it to `level.gd`. In the `Level` scene, connect the `Player` instance’s `died`
    signal:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当玩家死亡时，通过将其添加到`level.gd`中调用`restart()`函数。在`Level`场景中，连接`Player`实例的`died`信号：
- en: '[PRE27]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should now be able to play through the game fully. Make sure `title.tscn`
    is set as the game’s main scene (that is, the one that runs first). If you’ve
    previously set a different scene to be the “main” scene, you can change this in
    **Projects Settings** under **Application/Run**:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够完整地玩过游戏。确保`title.tscn`被设置为游戏的主场景（即首先运行的场景）。如果你之前将不同的场景设置为“主”场景，你可以在**项目设置**下的**应用程序/运行**中更改此设置：
- en: '![Figure 4.26: Choosing a main scene](img/B19289_04_27.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![图4.26：选择主场景](img/B19289_04_27.jpg)'
- en: 'Figure 4.26: Choosing a main scene'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.26：选择主场景
- en: Transitioning between levels
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在关卡之间过渡
- en: Your levels now need a way to transition from one to the next. In the `res://assets/environment/props.png`
    sprite sheet, there is an image of a door that you can use for your level’s exit.
    Finding and walking into the door will take the player to the next level.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 你的关卡现在需要一种从一关过渡到下一关的方法。在`res://assets/environment/props.png`精灵图中，有一个你可以用于关卡出口的门图像。找到并走进门将玩家带到下一关。
- en: Door scene
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 门场景
- en: Make a new scene with an `Area2D` node named `Door` and save it in the `items`
    folder. Add a `Sprite2D` node and use the `props.png` image as `-8`. This will
    ensure that when the door is placed at the tile location, it will be positioned
    correctly.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并命名为`Door`的`Area2D`节点，并将其保存在`items`文件夹中。添加一个`Sprite2D`节点，并使用`props.png`图像作为`-8`。这将确保当门放置在图块位置时，它将被正确定位。
- en: Add a `CollisionShape2D` node and give it a rectangular shape that covers the
    door. Put the door on the `items` layer and set its mask so that it only scans
    the `player` layer.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`CollisionShape2D`节点，并给它一个覆盖门的矩形形状。将门放在`items`层上，并设置其遮罩，使其只扫描`player`层。
- en: This scene doesn’t need a script because you’re just going to use its `body_entered`
    signal in the level script.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景不需要脚本，因为你只是要在关卡脚本中使用它的`body_entered`信号。
- en: To place the door in the level, you can use the door object from the `tiles_items`
    tileset, which you are using in your `Items` tilemap to place the cherries and
    gems. Place a door in your level and open `level.gd`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 要在关卡中放置门，你可以使用`tiles_items`图块集中的门对象，你正在使用它来放置樱桃和宝石的`Items`图块。在你的关卡中放置一个门并打开`level.gd`。
- en: 'At the top of `level.gd`, define the door scene:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在`level.gd`顶部定义门场景：
- en: '[PRE28]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, update `spawn_items()` so that it also instantiates doors:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新`spawn_items()`以便它也能实例化门：
- en: '[PRE29]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the function that will be called when the player touches the door:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 添加当玩家触摸门时将被调用的函数：
- en: '[PRE30]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Play the game and try walking into the door. If you’ve set `num_levels` in `game_state.gd`
    to a number greater than 1, the game will attempt to load `level_02.tscn` when
    you touch the door.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏并尝试走进门。如果你在`game_state.gd`中将`num_levels`设置为大于1的数字，当你触摸门时，游戏将尝试加载`level_02.tscn`。
- en: Screen settings
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 屏幕设置
- en: Recall that at the beginning of this chapter, you set `canvas_items` and `expand`,
    respectively. Run the game, and then try resizing the game window. Notice that
    if you make the window wider, you can see more of the game world to the player’s
    left/right. This is what the `expand` value is doing.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在本章开始时，你分别设置了`canvas_items`和`expand`。运行游戏，然后尝试调整游戏窗口的大小。注意，如果你使窗口变宽，玩家可以看到更多游戏世界在左侧/右侧。这就是`expand`值的作用。
- en: If you want to prevent this, you can set it to `keep` instead, which will always
    show the same amount of the game world as shown by the camera. However, it also
    means that if you make your window a different shape than the game, you’ll get
    black bars to fill in the extra space.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要防止这种情况发生，你可以将其设置为`keep`，这样就会始终显示与摄像机显示相同数量的游戏世界。然而，这也意味着如果你将窗口形状调整为与游戏不同，你将得到黑色条带来填充额外的空间。
- en: Alternatively, setting `ignore` will not display the black bars, but the game
    content will be stretched to fill the space, distorting the image.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，设置`ignore`将不会显示黑色条带，但游戏内容将被拉伸以填充空间，从而扭曲图像。
- en: Take some time to experiment with the various settings and decide which one
    you prefer.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 抽出一些时间来尝试不同的设置，并决定你更喜欢哪一个。
- en: Finishing touches
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的修饰
- en: Now that you’ve completed the main structure of the game, and hopefully designed
    a few levels for the player to enjoy, you can consider making some additions to
    improve the gameplay. In this section, you’ll find a few more suggested features
    – add them as-is or adjust them to your liking.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了游戏的主要结构，并且希望为玩家设计几个关卡来享受，你可以考虑添加一些功能来改善游戏体验。在本节中，你将找到一些额外的建议功能——直接添加或根据你的喜好进行调整。
- en: Sound effects
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音效
- en: 'As with the previous projects, you can add audio effects and music to improve
    the experience. In `res://assets/audio/`, you’ll find audio files you can use
    for different game events, such as player jump, enemy hit, and item pickup. There
    are also two music files: `Intro Theme` for the title screen and `Grasslands Theme`
    for the level scene.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的项目一样，你可以添加音效和音乐来提升体验。在`res://assets/audio/`中，你可以找到用于不同游戏事件（如玩家跳跃、敌人击中和物品拾取）的音频文件。还有两个音乐文件：`Intro
    Theme`用于标题屏幕，`Grasslands Theme`用于关卡场景。
- en: 'Adding these to the game will be left to you, but here are a few tips:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些添加到游戏中将由你来决定，但这里有一些提示：
- en: You may find it helpful to adjust the volume of individual sounds. This can
    be set with the **Volume dB** property. Setting a negative value will reduce the
    sound’s volume.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会发现调整单个声音的音量很有帮助。这可以通过**Volume dB**属性来设置。设置负值将降低声音的音量。
- en: You can attach the music to the master `level.tscn` scene; that music will be
    used for all levels. You could also attach separate music to individual levels
    if you want to set a certain mood.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将音乐附加到主 `level.tscn` 场景；该音乐将用于所有关卡。如果您想设定某种氛围，也可以为单个关卡附加单独的音乐。
- en: Your first thought might be to put `AudioStreamPlayer` on the `Item` scene to
    play the pickup sound. However, since the pickup is deleted when the player touches
    it, that won’t work well. Instead, put the audio player in the `Level` scene,
    since that’s where the result of the pickup is handled (increasing the score).
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的第一个想法可能是将 `AudioStreamPlayer` 放在 `Item` 场景中以播放拾取声音。然而，由于拾取物在玩家触摸时被删除，这不会很好地工作。相反，将音频播放器放在
    `Level` 场景中，因为那里处理了拾取物的结果（增加分数）。
- en: Double jumping
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双重跳跃
- en: Double jumps are a popular platforming feature. The player gets a second, usually
    smaller, upwards boost if they press the jump key a second time while in the air.
    To implement this feature, you need to add a few things to the player script.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 双重跳跃是流行的平台游戏功能。如果玩家在空中按下跳跃键第二次，他们将获得第二次，通常是较小的向上提升。要实现此功能，您需要向玩家脚本中添加一些内容。
- en: 'First, you will need variables to track the number of jumps and determine how
    big the second boost will be:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要变量来跟踪跳跃次数并确定第二次提升的大小：
- en: '[PRE31]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When entering the `JUMP` state, reset the number of jumps:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当进入 `JUMP` 状态时，重置跳跃次数：
- en: '[PRE32]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In `get_input()`, allow the jump if it meets the conditions that have been.
    Put this before the `if` statement where you check if the player is on the floor:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `get_input()` 中，如果满足条件，允许跳跃。将此放在检查玩家是否在地板上的 `if` 语句之前：
- en: '[PRE33]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In `_physics_process()`, when you land on the ground, reset the jump count:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_physics_process()` 中，当您落地时，重置跳跃计数：
- en: '[PRE34]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Play your game and try out the double jumps. Note that this code makes the second
    jump 2/3rds the size of the upward speed of the initial jump. You can adjust this
    according to your preferences.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 玩您的游戏并尝试双跳。请注意，此代码使第二次跳跃的大小为初始跳跃向上速度的 2/3。您可以根据您的喜好进行调整。
- en: Dust particles
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灰尘颗粒
- en: Spawning dust particles at the character’s feet is a low-effort effect that
    can add a lot of character to your player’s movements. In this section, you’ll
    add a small puff of dust to the player’s feet that is emitted whenever they land
    on the ground. This adds a sense of weight and impact to the player’s jumps.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在角色的脚下生成灰尘颗粒是一种低成本的特效，可以为玩家的动作增添很多特色。在本节中，您将为玩家落地时发出的少量灰尘添加一个轻微的喷溅效果。这为玩家的跳跃增添了重量感和冲击感。
- en: 'Add a `CPUParticles2D` node to the `Player` scene and name it `Dust`. Set the
    following properties:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `CPUParticles2D` 节点添加到 `Player` 场景，并将其命名为 `Dust`。设置以下属性：
- en: '| **Property** | **Value** |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **值** |'
- en: '| Amount | `20` |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| 数量 | `20` |'
- en: '| Lifetime | `0.45` |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| 寿命 | `0.45` |'
- en: '| One Shot | `On` |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| 一次性 | `On` |'
- en: '| Speed Scale | `2` |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| 速度缩放 | `2` |'
- en: '| Explosiveness | `0.7` |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| 爆炸性 | `0.7` |'
- en: '| Emission Shape | `Rectangle` |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| 发射形状 | `Rectangle` |'
- en: '| Rect Extents | `1, 6` |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| 矩形范围 | `1, 6` |'
- en: '| Initial Velocity Max | `10` |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| 初始速度最大 | `10` |'
- en: '| Scale Amount Max | `3` |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| 最大缩放量 | `3` |'
- en: '| Position | `-``2, 0` |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| 位置 | `-``2, 0` |'
- en: '| Rotation | `-``90` |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 旋转 | `-``90` |'
- en: The default particle color is white, but the dust effect will look better in
    a tan shade. It should also fade away so that it appears to dissipate. This can
    be accomplished with `Gradient`. In the **Color/Color Ramp** area, select **New
    Gradient**.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的颗粒颜色是白色，但灰尘效果在棕褐色中看起来会更好。它还应该逐渐消失，以便看起来像是在消散。这可以通过 `Gradient` 实现。在 **颜色/颜色渐变**
    区域，选择 **新建渐变**。
- en: '`Gradient` has two colors: a start color on the left and an end color on the
    right. These can be selected using the small rectangles at either end of the gradient.
    Clicking on the large square on the right allows you to set the color for the
    selected rectangle:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gradient` 有两种颜色：左侧的起始颜色和右侧的结束颜色。这些可以通过渐变两端的矩形选择。点击右侧的大方块允许您为选定的矩形设置颜色：'
- en: '![Figure 4.27: Color Ramp](img/B19289_04_28.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.27：颜色渐变](img/B19289_04_28.jpg)'
- en: 'Figure 4.27: Color Ramp'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.27：颜色渐变
- en: Set the start color to a tan shade, and set the end to the same color, but with
    the alpha value set to `0`. You should see a continuously puffing smoke effect.
    In the Inspector, set **One Shot** to on. Now, the particles will only emit once,
    each time you check the **Emitting** box.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 将起始颜色设置为棕褐色，并将结束颜色设置为相同的颜色，但将透明度值设置为 `0`。您应该看到一个持续冒烟的效果。在检查器中，将 **一次性** 设置为开启。现在，每次您勾选
    **发射** 复选框时，颗粒只会发射一次。
- en: Feel free to alter the properties that have been provided here. Experimenting
    with particle effects can be great fun, and often, you’ll stumble upon a very
    nice effect just by tinkering.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 随意更改这里提供的属性。实验粒子效果可以非常有趣，而且通常，你只需稍微调整就能发现一个非常棒的效果。
- en: 'Once you’re happy with its appearance, add the following to the player’s `_physics_process()`
    code:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对它的外观满意，将以下内容添加到玩家的`_physics_process()`代码中：
- en: '[PRE35]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Run the game and observe the puff of dust every time your character lands on
    the ground.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并观察每次你的角色落地时都会出现的灰尘。
- en: Ladders
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 梯子
- en: The player sprite sheet includes frames for a climbing animation, and the tileset
    contains ladder images. Currently, the ladder tiles do nothing – in `TileSet`,
    they do not have any collision shape assigned. That’s OK because you don’t want
    the player to collide with the ladders – you want them to be able to move up and
    down on them.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家精灵图包括攀爬动画的帧，而瓦片集包含梯子图像。目前，梯子瓷砖没有任何作用——在`TileSet`中，它们没有分配任何碰撞形状。这是可以的，因为你不希望玩家与梯子碰撞——你希望他们能够在上面上下移动。
- en: Player code
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩家代码
- en: Start by selecting the player’s `AnimationPlayer` node and adding a new animation
    called `climb`. Its `0.4` and it should be set to `Sprite2D` are *0 -> 1 -> 0
    ->* *2*.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，选择玩家的`AnimationPlayer`节点，并添加一个名为`climb`的新动画。它的`0.4`应该设置为`Sprite2D`，其动画顺序为*0
    -> 1 -> 0 ->* *2*。
- en: 'Go to `player.gd` and add a new state, `CLIMB`, to the `state` enum. In addition,
    add two new variable declarations at the top of the script:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 前往`player.gd`并添加一个新的状态，`CLIMB`，到`state`枚举中。此外，在脚本顶部添加两个新的变量声明：
- en: '[PRE36]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You’ll use `is_on_ladder` to keep track of whether the player is on a ladder
    or not. Using this, you can decide whether the up and down actions should have
    any effect.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用`is_on_ladder`来跟踪玩家是否在梯子上。使用这个，你可以决定上下动作是否应该有任何效果。
- en: 'In `change_state()`, add a condition for the new state:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在`change_state()`中，为新的状态添加一个条件：
- en: '[PRE37]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In `get_input()`, you need to check for the input actions and then determine
    if they change the state:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get_input()`中，你需要检查输入动作，然后确定它们是否改变状态：
- en: '[PRE38]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, you have three new conditions to check. First, if the player is not in
    the `CLIMB` state but is on a ladder, then pressing up should make the player
    start climbing. Second, if the player is currently climbing, then the up and down
    inputs should make them move up and down the ladder, but stop the animation from
    playing if no action is pressed. Finally, if the player leaves the ladder while
    climbing, they leave the `CLIMB` state.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你有三个新的条件需要检查。首先，如果玩家不在`CLIMB`状态但站在梯子上，按下向上键应该使玩家开始攀爬。其次，如果玩家正在攀爬，上下输入应该使他们在梯子上上下移动，但如果没有任何动作被按下，则停止动画播放。最后，如果玩家在攀爬时离开梯子，他们将离开`CLIMB`状态。
- en: 'You also need to make sure that gravity doesn’t pull the player downward while
    they’re on a ladder. Add a condition to the gravity code in `_physics_process()`:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要确保当玩家站在梯子上时，重力不会将他们向下拉。在`_physics_process()`中的重力代码中添加一个条件：
- en: '[PRE39]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, the player is ready to climb, which means you can add some ladders to your
    level.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩家已经准备好攀爬，这意味着你可以在关卡中添加一些梯子。
- en: Level setup
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关卡设置
- en: 'Add an `Area2D` node named `Ladders` to the `Level` scene, but don’t add a
    collision shape to it yet. Connect its `body_entered` and `body_exited` signals
    and set its collision `items` and `player`. This ensures that only the player
    can interact with the ladder. These signals are how you’ll let the player know
    they are or aren’t on a ladder:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 将名为`Ladders`的`Area2D`节点添加到`Level`场景中，但暂时不要给它添加碰撞形状。连接其`body_entered`和`body_exited`信号，并设置其碰撞`items`和`player`。这确保了只有玩家可以与梯子交互。这些信号是你让玩家知道他们是否在梯子上的方式：
- en: '[PRE40]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, the level needs to look for any ladder tiles and add collision shapes
    to the `Ladders` area whenever it finds one. Add the following function to `level.gd`
    and call it in `_ready()`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关卡需要查找任何梯子瓷砖，并在找到时将碰撞形状添加到`Ladders`区域。将以下函数添加到`level.gd`中，并在`_ready()`中调用它：
- en: '[PRE41]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that the collision shapes you’re adding are only `8` pixels wide. If you
    make the shape the full width of the ladder tile, then the player will still look
    as though they’re climbing even when they’re hanging off the side, which looks
    a bit odd.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你添加的碰撞形状只有`8`像素宽。如果你使形状与梯子瓷砖的整个宽度相同，那么玩家看起来就像是在攀爬，即使他们悬挂在一边，这看起来有点奇怪。
- en: Try it out – go to one of your level scenes and place some ladder tiles anywhere
    you’d like on your `World` tile map. Play the scene and try climbing the ladders.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下 - 前往您的关卡场景之一，并将一些梯子瓦片放置在您想要的 `World` 瓦片地图上的任何位置。播放场景并尝试爬梯子。
- en: Note that if you’re at the top of a ladder and step on it, you’ll fall to the
    bottom rather than climb down (although pressing up as you fall will cause you
    to grab the ladder). If you prefer to automatically transition to the climbing
    state, you can add an additional falling check in `_physics_process()`.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您在梯子的顶部并踩到它，您会掉到下面而不是爬下来（尽管在掉落时按上键会使您抓住梯子）。如果您希望自动过渡到攀爬状态，您可以在 `_physics_process()`
    中添加一个额外的坠落检查。
- en: Moving platforms
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动平台
- en: Moving platforms are a fun addition to your level design toolkit. In this section,
    you’ll make a moving platform that you can place anywhere on your level and set
    its movement and speed.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 移动平台是关卡设计工具包中的一项有趣的功能。在本节中，您将制作一个可以在关卡上的任何位置放置的移动平台，并设置其移动和速度。
- en: Start with a new scene using a `Node2D` node and name it `MovingPlatform`. Save
    the scene and add `TileMap` as a child. Since your platform art is all in sprite
    sheets and they’ve already been sliced into tiles and had collisions added, this
    will make your platform easy to draw. Add `tiles_world.tres` as **Tile Set**.
    You’ll also need to check the **Collision Animatable** box, which will make sure
    the collisions work properly even while moving.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Node2D` 节点创建一个新场景，并将其命名为 `MovingPlatform`。保存场景并将 `TileMap` 添加为子节点。由于您的平台艺术全部在精灵图中，并且它们已经被切割成瓦片并添加了碰撞，这将使您的平台易于绘制。将
    `tiles_world.tres` 添加为**瓦片集**。您还需要勾选**可动画碰撞**框，这将确保即使在移动时碰撞也能正常工作。
- en: 'Draw a few tiles into `TileMap`, but make sure to start at the origin, `(0,
    0)`, so that things will line up cleanly. These tiles work well for a floating
    platform:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `TileMap` 中绘制一些瓦片，但请确保从原点 `(0, 0)` 开始，以便事物可以整齐排列。这些瓦片非常适合浮动平台：
- en: '![Figure 4.28: Floating platform](img/B19289_04_29.jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.28：浮动平台](img/B19289_04_29.jpg)'
- en: 'Figure 4.28: Floating platform'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.28：浮动平台
- en: 'Add a script to the root node and start with these variables:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本添加到根节点，并从以下变量开始：
- en: '[PRE42]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These will allow you to set the movement amount and speed. `offset` is relative
    to the starting point, and since it’s a `Vector2` node, you can have platforms
    that move horizontally, vertically, or diagonally. `duration` is measured in seconds
    and represents how long the *complete* cycle will take.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将允许您设置移动量和速度。`offset` 是相对于起始点的，由于它是一个 `Vector2` 节点，您可以有水平、垂直或对角线移动的平台。`duration`
    以秒为单位，表示完整周期将花费多长时间。
- en: 'The platform will always be moving, so you can start the animation in `_ready()`.
    It will use a `tween` method to animate the position in two steps: from the start
    position to the offset position and vice versa:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 平台将始终在移动，因此您可以在 `_ready()` 中开始动画。它将使用 `tween` 方法通过两步来动画化位置：从起始位置到偏移位置，然后反过来：
- en: '[PRE43]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here are a few notes about tween usage:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于缓动使用的小贴士：
- en: You need to set the process mode so that the movement will be synced to physics
    and the player will be able to collide properly with the platform (that is, stand
    on it).
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要设置进程模式，以便移动将与物理同步，玩家将能够正确地与平台碰撞（即站在上面）。
- en: '`set_loops()` tells `tween` to repeat once finished.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_loops()` 告诉 `tween` 在完成后重复一次。'
- en: '`set_parallel(false)` tells `tween` to perform the two property tweens sequentially
    rather than at the same time.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_parallel(false)` 告诉 `tween` 按顺序执行两个属性缓动，而不是同时执行。'
- en: You can also experiment with other tween curves. Adding `tween.set_trans(Tween.TRANS_SINE)`,
    for example, will make the platform slow down at the ends of the movement for
    a more natural look. Try experimenting with the other transition types.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以尝试其他缓动曲线。例如，添加 `tween.set_trans(Tween.TRANS_SINE)` 将使平台在移动的末端减速，以获得更自然的外观。尝试使用其他过渡类型进行实验。
- en: 'Now, you can add instances of `MovingPlatform` to the level scene. To make
    sure things line up properly, make sure you turn on grid snapping:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将 `MovingPlatform` 的实例添加到关卡场景中。为了确保一切排列正确，请确保您已启用网格吸附：
- en: '![Figure 4.29: Enabling grid snapping](img/B19289_04_30.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.29：启用网格吸附](img/B19289_04_30.jpg)'
- en: 'Figure 4.29: Enabling grid snapping'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.29：启用网格吸附
- en: The default value is `(8, 8)`, but you can change it by clicking the three dots
    next to the icon and choosing **Configure Snap**.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值是 `(8, 8)`，但您可以通过点击图标旁边的三个点并选择**配置吸附**来更改它。
- en: When you run the game now, you will have a lot more to interact with. The ladders
    and moving platforms give you a lot more possibilities for your level designs.
    But you don’t have to stop there! Considering everything you’ve done in this chapter,
    there are many other features that you could still add. The player animation includes
    a “crouching” animation – what if the enemies could throw things at the player
    that could be ducked under? Many platformer games include additional movement
    mechanics such as sliding down slopes, wall jumps, changing gravity, and many
    more. Choose one and see if you can add it.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行游戏时，你将有更多可以与之互动的内容。梯子和移动平台给你的关卡设计提供了更多可能性。但你不一定要止步于此！考虑到本章中你所做的一切，还有很多其他功能你可以添加。玩家的动画包括一个“蹲下”动画——如果敌人能向玩家投掷可以被躲过的东西会怎样？许多平台游戏包括额外的移动机制，如沿着斜坡滑动、墙壁跳跃、改变重力等等。选择一个，看看你是否可以添加它。
- en: Summary
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use the `CharacterBody2D` node to create
    arcade-style physics for player movement. This is a powerful node that can be
    used for a wide variety of game objects – not just platform characters.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 `CharacterBody2D` 节点为玩家移动创建街机风格的物理效果。这是一个功能强大的节点，可以用于各种游戏对象——而不仅仅是平台角色。
- en: 'You learned about the `TileMap` node for level design – a powerful tool with
    even more features than you used in this project. An entire chapter could be written
    on all of the different things you can do with it. For more information, see the
    *Using TileMaps* page on the Godot documentation website: https://docs.godotengine.org/en/latest/tutorials/2d/using_tilemaps.html.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了关于用于关卡设计的 `TileMap` 节点的知识——这是一个功能强大的工具，甚至比你在本项目中使用的功能还要多。关于你可以用它做的一切，可以写整整一章。更多信息，请参阅
    Godot 文档网站上的 *使用 TileMaps* 页面：https://docs.godotengine.org/en/latest/tutorials/2d/using_tilemaps.html。
- en: '`Camera2D` and `ParallaxBackground` are also key tools for any game where you
    want to move around in a world that’s bigger than the size of the screen. The
    camera node in particular will be a node that you’ll use in most 2D projects.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`Camera2D` 和 `ParallaxBackground` 也是任何希望在世界中移动的游戏中的关键工具，这个世界比屏幕大小还要大。特别是相机节点，你将在大多数
    2D 项目中使用它。'
- en: You also made extensive use of what you learned in earlier projects to tie everything
    together. Hopefully, at this point, you have a good grasp of the scene system
    and how a Godot project is structured.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 你还广泛地使用了在早期项目中学到的知识来将所有内容串联起来。希望到这一点，你已经很好地掌握了场景系统以及 Godot 项目的结构。
- en: Once again, before moving on, take a few moments to play your game and look
    through its various scenes and scripts to review how you built it. Review any
    sections of this chapter that you found particularly tricky. And most importantly,
    before moving on, try to make some changes to the project.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，花几分钟时间玩你的游戏，浏览其各种场景和脚本，以回顾你是如何构建它的。回顾任何你觉得特别棘手的章节内容。最重要的是，在继续之前，尝试对项目进行一些修改。
- en: In the next chapter, you’ll make the jump to 3D!
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将进入 3D 世界！
