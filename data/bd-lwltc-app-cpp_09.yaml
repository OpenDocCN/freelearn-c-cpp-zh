- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Building the C++ Trading Algorithm’s Building Blocks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建C++交易算法的构建块
- en: 'In this chapter, we will build components that make up the intelligence in
    our trading applications. These are the components that the trading strategies
    will rely on very heavily to make decisions, send and manage orders, track and
    manage positions, **profits and losses** (**PnLs**), and manage risk. Not only
    do the trading strategies need to track the trading PnLs since the goal is to
    make money, but these components also need to track the PnLs to decide when to
    stop trading if needed. We will learn how to compute complex features from market
    data updates, track trading performance based on order executions and market updates,
    send and manage live strategy orders in the market, and manage market risk. In
    this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建构成我们交易应用智能的组件。这些是交易策略将非常依赖以做出决策、发送和管理订单、跟踪和管理位置、**损益**（**PnLs**）以及管理风险的组件。交易策略不仅需要跟踪交易损益，因为目标是赚钱，而且这些组件还需要跟踪损益以决定何时停止交易（如果需要的话）。我们将学习如何从市场数据更新中计算复杂特征，根据订单执行和市场更新跟踪交易表现，在市场上发送和管理实时策略订单，以及管理市场风险。在本章中，我们将涵盖以下主题：
- en: Reacting to executions and managing positions, PnLs, and risk
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对执行做出反应和管理位置、损益和风险
- en: Building the feature engine and computing complex features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建特征引擎和计算复杂特征
- en: Using executions and updating positions and PnLs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行、更新位置和损益
- en: Sending and managing orders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送和管理订单
- en: Computing and managing risk
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算和管理风险
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code for this book can be found in this book’s GitHub repository at
    [https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP).
    The source for this chapter is in the `Chapter9` directory in this repository.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有代码都可以在本书的GitHub仓库中找到，该仓库地址为[https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP)。本章的源代码位于该仓库的`Chapter9`目录中。
- en: You must have read and understood the design of the electronic trading ecosystem
    that was presented in *Chapter*, *Designing Our Trading Ecosystem*, especially
    the *Designing a framework for low-latency C++ trading algorithms* section. As
    before, we will use the building blocks we built in *Chapter*, *Building the C++
    Building Blocks for* *Low-Latency Applications*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须阅读并理解在*第*章*设计我们的交易生态系统*中介绍的电子交易生态系统的设计，特别是*设计一个低延迟C++交易算法框架*部分。和之前一样，我们将使用我们在*第*章*为低延迟应用构建C++构建块*中构建的构建块。
- en: 'The specifications of the environment in which the source code for this book
    was developed are shown here. We have provided the details of this environment
    since all the C++ code presented in this book is not necessarily portable and
    might require some minor changes for it to work in your environment:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书源代码开发环境的规格在此展示。我们提供了这个环境的详细信息，因为本书中展示的所有C++代码可能并不一定可移植，可能需要一些小的修改才能在你的环境中运行：
- en: '`Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18
    17:40:00 UTC 2 x86_64 x86_64` `x86_64 GNU/Linux.`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18
    17:40:00 UTC 2 x86_64 x86_64` `x86_64 GNU/Linux.`'
- en: '`g++ (Ubuntu` `11.3.0-1ubuntu1~22.04.1) 11.3.0.`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g++ (Ubuntu` `11.3.0-1ubuntu1~22.04.1) 11.3.0.`'
- en: '`cmake` `version 3.23.2.`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake` `版本 3.23.2.`'
- en: '`1.10.2.`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.10.2.`'
- en: Reacting to executions and managing positions, PnLs, and risk
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对执行做出反应和管理位置、损益和风险
- en: 'We need to build a few basic building blocks that will build and support our
    trading strategies. We discussed the need for these components in *Chapter*, *Designing
    Our Trading Ecosystem*, in the *Designing a framework for low-latency C++ trading
    algorithms* section. We have already implemented a major component – the limit
    order book – but in this section, we will build the remaining components we need,
    namely the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建一些基本的构建块，这些构建块将构建并支持我们的交易策略。我们在*第*章*设计我们的交易生态系统*中的*设计一个低延迟C++交易算法框架*部分讨论了这些组件的需求。我们已经实现了一个主要组件——限价订单簿，但在这个部分，我们将构建我们需要的其余组件，即以下内容：
- en: A `FeatureEngine`, which will be used to compute simple and complex features/signals
    that drive the trading strategy decisions
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`FeatureEngine`，它将被用来计算驱动交易策略决策的简单和复杂特征/信号
- en: A `PositionKeeper`, which will receive executions and compute important measures
    such as position, PnLs, traded volumes, and more
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`PositionKeeper`，它将接收执行并计算重要的指标，如头寸、损益、交易量等
- en: An `OrderManager`, which will be used by the strategies to send orders, manage
    them, and update these orders when there are updates
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`OrderManager`，它将被策略用来发送订单、管理它们并在有更新时更新这些订单
- en: A `RiskManager` to compute and check the market risk that a trading strategy
    is attempting to take on, as well as the risk it has realized
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`RiskManager`来计算和检查交易策略试图承担的市场风险以及它已经实现的风险
- en: 'The following diagram shows the topology of all these components and how they
    interact with each other. If you need to refresh your memory on why these components
    exist, what purpose they serve, how they interact with each other, and how they
    are designed, please revisit *Chapter*, *Designing Our Trading Ecosystem*, and
    look at the subsections in the *Designing a framework for low-latency C++ trading*
    *algorithms* section:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了所有这些组件的拓扑结构以及它们如何相互交互。如果您需要刷新对这些组件存在的原因、它们的目的、它们如何相互交互以及它们如何设计的记忆，请回顾*第*章*设计我们的交易生态系统*，并查看*设计低延迟C++交易算法框架*部分的子节。
- en: '![Figure 9.1 – The sub-components inside our trading engine](img/Figure_9.1_B19434.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 交易引擎内部的子组件](img/Figure_9.1_B19434.jpg)'
- en: Figure 9.1 – The sub-components inside our trading engine
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 交易引擎内部的子组件
- en: Now, let’s kick off our effort of implementing these components, starting with
    the feature engine in the next sub-section. But before we do that, we need to
    add two additional methods for the `Side` enumeration, which will make a lot of
    our source code simpler down the road. Both of these can be found in the `Chapter9/common/types.h`
    header file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始实施这些组件的工作，从下一子节的功能引擎开始。但在我们这样做之前，我们需要为`Side`枚举添加两个额外的方法，这将使我们的源代码在以后变得更加简单。这两个方法都可以在`Chapter9/common/types.h`头文件中找到。
- en: 'The first method we will add is the `sideToIndex()` method, which converts
    a `Side` value into an index that can be used to index into an array. This will
    allow us to maintain arrays of different types of objects that are indexed by
    a `Side` value. The implementation is simple – we simply typecast the side to
    a `size_t` type and add a `1` to account for the fact that `Side::SELL` has a
    value of -1 and valid that indices start from 0:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加的第一个方法是`sideToIndex()`方法，它将`Side`值转换为可以用于索引数组的索引。这将允许我们维护由`Side`值索引的不同类型的对象数组。实现很简单——我们只需将`side`类型转换为`size_t`类型并加1，以考虑到`Side::SELL`的值为-1，并且有效索引从0开始：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will also define a `sideToValue()` method, which converts a `Side` value
    into either a 1 for `Side::BUY` or a -1 for `Side::SELL`. This will help us when
    we compute positions and PnLs, which we will see shortly in this section:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义一个`sideToValue()`方法，它将`Side`值转换为`Side::BUY`的1或`Side::SELL`的-1。这将在我们计算头寸和损益时有所帮助，我们将在本节稍后看到：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have that additional functionality out of the way, we can start
    computing the feature engine.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了这些额外的功能，我们可以开始计算功能引擎。
- en: Building the feature and computing complex features
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建特征和计算复杂特征
- en: In this section, we will build a minimal version of a feature engine. We will
    only compute two simple features – one (market price) that computes fair market
    prices based on the top of book prices and quantity and another (aggressive trade
    qty ratio) that computes how big a trade is compared to the top of book quantities.
    We will use these feature values to drive our market-making and liquidity-taking
    trading algorithms later in this chapter. The source code for the `FeatureEngine`
    class we will build here can be found in the `Chapter9/trading/strategy/feature_engine.h`
    file on GitHub. We discussed the details of this component in *Chapter*, *Designing
    Our Trading Ecosystem*, in the *Designing a framework for low-latency C++ trading*
    *algorithms* section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个功能引擎的最小版本。我们将只计算两个简单的特征——一个（市场价格）基于订单簿价格顶部和数量计算公平市场价格，另一个（激进交易量比）计算交易量与订单簿顶部数量的比较大小。我们将使用这些特征值来驱动本章后面的市场制作和流动性获取交易算法。我们构建的`FeatureEngine`类的源代码可以在GitHub上的`Chapter9/trading/strategy/feature_engine.h`文件中找到。我们在*第*章*设计我们的交易生态系统*中讨论了该组件的详细信息，在*设计低延迟C++交易算法框架*部分。
- en: Defining the data members in the feature engine
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在功能引擎中定义数据成员
- en: 'First, we need to declare the `FeatureEngine` class and define the data members
    inside this class. First, we will include the required header files and define
    a constant sentinel value to represent invalid or uninitialized feature values.
    This is called `Feature_INVALID`, as shown here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要声明`FeatureEngine`类并在其中定义数据成员。首先，我们将包含所需的头文件并定义一个表示无效或未初始化特征值的常量哨兵值。这被称为`Feature_INVALID`，如下所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our `FeatureEngine` class is basic and has two important data members of the
    `double` type – one to compute and store the fair market price value, `mkt_price_`,
    and another to compute and store the aggressive trade quantity ratio feature value,
    `agg_trade_qty_ratio_`. It also stores a pointer to a `Logger` object (`logger_`)
    for logging purposes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`FeatureEngine`类是基础的，并且包含两个重要的`double`类型数据成员——一个用于计算和存储公平市场价格值，`mkt_price_`，另一个用于计算和存储激进交易数量比率特征值，`agg_trade_qty_ratio_`。它还存储了一个指向`Logger`对象的指针（`logger_`），用于日志记录：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we will look at how to initialize this class since we have already initialized
    the two feature variables with the `Feature_INVALID` value.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何初始化这个类，因为我们已经用`Feature_INVALID`值初始化了两个特征变量。
- en: Initializing the feature engine
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化特征引擎
- en: 'The constructor for this class accepts a `Logger` object and initializes the
    `logger_` data member – that’s all:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的构造函数接受一个`Logger`对象并初始化`logger_`数据成员——仅此而已：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, we will present two getter methods – `getMktPrice()` and `getAggTradeQtyRatio()`
    – to fetch the value of the two features that the `FeatureEngine` class is responsible
    for computing:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将展示两个获取方法——`getMktPrice()`和`getAggTradeQtyRatio()`——以获取`FeatureEngine`类负责计算的两个特征值：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the next two subsections, we will see how this component handles order book
    updates and trade events and updates the feature values.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个子节中，我们将看到这个组件如何处理订单簿更新和交易事件，并更新特征值。
- en: Computing the feature on order book changes
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在订单簿变化上计算特征
- en: 'The `FeatureEngine` class expects the `onOrderBookUpdate()` method to be called
    when there is an update to the order book. First, it uses `MarketOrderBook::getBBO()`
    to extract the BBO. As a reminder, `mkt_price_` value if they are valid. The fair
    market price is formulated as the book quantity weighted price, `(bid_price *
    ask_qty + ask_price * bid_qty) / (bid_qty + ask_qty)`. Note that this is just
    a single formulation for a fair market price; the important thing to remember
    with feature engineering is that there is no single correct formulation. You are
    encouraged to formulate a version of a fair market price or any other feature
    value you want to use in the future. The formulation we are using here tries to
    move the fair market price closer to the offer if there are more buy orders than
    sell orders and moves it closer to the bid if there are more sell orders than
    buy orders:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`FeatureEngine`类期望在订单簿更新时调用`onOrderBookUpdate()`方法。首先，它使用`MarketOrderBook::getBBO()`提取BBO。提醒一下，如果它们有效，则`mkt_price_`值。公平市场价格被公式化为订单簿数量加权价格，`(bid_price
    * ask_qty + ask_price * bid_qty) / (bid_qty + ask_qty)`。请注意，这只是公平市场价格的一个单一公式；在特征工程中要记住的重要事情是没有单一的正确公式。鼓励您制定一个公平市场价格或其他任何您希望在将来使用的特征值的版本。我们在这里使用的公式试图在买方订单多于卖方订单时将公平市场价格移向出价，在卖方订单多于买方订单时将其移向要价：'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The next subsection will compute the other feature, which we will refer to as
    the Aggressive Trade Quantity Ratio, for computing the trade quantity as a fraction
    of the book price level quantity.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将计算另一个特征，我们将称之为激进交易数量比率，用于将交易数量作为订单簿价格水平数量的分数来计算。
- en: Computing the feature on trade events
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在交易事件上计算特征
- en: '`FeatureEngine` expects the `onTradeUpdate()` method to be called when there
    is a trade event in the market data stream. As we saw previously, it fetches the
    BBO and checks if the prices are valid and then computes the `agg_trade_qty_ratio_`
    feature to be a ratio of the trade quantity and the quantity of the BBO that the
    trade aggresses on. As we mentioned with the previous feature, there is no single
    correct formulation of a feature – this is just the formulation we are using for
    now; hopefully, you will add your own formulations in the future. This formulation
    tries to measure how big a trade aggressor was compared to how much liquidity
    was available on the BBO side the aggressor trades against. We are simply trying
    to quantify the trade pressure with this feature that we are computing. As we
    mentioned previously, there are many other possible formulations:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`FeatureEngine` 预期在市场数据流中出现交易事件时调用 `onTradeUpdate()` 方法。正如我们之前所看到的，它获取BBO并检查价格是否有效，然后计算
    `agg_trade_qty_ratio_` 特征，该特征是交易量与交易所攻击的BBO数量的比率。正如我们之前提到的关于该特征，没有单一正确的特征公式 –
    这只是我们现在使用的公式；希望你在未来会添加自己的公式。这个公式试图衡量交易攻击者相对于攻击者交易的BBO侧可用的流动性的大小。我们只是试图通过我们计算的这个特征量化交易压力。正如我们之前提到的，还有许多其他可能的公式：'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That is the entire implementation of our `FeatureEngine` for this book. In the
    next section, we will learn how to handle executions and use that to update positions
    and PnLs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是本书中 `FeatureEngine` 的全部实现。在下一节中，我们将学习如何处理执行情况，并使用这些信息来更新头寸和PnL。
- en: Using executions to update positions and PnLs
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用执行情况更新头寸和PnL
- en: Now, we will build a `PositionKeeper` class that will be responsible for processing
    executions on a strategy’s orders and computing and tracking positions and PnLs.
    This component is used by the strategy as well as the risk manager to compute
    positions and PnLs for different purposes. All the source code for the `PositionKeeper`
    class is in the `Chapter9/trading/strategy/position_keeper.h` file on GitHub.
    Before we build the `PositionKeeper` class, which manages positions for all trading
    instruments, we will need to build a `PositionInfo` struct, which is also present
    in the same source file. The `PositionInfo` struct is the lower-level struct for
    managing the positions and PnLs for a single trading instrument; we will cover
    it in more detail in the next few subsections. We discussed the details of this
    component in *Chapter*, *Designing Our Trading Ecosystem*, in the *Designing a
    framework for low-latency C++ trading* *algorithms* section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将构建一个 `PositionKeeper` 类，该类将负责处理策略订单的执行情况，并计算和跟踪头寸和PnL。该组件被策略以及风险管理者用于计算不同目的的头寸和PnL。`PositionKeeper`
    类的所有源代码位于GitHub上的 `Chapter9/trading/strategy/position_keeper.h` 文件中。在我们构建管理所有交易工具头寸的
    `PositionKeeper` 类之前，我们需要构建一个也存在于同一源文件中的 `PositionInfo` 结构体。`PositionInfo` 结构体是用于管理单个交易工具的头寸和PnL的低级结构体；我们将在接下来的几个小节中更详细地介绍它。我们在
    *第* 章 *设计我们的交易生态系统* 的 *设计低延迟C++交易算法框架* 部分中讨论了该组件的细节。
- en: Declaring the data members in PositionInfo
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 `PositionInfo` 中声明数据成员
- en: 'First, we must specify the `include` files that will be needed for the `position_keeper.h`
    file, as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须指定 `position_keeper.h` 文件所需的 `include` 文件，如下所示：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The data members inside the `PositionInfo` struct are presented in the source
    code. The important data members are as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`PositionInfo` 结构体内的数据成员在源代码中呈现。重要的数据成员如下：'
- en: A `position_` variable of the `int32_t` type to represent the current position.
    This can be positive, negative, or 0.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `position_` 变量，其类型为 `int32_t`，用于表示当前头寸。这可以是正数、负数或0。
- en: Three `double` values – `real_pnl_`, `unreal_pnl_`, and `total_pnl_` – to track
    the realized or closed PnL for positions that have been closed (`real_pnl_`),
    the unrealized or open PnL for the currently open position (`unreal_pnl_`), and
    the total PnL, which is a summation of the two values (`total_pnl_`), respectively.
    The realized PnL only changes when additional order executions occur; the unrealized
    PnL can change even without order executions if there is a non-zero position and
    market prices change.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个 `double` 类型的值 – `real_pnl_`、`unreal_pnl_` 和 `total_pnl_` – 分别用于跟踪已关闭头寸的已实现或已关闭的PnL（`real_pnl_`）、当前开放头寸的未实现或开放PnL（`unreal_pnl_`），以及总PnL，这是两个值的总和（`total_pnl_`）。已实现PnL仅在发生额外订单执行时才会改变；如果存在非零头寸且市场价格发生变化，未实现PnL即使没有订单执行也可能改变。
- en: A `std::array` of `double` of a size large enough to accommodate entries for
    the buy side and sell side. This array will be indexed using the `sideToIndex(Side::BUY)`
    and `sideToIndex(Side::SELL)` values. This `open_vwap_` `std::array` variable
    tracks the product of price and execution quantity on each side when there is
    an open long (positive) or short (negative) position. We will need this to compute
    the unrealized PnL by comparing the **volume-weighted average price** (**VWAP**)
    of the open long or short position against the current market price.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个足够大的`std::array`，其大小足以容纳买方和卖方的条目。这个数组将使用`sideToIndex(Side::BUY)`和`sideToIndex(Side::SELL)`值进行索引。这个`open_vwap_`
    `std::array`变量跟踪在存在开放多头（正）或空头（负）持仓时每侧的价格和执行数量的乘积。我们需要这个来通过比较开放多头或空头持仓的**加权平均价格**（**VWAP**）与当前市场价格来计算未实现盈亏。
- en: A `volume_` variable of the `Qty` type to track the total quantity that has
    been executed.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`volume_`变量，其类型为`Qty`，用于跟踪已执行的总数量。
- en: 'A `const` pointer variable to a `BBO` object called `bbo_`, which will be used
    on market updates to fetch the updated top-of-book prices:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向名为`bbo_`的`BBO`对象的`const`指针变量，该变量将在市场更新时用于获取更新的订单簿顶端价格：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will also add a simple `toString()` method to this struct to *stringify*
    instances of this structure:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为此结构添加一个简单的`toString()`方法来将此结构的实例转换为字符串：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, we need to process order executions and update the positions and PnLs
    based on those executions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要处理订单执行情况，并根据这些执行情况更新持仓和盈亏（PnL）。
- en: Handling order executions in PositionInfo
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`PositionInfo`中处理订单执行
- en: When a trading strategy’s orders are executed, `PositionKeeper` needs to update
    the positions and PnLs that have been tracked for the trading instrument of the
    execution. It does this by providing the `MEClientResponse` message corresponding
    to order executions to the `PositionInfo::addFIll()` method. We will build this
    in this subsection.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个交易策略的订单被执行时，`PositionKeeper`需要更新跟踪执行交易工具的持仓和盈亏。它是通过向`PositionInfo::addFill()`方法提供与订单执行对应的`MEClientResponse`消息来做到这一点的。我们将在本小节中构建它。
- en: 'Before we look at the source code for our implementation of the `PositionInfo::addFill()`
    method, we will look at an example of how the algorithm to update the realized
    and unrealized PnLs works. This will help you easily understand the source code
    for the implementation. We will track the evolution of the different variables
    as we work our way through a few hypothetical executions for a hypothetical trading
    instrument. We will display the following variables as columns in our tables:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看`PositionInfo::addFill()`方法的实现源代码之前，我们将查看一个示例，说明如何更新实现和未实现盈亏的算法。这将帮助你轻松理解实现源代码。我们将跟踪在几个假设的执行过程中假设交易工具的不同变量的演变。在我们的表格中，我们将显示以下变量作为列：
- en: '**position – old**: This is the position before the current execution message
    is processed'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**position – old**：这是处理当前执行消息之前的持仓。'
- en: '**position – new**: This will be the new position after processing the current
    execution message'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**position – new**：这将是在处理当前执行消息后的新持仓。'
- en: '**open_vwap – BUY**: This is the sum of the products of execution price and
    execution quantity for buy executions only'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**open_vwap – BUY**：这是仅针对买入执行的执行价格和执行数量的乘积之和。'
- en: '**open_vwap – SELL**: This is the sum of the products of execution price and
    execution quantity for sell executions only'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**open_vwap – SELL**：这是仅针对卖出执行的执行价格和执行数量的乘积之和。'
- en: '**VWAP – BUY**: This is the actual VWAP of the current long/positive position,
    represented in units of price and not price x quantity'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VWAP – BUY**：这是当前多头/正持仓的实际VWAP，以价格单位表示，而不是价格乘以数量。'
- en: '**VWAP – SELL**: This is the actual VWAP of the current short/negative position,
    represented in units of price and not price x quantity'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VWAP – SELL**：这是当前空头/负持仓的实际VWAP，以价格单位表示，而不是价格乘以数量。'
- en: '**PnL – real**: This is the realized PnL after processing this execution'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PnL – real**：这是处理此执行后的实现盈亏。'
- en: '**PnL – unreal**: This is the unrealized PnL for the open position after processing
    this execution'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PnL – unreal**：这是处理此执行后的开放持仓的未实现盈亏。'
- en: 'Assuming we get an execution for buying 10 at 100.0, we must update `open_vwap`,
    `VWAP` on the `BUY` side, and the new position, as shown here. No changes need
    to be made to the unreal PnL yet:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们得到一个以100.0的价格买入10个单位的执行，我们必须更新`open_vwap`、`BUY`侧的`VWAP`以及新的持仓，如下所示。目前不需要对未实现盈亏进行更改：
- en: '| **position** | **open_vwap** | **VWAP** | **PnL** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **position** | **open_vwap** | **VWAP** | **PnL** |'
- en: '| **Old** | **new** | **BUY** | **SELL** | **BUY** | **SELL** | **real** |
    **unreal** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **旧** | **新** | **BUY** | **SELL** | **BUY** | **SELL** | **real** | **unreal**
    |'
- en: '| 0 | 10 | 1000.0 | 0.0 | 100.0 | 0.0 | 0.0 | 0.0 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 10 | 1000.0 | 0.0 | 100.0 | 0.0 | 0.0 | 0.0 |'
- en: 'Assuming we get another execution for buying 10 at 90.0, our old position was
    10 and the new position will be 20\. The `open_vwap` property for `BUY` now gets
    10 * 90 added to the previous 1,000 and becomes 1,900\. The `VWAP` column for
    the open long/positive position is 95, which can be computed by dividing 1,900
    (`BUY` `open_vwap`) by 20 (new position). We compute the unreal PnL by using a
    `VWAP` of 95 and the latest execution price of 90 and multiplying the difference
    of -5 by the position of 20 to get -100\. We have a negative unrealized PnL because
    our long/positive position’s `VWAP` is higher than current market prices (represented
    by the latest execution price):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们再次以90.0的价格执行买入10的操作。我们的旧仓位是10，新仓位将是20。`BUY`（买入）的`open_vwap`属性现在将10 * 90加到之前的1,000上，变成1,900。开放多头/正仓位的`VWAP`列是95，可以通过将1,900（`BUY`
    `open_vwap`）除以20（新仓位）来计算。我们通过使用95的`VWAP`和最新的执行价格90，将-5的差额乘以20的仓位来计算未实现损益，得到-100。由于我们的多头/正仓位的`VWAP`高于当前市场价格（由最新执行价格表示），我们有一个负的未实现损益：
- en: '| **position** | **open_vwap** | **VWAP** | **PnL** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **仓位** | **open_vwap** | **VWAP** | **PnL** |'
- en: '| **old** | **new** | **BUY** | **SELL** | **BUY** | **SELL** | **real** |
    **unreal** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **旧** | **新** | **BUY** | **SELL** | **BUY** | **SELL** | **real** | **unreal**
    |'
- en: '| 10 | 20 | 1900.0 | 0.0 | 95.0 | 0.0 | 0.0 | -100.0 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 20 | 1900.0 | 0.0 | 95.0 | 0.0 | 0.0 | -100.0 |'
- en: 'Now, let’s assume we get a sell execution for selling 10 at 92\. Our old position
    of 20 will be reduced to 10\. Our `open_vwap` and `VWAP` on the `BUY` side do
    not change since this was a sell execution. Since we closed 10 out of our long/positive
    20 positions, we will have some realized PnL and the remaining 10 long/positive
    positions will have some unrealized PnL based on the execution price of this latest
    execution. The realized PnL is computed using the sell execution price of 92,
    the `VWAP` property of the long/positive position, which is 95, and the execution
    quantity of 10 to yield a realized PnL of (92 - 95) * 10 = -30\. In this case,
    the unrealized PnL is also the same since there is a long/positive 10 position
    left:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们执行了一次以92的价格卖出10的卖出操作。我们的旧仓位从20减少到10。由于这是一次卖出操作，我们的`open_vwap`和`VWAP`在`BUY`（买入）方面没有变化。由于我们关闭了10个多头/正仓位，我们将有一些已实现损益（PnL），而剩余的10个多头/正仓位将基于这次最新执行的执行价格有一些未实现损益。已实现损益是通过使用92的卖出执行价格、多头/正仓位的`VWAP`属性（95）以及10的执行数量来计算的，得到已实现损益为(92
    - 95) * 10 = -30。在这种情况下，未实现损益也是相同的，因为还剩下多头/正仓位10：
- en: '| **position** | **open_vwap** | **VWAP** | **PnL** |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **仓位** | **open_vwap** | **VWAP** | **PnL** |'
- en: '| **Old** | **new** | **BUY** | **SELL** | **BUY** | **SELL** | **real** |
    **unreal** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **旧** | **新** | **BUY** | **SELL** | **BUY** | **SELL** | **real** | **unreal**
    |'
- en: '| 20 | 10 | 1900.0 | 0.0 | 95.0 | 0.0 | -30.0 | -30.0 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 10 | 1900.0 | 0.0 | 95.0 | 0.0 | -30.0 | -30.0 |'
- en: 'Now, let’s assume we receive another sell execution for selling 20 at 97\.
    This will cause our position to flip from 10 to –10 (note that we set `open_vwap`
    and `VWAP` for the `BUY` side to 0). The `open_vwap` property for the `SELL` side
    becomes 970 because of the -10 position and the execution price of 97\. We close
    the previous position of 10, which had a `VWAP` of 95 with this sell at 97\. Since
    we sold higher than the `VWAP` property of our long/positive position, we make
    a profit of (97 - 95) * 10 = 20, which when added to the previous realized PnL
    of -30, yields the final `realized` PnL of -10\. The unrealized PnL here is 0
    since a `VWAP` of 97 is the same as the current execution price of 97:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们收到另一个以97的价格卖出20的卖出执行。这将导致我们的仓位从10翻转到-10（注意，我们将`open_vwap`和`VWAP`的`BUY`（买入）方面设置为0）。由于-10的仓位和97的执行价格，`SELL`（卖出）方面的`open_vwap`属性变为970。我们关闭了之前的10仓位，该仓位在95的`VWAP`下以97的价格卖出。由于我们以高于我们多头/正仓位`VWAP`属性的价格卖出，我们获得了(97
    - 95) * 10 = 20的利润，加上之前的已实现损益-30，最终得到`realized`（已实现）损益为-10。这里的未实现损益为0，因为97的`VWAP`与当前的执行价格97相同：
- en: '| **position** | **open_vwap** | **VWAP** | **PnL** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **仓位** | **open_vwap** | **VWAP** | **PnL** |'
- en: '| **Old** | **new** | **BUY** | **SELL** | **BUY** | **SELL** | **real** |
    **unreal** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **旧** | **新** | **BUY** | **SELL** | **BUY** | **SELL** | **real** | **unreal**
    |'
- en: '| 10 | -10 | 0.0 | 970.0 | 0.0 | 97.0 | -10.0 | 0.0 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 10 | -10 | 0.0 | 970.0 | 0.0 | 97.0 | -10.0 | 0.0 |'
- en: 'Let’s assume that we get another sell execution of selling 20 and 94\. Here,
    the short/negative position increases from -10 to -30\. The `open_vwap` property
    on the `SELL` side is updated by adding (20 * 94) to the previous value of 970
    to yield 2,850\. The `VWAP` property of our short position is updated to 95 by
    dividing the `open_vwap` property of 2,850 by the position of 30 to yield 95\.
    The realized PnL does not change since the position was increased and nothing
    was reduced or closed. The unreal PnL uses the execution price of 94 on this new
    execution, compares it to the `VWAP` property of 95, and uses the new position
    of -30 to yield (95 - 94) * 30 = 30:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们得到另一个以 94 价格卖出 20 的卖出执行。在这里，空头/负头寸从 -10 增加到 -30。`open_vwap` 属性在 `SELL` 方面通过将
    (20 * 94) 加到之前的值 970 上进行更新，得到 2,850。我们的空头头寸的 `VWAP` 属性更新为 95，通过将 `open_vwap` 属性
    2,850 除以头寸 30 得到 95。由于头寸增加且没有减少或关闭，实际 PnL 没有变化。未实现 PnL 使用这次新执行上的执行价格 94，将其与 `VWAP`
    属性 95 进行比较，并使用新的头寸 -30 得到 (95 - 94) * 30 = 30：
- en: '| **position** | **open_vwap** | **VWAP** | **PnL** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **位置** | **开盘 VWAP** | **VWAP** | **PnL** |'
- en: '| **Old** | **new** | **BUY** | **SELL** | **BUY** | **SELL** | **real** |
    **unreal** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **旧值** | **新值** | **买入** | **卖出** | **买入** | **卖出** | **实际** | **未实现** |'
- en: '| -10 | -30 | 0.0 | 2850.0 | 0.0 | 95.0 | -10.0 | 30.0 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| -10 | -30 | 0.0 | 2850.0 | 0.0 | 95.0 | -10.0 | 30.0 |'
- en: 'Let’s assume that there is yet another sell execution of selling 10 at 90\.
    The short/negative position increases from -30 to -40\. We add the new execution’s
    price and quantity product (10 * 90) to the previous `open_vwap` property’s `SELL`
    of 2,850 to yield 3,750\. The actual `VWAP` of the short position changes from
    95 to 93.75 and was obtained by dividing this 3,750 value by the new position
    of 40\. The realized PnL does not change since the position was increased, but
    the unrealized PnL is updated using (93.75 - 90) * 40 = 150:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设还有一次以 90 价格卖出 10 的卖出执行。空头/负头寸从 -30 增加到 -40。我们将新执行的价格和数量乘积（10 * 90）加到之前的 `open_vwap`
    属性的 `SELL` 2,850 上，得到 3,750。实际 `VWAP` 的空头头寸从 95 变为 93.75，这是通过将这个 3,750 的值除以新的头寸
    40 得到的。实际 PnL 没有变化，因为头寸增加了，但没有减少或关闭。未实现 PnL 使用 (93.75 - 90) * 40 = 150 进行更新：
- en: '| **position** | **open_vwap** | **VWAP** | **PnL** |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| **位置** | **开盘 VWAP** | **VWAP** | **PnL** |'
- en: '| **Old** | **new** | **BUY** | **SELL** | **BUY** | **SELL** | **real** |
    **unreal** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **旧值** | **新值** | **买入** | **卖出** | **买入** | **卖出** | **实际** | **未实现** |'
- en: '| -30 | -40 | 0.0 | 3750.0 | 0.0 | 93.75 | -10.0 | 150.0 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| -30 | -40 | 0.0 | 3750.0 | 0.0 | 93.75 | -10.0 | 150.0 |'
- en: 'Finally, let’s assume that we receive a buy execution for buying 40 at 88\.
    This execution will flatten our short/negative position of -40, so the new position
    will be 0\. The unrealized PnL will be 0 and the `open_vwap` and `VWAP` properties
    will be 0 for both sides since there is no open position anymore. The realized
    PnL is updated using the previous `VWAP` property, the execution price, and the
    position of 40, so (93.75 - 88) * 40 = 230\. This is added to the previously realized
    PnL of –10 to yield the final realized PnL of 220:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，假设我们收到一个以 88 价格买入 40 的买入执行。这次执行将平掉我们的空头/负头寸 -40，因此新的头寸将为 0。未实现 PnL 将为 0，由于没有开放头寸，`open_vwap`
    和 `VWAP` 属性对于双方都将为 0。实际 PnL 使用之前的 `VWAP` 属性、执行价格和 40 的头寸进行更新，所以 (93.75 - 88) *
    40 = 230。这加到之前实现的 PnL -10 上，得到最终实现的 PnL 为 220：
- en: '| **position** | **open_vwap** | **VWAP** | **PnL** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **位置** | **开盘 VWAP** | **VWAP** | **PnL** |'
- en: '| **Old** | **new** | **BUY** | **SELL** | **BUY** | **SELL** | **real** |
    **unreal** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **旧值** | **新值** | **买入** | **卖出** | **买入** | **卖出** | **实际** | **未实现** |'
- en: '| -40 | 0 | 0.0 | 0.0 | 0.0 | 0.0 | 220.0 | 0.0 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| -40 | 0 | 0.0 | 0.0 | 0.0 | 0.0 | 220.0 | 0.0 |'
- en: Now, we can move on and discuss the implementation details of this algorithm.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续讨论这个算法的实现细节。
- en: 'The first thing we must do is initialize a few local variables. Here, the `old_position`
    variable saves the `current position_` value before updating it. `side_index`
    and `opp_side_index` use the `sideToIndex()` method to find the indices in the
    `open_vwap_` array that correspond to the side of the execution and the side opposite
    to the side of execution, respectively. We must also initialize a `side_value`
    variable, which will be +1 for a buy execution and -1 for a sell execution:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是初始化几个局部变量。在这里，`old_position` 变量保存更新前的 `current position_` 值。`side_index`
    和 `opp_side_index` 使用 `sideToIndex()` 方法找到 `open_vwap_` 数组中对应执行方向和执行方向相反方向的索引。我们还必须初始化一个
    `side_value` 变量，对于买入执行将是 +1，对于卖出执行将是 -1：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we must update the `position_` variable using the quantity executed (`exec_qty_`)
    in this response and the `side_value` variable we initialized. We must also update
    the `volume_` member by adding the new execution quantity to it. When we receive
    an execution on a buy order, our position increases; conversely, when we receive
    an execution on a sell order, our position decreases. When our position is positive,
    also known as a *long position*, we profit when prices increase and make a loss
    when prices decrease. When our position is negative, also known as a *short position*,
    we profit when prices decrease and make a loss when prices increase:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须使用这个响应中的执行数量（`exec_qty_`）和我们初始化的`side_value`变量来更新`position_`变量。我们还必须通过将新的执行数量添加到其中来更新`volume_`成员。当我们收到一个买进订单的执行时，我们的头寸会增加；相反，当我们收到一个卖出订单的执行时，我们的头寸会减少。当我们的头寸为正，也就是所谓的多头头寸时，价格上涨时我们获利，价格下跌时我们亏损。当我们的头寸为负，也就是所谓的空头头寸时，价格下跌时我们获利，价格上涨时我们亏损：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next important step for us is to update the `open_vwap_` entry’s `std::array`
    variable. We will check if we were flat (position 0) before this execution and
    open a new position with this execution or if we already had an open position
    and we got an execution that increases that position. In this case, we will simply
    update the `open_vwap_` variable using `side_index` to index the correct side.
    Since `open_vwap_` tracks the product of execution prices and executed quantities
    at those prices, we can simply multiply `price_` and `exec_qty_` on this execution
    and add it to the existing sum, as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，下一个重要的步骤是更新`open_vwap_`条目的`std::array`变量。我们将检查在此执行之前我们是否处于平衡状态（头寸为0）并使用此执行开立新头寸，或者如果我们已经有一个开立的头寸并且我们得到了增加该头寸的执行。在这种情况下，我们将简单地使用`side_index`来索引正确的方向来更新`open_vwap_`变量。由于`open_vwap_`跟踪执行价格和在该价格下执行的数量乘积，我们可以简单地乘以此执行的价格和执行数量，并将其添加到现有的总和，如下所示：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we need to handle the case where we had a pre-existing open position. This
    most recent execution reduces or flattens the position. In this case, we will
    need to update the realized PnL (`real_pnl_`) using the `open_vwap_` entry for
    the side opposite to the side of execution. One thing to understand is that the
    realized PnL is only updated when an open position is reduced or closed because,
    in this case, we have bought and sold a certain quantity. Another way to think
    about this is that we can match some of the buy quantity with some of the sell
    quantity and create a pair of buy and sell trades. In this case, we have closed
    at least part of our position. In the previous case, where we either opened a
    new position or increased an already open position, we did not have a pair of
    buy and sell trades to match up, so we did not need to update the realized PnL.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要处理我们之前已经有一个未平仓头寸的情况。这次最近的执行会减少或平掉头寸。在这种情况下，我们需要使用执行方向的相反方向的`open_vwap_`条目来更新已实现PnL（`real_pnl_`）。有一点需要理解的是，只有当未平仓头寸减少或关闭时，已实现PnL才会更新，因为在这种情况下，我们已经买进和卖出了一定数量的资产。另一种思考方式是，我们可以将部分买进数量与部分卖出数量相匹配，从而创建一对买进和卖出交易。在这种情况下，我们已经平仓了至少部分头寸。在前一种情况下，即我们要么开了一个新头寸，要么增加了一个已经开头的头寸，我们没有一对买进和卖出交易可以匹配，因此我们不需要更新已实现PnL。
- en: First, we will compute an `opp_side_vwap` value, which is the average price
    of all the executions on the other side, using the `open_vwap_` entry for `opp_side_index`
    and normalize it using the absolute value of `old_position` before this execution.
    Remember that the `open_vwap_` variable is named poorly; it tracks the product
    of execution price and quantity, not just the price, so dividing it by the quantity
    represented by `old_position` yields the actual VWAP. Then, we will update the
    `open_vwap_` entry for `opp_side_index` using the product of the VWAP we computed
    in `opp_side_vwap` and the absolute value of the new `position_` value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将计算一个`opp_side_vwap`值，这是另一侧所有执行的加权平均价格，使用`open_vwap_`条目为`opp_side_index`，并使用此执行之前的`old_position`的绝对值来归一化。记住，`open_vwap_`变量命名不佳；它跟踪执行价格和数量的乘积，而不仅仅是价格，所以通过除以由`old_position`表示的数量来得到实际的VWAP。然后，我们将使用在`opp_side_vwap`中计算的VWAP和新的`position_`值的绝对值来更新`opp_side_index`的`open_vwap_`条目。
- en: 'We can update the `real_pnl_` value by finding the minimum quantity value of
    the execution quantity (`exec_qty_`) and the absolute value of `old_position`.
    We must multiply that by the difference between the current execution message’s
    price (`price_`) and `opp_side_vwap`. Finally, we need to multiply this product
    by `opp_side_value` to account for whether a profit was made (bought at a lower
    price than the sell VWAP or sold at a higher price than the buy VWAP) or a loss
    was made (bought at a higher price than the sell VWAP or sold at a lower price
    than the buy VWAP):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过找到执行数量（`exec_qty_`）的最小数量值和`old_position`的绝对值来更新`real_pnl_`值。我们必须将这个值乘以当前执行消息的价格（`price_`）和`opp_side_vwap`之间的差值。最后，我们需要将这个乘积乘以`opp_side_value`来考虑是否盈利（以低于卖出VWAP的价格买入或以高于买入VWAP的价格卖出）或亏损（以高于卖出VWAP的价格买入或以低于买入VWAP的价格卖出）：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need to handle an edge case if this execution causes the position to flip,
    meaning it goes from a long position to a short position or vice versa. This position
    flip can happen, for instance, when we have a long/positive position of a certain
    amount and we receive a sell execution of a quantity larger than that position.
    Conversely, this can happen if we have a short/negative position of a certain
    amount and we receive a buy execution of a quantity larger than that position.
    In each of these cases, we go from having a positive/long position to a negative/short
    position or go from having a negative/short position to a positive/long position.
    In this case, we can simply reset the `open_vwap_` value corresponding to the
    opposite side to 0 and reset the `open_vwap_` value for the side of execution
    (and thus the side of the new position) so that it’s the product of the latest
    execution price and the absolute value of our current `position_`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这次执行导致头寸翻转，即从多头头寸变为空头头寸或反之，我们需要处理一个边缘情况。这种情况可能发生在，例如，我们持有一定数量的多头/正值头寸，并收到一个数量大于该头寸的卖出执行。相反，这也可能发生在我们持有一定数量的空头/负值头寸，并收到一个数量大于该头寸的买入执行。在这些情况中，我们从一个正/多头头寸变为负/空头头寸，或者从一个负/空头头寸变为正/多头头寸。在这种情况下，我们可以简单地重置对应于相反侧的`open_vwap_`值为0，并重置执行侧（以及因此新头寸侧）的`open_vwap_`值，使其成为最新执行价格和当前`position_`绝对值的乘积：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we will wrap up the `PositionInfo::addFill()` method by updating the
    unrealized PnL (`unreal_pnl_`) value. The case where we are now flat (`position_
    == 0`) is straightforward – we reset the `open_vwap_` variable for both sides
    and set `unreal_pnl_` to 0 since no open position implies no `unreal_pnl_`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过更新未实现损益（`unreal_pnl_`）值来结束`PositionInfo::addFill()`方法的封装。我们现在处于平衡状态（`position_
    == 0`）的情况很简单——我们重置两边的`open_vwap_`变量并将`unreal_pnl_`设置为0，因为没有开放头寸意味着没有`unreal_pnl_`：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we still have an open `position_` after this execution, then we can compute
    the `unreal_pnl_` value that was obtained by multiplying the absolute value of
    `position_` with the difference between the execution price from the current execution
    and the VWAP computed from the `open_vwap_` entry for the `position_` side:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在此执行后我们仍然有一个开放的`position_`，那么我们可以通过将`position_`的绝对值乘以当前执行价格与从`position_`侧的`open_vwap_`条目计算出的VWAP之间的差值来计算`unreal_pnl_`值：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, `total_pnl_` is just the summation of `real_pnl_` and `unreal_pnl_`,
    as explained previously:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`total_pnl_`只是`real_pnl_`和`unreal_pnl_`的总和，如前所述：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The final piece of functionality we need to add to `PositionInfo` is for handling
    changes in market prices and updating the unrealized PnL for any open position.
    We will investigate this functionality in the next subsection.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加到`PositionInfo`中的最后一块功能是处理市场价格的变动以及更新任何开放头寸的未实现损益（PnL）。我们将在下一小节中探讨这个功能。
- en: Handling order book changes in PositionInfo
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理`PositionInfo`中的订单簿变动
- en: 'When there are market updates that cause changes in the order book we build,
    we need to update the unrealized and total PnL values. The `PositionInfo::updateBBO()`
    method is called by the `PositionKeeper` class for the trading instrument, which
    receives a market update. This, in turn, leads to an order book change. We provide
    the `BBO` object that corresponds to the trading instrument that was updated in
    the `updateBBO()` method. We save the `bbo` argument provided in this method in
    the `bbo_` data member in our `PositionInfo` struct. This method only has anything
    to do if `position_` is non-zero and the bid and ask price values on the BBO provided
    are valid. This is the first thing we will check for:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当市场更新导致我们构建的订单簿发生变化时，我们需要更新未实现和总盈亏（PnL）值。`PositionInfo::updateBBO()` 方法由 `PositionKeeper`
    类在收到市场更新时调用，这会导致订单簿发生变化。我们提供与更新过的交易工具对应的 `BBO` 对象，在 `updateBBO()` 方法中。我们将此方法中提供的
    `bbo` 参数保存在我们的 `PositionInfo` 结构体中的 `bbo_` 数据成员中。此方法仅在 `position_` 不为零且提供的 BBO
    上的要价和卖价有效时才有意义。这是我们首先需要检查的事项：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we need to update the unrealized PnL, we can use the mid-price of the BBO
    prices, which we can compute and save in the `mid_price` variable, as shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要更新未实现 PnL，我们可以使用 BBO 价格的中值，我们可以计算并保存在 `mid_price` 变量中，如下所示：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After that, we can update `unreal_pnl_` using the same logic that we saw in
    the previous subsection, except that we use the `mid_price` value instead of an
    execution price. Let’s explain why we update the unrealized PnL even though we
    do not have additional executions. Let’s say we have a long position from an execution
    at a hypothetical price of 100\. At this point, the initial unrealized PnL is
    0\. Let’s also assume that, in the future, the market prices (represented by our
    `mid_price` variable) go up to 110\. In that case, our realized PnL has not changed
    because we have not executed any sell orders. However, our unrealized PnL increases
    because if we decide to liquidate our long position, we would get executions at
    a price roughly equal to `mid_price`. This is why we update the unrealized PnL
    when market prices change, even though no additional orders have been executed.
    Also, note that the realized PnL captures the PnL of pairs of buy and sell executions,
    so that does not need to be updated here since there were no additional executions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用之前子节中看到的相同逻辑来更新 `unreal_pnl_`，只是我们使用 `mid_price` 值而不是执行价格。让我们解释一下为什么即使我们没有额外的执行，我们也要更新未实现
    PnL。假设我们有一个从假设价格为 100 的执行中获得的多头头寸。在这个时候，初始未实现 PnL 是 0。让我们还假设，在未来，市场价格（由我们的 `mid_price`
    变量表示）上涨到 110。在这种情况下，我们的实现 PnL 没有改变，因为我们没有执行任何卖出订单。然而，我们的未实现 PnL 增加了，因为我们如果决定平仓多头头寸，我们会以大约等于
    `mid_price` 的价格获得执行。这就是为什么我们在市场价格变化时更新未实现 PnL，即使没有执行额外的订单。此外，请注意，实现 PnL 捕获买卖执行对的
    PnL，因此在这里不需要更新，因为没有额外的执行：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we must update the `total_pnl_` data member and log it if it has changed
    since the last time:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须更新 `total_pnl_` 数据成员，并在它自上次更改以来发生变化时记录它：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This concludes all the functionality we need for the `PositionInfo` struct.
    We will now shift our discussion to the `PositionKeeper` class, which we will
    use to manage the position and PnL for the entire trading engine across all trading
    instruments.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对 `PositionInfo` 结构体所需的所有功能。我们现在将讨论 `PositionKeeper` 类，我们将使用它来管理整个交易引擎中所有交易工具的头寸和
    PnL。
- en: Designing PositionKeeper
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计 PositionKeeper
- en: 'The `PositionKeeper` class manages the position and PnL across all trading
    instruments in the trading engine. The `PositionKeeper` class contains a `std::array`
    of `PositionInfo` objects and is large enough to accommodate `ME_MAX_TICKERS`
    number of objects:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`PositionKeeper` 类管理交易引擎中所有交易工具的头寸和 PnL。`PositionKeeper` 类包含一个 `std::array`
    的 `PositionInfo` 对象，并且足够大，可以容纳 `ME_MAX_TICKERS` 数量的对象：'
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will add a getter method to fetch and return the `PositionInfo` instance
    for a provided `TickerId` called `getPositionInfo()`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个获取并返回提供 `TickerId` 的 `PositionInfo` 实例的获取器方法 `getPositionInfo()`：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will also add a simple `toString()` method, which we will use for logging
    purposes later:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个简单的 `toString()` 方法，我们将在稍后用于日志记录：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Initializing an object of this class is straightforward and something we will
    discuss next.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化此类对象很简单，我们将在下一节中讨论。
- en: Initializing PositionKeeper
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化 PositionKeeper
- en: 'The `PositionKeeper` constructor accepts a `Logger` object and initializes
    the `logger_` data member with that argument, as shown here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`PositionKeeper` 构造函数接受一个 `Logger` 对象，并用该参数初始化 `logger_` 数据成员，如下所示：'
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Next, we will see how order executions and changes to `BBO` are handled in the
    `PositionKeeper` class and forwarded to the correct `PositionInfo` object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何在 `PositionKeeper` 类中处理订单执行和 `BBO` 的变化，并将其转发到正确的 `PositionInfo` 对象。
- en: Handling order executions and market updates in PositionKeeper
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 `PositionKeeper` 中处理订单执行和市场更新
- en: 'The `PositionKeeper::addFill()` method handles order executions and its implementation
    is straightforward. It simply calls the `PositionInfo::addFill()` method on the
    correct `PositionInfo` object for that `TickerId`, as shown here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`PositionKeeper::addFill()` 方法处理订单执行，其实现很简单。它只是简单地调用正确的 `PositionInfo::addFill()`
    方法在 `TickerId` 的 `PositionInfo` 对象上，如下所示：'
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `PositionKeeper::updateBBO()` method handles changes in `BBO` due to market
    updates and corresponding changes in the order book. It also simply calls the
    `PositionInfo::updateBBO()` method on the correct `PositionInfo` object for `TickerId`,
    as shown here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`PositionKeeper::updateBBO()` 方法处理由于市场更新和订单簿中相应的变化而导致的 `BBO` 变化。它还简单地调用正确的
    `PositionInfo::updateBBO()` 方法在 `TickerId` 的 `PositionInfo` 对象上，如下所示：'
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That concludes the design and implementation of everything we need in our `PositionKeeper`
    class. In the next section, we will build an order manager class, which will be
    used by the trading strategies to manage their orders at a higher level.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们 `PositionKeeper` 类中所需的所有设计和实现。在下一节中，我们将构建一个订单管理类，该类将被交易策略用于在更高层次上管理它们的订单。
- en: Sending and managing orders
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送和管理订单
- en: In *Chapter*, *Designing Our Trading Ecosystem*, we discussed the purpose of
    the trading system’s order manager component (the *Designing a framework for low-latency
    C++ trading algorithms* section). In this section, we will implement an `OrderManager`
    class to encapsulate the order management logic inside this class and thus make
    it easy for trading strategies to manage their orders. Before we build the `OrderManager`
    class itself, we will need to define a basic building block called the `OMOrder`
    structure.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第* 章 *设计我们的交易生态系统* 中，我们讨论了交易系统订单管理组件（*设计低延迟C++交易算法框架* 部分）的目的。在本节中，我们将实现一个
    `OrderManager` 类来封装这个类内部的订单管理逻辑，从而使交易策略能够轻松管理它们的订单。在我们构建 `OrderManager` 类本身之前，我们需要定义一个基本构建块，称为
    `OMOrder` 结构。
- en: Defining the OMOrder struct and its related types
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 OMOrder 结构及其相关类型
- en: In this first subsection, we will define some enumerations and types to be used
    in the `OrderManager` class and its sub-components. All the source code for this
    subsection is in the `Chapter9/trading/strategy/om_order.h` source file on GitHub.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一小节中，我们将定义一些将在 `OrderManager` 类及其子组件中使用的枚举和类型。本小节的所有源代码都在 GitHub 上的 `Chapter9/trading/strategy/om_order.h`
    源文件中。
- en: 'First, we must provide the `include` files that the `om_order.h` file needs:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须提供 `om_order.h` 文件所需的 `include` 文件：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we must declare an `OMOrderState` enumeration, which will be used to track
    the state of a strategy order (`OMOrder`) in the order manager. These states represent
    the state of an `OMOrder`, as described here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须声明一个 `OMOrderState` 枚举，它将用于跟踪订单管理器中策略订单（`OMOrder`）的状态。这些状态代表 `OMOrder`
    的状态，如下所述：
- en: The `INVALID` state represents an invalid order state
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INVALID` 状态表示无效的订单状态。'
- en: The `PENDING_NEW` state signifies that a new order has been sent out by `OrderManager`
    but it has not been accepted by the electronic trading exchange yet
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PENDING_NEW` 状态表示由 `OrderManager` 发送的新订单尚未被电子交易交易所接受。'
- en: When we receive a response from the exchange to signify acceptance, the order
    goes from `PENDING_NEW` to `LIVE`
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们收到交易所的响应以表示接受时，订单从 `PENDING_NEW` 状态变为 `LIVE` 状态。
- en: Like `PENDING_NEW`, the `PENDING_CANCEL` state represents the state of an order
    when a cancellation for an order has been sent to the exchange but has not been
    processed by the exchange or the response has not been received back
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 `PENDING_NEW` 状态类似，`PENDING_CANCEL` 状态表示订单已被发送至交易所进行取消，但交易所尚未处理或尚未收到响应。
- en: 'The `DEAD` state represents an order that does not exist – it has either not
    been sent yet or fully executed or successfully cancelled:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEAD` 状态表示不存在的订单——它可能尚未发送或已完全执行或成功取消：'
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We must also add a method for converting `OMOrderState` enumerations into strings
    for logging purposes, as shown here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须添加一个方法，将`OMOrderState`枚举转换为字符串，用于日志记录，如下所示：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we can define the `OMOrder` structure, which has the following key fields:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义`OMOrder`结构，它具有以下关键字段：
- en: A `ticker_id_` variable of the `TickerId` type to represent which trading instrument
    this order is for
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ticker_id_`变量，其类型为`TickerId`，用于表示此订单是为哪个交易工具
- en: An `order_id_` variable of the `OrderId` type, which is the unique order ID
    that’s been assigned to this order object
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`order_id_`变量，其类型为`OrderId`，这是分配给此订单对象的唯一订单ID
- en: A `side_` variable to hold the `Side` property of this order
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`side_`变量，用于存储此订单的`Side`属性
- en: The order’s `Price` is held in the `price_` data member
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单的`Price`存储在`price_`数据成员中
- en: The live or requested `Qty` for this order is saved in the `qty_` variable
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此订单的实时或请求的`Qty`存储在`qty_`变量中
- en: 'An `order_state_` variable of the `OMOrderState` type, which we defined previously,
    to represent the current state of `OMOrder`:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`order_state_`变量，其类型为`OMOrderState`，这是我们之前定义的，用于表示`OMOrder`的当前状态：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We must also add a `toString()` method to stringify `OMOrder` objects for logging
    purposes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须添加一个`toString()`方法，将`OMOrder`对象转换为字符串，用于日志记录：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we define an `OMOrderSideHashMap` typedef to represent a `std::array`
    of `OMOrder` objects and indicate that the capacity of this array is large enough
    to hold an entry for the buy side and another for the sell side. Objects of the
    `OMOrderSideHashMap` type will be indexed by the `sideToIndex(Side::BUY)` and
    `sideToIndex(Side::SELL)` indices:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义一个`OMOrderSideHashMap`类型定义，表示`OMOrder`对象的`std::array`，并指示此数组的容量足够大，可以容纳买方和卖方的条目。`OMOrderSideHashMap`类型的对象将通过`sideToIndex(Side::BUY)`和`sideToIndex(Side::SELL)`索引进行索引：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We must also define an `OMOrderTickerSideHashMap`, which is just another `std::array`
    of this `OMOrderSideHashMap` object that’s large enough to hold all trading instruments
    – that is, of `ME_MAX_TICKERS` size:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须定义一个`OMOrderTickerSideHashMap`，它只是另一个足够大的`std::array`，可以容纳所有交易工具——即`ME_MAX_TICKERS`大小：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, we can build the order manager class, which is used to manage `OMOrder`
    objects for trading strategies.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建订单管理器类，该类用于管理交易策略的`OMOrder`对象。
- en: Designing the OrderManager class
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计OrderManager类
- en: Our simplified order manager will manage `OMOrder` objects on the trading strategy’s
    behalf. To keep things simple, our `OrderManager` class will allow, at most, a
    single order on the buy side and a single order on the sell side. We will look
    at the details of this implementation in this section. All the code for the `OrderManager`
    class can be found in the `Chapter9/trading/strategy/order_manager.h` and `Chapter9/trading/strategy/order_manager.cpp`
    source files.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简化的订单管理器将代表交易策略管理`OMOrder`对象。为了保持简单，我们的`OrderManager`类将允许最多在买方和卖方各有一个订单。我们将在本节中查看此实现的详细信息。`OrderManager`类的所有代码都可以在`Chapter9/trading/strategy/order_manager.h`和`Chapter9/trading/strategy/order_manager.cpp`源文件中找到。
- en: Defining the data members in OrderManager
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义OrderManager中的数据成员
- en: 'We need to define the data members that belong within our `OrderManager` class.
    But before we do that, in the following code block, we have provided the header
    files we will need to include in the `order_manager.h` source file. We must also
    forward declare the `TradeEngine` class since we will refer to it in this class
    but want to avoid circular dependency issues:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义属于我们`OrderManager`类的数据成员。但在我们这样做之前，在下面的代码块中，我们提供了需要在`order_manager.h`源文件中包含的头文件。我们还必须声明`TradeEngine`类，因为我们将在本类中引用它，但想避免循环依赖问题：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can design the internal data members in the `OrderManager` class. The
    key members are as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`OrderManager`类中设计内部数据成员。关键成员如下：
- en: A `trade_engine_` variable. This is a pointer to a `TradeEngine` object. We
    will use this to store the parent `TradeEngine` instance that is using this order
    manager.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`trade_engine_`变量。这是一个指向`TradeEngine`对象的指针。我们将使用它来存储使用此订单管理器的父`TradeEngine`实例。
- en: A constant reference to a `RiskManager` object stored in the `risk_manager_`
    member variable. This will be used to perform *pre-trade* risk checks – that is,
    risk checks that are performed before new orders are sent out to the exchange.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在`risk_manager_`成员变量中的`RiskManager`对象的常量引用。这将用于执行*交易前*风险检查——即在新订单发送到交易所之前执行的风险检查。
- en: A `ticker_side_order_` variable of the `OMOrderTickerSideHashMap` type to hold
    a pair (a buy and a sell) of `OMOrder` objects for each trading instrument. This
    will be used as a hash map that’s indexed first by the `TickerId` value of the
    instrument we want to send an order for and then indexed by the `sideToIndex(Side::BUY)`
    or `sideToIndex(Side::SELL)` values to manage the buy or sell order.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ticker_side_order_`变量，其类型为`OMOrderTickerSideHashMap`，用于保存每个交易工具的（一个买入和一个卖出）`OMOrder`对象对。这将被用作一个哈希表，首先按我们想要发送订单的仪器的`TickerId`值索引，然后按`sideToIndex(Side::BUY)`或`sideToIndex(Side::SELL)`值索引来管理买入或卖出订单。
- en: 'New and unique order IDs starting from `1`, which we will generate using a
    simple `next_order_id_` variable of the `OrderId` type:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`1`开始的新的唯一订单ID，我们将使用简单的`next_order_id_`变量（`OrderId`类型）来生成：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: That is all the data inside the `OrderManager` class. In the next subsection,
    we will learn how to initialize these members and the `OrderManager` class itself.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是`OrderManager`类内部的所有数据。在下一小节中，我们将学习如何初始化这些成员以及`OrderManager`类本身。
- en: Initializing OrderManager
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化OrderManager
- en: 'Initializing `OrderManager` is straightforward. In addition to what we initialized
    in the class definition itself, we must initialize the `trade_engine_`, `risk_manager_`
    and `logger_` data members, which we expect to be passed through the constructor
    arguments:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化`OrderManager`很简单。除了在类定义本身中初始化的内容外，我们还必须初始化`trade_engine_`、`risk_manager_`和`logger_`数据成员，我们期望它们通过构造函数参数传递：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As shown here, we must add a simple convenience function that we can use in
    our `OrderManager` implementation called `getOMOrderSideHashMap()`. This simply
    returns the `OMOrderSideHashMap` instance for the provided `TickerId`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，我们必须添加一个简单的便利函数，我们可以在我们的`OrderManager`实现中使用它，称为`getOMOrderSideHashMap()`。这个函数简单地返回提供的`TickerId`的`OMOrderSideHashMap`实例：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next, we can move on to an important task in `OrderManager` – sending new orders.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以继续到`OrderManager`中的一个重要任务——发送新订单。
- en: Sending new orders from OrderManager
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从OrderManager发送新订单
- en: 'The `OrderManager::newOrder()` method is the lower-level method in our order
    manager class. It requires a pointer to an `OMOrder` object for which this new
    order is being sent. It also needs the `TickerId`, `Price`, `Side`, and `Qty`
    attributes to be set on the new order that’s being sent out:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderManager::newOrder()`方法是我们订单管理类中的底层方法。它需要一个指向`OMOrder`对象的指针，该对象将发送这个新订单。它还需要设置新发送的订单上的`TickerId`、`Price`、`Side`和`Qty`属性：'
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It creates a `MEClientRequest` structure of the `ClientRequestType::NEW` type
    and fills in the attributes that are passed through the arguments, sets `OrderId`
    to be `next_order_id_` and `ClientId` to be the client ID of `TradeEngine`, which
    can be obtained by calling the `clientId()` method. It also calls `TradeEngine::sendClientRequest()`
    and provides the `MEClientRequest` object (`new_request`) it just initialized:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建一个`ClientRequestType::NEW`类型的`MEClientRequest`结构，并填充通过参数传递的属性，将`OrderId`设置为`next_order_id_`，将`ClientId`设置为`TradeEngine`的客户ID，这可以通过调用`clientId()`方法获得。它还调用`TradeEngine::sendClientRequest()`并提供它刚刚初始化的`MEClientRequest`对象（`new_request`）：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, it updates the `OMOrder` object pointer it was provided in the method
    parameters and assigns it the attributes that were just set on the new order that
    was sent out. Note that the state of this `OMOrder` is set to `OMOrderState::PENDING_NEW`
    since it will be sent out shortly but will not be active until the exchange accepts
    it and we receive that response. It also increments the `next_order_id_` variable
    to maintain uniqueness on any new orders that might be sent out later:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它更新在方法参数中提供的`OMOrder`对象指针，并将新发送的订单上设置的属性分配给它。请注意，此`OMOrder`的状态被设置为`OMOrderState::PENDING_NEW`，因为它将很快被发送出去，但只有在交易所接受它并且我们收到响应后才会生效。它还增加`next_order_id_`变量以保持任何可能稍后发送的新订单的唯一性：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We will see where this `newOrder()` method gets called from shortly, but before
    that, let’s look at the complementary task of cancelling orders.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快看到`newOrder()`方法是从哪里被调用的，但在那之前，让我们看看取消订单的互补任务。
- en: Cancelling orders from OrderManager
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消来自OrderManager的订单
- en: '`OrderManager::cancelOrder()` is the lower-level method in our order manager
    class and will be used to send a cancel request for live orders being managed
    by `OrderManager`. It only accepts a single parameter, which is the `OMOrder`
    object for which it is going to send the cancel request:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderManager::cancelOrder()`是我们订单管理类中的底层方法，它将被用来向由`OrderManager`管理的实时订单发送取消请求。它只接受一个参数，即将要发送取消请求的`OMOrder`对象：'
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Like the `newOrder()` method, we must initialize an `MEClientRequest` `client_request`
    object of the `ClientRequestType::CANCEL` type and populate the attributes in
    it from the `OMOrder` object that was passed into the method. It calls the `TradeEngine::sendClientRequest()`
    method to send the cancel request out. One thing to understand is that the `next_order_id_`
    member variable is only used for generating new order IDs for new outgoing order
    requests. Cancelling an existing order does not change the `next_order_id_` variable,
    as shown in the following code block. In our design, `next_order_id_` keeps incrementing
    sequentially each time we send an `MEClientRequest` of the `ClientRequestType::NEW`
    type. Theoretically, we could reuse the `order_id_` value from the order we just
    cancelled on the next new order request, but that would require us to track the
    free order IDs, which is not too difficult either. This was just a design choice
    we made, but feel free to modify this scheme and track free order IDs if you wish:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `newOrder()` 方法类似，我们必须初始化一个 `MEClientRequest` 类型的 `client_request` 对象，并将其属性从传递到方法中的
    `OMOrder` 对象中填充。它调用 `TradeEngine::sendClientRequest()` 方法来发送取消请求。需要理解的一点是，`next_order_id_`
    成员变量仅用于为新出订单请求生成新的订单 ID。取消现有订单不会改变 `next_order_id_` 变量，如下面的代码块所示。在我们的设计中，`next_order_id_`
    在每次我们发送 `ClientRequestType::NEW` 类型的 `MEClientRequest` 时都会顺序递增。理论上，我们可以在下一个新订单请求中重用刚刚取消的订单的
    `order_id_` 值，但这需要我们跟踪空闲订单 ID，这也不是特别困难。这只是我们做出的一个设计选择，但如果你愿意，可以修改这个方案并跟踪空闲订单 ID：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we must update the `order_state_` value of the `OMOrder` object to
    `OMOrderState::PENDING_CANCEL` to represent the fact that a cancel request has
    been sent out:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须更新 `OMOrder` 对象的 `order_state_` 值为 `OMOrderState::PENDING_CANCEL`，以表示已发送取消请求：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Previously, we mentioned that `newOrder()` and `cancelOrder()` are lower-level
    methods in the `OrderManager` class. Trading strategies that use `OrderManager`
    will not call these methods directly; instead, they will have `OrderManager` manage
    the orders by calling the `OrderManager::moveOrders()` method. We will build this
    in the next subsection.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到，`newOrder()` 和 `cancelOrder()` 是 `OrderManager` 类中的低级方法。使用 `OrderManager`
    的交易策略不会直接调用这些方法；相反，它们将通过调用 `OrderManager::moveOrders()` 方法让 `OrderManager` 来管理订单。我们将在下一小节中构建这个方法。
- en: Adding methods to simplify order management
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加方法以简化订单管理
- en: 'Before we build the `moveOrders()` method, we will build one more lower-level
    method that’s used by `OrderManager`. This method, called `moveOrder()`, manages
    a single order and either sends a new order or cancels an existing order, depending
    on the arguments provided to it. The most important parameter for this method
    is a pointer to an `OMOrder` object. It also accepts the `TickerId`, `Price`,
    `Side`, and `Qty` parameters. The purpose of this method is to make sure that
    the `OMOrder` object that’s passed to it is placed or replaced with the provided
    `price`, `side`, and `qty` arguments. This involves a combination of cancelling
    an existing order if it is not at the specified price and/or placing a new order
    with the `price` and `qty` parameters specified:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建 `moveOrders()` 方法之前，我们将构建一个更多用于 `OrderManager` 的低级方法。这个方法称为 `moveOrder()`，它管理单个订单，根据提供的参数发送新订单或取消现有订单。这个方法最重要的参数是一个指向
    `OMOrder` 对象的指针。它还接受 `TickerId`、`Price`、`Side` 和 `Qty` 参数。这个方法的目的确保传递给它的 `OMOrder`
    对象被放置或替换为提供的 `price`、`side` 和 `qty` 参数。这涉及到取消现有订单（如果它不是指定的价格）和/或使用指定的 `price`
    和 `qty` 参数放置新订单的组合：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The action this method decides to take depends on the current `order_state_`
    of the `OMOrder` object passed to it. We will go through the different `OMOrderState`
    cases one by one, starting with `OMOrderState::LIVE`. If the `OMOrder` object
    is already live/active, it checks to make sure that the `price` parameter matches
    the order’s `price_` attribute. If that is not the case, then it calls the `OrderManager::cancelOrder()`
    method to cancel this order and replaces it in the next iteration:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法决定采取的操作取决于传递给它的 `OMOrder` 对象的当前 `order_state_`。我们将逐个通过不同的 `OMOrderState`
    情况，从 `OMOrderState::LIVE` 开始。如果 `OMOrder` 对象已经是活跃的/有效的，它会检查 `price` 参数是否与订单的 `price_`
    属性匹配。如果不是这种情况，它将调用 `OrderManager::cancelOrder()` 方法来取消这个订单，并在下一次迭代中替换它：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For cases where the order is in an `INVALID` or `DEAD` state, which means not
    active in the market, we will place the order using the `OrderManager::newOrder()`
    method we built previously. But it needs to check with `RiskManager` whether this
    action is allowed by calling the `RiskManager::checkPreTradeRisk()` method and
    passing it the `TickerId`, `Side` and `Qty` attributes of the order we would like
    to send. At this point, it should be clear why this is called pre-trade risk –
    we check if we can perform the action/trade before we do it. We will discuss the
    design and implementation of `RiskManager`, as well as the `checkPreTradeRisk()`
    method, shortly. For now, all you need to know is that it returns a `RiskCheckResult`
    enumeration value of `RiskCheckResult::ALLOWED` if the risk checks pass and a
    different value if the risk checks fail – that is, the action/trade is not allowed.
    In the following code block, we only send the order by calling the `newOrder()`
    method if the `checkPreTradeRisk()` method returns `RiskCheckResult::ALLOWED`.
    As a final note, here, we log an error message if the risk check fails using the
    `riskCheckResultToString()` method. We will cover this shortly:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于订单处于`INVALID`或`DEAD`状态的情况，这意味着在市场上不活跃，我们将使用我们之前构建的`OrderManager::newOrder()`方法来放置订单。但需要通过调用`RiskManager::checkPreTradeRisk()`方法并与`RiskManager`确认此操作是否允许，并将我们希望发送的订单的`TickerId`、`Side`和`Qty`属性传递给它。此时，应该清楚为什么这被称为预交易风险——我们在执行操作/交易之前检查我们是否可以执行此操作。我们将很快讨论`RiskManager`的设计和实现，以及`checkPreTradeRisk()`方法。目前，你需要知道的是，如果风险检查通过，它返回`RiskCheckResult::ALLOWED`枚举值，如果风险检查失败，则返回不同的值——也就是说，操作/交易是不允许的。在下面的代码块中，我们只有在`checkPreTradeRisk()`方法返回`RiskCheckResult::ALLOWED`时才通过调用`newOrder()`方法发送订单。最后，这里我们使用`riskCheckResultToString()`方法记录一个错误消息，如果风险检查失败。我们很快就会介绍这一点：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For the cases where the `OMOrder` object’s `order_state_` is `PENDING_NEW`
    or `PENDING_CANCEL`, we do nothing since we are waiting for a response from the
    electronic trading exchange before we can proceed:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`OMOrder`对象的`order_state_`为`PENDING_NEW`或`PENDING_CANCEL`的情况，我们什么都不做，因为我们正在等待电子交易交换的响应，然后才能继续操作：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, we have all the pieces we need to build our `OrderManager::moveOrders()`
    method. This is the primary method that’s used by trading strategies to generate
    and manage the orders it needs. It accepts a few parameters – the `TickerId` parameter
    of the instrument, the `Price` parameter’s `bid_price` for the buy order, the
    `Price` parameter’s `ask_price` for the sell order, and a `clip` parameter of
    the `Qty` type, which will be the quantity of the buy and sell orders. We will
    see where this `clip` parameter comes from in the *Defining the TradeEngineCfg
    structure* subsection, in the *Computing and managing risk* section. For now,
    note that the term `clip` comes from the term clip for ammunition for firearms,
    and in the context of our trading strategies, it means the size of each order
    that our trading strategy can send. We will see that this parameter gets used
    to set the size of outgoing new order requests. This is just the name of the variable
    we chose; it could also be `trade_size`, `order_size`, and so on.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经拥有了构建`OrderManager::moveOrders()`方法所需的所有组件。这是交易策略用来生成和管理所需订单的主要方法。它接受一些参数——工具的`TickerId`参数，购买订单的`Price`参数的`bid_price`，卖出订单的`Price`参数的`ask_price`，以及一个`Qty`类型的`clip`参数，这将代表购买和卖出订单的数量。我们将在*定义TradeEngineCfg结构*小节中看到这个`clip`参数的来源，在*计算和管理风险*部分。目前，请注意，术语`clip`来自枪械弹药的`clip`术语，在我们的交易策略的上下文中，它表示我们的交易策略可以发送的每个订单的大小。我们将看到这个参数被用来设置新订单请求的大小。这只是我们选择的变量名称；它也可以是`trade_size`、`order_size`等等。
- en: 'One thing to note here is that passing a price value of `Price_INVALID` for
    `bid_price` or `ask_price` will cause the order to be cancelled – that is, it
    will only have an order on the buy side or the sell side instead of both. This
    is because the `moveOrder()` method cancels an order if the price on `OMOrder`
    does not match the price passed to the method. And because any `OMOrder` that
    is active in the market (`OMOrderState::LIVE`) will have a valid price other than
    `Price_INVALID`, that check evaluates to true and causes the order to be cancelled.
    One more thing to note here is that, currently, we support a single `clip` value
    for both the buy and sell orders, but it is easy to extend this so that we have
    different quantities for the buy order and the sell order. The implementation
    of this method is extremely simple – it fetches the buy order (`bid_order`) by
    indexing the `ticker_side_order_` container with the `ticker_id` value and indexing
    that with the `sideToIndex(Side::BUY)` value. It then calls the `OrderManager::moveOrder()`
    method on this `bid_order` and passes it the `bid_price` parameter for the price
    and passes it the `clip` parameter for the quantity. We do the same thing for
    the sell order (`ask_order`), except we use `sideToIndex(Side::SELL)` and `ask_price`
    for the sell side:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的是，如果为 `bid_price` 或 `ask_price` 传递 `Price_INVALID` 的价格值，将会导致订单被取消——也就是说，订单将只在买方或卖方一侧存在，而不是在两侧都存在。这是因为
    `moveOrder()` 方法会在 `OMOrder` 上的价格与传递给方法的价格不匹配时取消订单。并且因为任何在市场中的活跃 `OMOrder` (`OMOrderState::LIVE`)
    都将有一个有效的价格，而不是 `Price_INVALID`，这个检查将评估为真，从而导致订单被取消。还有一点需要注意，目前，我们支持买方和卖方订单的单个
    `clip` 值，但很容易扩展以使买方订单和卖方订单有不同的数量。此方法的实现非常简单——通过使用 `ticker_id` 值索引 `ticker_side_order_`
    容器，并使用 `sideToIndex(Side::BUY)` 值索引它来获取买方订单 (`bid_order`)。然后，它在这个 `bid_order`
    上调用 `OrderManager::moveOrder()` 方法，并传递 `bid_price` 参数作为价格，传递 `clip` 参数作为数量。对于卖方订单
    (`ask_order`)，我们做同样的事情，除了使用 `sideToIndex(Side::SELL)` 和 `ask_price` 作为卖方侧：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We need to add one final functionality to our `OrderManager` class, which is
    handling incoming order responses. We will tackle this in the next subsection.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向我们的 `OrderManager` 类添加一个最终的功能，即处理传入的订单响应。我们将在下一个子节中处理这个问题。
- en: Handling order updates and updating orders
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理订单更新和更新订单
- en: 'Before we can wrap up our discussion on the implementation of `OrderManager`,
    we need to add some code to handle incoming order responses in the form of `MEClientResponse`
    messages. The `OrderManager::onOrderUpdate()` method we will build here expects
    to be called and passed a `MEClientResponse` object:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以结束对 `OrderManager` 实现的讨论之前，我们需要添加一些代码来处理以 `MEClientResponse` 消息形式传入的订单响应。我们将在这里构建的
    `OrderManager::onOrderUpdate()` 方法期望被调用并传递一个 `MEClientResponse` 对象：
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'First, we must fetch the `OMOrder` object that this `MEClientResponse` message
    is meant for. We can do that by accessing the `ticker_side_order_` container using
    the `ticker_id_` field in `client_response` and converting the `side_` field in
    the `client_response` message into an index using the `sideToIndex()` method.
    This is shown in the following code block:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须获取这个 `MEClientResponse` 消息针对的 `OMOrder` 对象。我们可以通过使用 `client_response`
    中的 `ticker_id_` 字段访问 `ticker_side_order_` 容器，并通过使用 `sideToIndex()` 方法将 `client_response`
    消息中的 `side_` 字段转换为索引来实现这一点。这在上面的代码块中显示：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We will update the `OMOrder` object we fetched previously, but that depends
    on the type of `MEClientResponse` we received. In the case of `ClientResponseType::ACCEPTED`,
    all we need to do is set the `order_state_` member of this `OMOrder` object to
    `OMOrderState::LIVE` to mark it as accepted and active in the market:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新之前获取的 `OMOrder` 对象，但这取决于我们收到的 `MEClientResponse` 类型。在 `ClientResponseType::ACCEPTED`
    的情况下，我们只需要将此 `OMOrder` 对象的 `order_state_` 成员设置为 `OMOrderState::LIVE`，以将其标记为已接受并在市场上活跃：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If the type of the response is `ClientResponseType::CANCELED`, then we just
    update the `order_state_` variable of `OMOrder` to `OMOrderState::DEAD` since
    it is no longer active in the market:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应类型是 `ClientResponseType::CANCELED`，那么我们只需将 `OMOrder` 的 `order_state_` 变量更新为
    `OMOrderState::DEAD`，因为它在市场上不再活跃：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If `MEClientResponse` is of the `ClientResponseType::FILLED` type, which is
    done to denote an execution, we update the `qty_` field on `OMOrder` to be the
    new `leaves_qty_`. This reflects the live quantity that still exists in the market.
    We also need to check that if the `qty_` field (and thus the `leaves_qty_` field
    on `client_response`) is 0, meaning the order was fully executed, the order is
    no longer active in the market. If so, we must set `order_state_` to `OMOrderState::DEAD`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`MEClientResponse`是`ClientResponseType::FILLED`类型，这是为了表示执行，我们将更新`OMOrder`上的`qty_`字段为新的`leaves_qty_`。这反映了市场上仍然存在的实时数量。我们还需要检查如果`qty_`字段（以及因此`client_response`上的`leaves_qty_`字段）为0，意味着订单已完全执行，该订单在市场上不再活跃。如果是这样，我们必须将`order_state_`设置为`OMOrderState::DEAD`：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We ignore the `CANCEL_REJECTED` and `INVALID` `ClientResponseType` enumeration
    values since there is no action that we need to take:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略了`CANCEL_REJECTED`和`INVALID`的`ClientResponseType`枚举值，因为没有任何需要采取的操作：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This concludes the discussion, design, and implementation of our `OrderManager`
    component. However, we referenced and used `RiskManager` in the implementation
    of the `OrderManager` class without discussing all its details. We will do this
    in the next section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对`OrderManager`组件的讨论、设计和实现的结束。然而，我们在`OrderManager`类的实现中引用并使用了`RiskManager`，而没有讨论其所有细节。我们将在下一节中这样做。
- en: Computing and managing risk
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算和管理风险
- en: The final component we still need to build before we can build our trading strategies
    is `RiskManager`. The `RiskManager` component tracks the active order quantities
    that a trading strategy has in the market through the same `OrderManager` instance
    that a trading strategy uses. It also tracks the positions and realized and unrealized
    PnLs using the `PositionKeeper` instance, which tracks the trading strategy’s
    positions and PnLs. It checks that the strategy stays within its assigned risk
    limits. If the trading strategy goes past its risk limits, such as if it loses
    more money than it’s allowed, tries to send an order larger than it’s allowed,
    or builds a position larger than it’s allowed, it prevents it from trading. To
    keep our `RiskManager` simple, we will only implement risk checks on the maximum
    allowed order size, the maximum allowed position, and the maximum allowed loss
    for each trading instrument in the client’s trading system. The source code for
    our `RiskManager` can be found in the `Chapter9/trading/strategy/risk_manager.h`
    and `Chapter9/trading/strategy/risk_manager.cpp` source files. First, we will
    declare an enumeration and a `RiskInfo` struct. We discussed the details of this
    component in *Chapter*, *Designing Our Trading Ecosystem*, in the *Designing a
    framework for low-latency C++ trading* *algorithms* section.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以构建我们的交易策略之前，我们还需要构建的最终组件是`RiskManager`。`RiskManager`组件通过交易策略使用的相同`OrderManager`实例跟踪交易策略在市场上的活跃订单数量。它还使用`PositionKeeper`实例跟踪头寸和已实现和未实现的盈亏，该实例跟踪交易策略的头寸和盈亏。它检查策略是否保持在分配的风险限制内。如果交易策略超过了其风险限制，例如，如果它损失的钱超过了允许的金额，试图发送超过允许的订单，或者构建超过允许的仓位，它将阻止其交易。为了使我们的`RiskManager`保持简单，我们将在客户端交易系统中对每个交易工具的最大允许订单大小、最大允许仓位和最大允许损失实现风险检查。我们的`RiskManager`的源代码可以在`Chapter9/trading/strategy/risk_manager.h`和`Chapter9/trading/strategy/risk_manager.cpp`源文件中找到。首先，我们将声明一个枚举和一个`RiskInfo`结构体。我们在*第*章*设计我们的交易生态系统*中的*设计低延迟C++交易算法框架*部分讨论了该组件的详细信息。
- en: Defining the RiskCfg structure
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义RiskCfg结构体
- en: 'First, we will define a structure that holds risk configurations. This is called
    the `RiskCfg` struct and is defined in the `Chapter9/common/types.h` header file.
    The risk configuration holds the following parameters:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个包含风险配置的结构体。这被称为`RiskCfg`结构体，并在`Chapter9/common/types.h`头文件中定义。风险配置包含以下参数：
- en: A `max_order_size_` member of the `Qty` type. It represents the maximum allowed
    order size that a strategy is allowed to send.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qty`类型的`max_order_size_`成员。它表示策略允许发送的最大允许订单大小。'
- en: A `max_position_` member variable of the `Qty` type. This represents the maximum
    position that a strategy is allowed to build.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qty`类型的`max_position_`成员变量。它表示策略允许构建的最大仓位。'
- en: A `max_loss_` variable of the `double` type. This is the maximum allowed loss
    before the trading strategy is shut off from trading further.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`类型的`max_loss_`变量。这是在交易策略被关闭以进一步交易之前允许的最大损失。'
- en: 'We must also add a `toString()` method to the structure for logging purposes:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须为结构体添加一个`toString()`方法，以便进行日志记录：
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We will define another configuration structure in the next section. This structure
    will be used to configure `TradeEngine`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将定义另一个配置结构。这个结构将用于配置 `TradeEngine`。
- en: Defining the TradeEngineCfg structure
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 TradeEngineCfg 结构
- en: 'First, we must define a structure to encapsulate `TradeEngine` configurations.
    We will call it `TradeEngineCfg`. This is what we use as the higher-level `TradeEngine`
    configuration and is defined in the `Chapter9/common/types.h` header file. It
    has the following important data members:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须定义一个结构来封装 `TradeEngine` 配置。我们将称之为 `TradeEngineCfg`。这是我们用作高级 `TradeEngine`
    配置的内容，并在 `Chapter9/common/types.h` 头文件中定义。它有以下重要的数据成员：
- en: A `clip_` member of the `Qty` type. This is what the trading strategies will
    use as the quantity of the orders that they send out.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Qty` 类型的 `clip_` 成员。这是交易策略将用作它们发送的订单数量的。'
- en: A `threshold_` member of the `double` type. This will be used by the trading
    strategies and will be used against the feature values to decide if a trading
    decision needs to be made or not.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double` 类型的 `threshold_` 成员。这将由交易策略使用，并将用于特征值，以决定是否需要做出交易决策。'
- en: The final member is a `risk_cfg_` variable of the `RiskCfg` type. We defined
    this previously so that it can hold the risk configuration.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个成员是一个 `RiskCfg` 类型的 `risk_cfg_` 变量。我们之前定义了这个变量，以便它可以保存风险配置。
- en: 'As usual, we must also define a `toString()` method to convert these objects
    into strings for logging purposes. All the code described here can be seen in
    the following code block:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们还必须定义一个 `toString()` 方法，将这些对象转换为字符串以便进行日志记录。这里描述的所有代码都可以在以下代码块中看到：
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `TradeEngineCfgHashMap` type we are defining here is a `std::array` of
    these `TradeEngineCfg` objects and is large enough to hold all possible `TickerId`
    values (`ME_MAX_TICKERS`):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义的 `TradeEngineCfgHashMap` 类型是一个 `std::array`，包含这些 `TradeEngineCfg` 对象，并且足够大，可以容纳所有可能的
    `TickerId` 值 (`ME_MAX_TICKERS`)：
- en: '[PRE59]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, we need to define a type to represent the outcome of risk checks – the
    `RiskCheckResult` enumeration.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要定义一个类型来表示风险检查的结果——`RiskCheckResult` 枚举。
- en: Declaring the RiskCheckResult enumeration
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明 RiskCheckResult 枚举
- en: 'First, we will formally declare the `RiskCheckResult` enumeration we encountered
    before. But before we do that, let’s look at the `include` files we need in the
    `risk_manager.h` header file. We will also need to forward declare the `OrderManager`
    class we built before so that we can use it without running into circular header
    dependency issues:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将正式声明之前遇到的 `RiskCheckResult` 枚举。但在我们这样做之前，让我们看看在 `risk_manager.h` 头文件中我们需要包含的文件。我们还需要提前声明之前构建的
    `OrderManager` 类，这样我们就可以使用它而不会遇到循环头文件依赖问题：
- en: '[PRE60]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `RiskCheckResult` enumeration is used to encapsulate information about
    the outcome of a risk check in `RiskManager`. Let’s look at these values in more
    detail:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`RiskCheckResult` 枚举用于封装 `RiskManager` 中风险检查结果的信息。让我们更详细地看看这些值：'
- en: '`INVALID` represents an invalid sentinel value.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INVALID` 表示一个无效的哨兵值。'
- en: '`ORDER_TOO_LARGE` means that the risk check failed because the order quantity
    that we are attempting to send would exceed the maximum allowed order quantity
    limit.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ORDER_TOO_LARGE` 表示风险检查失败，因为我们试图发送的订单数量将超过允许的最大订单数量限制。'
- en: '`POSITION_TOO_LARGE` means that the current position, plus the order quantity
    on the side we are attempting to send, would cause us to potentially exceed the
    maximum position limit that’s been configured in `RiskManager`.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POSITION_TOO_LARGE` 表示当前头寸加上我们试图发送的订单数量可能会使我们超过在 `RiskManager` 中配置的最大头寸限制。'
- en: The `LOSS_TOO_LARGE` enumeration represents the fact that the risk check failed
    because the trading strategy’s total loss (realized plus unrealized loss) is above
    what is allowed in `RiskManager`.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LOSS_TOO_LARGE` 枚举表示风险检查失败的事实，因为交易策略的总损失（已实现损失加上未实现损失）超过了在 `RiskManager` 中允许的值。'
- en: 'The `ALLOWED` enumeration is a value that represents that all risk checks passed
    successfully. As mentioned previously, this is the only value that allows the
    trading strategy to send additional orders to the exchange:'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALLOWED` 枚举是一个表示所有风险检查都成功通过的值。如前所述，这是唯一允许交易策略向交易所发送额外订单的值：'
- en: '[PRE61]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We will also add a `riskCheckResultToString()` method to convert these enumerations
    into strings for logging purposes:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个 `riskCheckResultToString()` 方法，将这些枚举转换为字符串，以便进行日志记录：
- en: '[PRE62]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the next section, we will define the basic `RiskInfo` struct, which holds
    the information we need to perform risk checks for a single trading instrument.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将定义基本的`RiskInfo`结构体，它包含我们执行单个交易工具风险检查所需的信息。
- en: Defining the RiskInfo structure
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义RiskInfo结构
- en: 'As mentioned previously, the `RiskInfo` struct holds the information needed
    to perform risk checks for a single trading instrument. The `RiskManager` class
    maintains and manages a container of `RiskInfo` objects. The `RiskInfo` struct
    needs the following important data members:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`RiskInfo`结构体包含执行单个交易工具风险检查所需的信息。`RiskManager`类维护和管理一个`RiskInfo`对象容器。`RiskInfo`结构体需要以下重要的数据成员：
- en: A `const` pointer to `PositionInfo` called `position_info_`. This will be used
    to fetch the position and PnL information for the trading instrument.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向`PositionInfo`的`const`指针`position_info_`。这将用于获取交易工具的位置和PnL信息。
- en: 'An object (`risk_cfg_`) of the `RiskCfg` type to hold the configured risk limits
    for this instrument. These are the limits that will be checked against:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`RiskCfg`类型的对象`risk_cfg_`，用于保存此工具配置的风险限制。这些限制将被检查：
- en: '[PRE63]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let’s add a `toString()` method to this class for logging purposes:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为这个类添加一个`toString()`方法，用于日志记录：
- en: '[PRE64]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, we must define a `TickerRiskInfoHashMap` type, which is a `std::array`
    of `RiskInfo` objects of `ME_MAX_TICKERS` size. We will use this as a hash map
    of `TickerId` to `RiskInfo` objects:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须定义一个`TickerRiskInfoHashMap`类型，它是一个大小为`ME_MAX_TICKERS`的`RiskInfo`对象`std::array`。我们将使用它作为`TickerId`到`RiskInfo`对象的哈希表：
- en: '[PRE65]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Next, we will look at the implementation of the `checkPreTradeRisk()` method,
    which performs the actual risk checks.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看`checkPreTradeRisk()`方法的实现，该方法执行实际的风险检查。
- en: Performing risk checks in RiskInfo
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在RiskInfo中执行风险检查
- en: 'The `checkPreTradeRisk()` method accepts a `Side` argument and a `Qty` argument
    and returns a `RiskCheckResult` enumeration value, depending on whether the risk
    check passes or fails for some reason:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkPreTradeRisk()`方法接受一个`Side`参数和一个`Qty`参数，并根据风险检查是否因某些原因通过或失败返回一个`RiskCheckResult`枚举值：'
- en: '[PRE66]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'First, it checks if the `qty` argument that’s passed to the method is larger
    than the `max_order_size_` member in the `RiskCfg` object (`risk_cfg_`). If this
    is the case, the risk check fails, and it returns the `RiskCheckResult::ORDER_TOO_LARGE`
    enumeration:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它检查传递给方法的`qty`参数是否大于`RiskCfg`对象（`risk_cfg_`）中的`max_order_size_`成员。如果是这种情况，风险检查失败，并返回`RiskCheckResult::ORDER_TOO_LARGE`枚举值：
- en: '[PRE67]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, it checks if the current `position_` (which it fetches from the `position_info_`
    data member), plus the additional `qty` we want to send, exceeds the maximum allowed
    `max_position_ limit` in the `RiskCfg` object (`risk_cfg_`). Note that it uses
    the `sideToValue(side)` method here to correctly compute what the position could
    be if this new `qty` were to be executed and then uses the `std::abs()` method
    to correctly compare against the `max_position_` parameter. In the case of a failure,
    it signifies the error by returning the `RiskCheckResult::POSITION_TOO_LARGE`
    method:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它检查当前`position_`（它从`position_info_`数据成员中获取），加上我们想要发送的额外`qty`，是否超过了`RiskCfg`对象（`risk_cfg_`）中允许的最大`max_position_`限制。注意，它在这里使用`sideToValue(side)`方法来正确计算如果执行这个新的`qty`，位置可能是什么，然后使用`std::abs()`方法来正确地与`max_position_`参数进行比较。在失败的情况下，它通过返回`RiskCheckResult::POSITION_TOO_LARGE`方法来表示错误：
- en: '[PRE68]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, it checks the last risk metric in our `RiskManager`, which is the
    total loss. It checks `total_pnl_` from `position_info_` against the `max_loss_`
    parameter in the `risk_cfg_` configuration. If the loss exceeds the max loss allowed,
    it returns a `RiskCheckResult::LOSS_TOO_LARGE` enumeration value:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它检查我们`RiskManager`中的最后一个风险指标，即总损失。它将`position_info_`中的`total_pnl_`与`risk_cfg_`配置中的`max_loss_`参数进行比较。如果损失超过允许的最大损失，它将返回一个`RiskCheckResult::LOSS_TOO_LARGE`枚举值：
- en: '[PRE69]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, if all the risk checks pass successfully, it returns the `RiskCheckResult::ALLOWED`
    value:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果所有风险检查都成功通过，它将返回`RiskCheckResult::ALLOWED`值：
- en: '[PRE70]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This important method concludes the design and implementation of the `RiskInfo`
    struct. Now, we can start building the `RiskManager` class, which is used by the
    other components we covered.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重要的方法完成了`RiskInfo`结构体的设计和实现。现在，我们可以开始构建`RiskManager`类，该类被我们之前提到的其他组件使用。
- en: Designing the data members in RiskManager
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计RiskManager中的数据成员
- en: 'Now, we will design our `RiskManager`, starting by defining the data members
    that make up this class. The key member is a `ticker_risk_` variable of the `TickerRiskInfoHashMap`
    type and holds `RiskInfo` objects. We defined this previously:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将设计我们的`RiskManager`，首先定义构成这个类的数据成员。关键成员是一个`ticker_risk_`变量，其类型为`TickerRiskInfoHashMap`，并持有`RiskInfo`对象。我们之前已经定义了它：
- en: '[PRE71]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Next, we will learn how to initialize the `RiskManager` class.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何初始化`RiskManager`类。
- en: Initializing our RiskManager class
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化我们的`RiskManager`类
- en: 'The `RiskManager` constructor expects a `Logger` object, a pointer to a `PositionKeeper`
    object, and a reference to an object of the `TradeEngineCfgHashMap` type (`ticker_cfg`)
    that holds the risk configurations. It initializes the `logger_` member variable
    and stores the `PositionInfo` objects from the `PositionKeeper` (`getPositionInfo()`)
    and `RiskCfg` objects from `TradeEngineCfgHashMap` (`risk_cfg_`) in the `TickerRiskInfoHashMap`
    data member (`ticker_risk_`):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`RiskManager`构造函数期望一个`Logger`对象，一个指向`PositionKeeper`对象的指针，以及一个指向`TradeEngineCfgHashMap`类型（`ticker_cfg`）对象的引用，该对象持有风险配置。它初始化`logger_`成员变量，并将`PositionKeeper`中的`PositionInfo`对象（`getPositionInfo()`）和`TradeEngineCfgHashMap`中的`RiskCfg`对象（`risk_cfg_`）存储在`TickerRiskInfoHashMap`数据成员（`ticker_risk_`）中：'
- en: '[PRE72]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Next, we will implement the final task that `RiskManager` needs to perform –
    performing risk checks.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`RiskManager`需要执行的最终任务——执行风险检查。
- en: Performing risk checks in RiskManager
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在`RiskManager`中执行风险检查
- en: 'Given a `TickerId` for an instrument, as well as a `Side` and `Qty` for the
    order we expect to send, performing risk checks for it in `RiskManager` is straightforward.
    It simply fetches the correct `RiskInfo` object corresponding to the instrument,
    calls the `RiskInfo::checkPreTradeRisk()` method, and returns the return value
    from that method:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个工具的`TickerId`，以及我们期望发送的订单的`Side`和`Qty`，在`RiskManager`中对其进行风险检查是直接的。它只是获取与该工具对应的正确`RiskInfo`对象，调用`RiskInfo::checkPreTradeRisk()`方法，并返回该方法返回的值：
- en: '[PRE73]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: That concludes our design and implementation of the `RiskManager` component,
    as well as all the components we needed before we can start putting them together
    and building our trading strategies. We will start with that in the next chapter.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对`RiskManager`组件的设计和实现，以及在我们开始组装它们并构建我们的交易策略之前所需的所有组件。我们将在下一章开始介绍这一点。
- en: One important note is that we will need to build all the components presented
    in this chapter, as well as *Building the C++ Market-Making and Liquidity-Taking
    Algorithms* chapter before we can build and run a meaningful trading client. Since
    our ecosystem consists of a server (trading exchange) and client (trading client)
    infrastructure, we will need to wait until the *Building the C++ Market-Making
    and Liquidity-Taking Algorithms* chapter, the *Building and running the main trading
    application* section, before we can run the full ecosystem.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的注意事项是，在我们能够构建和运行一个有意义的交易客户端之前，我们需要构建本章中展示的所有组件，以及*构建C++市场做市和流动性获取算法*章节中的所有组件。由于我们的生态系统由服务器（交易交易所）和客户端（交易客户端）基础设施组成，我们将在*构建C++市场做市和流动性获取算法*章节，*构建和运行主要交易应用程序*部分之前等待，然后我们才能运行完整的生态系统。
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, our primary focus was on adding intelligence and sophistication
    to the market participants’ trading systems. First, we discussed our market-making
    and liquidity-taking trading strategies. We discussed the motivation behind these
    strategies, how they seek to profit in the markets, and the trading dynamics of
    these algorithms.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的主要关注点是增强市场参与者交易系统的智能和复杂性。首先，我们讨论了我们的市场做市和流动性获取交易策略。我们讨论了这些策略背后的动机，它们如何在市场中寻求利润，以及这些算法的交易动态。
- en: We implemented the important components that make up the intelligence around
    our trading strategies. The first one was the feature engine that’s used to compute
    trading features/signals from the market data so that they can be used by the
    trading strategies to make informed trading decisions. The next one was the position
    keeper, which is in charge of tracking a trading strategy’s positions and PnLs
    as the strategy’s orders are executed in the market. After, we looked at the order
    manager component, which sends and manages live orders in the market to simplify
    the trading strategy’s implementation. The risk manager was the final and possibly
    the most vital component that we looked at since it is in charge of tracking and
    regulating the risk that a trading algorithm has currently taken, as well as any
    additional risk it is trying to take.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了构成我们交易策略智能的重要组件。第一个是特征引擎，它用于从市场数据中计算交易特征/信号，以便它们可以被交易策略用来做出明智的交易决策。接下来是持仓管理器，它负责跟踪交易策略的持仓和盈亏，随着策略在市场中的订单被执行。然后，我们研究了订单管理器组件，它负责发送和管理市场中的实时订单，以简化交易策略的实施。风险管理器是我们考虑的最后一个，也可能是最重要的组件，因为它负责跟踪和调节交易算法目前所承担的风险，以及它试图承担的任何额外风险。
- en: Now that we have all the important components in one place, in the next chapter,
    we will build our market-making strategy to provide passive liquidity in the market.
    Then, we will build the liquidity-taking trading algorithm to send aggressive
    orders and initiate and manage positions in the market. Finally, we will build
    our trade engine framework, which will house all the necessary components and
    build and drive the trading algorithms we built. By doing this, we will complete
    our electronic trading ecosystem.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有重要组件集中在一起，在下一章中，我们将构建我们的市场做市策略，以在市场中提供被动流动性。然后，我们将构建流动性获取的交易算法，以发送积极的订单并在市场中发起和管理头寸。最后，我们将构建我们的交易引擎框架，它将容纳所有必要的组件，并构建和驱动我们构建的交易算法。通过这样做，我们将完成我们的电子交易生态系统。
