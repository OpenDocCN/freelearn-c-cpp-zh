- en: C++ as an Embedded Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++作为嵌入式语言
- en: 'When it comes to embedded development on resource-restricted systems, it is
    still common to consider only C and ASM as viable choices, accompanied by the
    thought that C++ has a larger footprint than C, or adds a significant amount of
    complexity. In this chapter, we will look at all of these issues in detail and
    consider the merits of C++ as an embedded programming language:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源受限的嵌入式系统上进行开发时，通常仅考虑C和ASM作为可行选择，并伴随着这样的想法：C++的占用空间比C大，或者增加了相当多的复杂性。在本章中，我们将详细讨论所有这些问题，并考虑C++作为嵌入式编程语言的优点：
- en: C++ relative to C
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++相对于C
- en: Advantages of C++ as a multi-paradigm language
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++作为多范式语言的优势
- en: Compatibility with existing C and ASM
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与现有C和ASM的兼容性
- en: Changes with C++11, C++14, and C++17
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++11、C++14和C++17的变化
- en: C++ relative to C
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++相对于C
- en: The lineages of C and C++ both trace their lineage back to the ALGOL programming
    language, which saw its first version in 1958 (ALGOL 58), followed by updates
    in 1960 and 1968\. ALGOL introduced the concept of imperative programming—a programming
    style in which statements explicitly tell the machine how to make changes to data
    for output and control flow.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++的谱系都可以追溯到ALGOL编程语言，该语言于1958年推出第一个版本（ALGOL 58），随后在1960年和1968年进行了更新。ALGOL引入了命令式编程的概念——一种编程风格，其中语句明确告诉计算机如何对数据进行更改以输出和控制流。
- en: A paradigm that emerges rather naturally from imperative programming is the
    use of procedures. We will start with an example, to introduce the terminology.
    Procedures are synonymous to sub-routines and functions. They identify the groups
    of statements and make them self-contained, which has the effects of confining
    the reach of these statements to the limited scope of the section they are contained
    within, creating hierarchy and consequentially introducing these procedures as
    new, more abstract statements. Heavy use of this procedural programming style
    finds its place in so-called structured programming, alongside loop and branching
    control structures.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令式编程中自然而然地出现的一种范式是使用过程。我们将从一个示例开始，介绍这个术语。过程与子例程和函数是同义词。它们标识了一组语句，并使它们自包含，这样就限制了这些语句的范围，使其仅限于它们所包含的部分，从而创建了层次结构，并因此将这些过程引入为新的、更抽象的语句。这种过程式编程风格的大量使用与所谓的结构化编程并存，结构化编程还包括循环和分支控制结构。
- en: Over time, structured and modular programming styles were introduced as techniques
    to improve the development, quality and maintainability of application code. The
    C language is an imperative, structured programming language due to its use of
    statements, control structures and functions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，结构化和模块化编程风格被引入为改进应用程序代码的开发、质量和可维护性的技术。C语言是一种命令式、结构化的编程语言，因为它使用了语句、控制结构和函数。
- en: 'Take, for example, the standard Hello World example in C:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，C中的标准Hello World示例：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The entry point of any C (and C++) application is the `main()` function (procedure).
    In the first statement line of this function, we call another procedure (`printf()`),
    which contains its own statements and possibly calls other blocks of statements
    in the form of additional functions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何C（和C++）应用程序的入口点是`main()`函数（过程）。在这个函数的第一条语句行中，我们调用另一个过程（`printf()`），它包含自己的语句，并可能调用其他语句块，以额外的函数形式。
- en: This way we have already made use of procedural programming by implementing
    a `main()` logical block (the `main()` function), which is called as needed. While
    the `main()` function will just be called once, the procedural style is found
    again in the `printf()` statement, which calls the statements elsewhere in the
    application without having to copy them explicitly. Applying procedural programming
    makes it much easier to maintain the resulting code, and create libraries of code
    that we can use across a number of applications, while maintaining only a single
    code base.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现一个`main()`逻辑块（`main()`函数），我们已经使用了过程式编程，根据需要调用它。虽然`main()`函数只会被调用一次，但过程式风格在`printf()`语句中再次出现，它在应用程序的其他地方调用语句，而无需显式复制它们。应用过程式编程使得维护生成的代码变得更加容易，并创建可以在多个应用程序中使用的代码库，同时只维护一个代码库。
- en: 'In 1979, Bjarne Stroustrup started work on *C with Classes*, for which he took
    the existing programming paradigms of C and added elements from other languages,
    in particular Simula (object-oriented programming: both imperative and structured)
    and ML (generic programming, in the form of templates). It would also offer the
    speed of the **Basic Combined Programming Language** (**BCPL**), without restricting
    the developer to its restrictive low-level focus.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 1979年，Bjarne Stroustrup开始了*C with Classes*的工作，他在其中采用了C的现有编程范式，并从其他语言中添加了元素，特别是Simula（面向对象编程：命令式和结构化）和ML（模板形式的泛型编程）。它还提供了**Basic
    Combined Programming Language**（**BCPL**）的速度，而不限制开发人员的低级关注。
- en: The resulting multi-paradigm language was renamed to **C++** in 1983, while
    adding additional features not found in C, including operator and function overloading,
    virtual functions, references, and starting the development of a standalone compiler
    for this C++ language.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结果是多范式语言在1983年更名为**C++**，同时增加了C中没有的其他特性，包括运算符和函数重载、虚函数、引用，并开始为这种C++语言开发独立的编译器。
- en: 'The essential goal of C++ has remained to provide practical solutions to real-world
    issues. Additionally, it has always been the intention for C++ to be a better
    C, hence the name. Stroustrup himself defines a number of rules (as noted in *Evolving
    C++ 1991-2006*) that drive the development of C++ to this day, including the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C++的基本目标一直是为现实世界的问题提供实际解决方案。此外，C++一直意图成为更好的C，因此得名。 Stroustrup本人在《Evolving C++
    1991-2006》中定义了一些规则，包括以下规则，这些规则至今仍驱动着C++的发展：
- en: C++'s evolution must be driven by real problems
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++的发展必须受到真实问题的驱动
- en: Every feature must have a reasonably obvious implementation
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个特性必须有一个相当明显的实现
- en: C++ is a language, not a complete system
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++是一种语言，而不是一个完整的系统
- en: Don't try to force people to use a specific programming style
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要试图强迫人们使用特定的编程风格
- en: No implicit violations of the static type system
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不会有静态类型系统的隐式违规。
- en: Provide as good support for user-defined types as for built-in types
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户定义的类型提供与内置类型一样好的支持
- en: Leave no room for a lower-level language below C++ (except assembler)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不留下C++以下的低级语言（除了汇编语言）
- en: What you don't use, you don't pay for (zero-overhead rule)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用的东西就不需要付费（零开销规则）
- en: If in doubt, provide means for manual control
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有疑问，提供手动控制的手段
- en: The differences relative to C obviously goes beyond object-oriented programming.
    Despite the lingering impression that C++ is just a set of extensions to C, it
    has for a long time been its own language, adding a strict type system (compared
    to C's weak type system at that time), more powerful programming paradigms, and
    features not found in C. Its compatibility with C can therefore be seen more as
    coincidence, with C being the right language at the right time to be used as a
    foundation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相对于C语言的差异显然不仅仅是面向对象编程。尽管人们仍然认为C++只是C的一组扩展，但它长期以来一直是自己的语言，增加了严格的类型系统（与当时的C的弱类型系统相比），更强大的编程范式和C中找不到的特性。因此，它与C的兼容性更多地可以被看作是巧合，C恰好是在正确的时间用作基础语言。
- en: The problem with Simula at the time was that it was too slow for general use,
    and BCPL was too low-level. C, being a relatively new language at the time, provided
    the right middle ground between features and performance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当时Simula的问题在于它对于一般用途来说太慢了，而BCPL则太低级。C语言在当时是一个相对较新的语言，它在功能和性能之间提供了合适的平衡。
- en: C++ as an embedded language
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++作为嵌入式语言
- en: 'Around 1983 when C++ had just been conceived and got its name, popular personal
    computer systems for a general audience, as well as businesses, had specifications
    like ones listed in the following table:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在1983年，当C++刚刚被构想出来并得到了名字时，面向一般用户以及企业的流行个人计算机系统的规格如下表所列：
- en: '| **System** | **CPU** | **Clock speed (MHz)** | **RAM (KB)** | **ROM (KB)**
    | **Storage (KB)** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **系统** | **CPU** | **时钟速度（MHz）** | **RAM（KB）** | **ROM（KB）** | **存储（KB）**
    |'
- en: '| BBC Micro | 6502 (B+ 6512A) | 2 | 16-128 | 32-128 | Max 1,280 (ADFS floppy)Max
    20 MB (hard drive) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| BBC Micro | 6502（B+ 6512A） | 2 | 16-128 | 32-128 | 最大1,280（ADFS软盘）最大20 MB（硬盘）|'
- en: '| MSX | Zilog Z80 | 3.58 | 8-128 | 32 | 720 (floppy) |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| MSX | Zilog Z80 | 3.58 | 8-128 | 32 | 720（软盘）|'
- en: '| Commodore 64 | 6510 | ~1 | 64 | 20 | 1,000 (tape)170 (floppy) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Commodore 64 | 6510 | ~1 | 64 | 20 | 1,000（磁带）170（软盘）|'
- en: '| Sinclair ZX81 | Zilog Z80 | 3.58 | 1 | 8 | 15 (cartridge) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| Sinclair ZX81 | Zilog Z80 | 3.58 | 1 | 8 | 15（插卡）|'
- en: '| IBM PC | Intel 8080 | 4.77 | 16-256 | 8 | 360 (floppy) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| IBM PC | Intel 8080 | 4.77 | 16-256 | 8 | 360（软盘）|'
- en: 'Now compare these computer systems to a recent 8-bit **microcontroller** (**MCU**)
    such as the AVR ATMega 2560 with the following specifications:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这些计算机系统与最近的8位**微控制器**（**MCU**）AVR ATMega 2560的规格进行比较：
- en: 16 MHz clock speed
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16 MHz时钟速度
- en: 8 KB RAM
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8 KB RAM
- en: 256 KB ROM (program)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 256 KB ROM（程序）
- en: 4 KB ROM (data)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 KB ROM（数据）
- en: The ATMega 2560 was launched in 2005 and is among the more powerful 8-bit MCUs
    available nowadays. Its features stack up favorably against the 1980s computer
    systems, but on top of that the MCU does not rely on any external memory components.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ATMega 2560于2005年推出，是当今可用的更强大的8位MCU之一。它的功能与1980年代的计算机系统相比有了很大的提升，而且MCU不依赖于任何外部存储器组件。
- en: The MCU core clock speed is significantly faster these days thanks to improved
    silicon IC manufacturing processes which also provide smaller chip sizes, high
    throughput, and thus lower cost and what's more, 1980s architectures commonly
    took 2 to 5 clock cycles to retrieve, decode, execute an instruction and store
    the result as opposed to the single-cycle execution performance of the AVR.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，由于改进的硅IC制造工艺，MCU的核心时钟速度显著更快，这也提供了更小的芯片尺寸、更高的吞吐量，因此成本更低，而且1980年代的架构通常需要2到5个时钟周期来检索、解码、执行指令并存储结果，而AVR的单周期执行性能则不同。
- en: Current MCU (Static) RAM limitations are mostly due to cost and power constraints
    yet can be easily circumvented for most MCUs using external RAM chips, along with
    adding low-cost flash-based or other mass storage devices.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当前MCU（静态）RAM的限制主要是由成本和功耗约束造成的，但对于大多数MCU来说，可以很容易地通过使用外部RAM芯片以及添加低成本的基于闪存的或其他大容量存储设备来规避这些限制。
- en: 'Systems like the **Commodore 64** (**C64**) were routinely programmed in C,
    in addition to the built-in BASIC interpreter (in a built-in ROM). A well-known
    C development environment for the Commodore 64 was Power C published by Spinnaker:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 像**Commodore 64**（C64）这样的系统通常是用C语言编程的，除了内置的BASIC解释器（内置ROM中）。Commodore 64的一个著名的C开发环境是Spinnaker发布的Power
    C：
- en: '![](img/68f27296-883d-413d-9ab1-22a01b44e154.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68f27296-883d-413d-9ab1-22a01b44e154.png)'
- en: Power C was one brand of productivity software aimed at C developers. It came
    on a single, double-sided floppy disk and allowed you to write C code in an editor,
    then compile it with the included compiler, linker, header files, and libraries
    to produce executables for the system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Power C是面向C开发人员的一种生产力软件品牌。它放在一张单面、双面软盘上，允许您在编辑器中编写C代码，然后使用包含的编译器、链接器、头文件和库来编译生成系统的可执行文件。
- en: Many more of such compiler collections existed back then, targeting a variety
    of systems, showing the rich ecosystem that existed for software development.
    Among these, C++ was of course a newcomer. The first edition of Stroustrup's *The
    C++ Programming Language* was only being published in 1985, yet initially without
    a solid implementation of the language to go with it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当时存在许多这样的编译器集合，针对各种系统，显示出了丰富的软件开发生态系统。其中，C++当然是一个新手。Stroustrup的《C++程序设计语言》第一版是在1985年出版的，但最初并没有一个稳固的语言实现与之配套。
- en: Commercial support for C++ however began to appear rapidly, with major development
    environments such as Borland C++ 1.0 being released in 1987 and updated to 2.0
    in 1991\. Development environments like these got used in particular on the IBM
    PC and its myriad of clones where no preferred development language such as BASIC
    existed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于 C++ 的商业支持开始迅速出现，主要的开发环境，如 Borland C++ 1.0 在 1987 年发布，并在 1991 年更新到 2.0。这些开发环境特别在
    IBM PC 及其众多克隆机上得到使用，那里没有像 BASIC 这样的首选开发语言。
- en: While C++ began its life as an unofficial standard in 1985, it wasn't until
    1989 and the release of the *The C++ Programming Language* in its second edition
    as an authoritative work that C++ reached roughly the level of features equal
    to what would first be then standardized by an ISO working group as ISO/IEC 14882:1998,
    commonly known as C++98\. Still it can be said that C++ saw significant development
    and adoption before the advent of the Motorola 68040 in 1990 and Intel 486DX in
    1992, which bumped processing power above the 20 MIPS mark.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 C++ 在 1985 年开始作为非官方标准，但直到 1989 年第二版 *The C++ Programming Language* 的发布作为权威作品，C++
    才达到了大约与 ISO/IEC 14882:1998（通常称为 C++98）首次标准化的功能水平相等。可以说，C++ 在 1990 年摩托罗拉 68040
    和 1992 年英特尔 486DX 出现之前就已经有了显著的发展和采用，这将处理能力提升到了 20 MIPS 以上。
- en: Now that we have considered early hardware specifications and the evolution of
    C++ alongside C and other languages of the time intended to be used on the relatively
    limited systems that existed back then, it seems plausible that C++ is more than
    capable of running on such hardware, and by extension on modern-day microcontrollers.
    However, it also seems necessary to ask to what extent the complexity added to
    C++ since then has impacted memory or computing performance requirements.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经考虑了早期硬件规格和 C++ 与 C 以及当时旨在在相对有限的系统上使用的其他语言的发展，似乎可以认为 C++ 完全有能力在这样的硬件上运行，从而在现代微控制器上运行。然而，似乎有必要问问自从那时以来增加到
    C++ 中的复杂性在多大程度上影响了内存或计算性能要求。
- en: C++ language features
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 语言特性
- en: We previously took a look at the explicit nature of changes to data and system
    state that defines imperative programming as opposed to declarative programming,
    where instead of manipulating data in a loop such functionality could be declared
    as mapping an operator to some data, thus spelling out the functionality, not
    the specific order of operations. But why should programming languages necessarily
    be a choice between imperative and declarative paradigms?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看过数据和系统状态的显式变化性质，这定义了命令式编程与声明式编程的区别，声明式编程不是在循环中操作数据，而是将功能声明为将运算符映射到某些数据，从而阐明功能，而不是具体操作的顺序。但为什么编程语言必须必然是命令式和声明式范式之间的选择呢？
- en: In fact, one of the main distinguishing features of C++ is its multi-paradigm
    nature making use of both imperative and declarative paradigms. With the inclusion
    of object-oriented, generic, and functional programming into C++ in addition to
    C's procedural programming, it would seem natural to assume that this would all
    have to come at a cost, whether in terms of higher CPU usage or more RAM and/or
    ROM consumed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，C++ 的主要区别特征之一是其多范式性质，同时使用命令式和声明式范式。通过将面向对象、泛型和函数式编程纳入 C++，除了 C 的过程式编程之外，似乎自然而然地会认为这一切都必须付出代价，无论是在
    CPU 使用率方面还是在内存和/或 ROM 消耗方面。
- en: However, as we learned earlier in this chapter, C++ language features are ultimately
    built upon the C language, and as such there should in turn be little or no overhead
    relative to implementing a similar constructs in plain C. To resolve this conundrum
    and to investigate the validity of the low-overhead hypothesis, we'll now take
    a detailed look at a number of C++ language features, and how they are ultimately
    implemented, with their corresponding cost in binary and memory size.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们在本章前面学到的，C++ 语言特性最终是建立在 C 语言之上的，因此应该没有或几乎没有相对于在纯 C 中实现类似构造的开销。为了解决这个难题，并调查低开销假设的有效性，我们现在将详细研究一些
    C++ 语言特性，以及它们最终是如何实现的，以及它们在二进制和内存大小方面的相应成本。
- en: 'Some of the examples that focus specifically on C++ as a low-level embedded
    language are taken with permission from Rud Merriam''s Code Craft series, as published
    on Hackaday: [https://hackaday.io/project/8238-embedding-c](https://hackaday.io/project/8238-embedding-c).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一些专门关注 C++ 作为低级嵌入式语言的例子是在得到 Rud Merriam 的 Code Craft 系列的许可后使用的，该系列已在 Hackaday
    上发布：[https://hackaday.io/project/8238-embedding-c](https://hackaday.io/project/8238-embedding-c)。
- en: Namespaces
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: Namespaces are a way to introduce additional levels of scope into an application.
    As we saw in the earlier section on classes, these are a compiler-level concept.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是引入应用程序中的额外作用域级别的一种方式。正如我们在早期关于类的部分中看到的那样，这些是编译器级别的概念。
- en: The main use lies in modularizing code, dividing it into logical segments in
    cases where classes are not the most obvious solution, or where you want to explicitly
    sort classes into a particular category using a namespace. This way, you can also
    avoid name and type collisions between similarly named classes, types, and enumerations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 主要用途在于模块化代码，将其分成逻辑段，以便在类不是最明显的解决方案的情况下，或者在您想要明确将类排序到特定类别中使用命名空间的情况下。这样，您还可以避免类似命名的类、类型和枚举之间的名称和类型冲突。
- en: Strongly typed
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强类型
- en: Type information is necessary to test for proper access to and interpretation
    of data. A big feature in C++ that's relative to C is the inclusion of a strong
    type system. This means that many type checks performed by the compiler are significantly
    more strict than what would be allowed with C, which is a weakly typed language.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类型信息对于测试对数据的正确访问和解释是必要的。C++ 中一个与 C 相关的重要特性是强类型系统的包含。这意味着编译器执行的许多类型检查比 C 允许的要严格得多，C
    是一种弱类型语言。
- en: 'This is mostly apparent when looking at this legal C code, which will generate
    an error when compiled as C++:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当看这段合法的 C 代码时，这一点显而易见，当编译为 C++ 时会生成错误：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, they can also be written in the following way:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它们也可以以以下方式编写：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'C++ forbids implicit casts, requiring these examples to be written as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: C++禁止隐式转换，要求将这些示例写成如下形式：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'They can also be written in the following way:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以以以下方式编写：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we explicitly specify the type we are casting to, we can rest assured that
    during compile time any type casts do what we expect them to do.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们明确指定了要转换的类型，我们可以放心，在编译时任何类型转换都会按我们的期望进行。
- en: 'Similarly, the compiler will also complain and throw an error if we were to
    try to assign to a variable with a `const` qualifier from a reference without
    this qualifier:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们试图从一个没有这个限定符的引用中赋值给一个带有`const`限定符的变量，编译器也会抱怨并抛出错误：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To work around this, you are required to explicitly cast the following conversion:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，您需要显式地进行以下转换：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Performing an explicit cast like this is definitely possible and valid. It may
    also cause immense issues and headaches later on when using this reference to
    modify the contents of the supposedly constant value. By the time you find yourself
    writing code like the preceding, however, it can reasonably be assumed that you
    are aware of the implications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样进行显式转换是完全可能和有效的。但是，当使用这个引用来修改被假定为常量值的内容时，可能会在以后引起巨大的问题和头痛。然而，当你发现自己编写类似上面的代码时，可以合理地假定你已经意识到了这些影响。
- en: Such enforcement of explicit types has the significant benefit of making static
    analysis far more useful and effective than it is in a weakly typed language.
    This, in turn, benefits run-time safety, as any conversions and assignments are
    most likely to be safe and without unexpected side effects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种强制使用显式类型的做法有一个重要的好处，就是使得静态分析比在弱类型语言中更有用和有效。这反过来又有利于运行时安全性，因为任何转换和赋值很可能是安全的，没有意外的副作用。
- en: As a type system is predominantly a feature of the compiler rather than any
    kind of run-time code, with (optional) run-time type information as an exception.
    The overhead of having a strongly typed type system in C++ is noticed only at
    compile time, as more strict checks have to be performed on each variable assignment,
    operation, and conversion.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型系统主要是编译器的特性，而不是任何一种运行时代码，（可选的）运行时类型信息是一个例外。在C++中，具有强类型的类型系统的开销只在编译时才会被注意到，因为对每个变量赋值、操作和转换都必须执行更严格的检查。
- en: Type conversions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换
- en: A type conversion occurs whenever a value is assigned to a compatible variable,
    which is not the exact same type as the value. Whenever a rule for conversion
    exists, this conversion can be done implicitly, otherwise an explicit hint (cast)
    can be provided to the compiler to invoke a specific rule where ambiguity exists.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每当将一个值赋给一个兼容的变量时，就会发生类型转换，这个变量的类型并不完全相同。每当存在转换规则时，这种转换可以隐式进行，否则可以向编译器提供一个显式提示（转换）来调用特定的规则，以解决模糊性。
- en: 'Whereas C only has implicit and explicit type casting, C++ expands on this
    with a number of template-based functions, allowing you to cast both regular types
    and objects (classes) in a variety of ways:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: C只有隐式和显式类型转换，而C++通过一些基于模板的函数进行了扩展，允许以各种方式转换常规类型和对象（类）：
- en: '`dynamic_cast <new_type>` (expression)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dynamic_cast <new_type>`（表达式）'
- en: '`reinterpret_cast <new_type>` (expression)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reinterpret_cast <new_type>`（表达式）'
- en: '`static_cast <new_type>` (expression)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static_cast <new_type>`（表达式）'
- en: '`const_cast <new_type>` (expression)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const_cast <new_type>`（表达式）'
- en: Here, `dynamic_cast` guarantees that the resulting object is valid, relying
    on **runtime type information** (**RTTI**) (see the later section on it) for this.
    A `static_cast` is similar, but does not validate the resulting object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`dynamic_cast`保证了结果对象是有效的，依赖于**运行时类型信息**（**RTTI**）（请参见后面关于它的部分）。`static_cast`类似，但不验证结果对象。
- en: Next, `reinterpret_cast` can cast anything to anything, even unrelated classes.
    Whether this conversion makes sense is left to the developer, much like with a
    regular explicit conversion.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`reinterpret_cast`可以将任何东西转换为任何东西，甚至是不相关的类。这种转换是否有意义留给开发人员决定，就像常规的显式转换一样。
- en: Finally, a `const_cast` is interesting in that it either sets or removes the
    `const` status of a value, which can be useful when you need a non-`const` version
    of a value for just one function. This does, however, also circumvent the type
    safety system and should be used very cautiously.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`const_cast`很有趣，因为它可以设置或移除一个值的`const`状态，当你只需要一个函数的非`const`版本时，这可能很有用。然而，这也绕过了类型安全系统，应该非常谨慎地使用。
- en: Classes
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: '**Object-oriented programming** (**OOP**) has been around since the days of
    Simula, which was known for being a slow language. This led Bjarne Stroustrup
    to base his OOP implementation on the fast and efficient C programming language.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）自Simula以来就存在，Simula以其缓慢的语言而闻名。这导致Bjarne Stroustrup基于快速高效的C编程语言来实现他的OOP。'
- en: C++ uses C-style language constructs to implement objects. This becomes obvious
    when we take a look at C++ code and its corresponding C code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: C++使用C风格的语言构造来实现对象。当我们看C++代码及其对应的C代码时，这一点变得很明显。
- en: 'When looking at a C++ class, we see its typical structure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看C++类时，我们看到它的典型结构：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This class is also inside of a namespace (which we will look at in more detail
    in a later section), a redefinition of the `unsigned char` type, a namespace-global
    variable definition, and finally the class definition itself, including a private
    and public section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类也在一个命名空间内（我们将在后面的部分更详细地看一下），一个`unsigned char`类型的重新定义，一个命名空间全局变量定义，最后是类定义本身，包括私有和公共部分。
- en: This C++ code defines a number of different scopes, starting with the namespace
    and ending with the class. The class itself adds scopes in the sense of its public,
    protected, and private access levels.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这段C++代码定义了许多不同的作用域，从命名空间开始，到类结束。类本身在其公共、受保护和私有访问级别方面增加了作用域。
- en: 'The same code can be implemented in regular C as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的代码也可以在常规的C中实现：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `using` keyword is similar to `typedef`, making for a direct mapping there.
    We use a `const` instead of a `#define`. An `enum` is essentially the same between
    C and C++, only that C++'s compiler doesn't require the explicit marking of an
    `enum` when used as a type. The same is true for structs when it comes to simplifying
    the C++ code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`关键字类似于`typedef`，因此在这里有一个直接的映射。我们使用`const`代替`#define`。`enum`在C和C++之间本质上是相同的，只是C++的编译器在作为类型使用时不需要显式标记`enum`。当涉及到简化C++代码时，对于结构体也是如此。'
- en: The C++ class itself is implemented in C as a `struct` containing the class
    variables. When the class instance is created, it essentially means that an instance
    of this `struct` is initialized. A pointer to this `struct` instance is then passed
    with each call of a function that is part of the C++ class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: C++类本身在C中实现为包含类变量的`struct`。当创建类实例时，这实质上意味着初始化了这个`struct`的一个实例。然后，这个`struct`实例的指针在调用C++类的函数时被传递。
- en: What these basic examples show us is that there is no runtime overhead for any
    of the C++ features we used compared to the C-based code. The namespace, class
    access levels (public, private, and protected), and similar are only used by the
    compiler to validate the code that is being compiled.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本示例向我们展示了，与基于C的代码相比，我们使用的任何C++特性都没有运行时开销。命名空间、类访问级别（public、private和protected）等仅由编译器用于验证正在编译的代码。
- en: A nice feature of the C++ code is that, despite the identical performance, it
    requires less code, while also allowing you to define strict interface access
    levels and have a destructor class method that gets called when the class is destroyed,
    allowing you to automatically clean up allocated resources.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: C++代码的一个很好的特点是，尽管性能相同，但它需要更少的代码，同时还允许您定义严格的接口访问级别，并且在类被销毁时调用析构函数类方法，从而允许您自动清理分配的资源。
- en: 'Using the C++ class follows this pattern:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++类遵循以下模式：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This compares to the C version like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这与C版本的比较如下：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using the C++ class isn't very different from using the C-style method. Not
    having to do the manual passing of the allocated `struct` instance for each functional
    call, but instead calling a class method, is probably the biggest difference.
    This instance is still available in the form of the `this` pointer, which points
    to the class instance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++类与使用C风格的方法并没有太大的不同。不需要为每个功能调用手动传递分配的`struct`实例，而是调用类方法，这可能是最大的区别。这个实例仍然以`this`指针的形式可用，指向类实例。
- en: While the C++ example uses a namespace and embedded enumeration in the `RingBuffer`
    class, these are just optional features. One can still use global enumerations,
    or in the scope of a namespace, or have many layers of namespaces. This is very
    much determined by the requirements of the application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C++示例在`RingBuffer`类中使用了命名空间和嵌入枚举，但这些只是可选功能。人们仍然可以使用全局枚举，或者在命名空间的范围内，或者有许多层的命名空间。这在很大程度上取决于应用程序的要求。
- en: 'As for the cost of using classes, versions of the examples in this section
    were compiled for the aforementioned Code Craft series for both the Arduino UNO
    (ATMega328 MCU) and Arduino Due (AT91SAM3X8E MCU) development boards, giving the
    following file sizes for the compiled code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 至于使用类的成本，本节示例的版本已针对Arduino UNO（ATMega328 MCU）和Arduino Due（AT91SAM3X8E MCU）开发板进行了编译，给出了编译代码的以下文件大小：
- en: '|  | **Uno** | **Due** |  |  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|  | **Uno** | **Due** |  |  |'
- en: '| **C** | **C++** | **C** | **C++** |  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **C** | **C++** | **C** | **C++** |  |'
- en: '| **Global scope data** | 614 | 652 | 11,184 | 11,196 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| **全局范围数据** | 614 | 652 | 11,184 | 11,196 |'
- en: '| **Main scope data** | 664 | 664 | 11,200 | 11,200 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **主范围数据** | 664 | 664 | 11,200 | 11,200 |'
- en: '| **Four instances** | 638 | 676 | 11,224 | 11,228 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **四个实例** | 638 | 676 | 11,224 | 11,228 |'
- en: Optimization settings for these code file sizes were set to `-O2`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码文件大小的优化设置为`-O2`。
- en: Here, we can see that C++ code is identical to C code once compiled, except
    when we perform initialization of the global class instance, on account of the
    added code to perform this initialization for us, amounting to 38 bytes for the
    Uno.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一旦编译，C++代码与C代码是相同的，除了在全局类实例的初始化上，由于增加的代码来执行这个初始化，Uno的代码量为38字节。
- en: 'Since only one instance of this code has to exist, this is a constant cost
    we only have to pay once: in the first and last line, we have one and four class
    instances or their equivalent, respectively, yet there is only an additional 38
    bytes in the Uno firmware. For the Due firmware, we can see something similar,
    though not as clearly defined. This difference is likely affected by some other
    settings or optimizations.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码只需要存在一个实例，这是一个我们只需要支付一次的固定成本：在第一行和最后一行，我们有一个和四个类实例或它们的等价物，然而Uno固件中只有额外的38字节。对于Due固件，我们可以看到类似的情况，尽管没有那么明显。这种差异可能受到一些其他设置或优化的影响。
- en: What this tells us is that sometimes we don't want to have the compiler initialize
    a class for us, but we should do it ourselves if we need those last few bytes
    of ROM or RAM. Most of the time this will not be an issue, however.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们有时我们不希望编译器为我们初始化一个类，但如果我们需要最后几个字节的ROM或RAM，我们应该自己做。然而，大多数情况下这不会成为问题。
- en: Inheritance
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: In addition to allowing you to organize code into objects, classes also allow
    for classes to serve as a template for other classes through the use of polymorphism.
    In C++, we can combine the properties of any number of classes into a new class,
    giving it custom properties and methods as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许您将代码组织成对象之外，类还允许通过多态性将类作为其他类的模板。在C++中，我们可以将任意数量的类的属性合并到一个新的类中，赋予它自定义的属性和方法。
- en: This is a very effective way to create **user-defined types** (**UDTs**), especially
    when combined with operator overloading to use common operators to define operations
    for addition, subtraction, and so on for the UDT.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常有效的创建**用户定义类型**（**UDTs**）的方法，特别是当与运算符重载结合使用来使用常见运算符为UDT定义加法、减法等操作时。
- en: 'Inheritance in C++ follows the following pattern:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的继承遵循以下模式：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we declare a class, `B`, which derives from class `A`. This allows us
    to use any public methods defined in class A on an instance of class B, as if
    they were defined in the latter to begin with.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明一个类`B`，它派生自类`A`。这使我们可以在类B的实例上使用类A中定义的任何公共方法，就好像它们一开始就是在后者中定义的一样。
- en: All of this seems fairly easy to understand, even if things can get a bit confusing
    the moment we start deriving from more than one base class. However, with proper
    planning and design, polymorphism can be a very powerful tool.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些似乎都很容易理解，即使在我们开始从多个基类派生的那一刻，事情可能会变得有点混乱。然而，通过适当的规划和设计，多态性可以成为一个非常强大的工具。
- en: Unfortunately, none of this answers the question of how much overhead the use
    of polymorphism adds to our code. We saw earlier that C++ classes by themselves
    add no overhead during runtime, yet by deriving from one or more base classes,
    the resulting code would be expected to be significantly more complex.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这些都没有回答使用多态性会给我们的代码增加多少额外开销的问题。我们之前看到，C++类本身在运行时不会增加任何开销，但通过从一个或多个基类派生，预期生成的代码将会变得复杂得多。
- en: Fortunately, this is not the case. Much like with simple classes, the resulting
    derived classes are simple amalgamations of the base structs that underlie the
    class implementations. The inheritance process itself, along with the validation
    that comes with it, is primarily a compiler-time issue, bringing with it various
    benefits for the developer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，情况并非如此。与简单类一样，由此产生的派生类是基础结构的简单融合，这些基础结构构成了类的实现。继承过程本身以及随之而来的验证，主要是一个编译时问题，为开发人员带来了各种好处。
- en: Virtual base classes
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚基类
- en: At times, it doesn't make a lot of sense for a base class to have an implementation
    for a class method, yet at the same time we wish to force any derived classes
    to implement that method. The answer to this problem is virtual methods.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，对于基类来说，为一个类方法提供实现并不太合理，但与此同时，我们希望强制任何派生类实现该方法。解决这个问题的答案是虚拟方法。
- en: 'Take the following class definition:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下类定义：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we try to derive from this class, we must implement these two class methods
    or get a compiler error. Since both of the methods in the base class are virtual,
    the entire base class is referred to as a virtual base class. This is particularly
    useful for when you wish to define an interface that can be implemented by a range
    of different classes, yet keep the convenience of having just one user-defined
    type to refer to.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试从这个类派生，我们必须实现这两个类方法，否则会得到编译器错误。由于基类中的两个方法都是虚拟的，整个基类被称为虚基类。这对于希望定义一个可以由一系列不同类实现的接口，同时保留只有一个用户定义类型来引用的便利性非常有用。
- en: 'Internally, virtual methods like these are implemented using `vtables`, which
    is short for *virtual table*. This is a data structure containing, for each virtual
    method, a memory address (pointer) pointing to an implementation of that method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，这些虚拟方法是使用`vtables`实现的，它是*虚拟表*的缩写。这是一个数据结构，对于每个虚拟方法，都包含一个指向该方法实现的内存地址（指针）：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can compare the performance impact of this level of indirection relative
    to C-style code and classes with direct method calls. The Code Craft article on
    the timing of virtual functions ([https://hackaday.com/2015/11/13/code-craft-embedding-c-timing-virtual-functions/](https://hackaday.com/2015/11/13/code-craft-embedding-c-timing-virtual-functions/))
    describes such an approach, with interesting findings:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这种间接级别对性能的影响与C风格代码和具有直接方法调用的类进行比较。 Code Craft关于虚拟函数定时的文章（[https://hackaday.com/2015/11/13/code-craft-embedding-c-timing-virtual-functions/](https://hackaday.com/2015/11/13/code-craft-embedding-c-timing-virtual-functions/)）描述了这样一种方法，并得出了有趣的发现：
- en: '|  | `Uno` | `Due` |  |  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|  | `Uno` | `Due` |  |  |'
- en: '| `Os` | `O2` | `Os` | `O2` |  |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `Os` | `O2` | `Os` | `O2` |  |'
- en: '| **C function call** | 10.4 | 10.2 | 3.7 | 3.6 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **C函数调用** | 10.4 | 10.2 | 3.7 | 3.6 |'
- en: '| **C++ direct call** | 10.4 | 10.3 | 3.8 | 3.8 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **C++直接调用** | 10.4 | 10.3 | 3.8 | 3.8 |'
- en: '| **C++ virtual call** | 11.1 | 10.9 | 3.9 | 3.8 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **C++虚拟调用** | 11.1 | 10.9 | 3.9 | 3.8 |'
- en: '| **Multiple C calls** | 110.4 | 106.3 | 39.4 | 35.5 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **多个C调用** | 110.4 | 106.3 | 39.4 | 35.5 |'
- en: '| **C function pointer calls** | 105.7 | 102.9 | 38.6 | 34.9 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **C函数指针调用** | 105.7 | 102.9 | 38.6 | 34.9 |'
- en: '| **C++ virtual calls** | 103.2 | 100.4 | 39.5 | 35.2 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| **C++虚拟调用** | 103.2 | 100.4 | 39.5 | 35.2 |'
- en: All times listed here are in microseconds.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的所有时间都以微秒为单位。
- en: 'The same two Arduino development boards are used for this test as for the one
    comparing compile output size between C code and C++ classes. Two different optimization
    levels are used to compare the impact of such compiler settings: -Os optimizes
    for the size of the resulting binary in terms of bytes, where as the `-O2` setting
    optimizes for speed in a more aggressive manner than the `-O1` optimization level.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试使用了与比较C代码和C++类之间的编译输出大小相同的两个Arduino开发板。使用了两种不同的优化级别来比较这些编译器设置的影响：-Os优化生成的二进制文件的大小（以字节为单位），而`-O2`设置优化速度，比`-O1`优化级别更为激进。
- en: From these timings, we can say for sure that the level of indirection introduced
    by the virtual methods is measurable, although not dramatic, adding a whole 0.7
    microseconds on the ATMega328 of the Arduino Uno development board, and about
    0.1 microseconds on the faster ARM-based board.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些定时中，我们可以确定虚拟方法引入的间接级别是可以测量的，尽管不是很显著，在Arduino Uno开发板的ATMega328上增加了整整0.7微秒，在更快的基于ARM的开发板上增加了约0.1微秒。
- en: Even in absolute terms, the use of virtual class methods does not carry enough
    of a performance penalty to truly reconsider its use unless performance is paramount,
    and this is primarily the case on slower MCUs. The faster the MCU's CPU, the less
    severe the impact of its use will be.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 即使从绝对角度来看，虚拟类方法的使用也不会带来足够的性能损失，除非性能至关重要，这主要是在较慢的MCU上。 MCU的CPU速度越快，使用它的影响就越不严重。
- en: Function inlining
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数内联
- en: The inline keyword in C++ is a hint to the compiler to let it know that we would
    like each call to a function whose name is preceded by this keyword to result
    in that function's implementation instead of being copied to the location of the
    call, thus skipping the overhead of a function call.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，内联关键字是对编译器的提示，让它知道我们希望每次调用以此关键字为前缀的函数时，都会得到该函数的实现，而不是将其复制到调用位置，从而跳过函数调用的开销。
- en: This is a compile-time optimization, which only adds the size of the function
    implementation to the compiler output, once for each distinct call to the inline
    function.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种编译时优化，每次对内联函数的不同调用只会将函数实现的大小添加到编译器输出中一次。
- en: Runtime type information
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时类型信息
- en: The main purpose of RTTI is to allow the use of safe typecasting, like with
    the `dynamic_cast<>` operator. As RTTI involves storing additional information
    for each polymorphic class, it has a certain amount of overhead.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: RTTI的主要目的是允许使用安全的类型转换，就像使用`dynamic_cast<>`操作符一样。由于RTTI涉及为每个多态类存储额外信息，因此会有一定的开销。
- en: This is a runtime feature, as the name gives away, and thus can be disabled
    if you don't need the features it provides. Disabling RTTI is common practice
    on some embedded platforms, especially as it is rarely used on low-resource platforms,
    such as 8-bit MCUs.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个运行时特性，正如名称所示，因此如果您不需要它提供的功能，可以禁用它。在一些嵌入式平台上禁用RTTI是常见做法，特别是在低资源平台上很少使用，比如8位MCU。
- en: Exception handling
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: Exceptions are commonly used on desktop platforms, providing a way to generate
    exceptions for error conditions, which can be caught and handled in try/catch
    blocks.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 异常通常在桌面平台上使用，提供了一种为错误条件生成异常并在try/catch块中捕获和处理的方法。
- en: While exception support isn't expensive by itself, an exception being generated
    is relatively expensive, requiring a significant amount of CPU time and RAM to
    prepare and handle the exception. You have to also make sure to catch every exception,
    or risk having the application terminate without clear cause.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然异常支持本身并不昂贵，但生成异常相对昂贵，需要大量的CPU时间和RAM来准备和处理异常。您还必须确保捕获每个异常，否则可能导致应用程序在没有明确原因的情况下终止。
- en: Exceptions versus the checking of return code for a method being called is something
    that has to be decided on a case-by-case basis, and can also be a matter of personal
    preference. It requires a quite different programming style, which may not work
    for everyone.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 异常与检查方法返回代码之间的区别是需要根据具体情况来决定的，也可能是个人偏好的问题。这需要一种完全不同的编程风格，可能并不适合每个人。
- en: Templates
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: It's often thought that templates in C++ are very heavy, and carry a severe
    penalty for using them. This completely misses the point of templates, which is
    that templates are merely meant to be used as a shorthand method for automating
    the generation of nearly identical code from a single template – hence the name.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常认为C++中的模板非常沉重，并且使用它们会带来严重的惩罚。这完全忽略了模板的本质，即模板只是用作从单个模板自动生成几乎相同代码的一种简便方法 -
    因此得名。
- en: What this effectively means is that for any function or class template we define,
    the compiler will generate an inline implementation of the template each time
    the template is referenced.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上意味着对于我们定义的任何函数或类模板，每次引用模板时，编译器都会生成模板的内联实现。
- en: 'This is a pattern we commonly see in the C++ **standard template library**
    (**STL**), which, as the name suggests, makes heavy use of templates. Take, for
    example, a data structure like a humble map:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在C++标准模板库（STL）中经常看到的一种模式，正如其名称所示，它大量使用模板。例如，像一个简单的map这样的数据结构：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What happens here is that the singular template for an `std::map` is taken by
    the compiler, along with the template parameters we provide within the sharp brackets,
    filling in the template and writing an inline implementation in its spot.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是编译器会获取`std::map`的单一模板，以及我们在尖括号内提供的模板参数，填充模板并在其位置写入内联实现。
- en: Effectively, we get the same implementation as if we had written the entire
    data structure implementation by hand just for those two types. Since the alternative
    would be to write every implementation by hand for every conceivable built-in
    type and additional user-defined type, the use of a generic template saves us
    a lot of time, without sacrificing performance.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们得到的是与手动编写整个数据结构实现相同的实现，只是针对这两种类型。由于替代方案将是为每种可想象的内置类型和额外的用户定义类型手动编写每个实现，使用通用模板可以节省大量时间，而不会牺牲性能。
- en: The standard template library
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准模板库
- en: The standard library for C++ (STL) contains a comprehensive and ever-growing
    collection of functions, classes, and more that allows for common tasks to be
    performed without having to rely on external libraries. The STL string class is
    very popular, and allows you to safely handle strings without having to deal with
    null terminators and anything similar.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: C++的标准库（STL）包含了一个全面且不断增长的函数、类等集合，允许执行常见任务而无需依赖外部库。STL的string类非常受欢迎，可以安全地处理字符串，而无需处理空终止符或类似的内容。
- en: Most embedded platforms support all or at least a significant part of the STL,
    barring limitations on available RAM and the like that prevent the implementation
    of full hash tables and other complex data structures. Many embedded STL implementations
    contain optimizations for the target platform, minimizing RAM and CPU usage.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数嵌入式平台支持STL的全部或至少是重要部分，除了可用RAM等方面的限制，阻止了完整哈希表和其他复杂数据结构的实现。许多嵌入式STL实现都包含针对目标平台的优化，最小化RAM和CPU的使用。
- en: Maintainability
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性
- en: In the preceding sections, we have seen a number of features that C++ offers,
    and the viability of using them on a resource-limited platform. A big advantage
    of using C++ is the reduction in code size you can accomplish through the use
    of templates, along with the organization and modularization of a code base using
    classes, namespaces, and the like.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了C++提供的许多特性，以及在资源有限的平台上使用它们的可行性。使用C++的一个重要优势是通过使用模板来减小代码大小，以及使用类、命名空间等来组织和模块化代码库。
- en: By striving for a more modular approach in your code, with clear interfaces
    between modules, it becomes more feasible to reuse code between projects. It also
    simplifies the maintenance of code by making the function of a particular section
    of code clearer and providing clear targets for unit and integration testing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在代码中努力实现更模块化的方法，并在模块之间建立清晰的接口，使得在项目之间重用代码变得更加可行。这也通过使特定代码部分的功能更清晰，并为单元测试和集成测试提供明确的目标，简化了代码的维护。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we tackled the big question of why you would wish to use C++
    for embedded development. We saw that, due to the courtesy of C++'s development,
    it is highly optimized for resource-constrained platforms, while providing a large
    number of features essential to project management and organization.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解决了为什么要在嵌入式开发中使用C++的重要问题。我们看到，由于C++的开发方式，它非常适用于资源受限的平台，同时提供了许多对项目管理和组织至关重要的特性。
- en: The reader should, at this point, be able to describe C++'s main features and
    provide concrete examples of each. When writing C++ code, the reader will have
    a clear idea of the cost of a particular language feature, being able to reason
    why one implementation of a section of code is preferable to another implementation,
    based on both space and RAM constraints.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 读者现在应该能够描述C++的主要特性，并提供每个特性的具体示例。在编写C++代码时，读者将清楚地了解特定语言特性的成本，能够理由为什么一个代码部分的实现优于另一个实现，基于空间和RAM约束。
- en: In the next chapter, we will take a look at the development process for embedded
    Linux and similar systems, based on **single-board computers** (**SBCs**) and
    similar.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍基于**单板计算机**（SBCs）等系统的嵌入式Linux开发过程。
