- en: '*Chapter 5*: Compiling C++ Sources with CMake'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：使用CMake编译C++源代码'
- en: Simple compilation scenarios are usually handled by a default configuration
    of a toolchain or just provided out of the box by an IDE. However, in a professional
    setting, business needs often call for something more advanced. It could be a
    requirement for higher performance, smaller binaries, more portability, testing
    support, or extensive debugging capabilities – you name it. Managing all of these
    in a coherent, future-proof way quickly becomes a complex, tangled mess (especially
    when there are multiple platforms to support).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的编译场景通常由工具链的默认配置或直接由IDE提供。然而，在专业环境中，业务需求往往需要更高级的东西。可能是对更高性能、更小二进制文件、更可移植性、测试支持或广泛的调试功能的需求——您说得都对。以一种连贯、未来无忧的方式管理所有这些，很快就会变得复杂、纠缠不清（尤其是在需要支持多个平台的情况下）。
- en: The process of compilation is often not explained well enough in books on C++
    (in-depth subjects such as virtual base classes seem to be more interesting).
    In this chapter, we'll go through the basics to ensure success when things don't
    go as planned. We'll discover how compilation works, what its internal stages
    are, and how they affect the binary output.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程在C++书籍中往往没有解释得足够清楚（像虚拟基类这样的深入主题似乎更有趣）。在本章中，我们将回顾基础知识，以确保事情不如预期时能取得成功。我们将发现编译是如何工作的，它的内部阶段是什么，以及它们如何影响二进制输出。
- en: After that, we will focus on the prerequisites – we'll discuss what commands
    we can employ to tweak a compilation, how to require specific features from a
    compiler, and how to provide the compiler with the input files that it has to
    process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将重点关注先决条件——我们将讨论我们可以使用哪些命令来调整编译，如何从编译器那里要求特定的功能，以及如何向编译器提供必须处理的输入文件。
- en: Then, we'll focus on the first stage of compilation – the preprocessor. We'll
    be providing paths for included headers, and we'll study how to plug in variables
    from CMake and environments with preprocessor definitions. We'll cover some interesting
    use cases and learn how to expose CMake variables to C++ code in bulk.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将重点关注编译的第一阶段——预处理器。我们将提供包含头文件的路径，并研究如何插入CMake和环境预处理器定义。我们将涵盖一些有趣的用例，并学习如何大量暴露CMake变量给C++代码。
- en: Right after that, we'll talk about the optimizer and how different flags can
    affect performance. We'll also become painfully aware of the costs of optimization
    – how hard it is to debug mangled code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，我们将讨论优化器以及不同标志如何影响性能。我们还将痛苦地意识到优化的代价——调试被破坏的代码有多困难。
- en: Lastly, we'll explain how to manage the compilation process in terms of reducing
    the compilation time using precompiled headers and unity builds, preparing for
    the discovery of mistakes, debugging a build, and storing the debugging information
    in the final binary.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将解释如何通过使用预编译头和单元编译来减少编译时间，为发现错误做准备，调试构建，以及在最终二进制文件中存储调试信息。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The basics of compilation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译的基础
- en: Preprocessor configuration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理器配置
- en: Configuring the optimizer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置优化器
- en: Managing the process of compilation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理编译过程
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter05](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter05).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中存在的代码文件，地址为[https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter05](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter05)。
- en: 'To build examples provided in this book always use recommended commands:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 构建本书提供的示例时，始终使用建议的命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace placeholders `<build tree>` and `<source tree>` with appropriate
    paths. As a reminder: **build tree** is the path to target/output directory, **source
    tree** is the path at which your source code is located.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将占位符`<build tree>`和`<source tree>`替换为适当的路径。作为提醒：**build tree**是目标/输出目录的路径，**source
    tree**是您的源代码所在的路径。
- en: The basics of compilation
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译的基础
- en: Compilation can be roughly described as a process of translating instructions
    written in a higher-level programming language to a low-level machine code. This
    allows us to create our applications using abstract concepts such as classes and
    objects and not bother with the tedious details of processor-specific assembly
    languages. We don't need to work directly with CPU registers, think about short
    or long jumps, and manage stack frames. Compiled languages are more expressive,
    readable, secure, and foster more maintainable code (but are still as performant
    as possible).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 编译可以大致描述为将用高级编程语言编写的指令翻译成低级机器代码的过程。这允许我们使用类和对象等抽象概念来创建应用程序，而无需关心处理器特定汇编语言的繁琐细节。我们不需要直接与CPU寄存器打交道，考虑短跳或长跳，以及管理堆栈帧。编译语言更有表现力、可读性、更安全，并促进更易维护的代码（但性能尽可能）。
- en: In C++, we rely on static compilation – an entire program has to be translated
    into native code before it is executed. This is an alternative approach to languages
    such as Java or Python, which compile a program on the fly with a special, separate
    interpreter every time a user runs it. There are certain advantages to each method.
    The policy of C++ is to provide as many high-level tools as possible while still
    being able to deliver native performance in a complete, self-contained application
    for almost every architecture out there.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我们依赖于静态编译——整个程序必须在执行之前翻译成本地代码。这是Java或Python等语言的替代方法，这些语言每次用户运行时都使用特殊的、独立的解释器编译程序。每种方法都有其优点。C++的政策是为尽可能多的提供高级工具，同时仍能以完整的、自包含的应用程序的形式，为几乎所有的架构提供本地性能。
- en: 'It takes a few steps to create and run a C++ program:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并运行一个C++程序需要几个步骤：
- en: Design your application and carefully write the source code.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计你的应用程序并仔细编写源代码。
- en: Compile individual `.cpp` implementation files (called translation units) to
    *object files*.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单个`.cpp`实现文件（称为翻译单元）编译成*目标文件*。
- en: Link *object files* together in a single executable and add all other dependencies
    – dynamic and static libraries.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*目标文件*链接成单个可执行文件，并添加所有其他依赖项——动态和静态库。
- en: To run the program, the OS will use a tool called *loader* to map its machine
    code and all required dynamic libraries to the virtual memory. The loader then
    reads the headers to check where the program starts and hands over control to
    the code.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行程序，操作系统将使用一个名为*加载器*的工具将它的机器代码和所有必需的动态库映射到虚拟内存。加载器然后读取头文件以检查程序从哪里开始，并将控制权交给代码。
- en: C++ runtime kicks in; a special `_start` function is executed to collect the
    command-line arguments and environment variables. It starts threading, initializes
    static symbols, and registers cleanup callbacks. Only then will it call `main()`,
    which is filled with code by the programmer.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动C++运行时；执行特殊的`_start`函数来收集命令行参数和环境变量。它开始线程，初始化静态符号，并注册清理回调。然后它调用由程序员编写的`main()`函数。
- en: As you can see, quite a lot of work happens behind the scenes. This chapter
    is about the second step in the preceding list. By taking the whole picture into
    consideration, we can understand better where some of the possible issues come
    from. After all, there's no black magic in software (even if the impenetrable
    complexity makes it seem that way). Everything has an explanation and a reason.
    Things may fail during the runtime of a program because of how we compiled it
    (even if the compilation step itself has passed successfully). It's just not possible
    for a compiler to check all the edge cases during its work.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，幕后发生了相当多的工作。本章讨论的是前述列表中的第二步。从整体的角度考虑，我们可以更好地理解一些可能问题的来源。毕竟，软件中没有黑魔法（即使难以理解的复杂性让它看起来像是那样）。一切都有解释和原因。程序运行时可能会失败，是因为我们如何编译它（即使编译步骤本身已经成功完成）。编译器在其工作中检查所有边缘情况是不可能的。
- en: How compilation works
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译是如何工作的
- en: As mentioned before, compilation is the process of translating a higher-level
    language into a lower-level language – specifically, by producing machine code
    (instructions that a specific processor can directly execute) in a binary *object
    file* format specific for a given platform. On Linux, the most popular format
    is the **Executable and Linkable Format** (**ELF**). Windows uses a PE/COFF format
    specification. On macOS, we'll find Mach objects (the Mach-O format).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，编译是将高级语言翻译成低级语言的过程——具体来说，是通过产生特定处理器可以直接执行的机器代码，以二进制**对象文件**格式生成，该格式特定于给定平台。在Linux上，最流行的格式是**可执行和可链接格式**（**ELF**）。Windows使用PE/COFF格式规范。在macOS上，我们会找到Mach对象（Mach-O格式）。
- en: '*Object files* are the direct translation of a single source file. Each one
    of them has to be compiled separately and later joined by a linker into one executable
    or library. Thanks to this, when you change your code, you can save time by recompiling
    only the affected files.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对象文件**是单个源文件的直接翻译。每一个对象文件都需要单独编译，之后链接器将它们合并成一个可执行文件或库。正因为如此，当你修改了代码，只需重新编译受影响的文件，就能节省时间。
- en: 'The compiler has to execute the following stages to create an *object file*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器必须执行以下阶段来创建一个**对象文件**：
- en: Preprocessing
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理
- en: Linguistic analysis
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言分析
- en: Assembly
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇编
- en: Optimization
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化
- en: Code emission
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码生成
- en: '`#include` directives, replaces identifiers with defined values (`#define`
    directives and `-D` flags), invokes simple macros, and conditionally includes
    or excludes parts of code based on the `#if`, `#elif`, and `#endif` directives.
    The preprocessor is blissfully unaware of the actual C++ code and, in general,
    is just a slightly more advanced find-and-replace tool. Nevertheless, its job
    is critical in building advanced programs; the ability to break code up into parts
    and share declarations across multiple translation units is the foundation of
    code reusability.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include`指令，用定义的值替换标识符（`#define`指令和`-D`标志），调用简单的宏，并根据`#if`、`#elif`和`#endif`指令有条件地包含或排除代码的一部分。预处理器对实际的C++代码一无所知，通常只是一个更高级的查找和替换工具。然而，它在构建高级程序中的工作至关重要；将代码分成部分并在多个翻译单元之间共享声明是代码可重用的基础。'
- en: Next up is **linguistic analysis**. This is where more interesting things happen.
    The compiler will scan the file (containing all the headers included by the preprocessor)
    character by character and perform lexical analysis, grouping them into meaningful
    tokens – keywords, operators, variable names, and so on. Then, tokens are grouped
    into token chains and verified if their order and presence follow the rules of
    C++ – this process is called syntax analysis or parsing (usually, it's the most
    vocal part in terms of printed errors). Finally, semantic analysis is performed
    – the compiler tries to detect whether statements in a file actually make sense.
    For example, they have to meet type correctness checks (you can't assign an integer
    to a string variable).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是**语言分析**。在这里，更有趣的事情会发生。编译器将逐字符扫描文件（包含预处理器包含的所有头文件），并进行词法分析，将它们分组成有意义的标记——关键字、操作符、变量名等。然后，标记被分组成标记链，并检查它们的顺序和存在是否遵循C++的规则——这个过程称为语法分析或解析（通常，在打印错误方面，它是声音最大的部分）。最后，进行语义分析——编译器尝试检测文件中的语句是否真的有意义。例如，它们必须满足类型正确性检查（你不能将整数赋值给字符串变量）。
- en: '**Assembly** is nothing more than a translation of these tokens to CPU-specific
    instructions based on an instruction set available for the platform. Some compilers
    actually create an assembler output file, which is later passed to a dedicated
    assembler program to produce machine code that the CPU can execute. Others produce
    the same machine code directly from memory. Usually, such compilers include an
    option to produce a textual output of human-readable assembly code (although,
    just because you can read it, it doesn''t mean that it''s worth it).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**汇编**不过是将这些标记翻译成基于平台可用指令集的CPU特定指令。一些编译器实际上会创建一个汇编输出文件，之后再传递给专门的汇编器程序，以产生CPU可执行的机器代码。其他的编译器直接从内存中产生相同的机器代码。通常，这类编译器包括一个选项，以产生人类可读的汇编代码文本输出（尽管，仅仅因为你能读它，并不意味着它值得这么做）。'
- en: '**Optimization** happens throughout the whole compilation, little by little,
    at every stage. There''s an explicit stage after producing the first assembly
    version, which is responsible for minimizing the usage of registers and removing
    unused code. One interesting and important optimization is in-line expansion or
    *inlining*. The compiler will "cut" the body of a function and "paste" it instead
    of its call (standard doesn''t define in which cases this happens – it depends
    on the implementation of the compiler). This process speeds up execution and reduces
    memory usage but has significant disadvantages for debugging (the executed code
    is no longer at the original line).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化**在整个编译过程中逐步进行，一点一点地，在每个阶段。在生成第一个汇编版本之后有一个明确的阶段，负责最小化寄存器的使用和删除未使用的代码。一个有趣且重要的优化是在线扩展或*内联*。编译器将“剪切”函数的主体并“粘贴”代替其调用（标准未定义这种情况发生在哪些情况下——这取决于编译器的实现）。这个过程加快了执行速度并减少了内存使用，但对调试有重大缺点（执行的代码不再在原始行上）。'
- en: '**Code emission** consists of writing the optimized machine code into an *object
    file* according to the format specified by the target platform. This *object file*
    is not ready to be executed – it has to be passed to the next tool, the linker,
    which will appropriately relocate the sections of our *object file* and resolve
    references to external symbols. This is the transformation from the ASCII source
    code into binary *object files* that are digestible by processors.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码发射**包括根据目标平台指定的格式将优化后的机器代码写入*对象文件*。这个*对象文件*不能直接执行——它必须传递给下一个工具，链接器，它将适当移动我们*对象文件*的各个部分并解决对外部符号的引用。这是从ASCII源代码到可被处理器处理的二进制*对象文件*的转换。'
- en: Each of these stages is significant and can be configured to meet our specific
    needs. Let's look at how we can manage this process with CMake.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段都具有重要意义，可以根据我们的特定需求进行配置。让我们看看如何使用CMake管理这个过程。
- en: Initial configuration
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始配置
- en: 'CMake offers multiple commands to affect each stage:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了多个命令来影响每个阶段：
- en: '`target_compile_features()`: Require a compiler with specific features to compile
    this target.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_compile_features()`：要求具有特定特性的编译器编译此目标。'
- en: '`target_sources()`: Add sources to an already defined target.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_sources()`：向已定义的目标添加源文件。'
- en: '`target_include_directories()`: Set up the preprocessor *include paths*.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_include_directories()`：设置预处理器*包含路径*。'
- en: '`target_compile_definitions()`: Set up preprocessor definitions.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_compile_definitions()`：设置预处理器定义。'
- en: '`target_compile_options()`: Compiler-specific options for the command line.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_compile_options()`：命令行上的编译器特定选项。'
- en: '`target_precompile_headers()`: Optimize the compilation of external headers.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_precompile_headers()`：优化外部头的编译。'
- en: 'All of the preceding commands accept similar arguments:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述命令都接受类似的参数：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This means that they support property propagation, as discussed in the previous
    chapter, and can be used both for executables and libraries. Also, a reminder
    here – all of these commands support generator expressions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它们支持属性传播，如前章所讨论的，既可以用于可执行文件也可以用于库。顺便提一下——所有这些命令都支持生成器表达式。
- en: Requiring specific features from the compiler
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 要求编译器具有特定的特性
- en: As discussed in the *Checking for supported compiler features* section in [*Chapter
    3*](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078), *Setting Up Your First CMake
    Project*, prepare for things going wrong and aim to provide the user of your software
    with a clear message – **available compiler X isn't providing required feature
    Y**. This is a much better experience than the user deciphering whatever error
    is produced by the incompatible toolchain they might have. We don't want users
    to assume that your code is at fault instead of their outdated environment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第3章](B17205_03_Final_JC_ePub.xhtml#_idTextAnchor078)“*设置你的第一个CMake项目*”中讨论的，*检查支持的编译器特性*，为使用你的软件的用户准备可能出错的事情，并努力提供清晰的消息——**可用的编译器X没有提供所需的特性Y**。这比用户可能拥有的不兼容的工具链产生的任何错误都要好。我们不希望用户假设是你的代码出了问题，而不是他们过时的环境。
- en: 'The following command allows you to specify all the features that your target
    needs to build:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令允许你指定构建目标所需的所有特性：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'CMake understands C++ standards and supported compiler features for these `compiler_ids`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: CMake理解C++标准和这些`compiler_ids`所支持的编译器特性：
- en: '`AppleClang`: Apple Clang for Xcode versions 4.4+'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppleClang`：Xcode版本4.4+的Apple Clang'
- en: '`Clang`: Clang Compiler versions 2.9+'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clang`：Clang编译器版本2.9+'
- en: '`GNU`: GNU Compiler versions 4.4+'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GNU`: GNU编译器4.4+版本'
- en: '`MSVC`: Microsoft Visual Studio versions 2010+'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSVC`: Microsoft Visual Studio 2010+版本'
- en: '`SunPro`: Oracle Solaris Studio versions 12.4+'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SunPro`: Oracle Solaris Studio 12.4+版本'
- en: '`Intel`: Intel Compiler versions 12.1+'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Intel`: Intel编译器12.1+版本'
- en: Important Note
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can, of course, use any of the `CMAKE_CXX_KNOWN_FEATURES` variable, but
    I recommend sticking to a general C++ standard – `cxx_std_98`, `cxx_std_11`, `cxx_std_14`,
    `cxx_std_17`, `cxx_std_20`, or `cxx_std_23`. Check out the *Further reading* section
    for more details.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，您可以使用任何`CMAKE_CXX_KNOWN_FEATURES`变量，但我建议坚持使用通用C++标准——`cxx_std_98`、`cxx_std_11`、`cxx_std_14`、`cxx_std_17`、`cxx_std_20`或`cxx_std_23`。查看*进阶阅读*部分以获取更多详细信息。
- en: Managing sources for targets
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理目标源代码
- en: We already know how to tell CMake which source files make up a single target
    – an executable or a library. We provide the list of files whenever we use `add_executable()`
    or `add_library()`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何告诉CMake哪些源文件组成一个目标——一个可执行文件或一个库。我们在使用`add_executable()`或`add_library()`时提供文件列表。
- en: 'As you grow your solution, the list of files for each target grows too. We
    can end up with some really lengthy `add_...()` commands. How do we deal with
    that? One temptation might be to utilize the `file()` command in `GLOB` mode –
    it can collect all the files from subdirectories and store them in a variable.
    We could pass it as an argument to the target declaration and not bother with
    list files again:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随着解决方案的增长，每个目标的文件列表也在增长。我们可能会得到一些非常长的`add_...()`命令。我们如何处理呢？一种诱惑可能是使用`GLOB`模式的`file()`命令——它可以收集子目录中的所有文件并将它们存储在一个变量中。我们将其作为目标声明的参数传递，并不再担心列表文件：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, the previously mentioned approach is not recommended. Let's figure
    out why. CMake generates buildsystems based on changes in the list files, so if
    no changes are made, your builds might break without any warning (which, as we
    know from long hours spent debugging, is the worst kind of breakage). Other than
    that, not having all sources listed in the target declaration will break code
    inspection in IDEs such as CLion (CLion only parses some of the commands to understand
    your project).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面提到的方法并不推荐。让我们找出原因。CMake根据列表文件的变化生成构建系统，因此如果没有进行任何更改，构建可能会在没有警告的情况下失败（我们知道，在花费了长时间进行调试后，这种类型的失败是最糟糕的）。除此之外，不在目标声明中列出所有源代码将导致代码审查在IDE（如CLion）中失败（CLion只解析一些命令以理解您的项目）。
- en: If it's not recommended to use variables in target declarations, how can we
    add source files conditionally, for example, when dealing with platform-specific
    implementation files such as `gui_linux.cpp` and `gui_windows.cpp`?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不建议在目标声明中使用变量，我们如何才能在例如处理特定平台的实现文件（如`gui_linux.cpp`和`gui_windows.cpp`）时条件性地添加源文件呢？
- en: 'We can use the `target_sources()` command to append files to a previously created
    target:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`target_sources()`命令将文件追加到先前创建的目标：
- en: chapter05/01-sources/CMakeLists.txt
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05/01-sources/CMakeLists.txt
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This way, each platform gets its own set of compatible files. That's great,
    but what about long lists of sources? Well, we'll just have to accept that some
    things aren't perfect just yet and keep adding them manually.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每个平台都可以获得自己的兼容文件集合。很好，但是长文件列表怎么办呢？嗯，我们只能接受有些事情目前还不完美，并继续手动添加它们。
- en: Now that we have established the key facts about compilation, let's take a closer
    look at the first step – preprocessing. As with all things in computer science,
    the devil is in the details.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确立了编译的关键事实，让我们更仔细地看看第一步——预处理。与计算机科学中的所有事情一样，细节是魔鬼。
- en: Preprocessor configuration
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理器配置
- en: The preprocessor plays a huge role in the process of building. Maybe this is
    a little surprising, given how simple and limited its functionality is. In following
    sections, we'll cover providing paths to included files and using the preprocessor
    definitions. We'll also explain how we can use CMake to configure included headers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器在构建过程中的作用非常大。这可能有点令人惊讶，因为它的功能多么简单和有限。在接下来的部分，我们将介绍为包含文件提供路径和使用预处理器定义。我们还将解释如何使用CMake配置包含的头文件。
- en: Providing paths to included files
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为包含文件提供路径
- en: 'The most basic feature of the preprocessor is the ability to include `.h`/`.hpp`
    header files with the `#include` directive. It comes in two forms:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器最基本的功能是使用`#include`指令包含`.h`/`.hpp`头文件。它有两种形式：
- en: '`#include <path-spec>`: Angle-bracket form'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include <path-spec>`: 尖括号形式'
- en: '`#include "path-spec"`: Quoted form'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include "path-spec"`: 引号形式'
- en: As we know, the preprocessor will replace these directives with the contents
    of the file specified in `path-spec`. Finding these files may be an issue. Which
    directories do we search and in what order? Unfortunately, the C++ standard doesn't
    exactly specify that; we need to check the manual for the compiler we use.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，预处理器将这些指令替换为`path-spec`中指定的文件的正文。找到这些文件可能是个问题。我们搜索哪些目录以及按什么顺序？不幸的是，C++标准并没有确切指定；我们需要查看我们使用的编译器的手册。
- en: Typically, the angle-bracket form will check standard *include directories*,
    including the directories where standard C++ library and standard C library headers
    are stored in the system.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，尖括号形式将检查标准*包含目录*，包括系统中存储标准C++库和标准C库头文件的目录。
- en: The quoted form will start searching for the included file in the directory
    of the current file and then check directories for the angle-bracket form.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 引号形式将开始在当前文件的目录中搜索包含的文件，然后检查尖括号形式的目录。
- en: 'CMake provides a command to manipulate paths being searched for the included
    files:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了一个命令，用于操作搜索包含文件所需的路径：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can add custom paths that we'd like the compiler to check. CMake will add
    them to compiler invocations in the generated buildsystem. They will be provided
    with a flag appropriate for the specific compiler (usually, it's `-I`).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加自定义路径，我们希望编译器检查。CMake将在生成的构建系统中为编译器调用添加它们。它们将用适合特定编译器的标志提供（通常是`-I`）。
- en: Using `BEFORE` or `AFTER` determines whether the path should be prepended or
    appended to the target `INCLUDE_DIRECTORIES` property. It's still up to the compiler
    to decide whether directories provided here will be checked before or after the
    default ones (usually, it's before).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BEFORE`或`AFTER`确定路径应该附加到目标`INCLUDE_DIRECTORIES`属性之前还是之后。是否检查这里提供的目录还是默认目录之前还是之后（通常，是之前）仍然由编译器决定。
- en: The `SYSTEM` keyword informs the compiler that the provided directories are
    meant as standard system directories (to be used with the angle-bracket form).
    For many compilers, this value will be provided as a `-isystem` flag.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`SYSTEM`关键字通知编译器，提供的目录是作为标准系统目录（与尖括号形式一起使用）。对于许多编译器，这个值将作为`-isystem`标志提供。'
- en: Preprocessor definitions
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预处理器定义
- en: 'Remember how I mentioned the preprocessor''s `#define` and `#if`, `#elif`,
    and `#endif` directives when describing the stages of compilation? Let''s consider
    the following example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我提到预处理器的`#define`和`#if`、`#elif`、`#endif`指令时描述编译阶段吗？让我们考虑以下示例：
- en: chapter05/02-definitions/definitions.cpp
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05/02-definitions/definitions.cpp
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As it is, this example does nothing; neither `ABC` nor `DEF` is defined (`DEF`
    would default to `0` in this example). We can easily change that by adding two
    lines at the top of this code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如它所示，这个例子什么也不做；在这个例子中`ABC`和`DEF`都没有定义（在这个例子中`DEF`将默认为`0`）。我们可以在这个代码顶部添加两行轻松地改变这一点：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After compiling and executing this code, we can see both messages in the console:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并执行此代码后，我们可以在控制台看到两条消息：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This seems easy enough, but what happens if we want to condition these sections
    based on external factors, such as an operating system, architecture, or something
    else? Good news! You can pass values from CMake to a C++ compiler, and it's not
    complicated at all.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单，但如果我们想根据外部因素（如操作系统、体系结构或其他内容）来条件这些部分，会发生什么情况呢？好消息！您可以将值从CMake传递给C++编译器，而且一点也不复杂。
- en: 'The `target_compile_definitions()` command will do the trick:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`target_compile_definitions()`命令将解决这个问题：'
- en: chapter05/02-definitions/CMakeLists.txt
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05/02-definitions/CMakeLists.txt
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code will behave exactly like the two `#define` statements, but
    we have the freedom to use CMake's variables and generator expressions, and we
    can put the command in a conditional block.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将与两个`#define`声明完全一样，但我们有自由使用CMake的变量和生成表达式，并且可以将命令放在条件块中。
- en: Important Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'These definitions are traditionally passed to the compiler with the `-D` flag
    – `-DFOO=1` – and some programmers still use that flag in this command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义传统上通过`-D`标志传递给编译器——`-DFOO=1`——一些程序员仍然在这个命令中使用这个标志：
- en: '`target_compile_definitions(hello PRIVATE -DFOO)`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`target_compile_definitions(hello PRIVATE -DFOO)`'
- en: 'CMake recognizes this and will remove any leading `-D` flags. It will also
    ignore empty strings, so it''s even okay to write the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: CMake识别这一点，并将移除任何前面的`-D`标志。它还会忽略空字符串，所以即使写如下内容也是可以的：
- en: '`target_compile_definitions(hello PRIVATE -D FOO)`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`target_compile_definitions(hello PRIVATE -D FOO)`'
- en: '`-D` is a separate argument; it will become an empty string after removal,
    and then get ignored, correctly behaving as a result.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`-D`是一个独立的参数；移除后它将变成一个空字符串，然后正确地被忽略。'
- en: Common gotchas in unit-testing private class fields
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试私有类字段时的常见陷阱
- en: 'Some online resources recommend using a combination of specific `-D` definitions
    with `#ifdef/ifndef` directives for the purposes of unit testing. The simplest
    possible approach is to wrap access specifiers in conditional inclusion and ignore
    them when `UNIT_TEST` is defined:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一些在线资源建议在单元测试中使用特定的`-D`定义与`#ifdef/ifndef`指令的组合。最简单的可能方法是将访问修饰符包裹在条件包含中，并在定义`UNIT_TEST`时忽略它们：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While this use case is very convenient (it allows tests to directly access private
    members), it's not very clean code. Unit tests should only test whether methods
    in the public interface work as expected and treat underlying implementation as
    a black-box mechanism. I recommend that you only use this as a last resort.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种用例非常方便（它允许测试直接访问私有成员），但这不是非常整洁的代码。单元测试应该只测试公共接口中方法是否如预期工作，并将底层实现视为黑盒机制。我建议你只在万不得已时使用这个方法。
- en: Using git commit to track a compiled version
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用git提交跟踪编译版本
- en: 'Let''s think about use cases that benefit from knowing details about the environment
    or filesystem. One great example for professional settings might be passing the
    revision or commit `SHA` that was used to build the binary:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下在了解环境或文件系统详情方面有益的用例。一个在专业环境中可能很好的例子是传递用于构建二进制的修订版或提交`SHA`：
- en: chapter05/03-git/CMakeLists.txt
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05/03-git/CMakeLists.txt
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can then use it in our application, like so:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在应用程序中如此使用它：
- en: chapter05/03-git/print_commit.cpp
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05/03-git/print_commit.cpp
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Of course, the preceding code requires a user to have `git` installed and available
    in their `PATH`. This is useful when programs running on our production hosts
    come from a continuous integration/deployment pipeline. If there's an issue with
    our software, we can quickly check which exact Git commit was used to build the
    faulty product.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，上述代码需要用户在他们的`PATH`中安装并可访问`git`。这对于运行在我们生产主机上的程序来自持续集成/部署管道很有用。如果我们的软件有问题时，我们可以快速检查用于构建有缺陷产品的确切Git提交。
- en: Keeping track of an exact commit is really useful for debugging purposes. For
    a single variable, it's not a lot of work, but what happens when we have dozens
    of variables we'd like to pass to our headers?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪确切的提交对调试非常有用。对于一个变量来说，这不是很多工作，但是当我们想要将数十个变量传递给我们的头文件时会发生什么？
- en: Configuring the headers
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置头文件
- en: Passing definitions through `target_compile_definitions()` can be a bit of overhead
    if we have multiple variables. Can't we just provide a header file with placeholders
    referencing various variables and get CMake to fill them in?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有多个变量，通过`target_compile_definitions()`传递定义可能会有些繁琐。我们不能提供一个带有引用各种变量的占位符的头文件，并让CMake填充它们吗？
- en: 'Sure we can! With the `configure_file(<input> <output>)` command, we can generate
    new files from templates like this one:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然我们可以！使用`configure_file(<input> <output>)`命令，我们可以从模板生成新的文件，就像这个一样：
- en: chapter05/04-configure/configure.h.in
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05/04-configure/configure.h.in
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can then use the command, like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用命令，像这样：
- en: chapter05/04-configure/CMakeLists.txt
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05/04-configure/CMakeLists.txt
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can have CMake build an output file, like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以让CMake生成一个输出文件，像这样：
- en: chapter05/04-configure/<build_tree>/configure.h
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05/04-configure/<build_tree>/configure.h
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, the `@VAR@` and `${VAR}` variable placeholders were replaced
    with the values from the CMake list file. Additionally, `#cmakedefine` was replaced
    with `#define` for defined variables and `/* #undef VAR */` for undefined.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '正如你所见，`@VAR@`和`${VAR}`变量占位符被替换成了CMake列表文件中的值。此外，`#cmakedefine`被替换成了`#define`给已定义的变量，对于未定义的变量则替换成`/*
    #undef VAR */`。'
- en: If you need an explicit `#define 1` or `#define 0` for `#if` blocks, use `#cmakedefine01`
    instead.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为`#if`块提供显式的`#define 1`或`#define 0`，请使用`#cmakedefine01`。
- en: 'How do we use such a configured header in the application? We can simply include
    it in our implementation file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在应用程序中使用这样的配置头文件？我们可以在实现文件中简单地包含它：
- en: chapter05/04-configure/configure.cpp
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05/04-configure/configure.cpp
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And because we have added the binary tree to our *include paths* with the `target_include_directories()`
    command, we can compile the example and receive output populated from CMake:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已使用`target_include_directories()`命令将二叉树添加到了我们的*包含路径*中，因此我们可以编译示例并从CMake接收填充好的输出：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `configure_file()` command also has a number of formatting and file-permission
    options. Describing them here would be a bit too lengthy. If you're interested,
    check out the online documentation for details (the link is in the *Further reading*
    section).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure_file()`命令还具有许多格式化和文件权限选项。在这里描述它们可能会稍显冗长。如果你有兴趣，可以查看在线文档以获取详细信息（链接在*进一步阅读*部分）。'
- en: After preparing a complete composite of our headers and source file, we can
    talk about how the output code is shaped during the next steps. As we can't influence
    the linguistic analysis or assembling directly (these steps follow strict standards),
    we definitely have access to the configuration of the optimizer. Let's learn how
    it can affect the end result.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备好我们头文件和源文件的完整组合后，我们可以讨论在下一步中输出代码是如何形成的。由于我们无法直接影响语言分析或汇编（这些步骤遵循严格的标准），我们肯定可以访问优化器的配置。让我们了解它如何影响最终结果。
- en: Configuring the optimizer
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置优化器
- en: The optimizer will analyze the output of previous stages and use a multitude
    of tricks, which programmers would consider dirty, as they don't adhere to clean-code
    principles. That's okay – the critical role of the optimizer is to make code performant
    (that is, use few CPU cycles, few registers, and less memory). As the optimizer
    goes through the source code, it will transform it heavily so that it almost becomes
    unrecognizable. It turns into a specially prepared version for the target CPU.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器将分析前阶段的结果，并使用多种程序员认为不整洁的技巧，因为它们不符合整洁代码原则。没关系——优化器的关键作用是使代码具有高性能（即，使用较少的CPU周期、较少的寄存器和较少的内存）。当优化器遍历源代码时，它会对其进行大量转换，以至于它几乎变得无法辨认。它变成了针对目标CPU的特殊准备版本。
- en: The optimizer will not only decide which functions could be removed or compacted;
    it will also move code around or even significantly duplicate it! If it can determine
    with full certainty that some lines of code are meaningless, it will wipe them
    out from the middle of an important function (you won't even notice). It will
    reuse memory, so numerous variables can occupy the same slot in different periods
    of time. And it will transform your control structures into totally different
    ones if that means it can shave off a few cycles here and there.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器不仅会决定哪些函数可以被删除或压缩；它还会移动代码或甚至显著地重复它！如果它可以完全确定某些代码行是没有意义的，它就会从重要函数的中间抹去它们（你甚至都注意不到）。它会重复利用内存，所以众多变量在不同时间段可以占据同一个槽位。如果这意味着它可以节省一些周期，它还会将你的控制结构转换成完全不同的结构。
- en: 'The techniques described here, if applied manually to source code by a programmer,
    would turn it into a horrible, unreadable mess. It would be hard to write and
    reason about. On the other hand, they are great if applied by compilers, which
    will follow the orders exactly as written. The optimizer is a ruthless beast that
    serves only one purpose: make the execution fast, no matter how mangled the output
    will be. Such output may contain some debugging information if we are running
    it in our test environment, or it may not, in order to make it difficult for unauthorized
    people to tamper with it.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的技术，如果由程序员手动应用到源代码中，将会使其变得可怕、难以阅读。编写和推理将会困难。另一方面，如果由编译器应用，那就非常棒了，因为编译器将严格遵循所写的内容。优化器是一种无情的野兽，只服务于一个目的：使执行快速，无论输出会变得多么糟糕。如果我们在测试环境中运行它，输出可能包含一些调试信息，或者它可能不包含，以便让未授权的人难以篡改。
- en: Each compiler has its own tricks up its sleeve, aligned with the platform and
    philosophy it follows. We'll take a look at the most common ones, available in
    GNU GCC and LLVM Clang, so that we can understand what is useful and possible.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每个编译器都有自己的技巧，与它所遵循的平台和哲学相一致。我们将查看GNU GCC和LLVM Clang中可用的最常见的一些，以便我们可以了解什么是有用和可能的。
- en: Here's the thing – many compilers won't enable any optimization by default (GCC
    included). This is okay in some cases but not so much in others. Why go slow when
    you can go fast? To change things, we can use the `target_compile_options()` command
    and specify exactly what we want from the compiler.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是——许多编译器默认不会启用任何优化（包括GCC）。这在某些情况下是可以的，但在其他情况下则不然。为什么要慢慢来，当你可以快速前进时呢？要改变事物，我们可以使用`target_compile_options()`命令，并精确指定我们想从编译器那里得到什么。
- en: 'The syntax of this command is similar to others in this chapter:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的语法与本章中的其他命令相似：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We provide the `target` command-line options to add and we specify the propagation
    keyword. When this command is executed, CMake will append the given options to
    the appropriate `COMPILE_OPTIONS` variable of the target. The optional `BEFORE`
    keyword may be used to specify that we'd like to prepend them instead. Order matters
    in some cases, so it's good that we can choose.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供`target`命令行选项以添加，并指定传播关键字。当执行此命令时，CMake将在目标相应的`COMPILE_OPTIONS`变量中附加给定选项。可选的`BEFORE`关键字可用于指定我们想要在它们之前添加它们。在某些情况下，顺序很重要，因此能够选择是件好事。
- en: Important Note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`target_compile_options()` is a general command. It can also be used to provide
    other arguments to compiler-like `-D` definitions, for which CMake offers the
    `target_compile_definition()` command as well. It is always recommended to use
    the CMake commands wherever possible, as they work the same way across all supported
    compilers.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`target_compile_options()`是一个通用命令。它也可以用来为类似编译器的`-D`定义提供其他参数，对于这些参数，CMake还提供了`target_compile_definition()`命令。始终建议尽可能使用CMake命令，因为它们在所有支持的编译器上都是一致的。'
- en: Time to discuss the details. The subsequent sections will introduce various
    kinds of optimizations you can enable in most compilers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 是讨论细节的时候了。接下来的章节将介绍您可以在大多数编译器中启用的各种优化方法。
- en: General level
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用级别
- en: All the different behaviors of the optimizer can be configured in depth by specific
    flags that we can pass as *compile options*. Getting to know all of them is time-consuming
    and requires a lot of knowledge about the internal workings of compilers, processors,
    and memory. What can we do if we just want the best possible scenario that works
    well in most cases? We can reach for a general solution – an optimization-level
    specifier.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器的所有不同行为都可以通过我们作为*编译选项*传递的具体标志进行深度配置。了解它们需要花费大量时间，并需要深入了解编译器、处理器和内存的内部工作原理。如果我们只想在大多数情况下都能良好工作的最佳可能场景怎么办？我们可以寻求一个通用解决方案——一个优化级别指定符。
- en: Most compilers offer four basic levels of optimization, from `0` to `3`. We
    specify them with the `-O<level>` option. `-O0` means *no optimization* and, usually,
    it's the default level for compilers. On the other hand, `-O2` is considered a
    *full optimization*, one that generates highly optimized code but at the cost
    of the slowest compilation time.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编译器提供四个基本级别的优化，从`0`到`3`。我们使用`-O<level>`选项指定它们。`-O0`意味着*没有优化*，通常，这是编译器的默认级别。另一方面，`-O2`被认为是*完全优化*，它生成高度优化的代码，但编译时间最慢。
- en: There's an in-between `-O1` level, which (depending on your needs) can be a
    good compromise – it enables a reasonable amount of optimization mechanisms without
    slowing the compilation too much.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个中间的`-O1`级别，根据您的需求，它可以是一个很好的折中方案——它启用了适量的优化机制，而不会使编译速度变得太慢。
- en: Finally, we can reach for `-O3`, which is *full optimization*, like `-O2`, but
    with a more aggressive approach to subprogram inlining and loop vectorization.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`-O3`，这是*完全优化*，类似于`-O2`，但它在子程序内联和循环向量化方面采取了更为激进的方法。
- en: There are also some variants of the optimization that will optimize for the
    size (not necessarily the speed) of the produced file – `-Os`. There is a super-aggressive
    optimization, `-Ofast`, which is an `-O3` optimization that doesn't comply strictly
    with C++ standards. The most obvious difference is the usage of `-ffast-math`
    and `-ffinite-math` flags, meaning that if your program is about precise calculations
    (as most are), you might want to avoid it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些优化变体，它们将优化生成文件的大小（不一定是速度）——`-Os`。还有一个超级激进的优化，`-Ofast`，它是不严格符合C++标准的`-O3`优化。最明显的区别是使用`-ffast-math`和`-ffinite-math`标志，这意味着如果你的程序是关于精确计算（像大多数程序一样），你可能想避免使用它。
- en: 'CMake knows that not all compilers are made equal, and for that reason, it
    standardizes the experience for developers by providing some default flags for
    compilers. They are stored in system-wide (not target-specific) variables for
    used language (`CXX` for C++) and build configuration (`DEBUG` or `RELEASE`):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: CMake知道并非所有的编译器都平等，因此，为了提供一致的开发体验，它为编译器提供了一些默认标志。这些标志存储在系统级（非目标特定）变量中，用于指定使用的语言（`CXX`用于C++）和构建配置（`DEBUG`或`RELEASE`）：
- en: '`CMAKE_CXX_FLAGS_DEBUG` equals `-g`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CXX_FLAGS_DEBUG`等于`-g`。'
- en: '`CMAKE_CXX_FLAGS_RELEASE` equals `-O3 -DNDEBUG`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CXX_FLAGS_RELEASE`等于`-O3 -DNDEBUG`。'
- en: As you can see, the debug configuration doesn't enable any optimizations and
    the release configuration goes straight for `O3`. If you like, you can change
    them directly with the `set()` command or just add a target compilation option,
    which will override this default behavior. The other two flags (`-g,` `-DNDEBUG`)
    are related to debugging – we'll discuss them in the *Providing information for
    the debugger* section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调试配置没有启用任何优化，而发布配置直接选择了`O3`。如果你愿意，你可以直接使用`set()`命令更改它们，或者只是添加一个目标编译选项，这将覆盖这个默认行为。另外两个标志（`-g,`
    `-DNDEBUG`）与调试有关——我们将在*为调试器提供信息*部分讨论它们。
- en: Variables such as `CMAKE_<LANG>_FLAGS_<CONFIG>` are global – they apply to all
    targets. It is recommended to configure your targets through properties and commands
    such as `target_compile_options()` rather than relying on global variables. This
    way, you can control your targets at higher granularity.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`CMAKE_<LANG>_FLAGS_<CONFIG>`之类的变量是全局的——它们适用于所有目标。建议通过`target_compile_options()`等属性和命令来配置目标，而不是依赖全局变量。这样，你可以更精细地控制你的目标。
- en: 'By choosing an optimization level with `-O<level>`, we indirectly set a long
    list of flags, each controlling a specific optimization behavior. We can then
    fine-tune the optimization by appending more flags, like so:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`-O<level>`选择优化级别，我们间接设置了一系列标志，每个标志控制一个特定的优化行为。然后，我们可以通过添加更多标志来微调优化：
- en: 'Enable them with an `-f` option: `-finline-functions`.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-f`选项启用它们：`-finline-functions`。
- en: 'Disable them with an `-fno` option: `-fno-inline-functions`.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-fno`选项禁用它们：`-fno-inline-functions`。
- en: Some of these flags are worth understanding better as they will often impact
    how your program works and how you can debug it. Let's take a look.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些标志值得更深入地了解，因为它们通常会影响你的程序如何运行以及你如何可以调试它。让我们来看看。
- en: Function inlining
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数内联
- en: 'As you will recall, compilers can be encouraged to inline some functions, either
    by *defining* a function inside a class *declaration* block or by explicitly using
    the `inline` keyword:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所回忆的，编译器可以被鼓励内联某些函数，要么在类声明块内*定义*一个函数，要么明确使用`inline`关键字：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It's up to the compiler to decide whether a function will be inlined. If inlining
    is enabled and the function is used in a single place (or is a relatively small
    function used in a few places), then inlining will most likely happen.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 是否内联函数由编译器决定。如果启用了内联并且函数在一个地方使用（或者是一个在几个地方使用的小函数），那么很可能会发生内联。
- en: It's a really curious optimization technique. It works by extracting the code
    from the function in question and putting it in all the places the function was
    called, replacing the original call and saving precious CPU cycles.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常有趣的优化技术。它通过从所述函数中提取代码，并将它放在函数被调用的所有地方，替换原始调用并节省宝贵的CPU周期来工作。
- en: 'Let''s consider the following example using the class we just defined:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下我们刚刚定义的类以下示例：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Without inlining, the code would execute in the `main()` frame until a method
    call. Then, it would create a new frame for `im_inlined()`, execute in a separate
    scope, and go back to the `main()` frame. The same would happen for the `me_too()`
    method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有内联，代码将在`main()`帧中执行，直到一个方法调用。然后，它会为`im_inlined()`创建一个新帧，在一个单独的作用域中执行，并返回到`main()`帧。对`me_too()`方法也会发生同样的事情。
- en: 'However, when inlining takes place, the compiler will replace the calls, like
    so:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当内联发生时，编译器将替换这些调用，如下所示：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This isn't an exact representation because inlining happens at the level of
    assembly or machine code (and not the source code), but it conveys a general picture.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个精确的表示，因为内联是在汇编语言或机器代码级别（而不是源代码级别）发生的，但它传达了一个大致的画面。
- en: The compiler does it to save time; it won't have to go through the creation
    and teardown of a new call frame, it doesn't have to look up the address of the
    next instruction to execute (and return to), and it can cache the instructions
    better as they are nearby.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器这样做是为了节省时间；它不必经历新调用帧的创建和销毁，不必查找下一条要执行（并返回）的指令地址，而且因为它们彼此相邻，编译器可以更好地缓存这些指令。
- en: Of course, inlining has some important side effects; if the function is used
    more than once, it has to be copied to all places (meaning a bigger file size
    and more memory being used). Nowadays, this may not be so critical as it was in
    the past, but it's still relevant, as we constantly develop software that has
    to run on low-end devices without much RAM to spare.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，内联有一些重要的副作用；如果函数使用不止一次，它必须被复制到所有地方（意味着文件大小更大，使用的内存更多）。如今，这可能不像过去那么关键，但仍然相关，因为我们不断开发必须在内存有限的高端设备上运行的软件。
- en: Other than that, it affects us critically when we're debugging the code we wrote.
    Inlined code is no longer at the line number it was originally written, so it's
    not as easy (or sometimes even possible) to track. This is the exact reason why
    a debugger breakpoint placed in a function that was inlined never gets hit (although
    the code is still somehow executed). To avoid this issue, we simply have to disable
    inlining for debug builds (at the cost of not testing the exact same version as
    the release build).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，当我们调试自己编写的代码时，它对我们的影响尤为关键。内联代码不再位于其最初编写的行号，因此跟踪起来不再那么容易（有时甚至不可能），这就是为什么在调试器中放置的断点永远不会被击中（尽管代码以某种方式被执行）。为了避免这个问题，我们只能禁用调试构建中的内联功能（代价是不再测试与发布构建完全相同的版本）。
- en: 'We can do that by specifying the `-O0` level for the target or going straight
    after the flags responsible:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为目标指定`-O0`级别或直接针对负责的标志：
- en: '`-finline-functions-called-once`: GCC only'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-finline-functions-called-once`：仅GCC支持'
- en: '`-finline-functions`: Clang and GCC'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-finline-functions`：Clang和GCC'
- en: '`-finline-hint-functions`: Clang only'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-finline-hint-functions`：仅Clang支持'
- en: '`-finline-functions-called-once`: GCC only'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-finline-functions-called-once`：仅GCC支持'
- en: You can explicitly disable inlining with `-fno-inline-...`. In any case, for
    details, refer to the documentation of the specific version of your compiler.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`-fno-inline-...`显式禁用内联。无论如何，对于详细信息，请参阅您编译器的特定版本的文档。
- en: Loop unrolling
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环展开
- en: Loop unrolling is an optimization technique that is also known as loop unwinding.
    The general approach is to transform loops into a set of statements that achieve
    the same effect. By doing so, we'll trade the size of the program for execution
    speed, as we'll reduce or eliminate the instruction that controls the loop – pointer
    arithmetic or end-of-loop tests.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 循环展开是一种优化技术，也被称为循环展开。通用方法是将循环转换为一组实现相同效果的语句。这样做，我们将用程序的大小换取执行速度，因为我们减少了或消除了控制循环的指令——指针算术或循环末端测试。
- en: 'Consider the following example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下示例：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The previous code will be transformed into something like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将被转换为类似这样的内容：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The outcome will be the same, but we no longer have to allocate the `i` variable,
    increment it, or compare it three times with a value of `3`. If we call `func()`
    enough times in the lifetime of the program, unrolling even such a short and small
    function will make a significant difference.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将相同，但我们不再需要分配`i`变量，增加它，或三次将其与`3`进行比较。如果我们程序运行期间调用`func()`足够多次，即使是对这样一个简短且小的函数进行展开，也会产生显著的差异。
- en: However, it is important to understand two limiting factors. Loop unrolling
    will only work if the compiler knows or can effectively estimate the amount of
    iterations. Secondly, loop unrolling can produce undesirable effects on modern
    CPUs, as increased code size might prevent effective caching.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，理解两个限制因素很重要。循环展开只有在编译器知道或可以有效估计迭代次数时才能工作。其次，循环展开可能会对现代CPU产生不希望的效果，因为代码尺寸的增加可能会阻止有效缓存。
- en: 'Each compiler offers a slightly different version of this flag:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 每个编译器提供这个标志的略有不同的版本：
- en: '`-floop-unroll`: GCC'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-floop-unroll`：GCC'
- en: '`-funroll-loops`: Clang'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-funroll-loops`：Clang'
- en: If you're in doubt, test extensively whether this flag is affecting your particular
    program and explicitly enable or disable it. Do note that on GCC, it is implicitly
    enabled with `-O3` as part of the implicitly enabled `-floop-unroll-and-jam` flag.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有疑问，广泛测试这个标志是否影响你的特定程序，并显式启用或禁用它。请注意，在GCC上，`-O3`作为隐式启用的`-floop-unroll-and-jam`标志的一部分隐式启用。
- en: Loop vectorization
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环向量化
- en: '**Single Instruction Multiple Data** (**SIMD**) is one of the mechanisms developed
    in the early 1960s to achieve parallelism. It works exactly as the name suggests;
    it can perform the same operation on multiple pieces of information at the same
    time. What does it mean in practice? Let''s consider the following example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**单指令多数据**（**SIMD**）是20世纪60年代初为实现并行化而开发的一种机制。它的工作方式正如其名称所暗示的那样；它可以同时对多块信息执行相同的操作。实际意味着什么？让我们考虑以下示例：'
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Normally, the preceding code would loop 128 times, but with a capable CPU,
    we can execute the code much faster by calculating two or more elements of the
    array at the same time. This works because there''s no dependency between consecutive
    elements and no overlap of data between arrays. Smart compilers can transform
    the preceding loop into something similar to this (which happens on the assembly
    level):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，前面的代码会循环128次，但是有了性能强大的CPU，我们可以通过同时计算数组中的两个或更多元素来大大加快代码的执行速度。这之所以可行，是因为连续元素之间没有依赖性，数组之间的数据也没有重叠。智能编译器可以将前面的循环转换成类似于此的东西（这发生在汇编语言级别）：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'GCC will enable such automatic vectorization of loops at `-O3`. Clang enables
    it by default. Both compilers offer different flags to enable/disable vectorization
    in particular:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: GCC会在`-O3`时启用循环的自动向量化。Clang默认启用。这两个编译器提供了不同的标志来启用/禁用向量化：
- en: '`-ftree-vectorize -ftree-slp-vectorize` to enable in GCC'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ftree-vectorize -ftree-slp-vectorize` 在GCC中启用'
- en: '`-fno-vectorize -fno-slp-vectorize` to disable in Clang (if things break)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-fno-vectorize -fno-slp-vectorize` 在Clang中禁用（如果东西坏了）'
- en: The performance of vectorization comes from utilizing special instructions that
    CPU manufacturers provide, rather than just simply replacing the original form
    of the loop with the unrolled version. Therefore, it's not possible to achieve
    the same level of performance by doing it manually (also, it's not very clean
    code).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化性能的提升来自于利用CPU制造商提供的特殊指令，而不仅仅是简单地将循环的原始形式替换为展开版本。因此，手动操作是无法达到相同性能水平的（而且代码也不太整洁）。
- en: The role of the optimizer is important in enhancing the performance of the program
    during runtime. By employing its strategies effectively, we'll get more bang for
    our buck. Efficiency is important not only after the coding is completed but also
    as we work on the software. If the compilation times are lengthy, we can improve
    them by managing the process better.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 优化器在提高程序运行时的性能方面起着重要作用。通过有效地运用其策略，我们可以物有所值。效率的重要性不仅在于编码完成后，还在于我们开发软件的过程中。如果编译时间过长，我们可以通过更好地管理编译过程来改进它们。
- en: Managing the process of compilation
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理编译过程
- en: As programmers and build engineers, we need to consider the other aspects of
    compilation as well – the time it takes to complete, and how easy it is to spot
    and fix mistakes made during the process of building a solution.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员和构建工程师，我们需要考虑编译的其他方面——完成所需的时间，以及如何容易地发现和修复在构建解决方案过程中犯的错误。
- en: Reducing compilation time
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少编译时间
- en: In busy projects that require many dozens of recompilations per day (or per
    hour), it's paramount that compilation is as quick as possible. This not only
    affects how tight your code-compile-test loop is but also affects your concentration
    and flow of work. Luckily, C++ is already pretty good at managing compilation
    time, thanks to separate translation units. CMake will take care of recompiling
    only sources that were impacted by recent changes. However, if we need to improve
    things even more, there are a couple of techniques we can use – header precompilation
    and unity builds.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要每天（或每小时）进行许多十几个重新编译的繁忙项目中，编译速度尽可能快是至关重要的。这不仅影响了你的代码-编译-测试循环的紧密程度，还影响了你的注意力和工作流程。幸运的是，C++在管理编译时间方面已经相当出色，这要归功于独立的翻译单元。CMake会处理仅重新编译最近更改影响的源代码。然而，如果我们需要进一步改进，我们可以使用一些技术——头文件预编译和单元构建：
- en: Precompilation of headers
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头文件预编译
- en: Header files (`.h`) are included in the translation unit by the preprocessor
    before the actual compilation begins. It means that they have to be recompiled
    every time the `.cpp` implementation files change. On top of that, if multiple
    translation files are using the same shared header, it has to be compiled every
    time it's included. This is wasteful, but that's how things were for a long time.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件（`.h`）在实际编译开始前由预处理器包含在翻译单元中。这意味着每当`.cpp`实现文件发生变化时，它们都必须重新编译。此外，如果多个翻译文件使用相同的共享头文件，每次包含时都必须重新编译。这是浪费，但长期以来一直是这样。*
- en: 'Luckily, since version 3.16, CMake offers a command to enable header precompilation.
    This allows a compiler to process headers separately from the implementation file
    and speed up the compilation. This is the syntax for the provided command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，自从版本3.16以来，CMake提供了一个命令来启用头文件预编译。这使得编译器可以单独处理头文件和实现文件，从而加快编译速度。提供命令的语法如下：*
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The list of added headers is stored in the `PRECOMPILE_HEADERS` target property.
    As you'll know from [*Chapter 4*](B17205_04_Final_JC_ePub.xhtml#_idTextAnchor106),
    *Working with Targets*, we can use the propagated properties to share the headers
    with any depending targets by using the `PUBLIC` or `INTERFACE` keyword; however,
    this shouldn't be done for targets exported with the `install()` command. Other
    projects shouldn't be forced to consume our precompiled headers (as it's unconventional).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的头文件列表存储在`PRECOMPILE_HEADERS`目标属性中。正如你在[第4章](B17205_04_Final_JC_ePub.xhtml#_idTextAnchor106)，《使用目标》中了解到的，*我们可以使用传播属性通过使用`PUBLIC`或`INTERFACE`关键字将头文件与任何依赖的目标共享；然而，对于使用`install()`命令导出的目标，不应该这样做。其他项目不应当被迫消耗我们的预编译头文件（因为这不符合常规）。*
- en: Important Note
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：*
- en: If you need precompiled headers internally and still want to install-export
    the target, the `$<BUILD_INTERFACE:...>` generator expression described in [*Chapter
    4*](B17205_04_Final_JC_ePub.xhtml#_idTextAnchor106), *Working with Targets*, will
    prevent headers from appearing in usage requirements. However, they will still
    be added to targets exported from the build tree with the `export()` command.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要内部预编译头文件但仍然希望安装导出目标，那么[第4章](B17205_04_Final_JC_ePub.xhtml#_idTextAnchor106)，《使用目标》中描述的`$<BUILD_INTERFACE:...>`生成器表达式将防止头文件出现在使用要求中。然而，它们仍然会被添加到使用`export()`命令从构建树导出的目标中。*
- en: CMake will put all headers' names in a `cmake_pch.h|xx` file, which will then
    be precompiled to a compiler-specific binary file with a `.pch`, `.gch`, or `.pchi`
    extension.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: CMake会将所有头文件的名称放入一个`cmake_pch.h|xx`文件中，然后预编译为具有`.pch`、`.gch`或`.pchi`扩展名的特定于编译器的二进制文件。*
- en: 'We can use it like so:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用它：*
- en: chapter05/06-precompile/CMakeLists.txt
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05/06-precompile/CMakeLists.txt*
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: chapter05/06-precompile/hello.cpp
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05/06-precompile/hello.cpp*
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that in our `main.cpp` file, we don't need to include `cmake_pch.h` or
    any other header – it will be force-included by CMake with compiler-specific command-line
    options.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们的`main.cpp`文件中，我们不需要包含`cmake_pch.h`或其他任何头文件——CMake会使用特定的命令行选项强制包含它们。*
- en: 'In the previous example, I have used a built-in header; however, you can easily
    add your own headers with class or function definitions:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，我使用了一个内置的头文件；然而，你可以很容易地添加自己的头文件，带有类或函数定义：*
- en: '`header.h` is interpreted as relative to the current source directory and will
    be included with an absolute path.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`header.h`被视为相对于当前源目录的，并将使用绝对路径包含进来。*'
- en: '`[["header.h"]]` is interpreted according to the compiler''s implementation
    and is usually found in the `INCLUDE_DIRECTORIES` variable. Use `target_include_directiories()`
    to configure it.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[["header.h"]]`根据编译器的实现来解释，通常可以在`INCLUDE_DIRECTORIES`变量中找到。使用`target_include_directiories()`来配置它。*'
- en: Some online references will discourage precompiling headers that aren't part
    of a standard library, such as `<iostream>`, or using precompiled headers altogether.
    This is because changing the list or editing a custom header will cause recompilation
    of all translation units in the target. With CMake, you don't need to worry as
    much, especially if you structure your project right (with relatively small targets,
    focused on a narrow domain). Every target has a separate precompiled header file
    that limits the fallout of header changes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一些在线参考资料将不鼓励预编译不属于标准库的头文件，如`<iostream>`，或使用预编译头文件。这是因为更改列表或编辑自定义头文件会导致目标中所有翻译单元的重新编译。使用CMake，你不需要担心这么多，尤其是如果你正确地组织你的项目（具有相对较小的目标，专注于狭窄的领域）。每个目标都有一个单独的预编译头文件，限制了头文件更改的扩散。*
- en: 'On the other hand, if your headers are considered fairly stable, you might
    decide that it''s a good idea to reuse precompiled headers from one target in
    another. CMake provides a handy command for this purpose:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你的头文件被认为相当稳定，你可能会决定从一个小目标中重复使用预编译的头文件到另一个目标中。CMake为此目的提供了一个方便的命令：
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This sets the `PRECOMPILE_HEADERS_REUSE_FROM` property of the target reusing
    the headers and creates a dependency between these targets. By using this method,
    the consuming target can no longer specify its own precompiled headers. Additionally,
    all *compile options*, *compile flags*, and *compile definitions* must match between
    targets. Pay attention to requirements, especially if you have any headers that
    use the double bracket format (`[["header.h"]]`). Both targets need to set their
    *include paths* appropriately to make sure those headers are found by the compiler.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了使用头文件的目标的`PRECOMPILE_HEADERS_REUSE_FROM`属性，并在这些目标之间创建了一个依赖关系。使用这种方法，消费目标无法再指定自己的预编译头文件。另外，所有*编译选项*、*编译标志*和*编译定义*必须在目标之间匹配。注意要求，特别是如果你有任何使用双括号格式的头文件（`[["header.h"]]`）。两个目标都需要适当地设置它们的*包含路径*，以确保编译器能够找到这些头文件。
- en: Unity builds
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Unity构建
- en: CMake 3.16 also introduced another compilation time optimization feature – unity
    builds, also known as *unified build* or *jumbo build*. Unity builds combine multiple
    implementation source files with the `#include` directive (after all, a compiler
    doesn't know whether it's including headers or implementation). This has a few
    interesting implications – some are really useful and others are potentially harmful.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 3.16还引入了另一个编译时间优化功能——统一构建，也称为*统一构建*或*巨构建*。统一构建将多个实现源文件与`#include`指令结合在一起（毕竟，编译器不知道它是在包含头文件还是实现）。这带来了一些有趣的含义——有些是非常有用的，而其他的是潜在有害的。
- en: 'Let''s start with the most obvious one – avoiding recompilation of headers
    in different translation units when CMake creates a unified build file:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最明显的一个开始——避免在CMake创建统一构建文件时在不同翻译单元中重新编译头文件：
- en: '[PRE30]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When both of these sources contain a `#include "header.h"` line, it will only
    be parsed once thanks to *include guards* (assuming we didn't forget to add those).
    This isn't as elegant as precompiled headers, but it's an option.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当这两个源中都包含`#include "header.h"`行时，多亏了*包含守卫*（假设我们没有忘记添加那些），它只会被解析一次。这不如预编译头文件优雅，但这是一个选项。
- en: The second benefit from this type of build is the fact that the optimizer may
    now act on a greater scale and optimize interprocedural calls across all bundled
    sources. This is similar to link-time optimization, as we discussed in [*Chapter
    2*](B17205_02_Final_JC_ePub.xhtml#_idTextAnchor051), *The CMake Language*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构建方式的第二个好处是，优化器现在可以更大规模地作用，并优化所有捆绑源之间的跨过程调用。这类似于我们在[第2章](B17205_02_Final_JC_ePub.xhtml#_idTextAnchor051)《CMake语言》中讨论的链接时间优化。
- en: However, these benefits come at a price. As we reduced the number of the *object
    files* and processing steps, we also increased the amount of necessary memory
    to process much larger files. Additionally, we reduced the amount of parallelizable
    work. Compilers aren't really that great at multithreaded compiling because they
    don't need to be – the buildsystem will usually kick-start many compilation tasks
    to execute all the files simultaneously on different threads. When we clump all
    files together, we make it much harder, as CMake will now schedule parallel builds
    across however many jumbo builds we create.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些好处是有代价的。因为我们减少了*对象文件*的数量和处理步骤，我们也增加了处理更大文件所需的内存量。此外，我们减少了并行化工作量。编译器并不是真正那么擅长多线程编译，因为它们不需要——构建系统通常会启动许多编译任务，以便在不同的线程上同时执行所有文件。当我们把所有文件放在一起时，我们会使它变得困难得多，因为CMake现在会在我们创建的多个巨构建之间安排并行构建。
- en: With unity builds, you also need to consider some C++ semantic implications
    that might not be so obvious to catch – anonymous namespaces hiding symbols across
    files are now scoped to the group. The same thing happens with static global variables,
    functions, and macro definitions. It may cause name collisions, or incorrect function
    overloads to be executed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用统一构建时，你还需要考虑一些可能不是那么明显捕捉到的C++语义含义——匿名命名空间跨文件隐藏符号现在被分组到一组中。静态全局变量、函数和宏定义也是如此。这可能会导致名称冲突，或者执行不正确的函数重载。
- en: Jumbo builds are not desirable when recompiling, as they will compile many more
    files than needed. They work best when the code is meant to compile all files
    as fast as possible as a whole. Tests done on Qt Creator show that you can expect
    an improvement anywhere between 20% to 50% (depending on the compiler used).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新编译时，巨构构建不受欢迎，因为它们会编译比所需更多的文件。当代码旨在尽可能快地整体编译所有文件时，它们效果最佳。在Qt Creator上进行的测试表明，您可以期待性能提升在20%到50%之间（取决于所使用的编译器）。
- en: 'To enable unity builds, we have two options:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 启用统一构建，我们有两个选项：
- en: Set the `CMAKE_UNITY_BUILD` variable to `true` – it will initialize the `UNITY_BUILD`
    property on every target defined thereafter.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`CMAKE_UNITY_BUILD`变量设置为`true`——它将在定义后的每个目标上初始化`UNITY_BUILD`属性。
- en: Manually define `UNITY_BUILD` as `true` on every target that should use unity
    builds.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动将`UNITY_BUILD`设置为每个应使用统一构建的目标的`true`。
- en: 'The second option is achieved by calling the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是通过以下方式实现的：
- en: '[PRE31]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: By default, CMake will create builds containing eight source files, as specified
    by the `UNITY_BUILD_BATCH_SIZE` property of a target (copied at the creation of
    a target from the `CMAKE_UNITY_BUILD_BATCH_SIZE` variable). You can change the
    target property or default variable.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CMake将创建包含八个源文件的构建，这是由目标的`UNITY_BUILD_BATCH_SIZE`属性指定的（在创建目标时从`CMAKE_UNITY_BUILD_BATCH_SIZE`变量复制）。您可以更改目标属性或默认变量。
- en: 'Since version 3.18, you may decide that you''d like to explicitly define how
    files should be bundled with named groups. To do so, change the target''s `UNITY_BUILD_MODE`
    property to `GROUP` (the default is always `BATCH`). Then, you''ll need to assign
    your source files to groups by setting their `UNITY_GROUP` property to the name
    of your choosing:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本3.18起，你可以选择明确地定义文件如何与命名组一起打包。为此，将目标的`UNITY_BUILD_MODE`属性更改为`GROUP`（默认值始终为`BATCH`）。然后，你需要通过将他们的`UNITY_GROUP`属性设置为你选择的名称来为源文件分配组：
- en: '[PRE32]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: CMake will then disregard `UNITY_BUILD_BATCH_SIZE` and add all files from the
    group to a single jumbo build.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，CMake将忽略`UNITY_BUILD_BATCH_SIZE`，并将组中的所有文件添加到单个巨构构建中。
- en: CMake's documentation advises against enabling unity builds for public projects
    by default. It is recommended that the end user of your application should be
    able to decide whether they want jumbo builds or not by providing the `DCMAKE_UNITY_BUILD`
    command-line argument. What's more, if they cause issues because of how your code
    is written, you should explicitly set the target's property to `false`. However,
    nothing is stopping you from enabling this feature for code that will be used
    internally, such as inside a company or for your private project.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: CMake的文档建议不要默认启用公共项目的统一构建。建议您的应用程序的最终用户能够通过提供`DCMAKE_UNITY_BUILD`命令行参数来决定他们是否需要巨构构建。更重要的是，如果由于您的代码编写方式而引起问题，您应该明确将目标属性设置为`false`。然而，这并不妨碍您为内部使用的代码启用此功能，例如在公司内部或为您私人项目使用。
- en: Unsupported C++20 modules
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不支持的C++20模块
- en: If you follow the C++ standard releases closely, you will be aware of the new
    feature introduced in C++20 – modules. This is a significant game changer. It
    allows you to avoid many nuisances when using headers, reduces build time, and
    allows for cleaner, more compact code that is easier to navigate and reason about.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你密切关注C++标准的发布，你会知道C++20引入了一个新特性——模块。这是一个重大的变革。它允许你避免使用头文件时的许多烦恼，减少构建时间，并使得代码更简洁、更易于导航和推理。
- en: 'Essentially, instead of creating a separate header and implementation file,
    we can create a single file with module declaration:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，我们可以创建一个带有模块声明的单文件，而不是创建一个单独的头部和实现文件：
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, you can use it in your code by simply importing it:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在代码中简单地导入它：
- en: '[PRE34]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note how we aren't relying on a preprocessor anymore; modules have their own
    keywords – `import`, `export`, and `module`. The latest versions of the most popular
    compilers can already perform all the necessary tasks to support modules as the
    new method of writing and building C++ solutions. It was my hope that by the time
    this chapter was started, some early support for modules would already have been
    provided in CMake. Unfortunately, this hasn't happened just yet.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不再依赖预处理器；模块有自己的关键字——`import`、`export`和`module`。最受欢迎的编译器最新版本已经可以执行所有必要的任务，以支持模块作为编写和构建C++解决方案的新方法。我原本希望在本章开始时，CMake已经提供了对模块的早期支持。不幸的是，这一点尚未实现。
- en: However, it might be available by the time you have bought this book (or soon
    after). There are some really good indicators; Kitware developers have created
    (and released in 3.20) a new, experimental feature to support C++20 module dependency
    scanning for the Ninja generator. For now, it's only intended for compiler writers
    so that they can test their dependency scanning tools as they are being developed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到你购买这本书的时候（或不久之后）可能就有了。有一些非常好的指标；Kitware开发者已经创建（并在3.20中发布）了一个新的实验性特性，以支持C++20模块依赖项扫描对Ninja生成器的支持。现在，它只打算供编译器编写者使用，这样他们就可以在开发过程中测试他们的依赖项扫描工具。
- en: When this much-anticipated feature is finished and available in a stable release,
    I suggest researching it thoroughly. I expect it will simplify and speed up the
    compilation way beyond anything available today.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个备受期待的特性完成并在一个稳定的版本中可用时，我建议彻底研究它。我预计它将简化并大大加快编译速度，超过今天可用的任何东西。
- en: Finding mistakes
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找错误。
- en: As programmers, we spend a lot of time bug hunting. It's a sad fact. Finding
    errors and solving them can often get under our skin, especially if it takes long
    hours. It's even more difficult when we are flying blind, without instruments
    to help us navigate through the storm. This is why we should apply great care
    to set our environment in a way that makes this process as easy and as bearable
    as possible. We do this by configuring the compiler with `target_compile_options()`.
    Which *compile options* could help us then?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们花了很多时间寻找bug。这是一个悲哀的事实。查找并解决错误常常会让我们感到不舒服，尤其是如果它需要长时间的话。如果我们没有仪器帮助我们导航暴风雨，盲目飞行会更困难。这就是为什么我们应该非常小心地设置我们的环境，使这个过程尽可能容易和可忍受。我们通过使用`target_compile_options()`配置编译器来实现这一点。那么*编译选项*能帮助我们什么呢？
- en: Configuring errors and warnings
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置错误和警告。
- en: There are many great stressful things about software development – fixing critical
    bugs in the middle of the night, working on high-visibility, costly failures in
    large systems, and dealing with annoying compilation errors, especially with those
    that are hard to understand or impossibly tedious to fix. When researching a subject
    in order to simplify your work and reduce the chance of failure, you'll find a
    lot of recommendations on how to configure the compiler's warnings.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中有许多令人压力很大的事情——比如在半夜修复关键错误、在高知名度的大型系统中处理昂贵的失败、以及处理那些令人烦恼的编译错误，尤其是那些难以理解或修复起来极其繁琐的错误。当研究一个主题以简化你的工作并减少失败的可能性时，你会发现有很多关于如何配置编译器警告的建议。
- en: One such fine piece of advice is to enable the `-Werror` flag as default for
    all builds. What this flag does is innocently simple – all warnings are treated
    as errors, and the code won't compile unless you resolve all of them. While it
    may seem like a good idea, it hardly ever is.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一条这样的好建议就是为所有构建启用`-Werror`标志作为默认设置。这个标志做的简单而无辜的事情是——所有警告都被视为错误，除非你解决所有问题，否则代码不会编译。虽然这可能看起来是个好主意，但几乎从来不是。
- en: You see, warnings aren't errors for a reason. They're meant to warn you about
    things. It's up to you to decide what to do about that. Having the freedom to
    ignore a warning, especially when you experiment with and prototype your solution,
    is often a blessing.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，警告之所以不是错误，是有原因的。它们是用来警告你的。决定如何处理这是你的事。拥有忽视警告的自由，尤其是在你实验和原型化解决方案时，通常是一种祝福。
- en: On the other hand, if you have a perfect, no-warnings, all-shiny piece of code,
    it's a shame to allow future changes to ruin this state of things. What harm could
    come from enabling it and just keeping it there? Seemingly none. At least until
    your compiler gets upgraded, that is. New versions of compilers tend to be stricter
    about deprecated features or just get better about suggesting things to improve.
    This is great when you don't treat all warnings as errors, but when you do, you'll
    discover one day that your build starts breaking without changes in the code or,
    even more frustrating, when you need to quickly fix a problem totally unrelated
    to a new warning.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你有一个完美无瑕、没有警告、闪闪发光的代码，允许未来的更改破坏这种情况真是太可惜了。启用它并只是保持在那里会有什么害处呢？表面上看起来没有。至少在你升级编译器之前是这样。编译器的新版本往往对弃用的特性更加严格，或者更好地提出改进建议。当你不将所有警告视为错误时，这很好，但当你这样做时，有一天你会发现你的构建开始在没有代码更改的情况下失败，或者更令人沮丧的是，当你需要快速修复一个与新警告完全无关的问题时。
- en: What is this "hardly ever" case, when you actually should enable all the warnings
    possible? The quick answer is when you're writing a public library. Then, you
    really want to avoid issue tickets complaining about your code being naughty just
    because it is compiled in a stricter environment than yours. If you decide to
    enable it, make sure that you're up to speed with new versions of the compiler
    and the warnings it introduces.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，“几乎不”是什么意思，当你实际上应该启用所有可能的警告时？快速答案是当你编写一个公共库时。这时，你真的想避免因为你的代码在一个比你的环境更严格的编译器中编译而产生问题报告。如果你决定启用它，请确保你对编译器的新版本和它引入的警告了如指掌。
- en: Otherwise, let warnings be warnings, and focus on errors. If you feel an internal
    need to be pedantic, use the `-Wpedantic` flag. This is an interesting one – it
    enables all the warnings demanded by strict ISO C and ISO C++. Do note that you
    can't check whether the code is conforming to the standard with this flag – it
    will only find non-ISO practices that require a diagnostic message.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，让警告就是警告，专注于错误。如果你觉得自己有必要吹毛求疵，可以使用`-Wpedantic`标志。这是一个有趣的选择——它启用了所有严格遵循ISO
    C和ISO C++所要求的警告。请注意，使用此标志并不能检查代码是否符合标准——它只能找到需要诊断信息的非ISO实践。
- en: More lenient and down-to-earth coders will be satisfied with `-Wall` and optionally
    with `-Wextra` for that extra-fancy feel. These are considered to be actually
    useful and meaningful warnings that you should fix in your code when you have
    a spare moment.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 更加宽容和脚踏实地的程序员会对`-Wall`感到满意，可选地加上`-Wextra`，以获得那种额外的华丽感觉。这些被认为是有实际用处和意义的警告，当你有空时应该修复你的代码中的这些问题。
- en: There are plenty of other warning flags, which might be useful depending on
    the kind of project. I recommend that you read the manual for your chosen compiler
    and see what's available.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的警告标志，这取决于项目的类型可能会有所帮助。我建议你阅读你选择的编译器的手册，看看有什么可用。
- en: Debugging the build
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试构建过程
- en: Occasionally, compilation will break. This usually happens when we try to refactor
    a bunch of code or clean up our buildsystem. Sometimes, things get resolved easily,
    but then there are much more complex problems that require a deep dive into the
    steps of the configuration. We already know how to print more verbose CMake outputs
    (as discussed in [*Chapter 1*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014),
    *First Steps with CMake*), but how do we analyze what actually happens under the
    hood at each stage?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，编译会失败。这通常发生在我们试图重构一堆代码或清理我们的构建系统时。有时，事情很容易解决，但随后会有更复杂的问题，需要深入分析配置的每个步骤。我们已经知道如何打印更详细的CMake输出（如在[第1章](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014)中讨论的，*CMake的初步步骤*），但我们如何分析在每个阶段实际发生的情况呢？
- en: Debugging individual stages
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调试单个阶段
- en: 'There is a `-save-temps` flag we can pass to the compilers (both GCC and Clang
    have it) that will force the output of each stage to be stored in a file instead
    of memory:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向编译器传递`-save-temps`标志（GCC和Clang都有这个标志），它将强制将每个阶段的输出存储在文件中，而不是内存中：
- en: chapter05/07-debug/CMakeLists.txt
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05/07-debug/CMakeLists.txt
- en: '[PRE35]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding snippet will usually produce two extra files:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段通常会产生两个额外的文件：
- en: '`<build-tree>/CMakeFiles/<target>.dir/<source>.ii`: Stores the output of the
    preprocessing stage, with comments explaining where each part of the source code
    comes from:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<build-tree>/CMakeFiles/<target>.dir/<source>.ii`：存储预处理阶段的输出，带有注释解释源代码的每一部分来自哪里：'
- en: '[PRE36]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`<build-tree>/CMakeFiles/<target>.dir/<source>.s`: The output of the linguistic
    analysis stage, ready for the assembler stage:'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<build-tree>/CMakeFiles/<target>.dir/<source>.s`：语言分析阶段的输出，准备进入汇编阶段：'
- en: '[PRE37]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Depending on the kind of problem, we can usually discover what the actual issue
    is. The output of the preprocessor can be useful to discover bugs such as incorrect
    *include paths* (providing the wrong version of libraries) and mistakes with definitions
    causing incorrect `#ifdef` evaluations.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 根据问题的性质，我们通常可以发现实际的问题所在。预处理器的输出对于发现诸如不正确的*include路径*（提供错误版本的库）以及导致错误`#ifdef`评估的定义错误等bug很有帮助。
- en: The output of the linguistic analysis is useful for targeting specific processors
    and solving critical optimization problems.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 语言分析阶段的输出对于针对特定处理器和解决关键优化问题很有用。
- en: Debugging issues with header file inclusion
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决头文件包含的调试问题
- en: 'Incorrectly included files can be a really hard problem to debug. I should
    know – it was my first corporate job to port an entire code base from one buildsystem
    to another. If you ever find yourself in a position that requires an exact understanding
    of which paths are being used to include a requested header, use `-H`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 错误地包含的文件可能是一个真正难以调试的问题。我应该知道——我的第一份企业工作就是将整个代码库从一种构建系统移植到另一种。如果你发现自己需要精确了解正在使用哪些路径来包含请求的头文件，可以使用`-H`：
- en: chapter05/07-debug/CMakeLists.txt
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: chapter05/07-debug/CMakeLists.txt
- en: '[PRE38]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The printed output will look similar to this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出的输出将类似于这样：
- en: '[PRE39]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After the name of *object file*, each row in the output contains a path to a
    header. A single dot at beginning of the line means top-level inclusion (the `#include`
    directive is in `hello.cpp`). Two dots mean that this file is included by `<iostream>`.
    Every further dot indicates yet another level of nesting.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在`object file`的名称之后，输出中的每一行都包含一个头文件的路径。行首的一个点表示顶级包含（`#include`指令在`hello.cpp`中）。两个点意味着这个文件被`<iostream>`包含。进一步的点表示嵌套的又一层。
- en: 'At the end of this output, you may also find suggestions of possible improvements
    to your code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出的末尾，你也许还会找到对代码可能的改进建议：
- en: '[PRE40]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You're not required to fix the standard library, but you might see some of your
    own headers. You may want to correct them.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必修复标准库，但可能会看到一些自己的头文件。你可能想修正它们。
- en: Providing information for the debugger
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供调试器信息
- en: Machine code is a cryptic list of instructions and data encoded in binary format.
    It doesn't convey any meaning or objective. This is because the CPU doesn't care
    what the goal of the program is or what the sense of all of the instructions is.
    The only requirement is the correctness of the code. The compiler will translate
    all of the preceding into numeric identifiers of CPU instructions, some data to
    initialize the memory, and thousands of memory addresses. In other words, the
    final binary doesn't need to contain the actual source code, variable names, signatures
    of functions, or any other details that programmers care about. And that's the
    default output of the compiler – raw and dry.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 机器代码是一系列用二进制格式编码的指令和数据，它不传达任何意义或目标。这是因为CPU不关心程序的目标是什么，或者所有指令的含义是什么。唯一的要求是代码的正确性。编译器会将所有内容转换成CPU指令的数值标识符、一些用于初始化内存的数据以及成千上万的内存地址。换句话说，最终的二进制文件不需要包含实际的源代码、变量名、函数签名或程序员关心的任何其他细节。这就是编译器的默认输出——原始且干燥。
- en: This is done primarily to save space and execute without too much overhead.
    By coincidence, we are also (somewhat) protecting our application from reverse
    engineering. Yes, you can understand what each CPU instruction does without the
    source code (for example, copy this integer to that register). But in the end,
    even basic programs contain too many of them to easily think about the big picture.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做主要是为了节省空间并在执行时尽量减少开销。巧合的是，我们也在一定程度上（somewhat）保护了我们的应用程序免受逆向工程。是的，即使没有源代码，你也可以理解每个CPU指令做什么（例如，将这个整数复制到那个寄存器）。但最终，即使是基本程序也包含太多这样的指令，很难思考大局。
- en: If you're a particularly driven individual, you can use a tool called a **disassembler**,
    and with a lot of knowledge (and a little luck), you'll be able to understand
    what might be going on. This approach isn't very practical, as disassembled code
    doesn't have original symbols, so it's extremely hard and slow to untangle what
    goes where.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个特别有驱动力的人，你可以使用一个名为**反汇编器**的工具，并且凭借大量的知识（还有一点运气），你将能够理解可能发生了什么。这种方法并不非常实用，因为反汇编代码没有原始符号，所以很难且缓慢地弄清楚哪些部分应该放在哪里。
- en: Instead, we can ask the compiler to store the source code in the produced binary
    along with the map containing references between compiled and original code. Then,
    we can hook a debugger to a running program and see which source line is being
    executed at any given moment. This is indispensable when we're working on code,
    such as writing new functionality or correcting mistakes.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以要求编译器将源代码存储在生成的二进制文件中，并与包含编译后和原始代码之间引用关系的映射一起存储。然后，我们可以将调试器连接到运行中的程序，并查看任何给定时刻正在执行哪一行源代码。当我们编写代码时，例如编写新功能或修正错误，这是不可或缺的。
- en: 'These two use cases are the reason for two configs: `Debug` and `Release`.
    As we saw earlier, CMake will provide some flags to the compiler by default to
    manage this process, storing them first in global variables:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个用例是两个配置文件（`Debug`和`Release`）的原因。正如我们之前看到的，CMake会默认提供一些标志给编译器来管理这个过程，首先将它们存储在全局变量中：
- en: '`CMAKE_CXX_FLAGS_DEBUG` contains `-g`.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CXX_FLAGS_DEBUG`包含了`-g`。'
- en: '`CMAKE_CXX_FLAGS_RELEASE` contains `-DNDEBUG`.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CXX_FLAGS_RELEASE`包含了`-DNDEBUG`。'
- en: The `-g` flag simply means *add debugging information*. It's provided in the
    operating system's native format – stabs, COFF, XCOFF, or DWARF. These formats
    can be then accessed by debuggers such as `gdb` (the GNU debugger). Usually, this
    is good enough for IDEs such as CLion (as they use `gdb` under the hood). In other
    cases, refer to the manual of the provided debugger and check what the appropriate
    flag is for the compiler of your choice.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g`标志的意思是*添加调试信息*。它以操作系统的本地格式提供——stabs、COFF、XCOFF或DWARF。这些格式随后可以被诸如`gdb`（GNU调试器）之类的调试器访问。通常，这对于像CLion这样的IDE来说已经足够好了（因为它们在底层使用`gdb`）。在其他情况下，请参考提供的调试器的手册，并检查对于您选择的编译器，适当的标志是什么。'
- en: 'For the `RELEASE` config, CMake will add the `-DNDEBUG` flag. It''s a preprocessor
    definition, which simply means *not a debug build*. Some debug-oriented macros
    may not work when this option is enabled. One of them is `assert`, available in
    the `<assert.h>` header file. If you decide to use assertions in your production
    code, they simply won''t work:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`RELEASE`配置，CMake将添加`-DNDEBUG`标志。这是一个预处理器定义，简单意味着*不是调试构建*。当启用此选项时，一些面向调试的宏可能不会工作。其中之一就是`assert`，它在`<assert.h>`头文件中可用。如果你决定在你的生产代码中使用断言，它们将根本不会工作：
- en: '[PRE41]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `assert(my_boolean)` call won''t have any effect in the `Release` config,
    but it will work just fine in `Debug`. What do you do if you''re practicing assertive
    programming and still need to use `assert()` for release builds? Either change
    the defaults that are provided by CMake (remove `NDEBUG` from `CMAKE_CXX_FLAGS_RELEASE`)
    or implement a hardcoded override by undefining the macro before the header inclusion:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Release`配置中，`assert(my_boolean)`调用将不会产生任何效果，但在`Debug`模式下它会正常工作。如果你在实践断言性编程的同时还需要在发布构建中使用`assert()`，你会怎么做？要么更改CMake提供的默认设置（从`CMAKE_CXX_FLAGS_RELEASE`中移除`NDEBUG`），要么通过在包含头文件前取消定义宏来实现硬编码覆盖：
- en: '[PRE42]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Refer to the assert reference for more information: [https://en.cppreference.com/w/c/error/assert](https://en.cppreference.com/w/c/error/assert).'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`assert`的更多信息，请参考：[https://en.cppreference.com/w/c/error/assert](https://en.cppreference.com/w/c/error/assert)。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have completed yet another chapter! There is no doubt that compilation is
    a complex process. With all its edge cases and specific requirements, it can be
    difficult to manage without a good tool. Thankfully, CMake is doing a great job
    in supporting us here.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了又一章！毫无疑问，编译是一个复杂的过程。有了所有的边缘情况和特定要求，如果没有一个好工具，管理起来可能会很困难。幸运的是，CMake在这方面做得很好。
- en: What have we learned so far? We started by discussing what compilation is and
    where it fits in the larger story of building and running applications in the
    operating system. We then examined what the stages of compilation are and the
    internal tools that manage them. This is very useful in resolving all the issues
    in more advanced cases that we might encounter down the line.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们学到了什么？我们首先讨论了编译是什么以及它在操作系统中构建和运行应用程序的更广泛故事中的位置。然后，我们研究了编译的阶段以及管理它们的内部工具。这对于解决我们将来可能会遇到的更高级别案例中的所有问题非常有用。
- en: Then, we looked at how to ask CMake to verify whether the compiler available
    on the host is meeting all the necessary requirements for our code to build. As
    we have already established, it's a much better experience for users of our solution
    to see a friendly message asking them to upgrade, rather than some arcane error
    printed by an old compiler that is confused by the new features of the language.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了如何让CMake验证宿主上可用的编译器是否满足我们代码构建的所有必要要求。正如我们之前所确定的，对于我们的解决方案的用户来说，看到一个友好的消息要求他们升级，而不是由一个混淆于语言新特性的旧编译器打印出的某些神秘错误，会是一个更好的体验。
- en: We shortly discussed how to add sources to already defined targets, and moved
    on to the configuration of the preprocessor. This was quite a big subject, as
    this stage brings all bits of the code together and decides which of them will
    be ignored. We talked about providing paths to files and adding custom definitions
    as single arguments and in bulk (along with some use cases).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要讨论了如何向已定义的目标添加源代码，然后转向预处理器配置。这是一个相当大的主题，因为这一阶段将所有的代码片段汇集在一起，决定哪些将被忽略。我们谈论了提供文件路径以及作为单个参数和批量（还有一些用例）添加自定义定义。
- en: Then, we discussed the optimizer; we explored all the general levels of optimization
    and what kind of flags they imply, but we also went into details about a few of
    them – `finline`, `floop-unroll`, and `ftree-vectorize`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了优化器；我们探索了所有通用优化级别的优化以及它们隐含的标志，但我们也详细讨论了其中的一些——`finline`、`floop-unroll`和`ftree-vectorize`。
- en: Finally, it was time to research the bigger picture again and study how to manage
    the viability of compilation. We tackled two main aspects here – reducing the
    time of compilation (and, by extension, strengthening the focus of the programmer)
    and finding mistakes. The latter is extremely important for discovering what is
    broken and how. Setting the tools correctly and understanding why things happen
    goes a long way in ensuring the quality of the code (and our mental health).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是再次研究整体编译流程和如何管理编译可行性的时候了。在这里我们解决了两个主要问题——减少编译时间（从而加强程序员的注意力集中）和查找错误。后者对于发现什么坏了和如何坏是非常重要的。正确设置工具并了解事情为何如此发生，在确保代码质量（以及我们的心理健康）方面起着很长的作用。
- en: In the next chapter, we'll learn about linking, and all the things we need to
    consider to build libraries and use them in our projects.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习链接知识，以及我们需要考虑的所有构建库和使用它们的项目中的事情。
- en: Further reading
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following: *CMake-supported compile features and compilers:* [https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#supported-compilers](https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#supported-compilers)'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于本章涵盖的更多信息，你可以参考以下内容：*CMake支持的编译特性和编译器：* [https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#supported-compilers](https://cmake.org/cmake/help/latest/manual/cmake-compile-features.7.html#supported-compilers)
- en: '*Managing sources for targets:*'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理目标源文件：*'
- en: '[https://stackoverflow.com/questions/32411963/why-is-cmake-file-glob-evil](https://stackoverflow.com/questions/32411963/why-is-cmake-file-glob-evil)'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stack Overflow讨论：为什么CMake的文件匹配功能这么“邪恶”？](https://stackoverflow.com/questions/32411963/why-is-cmake-file-glob-evil)'
- en: '[https://cmake.org/cmake/help/latest/command/target_sources.html](https://cmake.org/cmake/help/latest/command/target_sources.html)'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CMake官方文档：target_sources命令](https://cmake.org/cmake/help/latest/command/target_sources.html)'
- en: '*Providing paths to included files:*'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供包含文件的路径：*'
- en: '[https://en.cppreference.com/w/cpp/preprocessor/include](https://en.cppreference.com/w/cpp/preprocessor/include)'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[C++参考：预处理器中的#include指令](https://en.cppreference.com/w/cpp/preprocessor/include)'
- en: '[https://cmake.org/cmake/help/latest/command/target_include_directories.html](https://cmake.org/cmake/help/latest/command/target_include_directories.html)'
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CMake官方文档：target_include_directories命令](https://cmake.org/cmake/help/latest/command/target_include_directories.html)'
- en: '*Configuring headers:* [https://cmake.org/cmake/help/latest/command/configure_file.html](https://cmake.org/cmake/help/latest/command/configure_file.html)'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置头文件：* [CMake官方文档：configure_file命令](https://cmake.org/cmake/help/latest/command/configure_file.html)'
- en: '*Pre-compilation of headers:* [https://cmake.org/cmake/help/latest/command/target_precompile_headers.html](https://cmake.org/cmake/help/latest/command/target_precompile_headers.html)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*预编译头文件：* [CMake官方文档：target_precompile_headers命令](https://cmake.org/cmake/help/latest/command/target_precompile_headers.html)'
- en: '*Unity builds:*'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*统一构建：*'
- en: '[https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html](https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html)'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CMake官方文档：UNITY_BUILD属性](https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html)'
- en: '[https://www.qt.io/blog/2019/08/01/precompiled-headers-and-unity-jumbo-builds-in-upcoming-cmake](https://www.qt.io/blog/2019/08/01/precompiled-headers-and-unity-jumbo-builds-in-upcoming-cmake)'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Qt官方博客：关于即将到来的CMake中的预编译头文件和大型构建](https://www.qt.io/blog/2019/08/01/precompiled-headers-and-unity-jumbo-builds-in-upcoming-cmake)'
- en: '*Finding mistakes – compiler flags:* [https://interrupt.memfault.com/blog/best-and-worst-gcc-clang-compiler-flags](https://interrupt.memfault.com/blog/best-and-worst-gcc-clang-compiler-flags)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查找错误——编译器标志：* [https://interrupt.memfault.com/blog/best-and-worst-gcc-clang-compiler-flags](https://interrupt.memfault.com/blog/best-and-worst-gcc-clang-compiler-flags)'
- en: '*Why use libraries and not object files:* [https://stackoverflow.com/questions/23615282/object-files-vs-library-files-and-why](https://stackoverflow.com/questions/23615282/object-files-vs-library-files-and-why)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为什么使用库而不是对象文件：* [https://stackoverflow.com/questions/23615282/object-files-vs-library-files-and-why](https://stackoverflow.com/questions/23615282/object-files-vs-library-files-and-why)'
- en: '*Separation of concerns:* [https://nalexn.github.io/separation-of-concerns/](https://nalexn.github.io/separation-of-concerns/)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离关注点：*[https://nalexn.github.io/separation-of-concerns/](https://nalexn.github.io/separation-of-concerns/*
