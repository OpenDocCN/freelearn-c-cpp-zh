- en: System Types for C and C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C和C++的系统类型
- en: With a system program, simple things, such as integer types, become complicated.
    This entire chapter is devoted toward common problems that arise when performing
    system programming, especially when performing system programming for multiple
    CPU architectures, operating systems, and user space/kernel communications, such
    as system calls.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过系统程序，诸如整数类型之类的简单事物变得复杂。整个章节都致力于解决在进行系统编程时出现的常见问题，特别是在为多个CPU架构、操作系统和用户空间/内核通信（如系统调用）进行系统编程时出现的问题。
- en: 'This chapter consists of the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: An explanation of the default types that C and C++ provide, including types
    that most programmers are familiar with, such as `char` and `int`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释C和C++提供的默认类型，包括大多数程序员熟悉的类型，如`char`和`int`
- en: A review of some of the standard integer types provided by `stdint.h` to address
    limitations with the default types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾`stdint.h`提供的一些标准整数类型，以解决默认类型的限制
- en: Structure packing and the complications associated with optimizations and type
    conversions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构打包和与优化和类型转换相关的复杂性
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To compile and execute the examples in this chapter, the reader must have the
    following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和执行本章中的示例，读者必须具备以下条件：
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够编译和执行C++17的基于Linux的系统（例如，Ubuntu 17.10+）
- en: GCC 7+
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 7+
- en: CMake 3.6+
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.6+
- en: An internet connection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: To download all of the code in this chapter, including the examples and code
    snippets, please go to the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter03).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载本章中的所有代码，包括示例和代码片段，请访问以下链接：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter03)。
- en: Exploring C and C++ default types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索C和C++的默认类型
- en: 'The C and C++ languages come with several built-in types that come with the
    language, without the need for additional header files or language features. In
    this section, we will be discussing the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++语言提供了几种内置类型，无需额外的头文件或语言特性。在本节中，我们将讨论以下内容：
- en: '`char`, `wchar_t`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`，`wchar_t`'
- en: '`short int`, `int`, `long int`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short int`，`int`，`long int`'
- en: '`float`, `double`, `long double`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`，`double`，`long double`'
- en: '`bool` (C++ only)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`（仅限C++）'
- en: Character types
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符类型
- en: 'The most basic type in C and C++ is the following character type:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++中最基本的类型是以下字符类型：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A `char` is an integer type that, on most platforms, is 8 bits in size, and must
    be capable of taking on the value range of [`0`, `255`] for unsigned, and [`-127`,
    `127`] for signed. The difference between a `char` and the other integer types
    is that a `char` has a special meaning, corresponding with the **American Standard
    Code for Information Interchange** (**ASCII**). In the preceding example, the
    uppercase letter `B` is represented by the 8-bit value `0x42`. It should be noted
    that although a `char` can be used to simply represent an 8-bit integer type,
    its default meaning is a character type; that''s why it has a special meaning.
    For example, consider the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`char`是一个整数类型，在大多数平台上，它的大小为8位，必须能够接受无符号的值范围为[`0`，`255`]，有符号的值范围为[`-127`，`127`]。`char`与其他整数类型的区别在于，`char`具有特殊含义，对应着**美国信息交换标准代码**（**ASCII**）。在前面的示例中，大写字母`B`由8位值`0x42`表示。需要注意的是，虽然`char`可以用来简单表示8位整数类型，但它的默认含义是字符类型；这就是为什么它具有特殊含义。例如，考虑以下代码：'
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the previous example, we represented the same integer type, `0x42`, using
    both an `int` (to be explained later) and a `char`. These two values are, however,
    output to `stdout` in two different ways. The integer is output as an integer
    while, using the same APIs, the `char` is output as its ASCII representation.
    In addition, arrays of `char` types are considered to be an ASCII string type
    in both C and C++, which also has a special meaning. The following code shows
    this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`int`（稍后将解释）和`char`来表示相同的整数类型`0x42`。然而，这两个值以两种不同的方式输出到`stdout`。整数以整数形式输出，而使用相同的API，`char`以其ASCII表示形式输出。此外，`char`类型的数组在C和C++中被认为是ASCII字符串类型，这也具有特殊含义。以下代码显示了这一点：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the preceding example, we understand the following. We define an ASCII
    string using a `char` pointer (an unbounded array type would also work in this
    case); `std::cout` understands how to handle this type by default, and a `char` array
    has a special meaning. Changing the array type to an `int` would not compile,
    as the compiler would not know how to convert the string to an array on integers,
    and `std::cout` would not know, by default, how to handle the array of integers,
    even though, on some platforms, an `int` and a `char` might actually be the same
    type.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，我们了解到以下内容。我们使用`char`指针（在这种情况下，无界数组类型也可以）定义了一个ASCII字符串；`std::cout`默认情况下知道如何处理这种类型，而`char`数组具有特殊含义。将数组类型更改为`int`将无法编译，因为编译器不知道如何将字符串转换为整数数组，而`std::cout`默认情况下也不知道如何处理整数数组，尽管在某些平台上，`int`和`char`实际上可能是相同的类型。
- en: Like a `bool` and `short int`, the character type is not always the most efficient
    type to use when representing an 8-bit integer, and as alluded to in the previous
    code, on some platforms, it is possible for a `char` to actually be larger than
    8 bits, a topic that will be discussed in further detail when we discuss integers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 像`bool`和`short int`一样，字符类型在表示8位整数时并不总是最有效的类型，正如前面的代码所暗示的，在某些平台上，`char`实际上可能比8位更大，这是我们在讨论整数时将进一步详细讨论的一个主题。
- en: To further investigate the `char` type, as well as the other types being discussed
    in this section, let's leverage the `std::numeric_limits{}` class. This class
    provides a simple wrapper around `limits.h`, which provides us with a means to
    query how a type is implemented on a given platform in real time using a collection
    of static member functions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步研究`char`类型，以及本节讨论的其他类型，让我们利用`std::numeric_limits{}`类。这个类提供了一个简单的包装器，围绕着`limits.h`，它为我们提供了一种查询在给定平台上如何实现类型的方法，使用一组静态成员函数实时地。
- en: 'For example, consider the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑下面的代码：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, we leverage `std::numeric_limits{}` to tell us the
    min and max value for both a signed and unsigned `char` (it should be noted that
    all examples in this book were performed on a standard Intel 64-bit CPU, and it
    is assumed that these same examples can, in fact, be executed on different platforms
    for which the values being returned might be different). The `std::numeric_limits{}`
    class can provide real-time information about a type, including the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们利用`std::numeric_limits{}`来告诉我们有符号和无符号`char`的最小和最大值（应该注意的是，本书中的所有示例都是在标准的英特尔64位CPU上执行的，假设这些相同的示例实际上可以在不同的平台上执行，返回的值可能是不同的）。`std::numeric_limits{}`类可以提供关于类型的实时信息，包括以下内容：
- en: Signed or unsigned
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有符号或无符号
- en: Conversion limits, such as rounding and the total number of digits needed to
    represent the type
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换限制，如四舍五入和表示类型所需的总位数
- en: Min and max information
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小值和最大值信息
- en: 'As shown in the preceding example, a `char` on a 64-bit Intel CPU is 1 byte
    in size (that is, 8 bits), and takes on the values [`0`, `255`] for an unsigned
    `char` and [`-127`, `127`] for a signed `char`, as stated by the specification.
    Let''s look at a wide `char` or `wchar_t`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，64位英特尔CPU上的`char`大小为1字节（即8位），对于无符号`char`取值范围为[`0`,`255`]，有符号`char`取值范围为[`-127`,`127`]，这是规范规定的。让我们来看一下宽字符`char`或`wchar_t`：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A `wchar_t` represents Unicode characters and its size depends on the operating
    system. On most Unix-based systems, a `wchar_t` is 4 bytes, and can represent
    a UTF-32 character type, as shown in the previous example, while on Windows, a
    `wchar_t` is 2 bytes in size, and can represent a UTF-16 character type. Executing
    the previous example on either of these operating systems will result in a different
    output.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`wchar_t`表示Unicode字符，其大小取决于操作系统。在大多数基于Unix的系统上，`wchar_t`为4字节，可以表示UTF-32字符类型，如前面的例子所示，而在Windows上，`wchar_t`为2字节，可以表示UTF-16字符类型。在这两种操作系统上执行前面的例子将得到不同的输出。'
- en: This is extremely important, and this issue defines the fundamental theme of
    this entire chapter; the default types that C and C++ provide are different depending
    on the CPU architecture, the operating system, and in some cases, if the application
    is running in user space or in the kernel (for example, when a 32-bit application
    is executing on a 64-bit kernel). Never assume, while system programming, that
    when interfacing with a system call, that your application's definition of a specific
    type is the same as the type the API assumes. Quite often, this assumption will
    prove to be invalid.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是非常重要的，这个问题定义了整个章节的基本主题；C和C++提供的默认类型取决于CPU架构、操作系统，有时还取决于应用程序是在用户空间还是内核中运行（例如，当32位应用程序在64位内核上执行时）。在系统编程时，永远不要假设在与系统调用进行接口时，你的应用程序对特定类型的定义与API所假定的类型相同。这种假设往往是无效的。
- en: Integer types
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数类型
- en: To further explain how the default C and C++ types are defined by their environment,
    and not by their size, let's look at the integer types. There are three main integer
    types—`short int`, `int`, and `long int` (excluding `long long int`, which on
    Windows is actually a `long int`).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步解释默认的C和C++类型是由它们的环境定义的，而不是由它们的大小定义的，让我们来看一下整数类型。有三种主要的整数类型——`short int`，`int`和`long
    int`（不包括`long long int`，在Windows上实际上是`long int`）。
- en: 'A `short int` is typically smaller than an `int`, and on most platforms, represents
    2 bytes. For example, go through the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`short int`通常比`int`小，在大多数平台上表示为2字节。例如，看下面的代码：'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As shown in the previous example, the code gets the min, max, and size of both
    a signed `short int` and an unsigned `short int`. The results of this code demonstrates
    that on an Intel 64-bit CPU running Ubuntu, a `short int`, whether it is signed
    or unsigned, returns a 2 byte representation.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，代码获取了有符号`short int`和无符号`short int`的最小值、最大值和大小。这段代码的结果表明，在运行Ubuntu的英特尔64位CPU上，`short
    int`，无论是有符号还是无符号，都返回2字节的表示。
- en: Intel CPUs provide an interesting advantage over other CPU architectures, as
    an Intel CPU is known as a **complex instruction set computer** (**CISC**), meaning
    that the Intel **instruction set architecture** (**ISA**) provides a long list
    of complicated instructions, designed to provide both compilers and by-hand authors
    of Intel assembly with advanced features. Among these features is the ability
    for an Intel processor to perform **arithmetic logic unit** (**ALU**) operations
    (including memory-based operations) at the byte level, even though most Intel
    CPUs are either 32-bit or 64-bit. Not all CPU architectures provide this same
    level of granularity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔CPU相对于其他CPU架构提供了一个有趣的优势，因为英特尔CPU被称为**复杂指令集计算机**（**CISC**），这意味着英特尔**指令集架构**（**ISA**）提供了一长串复杂的指令，旨在为英特尔汇编的编译器和手动作者提供高级功能。其中的一个特性是英特尔处理器能够在字节级别执行**算术逻辑单元**（**ALU**）操作（包括基于内存的操作），尽管大多数英特尔CPU都是32位或64位。并非所有的CPU架构都提供相同级别的细粒度。
- en: 'To explain this better, let''s look at the following example involving a `short
    int`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释这一点，让我们看一个涉及`short int`的例子：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous example, we take a `short int`, set it to the value `42`, output
    this value to `stdout` using `std::cout`, increment the `short int` by `1`, and
    then output the result to `stdout` using `std::cout` again. This is a simple example,
    but under the hood, a lot is occurring. In this case, a 2 byte value, executing
    on a system that contains 8 byte (that is, 64 bit) registers must be initialized
    to `42`, stored in memory, incremented, and then stored in memory again to be
    output to `stdout`. All of these operations must involve CPU registers to perform
    these actions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们取一个`short int`，将其设置为值`42`，使用`std::cout`将这个值输出到`stdout`，然后将`short int`增加`1`，再次使用`std::cout`将结果输出到`stdout`。这是一个简单的例子，但在底层，发生了很多事情。在这种情况下，一个2字节的值，在包含8字节寄存器的系统上执行（即64位），必须初始化为`42`，存储在内存中，递增，然后再次存储在内存中以输出到`stdout`。所有这些操作都必须涉及CPU寄存器来执行这些操作。
- en: On an Intel-based CPU (either 32-bit or 64-bit), these operations likely involve
    the use of the 2 byte versions of the CPU's registers. Specifically, Intel's CPUs
    might be 32-bit or 64-bit, but they provide registers that are 1, 2, 4, and 8
    bytes in size (specifically on 64-bit CPUs). In the previous example, this means
    that the CPU loads a 2 byte register with `42`, stores this value to memory (using
    a 2 byte memory operation), increments the 2 byte register by `1`, and then stores
    the 2 byte register back into memory again.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于英特尔的CPU上（32位或64位），这些操作可能涉及使用CPU寄存器的2字节版本。具体来说，英特尔的CPU可能是32位或64位，但它们提供的寄存器大小为1、2、4和8字节（特别是在64位CPU上）。在前面的例子中，这意味着CPU加载一个2字节寄存器，存储这个值到内存（使用2字节的内存操作），将这个2字节寄存器增加1，然后再次将这个2字节寄存器存储回内存中。
- en: On a **reduced instruction set computer** (**RISC**), this same operation might
    be far more complicated, as 2 byte registers do not exist. To load, store, increment,
    and store again only 2 bytes of data would require the use of additional instructions.
    Specifically, on a 32 bit CPU, a 32 bit value would have to be loaded into a register,
    and when this value is stored in memory, the upper 32 bit (or lower, depending
    on alignment) would have to be saved and restored to ensure that only 2 bytes
    of memory were actually being affected. The additional alignment checks, that
    is, memory reading, masking, and storing, would result in a substantial performance
    impact if a lot of operations were taking place.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在**精简指令集计算机**（**RISC**）上，这个相同的操作可能会更加复杂，因为2字节寄存器不存在。要加载、存储、递增和再次存储只有2字节的数据将需要使用额外的指令。具体来说，在32位CPU上，必须将32位值加载到寄存器中，当这个值存储在内存中时，必须保存和恢复上32位（或下32位，取决于对齐）以确保实际上只影响了2字节的内存。如果进行了大量的操作，额外的对齐检查，即内存读取、掩码和存储，将导致显著的性能影响。
- en: For this reason, C and C++ provide the default `int` type, which typically represents
    a CPU register. That is, if the architecture is 32 bit, an `int` is 32 bit and
    vice versa (with the exception of 64 bit, which will be explained shortly). It
    should be noted that CISC architectures, such as Intel, are free to implement
    ALU operations with granularity smaller than the CPU's register size however they
    wish, which means that under the hood, the same alignment checks and masking operations
    could still be taking place. The take home point is that unless you have a very
    specific reason to use a `short int` (for which there are a few reasons to do
    so; a topic we will discuss at the end of this chapter), instead of an `int`,
    an `int` type is, in most cases, more efficient than using a smaller type; even
    if you don't need a full 4 or 8 bytes, it's still faster.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，C和C++提供了默认的`int`类型，通常表示CPU寄存器。也就是说，如果架构是32位，那么`int`就是32位，反之亦然（64位除外，稍后将解释）。应该注意的是，像英特尔这样的CISC架构可以自由地以比CPU寄存器大小更小的粒度实现ALU操作，这意味着在底层，仍然可能进行相同的对齐检查和掩码操作。重点是，除非你有非常特定的原因要使用`short
    int`（对此有一些原因；我们将在本章末讨论这个话题），而不是`int`，在大多数情况下，使用更小的类型，即使你不需要完整的4或8字节，仍然更有效率。
- en: 'Let''s look at the `int` type:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`int`类型：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the previous example, an `int` is showing as 4 bytes on a 64 bit Intel CPU.
    The reason for this is backward compatibility, meaning that on some RISC architectures,
    the default register size, resulting in the most efficient processing, might not
    be an `int` but rather a `long int`. The problem is that to determine this in
    real time is painful (as the instructions being used are done so at compile-time).
    Let''s look at the `long int` to explain this further:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`int`在64位英特尔CPU上显示为4字节。这是因为向后兼容性，这意味着在一些RISC架构上，默认的寄存器大小，导致最有效的处理，可能不是`int`，而是`long
    int`。问题在于实时确定这一点是痛苦的（因为使用的指令是在编译时完成的）。让我们看一下`long int`来进一步解释这一点：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As shown in the preceding code, on a 64 bit Intel CPU running on Ubuntu, the
    `long int` is an 8 byte value. This is not true on Windows, which represents a
    `long int` as 32 bit, with the `long long int` being 64 bits (once again for backward
    compatibility).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，在运行Ubuntu的64位英特尔CPU上，`long int`是一个8字节的值。这在Windows上并不成立，它将`long int`表示为32位，而`long
    long int`为64位（再次是为了向后兼容）。
- en: When system programming, the size of the data you are working with is usually
    extremely important, and as shown in this section, unless you know exactly what
    CPU, operating system, and mode your application will be running on, it's nearly
    impossible to know the size of your integer types when using the default types
    provided by C and C++. Most of these types should not be used when system programming
    with the exception of `int`, which almost always represents a data type with the
    same bit width as the registers on your CPU, or at a minimum, a data type that
    doesn't require additional alignment checks and masking to perform simple arithmetic
    operations. In the next section, we will discuss additional types that overcome
    these size issues, and we will discuss their pros and cons.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程中，您正在处理的数据大小通常非常重要，正如本节所示，除非您确切知道应用程序将在哪种CPU、操作系统和模式上运行，否则几乎不可能知道在使用C和C++提供的默认类型时您的整数类型的大小。大多数这些类型在系统编程中不应该使用，除了`int`之外，它几乎总是表示与CPU寄存器相同位宽的数据类型，或者至少是一个不需要额外对齐检查和掩码来执行简单算术操作的数据类型。在下一节中，我们将讨论克服这些大小问题的其他类型，并讨论它们的优缺点。
- en: Floating – point numbers
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点数
- en: When system programming, floating point numbers are rarely used, but we will
    briefly discuss them here for reference. Floating point numbers increase the size
    of the possible value that can be stored by reducing the accuracy. For example,
    with a floating point number, it is possible to store a number that represents
    `1.79769e+308`, which is simply not possible with an integer value, even with
    a `long long int`. To accomplish this, however, it is not possible to subtract
    this value by `1` and see a difference in the number's value, and the floating
    point number cannot represent such a large value while still maintaining the same
    granularity as an integer value. Another benefit of floating point numbers is
    their ability to represent sub-integer numbers, which is useful when dealing with
    more complicated, mathematical calculations (a task that is rarely needed for
    system programming, as most kernels don't work with floating point numbers to
    prevent floating point errors from occurring within the kernel, ultimately resulting
    in a lack of system calls that take floating point values).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程中，浮点数很少使用，但我们在这里简要讨论一下以供参考。浮点数通过减少精度来增加可以存储的值的大小。例如，使用浮点数可以存储代表`1.79769e+308`的数字，这是使用整数值甚至`long
    long int`都不可能实现的。然而，无法将这个值减去`1`并看到数字值的差异，浮点数也无法在保持与整数值相同的粒度的同时表示如此大的值。浮点数的另一个好处是它们能够表示次整数数值，在处理更复杂的数学计算时非常有用（这在系统编程中很少需要，因为大多数内核不使用浮点数来防止内核中发生浮点错误，最终导致没有接受浮点值的系统调用）。
- en: 'There are mainly three different types of floating point numbers—`float`, `double`,
    and `long double`. For example, consider the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有三种不同类型的浮点数——`float`、`double`和`long double`。例如，考虑以下代码：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the previous example, we leverage `std::numeric_limits` to examine the `float` type,
    which on an Intel 64 bit CPU is a 4 byte value. The `double` is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们利用`std::numeric_limits`来检查`float`类型，在英特尔64位CPU上是4字节大小。`double`如下：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With the `long double`, the code is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`long double`，代码如下：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As shown in the previous code, on an Intel 64 bit CPU, the `long double` is
    a 16 byte value (or 128 bits), which can store an absolutely massive number.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，在英特尔64位CPU上，`long double`是16字节大小（或128位），可以存储绝对庞大的数字。
- en: Boolean
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔值
- en: The standard C language doesn't define a Boolean type natively. C++, however,
    does, and is defined using the `bool` keyword. When writing in C, a Boolean can
    be represented using any integer type, with `false` typically representing `0`,
    and `true` typically representing `1`. As an interesting side note, some CPUs
    are capable of comparing a register or memory location to `0` faster than `1`,
    meaning that on some CPUs, it's actually faster for Boolean arithmetic and branching
    to result in `false` in the *typical* case.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C语言没有本地定义布尔类型。然而，C++有，并使用`bool`关键字定义。在C中，布尔值可以用任何整数类型表示，通常`false`表示`0`，`true`表示`1`。有趣的是，一些CPU能够比较寄存器或内存位置与`0`更快，这意味着在某些CPU上，布尔算术和分支实际上更快地导致*典型*情况下的`false`。
- en: 'Let''s look at a `bool` using the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下使用以下代码的`bool`：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As shown in the preceding code, a Boolean using C++ on a 64 bit Intel CPU is
    1 byte in size, and can take on a value of `0` or `1`. It should be noted, for
    the same reasons as already identified, a Boolean could be 32-bits or even 64-bits,
    depending on the CPU architecture. On an Intel CPU, which is capable of supporting
    register sizes of 8 bits (that is, 1 byte), a Boolean only needs to be 1 byte
    in size.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，使用C++在64位英特尔CPU上的布尔值大小为1字节，可以取值为`0`或`1`。值得注意的是，出于相同的原因，布尔值可以是32位或者64位，取决于CPU架构。在英特尔CPU上，支持8位寄存器大小（即1字节），布尔值只需要1字节大小。
- en: The total size of a Boolean is important to note, with respect to storing Booleans
    in a file on disk. A Boolean technically only needs a single bit to store its
    value, but rarely (if any) CPU architectures support bit-style register and memory
    access, meaning a Boolean typically consumes more than a single bit, and in some
    cases could consume as many as 64 bits. If the size of your resulting file is
    important, storing a Boolean using the built-in Boolean type may not be preferred
    (ultimately resulting in the need for bit masking).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值的总大小很重要，特别是在磁盘上存储布尔值时。从技术上讲，布尔值只需要一个位来存储其值，但很少（如果有的话）CPU架构支持位式寄存器和内存访问，这意味着布尔值通常占用多于一个位，有些情况下甚至可能占用多达64位。如果您的结果文件的大小很重要，使用内置的布尔类型存储布尔值可能不是首选（最终需要位掩码）。
- en: Learning standard integer types
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习标准整数类型
- en: 'To address the uncertainty of the default types provided by C and C++, both
    provide the standard integer types, which are accessible from the `stdint.h` header
    file. This header defines the following types:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决C和C++提供的默认类型的不确定性，它们都提供了标准整数类型，可以从`stdint.h`头文件中访问。此头文件定义了以下类型：
- en: '`int8_t`, `uint8_t`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int8_t`，`uint8_t`'
- en: '`int16_t`, `uint16_t`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int16_t`，`uint16_t`'
- en: '`int32_t`, `uint32_t`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int32_t`，`uint32_t`'
- en: '`int64_t`, `uint64_t`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int64_t`，`uint64_t`'
- en: In addition, `stdint.h` provides both *least* and *fast* versions of the aforementioned
    types, and a max type and integer pointer type, which is all out-of-scope for
    this book. The previous types do exactly what you would expect; they define the
    width of integer types with a specific number of bits. For example, an `int8_t` is
    a signed 8 bit integer. No matter what the CPU architecture, operating system,
    or mode is, these types are always the same (with the only thing not being defined
    is their endianness, which is usually only needed when working with networking
    and external devices).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`stdint.h`提供了上述类型的*最小*和*最快*版本，以及最大类型和整数指针类型，这些都超出了本书的范围。前面的类型正是您所期望的；它们定义了具有特定位数的整数类型的宽度。例如，`int8_t`是一个有符号的8位整数。无论CPU架构、操作系统或模式如何，这些类型始终相同（唯一未定义的是它们的字节顺序，通常仅在处理网络和外部设备时才需要）。
- en: In general, if the size of the data type you are working with is important,
    use the standard integer types instead of the default types provided by the language.
    Although the standard types do solve a lot of the problems already identified,
    they do have their own issues. Specifically, `stdint.h` is a compiler provided
    header file, with a different header being defined for each CPU architecture and
    operating system combination possible. The types defined in this file are typically
    represented using the default types under the hood. This can be done because the
    compiler knows if an `int32_t` is an `int`, or a `long int`. To demonstrate this,
    let's create an application that's capable of comparing integer types.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果您正在处理的数据类型的大小很重要，应使用标准整数类型，而不是语言提供的默认类型。尽管标准类型确实解决了许多已经确定的问题，但它们也有自己的问题。具体来说，`stdint.h`是一个由编译器提供的头文件，对于可能的每个CPU架构和操作系统组合，都定义了不同的头文件。此文件中定义的类型通常在底层使用默认类型表示。这是因为编译器知道`int32_t`是`int`还是`long
    int`。为了证明这一点，让我们创建一个能够比较整数类型的应用程序。
- en: 'We will start with the following headers:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从以下头文件开始：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `typeinfo` header will provide us with C++ supported type information,
    which will ultimately provide us with the root type for a specific integer type.
    The problem is that `typeinfo` provides us with the mangled versions of this type
    information. To demangle this information, we will need the `cxxabi.h` header,
    which provides access to the demangler built into C++ itself:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`typeinfo`头文件将为我们提供C++支持的类型信息，最终为我们提供特定整数类型的根类型。问题在于`typeinfo`为我们提供了这些类型信息的编码版本。为了解码这些信息，我们需要`cxxabi.h`头文件，它提供了对C++本身内置的解码器的访问：'
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous function returns the root name for a provided type `T`. This is
    done by first getting the type''s name from C++, and then using the demangler
    to convert the mangled type information into its human-readable form. Finally,
    the resulting name is returned:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数返回提供的类型`T`的根名称。首先从C++中获取类型的名称，然后使用解码器将编码的类型信息转换为人类可读的形式。最后，返回结果名称：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The previous function checks to see if both the name and size of the type are
    the same, as they do not need to be the same (for example, the size could be the
    same, but the type''s root might not be). It should be noted that we add some
    strange characters to the output of this function (which outputs to `stdout`).
    These strange characters tell the console to output in the color red in the event
    that a match was not found, providing a simple means to see which types are the
    same, and which types are not the same:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数检查类型的名称和大小是否相同，因为它们不需要相同（例如，大小可能相同，但类型的根可能不同）。应该注意的是，我们向此函数的输出（输出到`stdout`）添加了一些奇怪的字符。这些奇怪的字符告诉控制台在找不到匹配项时以红色输出，提供了一种简单的方法来查看哪些类型是相同的，哪些类型是不同的：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, we will compare each standard integer type with the expected (or more
    appropriately stated, *typical*) default type to see if the types are in fact
    the same on any given architecture. This example can be run on any architecture
    to see what the differences are between the default types and the standard integer
    types so that we can look for discrepancies if this information is needed when
    system programming.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将比较每种标准整数类型与预期（更恰当地说是*典型*）默认类型，以查看在任何给定架构上这些类型是否实际相同。可以在任何架构上运行此示例，以查看默认类型和标准整数类型之间的差异，以便在需要系统编程时查找不一致之处。
- en: 'The results are as follow (for an Intel-based 64 bit CPU on Ubuntu) for a `uint8_t`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在Ubuntu上的基于英特尔64位CPU的`uint8_t`，结果如下：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following shows the results of a `char`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了`char`的结果：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, the following code shows the results for the remaining `int` types:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下代码显示了剩余的`int`类型的结果：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'All of the types are the same, with some notable exceptions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型都相同，但有一些显著的例外：
- en: The first two tests were provided specifically to ensure that an error would,
    in fact, be detected.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个测试是特意提供的，以确保实际上会检测到错误。
- en: On Ubuntu, an `int64_t` is implemented using `long` and not a `long long`, which
    means that on Ubuntu, a `long` and a `long long` mean the same thing. This is
    not the case with Windows.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Ubuntu上，`int64_t`是使用`long`实现的，而不是`long long`，这意味着在Ubuntu上，`long`和`long long`是相同的。但在Windows上不是这样。
- en: The most important thing to recognize with this demonstration is that the output
    doesn't include the standard integer type names, but instead only contains the
    default type names. This is because, as previously demonstrated, the compiler
    implements an `int32_t` on an Intel 64 bit CPU on Ubuntu using an `int`, and to
    the compiler, these types are one and the same. The difference is, on another
    CPU architecture and operating system, an `int32_t` might be implemented using
    a `long int`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示最重要的是要认识到输出中不包括标准整数类型名称，而只包含默认类型名称。这是因为，如前所示，编译器在Ubuntu上的Intel 64位CPU上使用`int`实现`int32_t`，对编译器来说，这些类型是一样的。不同之处在于，在另一个CPU架构和操作系统上，`int32_t`可能是使用`long
    int`实现的。
- en: If you care about the size of an integer type, use a standard integer type,
    and let the header file pick which default type to use for you. If you don't care
    about the size of the integer type, or an API dictates the type, leverage the
    default type instead. In the next section, we will show you how even standard
    integer types do not guarantee a specific size, and the rules just described can
    break down using a common system programming pattern.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您关心整数类型的大小，请使用标准整数类型，并让头文件为您选择默认类型。如果您不关心整数类型的大小，或者API规定了类型，请使用默认类型。在下一节中，我们将向您展示，即使标准整数类型也不能保证特定大小，并且刚刚描述的规则在使用常见的系统编程模式时可能会出现问题。
- en: Structure packing
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构打包
- en: 'The standard integers provide a compiler-supported method for dictating the
    size of an integer type at compile time. Specifically, they map bit widths to
    default types so that the coder doesn''t have to do this manually. The standard
    types, however, do not always guarantee the width of a type, and structures are
    a good example of this. To better understand this issue, let''s look at a simple
    example of a structure with some data in it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 标准整数提供了一个编译器支持的方法，用于在编译时指定整数类型的大小。具体来说，它们将位宽映射到默认类型，这样编码人员就不必手动执行此操作。然而，标准类型并不总是保证类型的宽度，结构是一个很好的例子。为了更好地理解这个问题，让我们看一个简单的结构示例：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the previous example, we created a structure with two 64 bit integers in
    it. We then, using the `sizeof()` function, output the size of the structure to
    `stdout` using `std::cout`. As expected, the total size, in bytes, of the structure
    is `16`. It should be noted that, like the rest of this book, the examples in
    this section are all being executed on a 64 bit Intel CPU.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个包含两个64位整数的结构。然后，使用`sizeof()`函数，我们输出了结构的大小到`stdout`，使用`std::cout`。如预期的那样，结构的总大小，以字节为单位，是`16`。值得注意的是，和本书的其余部分一样，本节中的例子都是在64位Intel
    CPU上执行的。
- en: 'Now, let''s look at the same example, but with one of the data types being
    changed to a 16 bit integer instead of a 64 bit integer, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看相同的例子，但其中一个数据类型被更改为16位整数，而不是64位整数，如下所示：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As shown in the preceding example, we have a structure that has two data types,
    but they do not match. We then output the size of the data structure to `stdout`
    using `std::cout`, and the reported size is 16 bytes. The problem is that we expect
    10 bytes, as we defined the structure as being the combination of a 64-bit (8
    bytes) and a 16-bit (2 bytes) integer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个结构，其中有两种数据类型，但它们不匹配。然后，我们使用`std::cout`输出数据结构的大小到`stdout`，报告的大小是16字节。问题在于，我们期望是10字节，因为我们将结构定义为64位（8字节）和16位（2字节）整数的组合。
- en: Under the hood, the compiler is replacing the 16 bit integer with a 64 bit integer.
    The reason for this is the base type for C and C++ is an `int`, and the compiler
    is allowed to change a type smaller than an `int` with an `int`, even though we
    explicitly declared the second integer as a 16 bit integer. To explain this in
    other words, the use of `unit16_t` does not demand the use of a 16 bit integer,
    but rather it is a `typedef` for `short int` on a 64 bit Intel-based CPU running
    Ubuntu, and based on the C and C++ specifications, the compiler is allowed to
    change a `short int` to an `int` at will.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，编译器正在用64位整数替换16位整数。这是因为C和C++的基本类型是`int`，编译器允许将小于`int`的类型更改为`int`，即使我们明确声明第二个整数为16位整数。换句话说，使用`unit16_t`并不要求使用16位整数，而是在64位Intel
    CPU上的Ubuntu上是`short int`的`typedef`，根据C和C++规范，编译器可以随意将`short int`更改为`int`。
- en: 'The order in which we specify our integers also does not matter:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定整数的顺序也不重要：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As seen in the previous example, the compiler once again states that the total
    size of the structure is 16 bytes when, in fact, we expect 10\. In this example,
    the compiler is even more likely to make this type of substitution because it
    is capable of identifying that there is an alignment issue. Specifically, the
    CPU this code was compiled on was a 64 bit CPU, which means that replacing the
    `uint16_t` with a `unit64_t` could possibly improve memory caching, and align
    `data2` on a 64 bit boundary instead of a 16 bit boundary, which would span two
    64 bit memory locations if the structure is properly aligned in memory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，编译器再次声明结构的总大小为16字节，而我们期望是10。在这个例子中，编译器更有可能进行这种类型的替换，因为它能够识别到存在对齐问题。具体来说，这段代码编译的CPU是64位CPU，这意味着用`unit64_t`替换`uint16_t`可能会改善内存缓存，并且将`data2`对齐到64位边界，而不是16位边界，如果结构在内存中正确对齐，它将跨越两个64位内存位置。
- en: 'Structures are not the only way to reproduce this type of substitution. Let''s
    examine the following example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 结构并不是唯一可以重现这种类型替换的方法。让我们来看看以下例子：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the previous example, we created a 16-bit integer and set it to `42`. We
    then created another integer and set it to our 16-bit integer plus `42`. The value
    `42` can be represented as an 8-bit integer, but it's not. Instead, the compiler
    represents `42` as an `int`, which in this case means that the system this code
    was compiled on is 4 bytes in size.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个16位整数，并将其设置为`42`。然后我们创建了另一个整数，并将其设置为我们的16位整数加上`42`。值`42`可以表示为8位整数，但实际上并没有。相反，编译器将`42`表示为`int`，在这种情况下，这意味着这段代码编译的系统大小为4字节。
- en: The compiler represents `42` as an `int`, and `int` plus an `int16_t`, which
    results in an `int`, as that is the higher width type. In the previous example,
    we define our `result` variable using `auto`, which ensures that the resulting
    type reflects the type the compiler created as a consequence of this arithmetic.
    We could have defined `result` as another `int16_t`, which would have worked unless
    we turned on integer type conversion warnings. Doing so would have resulted in
    a conversion warning as the compiler constructs an `int` as a consequence of adding
    `s` plus `42`, and then would have to automatically convert the resulting `int` back
    to an `int16_t`, which would be performing a narrowing conversion, which could
    result in an overflow (hence the warning).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将`42`表示为`int`，加上`int16_t`，结果为`int`，因为这是更高宽度类型。在前面的例子中，我们使用`auto`定义了`result`变量，这确保了结果类型反映了编译器由于这种算术操作而创建的类型。我们也可以将`result`定义为另一个`int16_t`，这样也可以工作，除非我们打开整数类型转换警告。这样做会导致一个转换警告，因为编译器构造了一个`int`，作为加上`s`加上`42`的结果，然后必须自动将结果的`int`转换回`int16_t`，这将执行一个缩小转换，可能导致溢出（因此会有警告）。
- en: All of these issues are a consequence of the compiler's ability to perform type
    conversions from a smaller width type to a higher width type in order to optimize
    performance to reduce the possibility of overflows. In this case, a numeric value
    is always an `int` unless the value requires more storage (for example, replace
    `42` with `0xFFFFFFFF00000000`).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都是编译器能够执行类型转换的结果，从较小宽度类型转换为更高宽度类型，以优化性能，减少溢出的可能性。在这种情况下，一个数字值总是一个`int`，除非该值需要更多的存储空间（例如，用`0xFFFFFFFF00000000`替换`42`）。
- en: 'This type of conversion is not always guaranteed. Consider the following example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的转换并不总是保证的。考虑以下例子：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the previous example, we have a structure with two 16 bit integers. The total
    size of the structure is reported as 4 bytes, which is exactly what we would expect.
    In this case, the compiler doesn't see a benefit to changing the size of either
    of the integers and thus leaves them alone.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个包含两个16位整数的结构。结构的总大小报告为4字节，这正是我们所期望的。在这种情况下，编译器并没有看到改变整数大小的好处，因此保持了它们不变。
- en: 'Bit fields also do not change the compiler''s ability to perform this type
    of conversion, as shown in the following example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 位域也不会改变编译器执行这种类型转换的能力，如下例所示：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the previous example, we created a structure with two integers (a 16-bit
    integer and a 64-bit integer), but instead of just defining the 16-bit integer,
    we also defined bit fields, giving us direct access to specific bits within the
    integer (a practice that should be avoided when system programming for reasons
    that are about to be explained). Defining these bit fields does not prevent the
    compiler from changing the total size of the first integer from 16 bits to 64
    bits.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个包含两个整数（一个16位整数和一个64位整数）的结构，但我们不仅定义了16位整数，还定义了位域，使我们可以直接访问整数中的特定位（这种做法在系统编程中应该避免，即将要解释的原因）。定义这些位域并不能阻止编译器将第一个整数的总大小从16位改为64位。
- en: The problem with the previous example is that bit fields are often a pattern
    used by system programmers when interfacing directly with hardware. In the previous
    example, the second 64-bit integer is expected to be at 2 bytes from the top of
    the structure. In this case, however, the second 64-bit integer is actually 8
    bytes from the top of the structure. If we used this structure to interface directly
    with hardware, a hard to find logic bug would be the result.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前面例子的问题在于，位域经常是系统程序员在直接与硬件接口时使用的一种模式。在前面的例子中，第二个64位整数预计应该距离结构顶部2字节。然而，在这种情况下，第二个64位整数实际上距离结构顶部8字节。如果我们使用这个结构直接与硬件接口，将会导致一个难以发现的逻辑错误。
- en: 'The way to overcome this problem is to pack the structure. The following example
    demonstrates how to do this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这个问题的方法是对结构进行打包。以下例子演示了如何做到这一点：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The previous example is similar to the first example in this section. A structure
    was created with a 64 bit integer and a 16 bit integer. In the previous example,
    the resulting size of the structure was 16 bytes, as the compiler replaced the
    16 bit integer with a 64 bit integer instead. In the previous example, to fix
    this issue, we wrap the structure with the `#pragma pack` and `#pragma pop` macros.
    These macros tell the compiler (since we passed a `1` to the macro, which indicates
    a byte) to pack the structure using a byte granularity, telling the compiler it
    is not allowed to make a substitution optimization.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子类似于本节中的第一个例子。创建了一个包含64位整数和16位整数的结构。在前面的例子中，结构的大小为16字节，因为编译器用64位整数替换了16位整数。为了解决这个问题，在前面的例子中，我们用`#pragma
    pack`和`#pragma pop`宏包装了结构。这些宏告诉编译器（因为我们向宏传递了`1`，表示一个字节）使用字节粒度对结构进行打包，告诉编译器不允许进行替换优化。
- en: 'Using this method, changing the order of the variables to the more likely scenario
    for which the compiler would attempt this type of optimization still results in
    a structure that is not converted, as shown in the following example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，将变量的顺序更改为编译器尝试执行这种类型优化的更可能情况，仍然会导致结构不被转换，如下例所示：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As seen in the previous example, the size of the structure is still 10 bytes,
    regardless of the order of the integers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，结构的大小仍然是10字节，无论整数的顺序如何。
- en: Combining structure packing with the standard integer types is sufficient (assuming
    endianness is not an issue)  to directly interface with the hardware, but this
    type of pattern is still discouraged in favor of building accessors and leveraging
    bit masks that provide the user with a means to ensure that direct access to hardware
    registers is occurring in a controlled manner without the compiler getting in
    the way, or optimizations producing undesired results.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将结构打包与标准整数类型结合使用足以（假设字节顺序不是问题）直接与硬件进行接口，但是这种模式仍然不鼓励，而是更倾向于构建访问器和利用位掩码，为用户提供一种方式来确保以受控的方式进行直接访问硬件寄存器，而不受编译器的干扰，或者优化产生不希望的结果。
- en: 'To explain why packed structures and bit fields should be avoided, let''s look
    at an alignment issue with the following example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释为什么应该避免打包结构和位字段，让我们看一个与对齐问题相关的例子：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the previous example, we created a structure with a 16 bit integer and a
    64-bit integer, and then packed the structure to ensure the total size of the
    structure is 10 bytes, and each data field is properly aligned. The total alignment
    of the structure is, however, not cache aligned, which is demonstrated in the
    previous example by creating an instance of the structure on the stack and then
    outputting the structure's address to `stdout` using `std::cout`. As shown, the
    address is byte aligned, not cache aligned.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们创建了一个包含16位整数和64位整数的结构，然后对结构进行了打包，以确保结构的总大小为10字节，并且每个数据字段都正确对齐。然而，结构的总对齐方式并不是缓存对齐，这在上一个例子中得到了证明，方法是在堆栈上创建结构的一个实例，然后使用`std::cout`将结构的地址输出到`stdout`。如图所示，地址是字节对齐的，而不是缓存对齐的。
- en: 'To cache align the structure, we will leverage the `alignas()` function, which
    will be explained in [Chapter 7](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml),
    *A Comprehensive Look at Memory Management*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对结构进行缓存对齐，我们将利用`alignas()`函数，这将在[第7章](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml)中进行解释，*内存管理的全面视图*：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the previous example, we added the `alignas()` function to the definition
    of the structure, which cache aligns the structure on the stack. We also output
    the total size of the structure as with previous examples, and as shown, the structure
    is no longer packed. In other words, the use of `#pragma pack#` does not guarantee
    the structure will, in fact, be packed. As in all cases, the compiler is free
    to make changes as needed, and even the `#pragma pack` macro is a hint, not a
    requirement.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们在结构的定义中添加了`alignas()`函数，它在堆栈上对结构进行了缓存对齐。我们还输出了结构的总大小，就像以前的例子一样，如图所示，结构不再是紧凑的。换句话说，使用`#pragma
    pack#`并不能保证结构实际上会被打包。在所有情况下，编译器都可以根据需要进行更改，即使`#pragma pack`宏也只是一个提示，而不是要求。
- en: 'In the previous case, it should be noted that the compiler actually adds additional
    memory to the end of the structure, meaning that the data members in the structure
    are still in their correct locations, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，应该注意编译器实际上在结构的末尾添加了额外的内存，这意味着结构中的数据成员仍然在它们的正确位置，如下所示：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the previous example, the address of each data member is output to `stdout`,
    and as expected, the first data member is aligned to `0`, and the second data
    member is 2 bytes from the top of the structure, even though the total size of
    the structure is 16 bytes, meaning that the compiler is getting the extra 6 bytes
    by adding addition integers to the bottom of the structure. Although this might
    seem benign if an array of these structures were created, and it was assumed the
    structures were 10 bytes in size due to the use of `#pragma pack`, a hard to find
    logic bug would be introduced.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，每个数据成员的地址都输出到`stdout`，并且如预期的那样，第一个数据成员对齐到`0`，第二个数据成员距离结构顶部2字节，即使结构的总大小是16字节，这意味着编译器通过在结构底部添加额外的整数来获得额外的6字节。虽然这可能看起来无害，如果创建了这些结构的数组，并且假定由于使用了`#pragma
    pack`，结构的大小为10字节，那么将引入一个难以发现的逻辑错误。
- en: 'To conclude this chapter, a note about pointers should be provided with respect
    to their size. Specifically, the size of a pointer depends entirely on the CPU
    architecture, operating system, and mode the application is running in. Let''s
    examine the following example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章，应该提供一个关于指针大小的注释。具体来说，指针的大小完全取决于CPU架构、操作系统和应用程序运行的模式。让我们来看下面的例子：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the previous example, we stored a pointer and an integer and output the total
    size of the structure to `stdout` using `std::cout`. The resulting size of this
    structure is 16 bytes on a 64-bit Intel CPU running Ubuntu. The total size of
    this structure on a 32-bit Intel CPU running Ubuntu would be 12 bytes, as the
    pointer would only be 4 bytes in size. Worse, if the application were compiled
    as a 32-bit application, but executed on a 64-bit kernel, the application would
    see this structure as 12 bytes, and the kernel would see this structure as 16
    bytes. Attempting to pass this structure to the kernel would result in a bug,
    as the application and kernel would see the structure differently.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们存储了一个指针和一个整数，并使用`std::cout`将结构的总大小输出到`stdout`。在运行Ubuntu的64位英特尔CPU上，这个结构的总大小是16字节。在运行Ubuntu的32位英特尔CPU上，这个结构的总大小将是12字节，因为指针只有4字节大小。更糟糕的是，如果应用程序被编译为32位应用程序，但在64位内核上执行，应用程序将看到这个结构为12字节，而内核将看到这个结构为16字节。尝试将这个结构传递给内核将导致错误，因为应用程序和内核会以不同的方式看待这个结构。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed the different integer types (and briefly reviewed
    the floating point types) that are provided by C and C++ for system programming.
    We started with a discussion on the default types provided by C and C++ and the
    pros and cons associated with these types, including the common `int` type, explaining
    what it is, and how it is used. Next, we discussed the standard integer types
    provided by `stdint.h` and how they address some of the issues with the default
    types. Finally, we concluded this chapter with a discussion on structure packing
    and the issues associated with type conversions and optimizations that the compiler
    can make in different scenarios.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了C和C++为系统编程提供的不同整数类型（并简要回顾了浮点类型）。我们从讨论C和C++提供的默认类型以及与这些类型相关的利弊开始，包括常见的“int”类型，解释了它是什么以及如何使用它。接下来，我们讨论了由“stdint.h”提供的标准整数类型以及它们如何解决默认类型的一些问题。最后，我们结束了本章，讨论了结构打包以及编译器在不同情况下可以进行的类型转换和优化的问题。
- en: In the next chapter, we will cover changes made by C++17, a C++ specific technique
    called **Resource Acquisition Is Initialization** (**RAII**) and provide an overview
    of the **Guideline Support Library** (**GSL**).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍C++17所做的更改，一种C++特定的技术称为**资源获取即初始化**（**RAII**），并概述**指导支持库**（**GSL**）。
- en: Questions
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a `short int` and an `int`?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “short int”和“int”之间有什么区别？
- en: What is the size of an `int`?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “int”的大小是多少？
- en: Is the size of a `signed int` and an `unsigned int` different?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “signed int”和“unsigned int”的大小不同吗？
- en: What is the difference between an `int32_t` and an `int`?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “int32_t”和“int”之间有什么区别？
- en: Is an `int16_t` guaranteed to be 16 bits?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “int16_t”保证是16位吗？
- en: What does `#pragma pack` do?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “#pragma pack”是做什么的？
- en: Is it possible to guarantee structure packing in all cases?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可能保证在所有情况下进行结构打包？
- en: Further reading
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
