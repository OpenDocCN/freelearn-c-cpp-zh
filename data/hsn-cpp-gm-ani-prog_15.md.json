["```cpp\n    class AnimTexture {\n    protected:\n    \u00a0\u00a0\u00a0\u00a0float* mData;\n    \u00a0\u00a0\u00a0\u00a0unsigned int mSize;\n    \u00a0\u00a0\u00a0\u00a0unsigned int mHandle;\n    ```", "```cpp\n    public:\n    \u00a0\u00a0\u00a0\u00a0AnimTexture();\n    \u00a0\u00a0\u00a0\u00a0AnimTexture(const AnimTexture&);\n    \u00a0\u00a0\u00a0\u00a0AnimTexture& operator=(const AnimTexture&);\n    \u00a0\u00a0\u00a0\u00a0~AnimTexture();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0void Load(const char* path);\n    \u00a0\u00a0\u00a0\u00a0void Save(const char* path);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0void UploadTextureDataToGPU();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0unsigned int Size();\n    \u00a0\u00a0\u00a0\u00a0void Resize(unsigned int newSize);\n    \u00a0\u00a0\u00a0\u00a0float* GetData();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0void SetTexel(unsigned int x, unsigned int y, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const vec3& v);\n    \u00a0\u00a0\u00a0\u00a0void SetTexel(unsigned int x, unsigned int y, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const quat& q);\n    \u00a0\u00a0\u00a0\u00a0vec4 GetTexel(unsigned int x, unsigned int y);\n    ```", "```cpp\n    \u00a0\u00a0 void Set(unsigned int uniform, unsigned int texture);\n    \u00a0\u00a0 void UnSet(unsigned int textureIndex);\n    \u00a0\u00a0 unsigned int GetHandle();\n    };\n    ```", "```cpp\n    AnimTexture::AnimTexture() {\n    \u00a0\u00a0\u00a0\u00a0mData = 0;\n    \u00a0\u00a0\u00a0\u00a0mSize = 0;\n    \u00a0\u00a0\u00a0\u00a0glGenTextures(1, &mHandle);\n    }\n    ```", "```cpp\n    AnimTexture::AnimTexture(const AnimTexture& other) {\n    \u00a0\u00a0\u00a0\u00a0mData = 0;\n    \u00a0\u00a0\u00a0\u00a0mSize = 0;\n    \u00a0\u00a0\u00a0\u00a0glGenTextures(1, &mHandle);\n    \u00a0\u00a0\u00a0\u00a0*this = other;\n    }\n    ```", "```cpp\n    AnimTexture& AnimTexture::operator=(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const AnimTexture& other) {\n    \u00a0\u00a0\u00a0\u00a0if (this == &other) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return *this;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0mSize = other.mSize;\n    \u00a0\u00a0\u00a0\u00a0if (mData != 0) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete[] mData;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0mData = 0;\n    \u00a0\u00a0\u00a0\u00a0if (mSize != 0) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mData = new float[mSize * mSize * 4];\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0memcpy(mData, other.mData, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sizeof(float) * (mSize * mSize * 4));\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return *this;\n    }\n    ```", "```cpp\n    AnimTexture::~AnimTexture() {\n    \u00a0\u00a0\u00a0\u00a0if (mData != 0) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete[] mData;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0glDeleteTextures(1, &mHandle);\n    }\n    ```", "```cpp\n    void AnimTexture::Save(const char* path) {\n    \u00a0\u00a0\u00a0\u00a0std::ofstream file;\n    \u00a0\u00a0\u00a0\u00a0file.open(path, std::ios::out | std::ios::binary);\n    \u00a0\u00a0\u00a0\u00a0if (!file.is_open()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Couldn't open \" << path << \"\\n\";\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0file << mSize;\n    \u00a0\u00a0\u00a0\u00a0if (mSize != 0) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0file.write((char*)mData, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 sizeof(float) * (mSize * mSize * 4));\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0file.close();\n    }\n    ```", "```cpp\n    void AnimTexture::Load(const char* path) {\n    \u00a0\u00a0\u00a0\u00a0std::ifstream file;\n    \u00a0\u00a0\u00a0\u00a0file.open(path, std::ios::in | std::ios::binary);\n    \u00a0\u00a0\u00a0\u00a0if (!file.is_open()) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0cout << \"Couldn't open \" << path << \"\\n\";\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0file >> mSize;\n    \u00a0\u00a0\u00a0\u00a0mData = new float[mSize * mSize * 4];\n    \u00a0\u00a0\u00a0\u00a0file.read((char*)mData, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 sizeof(float) * (mSize * mSize * 4));\n    \u00a0\u00a0\u00a0\u00a0file.close();\n    \u00a0\u00a0\u00a0\u00a0UploadTextureDataToGPU();\n    }\n    ```", "```cpp\n    void AnimTexture::UploadTextureDataToGPU() {\n    \u00a0\u00a0\u00a0\u00a0glBindTexture(GL_TEXTURE_2D, mHandle);\n    \u00a0\u00a0\u00a0\u00a0glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, mSize, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mSize, 0, GL_RGBA, GL_FLOAT, mData);\n    \u00a0\u00a0\u00a0\u00a0glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GL_CLAMP_TO_EDGE);\n    \u00a0\u00a0\u00a0\u00a0glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GL_CLAMP_TO_EDGE);\n    \u00a0\u00a0\u00a0\u00a0glTexParameteri(GL_TEXTURE_2D, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    \u00a0\u00a0\u00a0\u00a0glTexParameteri(GL_TEXTURE_2D, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    \u00a0\u00a0\u00a0\u00a0glBindTexture(GL_TEXTURE_2D, 0);\n    }\n    ```", "```cpp\n    unsigned int AnimTexture::Size() {\n    \u00a0\u00a0\u00a0\u00a0return mSize;\n    }\n    unsigned int AnimTexture::GetHandle() {\n    \u00a0\u00a0\u00a0\u00a0return mHandle;\n    }\n    float* AnimTexture::GetData() {\n    \u00a0\u00a0\u00a0\u00a0return mData;\n    }\n    ```", "```cpp\n    void AnimTexture::Resize(unsigned int newSize) {\n    \u00a0\u00a0\u00a0\u00a0if (mData != 0) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0delete[] mData;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0mSize = newSize;\n    \u00a0\u00a0\u00a0\u00a0mData = new float[mSize * mSize * 4];\n    }\n    ```", "```cpp\n    void AnimTexture::Set(unsigned int uniformIndex, unsigned int textureIndex) {\n    \u00a0\u00a0\u00a0\u00a0glActiveTexture(GL_TEXTURE0 + textureIndex);\n    \u00a0\u00a0\u00a0\u00a0glBindTexture(GL_TEXTURE_2D, mHandle);\n    \u00a0\u00a0\u00a0\u00a0glUniform1i(uniformIndex, textureIndex);\n    }\n    ```", "```cpp\n    void AnimTexture::UnSet(unsigned int textureIndex) {\n    \u00a0\u00a0\u00a0\u00a0glActiveTexture(GL_TEXTURE0 + textureIndex);\n    \u00a0\u00a0\u00a0\u00a0glBindTexture(GL_TEXTURE_2D, 0);\n    \u00a0\u00a0\u00a0\u00a0glActiveTexture(GL_TEXTURE0);\n    }\n    ```", "```cpp\n    void AnimTexture::SetTexel(unsigned int x, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int y, const vec3& v) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int index = (y * mSize * 4) + (x * 4);\n    \u00a0\u00a0\u00a0\u00a0mData[index + 0] = v.x;\n    \u00a0\u00a0\u00a0\u00a0mData[index + 1] = v.y;\n    \u00a0\u00a0\u00a0\u00a0mData[index + 2] = v.z;\n    \u00a0\u00a0\u00a0\u00a0mData[index + 3] = 0.0f;\n    }\n    ```", "```cpp\n    void AnimTexture::SetTexel(unsigned int x, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int y, const quat& q) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int index = (y * mSize * 4) + (x * 4);\n    \u00a0\u00a0\u00a0\u00a0mData[index + 0] = q.x;\n    \u00a0\u00a0\u00a0\u00a0mData[index + 1] = q.y;\n    \u00a0\u00a0\u00a0\u00a0mData[index + 2] = q.z;\n    \u00a0\u00a0\u00a0\u00a0mData[index + 3] = q.w;\n    }\n    ```", "```cpp\n    vec4 AnimTexture::GetTexel(unsigned int x, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 unsigned int y) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int index = (y * mSize * 4) + (x * 4);\n    \u00a0\u00a0\u00a0\u00a0return vec4(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mData[index + 0],\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mData[index + 1],\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mData[index + 2],\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mData[index + 3]\n    \u00a0\u00a0\u00a0\u00a0);\n    }\n    ```", "```cpp\n    void BakeAnimationToTexture(Skeleton& skel, Clip& clip, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0AnimTexture& outTex);\n    ```", "```cpp\n    void BakeAnimationToTexture(Skeleton& skel, Clip& clip, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0AnimTexture& tex) {\n    \u00a0\u00a0\u00a0\u00a0Pose& bindPose = skel.GetBindPose();\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0Pose pose = bindPose;\n    \u00a0\u00a0\u00a0\u00a0unsigned int texWidth = tex.Size();\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int x = 0; x < texWidth; ++x) {\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float t = (float)x / (float)(texWidth - 1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float start = clip.GetStartTime();\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float time = start + clip.GetDuration() * t;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clip.Sample(pose, time);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (unsigned int y = 0;y<pose.Size()*3;y+=3) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Transform node=pose.GetGlobalTransform(y/3);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 tex.SetTexel(x, y + 0, node.position);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 tex.SetTexel(x, y + 1, node.rotation);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 tex.SetTexel(x, y + 2, node.scale);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0} // End of x loop\n    \u00a0\u00a0\u00a0\u00a0tex.UploadTextureDataToGPU();\n    }\n    ```", "```cpp\n    #version 330 core\n    #define MAX_BONES 60\n    #define MAX_INSTANCES 80\n    ```", "```cpp\n    uniform mat4 view;\n    uniform mat4 projection;\n    uniform mat4 invBindPose[MAX_BONES];\n    uniform sampler2D animTex;\n    ```", "```cpp\n    uniform vec3 model_pos[MAX_INSTANCES];\n    uniform vec4 model_rot[MAX_INSTANCES];\n    uniform vec3 model_scl[MAX_INSTANCES];\n    uniform ivec2 frames[MAX_INSTANCES];\n    uniform float time[MAX_INSTANCES];\n    ```", "```cpp\n    in vec3 position;\n    in vec3 normal;\n    in vec2 texCoord;\n    in vec4 weights;\n    in ivec4 joints;\n    ```", "```cpp\n    out vec3 norm;\n    out vec3 fragPos;\n    out vec2 uv;\n    ```", "```cpp\n    vec3 QMulV(vec4 q, vec3 v) {\n    \u00a0\u00a0\u00a0\u00a0return q.xyz * 2.0f * dot(q.xyz, v) +\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 v * (q.w * q.w - dot(q.xyz, q.xyz)) +\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 cross(q.xyz, v) * 2.0f * q.w;\n    }\n    ```", "```cpp\n    mat4 GetModel(int instance) {\n    \u00a0\u00a0\u00a0\u00a0vec3 position = model_pos[instance];\n    \u00a0\u00a0\u00a0\u00a0vec4 rotation = model_rot[instance];\n    \u00a0\u00a0\u00a0\u00a0vec3 scale = model_scl[instance];\n    \u00a0\u00a0\u00a0\u00a0vec3 xBasis = QMulV(rotation, vec3(scale.x, 0, 0));\n    \u00a0\u00a0\u00a0\u00a0vec3 yBasis = QMulV(rotation, vec3(0, scale.y, 0));\n    \u00a0\u00a0\u00a0\u00a0vec3 zBasis = QMulV(rotation, vec3(0, 0, scale.z));\n    \u00a0\u00a0\u00a0\u00a0return mat4(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0xBasis.x, xBasis.y, xBasis.z, 0.0,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0yBasis.x, yBasis.y, yBasis.z, 0.0,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0zBasis.x, zBasis.y, zBasis.z, 0.0,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0position.x, position.y, position.z, 1.0\n    \u00a0\u00a0\u00a0\u00a0);\n    }\n    ```", "```cpp\n    mat4 GetPose(int joint, int instance) {\n    \u00a0\u00a0\u00a0\u00a0int x_now = frames[instance].x;\n    \u00a0\u00a0\u00a0\u00a0int x_next = frames[instance].y;\n    \u00a0\u00a0\u00a0\u00a0int y_pos = joint * 3;\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0vec4 pos0 = texelFetch(animTex, ivec2(x_now, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(y_pos + 0)), 0);\n    \u00a0\u00a0\u00a0\u00a0vec4 rot0 = texelFetch(animTex, ivec2(x_now, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(y_pos + 1)), 0);\n    \u00a0\u00a0\u00a0\u00a0vec4 scl0 = texelFetch(animTex, ivec2(x_now, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(y_pos + 2)), 0);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0vec4 pos1 = texelFetch(animTex, ivec2(x_next, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(y_pos + 0)), 0);\n    \u00a0\u00a0\u00a0\u00a0vec4 rot1 = texelFetch(animTex, ivec2(x_next, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(y_pos + 1)), 0);\n    \u00a0\u00a0\u00a0\u00a0vec4 scl1 = texelFetch(animTex, ivec2(x_next, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(y_pos + 2)), 0);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0if (dot(rot0, rot1) < 0.0) { rot1 *= -1.0; }\n    \u00a0\u00a0\u00a0\u00a0vec4 position = mix(pos0, pos1, time[instance]);\n    \u00a0\u00a0\u00a0\u00a0vec4 rotation = normalize(mix(rot0, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rot1, time[instance]));\n    \u00a0\u00a0\u00a0\u00a0vec4 scale = mix(scl0, scl1, time[instance]);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0vec3 xBasis = QMulV(rotation, vec3(scale.x, 0, 0));\n    \u00a0\u00a0\u00a0\u00a0vec3 yBasis = QMulV(rotation, vec3(0, scale.y, 0));\n    \u00a0\u00a0\u00a0\u00a0vec3 zBasis = QMulV(rotation, vec3(0, 0, scale.z));\n    \u00a0\u00a0\u00a0\u00a0return mat4(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0xBasis.x, xBasis.y, xBasis.z, 0.0,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0yBasis.x, yBasis.y, yBasis.z, 0.0,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0zBasis.x, zBasis.y, zBasis.z, 0.0,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0position.x, position.y, position.z, 1.0\n    \u00a0\u00a0\u00a0\u00a0);\n    }\n    ```", "```cpp\n    void main() {\n    \u00a0\u00a0\u00a0\u00a0mat4 pose0 = GetPose(joints.x, gl_InstanceID);\n    \u00a0\u00a0\u00a0\u00a0mat4 pose1 = GetPose(joints.y, gl_InstanceID);\n    \u00a0\u00a0\u00a0\u00a0mat4 pose2 = GetPose(joints.z, gl_InstanceID);\n    \u00a0\u00a0\u00a0\u00a0mat4 pose3 = GetPose(joints.w, gl_InstanceID);\n    \u00a0\u00a0\u00a0\u00a0mat4 model = GetModel(gl_InstanceID);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0mat4 skin = (pose0*invBindPose[joints.x])*weights.x;\n    \u00a0\u00a0\u00a0\u00a0skin += (pose1 * invBindPose[joints.y]) * weights.y;\n    \u00a0\u00a0\u00a0\u00a0skin += (pose2 * invBindPose[joints.z]) * weights.z;\n    \u00a0\u00a0\u00a0\u00a0skin += (pose3 * invBindPose[joints.w]) * weights.w;\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0gl_Position = projection * view * model * \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0skin * vec4(position, 1.0);\n    \u00a0\u00a0\u00a0\u00a0fragPos = vec3(model * skin * vec4(position, 1.0));\n    \u00a0\u00a0\u00a0\u00a0norm = vec3(model * skin * vec4(normal, 0.0f));\n    \u00a0\u00a0\u00a0\u00a0uv = texCoord;\n    }\n    ```", "```cpp\n    #define CROWD_MAX_ACTORS 80\n    ```", "```cpp\n    struct Crowd {\n    protected:\n    \u00a0\u00a0\u00a0\u00a0std::vector<vec3> mPositions;\n    \u00a0\u00a0\u00a0\u00a0std::vector<quat> mRotations;\n    \u00a0\u00a0\u00a0\u00a0std::vector<vec3> mScales;\n    \u00a0\u00a0\u00a0\u00a0std::vector<ivec2> mFrames;\n    \u00a0\u00a0\u00a0\u00a0std::vector<float> mTimes;\n    \u00a0\u00a0\u00a0\u00a0std::vector<float> mCurrentPlayTimes;\n    \u00a0\u00a0\u00a0\u00a0std::vector<float> mNextPlayTimes;\n    ```", "```cpp\n    protected:\n    \u00a0\u00a0\u00a0\u00a0float AdjustTime(float t, float start, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float end, bool looping);\n    \u00a0\u00a0\u00a0\u00a0void UpdatePlaybackTimes(float dt, bool looping, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float start, float end);\n    \u00a0\u00a0\u00a0\u00a0void UpdateFrameIndices(float start, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float duration, unsigned int texWidth);\n    \u00a0\u00a0\u00a0\u00a0void UpdateInterpolationTimes(float start, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float duration, unsigned int texWidth);\n    ```", "```cpp\n    public:\n    \u00a0\u00a0\u00a0\u00a0unsigned int Size();\n    \u00a0\u00a0\u00a0\u00a0void Resize(unsigned int size);\n    \u00a0\u00a0\u00a0\u00a0Transform GetActor(unsigned int index);\n    \u00a0\u00a0\u00a0\u00a0void SetActor(unsigned int index, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const Transform& t);\n    ```", "```cpp\n    \u00a0\u00a0\u00a0\u00a0void Update(float deltaTime, Clip& mClip, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int texWidth);\n    \u00a0\u00a0\u00a0\u00a0void SetUniforms(Shader* shader);\n    };\n    ```", "```cpp\n    unsigned int Crowd::Size() {\n    \u00a0\u00a0\u00a0\u00a0return mCurrentPlayTimes.size();\n    }\n    void Crowd::Resize(unsigned int size) {\n    \u00a0\u00a0\u00a0\u00a0if (size > CROWD_MAX_ACTORS) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size = CROWD_MAX_ACTORS;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0mPositions.resize(size);\n    \u00a0\u00a0\u00a0\u00a0mRotations.resize(size);\n    \u00a0\u00a0\u00a0\u00a0mScales.resize(size, vec3(1, 1, 1));\n    \u00a0\u00a0\u00a0\u00a0mFrames.resize(size);\n    \u00a0\u00a0\u00a0\u00a0mTimes.resize(size);\n    \u00a0\u00a0\u00a0\u00a0mCurrentPlayTimes.resize(size);\n    \u00a0\u00a0\u00a0\u00a0mNextPlayTimes.resize(size);\n    }\n    ```", "```cpp\n    Transform Crowd::GetActor(unsigned int index) {\n    \u00a0\u00a0\u00a0\u00a0return Transform(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mPositions[index],\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mRotations[index],\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mScales[index] );\n    }\n    void Crowd::SetActor(unsigned int index, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 const Transform& t) {\n    \u00a0\u00a0\u00a0\u00a0mPositions[index] = t.position;\n    \u00a0\u00a0\u00a0\u00a0mRotations[index] = t.rotation;\n    \u00a0\u00a0\u00a0\u00a0mScales[index] = t.scale;\n    }\n    ```", "```cpp\n    float Crowd::AdjustTime(float time, float start, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float end, bool looping) {\n    \u00a0\u00a0\u00a0\u00a0if (looping) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0time = fmodf(time - start, end - start);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (time < 0.0f) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0time += end - start;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0time = time + start;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0else {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (time < start) { time = start; }\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (time > end) { time = end; }\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return time;\n    }\n    ```", "```cpp\n    void Crowd::UpdatePlaybackTimes(float deltaTime, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0bool looping, float start, float end) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = mCurrentPlayTimes.size();\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < size; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float time = mCurrentPlayTimes[i] + deltaTime;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mCurrentPlayTimes[i] = AdjustTime(time, start,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end, looping);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0time = mCurrentPlayTimes[i] + deltaTime;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mNextPlayTimes[i] = AdjustTime(time, start, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end, looping);\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void Crowd::UpdateFrameIndices(float start, float duration, unsigned int texWidth) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int size = mCurrentPlayTimes.size();\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < size; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float thisNormalizedTime = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 (mCurrentPlayTimes[i] - start) / duration;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int thisFrame = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 thisNormalizedTime * (texWidth - 1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float nextNormalizedTime = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 (mNextPlayTimes[i] - start) / duration;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int nextFrame = \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 nextNormalizedTime * (texWidth - 1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mFrames[i].x = thisFrame;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mFrames[i].y = nextFrame;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void Crowd::UpdateInterpolationTimes(float start, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float duration, unsigned int texWidth) {\n    \u00a0\u00a0\u00a0\u00a0unsigned int size =\u00a0\u00a0mCurrentPlayTimes.size();\n    \u00a0\u00a0\u00a0\u00a0for (unsigned int i = 0; i < size; ++i) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (mFrames[i].x == mFrames[i].y) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mTimes[i] = 1.0f;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float thisT = (float)mFrames[i].x / \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(float)(texWidth - 1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float thisTime = start + duration * thisT;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float nextT = (float)mFrames[i].y / \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(float)(texWidth - 1);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float nextTime = start + duration * nextT;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (nextTime < thisTime) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0nextTime += duration;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0float frameDuration = nextTime - thisTime;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mTimes[i] = (mCurrentPlayTimes[i] - thisTime) /\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0frameDuration;\n    \u00a0\u00a0\u00a0\u00a0}\n    }\n    ```", "```cpp\n    void Crowd::Update(float deltaTime, Clip& mClip, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int texWidth) {\n    \u00a0\u00a0 bool looping = mClip.GetLooping();\n    \u00a0\u00a0 float start = mClip.GetStartTime();\n    \u00a0\u00a0 float end = mClip.GetEndTime();\n    \u00a0\u00a0 float duration = mClip.GetDuration();\n\n    \u00a0\u00a0 UpdatePlaybackTimes(deltaTime, looping, start, end);\n    \u00a0\u00a0 UpdateFrameIndices(start, duration, texWidth);\n    \u00a0\u00a0 UpdateInterpolationTimes(start, duration, texWidth);\n    }\n    ```", "```cpp\n    void Crowd::SetUniforms(Shader* shader) {\n    \u00a0\u00a0\u00a0\u00a0Uniform<vec3>::Set(shader->GetUniform(\"model_pos\"),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 mPositions);\n    \u00a0\u00a0\u00a0\u00a0Uniform<quat>::Set(shader->GetUniform(\"model_rot\"), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 mRotations);\n    \u00a0\u00a0\u00a0\u00a0Uniform<vec3>::Set(shader->GetUniform(\"model_scl\"), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 mScales);\n    \u00a0\u00a0\u00a0\u00a0Uniform<ivec2>::Set(shader->GetUniform(\"frames\"), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 mFrames);\n    \u00a0\u00a0\u00a0\u00a0Uniform<float>::Set(shader->GetUniform(\"time\"), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 mTimes);\n    }\n    ```", "```cpp\nvoid Render(float aspect) {\n\u00a0\u00a0\u00a0\u00a0mat4 projection = perspective(60.0f, aspect, 0.01f, 100);\n\u00a0\u00a0\u00a0\u00a0mat4 view=lookAt(vec3(0,15,40), vec3(0,3,0), vec3(0,1,0));\n\u00a0\u00a0\u00a0\u00a0mCrowdShader->Bind();\n\u00a0\u00a0\u00a0\u00a0int viewUniform = mCrowdShader->GetUniform(\"view\")\n\u00a0\u00a0\u00a0\u00a0Uniform<mat4>::Set(viewUniform, view);\n\u00a0\u00a0\u00a0\u00a0int projUniform = mCrowdShader->GetUniform(\"projection\")\n\u00a0\u00a0\u00a0\u00a0Uniform<mat4>::Set(projUniform, projection);\n\u00a0\u00a0\u00a0\u00a0int lightUniform = mCrowdShader->GetUniform(\"light\");\n\u00a0\u00a0\u00a0\u00a0Uniform<vec3>::Set(lightUniform, vec3(1, 1, 1));\n\u00a0\u00a0\u00a0\u00a0int invBind = mCrowdShader->GetUniform(\"invBindPose\");\n\u00a0\u00a0\u00a0\u00a0Uniform<mat4>::Set(invBind, mSkeleton.GetInvBindPose());\n\u00a0\u00a0\u00a0\u00a0int texUniform = mCrowdShader->GetUniform(\"tex0\");\n\u00a0\u00a0\u00a0\u00a0mDiffuseTexture->Set(texUniform, 0);\n\u00a0\u00a0\u00a0\u00a0int animTexUniform = mCrowdShader->GetUniform(\"animTex\");\n\u00a0\u00a0\u00a0\u00a0mCrowdTexture->Set(animTexUniform, 1);\n\u00a0\u00a0\u00a0\u00a0mCrowd.SetUniforms(mCrowdShader);\n\u00a0\u00a0\u00a0\u00a0int pAttrib = mCrowdShader->GetAttribute(\"position\");\n\u00a0\u00a0\u00a0\u00a0int nAttrib = mCrowdShader->GetAttribute(\"normal\");\n\u00a0\u00a0\u00a0\u00a0int tAttrib = mCrowdShader->GetAttribute(\"texCoord\");\n\u00a0\u00a0\u00a0\u00a0int wAttrib = mCrowdShader->GetAttribute(\"weights\");\n\u00a0\u00a0\u00a0\u00a0int jAttrib = mCrowdShader->GetAttribute(\"joints\");\n\u00a0\u00a0\u00a0\u00a0mMesh.Bind(pAttrib, nAttrib, uAttrib, wAttrib, jAttrib);\n\u00a0\u00a0\u00a0\u00a0mMesh.DrawInstanced(mCrowd.Size());\n\u00a0\u00a0\u00a0\u00a0mMesh.UnBind(pAttrib, nAttrib, uAttrib, wAttrib, jAttrib);\n\u00a0\u00a0\u00a0\u00a0mCrowdTexture->UnSet(1);\n\u00a0\u00a0\u00a0\u00a0mDiffuseTexture->UnSet(0);\n\u00a0\u00a0\u00a0\u00a0mCrowdShader->UnBind();\n}\n```", "```cpp\n\u00a0\u00a0\u00a0\u00a0mat4 pose0a = GetPose(animTexA, joints.x, instance);\n\u00a0\u00a0\u00a0\u00a0mat4 pose1a = GetPose(animTexA, joints.y, instance);\n\u00a0\u00a0\u00a0\u00a0mat4 pose2a = GetPose(animTexA, joints.z, instance);\n\u00a0\u00a0\u00a0\u00a0mat4 pose3a = GetPose(animTexA, joints.w, instance);\n\u00a0\u00a0\u00a0\u00a0mat4 pose0b = GetPose(animTexB, joints.x, instance);\n\u00a0\u00a0\u00a0\u00a0mat4 pose1b = GetPose(animTexB, joints.y, instance);\n\u00a0\u00a0\u00a0\u00a0mat4 pose2b = GetPose(animTexB, joints.z, instance);\n\u00a0\u00a0\u00a0\u00a0mat4 pose3b = GetPose(animTexB, joints.w, instance);\n\u00a0\u00a0\u00a0\u00a0mat4 pose0 = pose0a * (1.0 - fade) + pose0b * fade;\n\u00a0\u00a0\u00a0\u00a0mat4 pose1 = pose1a * (1.0 - fade) + pose1b * fade;\n\u00a0\u00a0\u00a0\u00a0mat4 pose2 = pose2a * (1.0 - fade) + pose2b * fade;\n\u00a0\u00a0\u00a0\u00a0mat4 pose3 = pose3a * (1.0 - fade) + pose3b * fade;\n```", "```cpp\n\u00a0\u00a0\u00a0\u00a0mat4 pose0 = (weights.x < 0.0001)? \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat4(1.0) : GetPose(joints.x, instance);\n\u00a0\u00a0\u00a0\u00a0mat4 pose1 = (weights.y < 0.0001)? \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat4(1.0) : GetPose(joints.y, instance);\n\u00a0\u00a0\u00a0\u00a0mat4 pose2 = (weights.z < 0.0001)? \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat4(1.0) : GetPose(joints.z, instance);\n\u00a0\u00a0\u00a0\u00a0mat4 pose3 = (weights.w < 0.0001)? \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mat4(1.0) : GetPose(joints.w, instance);\n```"]