- en: Chapter 1. Introduction to Windows 8 Apps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。介绍Windows 8应用程序
- en: Windows 8, Microsoft's latest client operating system, looks quite different
    than its Windows 7 predecessor. With a new Start (home) screen, it promises to
    be a redesigned system, not just on the UI front but also in the way applications
    are written. A new style of applications is available for Windows 8 (and later)
    that are quite different from the "normal" applications (that are still very much
    supported).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 8，微软最新的客户端操作系统，看起来与其前身Windows 7大不相同。具有新的开始（主页）屏幕，它承诺是一个重新设计的系统，不仅在UI前端，而且在应用程序编写方式上也是如此。Windows
    8（以及以后）提供了一种与“正常”应用程序截然不同的新应用程序风格（仍然得到了很好的支持）。
- en: In this chapter, we'll take a quick tour of the new Windows 8 features, specifically
    those related to the new application type, known as Windows Store apps (formerly
    "Metro").
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将快速浏览新的Windows 8功能，特别是与新应用程序类型相关的功能，即Windows Store应用程序（以前称为“Metro”）。
- en: Introducing Windows 8
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Windows 8
- en: Windows 8 has been described by Microsoft as "Windows reimagined", which is
    not a false statement. From a user's perspective Windows 8 looks different; most
    notably, a new Start screen and the removal of the ubiquitous Start button that
    existed since Windows 95.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 8被微软描述为“重新构想的Windows”，这并不是一个错误的说法。从用户的角度来看，Windows 8看起来不同；最显著的是，一个新的开始屏幕和自Windows
    95以来存在的普遍的开始按钮被移除了。
- en: Under the covers, though, Windows is still the operating system we know and
    love; applications running on Windows 7 should continue to run just as well (and
    probably better) on Windows 8\. Many improvements went into the product, most
    of them invisible to the typical user; the visible changes are quite evident right
    from the Start (pun intended).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Windows在底层仍然是我们熟悉和喜爱的操作系统；在Windows 8上运行的应用程序应该会像在Windows 7上一样良好（甚至更好）。产品中进行了许多改进，其中大部分对典型用户来说是看不见的；从开始（打开）就可以看到明显的变化。
- en: Touch everywhere
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触摸无处不在
- en: Windows 8 targets touch-enabled devices, such as tablets. Microsoft itself is
    providing tablet devices under its own brand ("Surface") that are available starting
    from the Windows 8 **General Availability** (**GA**) date, October 26, 2012.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 8面向平板等触摸设备。微软本身提供了自己品牌的平板设备（“Surface”），从2012年10月26日Windows 8的**通用可用性**（**GA**）日期开始提供。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's worth mentioning that in the same time frame, Microsoft has released Windows
    Phone 8, the successor of the Windows 7.5 mobile OS, with a similar look and feel
    to Windows 8\. Windows Phone 8 is based on the same kernel that powers Windows
    8, and shares portions of the Windows 8 runtime. Going forward, these platforms
    are likely to merge, or at least come closer together.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，在同一时间段，微软发布了Windows Phone 8，这是Windows 7.5移动操作系统的后继版本，具有与Windows 8相似的外观和感觉。Windows
    Phone 8基于驱动Windows 8的相同内核，并共享Windows 8运行时的部分。未来，这些平台可能会合并，或者至少更加接近。
- en: Windows 8 is optimized for touch-enabled devices. Swiping the edges of the screen
    (always towards the visible part of the screen) causes something to happen (the
    same effect can be achieved with the mouse by moving the cursor to the edges or
    by using certain keyboard shortcuts). For example, swiping from the right causes
    the Charms bar to appear (more on the Charms bar in *The Charms bar* section given
    later in the chapter); the same effect can be achieved by moving the mouse cursor
    to the right edge of the screen or using the keyboard shortcut Windows key + *C*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 8被优化为触摸设备。在屏幕的边缘划动（始终朝向屏幕的可见部分）会引起一些事情发生（通过将鼠标移动到边缘或使用某些键盘快捷键也可以实现相同的效果）。例如，从右边划动会导致魅力栏出现（稍后在*魅力栏*部分中详细介绍）；通过将鼠标光标移动到屏幕的右边缘或使用键盘快捷键Windows键+*C*也可以实现相同的效果。
- en: The Start (Home) screen
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始（主页）屏幕
- en: The first thing to note about Windows 8 is the new **Start** screen. It's filled
    with tiles, mostly representing applications installed on the machine. The well-known
    desktop (from previous Windows versions) appears as a regular tile; clicking it
    (or tapping it using touch) transfers the user to the familiar desktop environment
    with largely the same functionality as in previous Windows versions, with shortcut
    icons, the taskbar, the notifications area, and so on, all except the Start button,
    which has gone away.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Windows 8的第一件事是新的**开始**屏幕。它充满了磁贴，大多数代表安装在设备上的应用程序。以前Windows版本中的熟悉桌面出现为常规磁贴；单击它（或使用触摸轻击它）会将用户转移到熟悉的桌面环境，具有与以前Windows版本中大致相同的功能，包括快捷图标、任务栏、通知区域等，除了已经消失的开始按钮。
- en: 'All installed applications are available from the new **Start** screen, whether
    they are the "normal" desktop applications or the new Store ("Metro") style applications:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有安装的应用程序都可以从新的**开始**屏幕中找到，无论它们是“正常”的桌面应用程序还是新的Store（“Metro”）风格的应用程序：
- en: '![The Start (Home) screen](img/5022_01_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![开始（主页）屏幕](img/5022_01_01.jpg)'
- en: The AppBar
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AppBar
- en: Swiping from the bottom in the **Start** screen presents the AppBar. This piece
    of UI is the replacement for a right-click context menu popular with the mouse.
    In fact, right-clicking with the mouse anywhere in the **Start** screen shows
    the AppBar, just as if the screen was swiped from the bottom.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在**开始**屏幕中从底部划动会显示AppBar。这个UI部分是鼠标上常见的右键上下文菜单的替代品。实际上，使用鼠标在**开始**屏幕的任何地方右键单击都会显示AppBar，就好像从底部划动屏幕一样。
- en: The AppBar provides relevant options depending on the selected object (or no
    selected object) and is used with the new Store apps just as on the **Start**
    screen; there is no built-in way to show the classic context menu in a Store application,
    even if a mouse device is used.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: AppBar根据所选对象（或未选择的对象）提供相关选项，并且与新的Store应用程序一起使用，就像在**开始**屏幕上一样；即使使用鼠标设备，也没有内置的方法在Store应用程序中显示经典的上下文菜单。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The fact that right-clicking in a Windows Store app (or the **Start** screen)
    causes the AppBar to appear even though the mouse is used is somewhat annoying,
    as the user is now forced to move the mouse from the intended object all the way
    to the bottom (or top for some applications) to select the required option.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows商店应用程序（或**开始**屏幕）中右键单击会导致AppBar出现，即使使用鼠标也是有点烦人的，因为用户现在被迫将鼠标从预期的对象移动到底部（或某些应用程序的顶部）以选择所需的选项。
- en: The Charms bar
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Charms栏
- en: 'The Charms bar appears when swiping from the right (on a touch device), or
    by moving the mouse to one of the corners on the right-hand side of the screen.
    Charms are ways to communicate with other applications from a user''s perspective.
    The standard charms are **Search**, **Share**, **Start**, **Devices**, and **Settings**:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当从右侧滑动（在触摸设备上）或将鼠标移动到屏幕右侧的任一角时，Charms栏会出现。从用户的角度来看，Charms是与其他应用程序进行通信的方式。标准charms包括**搜索**、**共享**、**开始**、**设备**和**设置**：
- en: '![The Charms bar](img/5022_01_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Charms栏](img/5022_01_02.jpg)'
- en: The **Search** charm allows the user to not just search in the operating system's
    applications (such as Control Panel applications) and the user's personal files
    (documents, pictures, and so on), but also in any other Store application that
    indicates it supports the Search contract.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索** charm 允许用户不仅可以在操作系统的应用程序（如控制面板应用程序）和用户的个人文件（文档、图片等）中搜索，还可以在任何其他指示支持搜索协议的商店应用程序中进行搜索。'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From the **Start** screen you can start searching just by typing on the keyboard,
    no need to explicitly activate the **Search** charm.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从**开始**屏幕，您可以通过键盘输入开始搜索，无需显式激活**搜索** charm。
- en: The **Share** charm allows an app to communicate with other apps without knowing
    anything about those apps. This is achieved by implementing the Share contract—either
    as a provider and/or receiver (we'll cover contracts in [Chapter 8](ch08.html
    "Chapter 8. Contracts and Extensions"), *Contracts and Extensions*).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**共享** charm 允许应用程序与其他应用程序进行通信，而无需了解这些应用程序的任何信息。这是通过实现共享协议来实现的——可以是提供者和/或接收者（我们将在[第8章](ch08.html
    "第8章。合同和扩展")，“合同和扩展”中介绍合同）。'
- en: The **Start** charm simply takes the user to the **Start** screen.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**开始** charm 只是将用户带到**开始**屏幕。'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pressing the Windows key alone, at any time, shows the **Start** screen.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 单独按下Windows键随时都会显示**开始**屏幕。
- en: The **Devices** charm allows access to device-related activities (if supported
    by the app), such as printing. And finally, the **Settings** charm allows the
    user to customize the currently executing app (if supported by the app), or to
    customize general Windows features.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备** charm 允许访问与设备相关的活动（如果应用程序支持），如打印。最后，**设置** charm 允许用户自定义当前正在执行的应用程序（如果应用程序支持），或自定义一般的Windows功能。'
- en: Desktop apps versus Store apps
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桌面应用程序与商店应用程序
- en: All the applications running on Windows systems prior to Windows 8 are called
    Desktop applications in Windows 8 terminology. These are the regular, normal applications,
    which can be built with any of the various Microsoft technologies, such as the
    Win32 API, **Microsoft Foundation Classes** (**MFC**), **Active Template Library**
    (**ATL**), .NET technologies (WPF, Silverlight, Windows Forms, and so on), and
    any logical combination of these. These types of applications are still very much
    supported in Windows 8, so there's really nothing special here.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows 8术语中，之前在Windows系统上运行的所有应用程序都称为桌面应用程序。这些是常规的、普通的应用程序，可以使用各种微软技术构建，如Win32
    API、**Microsoft Foundation Classes**（**MFC**）、**Active Template Library**（**ATL**）、.NET技术（WPF、Silverlight、Windows
    Forms等），以及这些技术的任何逻辑组合。这些类型的应用程序在Windows 8中仍然得到了很好的支持，因此在这里实际上没有什么特别之处。
- en: The other type of applications supported in Windows 8 is the Store applications.
    These applications are unsupported in previous Windows versions. Windows Store
    apps are the focus of this book. We won't be dealing with desktop apps at all.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 8支持的另一种应用程序类型是商店应用程序。这些应用程序在以前的Windows版本中不受支持。Windows商店应用程序是本书的重点。我们将完全不涉及桌面应用程序。
- en: 'Store applications are different in many ways from desktop apps. Some of the
    differences are:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 商店应用程序在许多方面与桌面应用程序不同。一些不同之处包括：
- en: Store apps are immersive, they are always full screen (except when snapped,
    see [Chapter 9](ch09.html "Chapter 9. Packaging and the Windows Store"), *Packaging
    and the Windows Store*); there is no window chrome (that is no caption, no close
    or minimize buttons, and so on). We'll discuss the user interface aspects of Store
    apps in [Chapters 3](ch03.html "Chapter 3. Building UI with XAML"), *Building
    UI with XAML* and [Chapter 4](ch04.html "Chapter 4. Layout, Elements, and Controls"),
    *Layout, Elements, and Controls*.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店应用程序是沉浸式的，它们始终是全屏的（除非被捕捉，参见[第9章](ch09.html "第9章。打包和Windows商店")，“打包和Windows商店”）；没有窗口装饰（即没有标题、关闭或最小化按钮等）。我们将在[第3章](ch03.html
    "第3章。使用XAML构建UI")，“使用XAML构建UI”和[第4章](ch04.html "第4章。布局、元素和控件")，“布局、元素和控件”中讨论商店应用程序的用户界面方面。
- en: The Store apps life cycle is managed by Windows. If another application becomes
    the foreground app, the previous app is suspended (after a few seconds), consuming
    no CPU cycles. We'll discuss the application lifecycle in [Chapter 7](ch07.html
    "Chapter 7. Applications, Tiles, Tasks, and Notifications"), *Applications, Tiles,
    Tasks, and Notifications*.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店应用程序的生命周期由Windows管理。如果另一个应用程序成为前台应用程序，之前的应用程序将被挂起（几秒钟后），不消耗CPU周期。我们将在[第7章](ch07.html
    "第7章。应用程序、磁贴、任务和通知")，“应用程序、磁贴、任务和通知”中讨论应用程序的生命周期。
- en: Only one instance of the app can run at any one time. Clicking on the app tile
    while the app is running simply switches to the running app. The user should not
    know, nor care, if the app was actually already in memory or just started up.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只能运行一个应用程序实例。在应用程序运行时点击应用程序磁贴只是切换到正在运行的应用程序。用户不应该知道，也不应该关心应用程序实际上是已经在内存中还是刚刚启动。
- en: Store apps cannot directly communicate with other running apps, some forms of
    communication are possible through the idea of contracts. We'll discuss contracts
    in [Chapter 8](ch08.html "Chapter 8. Contracts and Extensions"), *Contracts and
    Extensions*.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店应用不能直接与其他正在运行的应用程序通信，一些形式的通信是通过合同的概念可能的。我们将在[第8章](ch08.html "第8章。合同和扩展"),
    *合同和扩展*中讨论合同。
- en: Store apps run on top of a new runtime, called **Windows Runtime** (**WinRT**)
    that is built upon native foundations and the **Component Object Model** (**COM**)
    technologies. We'll discuss WinRT and its relation to COM in [Chapter 2](ch02.html
    "Chapter 2. COM and C++ for Windows 8 Store Apps"), *COM and C++ for Windows 8
    Store Apps*.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店应用运行在一个新的运行时之上，称为**Windows Runtime**（**WinRT**），它建立在本地基础和**组件对象模型**（**COM**）技术之上。我们将在[第2章](ch02.html
    "第2章。Windows 8商店应用的COM和C++")中讨论WinRT及其与COM的关系，*Windows 8商店应用的COM和C++*。
- en: Store apps are distributed and installed via the Windows 8 Store only (except
    for special cases for enterprise customers), and not using traditional means of
    an installer package. We'll discuss the Store in [Chapter 9](ch09.html "Chapter 9. Packaging
    and the Windows Store"), *Packaging and the Windows Store*.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店应用程序只能通过Windows 8商店分发和安装（除了企业客户的特殊情况），而不能使用传统的安装程序包。我们将在[第9章](ch09.html "第9章。打包和Windows商店"),
    *打包和Windows商店*中讨论商店。
- en: Store apps must declare anything they want to use up front through capabilities
    (such as using the camera that may be present on the device). Anything not declared
    will cause a failure at runtime. When a user selects the app for downloading,
    he/she must accept the capabilities the app wants to use; otherwise, the app won't
    install.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店应用必须通过功能（例如使用设备上可能存在的摄像头）提前声明他们想要使用的任何东西。任何未声明的东西都会在运行时导致失败。当用户选择下载应用时，他/她必须接受应用想要使用的功能；否则，应用将无法安装。
- en: What all this means is that Store apps are different, requiring a different
    knowledge set, quite unlike the knowledge for writing desktop apps.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些意味着商店应用是不同的，需要不同的知识体系，与编写桌面应用的知识完全不同。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Windows 8 on tablets comes in two main variants, based on the CPU architecture.
    One is based on Intel/AMD (with 32 bit and 64 bit variants), which is a full Windows
    8 that can run desktop apps, as well as Store apps. The second edition is based
    on the ARM family of processors and is named "Windows RT" (not to be confused
    with the Windows Runtime). This edition can only run Store apps (at least at the
    time of writing).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 平板电脑上的Windows 8有两个主要变体，基于CPU架构。一个基于英特尔/AMD（具有32位和64位变体），这是一个完整的Windows 8，可以运行桌面应用程序，以及商店应用程序。第二版基于ARM处理器系列，被命名为“Windows
    RT”（不要与Windows Runtime混淆）。这个版本只能运行商店应用程序（至少在撰写本文时是这样）。
- en: The Windows Runtime
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows Runtime
- en: Store applications are built and execute against a new runtime called Windows
    Runtime (WinRT) that is not present on previous Windows versions. WinRT is built
    upon the well-established COM technology (with some WinRT-specific enhancements,
    such as the use of metadata). This means WinRT is entirely native (no .NET CLR
    anywhere), making C++ a natural and performant choice for targeting this runtime.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 商店应用程序是针对一个称为Windows Runtime（WinRT）的新运行时构建和执行的，这个运行时在以前的Windows版本中不存在。WinRT建立在成熟的COM技术之上（具有一些WinRT特定的增强功能，如元数据的使用）。这意味着WinRT是完全本地的（没有.NET
    CLR），使得C++成为针对这个运行时的自然和高性能的选择。
- en: 'WinRT provides a set of services, on which apps can be built. The relationship
    between the WinRT and applications can be represented by the following diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT提供了一组服务，应用程序可以构建在其上。WinRT和应用程序之间的关系可以用以下图表表示：
- en: '![The Windows Runtime](img/5022_01_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Windows Runtime](img/5022_01_03.jpg)'
- en: 'WinRT APIs have the following characteristics:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT API具有以下特点：
- en: Built as a set of types, implementing interfaces (as mandated by COM). These
    types are arranged in hierarchical namespaces, logically grouped for easy access
    and for preventing name clashes.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一组类型构建，实现接口（如COM所规定）。这些类型被组织在分层命名空间中，逻辑分组以便易于访问和防止名称冲突。
- en: Every WinRT object handles its own lifetime by using (mostly) an internal reference
    count (as done in COM).
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个WinRT对象都通过使用（主要是）内部引用计数来处理自己的生命周期（就像在COM中一样）。
- en: Using the raw WinRT may be pretty verbose, leading to language projections that
    implement the little details, such as decrementing the reference count automatically
    when an object is no longer needed by a client.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原始WinRT可能会非常冗长，导致语言投影实现一些细节，例如当客户端不再需要对象时自动减少引用计数。
- en: All public types are built with metadata, describing the public surface of the
    API. This is part of the magic that allows various languages to access WinRT relatively
    easily.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有公共类型都使用元数据构建，描述API的公共表面。这是让各种语言相对容易地访问WinRT的魔法的一部分。
- en: Many APIs are asynchronous, they start an operation and notify when that operation
    completes. A general guideline in WinRT is that any operation that may take more
    than 50 milliseconds should be made asynchronous. This is important so that the
    UI does not get frozen which makes for a bad user experience.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多API是异步的，它们启动一个操作并在操作完成时通知。在WinRT中的一个一般指导原则是，任何可能需要超过50毫秒的操作都应该是异步的。这很重要，以防止UI被冻结，从而造成糟糕的用户体验。
- en: We'll take a detailed look at WinRT core concepts in [Chapter 2](ch02.html "Chapter 2. COM
    and C++ for Windows 8 Store Apps"), COM and *C++ for Windows 8 Store Apps*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第2章](ch02.html "第2章。Windows 8商店应用的COM和C++")中详细了解WinRT的核心概念，COM和*Windows
    8商店应用的C++*。
- en: Language projections
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言投影
- en: As WinRT uses COM, using it directly is only possible from a language that understands
    pointers and virtual tables natively, namely C++ (C is technically also possible,
    but we won't discuss it in this book).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于WinRT使用COM，直接使用它只有从能够原生理解指针和虚拟表的语言才可能，也就是C++（从技术上讲，C也是可能的，但我们不会在本书中讨论它）。
- en: Many developers working with Microsoft technologies work in non-C++ environments,
    namely .NET (mostly with the C# language, but other languages are used as well,
    such as Visual Basic and F#) and JavaScript, popular (and necessary) with web
    development.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 许多使用微软技术的开发人员在非C++环境中工作，主要是.NET（主要使用C#语言，但也使用其他语言，如Visual Basic和F#）和JavaScript，在Web开发中非常流行（也是必要的）。
- en: Even in C++, using COM is not as easy as we'd like; a lot of details need to
    be taken care of (such as calling the `IUnknown` interface methods when appropriate),
    distracting the developer from his/her primary job—building the actual app functionality.
    This is why Microsoft has created language projections that expose WinRT in selected
    environments fairly consistently with that particular environment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在C++中，使用COM也不像我们希望的那样容易；许多细节需要被关注（比如在适当时调用`IUnknown`接口方法），这会让开发者分心，无法专注于他/她的主要工作——构建实际的应用功能。这就是为什么微软创建了语言投影，以在特定环境中相对一致地公开WinRT。
- en: 'Microsoft currently provides three language projections over WinRT:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 微软目前提供了三种WinRT语言投影：
- en: C++ has the most lightweight and direct projection. These projections are made
    possible by a set of language extensions, known as C++/CX (Component Extensions).
    These make working with WinRT objects much easier than using the raw COM interfaces
    (we'll discuss this in length in [Chapter 2](ch02.html "Chapter 2. COM and C++
    for Windows 8 Store Apps"), *COM and C++ for Windows 8 Store Apps*).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++具有最轻量级和直接的投影。这些投影是通过一组语言扩展实现的，称为C++/CX（组件扩展）。这使得与WinRT对象一起工作比使用原始COM接口更容易（我们将在[第2章](ch02.html
    "第2章。Windows 8商店应用的COM和C++")中详细讨论这一点，*Windows 8商店应用的COM和C++*）。
- en: Using managed (.NET) languages such as C# and Visual Basic is possible through
    projections to the .NET runtime. These projections make it very easy for .NET
    developers to work with WinRT. **Runtime Callable Wrappers** (**RCWs**) are created
    automatically to bridge the managed-native boundary when transitioning to and
    from WinRT. This mechanism is very similar in principle to the usual way in which
    .NET code calls COM objects.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用托管（.NET）语言，如C#和Visual Basic，通过对.NET运行时的投影是可能的。这些投影使得.NET开发人员非常容易与WinRT一起工作。**运行时可调用包装器**（**RCWs**）在过渡到和从WinRT时自动创建，以弥合托管-本机边界。这种机制在原则上与.NET代码调用COM对象的通常方式非常相似。
- en: The third supported projection is with the JavaScript language, popular in web
    development. Clever wrappers over WinRT make using JavaScript relatively easy,
    including making certain conventions automatic, such as using a lowercase letter
    for the first word of a method, even though the real WinRT method begins with
    a capital letter. Using JavaScript also brings in HTML for building the Store
    app user interface, again potentially leveraging existing knowledge for JavaScript
    developers.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种支持的投影是使用JavaScript语言，这在Web开发中很受欢迎。WinRT的聪明包装使得使用JavaScript相对容易，包括使某些约定自动化，比如使用小写字母作为方法的第一个字母，尽管真正的WinRT方法以大写字母开头。使用JavaScript还引入了HTML来构建商店应用的用户界面，这可能再次利用JavaScript开发人员的现有知识。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: JavaScript is limited to consuming WinRT types. It cannot create new types (.NET
    and C++ can).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript仅限于使用WinRT类型。它不能创建新类型（.NET和C++可以）。
- en: C++ does not require the CLR (.NET runtime), which makes it the most lightweight,
    both in terms of execution speed and memory consumption. We'll take a detailed
    look at using C++ throughout this book, starting from the next chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: C++不需要CLR（.NET运行时），这使得它在执行速度和内存消耗方面最轻量级。我们将在本书中详细介绍使用C++，从下一章开始。
- en: Building the user interface
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: JavaScript is the only language that has direct access to working with HTML,
    as the way to create the app's user interface. This is so that JavaScript developers
    have less to learn, they probably know HTML already. The Windows Library for JavaScript
    provides access to controls, CSS, and other helpers to bridge the gap to WinRT.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是唯一直接访问HTML的语言，用于创建应用的用户界面。这样JavaScript开发人员就不需要学习太多，他们可能已经了解HTML。Windows
    JavaScript库提供了对控件、CSS和其他辅助程序的访问，以弥合与WinRT之间的差距。
- en: C++ and .NET developers use the XAML language to build user interfaces. XAML
    is an XML-based declarative language that allows (somewhat simplistically) creating
    objects and setting their properties. We'll take a closer look at XAML and UI
    in [Chapter 3](ch03.html "Chapter 3. Building UI with XAML"), *Building UI with
    XAML*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: C++和.NET开发人员使用XAML语言构建用户界面。XAML是一种基于XML的声明性语言，允许（在某种程度上）创建对象并设置它们的属性。我们将在[第3章](ch03.html
    "第3章。使用XAML构建UI")中更详细地了解XAML和UI，*使用XAML构建UI*。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Developers familiar with XAML from working in other technologies, such as WPF
    or Silverlight, will feel pretty much at home, as the same basic concepts apply
    to WinRT XAML.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉XAML的开发人员，比如在其他技术中工作过的WPF或Silverlight，会感到非常熟悉，因为相同的基本概念适用于WinRT XAML。
- en: A third option exists, primarily for C++ developers – DirectX. DirectX is the
    most low-level and powerful graphic API on the Windows platform; thus, it's used
    mostly for authoring games while utilizing the full potential of the machine by
    leveraging the power of the **Graphic Processing Unit** (**GPU**). As DirectX
    is, itself, built upon COM, it's naturally accessible from C++. Other languages
    must go through some wrapper library to gain direct access to the DirectX APIs
    (no such wrapper is provided by Microsoft at the time of writing, but there are
    third party libraries such as SharpDX).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项存在，主要是为C++开发人员——DirectX。DirectX是Windows平台上最低级和最强大的图形API；因此，它主要用于创作游戏，同时利用机器的全部潜力，充分发挥**图形处理单元**（**GPU**）的能力。由于DirectX本身是基于COM构建的，因此它自然可以从C++中访问。其他语言必须通过一些包装库来直接访问DirectX
    API（微软在撰写时没有提供这样的包装器，但有第三方库，如SharpDX）。
- en: Creating your first Store application
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个商店应用
- en: Enough talk. It's time to open Visual Studio and create a simple Store app in
    C++, looking at some of its characteristics. We'll delve deeper into the way a
    Windows Store app is built in the next chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 足够的谈话。是时候打开Visual Studio并创建一个简单的C++商店应用程序，看一下它的一些特点。我们将在下一章中更深入地了解Windows商店应用程序的构建方式。
- en: Store apps must be created using Visual Studio 2012 (or later) running on Windows
    8 (or later); although Visual Studio 2012 runs on Windows 7, it cannot be used
    for developing Store apps on that OS.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 商店应用程序必须使用运行在Windows 8（或更高版本）上的Visual Studio 2012（或更高版本）创建；尽管Visual Studio 2012可以在Windows
    7上运行，但不能用于在该操作系统上开发商店应用程序。
- en: 'Let''s open Visual Studio 2012 and create a new Store application project in
    C++ by selecting the **Windows Store** node under the **Visual** **C++** node:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开Visual Studio 2012，并通过选择**Visual** **C++**节点下的**Windows Store**节点来创建一个新的商店应用程序项目：
- en: '![Creating your first Store application](img/5022_01_04.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![创建您的第一个商店应用程序](img/5022_01_04.jpg)'
- en: Select **Blank App (XAML)** on the right and enter `CH01.HelloLive` in the **Name**
    textbox and enter some location on your filesystem; then click **OK**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧选择**空白应用程序（XAML）**，在**名称**文本框中输入`CH01.HelloLive`，然后在您的文件系统中输入一些位置；然后点击**确定**。
- en: 'Visual Studio creates a project with several files. We''ll take a look at those
    files a bit later, but for now open the **MainPage.xaml** file. This is where
    the UI is located. It has a split view by default, the lower pane showing the
    XAML markup and the upper pane showing a preview. The XAML shows a `Page` root
    element with several attributes and a `Grid` element inside. We''ll discuss all
    the details in [Chapter 3](ch03.html "Chapter 3. Building UI with XAML"), *Building
    UI with XAML*, but for now we''ll create a simple addition calculator as our first
    "Hello World!" application. Add the following markup inside the `Grid` element:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio创建了一个带有多个文件的项目。我们稍后会看一下这些文件，但现在打开**MainPage.xaml**文件。这是UI所在的位置。默认情况下，它具有一个分割视图，下面的窗格显示XAML标记，上面的窗格显示预览。XAML显示了一个`Page`根元素，具有多个属性和内部的`Grid`元素。我们将在[第3章](ch03.html
    "第3章。使用XAML构建UI")中讨论所有细节，*使用XAML构建UI*，但现在我们将创建一个简单的加法计算器作为我们的第一个“Hello World！”应用程序。在`Grid`元素内添加以下标记：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.PacktPub.com](http://www.PacktPub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.PacktPub.com/support](http://www.PacktPub.com/support)并注册，以便将文件直接发送到您的电子邮件。
- en: 'The upper preview part should show something like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上部预览部分应该显示类似于这样的内容：
- en: '![Creating your first Store application](img/5022_01_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![创建您的第一个商店应用程序](img/5022_01_05.jpg)'
- en: 'Two `TextBox` controls (named `_number1` and `_number2`) are used for user
    input and a `TextBlock` element (named `_result`) is used for the output. To make
    this work, we need to handle the `Button`''s `Click` event. To do that, simply
    double-click the button in the designer. This will add an event handler in the
    `MainPage.xaml.cpp` file (as well as the corresponding header file and a `Click`
    attribute for the button in the XAML). Visual Studio should automatically open
    `MainPage.xaml.cpp`. The generated event handler will look like the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`TextBox`控件（名为`_number1`和`_number2`）用于用户输入，一个`TextBlock`元素（名为`_result`）用于输出。为了使其工作，我们需要处理`Button`的`Click`事件。要做到这一点，只需在设计器中双击按钮。这将在`MainPage.xaml.cpp`文件中添加一个事件处理程序（以及相应的头文件和XAML中按钮的`Click`属性）。Visual
    Studio应该会自动打开`MainPage.xaml.cpp`。生成的事件处理程序将如下所示：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At the top of the file Visual Studio created some using namespace declarations
    that we can leverage to simplify the method signature (`CH01_HelloLive`, `Platform`,
    and `Windows::UI::XAML` namespaces):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部，Visual Studio创建了一些使用命名空间声明，我们可以利用这些声明来简化方法签名（`CH01_HelloLive`，`Platform`和`Windows::UI::XAML`命名空间）：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The handler may seem strange at this time, at least due to the "hat" (`^`) symbol
    stuck to the `Object` and `RoutedEventArgs` classes. We'll discuss this in the
    next chapter (this is a C++/CX extension), but the hat basically means a "reference
    counted pointer" to a WinRT object.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，处理程序可能看起来很奇怪，至少是因为“帽子”（`^`）符号粘在`Object`和`RoutedEventArgs`类上。我们将在下一章中讨论这一点（这是C++/CX扩展），但帽子基本上意味着对WinRT对象的“引用计数指针”。
- en: All that's left to do now is implement the handler, so that the calculated result
    is shown in the result `TextBlock`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是实现处理程序，以便在结果`TextBlock`中显示计算结果。
- en: It turns out that naming elements makes those names actual member variables
    of the class in question (`MainPage`) and, thus, are available for us to use where
    needed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，给元素命名使这些名称成为了该类（`MainPage`）的实际成员变量，并且因此可以在需要时供我们使用。
- en: First, we need to extract the numbers to add, but the content of the `TextBox`
    controls is a string. In fact, it's a WinRT string, `Platform::String`. How do
    we convert that to a number? Do we use some WinRT function for that?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要提取要相加的数字，但`TextBox`控件的内容是一个字符串。实际上，它是一个WinRT字符串，`Platform::String`。我们如何将其转换为数字？我们使用一些WinRT函数吗？
- en: No. We use plain old C++; we just need a way to turn a `Platform::String` into
    a normal `std::string` or `std::wstring` (`wstring` should be preferred, as all
    WinRT strings are Unicode). Fortunately, that's easy with the `Data()` member
    function of `Platform::String` that returns a simple `const` `wchar_t*` pointing
    to the string; note that a Unicode pointer is the only one available.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们使用普通的C++；我们只需要一种方法将`Platform::String`转换为普通的`std::string`或`std::wstring`（应优先选择`wstring`，因为所有WinRT字符串都是Unicode）。幸运的是，使用`Platform::String`的`Data()`成员函数将返回一个简单的指向字符串的`const`
    `wchar_t*`；请注意，Unicode指针是唯一可用的。
- en: 'To do the actual conversion, we can use old C-style functions such as `wtoi()`,
    but for a nicer, modern conversion, we''ll use string streams. Add an `#include`
    near the top of the file (after the existing includes) for `<sstream>`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行实际的转换，我们可以使用旧的C风格函数，比如`wtoi()`，但为了更好的、现代化的转换，我们将使用字符串流。在文件的顶部附近（现有包含之后）添加一个`#include`，包括`<sstream>`：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, inside the event handler, we''ll create two `wstringstream` objects to
    handle the conversion based on the content of the `TextBox` controls:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在事件处理程序中，我们将创建两个`wstringstream`对象来处理基于`TextBox`控件内容的转换：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice the arrow (`->`) operator at work. The "hat" references are dereferenced
    using the arrow dereferencing operator, but they are not pointers (Chapter 2,
    *COM and C++ for Windows 8 Store Apps* will explain further). Let''s continue
    with the conversion to integers:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意箭头（`->`）操作符的工作。这些“帽子”引用是使用箭头解引用操作符进行解引用的，但它们不是指针（第2章，*用于Windows 8商店应用的COM和C++*将进一步解释）。让我们继续转换为整数：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can actually do the conversion faster with a new C++ 11 function, `std::stoi`
    that converts a `std::string` (or `std::wstring`) to an integer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以使用新的C++ 11函数`std::stoi`更快地进行转换，它将`std::string`（或`std::wstring`）转换为整数。
- en: 'Finally, we need to place the result of adding the numbers to the `TextBlock`
    named `_result`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将添加数字的结果放到名为`_result`的`TextBlock`中：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `ToString()` call operating on an integer, provides the conversion to a
    `Platform::String`, which is very convenient in this case. How is it possible
    to have a member function on an `int`? It's possible, because it's WinRT's `int`,
    and all WinRT types derive from an ultimate base class named `Platform::Object`
    (this is not strictly true, as this is achieved by compiler trickery. A more detailed
    explanation is provided in the next chapter), which exposes a `ToString()` virtual
    method to be overridden by derived types. Still, `int` is a primitive type in
    C++, and should not derive from anything, so how could it have a `ToString()`
    method? We'll return to that in a moment.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对整数进行`ToString()`调用，提供了转换为`Platform::String`，在这种情况下非常方便。怎么可能在`int`上有一个成员函数？这是可能的，因为这是WinRT的`int`，而所有WinRT类型都派生自一个名为`Platform::Object`的最终基类（这并不严格正确，因为这是通过编译器的技巧实现的。更详细的解释将在下一章中提供），它公开了一个`ToString()`虚方法，可以被派生类型重写。然而，`int`是C++中的一个原始类型，不应该派生自任何东西，那么它怎么可能有一个`ToString()`方法呢？我们马上就会回到这个问题。
- en: For now, let's test the application. Build the project and run it with the debugger
    by selecting **Debug** | **Start Debugging** from the menu, click on the relevant
    toolbar button (with a green arrow and labeled **Local Machine** by default) or
    simply press *F5*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下应用程序。通过选择菜单中的**调试** | **开始调试**来构建项目并在调试器中运行它，点击相关的工具栏按钮（默认情况下带有绿色箭头并标有**本地计算机**）或者简单地按下*F5*。
- en: 'A splash screen of a crossed rectangle should appear for a few seconds and
    then the application''s UI should come up. Type two numbers in the text boxes
    and click on the button to observe the result:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有交叉矩形的启动画面应该会出现几秒钟，然后应用程序的用户界面应该会出现。在文本框中输入两个数字，然后点击按钮观察结果：
- en: '![Creating your first Store application](img/5022_01_06.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![创建你的第一个商店应用程序](img/5022_01_06.jpg)'
- en: Not too sophisticated, but a Store app nonetheless! Note the application is
    full screen, with no title bar, caption buttons, or even a close button for that
    matter. This is the way Store apps look.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是太复杂，但仍然是一个商店应用程序！请注意，该应用程序是全屏的，没有标题栏、标题按钮，甚至没有关闭按钮。这就是商店应用程序的外观。
- en: Closing an application
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭应用程序
- en: How do we close the application? One—not so convenient with a mouse—way is to
    grab the window at the top (where a title bar would have been) and drag it all
    the way to the bottom. This was mainly done because Store apps are not meant to
    be explicitly closed. An app will become suspended (consume no CPU) if not used
    and can be terminated if the memory pressure is high; this means a typical user
    should not care about closing an app.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何关闭应用程序？一个不太方便的方法是用鼠标抓住窗口的顶部（原本是标题栏的地方）并将其拖到底部。这主要是因为商店应用程序不是用来明确关闭的。如果应用程序没有使用，它将被挂起（不消耗CPU），如果内存压力很大，它可以被终止；这意味着典型用户不应该关心关闭应用程序。
- en: Luckily, we're not typical users. A simpler way to close the app is to *Alt*
    + *Tab* back to Visual Studio and select **Debug** | **Stop Debugging** from the
    menu (or *Shift* + *F5*). That's why it's better to test Store apps from Visual
    Studio with the debugger attached.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不是典型的用户。关闭应用程序的一个更简单的方法是*Alt* + *Tab*回到Visual Studio并从菜单中选择**调试** | **停止调试**（或*Shift*
    + *F5*）。这就是为什么最好在附加了调试器的情况下从Visual Studio测试商店应用程序。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pressing *Alt* + *F4* also works as a way to close an application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Alt* + *F4*也可以作为关闭应用程序的方法。
- en: Application deployment
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序部署
- en: 'Can we run the application without Visual Studio? We can navigate to the folder
    where the source code is built and locate the resulting `.exe` file. Double-clicking
    on that from Windows Explorer fails with the following message box:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在没有Visual Studio的情况下运行应用程序吗？我们可以导航到源代码构建的文件夹并找到生成的`.exe`文件。在Windows资源管理器中双击该文件会出现以下消息框：
- en: '![Application deployment](img/5022_01_07.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序部署](img/5022_01_07.jpg)'
- en: The error message is basically saying that we cannot simply run the Store app
    just like a desktop app, there are several steps involved in starting a Store
    app, for which a simple double-click is not merely enough. So, how can we run
    the app without Visual Studio? The same way "normal" users do, through the **Start**
    screen.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息基本上是在说我们不能简单地像运行桌面应用程序那样运行商店应用程序，启动商店应用程序涉及几个步骤，简单的双击是不够的。那么，我们如何在没有Visual
    Studio的情况下运行应用程序呢？和“普通”用户一样，通过**开始**屏幕。
- en: 'If we open the **Start** screen and navigate all the way to the right, we''ll
    find something like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开**开始**屏幕并导航到最右边，我们会发现类似这样的东西：
- en: '![Application deployment](img/5022_01_08.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序部署](img/5022_01_08.jpg)'
- en: The application was deployed automatically by Visual Studio, as if it was downloaded
    from the Windows Store. It's actually possible to do deployment only without running
    by selecting **Build** | **Deploy Solution** from Visual Studio's menu. To remove
    the application, right-click it in the **Start** screen (or swipe from the bottom)
    and select **Uninstall**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序被Visual Studio自动部署，就好像它是从Windows商店下载的一样。实际上，可以通过从Visual Studio的菜单中选择**生成**
    | **部署解决方案**来仅进行部署而不运行应用程序。要删除应用程序，请在**开始**屏幕上右键单击它（或从底部滑动）并选择**卸载**。
- en: Where did int.ToString come from?
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: int.ToString是从哪里来的？
- en: 'To find this out, we''ll set a breakpoint on the last line of the click event
    handler we implemented, and run the application until we reach the breakpoint.
    When the breakpoint hits, right-click at the breakpoint line in the editor and
    select **Go To Disassembly**. These are the first few lines of assembly code at
    that point:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出这一点，我们将在我们实现的点击事件处理程序的最后一行上设置一个断点，并运行应用程序直到达到断点。当断点触发时，在编辑器中右键单击断点行并选择**转到反汇编**。这是该点的汇编代码的前几行：
- en: '![Where did int.ToString come from?](img/5022_01_09.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![int.ToString是从哪里来的？](img/5022_01_09.jpg)'
- en: 'The last line is the interesting one, calling some static function named `default::int32::ToString`.
    We can Step Over (*F10*) to that line and then Step Into (*F11*). After a few
    more Step Into, we finally reach the actual function. Right-clicking the window
    and selecting **Go To Source Code** leaves out the detailed assembly and shows
    code from a file called `basetypes.cpp` with the function implemented like the
    following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行很有趣，调用了一个名为`default::int32::ToString`的静态函数。我们可以通过Step Over（*F10*）到达该行，然后Step
    Into（*F11*）。经过几次Step Into，我们最终到达了实际的函数。右键单击窗口并选择**转到源代码**，可以省略详细的汇编代码，显示名为`basetypes.cpp`的文件中实现的代码，如下所示：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All this is in a namespace called `default`. The implementation is trivial,
    using a "safe" variant on the classic `swprintf` C function before turning that
    back into a WinRT string, namely `Platform::String`. The strange `ref new` will
    be discussed in the next chapter, but it essentially means "create an instance
    of a WinRT type".
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在一个名为`default`的命名空间中。实现是微不足道的，它使用了经典的`swprintf` C函数的“安全”变体，然后将其转换回WinRT字符串，即`Platform::String`。奇怪的`ref
    new`将在下一章中讨论，但它基本上意味着“创建一个WinRT类型的实例”。
- en: Similar helpers exist throughout the C++/CX library to make using WinRT from
    C++ easier. We'll see a lot more on that in the next chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: C++/CX库中存在类似的辅助程序，使得从C++使用WinRT更容易。我们将在下一章中看到更多相关内容。
- en: Project structure
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'Let''s take a closer look at some of the files created as part of the project
    we created:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下我们创建的项目中创建的一些文件：
- en: '![Project structure](img/5022_01_10.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![项目结构](img/5022_01_10.jpg)'
- en: Most of the files are new from a C++ developer's perspective, except the files
    `pch.h` and `pch.cpp`. These files constitute the precompiled header, which means
    a header that contains seldom changed headers, so it can be compiled just once,
    saving recompilations later. In other project types, such as a regular Win32 application,
    MFC, ATL, and so on, these files were named `StdAfx.h`/`StdAfx.cpp` (which have
    no real meaning) so their names changed for the better. Their use is exactly the
    same, placement of seldom changing header files to speed up compilation times.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从C++开发人员的角度来看，大多数文件都是新的，除了`pch.h`和`pch.cpp`文件。这些文件构成了预编译头文件，这意味着它包含了很少更改的头文件，因此可以只编译一次，节省后续的重新编译。在其他项目类型中，如常规的Win32应用程序、MFC、ATL等，这些文件被命名为`StdAfx.h`/`StdAfx.cpp`（没有实际意义），因此它们的名称更改得更好。它们的用法完全相同，即将很少更改的头文件放置在一起以加快编译时间。
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to keep the precompiled header file name `pch.h`; this is because
    some of the code generated by the build processes uses this hardcoded filename.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 保持预编译头文件名为`pch.h`很重要；这是因为构建过程生成的一些代码使用了这个硬编码的文件名。
- en: '`MainPage.xaml` holds the XAML markup for the `MainPage` class. The other two
    files that complete it are the H and CPP files. Note, that the CPP file has an
    `#include` to `MainPage.xaml.h` and that file has an `#include` to `MainPage.g.h`,
    which is generated (that''s what the "g" stands for) by the XAML compiler (in
    fact, it changes as needed by editing `MainPage.xaml`, without any actual compilation).
    There we can find the declarations for the three named elements we used, without
    declaring them ourselves:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainPage.xaml`包含了`MainPage`类的XAML标记。完成它的另外两个文件是H和CPP文件。请注意，CPP文件包含对`MainPage.xaml.h`的`#include`，而该文件包含对`MainPage.g.h`的`#include`，后者是由XAML编译器生成的（这就是“g”的含义），实际上，它会根据编辑`MainPage.xaml`而随需更改，而无需进行任何实际的编译。在那里，我们可以找到我们使用的三个命名元素的声明，而无需自己声明它们：'
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`MainPage.xaml` itself indicates which class it''s related to with the `x:Class`
    attribute on its root element:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainPage.xaml`本身通过其根元素上的`x:Class`属性指示了它与哪个类相关：'
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`App.xaml` , `App.xaml.h` , and `App.xaml.cpp` have the same kind of connection
    among themselves as do the `MainPage.*` files, but their meaning is a bit different.
    `App.xaml.h` declares the single application class that provides an entry point
    for the app, as well as other services that will be discussed in later chapters.
    It may be curious as to why it has a XAML file. Could the application object have
    a UI? Not really. The XAML is there mostly to host resources, as we''ll see in
    [Chapter 3](ch03.html "Chapter 3. Building UI with XAML"), *Building UI with XAML*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.xaml`，`App.xaml.h`和`App.xaml.cpp`之间有着相同的连接方式，但它们的含义有些不同。`App.xaml.h`声明了提供应用程序入口点以及其他将在后续章节中讨论的服务的单个应用程序类。或许你会好奇为什么它有一个XAML文件。应用程序对象可以有UI吗？实际上不是。XAML主要用于托管资源，正如我们将在[第3章](ch03.html
    "第3章。使用XAML构建UI")中看到的那样，*使用XAML构建UI*。'
- en: 'The `Package.appxmanifest` file is where all the application''s metadata is
    stored. Internally it''s an XML file, but Visual Studio wraps it in a nice UI
    that is easier to use most of the time. Double-clicking the file opens Visual
    Studio''s view of the manifest:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Package.appxmanifest` 文件是存储应用程序所有元数据的地方。在内部，它是一个 XML 文件，但 Visual Studio 将其包装在一个漂亮的
    UI 中，大多数时间更容易使用。双击文件打开 Visual Studio 的清单视图：'
- en: '![Project structure](img/5022_01_11.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![项目结构](img/5022_01_11.jpg)'
- en: Here, we can set the name of the app, description, supported orientations, various
    images (such as the splash screen image), and many other (more important) settings,
    such as the capabilities required by the application. We'll discuss the various
    options in the relevant chapters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以设置应用程序的名称、描述、支持的方向、各种图像（如启动画面图像）以及许多其他（更重要的）设置，比如应用程序所需的功能。我们将在相关章节讨论各种选项。
- en: 'If a raw view of the file as XML is needed, we can right-click the file in
    the Solution Explorer, select **Open With**, and then select **XML Editor**. Here''s
    what the XML looks like for our calculator application:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要以 XML 的原始视图查看文件，我们可以在“解决方案资源管理器”中右键单击文件，选择“打开方式”，然后选择“XML 编辑器”。以下是我们计算器应用程序的
    XML 内容：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The root element is `Package`. Everything else are the settings that differ
    from the defaults. The `Capabilities` element, for example, shows the required
    capabilities needed by the app to function correctly. The only element inside
    is `internetClient`. Clicking on the **Capabilities** tab in the Visual Studio
    manifest UI shows this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 根元素是 `Package`。其他所有内容都是与默认设置不同的设置。例如，`Capabilities` 元素显示了应用程序需要的必要功能。里面唯一的元素是
    `internetClient`。在 Visual Studio 清单 UI 中点击“功能”选项卡即可查看：
- en: '![Project structure](img/5022_01_12.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![项目结构](img/5022_01_12.jpg)'
- en: The **Internet (Client)** option is checked (the only capability that is requested
    by default), meaning the app can make outbound calls to the network.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**Internet (Client)** 选项已被选中（默认请求的唯一功能），这意味着应用程序可以向网络发出呼叫。'
- en: Changing the XML affects the Visual Studio UI and vice versa. Sometimes, it
    may be more convenient to edit changes in the XML mode.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 更改 XML 会影响 Visual Studio UI，反之亦然。有时，在 XML 模式下编辑更方便。
- en: Summary
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Windows 8 Store applications are different in many ways from desktop apps. From
    the way they look, to the way they execute and, of course, the runtime they depend
    upon. The Windows Runtime provides a rich environment for creating apps that run
    on desktop and tablet platforms alike, but it is new and, thus, requires getting
    acquainted with the library and the platform as a whole.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 8 商店应用程序在许多方面与桌面应用程序不同。从外观到执行方式，当然还有它们所依赖的运行时。Windows Runtime 提供了一个丰富的环境，用于创建在桌面和平板平台上运行的应用程序，但它是新的，因此需要熟悉库和整个平台。
- en: The Windows Runtime is based on the COM programming model, making it possible
    to create projections for various languages and runtimes. Currently, C++, .NET,
    and JavaScript are supported, but more may be created in the future by Microsoft
    and/or other vendors.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Windows Runtime 基于 COM 编程模型，可以为各种语言和运行时创建投影。目前支持 C++、.NET 和 JavaScript，但未来可能会由微软和/或其他供应商创建更多。
- en: C++ developers have the most fine-grained, direct access to WinRT. The C++/CX
    extensions that we'll see in more detail in the next chapter make developing with
    C++ almost as easy as with higher-level environments, while leveraging the powerful
    capabilities of existing C++ libraries and the C++ language.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 开发人员可以最精细地直接访问 WinRT。我们将在下一章更详细地了解的 C++/CX 扩展使得使用 C++ 开发几乎和使用更高级别的环境一样简单，同时利用现有
    C++ 库和 C++ 语言的强大功能。
