["```cpp\n// promise associated with the task launched \nvoid func1(std::promise<T>& pr) \n{ \n    try \n    { \n        T val; \n        process_data(val); \n        pr.set_value(val); // Can be retrieved by future<T>::get() \n    } \n    catch(...) \n    { \n        // Can be retrieved by future<T>::get() \n        // At the future level, when we call get(), the  \n        // get will propagate the exception  \n        pr.set_exception(std::current_exception()); \n    } \n} \n```", "```cpp\n// future corresponding to task already launched \nvoid func2(std::future<T>& ft) \n{ \n    try \n    { \n        // An exception will be thrown here, if the corresponding  \n        // promise had set an exception ..otherwise, retrieve the  \n        // value sets by the promise.  \n        T result = ft.get() \n    } \n    catch(...)\n    { \n        // Handle exception  \n    } \n} \n```", "```cpp\n// Function to calculate the sum of elements in an integer vector \nint calc_sum(std::vector<int> v) \n{ \n    int sum = std::accumulate(v.begin(), v.end(), 0); \n    return sum; \n} \n\nint main() \n{ \n    // Creating a packaged_task encapsulates a function \n    std::packaged_task<int(std::vector<int>)> task(calc_sum); \n\n    // Fetch associated future from packaged_task \n    std::future<int> result = task.get_future(); \n\n    std::vector<int> nums{1,2,3,4,5,6,7,8,9,10}; \n\n    // Pass packaged_task to thread to run asynchronously \n    std::thread t(std::move(task), std::move(nums)); \n\n    t.join();\n    // Fetch the result of packaged_task, the value returned by calc_sum() \n    int sum = result.get(); \n\n    std::cout << \"Sum = \" << sum << std::endl; \n    return 0; \n}\n```", "```cpp\n    std::packaged_task<int(std::vector<int>)> task([](std::vector<int> \n    v) { \n        return std::accumulate(v.begin(), v.end(), 0); \n    }); \n```", "```cpp\n// Function to calculate the sum of elements in a vector \nint calc_sum(std::vector<int> v) \n{ \n   int sum = std::accumulate(v.begin(), v.end(), 0); \n   return sum; \n} \n\nint main() \n{ \n   std::vector<int> nums{1,2,3,4,5,6,7,8,9,10}; \n\n   // task launch using std::async \n   std::future<int> result(std::async(std::launch::async, calc_sum,    std::move(nums))); \n\n   // Fetch the result of async, the value returned by calc_sum() \n   int sum = result.get(); \n\n   std::cout << \"Sum = \" << sum << std::endl; \n   return 0; \n} \n```", "```cpp\n// Fetch associated future from async\nstd::future<int> result( async([](std::vector<int> v) {\nreturn std::accumulate(v.begin(), v.end(), 0); \n}, std::move(nums))); \n```", "```cpp\nstd::atomic_flag flg = ATOMIC_FLAG_INIT;\n```", "```cpp\nflg.clear()\nbool val = flg.test_and_set(std::memory_order_relaxed);\n```", "```cpp\nclass spin_lock\n{\n    std::atomic_flag flg;\n    public:\n    spin_lock() : flg(ATOMIC_FLAG_INIT){}\n    void lock() {\n        // simulates a lock here... and spin\n        while (flg.test_and_set(std::memory_order_acquire));\n        //----- Do some action here\n        //----- Often , the code to be guarded will be sequenced as\n        // sp.lock() ...... Action_to_Guard() .....sp.unlock()\n    }\n    void unlock() {\n        //------ End of Section to be guarded\n        flg.clear(std::memory_order_release); // release lock\n    }\n};\n```", "```cpp\nstd::atomic<bool> flg(true);\nflg = false;\n```", "```cpp\nstd::atomic<bool> flg;\nflg.store(true);\nbool val = flg.load(std::memory_order_acquire);\nval = flg.exchange(false, std::memory_order_acq_rel);\n```", "```cpp\nbool expected = false;\natomic<bool> flg;\n...\nwhile(!flg.compare_exchange_weak(expected, true));\n```", "```cpp\nbool expected;\nstd::atomic<bool> flg;\nb.compare_exchange_weak(expected, true, std::memory_order_acq_rel, std::memory_order_acquire);\nb.compare_exchange_weak(expected, true, std::memory_order_release);\n```", "```cpp\nint main() \n{ \nstd::atomic<int> value; \n\nstd::cout << \"Result returned from Operation: \" << value.fetch_add(5) << 'n'; \nstd::cout << \"Result after Operation: \" << value << 'n'; \n\nstd::cout << \"Result returned from Operation: \" << value.fetch_sub(3) << 'n'; \nstd::cout << \"Result after Operation: \" << value << 'n'; \n\nstd::cout << \"Result returned from Operation: \" << value++ << 'n'; \nstd::cout << \"Result after Operation: \" << value << 'n'; \n\nstd::cout << \"Result returned from Operation: \" << ++value << 'n'; \nstd::cout << \"Result after Operation: \" << value << 'n'; \n\nvalue += 1; \nstd::cout << \"Result after Operation: \" << value << 'n'; \n\nvalue -= 1; \nstd::cout << \"Result after Operation: \" << value << 'n'; \n} \n```", "```cpp\nResult returned from Operation: 0 \nResult after Operation: 5 \nResult returned from Operation: 5 \nResult after Operation: 2 \nResult returned from Operation: 2 \nResult after Operation: 3 \nResult returned from Operation: 4 \nResult after Operation: 4 \nResult after Operation: 5 \nResult after Operation: 4 \n```", "```cpp\nobj.fetch_add(3, std::memory_order_release);\n```", "```cpp\nstd::string result; \nstd::atomic<bool> ready(false); \n\nvoid thread1() \n{ \n    while(!ready.load(std::memory_order_seq_cst)); \n    result += \"consistency\"; \n} \n\nvoid thread2() \n{ \n    result = \"sequential \"; \n    ready=true; \n} \n\nint main() \n{ \n    std::thread t1(thread1); \n    std::thread t2(thread2); \n    t1.join(); \n    t2.join(); \n\n    std::cout << \"Result : \" << result << 'n'; \n} \n\n```", "```cpp\nResult : sequential consistency \n```", "```cpp\nclass spin_lock \n{ \n    std::atomic_flag flg; \n\npublic: \n    spin_lock() : flg(ATOMIC_FLAG_INIT) \n    {} \n\n    void lock() \n    { \n        // acquire lock and spin \n        while (flg.test_and_set(std::memory_order_acquire)); \n    } \n\n    void unlock() \n    { \n        // release lock \n        flg.clear(std::memory_order_release); \n    } \n}; \n```", "```cpp\nstd::atomic<int> count = {0}; \n\nvoid func() \n{ \n    count.fetch_add(1, std::memory_order_relaxed); \n} \n\nint main() \n{ \n    std::vector<std::thread> v; \n    for (int n = 0; n < 10; ++n) \n    { \n        v.emplace_back(func); \n    } \n    for (auto& t : v) \n    { \n        t.join(); \n    } \n\n    std::cout << \"Number of spawned threads : \" << count << 'n'; \n} \n```", "```cpp\nNumber of spawned threads : 10 \n```", "```cpp\ntemplate<typename T> \nclass Lock_free_Queue \n{ \nprivate: \n    struct Node \n    { \n        std::shared_ptr<T> my_data; \n        Node* my_next_node; \n        Node() : my_next_node(nullptr) \n        {} \n    }; \n\n    std::atomic<Node*> my_head_node; \n    std::atomic<Node*> my_tail_node; \n\n    Node* pop_head_node() \n    { \n        Node* const old_head_node = my_head_node.load(); \n        if(old_head_node == my_tail_node.load()) \n        { \n            return nullptr; \n        } \n        my_head_node.store(old_head_node->my_next_node); \n        return old_head_node; \n    } \n```", "```cpp\npublic: \nLock_free_Queue() : my_head_node(new Node), my_tail_node(my_head_node.load()) \n    {} \n    Lock_free_Queue(const Lock_free_Queue& other) = delete; \n    Lock_free_Queue& operator= (const Lock_free_Queue& other) = delete; \n\n    ~Lock_free_Queue() \n    { \n        while(Node* const old_head_node = my_head_node.load()) \n        { \n            my_head_node.store(old_head_node->my_next_node); \n            delete old_head_node; \n        } \n    }\n```", "```cpp\n    std::shared_ptr<T> dequeue() \n    { \n        Node* old_head_node = pop_head_node(); \n        if(!old_head_node) \n        { \n            return std::shared_ptr<T>(); \n        } \n        std::shared_ptr<T> const result(old_head_node->my_data); \n        delete old_head_node; \n        return result; \n    } \n\n    void enqueue(T new_value) \n    { \n        std::shared_ptr<T> new_data(std::make_shared<T>(new_value)); \n        Node* p = new Node; \n        Node* const old_tail_node = my_tail_node.load(); \n        old_tail_node->my_data.swap(new_data); \n        old_tail_node->my_next_node = p; \n        my_tail_node.store(p); \n    } \n}; \n```"]