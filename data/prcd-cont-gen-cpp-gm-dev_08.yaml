- en: Chapter 8. Procedural Behavior and Mechanics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。程序行为和机制
- en: Until now, the focus of our efforts has been the procedural creation of resources.
    Let's branch out using what we've learned and procedurally create behavior and
    game mechanics. While the creation of *procedural game behavior* may sound exotic,
    you run into it in every game that you play; **artificial intelligence** (**AI**).
    AI in games is calculating behavior at runtime based on current factors. This
    definitely counts as procedural generation! Previously, when approaching large
    topics, I've commented that a whole book could be dedicated to the subject. Well,
    with AI, you'd need an entire library. For our project, we're going to have a
    look at pathfinding; allowing enemies to intelligently chase the player around
    our levels.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的工作重点一直是资源的程序生成。让我们利用所学的知识，扩展到程序生成行为和游戏机制。虽然创建*程序生成的游戏行为*听起来很新奇，但你在玩的每个游戏中都会遇到它；**人工智能**（**AI**）。游戏中的AI是根据当前因素在运行时计算行为。这绝对算作程序生成！以前在接触大型主题时，我曾评论过整本书都可以专门讨论这个主题。嗯，对于AI，你需要整个图书馆。对于我们的项目，我们将研究寻路；让敌人能够在我们的关卡中智能地追逐玩家。
- en: Another aspect that we'll look at is the procedural generation of mechanics,
    specifically the generation of unique game goals. A great example of where this
    can be applied is game quests. How many times have you come across a quest that
    said, *Kill X of this animal and bring me Y of its fur?* Probably around a thousand!
    We can use procedural generation to add some variety here. We can generate random
    goals for each room/floor of our dungeon that aren't so static.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的另一个方面是机制的程序生成，特别是生成独特的游戏目标。一个很好的例子是游戏任务。你有多少次遇到过一个任务说，“杀死X只动物，给我Y只毛皮？”大概有一千次吧！我们可以使用程序生成在这里增加一些变化。我们可以为我们的地牢的每个房间/楼层生成随机目标，使其不那么静态。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: The A* pathfinding algorithm
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A*寻路算法
- en: Generating unique game tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成独特的游戏任务
- en: An introduction to pathfinding
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻路简介
- en: 'We''re going to start by tackling the biggest job: implementing a pathfinding
    algorithm so that the enemies can move intelligently around the map. Before we
    do so, let''s take a look at pathfinding algorithms as a whole, what they do,
    and how they do it! This context will help you make the task ahead clearer and
    show you the wealth of choices that we have.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先着手解决最大的任务：实现一种寻路算法，使敌人能够在地图周围智能移动。在这样做之前，让我们先来看看寻路算法的整体情况，它们的作用以及实现方式！这个背景将帮助你更清晰地了解前面的任务，并展示我们拥有的丰富选择。
- en: What is a pathfinding algorithm?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是寻路算法？
- en: A **pathfinding algorithm** is an algorithm that calculates the best path from
    one position to another. A good algorithm will take into account the terrain and
    several other factors to ensure that the movement is intelligent and won't result
    in any weird behavior. Remember the last time you were playing a game and an NPC
    kept walking into the wall? This is the weird behavior that pathfinding errors
    produce. Every time an enemy runs around an object to get you in a game, it's
    the result of such an algorithm, and they're essential in the creation of a gameplay
    that's challenging and which feels natural.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻路算法**是一种计算从一个位置到另一个位置的最佳路径的算法。一个好的算法会考虑地形和其他几个因素，以确保移动是智能的，不会产生任何奇怪的行为。还记得上次玩游戏时NPC一直走向墙壁的情况吗？这就是寻路错误产生的奇怪行为。每当敌人在游戏中绕着物体跑来找你时，这就是这种算法的结果，它们对于创造具有挑战性且自然的游戏玩法至关重要。'
- en: 'For example, in the following diagram, the green circle is an NPC that has
    to get the red circle:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下图中，绿色圆圈是一个NPC，它必须到达红色圆圈：
- en: '![What is a pathfinding algorithm?](img/B04920_08_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![什么是寻路算法？](img/B04920_08_01.jpg)'
- en: 'In this example, the NPC can''t go directly towards the goal point as it would
    get stuck walking into the wall. Instead, we need to take the wall into account
    and move around it, as shown in the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，NPC不能直接朝着目标点前进，因为它会被困在墙壁里。相反，我们需要考虑墙壁并绕过它，如下图所示：
- en: '![What is a pathfinding algorithm?](img/B04920_08_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![什么是寻路算法？](img/B04920_08_02.jpg)'
- en: You can see that the NPC here intelligently avoided the wall while still reaching
    the goal as efficiently as possible. This is the essence of pathfinding, and it
    is what we'll implement in our game in the first part of this chapter. Let's take
    a look at what's going on behind the arrows.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到NPC在这里聪明地避开了墙壁，同时尽可能高效地到达了目标。这就是寻路的本质，也是我们在本章的第一部分中要实现的内容。让我们来看看箭头后面发生了什么。
- en: Dijkstra's algorithm
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dijkstra算法
- en: As with anything, there are a number of ways in which pathfinding can be implemented,
    and a number of common algorithms can be used to do so. Different algorithms have
    different characteristics, and while their finished product may appear similar,
    they achieve it in different ways. The most common pathfinding algorithm in games
    is **A***, an extension of Dijkstra's algorithm.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何事物一样，寻路可以有多种实现方式，也可以使用多种常见算法来实现。不同的算法有不同的特点，虽然它们的最终产品可能看起来相似，但它们的实现方式是不同的。游戏中最常见的寻路算法是**A***，这是Dijkstra算法的扩展。
- en: Dijkstra's algorithm was created by Edsger Dijkstra in 1959\. It is a best-first
    search algorithm, that is, it visits the node with the least value first in an
    effort to produce the shortest path possible. From its starting point, it radiates
    out, checking every node in turn until it finds its goal. As you can imagine,
    this is both expensive and it can take a long time to find the end node.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法是由Edsger Dijkstra于1959年创建的。它是一种最佳优先搜索算法，即它首先访问值最小的节点，以产生可能的最短路径。从起点开始，它向外辐射，依次检查每个节点，直到找到目标。你可以想象，这既耗费资源，又可能需要很长时间才能找到终点节点。
- en: 'The following diagram shows how, to find the end node, Dijkstra''s algorithm
    has to search most of the available nodes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了Dijkstra算法在寻找终节点时需要搜索大部分可用节点：
- en: '![Dijkstra''s algorithm](img/B04920_08_03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Dijkstra算法](img/B04920_08_03.jpg)'
- en: The A* algorithm
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: A*算法
- en: A* is an extension of Dijkstra's algorithm. Its aim is to decrease the time
    it takes to find the end node by introducing a heuristic to help guide the search.
    A **heuristic** (or heuristic technique) is simply a way of approaching a problem
    using a practical method that isn't perfect, but it's sufficient. For example,
    trial and error is a fundamental heuristic. While it's not perfect, you'll reach
    the solution to a problem using trial and error.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: A*是Dijkstra算法的扩展。它的目标是通过引入启发式来帮助引导搜索来减少找到终节点所需的时间。**启发式**（或启发式技术）只是一种使用实用方法来解决问题的方法，它并不完美，但足够。例如，试错是一种基本的启发式。虽然不完美，但您将使用试错方法找到问题的解决方案。
- en: 'In terms of A*, our heuristic is taking into account the distance that has
    already been travelled to guide the search towards the end node. Take another
    look at the preceding diagram that shows Dijkstra''s algorithm. Now, look at the
    same pathfinding problem that''s solved by A* in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 就A*而言，我们的启发式正在考虑已经走过的距离，以引导搜索朝着终节点。再看一下前面显示Dijkstra算法的图表。现在，看看A*在以下图表中解决的相同路径查找问题：
- en: '![The A* algorithm](img/B04920_08_04.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![A*算法](img/B04920_08_04.jpg)'
- en: It's clear that the A* implementation tended towards the target location and
    thus found the goal node quickly. Also, look at how many nodes each algorithm
    had to look at to find the goal. Dijkstra's algorithm practically visited every
    node, while in A*, thanks to the heuristic, significantly fewer nodes were visited.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，A*实现倾向于目标位置，因此快速找到了目标节点。此外，看看每个算法必须查看多少节点才能找到目标。Dijkstra算法实际上访问了每个节点，而在A*中，由于启发式，访问的节点明显更少。
- en: A breakdown of A*
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A*的分解
- en: Before we start coding our own A* implementation, it will do us good to break
    down the algorithm into its key areas and take an isolated look at each.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写自己的A*实现之前，将算法分解为其关键领域并独立查看每个领域对我们有好处。
- en: Representing a level as nodes
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代表节点的级别
- en: Perhaps the most important area of understanding when we look at A* is how the
    algorithm will view our level. While we see tiles, the pathfinding algorithm sees
    only nodes. In this context, a node just represents a valid location that an entity
    can move to within the level.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看A*时，最重要的理解领域可能是算法将如何查看我们的级别。虽然我们看到瓦片，但路径查找算法只看到节点。在这种情况下，节点只是表示实体可以在级别内移动到的有效位置。
- en: How nodes are defined differs from game to game. For example, in our game, the
    level is already described as a 2D array of tiles. Therefore, each tile in that
    grid will act as a node. In 3D games however, we don't have this grid so navigation
    meshes are used to create a surface that can be represented as nodes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的定义因游戏而异。例如，在我们的游戏中，级别已经被描述为瓦片的2D数组。因此，网格中的每个瓦片将充当节点。然而，在3D游戏中，我们没有这个网格，因此使用导航网格来创建可以表示为节点的表面。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Valve has a great article on their developer wiki page regarding navigation
    meshes. So head to [https://developer.valvesoftware.com/wiki/Navigation_Meshes](https://developer.valvesoftware.com/wiki/Navigation_Meshes)
    if you want to learn more about this subject.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Valve在其开发者维基页面上有一篇关于导航网格的很棒的文章。因此，如果您想了解更多有关此主题的信息，请访问[https://developer.valvesoftware.com/wiki/Navigation_Meshes](https://developer.valvesoftware.com/wiki/Navigation_Meshes)。
- en: The following image shows how the level is split into the 2D array of tiles
    that it is at heart. Each of these tiles will be used as a node in the A* algorithm.
    The tiles that are valid locations for players to move to (floor tiles) are marked
    in green, and the tiles that should be avoided (walls, obstacles, and so on) are
    marked in orange.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了级别如何分割为其核心的2D瓦片数组。这些瓦片中的每一个将在A*算法中用作节点。玩家可以移动到的有效位置（地板瓦片）用绿色标记，应该避免的瓦片（墙壁、障碍等）用橙色标记。
- en: The resulting green is the valid region of nodes that the algorithm will try
    and find a path through.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 结果绿色是算法将尝试并找到路径的有效节点区域。
- en: '![Representing a level as nodes](img/B04920_08_05.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![代表节点的级别](img/B04920_08_05.jpg)'
- en: The open and closed list
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放和关闭列表
- en: 'Once the nodes have been identified, they are stored into the following two
    lists:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦节点被识别，它们将存储到以下两个列表中：
- en: '**The open list**: This list contains all the nodes that are waiting to be
    the subject of the algorithm. This will make more sense when we get into some
    code, but the algorithm operates on one node a time, and the open list is the
    queue for this.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开放列表**：此列表包含所有等待成为算法主题的节点。当我们进入一些代码时，这将更有意义，但算法一次操作一个节点，开放列表是此队列。'
- en: '**The closed list**: This list simply contains all the nodes that have already
    been through the algorithm. Once a node gets added to this list, it''s ignored
    until the algorithm is complete.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭列表**：此列表只包含已经通过算法的所有节点。一旦节点被添加到此列表中，它将被忽略，直到算法完成。'
- en: The H, G, and F costs
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: H、G和F的成本
- en: 'When reading about the A* pathfinding algorithm, there are 3 letters that you''re
    going to come across: H, G, and F. These are crucial values in the algorithm,
    but they aren''t very descriptive. So let''s take a moment to look at what each
    value is and the role that it plays in calculating a path.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读A*路径查找算法时，您将遇到3个字母：H、G和F。这些是算法中至关重要的值，但它们并不是非常描述性的。因此，让我们花一点时间看看每个值是什么以及它在计算路径中扮演的角色。
- en: The H value
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: H值
- en: The H value, often referred to as the heuristic, is the estimated cost to reach
    the goal node from the current position. Every node in the level has an H value,
    which is calculated at the start of the pathfinding algorithm, and then used in
    later calculations. This value helps guide the search towards the target node
    instead of equally spreading out in all directions. How this value is calculated
    is up to the specific implementation, but a common method is called the **Manhattan
    distance**. We'll cover what this exactly is shortly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: H值，通常称为启发式，是从当前位置到目标节点的估计成本。级别中的每个节点都有一个H值，在路径规划算法开始时计算，然后在后续计算中使用。这个值有助于引导搜索朝着目标节点，而不是在所有方向上均匀分布。如何计算这个值取决于具体的实现方式，但一个常见的方法被称为**曼哈顿距离**。我们很快会介绍这到底是什么。
- en: The G value
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: G值
- en: The G value is the current movement cost from the start node to this node. The
    way this is calculated is again implementation-specific. However, as with the
    H value, a common method and the one that we'll be using is the Manhattan distance.
    As the algorithm iterates, every time a link between two nodes is made, the movement
    cost of that individual movement is added to that of the entire path so far. In
    this way, as the paths build, each node knows how long the entire path before
    it is.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: G值是从起始节点到当前节点的当前移动成本。这是根据具体实现方式计算的。然而，与H值一样，常见的方法是曼哈顿距离，我们将使用这种方法。算法迭代时，每次建立两个节点之间的连接时，该单独移动的移动成本将被添加到迄今为止整个路径的移动成本中。这样，随着路径的建立，每个节点都知道它之前的整个路径有多长。
- en: The F value
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: F值
- en: The F value is simply the sum of the H and G values. This value is used to determine
    which node the algorithm uses next. The lower this value, the lower the estimated
    complete path is. Thus, the algorithm prioritizes these nodes. This behavior is
    what makes Dijkstra's algorithm, and therefore A*, a best-first search algorithm.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: F值只是H值和G值的总和。这个值用于确定算法下一个使用的节点。这个值越低，完整路径的估计值就越低。因此，算法优先考虑这些节点。这种行为是使Dijkstra算法，因此A*算法成为最佳优先搜索算法的原因。
- en: The Manhattan distance
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 曼哈顿距离
- en: At the heart of a pathfinding algorithm lies calculating the distance between
    two points. As mentioned previously, exactly how this is done is implementation-specific,
    but there is a common and cheap method known as Manhattan distance (also known
    as taxicab geometry), which is what we'll be using.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 路径规划算法的核心是计算两点之间的距离。如前所述，这是根据具体的实现方式来完成的，但有一种常见且廉价的方法称为曼哈顿距离（也称为出租车几何），这是我们将要使用的方法。
- en: It's formally defined as the distance between two points calculated by taking
    the sum of the absolute difference of their Cartesian coordinates.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它正式定义为通过取它们的笛卡尔坐标的绝对差的和来计算两点之间的距离。
- en: That's quite a mouthful, but it's actually pretty simple. Cartesian coordinates
    are simply a way of expressing a position relative to two fixed perpendicular
    axes (even if this seems unfamiliar, we've all covered this at school), and absolute
    simply means that we ignore the sign of a number.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来有点复杂，但实际上很简单。笛卡尔坐标只是一种相对于两个固定的垂直轴的位置的表示方式（即使这似乎不熟悉，我们在学校都学过），而绝对值只是表示我们忽略一个数字的符号。
- en: 'Take a look at the following graph:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图表：
- en: '![The Manhattan distance](img/B04920_08_06.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![曼哈顿距离](img/B04920_08_06.jpg)'
- en: 'We have two points on the graph: **A(-4,4)** and **B(5,-3)**. The following
    pseudocode calculates the Manhattan distance between the two:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在图表上有两个点：**A(-4,4)**和**B(5,-3)**。以下伪代码计算了两者之间的曼哈顿距离：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's as simple as that!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单！
- en: Parenting nodes
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点的父节点
- en: Another crucial aspect of pathfinding is the idea of parenting nodes. A* works
    by building up a chain of nodes. Once the goal node is found, we work back through
    this chain to get the final path. When the shortest path between two nodes is
    identified, node A will be assigned as the parent of node B.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 路径规划的另一个关键方面是节点的父节点概念。A*算法通过建立节点链来工作。一旦找到目标节点，我们就会沿着这条链返回，得到最终路径。当确定两个节点之间的最短路径时，节点A将被分配为节点B的父节点。
- en: 'For example, the following screenshot shows a situation where the skeleton
    enemy has found a valid path to the player:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下截图显示了骷髅敌人找到了通往玩家的有效路径的情况：
- en: '![Parenting nodes](img/B04920_08_07.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![节点的父节点](img/B04920_08_07.jpg)'
- en: Let's imagine a situation where a path between two nodes is found. For example,
    the path between nodes **6** and **7**. Then, the first node is set as the parent
    of the second node, in this case, node **6** is set as the parent of node **7**.
    In this way, each node knows where it came from. When the algorithm finds the
    goal node (in our example, it's node **2**), we can use this parent hierarchy
    to work our way from the goal node to the start node, giving us the final shortest
    path. In this case, the shortest path between the skeleton and the player is **6**,
    **7**, **5**, **2**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一种情况，找到两个节点之间的路径。例如，节点**6**和**7**之间的路径。然后，将第一个节点设置为第二个节点的父节点，在这种情况下，节点**6**被设置为节点**7**的父节点。这样，每个节点都知道它来自哪里。当算法找到目标节点时（在我们的例子中，是节点**2**），我们可以使用这个父节点层次结构从目标节点向起始节点工作，得到最终的最短路径。在这种情况下，骷髅和玩家之间的最短路径是**6**，**7**，**5**，**2**。
- en: The pseudo-algorithm
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪算法
- en: 'To wrap up the breakdown of the algorithm, let''s look at a pseudo-implementation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 总结算法的分解，让我们看一个伪代码实现：
- en: Compute the H values beforehand, if possible.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可能的话，预先计算H值。
- en: Add the start node to the open list.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将起始节点添加到开放列表中。
- en: Find the node with the lowest F value in the open list.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开放列表中找到具有最低F值的节点。
- en: Remove that node from the open list and add it to the closed list.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从开放列表中删除该节点，并将其添加到关闭列表中。
- en: 'For all adjacent nodes, perform the following steps:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于所有相邻的节点，执行以下步骤：
- en: If the node is the goal node, set its parent to the current node and store the
    final path.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果节点是目标节点，则将其父节点设置为当前节点并存储最终路径。
- en: If the node is in the closed list, ignore it and go to step 3.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果节点在关闭列表中，则忽略它并转到步骤3。
- en: If the node is not in the closed list and the open list, set its parent to the
    current node and calculate its G and F value.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果节点不在关闭列表和开放列表中，则将其父节点设置为当前节点，并计算其G和F值。
- en: If the node is not in the closed list but is in the open list, check whether
    the path between it and the current node is quicker than its current path.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果节点不在关闭列表中，但在开放列表中，则检查它与当前节点之间的路径是否比当前路径更快。
- en: This is a simplified look at the A* algorithm. Hopefully, this breakdown has
    given context to some of these steps. Let's get it coded!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是A*算法的简化版本。希望这个分解给一些步骤提供了上下文。让我们开始编码吧！
- en: Coding the A* pathfinding algorithm
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写A*寻路算法
- en: With an understanding of the fundamentals of A*, let's start implementing it
    in our game. This will allow the enemies to follow our player around the level
    regardless of its topology.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对A*的基本原理的理解，让我们开始在游戏中实现它。这将允许敌人在级别中跟随我们的玩家，而不受其拓扑结构的影响。
- en: 'With a complex algorithm such as this, having a visual representation of what''s
    happening is really helpful. Wherever it''s appropriate, we will take a look at
    a visual representation of what''s happening using the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个复杂的算法，有一个视觉表示发生了什么是非常有帮助的。在适当的地方，我们将看一下使用以下示例发生了什么的视觉表示：
- en: '![Coding the A* pathfinding algorithm](img/B04920_08_08.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![编写A*寻路算法](img/B04920_08_08.jpg)'
- en: The Tile datatype
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 瓦片数据类型
- en: 'Let''s start by taking a quick look at the `Tile` struct that was defined in
    `Level.h`. As we''ve seen, a node contains quite a few values. In the implementation,
    it''s the level tiles that will act as nodes. As such, all the information that''s
    required by a node is defined in its type:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先快速看一下在`Level.h`中定义的`Tile`结构。正如我们所见，一个节点包含了相当多的值。在实现中，级别瓦片将充当节点。因此，节点所需的所有信息都在其类型中定义：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the rest of the chapter, a node is synonymous with a tile. So don't worry
    if they're used interchangeably. However, remember that this will not be the case
    in every A* implementation, as what you use as nodes will depend on the game.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，节点与瓦片是同义词。因此，如果它们可以互换使用，不用担心。但是，请记住，在每个A*实现中，节点的使用将取决于游戏。
- en: Creating supporting functions
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建支持函数
- en: Before we implement the algorithm itself, we need to create some supporting
    functions and variables that the algorithm will require. Note that these are specific
    to the implementation and are not a part of the A* algorithm.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现算法本身之前，我们需要创建一些支持算法所需的函数和变量。请注意，这些是特定于实现的，并不是A*算法的一部分。
- en: The Level class
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Level类
- en: The first class that we need to do some groundwork in is the `Level` class.
    We're going to need a function that resets all the variables in the nodes/tiles,
    as we need these values to be reset back to their defaults every time we run the
    algorithm.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做一些基础工作的第一个类是`Level`类。我们需要一个函数来重置节点/瓦片中的所有变量，因为我们需要这些值在每次运行算法时都重置回它们的默认值。
- en: 'Add the following function declaration to `Level.h`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Level.h`中添加以下函数声明：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Also, add the following definition in `Level.cpp`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 还要在`Level.cpp`中添加以下定义：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see that all that we're doing here is iterating over each tile in the
    level grid and resetting all the variables that we'll use in the A* calculations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们在这里所做的一切都是迭代级别网格中的每个瓦片，并重置我们将在A*计算中使用的所有变量。
- en: The Enemy class
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 敌人类
- en: 'Next, we need to create a function that will run the algorithm in the `Enemy`
    class. Add the following function declaration in `Enemy.h`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`Enemy`类中创建一个运行算法的函数。在`Enemy.h`中添加以下函数声明：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see that this function takes a reference to the level, the main player
    position, and is public. We need the function to be public so that we can call
    it from the main game class. This is for efficiency and it will become clearer
    why later. We will pass a reference to the level object, as the enemy will need
    to access the level information, and the player location is needed to calculate
    the target position.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这个函数接受对级别的引用，主要玩家位置，并且是公共的。我们需要这个函数是公共的，这样我们才能从主游戏类中调用它。这是为了效率，稍后会更清楚为什么。我们将传递对级别对象的引用，因为敌人将需要访问级别信息，并且需要计算目标位置的玩家位置。
- en: 'We also need to add the following variables in `Enemy.h`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`Enemy.h`中添加以下变量：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With this work done, we can add the empty function definition for `Enemy::UpdatePathFinding`
    in `Enemy.cpp`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这项工作后，我们可以在`Enemy.cpp`中为`Enemy::UpdatePathFinding`添加空的函数定义：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All code from this point onwards will be appended to this function. There's
    quite a bit to it!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，所有的代码都将附加到这个函数中。有相当多的内容！
- en: Variable declarations
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量声明
- en: 'The first step in the function is going to be the declarations of all the variables
    that we''ll use:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的第一步将是声明我们将使用的所有变量：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `openList` and `closedList` variables are used to manage the nodes. Nodes
    in the `openList` variable are waiting to be checked, and nodes in the `closedList`
    variable have already been checked and should be ignored from now on. This will
    be explained in detail when we come across them in the implementation. The `pathList`
    variable will store all the nodes in the final path.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`openList`和`closedList`变量用于管理节点。`openList`变量中的节点正在等待检查，`closedList`变量中的节点已经被检查，从现在开始应该被忽略。当我们在实现中遇到它们时，将会详细解释。`pathList`变量将存储最终路径中的所有节点。'
- en: The position variable is an iterator that will be used to find and remove values
    from our vectors. Finally, the `currentNode` variable is used to keep track of
    the node that we're currently working with.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 位置变量是一个迭代器，将用于查找和删除我们的向量中的值。最后，`currentNode`变量用于跟踪我们当前正在处理的节点。
- en: 'The next step is to reset all the nodes. Every time we run the function, we
    need the nodes to have their default values. To achieve this we''ll make a call
    to the `Level::ResetNodes` function that we just created, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是重置所有节点。每次运行函数时，我们需要节点具有它们的默认值。为了实现这一点，我们将调用刚刚创建的`Level::ResetNodes`函数，如下所示：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The final step in the setup will be to identify the start and end nodes, marking
    the start and end of the path that we''re looking for. The start node is going
    to be the position of the enemy. The end node, which is our goal, is the position
    of the player:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 设置的最后一步将是识别起点和终点节点，标记我们正在寻找的路径的起点和终点。起始节点将是敌人的位置。终点节点，也就是我们的目标，是玩家的位置：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Level::GetTile` function returns the tile at a given location, so we can
    use this to get the nodes. Once we''ve identified these, we''re going to perform
    a quick check to ensure that they are not the same nodes. If they are, there is
    no valid path between them and we can simply clear the current path and exit the
    function, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Level::GetTile`函数返回给定位置的瓦片，因此我们可以使用它来获取节点。一旦我们确定了这些节点，我们将进行快速检查，以确保它们不是相同的节点。如果是，它们之间就没有有效的路径，我们可以简单地清除当前路径并退出函数，如下所示：'
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this point, we have declared all the variables that we'll be using, reset
    all the nodes to their default values, and identified that we're working with
    a valid path. It's time to jump into the bulk of the algorithm!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经声明了将要使用的所有变量，重置了所有节点的默认值，并确定了我们正在处理有效路径。是时候进入算法的主体部分了！
- en: Precalculating the H values
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预先计算H值
- en: The next step in our A* algorithm implementation is to calculate the H value
    for every node in the level. Remember that the H value is the estimated cost of
    the path from the start node to the goal node.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们A*算法实现的下一步是计算级别中每个节点的H值。请记住，H值是从起始节点到目标节点的路径的估计成本。
- en: 'We''re going to use the Manhattan distance for this. So, for every tile in
    the level, we need to calculate this distance to the goal node, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用曼哈顿距离。因此，对于级别中的每个瓦片，我们需要计算到目标节点的距离，如下所示：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Defining the main loop
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义主循环
- en: 'We''re now going to define the main loop in which the algorithm actually takes
    place, but before we do so, we need to quickly add the start node to the list
    of open nodes, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将定义算法实际发生的主循环，但在这样做之前，我们需要快速将起始节点添加到开放节点列表中，如下所示：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The open list is a list of all the nodes that the algorithm has left to check.
    While this list has values in it, the algorithm should run. Therefore, we''ll
    define this behavior to create the main loop, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 开放列表是算法留下的所有节点的列表。只要此列表中有值，算法就应该运行。因此，我们将定义此行为以创建主循环，如下所示：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next step in the algorithm is to decide which node we''re going to operate
    on next. You may remember that the F value is used for this purpose. The open
    list contains all the nodes that are waiting to be checked. So we need to iterate
    over this vector and find the node with the lowest F (the estimated cost of the
    complete path) value:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的下一步是决定我们将在下一个操作的节点。您可能记得F值用于此目的。开放列表包含所有等待检查的节点。因此，我们需要遍历这个向量并找到具有最低F值（完整路径的估计成本）的节点：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code is pretty straightforward. We initially set `lowestF` to `INT_MAX`,
    a macro that contains the maximum value of an `int`, as we can be sure that no
    F value will come anywhere near that. When we identify a node with a smaller F
    value, we update the `lowestF` value and mark that node as the node that needs
    to be operated on next.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码非常简单。我们最初将`lowestF`设置为`INT_MAX`，这是一个包含`int`的最大值的宏，因为我们可以确保没有任何F值会接近那个值。当我们确定具有较小F值的节点时，我们更新`lowestF`值，并标记该节点为下一个需要操作的节点。
- en: 'Once we have identified the node with the lowest F value, we remove it from
    `openList` and add it to the `closedList` vector to ensure that we don''t operate
    on the same node again, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了具有最低F值的节点，我们就将其从`openList`中删除，并将其添加到`closedList`向量中，以确保我们不会再次操作相同的节点，如下所示：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is where the iterator variable comes into play. An iterator is simply an
    object with the ability to iterate through a range of elements. To remove an item
    from a vector, we make a call to `std::find()`, passing the start of the vector,
    the end, and the value that we are looking for. If the value is found, `std::find()`
    will return an iterator to that element. If the value is not found, it returns
    an iterator that refers to an imaginary element, which will follow the last element
    in the vector. Then, we call erase in `openList`, passing this iterator value
    to get to the right element.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是迭代器变量发挥作用的地方。迭代器只是具有迭代一系列元素的能力的对象。要从向量中删除项目，我们调用`std::find()`，传递向量的开始、结束和我们要查找的值。如果找到该值，`std::find()`将返回指向该元素的迭代器。如果未找到该值，它将返回一个指向虚构元素的迭代器，该元素将跟随向量中的最后一个元素。然后，我们在`openList`中调用erase，传递此迭代器值以找到正确的元素。
- en: Finding the adjacent nodes
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找相邻节点
- en: Now that the next node is selected and assigned to the `currentNode` variable,
    it's time to identify all the adjacent nodes. This is another area that will differ
    depending on each specific implementation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选择了下一个节点并将其分配给`currentNode`变量后，是时候识别所有相邻节点了。这是另一个将根据每个特定实现而有所不同的领域。
- en: 'In our case, the level is defined as a 2D grid. Therefore, it''s easy for us
    to get the surrounding nodes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，级别被定义为2D网格。因此，很容易获取周围的节点：
- en: '![Finding the adjacent nodes](img/B04920_08_09.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![查找相邻节点](img/B04920_08_09.jpg)'
- en: You can see from the preceding diagram how the column and row indices, `i` and
    `j` respectively, range from -1 to 1 surrounding the middle tile. We can use this
    to get the nodes around us that we want to check. We're only interested in valid
    floor nodes, so while we're fetching them, we can perform these checks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从前面的图表中看到，列和行索引`i`和`j`分别从-1到1，围绕中间的瓷砖。我们可以利用这一点来获取我们想要检查的周围节点。我们只对有效的地板节点感兴趣，所以在获取它们时，我们可以执行这些检查。
- en: 'Let''s implement this in the function, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在函数中实现这一点，如下所示：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this code, we got the 4 nodes around us, ensuring that they''re both valid
    and are floor tiles. Only then are they added to the list of adjacent nodes that
    need to be checked. With these identified, we now need to loop over each node.
    A `for` loop will allow us to do this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们得到了周围的4个节点，确保它们都是有效的地板砖。只有在这种情况下，它们才会被添加到需要检查的相邻节点列表中。有了这些确定的节点，现在我们需要循环遍历每个节点。`for`循环将允许我们这样做：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The algorithm is over when we reach the goal node. Therefore, every time we
    select an adjacent node, we can check whether we''ve done so. With the goal node
    stored in a variable, this is a simple check:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达目标节点时，算法结束。因此，每次选择相邻节点时，我们都可以检查是否已经到达目标节点。有了目标节点存储在一个变量中，这是一个简单的检查：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since we select nodes by the lowest F value, the first time we reach the goal
    node, we know that we will have travelled the shortest possible path. Before we
    move on to finding this path, we first need to make the parent of the goal node
    the current node:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们通过最低的F值选择节点，第一次到达目标节点时，我们知道我们已经走过了最短的可能路径。在继续寻找这条路径之前，我们首先需要将目标节点的父节点设置为当前节点：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next we have to construct a list of all the nodes that made up the path, from
    the start node to the goal node. There is no set way to do this, but we''ll use
    a `while` statement. While the node has a parent, add the node to the list and
    then set the node to its parent. Let''s add the code for this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要构建一个包含从起始节点到目标节点的所有节点的列表。没有固定的方法来做这个，但我们将使用`while`语句。当节点有父节点时，将节点添加到列表中，然后将节点设置为其父节点。让我们为此添加代码：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this way, we build a complete path from the goal node to the start node.
    Note that the resulting path is backwards, but we'll sort this out later!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们从目标节点到起始节点构建了一个完整的路径。请注意，结果路径是反向的，但我们稍后会解决这个问题！
- en: 'Now, the final step is to exit the main loop. We''re currently nested within
    a `while` loop and a `for` loop. To exit this, we need to empty the open list
    and call `break`. The `break` component kicks us out of the `for` loop, and with
    the open list now empty, we exit the `while` loop too:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后一步是退出主循环。我们目前嵌套在一个`while`循环和一个`for`循环中。为了退出这个循环，我们需要清空开放列表并调用`break`。`break`组件将我们从`for`循环中踢出来，现在开放列表为空，我们也退出了`while`循环：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that this is done, we have found the goal node, stored the path of nodes
    from the start to the goal, and exited the main loop. This was all the result
    of finding the goal node. We now need to turn our attention to the case where
    we didn't find the goal node.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这一切都完成了，我们已经找到了目标节点，存储了从起点到目标的节点路径，并退出了主循环。这一切都是找到目标节点的结果。现在我们需要把注意力转向我们没有找到目标节点的情况。
- en: Calculating the G and F costs
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算G和F成本
- en: 'If a node is in the closed list then it''s already been the subject of the
    algorithm. All the adjacent nodes have been checked and had their G and F values
    calculated. If this is the case, we can simply ignore the node:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个节点在关闭列表中，那么它已经成为算法的主题。所有相邻节点都已经被检查并计算了它们的G和F值。如果是这种情况，我们可以简单地忽略这个节点：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After insuring that the node is not in the closed list, we next check the open
    list:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 确保节点不在关闭列表中后，我们接下来检查开放列表：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Unlike the previous check, if our node is in the open list, we do not ignore
    it. If the node is not in the open list, then it''s the first time that the algorithm
    has encountered it. If this is the case, we need to perform the following actions:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的检查不同，如果我们的节点在开放列表中，我们不会忽略它。如果节点不在开放列表中，那么这是算法第一次遇到它。如果是这种情况，我们需要执行以下操作：
- en: Add the node to the open list.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将节点添加到开放列表中。
- en: Set `parent` to `currentNode` (it's the last node when checking the F values).
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`parent`设置为`currentNode`（在检查F值时，它是最后一个节点）。
- en: Calculate its G value.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算它的G值。
- en: Calculate its F value.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算它的F值。
- en: 'We''ll start by adding it to the open list and setting its parent node; these
    are quick and easy tasks:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将其添加到开放列表中并设置其父节点；这些都是快速简单的任务：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Calculating the G and F cost
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算G和F成本
- en: You may remember that the G cost is the total cost of movement from the start
    node to this node. In our grid, we can move in all the four directions, we don't
    move diagonally, so each movement costs `10`. This value is specific to the implementation
    and not the algorithm. It's the cost of movement between two nodes, and `10` is
    simply a nice value to work with.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得G成本是从起始节点到该节点的移动总成本。在我们的网格中，我们可以朝四个方向移动，不会对角线移动，所以每次移动成本为`10`。这个值是特定于实现而不是算法。这是两个节点之间移动的成本，`10`只是一个很好的数值。
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We are not using diagonals only for the sake of an easier presentation. One
    of the exercises at the end of the chapter is to add diagonal movement and I highly
    suggest that you give it a go!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以不使用对角线，只是为了更容易地进行演示。本章末尾的一个练习是添加对角线移动，我强烈建议您尝试一下！
- en: 'Since we know that the movement cost between the nodes is `10`, we now need
    to add the G cost of `currenNode` to it to arrive at the final value. The G cost
    of `currentNode` is the cost of that path far, so adding the last movement cost
    to it gives the new node the total cost of the path from the start node to itself:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道节点之间的移动成本是`10`，现在我们需要将`currentNode`的G成本加到其中以得到最终值。`currentNode`的G成本是到目前为止的路径成本，所以将最后的移动成本加到其中，新节点就得到了从起始节点到自身的路径总成本：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we need to calculate the F cost of the node, which is simply the sum
    of its G and H costs. We just calculated the G cost, and we precalculated the
    H costs at the start of the algorithm. All that is needed is a simple addition:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要计算节点的F成本，这只是它的G和H成本的总和。我们刚刚计算了G成本，并且在算法开始时预先计算了H成本。所需的只是一个简单的加法：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Checking for superior paths
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查更优越的路径
- en: The final step of the algorithm is the condition where we check whether the
    node is already in the open list, and it is. If this is the case, we've already
    generated its G and F values. We now however need to check whether they are the
    lowest possible values.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的最后一步是检查节点是否已经在开放列表中，如果是的话，我们已经生成了它的G和F值。然而，现在我们需要检查它们是否是最低可能的值。
- en: 'In the following image, node **7** is the parent to node **8**, and node **8**
    is the parent to node **5**:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，节点**7**是节点**8**的父节点，节点**8**是节点**5**的父节点：
- en: '![Checking for superior paths](img/B04920_08_10.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![检查更优越的路径](img/B04920_08_10.jpg)'
- en: This has resulted in a movement cost of `30` from node **7** – **8** – **5**.
    However, this is not the shortest path. The movement cost from **7** to **5**,
    assuming that we allowed diagonal movement, is `14`. If we drop **8** from the
    path, the total movement cost is `24`, which is lower than its current value of
    30\. When this is the case, we make 7 the parent of **5** instead of **8**. Since
    we don't use diagonal movements, this exact example won't apply unless you add
    them yourself.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了从节点**7**到**8**到**5**的移动成本为`30`。然而，这并不是最短的路径。从**7**到**5**的移动成本，假设我们允许对角线移动，是`14`。如果我们从路径中去掉**8**，总移动成本就是`24`，低于当前的30。在这种情况下，我们将**7**作为**5**的父节点，而不是**8**。由于我们不使用对角线移动，这个例子不适用，除非你自己添加对角线移动。
- en: 'Hopefully however, it demonstrates that we''re looking for superior paths as
    shown the following image:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这能展示出我们正在寻找更优越的路径，如下图所示：
- en: '![Checking for superior paths](img/B04920_08_11.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![检查更优越的路径](img/B04920_08_11.jpg)'
- en: We can see here that the movement cost of node **5** is lower and it is parented
    to **7**. This has created a diagonal path that is shorter than the previous one.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，节点**5**的移动成本更低，它是**7**的父节点。这创建了一个比之前更短的对角线路径。
- en: 'Let''s append some code to the function to include this behavior:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在函数中添加一些代码来包含这个行为：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Creating the final path
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建最终路径
- en: 'The final part of the A* implementation is to turn the list of nodes into a
    valid path that the enemy can follow. In the work that we did to prepare for the
    A* implementation, we added the following variable to the `Enemy` class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: A*算法的最后一部分是将节点列表转换为敌人可以跟随的有效路径。在为A*算法做准备的工作中，我们向`Enemy`类添加了以下变量：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This vector is going to hold a list of target locations that we''ll get from
    the nodes in the final path. However, before we do so, we need to ensure that
    we clear it. This is done so that every time the pathfinding algorithm is run,
    the player has a fresh set of coordinates to move to. Let''s clear the vector.
    Again, this code is just appended to the `Enemy::UpdatePathFinding` function,
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个向量将保存一个目标位置列表，我们将从最终路径的节点中获取。然而，在这之前，我们需要确保清空它。这样做是为了确保每次运行寻路算法时，玩家都有一组新的坐标移动到。让我们清空这个向量。同样，这段代码只是追加到`Enemy::UpdatePathFinding`函数中，如下所示：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, to convert the tiles into target locations we will iterate over the vector
    of the final nodes, get their actual positions, and add them to the `m_targetPositions`
    vector, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了将瓦片转换为目标位置，我们将遍历最终节点的向量，获取它们的实际位置，并将它们添加到`m_targetPositions`向量中，如下所示：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There''s one last thing that we need to do and which is easy to overlook. When
    we find the goal node and create the final path list, we store them from the goal
    node back to the start node. This means that the final path is backwards. The
    final step in the `Enemy::UpdatePathFinding` function is to reverse the `m_targetPositions`
    vector to correct this and add the final closing brackets:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要做最后一件事，这很容易被忽视。当我们找到目标节点并创建最终路径列表时，我们将它们从目标节点存储回起始节点。这意味着最终路径是反向的。`Enemy::UpdatePathFinding`函数的最后一步是将`m_targetPositions`向量反转以纠正这个问题，并添加最终的闭合括号：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That's it! We're done. The A* algorithm is complete. The base enemy class has
    a function that will create a vector of target locations and take the enemy to
    the player in the quickest path possible. The next step is to enable the enemy
    to follow this path!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们完成了。A*算法已经完成。基础敌人类有一个函数，可以创建一个目标位置的向量，并以最快的路径将敌人带到玩家那里。下一步是使敌人能够跟随这条路径！
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to explore pathfinding further, head over to [https://qiao.github.io/PathFinding.js/visual/](https://qiao.github.io/PathFinding.js/visual/).
    It's a fantastic app that visualizes a range of popular pathfinding algorithms.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步探索寻路，可以前往[https://qiao.github.io/PathFinding.js/visual/](https://qiao.github.io/PathFinding.js/visual/)。这是一个很棒的应用，可以可视化一系列流行的寻路算法。
- en: Implementing A* in the game
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在游戏中实现A*
- en: Now that we have the function that can calculate the shortest path, we need
    to incorporate this behavior into the game.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可以计算最短路径的函数，我们需要将这个行为整合到游戏中。
- en: Enabling the enemy to follow a path
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使敌人能够跟随路径
- en: We now need to make the enemies follow the vector of target locations that the
    pathfinding algorithm generates. We need the enemy to constantly follow this path,
    so we'll override its base classes' `Update` function, as it's called during every
    game's tick. The code that will do this is fairly simple; if there is a location
    in the vector, move towards it at a fixed pace. When the position is reached,
    we simply remove it from the vector. When the vector is empty, we know that the
    enemy has reached its goal.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要让敌人按照寻路算法生成的目标位置向量进行移动。我们需要敌人不断地跟随这条路径，所以我们将重写它的基类`Update`函数，因为它在每个游戏的tick期间被调用。这将会是相当简单的代码；如果向量中有位置，就以固定的速度朝着它移动。当到达位置时，我们就从向量中移除它。当向量为空时，我们就知道敌人已经到达目的地。
- en: 'We''ll start by adding the function declaration to `Enemy.h`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在`Enemy.h`中添加函数声明开始：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we can add the code to follow the path. Like we just said, if there is a
    value in the vector of the target positions, move towards it at a fixed pace.
    We do this by creating and normalizing a movement vector.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加代码来跟随路径。就像我们刚才说的，如果目标位置的向量中有值，就以固定的速度朝向它移动。我们通过创建和标准化移动向量来实现这一点。
- en: Tip
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We won't cover the mathematics behind this movement. So, if you want to read
    more about it, check out [http://www.fundza.com/vectors/normalize/](http://www.fundza.com/vectors/normalize/)
    for an overview.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会涵盖这种移动背后的数学原理。所以，如果你想了解更多，请查看[http://www.fundza.com/vectors/normalize/](http://www.fundza.com/vectors/normalize/)以获取概述。
- en: 'The following code is used for the creation and normalization of a movement
    vector:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于创建和标准化移动向量：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can also see that at the end of the function we call `Entity::Update`. The
    animation code lies in this function. We need to ensure that it still gets called!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到在函数的最后我们调用了`Entity::Update`。动画代码就在这个函数中。我们需要确保它仍然被调用！
- en: Calling the pathfinding behavior
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用寻路行为
- en: The final step in incorporating pathfinding into the game is to call the `Enemy::UpdatePathFinding`
    function when we want to generate a new path. The enemies are updated with each
    game update, but we don't want to update the path that frequently.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将寻路整合到游戏中的最后一步是在我们想要生成新路径时调用`Enemy::UpdatePathFinding`函数。敌人在每次游戏更新时都会更新，但我们不希望那么频繁地更新路径。
- en: 'Although A* is an efficient algorithm, we still want to call it as seldom as
    possible. The path will only change when the player moves to a new tile, so there''s
    no point in updating the pathfinding until this happens. In order to achieve this,
    we need to be able to tell which tile the player was on during the last update,
    and which tile the player is on this update. Let''s add the following variable
    to `Game.h` and ensure that we give it a default value in the class initializer:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管A*是一个高效的算法，但我们仍然希望尽可能少地调用它。路径只有在玩家移动到新的瓷砖时才会改变，所以在此之前更新寻路是没有意义的。为了实现这一点，我们需要能够告诉上次更新时玩家所在的瓷砖，以及本次更新时玩家所在的瓷砖。让我们在`Game.h`中添加以下变量，并确保在类初始化器中给它一个默认值：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `Game::Update` function, we can now check whether the player has moved
    to a tile, and if that''s the case, call the `Enemy::UpdatePathFinding` function
    of all the enemies in the level, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Game::Update`函数中，我们现在可以检查玩家是否移动到了一个瓷砖上，如果是这样，就调用关卡中所有敌人的`Enemy::UpdatePathFinding`函数，如下所示：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'That''s it! We can now test the game. We should see the enemies following us
    around the level instead of standing like stationary objects as shown in the following
    screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们现在可以测试游戏了。我们应该看到敌人在关卡中跟随我们，而不是像静止的物体一样站着，如下面的截图所示：
- en: '![Calling the pathfinding behavior](img/B04920_08_12.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![调用寻路行为](img/B04920_08_12.jpg)'
- en: Viewing our path
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看我们的路径
- en: We have the code working, which is great, but let's add some debug code so that
    we can see the path that the enemy is generating. I'm not going to cover this
    code in detail, as it's just for the purpose of demonstration. It basically just
    draws a sprite at each point in the target location's vector.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经让代码运行起来了，这很棒，但让我们添加一些调试代码，以便我们可以看到敌人正在生成的路径。我不会详细介绍这段代码，因为它只是为了演示目的。它基本上只在目标位置的向量中的每个点上绘制一个精灵。
- en: 'In `Enemy.h`, we''ll declare the following variables and function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Enemy.h`中，我们将声明以下变量和函数：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In `Enemy::Enemy`, we''ll set up the debug sprites and font, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Enemy::Enemy`中，我们将设置调试精灵和字体，如下所示：
- en: '[PRE37]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Also, we''ll add a body for the new draw function named `Enemy::Draw`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将为名为`Enemy::Draw`的新绘制函数添加一个主体：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code will show us the paths that the enemies'' A* algorithm find, helping
    us visualize what the A* algorithm is doing. Let''s run the game and take a look.
    Remember that you need to delete this debug code when you''re done as it''s going
    to have an impact on the performance. The following screenshot shows our enemies''
    paths:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将显示敌人的A*算法找到的路径，帮助我们可视化A*算法的操作。让我们运行游戏并看一下。记住，当你完成时，你需要删除这个调试代码，因为它会影响性能。下面的截图显示了我们敌人的路径：
- en: '![Viewing our path](img/B04920_08_13.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![查看我们的路径](img/B04920_08_13.jpg)'
- en: Procedurally generated level goals
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序生成的关卡目标
- en: The final system that we're going to build in this chapter is one that will
    generate randomized level goals. In each level, we have to find the key, find
    the exit, and kill all enemies that get in our way. Let's add more gameplay and
    challenge by adding random goals that the player can also complete. Every time
    a level is entered, we'll potentially give the player an optional task that, if
    completed, will yield a random reward.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们要构建的最终系统是生成随机化的关卡目标。在每个关卡中，我们必须找到钥匙、找到出口，并杀死所有挡路的敌人。通过添加玩家也可以完成的随机目标，让游戏增加更多的玩法和挑战。每次进入一个关卡，我们将可能给玩家一个可选任务，如果完成了，将获得随机奖励。
- en: The variable and function declarations
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量和函数声明
- en: 'The first step in creating this system is to declare the variables and functions
    that we''re going to need. We''ll encapsulate the behavior to generate a goal
    in its own function. For starters, we need to declare the following `private`
    function in `Game.h`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此系统的第一步是声明我们将需要的变量和函数。我们将封装生成目标行为到自己的函数中。首先，我们需要在`Game.h`中声明以下`private`函数：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Given the type of goals that we want to generate (killing enemies, collecting
    gold, and collecting gems), we need variables to hold these values. Let''s also
    declare the following `private` variables in `Game.h`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们想要生成的目标类型（杀死敌人、收集黄金和宝石），我们需要变量来保存这些值。让我们在`Game.h`中也声明以下`private`变量：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we''re going to want to be able to tell whether we have an active
    goal or not and draw the goal to the screen. We''ll declare a Boolean value to
    track whether we have a goal, and a string object to store the description of
    the current goal:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将要能够判断我们是否有一个活动目标，并将目标绘制到屏幕上。我们将声明一个布尔值来跟踪我们是否有一个目标，以及一个字符串对象来存储当前目标的描述：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Generating a random goal
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成随机目标
- en: Now we can generate the random goal. We have three types available, namely gold,
    gems, and enemies. So for a start, we need to choose which of these goals we're
    going to create.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以生成随机目标。我们有三种类型可用，即黄金、宝石和敌人。因此，首先我们需要选择要创建的目标中的哪一个。
- en: 'Let''s give `Game::GenerateLevelGoal` a body in `Game.cpp` by adding the following
    code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`Game.cpp`中添加以下代码，让`Game::GenerateLevelGoal`具有实体：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We started by defining a stream object that we'll use later, and resetting the
    goal variables to `0`. This is done to ensure that the goals start fresh every
    time this function is called. Then, we generate a number between `0` and `2` and
    use it in a `switch` statement.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了一个流对象，稍后我们将使用它，并将目标变量重置为`0`。这样做是为了确保每次调用此函数时目标都是全新的。然后，我们生成一个介于`0`和`2`之间的数字，并在`switch`语句中使用它。
- en: 'For each case we need to generate a random number as the goal value and set
    it to the appropriate variable. We also need to construct a string that describes
    the goal and store it in the `m_goalString` variable, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种情况，我们需要生成一个随机数作为目标值，并将其设置为适当的变量。我们还需要构造一个描述目标的字符串，并将其存储在`m_goalString`变量中，如下所示：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With this complete, our goals are essentially created. We now need to activate
    the goal by setting the `m_activeGoal` variable to `true`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们的目标基本上已经创建。现在我们需要通过将`m_activeGoal`变量设置为`true`来激活目标：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The complete function looks like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的函数看起来像这样：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We''ll hook up this function properly in the next chapter when we turn our
    attention to the level, but for now, we can test it by making a call to it in
    `Game::Game`. Add the following debug code so that we can test the function:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，当我们把注意力转向关卡时，我们将适当地连接这个函数，但现在，我们可以通过在`Game::Game`中调用它来测试它。添加以下调试代码，以便我们可以测试该函数：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Checking whether a goal is complete
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查目标是否完成
- en: We can now generate a random level goal at the call of a function. We now need
    to hook gameplay into these goals so that we can tell when one of them has been
    accomplished. Whenever we process an action that is related to a goal, we need
    to check whether we have an active goal and respond accordingly.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在调用函数时生成随机的关卡目标。我们现在需要将游戏玩法与这些目标连接起来，以便我们可以知道其中一个是否已经完成。每当我们处理与目标相关的动作时，我们需要检查是否有活动目标，并做出相应的响应。
- en: 'Starting with the kill count, when we determine that an enemy has been killed,
    we check whether we have an active goal, and if this is the case, we decrement
    the `m_killGoal` variable, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 从击杀计数开始，当我们确定敌人已被击败时，我们将检查是否有活动目标，如果是这样，我们会递减`m_killGoal`变量，如下所示：
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The same approach is taken for other level goals. In the object pickup code,
    when we have picked up either gold or a gem, we''ll check whether we have an active
    level goal, and if this is the case, we decrement the appropriate values, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 其他关卡目标也采用相同的方法。在对象拾取代码中，当我们拾取黄金或宝石时，我们将检查是否有活动的关卡目标，如果是这样，我们会递减相应的值，如下所示：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With this complete, the actions in the game are now hooked up to the goal counters.
    Next, we need to actually check whether we've achieved the goal. We'll put this
    code right at the end of `Game::Update` so that we can ensure that all the other
    actions have been executed.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，游戏中的动作现在已经与目标计数器连接起来。接下来，我们需要实际检查是否已经实现了目标。我们将把这段代码放在`Game::Update`的最后，以确保所有其他动作都已执行。
- en: 'Checking whether we''ve achieved our goal is simple. First, we check whether
    we have an active goal. Then, we check whether all the counter variables are less
    than or equal to `0`. If that''s the case then we know that we''ve decremented
    the appropriate counter to `0`. With this approach the other values will dip to
    negative values, but we won''t be collecting enough loot for that to be a problem.
    Let''s add this code at the end of `Game::Update`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们是否实现了目标很简单。首先，我们检查是否有一个活动目标。然后，我们检查所有计数器变量是否小于或等于`0`。如果是这样，那么我们知道我们已将适当的计数器减少到`0`。通过这种方法，其他值将下降到负值，但我们不会收集足够的战利品来解决这个问题。让我们在`Game::Update`的末尾添加这段代码：
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: With this complete, the majority of the goal system is set up. You can see that
    if we determine that a goal is active, and all counters are 0 or lower, we reward
    the player. We also set the `m_activeGoal` variable to `false` to show that the
    goal has now been achieved.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，大部分目标系统已经建立起来。您可以看到，如果我们确定目标是活动的，并且所有计数器都为0或更低，我们会奖励玩家。我们还将`m_activeGoal`变量设置为`false`，以显示目标现在已经实现。
- en: Drawing the goal on the screen
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在屏幕上绘制目标
- en: The final step now is to draw our goal on screen! We have a `bool` variable
    that denotes when we have an active goal, and when we generate that goal, we store
    its descriptor in a string variable. Drawing it is as simple as making a call
    to `Game::DrawText` and passing the description, but we'll only do this when the
    `m_activeGoal` variable is `true`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的最后一步是在屏幕上绘制我们的目标！我们有一个`bool`变量，表示我们是否有一个活动目标，当我们生成目标时，我们将其描述存储在一个字符串变量中。绘制它就像调用`Game::DrawText`并传递描述一样简单，但我们只会在`m_activeGoal`变量为`true`时这样做。
- en: 'It''s time to finish this system by adding the following to `Game::Draw`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过在`Game::Draw`中添加以下内容来完成这个系统了：
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, if you run the game, you will see that a unique goal is shown every time:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您运行游戏，您将看到每次显示一个独特的目标：
- en: '![Drawing the goal on the screen](img/B04920_08_14.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![在屏幕上绘制目标](img/B04920_08_14.jpg)'
- en: We could call it a day here, but we can do better! Since the string that defines
    the level goal is stored only once, when we create it, it doesn't update itself
    as we work towards achieving it. Let's fix this! If we jump back to `Game::Update`
    and find where we check whether we achieved our goal, we can make some modifications
    here to achieve this.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里结束一天，但我们可以做得更好！由于定义关卡目标的字符串只存储一次，当我们创建它时，它不会随着我们朝着目标努力而更新自身。让我们来解决这个问题！如果我们回到`Game::Update`并找到我们是否已经实现了目标的检查点，我们可以在这里进行一些修改来实现这一点。
- en: 'Currently, we check whether we''ve achieved the active goal, but we only do
    something if we have achieved it. This is our opportunity to update the string.
    All we have to do it determine which type of goal is set, which we can do by checking
    the values of our goal variables, and rebuild the string in the same way we do
    in `Game::GenerateLevelGoal`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们会检查是否已经实现了活动目标，但只有在实现了目标时才会执行操作。这是我们更新字符串的机会。我们只需要确定设置了哪种类型的目标，这可以通过检查我们的目标变量的值来实现，并以与我们在`Game::GenerateLevelGoal`中所做的相同方式重建字符串。
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, when we have an active goal, the string on the screen is updated as we
    work towards it!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们有一个活动目标时，屏幕上的字符串会随着我们朝着目标努力而更新！
- en: Exercises
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'To help you test your knowledge of this chapter''s content, here are a few
    exercises that you should work on. They are not imperative to the rest of the
    book, but working on them will help you assess your strengths and weaknesses in
    the material covered:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你测试本章内容的知识，这里有一些练习，你应该进行练习。它们对于本书的其余部分并不是必不可少的，但是进行练习将帮助你评估所涵盖材料的优势和劣势。
- en: When calculating pathfinding, we currently do not allow diagonal movement. Update
    the algorithm so that this is now allowed. To get you started, when calculating
    the G cost, you'll need to determine whether we moved diagonally or straight.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算路径查找时，我们目前不允许对角线移动。更新算法，使其允许对角线移动。为了帮助你入门，当计算G成本时，你需要确定我们是对角线移动还是直线移动。
- en: Currently, the enemies will chase us throughout the entire level. Amend the
    function so that the enemy will only chase the player if they are within a certain
    distance.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，敌人会在整个关卡中追逐我们。修改函数，使敌人只在一定距离内追逐玩家。
- en: Currently our enemies move at a fixed speed and don't take into account the
    speed variable that we generated in an earlier chapter. Incorporate the speed
    variable in the game so that the enemies move at their correct speeds.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，我们的敌人以固定速度移动，并且不考虑我们在早期章节生成的速度变量。在游戏中整合速度变量，使敌人以正确的速度移动。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we extended our efforts to procedural behavior and mechanics
    as opposed to just resources. Specifically, we implemented A* pathfinding algorithm
    to give the enemies some intelligence and natural movement around our levels and
    created random level goals. Hopefully, this has been a good demonstration of the
    fact that procedural generation isn't limited to just resources; it can be put
    to use for every aspect of a game.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将我们的努力扩展到程序行为和机制，而不仅仅是资源。具体来说，我们实现了A*路径查找算法，为敌人提供一些智能和在关卡周围的自然移动，并创建了随机关卡目标。希望这已经很好地证明了程序生成不仅仅局限于资源；它可以用于游戏的每个方面。
- en: 'In the next chapter, we''re going to implement what is perhaps the most iconic
    feature of roguelike games: procedurally generated levels. Up until now we''ve
    been working with the same fixed level, so it''s about time we started generating
    them procedurally! We''ll also create some variance between the levels and implement
    the goal generator that we just created!'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现可能是roguelike游戏最具标志性的特征：程序生成的关卡。到目前为止，我们一直在使用相同的固定关卡，所以是时候开始程序生成它们了！我们还将在关卡之间创建一些差异，并实现我们刚刚创建的目标生成器！
