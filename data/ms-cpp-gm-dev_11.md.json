["```cpp\nRenderScene(Frame f)\n{\n  ProcessFrame(f); //Handle any needed globally shared calculations\n  RenderFrame(f); //Render any globally shared elements\n  for(int i=0; i<numview points; i++) //numview points would be 2 for                            stereo\n    {\n      ProcessEye(i, f); //Handle any per eye needed calculations\n      RenderEye(i, f); //Render any per eye elements\n    }\n}\n```", "```cpp\nlayout (binding = 0) uniform FrameContext\n{\n  Mat4x4 location; //modelview\n  Mat4x4 projection;\n  Vec3 viewerPosition;\n  Vec3 position;\n}frame;\nlayout (binding = 1) uniform EyeContext\n{\n  Mat4x4 location; //modelview\n  Mat4x4 projection;\n  Vec3 position;\n}eye;\n```", "```cpp\nvoid GameplayScreen::Build()\n{\n  if (!vr::VR_IsHmdPresent())\n   {\n      throw BookEngine::Exception(\"No HMD attached to the system\");\n   }\n  if (!vr::VR_IsRuntimeInstalled())\n   {\n      throw BookEngine::Exception(\"OpenVR Runtime not found\");\n   }\n}\n```", "```cpp\nInitVR();\n```", "```cpp\nvoid GameplayScreen::InitVR()\n{\n   vr::EVRInitError err = vr::VRInitError_None;\n   m_hmd = vr::VR_Init(&err, vr::VRApplication_Scene);\n   if (err != vr::VRInitError_None)\n   {\n     HandleVRError(err);\n   }\n   std::cout << GetTrackedDeviceString(m_hmd,\n   vr::k_unTrackedDeviceIndex_Hmd,vr::Prop_TrackingSystemName_String)\n   << std::endl;\n   std::clog << GetTrackedDeviceString(m_hmd,                  vr::k_unTrackedDeviceIndex_Hmd, vr::Prop_SerialNumber_String)<<        std::endl;\n}\n```", "```cpp\nvoid GameplayScreen::HandleVRError(vr::EVRInitError err)\n{\n  throw BookEngine::Exception(vr::VR_GetVRInitErrorAsEnglishDescription(err));\n}\n```", "```cpp\nstd::string GameplayScreen::GetTrackedDeviceString(vr::IVRSystem * pHmd, vr::TrackedDeviceIndex_t unDevice, vr::TrackedDeviceProperty prop, vr::TrackedPropertyError * peError)\n{\n  uint32_t unRequiredBufferLen = pHmd-                  >GetStringTrackedDeviceProperty(unDevice, prop, NULL, 0, peError);\n    if (unRequiredBufferLen == 0)\n      return \"\";\n\n   char *pchBuffer = new char[unRequiredBufferLen];\n   unRequiredBufferLen = pHmd->GetStringTrackedDeviceProperty(unDevice,   prop, pchBuffer, unRequiredBufferLen, peError);\n   std::string sResult = pchBuffer;\n   delete[] pchBuffer;\n   return sResult;\n}\n```", "```cpp\nif (!vr::VRCompositor())\n {\n   throw BookEngine::Exception(\"Unable to initialize VR compositor!\\n \");\n }\nm_hmd->GetRecommendedRenderTargetSize(&m_VRWidth, &m_VRHeight);\n\nstd::cout << \"Initialized HMD with suggested render target size : \" << m_VRWidth << \"x\" << m_VRHeight << std::endl;\n}\n```", "```cpp\nvoid GameplayScreen::Destroy()\n{\n   if (m_hmd)\n    {\n       vr::VR_Shutdown();\n       m_hmd = NULL;\n    }\n}\n```", "```cpp\nBasicRenderTarget leftRT(1, vrApp.rtWidth, vrApp.rtHeight);\nBasicRenderTarget rightRT(1, vrApp.rtWidth, vrApp.rtHeight);\n\nleftRT.Init(leftEyeTexture.name);\nrightRT.Init(rightEyeTexture.name);\n\nglClearColor(1.0f, 0.0f, 0.0f, 1.0f);\nleftRT.fbo.Bind(GL_FRAMEBUFFER);\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\nif (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)\n  {\n    throw std::runtime_error(\"left rt incomplete\");\n  }\nglClearColor(0.0f, 1.0f, 0.0f, 1.0f);\nrightRT.fbo.Bind(GL_FRAMEBUFFER);\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\nif (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)\n  {\n    throw std::runtime_error(\"right rt incomplete\");\n  }\nglBindFramebuffer(GL_FRAMEBUFFER, 0);\n\nglClearColor (0.0f, 0.0f, 1.0f, 1.0f);\n```", "```cpp\nvoid GameplayScreen::SubmitFrames(GLint leftEyeTex, GLint rightEyeTex, bool linear = false)\n{\n if (!m_hmd)\n  {\n    throw std::runtime_error(\"Error : presenting frames when VR system handle is NULL\");\n  }\n  vr::TrackedDevicePose_t trackedDevicePose[vr::k_unMaxTrackedDeviceCount];\n  vr::VRCompositor()->WaitGetPoses(trackedDevicePose,        vr::k_unMaxTrackedDeviceCount, nullptr, 0);\n\n  vr::EColorSpace colorSpace = linear ? vr::ColorSpace_Linear :    vr::ColorSpace_Gamma;\n\n  vr::Texture_t leftEyeTexture = { (void*)leftEyeTex,    vr::TextureType_OpenGL, colorSpace };\n  vr::Texture_t rightEyeTexture = { (void*)rightEyeTex,   vr::TextureType_OpenGL, colorSpace };\n\n  vr::VRCompositor()->Submit(vr::Eye_Left, &leftEyeTexture);\n  vr::VRCompositor()->Submit(vr::Eye_Right, &rightEyeTexture);\n\n  vr::VRCompositor()->PostPresentHandoff();\n}\n```", "```cpp\n\u2026\nglClear(GL_COLOR_BUFFER_BIT);\nSubmitFrames(leftEyeTexture.id, rightEyeTexture.id);\n```"]