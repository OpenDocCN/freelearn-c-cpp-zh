- en: 18\. Gameplay Framework Classes in Multiplayer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18. 多人游戏中的游戏框架类
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn where the instances of the gameplay framework
    classes exist in multiplayer. You'll also learn how to use the game state and
    player state classes, as well as some new concepts in the game mode, including
    match states. We'll also cover some useful built-in functionality that can be
    used in different types of games.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习游戏框架类的实例在多人游戏中的存在位置。您还将学习如何使用游戏状态和玩家状态类，以及游戏模式中的一些新概念，包括比赛状态。我们还将介绍一些可用于不同类型游戏的有用内置功能。
- en: By the end of this chapter, you'll be able to use the game state and player
    state classes to store information about the game and about specific players that
    can be accessed by any client. You'll also know how to make the most of the game
    mode class and other related functionality.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够使用游戏状态和玩家状态类来存储关于游戏和特定玩家的信息，这些信息可以被任何客户端访问。您还将了解如何充分利用游戏模式类和其他相关功能。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we covered *Remote Procedure Calls*, which allow the
    server and the clients to execute remote functions on each other. We also covered
    enumerations and *Bi-Directional Circular Array Indexing*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了*远程过程调用*，它允许服务器和客户端在彼此上执行远程函数。我们还介绍了枚举和*双向循环数组索引*。
- en: In this chapter, we're going to take a look at the most common gameplay framework
    classes and see where their instances exist in a multiplayer environment. This
    is important to understand, so you know which instances can be accessed in a specific
    game instance. An example of this would be that only the server should be able
    to access the game mode instance, so if you were playing Fortnite, a player shouldn't
    be able to access it and modify the rules of the game.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看最常见的游戏框架类，并了解它们在多人游戏环境中的实例存在位置。这很重要，这样您就知道在特定游戏实例中可以访问哪些实例。例如，只有服务器应该能够访问游戏模式实例，因此如果您在玩《堡垒之夜》，玩家就不应该能够访问它并修改游戏规则。
- en: We'll also be covering the game state and player state classes in this chapter.
    As the name implies, these store information about the state of the game and of
    each player that is playing the game. Finally, toward the end of this book, we'll
    cover some new concepts in the game mode, as well as some useful built-in functionality.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将涵盖游戏状态和玩家状态类。顾名思义，这些类存储有关游戏状态和每个玩家的信息。最后，在本书的末尾，我们将介绍游戏模式中的一些新概念，以及一些有用的内置功能。
- en: We will begin with how gameplay framework classes work in multiplayer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从多人游戏中游戏框架类的工作方式开始。
- en: Gameplay Framework Classes in Multiplayer
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多人游戏中的游戏框架类
- en: 'Unreal Engine 4 comes with a gameplay framework, which is a set of classes
    that allow you to create games more easily. The gameplay framework does this by
    providing built-in common functionality that is present in most games, such as
    a way to define the game rules (game mode), and a way to control a character (the
    player controller and pawn/character class). When an instance of a gameplay framework
    class is created in a multiplayer environment, it can exist on the server, on
    the clients, and on the owning client, which is the client that has its player
    controller as the owner of that instance. This means that the instances of the
    gameplay framework classes will always fall into one of the following categories:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎4带有一个游戏框架，它是一组类，允许您更轻松地创建游戏。游戏框架通过提供内置的常见功能来实现这一点，这些功能在大多数游戏中都存在，例如定义游戏规则的方法（游戏模式），以及控制角色的方法（玩家控制器和pawn/character类）。在多人游戏环境中创建游戏框架类的实例时，它可以存在于服务器、客户端和拥有客户端，即其玩家控制器作为该实例的所有者的客户端。这意味着游戏框架类的实例将始终属于以下类别之一：
- en: '**Server Only**: The instances of the class will only exist on the server.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅服务器**：该类的实例将只存在于服务器。'
- en: '**Server and Clients**: The instances of the class will exist on the server
    and the clients.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器和客户端**：该类的实例将存在于服务器和客户端。'
- en: '**Server and Owning Client**: The instances of the class will exist on the
    server and on the owning client.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器和拥有客户端**：该类的实例将存在于服务器和拥有客户端。'
- en: '**Owning Client Only**: The instances of the class will only exist on the owning client.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅拥有客户端**：该类的实例只存在于拥有客户端。'
- en: 'Take a look at the following diagram, which shows each category and the purpose
    of the most common classes on the gameplay framework:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下图表，显示了每个类别以及游戏框架中最常见类的目的：
- en: '![Figure 18.1: The most common gameplay framework classes divided into categories'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图18.1：最常见的游戏框架类分成类别'
- en: '](img/B16183_18_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_18_01.jpg)'
- en: 'Figure 18.1: The most common gameplay framework classes divided into categories'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1：最常见的游戏框架类分成类别
- en: 'Let''s go into a bit more detail on each class in the preceding diagram:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解前面图表中每个类：
- en: '**Game Mode (Server Only)**: The game mode class defines the rules of the game
    and its instance can only be accessed by the server. If a client tries to access
    it, the instance will always be invalid, in order to prevent clients from changing
    the game rules.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏模式（仅服务器）**：游戏模式类定义游戏规则，其实例只能被服务器访问。如果客户端尝试访问它，实例将始终无效，以防止客户端更改游戏规则。'
- en: '**Game State (Server and Clients)**: The game state class stores the state
    of the game and its instance can be accessed both by the server and the clients.
    The game state will be covered in greater depth in a future topic.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏状态（服务器和客户端）**：游戏状态类存储游戏的状态，其实例可以被服务器和客户端访问。游戏状态将在未来的主题中更深入地讨论。'
- en: '**Player State (Server and Clients)**: The player state class stores the state
    of a player and its instance can be accessed both by the server and the clients.
    The player state will be covered in greater depth in a future topic.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Player State（服务器和客户端）**：Player State类存储玩家的状态，其实例可以被服务器和客户端访问。Player State将在未来的主题中更深入地介绍。'
- en: '**Pawn (Server and Clients)**: The pawn class is the visual representation
    of a player and its instance can be accessed by the server and the clients.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pawn（服务器和客户端）**：Pawn类是玩家的视觉表示，其实例可以被服务器和客户端访问。'
- en: '`UGameplayStatics::GetPlayerController` function with an index other than `0`
    (which would return its player controller), the returned instance will always
    be invalid. This means that the server is the only place that has access to all
    of the player controllers. You can find out whether a player controller instance
    is in its owning client by calling the `AController::IsLocalController` function.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`UGameplayStatics::GetPlayerController`函数并指定除`0`以外的索引（将返回其玩家控制器），返回的实例将始终无效。这意味着服务器是唯一可以访问所有玩家控制器的地方。您可以通过调用`AController::IsLocalController`函数来查找玩家控制器实例是否在其拥有客户端。
- en: '**HUD (Owning Client Only)**: The HUD class is used as an immediate mode to
    draw basic shapes and text on the screen. Since it''s used for UI, its instance
    is only available on the owning client, because the server and the other clients
    don''t need to know about it.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HUD（仅拥有客户端）**：HUD类用作在屏幕上绘制基本形状和文本的即时模式。由于它用于UI，因此其实例仅在拥有客户端上可用，因为服务器和其他客户端不需要知道它。'
- en: '**UMG Widgets (Owning Client Only)**: The UMG widget classes are used to display
    complex UI on the screen. Since it''s used for UI, its instance is only available
    on the owning client, because the server and the other clients don''t need to
    know about it.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UMG小部件（仅拥有客户端）**：UMG小部件类用于在屏幕上显示复杂的UI。由于它用于UI，因此其实例仅在拥有客户端上可用，因为服务器和其他客户端不需要知道它。'
- en: 'To help you understand these concepts, we can use Dota 2 as an example. The
    game mode defines that there are different phases of the game (*pre-game for hero
    picking, the actual game, and the post-game with the winner*) and that the end
    goal is to destroy the other team''s ancient. Since it''s a class that is critical
    to gameplay, clients can''t be allowed to access it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您理解这些概念，我们可以以Dota 2为例。游戏模式定义了游戏的不同阶段（*英雄选择的前期游戏，实际游戏以及赢家的后期游戏*），最终目标是摧毁对方团队的远古。由于这是对游戏玩法至关重要的类，客户端不能访问它：
- en: The game state stores the elapsed time, whether it's day or night, the score
    of each team, and so on, so the server and the clients need to be able to access
    it.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏状态存储经过的时间、白天或黑夜、每个队伍的得分等，因此服务器和客户端需要能够访问它。
- en: The player state stores the name, the hero selected, and the kill/death/assist
    ratio of a player, so the server and the clients need to be able to access it.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家状态存储玩家的名称、选择的英雄以及击杀/死亡/协助比率，因此服务器和客户端需要能够访问它。
- en: The pawn would be the hero, the courier, the illusions, and so on, controlled
    by the player, so the server and the clients need to be able to access it.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色将是英雄、信使、幻象等，由玩家控制，因此服务器和客户端需要能够访问它。
- en: The player controller is what relays the input information to the controlled
    pawn, so only the server and the owning client need to be able to access it.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家控制器是将输入信息传递给受控制的pawn的组件，因此只有服务器和拥有客户端需要能够访问它。
- en: The UI classes (`HUD` and `User` widget) would display all of the information
    on the owning client, so it only needs to be accessed there.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI类（`HUD`和`User`小部件）将在拥有客户端上显示所有信息，因此只需要在那里访问。
- en: In the next exercise, you will be displaying the instance values of the most
    common gameplay framework classes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将显示最常见的游戏框架类的实例值。
- en: 'Exercise 18.01: Displaying the Gameplay Framework Instance Values'
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习18.01：显示游戏框架实例值
- en: 'In this exercise, we''re going to create a new C++ project that uses the Third
    Person template, and we''re going to add the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个使用第三人称模板的新C++项目，并添加以下内容：
- en: On the owning client, the player controller creates and adds to the viewport
    a simple UMG widget that displays the name of the menu instance.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在拥有客户端上，玩家控制器创建并添加到视口一个简单的UMG小部件，用于显示菜单实例的名称。
- en: On the tick function, the character displays the value of its own instance (as
    a pawn) as well as whether it has a valid instance for the game mode, game state,
    player state, player controller, and HUD.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Tick`函数中，角色显示其自己实例的值（作为pawn），以及是否具有游戏模式、游戏状态、玩家状态、玩家控制器和HUD的有效实例。
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If needed, you can refer back to *Chapter 1*, *Unreal Engine Introduction*,
    for a recap of the tick function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您可以回顾一下*第1章*，*虚幻引擎介绍*，以了解`Tick`函数。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习：
- en: Create a new `Third Person` template project using `C++` called `GFInstances`
    (*as in Gameplay Framework Instances*) and save it on a location of your choosing.
    Once the project has been created, it should open the editor as well as the Visual
    Studio solution.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`C++`创建一个名为`GFInstances`（如游戏框架实例）的新`Third Person`模板项目，并将其保存在您选择的位置。创建项目后，它应该会打开编辑器以及Visual
    Studio解决方案。
- en: In the editor, create a new `C++` class called `GFInstancePlayerController`
    that is derived from `PlayerController`. Wait for the compilation to end, close
    the editor, and then go back to Visual Studio.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，创建一个名为`GFInstancePlayerController`的新`C++`类，该类派生自`PlayerController`。等待编译结束，关闭编辑器，然后返回Visual
    Studio。
- en: 'Open the `GFInstancesCharacter.h` file and declare the protected override for
    the `Tick` function:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GFInstancesCharacter.h`文件，并声明`Tick`函数的受保护覆盖：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open the `GFInstancesCharacter.cpp` file and include `DrawDebugHelpers.h` and
    `PlayerController.h`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GFInstancesCharacter.cpp`文件，并包括`DrawDebugHelpers.h`和`PlayerController.h`：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implement the `Tick` function:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Tick`函数：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Get the instances for the game mode, game state, player controller, and HUD:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取游戏模式、游戏状态、玩家控制器和HUD的实例：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, we store the instances for the game mode, game
    state, player controller, and HUD in separate variables, so that we can check
    whether they are valid.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将游戏模式、游戏状态、玩家控制器和HUD的实例存储在单独的变量中，以便我们可以检查它们是否有效。
- en: 'Create a string for each gameplay framework class:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个游戏框架类创建一个字符串：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we create strings to store the name of the pawn and whether the other
    gameplay framework instances are valid.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建字符串来存储角色的名称以及其他游戏框架实例是否有效。
- en: 'Display each string on the screen:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕上显示每个字符串：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code snippet, we print the strings created in the preceding code, which
    indicate the name of the pawn and whether the other gameplay framework instances
    are valid.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们打印了在前面的代码中创建的字符串，这些字符串指示了角色的名称以及其他游戏框架实例是否有效。
- en: 'Before we can move on to the `AGFInstancesPlayerController` class, we need
    to tell Unreal Engine that we want to use UMG functionality in order to be able
    to use the `UUserWidget` class. To do this, we need to open `GFInstances.Build.cs`
    and add `UMG` to the `PublicDependencyModuleNames` string array, like so:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以继续使用`AGFInstancesPlayerController`类之前，我们需要告诉虚幻引擎我们想要使用UMG功能，以便能够使用`UUserWidget`类。为此，我们需要打开`GFInstances.Build.cs`并将`UMG`添加到`PublicDependencyModuleNames`字符串数组中，如下所示：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you try to compile and get errors from adding the new module, then clean
    and recompile your project. If that doesn't work, try restarting your IDE.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试编译并从添加新模块中获得错误，则清理并重新编译项目。如果这样不起作用，请尝试重新启动您的IDE。
- en: 'Open `GFInstancesPlayerController.h` and add the protected variables to create
    the UMG widget:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GFInstancesPlayerController.h`并添加保护变量以创建UMG小部件：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Declare the protected override for the `BeginPlay` function:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`BeginPlay`函数的受保护覆盖：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open `GFInstancesPlayerController.cpp` and include `UserWidget.h`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GFInstancesPlayerController.cpp`并包括`UserWidget.h`：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement the `BeginPlay` function:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`BeginPlay`函数：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Abort the function if it''s not the owning client or if the menu class is invalid:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是拥有客户端或菜单类无效，则中止函数：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create the widget and add it to the viewport:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建小部件并将其添加到视口：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Compile and run the code.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行代码。
- en: In `Content Browser`, go to the `Content` folder, create a new folder called
    `UI`, and open it.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content Browser`中，转到`Content`文件夹，创建一个名为`UI`的新文件夹，并打开它。
- en: Create a new widget blueprint called `UI_Menu` and open it.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UI_Menu`的新小部件蓝图并打开它。
- en: Add a `Text Block` called `tbText` to the root canvas panel and set it to be
    a variable by clicking the checkbox `Is Variable` next to its name on the top
    of the Details panel.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根画布面板中添加一个名为`tbText`的`Text Block`并通过在详细面板顶部的其名称旁边点击复选框`Is Variable`来将其设置为变量。
- en: Set `tbText` to have `Size To Content` to `true`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`tbText`设置为`Size To Content`为`true`。
- en: 'Go to the `Graph` section and, in `Event Graph`, implement the `Event Construct`
    in the following manner:![Figure 18.2: The Event Construct that displays the name
    of the UI_Menu instance'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Graph`部分，在`Event Graph`中以以下方式实现`Event Construct`：![图18.2：显示UI_Menu实例名称的Event
    Construct
- en: '](img/B16183_18_02.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_18_02.jpg)'
- en: 'Figure 18.2: The Event Construct that displays the name of the UI_Menu instance'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.2：显示UI_Menu实例名称的Event Construct
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/38wvSr5](https://packt.live/38wvSr5).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到前面的完整分辨率截图以便更好地查看：[https://packt.live/38wvSr5](https://packt.live/38wvSr5)。
- en: Save and close `UI_Menu`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`UI_Menu`。
- en: Go to the `Content` folder and create a blueprint called `BP_PlayerController`
    that is derived from `GFInstancesPlayerController`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Content`文件夹并创建一个名为`BP_PlayerController`的蓝图，该蓝图派生自`GFInstancesPlayerController`。
- en: Open `BP_PlayerController` and set the `Menu` `Class` to use `UI_Menu`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_PlayerController`并设置`Menu` `Class`以使用`UI_Menu`。
- en: Save and close `BP_PlayerController`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`BP_PlayerController`。
- en: Go to the `Content` folder and create a blueprint called `BP_GameMode` that
    is derived from `GFInstancesGameMode`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Content`文件夹并创建一个名为`BP_GameMode`的蓝图，该蓝图派生自`GFInstancesGameMode`。
- en: Open `BP_GameMode` and set the `Player Controller` `Class` to use `BP_PlayerController`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_GameMode`并设置`Player Controller` `Class`以使用`BP_PlayerController`。
- en: Save and close `BP_GameMode`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`BP_GameMode`。
- en: Go to `Project Settings` and pick `Maps & Modes` from the left panel, which
    is in the `Project` category.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`项目设置`并从左侧面板选择`地图和模式`，该面板位于`项目`类别中。
- en: Set the `Default` `GameMode` to use `BP_GameMode`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Default` `GameMode`设置为使用`BP_GameMode`。
- en: Close `Project Settings`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`项目设置`。
- en: Finally, you can test the project.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以测试项目。
- en: Run the code and wait for the editor to fully load.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并等待编辑器完全加载。
- en: Go to `Multiplayer Options` and set the number of clients to `2`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`多人游戏选项`并将客户端数量设置为`2`。
- en: Set the window size to `800x600`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将窗口大小设置为`800x600`。
- en: Play in `New Editor Window (PIE)`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`新编辑器窗口（PIE）`中播放。
- en: Once you complete this exercise, you will be able to play on each client. You'll
    notice that the characters are displaying whether the instances for the game mode,
    game state, player state, player controller, and HUD are valid. It also displays
    the name of the instance of the pawn.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，您将能够在每个客户端上进行游戏。您会注意到角色是否显示游戏模式、游戏状态、玩家状态、玩家控制器和HUD的实例是否有效。它还显示了角色实例的名称。
- en: Now, let's analyze the values displayed in the `Server` and `Client 1` windows.
    Let's begin with the `Server` window first.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析在`服务器`和`客户端1`窗口中显示的值。让我们先从`服务器`窗口开始。
- en: The Server Window
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器窗口
- en: In the `Server` window, you have the values for `Server Character`, and in the
    background, you have the values for `Client 1 Character`. You should be able to
    see `Server Character`, `Client 1 Character`, and the `UI_Menu` UMG widget in
    the top-left corner. The UMG widget instance is only created for the player controller
    of `Server Character`, since it's the only player controller in this window that
    actually controls a character.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在“服务器”窗口中，您可以看到“服务器角色”的值，在背景中，您可以看到“客户端1角色”的值。您应该能够在左上角看到“服务器角色”，“客户端1角色”和“UI_Menu”UMG小部件。UMG小部件实例仅为“服务器角色”的玩家控制器创建，因为它是该窗口中实际控制角色的唯一玩家控制器。
- en: Let's first analyze the values for `Server Character`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先分析“服务器角色”的值。
- en: Server Character
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器角色
- en: 'This is the character that the listen server, which is a server that also has
    a client integrated that can play the game as well, is controlling. The values
    displayed on this character are as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是监听服务器的角色，它是一个同时具有客户端的服务器，也可以玩游戏。显示在该角色上的值如下：
- en: '**Game Mode = Valid** because the game mode instance only exists in the server,
    which is the current game instance.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏模式=有效，因为游戏模式实例只存在于服务器上，这是当前游戏实例。
- en: '**Game State = Valid** because the game state instance exists on the clients
    and the server, which is the current game instance.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏状态=有效，因为游戏状态实例存在于客户端和服务器上，这是当前游戏实例。
- en: '**Player State = Valid** because the player state instance exists on the clients
    and the server, which is the current game instance.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家状态=有效，因为玩家状态实例存在于客户端和服务器上，这是当前游戏实例。
- en: '**Pawn = ThirdPersonCharacter_2** because pawn instances exist on the clients
    and the server, which is the current game instance.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pawn=ThirdPersonCharacter_2，因为pawn实例存在于客户端和服务器上，这是当前游戏实例。
- en: '**Player Controller = Valid** because player controller instances exist on
    the owning client and the server, which is the current game instance.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家控制器=有效，因为玩家控制器实例存在于拥有的客户端和服务器上，这是当前游戏实例。
- en: '**HUD = Valid** because HUD instances only exist on the owning client, which
    is the case.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HUD=有效，因为HUD实例只存在于拥有的客户端上，这是情况。
- en: Next, we are going to be looking at `Client 1 Character` in the same window.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在同一窗口中查看“客户端1角色”。
- en: Client 1 Character
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端1角色
- en: 'This is the character that `Client 1` is controlling. The values displayed
    on this character are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是“客户端1”正在控制的角色。显示在该角色上的值如下：
- en: '**Game Mode = Valid** because the game mode instance only exists in the server,
    which is the current game instance.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏模式=有效，因为游戏模式实例只存在于服务器上，这是当前游戏实例。
- en: '**Game State = Valid** because the game state instance exists on the clients
    and the server, which is the current game instance.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏状态=有效，因为游戏状态实例存在于客户端和服务器上，这是当前游戏实例。
- en: '**Player State = Valid** because the player state instance exists on the clients
    and the server, which is the current game instance.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家状态=有效，因为玩家状态实例存在于客户端和服务器上，这是当前游戏实例。
- en: '**Pawn = ThirdPersonCharacter_0** because pawn instances exist on the clients
    and the server, which is the current game instance.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pawn=ThirdPersonCharacter_0，因为pawn实例存在于客户端和服务器上，这是当前游戏实例。
- en: '**Player Controller = Valid** because player controller instances exist on
    the owning client and the server, which is the current game instance.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家控制器=有效，因为玩家控制器实例存在于拥有的客户端和服务器上，这是当前游戏实例。
- en: '**HUD = Invalid** because HUD instances only exist on the owning client, which
    is not the case.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HUD=无效，因为HUD实例只存在于拥有的客户端上，这不是情况。
- en: The Client 1 Window
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端1窗口
- en: In the `Client 1` Window, you have the values for `Client 1 Character` and,
    in the background, you have values for `Server Character`. You should see `Client
    1 Character,` `Server Character`, and the `UI_Menu` UMG widget in the top-left
    corner. The UMG widget instance is only created for the player controller of `Client
    1 Character`, since it's the only player controller in this window that actually
    controls a character.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在“客户端1”窗口中，您可以看到“客户端1角色”的值，在背景中，您可以看到“服务器角色”的值。您应该能够在左上角看到“客户端1角色”，“服务器角色”和“UI_Menu”UMG小部件。UMG小部件实例仅为“客户端1角色”的玩家控制器创建，因为它是该窗口中实际控制角色的唯一玩家控制器。
- en: Let's first analyze the values for `Client 1 Character`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先分析“客户端1角色”的值。
- en: Client 1 Character
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端1角色
- en: 'This is the character that `Client 1` is controlling. The values displayed
    on this character are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是“客户端1”正在控制的角色。显示在该角色上的值如下：
- en: '**Game Mode = Invalid** because the game mode instance only exists in the server,
    which is not the current game instance.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏模式=无效，因为游戏模式实例只存在于服务器上，这不是当前游戏实例。
- en: '**Game State = Valid** because the game state instance exists on the server
    and the clients, which is the current game instance.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏状态=有效，因为游戏状态实例存在于服务器和客户端上，这是当前游戏实例。
- en: '**Player State = Valid** because the player state instance exists on the server
    and the clients, which is the current game instance.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家状态=有效，因为玩家状态实例存在于服务器和客户端上，这是当前游戏实例。
- en: '**Pawn = ThirdPersonCharacter_0** because pawn instances exist on the server
    and the clients, which is the current game instance.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pawn=ThirdPersonCharacter_0，因为pawn实例存在于服务器和客户端上，这是当前游戏实例。
- en: '**Player Controller = Valid** because player controller instances exist on
    the server and the owning client, which is the current game instance.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家控制器=有效，因为玩家控制器实例存在于服务器和拥有的客户端上，这是当前游戏实例。
- en: '**HUD = Valid** because HUD instances only exist on the owning client, which
    is the case.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HUD=有效，因为HUD实例只存在于拥有的客户端上，这是情况。
- en: Next, we are going to be looking at `Server Character` in the same window.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在同一窗口中查看“服务器角色”。
- en: Server Character
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器角色
- en: 'This is the character that the listen server is controlling. The values displayed
    on this character are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是监听服务器控制的角色。显示在该角色上的值如下：
- en: '**Game Mode = Invalid** because the game mode instance only exists in the server,
    which is not the current game instance.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏模式 = 无效**，因为游戏模式实例仅存在于服务器，而不是当前游戏实例。'
- en: '**Game State = Valid** because the game state instance exists on the server
    and the clients, which is the current game instance.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Game State = 有效**，因为游戏状态实例存在于服务器和客户端，即当前游戏实例。'
- en: '**Player State = Valid** because the player state instance exists on the server
    and the clients, which is the current game instance.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Player State = 有效**，因为玩家状态实例存在于服务器和客户端，即当前游戏实例。'
- en: '**Pawn = ThirdPersonCharacter_2** because pawn instances exist on the server
    and the clients, which is the current game instance.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pawn = ThirdPersonCharacter_2**，因为pawn实例存在于服务器和客户端，即当前游戏实例。'
- en: '**Player Controller = Invalid** because player controller instances exist on
    the server and the owning client, which is not the current game instance.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Player Controller = 无效**，因为玩家控制器实例存在于服务器和拥有的客户端，而不是当前游戏实例。'
- en: '**HUD = Invalid** because HUD instances only exist on the owning client, which
    is not the case.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HUD = 无效**，因为HUD实例仅存在于拥有的客户端，这不是情况。'
- en: By completing this exercise, you should have a better understanding of where
    each instance of the gameplay framework classes exists and where it doesn't. Next,
    we're going to cover the player state and game state classes, as well as some
    additional concepts on the game mode and useful built-in functionalities.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，您应该更好地理解游戏框架类的每个实例存在和不存在的位置。接下来，我们将介绍玩家状态和游戏状态类，以及游戏模式和有用的内置功能的一些额外概念。
- en: Game Mode, Player State, and Game State
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏模式、玩家状态和游戏状态
- en: So far, we've covered most of the important classes in the gameplay framework,
    including the game mode, player controller, and the pawn. In this chapter, we're
    going to cover the player state, game state, and some additional concepts of the
    game mode, as well as some useful built-in functionalities.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了游戏框架中的大部分重要类，包括游戏模式、玩家控制器和pawn。在本章中，我们将涵盖玩家状态、游戏状态以及游戏模式的一些额外概念，以及一些有用的内置功能。
- en: Game Mode
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏模式
- en: We've already talked about the game mode and how it works, but there are a few
    concepts that haven't yet been covered.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了游戏模式及其工作原理，但还有一些概念尚未涵盖。
- en: Constructor
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'To set the default class values, you can use the constructor like so:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置默认类值，可以使用构造函数如下：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code lets you specify which classes to use when spawning pawns,
    player controllers, player states, and game states when we are using this game
    mode.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码允许您指定在使用此游戏模式时生成pawn、player controller、player state和game state时要使用的类。
- en: '**Getting the Game Mode Instance**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取游戏模式实例**'
- en: 'If you want to access the game mode instance, you need to get it from the `GetWorld`
    function by using the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要访问游戏模式实例，您需要使用以下代码从`GetWorld`函数中获取它：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code allows you to access the current game mode instance so you
    can run functions and consult the values of certain variables. You have to make
    sure to call it only on the server, since this will be invalid on the clients,
    for security reasons.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码允许您访问当前游戏模式实例，以便您可以运行函数并查询某些变量的值。您必须确保仅在服务器上调用它，因为出于安全原因，这将在客户端上无效。
- en: '**Match States**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**比赛状态**'
- en: 'So far, we''ve only been using the `AGameModeBase` class, which is the most
    basic game mode class in the framework, and although it''s more than enough for
    certain types of games, there are cases where you require a bit more functionality.
    An example of this would be if we wanted to do a lobby system, where the match
    only starts if all players have marked that they were ready. This example wouldn''t
    be possible to do with the `AGameModeBase` class. For these cases, it''s better
    to use the `AGameMode` class instead, which is a child class of `AGameModeBase`
    that adds support to multiplayer matches through the use of match states. The
    way match states work is by using a state machine that can only be in one of the
    following states at a given time:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了`AGameModeBase`类，这是框架中最基本的游戏模式类，虽然对于某些类型的游戏来说已经足够了，但在某些情况下，您可能需要更多的功能。例如，如果我们想要做一个大厅系统，只有当所有玩家标记为准备好时比赛才开始。使用`AGameModeBase`类无法实现这个例子。对于这些情况，最好使用`AGameMode`类，它是`AGameModeBase`的子类，通过使用比赛状态来支持多人比赛。比赛状态的工作方式是使用状态机，该状态机在给定时间内只能处于以下状态之一：
- en: '`EnteringMap`: This is the starting state when the world is still loading and
    the actors aren''t ticking yet. It will transition to the `WaitingToStart` state
    once the world finishes loading.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnteringMap`：这是当世界仍在加载并且角色尚未开始计时时的起始状态。一旦世界加载完成，它将转换到`WaitingToStart`状态。'
- en: '`WaitingToStart`: This state is set when the world has finished loading and
    the actors are ticking, although the pawns for the players won''t be spawned because
    the game hasn''t started yet. When the state machine enters this state, it will
    call the `HandleMatchIsWaitingToStart` function. The state machine will transition
    to the `InProgress` state if the `ReadyToStartMatch` function returns `true` or
    if the `StartMatch` function is called somewhere in the code.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitingToStart`：当世界加载完成并且角色正在计时时，设置此状态，尽管玩家的pawn尚未生成，因为游戏尚未开始。当状态机进入此状态时，它将调用`HandleMatchIsWaitingToStart`函数。如果`ReadyToStartMatch`函数返回`true`，或者在代码中的某个地方调用了`StartMatch`函数，状态机将转换到`InProgress`状态。'
- en: '`InProgress`: This state is where the actual game takes place. When the state
    machine enters this state, it will spawn the pawns for the players, call `BeginPlay`
    on all of the actors in the world, and call the `HandleMatchHasStarted` function.
    The state machine will transition to the `WaitingPostMatch` state if the `ReadyToEndMatch`
    function returns `true` or if the `EndMatch` function is called somewhere in the
    code.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InProgress`：这是实际游戏发生的状态。当状态机进入此状态时，它将为玩家生成pawn，对世界中的所有角色调用`BeginPlay`，并调用`HandleMatchHasStarted`函数。如果`ReadyToEndMatch`函数返回`true`或者在代码中的某个地方调用了`EndMatch`函数，状态机将转换到`WaitingPostMatch`状态。'
- en: '`WaitingPostMatch`: This state is set when the match ends. When the state machine
    enters this state, it will call the `HandleMatchHasEnded` function. In this state,
    actors still tick, but new players cannot join. It will transition to the `LeavingMap`
    state when it starts unloading the world.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitingPostMatch`：比赛结束时设置此状态。当状态机进入此状态时，它将调用`HandleMatchHasEnded`函数。在此状态下，角色仍在进行计时，但新玩家无法加入。当开始卸载世界时，它将转换到`LeavingMap`状态。'
- en: '`LeavingMap`: This state is set while it''s unloading the world. When the state
    machine enters this state, it will call the `HandleLeavingMap` function. The state
    machine will transition to the `EnteringMap` state when it starts loading the
    new level.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LeavingMap`：在卸载世界时设置此状态。当状态机进入此状态时，它将调用`HandleLeavingMap`函数。当开始加载新级别时，状态机将转换到`EnteringMap`状态。'
- en: '`Aborted`: This is a failure state that can only be set by calling the `AbortMatch`
    function, which is used to flag that something went wrong that prevented the match
    from happening.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Aborted`：这是一个失败状态，只能通过调用`AbortMatch`函数来设置，该函数用于标记某些阻止比赛进行的错误。'
- en: 'To help you understand these concepts better, we can use Dota 2 again as an example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您更好地理解这些概念，我们可以再次以Dota 2为例：
- en: '`EnteringMap`: The state machine will be in this state when the map is loading.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnteringMap`：地图加载时，状态机将处于此状态。'
- en: '`WaitingToStart`: The state machine will be in this state once the map is loaded
    and the players are picking their heroes. The `ReadyToStartMatch` function will
    check whether all players have selected their heroes; if they have, then the match
    can start.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitingToStart`：一旦地图加载并且玩家正在选择他们的英雄，状态机将处于此状态。`ReadyToStartMatch`函数将检查所有玩家是否已选择他们的英雄；如果是，则比赛可以开始。'
- en: '`InProgress`: The state machine will be in this state when the game is actually
    underway. The players control their heroes to farm and fight against other players.
    The `ReadyToEndMatch` function will constantly check the health of each ancient
    to see whether one of them was destroyed; if it was, then the match ends.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InProgress`：当游戏实际进行时，状态机将处于此状态。玩家控制他们的英雄进行农场和与其他玩家的战斗。`ReadyToEndMatch`函数将不断检查每个远古生命值，以查看它们是否被摧毁；如果是，则比赛结束。'
- en: '`WaitingPostMatch`: The state machine will be in this state when the game has
    ended and you are seeing the destroyed ancient and showing the final scores for
    each player.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitingPostMatch`：游戏结束时，状态机将处于此状态，您将看到被摧毁的远古和每个玩家的最终得分。'
- en: '`LeavingMap`: The state machine will be in this state when it''s unloading
    the map.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LeavingMap`：在卸载地图时，状态机将处于此状态。'
- en: '`Aborted`: The state machine will be in this state if one of the players failed
    to connect in the initial stage, therefore aborting the whole match.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Aborted`：如果其中一个玩家在初始阶段未能连接，因此中止整个比赛，状态机将处于此状态。'
- en: '**Respawning the Player**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**重新生成玩家**'
- en: When the player dies and you want to respawn it, you typically have two options.
    The first option is to reuse the same pawn instance, manually reset its state
    back to the defaults, and teleport it to the respawn location. The second option
    is to destroy the pawn and spawn a new one, which will already have its state
    reset. If you prefer the latter option, then the `AGameModeBase::RestartPlayer`
    function handles the logic of spawning a new pawn instance for a certain player
    controller for you and places it on a player start.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家死亡并且您想要重新生成它时，通常有两种选择。第一种选择是重用相同的pawn实例，手动将其状态重置为默认值，并将其传送到重生位置。第二个选择是销毁pawn并生成一个新的，它将已经重置其状态。如果您喜欢后一种选择，那么`AGameModeBase::RestartPlayer`函数将处理为某个玩家控制器生成一个新的pawn实例的逻辑，并将其放置在玩家起始点。
- en: One important thing to take into consideration is that the function spawns a
    new pawn instance only if the player controller doesn't already possess a pawn,
    so make sure to destroy the controlled pawn before calling `RestartPlayer`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一件重要事情是，该函数仅在玩家控制器尚未拥有pawn的情况下生成新的pawn实例，因此在调用`RestartPlayer`之前，请务必销毁受控pawn。
- en: 'Take a look at the following example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, we have the `OnDeath` function that takes the player
    controller of the player that died, destroys its controlled pawn, and calls the
    `RestartPlayer` function to spawn a new instance on a player start. By default,
    the player start actor used will always be the same as the player spawned the
    first time. If you want the function to spawn on a random player start, then you
    need to override the `AGameModeBase::ShouldSpawnAtStartSpot` function and force
    it to `return false`, like so:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们有`OnDeath`函数，它获取死亡玩家的玩家控制器，销毁其受控pawn，并调用`RestartPlayer`函数在玩家起始点生成一个新实例。默认情况下，使用的玩家起始点actor将始终与第一次生成玩家的玩家相同。如果要使函数在随机玩家起始点生成，则需要重写`AGameModeBase::ShouldSpawnAtStartSpot`函数并强制其返回`false`，如下所示：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code will make the game mode use a random player start instead
    of always using the same.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将使游戏模式使用随机玩家起始点，而不是始终使用相同的。
- en: Note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about the game mode, please visit [https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes](https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes)
    and [https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.html).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有关游戏模式的更多信息，请访问[https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes](https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamemodes)和[https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameMode/index.html)。
- en: Player State
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家状态
- en: The player state class stores the state of a player, such as the current score,
    kills/deaths, and coins picked up. It's mostly used in multiplayer mode to store
    the information that other clients need to know about the player, since they can't
    access its player controller. The most widely used built-in variables are `PlayerName`,
    `Score`, and `Ping`, which give you the name, score, and ping of the player, respectively.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家状态类存储玩家的状态，例如当前得分、击杀/死亡和拾取的金币。它主要用于多人模式，以存储其他客户端需要了解的有关玩家的信息，因为它们无法访问其玩家控制器。最常用的内置变量是`PlayerName`、`Score`和`Ping`，分别提供玩家的名称、得分和延迟。
- en: 'A scoreboard entry on a multiplayer shooter is a good example of how to use
    the player state, because every client needs to know the names, kills/deaths,
    and pings of all the players. The player state instance can be accessed in the
    following ways:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 多人射击游戏中的记分牌条目是使用玩家状态的一个很好的例子，因为每个客户端都需要知道所有玩家的名称、击杀/死亡和延迟。玩家状态实例可以通过以下方式访问：
- en: '**AController::PlayerState**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**AController::PlayerState**'
- en: 'This variable has the player state associated with the controller and it can
    only be accessed by the server and the owning client. The following example will
    demonstrate how to use the variable:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此变量与控制器相关联的玩家状态，只能由服务器和拥有的客户端访问。以下示例将演示如何使用该变量：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**AController::GetPlayerState()**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**AController::GetPlayerState()**'
- en: 'This function returns the player state associated with the controller and it
    can only be accessed by the server and the owning client. This function also has
    a templated version, so you can cast it to your own custom player state class.
    The following examples will demonstrate how to use the default and template versions
    of this function:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回与控制器相关联的玩家状态，只能由服务器和拥有的客户端访问。该函数还有一个模板版本，因此您可以将其转换为自定义的玩家状态类。以下示例将演示如何使用该函数的默认版本和模板版本。
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**APawn::GetPlayerState()**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**APawn::GetPlayerState()**'
- en: 'This function returns the player state associated with the controller that
    is possessing the pawn and it can be accessed by the server and the clients. This
    function also has a templated version, so you can cast it to your own custom player
    state class. The following examples will demonstrate how to use the default and
    template versions of this function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回与控制器相关联的玩家状态，可以由服务器和客户端访问。该函数还有一个模板版本，因此您可以将其转换为自定义的玩家状态类。以下示例将演示如何使用该函数的默认版本和模板版本：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code demonstrates the two ways you can use the `GetPlayerState`
    function. You can use the default `APlayerState` version or the template version
    that casts automatically for you.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码演示了您可以使用`GetPlayerState`函数的两种方式。您可以使用默认的`APlayerState`版本，也可以使用自动为您转换的模板版本。
- en: '**AGameState::PlayerArray**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**AGameState::PlayerArray**'
- en: 'This variable stores the player state instances for each player and it can
    be accessed on the server and the clients. The following example will demonstrate
    how to use this variable:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此变量存储每个玩家的玩家状态实例，可以在服务器和客户端上访问。以下示例将演示如何使用此变量：
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To help you understand these concepts better, we can use Dota 2 again as an
    example. The player state would have at least the following variables:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您更好地理解这些概念，我们可以再次以Dota 2为例。玩家状态至少应具有以下变量：
- en: '**Name**: The name of the player'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称**：玩家的名称'
- en: '**Hero**: The selected hero'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**英雄**：所选英雄'
- en: '**Health**: The health of the hero'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**生命值**：英雄的生命值'
- en: '**Mana**: The mana of the hero'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**法力**：英雄的法力'
- en: '**Stats**: The hero stats'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**统计**：英雄统计'
- en: '**Level**: The level the hero is currently in'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**等级**：英雄当前所在的等级'
- en: '**Kill / Death / Assist**: The kill/death/assist ratio for the player'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**击杀/死亡/助攻**：玩家的击杀/死亡/助攻比例'
- en: Note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about the player state, please visit [https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.html).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有关玩家状态的更多信息，请访问[https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/APlayerState/index.html)。
- en: Game State
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏状态
- en: The game state class stores the state of the game, including the match's elapsed
    time and the score required to win the game. It's mostly used in multiplayer mode
    to store the information that other clients need to know about the game, since
    they can't access the game mode. The most widely used variable is `PlayerArray`,
    which is an array with the player state of every connected client. A scoreboard
    on a multiplayer shooter is a good example of how to use the game state, because
    every client needs to know how many kills are required to win and also the name
    and ping of each player.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏状态类存储游戏的状态，包括比赛经过的时间和赢得比赛所需的得分。它主要用于多人模式，以存储其他客户端需要了解的有关游戏的信息，因为它们无法访问游戏模式。最常用的变量是`PlayerArray`，它是一个包含每个连接客户端的玩家状态的数组。多人射击游戏中的记分牌是使用游戏状态的一个很好的例子，因为每个客户端都需要知道赢得比赛所需的击杀数，以及每个玩家的名称和延迟。
- en: 'The game state instance can be accessed in the following ways:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏状态实例可以通过以下方式访问：
- en: '**UWorld::GetGameState()**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**UWorld::GetGameState()**'
- en: 'This function returns the game state associated with the world and can be accessed
    on the server and the clients. This function also has a templated version, so
    you can cast it to your own custom game state class. The following examples will
    demonstrate how to use the default and template versions of this function:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回与世界关联的游戏状态，并且可以在服务器和客户端上访问。此函数还有一个模板化版本，因此您可以将其转换为自己的自定义游戏状态类。以下示例将演示如何使用此函数的默认和模板版本：
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**AGameModeBase::GameState**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: AGameModeBase::GameState
- en: 'This variable has the game state associated with the game mode and it can only
    be accessed on the server. The following example will demonstrate how to use the variable:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此变量具有与游戏模式关联的游戏状态，并且只能在服务器上访问。以下示例将演示如何使用该变量：
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**AGameModeBase::GetGameState()**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: AGameModeBase::GetGameState()
- en: 'This function returns the game state associated with the game mode and it can
    only be accessed on the server. This function also has a templated version, so
    you can cast it to your own custom game state class. The following examples will
    demonstrate how to use the default and template versions of this function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回与游戏模式关联的游戏状态，只能在服务器上访问。此函数还有一个模板化版本，因此您可以将其转换为自己的自定义游戏状态类。以下示例将演示如何使用此函数的默认和模板版本：
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To help you understand these concepts better, we can use Dota 2 again as an
    example. The game state would have the following variables:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您更好地理解这些概念，我们可以再次以Dota 2为例。游戏状态将具有以下变量：
- en: '**Elapsed Time**: How long the match has been going on for'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'Elapsed Time: 比赛进行了多长时间'
- en: '**Radiant Kills**: How many Dire heroes the Radiant team has killed'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'Radiant Kills: Radiant团队杀死了多少Dire英雄'
- en: '**Dire Kills**: How many Radiant heroes the Dire team has killed'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'Dire Kills: Dire团队杀死了多少Radiant英雄'
- en: '**Day/Night Timer**: Used to determine whether it is day or night'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 'Day/Night Timer: 用于确定是白天还是黑夜'
- en: Note
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about the game state, please visit [https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamestate](https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamestate)
    and [https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.html).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有关游戏状态的更多信息，请访问[https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamestate](https://docs.unrealengine.com/en-US/Gameplay/Framework/GameMode/#gamestate)和[https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AGameState/index.html)。
- en: Useful Built-in Functionality
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的内置功能
- en: 'Unreal Engine 4 comes with a lot of useful functionality built in. Here are
    some examples of some functions and a component that will be useful when developing
    your game:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 4自带许多有用的功能。以下是一些函数和组件的示例，在开发游戏时将会很有用：
- en: '**void AActor::EndPlay(const EEndPlayReason::Type EndPlayReason)**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: AActor::EndPlay(const EEndPlayReason::Type EndPlayReason) void
- en: 'This function is called when the actor has stopped playing, which is the opposite
    of the `BeginPlay` function. You have the `EndPlayReason` parameter, which tells
    you why the actor stopped playing (if it was destroyed, if you stopped PIE, and
    so on). Take a look at the following example, which prints to the screen the fact
    that the actor has stopped playing:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当角色停止播放时调用此函数，这与`BeginPlay`函数相反。您有`EndPlayReason`参数，它告诉您角色停止播放的原因（如果被销毁，如果您停止了PIE等）。看下面的例子，它打印到屏幕上角色停止播放的事实：
- en: '[PRE24]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**void ACharacter::Landed(const FHitResult& Hit)**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ACharacter::Landed(const FHitResult& Hit) void
- en: 'This function is called when a player lands on a surface after being in the
    air. Take a look at the following example, which plays a sound when a player lands
    on a surface:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家从空中着陆时调用此函数。看下面的例子，当玩家着陆时播放声音：
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**bool UWorld::ServerTravel(const FString& FURL, bool bAbsolute, bool bShouldSkipGameNotify)**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: UWorld::ServerTravel(const FString& FURL, bool bAbsolute, bool bShouldSkipGameNotify)
- en: This function will make the server load a new map and bring all of the connected
    clients along with it. This is different from using other methods that load maps,
    such as the `UGameplayStatics::OpenLevel` function, because it won't bring the
    clients along; it will just load the map on the server and disconnect the clients.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将使服务器加载新地图并将所有连接的客户端一起带来。这与使用其他加载地图的方法不同，例如`UGameplayStatics::OpenLevel`函数，因为它不会带上客户端；它只会在服务器上加载地图并断开客户端。
- en: 'One important thing to take into consideration is that server travel only works
    properly in the packaged version, so it won''t bring the clients along when playing
    in the editor. Take a look at the following example, which gets the current map
    name and uses server travel to reload it and bring along the connected clients:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一件重要事情是，服务器旅行只在打包版本中正常工作，因此在编辑器中游玩时不会带上客户端。看下面的例子，它获取当前地图名称并使用服务器旅行重新加载它并带上连接的客户端：
- en: '[PRE26]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**void TArray::Sort(const PREDICATE_CLASS& Predicate)**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: TArray::Sort(const PREDICATE_CLASS& Predicate) void
- en: 'The `TArray` data structure comes with the `Sort` function, which allows you
    to sort the values of an array by using a `lambda` function that returns whether
    value `A` should be ordered first, followed by value `B`. Take a look at the following
    example, which sorts an integer array from the smallest value to the highest:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`TArray`数据结构带有`Sort`函数，它允许您使用返回值`A`是否应该首先排序，然后是值`B`的`lambda`函数来对数组的值进行排序。看下面的例子，它将整数数组从最小值排序到最大值：'
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code will sort the `SortTest` array with the values [43, 1, 23,
    8] from smallest to highest [1, 8, 23, 43].
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将对`SortTest`数组进行排序，值为[43, 1, 23, 8]，从最小到最大[1, 8, 23, 43]。
- en: '**void AActor::FellOutOfWorld(const UDamageType& DmgType)**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: AActor::FellOutOfWorld(const UDamageType& DmgType) void
- en: 'In Unreal Engine 4, there is a concept called `Kill Z`, which is a plane on
    a certain value in `Z` (set in the `World Settings` panel), and if an actor goes
    below that `Z` value, it will call the `FellOutOfWorld` function, which, by default,
    destroys the actor. Take a look at the following example, which prints to the
    screen the fact that the actor fell out of the world:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎4中，有一个称为“Kill Z”的概念，它是在“Z”中的某个值上的一个平面（在“世界设置”面板中设置），如果一个角色低于该“Z”值，它将调用“FellOutOfWorld”函数，默认情况下，销毁角色。看一下以下示例，它在屏幕上打印出角色掉出世界的事实：
- en: '[PRE28]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**URotatingMovementComponent**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**URotatingMovementComponent**'
- en: 'This component rotates the owning actor along time with a certain rate on each
    axis, defined in the `RotationRate` variable. To use it, you need to include the
    following header:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件会以每个轴上的一定速率沿着时间旋转拥有的角色，速率由“RotationRate”变量定义。要使用它，您需要包含以下头文件：
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Declare the component variable:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 声明组件变量：
- en: '[PRE30]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And finally, initialize it in the actor constructor, like so:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在角色构造函数中初始化它，如下所示：
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, `RotationRate` is set to rotate `90` degrees per second
    on the `Yaw` axis.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，“RotationRate”被设置为在“偏航”轴上每秒旋转“90”度。
- en: 'Exercise 18.02: Making a Simple Multiplayer Pickup Game'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习18.02：制作一个简单的多人拾取游戏
- en: 'In this exercise, we''re going to create a new C++ project that uses the Third
    Person template and we''re going to add the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个使用第三人称模板的新C++项目，并添加以下内容：
- en: On the owning client, the player controller creates and adds to the viewport
    a UMG widget that, for each player, displays the score, sorted from highest to
    lowest, and how many pickups it has collected.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在拥有客户端上，玩家控制器创建并添加到视口一个UMG小部件，对于每个玩家，按从高到低排序显示分数以及收集了多少拾取物。
- en: Create a simple pickup actor class that gives 10 points to the player that picked
    it up. The pickup will also rotate 90 degrees per second on the `Yaw` axis.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的拾取物角色类，为拾取到它的玩家提供10分。拾取物还会在“偏航”轴上每秒旋转90度。
- en: Set `Kill Z` to `-500` and make the player respawn and lose 10 points every
    time he falls from the world.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“Kill Z”设置为“-500”，并使玩家在从世界中掉落时重生并失去10分。
- en: The game will end when there are no more pickups available. Once the game ends,
    all characters will be destroyed and, after 5 seconds, the server will do a server
    travel call to reload the same map and bring along the connected clients.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有更多的拾取物可用时，游戏将结束。游戏结束后，所有角色将被销毁，并且在5秒后，服务器将进行服务器旅行调用以重新加载相同的地图并带上连接的客户端。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习：
- en: Create a new `Third Person` template project using `C++` called `Pickups` and
    save it to a location of your choosing.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用C++创建一个名为“Pickups”的新“第三人称”模板项目，并将其保存到您选择的位置。
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目创建后，应该打开编辑器以及Visual Studio解决方案。
- en: 'Now, let''s create the new C++ classes we''re going to use:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们将要使用的新的C++类：
- en: Create the `Pickup` class that is derived from `Actor`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从“Actor”派生的“Pickup”类。
- en: Create the `PickupsGameState` class that is derived from `GameState`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从“GameState”派生的“PickupsGameState”类。
- en: Create the `PickupsPlayerState` class that is derived from `PlayerState`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从“PlayerState”派生的“PickupsPlayerState”类。
- en: Create the `PickupsPlayerController` class that is derived from `PlayerController`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从“PlayerController”派生的“PickupsPlayerController”类。
- en: Close the editor and open Visual Studio.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器并打开Visual Studio。
- en: Next, let's work on the `Pickup` class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来处理“Pickup”类。
- en: Open `Pickup.h` and clear all existing functions.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“Pickup.h”并清除所有现有函数。
- en: 'Declare the protected `Static Mesh` component called `Mesh`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的“Static Mesh”组件称为“Mesh”：
- en: '[PRE32]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Declare the protected rotating movement component called `RotatingMovement`:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的旋转运动组件称为“RotatingMovement”：
- en: '[PRE33]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Declare the protected `PickupSound` variable:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的“PickupSound”变量：
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Declare the protected constructor and `BeginPlay` override:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的构造函数和“BeginPlay”重写：
- en: '[PRE35]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Declare the protected `OnBeginOverlap` function:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的“OnBeginOverlap”函数：
- en: '[PRE36]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Open `Pickup.cpp` and include `PickupsCharacter.h`, `PickupsGameState.h`, `StaticMeshComponent.h`,
    and `RotatingMovementComponent.h`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“Pickup.cpp”并包括“PickupsCharacter.h”、“PickupsGameState.h”、“StaticMeshComponent.h”和“RotatingMovementComponent.h”：
- en: '[PRE37]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the constructor, initialize the `Static Mesh` component to overlap with
    everything and call the `OnBeginOverlap` function when it''s overlapped:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，将“静态网格”组件初始化为与所有内容重叠，并在重叠时调用“OnBeginOverlap”函数：
- en: '[PRE38]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Still in the constructor, initialize the rotating movement component to rotate
    `90` degrees per second on the `Yaw` axis:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在构造函数中，初始化旋转运动组件，使其在“偏航”轴上每秒旋转“90”度：
- en: '[PRE39]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To finalize the constructor, enable replication and disable the `Tick` function:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成构造函数，启用复制并禁用“Tick”函数：
- en: '[PRE40]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Implement the `BeginPlay` function, which binds the begin overlap event to
    the `OnBeginOverlap` function:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现“BeginPlay”函数，将开始重叠事件绑定到“OnBeginOverlap”函数：
- en: '[PRE41]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Implement the `OnBeginOverlap` function, which checks whether the character
    is valid and has authority, removes the pickup on the game state, plays the pickup
    sound on the owning client, adds `10` points and the pickup to the character.
    Once all of that is done, the pickup destroys itself.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现“OnBeginOverlap”函数，检查角色是否有效并具有权限，在游戏状态上移除拾取物，在拥有客户端上播放拾取声音，添加“10”分和拾取物给角色。完成所有这些后，拾取物将销毁自身。
- en: '[PRE42]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Next, we're going to work on the `PickupsGameState` class.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理“PickupsGameState”类。
- en: 'Open `PickupsGameState.h` and declare the protected replicated integer variable
    `PickupsRemaining`, which tells all clients how many pickups remain in the level:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“PickupsGameState.h”并声明受保护的复制整数变量“PickupsRemaining”，告诉所有客户端关卡中剩余多少拾取物：
- en: '[PRE43]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Declare the protected override for the `BeginPlay` function:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的“BeginPlay”函数的重写：
- en: '[PRE44]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Declare the protected `GetPlayerStatesOrderedByScore` function:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的“GetPlayerStatesOrderedByScore”函数：
- en: '[PRE45]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Implement the public `RemovePickup` function, which removes one pickup from
    the `PickupsRemaining` variable:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现公共的`RemovePickup`函数，该函数从`PickupsRemaining`变量中移除一个道具：
- en: '[PRE46]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement the public `HasPickups` function, which returns whether there are
    still pickups remaining:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现公共的`HasPickups`函数，该函数返回是否仍有剩余的道具：
- en: '[PRE47]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Open `PickupsGameState.cpp` and include `Pickup.h`, `GameplayStatics.h`, `UnrealNetwork.h`,
    and `PlayerState.h`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PickupsGameState.cpp`并包括`Pickup.h`，`GameplayStatics.h`，`UnrealNetwork.h`和`PlayerState.h`：
- en: '[PRE48]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Implement the `GetLifetimeReplicatedProps` function and make the `PickupRemaining`
    variable replicate to all clients:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`GetLifetimeReplicatedProps`函数，并使`PickupRemaining`变量复制到所有客户端：
- en: '[PRE49]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Implement the `BeginPlay` override function and set the value of `PickupsRemaining`
    by getting all of the pickups in the world:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`BeginPlay`覆盖函数，并通过获取世界中的所有道具来设置`PickupsRemaining`的值：
- en: '[PRE50]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Implement the `GetPlayerStatesOrderedByScore` function, which duplicates the
    `PlayerArray` variable and sorts it so that the players with the highest scores
    show up first:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`GetPlayerStatesOrderedByScore`函数，该函数复制`PlayerArray`变量并对其进行排序，以便得分最高的玩家首先出现：
- en: '[PRE51]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Next, let's work on the `PickupsPlayerState` class.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来处理`PickupsPlayerState`类。
- en: 'Open `PickupsPlayerState.h`, and declare the protected replicated integer variable
    `Pickups`, which indicates how many pickups a player has collected:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PickupsPlayerState.h`，并声明受保护的复制整数变量`Pickups`，该变量表示玩家收集了多少个道具：
- en: '[PRE52]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Implement the public `AddPickup` function, which adds one pickup to the `Pickups`
    variable:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现公共的`AddPickup`函数，该函数将一个道具添加到`Pickups`变量：
- en: '[PRE53]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Open `PickupsPlayerState.cpp` and include `UnrealNetwork.h`:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PickupsPlayerState.cpp`并包括`UnrealNetwork.h`：
- en: '[PRE54]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Implement the `GetLifetimeReplicatedProps` function and make the `Pickups`
    variable replicate to all clients:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`GetLifetimeReplicatedProps`函数，并使`Pickups`变量复制到所有客户端：
- en: '[PRE55]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Next, let's work on the `PickupsPlayerController` class.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来处理`PickupsPlayerController`类。
- en: 'Open `PickupsPlayerController.h` and declare the protected `ScoreboardMenuClass`
    variable, which enables the UMG widget we want to use for our scoreboard to be
    selected:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PickupsPlayerController.h`并声明受保护的`ScoreboardMenuClass`变量，该变量允许我们选择用于记分牌的UMG小部件：
- en: '[PRE56]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Declare the protected `ScoreboardMenu` variable, which stores the scoreboard
    UMG widget instance we create on the `BeginPlay` function variable:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的`ScoreboardMenu`变量，该变量存储我们在`BeginPlay`函数中创建的记分牌UMG小部件实例：
- en: '[PRE57]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Declare the protected override for the `BeginPlay` function:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`BeginPlay`函数的受保护覆盖：
- en: '[PRE58]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Open `PickupsPlayerController.cpp` and include `UserWidget.h`:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PickupsPlayerController.cpp`并包括`UserWidget.h`：
- en: '[PRE59]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Implement the `BeginPlay` override function, which, for the owning client,
    creates and adds the scoreboard UMG widget to the viewport:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`BeginPlay`覆盖函数，对于拥有的客户端，创建并将记分牌UMG小部件添加到视口：
- en: '[PRE60]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, let''s edit the `PickupsGameMode` class:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编辑`PickupsGameMode`类。
- en: 'Open `PickupsGameMode.h` and replace the `include` for `GameModeBase.h` with
    `GameMode.h`:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PickupsGameMode.h`并用`GameMode.h`替换`GameModeBase.h`的`include`：
- en: '[PRE61]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Make the class derive from `AGameMode` instead of `AGameModeBase`:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使该类从`AGameMode`派生而不是`AGameModeBase`：
- en: '[PRE62]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Declare the protected game state variable `MyGameState`, which holds the instance
    to the `APickupsGameState` class:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的游戏状态变量`MyGameState`，该变量保存`APickupsGameState`类的实例：
- en: '[PRE63]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Move the constructor to the protected area.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构造函数移动到受保护区域。
- en: 'Declare the protected override for the `BeginPlay` function:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`BeginPlay`函数的受保护覆盖：
- en: '[PRE64]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Declare the protected override for the `ShouldSpawnAtStartSpot` function:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`ShouldSpawnAtStartSpot`函数的受保护覆盖：
- en: '[PRE65]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Declare the protected overrides for the match state functions of the game mode:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明游戏模式的比赛状态函数的受保护覆盖：
- en: '[PRE66]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Declare the protected `RestartMap` function:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的`RestartMap`函数：
- en: '[PRE67]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Open `PickupsGameMode.cpp` and include `GameplayStatics.h`, `PickupGameState.h`,
    `Engine/World.h`, `TimerManager.h`, and `Engine.h`:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PickupsGameMode.cpp`并包括`GameplayStatics.h`，`PickupGameState.h`，`Engine/World.h`，`TimerManager.h`和`Engine.h`：
- en: '[PRE68]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Implement the `BeginPlay` override function, which stores the `APickupGameState`
    instance:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`BeginPlay`覆盖函数，该函数存储`APickupGameState`实例：
- en: '[PRE69]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Implement the `ShouldSpawnAtStartSpot` override function, which indicates that
    we want the players to respawn on a random player start and not always on the
    same one:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`ShouldSpawnAtStartSpot`覆盖函数，该函数指示我们希望玩家重新生成在一个随机的玩家起始点上，而不总是在同一个上：
- en: '[PRE70]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Implement the `HandleMatchHasStarted` override function, which prints to the
    screen, informing players that the game has started:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`HandleMatchHasStarted`覆盖函数，该函数向屏幕打印信息，通知玩家比赛已经开始：
- en: '[PRE71]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Implement the `HandleMatchHasEnded` override function, which prints to the
    screen, informing players that the game has ended, destroys all characters, and
    schedules a timer to restart the map:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`HandleMatchHasEnded`覆盖函数，该函数向屏幕打印信息，通知玩家比赛已经结束，销毁所有角色，并安排一个计时器来重新开始地图：
- en: '[PRE72]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Implement the `ReadyToStartMatch_Implementation` override function, which indicates
    that the match can start straight away:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`ReadyToStartMatch_Implementation`覆盖函数，该函数指示比赛可以立即开始：
- en: '[PRE73]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Implement the `ReadyToEndMatch_Implementation` override function, which indicates
    that the match ends when the game state has no more pickups remaining:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`ReadyToEndMatch_Implementation`覆盖函数，该函数指示当游戏状态没有剩余道具时比赛结束：
- en: '[PRE74]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Implement the `RestartMap` function, which indicates that the server travels
    to the same level and brings all clients along (*only in the packaged version*):'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`RestartMap`函数，该函数指示服务器前往相同的级别并带着所有客户端一起（*仅在打包版本中*）：
- en: '[PRE75]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now, let's edit the `PickupsCharacter` class.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编辑`PickupsCharacter`类。
- en: 'Open `PickupsCharacter.h` and declare the protected sound variables for falling
    and landing:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PickupsCharacter.h`并声明下落和着陆的受保护声音变量：
- en: '[PRE76]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Declare the protected `override` functions:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明受保护的`override`函数：
- en: '[PRE77]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Declare the public functions that add scores and pickups to the player state:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明添加分数和道具到玩家状态的公共函数：
- en: '[PRE78]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Declare the public client RPC that plays a sound on the owning client:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明在拥有的客户端上播放声音的公共客户端RPC：
- en: '[PRE79]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Open `PickupsCharacter.cpp` and include `PickupsPlayerState.h`, `GameMode.h`,
    and `GameplayStatics.h`:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PickupsCharacter.cpp`并包括`PickupsPlayerState.h`，`GameMode.h`和`GameplayStatics.h`：
- en: '[PRE80]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Implement the `EndPlay` override function, which plays the fall sound if the
    character was destroyed:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`EndPlay`覆盖函数，如果角色被销毁，则播放跌落声音：
- en: '[PRE81]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Implement the `Landed` override function, which plays the landed sound:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Landed`覆盖函数，该函数播放着陆声音：
- en: '[PRE82]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Implement the `FellOutOfWorld` override function, which stores the controller,
    removes `10` points from the score, destroys the character (which makes the controller
    invalid), and tells the game mode to restart the player using the previous controller:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`FellOutOfWorld`覆盖函数，该函数存储控制器，从分数中减去`10`分，销毁角色（使控制器无效），并告诉游戏模式使用先前的控制器重新启动玩家：
- en: '[PRE83]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Implement the `AddScore` function, which adds a score to the `Score` variable
    in the player state:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`AddScore`函数，该函数将分数添加到玩家状态中的`Score`变量中：
- en: '[PRE84]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Implement the `AddPickup` function, which adds a pickup to the `Pickup` variable
    in our custom player state:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`AddPickup`函数，将拾取物品添加到我们自定义玩家状态中的`Pickup`变量中：
- en: '[PRE85]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Implement the `ClientPlaySound2D_Implementation` function, which plays a sound
    on the owning client:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`ClientPlaySound2D_Implementation`函数，该函数在拥有客户端上播放声音：
- en: '[PRE86]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Open `Pickups.Build.cs` and add the `UMG` module to `PublicDependencyModuleNames`,
    like so:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Pickups.Build.cs`并将`UMG`模块添加到`PublicDependencyModuleNames`中，如下所示：
- en: '[PRE87]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: If you try to compile and get errors from adding the new module, then clean
    and recompile your project. If that doesn't work, try restarting your IDE.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试编译并从添加新模块中获得错误，则清理并重新编译您的项目。如果这样不起作用，请尝试重新启动您的IDE。
- en: Compile and run the code until the editor loads.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行代码，直到编辑器加载完成。
- en: First, let's import the sound files.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入声音文件。
- en: In `Content Browser`, create and go to the `Content\Sounds` folder.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`内容浏览器`中，创建并转到`Content\Sounds`文件夹。
- en: Import `Pickup.wav`, `Footstep.wav`, `Jump.wav`, `Land.wav`, and `Fall.wav`
    from the `Exercise18.02\Assets` folder.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Exercise18.02\Assets`文件夹导入`Pickup.wav`，`Footstep.wav`，`Jump.wav`，`Land.wav`和`Fall.wav`。
- en: Save the new files.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存新文件。
- en: Next, let's add the `Play Sound` anim notifies to some of the character's animations.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们向一些角色的动画中添加`Play Sound`动画通知。
- en: Open `ThirdPersonJump_Start animation`, located in `Content\Mannequin\Animations`,
    and add a `Play Sound` anim notify at frame `0` using the `Jump` sound.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`Content\Mannequin\Animations`中的`ThirdPersonJump_Start`动画，并在帧`0`处使用`Jump`声音添加一个`Play
    Sound`动画通知。
- en: Save and close `ThirdPersonJump_Start`.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`ThirdPersonJump_Start`。
- en: Open the `ThirdPersonRun` animation, located in `Content\Mannequin\Animations`,
    and add two `Play Sound` anim notifies using the `Footstep` sound at time 0.24
    sec and 0.56 sec.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`Content\Mannequin\Animations`中的`ThirdPersonRun`动画，并在0.24秒和0.56秒处添加两个`Play
    Sound`动画通知，使用`Footstep`声音。
- en: Save and close `ThirdPersonRun`.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`ThirdPersonRun`。
- en: Open the `ThirdPersonWalk` animation, located in `Content\Mannequin\Animations`,
    and add two `Play Sound` anim notifies using the `Footstep` sound at time 0.24
    sec and 0.79 sec.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`Content\Mannequin\Animations`中的`ThirdPersonWalk`动画，并在0.24秒和0.79秒处添加两个`Play
    Sound`动画通知，使用`Footstep`声音。
- en: Save and close `ThirdPersonWalk`.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`ThirdPersonWalk`。
- en: Now, let's set the sounds for the character blueprint.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为角色蓝图设置声音。
- en: Open the `ThirdPersonCharacter` blueprint, located in `Content\ThirdPersonCPP\Blueprints`,
    and set the `Fall` `Sound` and `Land` `Sound` to use the sounds `Fall` and `Land`,
    respectively.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于`Content\ThirdPersonCPP\Blueprints`中的`ThirdPersonCharacter`蓝图，并将`Fall` `Sound`和`Land`
    `Sound`设置为分别使用`Fall`和`Land`的声音。
- en: Save and close `ThirdPersonCharacter`.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`ThirdPersonCharacter`。
- en: Now, let's create the blueprint for the pickup.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为拾取物品创建蓝图。
- en: Create and open the `Content\Blueprints` folder.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并打开`Content\Blueprints`文件夹。
- en: Create a new blueprint called `BP_Pickup` that is derived from the `Pickup`
    class and open it.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`BP_Pickup`的新蓝图，该蓝图派生自`Pickup`类并打开它。
- en: 'Configure the `Static Mesh` component in the following way:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以以下方式配置`Static Mesh`组件：
- en: '[PRE88]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To display the Engine content, you need to go to View Options on the bottom
    right of the dropdown for the static mesh and make sure the Show Engine Content
    flag is set to true.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示引擎内容，您需要转到静态网格下拉菜单右下角的视图选项，并确保将显示引擎内容标志设置为true。
- en: Set the `Pickup` `Sound` variable to use the `Pickup` sound.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Pickup` `Sound`变量设置为使用`Pickup`声音。
- en: Save and close `BP_Pickup`.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`BP_Pickup`。
- en: Next, let's create the scoreboard UMG widgets.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建记分牌UMG小部件。
- en: Create and go to the `Content\UI` folder.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并转到`Content\UI`文件夹。
- en: 'Create a new widget blueprint called `UI_Scoreboard_Header`:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UI_Scoreboard_Header`的新小部件蓝图：
- en: Add a text block called `tbName` to the root canvas panel with `Is Variable`
    set to `true`, `Size To Content` set to `true`, `Text` set to `Player Name`, and
    `Color and Opacity` set to use the color `green`.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个名为`tbName`的文本块添加到根画布面板，将`Is Variable`设置为`true`，`Size To Content`设置为`true`，`Text`设置为`Player
    Name`，`Color and Opacity`设置为使用颜色`green`。
- en: Add a text block called `tbScore` to the root canvas panel with `Is Variable`
    set to `true`, `Position X = 500`, `Alignment = 1.0, 0.0`, `Size To Content` set
    to `true`, `Text` set to `Score`, and `Color and Opacity` set to use the color
    `green`.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个名为`tbScore`的文本块添加到根画布面板，将`Is Variable`设置为`true`，`Position X = 500`，`Alignment
    = 1.0, 0.0`，`Size To Content`设置为`true`，`Text`设置为`Score`，`Color and Opacity`设置为使用颜色`green`。
- en: Add a text block called `tbPickups` to the root canvas panel with `Is Variable`
    set to `true`, `Position X = 650`, `Alignment = 1.0, 0.0`, `Size To Content` set
    to `true`, `Text` set to `Pickups`, and `Color and Opacity` set to use the color
    `green`.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个名为`tbPickups`的文本块添加到根画布面板，将`Is Variable`设置为`true`，`Position X = 650`，`Alignment
    = 1.0, 0.0`，`Size To Content`设置为`true`，`Text`设置为`Pickups`，`Color and Opacity`设置为使用颜色`green`。
- en: From the `Hierarchy` panel, select the three new text blocks and copy them.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`层次结构`面板中选择三个新的文本块并复制它们。
- en: Save and close `UI_Scoreboard_Header`.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`UI_Scoreboard_Header`。
- en: Go back to `Content\UI`, create a new UMG widget called `UI_Scoreboard_Entry`,
    and open it.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`Content\UI`，创建一个名为`UI_Scoreboard_Entry`的新UMG小部件，并打开它。
- en: Paste the copied text blocks on the root canvas panel and change them to be
    `white` instead of `green` and make them all variables.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将复制的文本块粘贴到根画布面板上，并将它们更改为`white`而不是`green`，并将它们全部设置为变量。
- en: 'Go to the `Graph` section and create the `Player State` variable with the following
    configuration:![Figure 18.3: Creating the Player State variable'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Graph`部分，并创建以下配置的`Player State`变量：![图18.3：创建Player State变量
- en: '](img/B16183_18_03.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_18_03.jpg)'
- en: 'Figure 18.3: Creating the Player State variable'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.3：创建Player State变量
- en: 'Go back to the Designer section and create a bind for `tbName` that does the following:![Figure
    18.4: Displaying the player name'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到设计师部分，并为`tbName`创建一个绑定，执行以下操作：![图18.4：显示玩家名称
- en: '](img/B16183_18_04.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_18_04.jpg)'
- en: 'Figure 18.4: Displaying the player name'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.4：显示玩家名称
- en: Note
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3pCk9Nt](https://packt.live/3pCk9Nt).'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到完整分辨率的前一个截图，以便更好地查看：[https://packt.live/3pCk9Nt](https://packt.live/3pCk9Nt)。
- en: 'Create a bind for `tbScore` that does the following:![Figure 18.5: Displaying
    the player score'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`tbScore`创建一个绑定，执行以下操作：![图18.5：显示玩家得分
- en: '](img/B16183_18_05.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_18_05.jpg)'
- en: 'Figure 18.5: Displaying the player score'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.5：显示玩家得分
- en: Note
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3nuckYv](https://packt.live/3nuckYv).'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到完整分辨率的前一个截图，以便更好地查看：[https://packt.live/3nuckYv](https://packt.live/3nuckYv)。
- en: 'Create a bind for `tbPickups` that does the following:![Figure 18.6: Displaying
    the pickups count'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`tbPickups`创建一个绑定，执行以下操作：![图18.6：显示拾取物计数
- en: '](img/B16183_18_06.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_18_06.jpg)'
- en: 'Figure 18.6: Displaying the pickups count'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.6：显示拾取物计数
- en: Note
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/36pEGMz](https://packt.live/36pEGMz).'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到完整分辨率的前一个截图，以便更好地查看：[https://packt.live/36pEGMz](https://packt.live/36pEGMz)。
- en: 'Create a pure function called `Get Typeface` that does the following:![Figure
    18.7: Determining whether the entry should be displayed in bold or regular'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Get Typeface`的纯函数，执行以下操作：![图18.7：确定条目是否应以粗体或常规显示
- en: '](img/B16183_18_07.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_18_07.jpg)'
- en: 'Figure 18.7: Determining whether the entry should be displayed in bold or regular'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.7：确定条目是否应以粗体或常规显示
- en: Note
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/2JW9Zam](https://packt.live/2JW9Zam).'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到完整分辨率的前一个截图，以便更好地查看：[https://packt.live/2JW9Zam](https://packt.live/2JW9Zam)。
- en: In the preceding code, we use a select node, which can be created by dragging
    a wire from the return value and releasing it on an empty space, and type "select"
    on the filter. From there, we pick the select node from the list. In this specific
    function we use the select node to pick the name of the typeface we're going to
    use, so it should return `Regular` if the player state's pawn is not the same
    as the pawn that owns the widget and `Bold` if it is. We do this to highlight
    in bold the player state entry so that the player knows what their entry is.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用了选择节点，可以通过从返回值拖动线并将其释放到空白处，然后在过滤器上键入“select”来创建。从那里，我们从列表中选择了选择节点。在这个特定的函数中，我们使用选择节点来选择我们将要使用的字体的名称，因此如果玩家状态的pawn与拥有小部件的pawn不同，它应该返回`Regular`，如果相同则返回`Bold`。我们这样做是为了以粗体突出显示玩家状态条目，以便玩家知道他们的条目是什么。
- en: 'Implement `Event Construct` in the following way:![Figure 18.8: The Event Graph
    that sets the text for the name, score, and pickups count'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以以下方式实现`Event Construct`：![图18.8：设置名称、得分和拾取物计数的事件图
- en: '](img/B16183_18_08.jpg)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_18_08.jpg)'
- en: 'Figure 18.8: The Event Graph that sets the text for the name, score, and pickups
    count'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.8：设置名称、得分和拾取物计数的事件图
- en: Note
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/2JOdP58](https://packt.live/2JOdP58).'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到完整分辨率的前一个截图，以便更好地查看：[https://packt.live/2JOdP58](https://packt.live/2JOdP58)。
- en: In the preceding code, we set the font for `tbName`, `tbScore`, and `tbPickups`
    to use the `Bold` typeface to highlight which scoreboard entry is relative to
    the player of the current client. For the remainder of the players, use the `Regular` typeface.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们将`tbName`、`tbScore`和`tbPickups`的字体设置为使用`Bold`字体，以突出显示当前客户端玩家的记分板条目。对于其余的玩家，请使用`Regular`字体。
- en: Save and close `UI_Scoreboard_Entry`.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭`UI_Scoreboard_Entry`。
- en: Go back to `Content\UI` and then create a new UMG widget called `UI_Scoreboard`
    and open it.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`Content\UI`，然后创建一个名为`UI_Scoreboard`的新UMG小部件并打开它。
- en: Add a vertical box called `vbScoreboard` to the root canvas panel with `Size
    To Content` enabled.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个名为`vbScoreboard`的垂直框添加到根画布面板，并启用`Size To Content`。
- en: Add a text block to `vbScoreboard` called `tbGameInfo` that has the `Text` value
    defaulted to `Game Info`.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`vbScoreboard`添加一个文本块，名为`tbGameInfo`，其`Text`值默认为`Game Info`。
- en: Go to the `Graph` section and create a new variable called `Game State` of the
    `Pickups Game State` type.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`Graph`部分，并创建一个名为`Game State`的`Pickups Game State`类型的新变量。
- en: 'Implement `Event Construct` in the following way:![Figure 18.9: The Event Construct
    that sets a timer to update'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以以下方式实现`Event Construct`：![图18.9：设置定时器以每0.5秒更新
- en: the scoreboard every 0.5 seconds
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 每0.5秒更新一次记分板
- en: '](img/B16183_18_09.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_18_09.jpg)'
- en: 'Figure 18.9: The Event Construct that sets a timer to update the scoreboard
    every 0.5 seconds'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.9：设置每0.5秒更新记分板的事件构造
- en: Note
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3kemyu0](https://packt.live/3kemyu0).'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到完整分辨率的前一个截图，以便更好地查看：[https://packt.live/3kemyu0](https://packt.live/3kemyu0)。
- en: In the preceding code, we get the game state instance, update the scoreboard,
    and schedule a timer to automatically update the scoreboard every 0.5 seconds.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们获取游戏状态实例，更新记分牌，并安排一个定时器，以自动每0.5秒更新一次记分牌。
- en: 'Go back to the designer section and make the following bind for `vbScoreboard`:![Figure
    18.10: Displaying the number of pickups remaining in the world'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回设计部分，并为“vbScoreboard”进行以下绑定：![图18.10：显示世界中剩余拾取物的数量
- en: '](img/B16183_18_10.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_18_10.jpg)'
- en: 'Figure 18.10: Displaying the number of pickups remaining in the world'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.10：显示世界中剩余拾取物的数量
- en: Note
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/38xUDTE](https://packt.live/38xUDTE).'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到前面的屏幕截图的全分辨率，以便更好地查看：[https://packt.live/38xUDTE](https://packt.live/38xUDTE)。
- en: 'Add a vertical box to `vbScoreboard` called `vbPlayerStates` with `Is Variable`
    set to `true` and a top padding of `50`, so you should have the following:![Figure
    18.11: The UI_Scoreboard widget hierarchy'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向“vbScoreboard”添加一个垂直框，称为“vbPlayerStates”，并将“Is Variable”设置为“true”，顶部填充为“50”，因此您应该有以下内容：![图18.11：UI_Scoreboard小部件层次结构
- en: '](img/B16183_18_11.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_18_11.jpg)'
- en: 'Figure 18.11: The UI_Scoreboard widget hierarchy'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.11：UI_Scoreboard小部件层次结构
- en: 'Go back to the Graph section and implement the `Update Scoreboard` event in
    the following way:![Figure 18.12: The update scoreboard function, which clears
    and recreates the entry widgets'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回图形部分，并以以下方式实现“更新记分牌”事件：![图18.12：更新记分牌函数，清除并重新创建条目小部件
- en: '](img/B16183_18_12.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_18_12.jpg)'
- en: 'Figure 18.12: The update scoreboard function, which clears and recreates the
    entry widgets'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.12：更新记分牌函数，清除并重新创建条目小部件
- en: Note
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3pf8EeN](https://packt.live/3pf8EeN).'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到前面的屏幕截图的全分辨率，以便更好地查看：[https://packt.live/3pf8EeN](https://packt.live/3pf8EeN)。
- en: 'In the preceding code, we do the following:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们做了以下事情：
- en: Clear all of the previous entries in `vbPlayerStates`.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除“vbPlayerStates”中的所有先前条目。
- en: Create a scoreboard header entry and add it to `vbPlayerStates`.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个记分牌标题条目，并将其添加到“vbPlayerStates”中。
- en: Loop through all of the player states ordered by score and create an entry for
    each one, as well as adding it to `vbPlayerStates`.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环遍历所有按分数排序的玩家状态，并为每个创建一个条目，并将其添加到“vbPlayerStates”中。
- en: Save and close `UI_Scoreboard`.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭“UI_Scoreboard”。
- en: Now, let's create the blueprint for the player controller.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为玩家控制器创建蓝图。
- en: Go to `Content\Blueprints` and create a new blueprint called `BP_PlayerController`
    that is derived from the `PickupPlayerController` class.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“内容\蓝图”并创建一个名为“BP_PlayerController”的新蓝图，该蓝图派生自“PickupPlayerController”类。
- en: Open the new blueprint and set the `Scoreboard Menu` `Class` to use `UI_Scoreboard`.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的蓝图，并将“记分牌菜单”“类”设置为使用“UI_Scoreboard”。
- en: Save and close `BP_PlayerController`.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭“BP_PlayerController”。
- en: Next, let's create the blueprint for the game mode.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为游戏模式创建蓝图。
- en: 'Go to `Content\Blueprints` and create a new blueprint called `BP_GameMode`
    that is derived from the `PickupGameMode` class, open it, and change the following
    variables:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“内容\蓝图”并创建一个名为“BP_GameMode”的新蓝图，该蓝图派生自“PickupGameMode”类，打开它，并更改以下变量：
- en: '[PRE89]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Next, let's configure `Project Settings` to use the new game mode.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们配置“项目设置”以使用新的游戏模式。
- en: Go to `Project Settings` and pick `Maps & Modes` from the left panel, which
    is in the `Project` category.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“项目设置”并从左侧面板中选择“地图和模式”，该面板位于“项目”类别中。
- en: Set `Default GameMode` to use `BP_GameMode`.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“默认游戏模式”设置为使用“BP_GameMode”。
- en: Close `Project Settings`.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭“项目设置”。
- en: Now, let's modify the main level.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改主要级别。
- en: Make sure you have `ThirdPersonExampleMap` opened, located in `Content\ThirdPersonCPP\Maps`.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您已经打开了“ThirdPersonExampleMap”，位于“Content\ThirdPersonCPP\Maps”中。
- en: Add some cube actors to act as platforms and make sure they have gaps between
    them to force the player to jump on them and possibly fall from the level.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些立方体演员作为平台，并确保它们之间有间隙，以迫使玩家跳上它们，并可能从级别中掉下来。
- en: Add a couple of player start actors to different parts of the map.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向地图的不同部分添加一些玩家起始演员。
- en: Add at least 50 instances of `BP_Pickup` and spread them across the entire map.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少添加50个“BP_Pickup”的实例，并将它们分布在整个地图上。
- en: 'Here is an example of a possible way of configuring the map:![Figure 18.13:
    An example of the map configuration'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一种可能的配置地图的示例：![图18.13：地图配置示例
- en: '](img/B16183_18_13.jpg)'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_18_13.jpg)'
- en: 'Figure 18.13: An example of the map configuration'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.13：地图配置示例
- en: Run the code and wait for the editor to fully load.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并等待编辑器完全加载。
- en: Go to `Multiplayer Options` and set the number of clients to `2`.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“多人游戏选项”并将客户端数量设置为“2”。
- en: Set the window size to `800x600`.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将窗口大小设置为“800x600”。
- en: 'Play in `New Editor Window (PIE)`:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“新编辑器窗口（PIE）”中播放：
- en: '![Figure 18.14: The listen Server and Client 1 picking up cubes in the world'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '![图18.14：监听服务器和客户端1在世界中拾取立方体'
- en: '](img/B16183_18_14.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_18_14.jpg)'
- en: 'Figure 18.14: The listen Server and Client 1 picking up cubes in the world'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.14：监听服务器和客户端1在世界中拾取立方体
- en: Once you complete this exercise, you will be able to play on each client and
    you'll notice that the characters can collect pickups and gain `10` points just
    by overlapping with them. If a character falls from the level, it will respawn
    on a random player start and lose `10` points.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，您将能够在每个客户端上进行游戏，并且您会注意到角色可以收集拾取物并获得“10”分，只需与它们重叠。如果角色从级别掉下来，它将重新生成在随机的玩家起始点，并且失去“10”分。
- en: Once all pickups have been collected, the game will end, and after `5` seconds,
    it will perform a server travel to reload the same level and bring all the clients
    with it (*only in the packaged version*). You can also see that the UI displays
    how many pickups are remaining in the level, as well as the scoreboard with the
    information about the name, score, and pickups for each player.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有拾取物品都被收集，游戏将结束，并在`5`秒后执行服务器转移以重新加载相同的级别并将所有客户端带上（*仅在打包版本中*）。您还可以看到UI显示了级别中剩余的拾取物品数量，以及每个玩家的名称、得分和拾取物品的记分板信息。
- en: 'Activity 18.01: Adding Death, Respawn, Scoreboard, Kill Limit, and Pickups
    to the Multiplayer FPS Game'
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动18.01：向多人游戏FPS游戏添加死亡、重生、记分板、击杀限制和拾取物品
- en: In this activity, you'll add the concept of death, respawning, and the ability
    to use pickups to the character. We'll also add a way to check the scoreboard
    and a kill limit to the game so that it has an end goal.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将为角色添加死亡、重生和使用拾取物品的概念。我们还将添加一种方法来检查记分板和游戏的击杀限制，以便它有一个结束目标。
- en: 'The following steps will help you complete this activity:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此活动：
- en: Open the `MultiplayerFPS` project from *Activity 17.01*, *Adding Weapons and
    Ammo to the Multiplayer FPS Game*. Compile the code and run the editor.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*活动17.01*中打开`MultiplayerFPS`项目，*向多人游戏FPS游戏添加武器和弹药*。编译代码并运行编辑器。
- en: Next, you're going to create the C++ classes that we're going to need. Create
    a C++ class called `FPSGameState`, which is derived from the `GameState` class,
    and has a kill limit variable and a function that returns the player states ordered
    by kills.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将创建我们需要的C++类。创建一个名为`FPSGameState`的C++类，它派生自`GameState`类，并具有一个击杀限制变量和一个按击杀排序的玩家状态函数。
- en: Create a C++ class called `FPSPlayerState`, which is derived from the `PlayerState`
    class, and stores the number of kills and deaths of a player.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FPSPlayerState`的C++类，它派生自`PlayerState`类，并存储玩家的击杀数和死亡数。
- en: Create a C++ class called `PlayerMenu`, which is derived from the `UserWidget`
    class, and has some `BlueprintImplementableEvent` functions to toggle the scoreboard
    visibility, set the scoreboard visibility, and notify when a player was killed.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PlayerMenu`的C++类，它派生自`UserWidget`类，并具有一些`BlueprintImplementableEvent`函数来切换记分板的可见性、设置记分板的可见性，并在玩家被杀时通知。
- en: Create a C++ class called `FPSPlayerController`, which derives from `APlayerController`,
    that creates the `PlayerMenu` UMG widget instance on the owning client.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FPSPlayerController`的C++类，它派生自`APlayerController`，在拥有客户端上创建`PlayerMenu`
    UMG小部件实例。
- en: Create a C++ class called `Pickup`, which is derived from the `Actor` class,
    and has a static mesh that rotates 90 degrees per second on the `Yaw` axis, and
    can be picked up by the player on the overlap. Once picked up, it plays a pickup
    sound, and disables collision and visibility. After a certain amount of time,
    it will make it visible and able to collide again.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Pickup`的C++类，它派生自`Actor`类，并具有一个静态网格，在`Yaw`轴上每秒旋转90度，并且可以被玩家在重叠时拾取。一旦被拾取，它会播放拾取声音，并禁用碰撞和可见性。一定时间后，它将重新变得可见并能够再次发生碰撞。
- en: Create a C++ class called `AmmoPickup`, which is derived from the `Pickup` class,
    and adds a certain amount of an ammo type to the player.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AmmoPickup`的C++类，它派生自`Pickup`类，并向玩家添加一定数量的弹药类型。
- en: Create a C++ class called `ArmorPickup`, which is derived from the `Pickup`
    class, and adds a certain amount of armor to the player.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ArmorPickup`的C++类，它派生自`Pickup`类，并向玩家添加一定数量的护甲。
- en: Create a C++ class called `HealthPickup`, which is derived from the `Pickup`
    class, and adds a certain amount of health to the player.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`HealthPickup`的C++类，它派生自`Pickup`类，并向玩家添加一定数量的生命值。
- en: Create a C++ class called `WeaponPickup`, which is derived from the `Pickup`
    class, and adds a certain weapon type to the player. If the player already has
    the weapon, it will add a certain amount of ammo.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`WeaponPickup`的C++类，它派生自`Pickup`类，并向玩家添加特定的武器类型。如果玩家已经拥有该武器，它将添加一定数量的弹药。
- en: 'Edit the `FPSCharacter` class so that it does the following:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`FPSCharacter`类，使其执行以下操作：
- en: After the character is damaged, checks to see whether it's dead. If it's dead,
    it registers the kill for the killer character and the death of the character,
    as well as respawning the player. If the character is not dead, then it plays
    the pain sound on the owning client.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色受到伤害后，检查是否已死亡。如果已死亡，它会为杀手角色注册击杀和角色死亡，并重新生成玩家。如果角色尚未死亡，则在拥有客户端上播放疼痛声音。
- en: When the character dies and executes the `EndPlay` function, it should destroy
    all of its weapon instances.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当角色死亡并执行`EndPlay`函数时，它应销毁所有武器实例。
- en: If the character falls from the world, it will register the death of the player
    and respawn it.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果角色从世界中掉落，将注册玩家的死亡并重新生成。
- en: If the player presses the *Tab* key, it will toggle the visibility of the scoreboard menu.
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家按下*Tab*键，它将切换记分板菜单的可见性。
- en: 'Edit the `MultiplayerFPSGameModeBase` class so that it does the following:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`MultiplayerFPSGameModeBase`类，使其执行以下操作：
- en: Stores the number of kills necessary to win the game.
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储赢得比赛所需的击杀数。
- en: Uses the new player controller, player state, and game state classes.
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用新的玩家控制器、玩家状态和游戏状态类。
- en: Makes it implement the match state functions so that the match starts immediately
    and ends if there is a player that has the required number of kills.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使其实现比赛状态函数，以便比赛立即开始，并在有玩家达到所需的击杀数时结束。
- en: When the match ends, it will perform a server travel to the same level after
    5 seconds.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比赛结束时，将在5秒后执行服务器转移到相同的级别。
- en: Handles when a player dies by adding the kill (when killed by another player)
    and the death to the respective player state, as well as respawning the player
    on a random player start.
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理玩家死亡时通过向相应的玩家状态添加击杀（当被其他玩家杀死时）和死亡，并在随机玩家开始点重新生成玩家。
- en: Import `AmmoPickup.wav` from `Activity18.01\Assets` to `Content\Pickups\Ammo`.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity18.01\Assets`导入`AmmoPickup.wav`到`Content\Pickups\Ammo`。
- en: 'Create `BP_PistolBullets_Pickup` from `AAmmoPickup`, place it in `Content\Pickups\Ammo`,
    and configure it with the following values:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`AAmmoPickup`创建`BP_PistolBullets_Pickup`，放置在`Content\Pickups\Ammo`，并配置以下值：
- en: 'Scale: `(X=0.5, Y=0.5, Z=0.5)`'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放：`(X=0.5, Y=0.5, Z=0.5)`
- en: 'Static Mesh: `Engine\BasicShapes\Cube`'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态网格：`Engine\BasicShapes\Cube`
- en: 'Material: `Content\Weapon\Pistol\M_Pistol`'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质：`Content\Weapon\Pistol\M_Pistol`
- en: 'Ammo Type: `Pistol Bullets`, Ammo Amount: `25`'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹药类型：`手枪子弹`，弹药数量：`25`
- en: 'Pickup Sound: `Content\Pickup\Ammo\AmmoPickup`'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾取声音：`Content\Pickup\Ammo\AmmoPickup`
- en: 'Create `BP_MachineGunBullets_Pickup` from `AAmmoPickup`, place it in `Content\Pickups\Ammo`,
    and configure it with the following values:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`AAmmoPickup`创建`BP_MachineGunBullets_Pickup`，放置在`Content\Pickups\Ammo`，并配置以下值：
- en: 'Scale: `(X=0.5, Y=0.5, Z=0.5)`'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放：`(X=0.5, Y=0.5, Z=0.5)`
- en: 'Static Mesh: `Engine\BasicShapes\Cube`'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态网格：`Engine\BasicShapes\Cube`
- en: 'Material: `Content\Weapon\MachineGun\M_MachineGun`'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质：`Content\Weapon\MachineGun\M_MachineGun`
- en: 'Ammo Type: `Machine Gun Bullets`, Ammo Amount: `50`'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹药类型：`机枪子弹`，弹药数量：`50`
- en: 'Pickup Sound: `Content\Pickup\Ammo\AmmoPickup`'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾取声音：`Content\Pickup\Ammo\AmmoPickup`
- en: 'Create `BP_Slugs_Pickup` from `AAmmoPickup`, place it in `Content\Pickups\Ammo`,
    and configure it with the following values:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`AAmmoPickup`创建`BP_Slugs_Pickup`，放置在`Content\Pickups\Ammo`，并配置以下值：
- en: 'Scale: `(X=0.5, Y=0.5, Z=0.5)`'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放：`(X=0.5, Y=0.5, Z=0.5)`
- en: 'Static Mesh: `Engine\BasicShapes\Cube`'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态网格：`Engine\BasicShapes\Cube`
- en: 'Material: `Content\Weapon\Railgun\M_Railgun`'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质：`Content\Weapon\Railgun\M_Railgun`
- en: 'Ammo Type: `Slugs`, Ammo Amount: `5`'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹药类型：`弹丸`，弹药数量：`5`
- en: 'Pickup Sound: `Content\Pickup\Ammo\AmmoPickup`'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾取声音：`Content\Pickup\Ammo\AmmoPickup`
- en: Import `ArmorPickup.wav` from `Activity18.01\Assets` to `Content\Pickups\Armor`.
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity18.01\Assets`导入`ArmorPickup.wav`到`Content\Pickups\Armor`。
- en: Create the material `M_Armor` in `Content\Pickups\Armor`, which has `Base Color`
    set to `blue` and `Metallic` set to `1`.
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content\Pickups\Armor`中创建材质`M_Armor`，将`Base Color`设置为`蓝色`，`金属`设置为`1`。
- en: 'Create `BP_Armor_Pickup` from `AArmorPickup`, place it in `Content\Pickups\Armor`,
    and configure it with the following values:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`AArmorPickup`创建`BP_Armor_Pickup`，放置在`Content\Pickups\Armor`，并配置以下值：
- en: 'Scale: `(X=1.0, Y=1.5, Z=1.0)`'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放：`(X=1.0, Y=1.5, Z=1.0)`
- en: 'Static Mesh: `Engine\BasicShapes\Cube`'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态网格：`Engine\BasicShapes\Cube`
- en: 'Material: `Content\Pickup\Armor\M_Armor`'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质：`Content\Pickup\Armor\M_Armor`
- en: 'Armor Amount: `50`'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 护甲数量：`50`
- en: 'Pickup Sound: `Content\Pickup\Armor\ArmorPickup`'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾取声音：`Content\Pickup\Armor\ArmorPickup`
- en: Import `HealthPickup.wav` from `Activity18.01\Assets` to `Content\Pickups\Health`.
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity18.01\Assets`导入`HealthPickup.wav`到`Content\Pickups\Health`。
- en: Create the material `M_Health` in `Content\Pickups\Health`, which has `Base
    Color` set to `blue` and `Metallic`/`Roughness` set to `0.5`.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content\Pickups\Health`中创建材质`M_Health`，将`Base Color`设置为`蓝色`，`金属`/`粗糙度`设置为`0.5`。
- en: 'Create `BP_Health_Pickup` from `AHealthPickup`, place it in `Content\Pickups\Health`,
    and configure it with the following values:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`AHealthPickup`创建`BP_Health_Pickup`，放置在`Content\Pickups\Health`，并配置以下值：
- en: 'Static Mesh: `Engine\BasicShapes\Sphere`'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态网格：`Engine\BasicShapes\Sphere`
- en: 'Material: `Content\Pickup\Health\M_Health`'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质：`Content\Pickup\Health\M_Health`
- en: 'Health Amount: `50`'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命值：`50`
- en: 'Pickup Sound: `Content\Pickup\Health\HealthPickup`'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾取声音：`Content\Pickup\Health\HealthPickup`
- en: Import `WeaponPickup.wav` from `Activity18.01\Assets` to `Content\Pickups\Weapon`.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity18.01\Assets`导入`WeaponPickup.wav`到`Content\Pickups\Weapon`。
- en: 'Create `BP_Pistol_Pickup` from `AWeaponPickup`, place it in `Content\Pickups\Weapon`,
    and configure it with the following values:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`AWeaponPickup`创建`BP_Pistol_Pickup`，放置在`Content\Pickups\Weapon`，并配置以下值：
- en: 'Static Mesh: `Content\Pickup\Weapon\SM_Weapon`'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态网格：`Content\Pickup\Weapon\SM_Weapon`
- en: 'Material: `Content\Weapon\Pistol\M_Pistol`'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质：`Content\Weapon\Pistol\M_Pistol`
- en: 'Weapon Type: `Pistol`, Ammo Amount: `25`'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 武器类型：`手枪`，弹药数量：`25`
- en: 'Pickup Sound: `Content\Pickup\Weapon\WeaponPickup`'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾取声音：`Content\Pickup\Weapon\WeaponPickup`
- en: 'Create `BP_MachineGun_Pickup` from `AWeaponPickup`, place it in `Content\Pickups\Weapon`,
    and configure it with the following values:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`AWeaponPickup`创建`BP_MachineGun_Pickup`，放置在`Content\Pickups\Weapon`，并配置以下值：
- en: 'Static Mesh: `Content\Pickup\Weapon\SM_Weapon`'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态网格：`Content\Pickup\Weapon\SM_Weapon`
- en: 'Material: `Content\Weapon\MachineGun\M_MachineGun`'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质：`Content\Weapon\MachineGun\M_MachineGun`
- en: 'Weapon Type: `Machine Gun`, Ammo Amount: `50`'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 武器类型：`机枪`，弹药数量：`50`
- en: 'Pickup Sound: `Content\Pickup\Weapon\WeaponPickup`'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾取声音：`Content\Pickup\Weapon\WeaponPickup`
- en: 'Create `BP_Pistol_Pickup` from `AWeaponPickup`, place it in `Content\Pickups\Weapon`,
    and configure it with the following values:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`AWeaponPickup`创建`BP_Pistol_Pickup`，放置在`Content\Pickups\Weapon`，并配置以下值：
- en: 'Static Mesh: `Content\Pickup\Weapon\SM_Weapon`'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态网格：`Content\Pickup\Weapon\SM_Weapon`
- en: 'Material: `Content\Weapon\Railgun\M_Railgun`'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材质：`Content\Weapon\Railgun\M_Railgun`
- en: 'Weapon Type: `Railgun`, Ammo Amount: `5`'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 武器类型：`Railgun`，弹药数量：`5`
- en: 'Pickup Sound: `Content\Pickup\Weapon\WeaponPickup`'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拾取声音：`Content\Pickup\Weapon\WeaponPickup`
- en: Import `Land.wav` and `Pain.wav` from `Activity18.01\Assets` to `Content\Player\Sounds`.
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Activity18.01\Assets`导入`Land.wav`和`Pain.wav`到`Content\Player\Sounds`。
- en: Edit `BP_Player` so that it uses the `Pain` and `Land` sounds, as well as deleting
    all of the nodes that create and add the `UI_HUD` instance to the viewport in
    the `Begin Play` event.
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`BP_Player`，使其使用`Pain`和`Land`声音，并删除所有在`Begin Play`事件中创建和添加`UI_HUD`实例的节点。
- en: Create a UMG widget called `UI_Scoreboard_Entry` in `Content\UI` that displays
    the name, kills, deaths, and ping of `AFPSPlayerState`.
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content\UI`中创建名为`UI_Scoreboard_Entry`的UMG小部件，显示`AFPSPlayerState`的名称、击杀数、死亡数和ping。
- en: Create a UMG widget called `UI_Scoreboard_Header` that displays the headers
    for the name, kills, deaths, and ping.
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`UI_Scoreboard_Header`的UMG小部件，显示名称、击杀数、死亡数和ping的标题。
- en: Create a UMG widget called `UI_Scoreboard` that displays the kill limit from
    the game state, a vertical box that has `UI_Scoreboard_Header` as the first entry,
    and then add a `UI_Scoreboard_Entry` for each `AFPSPlayerState` in the game state
    instance. The vertical box will update every 0.5 seconds, through a timer, by
    clearing its children and adding them again.
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`UI_Scoreboard`的UMG小部件，显示游戏状态中的杀敌限制，一个垂直框，其中`UI_Scoreboard_Header`作为第一个条目，然后为游戏状态实例中的每个`AFPSPlayerState`添加一个`UI_Scoreboard_Entry`。垂直框将通过定时器每0.5秒更新一次，通过清除其子项并再次添加它们。
- en: Edit `UI_HUD` so that it adds a new text block called `tbKilled` that starts
    with `Visibility` set to `Hidden`. When the player kills someone, it will make
    the text block visible, display the name of the killed player, and hide after
    1 second.
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`UI_HUD`，使其添加一个名为`tbKilled`的新文本块，其`Visibility`设置为`Hidden`。当玩家杀死某人时，它将使文本块可见，显示被杀玩家的名称，并在1秒后隐藏。
- en: Create a new blueprint called `UI_PlayerMenu` from `UPlayerMenu` and place it
    in `Content\UI`. Use a widget switcher with an instance of `UI_HUD` in index `0`
    and an instance of `UI_Scoreboard` in index `1`. In the event graph, make sure
    to override the `Toggle Scoreboard`, `Set Scoreboard Visibility`, and `Notify
    Kill` events that were set as `BlueprintImplementableEvent` in C++. The `Toggle
    Scoreboard` event toggles the widget switcher's active index between `0` and `1`,
    the `Set Scoreboard Visibility` event sets the widget switcher's active index
    to `0` or `1`, and the `Notify Kill` event tells the `UI_HUD` instance to set
    the text and fade out the animation.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`UPlayerMenu`创建一个名为`UI_PlayerMenu`的新蓝图，并将其放置在`Content\UI`中。使用一个小部件切换器，在索引`0`中使用`UI_HUD`的一个实例，在索引`1`中使用`UI_Scoreboard`的一个实例。在事件图中，确保覆盖在C++中设置为`BlueprintImplementableEvent`的`Toggle
    Scoreboard`、`Set Scoreboard Visibility`和`Notify Kill`事件。`Toggle Scoreboard`事件在`0`和`1`之间切换小部件切换器的活动索引，`Set
    Scoreboard Visibility`事件将小部件切换器的活动索引设置为`0`或`1`，`Notify Kill`事件告诉`UI_HUD`实例设置文本并淡出动画。
- en: Create `BP_PlayerController` from `AFPSPlayerController`, place it in the `Content`
    folder, and set the `PlayerMenuClass` variable to use `UI_PlayerMenu`.
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`AFPSPlayerController`创建`BP_PlayerController`，将其放置在`Content`文件夹中，并设置`PlayerMenuClass`变量以使用`UI_PlayerMenu`。
- en: Edit `BP_GameMode` and set `Player Controller Class` to use `BP_PlayerController`.
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`BP_GameMode`并设置`Player Controller Class`以使用`BP_PlayerController`。
- en: In the `Input` section of `Project Settings`, create an action mapping called
    `Scoreboard` that uses the `TAB` key.
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`项目设置`的`输入`部分，创建一个名为`Scoreboard`的动作映射，使用`TAB`键。
- en: Edit the `DM-Test` level so that you have at least three new player starts placed
    in different locations, `Kill Z` to `-500` in `World Settings`, and an instance
    placed of every different pickup.
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`DM-Test`关卡，以便至少放置三个新的玩家开始点在不同的位置，将`Kill Z`设置为`-500`在`世界设置`中，并放置每个不同拾取物品的实例。
- en: 'Expected output:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出：
- en: '![Figure 18.15: The expected output of the activity'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '![图18.15：活动的预期输出'
- en: '](img/B16183_18_15.jpg)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_18_15.jpg)'
- en: 'Figure 18.15: The expected output of the activity'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.15：活动的预期输出
- en: The result should be a project where each client's character can pick up, use,
    and switch between three different weapons. If a character kills another, it should
    register the kill and the death, as well as respawning the character that died
    at a random player start. You should have a scoreboard that displays the name,
    kill count, death count, and ping, for each player. A character can fall from
    the level, which should only count as a death, and respawn at a random player
    start. The character should also be able to pick up the different pickups in the
    level to get ammo, armor, health, and weapons. The game should end when the kill
    limit has been reached by showing the scoreboard and server travel to the same
    level after 5 seconds.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是一个项目，其中每个客户端的角色都可以拾取、使用和在三种不同的武器之间切换。如果一个角色杀死另一个角色，它应该注册杀死和死亡，以及在随机玩家开始处重生死亡的角色。您应该有一个计分板，显示每个玩家的名称、杀敌数、死亡数和ping。角色可以从关卡中掉落，这应该只算作一次死亡，并在随机玩家开始处重生。角色还应该能够拾取关卡中的不同物品，以获得弹药、盔甲、健康和武器。当达到杀敌限制时，游戏应该结束，并在5秒后显示计分板并服务器转移到相同的关卡。
- en: Note
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下网址找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: Summary
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned that the gameplay framework class's instances exist
    in some game instances, but not in others. Having that knowledge will help you
    understand which instances can be accessed in a particular game instance. You
    also learned the purpose of the game state and player state classes, as well as
    learning new concepts for the game mode and some useful built-in functionalities.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解到游戏框架类的实例存在于某些游戏实例中，但在其他游戏实例中不存在。了解这一点将有助于您了解在特定游戏实例中可以访问哪些实例。您还了解了游戏状态和玩家状态类的目的，以及学习了游戏模式和一些有用的内置功能的新概念。
- en: At the end of this chapter, you have made a basic but functional multiplayer
    shooter that can be used as a foundation to build upon. You can add new weapons,
    ammo types, fire modes, pickups, and so on, to make it more feature-complete and
    fun.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，您已经制作了一个基本但功能齐全的多人射击游戏，可以作为进一步构建的基础。您可以添加新的武器、弹药类型、射击模式、拾取物品等，使其更加完整和有趣。
- en: Having completed this book, you should now have a better understanding of how
    to use Unreal Engine 4 to make your own games come to life. We've covered a lot
    of topics in this book, ranging from the simple to more advanced. You started
    out by learning how to create projects using the different templates and how to
    use blueprints to create actors and components. You then saw how to create a fully
    functioning Third Person template from scratch by importing and setting up the
    required assets, setting up the animation blueprint and Blend Space, and creating
    your own game mode and character, as well as defining and handling the inputs.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了这本书后，您现在应该更好地了解如何使用Unreal Engine 4让自己的游戏变得生动起来。在本书中，我们涵盖了许多主题，从简单到更高级的内容。您首先学习了如何使用不同模板创建项目，以及如何使用蓝图创建角色和组件。然后，您看到了如何从头开始创建一个完全功能的第三人称模板，通过导入和设置所需的资产，设置动画蓝图和混合空间，并创建自己的游戏模式和角色，以及定义和处理输入。
- en: You then moved on to your first project; a simple stealth game that uses game
    physics and collisions, projectile movement components, actor components, interfaces,
    blueprint function libraries, UMG, sounds, and particle effects. Following this,
    you learned how to create a simple side-scrolling game by using AI, Anim Montages,
    and Destructible Meshes. Finally, you discovered how to create a first-person
    multiplayer shooter by using the Server-Client architecture, variable replication,
    and RPCs that come with the Network Framework, and learned how the Player State,
    Game State, and Game Mode classes work.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您开始了您的第一个项目；一个使用游戏物理和碰撞、投射物移动组件、角色组件、接口、蓝图函数库、UMG、声音和粒子效果的简单潜行游戏。在此之后，您学会了如何使用AI、动画蒙太奇和可破坏网格创建一个简单的横向卷轴游戏。最后，您了解了如何使用服务器-客户端架构、变量复制和网络框架提供的RPC来创建第一人称多人射击游戏，并学会了Player
    State、Game State和Game Mode类的工作原理。
- en: By working on various projects that use different parts of the engine, you now
    have a strong understanding of how Unreal Engine 4 works, and although this is
    the end of this book, it is just the start of your journey into the world of game
    development using Unreal Engine 4.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 通过参与使用引擎不同部分的各种项目，您现在对Unreal Engine 4的工作原理有了深刻的理解，尽管这本书到此结束，但这只是您进入使用Unreal
    Engine 4进行游戏开发世界的开始。
