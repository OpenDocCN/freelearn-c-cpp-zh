- en: '5\. Concurrency: Multithreading Parallel and Async Code'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.并发：多线程并行和异步代码
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: C# and .NET provide a highly effective way to run concurrent code, making it
    easy to perform complex and often time-consuming actions. In this chapter, you
    will explore the various patterns that are available, from creating tasks using
    the `Task` factory methods to continuations to link tasks together, before moving
    on to the `async`/`await` keywords, which vastly simplify such code. By the end
    of this chapter, you will see how C# can be used to execute code that runs concurrently
    and often produces results far quicker than a single-threaded application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C#和.NET提供了一种高效的并发代码运行方式，使得执行复杂且通常耗时的操作变得简单。在本章中，您将探索各种可用的模式，从使用`Task`工厂方法创建任务到使用连续性将任务链接在一起，然后转向`async`/`await`关键字，这些关键字极大地简化了这样的代码。通过本章的学习，您将了解到C#如何执行并发代码，并且通常比单线程应用程序产生结果更快。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Concurrency is a generalized term that describes the ability of software to
    do more than one thing at the same time. By harnessing the power of concurrency,
    you can provide a more responsive user interface by offloading CPU-intensive activities
    from the main UI thread. On the server side, taking advantage of modern processing
    power through multi-processor and multi-core architectures, scalability can be
    achieved by processing operations in parallel.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是一个泛化的术语，用来描述软件同时执行多项任务的能力。通过利用并发的能力，您可以通过将CPU密集型活动从主UI线程中卸载，提供更加响应的用户界面。在服务器端，通过利用多处理器和多核架构的现代处理能力，可以通过并行处理操作来实现可伸缩性。
- en: Multithreading is a form of concurrency whereby multiple threads are used to
    perform operations. This is typically achieved by creating many `Thread` instances
    and coordinating operations between them. It is regarded as a legacy implementation,
    having largely been replaced by parallel and async programming; you may well find
    it used in older projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程是一种并发的形式，其中多个线程用于执行操作。通常通过创建许多`Thread`实例并在它们之间协调操作来实现。它被视为一种传统的实现方式，大部分已经被并行和异步编程所取代；您可能会在旧项目中找到它的使用。
- en: Parallel programming is a class of multithreading where similar operations are
    run independently of each other. Typically, the same operation is repeated using
    multiple loops, where the parameters or target of the operation themselves vary
    by iteration. .NET provides libraries that shield developers from the low-level
    complexities of thread creation. The phrase **embarrassingly parallel** is often
    used to describe an activity that requires little extra effort to be broken down
    into a set of tasks that can be run in parallel, often where there are few interactions
    between sub-tasks. One such example of parallel programming could be counting
    the number of words found in each text file within a folder. The job of opening
    a file and scanning through the words can be split into parallel tasks. Each task
    executes the same lines of code but is given a different text file to process.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 并行编程是一种多线程的类别，其中类似的操作是独立运行的。通常，相同的操作会使用多个循环重复进行，其中操作的参数或目标本身会随着迭代而变化。.NET提供了库，可以屏蔽开发人员对线程创建的低级复杂性。短语“尴尬并行”通常用来描述一个活动，该活动需要很少的额外工作才能被分解成一组可以并行运行的任务，通常在子任务之间几乎没有交互。并行编程的一个例子可能是计算文件夹中每个文本文件中找到的单词数量。打开文件并扫描单词的工作可以被分解成并行任务。每个任务执行相同的代码行，但给定不同的文本文件来处理。
- en: Asynchronous programming is a more recent form of concurrency where an operation,
    once started, will complete at some point in the future, and the calling code
    is able to continue with other operations. This completion is often known as a
    `Task<>` equivalent. In C# and .NET, async programming has become the preferred
    means to achieve concurrent operations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程是一种更近期的并发形式，其中一项操作一旦开始，将在将来的某个时刻完成，调用代码可以继续执行其他操作。这种完成通常被称为`Task<>`等效。在C#和.NET中，异步编程已成为实现并发操作的首选方式。
- en: A common application of asynchronous programming is where multiple slow-running
    or expensive dependencies need to be initialized and marshaled prior to calling
    a final step that should be called only when all or some of the dependencies are
    ready to be used. For example, a mobile hiking application may need to wait for
    a reliable GPS satellite signal, a planned navigation route, and a heart-rate
    monitoring service to be ready before the user can start hiking safely. Each of
    these distinct steps would be initialized using a dedicated task.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程的常见应用是在需要初始化和调度多个运行缓慢或昂贵的依赖项之前，调用最终步骤的情况下。这些依赖项在准备好被使用之前，应该只在所有或部分依赖项准备就绪时才被调用。例如，移动徒步应用程序可能需要等待可靠的GPS卫星信号、计划的导航路线和心率监测服务准备就绪，然后用户才能安全地开始徒步旅行。每个不同的步骤都将使用专用任务进行初始化。
- en: Another very common use case for asynchronous programming occurs in UI applications
    where, for example, saving a customer's order to a database could take 5-10 seconds
    to complete. This may involve validating the order, opening a connection to a
    remote server or database, packaging and sending the order in a format that can
    be transmitted over the wire, and then finally waiting for confirmation that the
    customer's order has been successfully stored in a database. In a single-threaded
    application, this would take much longer, and this delay would soon be noticed
    by the user. The application would become unresponsive until the operation was
    completed. In this scenario, the user may rightly think the application has crashed
    and may try to close it. That is not an ideal user experience.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程的另一个非常常见的用例发生在UI应用程序中，例如，将客户的订单保存到数据库可能需要5-10秒才能完成。这可能涉及验证订单，打开到远程服务器或数据库的连接，打包并以可以通过网络传输的格式发送订单，然后等待确认客户的订单已成功存储在数据库中。在单线程应用程序中，这将需要更长的时间，用户很快就会注意到这种延迟。应用程序会变得无响应，直到操作完成。在这种情况下，用户可能会认为应用程序已崩溃，并尝试关闭它。这不是一个理想的用户体验。
- en: Such issues can be mitigated by using async code that performs any of the slow
    operations using a dedicated task for each. These tasks may choose to provide
    feedback as they progress, which the UI's main thread can use to notify the user.
    Overall, the operation should complete sooner, thus freeing the user to continue
    interacting with the app. In modern applications, users have come to expect this
    method of operation. In fact, many UI guidelines suggest that if an operation
    may take more than a few seconds to complete, then it should be performed using
    async code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用异步代码执行任何慢速操作的方式可以缓解这些问题，每个慢速操作都使用专用任务。这些任务可以选择在进展时提供反馈，UI的主线程可以用来通知用户。总的来说，操作应该更快地完成，从而使用户可以继续与应用程序进行交互。在现代应用程序中，用户已经习惯了这种操作方法。事实上，许多UI指南建议，如果一个操作可能需要超过几秒钟才能完成，那么应该使用异步代码来执行。
- en: Note that when code is executing, whether it's synchronous or asynchronous code,
    it is run within the context of a `Thread` instance. In the case of asynchronous
    code, this `Thread` instance is chosen by the .NET scheduler from a pool of available
    threads.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当代码执行时，无论是同步还是异步代码，它都是在`Thread`实例的上下文中运行的。在异步代码的情况下，这个`Thread`实例是由.NET调度程序从可用线程池中选择的。
- en: The `Thread` class has various properties but one of the most useful is `ManagedThreadId`,
    which will be used extensively throughout this chapter. This integer value serves
    to uniquely identify a thread within your process. By examining `Thread.ManagedThreadId`,
    you can determine that multiple thread instances are being used. This can be done
    by accessing the `Thread` instance from within your code using the static `Thread.CurrentThread`
    method.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类有各种属性，但其中最有用的之一是`ManagedThreadId`，这将在本章中广泛使用。这个整数值用于唯一标识进程中的线程。通过检查`Thread.ManagedThreadId`，您可以确定正在使用多个线程实例。这可以通过在代码中访问`Thread`实例，使用静态的`Thread.CurrentThread`方法来完成。'
- en: For example, if you started five long-running tasks and examined the `Thread.ManagedThreadId`
    for each, you would observe five unique IDs, possibly numbered as two, three,
    four, five, and six. In most cases, the thread with ID number one is the process's
    main thread, created when the process first starts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您启动了五个长时间运行的任务，并检查了每个`Thread.ManagedThreadId`，您会观察到五个唯一的ID，可能编号为2、3、4、5和6。在大多数情况下，ID号为1的线程是进程的主线程，在进程首次启动时创建。
- en: Keeping track of thread IDs can be quite useful, especially when you have time-consuming
    operations to perform. As you have seen, using concurrent programming, multiple
    operations can be executed at the same time, rather than using a traditional single-threaded
    approach, where one operation must complete before a subsequent operation can
    start.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪线程ID可能非常有用，特别是当您需要执行耗时操作时。正如您所见，使用并发编程，多个操作可以同时执行，而不是使用传统的单线程方法，其中一个操作必须在后续操作开始之前完成。
- en: In the physical world, consider the case of building a train tunnel through
    a mountain. Starting at one side of a mountain and tunneling through to the other
    side could be made considerably faster if two teams started on opposite sides
    of the mountain, both tunneling toward each other. The two teams could be left
    to work independently; any issues experienced by a team on one side should not
    have an adverse effect on the other side's team. Once both sides have completed
    their tunneling, there should be one single tunnel, and the construction could
    then continue with the next task, such as laying the train line.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理世界中，考虑建造一条穿过山的火车隧道的情况。如果两个团队从山的两侧开始挖隧道，朝着彼此挖掘，那么整个过程会快得多。这两个团队可以独立工作；一个团队在一侧遇到的任何问题不应该对另一侧的团队产生不利影响。一旦两侧都完成了挖隧道的工作，就应该有一个单一的隧道，然后可以继续进行下一个任务，比如铺设火车线路。
- en: 'The next section will look at using the C# `Task` class, which allows you to
    execute blocks of code at the same time and independently of each other. Consider
    again the example of the UI app, where the customer''s order needs to be saved
    to a database. For this, you would have two options:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍使用C# `Task`类，它允许您同时执行代码块，并且彼此独立。再次考虑UI应用程序的例子，客户的订单需要保存到数据库。对此，您有两个选项：
- en: 'Option 1 is to create a C# `Task` that performs each step one after another:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 选项1是创建一个C# `Task`，按顺序执行每个步骤：
- en: Validate the order.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证订单。
- en: Connect to the server.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到服务器。
- en: Send the request.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送请求。
- en: Wait for a response.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待响应。
- en: Option 2 is to create a C# `Task` for each of the steps, executing each in parallel
    where possible.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 选项2是为每个步骤创建一个C# `Task`，在可能的情况下并行执行每个步骤。
- en: Both options achieve the same end result, freeing the UI's main thread to respond
    to user interactions. Option one may well be slower to finish, but the upside
    is that this would require simpler code. However, Option two would be the preferred
    choice as you are offloading multiple steps, so it should complete sooner. Although,
    this could involve additional complexity as you may need to coordinate each of
    the individual tasks as they are complete.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选项都可以实现相同的最终结果，即释放UI的主线程以响应用户交互。选项一可能会慢一些完成，但好处是这将需要更简单的代码。然而，选项二将是首选，因为您正在卸载多个步骤，所以它应该更快完成。尽管如此，这可能涉及额外的复杂性，因为您可能需要在每个单独的任务完成时进行协调。
- en: In the upcoming sections, you will first get a look at how Option one could
    be approached, that is, using a single `Task` to run blocks of code, before moving
    on to the complexity of Option two where multiple tasks are used and coordinated.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，您将首先看一下如何处理选项一，即使用单个`Task`来运行代码块，然后再转向选项二的复杂性，其中使用和协调多个任务。
- en: Running Asynchronous Code Using Tasks
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用任务运行异步代码
- en: The `Task` class is used to execute blocks of code asynchronously. Its usage
    has been somewhat superseded by the newer `async` and `await` keywords, but this
    section will cover the basics of creating tasks as they tend to be pervasive in
    larger or mature C# applications and form the backbone of the `async`/`await`
    keywords.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`类用于异步执行代码块。它的使用在某种程度上已被新的`async`和`await`关键字所取代，但本节将介绍创建任务的基础知识，因为它们在较大或成熟的C#应用程序中往往是无处不在的，并且构成了`async`/`await`关键字的基础。'
- en: In C#, there are three ways to schedule asynchronous code to run using the `Task`
    class and its generic equivalent `Task<T>`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，有三种使用`Task`类及其泛型等效`Task<T>`来安排异步代码运行的方法。
- en: Creating a New Task
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的任务
- en: You'll start off with the simplest form, one that performs an operation but
    does not return a result back to the caller. You can declare a `Task` instance
    by calling any of the `Task` constructors and passing in an `Action` based delegate.
    This delegate contains the actual code to be executed at some point in the future.
    Many of the constructor overloads allow cancellation tokens and `Task` runs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您将从最简单的形式开始，执行一个操作但不将结果返回给调用方。您可以通过调用任何`Task`构造函数并传递基于`Action`的委托来声明一个`Task`实例。这个委托包含将来某个时间执行的实际代码。许多构造函数重载允许取消令牌和`Task`运行。
- en: 'Some of the commonly used constructors are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的构造函数如下：
- en: '`public Task(Action action)`: The `Action` delegate represents the body of
    code to be run.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Task(Action action)`: `Action`委托表示要运行的代码主体。'
- en: '`public Task(Action action, CancellationToken cancellationToken)`: The `CancellationToken`
    parameter can be used as a way to interrupt the code that is running. Typically,
    this is used where the caller has been provided with a means to request that an
    operation be stopped, such as adding a `Cancel` button that a user can press.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Task(Action action, CancellationToken cancellationToken)`: `CancellationToken`参数可用作中断正在运行的代码的方法。通常情况下，这是在调用方已提供了一种请求停止操作的方式时使用的，例如添加一个用户可以按下的`Cancel`按钮。'
- en: '`public Task(Action action, TaskCreationOptions creationOptions)`: `TaskCreationOptions`
    offers a way to control how the `Task` is run, allowing you to provide hints to
    the scheduler that a certain `Task` might take extra time to complete. This can
    help when running related tasks together.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Task(Action action, TaskCreationOptions creationOptions)`: `TaskCreationOptions`提供了一种控制`Task`运行方式的方法，允许您向调度程序提供关于某个`Task`可能需要额外时间完成的提示。这在运行相关任务时会有所帮助。'
- en: 'The following are the most often used `Task` properties:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常用的`Task`属性：
- en: '`public bool IsCompleted { get; }`: Returns `true` if the `Task` completed
    (completion does not indicate success).'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsCompleted { get; }`: 如果`Task`已完成（完成并不表示成功），则返回`true`。'
- en: '`public bool IsCompletedSuccessfully { get; }`: Returns `true` if the `Task`
    completed successfully.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsCompletedSuccessfully { get; }`: 如果`Task`成功完成，则返回`true`。'
- en: '`public bool IsCanceled { get; }`: Returns `true` if the `Task` was canceled
    prior to completion.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsCanceled { get; }`: 如果`Task`在完成之前被取消，则返回`true`。'
- en: '`public bool IsFaulted { get; }`: Returns `true` if the `Task` has thrown an
    unhandled exception prior to completion.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsFaulted { get; }`: 如果`Task`在完成之前抛出了未处理的异常，则返回`true`。'
- en: '`public TaskStatus Status { get; }`: Returns an indicator of the task''s current
    status, such as `Canceled`, `Running`, or `WaitingToRun`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public TaskStatus Status { get; }`: 返回任务当前状态的指示器，例如`Canceled`、`Running`或`WaitingToRun`。'
- en: '`public AggregateException Exception { get; }`: Returns the exception, if any,
    that caused the `Task` to end prematurely.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public AggregateException Exception { get; }`: 返回引起`Task`过早结束的异常（如果有的话）。'
- en: Note that the code within the `Action` delegate is not executed until sometime
    after the `Start()` method is called. This may well be some milliseconds after
    and is determined by the .NET scheduler.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Action`委托中的代码直到调用`Start()`方法之后的某个时间才会执行。这可能是在几毫秒之后，并由.NET调度程序确定。
- en: Start here by creating a new VS Code console app, adding a utility class named
    `Logger`, which you will use in the exercises and examples going forward. It will
    be used to log a message to the console along with the current time and current
    thread's `ManagedThreadId`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，通过创建一个新的VS Code控制台应用程序，添加一个名为`Logger`的实用类，您将在以后的练习和示例中使用它。它将用于将消息记录到控制台，以及当前时间和当前线程的`ManagedThreadId`。
- en: 'The steps for this are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作的步骤如下：
- en: Change to your source folder.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到您的源文件夹。
- en: 'Create a new console app project called `Chapter05` by running the following command:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Chapter05`的新控制台应用程序项目，通过运行以下命令来完成：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Rename the `Class1.cs` file to `Logger.cs` and remove all the template code.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Class1.cs`文件重命名为`Logger.cs`并删除所有模板代码。
- en: 'Be sure to include the `System` and `System.Threading` namespaces. `System.Threading`
    contains the `Threading` based classes:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保包含`System`和`System.Threading`命名空间。`System.Threading`包含基于`Threading`的类：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Mark the `Logger` class as static so that it can be used without having to
    create an instance to use:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Logger`类标记为静态，以便无需创建实例即可使用：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you use the `Chapter05` namespace, then the `Logger` class will be accessible
    to code in examples and activities, provided they also use the `Chapter05` namespace.
    If you prefer to create a folder for each example and exercise, then you should
    copy the file `Logger.cs` into each folder that you create.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`Chapter05`命名空间，那么`Logger`类将可供示例和活动中的代码访问，前提是它们也使用`Chapter05`命名空间。如果您更喜欢为每个示例和练习创建一个文件夹，那么您应该将`Logger.cs`文件复制到您创建的每个文件夹中。
- en: 'Now declare a `static` method called `Log` that is passed a `string message`
    parameter:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在声明一个名为`Log`的`static`方法，它接受一个`string message`参数：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When invoked, this will log a message to the console window using the `WriteLine`
    method. In the preceding snippet, the string interpolation feature in C# is used
    to define a string using the `$` symbol; here, `:T` will format the current time
    (`DateTime.Now`) into a time-formatted string and `:00` is used to include `Thread.ManagedThreadId`
    with a leading 0.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用时，这将使用`WriteLine`方法向控制台窗口记录消息。在前面的片段中，C#中的字符串插值功能使用`$`符号定义字符串；这里，`:T`将当前时间(`DateTime.Now`)格式化为时间格式的字符串，`：00`用于包含带有前导0的`Thread.ManagedThreadId`。
- en: Thus, you have created the static Logger class that will be used throughout
    the rest of this chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您已经创建了将在本章的其余部分中使用的静态Logger类。
- en: Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/cg6c5](https://packt.link/cg6c5).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/cg6c5](https://packt.link/cg6c5)找到此示例使用的代码。
- en: In the next example, you will use the `Logger` class to log details when a thread
    is about to start and finish.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，您将使用`Logger`类在线程即将启动和完成时记录详细信息。
- en: 'Start by adding a new class file called `TaskExamples.cs`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加一个名为`TaskExamples.cs`的新类文件：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Main` entry point will log that `taskA` is being created:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Main`入口点将记录`taskA`正在被创建：'
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, add the following code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下代码：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the simplest `Task` constructor is passed an `Action` lambda statement,
    which is the actual target code that you want to execute. The target code writes
    the message `Inside taskA` to the console. It pauses for five seconds using `Thread.Sleep`
    to block the current thread, thus simulating a long-running activity, before finally
    writing `Leaving taskA` to the console.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，最简单的`Task`构造函数传递了一个`Action` lambda语句，这是您要执行的实际目标代码。目标代码将消息`Inside taskA`写入控制台。它使用`Thread.Sleep`暂停五秒钟来阻塞当前线程，从而模拟长时间运行的活动，最后将`Leaving
    taskA`写入控制台。
- en: 'Now that you have created `taskA`, confirm that it will only invoke its target
    code when the `Start()` method is called. You will do this by logging a message
    immediately before and after the method is called:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经创建了`taskA`，请确认它只会在调用`Start()`方法时调用其目标代码。您将通过在方法调用之前和之后立即记录消息来实现这一点：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Copy the contents of `Logger.cs` file to same folder as the `TaskExamples.cs`
    example.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Logger.cs`文件的内容复制到与`TaskExamples.cs`示例相同的文件夹中。
- en: 'Next run the console app to produce the following output:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来运行控制台应用程序以产生以下输出：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the task's status is `WaitingToRun` even after you've called `Start`.
    This is because you are asking the .NET scheduler to schedule the code to run—that
    is, to add it to its queue of pending actions. Depending on how busy your application
    is with other tasks, it may not run immediately after you've called `Start`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使您调用了`Start`，任务的状态仍为`WaitingToRun`。这是因为您要求.NET调度程序安排代码运行 - 也就是说，将其添加到待处理操作队列中。根据您的应用程序与其他任务的繁忙程度，它可能不会在您调用`Start`后立即运行。
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/DHxt3](https://packt.link/DHxt3).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/DHxt3](https://packt.link/DHxt3)找到此示例使用的代码。
- en: In earlier versions of C#, this was the main way to create and start `Task`
    objects directly. It is no longer recommended and is only included here as you
    may find it used in older code. Its usage has been replaced by the `Task.Run`
    or `Task.Factory.StartNew` static factory methods, which offer a simpler interface
    for the most common usage scenarios.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#的早期版本中，这是直接创建和启动`Task`对象的主要方法。现在不再推荐使用，仅在此包含，因为您可能会发现它在旧代码中使用。它的使用已被`Task.Run`或`Task.Factory.StartNew`静态工厂方法取代，这些方法为最常见的使用场景提供了更简单的接口。
- en: Using Task.Factory.StartNew
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Task.Factory.StartNew
- en: The static method `Task.Factory.StartNew` contains various overloads that make
    it easier to create and configure a `Task`. Notice how the method is named `StartNew`.
    It creates a `Task` and automatically starts the method for you. The .NET team
    recognized that there is little value in creating a `Task` that is not immediately
    started after it is first created. Typically, you would want the `Task` to start
    performing its operation right away.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法`Task.Factory.StartNew`包含各种重载，使创建和配置`Task`更容易。请注意方法的命名为`StartNew`。它创建一个`Task`并自动为您启动方法。.NET团队认识到，在首次创建后不立即启动`Task`几乎没有价值。通常，您希望`Task`立即开始执行其操作。
- en: The first parameter is the familiar `Action` delegate to be executed, followed
    by optional cancelation tokens, creation options, and a `TaskScheduler` instance.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是熟悉的`Action`委托，用于执行，后跟可选的取消令牌、创建选项和`TaskScheduler`实例。
- en: 'The following are some of the common overloads:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见的重载：
- en: '`Task.Factory.StartNew(Action action)`: The `Action` delegate contains the
    code to execute, as you have seen previously.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Factory.StartNew(Action action)`: `Action`委托包含要执行的代码，正如您之前所见。'
- en: '`Task.Factory.StartNew(Action action, CancellationToken cancellationToken)`:
    Here, `CancellationToken` coordinates the cancellation of the task.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Factory.StartNew(Action action, CancellationToken cancellationToken)`:
    这里，`CancellationToken`协调任务的取消。'
- en: '`Task.Factory.StartNew(Action<object> action, object state, CancellationToken
    cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler)`:
    The `TaskScheduler` parameter allows you to specify a type of low-level scheduler
    responsible for queuing tasks. This option is rarely used.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Factory.StartNew(Action<object> action, object state, CancellationToken
    cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler)`:
    `TaskScheduler`参数允许您指定负责排队任务的低级调度程序类型。这个选项很少使用。'
- en: 'Consider the following code, which uses the first and simplest overload:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，它使用了第一个和最简单的重载：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running this code produces the following output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生以下输出：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the output, you can see that this code achieves the same result as creating
    a `Task` but is more concise. The main point to consider is that `Task.Factory.StartNew`
    was added to C# to make it easier to create tasks that are started for you. It
    was preferable to use `StartNew` rather than creating tasks directly.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，这段代码实现了与创建`Task`相同的结果，但更加简洁。需要考虑的主要问题是，`Task.Factory.StartNew`是为了让创建任务更容易而添加到C#中的。最好使用`StartNew`而不是直接创建任务。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The term **Factory** is often used in software development to represent methods
    that help create objects.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**工厂**经常在软件开发中用来表示帮助创建对象的方法。
- en: '`Task.Factory.StartNew` provides a highly configurable way to start tasks,
    but in reality, many of the overloads are rarely used and need a lot of extra
    parameters to be passed to them. As such, `Task.Factory.StartNew` itself has also
    become somewhat obsolete in favor of the newer `Task.Run` static method. Still,
    the `Task.Factory.StartNew` is briefly covered as you may see it used in legacy
    C# applications.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task.Factory.StartNew`提供了一种高度可配置的启动任务的方式，但实际上，很少使用许多重载，并且需要传递许多额外的参数。因此，`Task.Factory.StartNew`本身也已经在新的`Task.Run`静态方法的支持下变得有些过时。不过，由于您可能会在传统的C#应用程序中看到它的使用，因此还是简要介绍了`Task.Factory.StartNew`。'
- en: Using Task.Run
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`Task.Run`
- en: The alternative and preferred `static` factory method, `Task.Run`, has various
    overloads and was added later to .NET to simplify and shortcut the most common
    task scenarios. It is preferable for newer code to use `Task.Run` to create started
    tasks, as far fewer parameters are needed to achieve common threading operations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 备用和首选的`static`工厂方法`Task.Run`有各种重载，并且后来添加到.NET中，以简化和快捷处理最常见的任务场景。对于较新的代码来说，最好使用`Task.Run`来创建已启动的任务，因为需要更少的参数来实现常见的线程操作。
- en: 'Some of the common overloads are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的重载如下：
- en: '`public static Task Run(Action action)`: Contains the `Action` delegate code
    to execute.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static Task Run(Action action)`: 包含要执行的`Action`委托代码。'
- en: '`public static Task Run(Action action, CancellationToken cancellationToken)`:
    Additionally contains a cancelation token used to coordinate the cancellation
    of a task.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static Task Run(Action action, CancellationToken cancellationToken)`:
    还包含用于协调任务取消的取消令牌。'
- en: 'For example, consider the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running this code will produce the following output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将产生以下输出：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, the output is pretty similar to the outputs of the previous
    two code snippets. Each wait for a shorter time than its predecessor before the
    associated `Action` delegate completes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输出与前两个代码片段的输出非常相似。每个都等待比前一个更短的时间，然后相关的`Action`委托完成。
- en: The main difference is that creating a `Task` instance directly is an obsolete
    practice but will allow you to add an extra logging call before you explicitly
    call the `Start` method. That is the only benefit in creating a `Task` directly,
    which is not a particularly compelling reason to do so.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于直接创建`Task`实例是一种过时的做法，但允许您在显式调用`Start`方法之前添加额外的日志调用。这是直接创建`Task`的唯一好处，这并不是一个特别有说服力的理由。
- en: 'Running all three examples together produces this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有三个示例将产生以下结果：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see various `ManagedThreadIds` being logged and that `taskC` completes
    before `taskB`, which completes before `taskA`, due to the decreasing number of
    seconds specified in the `Thread.Sleep` calls in each case.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到记录了各种`ManagedThreadIds`，并且`taskC`在`taskB`之前完成，`taskB`在`taskA`之前完成，这是由于在每种情况下`Thread.Sleep`调用中指定的秒数递减。
- en: It is preferable to favor either of the two static methods, but which should
    you use when scheduling a new task? `Task.Run` should be used for the `Task.Run`
    defers down to `Task.Factory.StartNew`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最好优先考虑这两种静态方法中的一种，但在安排新任务时应该使用哪一个呢？`Task.Run`应该用于`Task.Run`向下延迟到`Task.Factory.StartNew`。
- en: '`Task.Factory.StartNew` should be used where you have more advanced requirements,
    such as defining where tasks are queued, by using any of the overloads that accept
    a `TaskScheduler` instance, but in practice, this is seldom the requirement.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task.Factory.StartNew`应该用于具有更高级要求的情况，例如通过使用接受`TaskScheduler`实例的任何重载来定义任务排队的位置，但实际上，这种情况很少发生。'
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on `Task.Run` and `Task.Factory.StartNew` at [https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/)
    and [https://blog.stephencleary.com/2013/08/startnew-is-dangerous.html](https://blog.stephencleary.com/2013/08/startnew-is-dangerous.html).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下网址找到有关`Task.Run`和`Task.Factory.StartNew`的更多信息：[https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/](https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/)
    和 [https://blog.stephencleary.com/2013/08/startnew-is-dangerous.html](https://blog.stephencleary.com/2013/08/startnew-is-dangerous.html)。
- en: So far, you have seen how small tasks can be started, each with a small delay
    before completion. Such delays can simulate the effect caused by code accessing
    slow network connections or running complex calculations. In the following exercise,
    you'll extend your `Task.Run` knowledge by starting multiple tasks that run increasingly
    longer numeric calculations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了如何启动小任务，每个任务在完成之前都有一段短暂的延迟。这些延迟可以模拟代码访问慢速网络连接或运行复杂计算所造成的效果。在接下来的练习中，您将通过启动多个任务来扩展您对`Task.Run`的了解，这些任务将运行越来越长的数字计算。
- en: This serves as an example to show how potentially complex tasks can be started
    and allowed to run to completion in isolation from one another. Note that in a
    traditional synchronous implementation, the throughput of such calculations would
    be severely restricted, owing to the need to wait for one operation to complete
    before the next one can commence. It is now time to practice what you have learned
    through an exercise.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子，展示了如何启动潜在复杂的任务并允许它们独立完成。请注意，在传统的同步实现中，这样的计算吞吐量会受到严重限制，因为需要等待一个操作完成后才能开始下一个操作。现在是时候通过练习来实践你所学到的知识了。
- en: 'Exercise 5.01: Using Tasks to Perform Multiple Slow-Running Calculations'
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.01：使用任务执行多个运行缓慢的计算
- en: 'In this exercise, you will create a recursive function, Fibonacci, which calls
    itself twice to calculate a cumulative value. This is an example of potentially
    slow-running code rather than using `Thread.Sleep` to simulate a slow call. You
    will create a console app that repeatedly prompts for a number to be entered.
    The larger this number, the longer each task will take to calculate and output
    its result. The following steps will help you complete this exercise:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个递归函数`Fibonacci`，它调用自身两次来计算累积值。这是一个潜在的运行缓慢的代码的例子，而不是使用`Thread.Sleep`来模拟一个缓慢的调用。你将创建一个控制台应用程序，重复提示输入一个数字。这个数字越大，每个任务计算和输出结果所花费的时间就越长。以下步骤将帮助你完成这个练习：
- en: In the `Chapter05` folder, add a new folder called `Exercises`. Inside that
    folder, add a new folder called `Exercise01`. You should have the folder structure
    as `Chapter05\Exercises\Exercise01`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter05`文件夹中，添加一个名为`Exercises`的新文件夹。在该文件夹内，添加一个名为`Exercise01`的新文件夹。你应该有如下的文件夹结构：`Chapter05\Exercises\Exercise01`。
- en: Create a new file called `Program.cs`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Program.cs`的新文件。
- en: 'Add the recursive `Fibonacci` function as follows. You can save a little processing
    time by returning `1` if the requested iteration is less than or equal to `2`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加递归的`Fibonacci`函数如下。如果请求的迭代次数小于或等于`2`，可以通过返回`1`来节省一些处理时间：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Add the `static Main` entry point to the console app and use a `do`-loop to
    prompt for a number to be entered.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中添加`static Main`入口点，并使用`do`循环提示输入一个数字。
- en: 'Use `int.TryParse` to convert the string into an integer if the user enters
    a string:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户输入一个字符串，使用`int.TryParse`将其转换为整数：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define a lambda statement that captures the current time using `DateTime.Now`,
    calls the slow-running `Fibonacci` function, and logs the time taken to run:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个lambda语句，使用`DateTime.Now`捕获当前时间，调用运行缓慢的`Fibonacci`函数，并记录运行所花费的时间：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The lambda is passed to `Task.Run` and will be started by `Task.Run` shortly,
    freeing the `do-while` loop to prompt for another number.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda被传递给`Task.Run`，并将很快由`Task.Run`启动，从而释放`do-while`循环以提示输入另一个数字。
- en: 'The program shall exit the loop when an empty value is entered:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当输入空值时，程序将退出循环：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For running the console app, start by entering the numbers `1` and then `2`.
    As these are very quick calculations, they both return in under one second.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序时，先输入数字`1`，然后输入`2`。由于这些是非常快速的计算，它们都在一秒内返回。
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice how the `ThreadId` is `[04]` for both `1` and `2`. This shows that the
    same thread was used by `Task.Run` for both iterations. By the time `2` was entered,
    the previous calculation had already been completed. So .NET decided to reuse
    thread `04` again. The same occurs for the value `45`, which took `27` seconds
    to complete even though it was the third requested.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`ThreadId`对于`1`和`2`都是`[04]`。这表明`Task.Run`使用相同的线程进行了两次迭代。当输入`2`时，之前的计算已经完成。因此.NET决定再次重用线程`04`。对于值`45`也是一样的，尽管它是第三次请求，但完成所花费的时间是`27`秒。
- en: You can see that entering values above `40` causes the elapsed time to increase
    quite dramatically (for each increase by one, the time taken almost doubles).
    Starting with higher numbers and descending downward, you can see that the calculations
    for `41`, `40`, and `42` were all completed before `44` and `43`, even though
    they were started at similar times. In a few instances, the same thread appears
    twice. Again, this is .NET re-using idle threads to run the task's action.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，输入大于`40`的值会导致经过的时间急剧增加（每增加一个，所花费的时间几乎翻倍）。从较高的数字开始向下降，你会发现`41`、`40`和`42`的计算都在`44`和`43`之前完成，尽管它们在类似的时间开始。在一些情况下，相同的线程会出现两次。同样，这是.NET重新使用空闲线程来运行任务的动作。
- en: Note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/YLYd4](https://packt.link/YLYd4).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/YLYd4](https://packt.link/YLYd4)找到本练习使用的代码。
- en: Coordinating Tasks
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协调任务
- en: In the previous *Exercise 5.01*, you saw how multiple tasks can be started and
    left to run to completion without any interaction between the individual tasks.
    One such scenario is a process that needs to search a folder looking for image
    files, adding a copyright watermark to each image file found. The process can
    use multiple tasks, each working on a distinct file. There would be no need to
    coordinate each task and its resulting image.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的*练习5.01*中，你看到了如何启动多个任务并让它们在没有任何交互的情况下完成。这样的一个场景是一个需要搜索文件夹查找图像文件并给每个找到的图像文件添加版权水印的过程。该过程可以使用多个任务，每个任务处理一个不同的文件。不需要协调每个任务及其生成的图像。
- en: Conversely, it is quite common to start various long-running tasks and only
    continue when some or all of the tasks have completed; maybe you have a collection
    of complex calculations that need to be started and can only perform a final calculation
    once the others have completed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，通常会启动各种长时间运行的任务，只有在一些或所有任务完成时才继续；也许你有一系列需要启动的复杂计算，只有在其他计算完成后才能执行最终计算。
- en: In the *Introduction* section, it was mentioned that a hiking application needed
    a GPS satellite signal, navigation route, and a heart rate monitor before it could
    be used safely. Each of these dependencies can be created using a `Task` and only
    when all of them have signaled that they are ready to be used should the application
    then allow the user to start with their route.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在*介绍*部分提到，一个徒步应用程序在安全使用前需要GPS卫星信号、导航路线和心率监测器。每个这些依赖关系都可以使用`Task`来创建，只有当它们都发出信号表明已准备好使用时，应用程序才应允许用户开始他们的路线。
- en: Over the next sections, you will cover various ways offered by C# to coordinate
    tasks. For example, you may have a requirement to start many independent tasks
    running, each running a complex calculation, and need to calculate a final value
    once all the previous tasks have completed. You may either like to start downloading
    data from multiple websites but want to cancel the downloads that are taking too
    long to complete. The next section will cover this scenario.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，您将了解C#提供的协调任务的各种方式。例如，您可能需要启动许多独立的任务运行，每个任务运行一个复杂的计算，并且需要在所有先前的任务完成后计算出最终值。您可能还想要从多个网站开始下载数据，但希望取消那些下载时间太长的下载。下一节将涵盖这种情况。
- en: Waiting for Tasks to Complete
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等待任务完成
- en: '`Task.Wait` can be used to wait for an individual task to complete. If you
    are working with multiple tasks, then the static `Task.WaitAll` method will wait
    for all tasks to complete. The `WaitAll` overloads allow cancellation and timeout
    options to be passed in, with most returning a Boolean value to indicate success
    or failure, as you can see in the following list:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task.Wait`可以用来等待单个任务完成。如果您正在处理多个任务，那么静态的`Task.WaitAll`方法将等待所有任务完成。`WaitAll`重载允许传入取消和超时选项，大多数都返回一个布尔值来指示成功或失败，如下列表所示：'
- en: '`public static bool WaitAll(Task[] tasks, TimeSpan timeout)`: This is passed
    an array of `Task` items to wait for. It returns `true` if `TimeSpan` allows specific
    units such as hours, minutes, and seconds to be expressed).'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static bool WaitAll(Task[] tasks, TimeSpan timeout)`: 这里传入一个`Task`数组来等待。如果`TimeSpan`允许特定单位（如小时、分钟和秒）来表示，则返回`true`。'
- en: '`public static void WaitAll(Task[] tasks, CancellationToken cancellationToken)`:
    This is passed an array of `Task` items to wait for, and a cancellation token
    that can be used to coordinate the cancellation of the tasks.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static void WaitAll(Task[] tasks, CancellationToken cancellationToken)`:
    这里传入一个`Task`数组来等待，并且一个可用于协调任务取消的取消标记。'
- en: '`public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken
    cancellationToken)`: This is passed an array of `Task` items to wait for and a
    cancellation token that can be used to coordinate the cancellation of the tasks.
    `millisecondsTimeout` specifies the number of milliseconds to wait for all tasks
    to complete by.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken
    cancellationToken)`: 这里传入一个`Task`数组来等待，并且一个可用于协调任务取消的取消标记。`millisecondsTimeout`指定等待所有任务完成的毫秒数。'
- en: '`public static void WaitAll(params Task[] tasks)`: This allows an array of
    `Task` items to wait for.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static void WaitAll(params Task[] tasks)`: 这允许等待一个`Task`数组。'
- en: If you need to wait for any task to complete from a list of tasks, then you
    can use `Task.WaitAny`. All of the `WaitAny` overloads return either the index
    number of the first completed task or `-1` if a timeout occurred (the maximum
    amount of time to wait for).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要等待任务列表中的任何任务完成，那么您可以使用`Task.WaitAny`。所有的`WaitAny`重载都会返回第一个完成的任务的索引号，如果发生超时（等待的最长时间），则返回`-1`。
- en: For example, if you pass an array of five Task items and the last Task in that
    array completes, then you will be returned the value four (array indexes always
    start counting at zero).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您传入一个包含五个Task项目的数组，并且该数组中的最后一个Task完成，那么将返回值四（数组索引始终从零开始计数）。
- en: '`public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken
    cancellationToken)`: This is passed an array of `Task` items to wait for, the
    number of milliseconds to wait for any `Task` to complete by, and a cancellation
    token that can be used to coordinate the cancellation of the tasks.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken
    cancellationToken)`: 这里传入一个`Task`数组来等待，等待任何`Task`完成的毫秒数，以及一个可用于协调任务取消的取消标记。'
- en: '`public static int WaitAny(params Task[] tasks)`: This is passed an array of
    `Task` items to wait for any `Task` to be completed.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static int WaitAny(params Task[] tasks)`: 这里传入一个`Task`数组来等待任何`Task`完成。'
- en: '`public static int WaitAny(Task[] tasks, int millisecondsTimeout)`: Here, you
    pass the number of milliseconds to wait for any tasks to complete.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static int WaitAny(Task[] tasks, int millisecondsTimeout)`: 在这里，您传入等待任何任务完成的毫秒数。'
- en: '`public static int WaitAny(Task[] tasks, CancellationToken cancellationToken)
    CancellationToken`: This is passed a cancellation token that can be used to coordinate
    the cancellation of the tasks.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static int WaitAny(Task[] tasks, CancellationToken cancellationToken)
    CancellationToken`: 这里传入一个可用于协调任务取消的取消标记。'
- en: '`public static int WaitAny(Task[] tasks, TimeSpan timeout)`: This is passed
    the maximum time period to wait for.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static int WaitAny(Task[] tasks, TimeSpan timeout)`: 这里传入最大等待时间段。'
- en: Calling `Wait`, `WaitAll`, or `WaitAny` will block the current thread, which
    can negate the benefits of using a task in the first place. For this reason, it
    is preferable to call these from within an awaitable task, such as via `Task.Run`
    as the following example shows.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Wait`、`WaitAll`或`WaitAny`将阻塞当前线程，这可能会抵消使用任务的好处。因此，最好从可等待的任务中调用这些方法，例如通过`Task.Run`，如下例所示。
- en: 'The code creates `outerTask` with a lambda statement, which itself then creates
    two inner tasks, `inner1`, and `inner2`. `WaitAny` is used to get the index of
    the `inner2` will complete first as it pauses for a shorter time, so the resulting
    index value will be `1`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用lambda语句创建了`outerTask`，它本身创建了两个内部任务`inner1`和`inner2`。使用`WaitAny`来获取`inner2`将首先完成的索引，因为它暂停的时间较短，所以结果索引值将是`1`：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When the code runs, it produces the following output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码运行时，会产生以下输出：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The application remains responsive because you called `WaitAny` from inside
    a `Task`. You have not blocked the application''s main thread. As you can see,
    thread ID `01` has logged this message: `15:47:43 [01] Press ENTER`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序保持响应，因为你在一个`Task`内部调用了`WaitAny`。你没有阻塞应用程序的主线程。正如你所看到的，线程ID`01`已经记录了这条消息：`15:47:43
    [01] Press ENTER`。
- en: This type of pattern can be used in cases where you need to fire and forget
    a task. For example, you may want to log an informational message to a database
    or a log file, but it is not essential that the flow of the program is altered
    if either task fails to complete.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可以用在需要启动并忘记任务的情况下。例如，你可能想要将信息消息记录到数据库或日志文件中，但如果任一任务未能完成，程序的流程并不会改变，这并不是必要的。
- en: A common progression from fire-and-forget tasks is those cases where you need
    to wait for several tasks to complete within a certain time limit. The next exercise
    will cover this scenario.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从启动并忘记任务的常见进展是那些需要在一定时间限制内等待多个任务完成的情况。下一个练习将涵盖这种情况。
- en: 'Exercise 5.02: Waiting for Multiple Tasks to Complete Within a Time Period'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.02：在一定时间内等待多个任务完成
- en: In this exercise, you will start three long-running tasks and decide your next
    course of action if they all completed within a certain randomly selected time
    span.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将启动三个长时间运行的任务，并在一定随机选择的时间段内决定下一步的行动。
- en: 'Here, you will see the generic `Task<T>` class being used. The `Task<T>` class
    includes a `Value` property that can be used to access the result of `Task` (in
    this exercise, it is a string-based generic, so `Value` will be a string type).
    You won''t use the `Value` property here as the purpose of this exercise is to
    show that void and generic tasks can be waited for together. Perform the following
    steps to complete this exercise:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将看到使用泛型`Task<T>`类。`Task<T>`类包括一个`Value`属性，可以用来访问`Task`的结果（在本练习中，它是基于字符串的泛型，所以`Value`将是字符串类型）。在这里，你不会使用`Value`属性，因为这个练习的目的是展示void和泛型任务可以一起等待。执行以下步骤完成这个练习：
- en: 'Add the main entry point to the console app:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台应用程序添加主入口点：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Declare a variable named `taskA`, passing `Task.Run` a lambda that pauses the
    current thread for `5` seconds:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`taskA`的变量，传递给`Task.Run`一个暂停当前线程`5`秒的lambda：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create two more tasks using the method group syntax:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用方法组语法创建另外两个任务：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you may recall, this shorter syntax can be used if the compiler can determine
    the type of argument required for a zero- or single-parameter method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的，如果编译器可以确定零个或单个参数方法所需的参数类型，那么可以使用这种更短的语法。
- en: 'Now pick a random maximum timeout in seconds. This means that either of the
    two tasks may **not** complete before the timeout period has elapsed:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在随机选择一个最大超时时间（以秒为单位）。这意味着两个任务中的任何一个在超时期限到期之前都可能**不**完成：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that each of the tasks will still run to completion as you have not added
    a mechanism to stop executing the code inside the body of the `Task.Run` `Action`
    lambda.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个任务仍将完成运行，因为你没有添加一个机制来停止执行`Task.Run` `Action` lambda体内的代码。
- en: 'Call `WaitAll`, passing in the three tasks and the `timeout` period:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`WaitAll`，传入三个任务和`timeout`时间：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will return `true` if all tasks complete in time. You will then log the
    status of all tasks and wait for `Enter` to be pressed to exit the application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有任务都及时完成，这将返回`true`。然后，你将记录所有任务的状态，并等待按下`Enter`键退出应用程序。
- en: 'Finish off by adding two slow-running `Action` methods:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过添加两个运行缓慢的`Action`方法来完成：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each will log a message when starting and leaving a task, after a few seconds.
    The useful `nameof` statement is used to include the name of the method for extra
    logging information. Often, it is useful to examine log files to see the name
    of a method that has been accessed rather than hardcoding its name as a literal string.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务在开始和离开任务后都会记录一条消息，几秒钟后。有用的`nameof`语句用于包含方法的名称，以提供额外的日志信息。通常，检查日志文件以查看已访问方法的名称是有用的，而不是将其名称硬编码为字面字符串。
- en: 'Upon running the code, you will see the following output:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码后，你将看到以下输出：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: While running the code, a seven-second timeout was randomly picked by the runtime.
    This allowed all tasks to complete in time, so `true` was returned by `WaitAll`
    and all tasks had a `RanToCompletion` status at that point. Notice that the thread
    ID, in square brackets, is different for all three tasks.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行代码时，运行时随机选择了七秒的超时时间。这使得所有任务都及时完成，因此`WaitAll`返回`true`，此时所有任务都处于`RanToCompletion`状态。请注意，方括号中的线程ID对于所有三个任务都是不同的。
- en: 'Run the code again:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行代码：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This time the runtime picked a two-second maximum wait time, so the `WaitAll`
    call times out with `false` being returned.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这次运行时选择了两秒的最大等待时间，因此`WaitAll`调用超时，返回`false`。
- en: You may have noticed from the output that `Inside TaskBActivity` can sometimes
    appear before `Inside TaskCActivity`. This demonstrates the .NET scheduler's queuing
    mechanism. When you call `Task.Run`, you are asking the scheduler to add this
    to its queue. There may only be a matter of milliseconds between the time that
    you call `Task.Run` and when it invokes your lambda, but this can depend on how
    many other tasks you have recently added to the queue; a greater number of pending
    tasks could increase that time period.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，输出中有时会出现`Inside TaskBActivity`在`Inside TaskCActivity`之前。这展示了.NET调度程序的排队机制。当你调用`Task.Run`时，你要求调度程序将其添加到其队列中。在你调用`Task.Run`和它调用你的lambda之间可能只有几毫秒的时间，但这取决于你最近添加到队列中的任务数量；待处理任务的数量可能会增加这段时间。
- en: Interestingly, the output shows `Leaving TaskBActivity`, but the `taskB` status
    was still `Running` just after `WaitAll` finished waiting. This indicates that
    there can sometimes be a very slight delay when a timed-out task's status is changed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，输出显示`Leaving TaskBActivity`，但`taskB`的状态在`WaitAll`完成等待后仍然是`Running`。这表明在超时任务的状态发生变化时，有时可能会有非常轻微的延迟。
- en: Some three seconds after the `Enter` key is pressed, `Leaving TaskA` is logged.
    This shows that the `Action` within any timed-out tasks will continue to run,
    and .NET will not stop it for you.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 按下`Enter`键后的三秒钟，将记录`Leaving TaskA`。这表明任何超时任务中的`Action`将继续运行，.NET不会为您停止它。
- en: Note
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/5lH0o](https://packt.link/5lH0o).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/5lH0o](https://packt.link/5lH0o)找到此练习使用的代码。
- en: Continuation Tasks
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继续任务
- en: So far, you have created tasks that are independent of one another, but what
    if you need to continue a task with the results of the previous task? Rather than
    blocking the current thread, by calling `Wait` or accessing the `Result` property,
    this can be achieved using the `Task` `ContinueWith` methods.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经创建了彼此独立的任务，但如果您需要使用前一个任务的结果继续任务怎么办？而不是通过调用`Wait`或访问`Result`属性来阻塞当前线程，可以使用`Task`的`ContinueWith`方法来实现这一点。
- en: These methods return a new task, referred to as a **continuation** task, or
    more simply, a continuation, which can consume the previous task's or the antecedent's
    results.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法返回一个新的任务，称为**继续**任务，或更简单地说，一个继续任务，它可以消耗前一个任务或前置任务的结果。
- en: 'As with standard tasks, they do not block the caller thread. There are several
    `ContinueWith` overloads available, many allowing extensive customization. A few of
    the more commonly used overloads are as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准任务一样，它们不会阻塞调用者线程。有多个可用的`ContinueWith`重载，允许进行广泛的自定义。以下是一些常用的重载：
- en: '`public Task ContinueWith(Action<Task<TResult>> continuationAction)`: This
    defines a generic `Action<T>` based `Task` to run when the previous task completes.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Task ContinueWith(Action<Task<TResult>> continuationAction)`: 这定义了一个基于泛型`Action<T>`的任务，在前一个任务完成时运行。'
- en: '`public Task ContinueWith(Action<Task<TResult>> continuationAction, CancellationToken
    cancellationToken)`: This has a task to run and a cancellation token that can
    be used to coordinate the cancellation of the task.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Task ContinueWith(Action<Task<TResult>> continuationAction, CancellationToken
    cancellationToken)`: 这有一个要运行的任务和一个可用于协调任务取消的取消标记。'
- en: '`public Task ContinueWith(Action<Task<TResult>> continuationAction, TaskScheduler
    scheduler)`: This also has a task to run and a low-level `TaskScheduler` that
    be used to queue the task.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Task ContinueWith(Action<Task<TResult>> continuationAction, TaskScheduler
    scheduler)`: 这也有一个要运行的任务和一个低级的`TaskScheduler`，可以用来排队任务。'
- en: '`public Task ContinueWith(Action<Task<TResult>> continuationAction, TaskContinuationOptions
    continuationOptions)`: A task to run, with the behavior for the task specified
    with `TaskContinuationOptions`. For example, specifying `NotOnCanceled` indicates
    that you do **not** want the continuation to be called if the previous task is
    canceled.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public Task ContinueWith(Action<Task<TResult>> continuationAction, TaskContinuationOptions
    continuationOptions)`: 要运行的任务，任务的行为由`TaskContinuationOptions`指定。例如，指定`NotOnCanceled`表示如果前一个任务被取消，则**不**希望调用继续任务。'
- en: Continuations have an initial `WaitingForActivation` status. The .NET Framework
    will execute this task once the antecedent task or tasks have completed. It is
    important to note that you do not need to start a continuation and attempting
    to do so will result in an exception.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 继续任务具有初始的`WaitingForActivation`状态。.NET Framework将在前置任务完成后执行此任务。重要的是要注意，您不需要启动一个继续任务，尝试这样做将导致异常。
- en: 'The following example simulates calling a long-running function, `GetStockPrice`
    (this may be some sort of web service or database call that takes a few seconds
    to return):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例模拟调用长时间运行的函数`GetStockPrice`（这可能是某种需要几秒钟才能返回的网络服务或数据库调用）：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The call to `GetStockPrice` returns a `double`, which results in the generic
    `Task<double>` being passed to as a continuation (see the highlighted part). The
    `prev` parameter is a generic `Action` of type `Task<double>`, allowing you to
    access the antecedent task and its `Result` to retrieve the value returned from `GetStockPrice`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对`GetStockPrice`的调用返回一个`double`，这导致将通用的`Task<double>`作为继续任务传递（见突出显示的部分）。`prev`参数是一个泛型的`Action`类型`Task<double>`，允许您访问前置任务及其`Result`以检索从`GetStockPrice`返回的值。
- en: 'If you hover your mouse over the `ContinueWith` method, you will see the IntelliSense
    description for it as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将鼠标悬停在`ContinueWith`方法上，将看到其IntelliSense描述如下：
- en: '![Figure 5.1: ContinueWith method signature'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1：ContinueWith方法签名'
- en: '](img/B16835_05_01.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_05_01.jpg)'
- en: 'Figure 5.1: ContinueWith method signature'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：ContinueWith方法签名
- en: Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `ContinueWith` method has various options that can be used to fine-tune
    behavior, and you can get more details about them from [https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContinueWith`方法有各种选项，可用于微调行为，您可以从[https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions)获取更多详细信息。'
- en: 'Running the example produces an output similar to the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例会产生类似以下的输出：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the output, thread `[01]` represents the console's main thread. The task
    that called `GetStockPrice` was executed by thread ID `[03]`, yet the continuation
    was executed using a different thread, thread (`[04]`).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，线程`[01]`代表控制台的主线程。调用`GetStockPrice`的任务由线程ID`[03]`执行，但继续任务是使用不同的线程，线程(`[04]`)执行的。
- en: Note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/rpNcx](https://packt.link/rpNcx).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/rpNcx](https://packt.link/rpNcx)找到此示例使用的代码。
- en: The continuation running on a different thread may not be a problem, but it
    certainly will be an issue if you are working on UWP, WPF, or WinForms UI apps
    where it's essential that UI elements are updated using the main UI thread (unless
    you are using binding semantics).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的线程上运行可能不是问题，但如果您正在处理UWP、WPF或WinForms UI应用程序，那么这肯定会成为一个问题，因为在这些应用程序中，使用主UI线程更新UI元素是至关重要的（除非您使用绑定语义）。
- en: It is worth noting that the `TaskContinuationOptions.OnlyOnRanToCompletion`
    option can be used to ensure the continuation only runs if the antecedent task
    has run to completion first. For example, you may create a `Task` that fetches
    customers' orders from a database and then use a continuation task to calculate
    the average order value. If the previous task fails or is canceled by the user,
    then there is no point in wasting processing power to calculate the average if
    the user no longer cares about the result.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`TaskContinuationOptions.OnlyOnRanToCompletion`选项可用于确保只有在前置任务首先完成时才运行连续任务。例如，您可以创建一个从数据库中获取客户订单的`Task`，然后使用连续任务来计算平均订单价值。如果前一个任务失败或被用户取消，则没有必要浪费处理能力来计算平均值，如果用户不再关心结果。
- en: Note
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `ContinueWith` method has various options that can be used to fine-tune
    behavior, and you can see [https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions)
    for more details.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContinueWith`方法有各种选项，可用于微调行为，您可以查看[https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcontinuationoptions)获取更多详细信息。'
- en: If you access the `Task<T> Result` property on a `AggregateException` being
    thrown. This will be covered in more detail later.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果访问`AggregateException`上的`Task<T> Result`属性被抛出。稍后将更详细地介绍这一点。
- en: Using Task.WhenAll and Task.WhenAny with Multiple Tasks
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Task.WhenAll和Task.WhenAny处理多个任务
- en: You have seen how a single task can be used to create a continuation task, but
    what if you have multiple tasks and need to continue with a final operation when
    any or all of the previous tasks have completed?
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了如何使用单个任务来创建一个连续任务，但如果您有多个任务并且需要在任何或所有先前的任务完成时继续进行最终操作呢？
- en: Earlier, the `Task.WaitAny` and `Task.WaitAll` methods were used to wait for
    tasks to complete, but these block the current thread. This is where `Task.WhenAny`
    and `Task.WhenAll` can be used. They return a new `Task` whose `Action` delegate
    is called **when** any, or all, of the preceding tasks have completed.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，使用`Task.WaitAny`和`Task.WaitAll`方法等待任务完成，但这些方法会阻塞当前线程。这就是`Task.WhenAny`和`Task.WhenAll`可以使用的地方。它们返回一个新的`Task`，其`Action`委托在前面的任务中的任何一个或全部完成时调用。
- en: 'There are four `WhenAll` overloads, two that return a `Task` and two that return
    a generic `Task<T>` allowing the task''s result to be accessed:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个`WhenAll`重载，两个返回`Task`，两个返回通用的`Task<T>`，允许访问任务的结果：
- en: '`public static Task WhenAll(IEnumerable<Task> tasks)`: This continues when
    the collection of tasks completes.'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public static Task WhenAll(IEnumerable<Task> tasks)`: 当任务集合完成时继续。'
- en: '`public static Task WhenAll(params Task[] tasks)`: This continues when the
    array of tasks completes.'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public static Task WhenAll(params Task[] tasks)`: 当任务数组完成时继续。'
- en: '`public static Task<TResult[]> WhenAll<TResult>(params Task<TResult>[] tasks)`:
    This continues when the array of generic `Task<T>` items complete.'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public static Task<TResult[]> WhenAll<TResult>(params Task<TResult>[] tasks)`:
    当通用的`Task<T>`项目数组完成时继续。'
- en: '`public static Task<TResult[]> WhenAll<TResult>(IEnumerable<Task<TResult>>
    tasks)`: This continues when the collection of generic `Task<T>` items complete.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public static Task<TResult[]> WhenAll<TResult>(IEnumerable<Task<TResult>>
    tasks)`: 当通用的`Task<T>`项目集合完成时继续。'
- en: '`WhenAny` has a similar set of overloads but returns the `Task` or `Task<T>`
    that is the `WhenAll` and `WhenAny` in practice.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`WhenAny`有一组类似的重载，但实际上返回`WhenAll`和`WhenAny`的`Task`或`Task<T>`。'
- en: 'Exercise 5.03: Waiting for All Tasks to Complete'
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.03：等待所有任务完成
- en: Say you have been asked by a car dealer to create a console application that
    calculates the average sales value for cars sold across different regions. A dealership
    is a busy place, but they know it may take a while to fetch and calculate the
    average. For this reason, they want to enter a maximum number of seconds that
    they are prepared to wait for the average calculation. Any longer and they will
    leave the app and ignore the result.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您被一家汽车经销商要求创建一个控制台应用程序，用于计算不同地区销售的汽车的平均销售价值。经销商是一个繁忙的地方，但他们知道获取和计算平均值可能需要一段时间。因此，他们希望输入一个最长等待平均计算的秒数。如果超过这个时间，他们将离开应用程序并忽略结果。
- en: The dealership has 10 regional sales hubs. To calculate the average, you need
    to first invoke a method called `FetchSales`, which returns a list of `CarSale`
    items for each of these regions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 经销商有10个区域销售中心。要计算平均值，您需要首先调用一个名为`FetchSales`的方法，该方法返回每个区域的`CarSale`项目列表。
- en: Each call to `FetchSales` could be to a potentially slow-running service (you
    will implement random pauses to simulate such a delay) so you need to use a `Task`
    for each as you can't know for sure how long each call will take to complete.
    You also do not want slow-running tasks to affect other tasks, but to calculate
    a valid average, it's important to have **all** results returned before continuing.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`FetchSales`可能是对潜在的运行缓慢的服务（您将实现随机暂停以模拟这种延迟），因此您需要为每个调用使用一个`Task`，因为您无法确定每个调用需要多长时间才能完成。您也不希望运行缓慢的任务影响其他任务，但为了计算有效的平均值，重要的是在继续之前**所有**结果都返回。
- en: Create a `SalesLoader` class that implements `IEnumerable<CarSale> FetchSales()`
    to return the car sales details. Then, a `SalesAggregator` class should be passed
    a list of `SalesLoader` (in this exercise, there will be 10 loader instances,
    one for each region). The aggregator will wait for all loaders to finish using
    `Task.WhenAll` before continuing with a task that calculates the average across
    all regions.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个实现`IEnumerable<CarSale> FetchSales()`的`SalesLoader`类来返回汽车销售详情。然后，应该传递一个`SalesLoader`列表给`SalesAggregator`类（在本练习中，将有10个加载器实例，每个地区一个）。聚合器将使用`Task.WhenAll`等待所有加载器完成，然后继续执行一个任务，计算所有地区的平均值。
- en: 'Perform the following steps to do so:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成：
- en: 'First, create a `CarSale` record. The constructor accepts two values, the name
    of the car and its sale price (`name` and `salePrice`):'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`CarSale`记录。构造函数接受两个值，汽车的名称和销售价格（`name`和`salePrice`）：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now create an interface, `ISalesLoader`, that represents the sales data loading service:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个表示销售数据加载服务的接口`ISalesLoader`：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It has just one call, `FetchSales`, returning an enumerable of type `CarSale`.
    For now, it's not important to know how the loader works; just that it returns
    a list of car sales when called. Using an interface here allows using various
    types of loader as needed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 它只有一个调用，`FetchSales`，返回类型为`CarSale`的可枚举。现在，重要的是知道加载器的工作原理；只是在调用时返回汽车销售列表。在这里使用接口允许根据需要使用各种类型的加载器。
- en: 'User the aggregator class to call an `ISalesLoader` implementation:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用聚合器类调用`ISalesLoader`实现：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It is declared as `static` as there is no state between calls. Define an `Average`
    function that is passed an enumerable of `ISalesLoader` items and returns a generic
    `Task<Double>` for the final average calculation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 它声明为`static`，因为在调用之间没有状态。定义一个`Average`函数，该函数接受`ISalesLoader`项目的可枚举，并返回最终平均值计算的通用`Task<Double>`。
- en: 'For each of the loader parameters, use a LINQ projection to pass a `loader.FetchSales`
    method to `Task.Run`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于加载器参数的每个，使用LINQ投影将`loader.FetchSales`方法传递给`Task.Run`：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Each of these will return a `Task<IEnumerable<CarSale>>` instance. `WhenAll`
    is used to create a single task that continues when `ContinueWith` call.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 其中每个都将返回一个`Task<IEnumerable<CarSale>>`实例。使用`WhenAll`创建一个单一任务，该任务在`ContinueWith`调用时继续。
- en: 'Use the LINQ `SelectMany` to grab all of the `CarSale` items from every loader
    call result, before calling the Linq `Average` on the `SalePrice` field of each
    `CarSale` item:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用LINQ的`SelectMany`从每个加载器调用结果中抓取所有的`CarSale`项目，然后在每个`CarSale`项目的`SalePrice`字段上调用Linq的`Average`：
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Implement the `ISalesLoader` interface from a class called `SalesLoader`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从名为`SalesLoader`的类实现`ISalesLoader`接口：
- en: '[PRE36]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The constructor will be passed an `int` variable used for logging and a `Random`
    instance to help create a random number of `CarSale` items.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将传递一个用于记录的`int`变量和一个`Random`实例，以帮助创建随机数量的`CarSale`项目。
- en: 'Your `ISalesLoader` implementation requires a `FetchSales` function. Include
    a random delay of between `1` and `3` seconds to simulate a less reliable service:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的`ISalesLoader`实现需要一个`FetchSales`函数。包括一个介于`1`和`3`秒之间的随机延迟，以模拟不太可靠的服务：
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You are trying to test that your application behaves with various time delays.
    Hence, the random class use.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在尝试测试应用程序在各种时间延迟下的行为。因此，使用随机类。
- en: 'Use `Enumerable.Range` and `random.Next` to pick a random number from one to
    five:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Enumerable.Range`和`random.Next`来从一到五中选择一个随机数：
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is the total number of `CarSale` items to return using your `GetRandomCar` function.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用您的`GetRandomCar`函数返回的`CarSale`项目的总数。
- en: Use the `GetRandomCar` to generate a `CarSale` item with a random manufacturer's
    name from a hardcoded list.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GetRandomCar`从硬编码列表中生成具有随机制造商名称的`CarSale`项目。
- en: 'Use the `carNames.length` property to pick a random index number between zero
    and four for the car''s name:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`carNames.length`属性来选择介于零和四之间的随机索引号作为汽车的名称：
- en: '[PRE39]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, create your console app to test this out:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建您的控制台应用程序来测试这一点：
- en: '[PRE40]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Your app will repeatedly ask for a maximum time that the user is prepared to
    wait while data is downloaded. Once all the data has been downloaded, the app
    will use this to calculate an average price. Pressing `Enter` alone will result
    in the program loop ending. `MaxSalesHubs` is the maximum number of sales hubs
    to request data for.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序将重复要求用户准备等待数据下载的最长时间。一旦所有数据都已下载，应用程序将使用此数据来计算平均价格。仅按下`Enter`将导致程序循环结束。`MaxSalesHubs`是要请求数据的最大销售中心数。
- en: 'Convert the entered value into an `int` type, then use `Enumerable.Range` again
    to create a random number of new `SalesLoader` instances (you have up to 10 different
    sales hubs):'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入的值转换为`int`类型，然后再次使用`Enumerable.Range`创建新的`SalesLoader`实例的随机数量（最多有10个不同的销售中心）：
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Pass loaders to the static `SalesAggregator.Average` method to receive a `Task<Double>`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将加载器传递给静态的`SalesAggregator.Average`方法以接收一个`Task<Double>`。
- en: 'Call `Wait`, passing in the maximum wait time:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`Wait`，传入最大等待时间：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If the `Wait` call does return in time, then you will see a `true` value for
    has completed.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Wait`调用及时返回，则将看到`has completed`的`true`值。
- en: 'Finish off by checking `hasCompleted` and log a message accordingly:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后通过检查`hasCompleted`并相应地记录一条消息来完成：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When running the console app and entering a short maximum wait of `1` second,
    you see three loader instances randomly created:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并输入`1`秒的短暂最长等待时间时，您会看到随机创建了三个加载器实例：
- en: '[PRE44]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Each loader sleeps for `1` second (you can see various thread IDs are logged)
    before returning a random list of `CarSale` records. You soon reach the maximum
    timeout value, hence the message `Timeout!` with no average value displayed.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 每个加载器在返回随机的`CarSale`记录之前都会休眠`1`秒（您可以看到记录了各种线程ID）。您很快就会达到最大超时值，因此显示了消息`Timeout!`，没有显示平均值。
- en: 'Enter a larger timeout period of `10` seconds:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`10`秒的较长超时期：
- en: '[PRE45]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Entering a value of `10` seconds allow `7` random loaders to complete in time
    and to finally create the average value of `639`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个值为`10`秒，允许`7`个随机加载器及时完成，并最终创建平均值为`639`。
- en: Note
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/kbToQ](https://packt.link/kbToQ).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/kbToQ](https://packt.link/kbToQ)找到用于此练习的代码。
- en: So far, this chapter has considered the various ways that individual tasks can
    be created and how static `Task` methods are used to create tasks that are started
    for us. You saw how `Task.Factory.StartNew` is used to create configured tasks,
    albeit with a longer set of configuration parameters. The `Task.Run` methods,
    which were more recently added to C#, are preferable by using their more concise
    signatures for most regular scenarios.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章已经考虑了可以创建个体任务的各种方式，以及如何使用静态`Task`方法来创建为我们启动的任务。您看到了如何使用`Task.Factory.StartNew`来创建配置的任务，尽管配置参数更长。最近添加到C#中的`Task.Run`方法，通过使用更简洁的签名，更适合大多数常规场景。
- en: Using continuations, single and multiple tasks can be left to run in isolation,
    only continuing with a final task when all or any of the preceding tasks have
    run to completion.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用连续性，单个和多个任务可以独立运行，只有在所有或任何前面的任务都已完成时才继续进行最终任务。
- en: Now it is time to look at the `async` and `wait` keywords to run asynchronous
    code. These keywords are a relatively new addition to the C# language. The `Task.Factory.StartNew`
    and `Task.Run` methods can be found in older C# applications, but hopefully, you
    will see that `async`/`await` provides a much clearer syntax.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看一下`async`和`await`关键字来运行异步代码了。这些关键字是C#语言的一个相对较新的添加。`Task.Factory.StartNew`和`Task.Run`方法可以在较旧的C#应用程序中找到，但希望您会发现`async`/`await`提供了更清晰的语法。
- en: Asynchronous Programming
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程
- en: So far, you have created tasks and used the static `Task` factory methods to
    run and coordinate such tasks. In earlier versions of C#, these were the only
    ways to create tasks.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经创建了任务，并使用静态`Task`工厂方法来运行和协调这些任务。在较早的C#版本中，这些是创建任务的唯一方式。
- en: The C# language now provides the `async` and `await` keywords to `async`/`await`
    style results in less code and the code that is created is generally easier to
    grasp and therefore easier to maintain.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言现在提供了`async`和`await`关键字，以`async`/`await`风格的结果代码更少，创建的代码通常更容易理解，因此更容易维护。
- en: Note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may often find that legacy concurrent-enabled applications were originally
    created using `Task.Factory.StartNew` methods are subsequently updated to use
    the equivalent `Task.Run` methods or are updated directly to the `async`/`await`
    style.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能经常发现，最初使用`Task.Factory.StartNew`方法创建的遗留并发应用程序随后更新为使用等效的`Task.Run`方法，或直接更新为`async`/`await`风格。
- en: The `async` keyword indicates that the method will return to the caller before
    it has had a chance to complete its operations, therefore the caller should wait
    for it to complete at some point in time.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`关键字表示该方法将在完成其操作之前返回给调用者，因此调用者应该在某个时间点等待它完成。'
- en: Adding the `async` keyword to a method instructs the compiler that it may need
    to generate additional code to create a state machine. In essence, a state machine
    extracts the logic from your original method into a series of delegates and local
    variables that allows code to continue onto the next statement following an `await` expression.
    The compiler generates delegates that can jump back to the same location in the
    method once they have completed.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 向方法添加`async`关键字指示编译器可能需要生成额外的代码来创建状态机。实质上，状态机将原始方法中的逻辑提取为一系列委托和本地变量，允许代码在`await`表达式之后继续执行下一个语句。编译器生成的委托可以在完成后跳回方法中的相同位置。
- en: Note
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You don't normally see this extra complied code, but if you are interested in
    learning more about state machines in C#, visit [https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c](https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您看不到这些额外的编译代码，但如果您对在C#中学习更多关于状态机感兴趣，请访问[https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c](https://devblogs.microsoft.com/premier-developer/dissecting-the-async-methods-in-c)。
- en: Adding the `async` keyword does not mean that `async` method is executed, it
    starts off running synchronously until it comes to a section of code with the
    `await` keyword. At this point, the awaitable block of code (in the following
    example, the `BuildGreetings` call is awaitable due to the preceding `async` keyword)
    is checked to see if it has already been completed. If so, it continues executing
    synchronously. If not, the asynchronous method is paused and returns an incomplete
    `Task` to the caller. This will be complete once the `async` code has been completed.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`async`关键字并不意味着`async`方法被执行，它开始以同步方式运行，直到到达具有`await`关键字的代码部分。此时，将检查可等待的代码块（在以下示例中，由于前面的`async`关键字，`BuildGreetings`调用是可等待的），以查看它是否已经完成。如果是，则继续以同步方式执行。如果没有，则异步方法暂停并向调用者返回一个不完整的`Task`。一旦`async`代码完成，这将完成。
- en: 'In the following console app, the entry point, `static Main`, has been marked
    as `async` and the `Task` return type added. You cannot mark a `Main` entry point,
    which returns either `int` or `void`, as `async` because the runtime must be able
    to return a `Task` result to the calling environment when the console app closes:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的控制台应用程序中，入口点`static Main`已标记为`async`，并添加了`Task`返回类型。您不能将返回`int`或`void`的`Main`入口点标记为`async`，因为运行时必须能够在控制台应用程序关闭时向调用环境返回`Task`结果。
- en: '[PRE46]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Running the example produces an output like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例会产生如下输出：
- en: '[PRE47]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As soon as `Main` runs, it logs `Starting`. Notice how the `ThreadId` is `[01]`.
    As you saw earlier, the console app's main thread is numbered as `1` (because
    the `Logger.Log` method uses the `00` format string, which adds a leading `0`
    to numbers in the range zero to nine).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Main`运行，它就会记录`Starting`。请注意`ThreadId`是`[01]`。正如您之前看到的，控制台应用程序的主线程编号为`1`（因为`Logger.Log`方法使用`00`格式字符串，它会在零到九范围内的数字前添加一个前导`0`）。
- en: Then the asynchronous method `BuildGreetings` is called. It sets the string
    `message` variable to `"Morning"` and logs the message. The `ThreadId` is still
    `[01]`; this is currently running synchronously.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用异步方法`BuildGreetings`。它将字符串`message`变量设置为`"Morning"`并记录消息。`ThreadId`仍然是`[01]`；这是当前同步运行的。
- en: So far, you have been using `Thread.Sleep` to block the calling thread in order
    or simulate long-running operations, but `async`/`await` makes it easier to simulate
    slow actions using the static `Task.Delay` method and awaiting that call. `Task.Delay`
    returns a task so it can also be used in continuation tasks.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您一直在使用`Thread.Sleep`来阻塞调用线程，以模拟长时间运行的操作，但是`async`/`await`使得使用静态的`Task.Delay`方法更容易模拟缓慢的操作，并等待该调用。`Task.Delay`返回一个任务，因此它也可以用于连续任务。
- en: Using `Task.Delay`, you will make two distinct awaitable calls (one that waits
    for 10 seconds and the second for two seconds), before continuing and appending
    to your local `message` string. The two `Task.Delay` calls could have been any
    method in your code that returns a `Task`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Task.Delay`，您将进行两个不同的可等待调用（一个等待10秒，另一个等待两秒），然后继续并附加到本地的`message`字符串。这两个`Task.Delay`调用可以是代码中返回`Task`的任何方法。
- en: The great thing here is that each awaited section gets its correct state in
    the order that it was declared in the code, irrespective of waiting 10 (or two)
    seconds prior. The thread IDs have all changed from `[01]` to `[04]`. This tells
    you that a different thread is running these statements. Even the very last `Press
    Enter` message has a different thread to the original thread.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的伟大之处在于，无论在代码中声明的顺序如何，每个等待的部分都会按照其正确的状态进行，不管之前等待了10（或两）秒。线程ID已经从`[01]`更改为`[04]`。这告诉您不同的线程正在运行这些语句。甚至最后的`Press
    Enter`消息也与原始线程不同。
- en: '`Async/await` makes it easier to run a series of task-based codes using the
    familiar `WhenAll`, `WhenAny`, and `ContinueWith` methods interchangeably.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`Async/await`使得可以更容易地运行一系列基于任务的代码，可以交替使用熟悉的`WhenAll`、`WhenAny`和`ContinueWith`方法。'
- en: The following example shows how multiple `async`/`await` calls can be applied
    at various stages in a program using a mixture of various awaitable calls. This
    simulates an application that makes a call to a database (`FetchPendingAccounts`)
    to fetch a list of user accounts. Each user in the pending accounts list is given
    a unique ID (using a task for each user).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何在程序的各个阶段使用多个`async`/`await`调用，使用各种可等待调用的混合。这模拟了一个应用程序，该应用程序调用数据库（`FetchPendingAccounts`）获取用户账户列表。待处理账户列表中的每个用户都会被分配一个唯一的ID（使用每个用户的任务）。
- en: Based on the user's region, an account is then created in the `Task.WhenAll`
    call signals that everything has been completed.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用户的地区，然后在`Task.WhenAll`调用中创建一个账户，表示一切都已完成。
- en: '[PRE48]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Use an `enum` to define a `RegionName`:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`enum`定义`RegionName`：
- en: '[PRE49]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A `User` record constructor is passed a `userName` and the user''s `region`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`记录构造函数接受`userName`和用户的`region`：'
- en: '[PRE50]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`AccountGenerator` is the main controlling class. It contains an `async` `CreateAccounts`
    method that can be awaited by a console app (this is implemented at the end of
    the example):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountGenerator`是主要的控制类。它包含一个`async`的`CreateAccounts`方法，可以被控制台应用程序等待（这是在示例的最后实现的）：'
- en: '[PRE51]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Using the `await` keyword, you define an awaitable call to `FetchPendingAccounts`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`await`关键字，您定义了一个可等待调用`FetchPendingAccounts`：
- en: '[PRE52]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For each one of the users returned by `FetchPendingAccounts`, you make an awaitable
    call to `GenerateId`. This shows that a loop can contain multiple awaitable calls.
    The runtime will set the user ID for the correct user instance:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`FetchPendingAccounts`返回的每个用户，您都会调用`GenerateId`进行等待。这表明循环可以包含多个可等待调用。运行时将为正确的用户实例设置用户ID：
- en: '[PRE53]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Using a Linq `Select` function, you create a list of tasks. For each user,
    a Northern or Other account is created based on the user''s region (each one of
    the calls is a `Task` per user):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Linq的`Select`函数，您可以创建一个任务列表。对于每个用户，根据用户的地区创建一个北部或其他账户（每个调用都是每个用户的`Task`）：
- en: '[PRE54]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The list of account creation tasks is awaited using the `static` `WhenAll`
    call. Once this completes, `UpdatePendindAccounts` will be called passing in the
    updated user list. This shows that you can pass lists of tasks between `async`
    statements:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`static`的`WhenAll`调用等待账户创建任务列表。一旦完成，将调用`UpdatePendindAccounts`，并传入更新后的用户列表。这表明您可以在`async`语句之间传递任务列表：
- en: '[PRE55]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `FetchPendingAccounts` method returns a `Task` containing a list of users
    (here you simulate a delay of `3` seconds using `Task.Delay`):'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchPendingAccounts`方法返回一个包含用户列表的`Task`（这里使用`Task.Delay`模拟了`3`秒的延迟）：'
- en: '[PRE56]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`GenerateId` uses `Task.FromResult` to generate a globally unique ID using
    the `Guid` class. `Task.FromResult` is used when you want to return a result but
    do not need to create a running task as you would with `Task.Run`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`GenerateId`使用`Task.FromResult`使用`Guid`类生成全局唯一ID。当您想要返回结果但不需要像使用`Task.Run`那样创建运行任务时，可以使用`Task.FromResult`。'
- en: '[PRE57]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The two `bool` task methods create either a northern account or other account.
    Here, you return `true` to indicate that each account creation call was successful, regardless:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`bool`任务方法分别创建北部账户或其他账户。在这里，您返回`true`以指示每个账户创建调用都成功了，而不管：
- en: '[PRE58]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, `UpdatePendingAccounts` is passed a list of users. For each user, you
    create a task that simulates a slow-running call to update each user and returning
    a count of the number of users subsequently updated:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`UpdatePendingAccounts`接收一个用户列表。对于每个用户，您都会创建一个模拟缓慢运行的调用的任务，以更新每个用户，并返回随后更新的用户数量：
- en: '[PRE59]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, the console app creates an `AccountGenerator` instance and waits for
    `CreateAccounts` to finish before writing an `All done` message:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，控制台应用程序创建一个`AccountGenerator`实例，并在写入`All done`消息之前等待`CreateAccounts`完成：
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Running the console app produces this output:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台应用程序会产生以下输出：
- en: '[PRE61]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, you can see that thread `[01]` writes the `Starting` message. This is
    the application's main thread. Note, too, that the main thread also writes `Fetching
    pending accounts...` from the `FetchPendingAccounts` method. This is still running
    synchronously as the awaitable block (`Task.Delay`) has not yet been reached.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到线程`[01]`写入`Starting`消息。这是应用程序的主线程。还要注意，主线程还从`FetchPendingAccounts`方法中写入`Fetching
    pending accounts...`。这仍然是同步运行的，因为可等待的块（`Task.Delay`）尚未到达。
- en: 'Threads `[4]`, `[5]`, and `[7]` create each of the four user accounts. You
    used `Task.Run` to call the `CreateNorthernAccount` or `CreateOtherAccount` methods.
    Thread `[5]` runs the last statement in `CreateAccounts: Updated 4 pending accounts`.
    The thread numbers might differ in your system because .NET uses an internal pool
    of threads which vary based on how busy each thread is.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '线程`[4]`，`[5]`和`[7]`分别创建了四个用户帐户。您使用`Task.Run`来调用`CreateNorthernAccount`或`CreateOtherAccount`方法。线程`[5]`运行`CreateAccounts:
    Updated 4 pending accounts`中的最后一个语句。线程号可能因您的系统而异，因为.NET使用一个基于每个线程的繁忙程度而变化的内部线程池。'
- en: Note
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/ZIK8k](https://packt.link/ZIK8k).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/ZIK8k](https://packt.link/ZIK8k)找到此示例的代码。
- en: Async Lambda Expressions
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步Lambda表达式
- en: '*Chapter 3*, *Delegates, Events, and Lambdas*, looked at lambda expressions
    and how they can be used to create succinct code. You can also use the `async`
    keyword with lambda expressions to create code for an event handler that contains
    various `async` code.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*第3章*，*委托，事件和Lambda*，介绍了lambda表达式以及它们如何用于创建简洁的代码。您还可以在lambda表达式中使用`async`关键字来创建包含各种`async`代码的事件处理程序代码。'
- en: The following example uses the `WebClient` class to show two different ways
    to download data from a website (this will be covered in great detail in *Chapter
    8*, *Creating and Using Web API Clients* and *Chapter 9*, *Creating API Services*).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`WebClient`类展示了从网站下载数据的两种不同方式（这将在*第8章*，*创建和使用Web API客户端*和*第9章*，*创建API服务*中详细介绍）。
- en: '[PRE62]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, you add your own event handler to the `WebClient` class `DownloadDataCompleted`
    event using a lambda statement that is prefixed with the `async` keyword. The
    compiler will allow you to add awaitable calls inside the body of the lambda.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以使用`async`关键字将自己的事件处理程序添加到`WebClient`类的`DownloadDataCompleted`事件中，使用带有`async`关键字的lambda语句。编译器将允许您在lambda的主体内添加可等待的调用。
- en: 'This event will be fired after `DownloadData` is called and the data requested
    has been downloaded for us. The code uses an awaitable block `Task.Delay` to simulate
    some extra processing on a different thread:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件将在调用`DownloadData`并且我们请求的数据已经为我们下载完成后触发。该代码使用可等待的块`Task.Delay`来模拟在不同线程上进行一些额外处理：
- en: '[PRE63]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You invoke the `DownloadData` method, passing in your URL and then logging
    the length of the web data received. This particular call itself will block the
    main thread until data is downloaded. `WebClient` offers a task-based asynchronous
    version of the `DownloadData` method called `DownloadDataTaskAsync`. So it''s
    recommended to use the more modern `DownloadDataTaskAsync` method as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 您调用`DownloadData`方法，传入您的URL，然后记录接收到的Web数据的长度。这个特定的调用本身将阻塞主线程，直到数据被下载。`WebClient`提供了`DownloadData`方法的基于任务的异步版本，称为`DownloadDataTaskAsync`。因此建议使用更现代的`DownloadDataTaskAsync`方法如下：
- en: '[PRE64]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Once again, you request the same URL but can simply use an `await` statement,
    which will be run once the data download has been completed. As you can see, this
    requires less code and has a cleaner syntax:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您请求相同的URL，但可以简单地使用`await`语句，一旦数据下载完成就会运行。正如您所看到的，这需要更少的代码并且具有更清晰的语法：
- en: '[PRE65]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Running the code produces this output:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会产生以下输出：
- en: '[PRE66]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'When running the program, you may see the following warning: `"Warning SYSLIB0014:
    ''WebClient.WebClient()'' is obsolete: ''WebRequest, HttpWebRequest, ServicePoint,
    and WebClient are obsolete. Use HttpClient instead.''"`. Here, Visual Studio has
    suggested that the `HttpClient` class be used, as `WebClient` has been marked
    as obsolete.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序时，您可能会看到以下警告：“'WebClient.WebClient()'已过时：'WebRequest，HttpWebRequest，ServicePoint和WebClient已过时。请改用HttpClient。'”。在这里，Visual
    Studio建议使用`HttpClient`类，因为`WebClient`已被标记为过时。
- en: '`DownloadData` is logged by thread `[01]`, the main thread, which is blocked
    for around one second until the download completes. The size of the downloaded
    file is then logged using the `downloadBytes.Length` property.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`DownloadData`由线程`[01]`，即主线程，记录，该线程在下载完成前被阻塞了大约一秒钟。然后使用`downloadBytes.Length`属性记录下载文件的大小。'
- en: The `DownloadDataTaskAsync` request is handled by thread `06`. Finally, the
    delayed code inside the `DownloadDataCompleted` event handler completes via thread
    `04`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`DownloadDataTaskAsync`请求由线程`06`处理。最后，`DownloadDataCompleted`事件处理程序中的延迟代码通过线程`04`完成。'
- en: Note
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/IJEaU](https://packt.link/IJEaU).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/IJEaU](https://packt.link/IJEaU)找到此示例的代码。
- en: Canceling Tasks
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消任务
- en: 'Task cancelation is a two-step approach:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 任务取消是一个两步方法：
- en: You need to add a way to request a cancelation.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要添加一种请求取消的方法。
- en: Any cancelable code needs to support this.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何可取消的代码都需要支持这一点。
- en: You cannot provide cancelation without both mechanisms in place.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这两种机制，您无法提供取消。
- en: Typically, you will start a long-running task that supports cancelation and
    provide the user with the ability to cancel the operation by pressing a button
    on a UI. There are many real-world examples where such cancellation is needed,
    such as image processing where multiple images need to be altered allowing a user
    to cancel the remainder of the task if they run out of time. Another common scenario
    is sending multiple data requests to different web servers and allowing slow-running
    or pending requests to be canceled as soon as the first response is received.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您将启动一个支持取消的长时间运行的任务，并通过在UI上按下按钮来提供用户取消操作的能力。有许多现实世界的例子需要这样的取消，例如图像处理，其中需要修改多个图像，允许用户在时间用尽时取消任务的其余部分。另一个常见的场景是向不同的Web服务器发送多个数据请求，并允许取消运行缓慢或挂起的请求，一旦收到第一个响应就可以取消。
- en: In C#, `CancellationTokenSource` acts as a top-level object to initiate a cancelation
    request with its `Token` property, `CancellationToken`, being passed to concurrent/slow
    running code that can periodically check and act upon this cancellation status.
    Ideally, you would not want low-level methods to arbitrarily cancel high-level
    operations, hence the separation between the source and the token.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，`CancellationTokenSource`充当顶级对象，使用其`Token`属性`CancellationToken`传递给并发/运行缓慢的代码，该代码可以定期检查并根据取消状态采取行动。理想情况下，您不希望低级方法随意取消高级操作，因此源和令牌之间有区分。
- en: 'There are various `CancellationTokenSource` constructors, including one that
    will initiate a cancel request after a specified time has elapsed. Here are a
    few of the `CancellationTokenSource` methods, offering various ways to initiate
    a cancellation request:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种`CancellationTokenSource`构造函数，包括一个在指定时间后发起取消请求的构造函数。以下是一些`CancellationTokenSource`方法，提供了各种发起取消请求的方式：
- en: '`public bool IsCancellationRequested { get; }`: This returns `true` if a cancellation
    has been requested for this token source (a caller has called the `Cancel` method).
    This can be inspected at intervals in the target code.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsCancellationRequested { get; }`: 如果已经为此令牌源请求了取消（调用者已调用`Cancel`方法），则返回`true`。这可以在目标代码中间隔地进行检查。'
- en: '`public CancellationToken Token { get; }`: The `CancellationToken` that is
    linked to this source object is often passed to `Task.Run` overloads, allowing
    .NET to check the status of pending tasks or for your own code to check while
    running.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CancellationToken Token { get; }`: 与此源对象关联的`CancellationToken`通常传递给`Task.Run`重载，允许.NET检查挂起任务的状态，或者让您自己的代码在运行时检查。'
- en: '`public void Cancel()`: Initiates a request for cancellation.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void Cancel()`: 启动取消请求。'
- en: '`public void Cancel(bool throwOnFirstException)`: Initiates a request for cancellation
    and determines whether further operations are to be processed should an exception
    occur.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void Cancel(bool throwOnFirstException)`: 启动取消请求，并确定是否应处理进一步的操作，如果发生异常。'
- en: '`public void CancelAfter(int millisecondsDelay)`: Schedules a cancel request
    after a specified number of milliseconds.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void CancelAfter(int millisecondsDelay)`: 在指定的毫秒数后安排取消请求。'
- en: '`CancellationTokenSource` has a `Token` property. `CancellationToken` contains
    various methods and properties that can be used for code to detect a cancellation
    request:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`CancellationTokenSource`有一个`Token`属性。`CancellationToken`包含各种方法和属性，可用于代码检测取消请求：'
- en: '`public bool IsCancellationRequested { get; }`: This returns `true` if a cancellation
    has been requested for this token.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsCancellationRequested { get; }`: 如果已经为此令牌请求了取消，则返回`true`。'
- en: '`public CancellationTokenRegistration Register(Action callback)`: Allows code
    to register a delegate that will be executed by the system if this token is canceled.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CancellationTokenRegistration Register(Action callback)`: 允许代码注册一个委托，如果此令牌被取消，系统将执行该委托。'
- en: '`public void ThrowIfCancellationRequested()`: Calling this method will result
    in `OperationCanceledException` being thrown if a cancellation has been requested.
    This is typically used to break out of loops.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void ThrowIfCancellationRequested()`: 如果已经请求了取消，调用此方法将导致抛出`OperationCanceledException`。这通常用于跳出循环。'
- en: Throughout the previous examples, you may have spotted that `CancellationToken`
    can be passed to many of the static `Task` methods. For example, `Task.Run`, `Task.Factory.StartNew`,
    and `Task.ContinueWith` all contain overrides that accept `CancellationToken`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您可能已经注意到`CancellationToken`可以传递给许多静态`Task`方法。例如，`Task.Run`，`Task.Factory.StartNew`和`Task.ContinueWith`都包含接受`CancellationToken`的重载。
- en: .NET will not try to interrupt or stop any of your code once it is running,
    no matter how many times you call `Cancel` on a `CancellationToken`. Essentially,
    you pass these tokens into target code, but it is up to that code to periodically
    check the cancellation status whenever it can, such as within a loop, and then
    decide how it should act upon it. This makes logical sense; how would .NET know
    at what point it was safe to interrupt a method, maybe one that has hundreds of
    lines of code?
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: .NET不会尝试中断或停止任何正在运行的代码，无论您在`CancellationToken`上调用`Cancel`多少次。基本上，您将这些令牌传递到目标代码中，但由该代码定期检查取消状态，每当可能时，例如在循环内，然后决定如何对其进行操作。这是合乎逻辑的；.NET如何知道在何时安全地中断一个方法，也许是一个有数百行代码的方法？
- en: Passing `CancellationToken` to `Task.Run` only provides a hint to the queue
    scheduler that it may not need to start a task's action, but once started, .NET
    will not stop that running code for you. The running code itself must subsequently
    observe the cancelation status.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 将`CancellationToken`传递给`Task.Run`只是向队列调度程序提供一个提示，表明它可能不需要启动任务的操作，但一旦启动，.NET将不会为您停止正在运行的代码。运行的代码本身随后必须观察取消状态。
- en: This is analogous to a pedestrian waiting to cross a road at a set of traffic
    lights. Motor vehicles can be thought of as tasks that have been started elsewhere.
    When the pedestrian arrives at the crossing and they press a button (calling `Cancel`
    on `CancellationTokenSource`), the traffic lights should eventually change to
    red so that the moving vehicles are requested to stop. It is up to each individual
    driver to observe that the red light has changed (`IsCancellationRequested`) and
    then decide to stop their vehicle. The traffic light does not forcibly stop each
    vehicle (.NET runtime). If a driver notices that the vehicle behind is too close
    and stopping soon may result in a collision, they may decide to not stop immediately.
    A driver that is not observing the traffic light status at all may fail to stop.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于行人在等待通过一组交通灯穿过马路。机动车可以被认为是在其他地方启动的任务。当行人到达十字路口并按下按钮（调用“Cancel”在“CancellationTokenSource”上），交通灯应该最终变成红色，以便移动车辆被要求停止。每个驾驶员都要观察到红灯已经改变（“IsCancellationRequested”），然后决定停止他们的车辆。交通灯不会强制停止每辆车（.NET运行时）。如果驾驶员注意到后面的车太近，立即停车可能会导致碰撞，他们可能决定不立即停车。根本没有注意交通灯状态的驾驶员可能会未能停车。
- en: The next sections will continue with exercises that show `async`/`await` in
    action, some of the commonly used options for canceling tasks, in which you will
    need to control whether pending tasks should be allowed to run to completion or
    interrupted, and when you should aim to catch exceptions.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将继续进行显示“async”/“await”在操作中的练习，一些常用的取消任务选项，您需要控制是否允许挂起任务运行到完成或中断，以及何时应该捕获异常。
- en: 'Exercise 5.04: Canceling Long-Running Tasks'
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.04：取消长时间运行的任务
- en: 'You will create this exercise in two parts:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 您将分两部分创建此练习：
- en: One that uses a `Task` that returns a double-based result.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用返回双精度结果的“Task”的一个。
- en: Second that provides a fine-grained level of control by inspecting the `Token.IsCancellationRequested`
    property.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个提供了通过检查“Token.IsCancellationRequested”属性来进行细粒度控制的方法。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: 'Create a class called `SlowRunningService`. As the name suggests, the methods
    inside the service have been designed to be slow to complete:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“SlowRunningService”的类。顾名思义，服务内部的方法被设计为完成速度较慢：
- en: '[PRE67]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Add the first slow-running operation, `Fetch`, which is passed a delay time
    (implemented with a simple `Thread.Sleep` call), and the cancellation token, which
    you pass to `Task.Run`:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第一个耗时操作“Fetch”，它传递了一个延迟时间（使用简单的“Thread.Sleep”调用实现），以及取消令牌，您将其传递给“Task.Run”：
- en: '[PRE68]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When `Fetch` is called, the token may get canceled before the sleeping thread awakes.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用“Fetch”时，线程休眠之前可能会取消令牌。
- en: 'To test whether `Fetch` will just stop running or return a number, add a console
    app to test this. Here, use a default delay (`DelayTime`) of `3` seconds:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试“Fetch”是否会停止运行或返回一个数字，添加一个控制台应用程序来测试这一点。在这里，使用默认延迟（“DelayTime”）为“3”秒：
- en: '[PRE69]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add a helper function to prompt for a maximum number of seconds that you are
    prepared to wait. If a valid number is entered, convert the value entered into
    a `TimeSpan`:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个辅助函数来提示您准备等待的最大秒数。如果输入了有效数字，则将输入的值转换为“TimeSpan”：
- en: '[PRE70]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Add a standard `Main` entry point for the console app. This is marked async
    and returns a `Task`:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为控制台应用程序添加一个标准的“Main”入口点。这是异步标记的，并返回一个“Task”：
- en: '[PRE71]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Create an instance of the service. You will use the same instance in a loop, shortly:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建服务的实例。您将在不久的将来在循环中使用相同的实例：
- en: '[PRE72]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now add a `do`-loop that repeatedly asks for a maximum delay time:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个“do”循环，重复询问最大延迟时间：
- en: '[PRE73]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This allows you to try various values to see how that affects the cancel token
    and the results you receive back. In the case of a `null` value, you will `break`
    out of the `do`-loop.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您可以尝试各种值，以查看它对取消令牌和您收到的结果的影响。在“null”值的情况下，您将从“do”循环中“break”出来。
- en: 'Create `CancellationTokenSource`, passing in the maximum waiting time:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建“CancellationTokenSource”，传入最大等待时间：
- en: '[PRE74]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This will trigger a cancellation without having to call the `Cancel` method yourself.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这将触发取消，而无需自己调用“Cancel”方法。
- en: 'Using the `CancellationToken.Register` method, pass an `Action` delegate to
    be invoked when the token gets signaled for cancellation. Here, simply log a message
    when that occurs:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“CancellationToken.Register”方法，传递一个在令牌被取消时调用的“Action”委托。在这里，当发生这种情况时，简单地记录一条消息：
- en: '[PRE75]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now for the main activity, call the service''s `Fetch` method, passing in the
    default `DelayTime` and the token:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是主要活动，调用服务的“Fetch”方法，传入默认的“DelayTime”和令牌：
- en: '[PRE76]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Before you await `resultTask`, add a `try-catch` block to catch any `TaskCanceledException`:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在等待“resultTask”之前，添加一个“try-catch”块来捕获任何“TaskCanceledException”：
- en: '[PRE77]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: When using cancelable tasks, there is a possibility that they will throw `TaskCanceledException`.
    In this case, that is okay as you do expect that to happen. Notice that you only
    access the `resultTask.Result` if the task is marked as `IsCompletedSuccessfully`.
    If you attempt to access the `Result` property of a faulted task, then `AggregateException`
    instance is thrown. In some older projects, you may see non-async/await code that
    catches `AggregateException`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用可取消任务时，有可能会抛出“TaskCanceledException”。在这种情况下，这是可以接受的，因为你确实希望发生这种情况。请注意，只有在任务标记为“IsCompletedSuccessfully”时才访问“resultTask.Result”。如果尝试访问故障任务的“Result”属性，则会抛出“AggregateException”实例。在一些较旧的项目中，您可能会看到捕获“AggregateException”的非异步/等待代码。
- en: 'Run the app and enter a waiting time greater than the ETA of three seconds,
    `5` in this case:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，并输入大于三秒的预计到达时间的等待时间，“5”在这种情况下：
- en: '[PRE78]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: As expected, the token was not canceled prior to completion, so you see `Result=3`
    (the elapsed time in seconds).
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，令牌在完成之前未被取消，因此您会看到“Result=3”（以秒为单位的经过时间）。
- en: 'Try this again. For the cancellation to be triggered and detected, enter `2`
    for the number of seconds:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再试一次。为了触发和检测取消，输入“2”作为秒数：
- en: '[PRE79]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Notice that the `Cancelled token` message is logged `Fetch` awakes, but you
    still end up receiving a result of `3` seconds with no `TaskCanceledException`
    message. This emphasizes the point that passing a cancellation token to `Start.Run`
    does not stop the task's action from starting, and more importantly, it did not
    interrupt it either.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，被记录的`Cancelled token`消息是`Fetch`醒来，但您最终仍然收到了一个`3`秒的结果，没有`TaskCanceledException`消息。这强调了将取消令牌传递给`Start.Run`并不会阻止任务的动作启动，更重要的是，它也没有中断它。
- en: 'Finally, use `0` as the maximum waiting time, which will effectively trigger
    the cancellation immediately:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`0`作为最大等待时间，这将有效地立即触发取消：
- en: '[PRE80]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You will see the canceled token message and `TaskCanceledException` being caught,
    but there are no `Sleeping` or `Awake` messages logged at all. This shows that
    the `Action` passed to `Task.Run` was not actually started by the runtime. When
    you pass a `CancelationToken` to `Start.Run`, the task's `Action` gets queued
    but `TaskScheduler` will not run the action if it notices that the token has been
    canceled prior to starting; it just throws `TaskCanceledException`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到取消令牌消息和被捕获的`TaskCanceledException`，但根本没有记录`Sleeping`或`Awake`消息。这表明传递给`Start.Run`的`Action`实际上并没有被运行。当您将`CancelationToken`传递给`Start.Run`时，任务的`Action`被排队，但是如果`TaskScheduler`在启动之前注意到令牌已被取消，它就会抛出`TaskCanceledException`，而不会运行动作。
- en: Now for an alternative slow-running method, one that allows you to support cancellable
    actions via a loop that polls for a change in the cancellation status.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于另一种运行缓慢的方法，一种允许您通过轮询取消状态的循环来支持可取消操作的方法。
- en: 'In the `SlowRunningService` class, add a `FetchLoop` function:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SlowRunningService`类中，添加一个`FetchLoop`函数：
- en: '[PRE81]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This produces a result similar to the earlier `Fetch` function but its purpose
    is to show how a function can be broken into a repeating loop that offers the
    ability to examine `CancellationToken` as each loop iteration runs.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了与之前的`Fetch`函数类似的结果，但其目的是展示如何将函数分解为一个重复循环，该循环提供了检查`CancellationToken`的能力，每次循环迭代都会运行。
- en: 'Define the body of a `for...next` loop, which checks, for each iteration, if
    the `IsCancellationRequested` property is `true` and simply returns a nullable
    double if it detects that a cancellation has been requested:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`for...next`循环的主体，该循环在每次迭代时检查`IsCancellationRequested`属性是否为`true`，并在检测到取消请求时返回一个可空的双精度数：
- en: '[PRE82]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This is a rather firm way to exit a loop, but as far as this code is concerned,
    nothing else needs to be done.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种相当坚定的退出循环的方式，但就这段代码而言，不需要做其他事情。
- en: Note
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You could have also used a `continue` statement and cleaned up before returning.
    Another option is to call `token.ThrowIfCancellationRequested()` rather than checking
    `token.IsCancellationRequested`, which will force you to exit the `for` loop.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`continue`语句并在返回之前清理。另一个选择是调用`token.ThrowIfCancellationRequested()`而不是检查`token.IsCancellationRequested`，这将强制您退出`for`循环。
- en: 'In the `Main` console app, add a similar `while` loop that calls the `FetchLoop`
    method this time. The code is similar to the previous looping code:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`控制台应用程序中，这次添加一个类似的`while`循环，调用`FetchLoop`方法。代码与之前的循环代码类似：
- en: '[PRE83]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now call the `FetchLoop` and await the result:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在调用`FetchLoop`并等待结果：
- en: '[PRE84]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Running the console app and using a `5`-second maximum allows all the iterations
    to run through with none detecting a cancellation request. The result is `3` as expected:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并使用`5`秒的最大值允许所有迭代运行，没有一个检测到取消请求。结果是`3`，正如预期的那样：
- en: '[PRE85]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Use `2` as the maximum. This time the token is auto-triggered during iteration
    `4` and spotted by iteration `5`, so you are returned a null result:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`2`作为最大值。这次令牌在迭代`4`期间自动触发，并在迭代`5`中被发现，因此您将得到一个空结果：
- en: '[PRE86]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'By using `0`, you see the same output as the earlier `Fetch` example:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`0`，您将看到与之前的`Fetch`示例相同的输出：
- en: '[PRE87]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The action doesn't get a chance to run. You can see a `Cancelled token` message
    and `TaskCanceledException` being logged.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作没有机会运行。您可以看到一个`Cancelled token`消息和被记录的`TaskCanceledException`。
- en: By running this exercise, you have seen how long-running tasks can be automatically
    marked for cancellation by the .NET runtime if they do not complete within a specified
    time. By using a `for` loop, a task was broken down into small iterative steps,
    which provided a frequent opportunity to detect if a cancellation was requested.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行这个练习，您已经看到了长时间运行的任务如果在指定的时间内没有完成，可以被.NET运行时自动标记为取消。通过使用`for`循环，一个任务被分解成小的迭代步骤，这提供了频繁的机会来检测是否请求了取消。
- en: Note
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/xa1Yf](https://packt.link/xa1Yf).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/xa1Yf](https://packt.link/xa1Yf)找到此练习使用的代码。
- en: Exception Handling in Async/Await Code
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步/等待代码中的异常处理
- en: You have seen that canceling a task can result in `TaskCanceledException` being
    thrown. Exception handling for asynchronous code can be implemented in the same
    way you would for standard synchronous code, but there are a few things you need
    to be aware of.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到取消任务可能导致抛出`TaskCanceledException`。异步代码的异常处理可以以与标准同步代码相同的方式实现，但有一些需要注意的事项。
- en: When code in an `async` method causes an exception to be thrown, the task's
    status is set to **Faulted**. However, an exception will not be rethrown until
    the awaited expression gets rescheduled. What this mean is that if you do not
    await a call, then it's possible for exceptions to be thrown and to go completely
    unobserved in code.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 当`async`方法中的代码导致异常被抛出时，任务的状态被设置为**Faulted**。但是，直到等待的表达式被重新安排之前，异常才不会被重新抛出。这意味着如果您不等待调用，那么可能会在代码中抛出异常并完全不被观察到。
- en: Unless you absolutely cannot help it, you should not create `async void` methods.
    Doing so makes it difficult for the caller to await your code. This means they
    cannot catch any exceptions raised, which by default, will terminate a program.
    If the caller is not given a `Task` reference to await, then there is no way for
    them to tell if the called method ran to completion or not.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您绝对不能帮助它，否则不应创建“async void”方法。这样做会使调用者难以等待您的代码。这意味着他们无法捕获引发的任何异常，默认情况下，这将终止程序。如果调用者没有给予“Task”引用以等待，则他们无法知道被调用的方法是否已完成。
- en: The general exception to this guideline is in the case of fire-and-forget methods
    as mentioned at the start of the chapter. A method that asynchronously logs the
    usage of the application may not be of such critical importance, so you may not
    care if such calls are successful or not.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 对此指南的一般例外是在本章开头提到的fire-and-forget方法的情况下。异步记录应用程序使用情况的方法可能并不那么重要，因此您可能不在乎这样的调用是否成功。
- en: 'It is possible to detect and handle unobserved task exceptions. If you attach
    an event delegate to the static `TaskScheduler.UnobservedTaskException` event,
    you can receive a notification that a task exception has gone unobserved. You
    can attach a delegate to this event as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 可以检测和处理未观察到的任务异常。如果将事件委托附加到静态`TaskScheduler.UnobservedTaskException`事件，则可以收到任务异常未被观察到的通知。您可以按照以下方式将委托附加到此事件：
- en: '[PRE88]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The runtime considers a task exception to be **unobserved** once the task object
    is finalized.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时一旦任务对象被最终化，就会将任务异常视为**未观察到**。
- en: Note
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/OkH7r](https://packt.link/OkH7r).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/OkH7r](https://packt.link/OkH7r)找到此示例使用的代码。
- en: Continuing with some more exception handling examples, see how you can catch
    a specific type of exception as you would with synchronous code.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行更多的异常处理示例，看看如何像处理同步代码一样捕获特定类型的异常。
- en: In the following example, the `CustomerOperations` class provides the `AverageDiscount`
    function, which returns `Task<int>`. However, there is a chance that it may throw
    `DivideByZeroException`, so you will need to catch that; otherwise, the program
    will crash.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`CustomerOperations`类提供`AverageDiscount`函数，返回`Task<int>`。但是，它有可能引发`DivideByZeroException`，因此您需要捕获它；否则，程序将崩溃。
- en: '[PRE89]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Create a `CustomerOperations` instance and wait for the `AverageDiscount` method
    to return a value:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`CustomerOperations`实例，并等待`AverageDiscount`方法返回一个值：
- en: '[PRE90]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Choose a random value for `ordercount` between `0` and `2`. An attempt to divide
    by zero will result in an exception being thrown by the .NET runtime:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`ordercount`在`0`和`2`之间的随机值。尝试除以零将导致.NET运行时引发异常：
- en: '[PRE91]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The results show that when `orderCount` was zero, you did catch `DivideByZeroException`
    as expected:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，当`orderCount`为零时，您确实捕获了`DivideByZeroException`：
- en: '[PRE92]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Running a second time, there was no error caught:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次运行时，没有捕获到错误：
- en: '[PRE93]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: On your system you may find that the program needs to be run multiple times
    before the `DivideByZeroException` is raised. This is due to the use of a random
    instance to assign a value to `orderCount`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的系统上，您可能会发现需要多次运行程序，才会引发`DivideByZeroException`。这是由于使用随机实例为`orderCount`分配值。
- en: Note
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/18kOK](https://packt.link/18kOK).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/18kOK](https://packt.link/18kOK)找到此示例使用的代码。
- en: So far, you have created single tasks that may throw exceptions. The following
    exercise will look at a more complex variant.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经创建了可能引发异常的单个任务。以下练习将查看更复杂的变体。
- en: 'Exercise 5.05: Handling Async Exceptions'
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.05：处理异步异常
- en: Imagine you have a `CustomerOperations` class that can be used to fetch a list
    of customers via a `Task`. For each customer, you need to run an extra `async`
    task, which goes off to a service to calculate the total value of that customer's
    orders.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 想象您有一个`CustomerOperations`类，可以通过`Task`获取客户列表。对于每个客户，您需要运行额外的`async`任务，该任务会去服务计算该客户订单的总价值。
- en: Once you have your customer list, the customers need to be sorted in descending
    order of sales, but due to some security restrictions, you are not allowed to
    read a customer's `TotalOrders` property if their region name is `West`. In this
    exercise you will create a copy of the `RegionName` enum that was used in the
    earlier example.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了客户列表，就需要按销售额降序对客户进行排序，但由于一些安全限制，如果他们的地区名称是“West”，则不允许读取客户的“TotalOrders”属性。在此练习中，您将创建一个`RegionName`枚举的副本，该枚举在早期示例中使用。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Start by adding the `Customer` class:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加`Customer`类：
- en: '[PRE94]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The constructor is passed the customer `name` and their `region`, along with
    a second region that identifies the `protectedRegion` name. If the customer's
    `region` is the same as this `protectedRegion`, then throw an access violation
    exception on any attempt to read the `TotalOrders` property.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数传递了客户的“名称”和他们的“地区”，以及一个标识“protectedRegion”名称的第二个地区。如果客户的“地区”与此“protectedRegion”相同，则在尝试读取“TotalOrders”属性时引发访问违例异常。
- en: 'Then add a `CustomerOperations` class:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加一个`CustomerOperations`类：
- en: '[PRE95]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This knows how to load a customer's name and populate their total order value.
    The requirement here is that customers from the `West` region need to have a restriction
    hardcoded, so add a constant called `ProtectedRegion` that has `RegionName.West`
    as a value.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这知道如何加载客户的名称并填充其总订单价值。这里的要求是，来自“West”地区的客户需要有一个硬编码的限制，因此添加一个名为`ProtectedRegion`的常量，其值为`RegionName.West`。
- en: 'Add a `FetchTopCustomers` function:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`FetchTopCustomers`函数：
- en: '[PRE96]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This returns a `Task` enumeration of `Customer` and is marked as `async` as
    you will make further `async` calls to populate each customer's order details
    inside the function. Await using `Task.Delay` to simulate a slow-running operation.
    Here, a sample list of customers is hardcoded. Create each `Customer` instance,
    passing their name, actual region, and the protected region constant, `ProtectedRegion`.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个`Customer`的`Task`枚举，并标记为`async`，因为你将进一步进行`async`调用来填充每个客户的订单细节。使用`Task.Delay`来模拟一个运行缓慢的操作。在这里，一个客户的样本列表是硬编码的。创建每个`Customer`实例，传递他们的名字，实际区域和受保护的区域常量`ProtectedRegion`。
- en: 'Add an `await` call to `FetchOrders` (which will be declared shortly):'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FetchOrders`（很快会声明）中添加一个`await`调用：
- en: '[PRE97]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now, iterate through the list of customers, but be sure to wrap each call to
    `TotalOrders` with a `try-catch` block that explicitly checks for the access violation
    exception that will be thrown if you attempt to view a protected customer:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，遍历客户列表，但一定要用一个`try-catch`块包装对`TotalOrders`的每个调用，明确检查访问违规异常，如果你尝试查看受保护的客户，它将被抛出：
- en: '[PRE98]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now that the `filteredCustomers` list has been populated with a filtered list
    of customers, use the Linq `OrderByDescending` extension method to return the
    items sorted by each customer''s `TotalOrders` value:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`filteredCustomers`列表已经填充了一个经过筛选的客户列表，使用Linq的`OrderByDescending`扩展方法按每个客户的`TotalOrders`值排序返回项目：
- en: '[PRE99]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Finish off `CustomerOperations` with the `FetchOrders` implementation.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`FetchOrders`实现`CustomerOperations`的结束。
- en: 'For each customer in the list, use an `async` lambda that pauses for `500`
    milliseconds before assigning a random value to `TotalOrders`:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于列表中的每个客户，使用一个`async` lambda，在分配随机值给`TotalOrders`之前暂停`500`毫秒：
- en: '[PRE100]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The delay could represent another slow-running service.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟可能代表另一个运行缓慢的服务。
- en: 'Wait for `orderUpdateTasks` to complete using `Task.WhenAll`:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Task.WhenAll`等待`orderUpdateTasks`完成：
- en: '[PRE101]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now create a console app to run the operation:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个控制台应用程序来运行这个操作：
- en: '[PRE102]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'On running the console, there are no errors as `Roy Batty` from the `West`
    region was skipped safely:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行控制台时，没有错误，因为来自`West`地区的`Roy Batty`被安全地跳过了：
- en: '[PRE103]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: In this exercise, you saw how exceptions can be handled gracefully with asynchronous
    code. You placed a `try-catch` block at the required location, rather than over-complicating
    and adding too many unnecessary levels of nested `try-catch` blocks. When the
    code was run, an exception was caught that did not crash the application.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你看到了异常如何在异步代码中得到优雅处理。你在需要的位置放置了一个`try-catch`块，而不是过于复杂和添加太多不必要的嵌套`try-catch`块。当运行代码时，捕获了一个不会使应用程序崩溃的异常。
- en: Note
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/4ozac](https://packt.link/4ozac).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/4ozac](https://packt.link/4ozac)找到这个练习中使用的代码。
- en: The AggregateException Class
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AggregateException类
- en: At the beginning of the chapter, you saw that the `Task` class has an `Exception`
    property of type `AggregateException`. This class contains details about one or
    more errors that occur during an asynchronous call.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，你看到`Task`类有一个`AggregateException`类型的`Exception`属性。这个类包含了在异步调用过程中发生的一个或多个错误的详细信息。
- en: '`AggregateException` has various properties, but the main ones are as follows:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`AggregateException`有各种属性，但主要的是：'
- en: '`public ReadOnlyCollection<Exception> InnerExceptions { get; }`: A collection
    of exceptions that caused the current exception. A single asynchronous call can
    result in multiple exceptions being raised and collected here.'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public ReadOnlyCollection<Exception> InnerExceptions { get; }`: 导致当前异常的异常集合。一个单独的异步调用可能会导致多个异常被引发和收集在这里。'
- en: '`public AggregateException Flatten()`: Flattens all of the `AggregateException`
    instances in the `InnerExeceptions` property into a single new instance. This
    saves you from having to iterate over `AggregateException` nested with the exceptions
    list.'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public AggregateException Flatten()`: 将`InnerExeceptions`属性中的所有`AggregateException`实例展平为一个新实例。这样可以避免迭代异常列表中嵌套的`AggregateException`。'
- en: '`public void Handle(Func<Exception, bool> predicate)`: Invokes the specified
    Func handler on every exception in this aggregate exception. This allows the handler
    to return `true` or `false` to indicate whether each exception was handled. Any
    remaining unhandled exceptions will be thrown for the caller to catch as required.'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void Handle(Func<Exception, bool> predicate)`: 在这个聚合异常中对每个异常调用指定的Func处理程序。这允许处理程序返回`true`或`false`来指示每个异常是否被处理。任何剩余的未处理异常将被抛出，供调用者根据需要捕获。'
- en: When something goes wrong and this exception is caught by a caller, `InnerExceptions`
    contains a list of the exceptions that caused the current exception. These can
    be from multiple tasks, so each individual exception is added to the resulting
    task's `InnerExceptions` collection.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现问题并且这个异常被调用者捕获时，`InnerExceptions`包含导致当前异常的异常列表。这些可能来自多个任务，所以每个单独的异常都被添加到结果任务的`InnerExceptions`集合中。
- en: 'You may often find `async` code with a `try-catch` block that catches `AggregateException`
    and logs each of `InnerExceptions` details. In this example, `BadTask` returns
    an `int` based task, but it can be the cause of an exception when run. Perform
    the following steps to complete this example:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会发现`async`代码中有一个`try-catch`块，它捕获`AggregateException`并记录每个`InnerExceptions`的细节。在这个例子中，`BadTask`返回一个基于任务的`int`，但在运行时可能会引发异常。执行以下步骤来完成这个例子：
- en: '[PRE104]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'It sleeps for `1,000` milliseconds before throwing the `InvalidOperationException`
    in case the number passed in is an even number (using the % operator to see if
    the number can be divided by `2` with no remainder):'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 它在抛出`InvalidOperationException`之前睡眠`1,000`毫秒，以防传入的数字是偶数（使用%运算符来查看数字是否可以被`2`整除而没有余数）：
- en: '[PRE105]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Add a helper function, `CreateBadTasks`, that creates a collection of five
    bad tasks. When started, each of the tasks will eventually throw an exception
    of type `InvalidOperationException`:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个辅助函数`CreateBadTasks`，它创建一个包含五个坏任务的集合。当启动时，每个任务最终都会抛出一个`InvalidOperationException`类型的异常：
- en: '[PRE106]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now, create the console app''s `Main` entry point. You pass the results of
    `CreateBadTasks` to `WhenAll`, passing in the string `[WhenAll]` to make it easier
    to see what is happening in the output:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建控制台应用程序的`Main`入口点。您将`CreateBadTasks`的结果传递给`WhenAll`，并传递字符串`[WhenAll]`以便更容易地查看输出中发生的情况：
- en: '[PRE107]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Before you attempt to await the `whenAllCompletedTask` task, you need to wrap
    it in `try-catch`, which catches the base `Exception` type (or a more specific
    one if you are expecting that).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试等待`whenAllCompletedTask`任务之前，您需要将其包装在`try-catch`中，该`try-catch`捕获基本的`Exception`类型（或者如果您期望的话，可以捕获更具体的类型）。
- en: 'You cannot catch `AggregateException` here as it''s the first exception inside
    the `Task` that you receive, but you can still use the `Exception` property of
    `whenAllCompletedTask` to get at the `AggregateException` itself:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法在此处捕获`AggregateException`，因为它是您收到的`Task`内的第一个异常，但是您仍然可以使用`whenAllCompletedTask`的`Exception`属性来获取`AggregateException`本身：
- en: '[PRE108]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'You''ve caught an exception, so log its type (this will be `InvalidOperationException`
    instance that you threw) and the message:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 您捕获了一个异常，因此记录其类型（这将是您抛出的`InvalidOperationException`实例）和消息：
- en: '[PRE109]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now you can examine `whenAllCompletedTask`, iterating though this task''s `AggregateException`
    to see its `InnerExceptions` list:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以检查`whenAllCompletedTask`，遍历此任务的`AggregateException`以查看其`InnerExceptions`列表：
- en: '[PRE110]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Running the code, you''ll see five tasks that sleep, and eventually, numbers
    `0`, `2`, and `4` each throw `InvalidOperationException`, which you will catch:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，您将看到五个休眠的任务，最终，数字`0`、`2`和`4`分别抛出`InvalidOperationException`，您将捕获到：
- en: '[PRE111]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Notice how `number 0` appears to be the only error that was caught (`(Message=Oh`
    dear from `[WhenAll] number 0`). However, by logging each entry in the `InnerExceptions`
    list, you see all `number 0` appearing once again.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`number 0`似乎是唯一捕获的错误(`(Message=Oh` dear from `[WhenAll] number 0`)。然而，通过记录`InnerExceptions`列表中的每个条目，您会再次看到所有`number
    0`。
- en: 'You can try the same code, but this time use `WhenAny`. Remember that `WhenAny`
    will complete when the first task in the list completes, so notice the complete
    lack of **error handling** in this case:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试相同的代码，但这次使用`WhenAny`。请记住，`WhenAny`将在列表中的第一个任务完成时完成，因此请注意在这种情况下完全缺少**错误处理**：
- en: '[PRE112]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Unless you wait for all tasks to complete, you may miss an exception raised
    by a task when using `WhenAny`. Running this code results in not a single error
    being caught and the app does `3` as that completed first:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您等待所有任务完成，否则在使用`WhenAny`时可能会错过任务引发的异常。运行此代码将导致未捕获任何错误，并且应用程序执行`3`，因为它首先完成：
- en: '[PRE113]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: You will finish this look at `async`/`await` code by looking at some of the
    newer options in C# around handling streams of `async` results. This provides
    a way to efficiently iterate through the items of a collection without the calling
    code having to wait for the entire collection to be populated and returned before
    it can start processing the items in the list.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看C#中处理`async`结果流的一些新选项，您将完成对`async`/`await`代码的探讨。这提供了一种有效地遍历集合项的方法，而不需要调用代码等待整个集合被填充和返回，然后才能开始处理列表中的项目。
- en: Note
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/SuCXK](https://packt.link/SuCXK).
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/SuCXK](https://packt.link/SuCXK)找到此示例中使用的代码。
- en: IAsyncEnumerable Streams
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IAsyncEnumerable Streams
- en: If your application targets .NET 5, .NET6, .NET Core 3.0, .NET Standard 2.1,
    or any of the later versions, then you can use `IAsyncEnumerable` streams to create
    awaitable code that combines the `yield` keyword into an enumerator to iterate
    asynchronously through a collection of objects.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序目标是.NET 5、.NET6、.NET Core 3.0、.NET Standard 2.1或任何以后的版本，那么您可以使用`IAsyncEnumerable`流来创建可等待的代码，将`yield`关键字结合到枚举器中，以异步方式遍历对象集合。
- en: Note
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Microsoft''s documentation provides this definition of the `yield` keyword:
    When a `yield` return statement is reached in the iterator method, expression
    is returned, and the current location in code is retained. Execution is restarted
    from that location the next time that the iterator function is called.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft的文档提供了`yield`关键字的定义：当在迭代器方法中达到`yield`返回语句时，将返回表达式，并保留代码中的当前位置。下次调用迭代器函数时，将从该位置重新启动执行。
- en: Using the `yield` statement, you can create methods that return an enumeration
    of items to the caller. Additionally, the caller does not need to wait for the
    **entire list** of items to be returned before they can start traversing each
    item in the list. Instead, the caller can access each item as soon as it becomes
    available.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`yield`语句，您可以创建返回项目枚举的方法。此外，调用方无需等待**整个列表**的项目返回，就可以开始遍历列表中的每个项目。相反，调用方可以在每个项目变为可用时访问每个项目。
- en: In this example, you will create a console app that replicates an insurance
    quoting system. You will make five requests for an insurance quote, once again
    using `Task.Delay` to simulate a 1-second delay in receiving each delay.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您将创建一个控制台应用程序，复制一个保险报价系统。您将发出五个保险报价请求，再次使用`Task.Delay`来模拟接收每个延迟需要1秒的延迟。
- en: 'For the list-based approach, you can only log each quote once all five results
    have been received back to the `Main` method. Using `IAsyncEnumerable` and the
    `yield` keyword, the same one second exists between quotes being received, but
    as soon as each quote is received, the `yield` statement allows the calling `Main`
    method to receive and process the value quoted. This is ideal if you want to start
    processing items right away or potentially do not want the overhead of having
    thousands of items in a list for longer than is needed to process them individually:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于列表的方法，只有在所有五个结果都返回到`Main`方法后，您才能记录每个报价。使用`IAsyncEnumerable`和`yield`关键字，报价之间仍然存在一秒的延迟，但是一旦收到每个报价，`yield`语句允许调用的`Main`方法接收并处理报价的值。如果您希望立即开始处理项目或者可能不希望在需要单独处理项目的时间比需要处理它们的时间长的情况下，这是理想的选择：
- en: '[PRE114]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Start by `GetInsuranceQuotesAsTask` to return a list of strings and iterate
    through each, logging the details of each quote. This code will wait for all quotes
    to be received before logging each item:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 首先通过`GetInsuranceQuotesAsTask`返回一个字符串列表并遍历每个字符串，记录每个报价的详细信息。此代码将等待所有报价接收完毕后再记录每个项目：
- en: '[PRE115]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now for the `async` stream version. If you compare the following code to the
    preceeding code block, you''ll see that there are fewer lines of code needed to
    iterate through the items returned. This code does not wait for all quote items
    to be received but instead writes out each quote as soon as it is received from
    `GetInsuranceQuotesAsync`:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`async`流版本。如果您将以下代码与前面的代码块进行比较，您会发现需要更少的代码行来遍历返回的项目。此代码不等待所有报价项目接收完毕，而是在从`GetInsuranceQuotesAsync`接收到每个报价时立即写出每个报价：
- en: '[PRE116]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The `GetInsuranceQuotesAsTask` method returns a `Task` of strings. Between
    each of the five quotes, you wait for one second to simulate a delay, before adding
    the result to the list and finally returning the entire list back to the caller:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInsuranceQuotesAsTask`方法返回一个字符串的`Task`。在五个报价之间，您等待一秒钟来模拟延迟，然后将结果添加到列表中，最后将整个列表返回给调用者：'
- en: '[PRE117]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The `GetInsuranceQuotesAsync` method contains the same delay between each quote,
    but rather than populating a list to return back to the caller, the `yield` statement
    is used to allow the `Main` method to process each quote item immediately:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInsuranceQuotesAsync`方法在每个报价之间包含相同的延迟，但是不是填充一个列表返回给调用者，而是使用`yield`语句允许`Main`方法立即处理每个报价项：'
- en: '[PRE118]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Running the console app produces the following output:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台应用程序会产生以下输出：
- en: '[PRE119]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Thread `[04]` logged all five task-based quote details five seconds after the
    app started. Here, it waited for all quotes to be returned before logging each
    quote. However, notice that each of the stream-based quotes was logged as soon
    as it was yielded by threads `4` and `5` with 1 second between them.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 线程`[04]`在应用程序启动后5秒钟记录了所有五个基于任务的报价详情。在这里，它等待所有报价返回后再记录每个报价。但是，请注意，每个基于流的报价在线程`4`和`5`产生后立即记录，它们之间间隔1秒。
- en: The overall time taken for both calls is the same (5 seconds in total), but
    `yield` is preferrable when you want to start processing each result as soon as
    it is ready. This is often useful in UI apps where you can provide early results
    to the user.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 两次调用的总时间相同（总共5秒），但是当您希望在准备好时立即开始处理每个结果时，`yield`是更可取的。这在UI应用程序中经常很有用，可以为用户提供早期结果。
- en: Note
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/KarKW](https://packt.link/KarKW).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/KarKW](https://packt.link/KarKW)找到此示例使用的代码。
- en: Parallel Programming
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行编程
- en: So far, this chapter has covered async programming using the `Task` class and
    `async`/`await` keywords. You have seen how tasks and `async` blocks of code can
    be defined and the flow of a program can be finely controlled as these structures complete.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章已经涵盖了使用`Task`类和`async`/`await`关键字进行异步编程。您已经看到了如何定义任务和`async`代码块，以及如何精细控制程序的流程。
- en: The Parallel Framework (PFX) offers further ways to utilize multicore processors
    to efficiently run concurrent operations. The phrase TPL (Task Parallel Library)
    is generally used to refer to the `Parallel` class in C#.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 并行框架（PFX）提供了更多利用多核处理器有效运行并发操作的方法。短语TPL（任务并行库）通常用于指代C#中的`Parallel`类。
- en: Using the Parallel Framework, you do not need to worry about the complexity
    of creating and reusing threads or coordinating multiple tasks. The framework
    manages this for you, even adjusting the number of threads that are used, in order
    to maximize throughput.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 使用并行框架，您不需要担心创建和重用线程或协调多个任务的复杂性。框架会为您管理这一切，甚至调整使用的线程数量，以最大化吞吐量。
- en: 'For parallel programming to be effective, the order in which each task executes
    must be irrelevant and all tasks should be independent of each other, as you cannot
    be certain when one task completes and the next one begins. Coordinating negates
    any benefits. Parallel programming can be broken down into two distinct concepts:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使并行编程有效，每个任务执行的顺序必须是无关紧要的，并且所有任务都应该彼此独立，因为您无法确定一个任务何时完成并且下一个任务开始。协调会抵消任何好处。并行编程可以分解为两个不同的概念：
- en: Data parallelism
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据并行性
- en: Task parallelism
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务并行性
- en: Data Parallelism
  id: totrans-553
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据并行性
- en: Data parallelism is used when you have multiple data values, and the same operation
    is to be applied concurrently to each of those values. In this scenario, processing
    each of the values is partitioned across different threads.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有多个数据值，并且要对每个值同时应用相同的操作时，使用数据并行性。在这种情况下，对每个值的处理被分配到不同的线程上。
- en: A typical example might be calculating the prime numbers from one to 1,000,000\.
    For each number in the range, the same function needs to be applied to determine
    whether the value is a prime. Rather than iterating through each number one at
    a time, an asynchronous approach would be to split numbers across multiple threads.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的例子可能是计算从1到1,000,000的质数。对于范围内的每个数字，需要应用相同的函数来确定该值是否为质数。与其逐个迭代每个数字，不如采用异步方法将数字分配到多个线程上。
- en: Task Parallelism
  id: totrans-556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务并行性
- en: 'Conversely, task parallelism is used where a collection of threads all performs
    a different action, such as calling different functions or sections of code, concurrently.
    One such example is a program that analyzes the words found in a book, by downloading
    the book''s text and defining separate tasks to do the following:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，任务并行性用于一组线程执行不同的操作，例如同时调用不同的函数或代码段。一个这样的例子是分析一本书中发现的单词，通过下载书的文本并定义单独的任务来执行以下操作：
- en: Count the number of words.
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算单词的数量。
- en: Find the longest word.
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到最长的单词。
- en: Calculate the average word length.
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算平均单词长度。
- en: Count the number of noise words (the, and, of, for example).
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算噪声词的数量（例如the，and，of，for）。
- en: Each of these tasks can be run concurrently and they do not depend on each other.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务可以并行运行，彼此之间不依赖。
- en: For the `Parallel` class, the Parallel Framework provides various layers that
    offer parallelism, including Parallel Language Integrated Query (PLINQ). PLINQ
    is a collection of extension methods that add the power of parallel programming
    to the LINQ syntax. The PLINQ won't be covered here in detail, but the `Parallel`
    class will be covered in more detail.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Parallel`类，并行框架提供了各种层次的并行性，包括并行语言集成查询（PLINQ）。PLINQ是一组扩展方法，将并行编程的能力添加到LINQ语法中。这里不会详细介绍PLINQ，但会更详细地介绍`Parallel`类。
- en: Note
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you're interested in learning more about PLINQ, you can refer to the online
    documentation at [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq).
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于PLINQ的信息，可以参考在线文档[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq)。
- en: The Parallel Class
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并行类
- en: The `Parallel` class contains just three `static` methods but there are numerous
    overloads providing options to control and influence how actions are performed.
    Each of the methods `Parallel` class is often called from within an awaitable
    block such as `Task.Run`.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel`类包含了三个`static`方法，但有许多重载，提供了控制和影响操作执行方式的选项。`Parallel`类的每个方法通常从可等待的块中调用，比如`Task.Run`。'
- en: It is worth remembering that the runtime may run the required operations in
    parallel only if it thinks that is warranted. In the case of individual steps
    completing sooner than others, the runtime may decide that the overhead of running
    the remaining operations in parallel is not justified.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是，运行时只有在认为有必要的情况下才会并行运行所需的操作。在个别步骤完成得比其他步骤更快的情况下，运行时可能会决定不值得并行运行剩余的操作的开销。
- en: 'Some of the commonly used `Parallel` method overloads are as follows:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的`Parallel`方法重载如下：
- en: '`public static ParallelLoopResult For(int from, int to, Action<int> body)`:
    This data parallelism call executes a loop by invoking the body `Action` delegate,
    passing in an `int` value across the from and to numeric range. It returns `ParallelLoopResult`,
    which contains details of the loop once completed.'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static ParallelLoopResult For(int from, int to, Action<int> body)`:
    这个数据并行调用通过在从和到的数字范围内调用`Action`委托来执行循环。它返回`ParallelLoopResult`，其中包含循环完成后的详细信息。'
- en: '`public static ParallelLoopResult For(int from, int to, ParallelOptions options,
    Action<int, ParallelLoopState> body)`: A data parallelism call that executes a
    loop across the numeric range. `ParallelOptions` allows loop options to be configured
    and `ParallelLoopState` is used to monitor or manipulate the state of the loop
    as it runs. It returns `ParallelLoopResult`.'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static ParallelLoopResult For(int from, int to, ParallelOptions options,
    Action<int, ParallelLoopState> body)`: 一个数据并行调用，执行数字范围内的循环。`ParallelOptions`允许配置循环选项，`ParallelLoopState`用于监视或操作循环的状态。它返回`ParallelLoopResult`。'
- en: '`public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source,
    Action<TSource, ParallelLoopState> body)`: A data parallelism call that invokes
    the `Action` body on each item in the `IEnumerable` source. It returns `ParallelLoopResult`.'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static ParallelLoopResult ForEach<TSource>(IEnumerable<TSource> source,
    Action<TSource, ParallelLoopState> body)`: 在`IEnumerable`源中的每个项目上调用`Action`体的数据并行调用。它返回`ParallelLoopResult`。'
- en: '`public static ParallelLoopResult ForEach<TSource>(Partitioner<TSource> source,
    Action<TSource> body)`: An advanced data parallelism call that invokes the `Action`
    body and allows you to specify `Partitioner` to provide partitioning strategies
    optimized for specific data structures to improve performance. It returns `ParallelLoopResult`.'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static ParallelLoopResult ForEach<TSource>(Partitioner<TSource> source,
    Action<TSource> body)`: 一个高级的数据并行调用，调用`Action`主体，并允许您指定`Partitioner`以提供针对特定数据结构进行优化的分区策略，以提高性能。它返回`ParallelLoopResult`。'
- en: '`public static void Invoke(params Action[] actions)`: A task parallelism call
    that executes each of the actions passed.'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static void Invoke(params Action[] actions)`: 一个任务并行调用，执行传递的每个动作。'
- en: '`public static void Invoke(ParallelOptions parallelOptions, params Action[]
    actions)`: A task parallelism call that executes each of the actions and allows
    `ParallelOptions` to be specified to configure method calls.'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public static void Invoke(ParallelOptions parallelOptions, params Action[]
    actions)`: 一个任务并行调用，执行每个动作，并允许指定`ParallelOptions`来配置方法调用。'
- en: 'The `ParallelOptions` class can be used to configure how the `Parallel` methods
    operate:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelOptions`类可用于配置`Parallel`方法的操作方式：'
- en: '`public CancellationToken CancellationToken { get; set; }`: The familiar cancelation
    token that can be used to detect within loops if cancellation has been requested
    by a caller.'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public CancellationToken CancellationToken { get; set; }`: 可以用于在循环中检测调用者是否已请求取消的熟悉取消令牌。'
- en: '`public int MaxDegreeOfParallelism { get; set; }`: An advanced setting that
    determines the maximum number of concurrent tasks that can be enabled at a time.'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public int MaxDegreeOfParallelism { get; set; }`: 一个高级设置，确定可以同时启用的最大并发任务数。'
- en: '`public TaskScheduler? TaskScheduler { get; set; }`: An advanced setting that
    allows a certain type of task queue scheduler to be set.'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public TaskScheduler? TaskScheduler { get; set; }`: 允许设置某种类型的任务队列调度器的高级设置。'
- en: '`ParallelLoopState` can be passed into the body of an `Action` for that action
    to then determine or monitor flow through the loop. The most commonly used properties
    are as follows:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelLoopState`可以传递到`Action`的主体中，以便该动作确定或监视循环中的流程。最常用的属性如下：'
- en: '`public bool IsExceptional { get; }`: Returns `true` if an iteration has thrown
    an unhandled exception.'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsExceptional { get; }`: 如果迭代抛出未处理的异常，则返回`true`。'
- en: '`public bool IsStopped { get; }`: Returns `true` if an iteration has stopped
    the loop by calling the `Stop` method.'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsStopped { get; }`: 如果迭代通过调用`Stop`方法停止了循环，则返回`true`。'
- en: '`public void Break()`: The `Action` loop can call this to indicate execution
    should cease beyond the current iteration.'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void Break()`: `Action`循环可以调用此方法来指示执行应在当前迭代之后停止。'
- en: '`public void Stop()`: Requests that the loop should cease execution at the
    current iteration.'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void Stop()`: 请求循环在当前迭代中停止执行。'
- en: '`ParallelLoopResult`, as returned by the `For` and `ForEach` methods, contains
    a completion status for the `Parallel` loop.'
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParallelLoopResult`，由`For`和`ForEach`方法返回，包含了`Parallel`循环的完成状态。'
- en: '`public bool IsCompleted { get; }`: Indicates that the loop ran to completion
    and did not receive a request to end before completion.'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public bool IsCompleted { get; }`: 表示循环已经完成，并且在完成之前没有收到结束请求。'
- en: '`public long? LowestBreakIteration { get; }`: If `Break` is called `while`
    the loop runs. This returns the index of the lowest iteration the loop arrived
    at.'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public long? LowestBreakIteration { get; }`: 如果在循环运行时调用了`Break`。这将返回循环到达的最低迭代的索引。'
- en: Using the `Parallel` class does not automatically mean that a particular bulk
    operation will complete any faster. There is an overhead in scheduling tasks,
    so care should be taken when running tasks that are too short or too long. Sadly,
    there is no simple metric that determines an optimal figure here. It is often
    a case of profiling to see if operations do indeed complete faster using the `Parallel`
    class.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Parallel`类并不意味着特定的批量操作会更快完成。在调度任务方面存在开销，因此在运行太短或太长的任务时应该小心。遗憾的是，没有一个简单的度量标准来确定这里的最佳数字。通常情况下，需要进行分析以查看是否使用`Parallel`类确实可以更快地完成操作。
- en: Note
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on data and task parallelism at [https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism).
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism)找到有关数据和任务并行性的更多信息。
- en: Parallel.For and Parallel.ForEach
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Parallel.For和Parallel.ForEach
- en: These two methods offer data parallelism. The same operation is applied to a
    collection of data objects or numbers. To benefit from these, each operation should
    be CPU-bound, that is it should require CPU cycles to execute rather than being
    IO-bound (accessing a file, for example).
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法提供了数据并行性。相同的操作应用于一组数据对象或数字。要从中受益，每个操作都应该是CPU绑定的，也就是说，它应该需要CPU周期来执行，而不是IO绑定的（例如访问文件）。
- en: With these two methods, you define an `Action` to be applied, which is passed
    an object instance or number to work with. In the case of `Parallel.ForEach`,
    the `Action` is passed an object reference parameter. A numeric parameter is passed
    to `Parallel.For`.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两种方法，您可以定义要应用的`Action`，该`Action`将传递一个对象实例或数字进行处理。在`Parallel.ForEach`的情况下，`Action`将传递一个对象引用参数。一个数字参数将传递给`Parallel.For`。
- en: 'As you saw in *Chapter 3*, *Delegates, Events, and Lambdas*, the `Action` delegate
    code can be as simple or complex as you need:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在*第3章*中看到的，*委托、事件和Lambda*，`Action`委托代码可以是您需要的简单或复杂：
- en: '[PRE120]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'In this example, calling `Parallel.For`, you pass an inclusive `int` value
    to start from (`99`) and an exclusive end value (`105`). The third argument is
    a lambda statement, `Action`, that you want invoked over each iteration. This
    overload uses `Action<int>`, passing an integer via the `i` argument:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，调用`Parallel.For`，您传递了一个包含的`int`值以从`99`开始（`99`）和一个不包含的结束值（`105`）。第三个参数是一个lambda语句，`Action`，您希望在每次迭代中调用。这个重载使用`Action<int>`，通过`i`参数传递一个整数：
- en: '[PRE121]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Examine the `ParallelLoopResult` `IsCompleted` property:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`ParallelLoopResult`的`IsCompleted`属性：
- en: '[PRE122]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Running the code, you''ll see that it stops at `104`. Each iteration is executed
    by a set of different threads and the order appears somewhat random with certain
    iterations awaking before others. You have used a relatively short delay (using
    `Thread.Sleep`) so the parallel task scheduler may take a few additional milliseconds
    to activate each iteration. This is the reason why the orders in which iterations
    are executed should be independent of each other:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，您会看到它在`104`处停止。每次迭代都由一组不同的线程执行，顺序似乎有些随机，某些迭代在其他迭代之前醒来。您使用了相对较短的延迟（使用`Thread.Sleep`），因此并行任务调度程序可能需要额外几毫秒来激活每次迭代。这就是为什么迭代的执行顺序应该是相互独立的原因：
- en: '[PRE123]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Using the `ParallelLoopState` override, you can control the iterations from
    with the `Action` code. In the following example, the code checks to see if it
    is at iteration number `15`:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ParallelLoopState`覆盖，您可以在`Action`代码中控制迭代。在下面的例子中，代码检查是否在第`15`次迭代：
- en: '[PRE124]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Calling `Break` on `loopState` communicates that the `Parallel` loop should
    cease further iterations as soon as it can:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loopState`上调用`Break`表示`Parallel`循环应尽快停止进一步的迭代：
- en: '[PRE125]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'From the results, you can see you got to item `17` before things actually stopped,
    despite asking to break at iteration `15`, as can be seen from the following snippet:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中，您可以看到在实际停止之前，您已经到达了第`17`项，尽管要求在第`15`次迭代时中断，如下面的片段所示：
- en: '[PRE126]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The code used `ParallelLoopState.Break`; this indicates the loop `17` despite
    requesting a stop at iteration `15`. This generally occurs when the runtime has
    already started a subsequent iteration and then detects a `Break` request just
    after. These are requests to stop; the runtime may run extra iterations before
    it can stop.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ParallelLoopState.Break`的代码；这表明循环在请求在第`15`次迭代时停止后，仍然进行了第`17`次迭代。这通常发生在运行时已经开始了后续迭代，然后在此之后检测到`Break`请求。这些都是停止的请求；运行时可能会在停止之前运行额外的迭代。
- en: Alternatively, the `ParallelLoopState.Stop` method can be used for a more abrupt
    stop. An alternative `Parallel.For` overload allows state to be passed into each
    loop and return a single aggregate value.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用`ParallelLoopState.Stop`方法进行更突然的停止。另一个`Parallel.For`重载允许将状态传递到每个循环中，并返回单个聚合值。
- en: To better learn about these overloads, you will calculate the value of `pi`
    in the next example. This is an ideal task for `Parallel.For` as it means repeatedly
    calculating a value, which is aggregated before being passed to the next iteration.
    The higher the number of iterations, the more accurate the final number.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解这些重载，您将在下一个示例中计算`pi`的值。这是`Parallel.For`的理想任务，因为它意味着重复计算一个值，然后将其聚合，然后传递给下一个迭代。迭代次数越多，最终数字越准确。
- en: Note
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on the formula at [https://www.mathscareers.org.uk/article/calculating-pi/](https://www.mathscareers.org.uk/article/calculating-pi/).
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.mathscareers.org.uk/article/calculating-pi/](https://www.mathscareers.org.uk/article/calculating-pi/)找到有关该公式的更多信息。
- en: 'You use a loop to prompt the user to enter the number of series (the number
    of decimal places to be shown) as a multiple of a million (to save typing many
    zeroes):'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用循环提示用户输入要显示的系列数（要显示的小数位数的百万的倍数）以节省输入许多零：
- en: '[PRE127]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Try to parse the input:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试解析输入：
- en: '[PRE128]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Multiply the entered value by one million and pass it to the awaitable `CalcPi`
    function (which will be defined shortly):'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入的值乘以一百万，并传递给可等待的`CalcPi`函数（稍后将定义）：
- en: '[PRE129]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'You eventually receive the value of `pi`, so use the string interpolation feature
    to write `pi` to `18` decimal places using the `:N18` numeric format style:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 最终您会收到`pi`的值，因此使用字符串插值功能，使用`:N18`数字格式样式将`pi`写入`18`位小数：
- en: '[PRE130]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Repeat the loop until `0` is entered:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 重复循环，直到输入`0`为止：
- en: '[PRE131]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Now for the `CalcPi` function. You know that the `Parallel` methods all block
    the calling thread, so you need to use `Task.Run` which will eventually return
    the final calculated value.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`CalcPi`函数。您知道`Parallel`方法都会阻塞调用线程，因此您需要使用`Task.Run`，它最终会返回最终计算出的值。
- en: The concept of thread synchronization will be covered briefly. There is a danger
    when using multiple threads and shared variables that one thread may read a value
    from memory and attempt to write a new value at the same time a different thread
    is trying to do the same operation, with its own value and what it thinks is the
    correct current value, when it may have read an already out-of-date shared value.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 将简要介绍线程同步的概念。当使用多个线程和共享变量时，存在一个危险，即一个线程可能从内存中读取一个值，并尝试同时写入一个新值，而另一个线程正在尝试执行相同的操作，使用自己的值和它认为是正确的当前值，当它可能已经读取了一个已经过时的共享值。
- en: To prevent such issues, a mutual-exclusion lock can be used so that a given
    thread can execute its statements while it holds a lock and then releases that
    lock when finished. All other threads are blocked from acquiring the lock and
    are forced to wait until the lock is released.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，可以使用互斥锁，以便给定线程可以在持有锁时执行其语句，然后在完成时释放该锁。所有其他线程都被阻止获取锁，并被迫等待，直到锁被释放。
- en: 'This can be achieved using the `lock` statement. All of the complexities are
    handled by the runtime when the `lock` statement is used to achieve thread synchronization.
    The `lock` statement has the following form:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用`lock`语句来实现。当使用`lock`语句来实现线程同步时，运行时会处理所有复杂性。`lock`语句的形式如下：
- en: '[PRE132]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Conceptually, you can think of the `lock` statement as a narrow gate that has
    enough room to allow just one person to pass through at a time. No matter how
    long a person takes to pass through the gate and what they do while they are there,
    everyone else must wait to get through the gate until the person with the key
    has left (releasing the lock).
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，您可以将`lock`语句视为一个狭窄的门，它有足够的空间只允许一个人一次通过。无论一个人花多长时间通过大门以及他们在那里做什么，其他人都必须等待，直到拥有钥匙的人离开（释放锁）。
- en: 'Returning to the `CalcPi` function:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`CalcPi`函数：
- en: '[PRE133]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The `gate` variable is of type `object` and used with the `lock` statement
    inside the lambda to protect the `sum` variable from unsafe access:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '`gate`变量的类型为`object`，并且在lambda内部使用`lock`语句来保护`sum`变量免受不安全的访问：'
- en: '[PRE134]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'This is where things get a little more complex, as you use the `Parallel.For`
    overload, which additionally allows you to pass in extra parameters and delegates:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 这是事情变得更加复杂的地方，因为您使用了`Parallel.For`的重载，它还允许您传递额外的参数和委托：
- en: '`fromInclusive`: The start index (`0` in this case).'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fromInclusive`：起始索引（在本例中为`0`）。'
- en: '`toExclusive`: The end index (steps).'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toExclusive`：结束索引（步骤）。'
- en: '`localInit`: A `Func` delegate that returns the **initial state** of data local
    to each iteration.'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localInit`：返回每次迭代本地数据的**初始状态**的`Func`委托。'
- en: '`body`: The actual `Func` delegate that calculates a value of Pi.'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`：实际的`Func`委托，用于计算Pi的值。'
- en: '`localFinal`: A `Func` delegate that performs the final action on the local
    state of each iteration.'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localFinal`：对每次迭代的本地状态执行最终操作的`Func`委托。'
- en: '[PRE135]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Here, you now use the `lock` statement to ensure that only one thread at a
    time can increment the value of `sum` with its own correct value:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您现在使用`lock`语句来确保只有一个线程可以递增`sum`的值，并且使用自己的正确值：
- en: '[PRE136]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'By using the `lock(obj)` statement, you have provided a minimum level of thread
    safety, and running the program produces the following output:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`lock(obj)`语句，您提供了最低级别的线程安全性，并且运行程序会产生以下输出：
- en: '[PRE137]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '`Parallel.ForEach` follows similar semantics; rather than a range of numbers
    being passed to the `Action` delegate, you pass a collection of objects to work
    with.'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.ForEach`遵循类似的语义；而不是将一系列数字传递给`Action`委托，而是将一组对象传递给它们进行处理。'
- en: Note
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/1yZu2](https://packt.link/1yZu2).
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/1yZu2](https://packt.link/1yZu2)找到本示例使用的代码。
- en: The following example shows `Parallel.ForEach` using `ParallelOptions` along
    with a cancelation token. In this example, you have a console app that creates
    10 customers. Each customer has a list containing the value of all orders placed.
    You want to simulate a slow-running service that fetches a customer's order on
    demand. Whenever any code accesses the `Customer.Orders` property, the list is
    populated only once though. Here, you will use another `lock` statement per customer
    instance to ensure the list is safely populated.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示使用`ParallelOptions`和取消令牌的`Parallel.ForEach`。在这个例子中，您有一个创建10个客户的控制台应用程序。每个客户都有一个包含所有下订单价值的列表。您想模拟一个慢速运行的服务，根据需要获取客户的订单。无论何时访问`Customer.Orders`属性，列表只被填充一次。在这里，您将为每个客户实例使用另一个`lock`语句来确保列表安全填充。
- en: An `Aggregator` class will iterate through the list of customers and calculate
    the total and average order costs using a `Parallel.ForEach` call. Allow the user
    to enter a maximum time period that they are prepared to wait for all of the aggregations
    to complete and then show the top five customers.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Aggregator`类将遍历客户列表，并使用`Parallel.ForEach`调用计算总订单成本和平均订单成本。允许用户输入他们准备等待所有聚合完成的最长时间段，然后显示前五名客户。
- en: 'Start by creating a `Customer` class whose constructor is passed a `name` argument:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个`Customer`类，其构造函数接受一个`name`参数：
- en: '[PRE138]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: You want to populate the `Orders` list on demand and once only per customer,
    so use another `lock` example that ensures the list of orders is safely populated
    once. You simply use the `Orders` `get` accessor to check for a null reference
    on the `_orders` variable, before creating a random number of order values using
    the `Enumerable.Range` LINQ method to generate a range of numbers.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 您想根据需要填充`Orders`列表，并且每个客户只填充一次，因此使用另一个`lock`示例来确保订单列表安全填充。您只需使用`Orders`的`get`访问器来检查`_orders`变量上的空引用，然后使用`Enumerable.Range`
    LINQ方法创建一系列数字来创建随机数量的订单值。
- en: 'Note, you also simulate a slow request by adding `Thread.Sleep` to block the
    thread that is accessing this customer''s orders for the first time (as you''re
    using the `Parallel` class, this will be a background thread rather than the main
    thread):'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您还通过向访问此客户订单的线程添加`Thread.Sleep`来模拟慢请求（因为您使用`Parallel`类，这将是一个后台线程而不是主线程）：
- en: '[PRE139]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The `Total` and `Average` properties that will be calculated by your `Aggregator`
    class are as follows:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`Aggregator`类将计算的`Total`和`Average`属性如下：
- en: '[PRE140]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Looking at the `Aggregator` class, note that its `Aggregate` method is passed
    a list of customers to work with and `CancellationToken`, which will automatically
    raise a cancellation request based on the console user''s preferred timespan.
    The method returns a bool-based `Task`. The result will indicate whether the operation
    was canceled partway through processing the customers:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`Aggregator`类，注意其`Aggregate`方法被传递一个要处理的客户列表和`CancellationToken`，它将根据控制台用户的首选时间段自动发出取消请求。该方法返回一个基于布尔值的`Task`。结果将指示操作是否在处理客户的过程中被取消：
- en: '[PRE141]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The main `Parallel.ForEach` method is configured by creating a `ParallelOptions`
    class, passing in the cancellation token. When invoked by the `Parallel` class,
    the `Action` delegate is passed a `Customer` instance (`customer =>`) that simply
    sums the order values and calculates the average which is assigned to the customer's
    properties.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 主`Parallel.ForEach`方法通过创建`ParallelOptions`类进行配置，传入取消令牌。当由`Parallel`类调用时，`Action`委托将传递一个`Customer`实例（`customer
    =>`），它只是对订单值求和并计算平均值，然后将其分配给客户的属性。
- en: 'Notice how the `Parallel.ForEach` call is wrapped in a `try-catch` block that
    catches any exceptions of type `OperationCanceledException`. If the maximum time
    period is exceeded, then the runtime will throw an exception to stop processing.
    You must catch this; otherwise, the application will crash with an unhandled exception
    error:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Parallel.ForEach`调用被包裹在一个`try-catch`块中，捕获任何`OperationCanceledException`类型的异常。如果超过最长时间段，则运行时将抛出异常以停止处理。您必须捕获这个异常；否则，应用程序将崩溃并显示未处理的异常错误：
- en: '[PRE142]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The main console app prompts for a maximum waiting time, `maxWait`:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 主控制台应用程序提示最长等待时间，`maxWait`：
- en: '[PRE143]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Create `100` customers that can be passed to the aggregator:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`100`个客户，可以传递给聚合器：
- en: '[PRE144]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Create `CancellationTokenSource` instance, passing in the maximum wait time.
    As you saw earlier, any code that uses this token will be interrupted with a cancellation
    exception should the time limit be exceeded:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`CancellationTokenSource`实例，传入最长等待时间。正如您之前看到的，任何使用此令牌的代码在超过时间限制时将被中断，并引发取消异常：
- en: '[PRE145]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Once the task completes, you simply take the top five customers ordered by
    total. The `PadRight` method is used to align the customer''s name in the output:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成后，您只需取前五名客户按总数排序。使用`PadRight`方法来对齐输出中客户的名称：
- en: '[PRE146]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Running the console app with a short time of `1` second produces this output:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，持续时间为`1`秒，产生以下输出：
- en: '[PRE147]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The operation of creating `10` customers ran using Thread `01` as this was intentionally synchronous.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`10`个客户的操作使用线程`01`运行，因为这是有意的同步。
- en: Note
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Visual Studio may show the following warning the first time you run the program:
    `Non-nullable field ''_orders'' must contain a non-null value when exiting constructor.
    Consider declaring the field as nullable.` This is a suggestion to check the code
    for the possibility of a null reference.'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行程序时，Visual Studio可能会显示以下警告：`Non-nullable field '_orders' must contain a
    non-null value when exiting constructor. Consider declaring the field as nullable.`
    这是一个建议，检查代码是否可能为空引用。
- en: '`Aggregator` then starts processing each of the customers. Notice how different
    threads are used and processing does not start with the first customer either.
    This is the task scheduler deciding which task is next in the queue. You only
    managed to process eight of the customers before the token raised the cancelation
    exception.'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`Aggregator`开始处理每个客户。请注意不同的线程是如何使用的，并且处理也不是从第一个客户开始的。这是任务调度程序决定下一个任务在队列中的顺序。在令牌引发取消异常之前，您只能处理八个客户。
- en: Note
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/1LDxI](https://packt.link/1LDxI).
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/1LDxI](https://packt.link/1LDxI)找到此示例使用的代码。
- en: You have looked at some of the features available in the `Parallel` class. You
    can see that it provides a simple yet effective way to run code across multiple
    tasks or pieces of data.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经查看了`Parallel`类中可用的一些功能。您可以看到它提供了一种简单而有效的方法，可以在多个任务或数据片段之间运行代码。
- en: The phrase `Parallel` class is an example of this and can be a great utility.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel`类是其示例，并且可以是一个很好的实用工具。'
- en: The next section will bring these concurrency concepts into an activity that
    uses multiple tasks to generate a sequence of images. As each of the images can
    take a few seconds to create, you will need to offer the user a way to cancel
    any remaining tasks if the user so chooses.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将把这些并发概念带入一个使用多个任务生成图像序列的活动中。由于每个图像可能需要几秒钟来创建，因此您需要为用户提供一种取消任何剩余任务的方法，如果用户选择的话。
- en: 'Activity 5.01: Creating Images from a Fibonacci Sequence'
  id: totrans-680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动5.01：从斐波那契序列创建图像
- en: In *Exercise 5.01*, you looked at a recursive function to create a value called
    a Fibonacci number. These numbers can be joined into what is known as a Fibonacci
    sequence and used to create interesting spiral-shaped images.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Exercise 5.01*中，您查看了一个递归函数来创建一个称为斐波那契数的值。这些数字可以连接成所谓的斐波那契序列，并用于创建有趣的螺旋形图像。
- en: For this activity, you need to create a console application that allows various
    inputs to be passed to a sequence calculator. Once the user has entered their
    parameters, the app will start the time-consuming task of creating 1,000 images.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此活动，您需要创建一个控制台应用程序，允许将各种输入传递给序列计算器。一旦用户输入了他们的参数，应用程序将开始耗时的任务，创建1,000个图像。
- en: Each image in the sequence may take a few seconds to compute and create so you
    will need to provide a way to cancel the operation midway using `TaskCancellationSource`.
    If the user cancels the task, they should still be able to access the images that
    were created prior to the cancellation request. Essentially, you are allowing
    the user to try different parameters to see how this affects output images.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 序列中的每个图像可能需要几秒钟来计算和创建，因此您需要提供一种使用`TaskCancellationSource`取消操作的方法。如果用户取消任务，则他们仍应能够访问取消请求之前创建的图像。基本上，您允许用户尝试不同的参数，以查看这如何影响输出图像。
- en: '![Figure 5.2: Fibonacci sequence image files'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2：斐波那契序列图像文件'
- en: '](img/B16835_05_02.jpg)'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_05_02.jpg)'
- en: 'Figure 5.2: Fibonacci sequence image files'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：斐波那契序列图像文件
- en: 'This is an ideal example for the `Parallel` class or `async`/`await` tasks
    if you prefer. The following inputs will be needed from the user:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Parallel`类或`async`/`await`任务的理想示例。用户将需要以下输入：
- en: Input the value for `phi` (values between `1.0` and `6.0` provide ideal images).
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入`phi`的值（`1.0`和`6.0`之间的值提供理想的图像）。
- en: Input the number of images to create (the suggestion is `1,000` per cycle).
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入要创建的图像数量（建议每个周期为`1,000`）。
- en: Input the optional number of points per image (a default of `3,000` is recommended).
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入每个图像的可选点数（建议默认为`3,000`）。
- en: Input the optional image size (defaults to `800` pixels).
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入可选的图像大小（默认为`800`像素）。
- en: Input the optional point size (defaults to `5`).
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入可选的点大小（默认为`5`）。
- en: Next input the optional file format (defaults to `.png` format).
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来输入可选的文件格式（默认为`.png`格式）。
- en: The console app should use a loop that prompts for the preceding parameters
    and allows the user to enter new criteria while images are created for previous criteria.
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制台应用程序应使用循环提示前述参数，并允许用户在为先前的标准创建图像时输入新的标准。
- en: If the user presses `Enter` whilst a previous set of images is still being created,
    then that task should be canceled.
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户在先前的图像集仍在创建时按下`Enter`，则该任务应该被取消。
- en: Pressing `x` should close the application.
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下`x`应该关闭应用程序。
- en: 'As this activity is aimed at testing your asynchronous skills, rather than
    math or image processing, you have the following classes to help with calculations
    and image creation:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此活动旨在测试您的异步技能，而不是数学或图像处理，因此您可以使用以下类来帮助进行计算和图像创建：
- en: The `Fibonacci` class defined here calculates `X` and `Y` coordinates for successive
    sequence items. For each image loop, return a list of `Fibonacci` classes.
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此处定义的`Fibonacci`类计算连续序列项的`X`和`Y`坐标。对于每个图像循环，返回一个`Fibonacci`类的列表。
- en: 'Create the first element by calling `CreateSeed`. The remainder of the list
    should use `CreateNext`, passing in the previous item:'
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`CreateSeed`创建第一个元素。列表的其余部分应使用`CreateNext`，传入前一个项目：
- en: '[PRE148]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Create a list of Fibonacci items using the following `FibonacciSequence`.`Calculate`
    method. This will be passed the number of points to be drawn and the value of
    `phi` (both as specified by the user):'
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下`FibonacciSequence`.`Calculate`方法创建斐波那契项的列表。这将传递要绘制的点数和`phi`的值（均由用户指定）：
- en: '[PRE150]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Export the generated data to `.png` format image files using the `dotnet add
    package` command to add a reference to the `System.Drawing.Common` namespace.
    Within your project''s source folder, run this command:'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dotnet add package`命令将生成的数据导出为`.png`格式的图像文件，以添加对`System.Drawing.Common`命名空间的引用。在项目的源文件夹中，运行以下命令：
- en: '[PRE152]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'This image creation class `ImageGenerator` can be used to create each of the
    final image files:'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此图像创建类`ImageGenerator`可用于创建每个最终图像文件：
- en: '[PRE153]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'To complete this activity, perform the following steps:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此活动，请执行以下步骤：
- en: Create a new console app project.
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序项目。
- en: The generated images should be saved in a folder within the system's `Temp`
    folder, so use `Path.GetTempPath()` to get the `Temp` path and create a subfolder
    called `Fibonacci` using `Directory.CreateDirectory`.
  id: totrans-712
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的图像应该保存在系统的`Temp`文件夹中的一个文件夹中，因此使用`Path.GetTempPath()`来获取`Temp`路径，并使用`Directory.CreateDirectory`创建一个名为`Fibonacci`的子文件夹。
- en: Declare a `do`-loop that repeats the following *Step 4* to *Step 7*.
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`do`循环，重复以下*步骤4*至*步骤7*。
- en: Prompt the user to enter a value for `phi` (this typically ranges from `1.0`
    to `6.00`). You will need to read the user's input as a string and use `double.TryParse`
    to attempt to convert their input into a valid double variable.
  id: totrans-714
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示用户输入`phi`的值（通常范围为`1.0`至`6.00`）。您需要将用户的输入读取为字符串，并使用`double.TryParse`尝试将其转换为有效的双精度变量。
- en: Next, prompt the user to enter a value for the number of image files to create
    (`1,000` is an acceptable example value). Store the parsed input in an `int` variable
    called `imageCount`.
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，提示用户输入要创建的图像文件数量的值（`1,000`是一个可接受的示例值）。将解析后的输入存储在名为`imageCount`的`int`变量中。
- en: If either of the entered values is empty, this will indicate that the user pressed
    the `Enter` key alone, so break out of the `do`-loop. Ideally, `CancellationTokenSource`
    can also be defined and used to cancel any pending calculations.
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入的值为空，则表示用户仅按下了`Enter`键，因此跳出`do`循环。理想情况下，还可以定义并使用`CancellationTokenSource`来取消任何待定的计算。
- en: The value of `phi` and `imageCount` should be passed to a new method called
    `GenerateImageSequences`, which returns a `Task`.
  id: totrans-717
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`phi`和`imageCount`的值应传递给一个名为`GenerateImageSequences`的新方法，该方法返回一个`Task`。'
- en: The `GenerateImageSequences` method needs to use a loop that iterates for each
    of the image counts requested. Each iteration should increment `phi`, and a constant
    value (a suggestion is `0.015`) before awaiting a `Task.Run` method that calls
    `FibonacciSequence.Calculate`, passing in `phi` and a constant for the number
    of points (`3,000` provides an acceptable example value). This will return a list
    of Fibonacci items.
  id: totrans-718
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GenerateImageSequences`方法需要使用循环，对于请求的每个图像计数进行迭代。每次迭代应该在等待`Task.Run`调用之前递增`phi`和一个常量值（建议为`0.015`）。该调用`FibonacciSequence.Calculate`，传入`phi`和一个常量作为点数（`3,000`提供了一个可接受的示例值）。这将返回一个斐波那契项列表。'
- en: '`GenerateImageSequences` should then pass the generated Fibonacci list to the
    image creator `ImageGenerator.ExportSequence`, awaiting using a `Task.Run` call.
    An image size of `800` and a point size of `5` are recommended constants for the
    call to `ExportSequence`.'
  id: totrans-719
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`GenerateImageSequences`应将生成的斐波那契列表传递给图像创建者`ImageGenerator.ExportSequence`，使用`Task.Run`调用等待。建议调用`ExportSequence`时使用图像大小为`800`和点大小为`5`的常量。
- en: 'Running the console app should produce the following console output:'
  id: totrans-720
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序应该产生以下控制台输出：
- en: '[PRE155]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'You will find that various image files have been generated in the Fibonacci
    folder in the system''s `Temp` folder:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现各种图像文件已经在系统的`Temp`文件夹中的Fibonacci文件夹中生成：
- en: '![Figure 5.3: Windows 10 Explorer image folder contents (a subset of images
    produced)'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3：Windows 10资源管理器图像文件夹内容（生成的图像的子集）'
- en: '](img/B16835_05_03.jpg)'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_05_03.jpg)'
- en: 'Figure 5.3: Windows 10 Explorer image folder contents (a subset of images produced)'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：Windows 10资源管理器图像文件夹内容（生成的图像的子集）
- en: By completing this activity, you have seen how multiple long-running operations
    can be started and then coordinated to produce a single result, with each step
    running in isolation, allowing other operations to continue as necessary.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成此活动，您已经看到了如何启动多个长时间运行的操作，然后协调产生单个结果，每个步骤都在隔离中运行，允许其他操作根据需要继续进行。
- en: Note
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在[https://packt.link/qclbF](https://packt.link/qclbF)找到。
- en: Summary
  id: totrans-729
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you considered some of the power and flexibility that concurrency
    provides. You started by passing target actions to tasks that you created and
    then looked at the static `Task` factory helper methods. By using continuation
    tasks, you saw that single tasks and collections of tasks can be coordinated to
    perform aggregate actions.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您考虑了并发提供的一些功能和灵活性。您首先将目标操作传递给创建的任务，然后查看了静态`Task`工厂辅助方法。通过使用继续任务，您可以看到单个任务和任务集合可以协调执行聚合操作。
- en: Next, you studied the `async`/`await` keywords that can help you write simpler
    and more concise code that is, hopefully, easier to maintain.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习`async`/`await`关键字，这些关键字可以帮助您编写更简洁、更简洁的代码，希望更容易维护。
- en: This chapter looked at how C# provides, with relative ease, concurrency patterns
    that make it possible to leverage the power of multicore processors. This is great
    for offloading time-consuming calculations, but it does come at a price. You saw
    how the `lock` statement can be used to safely prevent multiple threads from reading
    or writing to a value simultaneously.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了C#如何相对容易地提供并发模式，使得利用多核处理器的能力成为可能。这对于卸载耗时的计算非常有用，但也是有代价的。您看到了`lock`语句如何用于安全地防止多个线程同时读取或写入值。
- en: In the next chapter, you will look at how Entity Framework and SQL Server can
    be used to interact with relational data in C# applications. This chapter is about
    working with databases. If you are unfamiliar with database structure or would
    like a refresher on the basics of PostgreSQL, please refer to the bonus chapter
    available in the GitHub repository for this book.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解如何使用Entity Framework和SQL Server与C#应用程序中的关系数据进行交互。本章是关于与数据库一起工作。如果您不熟悉数据库结构，或者想要复习一下PostgreSQL的基础知识，请参考本书的GitHub存储库中提供的额外章节。
