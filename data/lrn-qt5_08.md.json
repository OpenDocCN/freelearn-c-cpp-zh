["```cpp\nQT += sql network\n```", "```cpp\n#ifndef INETWORKACCESSMANAGER_H\n#define INETWORKACCESSMANAGER_H\n#include <QNetworkReply>\n#include <QNetworkRequest>\n\nnamespace cm {\nnamespace networking {\nclass INetworkAccessManager\n{\npublic:\n    INetworkAccessManager(){}\n    virtual ~INetworkAccessManager(){}\n    virtual QNetworkReply* get(const QNetworkRequest& request) = 0;\n    virtual bool isNetworkAccessible() const = 0;\n};\n}}\n#endif\n```", "```cpp\n#ifndef NETWORKACCESSMANAGER_H\n#define NETWORKACCESSMANAGER_H\n#include <QObject>\n#include <QScopedPointer>\n#include <networking/i-network-access-manager.h>\nnamespace cm {\nnamespace networking {\nclass NetworkAccessManager : public QObject, public INetworkAccessManager\n{\n    Q_OBJECT\npublic:\n    explicit NetworkAccessManager(QObject* parent = nullptr);\n    ~NetworkAccessManager();\n    QNetworkReply* get(const QNetworkRequest& request) override;\n    bool isNetworkAccessible() const override;\nprivate:\n    class Implementation;\n    QScopedPointer<Implementation> implementation;\n};\n}}\n#endif\n```", "```cpp\n#include \"network-access-manager.h\"\n#include <QNetworkAccessManager>\nnamespace cm {\nnamespace networking {\nclass NetworkAccessManager::Implementation\n{\npublic:\n    Implementation()\n    {}\n    QNetworkAccessManager networkAccessManager;\n};\nNetworkAccessManager::NetworkAccessManager(QObject *parent)\n    : QObject(parent)\n    , INetworkAccessManager()\n{\n    implementation.reset(new Implementation());\n}\nNetworkAccessManager::~NetworkAccessManager()\n{\n}\nQNetworkReply* NetworkAccessManager::get(const QNetworkRequest& request)\n{\n    return implementation->networkAccessManager.get(request);\n}\nbool NetworkAccessManager::isNetworkAccessible() const\n{\n    return implementation->networkAccessManager.networkAccessible() == QNetworkAccessManager::Accessible;\n}\n}}\n```", "```cpp\n#ifndef IWEBREQUEST_H\n#define IWEBREQUEST_H\n#include <QUrl>\nnamespace cm {\nnamespace networking {\nclass IWebRequest\n{\npublic:\n    IWebRequest(){}\n    virtual ~IWebRequest(){}\n    virtual void execute() = 0;\n    virtual bool isBusy() const = 0;\n    virtual void setUrl(const QUrl& url) = 0;\n    virtual QUrl url() const = 0;\n};\n}}\n#endif\n```", "```cpp\n#ifndef WEBREQUEST_H\n#define WEBREQUEST_H\n#include <QList>\n#include <QObject>\n#include <QSslError>\n#include <networking/i-network-access-manager.h>\n#include <networking/i-web-request.h>\nnamespace cm {\nnamespace networking {\nclass WebRequest : public QObject, public IWebRequest\n{\n    Q_OBJECT\npublic:\n    WebRequest(QObject* parent, INetworkAccessManager* networkAccessManager, const QUrl& url);\n    WebRequest(QObject* parent = nullptr) = delete;\n    ~WebRequest();\npublic:\n    void execute() override;\n    bool isBusy() const override;\n    void setUrl(const QUrl& url) override;\n    QUrl url() const override;\nsignals:\n    void error(QString message);\n    void isBusyChanged();\n    void requestComplete(int statusCode, QByteArray body);\n    void urlChanged();\nprivate slots:\n    void replyDelegate();\n    void sslErrorsDelegate( const QList<QSslError>& _errors );\nprivate:\n    class Implementation;\n    QScopedPointer<Implementation> implementation;\n};\n}}\n#endif\n```", "```cpp\n#include \"web-request.h\"\n\n#include <QMap>\n#include <QNetworkReply>\n#include <QNetworkRequest>\nnamespace cm {\nnamespace networking { // Private Implementation\nstatic const QMap<QNetworkReply::NetworkError, QString> networkErrorMapper = {\n    {QNetworkReply::ConnectionRefusedError, \"The remote server refused the connection (the server is not accepting requests).\"},\n    /* ...section shortened in print for brevity...*/\n    {QNetworkReply::UnknownServerError, \"An unknown error related to the server response was detected.\"}\n};\nclass WebRequest::Implementation\n{\npublic:\n    Implementation(WebRequest* _webRequest, INetworkAccessManager* _networkAccessManager, const QUrl& _url)\n        : webRequest(_webRequest)\n        , networkAccessManager(_networkAccessManager)\n        , url(_url)\n    {\n    }\n    WebRequest* webRequest{nullptr};\n    INetworkAccessManager* networkAccessManager{nullptr};\n    QUrl url {};\n    QNetworkReply* reply {nullptr};\npublic: \n    bool isBusy() const\n    {\n        return isBusy_;\n    }\n    void setIsBusy(bool value)\n    {\n        if (value != isBusy_) {\n            isBusy_ = value;\n            emit webRequest->isBusyChanged();\n        }\n    }\nprivate:\n    bool isBusy_{false};\n};\n}\nnamespace networking {  // Structors\nWebRequest::WebRequest(QObject* parent, INetworkAccessManager* networkAccessManager, const QUrl& url)\n    : QObject(parent)\n    , IWebRequest()\n{\n    implementation.reset(new WebRequest::Implementation(this, networkAccessManager, url));\n}\nWebRequest::~WebRequest()\n{\n}\n}\nnamespace networking { // Methods\nvoid WebRequest::execute()\n{\n    if(implementation->isBusy()) {\n        return;\n    }\n\n    if(!implementation->networkAccessManager->isNetworkAccessible()) {\n        emit error(\"Network not accessible\");\n        return;\n    }\n    implementation->setIsBusy(true);\n    QNetworkRequest request;\n    request.setUrl(implementation->url);\n    implementation->reply = implementation->networkAccessManager->get(request);\n    if(implementation->reply != nullptr) {\n        connect(implementation->reply, &QNetworkReply::finished, this, &WebRequest::replyDelegate);\n        connect(implementation->reply, &QNetworkReply::sslErrors, this, &WebRequest::sslErrorsDelegate);\n    }\n}\nbool WebRequest::isBusy() const\n{\n    return implementation->isBusy();\n}\nvoid WebRequest::setUrl(const QUrl& url)\n{\n    if(url != implementation->url) {\n        implementation->url = url;\n        emit urlChanged();\n    }\n}\nQUrl WebRequest::url() const\n{\n    return implementation->url;\n}\n}\nnamespace networking { // Private Slots\nvoid WebRequest::replyDelegate()\n{\n    implementation->setIsBusy(false);\n    if (implementation->reply == nullptr) {\n        emit error(\"Unexpected error - reply object is null\");\n        return;\n    }\n    disconnect(implementation->reply, &QNetworkReply::finished, this, &WebRequest::replyDelegate);\n    disconnect(implementation->reply, &QNetworkReply::sslErrors, this, &WebRequest::sslErrorsDelegate);\n    auto statusCode = implementation->reply->attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();\n    auto responseBody = implementation->reply->readAll();\n    auto replyStatus = implementation->reply->error();\n    implementation->reply->deleteLater();\n    if (replyStatus != QNetworkReply::NoError) {\n        emit error(networkErrorMapper[implementation->reply->error()]);\n    }\n    emit requestComplete(statusCode, responseBody);\n}\nvoid WebRequest::sslErrorsDelegate(const QList<QSslError>& errors)\n{\n    QString sslError;\n    for (const auto& error : errors) {\n        sslError += error.errorString() + \"\\n\";\n    }\n    emit error(sslError);\n}\n}}\n```", "```cpp\nNetworkAccessManager* networkAccessManager{nullptr};\nWebRequest* rssWebRequest{nullptr};\n```", "```cpp\nnetworkAccessManager = new NetworkAccessManager(masterController);\nrssWebRequest = new WebRequest(masterController, networkAccessManager, QUrl(\"http://feeds.bbci.co.uk/news/rss.xml?edition=uk\"));\n```", "```cpp\ncommandController = new CommandController(masterController, databaseController, navigationController, newClient, clientSearch, rssWebRequest);\n```", "```cpp\nexplicit CommandController(QObject* _parent = nullptr, IDatabaseController* databaseController = nullptr, NavigationController* navigationController = nullptr, models::Client* newClient = nullptr, models::ClientSearch* clientSearch = nullptr, networking::IWebRequest* rssWebRequest = nullptr);\n```", "```cpp\nIWebRequest* rssWebRequest{nullptr};\n```", "```cpp\nvoid CommandController::onRssRefreshExecuted()\n{\n    qDebug() << \"You executed the Rss Refresh command!\";\n\n    implementation->rssWebRequest->execute();\n}\n```", "```cpp\nvoid MasterController::onRssReplyReceived(int statusCode, QByteArray body)\n{\n    qDebug() << \"Received RSS request response code \" << statusCode << \":\";\n    qDebug() << body;\n}\n```", "```cpp\nQObject::connect(rssWebRequest, &WebRequest::requestComplete, masterController, &MasterController::onRssReplyReceived);\n```", "```cpp\nReceived RSS request response code 200 :\n\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n<?xml-stylesheet title=...\u201d\n```", "```cpp\n<rss>\n    <channel>\n        <title></title>\n        <description></description>\n        <link></link>\n        <image>\n            <url></url>\n            <title></title>\n            <link></link>\n            <width></width>\n            <height></height>\n        </image>\n        <item>\n            <title></title>\n            <description></description>\n            <link></link>\n            <pubDate></pubDate>\n        </item>\n        <item>\n                \u2026\n          </item>\n    </channel>\n</rss>\n```", "```cpp\nQT += sql network xml\n```", "```cpp\n#ifndef XMLHELPER_H\n#define XMLHELPER_H\n#include <QDomNode>\n#include <QString>\nnamespace cm {\nnamespace utilities {\nclass XmlHelper\n{\npublic:\n    static QString toString(const QDomNode& domNode);\nprivate:\n    XmlHelper(){}\n    static void appendNode(const QDomNode& domNode, QString& output);\n};\n}}\n#endif\n```", "```cpp\n#include \"xml-helper.h\"\n\nnamespace cm {\nnamespace utilities {\nQString XmlHelper::toString(const QDomNode& domNode)\n{\n    QString returnValue;\n    for(auto i = 0; i < domNode.childNodes().size(); ++i) {\n        QDomNode subNode = domNode.childNodes().at(i);\n        appendNode(subNode, returnValue);\n    }\n    return returnValue;\n}\nvoid XmlHelper::appendNode(const QDomNode& domNode, QString& output)\n{\n    if(domNode.nodeType() == QDomNode::TextNode) {\n        output.append(domNode.nodeValue());\n        return;\n    }\n    if(domNode.nodeType() == QDomNode::AttributeNode) {\n        output.append(\" \");\n        output.append(domNode.nodeName());\n        output.append(\"=\\\"\");\n        output.append(domNode.nodeValue());\n        output.append(\"\\\"\");\n        return;\n    }\n    if(domNode.nodeType() == QDomNode::ElementNode) {\n        output.append(\"<\");\n        output.append(domNode.nodeName());\n        // Add attributes\n        for(auto i = 0; i < domNode.attributes().size(); ++i) {\n            QDomNode subNode = domNode.attributes().item(i);\n            appendNode(subNode, output);\n        }\n        output.append(\">\");\n        for(auto i = 0; i < domNode.childNodes().size(); ++i) {\n            QDomNode subNode = domNode.childNodes().at(i);\n            appendNode(subNode, output);\n        }\n        output.append(\"</\" + domNode.nodeName() + \">\");\n    }\n}\n}}\n```", "```cpp\n<xmlNode>\n    Here is something from a website that has a <a href=\u201dhttp://www.bbc.co.uk\u201d>hyperlink</a> in it.\n</xmlNode>\n```", "```cpp\n<xmlNode>\n    <textNode1>Here is something from a website that has a </textNode1>\n    <a href=\u201dhttp://www.bbc.co.uk\u201d>hyperlink</a>\n    <textNode2>in it.</textNode2>\n</xmlNode>\n```", "```cpp\n#ifndef RSSIMAGE_H\n#define RSSIMAGE_H\n#include <QObject>\n#include <QScopedPointer>\n#include <QtXml/QDomNode>\n#include <cm-lib_global.h>\nnamespace cm {\nnamespace rss {\nclass CMLIBSHARED_EXPORT RssImage : public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(quint16 ui_height READ height CONSTANT)\n    Q_PROPERTY(QString ui_link READ link CONSTANT)\n    Q_PROPERTY(QString ui_title READ title CONSTANT)\n    Q_PROPERTY(QString ui_url READ url CONSTANT)\n    Q_PROPERTY(quint16 ui_width READ width CONSTANT)\npublic:\n    explicit RssImage(QObject* parent = nullptr, const QDomNode& domNode = QDomNode());\n    ~RssImage();\n    quint16 height() const;\n    const QString& link() const;\n    const QString& title() const;\n    const QString& url() const;\n    quint16 width() const;\nprivate:\n    class Implementation;\n    QScopedPointer<Implementation> implementation;\n};\n}}\n\n#endif\n```", "```cpp\n#include \"rss-image.h\"\n\nnamespace cm {\nnamespace rss {\nclass RssImage::Implementation\n{\npublic:\n    QString url;    // Mandatory. URL of GIF, JPEG or PNG that represents the channel.\n    QString title;  // Mandatory.  Describes the image.\n    QString link;   // Mandatory.  URL of the site.\n    quint16 width;  // Optional.  Width in pixels.  Max 144, default \n                                                                    88.\n    quint16 height; // Optional.  Height in pixels.  Max 400, default \n                                                                    31\n    void update(const QDomNode& domNode)\n    {\n        QDomElement imageUrl = domNode.firstChildElement(\"url\");\n        if(!imageUrl.isNull()) {\n            url = imageUrl.text();\n        }\n        QDomElement imageTitle = domNode.firstChildElement(\"title\");\n        if(!imageTitle.isNull()) {\n            title = imageTitle.text();\n        }\n        QDomElement imageLink = domNode.firstChildElement(\"link\");\n        if(!imageLink.isNull()) {\n            link = imageLink.text();\n        }\n        QDomElement imageWidth = domNode.firstChildElement(\"width\");\n        if(!imageWidth.isNull()) {\n            width = static_cast<quint16>(imageWidth.text().toShort());\n        } else {\n            width = 88;\n        }\n        QDomElement imageHeight = domNode.firstChildElement(\"height\");\n        if(!imageHeight.isNull()) {\n            height = static_cast<quint16>\n                                  (imageHeight.text().toShort());\n        } else {\n            height = 31;\n        }\n    }\n};\nRssImage::RssImage(QObject* parent, const QDomNode& domNode)\n    : QObject(parent)\n{\n    implementation.reset(new Implementation());\n    implementation->update(domNode);\n}\nRssImage::~RssImage()\n{\n}\nquint16 RssImage::height() const\n{\n    return implementation->height;\n}\nconst QString& RssImage::link() const\n{\n    return implementation->link;\n}\nconst QString& RssImage::title() const\n{\n    return implementation->title;\n}\nconst QString& RssImage::url() const\n{\n    return implementation->url;\n}\nquint16 RssImage::width() const\n{\n    return implementation->width;\n}\n}}\n```", "```cpp\n#ifndef RSSITEM_H\n#define RSSITEM_H\n#include <QDateTime>\n#include <QObject>\n#include <QscopedPointer>\n#include <QtXml/QDomNode>\n#include <cm-lib_global.h>\nnamespace cm {\nnamespace rss {\nclass CMLIBSHARED_EXPORT RssItem : public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(QString ui_description READ description CONSTANT)\n    Q_PROPERTY(QString ui_link READ link CONSTANT)\n    Q_PROPERTY(QDateTime ui_pubDate READ pubDate CONSTANT)\n    Q_PROPERTY(QString ui_title READ title CONSTANT)\npublic:\n    RssItem(QObject* parent = nullptr, const QDomNode& domNode = QDomNode());\n    ~RssItem();\n    const QString& description() const;\n    const QString& link() const;\n    const QDateTime& pubDate() const;\n    const QString& title() const;\nprivate:\n    class Implementation;\n    QScopedPointer<Implementation> implementation;\n};\n}}\n#endif\n```", "```cpp\n#include \"rss-item.h\"\n#include <QTextStream>\n#include <utilities/xml-helper.h>\nusing namespace cm::utilities;\nnamespace cm {\nnamespace rss {\nclass RssItem::Implementation\n{\npublic:\n    Implementation(RssItem* _rssItem)\n        : rssItem(_rssItem)\n    {\n    }\n    RssItem* rssItem{nullptr};\n    QString description;    // This or Title mandatory.  Either the \n                            synopsis or full story.  HTML is allowed.\n    QString link;           // Optional. Link to full story.  Populated \n                                  if Description is only the synopsis.\n    QDateTime pubDate;      // Optional. When the item was published. \n                     RFC 822 format e.g. Sun, 19 May 2002 15:21:36 GMT.\n    QString title;          // This or Description mandatory.\n    void update(const QDomNode& domNode)\n    {\n        for(auto i = 0; i < domNode.childNodes().size(); ++i) {\n            QDomNode childNode = domNode.childNodes().at(i);\n            if(childNode.nodeName() == \"description\") {\n                description = XmlHelper::toString(childNode);\n            }\n        }\n        QDomElement itemLink = domNode.firstChildElement(\"link\");\n        if(!itemLink.isNull()) {\n            link = itemLink.text();\n        }\n        QDomElement itemPubDate = domNode.firstChildElement(\"pubDate\");\n        if(!itemPubDate.isNull()) {\n            pubDate = QDateTime::fromString(itemPubDate.text(), \n                                                     Qt::RFC2822Date);\n        }\n        QDomElement itemTitle = domNode.firstChildElement(\"title\");\n        if(!itemTitle.isNull()) {\n            title = itemTitle.text();\n        }\n    }\n};\nRssItem::RssItem(QObject* parent, const QDomNode& domNode)\n{\n    implementation.reset(new Implementation(this));\n    implementation->update(domNode);\n}\nRssItem::~RssItem()\n{\n}\nconst QString& RssItem::description() const\n{\n    return implementation->description;\n}\nconst QString& RssItem::link() const\n{\n    return implementation->link;\n}\nconst QDateTime& RssItem::pubDate() const\n{\n    return implementation->pubDate;\n}\nconst QString& RssItem::title() const\n{\n    return implementation->title;\n}\n}}\n```", "```cpp\n#ifndef RSSCHANNEL_H\n#define RSSCHANNEL_H\n#include <QDateTime>\n#include <QtXml/QDomElement>\n#include <QtXml/QDomNode>\n#include <QList>\n#include <QObject>\n#include <QtQml/QQmlListProperty>\n#include <QString>\n#include <cm-lib_global.h>\n#include <rss/rss-image.h>\n#include <rss/rss-item.h>\nnamespace cm {\nnamespace rss {\nclass CMLIBSHARED_EXPORT RssChannel : public QObject\n{\n    Q_OBJECT\n    Q_PROPERTY(QString ui_description READ description CONSTANT)\n    Q_PROPERTY(cm::rss::RssImage* ui_image READ image CONSTANT)\n    Q_PROPERTY(QQmlListProperty<cm::rss::RssItem> ui_items READ \n                                                ui_items CONSTANT)\n    Q_PROPERTY(QString ui_link READ link CONSTANT)\n    Q_PROPERTY(QString ui_title READ title CONSTANT)\npublic:\n    RssChannel(QObject* parent = nullptr, const QDomNode& domNode = QDomNode());\n    ~RssChannel();\n    void addItem(RssItem* item);\n    const QString& description() const;\n    RssImage* image() const;\n    const QList<RssItem*>& items() const;\n    const QString& link() const;\n    void setImage(RssImage* image);\n    const QString& title() const;\n    QQmlListProperty<RssItem> ui_items();\n    static RssChannel* fromXml(const QByteArray& xmlData, QObject* \n                                            parent = nullptr);\nprivate:\n    class Implementation;\n    QScopedPointer<Implementation> implementation;\n};\n}}\n#endif\n```", "```cpp\n#include \"rss-channel.h\"\n#include <QtXml/QDomDocument>\nnamespace cm {\nnamespace rss {\nclass RssChannel::Implementation\n{\npublic:\n    QString description;            // Mandatory.  Phrase or sentence describing the channel.\n    RssImage* image{nullptr};       // Optional.  Image representing the channel.\n    QList<RssItem*> items;          // Optional.  Collection representing stories.\n    QString link;                   // Mandatory.  URL to the corresponding HTML website.\n    QString title;                  // Mandatory.  THe name of the Channel.\n    void update(const QDomNode& domNode)\n    {\n        QDomElement channelDescription = domNode.firstChildElement(\"description\");\n        if(!channelDescription.isNull()) {\n            description = channelDescription.text();\n        }\n        QDomElement channelLink = domNode.firstChildElement(\"link\");\n        if(!channelLink.isNull()) {\n            link = channelLink.text();\n        }\n        QDomElement channelTitle = domNode.firstChildElement(\"title\");\n        if(!channelTitle.isNull()) {\n            title = channelTitle.text();\n        }\n    }\n};\nRssChannel::RssChannel(QObject* parent, const QDomNode& domNode)\n    : QObject(parent)\n{\n    implementation.reset(new Implementation());\n    implementation->update(domNode);\n}\nRssChannel::~RssChannel()\n{\n}\nvoid RssChannel::addItem(RssItem* item)\n{\n    if(!implementation->items.contains(item)) {\n        item->setParent(this);\n        implementation->items.push_back(item);\n    }\n}\nconst QString&  RssChannel::description() const\n{\n    return implementation->description;\n}\nRssImage* RssChannel::image() const\n{\n    return implementation->image;\n}\nconst QList<RssItem*>&  RssChannel::items() const\n{\n    return implementation->items;\n}\nconst QString&  RssChannel::link() const\n{\n    return implementation->link;\n}\nvoid RssChannel::setImage(RssImage* image)\n{\n    if(implementation->image) {\n        implementation->image->deleteLater();\n        implementation->image = nullptr;\n    }\n    image->setParent(this);\n    implementation->image = image;\n}\nconst QString& RssChannel::title() const\n{\n    return implementation->title;\n}\nQQmlListProperty<RssItem> RssChannel::ui_items()\n{\n    return QQmlListProperty<RssItem>(this, implementation->items);\n}\nRssChannel* RssChannel::fromXml(const QByteArray& xmlData, QObject* parent)\n{\n    QDomDocument doc;\n    doc.setContent(xmlData);\n    auto channelNodes = doc.elementsByTagName(\"channel\");\n    // Rss must have 1 channel\n    if(channelNodes.size() != 1) return nullptr;\n    RssChannel* channel = new RssChannel(parent, channelNodes.at(0));\n    auto imageNodes = doc.elementsByTagName(\"image\");\n    if(imageNodes.size() > 0) {\n        channel->setImage(new RssImage(channel, imageNodes.at(0)));\n    }\n    auto itemNodes = doc.elementsByTagName(\"item\");\n    for (auto i = 0; i < itemNodes.size(); ++i) {\n        channel->addItem(new RssItem(channel, itemNodes.item(i)));\n    }\n    return channel;\n}\n}}\n```", "```cpp\nqmlRegisterType<cm::rss::RssChannel>(\"CM\", 1, 0, \"RssChannel\");\nqmlRegisterType<cm::rss::RssImage>(\"CM\", 1, 0, \"RssImage\");\nqmlRegisterType<cm::rss::RssItem>(\"CM\", 1, 0, \"RssItem\");\n```", "```cpp\nvoid MasterController::onRssReplyReceived(int statusCode, QByteArray body)\n{\n    qDebug() << \"Received RSS request response code \" << statusCode << \":\";\n    qDebug() << body;\n    if(implementation->rssChannel) {\n        implementation->rssChannel->deleteLater();\n        implementation->rssChannel = nullptr;\n        emit rssChannelChanged();\n    }\n    implementation->rssChannel = RssChannel::fromXml(body, this);\n    emit rssChannelChanged();\n}\n```", "```cpp\nimport QtQuick 2.9\nimport assets 1.0\nimport CM 1.0\nItem {\n    property RssItem rssItem\n    implicitWidth: parent.width\n    implicitHeight: background.height\n    Rectangle {\n        id: background\n        width: parent.width\n        height: textPubDate.implicitHeight + textTitle.implicitHeight + \n                       borderBottom.height + (Style.sizeItemMargin * 3)\n        color: Style.colourPanelBackground\n        Text {\n            id: textPubDate\n            anchors {\n                top: parent.top\n                left: parent.left\n                right: parent.right\n                margins: Style.sizeItemMargin\n            }\n            text: Qt.formatDateTime(rssItem.ui_pubDate, \"ddd, d MMM \n                                                    yyyy @ h:mm ap\")\n            font {\n                pixelSize: Style.pixelSizeDataControls\n                italic: true\n                weight: Font.Light\n            }\n            color: Style.colorItemDateFont\n        }\n        Text {\n            id: textTitle\n            anchors {\n                top: textPubDate.bottom\n                left: parent.left\n                right: parent.right\n                margins: Style.sizeItemMargin\n            }\n            text: rssItem.ui_title\n            font {\n                pixelSize: Style.pixelSizeDataControls\n            }\n            color: Style.colorItemTitleFont\n            wrapMode: Text.Wrap\n        }\n        Rectangle {\n            id: borderBottom\n            anchors {\n                top: textTitle.bottom\n                left: parent.left\n                right: parent.right\n                topMargin: Style.sizeItemMargin\n            }\n            height: 1\n            color: Style.colorItemBorder\n        }\n        MouseArea {\n            anchors.fill: parent\n            cursorShape: Qt.PointingHandCursor\n            hoverEnabled: true\n            onEntered: background.state = \"hover\"\n            onExited: background.state = \"\"\n            onClicked: if(rssItem.ui_link !== \"\") {\n                           Qt.openUrlExternally(rssItem.ui_link);\n                       }\n        }\n        states: [\n            State {\n                name: \"hover\"\n                PropertyChanges {\n                    target: background\n                    color: Style.colourPanelBackgroundHover\n                }\n            }\n        ]\n    }\n}\n```", "```cpp\nreadonly property color colourItemBackground: \"#fefefe\"\nreadonly property color colourItemBackgroundHover: \"#efefef\"\nreadonly property color colorItemBorder: \"#efefef\"\nreadonly property color colorItemDateFont: \"#636363\"\nreadonly property color colorItemTitleFont: \"#131313\"\nreadonly property real sizeItemMargin: 5\n```", "```cpp\nimport QtQuick 2.9\nimport assets 1.0\nimport components 1.0\nItem {\n    Rectangle {\n        anchors.fill: parent\n        color: Style.colourBackground\n    }\n    ListView {\n        id: itemsView\n        anchors {\n            top: parent.top\n            left: parent.left\n            right: parent.right\n            bottom: commandBar.top\n            margins: Style.sizeHeaderMargin\n        }\n        clip: true\n        model: masterController.ui_rssChannel ? masterController.ui_rssChannel.ui_items : 0\n        delegate: RssItemDelegate {\n            rssItem: modelData\n        }\n    }\n    CommandBar {\n        id: commandBar\n        commandList: masterController.ui_commandController.ui_rssViewContextCommands\n    }\n}\n```"]