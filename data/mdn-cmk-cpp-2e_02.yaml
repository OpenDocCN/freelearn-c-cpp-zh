- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: The CMake Language
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMake 语言
- en: Writing in the **CMake** **language** is trickier than one might expect. When
    you read a CMake listfile for the first time, you may be under the impression
    that the language in it is so simple that it can be just practiced without any
    theory. You may then attempt to introduce changes and experiment with the code
    without a thorough understanding of how it actually works. I wouldn’t blame you.
    We programmers are usually very busy, and build-related issues aren’t usually
    something that sounds exciting to invest lots of time in. In an effort to go fast,
    we tend to make gut-based changes hoping they just might do the trick. This approach
    to solving technical problems is called *voodoo programming*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 用 **CMake** **语言** 编写代码比想象的要复杂。当你第一次阅读 CMake 列表文件时，可能会觉得它的语言如此简单，以至于可以直接实践，而不需要任何理论基础。你可能会尝试做出修改，并在没有充分理解其工作原理的情况下实验代码。我不会责怪你。我们程序员通常都很忙，构建相关的问题通常也不是一个值得投入大量时间的有趣话题。为了快速推进，我们往往凭直觉做出修改，希望它们能奏效。这种解决技术问题的方式被称为*巫术编程*。
- en: 'The CMake language appears trivial: after introducing our small extension,
    fix, hack, or one-liner, we suddenly realize that something isn’t working. Usually,
    the duration spent on debugging exceeds the time required for comprehending the
    topic itself. Luckily, this won’t be our fate because this chapter covers most
    of the critical knowledge needed to use the CMake language in practice.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 语言看起来很简单：在我们引入了小扩展、修复、黑客技巧或一行代码后，我们突然发现有些东西不起作用。通常，调试所花费的时间超过了理解该主题本身所需的时间。幸运的是，这不会成为我们的命运，因为本章涵盖了使用
    CMake 语言实践所需的大部分关键知识。
- en: In this chapter, we’ll not only learn about the building blocks of the CMake
    language – **comments**, **commands**, **variables**, and **control structures**
    – but we’ll also understand the necessary background and try out examples following
    the latest practices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不仅将学习 CMake 语言的构成模块——**注释**、**命令**、**变量**和**控制结构**——还将理解相关背景知识，并根据最新的实践进行示例操作。
- en: CMake puts you in a bit of a unique position. On one hand, you perform the role
    of a build engineer and must have a comprehensive grasp of compilers, platforms,
    and all related aspects. On the other hand, you’re a developer who writes the
    code that generates a buildsystem. Crafting high-quality code is a challenging
    task that demands a multifaceted approach. Not only must the code be functional
    and legible but it should also be easy to analyze, extend, and maintain.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 让你处于一个独特的地位。一方面，你扮演着构建工程师的角色，必须全面了解编译器、平台及相关方面；另一方面，你是一个开发者，编写生成构建系统的代码。编写高质量代码是一项具有挑战性的任务，需要多方面的能力。代码不仅要能正常工作、易于阅读，还应该易于分析、扩展和维护。
- en: To conclude, we will present a selection of the most practical and frequently
    utilized commands in CMake. Commands that are also commonly used, but not to the
    same extent, will be placed in *Appendix*, *Miscellaneous Commands* (reference
    guides for the `string`, `list`, `file`, and `math` commands).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 总结时，我们将展示一些在 CMake 中最实用和最常用的命令。那些也常用但使用频率较低的命令将被放入*附录*，*杂项命令*中（包括 `string`、`list`、`file`
    和 `math` 命令的参考指南）。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主要内容：
- en: The basics of the CMake language syntax
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 语言语法基础
- en: Working with variables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理变量
- en: Using lists
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表
- en: Understanding control structures in CMake
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 CMake 中的控制结构
- en: Exploring the frequently used commands
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索常用的命令
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch02](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch02).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章中出现的代码文件，链接地址是：[https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch02](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch02)。
- en: 'To build the examples provided in this book, always use the recommended commands:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建本书提供的示例，始终使用推荐的命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace the placeholders `<build tree>` and `<source tree>` with
    appropriate paths. As a reminder: **build tree** is the path to the target/output
    directory and **source tree** is the path at which your source code is located.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将 `<build tree>` 和 `<source tree>` 占位符替换为适当的路径。提醒一下：**build tree** 是目标/输出目录的路径，**source
    tree** 是源代码所在的路径。
- en: The basics of the CMake language syntax
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMake 语言语法基础
- en: 'Composing CMake code is very much like writing in any other imperative language:
    lines are executed from top to bottom and from left to right, occasionally stepping
    into an included file or a called function. The starting point of execution is
    determined by the mode (see the *Mastering the command line* section in *Chapter
    1*, *First Steps with CMake*), either from the root file of the source tree (`CMakeLists.txt`)
    or a `.cmake` script file provided as an argument to `cmake`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 CMake 代码与编写其他命令式语言非常相似：代码行从上到下、从左到右执行，偶尔会进入一个包含文件或调用的函数。执行的起点由模式决定（参见*第1章*中*掌握命令行*部分，*与
    CMake 初步接触*），即从源代码树的根文件（`CMakeLists.txt`）或作为参数传递给 `cmake` 的 `.cmake` 脚本文件开始。
- en: Since CMake scripts offer extensive support for the CMake language, except for
    project-related features, we will utilize them to practice CMake syntax in this
    chapter. Once we become proficient in composing simple listfiles, we can advance
    to creating actual project files, which we will cover in *Chapter 4*, *Setting
    Up Your First CMake Project*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CMake 脚本广泛支持 CMake 语言，除了项目相关功能外，我们将在本章中利用它们来练习 CMake 语法。一旦我们熟练掌握了编写简单列表文件的技巧，就可以进阶到创建实际的项目文件，这部分内容将在*第4章*中讲解，*设置你的第一个
    CMake 项目*。
- en: 'As a reminder, scripts can be run with the following command: `cmake -P script.cmake`.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，可以使用以下命令运行脚本：`cmake -P script.cmake`。
- en: CMake supports **7-bit** **ASCII** text files for portability across all platforms.
    You can use both `\n` or `\r\n` line endings. CMake versions above 3.2 support
    **UTF-8** and **UTF-16** with optional **byte-order markers** (**BOMs**).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 支持 **7位** **ASCII** 文本文件，以实现跨平台的可移植性。你可以使用`\n`或`\r\n`行结束符。CMake 版本高于 3.2
    支持 **UTF-8** 和 **UTF-16**，并且可以选择使用 **字节顺序标记** (**BOM**)。
- en: Everything in a CMake listfile is either a *comment* or a *command invocation*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CMake 列表文件中，所有内容要么是*注释*，要么是*命令调用*。
- en: Comments
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'Just like in **C++**, there are two kinds of comments: *single-line* comments
    and *bracket* (multiline) comments. But unlike in C++, bracket comments can be
    nested. Single-line comments start with a hash sign, `#`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 **C++** 中一样，注释有两种类型：*单行*注释和*括号*（多行）注释。但与 C++ 不同的是，括号注释可以嵌套。单行注释以井号`#`开始：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Multiline bracket comments get their name from their symbol – they start with
    `#` followed by opening square bracket `[`, any number of equal signs `=` (which
    can also include 0), and another square bracket `[`. To close a bracket comment,
    use the same number of equal signs and reverse the brackets `]`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 多行括号注释得名于其符号——它们以`#`开头，后跟一个左方括号`[`，接着是任意数量的等号`=`（可以包括0个），然后是另一个方括号`[`。要关闭一个括号注释，请使用相同数量的等号并反向括号`]`：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can deactivate a multiline comment swiftly by adding another `#` to the
    initial line of the bracket comment, as demonstrated in the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在括号注释的首行再添加一个`#`来快速停用多行注释，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Knowing how to use comments is definitely useful, but it raises another question:
    when should we do it? Since writing listfiles is essentially programming, it is
    a good idea to bring our best coding practices to them as well.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何使用注释绝对是有用的，但这又引出了另一个问题：我们应该在何时使用它们？因为编写列表文件本质上是编程，所以将最佳编码实践应用于它们也是一个好主意。
- en: Code that follows such practices is often called *clean code* – a term used
    over the years by software development gurus like Robert C. Martin, Martin Fowler,
    and many other authors.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这种做法的代码通常被称为*干净代码*——这是软件开发大师如罗伯特·C·马丁、马丁·福勒等许多作者多年来使用的术语。
- en: 'There is often a lot of controversy surrounding which practices are considered
    beneficial or detrimental, and as you might expect, comments have not been exempt
    from these debates. Everything should be judged on a case-by-case basis, but generally
    agreed-upon guidelines say that good comments provide at least one of the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关于哪些做法是有益的，哪些是有害的，常常会有很多争议，正如你所料，注释也未能免于这些争论。所有事情都应该根据具体情况进行判断，但普遍认可的指南认为好的注释至少应该具备以下之一：
- en: '**Information**: They can untangle complexities such as regex patterns or formatting
    strings.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息**：它们可以解开复杂性，比如正则表达式模式或格式化字符串。'
- en: '**Intent**: They can explain the intent of the code when it is not obvious
    from the implementation or interface.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**意图**：它们可以解释代码的意图，当代码的实现或接口并不明显时。'
- en: '**Clarification**: They can explain concepts that can’t be easily refactored
    or changed.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**澄清**：它们可以解释一些无法轻易重构或更改的概念。'
- en: '**Warnings of consequences**: They can provide warnings, especially around
    code that can break other things.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后果警告**：它们可以提供警告，特别是关于可能破坏其他部分的代码。'
- en: '**Amplification**: They can underline the importance of an idea that is hard
    to express in code.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加强**：它们可以强调某个在代码中难以表达的概念的重要性。'
- en: '**Legal clauses**: They can add this necessary evil, which is usually not the
    domain of a programmer.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合法条款**：它们可以添加这个必要的麻烦，通常这并不是程序员的领域。'
- en: 'It’s best to avoid comments by applying better naming, refactoring or correcting
    your code. Omit comments that are:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最好通过更好的命名、重构或修正代码来避免注释。省略以下类型的注释：
- en: '**Mandated**: These are added for completeness but they are not really important.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制性**：这些是为了完整性而添加的，但它们并不真正重要。'
- en: '**Redundant**: These repeat what is already clearly written in the code.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冗余**：这些内容重复了代码中已清晰表达的内容。'
- en: '**Misleading**: These could be outdated or incorrect if they don’t follow code
    changes.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**误导性**：如果这些没有跟随代码变化，它们可能会变得过时或不准确。'
- en: '**Journal**: These note what has been changed and when (use **Version Control
    Systems** (**VCS**) for this instead).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**：这些记录了已更改的内容及其时间（可以使用**版本控制系统**（**VCS**）来替代）。'
- en: '**Dividers**: These mark sections.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分隔符**：这些标记出不同的部分。'
- en: If you can, avoid adding comments, adopt better naming practices, and refactor
    or correct your code. Crafting elegant code is a challenging task but it enhances
    the reader’s experience. Since we spend more time reading code than composing
    it, we should always strive to write code that is easy to read, instead of just
    trying to finish it quickly. I recommend checking out the *Further reading* section
    at the end of this chapter for some good references on *clean code*. If you’re
    interested in comments, you’ll find a link to my YouTube video *Which comments
    in your code ARE GOOD?* touching on this subject in depth.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以，避免添加注释，采用更好的命名实践，并重构或修正代码。编写优雅的代码是一个具有挑战性的任务，但它提升了读者的体验。由于我们花在阅读代码上的时间通常比编写代码的时间更多，我们应该始终努力编写易于阅读的代码，而不仅仅是追求快速完成。我建议你查看本章末尾的*进一步阅读*部分，那里有一些关于*清洁代码*的好参考。如果你对注释感兴趣，你可以找到我
    YouTube 视频《你代码中的哪些注释是好的？》的链接，深入探讨这个话题。
- en: Command invocations
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令调用
- en: Time for some action! Invoking commands is the bread and butter of CMake listfiles.
    In order to run a command, you must specify its name followed by parentheses,
    in which you can enclose a list of **command arguments** separated by whitespace.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该采取行动啦！调用命令是 CMake 列表文件的核心。在运行命令时，必须指定命令名称，后面跟上括号，括号内可以包含以空格分隔的**命令参数**。
- en: '![](img/B19844_02_01.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_02_01.png)'
- en: 'Figure 2.1: An example of a command'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：命令示例
- en: Command names aren’t case-sensitive, but there is a convention in the CMake
    community to use `snake_case` (that is, lowercase words joined with underscores).
    You can also define your own commands, which we’ll cover in the *Understanding
    control structures in CMake* section of this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 命令名称不区分大小写，但 CMake 社区有一个约定，使用 `snake_case`（即用下划线连接的小写单词）。你还可以定义自己的命令，我们将在本章的*理解
    CMake 中的控制结构*部分讲解这一点。
- en: One significant difference between CMake and C++ is that command invocations
    in CMake are not expressions. This means that you cannot pass another command
    as an argument to a called command because *everything* inside the parentheses
    is treated as an argument for that specific command.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 与 C++ 之间一个显著的区别是，CMake 中的命令调用不是表达式。这意味着你不能将另一个命令作为参数传递给已调用的命令，因为*括号内的所有内容*都被视为该特定命令的参数。
- en: CMake commands are also not followed with semicolons. This is because each line
    of source code can only contain one command.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 命令后面也不需要加分号。这是因为每行源代码只能包含一个命令。
- en: 'A command can be optionally followed by a comment:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 命令后面可以选择性地加上注释：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But not the other way around:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但不是反过来：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we said earlier, everything in a CMake listfile is either a *comment* or
    a *command* *invocation*. CMake syntax really is that simple, and for the most
    part, it’s a good thing. While there are some constraints (for instance, you can’t
    increment a counter variable using an expression), for the most part, these limitations
    are mostly acceptable because CMake is not intended to be a general-purpose language.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所说，CMake 列表文件中的所有内容要么是*注释*，要么是*命令* *调用*。CMake 语法确实如此简单，通常来说，这是件好事。虽然有些限制（例如，你不能通过表达式来递增计数器变量），但大部分情况下，这些限制是可以接受的，因为
    CMake 并非旨在成为一种通用编程语言。
- en: 'CMake provides commands to manipulate variables, direct the flow of execution,
    modify files, and much more. To make things easier, we will be introducing the
    relevant commands as we progress through different examples. These commands can
    be categorized into two groups:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 提供了命令来操作变量、控制执行流、修改文件等等。为了简化操作，我们将在不同示例中逐步介绍相关命令。这些命令可以分为两组：
- en: '**Scripting commands**: These are always available and they change the state
    of the command processor and access variables, and affect other commands and the
    environment.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本命令**：这些命令始终可用，它们改变命令处理器的状态，访问变量，并影响其他命令和环境。'
- en: '**Project commands**: These are available in projects and they manipulate the
    project state and build targets.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目命令**：这些命令在项目中可用，它们用于操作项目状态和构建目标。'
- en: 'Virtually every command relies on other elements of the language in order to
    function: variables, conditional statements, and, most importantly, command-line
    arguments. Now, let’s explore how we can utilize them.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有命令都依赖于语言中的其他元素才能运行：变量、条件语句，最重要的是命令行参数。现在，让我们探讨一下如何利用它们。
- en: Command arguments
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令参数
- en: A number of commands in CMake necessitate whitespace-separated arguments to
    configure their behavior. As demonstrated in *Figure 2.1*, the quotation marks
    used around the arguments can be quite peculiar. While certain arguments require
    quotes, others do not. What’s the reasoning behind this distinction?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 中的许多命令需要空格分隔的参数来配置其行为。如*图 2.1*所示，围绕参数使用的引号可能相当特殊。某些参数需要引号，而其他参数则不需要。为什么会有这样的区别呢？
- en: Under the hood, the only data type recognized by CMake is a `string`. This is
    why every command expects zero or more strings for its arguments. CMake will **evaluate**
    every argument to a static string and then pass them into the command. *Evaluating*
    means **string interpolation**, or substituting parts of a string with another
    value. This can mean replacing the **escape sequences,** expanding the **variable
    references** (also called *variable interpolation*), and unpacking **lists**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，CMake 识别的唯一数据类型是 `string`。因此，每个命令都期望它的参数是零个或多个字符串。CMake 会**评估**每个参数为静态字符串，然后将它们传递给命令。*评估*意味着**字符串插值**，或者用另一个值替换字符串的一部分。这可能意味着替换**转义序列**，扩展**变量引用**（也叫做*变量插值*），以及解包**列表**。
- en: 'Depending on the context, we might want to enable such evaluation as needed.
    For that reason, CMake offers three types of arguments:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上下文的不同，我们可能需要根据需要启用这样的评估。因此，CMake 提供了三种类型的参数：
- en: Bracket arguments
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号参数
- en: Quoted arguments
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加引号的参数
- en: Unquoted arguments
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未加引号的参数
- en: Every argument type in CMake has its own peculiarities and provides a distinct
    level of evaluation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 中的每种参数类型都有其特殊性，并提供不同级别的评估。
- en: Bracket arguments
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 括号参数
- en: Bracket arguments aren’t evaluated because they are used to pass multiline strings,
    verbatim, as a single argument to commands. This means that such an argument will
    include whitespace in the form of tabs and newlines.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 括号参数不会被评估，因为它们用于将多行字符串逐字传递给命令作为单一参数。这意味着这样的参数会包括制表符和换行符形式的空白字符。
- en: Bracket arguments are formatted identically to comments. They are initiated
    with `[=[` and concluded with `]=]`, and the number of equal signs in both the
    opening and closing tokens must match (omitting equal signs is permissible as
    long as they match). The only difference from the comments is that bracket arguments
    cannot be nested.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 括号参数的格式与注释完全相同。它们以 `[=[` 开始，并以 `]=]` 结束，开头和结尾的等号数量必须匹配（只要匹配，省略等号也是允许的）。与注释的唯一不同是，括号参数不能嵌套。
- en: 'Here’s an example of the use of such an argument with the `message()` command,
    which prints all passed arguments to the screen:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用这种参数的示例，结合 `message()` 命令，它会将所有传递的参数打印到屏幕上：
- en: '**ch02/01-arguments/bracket.cmake**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch02/01-arguments/bracket.cmake**'
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example, we can see different forms of bracket arguments.
    Note how putting closing tags on a separate line in the first call introduces
    an empty line in the output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到不同形式的括号参数。注意在第一次调用中将闭合标签放在单独一行，会导致输出中出现空行：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The second form is useful when we’re passing text that contains double brackets
    (`]]`) (highlighted in the code snippet), as they won’t be interpreted as marking
    the end of the argument.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种形式在传递包含双括号（`]]`）（代码片段中突出显示）的文本时非常有用，因为它们不会被解释为标记参数的结束。
- en: These kinds of bracket arguments have limited use – typically, they contain
    lengthier blocks of text with messages that are displayed to the user. In most
    cases, we’ll need something more dynamic, such as quoted arguments.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这类括号参数的使用较为有限——通常它们包含较长的文本块，其中的信息会显示给用户。大多数情况下，我们需要的是更动态的内容，比如带引号的参数。
- en: Quoted arguments
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带引号的参数
- en: 'Quoted arguments resemble a regular C++ string – these arguments group together
    multiple characters, including whitespace, and they will expand *escape sequences*.
    Like C++ strings, they are opened and closed with a double quote character, `"`,
    so to include a quote character within the output string, you have to escape it
    with a backslash, `\"`. Other well-known escape sequences are supported as well:
    `\\` denotes a literal backslash, `\t` is a tab character, `\n` is a newline,
    and `\r` is a carriage return.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 带引号的参数类似于常规的 C++ 字符串——这些参数将多个字符（包括空格）组合在一起，并且它们会展开*转义序列*。像 C++ 字符串一样，它们以双引号字符
    `" ` 开头和结尾，因此要在输出字符串中包含引号字符，必须用反斜杠进行转义 `\"`。其他常见的转义序列也被支持：`\\` 表示字面上的反斜杠，`\t`
    是制表符，`\n` 是换行符，`\r` 是回车符。
- en: 'This is where the similarities with C++ strings end. Quoted arguments can span
    multiple lines, and they will interpolate variable references. Think of them as
    having a built-in `sprintf` function from **C** or a `std::format` function from
    **C++20**. To insert a variable reference to your argument, wrap the name of the
    variable in a token like so: `${name}`. We’ll talk more about variable references
    in the *Working with variables* section of this chapter.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是与 C++ 字符串相似之处的终结。带引号的参数可以跨越多行，并且它们会插入变量引用。可以将它们视为内置的`printf`函数来自**C**，或来自**C++20**的`std::format`函数。要在参数中插入变量引用，只需将变量名用
    `${name}` 这样的标记括起来。我们将在本章的*处理变量*部分进一步讨论变量引用。
- en: Can you guess how many lines will be in the output of the following script?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到下面的脚本输出会有多少行吗？
- en: '**ch02/01-arguments/quoted.cmake**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch02/01-arguments/quoted.cmake**'
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s see it in action:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个实际例子：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That’s right – we have one escaped quote character, one newline escape sequence,
    and a literal newline. We also accessed a built-in `CMAKE_VERSION` variable, which
    we can see interpolated on the last line. Let’s take a look at how CMake treats
    arguments without quotes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 没错——我们有一个转义的引号字符，一个换行转义序列和一个字面上的换行符。我们还访问了一个内置的 `CMAKE_VERSION` 变量，可以看到它在最后一行被插入。让我们来看
    CMake 是如何处理没有引号的参数的。
- en: Unquoted arguments
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未加引号的参数
- en: In the programming world, we have gotten used to the fact that strings must
    be delimited in one form or another, for example, by using single quotes, double
    quotes, or a backslash. CMake deviates from this convention and introduces *unquoted
    arguments*. We might argue that dropping delimiters makes the code easier to read.
    Is that true? I’ll let you form your own opinion.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程领域，我们已经习惯了字符串必须以某种方式进行定界，例如使用单引号、双引号或反斜杠。CMake 偏离了这一惯例，提出了*未加引号的参数*。我们或许可以争论去掉定界符会让代码更易读。这个说法是否成立？我让你自己去判断。
- en: Unquoted arguments evaluate both *escape sequences* and *variable references*.
    However, be careful with semicolons `(;)` as, in CMake, semicolons are treated
    as *list* delimiters. If an argument contains a semicolon, CMake will split it
    into multiple arguments. If you need to use them, escape every semicolon with
    a backslash, `\;`. We’ll talk more about semicolons in the *Using lists* section
    of this chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 未加引号的参数会同时处理*转义序列*和*变量引用*。但是，要小心分号 `(；)`，因为在 CMake 中，分号会被视为*列表*的定界符。如果参数中包含分号，CMake
    会将其拆分成多个参数。如果需要使用分号，必须使用反斜杠进行转义 `\;`。我们将在本章的*使用列表*部分进一步讨论分号。
- en: 'You may find that these arguments are the most perplexing to work with, so
    here’s an illustration to help clarify how these arguments are partitioned:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现这些参数最难处理，因此这里有一个例子可以帮助说明这些参数是如何被划分的：
- en: '![](img/B19844_02_02.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_02_02.png)'
- en: 'Figure 2.2: Escape sequences cause separate tokens to be interpreted as a single
    argument'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2：转义序列导致多个标记被解释为一个单一的参数
- en: It’s always worth being careful with unquoted arguments. Some CMake commands
    require a specific number of arguments and ignore any overhead. If your arguments
    become accidentally separated, you’ll get hard-to-debug errors.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 处理未加引号的参数时总是需要小心。一些 CMake 命令需要特定数量的参数，并会忽略任何附加内容。如果你的参数被不小心分开了，你可能会遇到难以调试的错误。
- en: Unquoted arguments cannot contain unescaped *quotes (“), hashes (#), and backslashes
    (\). And if that’s not enough to remember, parentheses, `()`, are allowed only
    if they form correct, matching pairs. That is, you’ll start with an opening parenthesis
    and close it before closing the command argument list.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 未加引号的参数不能包含未转义的*引号（“）*、井号（#）和反斜杠（\）。如果这些还不够记住，括号`()`仅在它们形成正确的配对时才允许使用。也就是说，你必须从一个左括号开始，并在关闭命令参数列表之前关闭它。
- en: 'Here are some examples that demonstrate the rules we have discussed:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些展示我们讨论过的规则的例子：
- en: '**ch02/01-arguments/unquoted.cmake**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch02/01-arguments/unquoted.cmake**'
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What will be the output of the preceding? Let’s have a look:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将会输出什么呢？我们来看看：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Even a simple command such as `message()` is very particular about separated
    unquoted arguments. The space in `a single argument` was correctly printed when
    it was explicitly escaped. However, `twoarguments` and `threeseparatearguments`
    were *glued* together, since `message()` doesn’t add any spaces on its own.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是像`message()`这样简单的命令，对于未加引号的参数分隔也有严格要求。当`a single argument`中的空格被正确转义时，它被正确打印出来。然而，`twoarguments`和`threeseparatearguments`却被*粘*在了一起，因为`message()`不会自动添加空格。
- en: 'Given all these complexities, when is it beneficial to use unquoted arguments?
    Some CMake commands allow optional arguments that are preceded by a keyword to
    signify that an optional argument will be provided. In such instances, using an
    unquoted argument for the keyword can make the code more legible. For example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于所有这些复杂性，何时使用未加引号的参数会更有利呢？一些CMake命令允许使用由关键字引导的可选参数，表示将提供一个可选参数。在这种情况下，使用未加引号的关键字参数可以使代码更加易读。例如：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this command, the `VERSION` keyword and the following argument `1.2.3` are
    optional. As you can see, both are left unquoted for readability. Note that keywords
    are case-sensitive.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，`VERSION`关键字和后面的参数`1.2.3`是可选的。正如你所看到的，两个部分都没有加引号，以提高可读性。注意，关键字是区分大小写的。
- en: Now that we understand how to deal with the complexities and quirks of CMake
    arguments, we are ready to tackle the next interesting subject – working with
    all kinds of variables in CMake.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何处理CMake参数的复杂性和怪癖，接下来就可以处理CMake中各种变量的操作了。
- en: Working with variables
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作变量
- en: '**Variables** in CMake are a surprisingly complex subject. Not only are there
    three categories of variables – **normal**, **cache**, and **environment** – but
    they also reside in different **variable scopes**, with specific rules on how
    one *scope* affects the other. Very often, a poor understanding of these rules
    becomes a source of bugs and headaches. I recommend you study this section with
    care and make sure you understand all of the concepts before moving on.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: CMake中的**变量**是一个令人惊讶的复杂话题。变量不仅有三类——**普通变量**、**缓存变量**和**环境变量**——它们还存在于不同的**变量作用域**中，并有特定的规则规定一个*作用域*如何影响另一个作用域。通常，对于这些规则理解不够清晰会成为bug和头痛的源头。我建议你认真学习这一部分，确保在继续之前完全理解所有的概念。
- en: 'Let’s start with some key facts about variables in CMake:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些关于CMake变量的关键事实开始：
- en: Variable names are case-sensitive and can include almost any character.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名是区分大小写的，并且几乎可以包含任何字符。
- en: All variables are stored internally as strings, even if some commands can interpret
    them as values of other data types (even *lists*!).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有变量都以字符串形式存储，即使一些命令可以将它们解释为其他数据类型的值（甚至是*列表*！）。
- en: The basic variable manipulation commands are `set()` and `unset()`, but there
    are other commands that can alter variable values, such as `string()` and `list()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的变量操作命令是`set()`和`unset()`，但还有其他命令可以改变变量的值，例如`string()`和`list()`。
- en: 'To declare a **normal variable**, we simply call `set()`, providing its name
    and the value:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个**普通变量**，我们只需要调用`set()`，提供其名称和值：
- en: '**ch02/02-variables/set.cmake**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch02/02-variables/set.cmake**'
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the use of brackets and quoted arguments allows for spaces to
    be included in the variable name. However, when referencing it later, we have
    to escape the whitespace with a backslash, `\`. For that reason, it is recommended
    to use only alphanumeric characters, dashes `(-)`, and underscores `(_)` in variable
    names.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用括号和加引号的参数可以使变量名包含空格。然而，在稍后的引用中，我们必须使用反斜杠`\`来转义空格。因此，建议仅在变量名中使用字母数字字符、连字符`(-)`和下划线`(_)`。
- en: 'Also avoid reserved names (in uppercase, lowercase, or mixed case) that begin
    with any of the following: `CMAKE_`, `_CMAKE_`, or an underscore, `_`, followed
    by the name of any CMake command.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 同时避免使用以下保留名称（无论是大写、小写还是混合大小写），这些名称以以下任何一个开始：`CMAKE_`、`_CMAKE_`，或者是一个下划线`_`，后跟任何CMake命令的名称。
- en: 'To unset a variable, we can use `unset()` in the following way: `unset(MyString1)`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消设置一个变量，我们可以使用`unset()`，方法如下：`unset(MyString1)`。
- en: The `set()` command accepts a plain text variable name as its first argument,
    but the `message()` command uses a variable reference wrapped in the `${}` syntax.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`set()`命令接受一个普通文本变量名作为第一个参数，但`message()`命令使用用`${}`语法包裹的变量引用。'
- en: What would happen if we were to provide a variable wrapped in the `${}` syntax
    to the `set()` command?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个变量用`${}`语法传递给`set()`命令，会发生什么情况？
- en: To answer that, we’ll need to understand *variable references* better.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这个问题，我们需要更好地理解*变量引用*。
- en: Variable references
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量引用
- en: 'I already mentioned references briefly in the *Command arguments* section,
    as they’re evaluated for quoted and unquoted arguments. We learned that to create
    a reference to a defined variable, we need to use the `${}` syntax, like so: `message(${MyString1})`.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在*命令参数*部分简要提到了引用，因为它们会在带引号和不带引号的参数中进行求值。我们了解到，要创建对已定义变量的引用，我们需要使用`${}`语法，像这样：`message(${MyString1})`。
- en: On evaluation, CMake will traverse the *variable scopes* from the innermost
    scope to the outermost scope and replace `${MyString1}` with a value, or an empty
    string if no variable is found (CMake won’t produce any error messages). This
    process is also called *variable evaluation*, *expansion*, or *interpolation*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在求值时，CMake将从最内层的作用域遍历到最外层作用域，并将`${MyString1}`替换为一个值，或者如果没有找到变量，则替换为空字符串（CMake不会产生任何错误信息）。这个过程也被称为*变量求值*、*扩展*或*插值*。
- en: 'Interpolation is performed in an inside-out manner, beginning from the innermost
    curly brace pair and moving outward. For example, if the ${MyOuter${MyInner}}
    reference is encountered:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 插值是从内向外进行的，从最内层的花括号对开始，逐步向外推进。例如，如果遇到`${MyOuter${MyInner}}`引用：
- en: CMake will try to evaluate `MyInner` first, rather than searching for a variable
    named `MyOuter${MyInner}`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake将首先尝试评估`MyInner`，而不是查找名为`MyOuter${MyInner}`的变量。
- en: If the `MyInner` variable is successfully expanded, CMake will repeat the expansion
    process using the newly formed reference until no further expansion is possible.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`MyInner`变量成功展开，CMake将使用新形成的引用重复扩展过程，直到无法继续扩展为止。
- en: To avoid receiving unexpected outcomes, it is recommended to refrain from storing
    variable expansion tokens in variable values.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免出现意外的结果，建议不要将变量扩展标记存储在变量值中。
- en: CMake will perform variable expansion to the full extent, and only after completion
    will it pass the resulting values as arguments to the command. This is why when
    we call `set(${MyInner} "Hi")`; we won’t actually be changing the `MyInner` variable,
    but instead, we’ll change the variable named after the value stored in `MyInner`.
    Very often, this is not what we want.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: CMake会执行变量扩展，直到完全展开，之后才会将得到的结果作为参数传递给命令。这就是为什么当我们调用`set(${MyInner} "Hi")`时；我们实际上不会改变`MyInner`变量，而是会修改一个以`MyInner`存储的值命名的变量。通常，这并不是我们想要的结果。
- en: 'Variable references are a bit peculiar in how they work when it comes to variable
    categories, but in general, the following applies:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 变量引用在处理变量类别时有些特别，但一般来说，以下内容适用：
- en: The `${}` syntax is used to reference *normal* or *cache* variables.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${}`语法用于引用*普通*或*缓存*变量。'
- en: The `$ENV{}` syntax is used to reference *environment* variables.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$ENV{}`语法用于引用*环境*变量。'
- en: The `$CACHE{}` syntax is used to reference *cache* variables.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$CACHE{}`语法用于引用*缓存*变量。'
- en: 'That’s right, with `${}`, you might get a value from one category or the other:
    the *normal* variable will be used if it was set in the current scope, but if
    it wasn’t set, or was unset, CMake will use the *cache* variable with the same
    name. If there’s no such variable, the reference evaluates to an empty string.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，通过`${}`，你可能从某个类别获取到一个值：如果在当前作用域内设置了*普通*变量，则会使用该变量；但如果没有设置，或者被取消设置，CMake将使用具有相同名称的*缓存*变量。如果没有这样的变量，引用将评估为空字符串。
- en: CMake predefines a lot of built-in normal variables that serve different purposes.
    For example, you can pass command-line arguments to scripts after the `--` token
    and they will be stored in the `CMAKE_ARGV<n>` variables (the `CMAKE_ARGC` variable
    will contain the count).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: CMake预定义了许多内置的普通变量，它们有不同的用途。例如，你可以在`--`标记之后将命令行参数传递给脚本，这些参数将被存储在`CMAKE_ARGV<n>`变量中（`CMAKE_ARGC`变量将包含计数）。
- en: Let’s introduce other categories of variables so that we understand clearly
    what they are.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍其他类别的变量，以便更清楚地理解它们是什么。
- en: Using environment variables
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用环境变量
- en: This is the least complicated kind of variable. CMake makes a copy of the variables
    that were in the environment used to start the `cmake` process and makes them
    available in a single, global scope. To reference these variables, use the `$ENV{<name>}`
    syntax.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的一种变量类型。CMake会复制用于启动`cmake`进程的环境中的变量，并将它们提供给单一的全局作用域。要引用这些变量，可以使用`$ENV{<name>}`语法。
- en: CMake changes these variables, but changes will only be made to a local copy
    in the running `cmake` process and not the actual system environment; moreover,
    these changes won’t be visible to subsequent runs of builds or tests, so it is
    not recommended.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: CMake会更改这些变量，但更改只会影响正在运行的`cmake`进程中的本地副本，而不会影响实际的系统环境；此外，这些更改不会对后续的构建或测试运行产生影响，因此不推荐这样做。
- en: 'Be aware that there are a few environment variables that affect different aspects
    of CMake behavior. For example, the `CXX` variable specifies what executable will
    be used for compiling C++ files. We’ll cover environment variables, as they will
    become relevant to this book. A full list is available in the documentation: [https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有一些环境变量会影响CMake行为的不同方面。例如，`CXX`变量指定了用于编译C++文件的可执行文件。我们将在本书中讲解环境变量，它们将变得非常相关。完整的列表可以在文档中找到：[https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-env-variables.7.html)。
- en: It’s important to realize that if you use `ENV` variables as arguments to your
    commands, the values will be interpolated during the generation of the buildsystem.
    This means that they will get permanently baked into the build tree, and changing
    the environment for the build stage won’t have any effect.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，如果你将`ENV`变量作为命令的参数，值将在生成构建系统时进行插值。这意味着它们将永久地嵌入到构建树中，改变构建阶段的环境将没有任何效果。
- en: 'For example, take the following project file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下项目文件：
- en: '**ch02/03-environment/CMakeLists.txt**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch02/03-environment/CMakeLists.txt**'
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding example has two steps: it will print the `myenv` environment
    variable during the configuration, and it will add a build stage through `add_custom_target()`,
    which echoes the same variable as part of the build process. We can test what
    happens with a bash script that uses one value for the configuration stage and
    another for the build stage:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子有两个步骤：它将在配置过程中打印`myenv`环境变量，并通过`add_custom_target()`添加一个构建阶段，该阶段在构建过程中回显相同的变量。我们可以用一个bash脚本来测试在配置阶段使用一个值、在构建阶段使用另一个值的效果：
- en: '**ch02/03-environment/build.sh**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch02/03-environment/build.sh**'
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running the preceding code clearly shows that the value set during the configuration
    is persisted to the generated buildsystem:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码清楚地显示，在配置过程中设置的值被保留到生成的构建系统中：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This concludes our discussion on environmental variables for the time being.
    Let us now move on to the final category of variables: cache variables.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们暂时对环境变量的讨论。现在让我们转向变量的最后一类：缓存变量。
- en: Using cache variables
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缓存变量
- en: We first mentioned cache variables when discussing command-line options for
    `cmake` in *Chapter 1*, *First Steps with CMake*. Essentially, they’re persistent
    variables stored in a `CMakeCache.txt` file in your build tree. They contain information
    gathered during the *configuration stage* of your project. They originate from
    the system (path to compilers, linkers, tools, and others) and from the user,
    provided through the GUI or from the command line with the `-D` option. Again,
    cache variables are not available in *scripts*; they only exist in *projects*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第 1 章*《CMake 初步应用》中讨论 `cmake` 命令行选项时首次提到了缓存变量。本质上，它们是存储在构建树中 `CMakeCache.txt`
    文件里的持久变量。它们包含在项目的*配置阶段*收集的信息。它们来源于系统（编译器、链接器、工具等的路径）和用户，通过 GUI 或通过命令行的 `-D` 选项提供。再强调一次，缓存变量在*脚本*中不可用；它们只存在于*项目*中。
- en: 'Cache variables will be used if the `${<name>}` reference can’t find a normal
    variable defined in the current scope but a cache variable with the same name
    exists. However, they can also be explicitly referenced with the `$CACHE{<name>}`
    syntax and defined with a special form of the `set()` command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `${<name>}` 引用在当前作用域内找不到普通变量，而存在同名的缓存变量，则将使用缓存变量。然而，它们也可以通过 `$CACHE{<name>}`
    语法显式引用，并通过 `set()` 命令的特殊形式进行定义：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In contrast to the `set()` command for *normal variables*, extra arguments
    are necessary for cache variables: `<type>` and `<docstring>`. This is because
    these variables can be configured by the user, and the GUI requires this information
    to display them appropriately.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与用于*普通变量*的 `set()` 命令不同，缓存变量需要额外的参数：`<type>` 和 `<docstring>`。这是因为这些变量可以由用户配置，GUI
    需要这些信息来适当地显示它们。
- en: 'The following *types* are accepted:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下*类型*是被接受的：
- en: '`BOOL`: A Boolean on/off value. The GUI will show a checkbox.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOL`：布尔值开/关。GUI 会显示一个复选框。'
- en: '`FILEPATH`: A path to a file on a disk. The GUI will open a file dialog.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILEPATH`：磁盘上文件的路径。GUI 将打开一个文件对话框。'
- en: '`PATH`: A path to a directory on a disk. The GUI will open a directory dialog.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATH`：磁盘上目录的路径。GUI 将打开一个目录对话框。'
- en: '`STRING`: A line of text. The GUI offers a text field to be filled. It can
    be replaced by a drop-down control by calling `set_property(CACHE <variable> STRINGS
    <values>)`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STRING`：一行文本。GUI 提供一个文本框供填写。通过调用 `set_property(CACHE <variable> STRINGS <values>)`，它可以被下拉框控件替代。'
- en: '`INTERNAL`: A line of text. The GUI skips internal entries. The internal entries
    may be used to store variables persistently across runs. Use of this type implicitly
    adds the `FORCE` keyword.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERNAL`：一行文本。GUI 会跳过内部条目。内部条目可用于在多次运行之间持久存储变量。使用此类型隐式添加了 `FORCE` 关键字。'
- en: The `<doctring>` value is simply a label that will be displayed by the GUI next
    to the field to provide more detail about this setting to the user. It is required
    even for an `INTERNAL` type.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`<docstring>` 值仅仅是一个标签，GUI 会在字段旁边显示它，以便为用户提供有关该设置的更多细节。即使是 `INTERNAL` 类型，也需要提供此信息。'
- en: 'Setting cache variables in the code follows the same rules as environmental
    variables to some extent – values are overwritten only for the current execution
    of CMake. However, if the variable doesn’t exist in the cache file or an optional
    `FORCE` argument is specified, the value will be persisted:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中设置缓存变量的规则在某种程度上与环境变量相同——值仅在当前的 CMake 执行中被覆盖。然而，如果变量在缓存文件中不存在，或者指定了可选的 `FORCE`
    参数，则该值将被持久保存：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Similar to C++, CMake supports *variable scopes*, albeit implemented in a rather
    specific way.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 C++，CMake 支持*变量作用域*，尽管它的实现方式比较特定。
- en: How to correctly use variable scopes in CMake
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在 CMake 中正确使用变量作用域
- en: '**Variable scope** is probably the strangest concept in the CMake language.
    This is maybe because we’re so accustomed to how it is implemented in general-purpose
    languages. We’re explaining this early because incorrect understanding of scopes
    is often a source of bugs that are difficult to find and fix.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量作用域** 可能是 CMake 语言中最奇怪的概念。这也许是因为我们习惯了在通用编程语言中实现变量作用域的方式。我们早期解释这个概念，是因为对作用域的错误理解通常是导致难以发现和修复的错误的根源。'
- en: Just to clarify, variable scope as a general concept is meant to separate different
    layers of abstraction expressed with code. Scopes are nested inside one another
    in a tree-like fashion. The outermost scope (root) is called the **global scope**.
    Any scope can be called the **local scope**, to indicate the currently executed
    or discussed scope. Scopes create boundaries between variables, so that the *nested
    scope* can access variables defined in the *outer scope*, but not the other way
    around.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，作为一个通用概念，变量作用域旨在通过代码表达不同层次的抽象。作用域以树形结构相互嵌套。最外层的作用域（根）被称为**全局作用域**。任何作用域都可以称为**局部作用域**，表示当前执行或讨论的作用域。作用域在变量之间创建了边界，使得*嵌套作用域*可以访问*外部作用域*中定义的变量，但反过来则不行。
- en: 'CMake has two kinds of variable scopes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 有两种变量作用域：
- en: '**File**: Used when blocks and custom functions are executed within a file'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件**：在文件内执行块和自定义函数时使用'
- en: '**Directory**: Used when the `add_subdirectory()` command is called to execute
    another `CMakeLists.txt` listfile in a nested directory'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**：当调用`add_subdirectory()`命令在嵌套目录中执行另一个`CMakeLists.txt`列表文件时使用'
- en: Conditional blocks, loop blocks, and macros don’t create separate scopes.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 条件块、循环块和宏不会创建独立的作用域。
- en: So, what’s so different about how a variable scope is implemented in CMake?
    When a *nested scope* is created, CMake simply fills it with copies of all the
    variables from the *outer scope*. Subsequent commands will affect these copies.
    But as soon as the execution of the *nested scope* is completed, all copies are
    deleted and the original variables from the *outer scope* are restored.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，CMake 中变量作用域的实现有什么不同呢？当创建一个*嵌套作用域*时，CMake 会简单地用*外部作用域*中的所有变量的副本填充它。后续命令将影响这些副本。但一旦*嵌套作用域*的执行完成，所有副本将被删除，*外部作用域*中的原始变量将被恢复。
- en: How the concept of scope works in CMake has interesting implications that aren’t
    that common in other languages. When executing in a nested scope, if you unset
    (`unset()`) a variable created in the *outer scope*, it will disappear, but only
    in the current *nested scope*, because the variable is a local copy. If you now
    reference this variable, CMake will determine that no such variable is defined,
    it will ignore the *outer scopes*, and continue searching through the cache variables
    (which are considered separate). That’s a possible gotcha.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 中作用域的概念有一些有趣的影响，这在其他语言中并不常见。在嵌套作用域中执行时，如果你取消设置（`unset()`）一个在*外部作用域*中创建的变量，它会消失，但仅在当前的*嵌套作用域*内，因为该变量是局部副本。如果你现在引用这个变量，CMake
    会认为没有定义这样的变量，它将忽略*外部作用域*，并继续在缓存变量中查找（这些被视为独立的）。这是一个可能的陷阱。
- en: '*File variable scopes* are opened using the `block()` and `function()` commands
    (but not `macro()`) and closed with the `endblock()` and `endfunction()` commands,
    respectively. We’ll cover functions in the *Command definitions* section of this
    chapter. For now, let’s see how variable scope works in practice with the simpler
    `block()` command (introduced in CMake 3.25).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件变量作用域*是通过`block()`和`function()`命令打开的（但不是`macro()`），并分别通过`endblock()`和`endfunction()`命令关闭。我们将在本章的*命令定义*部分讨论函数。现在，让我们看看如何通过更简单的`block()`命令（在
    CMake 3.25 中引入）来实际使用变量作用域。'
- en: 'Consider the following example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '**ch02/04-scope/scope.cmake**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch02/04-scope/scope.cmake**'
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We initially set the variable `V` to `1` in the *global scope*. After entering
    the outer and inner blocks, we immediately change them to `2` and `3`, respectively.
    We also print the variable upon entering and exiting each scope:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初将变量`V`设置为`1`，在*全局作用域*中。进入外部和内部块后，我们分别将它们改为`2`和`3`。我们还会在进入和退出每个作用域时打印变量：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As explained previously, as we enter each *nested scope*, the variable values
    are temporarily copied from the *outer scope* but their original values are restored
    upon exiting. This is reflected in the last two lines of the output.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当我们进入每个*嵌套作用域*时，变量值会从*外部作用域*临时复制，但在退出时会恢复其原始值。这反映在输出的最后两行中。
- en: 'The `block()` command can also propagate values to outer scopes (like C++ would
    do by default), but it has to be explicitly enabled with the `PROPAGATE` keyword.
    If we were to enable propagation for the inner block with `block(PROPAGATE V)`,
    the output would be as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`block()`命令还可以将值传播到外部作用域（就像 C++ 默认的行为一样），但必须通过`PROPAGATE`关键字显式启用。如果我们使用`block(PROPAGATE
    V)`来启用内部块的传播，输出将如下所示：'
- en: '[PRE21]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Again, we affected the scope of the outer block but not the global scope.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们只影响了外部块的作用域，而没有影响全局作用域。
- en: 'Another method for modifying a variable in the outer scope is to set the `PARENT_SCOPE`
    flag for the `set()` and `unset()` commands:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 修改外部作用域变量的另一种方法是为 `set()` 和 `unset()` 命令设置 `PARENT_SCOPE` 标志：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That workaround is a bit limited, as it doesn’t allow accessing variables more
    than one level up. Another thing worth noting is the fact that using `PARENT_SCOPE`
    doesn’t change variables in the current scope.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方法有些局限，因为它不允许访问比当前层级更高的变量。另一个值得注意的事实是，使用 `PARENT_SCOPE` 不会改变当前作用域中的变量。
- en: 'Now that we know how to handle basic variables, let’s take a look at one special
    case: since all variables are stored as strings, CMake has to take a more creative
    approach to more complex data structures such as *lists*.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何处理基本变量，让我们来看看一个特殊的情况：由于所有变量都以字符串形式存储，CMake 必须采取更有创意的方法来处理更复杂的数据结构，如*列表*。
- en: Using lists
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用列表
- en: 'To store a **list**, CMake concatenates all elements into a string, using a
    semicolon, `;`, as a delimiter: `a;list;of;5;elements`. You can escape a semicolon
    in an element with a backslash, like so: `a\;single\;element`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储一个**列表**，CMake 会将所有元素连接成一个字符串，使用分号 `;` 作为分隔符：`a;list;of;5;elements`。你可以通过反斜杠来转义分号，例如：`a\;single\;element`。
- en: 'To create a list, we can use the `set()` command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个列表，我们可以使用 `set()` 命令：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Because of how lists are stored, the following commands will have exactly the
    same effect:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表存储方式，以下命令将产生完全相同的效果：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'CMake automatically unpacks lists in unquoted arguments. By passing an unquoted
    `myList` reference, we effectively send more arguments to the command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 会在未加引号的参数中自动解包列表。通过传递一个未加引号的 `myList` 引用，我们实际上是向命令发送了更多的参数：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `message()` command will receive six arguments: “`the list is:`", “`a`",
    “`list`", “`of`", “`five`", and “`elements`". This may have unintended consequences,
    as the output will be printed without any additional spaces between the arguments:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`message()` 命令将接收六个参数：“`the list is:`”、"`a`"、"`list`"、"`of`"、"`five`" 和 "`elements`"。这可能会产生意外的后果，因为输出将没有额外的空格分隔每个参数：'
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, this is a very simple mechanism, and it should be used carefully.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这是一个非常简单的机制，应该谨慎使用。
- en: 'CMake offers a `list()` command that provides a multitude of subcommands to
    read, search, modify, and order lists. Here’s a short summary:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 提供了一个 `list()` 命令，提供了多种子命令来读取、搜索、修改和排序列表。以下是简短的总结：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Most of the time, we don’t really need to use lists in our projects. However,
    if you find yourself in that rare case where this concept would be convenient,
    you’ll find a more in-depth reference of the `list()` command in *Appendix*, *Miscellaneous
    Commands*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们在项目中并不需要使用列表。然而，如果你遇到那种少见的情况，列表概念会很方便，你可以在*附录*、*杂项命令*中找到 `list()` 命令的更深入参考。
- en: Now that we know how to work with lists and variables of all kinds, let’s shift
    our focus to controlling the execution flow and learn about control structures
    available in CMake.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何处理各种列表和变量，让我们把重点转移到控制执行流程，学习 CMake 中可用的控制结构。
- en: Understanding control structures in CMake
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 CMake 中的控制结构
- en: 'The CMake language wouldn’t be complete without **control structures**! Like
    everything else, they are provided in the form of a command, and they come in
    three categories: **conditional blocks**, **loops**, and **command definitions**.
    Control structures are executed in scripts and during buildsystem generation for
    projects.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 语言如果没有**控制结构**就不完整了！像其他所有功能一样，控制结构以命令的形式提供，分为三类：**条件块**、**循环**和**命令定义**。控制结构在脚本和项目的构建系统生成过程中执行。
- en: Conditional blocks
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件块
- en: 'The only conditional block supported in CMake is the humble `if()` command.
    All conditional blocks have to be closed with an `endif()` command, and they may
    have any number of `elseif()` commands and one optional `else()` command in this
    order:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 中唯一支持的条件块是简单的 `if()` 命令。所有条件块必须以 `endif()` 命令结束，并且可以包含任意数量的 `elseif()`
    命令和一个可选的 `else()` 命令，顺序如下：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As in many other imperative languages, the `if()`-`endif()` block controls
    which sets of commands will be executed:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如同许多其他命令式语言，`if()`-`endif()` 块控制哪些命令集合将被执行：
- en: If the `<condition>` expression specified in the `if()` command is met, the
    first section will be executed.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `if()` 命令中指定的 `<condition>` 表达式满足条件，第一部分将被执行。
- en: Otherwise, CMake will execute commands in the section belonging to the first
    `elseif()` command in this block that has met its condition.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，CMake 会在本块中满足条件的第一个 `elseif()` 命令所属的部分执行命令。
- en: If there are no such commands, CMake will check whether the `else()` command
    is provided and execute any commands in that section of the code.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有这样的命令，CMake会检查是否提供了`else()`命令，并执行该代码段中的任何命令。
- en: If none of the preceding conditions are met, the execution continues after the
    `endif()` command.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果前面的条件都不满足，执行将在`endif()`命令之后继续。
- en: Note that no local *variable scope* is created in any of the conditional blocks.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在任何条件块中都不会创建本地*变量作用域*。
- en: The provided `<condition>` expression is evaluated according to a very simple
    syntax – let’s learn more about it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的`<condition>`表达式根据非常简单的语法进行评估——让我们进一步了解它。
- en: The syntax for conditional commands
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件命令的语法
- en: The same syntax is valid for `if()`, `elseif()`, and `while()` commands.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的语法适用于`if()`，`elseif()`和`while()`命令。
- en: Logical operators
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'The `if()` conditions support the `NOT`, `AND`, and `OR` logical operators:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`if()`条件支持`NOT`，`AND`和`OR`逻辑运算符：'
- en: '`NOT <condition>`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOT <condition>`'
- en: '`<condition> AND <condition>`'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<condition> AND <condition>`'
- en: '`<condition> OR <condition>`'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<condition> OR <condition>`'
- en: 'Also, the nesting of conditions is possible with matching pairs of parentheses
    (`()`). As in all decent languages, the CMake language respects the order of evaluation
    and starts from the innermost parenthesis:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以使用匹配的括号对（`()`）来嵌套条件。像所有优秀的编程语言一样，CMake语言遵循评估顺序，从最内层的括号开始：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The evaluation of a string and a variable
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串和变量的评估
- en: 'For legacy reasons (because the variable reference (`${}`) syntax wasn’t always
    around), CMake will try to evaluate *unquoted arguments* as if they are *variable
    references*. In other words, using a plain variable name (for example, `QUX`)
    inside a condition is equal to writing `${QUX}`. Here’s an example for you to
    consider, and a gotcha:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 出于兼容性原因（因为变量引用（`${}`）语法并非一直存在），CMake会尝试将*未加引号的参数*评估为*变量引用*。换句话说，在条件中使用一个简单的变量名（例如`QUX`）等同于写`${QUX}`。这里有一个示例供你考虑，还有一个陷阱：
- en: '[PRE30]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `if()` condition works in a bit of a convoluted way here – first, it will
    evaluate `${QUX}` to `BAZ`, which is a recognized variable, and this in turn is
    evaluated to a string containing five characters spelling `FALSE`. Strings are
    considered *Boolean true* only if they equal any of the following constants (these
    comparisons are case-insensitive): `ON`, `Y`, `YES`, `TRUE`, or a *non-zero number*.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`if()`条件在这里有点复杂——首先，它会将`${QUX}`评估为`BAZ`，这是一个已识别的变量，然后它将被评估为一个包含五个字符的字符串`FALSE`。字符串只有在等于以下常量之一时才被视为*布尔真*（这些比较是不区分大小写的）：`ON`，`Y`，`YES`，`TRUE`，或者是一个*非零数字*。'
- en: This brings us to the conclusion that the condition in the preceding example
    will evaluate to *Boolean false*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们得出结论，前面示例中的条件将评估为*布尔假*。
- en: 'However, here’s another catch – what would be the evaluation of a condition
    with an unquoted argument with the name of a variable containing a value such
    as `BAR`? Consider the following code example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个陷阱——如果条件中有一个未加引号的参数，且该参数是一个包含值的变量名，例如`BAR`，会如何评估呢？考虑以下代码示例：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'According to what we have said so far, it would be `false`, as the `BAR` string
    doesn’t meet the criteria to evaluate to a *Boolean true* value. That’s unfortunately
    not the case, because CMake makes an exception when it comes to unquoted variable
    references. Unlike quoted arguments, `FOO` won’t be evaluated to `BAR` to produce
    an `if("BAR")` statement (which would be `false`). Instead, CMake will only evaluate
    `if(FOO)` to `false` if it is any of the following constants (these comparisons
    are case-insensitive):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们到目前为止所说的内容，它应该是`false`，因为`BAR`字符串不满足评估为*布尔真*值的条件。遗憾的是，并非如此，因为CMake在未加引号的变量引用时会做出例外处理。与加引号的参数不同，`FOO`不会被评估为`BAR`，从而生成`if("BAR")`语句（这将是`false`）。相反，只有当`FOO`等于以下常量之一时，CMake才会将`if(FOO)`评估为`false`（这些比较是不区分大小写的）：
- en: '`OFF`, `NO`, `FALSE`, `N`, `IGNORE`, or `NOTFOUND`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OFF`，`NO`，`FALSE`，`N`，`IGNORE`，或`NOTFOUND`'
- en: A string ending with `-NOTFOUND`
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`-NOTFOUND`结尾的字符串
- en: An empty string
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空字符串
- en: Zero
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零
- en: 'So, simply asking for an undefined variable will be evaluated to `false`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简单地请求一个未定义的变量将被评估为`false`：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When a variable is defined beforehand, the scenario changes and the condition
    evaluates to `true`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量在之前定义时，情况就会发生变化，条件评估为`true`：
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you think that the recursive evaluation of unquoted `if()` arguments is
    confusing, wrap variable references in quoted arguments: `if("${`CORGE`}")`. This
    will result in argument evaluation before the provided argument is passed into
    the `if()` command, and the behavior will be consistent with the evaluation of
    strings.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为递归求值未加引号的`if()`参数很令人困惑，可以将变量引用放在引号参数中：`if("${`CORGE`}")`。这会使得在将参数传递到`if()`命令之前，首先对参数进行求值，行为将与字符串求值一致。
- en: 'In other words, CMake assumes that the user passing a variable name to the
    `if()` command is asking whether the variable is defined with a value that does
    not evaluate to *Boolean false*. To explicitly check whether the variable is defined
    or not (and ignore its value), we can use the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，CMake 假定传递变量名给`if()`命令的用户是想检查该变量是否已定义且其值不等于*布尔假*。要明确检查变量是否已定义（忽略其值），我们可以使用以下方法：
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Comparing values
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 比较值
- en: 'Comparison operations are supported with the following operators:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 比较操作支持以下运算符：
- en: '`EQUAL`, `LESS`, `LESS_EQUAL`, `GREATER`, and `GREATER_EQUAL`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`EQUAL`、`LESS`、`LESS_EQUAL`、`GREATER`、`GREATER_EQUAL`'
- en: 'The usual comparison operators found in other languages do not work in CMake:
    `==`, `>`, `<`, `!=`, and so on.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 其他语言中常见的比较运算符在 CMake 中并不适用：`==`、`>`、`<`、`!=` 等等。
- en: 'They can be used to compare numeric values, like so:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以用来比较数值，例如：
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can compare software versions following the `major[.minor[.patch[.tweak]]]`
    format by adding a `VERSION_` prefix to any of the operators:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在任何运算符前添加`VERSION_`前缀来比较软件版本，格式为`major[.minor[.patch[.tweak]]]`：
- en: '[PRE36]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Omitted components are treated as zeros, and non-integer version components
    truncate the compared string at that point.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 被省略的组件会被视为零，且非整数版本组件会在该点截断比较的字符串。
- en: 'For *lexicographic* string comparisons, we need to prepend an operator with
    the `STR` prefix (note the lack of an underscore):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*字典序*字符串比较，我们需要在操作符前加上`STR`前缀（注意没有下划线）：
- en: '[PRE37]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We often need more advanced mechanisms than simple equality comparisons. Fortunately,
    CMake also supports **POSIX** **regex** matching (the CMake documentation hints
    at an **Extended Regular Expression** (**ERE**) flavor, but no support for specific
    regex character classes is mentioned). We can use the `MATCHES` operator as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常需要比简单的相等比较更高级的机制。幸运的是，CMake 还支持**POSIX** **正则表达式**匹配（CMake 文档提示支持**扩展正则表达式**（**ERE**）类型，但未提到支持特定的正则表达式字符类）。我们可以使用`MATCHES`运算符，如下所示：
- en: '[PRE38]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Any matched groups are captured in `CMAKE_MATCH_<n>` variables.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 任何匹配的组都会被捕获到`CMAKE_MATCH_<n>`变量中。
- en: Simple checks
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简单检查
- en: We already mentioned one simple check, `DEFINED`, but there are others that
    simply return `true` if a condition is met.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过一个简单的检查方法`DEFINED`，但还有其他方法，如果条件满足，直接返回`true`。
- en: 'We can check the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查以下内容：
- en: 'Whether a value is in a list: `<VARIABLE|STRING> IN_LIST <VARIABLE>`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判断一个值是否在列表中：`<VARIABLE|STRING> IN_LIST <VARIABLE>`
- en: 'Whether a command is available for invocation in this version of CMake: `COMMAND
    <command-name>`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判断在此版本的 CMake 中是否可以调用某个命令：`COMMAND <command-name>`
- en: 'Whether a CMake policy exists: `POLICY <policy-id>` (this is covered in *Chapter
    4*, *Setting Up Your First CMake Project* )'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判断是否存在 CMake 策略：`POLICY <policy-id>`（在*第4章*《设置你的第一个 CMake 项目》中讲解过）
- en: 'Whether a CTest test was added with `add_test()`: `TEST <test-name>`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判断 CTest 测试是否通过`add_test()`添加：`TEST <test-name>`
- en: 'Whether a build target is defined: `TARGET <target-name>`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 判断构建目标是否已定义：`TARGET <target-name>`
- en: We’ll explore build targets in *Chapter 5*, *Working with Targets*, but for
    now, let’s just say that targets are logical units of a build process in a project
    created with `add_executable()`, `add_library()`, or `add_custom_target()` commands.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第5章*《与目标一起工作》中深入探讨构建目标，但现在我们只需要知道，目标是通过`add_executable()`、`add_library()`或`add_custom_target()`命令创建的项目中的构建过程的逻辑单元。
- en: Examining the filesystem
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查文件系统
- en: 'CMake provides many ways of working with files. We rarely need to manipulate
    them directly, and normally, we’d rather use a high-level approach. For reference,
    this book will provide a short list of the file-related commands in the *Appendix*.
    But most often, only the following operators will be needed (behavior is well-defined
    only for absolute paths):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 提供了多种操作文件的方法。我们很少需要直接操作文件，通常我们更倾向于使用高层方法。作为参考，本书将在*附录*中提供一个与文件相关的命令简短列表。但通常情况下，只需要以下运算符（仅对绝对路径定义了明确的行为）：
- en: '`EXISTS <path-to-file-or-directory>`: Checks if a file or directory exists.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXISTS <path-to-file-or-directory>`：检查文件或目录是否存在。'
- en: This resolves symbolic links (it returns `true` if the target of the symbolic
    link exists).
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这会解析符号链接（如果符号链接的目标存在，它会返回 `true`）。
- en: '`<file1> IS_NEWER_THAN <file2>`: Checks which file is newer.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<file1> IS_NEWER_THAN <file2>`：检查哪个文件较新。'
- en: This returns `true` if `file1` is newer than (or equal to) `file2` or if one
    of the two files doesn’t exist.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `file1` 比 `file2` 更新（或两者相同），或者其中一个文件不存在，则返回 `true`。
- en: '`IS_DIRECTORY path-to-directory`: Checks if a path is a directory.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IS_DIRECTORY path-to-directory`：检查路径是否为目录。'
- en: '`IS_SYMLINK file-name`: Checks if a path is a symbolic link.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IS_SYMLINK file-name`：检查路径是否为符号链接。'
- en: '`IS_ABSOLUTE path`: Checks if a path is absolute.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IS_ABSOLUTE path`：检查路径是否为绝对路径。'
- en: 'Additionally, since 3.24 CMake supports a simple path comparison check, that
    will collapse multiple path separators but won’t do any other normalization:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从 3.24 版本开始，CMake 支持简单的路径比较检查，它会压缩多个路径分隔符，但不会进行其他规范化操作：
- en: '[PRE39]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For more advanced path manipulation, refer to the documentation on the `cmake_path()`
    command.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 若要进行更高级的路径操作，请参考 `cmake_path()` 命令的文档。
- en: This completes the syntax for conditional commands; the next control structure
    we’ll discuss is a loop.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了条件命令的语法；接下来我们将讨论的控制结构是循环。
- en: Loops
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'Loops in CMake are fairly straightforward – we can use either a `while()` loop
    or a `foreach()` loop to repeatedly execute the same set of commands. Both of
    these commands support loop control mechanisms:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 中的循环非常简单——我们可以使用 `while()` 循环或 `foreach()` 循环来反复执行相同的一组命令。这两个命令都支持循环控制机制：
- en: The `break()` loop stops the execution of the remaining block and breaks from
    the enclosing loop.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`break()` 循环会停止剩余代码块的执行，并跳出外部循环。'
- en: The `continue()` loop stops the execution of the current iteration and starts
    at the top of the next one.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`continue()` 循环会停止当前迭代的执行，并从下一次迭代的顶部重新开始。'
- en: Note that no local *variable scope* is created in any of the loop blocks.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任何循环块中都不会创建局部的 *变量作用域*。
- en: while()
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while()
- en: 'The loop block is opened with a `while()` command and closed with an `endwhile()`
    command. Any enclosed commands will be executed as long as the `<condition>` expression
    provided in `while()` is `true`. The syntax for phrasing the condition is the
    same as for the `if()` command:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 循环块通过 `while()` 命令打开，通过 `endwhile()` 命令关闭。只要在 `while()` 中提供的 `<condition>` 表达式为
    `true`，被包裹的命令就会被执行。条件语法与 `if()` 命令相同：
- en: '[PRE40]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You probably guessed that – with some additional variables – the `while` loop
    can replace a `for` loop. Actually, it’s way easier to use a `foreach()` loop
    for that – let’s take a look.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能猜到了——通过一些额外的变量——`while` 循环可以替代 `for` 循环。实际上，使用 `foreach()` 循环更为简单——让我们来看一下。
- en: foreach() loops
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: foreach() 循环
- en: 'There are several variations of the `foreach()` block, which execute the enclosed
    commands for each value in the given list. Like other blocks, it has opening and
    closing commands: `foreach()` and `endforeach()`.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach()` 块有多种变体，能够为给定列表中的每个值执行包裹的命令。像其他块一样，它有开启和关闭命令：`foreach()` 和 `endforeach()`。'
- en: 'The simplest form of `foreach()` is meant to provide a C++-style `for` loop:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach()` 的最简单形式旨在提供类似 C++ 风格的 `for` 循环：'
- en: '[PRE41]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'CMake will iterate from `0` to `<max>` (inclusive). If we need more control,
    we can use the second variant, providing `<min>`, `<max>`, and, optionally, `<step>`.
    All arguments must be non-negative integers, and `<min>` has to be smaller than
    `<max>`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 会从 `0` 迭代到 `<max>`（包括 `<max>`）。如果我们需要更多控制，可以使用第二种变体，提供 `<min>`、`<max>`，并且可以选择性地提供
    `<step>`。所有参数必须是非负整数，且 `<min>` 必须小于 `<max>`：
- en: '[PRE42]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'However, `foreach()` shows its true colors when it is working with lists:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`foreach()` 在处理列表时真正展现其强大功能：
- en: '[PRE43]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'CMake will retrieve elements from one or more specified `<lists>` list variables,
    as well as a list of `<items>` values defined in-line, and put them in `<loop
    variable>`. Then, it will execute all commands for each item in the list. You
    can choose to provide only lists, only values, or both:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 会从一个或多个指定的 `<lists>` 列表变量中，或者从内联定义的 `<items>` 值列表中获取元素，并将其放入 `<loop variable>`
    中。然后，它会为列表中的每个项执行所有命令。你可以选择仅提供列表、仅提供值，或者两者同时提供：
- en: '**ch02/06-loops/foreach.cmake**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch02/06-loops/foreach.cmake**'
- en: '[PRE44]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding code will print the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将输出以下内容：
- en: '[PRE45]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Or, we can use a short version (skipping the `IN` keyword) for the same result:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用简短的版本（跳过 `IN` 关键字）来实现相同的结果：
- en: '[PRE46]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Since version 3.17, `foreach()` has learned how to zip lists (`ZIP_LISTS`):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 3.17 起，`foreach()` 增强了对列表压缩的支持（`ZIP_LISTS`）：
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The process of zipping lists involves iterating through multiple lists and
    operating on corresponding items that have the same index. Let’s look at an example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩列表的过程涉及遍历多个列表，并对具有相同索引的对应项进行操作。让我们来看一个例子：
- en: '**ch02/06-loops/foreach.cmake**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch02/06-loops/foreach.cmake**'
- en: '[PRE48]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: CMake will create a `num_<N>` variable for each list provided, which it will
    fill with items from each list.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 会为每个提供的列表创建一个 `num_<N>` 变量，并用每个列表中的项填充它。
- en: 'You can pass multiple variable names (one for every list) and each list will
    use a separate variable to store its items:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以传递多个变量名（每个列表一个），每个列表将使用一个单独的变量来存储其项：
- en: '[PRE49]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Both examples on `ZIP_LISTS` will produce the same output:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`ZIP_LISTS` 中的两个示例将产生相同的输出：'
- en: '[PRE50]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the event that the item counts between lists vary, variables for the shorter
    lists will be empty.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表之间的项数不同，较短列表的变量将为空。
- en: It is worth noting that, as of version 3.21, the loop variables in `foreach()`
    are restricted to the local scope of the loop. This concludes our discussion on
    loops.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，从版本 3.21 起，`foreach()` 中的循环变量被限制在循环的局部作用域内。这结束了我们对循环的讨论。
- en: Command definitions
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令定义
- en: 'There are two ways to define your own command: you can use the `macro()` command
    or the `function()` command. The easiest way to explain the differences between
    these commands is by comparing them to *C-style preprocessor macros* and actual
    C++ functions:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以定义自己的命令：可以使用 `macro()` 命令或 `function()` 命令。解释这两个命令之间的区别最简单的方式是将它们与 *C
    风格的预处理器宏* 和实际的 C++ 函数进行比较：
- en: A `macro()` command works more like a find-and-replace instruction than an actual
    subroutine call such as `function()`. Contrary to functions, macros don’t create
    a separate entry on a call stack. This means that calling `return()` in a macro
    will return to the calling statement one level higher than it would for a function
    (possibly terminating the execution if we’re already in the top scope).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`macro()` 命令更像是一个查找替换指令，而不是像 `function()` 这样的实际子程序调用。与函数不同，宏不会在调用栈上创建单独的条目。这意味着在宏中调用
    `return()` 会返回到比函数更高一级的调用语句（如果我们已经在最顶层作用域，可能会终止执行）。'
- en: The `function()` command creates a *local scope* for its variables, unlike the
    `macro()` command, which works in the *variable scope* of the caller. This may
    lead to confusing results. Let’s talk about these details in the next section.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`function()` 命令为其变量创建 *局部作用域*，与 `macro()` 命令不同，后者在调用者的 *变量作用域* 中工作。这可能会导致混淆的结果。我们将在下一节讨论这些细节。'
- en: 'Both methods of defining commands allow the defining of named arguments that
    can be referred to in the local scope of the defined command. Moreover, CMake
    offers the following variables for accessing call-related values:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 定义命令的两种方法都允许定义可以在命令的局部作用域中引用的命名参数。此外，CMake 提供了以下变量用于访问与调用相关的值：
- en: '`${ARGC}`: The count of arguments'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ARGC}`：参数的数量'
- en: '`${ARGV}`: All arguments as list'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ARGV}`：所有参数作为列表'
- en: '`${ARGV<index>}`: The value of an argument at a specific index (starting from
    0), regardless of whether this argument was expected or not'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ARGV<index>}`：特定索引（从 0 开始）处的参数值，无论该参数是否为预期参数'
- en: '`${ARGN}`: A list of anonymous arguments that were passed by a caller after
    the last expected argument'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ARGN}`：由调用者在最后一个预期参数后传递的匿名参数列表'
- en: Accessing a numeric argument with an index outside of the `ARGC` bounds is an
    undefined behavior. To handle advanced scenarios (usually with an unknown number
    of arguments), you may be interested to read about `cmake_parse_arguments()` in
    the official documentation. If you decide to define a command with named arguments,
    every call has to pass all of them or it will be invalid.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 访问超出 `ARGC` 范围的数字参数是未定义行为。为了处理高级场景（通常是参数个数未知的情况），你可能会对官方文档中的 `cmake_parse_arguments()`
    感兴趣。如果你决定定义一个带命名参数的命令，那么每次调用必须传递所有参数，否则会无效。
- en: Macros
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 宏
- en: 'Defining a macro is similar to any other block:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 定义宏类似于定义任何其他块：
- en: '[PRE51]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: After this declaration, we may execute our macro by calling its name (function
    calls are case- insensitive).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在此声明之后，我们可以通过调用宏的名称来执行宏（函数调用不区分大小写）。
- en: 'As we know, macros don’t create a separate entry on a call stack or a *variable
    scope*. The following example highlights some of the problems relating to this
    behavior in macros:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，宏不会在调用栈上创建单独的条目或 *变量作用域*。以下示例突出了与宏行为相关的一些问题：
- en: '**ch02/08-definitions/macro.cmake**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch02/08-definitions/macro.cmake**'
- en: '[PRE52]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here’s the output from this script:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该脚本的输出：
- en: '[PRE53]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'What happened? Despite explicitly setting `myVar` to `new value`, it didn’t
    affect the output for `message("argument: ${myVar}")`! This is because arguments
    passed to macros aren’t treated as real variables but rather, as constant find-and-replace
    instructions.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '发生了什么？尽管我们明确地将 `myVar` 设置为 `new value`，但它没有影响 `message("argument: ${myVar}")`
    的输出！这是因为传递给宏的参数不会被当作真实的变量，而是当作常量查找并替换的指令。'
- en: On the other hand, the `myVar` variable in the global scope was changed from
    `first value` to `new value`. This behavior is a *side effect* and is considered
    a bad practice, as it’s impossible to tell which global variables will be changed
    by a macro without reading it. It is advisable to utilize functions whenever possible,
    as they are likely to prevent many issues.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`myVar` 变量在全局范围内从 `first value` 被更改为 `new value`。这种行为是一个 *副作用*，被认为是不好的实践，因为在不阅读宏的情况下，无法知道哪些全局变量会被更改。建议尽可能使用函数，因为它们能够避免许多问题。
- en: Functions
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: 'To declare a command as a function, follow this syntax:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 要将命令声明为函数，请遵循以下语法：
- en: '[PRE54]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: A function requires a name and optionally accepts a list of names of expected
    arguments. As mentioned before, functions create their own *variable scopes*.
    You can call `set()`, providing one of the named arguments of the function, and
    any change will be local to the function (unless `PARENT_SCOPE` is specified,
    as we discussed in the *How to correctly use variable scopes in CMake* section).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 函数需要一个名称，并可以选择性地接受一组期望的参数名称。如前所述，函数创建它们自己的 *变量作用域*。你可以调用 `set()`，提供函数的某个命名参数，任何更改都将仅在函数内有效（除非指定了
    `PARENT_SCOPE`，正如我们在 *如何正确使用 CMake 中的变量作用域* 部分讨论过的那样）。
- en: Functions follow the rules of the call stack, enabling returning to the calling
    scope with the `return()` command. Starting from CMake 3.25, the `return()` command
    allows an optional `PROPAGATE` keyword followed by a list of variable names. Its
    purpose is similar to the one in the `block()` command – it transfers the values
    of the specified variables from the *local scope* to the scope of the call.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 函数遵循调用栈规则，可以使用 `return()` 命令返回到调用范围。从 CMake 3.25 开始，`return()` 命令允许使用可选的 `PROPAGATE`
    关键字，后面跟着一个变量名列表。其目的是类似于 `block()` 命令 —— 将指定变量的值从 *局部范围* 传递到调用范围。
- en: 'CMake sets the following variables for each function (these have been available
    since version 3.17):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 为每个函数设置了以下变量（这些变量自版本 3.17 起可用）：
- en: '`CMAKE_CURRENT_FUNCTION`'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_FUNCTION`'
- en: '`CMAKE_CURRENT_FUNCTION_LIST_DIR`'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_FUNCTION_LIST_DIR`'
- en: '`CMAKE_CURRENT_FUNCTION_LIST_FILE`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_FUNCTION_LIST_FILE`'
- en: '`CMAKE_CURRENT_FUNCTION_LIST_LINE`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_FUNCTION_LIST_LINE`'
- en: 'Let’s take a look at these function variables in practice:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际看看这些函数变量：
- en: '**ch02/08-definitions/function.cmake**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch02/08-definitions/function.cmake**'
- en: '[PRE55]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Running this script with `cmake -P function.cmake` prints the following output:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `cmake -P function.cmake` 运行此脚本将打印以下输出：
- en: '[PRE56]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, the general syntax and concept of the functions are very similar
    to macros but less susceptible to implicit errors.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，函数的一般语法和概念与宏非常相似，但不容易出现隐式错误。
- en: The procedural paradigm in CMake
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CMake 中的过程式范式
- en: 'Let us suppose that we want to write CMake code similar to how we write a program
    in C++. We’ll make a `CMakeLists.txt` listfile that will call three defined commands
    that may call defined commands of their own. *Figure 2.3* illustrates that:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望编写类似于 C++ 程序风格的 CMake 代码。我们将创建一个 `CMakeLists.txt` 文件，调用三个已定义的命令，这些命令可能会调用它们自己定义的命令。*图
    2.3* 展示了这一点：
- en: '![](img/B19844_02_03.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_02_03.png)'
- en: 'Figure 2.3: A procedural call graph'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3：过程调用图
- en: 'In CMake, writing in a procedural style can be problematic since you must provide
    command definitions before calling them. The CMake parser will not have it any
    other way. Your code could look something like this:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CMake 中，采用过程式风格编程可能会遇到问题，因为你必须在调用命令之前提供命令定义。CMake 的解析器不会接受其他方式。你的代码可能看起来像这样：
- en: '[PRE57]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: What a nightmare! Everything is reversed! It will be very difficult to understand
    because the code with the lowest level of abstraction is at the beginning of the
    file. A correctly structured piece of code lists the most general steps in the
    first subroutine, after which it provides the slightly more detailed subroutines,
    and keeps the most detailed steps at the very end of the file.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 多么糟糕！一切都被颠倒了！因为最低抽象级别的代码出现在文件的开头，所以很难理解。正确结构化的代码应该在第一个子程序中列出最一般的步骤，然后提供稍微更详细的子程序，并将最详细的步骤放在文件的末尾。
- en: 'There are solutions to this problem, such as moving command definitions to
    other files and partitioning scopes across directories (scoped directories will
    be explained in detail in *Chapter 4*, *Setting Up Your First CMake Project* ).
    But there is also a simple and elegant approach – declaring an entry-point macro
    at the top of the file and calling it at the very end of the file:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有解决方案，比如将命令定义移到其他文件中，并在不同目录之间划分作用域（作用域目录将在*第4章*，*设置你的第一个CMake项目*中详细解释）。但也有一种简单而优雅的方法——在文件顶部声明一个入口点宏，并在文件末尾调用它：
- en: '[PRE58]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: With this approach, our code is written with a gradually narrowing scope, and
    because we’re not actually calling the `main()` macro until the very end, CMake
    won’t complain about the execution of undefined commands.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们的代码是按照逐渐缩小的范围编写的，并且由于我们实际上是在最后才调用`main()`宏，CMake不会因为执行未定义的命令而报错。
- en: Why use a macro over a function in this case? It’s good to have unrestricted
    access to global variables, and since we’re not passing any arguments to `main()`,
    we don’t need to worry about the usual caveats.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在这种情况下使用宏而不是函数？因为宏能够不受限制地访问全局变量，而且由于我们没有向`main()`传递任何参数，因此不需要担心通常的注意事项。
- en: You’ll find a simple example of this concept in the `ch02/09-procedural/CMakeLists.txt`
    listfile in the GitHub repository for this book.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书GitHub仓库的`ch02/09-procedural/CMakeLists.txt`列表文件中找到一个简单的示例。
- en: A word on naming conventions
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于命名约定的几点说明
- en: 'Naming is famously hard in software development, but nevertheless, it’s very
    important to maintain a solution that is easy to read and understand. When it
    comes to CMake scripts and projects, we should follow the rules of the *clean
    code* approach, as we would with any software development solution:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 命名在软件开发中一向被认为是难题，但尽管如此，保持易读易懂的解决方案仍然非常重要。对于CMake脚本和项目，我们应该像处理任何软件开发解决方案一样，遵循*清晰代码*的方法：
- en: Follow a consistent naming style (`snake_case` is an accepted standard in the
    CMake community).
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循一致的命名风格（`snake_case`是CMake社区公认的标准）。
- en: Use short but meaningful names (for example, avoid `func()`, `f()`, and similar).
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简短但有意义的名称（例如，避免使用`func()`、`f()`等类似名称）。
- en: Avoid puns and cleverness in your naming.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在命名中使用双关语或聪明的做法。
- en: Use pronounceable, searchable names that don’t require mental mapping.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可以发音、易于搜索且无需进行思维映射的名称。
- en: Now that we know how to properly invoke the commands with the correct syntax,
    let’s explore which commands will be the most beneficial to us to begin with.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何正确地使用正确的语法调用命令，让我们首先探索哪些命令对我们最有益。
- en: Exploring the frequently used commands
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索常用命令
- en: 'CMake offers many scripting commands that allow you to work with variables
    and the environment. Some of them have been extensively covered in the *Appendix*:
    for example, `list()`, `string()`, and `file()`. Others, such as `find_file()`,
    `find_package()`, and `find_path()`, fit better in chapters that talk about their
    respective subjects. In this section, we will provide a brief overview of the
    common commands that are useful in most situations:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了许多脚本命令，允许你处理变量和环境。部分命令在*附录*中有详细介绍，例如，`list()`、`string()`和`file()`。其他一些命令，如`find_file()`、`find_package()`和`find_path()`，更适合放在讨论它们各自主题的章节中。在本节中，我们将简要概述在大多数情况下都很有用的常见命令：
- en: '`message()`'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message()`'
- en: '`include()`'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include()`'
- en: '`include_guard()`'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include_guard()`'
- en: '`file()`'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file()`'
- en: '`execute_process()`'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute_process()`'
- en: Let’s get to it.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: The message() command
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: message()命令
- en: 'We already know and love our trusty `message()` command, which prints text
    to standard output. However, there’s a lot more to it than meets the eye. By providing
    a `MODE` argument, you can customize the behavior of the command like so: `message(<MODE>
    "text to print")`.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道并喜爱我们可靠的`message()`命令，它将文本打印到标准输出。但是，它的功能远不止表面那么简单。通过提供一个`MODE`参数，你可以像这样定制命令的行为：`message(<MODE>
    "要打印的文本")`。
- en: 'The recognized modes are as follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 识别的模式如下：
- en: '`FATAL_ERROR`: This stops processing and generation.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FATAL_ERROR`：这会停止处理和生成。'
- en: '`SEND_ERROR`: This continues processing but skips generation.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEND_ERROR`：这会继续处理，但跳过生成。'
- en: '`WARNING`: This continues processing.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WARNING`：这会继续处理。'
- en: '`AUTHOR_WARNING`: A CMake warning. This continues processing.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AUTHOR_WARNING`：一个CMake警告。此警告会继续处理。'
- en: '`DEPRECATION`: This works accordingly if either of the `CMAKE_ERROR_DEPRECATED`
    or `CMAKE_WARN_DEPRECATED` variables are enabled.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEPRECATION`：如果启用了`CMAKE_ERROR_DEPRECATED`或`CMAKE_WARN_DEPRECATED`变量，则此命令按相应方式工作。'
- en: '`NOTICE` or omitted mode (default): This prints a message to `stderr` to attract
    the user’s attention.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOTICE`或省略模式（默认）：这将向`stderr`打印一条信息，以引起用户的注意。'
- en: '`STATUS`: This continues processing and is recommended for main messages to
    users.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATUS`：这继续处理，推荐用于向用户传递主要信息。'
- en: '`VERBOSE`: This continues processing and should be used for more detailed information
    that usually isn’t very necessary.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VERBOSE`：这继续处理，通常用于包含更详细的信息，这些信息通常不太必要。'
- en: '`DEBUG`: This continues processing and should contain any fine details that
    might be helpful when there’s an issue with a project.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG`：这继续处理，并应包含在项目出现问题时可能有帮助的任何细节。'
- en: '`TRACE`: This continues processing and is recommended to print messages during
    project development. Usually, these sorts of messages would be removed before
    publishing the project.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRACE`：这继续处理，推荐在项目开发过程中打印消息。通常，这些类型的消息在发布项目之前会被删除。'
- en: 'Picking the right mode is extra work, but it can save debugging time by coloring
    the output text based on the severity (since 3.21) or even stop the execution
    after declaring an irrecoverable error:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的模式需要额外的工作，但通过根据严重性为输出文本着色（自3.21起）或在声明不可恢复错误后停止执行，它可以节省调试时间：
- en: '**ch02/10-useful/message_error.cmake**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch02/10-useful/message_error.cmake**'
- en: '[PRE59]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Messages will be printed depending on the current log level (which is `STATUS`
    by default). We discussed how to change this in the previous chapter in the *Options
    for debugging and tracing* section.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 消息将根据当前的日志级别进行打印（默认情况下是`STATUS`）。我们在上一章的*调试和追踪选项*部分讨论了如何更改这一点。
- en: 'In *Chapter 1*, *First Steps with CMake*, I mentioned debugging with `CMAKE_MESSAGE_CONTEXT`,
    and now it’s time to delve into it. In the meantime, we have gained insights into
    three crucial pieces of this subject: lists, scopes, and functions.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章*，*CMake的第一步*中，我提到了使用`CMAKE_MESSAGE_CONTEXT`进行调试，现在是时候深入研究它了。在此期间，我们已经深入了解了该主题的三个关键内容：列表、作用域和函数。
- en: 'In complex debugging scenarios, it can be extremely useful to indicate in which
    context the message is occurring. Consider the following output, where messages
    printed in the `foo` function have the appropriate prefix:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的调试场景中，指示消息发生在哪个上下文中可能非常有用。考虑以下输出，其中在`foo`函数中打印的消息具有适当的前缀：
- en: '[PRE60]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here’s how this works:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 其工作原理如下：
- en: '**ch02/10-useful/message_context.cmake**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch02/10-useful/message_context.cmake**'
- en: '[PRE61]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let’s break this down:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: First, we append the `top` to the context-tracking variable `CMAKE_MESSAGE_CONTEXT`,
    then we print the initial `` Before `foo` `` message, and the matching prefix
    `[top]` will be added to the output.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将`top`添加到上下文跟踪变量`CMAKE_MESSAGE_CONTEXT`中，然后我们打印初始的`` Before `foo` ``消息，并且匹配的前缀`[top]`将被添加到输出中。
- en: Next, upon entering the `foo()` function, we append a new context to the list
    named `foo` after the function it belongs to and output another message, which
    appears with the extended `[top.foo]` prefix in the output.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入`foo()`函数时，我们会在该函数所属的函数名后，将一个名为`foo`的新上下文添加到列表中，并输出另一条信息，该信息在输出中将以扩展的`[top.foo]`前缀出现。
- en: 'Finally, after function execution has completed, we print the `` After `foo`
    `` message. The message is printed with the original `[foo]` scope. Why? Because
    of the *variable scope* rules: the changed `CMAKE_MESSAGE_CONTEXT` variable only
    lives until the end of the function scope, and is then restored to the original
    unchanged version.'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在函数执行完成后，我们打印`` After `foo` ``消息。该消息将以原始的`[foo]`作用域打印。为什么？因为*变量作用域*规则：更改的`CMAKE_MESSAGE_CONTEXT`变量仅存在于函数作用域结束之前，然后会恢复为原始未更改的版本。
- en: 'Another cool trick with `message()` is to add indentation to the `CMAKE_MESSAGE_INDENT`
    list (in exactly the same way as with `CMAKE_MESSAGE_CONTEXT`):'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`message()`的另一个酷技巧是将缩进添加到`CMAKE_MESSAGE_INDENT`列表中（与`CMAKE_MESSAGE_CONTEXT`完全相同的方式）：
- en: '[PRE62]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output from our scripts can then look a bit simpler:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本的输出看起来可能更简单：
- en: '[PRE63]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Since CMake doesn’t offer any real debugger with breakpoints or other tools,
    the ability to produce clean log messages comes in very handy when things don’t
    go exactly as planned.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CMake没有提供任何真正的调试器或断点等工具，因此在事情没有按计划进行时，生成干净的日志消息的能力变得非常方便。
- en: The include() command
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: include()命令
- en: 'Partitioning code into different files to keep things ordered and, well, *separate*,
    is quite useful. Then, we can reference them from our parent listfile by calling
    `include()`, like so:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码分割到不同的文件中以保持秩序并且，嗯，*分开*，是非常有用的。然后，我们可以通过调用`include()`从父列表文件中引用它们，如下所示：
- en: '[PRE64]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If we provide a filename (a path with a `.cmake` extension), CMake will try
    to open and execute it.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供了一个文件名（即带有`.cmake`扩展名的路径），CMake会尝试打开并执行该文件。
- en: Note that no nested, separate *variable scope* will be created, so any changes
    to variables made in that file will affect the calling scope.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不会创建嵌套的独立*变量作用域*，因此在该文件中对变量的任何更改将影响调用作用域。
- en: CMake will raise an error if a file doesn’t exist unless we specify that it
    is optional with the `OPTIONAL` keyword. When we need to know whether `include()`
    was successful, we can provide a `RESULT_VARIABLE` keyword with the name of the
    variable. It will be filled with a full path to the included file on success or
    not found (`NOTFOUND`) on failure.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件不存在，CMake会报错，除非我们指定该文件是可选的，使用`OPTIONAL`关键字。当我们需要知道`include()`是否成功时，可以提供一个`RESULT_VARIABLE`关键字，并指定变量名。该变量将在成功时填充包含文件的完整路径，若失败则为未找到（`NOTFOUND`）。
- en: 'When running in script mode, any relative paths will be resolved from the current
    working directory. To force searching in relation to the script itself, provide
    an absolute path:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本模式下运行时，任何相对路径都会相对于当前工作目录进行解析。如果希望强制根据脚本本身进行查找，可以提供绝对路径：
- en: '[PRE65]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If we don’t provide a path but do provide the name of a module (without `.cmake`
    or otherwise), CMake will try to find a module and include it. CMake will search
    for a file with the name of `<module>.cmake` in `CMAKE_MODULE_PATH` and then in
    the CMake module directory.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有提供路径，但提供了模块名称（没有`.cmake`扩展名或其他后缀），CMake会尝试查找该模块并包含它。CMake会在`CMAKE_MODULE_PATH`中以及CMake模块目录中查找名为`<module>.cmake`的文件。
- en: 'As CMake walks the source tree and includes different listfiles, the following
    variables are set: `CMAKE_CURRENT_LIST_DIR`, `CMAKE_CURRENT_LIST_FILE`, `CMAKE_PARENT_LIST_FILE`,
    and `CMAKE_CURRENT_LIST_LINE`.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 当CMake遍历源树并包含不同的列表文件时，以下变量会被设置：`CMAKE_CURRENT_LIST_DIR`、`CMAKE_CURRENT_LIST_FILE`、`CMAKE_PARENT_LIST_FILE`和`CMAKE_CURRENT_LIST_LINE`。
- en: The include_guard() command
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`include_guard()`命令'
- en: When we include files that have side effects, we might want to restrict them
    so that they’re only included once. This is where `include_guard([DIRECTORY|GLOBAL])`
    comes in.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们包含具有副作用的文件时，我们可能希望限制它们只能被包含一次。这时，`include_guard([DIRECTORY|GLOBAL])`就派上用场了。
- en: Put `include_guard()` at the top of the included file. When CMake encounters
    it for the first time, it will make a note of this fact in the current scope.
    If the file gets included again (maybe because we don’t control all the files
    in our project), it won’t be processed any further.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 将`include_guard()`放在包含文件的顶部。当CMake第一次遇到它时，它会在当前作用域中记录这一事实。如果该文件再次被包含（可能因为我们无法控制项目中的所有文件），则不会再进行处理。
- en: If we want to protect against inclusion in unrelated function scopes that won’t
    share variables with each other, we should provide `DIRECTORY` or `GLOBAL` arguments.
    As the names suggest, the `DIRECTORY` keyword will apply the protection within
    the current directory and below it, and the `GLOBAL` keyword applies the protection
    to the whole build.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要防止在不相关的函数作用域中包含那些不会共享变量的文件，我们应该提供`DIRECTORY`或`GLOBAL`参数。正如名字所示，`DIRECTORY`关键字会在当前目录及其子目录中应用保护，而`GLOBAL`关键字则会将保护应用到整个构建中。
- en: The file() command
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`file()`命令'
- en: 'To give you an idea of what you can do with CMake scripts, let’s take a quick
    look at the most useful variants of the file manipulation command:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你了解如何使用CMake脚本，我们快速看看`file()`命令的一些常用变体：
- en: '[PRE66]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In short, the `file()` command will let you read, write, and transfer files
    and work with the filesystem, file locks, paths, and archives, all in a system-independent
    manner. Please see the *Appendix* for more details.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`file()`命令允许你读取、写入、传输文件，并且可以操作文件系统、文件锁、路径和归档，所有这些操作都是系统独立的。更多详情请参见*附录*。
- en: The execute_process() command
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`execute_process()`命令'
- en: 'Every now and then, you’ll need to resort to using tools available in the system
    (after all, CMake is primarily a buildsystem generator). CMake offers a command
    for this purpose: you can use `execute_process()` to run other processes and collect
    their output. This command is a great fit for scripts and it can also be used
    in projects, but it **only works during the configuration stage**. Here’s the
    general form of the command:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要使用系统中可用的工具（毕竟，CMake主要是一个构建系统生成器）。CMake为此提供了一个命令：你可以使用`execute_process()`来运行其他进程并收集它们的输出。这个命令非常适合用于脚本，也可以在项目中使用，但它**仅在配置阶段有效**。以下是该命令的一般格式：
- en: '[PRE67]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: CMake will use the API of the operating system to create a child process (so,
    shell operators such as `&&`, `||`, and `>` won’t work). However, you can still
    chain commands and pass the output of one to another simply by providing the `COMMAND
    <cmd> <arguments>` arguments more than once.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: CMake将使用操作系统的API创建一个子进程（因此，`&&`、`||`和`>`等shell操作符将无法使用）。但是，你仍然可以通过多次提供`COMMAND
    <cmd> <arguments>`参数来链式执行命令并将一个命令的输出传递给另一个命令。
- en: Optionally, you may use a `TIMEOUT <seconds>` argument to terminate the process
    if it hasn’t finished the task within the required limit, and you can set the
    `WORKING_DIRECTORY <directory>` as you need.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，你可以使用`TIMEOUT <seconds>`参数来终止任务，如果任务在规定时间内未完成，还可以根据需要设置`WORKING_DIRECTORY
    <directory>`。
- en: 'The exit codes of all tasks can be collected in a list by providing `RESULTS_VARIABLE
    <variable>` arguments. If you’re only interested in the result of the last executed
    command, use the singular form: `RESULT_VARIABLE <variable>`.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 所有任务的退出代码可以通过提供`RESULTS_VARIABLE <variable>`参数收集到一个列表中。如果你只对最后执行命令的结果感兴趣，可以使用单数形式：`RESULT_VARIABLE
    <variable>`。
- en: 'To collect the output, CMake provides two arguments: `OUTPUT_VARIABLE` and
    `ERROR_VARIABLE` (which are used in a similar fashion). If you would like to merge
    both `stdout` and `stderr`, use the same variable for both arguments.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 为了收集输出，CMake提供了两个参数：`OUTPUT_VARIABLE`和`ERROR_VARIABLE`（它们的使用方式相似）。如果你想合并`stdout`和`stderr`，可以对两个参数使用相同的变量。
- en: Remember that when writing projects for other users, you should make sure that
    the command you’re planning to use is available on the platforms you claim to
    support.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当为其他用户编写项目时，确保你计划使用的命令在你声称支持的平台上是可用的。
- en: Summary
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter opened the door to actual programming with CMake – you’re now able
    to write great, informative comments and utilize built-in commands, and you understand
    how to correctly provide all kinds of arguments to them. This knowledge alone
    will help you understand the unusual syntax of CMake listfiles that you might
    have seen in projects created by others. We have covered variables in CMake –
    specifically, how to reference, set, and unset *normal*, *cache*, and *environment
    variables*. We delved into how file and directory *variable scopes* work, how
    to create them, and what issues we might encounter and how to solve them. We also
    covered lists and control structures. We examined the syntax of conditions, their
    logical operations, the evaluation of unquoted arguments, as well as strings and
    variables. We learned how to compare values, do simple checks, and examine the
    state of the files in the system. This allows us to write conditional blocks and
    `while` loops; while we were talking about loops, we also grasped the syntax of
    `foreach` loops.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为CMake的实际编程打开了大门——你现在可以编写出色的、有信息量的注释，并利用内置命令，还理解了如何正确地为它们提供各种参数。仅凭这些知识，你就能理解你可能在其他人创建的项目中看到的CMake列表文件中的不寻常语法。我们已经涵盖了CMake中的变量——具体来说，如何引用、设置和取消设置*普通*、*缓存*和*环境变量*。我们深入探讨了文件和目录*变量作用域*的工作原理，如何创建它们，以及可能遇到的问题和解决方法。我们还涵盖了列表和控制结构。我们研究了条件语法、逻辑运算、无引号参数的评估，以及字符串和变量的操作。我们学习了如何比较值、进行简单检查并检查系统中文件的状态。这使我们能够编写条件块和`while`循环；在讨论循环时，我们也掌握了`foreach`循环的语法。
- en: Understanding how to define custom commands using macro and function statements
    will undoubtedly facilitate cleaner, more procedural code. We also discussed strategies
    for improving code structure and creating more readable names.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用宏和函数语句定义自定义命令无疑会帮助你写出更清晰、更具程序化的代码。我们还讨论了改善代码结构和创建更具可读性名称的策略。
- en: Finally, we formally introduced the `message()` command and its multiple log
    levels. We also studied how to partition and include listfiles, and we discovered
    a few other useful commands. With this information, we are well prepared to take
    on the next chapter, *Chapter 3*, *Using CMake in Popular IDEs*.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们正式介绍了`message()`命令及其多个日志级别。我们还学习了如何分区和包含列表文件，并发现了一些其他有用的命令。凭借这些信息，我们已经为迎接下一章，*第3章*，*在流行的IDE中使用CMake*，做好了充分准备。
- en: Further reading
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following links:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章涵盖的主题的更多信息，你可以参考以下链接：
- en: 'Clean Code: A Handbook of Agile Software Craftsmanship (Robert C. Martin):
    [https://amzn.to/3cm69DD](https://www.amazon.co.uk/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882?&linkCode=sl1&tag=smoku-21&linkId=2bce0992e1e138154bfec781f28805ce&language=en_GB&ref_=as_li_ss_tl)'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《代码整洁之道：敏捷软件开发的手册》（Robert C. Martin）：[https://amzn.to/3cm69DD](https://www.amazon.co.uk/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882?&linkCode=sl1&tag=smoku-21&linkId=2bce0992e1e138154bfec781f28805ce&language=en_GB&ref_=as_li_ss_tl)
- en: 'Refactoring: Improving the Design of Existing Code (Martin Fowler): [https://amzn.to/3cmWk8o](https://amzn.to/3cmWk8o)'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《重构：改善既有代码的设计》（Martin Fowler）：[https://amzn.to/3cmWk8o](https://amzn.to/3cmWk8o)
- en: 'Which comments in your code ARE GOOD? (Rafał Świdzinski): [https://youtu.be/4t9bpo0THb8](https://youtu.be/4t9bpo0THb8)'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你代码中的哪些注释是好的？（Rafał Świdzinski）：[https://youtu.be/4t9bpo0THb8](https://youtu.be/4t9bpo0THb8)
- en: 'What’s the CMake syntax to set and use variables? (StackOverflow): [https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables](https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables)'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置并使用变量的 CMake 语法是什么？（StackOverflow）：[https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables](https://stackoverflow.com/questions/31037882/whats-the-cmake-syntax-to-set-and-use-variables)
- en: Join our community on Discord
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区，加入 Discord 讨论群
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
- en: '![](img/QR_Code94081075213645359.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code94081075213645359.png)'
