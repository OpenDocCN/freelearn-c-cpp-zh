- en: '*Chapter 9*: Program Analysis Tools'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：程序分析工具
- en: Producing high-quality code is not an easy task, even for very experienced developers.
    By adding tests to our solution, we reduce the risk of making obvious mistakes
    in the business code. But that won't be enough to avoid more intricate problems.
    Every piece of software consists of so many details that keeping track of them
    all becomes a full-time job. There are dozens of conventions and multiple special
    design practices agreed upon by teams maintaining the product.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编写高质量代码并非易事，即使对于经验非常丰富的开发者也是如此。通过向我们的解决方案中添加测试，我们可以减少在业务代码中犯明显错误的风险。但这还不足以避免更复杂的问题。每一段软件都由如此多的细节组成，跟踪它们全部成为了一份全职工作。团队维护产品达成了数十种约定和多种特殊设计实践。
- en: 'Some questions relate to consistent coding style: should we use 80 or 120 columns
    in our code? Should we allow `std::bind` or commit to Lambda functions? Is it
    okay to use C-style arrays? Should small functions be defined in a single line?
    Should we insist on using `auto` always, or only when it increases readability?'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些问题涉及一致的编码风格：我们的代码应该使用80列还是120列？我们应该允许使用`std::bind`还是坚持使用Lambda函数？使用C风格数组可以吗？小函数是否应该定义在单行中？我们是否应该始终坚持使用`auto`，或者只在提高可读性时使用？
- en: 'Ideally, we also avoid any statements that are known to be incorrect in general:
    infinite loops, usage of identifiers reserved by a standard library, unintended
    loss of precision, redundant `if` statements, and anything else that isn''t considered
    a "best practice" (see the *Further reading* section for references).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们还应避免任何已知在一般情况下不正确的语句：无限循环、使用标准库保留的标识符、无意中失去精度、冗余的`if`语句，以及其他不被认为是“最佳实践”的内容（参见*进一步阅读*部分获取参考资料）。
- en: 'Another thing to look at is the modernization of code: as C++ evolves, it offers
    new features. It can be difficult to track all the places we can refactor to the
    latest standard. Additionally, manual effort costs time and introduces the risk
    of bugs, which can be considerable for a large code base.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 的另一件事是要关注代码现代化：随着C++的发展，它提供了新特性。跟踪我们可以重构以适应最新标准的所有地方可能会很困难。此外，人工努力需要时间并引入了引入bug的风险，对于大型代码库来说这是相当可观的。
- en: 'Finally, we should inspect how things work when they''re put into motion: executing
    the program and examining its memory. Is the memory freed properly after use?
    Do we access data that was initialized correctly? Or maybe the code tries to dereference
    some dangling pointers?'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该检查事物在运动时的表现：执行程序并检查其内存。内存在使用后是否被正确释放？我们是否正确地访问了初始化的数据？或者代码试图解引用一些悬空指针？
- en: Managing all these issues and questions by hand is inefficient and error-prone.
    Thankfully, we can employ automatic utilities to check and enforce rules, fix
    mistakes, and modernize code for us. It's time to discover tools for program analysis.
    Our code will be inspected on every build to ensure that it adheres to industry
    standards.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 手工管理所有这些问题和问题是不效率且容易出错的。幸运的是，我们可以使用自动工具来检查和强制执行规则、修复错误并现代化代码为我们。是时候发现程序分析工具了。我们的代码将在每次构建时进行检查，以确保其符合行业标准。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Enforcing the formatting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制格式化
- en: Using static checkers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态检查器
- en: Dynamic analysis with Valgrind
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Valgrind进行动态分析
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter09](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter09).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中存在的代码文件：[https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter09](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter09)。
- en: 'To build examples provided in this book always use recommended commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 构建本书中提供的示例时，请始终使用推荐的命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace placeholders <`build tree>` and `<source tree>` with appropriate
    paths. As a reminder: **build tree** is the path to target/output directory, **source
    tree** is the path at which your source code is located.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将占位符`<`build tree>`和`<source tree>`替换为适当的路径。作为提醒：**build tree**是目标/输出目录的路径，**source
    tree**是源代码所在的路径。
- en: Enforcing the formatting
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制格式化
- en: Professional developers generally follow rules. They say that senior developers
    know when to break one (as they can justify the need to). On the other hand, it
    is said that very senior developers don't break rules because it's a waste of
    time having to keep explaining their reasons to others. I say, pick your battles
    and focus on things that actually matter and have a tangible impact on the product.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 专业开发者通常遵循规则。他们认为高级开发者知道何时打破一条规则（因为他们可以证明需要这么做）。另一方面，有人说非常高级的开发者不打破规则，因为向他人解释理由是浪费时间。我说，选择你的战斗，专注于对产品有实际影响和实质性作用的事情。
- en: 'When it comes to coding style and formatting, programmers are presented with
    a myriad of choices: should we use tabs or spaces for indentation? If spaces,
    how many? What is the limit of characters in a column? How about in a file? Such
    choices don''t impact the behavior of the program in most cases, but they do generate
    a lot of noise and start lengthy discussions that don''t bring much value to a
    product.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到代码风格和格式化时，程序员面临着许多选择：我们应该使用制表符还是空格进行缩进？如果使用空格，是多少个？列字符数的限制是多少？文件呢？在大多数情况下，这些选择不会影响程序的行为，但它们确实会产生很多噪音，并引发长时间讨论，这些讨论对产品并没有太大价值。
- en: Some practices are commonly agreed upon, but most of the time, we're debating
    personal preference and anecdotal evidence. After all, enforcing 80 characters
    in a column over 120 is an arbitrary choice. It doesn't really matter what we're
    going to choose as long as we're consistent. Inconsistency in style is bad, as
    it affects an important aspect of the software – the readability of the code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有些实践是普遍认同的，但大多数时候，我们是在争论个人偏好和 anecdotal 证据。毕竟，将列中的字符数从120强制到80是一个任意选择。只要我们保持一致，我们选择什么并不重要。风格上的不一致是坏事，因为它影响软件的一个重要方面——代码的可读性。
- en: 'The best way to avoid it is to use a formatting tool such as `clang-format`.
    This can alert us that the code isn''t formatted properly and even fix things
    that stand out if we let it. Here''s an example of a command that formats code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种情况的最佳方式是使用格式化工具，如`clang-format`。这可以警告我们的代码格式不正确，甚至在我们允许的情况下修复突出显示的问题。以下是一个格式化代码的命令示例：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `-i` option tells ClangFormat to edit files in place. `--style` selects
    which supported formatting style should be used: `LLVM`, `Google`, `Chromium`,
    `Mozilla`, `WebKit`, or custom, provided from `file` (there are links to details
    in the *Further reading* section).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i`选项告诉ClangFormat就地编辑文件。`--style`选择应使用哪种支持的格式化样式：`LLVM`、`Google`、`Chromium`、`Mozilla`、`WebKit`或自定义，从`file`提供（在*进一步阅读*部分有详细信息的链接）。'
- en: 'Of course, we don''t want to execute this command manually every time we make
    a change; CMake should take care of this as part of the building process. We already
    know how to find `clang-format` in the system (we''ll need to install it manually
    beforehand). What we haven''t discussed yet is the process of applying an external
    tool to all of our source files. To do it, we''ll create a convenient function
    that can be included from the `cmake` directory:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不想每次修改后都手动执行这个命令；CMake应该在构建过程中处理这个问题。我们已经知道如何在系统中找到`clang-format`（我们之前需要手动安装它）。我们还没有讨论的是将外部工具应用于所有源文件的过程。为此，我们将创建一个方便的函数，可以从`cmake`目录中包含：
- en: chapter09/01-formatting/cmake/Format.cmake
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09/01-formatting/cmake/Format.cmake
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Format` function takes two arguments: `target` and `directory`. It will
    format all source files from `directory`, right before `target` is built.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Format`函数接受两个参数：`target`和`directory`。它将格式化来自`directory`的所有源文件，在构建`target`之前。'
- en: Technically, not all files in `directory` must necessarily belong to `target`
    (and target sources can potentially be in multiple directories). However, finding
    all the source files and headers that belong to the target (and possible dependent
    targets) is a very complex process, especially when we need to filter out headers
    that belong to external libraries and shouldn't be formatted. It's just more manageable
    to work on directories in this scenario. We can just call the function for each
    directory of the formatted target.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`directory`中的所有文件不一定都属于`target`（并且目标源代码可能位于多个目录中）。然而，找到所有属于目标（以及可能的依赖目标）的源文件和头文件是一个非常复杂的过程，尤其是当我们需要过滤掉属于外部库且不应该格式化的头文件时。在这种情况下，按目录工作更加可行。我们只需为每个格式化目标调用函数。
- en: 'This function has the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有以下几个步骤：
- en: Find the `clang-format` binary installed in the system. The `REQUIRED` keyword
    will stop the configuration with an error if the binary wasn't found.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找系统中安装的`clang-format`二进制文件。`REQUIRED`关键字将在找不到二进制文件时停止配置并显示错误。
- en: Create a list of file extensions to format (to be used as a *globbing expression*).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个要格式化的文件扩展名列表（用作*通配符表达式*）。
- en: Prepend each expression with a path to `directory`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个表达式前加上`directory`的路径。
- en: Recursively search for sources and headers (using the previously created list),
    skip directories, and put their paths into the `SOURCE_FILES` variable.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归搜索源文件和头文件（使用之前创建的列表），跳过目录，并将它们的路径放入`SOURCE_FILES`变量中。
- en: Hook the formatting command as the `PRE_BUILD` step of `target`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将格式化命令作为`target`的`PRE_BUILD`步骤。
- en: This command will work well for small-to-medium code bases. For high amounts
    of files, we'd need to transform absolute file paths to relative paths and execute
    formatting using `directory` as a working directory (the `list(TRANSFORM)` command
    is useful here). This might be necessary because commands passed to the shell
    have a limit on their length (usually about 13,000 characters) and too many long
    paths simply won't fit.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令对于小到中等大小的代码库来说效果很好。对于大量文件，我们需要将绝对文件路径转换为相对路径，并使用`directory`作为工作目录执行格式化（`list(TRANSFORM)`命令在这里很有用）。这可能是因为传递给shell的命令长度有限制（通常约为13,000个字符），而太多的长路径根本放不下。
- en: 'Let''s see how we can use this function in practice. We''ll use the following
    project structure:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在实际中使用这个函数。我们将使用以下项目结构：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, we''ll need to set up the project and add the `cmake` directory to the
    module path so that we can include it later:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置项目并将`cmake`目录添加到模块路径中，这样我们稍后才能包含它：
- en: chapter09/01-formatting/CMakeLists.txt
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第9章/01-格式化/CMakeLists.txt
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Having that set, let''s fill in the list file for the `src` directory:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好之后，让我们为`src`目录填写列表文件：
- en: chapter09/01-formatting/src/CMakeLists.txt
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第9章/01-格式化/src/CMakeLists.txt
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is simple and to the point. We have created an executable target `main`,
    included the `Format.cmake` module, and called the `Format()` function for the
    `main` target in the current directory (`src`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，直截了当。我们创建了一个名为`main`的可执行目标，包含了`Format.cmake`模块，并在当前目录（`src`）中调用了`Format()`函数。
- en: 'Now, we need some unformatted source files. The header is just a simple `unused`
    function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一些未格式化的源文件。头文件只是一个简单的`unused`函数：
- en: chapter09/01-formatting/src/header.h
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第9章/01-格式化/src/header.h
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''ll also add a source file with way too much whitespace:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会添加一个源文件，其中空格过多：
- en: chapter09/01-formatting/src/main.cpp
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第9章/01-格式化/src/main.cpp
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''re almost set. All that''s left is the configuration file of the formatter
    (which is enabled with the `--style=file` argument in the command line):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 万事俱备，只差格式化器的配置文件（可在命令行中使用`--style=file`参数启用）：
- en: chapter09/01-formatting/.clang-format
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第9章/01-格式化/.clang-format
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Clang Format will scan the parent directories for the `.clang-format` file,
    which specifies the exact formatting rules. This allows us to specify every little
    detail, or to customize one of the standards mentioned earlier. In my case, I''ve
    chosen to start with Google''s coding style and throw in a few tweaks: limit columns
    to 140 characters, remove tabs, and allow short loops, functions, and `if` statements.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Clang Format将扫描父目录中的`.clang-format`文件，该文件指定确切的格式化规则。这允许我们指定每一个小细节，或者定制前面提到的标准之一。在我的案例中，我选择从Google的编码风格开始，并加入一些调整：限制列数为140个字符，移除制表符，并允许短循环、函数和`if`语句。
- en: 'Let''s see how files have changed after building this project (formatting happens
    automatically before compilation):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看看在构建该项目后文件的变化情况（格式化会在编译前自动进行）：
- en: chapter09/01-formatting/src/header.h (formatted)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第9章/01-格式化/src/header.h（已格式化）
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The header file was formatted, even though it isn''t used by the target; short
    functions aren''t allowed on a single line. The formatter added new lines, just
    as expected. The `main.cpp` file also looks pretty slick now:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管目标没有使用头文件，但格式化器还是对其进行了格式化；不允许单行上有短函数。格式化器添加了新行，正如所期望的那样。`main.cpp`文件现在看起来也很酷：
- en: chapter09/01-formatting/src/main.cpp (formatted)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第9章/01-格式化/src/main.cpp（已格式化）
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Unnecessary whitespace was removed and indentations were standardized.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了不必要的空格，并将缩进标准化。
- en: Adding the automated formatter isn't too big of an effort and will save you
    a bunch of time in code reviews. If you've ever had to amend a commit to correct
    some whitespace, you know the feeling. Consistent formatting keeps your code neat
    without any effort.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 添加自动化格式化工具并不需要太多努力，而且在代码审查时节省你大量时间。如果你曾经不得不修改提交来修正一些空白字符，你就会明白这种感觉。一致的格式化让你的代码整洁而无需任何努力。
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Applying formatting to an existing code base will most likely introduce a big
    one-off change to the majority of the files in the repository. This may cause
    *a lot* of merge conflicts if you (or your teammates) have some ongoing work.
    It's best to coordinate such efforts to happen after all pending changes are done.
    If this isn't possible, consider gradual adoption, perhaps on a per-directory
    basis. Your fellow developers will thank you.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将格式化应用到现有代码库中很可能会对大多数仓库中的文件引入一次性的巨大变化。如果你（或你的团队成员）有一些正在进行的工作，这可能会导致大量的合并冲突。最好协调这样的努力，在所有待处理的变化完成后进行。如果这不可能，考虑逐步采用，也许按目录
    basis进行。你的同事们会感谢你的。
- en: The formatter is a great and simple tool to bring the visual aspect of the code
    together, but it isn't a fully fledged program analysis tool (it focuses mostly
    on whitespace). To deal with more advanced scenarios, we need to reach for utilities
    capable of understanding the program's source to perform a static analysis.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化器是一个伟大而简单的工具，可以统一代码的视觉方面，但它不是一个完全成熟的程序分析工具（它主要关注空白字符）。为了处理更高级的场景，我们需要使用能够理解程序源代码的工具来执行静态分析。
- en: Using static checkers
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态检查器
- en: 'Static program analysis is the process of checking the source code without
    actually running the compiled version. The rigorous application of static checkers
    dramatically improves the quality of the code: it becomes more consistent and
    less bug-prone. The chance of introducing known security vulnerabilities is reduced
    too. The C++ community has created dozens of static checkers: Astrée, Clang-Tidy,
    CLazy, CMetrics, Cppcheck, Cpplint, CQMetrics, ESBMC, FlawFinder, Flint, IKOS,
    Joern, PC-Lint, Scan-Build, Vera++, and so on.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 静态程序分析是检查源代码而不实际运行编译版本的过程。严格应用静态检查器显著提高了代码的质量：它变得更加一致，更少出现错误。引入已知的安全漏洞的机会也减少了。C++社区已经创建了数十个静态检查器：Astrée、Clang-Tidy、CLazy、CMetrics、Cppcheck、Cpplint、CQMetrics、ESBMC、FlawFinder、Flint、IKOS、Joern、PC-Lint、Scan-Build、Vera++等等。
- en: 'Many of them recognize CMake as the industry standard and will provide out-of-the-box
    support (or an integration tutorial). Some build engineers don''t want to go to
    the trouble of writing CMake code, and they add static checkers by including external
    modules available online, such as those collected by Lars Bilke in his GitHub
    repository: [https://github.com/bilke/cmake-modules](https://github.com/bilke/cmake-modules).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 许多它们认识CMake作为行业标准，并提供开箱即用的支持（或集成教程）。一些构建工程师不想费心写CMake代码，他们通过包含在线可用的外部模块来添加静态检查器，例如Lars
    Bilke在他的GitHub仓库中收集的那些：[https://github.com/bilke/cmake-modules](https://github.com/bilke/cmake-modules)。
- en: 'It''s no wonder, as the general misconception is that you''d need to jump through
    many hoops to get your code checked. The reason for this complexity is in the
    nature of static checkers: they often mimic the behavior of a real compiler to
    understand what happens in the code.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 难怪，因为普遍的误解是你需要跳过很多障碍才能让你的代码进行检查。造成这种复杂性的原因是静态检查器的本质：它们经常模仿真实编译器的行为来理解代码中发生的事情。
- en: 'Cppcheck recommends the following steps in its manual:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Cppcheck在其手册中推荐了以下步骤：
- en: Find the static checker's executable.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到静态检查器的可执行文件。
- en: 'Generate a *compile database* with the following:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方法生成*编译数据库*：
- en: '[PRE11]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the checker on the produced JSON file:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成的JSON文件上运行检查器：
- en: '[PRE12]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All that should happen as part of the build so that it doesn't get forgotten.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都应该作为构建过程的一部分发生，这样就不会被忘记了。
- en: 'Since CMake understands exactly how we want our targets built, can''t it support
    some of these utilities? At least the most popular? Sure, it can! This gem of
    a feature is hard to find among the online noise, despite being so simple to use.
    CMake supports enabling checkers on a per-target basis for the following tools:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CMake完全理解我们想要如何构建目标，它不能支持这些工具中的某些吗？至少是最受欢迎的那些？当然可以！这个珍贵的特性在网络噪声中很难找到，尽管它使用起来如此简单。CMake支持为以下工具启用检查器：
- en: include-what-you-use ([https://include-what-you-use.org](https://include-what-you-use.org))
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: include-what-you-use ([https://include-what-you-use.org](https://include-what-you-use.org))
- en: Clang-Tidy ([https://clang.llvm.org/extra/clang-tidy](https://clang.llvm.org/extra/clang-tidy))
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang-Tidy ([https://clang.llvm.org/extra/clang-tidy](https://clang.llvm.org/extra/clang-tidy))
- en: link what you use (a built-in CMake checker)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接你所使用的（内置的CMake检查器）
- en: cpplint ([https://github.com/cpplint/cpplint](https://github.com/cpplint/cpplint))
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cpplint ([https://github.com/cpplint/cpplint](https://github.com/cpplint/cpplint))
- en: Cppchecker ([https://cppcheck.sourceforge.io](https://cppcheck.sourceforge.io))
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cppchecker ([https://cppcheck.sourceforge.io](https://cppcheck.sourceforge.io))
- en: 'All we need to do is set an appropriate target property to a semicolon-separated
    list containing the path to the checker''s executable, followed by any command-line
    options that should be forwarded to the checker:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要做的是为适当的目标属性设置一个分号分隔的列表，该列表包含检查器可执行文件的路径，后跟任何应传递给检查器的命令行选项：
- en: '`<LANG>_CLANG_TIDY`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<LANG>_CLANG_TIDY`'
- en: '`<LANG>_CPPCHECK`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<LANG>_CPPCHECK`'
- en: '`<LANG>_CPPLINT`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<LANG>_CPPLINT`'
- en: '`<LANG>_INCLUDE_WHAT_YOU_USE`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<LANG>_INCLUDE_WHAT_YOU_USE`'
- en: '`LINK_WHAT_YOU_USE`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINK_WHAT_YOU_USE`'
- en: 'As usual, `<LANG>` should be replaced with the language used, so use `C` for
    C sources and `CXX` for C++. If you don''t need to control the checker on a per-target
    basis, you can specify a default value for all targets in the project by setting
    an appropriate global variable prefixed with `CMAKE_`, such as the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，`<LANG>`应该用所使用的语言替换，所以用`C`表示C源文件，用`CXX`表示C++。如果你不需要针对每个目标控制检查器，可以通过设置一个前缀为`CMAKE_`的适当的全局变量，为项目中的所有目标指定一个默认值，例如以下：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Any target defined after this statement will have its `CXX_CLANG_TIDY` property
    set the same way. Just keep in mind that this adds the analysis to regular builds,
    which will make them slightly longer.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在此声明之后定义的任何目标，其`CXX_CLANG_TIDY`属性将以此方式设置。只需记住，这将分析常规构建，使它们稍微变慢。
- en: 'On the other hand, there''s some value in more granular control of how targets
    should be tested by the checker. We can write a simple function to solve this
    for us:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，更细粒度地控制检查器如何测试目标有一定的价值。我们可以编写一个简单的函数来解决这个问题：
- en: chapter09/02-clang-tidy/cmake/ClangTidy.cmake
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09/02-clang-tidy/cmake/ClangTidy.cmake
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `AddClangTidy` function has two simple steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddClangTidy`函数有两个简单步骤：'
- en: Find the Clang-Tidy binary and store its path in `CLANG-TIDY_PATH`. The `REQUIRED`
    keyword will stop the configuration with an error if the binary wasn't found.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找Clang-Tidy二进制文件并将其路径存储在`CLANG-TIDY_PATH`中。`REQUIRED`关键字将在找不到二进制文件时停止配置并显示错误。
- en: Enable Clang-Tidy on `target`, provide the path to the binary and custom options
    to enable all checks, and treat warnings as errors.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`target`上启用Clang-Tidy，提供二进制文件的路径和自定义选项以启用所有检查，并将警告视为错误。
- en: 'To use this function, we just need to include the module and call it for the
    chosen target:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个函数，我们只需要包含模块并针对所选目标调用它：
- en: chapter09/02-clang-tidy/src/CMakeLists.txt
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09/02-clang-tidy/src/CMakeLists.txt
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is short and extremely powerful. As we build the solution, we can see
    the output from Clang-Tidy:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是简短且极其强大的。在我们构建解决方案时，我们可以看到Clang-Tidy的输出：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that unless you add the `--warnings-as-errors=*` option to the command-line
    arguments, the build will succeed. It is recommended to agree on a list of rules
    that will be enforced and fail builds that break them; this way, we'll prevent
    non-compliant code from tainting the repository.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除非你在命令行参数中添加了`--warnings-as-errors=*`选项，否则构建将会成功。建议达成一致，制定一个将强制执行并使违反它们的构建失败的规则列表；这样，我们可以防止不符合规定的代码污染仓库。
- en: '`clang-tidy` also offers an interesting `--fix` option, which will automatically
    correct your code where possible. This is definitely a great timesaver and can
    be used whenever you''re increasing the number of checks. As with formatting,
    be sure to avoid merge conflicts when introducing any changes generated by static
    analysis tools to legacy code bases.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`clang-tidy`还提供了一个有趣的`--fix`选项，它可以自动尽可能地修复你的代码。这绝对是节省时间的好方法，并且在增加检查数量时可以随时使用。与格式化一样，确保在将静态分析工具生成的任何更改引入遗留代码库时避免合并冲突。'
- en: Depending on your use case, the size of the repository, and team preferences,
    you should probably choose a few checkers that are a good match. Adding too many
    will become a nuisance. Here's a short introduction to checkers supported by CMake
    out-of-the-box.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的用例、仓库的大小和团队偏好，您可能需要选择几个与之一致的检查器。添加太多将变得令人烦恼。以下是CMake支持的一些检查器的简介。
- en: Clang-Tidy
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Clang-Tidy
- en: 'Here is a description of Clang-Tidy from the official website:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从官方网站对Clang-Tidy的描述：
- en: clang-tidy is a clang-based C++ "linter" tool. Its purpose is to provide an
    extensible framework for diagnosing and fixing typical programming errors, like
    style violations, interface misuse, or bugs that can be deduced via static analysis.
    clang-tidy is modular and provides a convenient interface for writing new checks.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: clang-tidy是基于Clang的C++“代码检查”工具。它的目的是提供一个可扩展的框架，用于诊断和修复常见的编程错误，如风格违规、接口误用，或通过静态分析可以推断出的错误。clang-tidy是模块化的，并为编写新检查提供了方便的接口。
- en: The versatility of this tool is really impressive, as it offers over 400 checks.
    It works well paired with ClangFormat, as the fixes applied automatically (over
    150 available) can follow the same format file. Offered checks include improvements
    in performance, readability, modernization, cpp-core-guidelines, and bug-prone
    namespaces.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具的多样性真的很令人印象深刻，因为它提供了超过400个检查项。它与ClangFormat配合得很好，因为自动应用的修复项（超过150个）可以遵循相同的格式文件。提供的检查项包括性能改进、可读性、现代化、cpp-core-guidelines和易出错命名空间等方面的改进。
- en: Cpplint
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cpplint
- en: 'Here is a description of Cpplint from the official website:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从官方网站对Cpplint的描述：
- en: Cpplint is a command-line tool to check C/C++ files for style issues following
    Google's C++ style guide. Cpplint is developed and maintained by Google Inc. at
    google/styleguide.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Cpplint是一个命令行工具，用于检查遵循Google C++风格指南的C/C++文件的风格问题。Cpplint是由Google公司在google/styleguide开发和维护的。
- en: This linter is meant to get your code in line with the aforementioned Google
    style. It is written in Python, which might be an unwanted dependency for some
    projects. The fixes are offered in formats consumable by Emacs, Eclipse, VS7,
    Junit, and as `sed` commands.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码检查工具旨在让您的代码符合上述的Google风格。它是用Python编写的，这可能会成为某些项目不愿依赖的库。提供的修复格式可以被Emacs、Eclipse、VS7、Junit以及作为`sed`命令的格式所消费。
- en: Cppcheck
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cppcheck
- en: 'Here is a description of Cppcheck from the official website:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从官方网站对Cppcheck的描述：
- en: Cppcheck is a static analysis tool for C/C++ code. It provides unique code analysis
    to detect bugs and focuses on detecting undefined behaviour and dangerous coding
    constructs. The goal is to have very few false positives. Cppcheck is designed
    to be able to analyze your C/C++ code even if it has non-standard syntax (common
    in embedded projects).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Cppcheck是一个用于C/C++代码的静态分析工具。它提供独特的代码分析来检测错误，并专注于检测未定义行为和危险编码结构。目标是尽量减少误报。Cppcheck旨在能够分析具有非标准语法（在嵌入式项目中很常见）的您的C/C++代码。
- en: This tool is worth recommending for peace of mind when it comes to avoiding
    unnecessary noise generated by false positives. It is quite well established (over
    14 years in the making) and still very actively maintained. Also, you might find
    it useful if your code doesn't compile with Clang.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具非常值得推荐，它能让您在使用时无忧无虑，避免由于误报而产生的不必要噪音。它已经相当成熟（已有14多年的历史），并且仍然维护得非常活跃。另外，如果你的代码不能与Clang编译，你可能会觉得它很有用。
- en: include-what-you-use
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含你使用的（include-what-you-use）
- en: 'Here is a description of include-what-you-use from the official website:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从官方网站对include-what-you-use的描述：
- en: 'The main goal of include-what-you-use is to remove superfluous #includes. It
    does this both by figuring out what #includes are not actually needed for this
    file (for both .cc and .h files), and replacing #includes with forward-declares
    when possible.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 包含你使用的的主要目标是去除不必要的#include。它通过找出实际不需要包含的#include（对于.cc和.h文件），并在可能的情况下用前向声明替换#include来实现这一点。
- en: Too many included headers might not seem like a really big problem if your code
    base is slim. In larger projects, time saved by avoiding unnecessary compilation
    of header files quickly adds up.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码库比较瘦，太多的包含头文件可能看起来并不是一个大问题。在更大的项目中，避免不必要的头文件编译节省的时间会迅速累积。
- en: Link what you use
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接你使用的（Link what you use）
- en: 'Here is a description of link-what-you-use on CMake''s blog:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是CMake博客上对link-what-you-use的描述：
- en: This is a built in CMake feature that uses options of ld and ldd to print out
    if executables link more libraries than they actually require.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个内置的CMake功能，使用ld和ldd的选项来输出如果可执行文件链接了比实际需要更多的库。
- en: This also speeds up the build time; only in this case we're focusing on the
    unneeded binary artifacts.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这也加快了构建时间；在这种情况下，我们关注的是不需要的二进制文件。
- en: Static analysis is critical where software errors can affect people's safety,
    especially in medical, nuclear, aviation, automotive, and machine industries.
    Smart developers know that it doesn't hurt to follow similar practices in less
    demanding environments, most of all when the costs of adoption are so low. Using
    static analyzers during the build is not only much cheaper than finding and fixing
    bugs manually; it's also easy to enable with CMake. I'd even go as far to say
    that there's almost no excuse to skip these checks in quality-sensitive software
    (that is, all software involving someone else other than the programmer).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析在软件错误可能影响人们安全的领域至关重要，尤其是在医疗、核能、航空、汽车和机械工业中。明智的开发者知道，在要求不高的环境中遵循类似实践并不会有什么坏处，尤其是在采用成本如此之低的情况下。在构建过程中使用静态分析器不仅比手动查找和修复错误便宜得多；而且通过
    CMake 很容易启用。我甚至可以说，在质量敏感的软件（即涉及除程序员以外的其他人的所有软件）中几乎没有任何理由跳过这些检查。
- en: Unfortunately, not all bugs can be caught before a program is executed. What
    can we do to get an even better insight into our projects?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并非所有错误都能在程序执行之前捕获。我们能做些什么来更深入地了解我们的项目呢？
- en: Dynamic analysis with Valgrind
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Valgrind 进行动态分析
- en: 'Valgrind ([https://www.valgrind.org](https://www.valgrind.org)) is an instrumentation
    framework that allows building dynamic analysis utilities – that is, analysis
    performed during a program''s runtime. It offers an extensive tool suite that
    allows all kinds of investigations and checks. Some of the tools are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind ([https://www.valgrind.org](https://www.valgrind.org)) 是一个允许构建动态分析工具的框架——即在程序运行时执行的分析。它提供了一个广泛的工具套件，允许进行各种调查和检查。其中一些工具如下：
- en: Memcheck – detects memory-management problems
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Memcheck – 检测内存管理问题
- en: Cachegrind – profiles CPU caches, and pinpoints cache misses and other cache
    issues
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cachegrind – 分析 CPU 缓存，并定位缓存缺失和其他缓存问题
- en: Callgrind – an extension of Cachegrind with extra information on call graphs
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Callgrind – Cachegrind 的扩展，带有关于调用图的额外信息
- en: Massif – a heap profiler that shows which parts of the program use heap over
    time
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Massif – 一种堆分析器，可以显示程序随时间使用堆的情况
- en: Helgrind – a thread debugger, which helps with data race issues
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helgrind – 线程调试器，有助于解决数据竞争问题
- en: DRD – a lighter, limited version of Helgrind
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DRD – Helgrind 的更轻量级、有限版本
- en: Every single tool from this list is extremely handy when the occasion is right.
    Most package managers know Valgrind and can install it on your OS with ease (it's
    possible that it's already installed if you're using Linux). In any case, the
    official website offers the source code, so you can build it yourself.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表中的每一个工具在适当的时候都非常方便。大多数包管理器都知道 Valgrind 并且可以轻松地在您的操作系统上安装它（如果您使用的是 Linux，可能已经安装了）。无论如何，官方网站提供了源代码，所以您可以自己构建它。
- en: We'll limit our focus to the most useful application from the suite. When people
    refer to Valgrind, they very often mean Valgrind's Memcheck. Let's figure out
    how to use it with CMake – it will pave the way for the adoption of other tools,
    should you need them.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点关注套件中最有用的应用程序。当人们提到 Valgrind 时，他们经常会指的是 Valgrind 的 Memcheck。让我们找出如何使用它与
    CMake 一起工作——这将为您需要它们时采用其他工具铺平道路。
- en: Memcheck
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Memcheck
- en: 'Memcheck can be indispensable when debugging memory issues. This subject is
    particularly tricky in C++, as programmers have tremendous control over how they
    manage memory. All kinds of mistakes are possible: reading unallocated memory,
    reading memory that was already freed, attempting to free memory more than once,
    and writing to incorrect addresses. Developers obviously try to avoid these, but
    since these bugs are so inconspicuous, they can sneak into even the simplest programs.
    Sometimes, all it takes is a forgotten variable initialization and we''re in a
    pinch.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Memcheck 在调试内存问题时可能不可或缺。在 C++ 中，这尤其棘手，因为程序员对自己如何管理内存有极大的控制权。可能出现各种错误：读取未分配的内存、读取已经释放的内存、尝试多次释放内存以及写入错误的地址。开发者显然试图避免这些错误，但由于这些错误如此微妙，它们甚至可以潜入最简单的程序中。有时，只需忘记一个变量的初始化，我们就陷入了困境。
- en: 'Invoking Memcheck looks like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 Memcheck 看起来像这样：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Memcheck is the default tool of Valgrind, but you can also select it explicitly:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Memcheck 是 Valgrind 的默认工具，但您也可以明确选择它：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running Memcheck is expensive; the manual (see the link in *Further reading*)
    says that programs instrumented with it can be 10–15 times slower. To avoid waiting
    for Valgrind every time we run tests, we''ll create a separate target that will
    be called from the command line whenever we need to test our code. Ideally, the
    developer will run it before merging their change to the default branch of the
    repository. This can be done with an early Git hook or added as a step in the
    CI pipeline. To build a custom target, we''ll use the following command after
    the generation stage has been completed:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Memcheck代价昂贵；手册（参见*进一步阅读*中的链接）说，用它 instrumented 的程序可以慢10-15倍。为了避免每次运行测试时都要等待Valgrind，我们将创建一个可以在需要测试代码时从命令行调用的独立目标。理想情况下，开发者会在将他们的更改合并到仓库的默认分支之前运行它。这可以通过早期Git钩子或添加为CI管道中的一个步骤来实现。在生成阶段完成后，我们将使用以下命令来构建自定义目标：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Adding such a target isn''t very difficult:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此类目标并不困难：
- en: chapter09/03-valgrind/cmake/Valgrind.cmake
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09/03-valgrind/cmake/Valgrind.cmake
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, we created a CMake module (so we can reuse the same file across
    projects) wrapping function that will accept the target to be tested. Two things
    happen here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个CMake模块（这样我们就可以在不同的项目中重复使用同一个文件）来包装接受要测试的目标的函数。这里发生两件事：
- en: CMake searches default system paths for the `valgrind` executable and stores
    it in the `VALGRIND_PATH` variable. The `REQUIRED` keyword will stop the configuration
    with an error if the binary wasn't found.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake会在默认的系统路径中搜索`valgrind`可执行文件，并将其存储在`VALGRIND_PATH`变量中。如果找不到二进制文件，`REQUIRED`关键字会导致配置出现错误而停止。
- en: A custom target, `valgrind`, is created; it will execute the Memcheck tool on
    the `target` binary. We also added an option to always check for memory leaks.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个自定义目标`valgrind`；它将在`target`二进制文件上执行Memcheck工具。我们还添加了一个选项，始终检查内存泄漏。
- en: 'When it comes to Valgrind options, we can provide them as command-line arguments
    and also in the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到Valgrind选项时，我们可以提供命令行参数，也可以如下进行：
- en: The `~/.valgrindrc` file (in your home directory)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`~/.valgrindrc`文件（在你的家目录中）'
- en: The `$VALGRIND_OPTS` environment variable
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$VALGRIND_OPTS`环境变量'
- en: The `./.valgrindrc` file (in the working directory)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`./.valgrindrc`文件（在工作目录中）'
- en: These are checked in that order. Also, note that the last file will only be
    considered if it belongs to the current user, is a regular file, and isn't marked
    as world-writable. This is a safety mechanism, as options given to Valgrind can
    be potentially harmful.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些按顺序进行检查。另外，请注意，最后一个文件只有在属于当前用户、是普通文件，并且没有被标记为世界可写时才会被考虑。这是一个安全机制，因为给Valgrind的选项可能是有害的。
- en: 'To use the `AddValgrind` function, we should provide it with a unit_tests target:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`AddValgrind`函数，我们应该向其提供一个unit_tests目标：
- en: chapter09/03-valgrind/test/CMakeLists.txt (fragment)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09/03-valgrind/test/CMakeLists.txt（片段）
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Remember that generating build trees with the `Debug` config allows Valgrind
    to tap into the debug information, which makes its output much clearer. Let''s
    see how this works in practice:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用`Debug`配置生成构建树可以让Valgrind访问调试信息，这使得它的输出更加清晰。让我们看看实际中这是如何工作的：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will build the `sut` and `unit_tests` targets:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这会构建`sut`和`unit_tests`目标：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Start the execution of Memcheck, which will provide us with general information:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Memcheck的执行，它将为我们提供一般信息：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `==954==` prefix contains the process ID. This is added to distinguish Valgrind
    commentary from the output of the tested process.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`==954==`前缀包含进程ID。这是为了区分Valgrind注释和被测试进程的输出而添加的。'
- en: 'Next, tests are run as usual with `gtest`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`gtest`进行常规测试：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At the end, a summary is presented:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，会呈现一个总结：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Uh-oh! We are still using at least 1 byte. Allocations made with `malloc()`
    and `new` aren''t matched with appropriate `free()` and `delete` operations. It
    seems we have a memory leak in our program. Valgrind provides more details to
    find it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们至少还在使用1个字节。使用`malloc()`和`new`进行的分配没有与适当的`free()`和`delete`操作相匹配。看来我们的程序中有一个内存泄漏。Valgrind提供了更多细节来找到它：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Lines starting with `by 0x<address>` indicate individual functions in a call
    stack. I''ve truncated the output (it had some noise from GTest) to focus on the
    interesting bit – the topmost function and source reference, `run()(run.cpp:6)`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以`by 0x<address>`开头的行表示调用栈中的个别函数。我已经截断了输出（它有一些来自GTest的噪音）以专注于有趣的部分——最顶层的函数和源引用，`run()(run.cpp:6)`：
- en: 'Finally, the summary is found at the bottom:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，总结在底部找到：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Valgrind does a very good job of finding very intricate issues. On occasion,
    it's capable of digging even deeper to find questionable situations that can't
    be categorized automatically. Such discoveries will be accounted for in the `possibly
    lost` row.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind非常擅长找到非常复杂的错误。偶尔，它甚至能够更深入地挖掘，找到不能自动分类的值得怀疑的情况。此类发现将在`可能丢失`行中予以说明。
- en: 'Let''s see what the issue found by Memcheck was in this case:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Memcheck在此案例中发现的问题是什么：
- en: chapter09/03-valgrind/src/run.cpp
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09/03-valgrind/src/run.cpp
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That''s right: the highlighted code is faulty. We do, in fact, create an object
    that isn''t deleted before the test ends. This is the exact reason why having
    extensive test coverage is so important.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 没错：高亮的代码是有错误的。事实上，我们确实创建了一个在测试结束前没有被删除的对象。这就是为什么拥有广泛测试覆盖度如此重要的原因。
- en: Valgrind is an extremely useful tool, but it can get a bit verbose when dealing
    with more complex programs. There must be a way to collect that information in
    a more manageable form.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind是一个非常实用的工具，但在处理更复杂的程序时可能会变得有些冗长。必须有一种方法以更易管理的形式收集这些信息。
- en: Memcheck-Cover
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Memcheck-Cover
- en: 'Commercial IDEs such as CLion natively support parsing Valgrind''s output to
    something that can be easily navigated through GUI without scrolling through the
    console window to find the right message. If your editor doesn''t have this option,
    you still can get a much clearer view of the errors by using a third-party report
    generator. Memcheck-cover, written by David Garcin, offers a nicer experience
    in the form of a generated HTML file, as shown in *Figure 9.1*:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 商业IDE，如CLion，原生支持解析Valgrind的输出，以便可以通过GUI轻松导航，而不必滚动控制台窗口以找到正确的消息。如果你的编辑器没有这个选项，你仍然可以通过使用第三方报告生成器获得更清晰的错误视图。由David
    Garcin编写的Memcheck-cover提供了一个更愉快的体验，以生成的HTML文件的形式，如图*9.1*所示：
- en: '![Figure 9.1 – A report generated by memcheck-cover'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 由memcheck-cover生成的报告'
- en: '](img/Figure_9.1_B17205.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B17205.jpg)'
- en: Figure 9.1 – A report generated by memcheck-cover
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 由memcheck-cover生成的报告
- en: 'This neat little project is available on GitHub ([https://github.com/Farigh/memcheck-cover](https://github.com/Farigh/memcheck-cover));
    it requires Valgrind and `gawk` (GNU AWK tool). To use it, we''ll prepare a setup
    function in a separate CMake module. It will consist of two parts:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小巧的项目在GitHub上可用（[https://github.com/Farigh/memcheck-cover](https://github.com/Farigh/memcheck-cover)）；它需要Valgrind和`gawk`（GNU
    AWK工具）。要使用它，我们将在一个单独的CMake模块中准备一个设置函数。它将由两部分组成：
- en: Fetching and configuring the tool
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和配置工具
- en: Adding a custom target that executes Valgrind and generates a report
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个自定义目标，执行Valgrind并生成报告
- en: 'The configuration looks as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 配置如下所示：
- en: chapter09/04-memcheck/cmake/Memcheck.cmake
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09/04-memcheck/cmake/Memcheck.cmake
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the first part, we follow the same practices as with a regular dependency:
    include the `FetchContent` module, and specify the project''s repository and desired
    Git tag with `FetchContent_Declare`. Next, we initiate the fetch process and configure
    the path to the binary using the `memcheck-cover_SOURCE_DIR` variable set by `FetchContent_Populate`
    (called implicitly by `FetchContent_MakeAvailable`).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，我们遵循与常规依赖项相同的实践：包含`FetchContent`模块，并在`FetchContent_Declare`中指定项目的存储库和所需的Git标签。接下来，我们启动获取过程，并使用由`FetchContent_Populate`设置的（由`FetchContent_MakeAvailable`隐式调用）`memcheck-cover_SOURCE_DIR`变量配置二进制文件的路径。
- en: 'The second part of the function is creating the target to generate reports.
    We''ll call it `memcheck` (so that it doesn''t overlap with the previous `valgrind`
    target if we want to keep both options for some reason):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第二部分是创建生成报告的目标。我们将其命名为`memcheck`（这样如果出于某种原因想要保留这两个选项，它就不会与之前的`valgrind`目标重叠）：
- en: chapter09/04-memcheck/cmake/Memcheck.cmake (continued)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09/04-memcheck/cmake/Memcheck.cmake（继续）
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This happens in two commands:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况发生在两个命令中：
- en: First, we'll run the `memcheck_runner.sh` wrapper script, which will execute
    Valgrind's Memcheck and collect the output to the file provided with the `-o`
    argument.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将运行`memcheck_runner.sh`包装脚本，该脚本将执行Valgrind的Memcheck并收集通过`-o`参数提供的文件输出的输出。
- en: Then, we'll parse the output and create the report with `generate_html_report.sh`.
    This script requires input and output directories provided with the `-i` and `-o`
    arguments.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将解析输出并使用`generate_html_report.sh`创建报告。这个脚本需要通过`-i`和`-o`参数提供的输入和输出目录。
- en: Both steps should be executed in the `CMAKE_BINARY_DIR` working directory so
    that the unit test binary can access files through relative paths if needed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤应该在`CMAKE_BINARY_DIR`工作目录中执行，以便如果需要，单元测试二进制可以通过相对路径访问文件。
- en: 'The last thing we need to add to our list files is, of course, a call to this
    function. It has the same pattern as `AddValgrind`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要在我们的列表文件中添加的最后一样东西，当然是调用这个函数的调用。它的模式和`AddValgrind`一样：
- en: chapter09/04-memcheck/test/CMakeLists.txt (fragment)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: chapter09/04-memcheck/test/CMakeLists.txt（片段）
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After generating a buildsystem with the `Debug` config, we can build the target
    with the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在用`Debug`配置生成构建系统后，我们可以用以下命令来构建目标：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: And then we can enjoy our formatted report. Well, to truly enjoy it we'll need
    to add that missing `delete c;` in `run.cpp` so that it stops complaining (or,
    better yet, use a smart pointer instead).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以享受我们的格式化报告。嗯，要真正享受它，我们还需要在`run.cpp`中添加那个缺失的`delete c;`，这样它就不会抱怨了（或者，更好的是，使用智能指针）。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: '"You''ll spend more time studying the code than creating it – therefore, you
    should optimize for reading rather than writing."'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: “你会在研究代码上花费的时间比在编写代码上多——因此，你应该优化阅读而不是编写。”
- en: This sentence is repeated like a mantra in more than one book discussing clean
    code practices. No wonder, as this is very true, as tested in practice by many
    software developers – so much so that rules for even minuscule things such as
    the numbers of spaces, newlines, and the ordering of `#import` statements have
    been codified. This isn't done out of pettiness, but to save time. By following
    the practices outlined in this chapter, we don't need to worry about formatting
    code correctly by hand. It will automatically get formatted as a side effect of
    building – a step that we have to do anyway to check whether the code is working
    correctly. By introducing ClangFormat, we can also ensure that it looks proper.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话在讨论整洁代码实践的书中被像咒语一样重复。难怪，因为这是非常正确的，很多软件开发者已经在实践中证明了这一点——以至于连像空格数、换行符以及`#import`声明的顺序这样的微小事情都有了规定。这并不是出于小气，而是为了节省时间。遵循本章概述的实践，我们无需担心手动格式化代码。它将自动在构建过程中作为副作用进行格式化——这是我们无论如何都必须执行的步骤，以检查代码是否正确运行。通过引入ClangFormat，我们还可以确保它看起来正确。
- en: 'Of course, we want more than a simple whitespace correction; code has to conform
    to dozens of other small regulations. This is done by the addition of Clang-Tidy
    and configuring it to enforce the coding style of our choosing. We discussed this
    static checker in detail, but we also mentioned other options: Cpplint, Cppcheck,
    Include-what-you-use, and Link-what-you-use. Since static linkers are relatively
    fast, we can add them to builds with little investment, and it will usually be
    well worth the price.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们想要的不仅仅是简单的空格修正；代码必须符合几十个其他的小规定。这是通过添加Clang-Tidy并配置它强制执行我们选择的编码风格来完成的。我们详细讨论了这道静态检查器，但我们也提到了其他选项：Cpplint，Cppcheck，Include-what-you-use和Link-what-you-use。由于静态链接器相对较快，我们可以少量投资将它们添加到构建中，这通常是非常值得的。
- en: 'Lastly, we looked at the Valgrind utilities, specifically Memcheck, which allows
    debugging problems related to memory management: incorrect reads, writes, deallocations,
    and so on. This is a very handy tool that can save hours of manual investigation
    and prevent bugs from sneaking into production. As mentioned, it can be a bit
    slow to execute, which is why we created a separate target to run it explicitly
    before submitting the code. We also learned how to present the output of Valgrind
    in a more approachable form with Memcheck-Cover, an HTML report generator. This
    can be really useful in environments that don''t support running an IDE (such
    as CI pipelines).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们查看了Valgrind工具，特别是Memcheck，它允许调试与内存管理相关的问题：不正确的读取、写入、释放等等。这是一个非常方便的工具，可以节省数小时的手动调查，并防止错误溜进生产环境。正如提到的，它的执行可能会慢一些，这就是我们创建一个单独的目标来显式地在提交代码之前运行它的原因。我们还学会了如何使用Memcheck-Cover（一个HTML报告生成器）以更易接受的形式呈现Valgrind的输出。这在支持运行IDE的环境中（如CI管道）可能非常有用。
- en: 'Of course, we aren''t limited to these tools; there''s plenty more: both free
    and open source projects, as well as commercial products coming with extensive
    support. This is merely an introduction to the subject. Be sure to explore what''s
    right for you. In the next chapter, we''ll take a closer look at documentation
    generation.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不仅限于这些工具；还有很多：既有自由和开源项目，也有带有广泛支持的商业产品。这只是对这个主题的介绍。确保探索对你来说正确的东西。在下一章，我们将更详细地查看文档生成。
- en: Further reading
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following links:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更多信息，你可以参考以下链接：
- en: '*C++ Core guidelines curated by Bjarne Stroustrup, author of C++:* [https://github.com/isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由C++创作者Bjarne Stroustrup整理的**C++核心指南：** [https://github.com/isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines)
- en: '*The ClangFormat reference:* [https://clang.llvm.org/docs/ClangFormat.html](https://clang.llvm.org/docs/ClangFormat.html)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClangFormat参考手册：** [https://clang.llvm.org/docs/ClangFormat.html](https://clang.llvm.org/docs/ClangFormat.html)'
- en: '*Static analyzers for C++ – a curated list:* [https://github.com/analysis-tools-dev/static-analysis#cpp](https://github.com/analysis-tools-dev/static-analysis#cpp)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C++静态分析器——精选列表：** [https://github.com/analysis-tools-dev/static-analysis#cpp](https://github.com/analysis-tools-dev/static-analysis#cpp)'
- en: '*Built-in static checker support in CMake:* [https://blog.kitware.com/static-checks-with-cmake-cdash-iwyu-clang-tidy-lwyu-cpplint-and-cppcheck/](https://blog.kitware.com/static-checks-with-cmake-cdash-iwyu-clang-tidy-lwyu-cpplint-and-cppcheck/)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMake中内置静态检查器的支持：** [https://blog.kitware.com/static-checks-with-cmake-cdash-iwyu-clang-tidy-lwyu-cpplint-and-cppcheck/](https://blog.kitware.com/static-checks-with-cmake-cdash-iwyu-clang-tidy-lwyu-cpplint-and-cppcheck/)'
- en: '*A target property enabling ClangTidy:* [https://cmake.org/cmake/help/latest/prop_tgt/LANG_CLANG_TIDY.html](https://cmake.org/cmake/help/latest/prop_tgt/LANG_CLANG_TIDY.html)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用ClangTidy的目标属性：** [https://cmake.org/cmake/help/latest/prop_tgt/LANG_CLANG_TIDY.html](https://cmake.org/cmake/help/latest/prop_tgt/LANG_CLANG_TIDY.html)'
- en: '*The Valgrind manual:* [https://www.valgrind.org/docs/manual/manual-core.html](https://www.valgrind.org/docs/manual/manual-core.html)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Valgrind手册：** [https://www.valgrind.org/docs/manual/manual-core.html](https://www.valgrind.org/docs/manual/manual-core.html)'
