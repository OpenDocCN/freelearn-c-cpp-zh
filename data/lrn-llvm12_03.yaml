- en: '*Chapter 2*: Touring the LLVM Source'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：LLVM源代码导览'
- en: 'The LLVM mono repository contains all the projects under the `llvm-project`
    root directory. All projects follow a common source layout. To use LLVM effectively,
    it is good to know what is available and where to find it. In this chapter, you
    will learn about the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM单一存储库包含`llvm-project`根目录下的所有项目。所有项目都遵循统一的源代码布局。要有效地使用LLVM，了解可用内容以及其位置是很重要的。在本章中，您将了解以下内容：
- en: The contents of the LLVM mono repository, covering the most important top-level
    projects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM单一存储库的内容，涵盖了最重要的顶级项目
- en: The layout of an LLVM project, showing the common source layout used by all
    projects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM项目的布局，展示了所有项目使用的通用源代码布局
- en: How to create your own projects using LLVM libraries, covering all the ways
    you can use LLVM in your own projects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用LLVM库创建自己的项目，涵盖了在自己的项目中使用LLVM的所有方式
- en: How to target a different CPU architecture, showing the steps required to cross-compile
    to another system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何针对不同的CPU架构，展示交叉编译到另一个系统所需的步骤
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for the chapter are available at [https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter02/tinylang](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter02/tinylang)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在[https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter02/tinylang](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter02/tinylang)找到
- en: You can find the code in action videos at [https://bit.ly/3nllhED](https://bit.ly/3nllhED)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://bit.ly/3nllhED](https://bit.ly/3nllhED)找到代码演示视频
- en: Contents of the LLVM mono repository
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLVM单一存储库的内容
- en: 'In [*Chapter 1*](B15647_01_ePub_RK.xhtml#_idTextAnchor015), *Installing LLVM*,
    you cloned the LLVM mono repository. This repository contains all LLVM top-level
    projects. They can be grouped as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B15647_01_ePub_RK.xhtml#_idTextAnchor015)中，*安装LLVM*，您克隆了LLVM单一存储库。该存储库包含所有LLVM顶级项目。它们可以分为以下几类：
- en: LLVM core libraries and additions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM核心库和附加内容
- en: Compilers and tools
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器和工具
- en: Runtime libraries
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时库
- en: In the next sections, we will take a closer look at these groups.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地了解这些组。
- en: LLVM core libraries and additions
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LLVM核心库和附加内容
- en: 'The LLVM core libraries are in the `llvm` directory. This project provides
    a set of libraries with optimizers and code generation for well-known CPUs. It
    also provides tools based on these libraries. The LLVM static compiler `llc` takes
    a file written in LLVM `llvm-objdump` and `llvm-dwarfdump` let you inspect object
    files, and those such as `llvm-ar` let you create an archive file from a set of
    object files. It also includes tools that help with the development of LLVM itself.
    For example, the `bugpoint` tool helps to find a minimal test case for a crash
    inside LLVM. `llvm-mc` is the machine code playground: this tool assembles and
    disassembles machine instructions and also outputs the encoding, which is a great
    help when adding new instructions.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM核心库位于`llvm`目录中。该项目提供了一组为知名CPU进行优化和代码生成的库。它还提供了基于这些库的工具。LLVM静态编译器`llc`接受LLVM
    `llvm-objdump`和`llvm-dwarfdump`文件，让您检查目标文件，以及像`llvm-ar`这样的工具让您从一组目标文件创建存档文件。它还包括帮助开发LLVM本身的工具。例如，`bugpoint`工具有助于找到LLVM内部崩溃的最小测试用例。`llvm-mc`是机器码播放器：该工具汇编和反汇编机器指令，并输出编码，这在添加新指令时非常有帮助。
- en: The LLVM core libraries are written in C++. Additionally, a C interface and
    bindings for Go, Ocaml, and Python are provided.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM核心库是用C++编写的。此外，还提供了C接口和Go、Ocaml和Python的绑定。
- en: The Polly project, located in the `polly` directory, adds another set of optimizations
    to LLVM. It is based on a mathematical representation called the **polyhedral
    model**. With this approach, complex optimizations such as loops optimized for
    cache locality are possible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 位于`polly`目录中的Polly项目为LLVM增加了另一组优化。它基于一种称为**多面体模型**的数学表示。采用这种方法，可以进行诸如为缓存局部性优化的循环等复杂优化。
- en: The `mlir` directory.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`mlir`目录。'
- en: Compilers and tools
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器和工具
- en: A complete C/C++/Objective-C/Object-C++ compiler named clang ([http://clang.llvm.org/](http://clang.llvm.org/))
    is part of the LLVM project. The source is located in the `clang` directory. It
    provides a set of libraries for lexing, parsing, semantic analysis, and generation
    of LLVM IR from C, C++, Objective-C, and Objective-C++ source files. The small
    tool `clang` is the compiler driver, based on these libraries. Another useful
    tool is `clang-format`, which can format C/C++ source files and source fragments
    according to rules provided by the user.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM项目中包含一个名为clang（[http://clang.llvm.org/](http://clang.llvm.org/)）的完整的C/C++/Objective-C/Object-C++编译器。源代码位于`clang`目录中。它提供了一组库，用于从C、C++、Objective-C和Objective-C++源文件中进行词法分析、语法分析、语义分析和生成LLVM
    IR。小工具`clang`是基于这些库的编译器驱动程序。另一个有用的工具是`clang-format`，它可以根据用户提供的规则格式化C/C++源文件和源代码片段。
- en: Clang aims to be compatible with GCC, the GNU C/C++ compiler, and CL, the Microsoft
    C/C++ compiler.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Clang旨在与GCC（GNU C/C++编译器）和CL（Microsoft C/C++编译器）兼容。
- en: Additional tools for C/C++ are provided by the `clang-tools-extra` project in
    the directory of the same name. Most notable here is `clang-tidy` which is a Lint
    style checker for C/C++. `clang-tidy` uses the clang libraries to parse the source
    code and checks the source with static analysis. The tool can catch more potential
    errors than the compiler, at the expense of more runtime.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`clang-tools-extra`项目提供了C/C++的其他工具，位于同名目录中。其中最值得注意的是`clang-tidy`，它是用于C/C++的Lint风格检查器。`clang-tidy`使用clang库解析源代码并进行静态分析。该工具可以捕获比编译器更多的潜在错误，但运行时开销更大。'
- en: Llgo is a compiler for the Go programming languages, located in the `llgo` directory.
    It is written in Go and uses the Go bindings from the LLVM core libraries to interface
    with LLVM. Llgo aims to be compatible with the reference compiler (https://golang.org/)
    but currently, the only supported target is 64-bit x86 Linux. The project seems
    unmaintained and may be removed in the future.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Llgo是Go编程语言的编译器，位于`llgo`目录中。它是用Go编写的，并使用LLVM核心库的Go绑定与LLVM进行接口。Llgo旨在与参考编译器（https://golang.org/）兼容，但目前唯一支持的目标是64位x86
    Linux。该项目似乎没有维护，并可能在将来被移除。
- en: The object files created by a compiler must be linked together with runtime
    libraries to form an executable. This is the job of `lld` ([http://lld.llvm.org/](http://lld.llvm.org/)),
    the LLVM linker that is located in the `lld` directory. The linker supports the
    ELF, COFF, Mach-O, and WebAssembly formats.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器创建的目标文件必须与运行时库链接在一起形成可执行文件。这是`lld`（[http://lld.llvm.org/](http://lld.llvm.org/)）的工作，LLVM链接器位于`lld`目录中。该链接器支持ELF、COFF、Mach-O和WebAssembly格式。
- en: No compiler toolset is complete without a debugger! The LLVM debugger is called
    `lldb` ([http://lldb.llvm.org/](http://lldb.llvm.org/)) and is located in the
    directory of the same name. The interface is similar to GDB, the GNU debugger,
    and the tool supports C, C++, and Objective-C out of the box. The debugger is
    extensible so support for other programming languages can be added easily.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 没有调试器的编译器工具集是不完整的！LLVM调试器称为`lldb`（[http://lldb.llvm.org/](http://lldb.llvm.org/)），位于同名目录中。其界面类似于GDB，GNU调试器，并且该工具可以直接支持C、C++和Objective-C。调试器是可扩展的，因此可以轻松添加对其他编程语言的支持。
- en: Runtime libraries
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时库
- en: 'In addition to a compiler, runtime libraries are required for complete programming
    language support. All the listed projects are located in the top-level directory
    in a directory of the same name:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编译器，完整的编程语言支持还需要运行时库。所有列出的项目都位于顶级目录中，与同名目录中的目录相同：
- en: The `compiler-rt` project provides programming language-independent support
    libraries. It includes generic functions, such as a 64-bit division for 32-bit
    i386, various sanitizers, the fuzzing library, and the profiling library.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compiler-rt`项目提供了与编程语言无关的支持库。它包括通用函数，例如32位i386的64位除法，各种消毒剂，模糊库和分析库。'
- en: The `libunwind` library provides helper functions for stack unwinding based
    on the DWARF standard. This is usually used for implementing exception handling
    of languages such as C++. The library is written in C and the functions are not
    tied to a specific exception handling model.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libunwind`库基于DWARF标准提供了用于堆栈展开的辅助函数。这通常用于实现诸如C++之类的语言的异常处理。该库是用C编写的，函数与特定的异常处理模型无关。'
- en: The `libcxxabi` library implements C++ exception handling on top of `libunwind`
    and provides the standard C++ functions for it.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libcxxabi`库在`libunwind`的基础上实现了C++异常处理，并为其提供了标准的C++函数。'
- en: Finally, `libcxx` is an implementation of the C++ standard library, including
    iostreams and STL. In addition, the `pstl` project provides a parallel version
    of the STL algorithm.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`libcxx`是C++标准库的实现，包括iostreams和STL。此外，`pstl`项目提供了STL算法的并行版本。
- en: '`libclc` is the runtime library for OpenCL. OpenCL is a standard for heterogeneous
    parallel computing and helps with moving computational tasks to graphics cards.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libclc`是OpenCL的运行时库。OpenCL是用于异构并行计算的标准，有助于将计算任务移动到图形卡上。'
- en: '`libc` aims to provide a complete C library. This project is still in its early
    stages.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libc`旨在提供完整的C库。该项目仍处于早期阶段。'
- en: Support for the OpenMP API is provided by the `openmp` project. OpenMP helps
    with multithreaded programming and can, for instance, parallelize loops based
    on annotations in the source.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openmp`项目提供了对OpenMP API的支持。OpenMP有助于多线程编程，并且可以根据源代码中的注释来并行化循环。'
- en: Even though this is a long list of projects, the good news is that all projects
    are structured similarly. We look at the general directory layout in the next
    section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个很长的项目列表，但好消息是所有项目的结构都类似。我们将在下一节中查看通用目录布局。
- en: Layout of an LLVM project
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLVM项目的布局
- en: All LLVM projects follow the same idea of directory layout. To understand the
    idea, let's compare LLVM with **GCC**, the **GNU Compiler Collection**. GCC has
    provided mature compilers for decades for almost every system you can imagine.
    But, except for the compilers, there are no tools that take advantage of the code.
    The reason is that it is not designed for reuse. This is different with LLVM.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有LLVM项目都遵循相同的目录布局理念。为了理解这个理念，让我们将LLVM与**GCC**，**GNU编译器集**进行比较。几十年来，GCC为几乎您能想象到的每个系统提供了成熟的编译器。但是，除了编译器，没有利用代码的工具。原因是它不是为重用而设计的。这与LLVM不同。
- en: Every functionality has a clearly defined API and is put in a library of its
    own. The clang project has (among others) a library to lex a C/C++ source file
    into a token stream. The parser library turns this token stream into an abstract
    syntax tree (also backed by a library). Semantic analysis, code generation, and
    even the compiler driver are provided as a library. The well-known `clang` tool
    is only a small application linked against these libraries.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个功能都有明确定义的API，并放在自己的库中。clang项目（除其他外）有一个库，用于将C/C++源文件词法分析为标记流。解析器库将此标记流转换为抽象语法树（也由库支持）。语义分析、代码生成甚至编译器驱动程序都作为库提供。著名的`clang`工具只是针对这些库链接的一个小应用程序。
- en: 'The advantage is obvious: when you want to build a tool that requires the **abstract
    syntax tree** (**AST**) of a C++ file, then you can reuse the functionality from
    these libraries to construct the AST. Semantic analysis and code generation are
    not required and you do not link against these libraries. This principle is followed
    by all LLVM projects, including the core libraries!'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 优势是显而易见的：当您想要构建一个需要C++文件的**抽象语法树**（**AST**）的工具时，您可以重用这些库的功能来构建AST。不需要语义分析和代码生成，也不需要链接到这些库。这个原则被所有LLVM项目遵循，包括核心库！
- en: Each project has a similar organization. Because CMake is used for build file
    generation, each project has a `CMakeLists.txt` file that describes the building
    of the projects. If additional CMake modules or support files are required, then
    they are stored in the `cmake` subdirectory, with modules placed in `cmake/modules`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都有类似的组织结构。因为CMake用于构建文件生成，每个项目都有一个`CMakeLists.txt`文件，描述了项目的构建过程。如果需要额外的CMake模块或支持文件，则它们存储在`cmake`子目录中，模块放置在`cmake/modules`中。
- en: Libraries and tools are mostly written in C++. Source files are placed under
    the `lib` directory and header files under the `include` directory. Because a
    project typically consists of several libraries, there are directories for each
    library in the `lib` directory. If necessary, this repeats. For example, inside
    the `llvm/lib` directory is the `Target` directory, which holds the code for the
    target-specific lowering. Besides some source files, there are again subdirectories
    for each target that are again compiled into libraries. Each of these directories
    has a `CMakeLists.txt` file that describes how to build the library and which
    subdirectories also contain source.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 库和工具大多是用C++编写的。源文件放在`lib`目录下，头文件放在`include`目录下。因为一个项目通常由多个库组成，在`lib`目录中为每个库都有一个目录。如果需要，这个过程会重复。例如，在`llvm/lib`目录中有`Target`目录，其中包含特定目标的降低代码。除了一些源文件外，每个目标都有一个子目录，这些子目录再次编译成库。每个目录都有一个`CMakeLists.txt`文件，描述了如何构建库以及哪些子目录还包含源代码。
- en: The `include` directory has an additional level. To make the names of the include
    files unique, the path name includes the project name, which is the first subdirectory
    under `include`. Only in this folder is the structure from the `lib` directory
    repeated.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`include`目录有一个额外的级别。为了使包含文件的名称唯一，路径名包括项目名称，这是`include`下的第一个子目录。只有在这个文件夹中，才会重复来自`lib`目录的结构。'
- en: The source of applications is inside the `tools` and `utils` directories. In
    the `utils` directory are internal applications that are used during compilation
    or testing. They are usually not part of a user installation. The `tools` directory
    contains applications for the end user. In both directories, each application
    has its own subdirectory. As with the `lib` directory, each subdirectory that
    contains source has a `CMakeLists.txt` file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的源代码位于`tools`和`utils`目录中。`utils`目录中是在编译或测试期间使用的内部应用程序。它们通常不是用户安装的一部分。`tools`目录包含面向最终用户的应用程序。在这两个目录中，每个应用程序都有自己的子目录。与`lib`目录一样，每个包含源代码的子目录都有一个`CMakeLists.txt`文件。
- en: Correct code generation is a *must* for a compiler. This can only be achieved
    with a good test suite. The `unittest` directory contains unit tests that use
    the *Google Test* framework. This is mainly used for single functions and isolated
    functionality that can't be tested otherwise. In the `test` directory are the
    LIT tests. These tests use the `llvm-lit` utility to execute tests. `llvm-lit`
    scans a file for shell commands and executes them. The file contains the source
    code used as input for the test, for example, LLVM IR. Embedded in the file are
    commands to compile it, executed by `llvm-lit`. The output of this step is then
    verified, often with the help of the `FileCheck` utility. This utility reads check
    statements from one file and matches them against another file. The LIT tests
    themselves are in subdirectories under the `test` directory, loosely following
    the structure of the `lib` directory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的代码生成对于编译器是*必不可少*的。这只能通过一个良好的测试套件来实现。`unittest`目录包含使用*Google Test*框架的单元测试。这主要用于单个函数和无法以其他方式进行测试的独立功能。`test`目录中是LIT测试。这些测试使用`llvm-lit`实用程序来执行测试。`llvm-lit`扫描文件以执行shell命令。文件包含用作测试输入的源代码，例如LLVM
    IR。文件中嵌入了由`llvm-lit`执行的编译命令。然后验证此步骤的输出，通常借助`FileCheck`实用程序的帮助。这个实用程序从一个文件中读取检查语句，并将它们与另一个文件进行匹配。LIT测试本身位于`test`目录下的子目录中，大致遵循`lib`目录的结构。
- en: Documentation (usually as `docs` directory. If a project provides examples,
    they are in the `examples` directory.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 文档（通常作为`docs`目录。如果项目提供示例，则它们在`examples`目录中。
- en: Depending on the needs of the project, there can be other directories too. Most
    notably, some projects that provide runtime libraries place the source code in
    a `src` directory and use the `lib` directory for library export definitions.
    The compiler-rt and libclc projects contain architecture-dependent code. This
    is always placed in a subdirectory named after the target architecture (for example,
    `i386` or `ptx`).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据项目的需求，也可以有其他目录。最值得注意的是，一些提供运行时库的项目将源代码放在`src`目录中，并使用`lib`目录进行库导出定义。compiler-rt和libclc项目包含与体系结构相关的代码。这总是放在以目标体系结构命名的子目录中（例如`i386`或`ptx`）。
- en: 'In summary, the general layout of a project that provides a sample library
    and has a driver tool looks like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，提供示例库并具有驱动程序工具的项目的一般布局如下：
- en: '![Figure 2.1 – General project directory layout'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1-一般项目目录布局'
- en: '](img/B15647_02_01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15647_02_01.jpg)'
- en: Figure 2.1 – General project directory layout
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1-一般项目目录布局
- en: Our own project will follow this organization, too.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自己的项目也将遵循这种组织结构。
- en: Creating your own project using LLVM libraries
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LLVM库创建您自己的项目
- en: Based on the information in the previous section, you can now create your own
    project using LLVM libraries. The following sections introduce a small language
    called `tinylang`. Here the structure for such a project is defined. Even though
    the tool in this section is only a **Hello, world** application, its structure
    has all the parts required for a real-world compiler.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前一节的信息，现在可以使用LLVM库创建自己的项目。以下部分介绍了一个名为`tinylang`的小语言。在这里定义了这样一个项目的结构。尽管本节中的工具只是一个**Hello,
    world**应用程序，但其结构具有实现真实编译器所需的所有部分。
- en: Creating the directory structure
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建目录结构
- en: The first question is if the `tinylang` project should be built together with
    LLVM (like clang), or if it should be a standalone project that just uses the
    LLVM libraries. In the former case, it is also necessary to decide where to create
    the project.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是是否应该将`tinylang`项目与LLVM一起构建（如clang），还是应该是一个独立的项目，只是使用LLVM库。在前一种情况下，还需要决定在哪里创建项目。
- en: Let's first assume that `tinylang` should be built together with LLVM. There
    are different options for where to place the project. The first solution is to
    create a subdirectory for the project inside the `llvm-projects` directory. All
    projects in this directory are picked up and built as part of building LLVM. Before
    the side-by-side project layout was created, this the standard way to build, for
    example, clang.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先假设`tinylang`应与LLVM一起构建。有不同的选项可供放置项目。第一个解决方案是在`llvm-projects`目录内创建项目的子目录。此目录中的所有项目都将作为构建LLVM的一部分进行捕获和构建。在创建并排项目布局之前，这是构建例如clang的标准方式。
- en: A second option is to place the `tinylang` project in the top-level directory.
    Because it is not an official LLVM project, the CMake script does not know about
    it. When running `cmake`, you need to specify `–DLLVM_ENABLE_PROJECTS=tinylang`
    to include the project in the build.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是将`tinylang`项目放在顶级目录中。因为它不是官方的LLVM项目，所以CMake脚本不知道它。在运行`cmake`时，您需要指定`–DLLVM_ENABLE_PROJECTS=tinylang`以将项目包含在构建中。
- en: And the third option is to place the project directory somewhere else, outside
    the `llvm-project` directory. Of course, you need to tell CMake about this location.
    If the location is `/src/tinylang`, for example, then you need to specify `–DLLVM_ENABLE_PROJECTS=tinylang
    –DLLVM_EXTERNAL_TINYLANG_SOURCE_DIR=/src/tinylang`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项是将项目目录放在`llvm-project`目录之外的其他位置。当然，您需要告诉CMake这个位置。例如，如果位置是`/src/tinylang`，则需要指定`–DLLVM_ENABLE_PROJECTS=tinylang
    –DLLVM_EXTERNAL_TINYLANG_SOURCE_DIR=/src/tinylang`。
- en: If you want to build the project as a standalone project, then it needs to find
    the LLVM libraries. This is done in the `CMakeLists.txt` file, which is discussed
    later in this section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将项目构建为独立项目，则需要找到LLVM库。这是在稍后讨论的`CMakeLists.txt`文件中完成的。
- en: After learning about the possible options, which one is the best? Making your
    project part of the LLVM source tree is a bit inflexible because of the size.
    As long as you don't aim to add your project to the list of top-level projects,
    I recommend using a separate directory. You can maintain your project on GitHub
    or similar services without worrying about how to sync with the LLVM project.
    And as shown previously, you can still build it together with the other LLVM projects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解可能的选项之后，哪一个是最好的？将您的项目作为LLVM源树的一部分是有点不灵活的，因为大小。只要您不打算将项目添加到顶级项目列表中，我建议使用单独的目录。您可以在GitHub或类似服务上维护您的项目，而不必担心如何与LLVM项目同步。并且如前所示，您仍然可以与其他LLVM项目一起构建。
- en: 'Let''s create a project with a very simple library and application. The first
    step is to create the directory layout. Choose a location that''s convenient for
    you. In the following steps, I assume it is in the same directory in which you
    cloned the `llvm-project` directory. Create the following directories with `mkdir`
    (Unix) or `md` (Windows):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个非常简单的库和应用程序的项目。第一步是创建目录布局。选择一个对您方便的位置。在接下来的步骤中，我假设它与您克隆`llvm-project`目录的相同目录中。使用`mkdir`（Unix）或`md`（Windows）创建以下目录：
- en: '![Figure 2.2 – Required directories for the project'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2- 项目所需的目录'
- en: '](img/B15647_02_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15647_02_02.jpg)'
- en: Figure 2.2 – Required directories for the project
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2- 项目所需的目录
- en: Next, we will place the build description and source files in these directories.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在这些目录中放置构建描述和源文件。
- en: Adding the CMake files
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加CMake文件
- en: 'You should recognize the basic structure from the last section. Inside the
    `tinylang` directory, create a file called `CMakeLists.txt` with the following
    steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该从上一节中认识到基本结构。在`tinylang`目录中，创建一个名为`CMakeLists.txt`的文件，并执行以下步骤：
- en: 'The file starts by calling `cmake_minimum_required()` to declare the minimal
    required version of CMake. It is the same version as in [*Chapter 1*](B15647_01_ePub_RK.xhtml#_idTextAnchor015),
    *Installing LLVM*:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件开始时调用`cmake_minimum_required()`来声明所需的CMake的最小版本。这与[*第1章*](B15647_01_ePub_RK.xhtml#_idTextAnchor015)中的版本相同，*安装LLVM*：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The next statement is `if()`. If the condition is true, then the project is
    built standalone, and some additional setup is required. The condition uses two
    variables, `CMAKE_SOURCE_DIR` and `CMAKE_CURRENT_SOURCE_DIR`. The `CMAKE_SOURCE_DIR`
    variable is the top-level source directory that is given on the `cmake` command
    line. As we saw in the discussion about the directory layout, each directory with
    source files has a `CMakeLists.txt` file. The directory of the `CMakeLists.txt`
    file that CMake currently processes is recorded in the `CMAKE_CURRENT_SOURCE_DIR`
    variable. If both variables have the same string value, then the project is built
    standalone. Otherwise, `CMAKE_SOURCE_DIR` would be the `llvm` directory:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个语句是`if()`。如果条件为真，则将构建项目，并且需要一些额外的设置。条件使用两个变量，`CMAKE_SOURCE_DIR`和`CMAKE_CURRENT_SOURCE_DIR`。`CMAKE_SOURCE_DIR`变量是在`cmake`命令行上给出的顶层源目录。正如我们在关于目录布局的讨论中看到的，每个具有源文件的目录都有一个`CMakeLists.txt`文件。CMake当前处理的`CMakeLists.txt`文件的目录记录在`CMAKE_CURRENT_SOURCE_DIR`变量中。如果两个变量具有相同的字符串值，则将构建项目。否则，`CMAKE_SOURCE_DIR`将是`llvm`目录：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The standalone setup is straightforward. Each CMake project needs a name. Here,
    we set it to `Tinylang`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 独立设置很简单。每个CMake项目都需要一个名称。在这里，我们将其设置为`Tinylang`：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The LLVM package is searched and the found LLVM directory is added to the CMake
    module path:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLVM软件包已被搜索，找到的LLVM目录被添加到CMake模块路径中：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, three additional CMake modules provided by LLVM are included. The first
    is only needed when Visual Studio is used as the build compiler and sets the correct
    runtime library to link again. The other two modules add the macros used by LLVM
    and configure the build based on the provided options:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，包含了LLVM提供的另外三个CMake模块。第一个仅在使用Visual Studio作为构建编译器时需要，并设置正确的运行时库以进行链接。另外两个模块添加了LLVM使用的宏，并根据提供的选项配置了构建：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, the path of the header files from LLVM is added to the include search
    path. Two directories are added. The `include` directory from the build directory
    is added because auto-generated files are saved here. The other `include` directory
    is the one inside the source directory:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，LLVM的头文件路径被添加到包含搜索路径中。添加了两个目录。从构建目录中添加了`include`目录，因为自动生成的文件保存在这里。另一个`include`目录是源目录内的目录：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With `link_directories()`, the path of the LLVM libraries is added for the
    linker:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`link_directories()`，将LLVM库的路径添加到链接器中：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As a last step, a flag is set to denote that the project is built standalone:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，设置一个标志以表示项目是独立构建的：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now follows the common setup. The `cmake/modules` directory is added to the
    CMake modules search path. This allows us to later add our own CMake modules:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在进行常见的设置。将`cmake/modules`目录添加到CMake模块搜索路径中。这样可以稍后添加我们自己的CMake模块：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we check whether the user is performing an out-of-tree build. Like LLVM,
    we require that the user uses a separate directory for building the project:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查用户是否正在进行外部构建。与LLVM一样，我们要求用户为构建项目使用单独的目录：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The version number of `tinylang` is written to a generated file with the `configure_file()`command.
    The version number is taken from the `TINYLANG_VERSION_STRING` variable. The `configure_file()`
    command reads an input file, replaces CMake variables with their current value,
    and writes an output file. Please note that the input file is read from the source
    directory and is written to the build directory:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tinylang`的版本号被写入一个生成的文件中，使用`configure_file()`命令。版本号取自`TINYLANG_VERSION_STRING`变量。`configure_file()`命令读取一个输入文件，用当前值替换CMake变量，并写入一个输出文件。请注意，输入文件是从源目录读取的，并写入构建目录：'
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, another CMake module is included. The `AddTinylang` module has some helper
    functionality:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，包含另一个CMake模块。`AddTinylang`模块具有一些辅助功能：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There follows another `include_directories()` statement. This adds our own
    `include` directories to the beginning of the search path. As in the standalone
    build, two directories are added:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是另一个`include_directories()`语句。这将我们自己的`include`目录添加到搜索路径的开头。与独立构建一样，添加了两个目录：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At the end of the file, the `lib` and the `tools` directories are declared
    as further directories in which CMake finds the `CMakeLists.txt` file. This is
    the basic mechanism to connect the directories. This sample application only has
    source files below the `lib` and the `tools` directories, so nothing else is needed.
    More complex projects will add more directories, for example, for the unit tests:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾，将`lib`和`tools`目录声明为CMake查找`CMakeLists.txt`文件的其他目录。这是连接目录的基本机制。此示例应用程序只在`lib`和`tools`目录下有源文件，因此不需要其他内容。更复杂的项目将添加更多目录，例如用于单元测试的目录：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is the main description for your project.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您项目的主要描述。
- en: 'The `AddTinylang.cmake` helper module is placed in the `cmake/modules` directory.
    It has the following content:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddTinylang.cmake`辅助模块放置在`cmake/modules`目录中。它具有以下内容：'
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With inclusion of the module, the `add_tinylang_subdirectory()`, `add_tinylang_library()`,
    `add_tinylang_executable()`, and `add_tinylang_tool()` functions are available
    for use. Basically, these are wrappers around the equivalent functions provided
    by LLVM (in the `AddLLVM` module). `add_tinylang_subdirectory()` adds a new source
    directory for inclusion in the build. Additionally, a new CMake option is added.
    With this option, the user can control whether the content of the directory should
    be compiled or not. With `add_tinylang_library()`, a library is defined that is
    also installed. `add_tinylang_executable()` defines an executable and `add_tinylang_tool()`
    defines an executable that is also installed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 随着模块的包含，`add_tinylang_subdirectory()`、`add_tinylang_library()`、`add_tinylang_executable()`和`add_tinylang_tool()`函数可供使用。基本上，这些函数是LLVM提供的等效函数（在`AddLLVM`模块中）的包装器。`add_tinylang_subdirectory()`添加一个新的源目录以便在构建中包含。此外，还添加了一个新的CMake选项。通过此选项，用户可以控制是否应该编译该目录的内容。使用`add_tinylang_library()`定义一个也被安装的库。`add_tinylang_executable()`定义一个可执行文件，`add_tinylang_tool()`定义一个也被安装的可执行文件。
- en: 'Inside the `lib` directory, a `CMakeLists.txt` file is needed even if there
    is no source. It must include the source directories of this project''s libraries.
    Open your favorite text editor and save the following content in the file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lib`目录中，即使没有源文件，也需要一个`CMakeLists.txt`文件。它必须包括该项目库的源目录。打开您喜欢的文本编辑器，并将以下内容保存到文件中：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A large project would create several libraries, and the source would be placed
    in subdirectories of `lib`. Each of these directories would have to be added in
    the `CMakeLists.txt` file. Our small project has only one library called `Basic`,
    so only one line is needed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大型项目会创建多个库，并且源文件会放在`lib`的子目录中。每个这些目录都必须在`CMakeLists.txt`文件中添加。我们的小项目只有一个名为`Basic`的库，所以只需要一行。
- en: 'The `Basic` library has only one source file, `Version.cpp`. The `CMakeLists.txt`
    file in this directory is again simple:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Basic`库只有一个源文件`Version.cpp`。该目录中的`CMakeLists.txt`文件同样简单：'
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A new library called `tinylangBasic` is defined, and the compiled `Version.cpp`
    is added to this library. An LLVM option controls whether this is a shared or
    static library. By default, a static library is created.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个名为`tinylangBasic`的新库，并将编译的`Version.cpp`添加到该库中。LLVM选项控制这是一个共享库还是静态库。默认情况下，将创建一个静态库。
- en: 'The same steps repeat in the `tools` directory. The `CMakeLists.txt` file in
    this folder is almost as simple as in the `lib` directory:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tools`目录中重复相同的步骤。该文件夹中的`CMakeLists.txt`文件几乎与`lib`目录中的一样简单：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, a CMake option is defined that controls whether the content of this directory
    is compiled. Then the only subdirectory, `driver`, is added, this time with a
    function from our own module. Again, this allows us to control if this directory
    is included in compilation or not.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个CMake选项，用于控制是否编译此目录的内容。然后添加唯一的子目录`driver`，这次使用我们自己模块的函数。同样，这使我们能够控制是否包括此目录在编译中。
- en: 'The `driver` directory contains the source of the application, `Driver.cpp`.
    The `CMakeLists.txt` file in this directory has all the steps to compile and link
    this application:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`driver`目录包含应用程序`Driver.cpp`的源代码。此目录中的`CMakeLists.txt`文件包含编译和链接此应用程序的所有步骤：'
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, the `LLVM_LINK_COMPONENTS` variable is set to the list of LLVM components
    that we need to link our tool against. An LLVM component is a set of one or more
    libraries. Obviously, this depends on the implemented functionality of the tools.
    Here, we need only the `Support` component.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将`LLVM_LINK_COMPONENTS`变量设置为我们需要将我们的工具链接到的LLVM组件列表。LLVM组件是一个或多个库的集合。显然，这取决于工具的实现功能。在这里，我们只需要`Support`组件。
- en: With `add_tinylang_tool()` a new installable application is defined. The name
    is `tinylang` and the only source file is `Driver.cpp`. To link against our own
    libraries, we have to specify them with `target_link_libraries()`. Here, only
    `tinylangBasic` is needed.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`add_tinylang_tool()`定义一个新的可安装应用程序。名称为`tinylang`，唯一的源文件是`Driver.cpp`。要链接到我们自己的库，必须使用`target_link_libraries()`指定它们。这里只需要`tinylangBasic`。
- en: Now the files required for the CMake system are in place. Next, we will add
    the source files.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，CMake系统所需的文件已经就位。接下来，我们将添加源文件。
- en: Adding the C++ source files
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加C++源文件
- en: 'Let''s start in the `include/tinylang/Basic` directory. First, create the `Version.inc.in`
    template file, which holds the configured version number:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`include/tinylang/Basic`目录开始。首先，创建`Version.inc.in`模板文件，其中包含配置的版本号：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `@` symbols around `TINYLANG_VERSION_STRING` denote that this is a CMake
    variable that should be replaced with their content.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`@`符号表示`TINYLANG_VERSION_STRING`是一个CMake变量，应该用其内容替换。'
- en: 'The `Version.h` header file only declares a function to retrieve the version
    string:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Version.h`头文件只声明一个函数来检索版本字符串：'
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The implementation for this function is in the `lib/Basic/Version.cpp` file.
    It''s similarly simple:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的实现在`lib/Basic/Version.cpp`文件中。它同样简单：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And finally, in the `tools/driver/Driver.cpp` file there is the application
    source:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`tools/driver/Driver.cpp`文件中有应用程序源代码：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Despite being only a friendly tool, the source uses typical LLVM functionality.
    The `llvm::InitLLVM()` call does some basic initialization. On Windows, the arguments
    are converted to Unicode for the uniform treatment of command-line parsing. And
    in the (hopefully unlikely) case that the application crashes, a pretty print
    stack trace handler is installed. It outputs the call hierarchy, beginning with
    the function inside which the crash happened. To see the real function names instead
    of hex addresses, the debug symbols must be present.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管只是一个友好的工具，但源代码使用了典型的LLVM功能。`llvm::InitLLVM()`调用进行了一些基本的初始化。在Windows上，参数被转换为Unicode，以便统一处理命令行解析。并且在应用程序崩溃的情况下（希望不太可能发生），会安装一个漂亮的打印堆栈跟踪处理程序。它输出调用层次结构，从发生崩溃的函数开始。要查看真实的函数名称而不是十六进制地址，必须存在调试符号。
- en: LLVM does not use the `iostream` classes of the C++ standard library. It comes
    with its own implementation. `llvm::outs()` is the output stream and is used here
    to send a friendly message to the user.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM不使用C++标准库的`iostream`类。它带有自己的实现。`llvm::outs()`是输出流，在这里用于向用户发送友好的消息。
- en: Compiling the tinylang application
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译tinylang应用程序
- en: 'Now all files for the first application are in place, the application can be
    compiled. To recap, you should have the following directories and files:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第一个应用程序的所有文件都就位，可以编译该应用程序。简而言之，您应该有以下目录和文件：
- en: '![Figure 2.3 – All directories and files of the tinylang project'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 - tinylang项目的所有目录和文件'
- en: '](img/B15647_02_03.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15647_02_03.jpg)'
- en: Figure 2.3 – All directories and files of the tinylang project
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 - tinylang项目的所有目录和文件
- en: 'As discussed previously, there are several ways to build `tinylang`. Here is
    how to build `tinylang` as a part of LLVM:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有几种构建`tinylang`的方法。以下是如何将`tinylang`作为LLVM的一部分构建：
- en: 'Change into the build directory with this:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令切换到构建目录：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, run CMake as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按以下方式运行CMake：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, build and install everything:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建并安装所有内容：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After building and installing, the`../llvm-12` directory contains the LLVM
    and the `tinylang` binaries. Please check that you can run the application:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建和安装后，`../llvm-12`目录包含LLVM和`tinylang`二进制文件。请检查您是否可以运行该应用程序：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should see the friendly message. Please also check that the Basic library
    was installed:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该看到友好的消息。还请检查是否安装了Basic库：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Building together with LLVM is useful when you closely follow LLVM development,
    and you want to be aware of API changes as soon as possible. In [*Chapter 1*](B15647_01_ePub_RK.xhtml#_idTextAnchor015),
    *Installing LLVM*, we checked out a specific version of LLVM. Therefore, we see
    no changes to LLVM sources.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与LLVM一起构建在您密切关注LLVM开发并希望尽快了解API更改时非常有用。在[*第1章*](B15647_01_ePub_RK.xhtml#_idTextAnchor015)中，*安装LLVM*，我们检出了LLVM的特定版本。因此，我们看不到LLVM源代码的任何更改。
- en: 'In this scenario, it makes sense to build LLVM once and compile `tinylang`
    as a standalone project using the compiled version of LLVM. Here is how to do
    it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，构建LLVM一次并使用编译版本的LLVM编译`tinylang`作为独立项目是有意义的。以下是如何做到这一点：
- en: 'Start again with entering the `build` directory:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新开始，进入`build`目录：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This time, CMake is used only to build LLVM:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，只使用CMake构建LLVM：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Compare this with the preceding CMake command: the parameters referring to
    `tinylang` are missing; everything else is identical.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此与前面的CMake命令进行比较：缺少指向`tinylang`的参数；其他一切都是相同的。
- en: 'Build and install LLVM with Ninja:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Ninja构建和安装LLVM：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now you have an LLVM installation in the `llvm-12` directory. Next, the `tinylang`
    project will be built. As it is a standalone build, a new `build` directory is
    required. Leave the LLVM build directory like so:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您在`llvm-12`目录中安装了LLVM。接下来，将构建`tinylang`项目。由于它是一个独立的构建，需要一个新的`build`目录。保留LLVM构建目录如下：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now create a new `build-tinylang` directory. On Unix, you use the following
    command:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个新的`build-tinylang`目录。在Unix上，您使用以下命令：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And on Windows, you would use this command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，您将使用以下命令：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Enter the new directory with the following command on either operating system:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令进入新目录，无论是在哪个操作系统上：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now run CMake to create the build files for `tinylang`. The only peculiarity
    is how LLVM is discovered, because CMake does not know the location where we installed
    LLVM. The olution is to specify the path to the `LLVMConfig.cmake` file from LLVM
    with the `LLVM_DIR` variable. The command is as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行CMake为`tinylang`创建构建文件。唯一的特殊之处在于如何发现LLVM，因为CMake不知道我们安装LLVM的位置。解决方案是使用`LLVMConfig.cmake`文件的路径来指定`LLVM_DIR`变量。命令如下：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The installation directory is now separate, too. As usual, build and install
    with the following:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装目录现在也是分开的。像往常一样，使用以下命令构建和安装：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: After the commands are finished, you should run the`../tinylang/bin/tinylang`
    application to check that the application works.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令完成后，您应该运行`../tinylang/bin/tinylang`应用程序，以检查应用程序是否正常工作。
- en: An alternate way to include LLVM
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包含LLVM的另一种方法
- en: If you do not want to use CMake for your project, then you need to find out
    where the include files and libraries are, which libraries to link against, which
    build mode was used, and much more. This information is provided by the `llvm-config`
    tool, which is in the `bin` directory of an LLVM installation. Assuming that this
    directory is included in your shell search path, you run `$ llvm-config` to see
    all options.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想为您的项目使用CMake，那么您需要找出包含文件和库的位置，链接的库，使用了哪种构建模式等等。这些信息由`llvm-config`工具提供，该工具位于LLVM安装的`bin`目录中。假设该目录包含在您的shell搜索路径中，您运行`$
    llvm-config`来查看所有选项。
- en: 'For example, to get the LLVM libraries to link against the `support` component
    (which is used in the preceding example), you run this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要使LLVM库链接到`support`组件（在前面的示例中使用），您运行以下命令：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The output is a line with the library names including the link option for the
    compiler, for example, `-lLLVMSupport –lLLVMDemangle`. Obviously, this tool can
    be easily integrated with your build system of choice.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一行库名称，包括编译器的链接选项，例如`-lLLVMSupport –lLLVMDemangle`。显然，这个工具可以很容易地与您选择的构建系统集成。
- en: 'With the project layout shown in this section, you have a structure that scales
    for large projects such as compilers. The next section lays another foundation:
    how to cross-compile for a different target architecture.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本节中显示的项目布局，您拥有一个适用于大型项目（如编译器）的结构。下一节奠定了另一个基础：如何为不同的目标架构进行交叉编译。
- en: Targeting a different CPU architecture
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对不同的CPU架构
- en: Today, many small computers such as the Raspberry Pi are in use and have only
    limited resources. Running a compiler on such a computer is often not possible
    or takes too much runtime. Hence, a common requirement for a compiler is to generate
    code for a different CPU architecture. The whole process of creating an executable
    is called cross-compiling. In the previous section, you created a small example
    application based on the LLVM libraries. Now we will take this application and
    compile it for a different target.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，许多小型计算机，如树莓派，正在使用，并且资源有限。在这样的计算机上运行编译器通常是不可能的，或者运行时间太长。因此，编译器的一个常见要求是为不同的CPU架构生成代码。创建可执行文件的整个过程称为交叉编译。在上一节中，您创建了一个基于LLVM库的小型示例应用程序。现在我们将采用这个应用程序，并为不同的目标进行编译。
- en: 'With cross-compiling, there are two systems involved: the compiler runs on
    the host system and produces code for the target system. To denote the systems,
    the so-called `x86_64-pc-win32` is used for a Windows system running on a 64-bit
    X86 CPU. The CPU architecture is `x86_64`, `pc` is a generic vendor, and `win32`
    is the operating system. The parts are connected by a hyphen. A Linux system running
    on an ARMv8 CPU uses `aarch64-unknown-linux-gnu` as the triple. `aarch64` is the
    CPU architecture. The operating system is `linux`, running a `gnu` environment.
    There is no real vendor for a Linux-based system, so this part is `unknown`. Parts
    that are not known or unimportant for a specific purpose are often omitted: the
    triple `aarch64-linux-gnu` describes the same Linux system.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在交叉编译中，涉及两个系统：编译器在主机系统上运行，并为目标系统生成代码。为了表示这些系统，所谓的`x86_64-pc-win32`用于运行在64位X86
    CPU上的Windows系统。CPU架构是`x86_64`，`pc`是一个通用的供应商，`win32`是操作系统。这些部分由连字符连接。在ARMv8 CPU上运行Linux系统使用`aarch64-unknown-linux-gnu`作为三重。`aarch64`是CPU架构。操作系统是`linux`，运行`gnu`环境。对于基于Linux的系统，没有真正的供应商，因此这一部分是`unknown`。对于特定目的未知或不重要的部分通常被省略：三重`aarch64-linux-gnu`描述了相同的Linux系统。
- en: 'Let''s assume your development machine runs Linux on an X86 64-bit CPU and
    you want to cross-compile to an ARMv8 CPU system running Linux. The host triple
    is `x86_64-linux-gnu` and the target triple is `aarch64-linux-gnu`. Different
    systems have different characteristics. Your application must be written in a
    portable fashion, otherwise you will be surprised by failures. Common pitfalls
    are as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的开发机器在X86 64位CPU上运行Linux，并且您希望交叉编译到运行Linux的ARMv8 CPU系统。主机三重是`x86_64-linux-gnu`，目标三重是`aarch64-linux-gnu`。不同的系统具有不同的特征。您的应用程序必须以可移植的方式编写，否则您将会受到失败的惊吓。常见的陷阱如下：
- en: '**Endianness**: The order in which multi-byte values are stored in memory can
    be different.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字节序**：存储在内存中的多字节值的顺序可能不同。'
- en: '`int` may not be large enough to hold a pointer.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`可能不足以容纳指针。'
- en: '`long double` can use 64 bit (ARM), 80 bit (X86), or 128 bit (ARMv8). PowerPC
    systems may use double-double arithmetic for `long double`, which gives more precision
    by using a combination of two 64-bit `double` values.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long double`可以使用64位（ARM）、80位（X86）或128位（ARMv8）。PowerPC系统可能使用`long double`的双倍精度算术，通过使用两个64位`double`值的组合来获得更高的精度。'
- en: If you do not pay attention to these points, then your application can act surprisingly
    or crash on the target platform even if it runs perfectly on your host system.
    The LLVM libraries are tested on different platforms and also contain portable
    solutions to the mentioned issues.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不注意这些要点，那么你的应用程序在目标平台上可能会表现出令人惊讶的行为，甚至在你的主机系统上运行完美。LLVM库在不同平台上进行了测试，也包含了对上述问题的可移植解决方案。
- en: 'For cross-compiling, you need the following tools:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 进行交叉编译，你需要以下工具：
- en: A compiler that generates code for the target
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为目标生成代码的编译器
- en: A linker capable of generating binaries for the target
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够为目标生成二进制文件的链接器
- en: Header files and libraries for the target
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标的头文件和库
- en: 'Ubuntu and Debian distributions have packages that support cross-compiling.
    In the following setup, we take advantage of this. The `gcc` and `g++` compilers,
    the `ld` linker, and the libraries are available as precompiled binaries producing
    ARMv8 code and executables. To install all these packages, type the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu和Debian发行版有支持交叉编译的软件包。在下面的设置中，我们利用了这一点。`gcc`和`g++`编译器，`ld`链接器和库都可以作为预编译的二进制文件，生成ARMv8代码和可执行文件。要安装所有这些软件包，输入以下命令：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The new files are installed under the `/usr/aarch64-linux-gnu`. directory This
    directory is the (logical) root directory of the target system. It contains the
    usual `bin`, `lib`, and `include` directories. The cross-compilers (`aarch64-linux-gnu-gcc-8`
    and `aarch64-linux-gnu-g++-8`) know about this directory.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 新文件安装在`/usr/aarch64-linux-gnu`目录下。这个目录是目标系统的（逻辑）根目录。它包含通常的`bin`、`lib`和`include`目录。交叉编译器（`aarch64-linux-gnu-gcc-8`和`aarch64-linux-gnu-g++-8`）知道这个目录。
- en: Cross-compiling on other systems
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他系统上进行交叉编译
- en: If your distribution does not come with the required toolchain, then you can
    build it from source. The gcc and g++ compilers must be configured to produce
    code for the target system and the binutils tools need to handle files for the
    target system. Moreover, the C and the C++ library need to be compiled with this
    toolchain. The steps vary with the used operating systems and host and target
    architecture. On the web, you can find instructions if you search for `gcc cross-compile
    <architecture>`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的发行版没有所需的工具链，那么你可以从源代码构建它。gcc和g++编译器必须配置为为目标系统生成代码，binutils工具需要处理目标系统的文件。此外，C和C++库需要使用这个工具链进行编译。这些步骤因使用的操作系统和主机和目标架构而异。在网上，你可以找到指令，如果你搜索`gcc交叉编译<架构>`。
- en: 'With this preparation, you are almost ready to cross-compile the sample application
    (including the LLVM libraries) except for one little detail. LLVM uses the `llvm-tblgen`
    from the build of [*Chapter 1*](B15647_01_ePub_RK.xhtml#_idTextAnchor015), *Installing
    LLVM*, or you can compile only this tool. Assuming you are in the directory that
    contains the clone of the GitHub repository, type this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作完成后，你几乎可以开始交叉编译示例应用程序（包括LLVM库），只是还有一个小细节。LLVM使用[*第1章*](B15647_01_ePub_RK.xhtml#_idTextAnchor015)中构建的`llvm-tblgen`，或者你可以只编译这个工具。假设你在包含GitHub存储库克隆的目录中，输入以下命令：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These steps should be familiar by now. A build directory is created and entered.
    The CMake command creates LLVM build files for the X86 target only. To save space
    and time, a release build is done but assertions are enabled to catch possible
    errors. Only the `llvm-tblgen` tool is compiled with Ninja.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤现在应该很熟悉了。创建一个构建目录并进入。CMake命令只为X86目标创建LLVM构建文件。为了节省空间和时间，进行了一个发布构建，但启用了断言以捕获可能的错误。只有`llvm-tblgen`工具是用Ninja编译的。
- en: 'With the `llvm-tblgen` tool at hand, you can now start the cross-compilation.
    The CMake command line is very long so you may want to store the command in a
    script file. The difference from previous builds is that more information must
    be provided:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`llvm-tblgen`工具，现在你可以开始交叉编译了。CMake命令行非常长，所以你可能想把命令存储在一个脚本文件中。与以前的构建不同的是，需要提供更多的信息：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Again, you create a build directory and enter it. Some of the CMake parameters
    have not been used before and need some explanation:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 再次创建一个构建目录并进入。一些CMake参数以前没有使用过，需要一些解释：
- en: '`CMAKE_CROSSCOMPILING` set to `ON` tells CMake that we are cross-compiling.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_CROSSCOMPILING`设置为`ON`告诉CMake我们正在进行交叉编译。'
- en: '`LLVM_TABLEGEN` specifies the path to the `llvm-tblgen` tool to use. This is
    the one from the previous build.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LLVM_TABLEGEN`指定要使用的`llvm-tblgen`工具的路径。这是之前构建的那个。'
- en: '`LLVM_DEFAULT_TARGET_TRIPLE` is the triple of the target architecture.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LLVM_DEFAULT_TARGET_TRIPLE`是目标架构的三元组。'
- en: '`LLVM_TARGET_ARCH` is used for **just-in-time** (**JIT**) code generation.
    It defaults to the architecture of the host. For cross-compiling, this must be
    set to the target architecture.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LLVM_TARGET_ARCH`用于**即时**（**JIT**）代码生成。它默认为主机的架构。对于交叉编译，这必须设置为目标架构。'
- en: '`LLVM_TARGETS_TO_BUILD` is the list of target(s) for which LLVM should include
    code generators. The list should at least include the target architecture.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LLVM_TARGETS_TO_BUILD`是LLVM应该包括代码生成器的目标列表。列表至少应该包括目标架构。'
- en: '`CMAKE_C_COMPILER` and `CMAKE_CXX_COMPILER` specify the C and C++ compilers
    used for the build. The binaries of the cross-compilers are prefixed with the
    target triple and are not found automatically by CMake.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_C_COMPILER`和`CMAKE_CXX_COMPILER`指定用于构建的C和C++编译器。交叉编译器的二进制文件以目标三元组为前缀，并且CMake不会自动找到它们。'
- en: With the other parameters, a release build with assertions enabled is requested
    and our tinylang application is built as part of LLVM (as shown in the previous
    section). After the compilation process is finished, you can check with the `file`
    command that you have really created a binary for ARMv8\. Run `$ file bin/tinylang`
    and check that the output says that it is an ELF 64-bit object for the ARM aarch64
    architecture.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他参数，请求启用断言的发布构建，并将我们的 tinylang 应用程序作为 LLVM 的一部分构建（如前一节所示）。编译过程完成后，您可以使用 `file`
    命令检查您是否真的为 ARMv8 创建了一个二进制文件。运行 `$ file bin/tinylang` 并检查输出是否表明它是针对 ARM aarch64
    架构的 ELF 64 位对象。
- en: Cross-compiling with clang
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 clang 进行交叉编译
- en: 'As LLVM generates code for different architectures, it seems obvious to use
    clang to cross-compile. The obstacle here is that LLVM does not provide all required
    parts; for example, the C library is missing. Because of this, you have to use
    a mix of LLVM and GNU tools, and as a result you need to tell CMake even more
    about the environment you are using. As a minimum, you need to specify the following
    options for clang and clang++: `--target=<target-triple>` (enables code generation
    for a different target), `--sysroot=<path>` (path to the root directory for the
    target; see previous), `I` (search path for header files), and `–L` (search path
    for libraries). During the CMake run, a small application is compiled and CMake
    complains if something is wrong with your setup. This step is sufficient to check
    if you have a working environment. Common problems include picking the wrong header
    files, link failures due to different library names, and the wrong search path.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 LLVM 为不同的架构生成代码，使用 clang 进行交叉编译似乎是显而易见的。这里的障碍是 LLVM 并未提供所有所需的部分；例如，缺少 C 库。因此，您必须使用
    LLVM 和 GNU 工具的混合，并且作为结果，您需要向 CMake 提供更多关于您正在使用的环境的信息。至少，您需要为 clang 和 clang++ 指定以下选项：`--target=<target-triple>`（启用为不同目标生成代码）、`--sysroot=<path>`（目标根目录的路径；参见前文）、`I`（头文件的搜索路径）和
    `–L`（库的搜索路径）。在 CMake 运行期间，将编译一个小应用程序，如果您的设置有问题，CMake 将会报错。这一步足以检查您是否有一个可用的环境。常见问题包括选择错误的头文件、由于不同的库名称导致的链接失败，以及错误的搜索路径。
- en: Cross-compiling is surprisingly complex. With the instructions from this section,
    you will be able to cross-compile your application for a target architecture of
    your choice.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉编译非常复杂。有了本节的说明，您将能够为您选择的目标架构交叉编译您的应用程序。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about the projects that are part of the LLVM repository
    and the common layout used. You replicated this structure for your own small application,
    laying the foundation for more complex applications. As the supreme discipline
    of compiler construction, you also learned how to cross-compile your application
    for another target architecture.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了 LLVM 仓库中的项目以及常用的布局。您为自己的小应用程序复制了这个结构，为更复杂的应用程序奠定了基础。作为编译器构建的至高学科，您还学会了如何为另一个目标架构交叉编译您的应用程序。
- en: In the next chapter, the sample language `tinylang` will be outlined. You will
    learn about the tasks a compiler has to do and where LLVM library support is available.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，将概述示例语言 `tinylang`。您将了解编译器必须执行的任务以及 LLVM 库支持的位置。
