["```cpp\nauto add = [](const int first, const int second){return first + second;};\nauto increment = partialApplication(add, /*first*/ 1); \n/* equivalent with \nauto increment = [](const int second){return 1 + second;}; \n*/\n```", "```cpp\nauto add = [](const int first, const int second) { return first + second; };\nTEST_CASE(\"Increments using manual partial application\"){\n    auto increment = [](const int value) { return add(value, 1); };\n\n    CHECK_EQ(43, increment(42));\n}\n```", "```cpp\nusing namespace std::placeholders; // to allow _1, _2 etc.\n\nTEST_CASE(\"Increments using bind\"){\n    // bind the value 1 to the first parameter of add \n    // _1 is a placeholder for the first parameter of the increment    \n       lambda\n    auto increment = bind(add, 1, _1); \n\n    CHECK_EQ(43, increment(42));\n}\n```", "```cpp\nTEST_CASE(\"Constant using bind\"){\n   auto number42 = bind(add, 1, 41); \n   CHECK_EQ(42, number42());\n}\n```", "```cpp\nauto addThree = [](const int first, const int second, const int third){return first + second + third;};\n\nTEST_CASE(\"Adds three\"){\n    CHECK_EQ(42, addThree(10, 20, 12));\n}\n```", "```cpp\nTEST_CASE(\"Adds two numbers to 10\"){\n    auto addTwoNumbersTo10 = bind(addThree, 10, _1, _2);\n\n    CHECK_EQ(42, addTwoNumbersTo10(20, 12));\n}\n```", "```cpp\nTEST_CASE(\"Adds one number to 10 + 20\"){\n    auto addTo10Plus20 = bind(addThree, 10, 20, _1);\n\n    CHECK_EQ(42, addTo10Plus20(12));\n}\n```", "```cpp\nTEST_CASE(\"Adds 10 to one number, and then to 20\"){\n    auto addTo10Plus20 = bind(addThree, 10, _1, 20);\n\n    CHECK_EQ(42, addTo10Plus20(12));\n}\n```", "```cpp\nTEST_CASE(\"Adds one number to 10, and then to 20\"){\n    auto addTo10Plus20 = bind(addThree, _1, 10, 20);\n\n    CHECK_EQ(42, addTo10Plus20(12));\n}\n```", "```cpp\nclass AddOperation{\n    private:\n        int first;\n        int second;\n\n    public:\n        AddOperation(int first, int second): first(first), \n            second(second){}\n        int add(){ return first + second;}\n};\n```", "```cpp\nTEST_CASE(\"Bind member method\"){\n    AddOperation operation(41, 1);\n    auto add41And1 = bind(&AddOperation::add, operation); \n\n    CHECK_EQ(42, add41And1());\n}\n```", "```cpp\nTEST_CASE(\"Partial bind member method no arguments\"){\n    auto add = bind(&AddOperation::add, _1); \n    AddOperation operation(41, 1);\n    CHECK_EQ(42, add(operation));\n}\n```", "```cpp\nclass AddToOperation{\n    private:\n        int first;\n\n    public:\n        AddToOperation(int first): first(first) {}\n        int addTo(int second){ return first + second;}\n};\n```", "```cpp\nTEST_CASE(\"Partial application member method\"){\n    AddToOperation operation(41);\n    auto addTo41 = bind(&AddToOperation::addTo, operation, _1); \n\n    CHECK_EQ(42, addTo41(1));\n}\n```", "```cpp\nauto add = [](const int first, const int second) { return first +  \n     second; };\n\nTEST_CASE(\"Adds values\"){\n    CHECK_EQ(42, add(25, 17));\n}\n```", "```cpp\nauto curryAdd = [](const int first){ \n    return [first](const int second){\n        return first + second;\n    };\n};\n\nTEST_CASE(\"Adds values using captured curry\"){\n    CHECK_EQ(42, curryAdd(25)(17));\n}\n```", "```cpp\nTEST_CASE(\"Increments using bind\"){\n    auto increment = bind(add, 1, _1); \n\n    CHECK_EQ(43, increment(42));\n}\n```", "```cpp\nauto curryAdd = [](const int first){ \n    return [first](const int second){\n        return first + second;\n    };\n};\n\nTEST_CASE(\"Adds values using captured curry\"){\n    CHECK_EQ(42, curryAdd(25)(17));\n}\n```", "```cpp\nTEST_CASE(\"Increments value\"){\n    auto increment = curryAdd(1);\n\n    CHECK_EQ(43, increment(42));\n}\n```", "```cpp\nadd first second\n```", "```cpp\nincrement = add 1\n```", "```cpp\nauto curryAddPartialApplication = [](const int first){ \n    return bind(add, first, _1);\n};\n\nTEST_CASE(\"Adds values using partial application curry\"){\n    CHECK_EQ(42, curryAddPartialApplication(25)(17));\n}\n```", "```cpp\nauto curriedAddThree = [](const int first){\n    return [first](const int second){ \n        return [first, second](const int third){\n            return first + second + third;\n        };\n    };\n}; \n\nTEST_CASE(\"Add three with curry\"){\n    CHECK_EQ(42, curriedAddThree(15)(10)(17));\n}\n```", "```cpp\nbind(bind(bind(addThree, _1),_1), _1)\n```", "```cpp\nbind(bind(bind(addThree, ?, ?, _1), ?,_1), _1)\n```", "```cpp\nauto simpleCurry1 = [](auto f){\n     return f;\n };\n```", "```cpp\nauto simpleCurry2 = [](auto f){\n    return [f](auto x){ return bind(f, x, _1); };\n};\n```", "```cpp\nauto simpleCurry3 = [](auto f){\n     return [f](auto x, auto y){ return bind(f, x, y, _1); };\n};\nauto simpleCurry4 = [](auto f){\n    return [f](auto x, auto y, auto z){ return bind(f, x, y, z, _1);  \n};\n};\n```", "```cpp\nauto curry2 = [](auto f){\n    return simpleCurry2(f);\n };\n\nauto curry3 = [](auto f){\n    return curry2(simpleCurry3(f));\n };\n\nauto curry4 = [](auto f){\n    return curry3(simpleCurry4(f));\n};\n```", "```cpp\nTEST_CASE(\"Add three with partial application curry\"){\n    auto add = [](int a, int b) { return a+b; };\n    CHECK_EQ(3, curry2(add)(1)(2));\n\n    auto addThreeCurryThree = curry3(addThree);\n    CHECK_EQ(6, curry3(addThree)(1)(2)(3));\n\n    auto addFour = [](int a, int b, int c, int d){return a + b + c +  \n        d;};\n    CHECK_EQ(10, curry4(addFour)(1)(2)(3)(4));\n }\n```", "```cpp\nauto add = [](const auto first, const auto second) { return first + second; };\nauto increment = bind(add, _1, 1);\n\nTEST_CASE(\"Increments\"){\n    CHECK_EQ(43, increment(42));\n}\n```", "```cpp\nauto add = [](const auto first, const auto second) { return first + \n    second; };\n\ntemplate<typename T, T one>\nauto increment = bind(add, _1, one);\n\nTEST_CASE(\"Increments\"){\n    CHECK_EQ(43, increment<int, 1>(42));\n}\n```", "```cpp\n// Assume wrap at 20 for now\nauto addWrapped = [](const auto first, const auto second) { return \n    (first + second)%20; };\n\nTEST_CASE(\"Adds values\"){\n    CHECK_EQ(7, addWrapped(10, 17));\n}\n\ntemplate<typename T, T one>\nauto incrementWrapped = bind<T>(addWrapped, _1, one);\n\nTEST_CASE(\"Increments\"){\n    CHECK_EQ(1, incrementWrapped<int, 1>(20));\n}\n```", "```cpp\nauto addWrapped = [](const auto first, const auto second, const auto \n    wrapAt) { return (first + second) % wrapAt; };\n\nauto add = bind(addWrapped, _1, _2, 20);\n\ntemplate<typename T, T one>\n    auto increment = bind<T>(add, _1, one);\n\nTEST_CASE(\"Increments\"){\n    CHECK_EQ(1, increment<int, 1>(20));\n}\n```"]