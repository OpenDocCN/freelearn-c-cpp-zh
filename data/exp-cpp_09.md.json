["```cpp\nstd::vector<std::vector<int>>\n```", "```cpp\nusing IntMatrix = std::vector<std::vector<int>>;\n```", "```cpp\nstd::vector<int> count_all_evens(const IntMatrix& numbers)\n{\n  std::vector<int> even_numbers_count;\n  for (const auto& number_line: numbers) {\n    int even{0};\n for (const auto& number: number_line) {\n if (number % 2 == 0) {\n ++even;\n }\n }\n even_numbers_count.push_back(even);\n  }\n  return even_numbers_count;\n}\n```", "```cpp\nint count_evens(const std::vector<int>& number_line) {\n  return std::count_if(number_line.begin(), \n       number_line.end(), [](int num){return num % 2 == 0;});\n}\n```", "```cpp\nstd::vector<int> count_all_evens(const std::vector<std::vector<int>>& numbers) {\n  return numbers | std::ranges::views::transform(count_evens);\n}\n```", "```cpp\ntemplate <typename InputIterator, typename UnaryPredicate>\nconstexpr typename iterator_traits<InputIterator>::difference_type\n  count_if(InputIterator first, InputIterator last, UnaryPredicate p);\n```", "```cpp\n#include <array>\n#include <iostream>\n#include <algorithm>\n\nint main()\n{\n  std::array<int, 4> arr{1, 2, 3, 4};\n auto res = std::count_if(arr.cbegin(), arr.cend(), \n [](int x){ return x == 3; });\n  std::cout << \"There are \" << res << \" number of elements equal to 3\";\n}\n```", "```cpp\n// consider the Product is already declared and has a \"name\", \"price\", and \"weight\"\n// also consider the get_products() is defined \n// and returns a vector of Product instances\n\nusing ProductList = std::vector<std::shared_ptr<Product>>;\nProductList vec{get_products()};\n```", "```cpp\nProductList full_named_products; // type alias has been defined above\nusing ProductPtr = std::shared_ptr<Product>;\nstd::transform(vec.cbegin(), vec.cend(), \n  std::back_inserter(full_named_products), \n  [](ProductPtr p){ /* modify the name and return */ });\n```", "```cpp\nProductList apples;\nstd::copy_if(full_named_products.cbegin(), full_named_products.cend(),\n  std::back_inserter(apples), \n  [](ProductPtr p){ return p->name() == \"apple\"; });\n```", "```cpp\nProductList apples = filter(\n  transform(vec, [](ProductPtr p){/* normalize the name */}),\n  [](ProductPtr p){return p->name() == \"apple\";}\n);\n```", "```cpp\nProductList apples = vec | transform([](ProductPtr p){/* normalize the name */})\n                         | filter([](ProductPtr p){return p->name() == \"apple\";});\n```", "```cpp\nauto operator*()\n{\n  return predicate(*current_position);\n}\n```", "```cpp\ndouble square(double num) { return num * num; }\n```", "```cpp\nvoid calc_square_roots(std::vector<double>& vec) \n{\n  for (auto& elem : vec) {\n    elem = std::sqrt(elem);\n  }\n}\n\nint main()\n{\n  std::vector<double> vec{1.1, 2.2, 4.3, 5.6, 2.4};\n calc_square_roots(vec);\n}\n```", "```cpp\nstd::vector<double> pure_calc_square_roots(const std::vector<double>& vec)\n{\n std::vector<double> new_vector;\n  for (const auto& elem : vec) {\n    new_vector.push_back(std::sqrt(elem));\n  }\n return new_vector;\n}\n```", "```cpp\n#include <ranges>\n#include <vector>\n\nint main()\n{\n std::vector<double> vec{1.1, 2.2, 4.3, 5.6, 2.4};\n auto result = vec | std::ranges::views::transform(std::sqrt);\n}\n```", "```cpp\nstruct User\n{\n  int age;\n  string name;\n  string phone_number;\n  string email;\n};\n```", "```cpp\nvoid update_age(User& u)\n{\n  u.age = u.age + 1;\n}\n```", "```cpp\nUser pure_update_age(const User& u) // cannot modify the input argument\n{\n User tmp{u};\n  tmp.age = tmp.age + 1;\n  return tmp;\n}\n```", "```cpp\nUser pure_update_age(User u) // u is the copy of the passed object\n{\n  u.age = u.age + 1;\n  return u;\n}\n```", "```cpp\nUser john{.age{21}, .name{\"John\"}};\n\nauto updated{pure_update_age(john)};\nstd::cout << updated.age; // prints 22\n\nupdated = pure_update_age(john);\nstd::cout << updated.age; // prints 22\n```", "```cpp\ntypedef  void (*PF)(int);\nvoid foo(int arg) \n{\n  // do something with arg\n}\n\nint bar(int arg, PF f)\n{\n f(arg);\n  return arg;\n}\n\nbar(42, foo);\n```", "```cpp\nclass Function\n{\npublic:\n  void modify_state(int a) {\n    state_ = a;\n  }\n\n  int get_state() {\n    return state_;\n  }\n\n  void operator()() {\n // do something that a function would do\n }\nprivate:\n  int state_;\n};\n\nvoid foo(Function f)\n{\n f();\n  // some other useful code\n}\n```", "```cpp\nvoid foo(Function f)\n{\n  f();\n  f.modify_state(11);\n cout << f.get_state(); // get the state\n  f(); // call the \"function\"\n}\n```", "```cpp\nclass Function\n{\npublic:\n void operator()() {    // some useful stuff ++called_; \n  }\n\nprivate:\n  int called_ = 0;\n};\n```", "```cpp\n#include <functional>\n\nvoid print_it(int a) {\n  cout << a;\n}\n\nstd::function<void(int)> function_object = print_it;\n```", "```cpp\n#include <functional>\n#include <iostream>\n\nstd::function<int (int, int)> get_multiplier()\n{\n return [](int a, int b) { return a * b; };\n}\n\nint main()\n{\n auto multiply = get_multiplier();\n  std::cout << multiply(3, 5) << std::endl; // outputs 15\n}\n```", "```cpp\nstd::function<int(int)> multiply(int a)\n{\n return [a](int b) { return a * b; };\n}\n\nint main()\n{\n  std::cout << multiply(3)(5) << std::endl;\n}\n```", "```cpp\nauto multiplyBy22 = multiply(22);\nauto fiveTimes = multiply(5);\n\nstd::cout << multiplyBy22(10); // outputs 220\nstd::cout << fiveTimes(4); // outputs 20\n```", "```cpp\nstd::vector<int> elems{1, 2, 3, 4, 5, 6};\nstd::find_if(elems.begin(), elems.end(), [](int el) {return el % 3 == 0;});\n```", "```cpp\nstd::string str = \"lowercase\";\nstd::transform(str.begin(), str.end(), str.begin(), \n  [](unsigned char c) { return std::toupper(c); });\nstd::cout << str; // \"LOWERCASE\"\n```", "```cpp\nstd::vector<double> elems{1.1, 2.2, 3.3, 4.4, 5.5};\nauto sum = std::accumulate(elems.begin(), elems.end(), 0);\n```", "```cpp\nauto product = std::accumulate(elems.begin(), elems.end(), 1, \n  [](int prev, int cur) { return prev * cur; });\n```", "```cpp\nauto product = std::accumulate(elems.begin(), elems.end(), 1, \n std::multiplies<int>());\n```", "```cpp\nstd::reduce(std::execution::par, elems.begin(), elems.end(), \n  1, std::multiplies<int>());\n```", "```cpp\nint factorial(int n)\n{\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n}\n```", "```cpp\n...\nreturn n * factorial(n - 1);\n...\n```", "```cpp\nint factorial(int n) \n{\n  int result = 1;\n  for (int ix = n; ix > 1; --ix) {\n    result *= ix;\n  }\n  return result;\n}\n```", "```cpp\nint tail_factorial(int n, int result)\n{\n  if (n <= 1) return result;\n  return tail_factorial(n - 1, n * result);\n}\n```", "```cpp\ntemplate <int N>\nstruct MetaFactorial\n{\n  enum {\n    value = N * MetaFactorial<N - 1>::value\n  };\n};\n\ntemplate <>\nstruct MetaFactorial<0>\n{\n  enum {\n    value = 1\n  };\n};\n\nint main() {\n  std::cout << MetaFactorial<5>::value; // outputs 120\n  std::cout << MetaFactorial<6>::value; // outputs 720\n}\n```", "```cpp\ntemplate <int N>\nstruct MetaFactorial\n{\n  enum {\n value = N * MetaFactorial<N - 1>::value\n };\n};\n```", "```cpp\nstd::cout << MetaFactorial<3>::value;\n```", "```cpp\nstruct MetaFactorial<3>\n{\n  enum {\n    value = 3 * MetaFactorial<2>::value\n  };\n};\n\nstruct MetaFactorial<2>\n{\n  enum {\n    value = 2 * MetaFactorial<1>::value;\n  };\n};\n\nstruct MetaFactorial<1>\n{\n  enum {\n    value = 1 * MetaFactorial<0>::value;\n  };\n};\n```", "```cpp\nstruct MetaFactorial<3>\n{\n  enum {\n   value = 3 * 2\n  };\n};\n\nstruct MetaFactorial<2>\n{\n  enum {\n    value = 2 * 1\n  };\n};\n\nstruct MetaFactorial<1>\n{\n  enum {\n    value = 1 * 1\n  };\n};\n\n```", "```cpp\nstd::cout << 6;\n```", "```cpp\nstd::cout << MetaFactorial<3>::value;\n```"]