- en: 15\. Collectibles, Power-Ups, and Pickups
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15. 收藏品、强化道具和拾取物品
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will create collectible coins and potion power-ups for the
    player. Furthermore, we will design the UI for the collectible coins using the
    Unreal Motion Graphics UI Designer, or UMG as it is more commonly known. Lastly,
    we will create bricks that will have these collectibles hidden inside of them.
    By the end of this chapter, you will be able to implement collectibles and power-ups
    for a player character to find within a level environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为玩家创建可收藏的硬币和药水强化道具。此外，我们将使用虚幻运动图形UI设计师（UMG）为可收藏的硬币设计UI。最后，我们将创建砖块，这些砖块将隐藏着这些收藏品。通过本章的学习，你将能够在关卡环境中为玩家角色实现收藏品和强化道具。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, you created the player projectile and used `Anim Notifies`
    to spawn the player projectile during the `Throw` animation. The player projectile
    will serve as the player's main offensive gameplay mechanic to use against the
    enemies throughout the level. Due to the combination of default `Anim Notifies`
    provided by Unreal Engine 4 and your own custom `Anim_ProjectileNotify` class,
    the player projectile mechanic looks and feels great.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你创建了玩家投射物，并使用“Anim Notifies”在“投掷”动画期间生成玩家投射物。玩家投射物将作为玩家对抗整个关卡中的敌人的主要进攻游戏机制。由于虚幻引擎4提供的默认“Anim
    Notifies”和你自己的自定义“Anim_ProjectileNotify”类的组合，玩家投射物机制看起来感觉很棒。
- en: The last set of mechanics that we need to develop are the coin collectible and
    potion power-up. Let's briefly break down how collectibles and power-ups have
    influenced other games, and what they will accomplish for our `SuperSideScroller`
    game.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要开发的最后一组机制是硬币收藏品和药水强化道具。让我们简要地分析一下收藏品和强化道具是如何影响其他游戏的，以及它们将为我们的“超级横向卷轴”游戏带来什么成就。
- en: '**Coin Collectible**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**硬币收藏品**'
- en: Collectibles give the player an incentive to explore the level thoroughly. In
    many games, such as *Hollow Knight*, collectibles also serve as a form of currency
    that can be used to purchase upgrades for your character and items. In other,
    more classic platformers, such as Super Mario or Sonic, collectibles serve to
    improve the player's score as they traverse the level.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 收藏品给玩家一个动力去彻底探索关卡。在许多游戏中，比如《虚空骑士》，收藏品也可以作为一种货币，用来购买角色升级和物品。在其他更经典的平台游戏中，比如超级马里奥或索尼克，收藏品可以提高玩家在关卡中的得分。
- en: In today's gaming landscape, it is expected that games include achievements.
    Collectibles are a great way to integrate achievements into your game; for example,
    an achievement for collecting all the coins in a level, or the entire game. For
    the `SuperSideScroller` game, the coin collectible will serve as a satisfactory
    means for the player to explore the game's levels to find as many coins as possible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的游戏环境中，游戏包含成就是一种预期。收藏品是将成就融入游戏的好方法；例如，在某个关卡或整个游戏中收集所有的硬币的成就。对于“超级横向卷轴”游戏来说，硬币收藏品将成为玩家探索游戏关卡的满意手段，尽可能多地找到硬币。
- en: '**Potion Power-Up**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**药水强化道具**'
- en: Power-ups give the player either permanent or temporary advantages against enemies
    or the environments that the player must navigate through. There are many game
    examples that utilize power-ups, and one of the most famous is the Metroid series.
    Metroid uses power-ups to allow the player to explore new areas and battle against
    stronger enemies.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 强化道具给玩家永久或临时的优势，可以对抗敌人或者玩家必须穿越的环境。有许多游戏示例使用了强化道具，其中最著名的之一就是《银河战士》系列。《银河战士》使用强化道具让玩家探索新区域并对抗更强大的敌人。
- en: Power-ups are also another way to integrate achievements into your game. For
    example, you can have an achievement to destroy a certain number of enemies with
    a specific power-up. For the `SuperSideScroller` game, the potion power-up will
    serve as a means to improve the player's ability to navigate the level environment
    by increasing their movement speed and jump height.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 强化道具也是将成就融入游戏的另一种方式。例如，你可以设定一个成就，使用特定的强化道具摧毁一定数量的敌人。对于“超级横向卷轴”游戏来说，药水强化道具将提高玩家在关卡环境中的能力，增加他们的移动速度和跳跃高度。
- en: In this chapter, you will learn how to create the coin collectible and potion
    power-up using C++ to add more layers of gameplay to the `SuperSideScroller` game.
    These gameplay elements will derive from the same base `actor` class that you
    will create. You will also be adding visual and audio elements to both the collectible
    and the power-up so that they are more polished.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用C++创建硬币收藏品和药水强化道具，为“超级横向卷轴”游戏增加更多的游戏层次。这些游戏元素将源自你将创建的相同基础“actor”类。你还将为收藏品和强化道具添加视觉和音频元素，使它们更加精致。
- en: To make the coin collectible and potion power-up more visually interesting to
    the player, we will add a rotating component to these actors in order to draw
    the player's attention to them. This is where `URotatingMovementComponent` can
    be very useful; it allows us to add rotation to actors in a very optimized and
    straightforward way, as opposed to coding our own logic to handle the constant
    rotation of the actor. Let's begin by learning more about this component.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使硬币收藏品和药水强化道具对玩家更具视觉吸引力，我们将为这些角色添加一个旋转组件，以吸引玩家的注意。这就是“URotatingMovementComponent”非常有用的地方；它允许我们以一种非常优化和直接的方式为角色添加旋转，而不是编写自己的逻辑来处理角色的不断旋转。让我们开始学习更多关于这个组件的知识。
- en: URotatingMovementComponent
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URotatingMovementComponent
- en: '`URotatingMovementComponent` is one of a few movement components that exist
    within Unreal Engine 4\. You are already familiar with `CharacterMovementComponent`
    and `ProjectileMovementComponent` from the `SuperSideScroller` game project alone,
    and `RotatingMovementComponent` is just that – another movement component. As
    a refresher, movement components allow different types of movements to occur on
    actors, or characters, that they belong to.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: “URotatingMovementComponent”是Unreal Engine 4中存在的几个移动组件之一。在“SuperSideScroller”游戏项目中，您已经熟悉了“CharacterMovementComponent”和“ProjectileMovementComponent”，而“RotatingMovementComponent”只是另一个移动组件。作为一个复习，移动组件允许不同类型的移动发生在它们所属的actor或角色上。
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`CharacterMovementComponent`, which allows you to control the movement parameters
    of your character such as their movement speed and jump height, was covered in
    *Chapter 10*, *Creating a SuperSideScroller Game*, when you created the `SuperSideScroller`
    player character. `ProjectileMovementComponent`, which allows you to add projectile-based
    movement functionality to actors such as speed and gravity, was covered in *Chapter
    14*, *Spawning the Player Projectile*, when you developed the player projectile.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: “CharacterMovementComponent”允许您控制角色的移动参数，如其移动速度和跳跃高度，在*第10章*“创建SuperSideScroller游戏”中，当您创建“SuperSideScroller”玩家角色时进行了介绍。“ProjectileMovementComponent”允许您向actor添加基于抛射物的移动功能，如速度和重力，在*第14章*“生成玩家抛射物”中，当您开发玩家抛射物时进行了介绍。
- en: '`RotatingMovementComponent` is a very simple movement component compared to
    `CharacterMovementComponent` and that''s because it only involves rotating the
    actor that `RotatingMovementComponent` is a part of; nothing more. `RotatingMovementComponent`
    performs the continuous rotation of a component based on the defined `Rotation
    Rate`, pivot translation, and the option to use rotation in local space or world
    space.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与“CharacterMovementComponent”相比，“RotatingMovementComponent”是一个非常简单的移动组件，因为它只涉及旋转“RotatingMovementComponent”所属的actor；没有其他操作。“RotatingMovementComponent”根据定义的“Rotation
    Rate”、枢轴平移以及使用本地空间或世界空间中的旋转选项执行组件的连续旋转。
- en: Additionally, `RotatingMovementComponent` is much more efficient compared to
    other methods of rotating an actor, such as through the `Event Tick` or `Timelines`
    within Blueprints.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，“RotatingMovementComponent”与通过蓝图中的“Event Tick”或“Timelines”等其他旋转actor的方法相比要高效得多。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'More information about movement components can be found here: [https://docs.unrealengine.com/en-US/Engine/Components/Movement/index.html#rotatingmovementcomponent](https://docs.unrealengine.com/en-US/Engine/Components/Movement/index.html#rotatingmovementcomponent).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 关于移动组件的更多信息可以在这里找到：[https://docs.unrealengine.com/en-US/Engine/Components/Movement/index.html#rotatingmovementcomponent](https://docs.unrealengine.com/en-US/Engine/Components/Movement/index.html#rotatingmovementcomponent)。
- en: We will be using `RotatingMovementComponent` to allow the coin collectible and
    potion power-up to rotate in-place along the Yaw axis. This rotation will draw
    the player's attention to the collectible and give them a visual cue that the
    collectible is important.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用“RotatingMovementComponent”来允许硬币可收集和药水增强沿Yaw轴在原地旋转。这种旋转将吸引玩家的注意力，并给他们一个视觉提示，表明这个可收集物品是重要的。
- en: Now that you have a better understanding of `RotatingMovementComponent`, let's
    move on and create the `PickableActor_Base` class, which is what the coin collectible
    and the potion power-up will derive from.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对“RotatingMovementComponent”有了更好的理解，让我们继续创建“PickableActor_Base”类，这是硬币可收集和药水增强将从中派生的类。
- en: 'Exercise 15.01: Creating the PickableActor_Base Class and Adding URotatingMovementComponent'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.01：创建PickableActor_Base类并添加URotatingMovementComponent
- en: 'In this exercise, you will be creating the `PickableActor_Base` actor class,
    which will be used as the base class that both the collectible coin and potion
    power-up will derive from. You will also create a Blueprint class from this C++
    base class to preview how `URotatingMovementComponent` works. Follow these steps
    to complete this exercise:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建“PickableActor_Base”actor类，这将作为可收集的硬币和药水增强的基类。您还将从这个C++基类创建一个蓝图类，以预览“URotatingMovementComponent”的工作原理。按照以下步骤完成这个练习：
- en: Note
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You have performed many of the following steps numerous times throughout the
    `SuperSideScroller` game project, so there will be limited images to help guide
    you. Only when introducing a new concept will there be an accompanying image.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在“SuperSideScroller”游戏项目中，您已经多次执行了以下许多步骤，因此将有限的图像来帮助您进行指导。只有在引入新概念时才会有相应的图像。
- en: Inside the Unreal Engine 4 editor, *left-click* the `File` option at the top-left
    of the editor and *left-click* the option for `New C++ Class`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unreal Engine 4编辑器中，*左键单击*编辑器左上角的“文件”选项，然后*左键单击*“新建C++类”选项。
- en: From the `Choose Parent Class` window, select the `Actor` option, and then *left-click*
    on the `Next` button at the bottom of this window.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“选择父类”窗口中，选择“Actor”选项，然后*左键单击*此窗口底部的“下一步”按钮。
- en: Name this class `PickableActor_Base` and leave the default `Path` directory
    as it is. Then, select the `Create Class` button at the bottom of this window.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此类命名为“PickableActor_Base”，并将默认的“路径”目录保持不变。然后，选择此窗口底部的“创建类”按钮。
- en: After selecting the `Create Class` button, Unreal Engine 4 will recompile the
    project code and automatically open Visual Studio with both the header and source
    files for the `PickableActor_Base` class.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“创建类”按钮后，Unreal Engine 4将重新编译项目代码，并自动打开Visual Studio，其中包含“PickableActor_Base”类的头文件和源文件。
- en: By default, `Actor` classes provide you with the `virtual void Tick(float DeltaTime)
    override;` function declaration inside the header file. For the purposes of the
    `PickableActor_Base` class, we will not require the `Tick` function, so remove
    this function declaration from the `PickableActor_Base.h` header file.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，“Actor”类在头文件中提供了“virtual void Tick(float DeltaTime) override;”函数声明。对于“PickableActor_Base”类，我们不需要“Tick”函数，因此从“PickableActor_Base.h”头文件中删除此函数声明。
- en: 'Next, you will also need to remove the function from the `PickableActor_Base.cpp`
    file; otherwise, you will receive a compile error. In this source file, find and
    remove the following code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您还需要从`PickableActor_Base.cpp`文件中删除该函数；否则，您将收到编译错误。在此源文件中，查找并删除以下代码：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In many cases, the use of the `Tick()` function for movement updates can lead
    to performance issues as the `Tick()` function is called every single frame. Instead,
    try using `Gameplay Timer` functions to perform certain updates at specified intervals,
    rather than on each frame. You can learn more about `Gameplay Timers` here: [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Timers/index.html](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Timers/index.html).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，使用`Tick()`函数进行移动更新可能会导致性能问题，因为`Tick()`函数在每一帧都会被调用。相反，尝试使用`Gameplay Timer`函数在指定的时间间隔执行某些更新，而不是在每一帧上执行。您可以在这里了解更多关于`Gameplay
    Timers`的信息：[https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Timers/index.html](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Timers/index.html)。
- en: 'Now, it is time to add the components that the `PickableActor_Base` class requires.
    Let''s start with `USphereComponent`, which you will use to detect overlap collision
    with the player. Add the following code underneath the `Protected` access modifier
    inside the `PickableActor_Base.h` header file:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候添加`PickableActor_Base`类所需的组件了。让我们从`USphereComponent`开始，您将使用它来检测与玩家的重叠碰撞。在`PickableActor_Base.h`头文件中的`Protected`访问修饰符内添加以下代码：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The declaration of `USphereComponent` should be very familiar to you by now;
    we've done this in previous chapters, such as *Chapter 16*, *Multiplayer Basics*,
    when we created the `PlayerProjectile` class.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`USphereComponent`的声明现在应该对您非常熟悉；我们在以前的章节中已经做过这个，比如*第16章*，*多人游戏基础*，当我们创建`PlayerProjectile`类时。'
- en: 'Next, add the following code underneath the declaration of `USphereComponent`
    to create a new `UStaticMeshComponent`. This will be used to visually represent
    either the coin collectible or the potion power-up:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在声明`USphereComponent`下面添加以下代码来创建一个新的`UStaticMeshComponent`。这将用于视觉上代表硬币可收集或药水提升：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, add the following code underneath the declaration of `UStaticMeshComponent`
    to create a new `URotatingMovementComponent`. This will be used to give the collectible
    coin and potion power-up simple rotational movement:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在声明`UStaticMeshComponent`下面添加以下代码来创建一个新的`URotatingMovementComponent`。这将用于给可收集的硬币和药水提供简单的旋转运动：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that you have the components declared inside the `PickableActor_Base.h`
    header file, navigate to the `PickableActor_Base.cpp` source file so that you
    can add the required `#includes` for these added components. Add the following
    lines after the first `#include "PickableActor_Base.h"`, at the top of the source
    file:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您已经在`PickableActor_Base.h`头文件中声明了组件，转到`PickableActor_Base.cpp`源文件，以便为这些添加的组件添加所需的`#includes`。在源文件的顶部，在第一个`#include
    "PickableActor_Base.h"`之后添加以下行：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that you have the necessary `include` files for the components, you can
    add the necessary code to initialize these components within the `APickableActor_Base::APickableActor_Base()`
    constructor function:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您已经为组件准备好了必要的`include`文件，可以在`APickableActor_Base::APickableActor_Base()`构造函数中添加必要的代码来初始化这些组件：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'First, initialize the `USphereComponent` component variable, `CollisionComp`,
    by adding the following code to `APickableActor_Base::APickableActor_Base()`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过在`APickableActor_Base::APickableActor_Base()`中添加以下代码来初始化`USphereComponent`组件变量`CollisionComp`：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, initialize `USphereComponent` with a default sphere radius of `30.0f`
    by adding the following code underneath the code provided in the previous step:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过在上一步提供的代码下面添加以下代码，使用默认的球体半径`30.0f`来初始化`USphereComponent`：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since the player character needs to overlap with this component, you will need
    to add the following code so that, by default, `USphereComponent` has the collision
    settings for `Overlap All Dynamic`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于玩家角色需要与此组件重叠，因此您需要添加以下代码，以便默认情况下，`USphereComponent`具有`Overlap All Dynamic`的碰撞设置：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Lastly, `CollisionComp USphereComponent` should be the root component of this
    actor. Add the following code to assign this:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`CollisionComp USphereComponent`应该是这个角色的根组件。添加以下代码来分配这个：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that `CollisionComp USphereComponent` has been initialized, let''s do the
    same for `MeshComp UStaticMeshComponent`. Add the following code. After, we''ll
    discuss what the code is doing for us:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`CollisionComp USphereComponent`已经初始化，让我们为`MeshComp UStaticMeshComponent`做同样的事情。添加以下代码。之后，我们将讨论代码为我们做了什么：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first line initializes `MeshComp UStaticMeshComponent` using the `CreateDefaultSubobject()`
    template function. Next, you are attaching `MeshComp` to the root component, which
    you made for `CollisionComp`, using the `AttachTo()` function. Lastly, `MeshComp
    UStaticMeshComponent` should not have any collision by default, so you are using
    the `SetCollisionEnabled()` function and passing in the `ECollisionEnable::NoCollision`
    enumerator value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用`CreateDefaultSubobject()`模板函数初始化了`MeshComp UStaticMeshComponent`。接下来，您使用`AttachTo()`函数将`MeshComp`附加到您为`CollisionComp`创建的根组件。最后，`MeshComp
    UStaticMeshComponent`默认不应具有任何碰撞，因此您使用`SetCollisionEnabled()`函数并传入`ECollisionEnable::NoCollision`枚举值。
- en: 'Lastly, we can initialize `URotatingMovementComponent RotationComp` by adding
    the following code:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过添加以下代码来初始化`URotatingMovementComponent RotationComp`：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With all the components initialized, compile the C++ code and return to the
    Unreal Engine 4 editor. After compilation succeeds, you will move on to creating
    a Blueprint class for `PickableActor_Base`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有组件初始化后，编译C++代码并返回到Unreal Engine 4编辑器。编译成功后，您将继续为`PickableActor_Base`创建蓝图类。
- en: In the `Content Browser` window, create a new folder called `PickableItems`
    by *right-clicking* on the `Content` folder and selecting the `New Folder` option.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content Browser`窗口中，通过*右键单击*`Content`文件夹并选择`New Folder`选项来创建一个名为`PickableItems`的新文件夹。
- en: In the `PickableItems` folder, *right-click* and select `Blueprint Class`. From
    the `Pick Parent Class` window, search for the `PickableActor_Base` class and
    *left-click* `Select` to create a new Blueprint.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“PickableItems”文件夹中，*右键单击*并选择“蓝图类”。从“选择父类”窗口中，搜索“PickableActor_Base”类并*左键单击*“选择”以创建新的蓝图。
- en: Name this Blueprint `BP_PickableActor_Base` and *double-left-click* the Blueprint
    to open it.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此蓝图命名为`BP_PickableActor_Base`并*双击*打开蓝图。
- en: 'In the `Components` tab, select `MeshComp Static Mesh Component` and assign
    the `Shape_Cone` static mesh to the `Static Mesh` parameter in the `Details` panel.
    Please refer to the following screenshot:![Figure 15.1: The Shape_Cone mesh assigned
    to MeshComp UStaticMeshComponent of the BP_Pickable_Base actor class](img/B16183_15_01.jpg)'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“组件”选项卡中，选择“MeshComp Static Mesh Component”并将“Shape_Cone”静态网格分配给“详细”面板中的“静态网格”参数。请参考以下截图：![图15.1：分配给BP_Pickable_Base
    actor类的MeshComp UStaticMeshComponent的Shape_Cone网格](img/B16183_15_01.jpg)
- en: 'Figure 15.1: The Shape_Cone mesh assigned to MeshComp UStaticMeshComponent
    of the BP_Pickable_Base actor class'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：分配给BP_Pickable_Base actor类的MeshComp UStaticMeshComponent的Shape_Cone网格
- en: Next, select `RotationComp` `URotatingMovementComponent` and find the `Rotation
    Rate` parameter under the `Rotating Component` category of the `Details` panel.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择`RotationComp` `URotatingMovementComponent`并在`详细`面板的`旋转组件`类别下找到`旋转速率`参数。
- en: 'Set `Rotation Rate` to the following values:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“旋转速率”设置为以下值：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These values determine how fast the actor will rotate along each axis per second.
    This means that the cone-shaped actor will rotate along each axis at 100 degrees
    per second on each axis.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值确定了actor每秒沿每个轴旋转的速度。这意味着锥形actor将沿每个轴以每秒100度的速度旋转。
- en: Compile the `PickableActor_Base` Blueprint and add this actor to your level.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译`PickableActor_Base`蓝图并将此actor添加到您的级别中。
- en: 'Now, if you use PIE and look at the `PickableActor_Base` actor in the level,
    you will see that it is now rotating. Please refer to the following screenshot:![Figure
    15.2: Now, the Cone mesh rotates along all the axes, as per the values we added
    to the Rotation Rate window of URotatingMovementComponent'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您使用PIE并查看级别中的`PickableActor_Base` actor，您将看到它正在旋转。请参考以下截图：![图15.2：现在，锥形网格沿所有轴旋转，根据我们添加到URotatingMovementComponent的旋转速率窗口的值
- en: '](img/B16183_15_02.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_02.jpg)'
- en: 'Figure 15.2: Now, the Cone mesh rotates along all the axes, as per the values
    we added to the Rotation Rate window of URotatingMovementComponent'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：现在，锥形网格沿所有轴旋转，根据我们添加到URotatingMovementComponent的旋转速率窗口的值
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the assets and code for this exercise here: [https://packt.live/3njhwyt](https://packt.live/3njhwyt).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到此练习的资产和代码：[https://packt.live/3njhwyt](https://packt.live/3njhwyt)。
- en: With this exercise complete, you've created the base components required for
    the `PickableActor_Base` class and learned how to implement and use `URotatingMovementComponent`.
    With the `PickableActor_Base` class ready, and with `URotatingMovementComponent`
    implemented on the Blueprint actor, we can complete the class by adding overlap
    detection functionality, destroying the collectible actor, and spawning audio
    effects when the actor is picked up by the player. In the following activity,
    you will add the remaining functionality required for the `PickableActor_Base`
    class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成此练习，您已经创建了`PickableActor_Base`类所需的基本组件，并学会了如何实现和使用`URotatingMovementComponent`。有了准备好的`PickableActor_Base`类，并且在蓝图actor上实现了`URotatingMovementComponent`，我们可以通过添加重叠检测功能，销毁可收集的actor，并在玩家拾取actor时产生音频效果来完成该类。在接下来的活动中，您将添加`PickableActor_Base`类所需的其余功能。
- en: 'Activity 15.01: Player Overlap Detection and Spawning Effects in PickableActor_Base'
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动15.01：在PickableActor_Base中进行玩家重叠检测和产生效果
- en: 'Now that the `PickableActor_Base` class has all the required components and
    has its constructor initializing the components, it is time to add the remaining
    aspects of its functionality. These will be inherited by the coin collectible
    and potion power-up later in this chapter. This additional functionality includes
    player overlap detection, destroying the collectible actor, and spawning an audio
    effect to give feedback to the player that it has been successfully picked up
    by. Perform the following steps to add functionality that allows a `USoundBase`
    class object to be played when the collectible overlaps with the player:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`PickableActor_Base`类具有所有必需的组件，并且其构造函数初始化了这些组件，是时候添加其功能的其余部分了。这些功能将在本章后面的硬币可收集物和药水增益中继承。这些额外的功能包括玩家重叠检测，销毁可收集的actor，并产生音频效果以向玩家提供反馈，表明它已被成功拾取。执行以下步骤以添加功能，允许`USoundBase`类对象在可收集物与玩家重叠时播放：
- en: Create a new function in the `PickableActor_Base` class that takes in a reference
    to the player as an input parameter. Call this function `PlayerPickedUp`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PickableActor_Base`类中创建一个接受玩家引用作为输入参数的新函数。将此函数命名为`PlayerPickedUp`。
- en: Create a new `UFUNCTION` called `BeginOverlap()`. Make sure to include all the
    required input parameters for this function before moving on. Refer to *Chapter
    6*, *Collision Objects*, where you used this function inside the `VictoryBox` class.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`BeginOverlap()`的新`UFUNCTION`。在继续之前，请确保包括此函数的所有必需输入参数。请参考*第6章*，*碰撞对象*，在那里您在`VictoryBox`类内使用了此函数。
- en: Add a new `UPROPERTY()` for the `USoundBase` class and name it `PickupSound`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`USoundBase`类添加一个新的`UPROPERTY()`，并将其命名为`PickupSound`。
- en: In the `PickableActor_Base.cpp` source file, create the definitions for both
    the `BeginOverlap()` and `PlayerPickedUp()` functions.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PickableActor_Base.cpp`源文件中，为`BeginOverlap()`和`PlayerPickedUp()`函数创建定义。
- en: Now, add the required `#include` files for the `SuperSideScroller_Player` class
    and the `GameplayStatics` class at the top of the source file.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在源文件的顶部为`SuperSideScroller_Player`类和`GameplayStatics`类添加所需的`#include`文件。
- en: In the `BeginOverlap()` function, create a reference to the player using the
    `OtherActor` input parameter of the function.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BeginOverlap()`函数中，使用函数的`OtherActor`输入参数创建对玩家的引用。
- en: In the `PlayerPickedUp()` function, create a variable for the `UWorld*` object
    that's returned by the `GetWorld()` function.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerPickedUp()`函数中，为`GetWorld()`函数返回的`UWorld*`对象创建一个变量。
- en: Use the `UGameplayStatics` library to spawn `PickUpSound` at the location of
    the `PickableActor_Base` actor.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`UGameplayStatics`库在`PickableActor_Base` actor的位置生成`PickUpSound`。
- en: Then, call the `Destroy()` function so that the actor gets destroyed and removed
    from the world.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，调用`Destroy()`函数，以便角色被销毁并从世界中移除。
- en: Finally, in the `APickableActor_Base::APickableActor_Base()` constructor, bind
    the `OnComponentBeginOverlap` event of `CollisionComp` to the `BeginOverlap()`
    function.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`APickableActor_Base::APickableActor_Base()`构造函数中，将`CollisionComp`的`OnComponentBeginOverlap`事件绑定到`BeginOverlap()`函数。
- en: Download and install the `Unreal Match 3` project from the `Learn` tab of `Epic
    Games Launcher`. Migrate the `Match_Combo` soundwave asset from this project into
    your `SuperSideScroller` project using the knowledge you gained in *Chapter 14*,
    *Spawning the Player Projectile*.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Epic Games Launcher`的`Learn`选项卡中下载并安装`Unreal Match 3`项目。使用您在*第14章*中获得的知识，将`Match_Combo`声波资产从该项目迁移到您的`SuperSideScroller`项目中。
- en: Apply this sound to the `PickupSound` parameter of the `BP_PickableActor_Base`
    Blueprint.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此声音应用到`BP_PickableActor_Base`蓝图的`PickupSound`参数上。
- en: Compile the Blueprint, and if one does not exist in your level, add the `BP_PickableActor_Base`
    actor to your level now.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译蓝图，如果您的关卡中不存在蓝图，则现在将`BP_PickableActor_Base` actor添加到您的关卡中。
- en: In `PIE`, have your character overlap with the `BP_PickableActor_Base` actor.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PIE`中，使您的角色与`BP_PickableActor_Base` actor重叠。
- en: 'Expected output:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出：
- en: '![Figure 15.3: The BP_PickableActor_Base object can be overlapped'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.3：BP_PickableActor_Base对象可以被重叠'
- en: and picked up by the player
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 并被玩家拾取
- en: '](img/B16183_15_03.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_03.jpg)'
- en: 'Figure 15.3: The BP_PickableActor_Base object can be overlapped and picked
    up by the player'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：BP_PickableActor_Base对象可以被玩家重叠和拾取
- en: Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下网址找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: With this activity complete, you have proven your knowledge regarding how to
    add the `OnBeginOverlap()` functionality to your actor classes and how to use
    this function to perform logic for your actor. In the case of `PickableActor_Base`,
    we added logic that will spawn a custom sound and destroy the actor.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个活动后，您已经证明了您如何向您的角色类添加`OnBeginOverlap()`功能，并且如何使用这个功能来执行您的角色的逻辑的知识。在`PickableActor_Base`的情况下，我们添加了一个逻辑，将生成一个自定义声音并销毁该角色。
- en: Now that the `PickableActor_Base` class is set and ready, it is time to develop
    the collectible coin and power-up potion classes that will derive from it. The
    coin collectible class will inherit from the `PickableActor_Base` class you have
    just created. It will override key functionality, such as the `PlayerPickedUp()`
    function, so that we can implement unique logic for the collectible when it's
    picked up by the player. In addition to overriding functionality from the inherited
    parent `PickableActor_Base` class, the coin collectible class will have its own
    unique set of properties, such as its current coin value and unique pickup sound.
    We'll create the coin collectible class together in the next exercise.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`PickableActor_Base`类已经设置好了，是时候开发从中派生的可收集硬币和增益药水类了。硬币可收集类将继承您刚刚创建的`PickableActor_Base`类。它将覆盖关键功能，如`PlayerPickedUp()`函数，以便我们可以在玩家拾取时实现独特的逻辑。除了从继承的父`PickableActor_Base`类中覆盖功能之外，硬币可收集类还将具有其自己独特的属性集，如当前硬币价值和独特的拾取声音。我们将在下一个练习中一起创建硬币可收集类。
- en: 'Exercise 15.02: Creating the PickableActor_Collectable Class'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.02：创建PickableActor_Collectable类
- en: 'In this exercise, you will be creating the `PickableActor_Collectable` class,
    which will be derived from the `PickableActor_Base` class you created in *Exercise
    15.01*, *Creating the PickableActor_Base Class and Adding URotatingMovement Component*
    and finished in *Activity 15.01*, *Player Overlap Detection and Spawning Effects
    in PickableActor_Base*. This class will be used as the main collectible coin that
    the player can collect within the level. Follow these steps to complete this exercise:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建`PickableActor_Collectable`类，该类将从您在*练习15.01*中创建的`PickableActor_Base`类派生，并在*活动15.01*中完成，*创建PickableActor_Base类并添加URotatingMovement组件*。这个类将被用作玩家可以在关卡中收集的主要可收集硬币。按照以下步骤完成这个练习：
- en: Inside the Unreal Engine 4 editor, *left-click* the `File` option at the top-left
    of the editor and *left-click* the option for `New C++ Class`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚幻引擎4编辑器中，*左键单击*编辑器左上角的`文件`选项，然后*左键单击*`新建C++类`选项。
- en: From the `Choose Parent Class` window, select the `PickableActor_Base` option,
    and then *left-click* on the `Next` button at the bottom of this window.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Choose Parent Class`窗口中选择`PickableActor_Base`选项，然后在此窗口底部*左键单击*`Next`按钮。
- en: Name this class `PickableActor_Collectable` and leave the default `Path` directory
    as it is. Then, select the `Create Class` button at the bottom of this window.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此类命名为`PickableActor_Collectable`，并将默认的`Path`目录保持不变。然后，在此窗口底部选择`Create Class`按钮。
- en: After selecting the `Create Class` button, Unreal Engine 4 will recompile the
    project code and will automatically open Visual Studio with both the header and
    source files for the `PickableActor_Collectable` class.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Create Class`按钮后，虚幻引擎4将重新编译项目代码，并将自动打开Visual Studio，显示`PickableActor_Collectable`类的头文件和源文件。
- en: 'By default, the `PickableActor_Collectable.h` header file has no declared functions
    or variables within its class declaration. You will need to add the override for
    the `BeginPlay()` function underneath a new `Protected Access Modifier`. Add the
    following code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`PickableActor_Collectable.h`头文件在其类声明中没有声明的函数或变量。您需要在新的`Protected Access
    Modifier`下添加`BeginPlay()`函数的覆盖。添加以下代码：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The reason we are overriding the `BeginPlay()` function is that `URotatingMovementComponent`
    requires the actor to initialize and use `BeginPlay()` to correctly rotate the
    actor. Therefore, we need to create the override declaration of this function
    and create a basic definition inside the source file. First, however, we need
    to override another important function from the `PickableActor_Base` parent class.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们覆盖“BeginPlay()`函数的原因是，“URotatingMovementComponent”需要角色初始化并使用“BeginPlay()`来正确旋转角色。因此，我们需要创建这个函数的覆盖声明，并在源文件中创建一个基本的定义。然而，首先，我们需要覆盖另一个重要的函数，来自“PickableActor_Base”父类。
- en: 'Override the `PlayerPickedUp()` function from the `PickableActor_Base` parent
    class by adding the following code under `Protected Access Modifier`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在“Protected Access Modifier”下添加以下代码，覆盖`PickableActor_Base`父类中的`PlayerPickedUp()`函数：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this, we are saying that we are going to use, and override, the functionality
    of the `PlayerPickedUp()` function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们表明我们将使用并覆盖“PlayerPickedUp()`函数的功能。
- en: 'Lastly, create a new integer called `UPROPERTY()` that will hold the value
    that the coin collectible will have; in this case, it will have a value of `1`.
    Add the following code to do this:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个名为`UPROPERTY()`的新整数，它将保存硬币可收集的价值；在这种情况下，它的价值将是`1`。添加以下代码来实现这一点：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are creating the integer variable that will be accessible in Blueprints
    and has a default value of `1`. If you so choose, with the `EditAnywhere UPROPERTY()`
    keyword, you can change how much a coin collectible is worth.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个整数变量，该变量将在蓝图中可访问，并具有默认值为“1”。如果您愿意，可以使用“EditAnywhere UPROPERTY()`关键字来更改硬币可收集物品的价值。
- en: 'Now, we can move on to the `PickableActor_Collectable.cpp` source file to create
    the definition of the overridden `PlayerPickedUp()` function. Add the following
    code to the source file:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以继续在“PickableActor_Collectable.cpp”源文件中创建覆盖的“PlayerPickedUp()`函数的定义。在源文件中添加以下代码：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For now, we need to make a call to the `PlayerPickedUp()` parent function by
    using the `Super` keyword. Add the following code to the `PlayerPicked()` function:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要使用“Super”关键字调用“PlayerPickedUp()`父函数。将以下代码添加到“PlayerPicked()`函数中：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The call to the parent function using `Super::PlayerPickedUp(Player)` will ensure
    that the functionality you created in the `PickableActor_Base` class is called.
    As you may recall, the `PlayerPickedUp()` function in the parent class makes a
    call to spawn the `PickupSound` sound object and destroys the actor.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Super::PlayerPickedUp(Player)`调用父函数，将确保您在“PickableActor_Base”类中创建的功能被调用。您可能还记得，父类中的“PlayerPickedUp()`函数调用生成“PickupSound”声音对象并销毁角色。
- en: 'Next, create the definition of the `BeginPlay()` function inside the source
    file by adding the following code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在源文件中创建`BeginPlay()`函数的定义，添加以下代码：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The last thing to do here in C++ is to once again make the call to the `BeginPlay()`
    parent function using the `Super` keyword. Add the following code to the `BeginPlay()`
    function inside the `PickableActor_Collectable` class:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C++中，最后要做的一件事是再次使用“Super”关键字调用“BeginPlay()`父函数。将以下代码添加到“PickableActor_Collectable”类中的“BeginPlay()`函数中：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Compile the C++ code and return to the editor.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译C++代码并返回编辑器。
- en: Note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the assets and code for this exercise at the following link: [https://packt.live/35fRN3E](https://packt.live/35fRN3E).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到此练习的资产和代码：[https://packt.live/35fRN3E](https://packt.live/35fRN3E)。
- en: Now that you've successfully compiled the `PickableActor_Collectable` class,
    you have created the framework needed for the coin collectible. In the following
    activity, you will create a Blueprint from this class and finalize the coin collectible actor.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已成功编译了“PickableActor_Collectable”类，已经为硬币可收集物品创建了所需的框架。在接下来的活动中，您将从这个类创建一个蓝图，并完成硬币可收集物品角色。
- en: 'Activity 15.02: Finalizing the PickableActor_Collectable Actor'
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动15.02：完成PickableActor_Collectable角色
- en: 'Now that the `PickableActor_Collectable` class has all of the necessary inherited
    functionality and unique properties it needs, it is time to create the Blueprint
    from this class and add a `Static Mesh`, update its `URotatingMovementComponent`,
    and apply a sound to the `PickUpSound` property. Perform the following steps to
    finalize the `PickableActor_Collectable` actor:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，“PickableActor_Collectable”类已经具有了所有必要的继承功能和独特属性，是时候从这个类创建蓝图，并添加一个“Static
    Mesh”，更新其“URotatingMovementComponent”，并将声音应用到“PickUpSound”属性。执行以下步骤来完成“PickableActor_Collectable”角色：
- en: From `Epic Games Launcher`, find the `Content Examples` project from the `Learn`
    tab, underneath the `Engine Feature Samples` category.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“Epic Games Launcher”中，在“Learn”选项卡下的“Engine Feature Samples”类别下找到“Content Examples”项目。
- en: Create and install a new project from the `Content Examples` project.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“Content Examples”项目中创建并安装一个新项目。
- en: Migrate the `SM_Pickup_Coin` asset and all its referenced assets from the `Content
    Examples` project to your `SuperSideScroller` project.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“SM_Pickup_Coin”资产及其所有引用的资产从“Content Examples”项目迁移到您的“SuperSideScroller”项目。
- en: Create a new folder within the `Content/PickableItems` directory in the `Content
    Browser` window and name it `Collectable`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Content Browser”窗口中的“Content/PickableItems”目录中创建一个名为“Collectable”的新文件夹。
- en: In this new `Collectable` folder, create a new Blueprint from the `PickableActor_Collectable`
    class that you created in *Exercise 15.02*, *Creating the PickableActor_Collectable
    Class*. Name this new Blueprint `BP_Collectable`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新的“Collectable”文件夹中，从您在*练习15.02*中创建的“PickableActor_Collectable”类创建一个新的蓝图。将这个新的蓝图命名为“BP_Collectable”。
- en: In this Blueprint, set the `Static Mesh` parameter of the `MeshComp` component
    to the `SM_Pickup_Coin` mesh you imported earlier in this activity.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个蓝图中，将“MeshComp”组件的“Static Mesh”参数设置为您在本次活动中导入的“SM_Pickup_Coin”网格。
- en: Next, add the `Match_Combo` sound asset to the `PickupSound` parameter of the
    collectible.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将“Match_Combo”声音资源添加到可收集物品的“PickupSound”参数中。
- en: Lastly, update the `RotationComp` component so that the actor rotates along
    the Z-axis at 90 degrees per second.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新`RotationComp`组件，使演员沿Z轴以每秒90度旋转。
- en: Compile the Blueprint, place `BP_Collectable` in your level, and use PIE.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译蓝图，在您的级别中放置`BP_Collectable`，并使用PIE。
- en: Overlap the player character with the `BP_Collectable` actor and observe the results.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将玩家角色与`BP_Collectable`演员重叠，并观察结果。
- en: 'Expected output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出：
- en: '![Figure 15.4: The coin collectible rotates and can be overlapped by the player'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.4：可旋转的硬币可被玩家重叠'
- en: '](img/B16183_15_04.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_04.jpg)'
- en: 'Figure 15.4: The coin collectible rotates and can be overlapped by the player'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：可旋转的硬币可被玩家重叠
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下位置找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: With this activity complete, you have proven that you know how to migrate assets
    into your Unreal project and how to use and update `URotatingMovementComponent`
    to fit the needs of the coin collectible. Now that the coin collectible actor
    is complete, it is time to add functionality to the player so that the player
    can keep track of how many coins they have collected.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动后，您已经证明了您知道如何将资产迁移到您的虚幻项目中，以及如何使用和更新`URotatingMovementComponent`以满足硬币收藏的需求。现在硬币收藏演员已经完成，是时候为玩家添加功能，以便玩家可以跟踪他们收集了多少硬币。
- en: First, we will create the logic that will count the coins using `UE_LOG` and
    later implement the coin counter using UMG on the game's UI.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建使用`UE_LOG`计算硬币数量的逻辑，然后在游戏的UI上使用UMG实现硬币计数器。
- en: Logging Variables Using UE_LOG
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UE_LOG记录变量
- en: In *Chapter 11*, *Blend Spaces 1D, Key Bindings, and State Machines*, we used
    and learned about the `UE_LOG` function in order to log when the player should
    throw the projectile. We then used the `UE_LOG` function in *Chapter 13*, *Enemy
    Artificial Intelligence*, to log when the player projectile hit an object. `UE_LOG`
    is a robust logging tool we can use to output important information from our C++
    functions into the `Output Log` window inside the editor when playing our game.
    Up until this point, we have only logged `FStrings` to display general text in
    the `Output Log` window to know that our functions were being called. Now, it
    is time to learn how to log variables in order to debug how many coins the player
    has collected.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第11章*，*混合空间1D，键绑定和状态机*中，我们使用并了解了`UE_LOG`函数，以便在玩家应该投掷抛射物时记录。然后我们在*第13章*，*敌人人工智能*中使用`UE_LOG`函数，记录玩家抛射物击中物体的情况。`UE_LOG`是一个强大的日志记录工具，我们可以使用它将重要信息从我们的C++函数输出到编辑器中的`输出日志`窗口中。到目前为止，我们只记录了`FStrings`，以在`输出日志`窗口中显示一般文本，以了解我们的函数是否被调用。现在是时候学习如何记录变量以调试玩家收集了多少硬币。
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is another useful debug function available in C++ with Unreal Engine
    4, known as `AddOnScreenDebugMessage`. You can learn more about this function
    here: [https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.html).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unreal Engine 4中还有另一个有用的调试函数，称为`AddOnScreenDebugMessage`。您可以在这里了解更多关于此功能的信息：[https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.html](https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UEngine/AddOnScreenDebugMessage/1/index.html)。
- en: When creating the `FString` syntax used by the `TEXT()` macro, we can add format
    specifiers to log different types of variables. We will only be discussing how
    to add the format specifier for integer variables.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`TEXT()`宏使用的`FString`语法时，我们可以添加格式说明符以记录不同类型的变量。我们只讨论如何为整数变量添加格式说明符。
- en: Note
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find more information on how to specify other variable types by reading
    the following documentation: [https://www.ue4community.wiki/Logging#Logging_an_FString](https://www.ue4community.wiki/Logging#Logging_an_FString).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过阅读以下文档找到有关如何指定其他变量类型的更多信息：[https://www.ue4community.wiki/Logging#Logging_an_FString](https://www.ue4community.wiki/Logging#Logging_an_FString)。
- en: 'This is what `UE_LOG()` looks like when passing in `FString "Example Text"`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在传递`FString "Example Text"`时`UE_LOG()`的样子：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, you have `Log Category`, `Log Verbose Level`, and the actual `FString`,
    `"Example Text"`, to display in the log. To log an integer variable, you need
    to add `%d` to your `FString` within the `TEXT()` macro, followed by the integer
    variable name outside the `TEXT()` macro, separated by a comma. Here is an example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您有`Log Category`，`Log Verbose Level`和实际的`FString`，`"Example Text"`，显示在日志中。要记录整数变量，您需要在`TEXT()`宏中添加`％d`，然后在`TEXT()`宏之外添加整数变量名称，用逗号分隔。这是一个例子：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The format specifier is identified by the `%` symbol, and each variable type
    has a designated letter that corresponds with it. In the case of integers, the
    letter `d` is used. You will be using this method of logging integer variables
    to log the number of coin collectibles the player has in the next exercise.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 格式说明符由`％`符号标识，每种变量类型都有一个对应的字母。在整数的情况下，使用字母`d`。您将使用此方法记录整数变量，以记录玩家在下一个练习中拥有的硬币收藏数量。
- en: 'Exercise 15.03: Tracking the Number of Coins for the Player'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.03：跟踪玩家的硬币数量
- en: 'In this exercise, you will be creating the necessary properties and functions
    that will allow you to track how many coins the player collects throughout the
    level. You will use this tracking to show the player using UMG later in this chapter.
    Follow these steps to complete this exercise:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建必要的属性和函数，以便跟踪玩家在整个级别中收集的硬币数量。您将在本章后面使用此跟踪来向玩家展示。按照以下步骤完成此练习：
- en: In Visual Studio, find and open the `SuperSideScroller_Player.h` header file.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，找到并打开`SuperSideScroller_Player.h`头文件。
- en: 'Under `Private Access Modifier`, create a new `int` variable called `NumberofCollectables`,
    as shown here:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Private Access Modifier`下，创建一个名为`NumberofCollectables`的新`int`变量，如下所示：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will be a private property that will keep track of the current number of
    coins the player has collected. You will be creating a public function that will
    return this integer value. We do this for safety reasons to ensure that no other
    classes can modify this value.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是一个私有属性，用于跟踪玩家已收集的硬币的当前数量。您将创建一个公共函数，用于返回这个整数值。出于安全原因，我们这样做是为了确保没有其他类可以修改这个值。
- en: 'Next, under the existing `public` access modifier, create a new `UFUNCTION()`
    using the `BlueprintPure` keyword called `GetCurrentNumberOfCollectables()`. This
    function will return an `int`. The following code adds this as an inline function:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有的`public`访问修饰符下，使用`BlueprintPure`关键字创建一个新的`UFUNCTION()`，名为`GetCurrentNumberOfCollectables()`。这个函数将返回一个`int`。以下代码将其添加为内联函数：
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We are using `UFUNCTION()` and the `BlueprintPure` keyword to expose this function
    to Blueprints so that we can use it later in UMG.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`UFUNCTION()`和`BlueprintPure`关键字将这个函数暴露给蓝图，以便我们以后在UMG中使用它。
- en: 'Declare a new `void` function, under the `public` access modifier, called `IncrementNumberofCollectables()`
    that takes in a single integer parameter called `Value`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新的`void`函数，在`public`访问修饰符下，名为`IncrementNumberofCollectables()`，接受一个名为`Value`的整数参数：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is the main function you will use to keep track of how many coins the player
    has collected. We will also add some safety measures to ensure this value is never
    negative.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您将用来跟踪玩家收集了多少硬币的主要函数。我们还将添加一些安全措施，以确保这个值永远不会是负数。
- en: With the `IncrementNumberofCollectables()` function declared, let's create the
    definition of this function inside the `SuperSideScroller_Player.cpp` source file.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明了`IncrementNumberofCollectables()`函数，让我们在`SuperSideScroller_Player.cpp`源文件中创建这个函数的定义。
- en: 'Write the following code to create the definition of the `IncrementNumberofCollectables`
    function:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码来创建`IncrementNumberofCollectables`函数的定义：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The main case to handle here is if the integer value that''s passed into this
    function is less than or equal to `0`. In this case, we do not want to bother
    incrementing the `NumberofCollectables` variable. Add the following code to the
    `IncrementNumberofCollectables()` function:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里需要处理的主要情况是，传递给这个函数的整数值是否小于或等于`0`。在这种情况下，我们不希望麻烦增加`NumberofCollectables`变量。在`IncrementNumberofCollectables()`函数中添加以下代码：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This `if()` statement says that if the `value` input parameter is less than
    or equal to `0`, the function will end. With the `IncrementNumberofCollectables()`
    function returning `void`, it is perfectly okay to use the `return` keyword in
    this way.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`if()`语句表示如果`value`输入参数小于或等于`0`，函数将结束。由于`IncrementNumberofCollectables()`函数返回`void`，在这种情况下使用`return`关键字是完全可以的。
- en: We're adding this check of ensuring the `value` parameter that's passed into
    the `IncrementNumberofCollectables()` function is neither 0 nor negative because
    it is important to establish good coding practices; this guarantees that all possible
    outcomes are handled. In an actual development environment, there could be designers
    or other programmers who attempt to use the `IncrementNumberofCollectables()`
    function and try to pass in a negative value, or a value that equals 0\. If the
    function does not take these possibilities into account, there is potential for
    bugs later on in development.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了这个检查，确保传递给`IncrementNumberofCollectables()`函数的`value`参数既不是0也不是负数，因为建立良好的编码习惯非常重要；这保证了处理了所有可能的结果。在实际的开发环境中，可能会有设计师或其他程序员尝试使用`IncrementNumberofCollectables()`函数并尝试传递一个负值或等于0的值。如果函数没有考虑到这些可能性，后续开发中可能会出现bug。
- en: 'Now that we''ve handled the edge case where `value` is less than or equal to
    `0`, let''s continue with the function using an `else()` statement to increase
    `NumberofCollectables`. Add the following code under the `if()` statement from
    the previous step:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经处理了`value`小于或等于`0`的边缘情况，让我们继续使用`else()`语句来增加`NumberofCollectables`。在上一步的`if()`语句下面添加以下代码：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, let''s log `NumberofCollectables` using `UE_LOG` and the knowledge we
    learned about logging variables. Add the following code after the `else()` statement
    to properly log `NumberofCollectables`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用`UE_LOG`和我们学到的关于记录变量的知识来记录`NumberofCollectables`。在`else()`语句之后添加以下代码来正确记录`NumberofCollectables`：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this `UE_LOG()`, we are making a more robust log to track the number of
    coins. This lays out the groundwork of how the UI will work. This is because we
    are essentially logging the same information to the player through the use of
    UMG later in this chapter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`UE_LOG()`，我们正在创建一个更健壮的日志来跟踪硬币的数量。这为UI的工作奠定了基础。这是因为我们实质上是通过UMG在本章后期向玩家记录相同的信息。
- en: With `UE_LOG()` added, all we need to do is call the `IncrementNumberofCollectables()`
    function inside the `PickableActor_Collectable` class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了`UE_LOG()`后，我们只需要在`PickableActor_Collectable`类中调用`IncrementNumberofCollectables()`函数。
- en: 'In the `PickableActor_Collectable.cpp` source file, add the following header:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PickableActor_Collectable.cpp`源文件中，添加以下头文件：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, inside the `PlayerPickedUp()` function, add the following function call
    before the `Super::PlayerPickedUp(Player)` line:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`PlayerPickedUp()`函数内，在`Super::PlayerPickedUp(Player)`行之前添加以下函数调用：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now that our `PickableActor_Collectable` class is calling our player's `IncrementNumberofCollectables`
    function, recompile the C++ code and return to the Unreal Engine 4 editor.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的`PickableActor_Collectable`类正在调用我们玩家的`IncrementNumberofCollectables`函数，重新编译C++代码并返回到Unreal
    Engine 4编辑器。
- en: Within the UE4 editor, open the `Output Log` window by *left-clicking* `Window`,
    and then hovering over the `Developer Tools` option. From this additional dropdown,
    select `Output Log`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UE4编辑器中，通过*左键单击*`Window`，然后悬停在`Developer Tools`选项上，打开`Output Log`窗口。从这个额外的下拉菜单中选择`Output
    Log`。
- en: Now, add multiple `BP_Collectable` actors to your level and then use PIE.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你的关卡中添加多个`BP_Collectable`角色，然后使用PIE。
- en: When you overlap over each coin collectible, observe the `Output Log` window
    to find that each time you collect a coin, the `Output Log` window will show you
    how many coins you've collected.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您重叠每个可收集的硬币时，请观察“输出日志”窗口，以找出每次收集硬币时，“输出日志”窗口将向您显示您已收集了多少枚硬币。
- en: Note
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the assets and code for this exercise here: [https://packt.live/36t6xM5](https://packt.live/36t6xM5).'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到此练习的资产和代码：[https://packt.live/36t6xM5](https://packt.live/36t6xM5)。
- en: With this exercise completed, you have now completed half of the work needed
    to develop the UI element of tracking the number of coins collected by the player.
    The next half will be using the functionality developed in this activity inside
    UMG to show this information to the player on-screen. To do this, we need to learn
    more about UMG inside of Unreal Engine 4.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成此练习，您现在已经完成了开发跟踪玩家收集的硬币数量的UI元素所需工作的一半。下半部分将使用在此活动中开发的功能在UMG内向玩家在屏幕上显示这些信息。为此，我们需要在虚幻引擎4内学习更多关于UMG的知识。
- en: UMG
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UMG
- en: UMG, or Unreal Motion Graphics UI Designer, is Unreal Engine 4's main tool for
    creating UI for things such as menus, in-game HUD elements such as health bars,
    and other user interfaces you may want to present to the player.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: UMG，或虚幻动态图形用户界面设计师，是虚幻引擎4用于创建菜单、游戏内HUD元素（如生命条）和其他用户界面的主要工具。
- en: In the `SuperSideScroller` game, we will only be using the `Text` widget to
    construct our `Coin Collection UI` in *Exercise 15.04,* *Creating the Coin Counter
    UI HUD Element*. We'll learn more about the `Text` widget in the next section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在“SuperSideScroller”游戏中，我们将仅使用“文本”小部件来构建我们的*练习15.04*中的“硬币收集UI”，*创建硬币计数器UI HUD元素*。我们将在下一节中更多地了解“文本”小部件。
- en: Text Widget
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本小部件
- en: The `Text` widget is one of the simpler widgets that exists. This is because
    it only allows you to display text information to the user and customize the visuals
    of this text. Almost every single game uses text in one way or another to display
    information to its players. Overwatch, for example, uses a text-based UI to display
    crucial match data to its players. Without the use of text, it would be very difficult
    – maybe even impossible – to convey key pieces of statistical data to the player,
    such as total damage dealt, total time playing the game, and many others.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: “文本”小部件是存在的较简单的小部件之一。这是因为它只允许您向用户显示文本信息并自定义这些文本的视觉效果。几乎每个游戏都以某种方式使用文本向玩家显示信息。例如，《守望先锋》使用基于文本的用户界面向玩家显示关键的比赛数据。如果不使用文本，向玩家传达关键的统计数据，如总伤害、游戏时间总计等，可能会非常困难，甚至不可能。
- en: 'The `Text` widget appears in the `Palette` tab within UMG. When you add a `Text`
    widget to the `Canvas` panel, it will display the text `Text Block` by default.
    You can customize this text by adding your text to the `Text` parameter of the
    widget. Alternatively, you can use `Function Binding` to display more robust text
    that can reference internal or external variables. `Function Binding` should be
    used whenever you need to display information that can change; this could be text
    that represents a player''s score, how much money the player has, or in our case,
    the number of coins the player has collected:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: “文本”小部件出现在UMG的“调色板”选项卡中。当您将“文本”小部件添加到“画布”面板时，它将默认显示“文本块”。您可以通过将文本添加到小部件的“文本”参数中来自定义此文本。或者，您可以使用“功能绑定”来显示更强大的文本，可以引用内部或外部变量。“功能绑定”应该在需要显示可能会改变的信息时使用；这可能是代表玩家得分、玩家拥有的金钱数量，或者在我们的情况下，玩家收集的硬币数量。
- en: You will be using the `Function Binding` functionality of the `Text` widget
    to display the number of coins collected by the player using the `GetCurrentNumberofCollectables()`
    function you created in *Exercise 15.03*, *Tracking the Number of Coins for the
    Player*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用“文本”小部件的“功能绑定”功能来显示玩家使用您在*练习15.03*中创建的“GetCurrentNumberofCollectables（）”函数收集的硬币数量，*跟踪玩家的硬币数量*。
- en: Now that we have the `Text` widget in the `Canvas` panel, it is time to position
    this widget where we need it to be. For this, we will take advantage of Anchors.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在“画布”面板中有了“文本”小部件，是时候将这个小部件定位到我们需要的位置了。为此，我们将利用锚点。
- en: Anchors
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锚点
- en: Anchors are used to define where a widget's desired location should be on the
    `Canvas` panel. Once defined, the `Anchor` will ensure that the widget will maintain
    this position with varying screen sizes through different platform devices such
    as phones, tablets, and computers. Without an anchor, a widget's position can
    become inconsistent between different screen resolutions, which is never desired.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点用于定义小部件在“画布”面板上的期望位置。一旦定义，锚点将确保小部件在不同平台设备（如手机、平板电脑和计算机）的不同屏幕尺寸上保持这个位置。没有锚点，小部件的位置可能会在不同的屏幕分辨率之间变化，这是不希望发生的。
- en: Note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information about Anchors, please refer to the following documentation:
    [https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors/index.html](https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors/index.html).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有关锚点的更多信息，请参阅以下文档：[https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors/index.html](https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/Anchors/index.html)。
- en: For the purposes of our `Coin Collection UI` and the `Text` widget you will
    use, the `Anchor` point will be at the top-left corner of the screen. You will
    also add a position offset from this `Anchor` point so that the text is more visible
    and readable to the player. Before moving onto creating our `Coin Collection UI`,
    let's learn about `Text Formatting`, which you will use to display the current
    number of collected coins to the player.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的“硬币收集UI”和您将使用的“文本”小部件，锚点将位于屏幕的左上角。您还将从此“锚点”位置添加位置偏移，以便文本对玩家更加可见和可读。在继续创建我们的“硬币收集UI”之前，让我们了解一下“文本格式”，您将使用它来向玩家显示当前收集的硬币数量。
- en: Text Formatting
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本格式
- en: 'Much like the `UE_LOG()` macro available to us in C++, Blueprints offers a
    similar solution to display text and format the text to allow custom variables
    to be added to it. The `Format Text` function takes in a single text input labeled
    `Format` and returns the `Result` text out. This can then be used to display information:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++中可用的`UE_LOG()`宏类似，蓝图提供了类似的解决方案，用于显示文本并格式化文本以允许添加自定义变量。`格式文本`函数接受一个标记为`Format`的单个文本输入，并返回`Result`文本。然后可以用于显示信息：
- en: '![Figure 15.5: The Format Text function allows us to customize the text using
    formatted arguments that can be passed in'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.5：格式文本函数允许我们使用格式化参数自定义文本'
- en: '](img/B16183_15_05.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_05.jpg)'
- en: 'Figure 15.5: The Format Text function allows us to customize the text using
    formatted arguments that can be passed in'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5：格式文本函数允许我们使用格式化参数自定义文本
- en: 'Instead of using the `%` symbol like `UE_LOG()` does, the `Format Text` function
    uses the `{}` symbols to denote arguments that can be passed into the string.
    In-between the `{}` symbols, you need to add an argument name; this can be anything
    you want, but it should be representative of what the argument is. Refer to the
    example shown in the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`格式文本`函数不像`UE_LOG()`那样使用`%`符号，而是使用`{}`符号来表示可以传递到字符串中的参数。在`{}`符号之间，您需要添加一个参数名称；这可以是任何你想要的东西，但它应该代表参数是什么。请参考以下截图中显示的示例：'
- en: '![Figure 15.6: Here, we are passing an example integer into the formatted text'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.6：在这里，我们将一个示例整数传递到格式化文本中'
- en: '](img/B16183_15_06.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_06.jpg)'
- en: 'Figure 15.6: Here, we are passing an example integer into the formatted text'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6：在这里，我们将一个示例整数传递到格式化文本中
- en: The `Format Text` function only supports `Byte`, `Integer`, `Float`, `Text`,
    or `EText Gender` variable types, so if you are attempting to pass any other type
    of variable into the function as an argument, you must convert it into one of
    the supported types.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`格式文本`函数仅支持`Byte`、`Integer`、`Float`、`Text`或`EText Gender`变量类型，因此，如果您尝试将任何其他类型的变量作为参数传递到函数中，您必须将其转换为受支持的类型之一。'
- en: Note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `Format Text` function is also used for `Text Localization`, where you
    can support multiple languages for your game. More information about how this
    can be done in both C++ and Blueprints can be found here: [https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.html](https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.html).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`格式文本`功能还用于`文本本地化`，您可以为游戏支持多种语言。有关如何在C++和蓝图中执行此操作的更多信息，请访问：[https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.html](https://docs.unrealengine.com/en-US/Gameplay/Localization/Formatting/index.html)。'
- en: You will be using the `Format Text` function in conjunction with the `Text`
    widget in UMG in the next exercise, where we will be creating the `Coin Counter
    UI` widget to display the number of coins that have been collected by the player.
    You will also be using `Anchors` to position the `Text` widget at the top-left
    corner of the screen.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将在UMG中的`Text`小部件中与`格式文本`函数一起使用，我们将创建`Coin Counter UI`小部件，以显示玩家收集的硬币数量。您还将使用`Anchors`将`Text`小部件定位在屏幕的左上角。
- en: 'Exercise 15.04: Creating the Coin Counter UI HUD Element'
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.04：创建硬币计数器UI HUD元素
- en: 'In this exercise, you will be creating the UMG UI asset, which will display
    and update the number of coins collected by the player. You will use the `GetCurrentNumberofCollectables()`
    inline function you created in *Exercise 15.02*, *Creating the PickableActor_Collectable
    Class*, to display this value on the screen using a simple `Text` widget. Follow
    these steps to accomplish this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建UMG UI资产，用于显示和更新玩家收集的硬币数量。您将使用在*练习15.02*中创建的`GetCurrentNumberofCollectables()`内联函数，在屏幕上使用简单的`Text`小部件显示此值。按照以下步骤完成此操作：
- en: Let's start by creating a new folder inside the `Content Browser` window called
    `UI`. Do this by *right-clicking* on the `Content` folder at the top of the browser
    directory in the editor and selecting `New Folder`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在`Content Browser`窗口内创建一个名为`UI`的新文件夹。在编辑器中的浏览器目录顶部的`Content`文件夹上*右键单击*，然后选择`New
    Folder`。
- en: Inside the new `/Content/UI` directory, *right-click* and instead of selecting
    `Blueprint Class`, hover over the `User Interface` option at the bottom of this
    list and *left-click* the `Widget Blueprint` option.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的`/Content/UI`目录内，*右键单击*，而不是选择`Blueprint Class`，悬停在列表底部的`User Interface`选项上，然后*左键单击*`Widget
    Blueprint`选项。
- en: Name this new `Widget Blueprint` `BP_UI_CoinCollection`, and then *double-left-click*
    the asset to open the UMG editor.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新的`Widget Blueprint`命名为`BP_UI_CoinCollection`，然后*双击*该资产以打开UMG编辑器。
- en: 'By default, the `Widget` panel is empty, and you will find an empty hierarchy
    on the left-hand side, as shown in the following screenshot:![Figure 15.7: The
    Widget panel Hierarchy outlines how the different'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`Widget`面板是空的，您会在左侧找到一个空的层次结构，如下截图所示：![图15.7：Widget面板层次结构概述了UI的不同
- en: elements of the UI are layered with one another
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 元素如何相互叠加
- en: '](img/B16183_15_07.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_07.jpg)'
- en: 'Figure 15.7: The Widget panel Hierarchy outlines how the different elements
    of the UI are layered with one another'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7：Widget面板层次结构概述了UI的不同元素如何相互叠加
- en: Above the `Hierarchy` tab is the `Palette` tab, which lists all the available
    widgets you can use inside your UI. We will only focus on the `Text` widget, which
    is listed under the `Common` category. Do not mistake this option with the Rich
    Text Block widget.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Hierarchy`选项卡上方是`Palette`选项卡，列出了您可以在UI内使用的所有可用小部件。我们只关注`Text`小部件，它列在`Common`类别下。不要将此选项与Rich
    Text Block小部件混淆。
- en: Note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a more detailed reference to all the available `Widgets` inside UMG, please
    read the following documentation from Epic Games: [https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/WidgetTypeReference/index.html](https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/WidgetTypeReference/index.html).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有关UMG中所有可用`Widgets`的更详细参考，请阅读Epic Games的以下文档：[https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/WidgetTypeReference/index.html](https://docs.unrealengine.com/en-US/Engine/UMG/UserGuide/WidgetTypeReference/index.html)。
- en: Add the `Text` widget to the `UI` panel by either *left-clicking* and dragging
    the `Text` widget from the `Palette` tab to the `Hierarchy` tab underneath the
    `Canvas` panel root, or by *left-clicking* and dragging the `Text` widget directly
    into the `Canvas` panel itself in the middle of the UMG editor.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过*左键单击*并将`Text`小部件从`Palette`选项卡拖动到`Canvas`面板根下的`Hierarchy`选项卡，或者通过*左键单击*并将`Text`小部件直接拖放到UMG编辑器中间的`Canvas`面板本身中，将`Text`小部件添加到`UI`面板。
- en: Before changing the text of this widget, we need to update its anchor, position,
    and font size in order to fit the needs we have for displaying the information
    to the player.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改此小部件的文本之前，我们需要更新其锚点、位置和字体大小，以满足我们在向玩家显示信息方面的需求。
- en: 'With the `Text` widget selected, you will see many options under its `Details`
    panel to customize this text. The first thing to do here is anchor the `Text`
    widget to the top-left corner of the `Canvas` panel. *Left-click* on the `Anchors`
    dropdown and select the top-left anchoring option, as shown in the following screenshot:![Figure
    15.8: By default, there are options to anchor a widget'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Text`小部件后，您会在其`Details`面板下看到许多选项来自定义此文本。这里要做的第一件事是将`Text`小部件锚定到`Canvas`面板的左上角。*左键单击*`Anchors`下拉菜单，并选择左上角的锚定选项，如下截图所示：![图15.8：默认情况下，有选项可以锚定小部件
- en: at different locations of the screen
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕的不同位置
- en: '](img/B16183_15_08.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_08.jpg)'
- en: 'Figure 15.8: By default, there are options to anchor a widget at different
    locations of the screen'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8：默认情况下，有选项可以锚定小部件在屏幕的不同位置
- en: Anchoring allows the widget to maintain its desired location within the `Canvas`
    panel, regardless of varying screen sizes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 锚定允许小部件在`Canvas`面板内保持所需的位置，而不受不同屏幕尺寸的影响。
- en: Now that the `Text` widget is anchored to the top-left corner, we need to set
    its relative position to this anchor so that there is an offset for better positioning
    and readability of the text.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Text`小部件已经锚定在左上角，我们需要设置它相对于此锚点的位置，以便为文本提供更好的定位和可读性的偏移量。
- en: In the `Details` panel, underneath the `Anchors` option, are parameters for
    `Position X` and `Position Y`. Set both these parameters to `100.0f`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Anchors`选项下的`Details`面板中，有`Position X`和`Position Y`的参数。将这两个参数都设置为`100.0f`。
- en: 'Next, enable the `Size To Content` parameter so that the size of the `Text`
    widget will automatically resize itself, depending on the size of the text it
    is displaying, as shown in the following screenshot:![Figure 15.9: The Size To
    Content parameter will ensure that the Text widget'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，启用`Size To Content`参数，以便`Text`小部件的大小将根据其显示的文本大小自动调整大小，如下截图所示：![图15.9：`Size
    To Content`参数将确保`Text`小部件
- en: will display its full content and not be cut off
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示其完整内容，不会被切断
- en: '](img/B16183_15_09.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_09.jpg)'
- en: 'Figure 15.9: The Size To Content parameter will ensure that the Text widget
    will display its full content and not be cut off'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9：`Size To Content`参数将确保`Text`小部件将显示其完整内容，不会被切断
- en: The last thing we need to do here is to update the size of the font used for
    the `Text` widget. Underneath the `Appearance` tab of the `Details` panel for
    the `Text` widget, you will find the `Size` parameter. Set this value to `48`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里需要做的最后一件事是更新`Text`小部件使用的字体大小。在`Text`小部件的`Details`面板的`Appearance`选项卡下，您会找到`Size`参数。将此值设置为`48`。
- en: 'The final `Text` widget will look like this:![Figure 15.10: The Text widget
    is now anchored to the top-left of the Canvas panel, with a small relative offset
    and a larger font for better readability for the player'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的`Text`小部件将如下所示：![图15.10：现在`Text`小部件已经锚定在画布面板的左上角，具有较小的相对偏移和更大的字体，以便玩家更容易阅读
- en: '](img/B16183_15_10.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_10.jpg)'
- en: 'Figure 15.10: The Text widget is now anchored to the top-left of the Canvas
    panel, with a small relative offset and a larger font for better readability for
    the player'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10：现在`Text`小部件已经锚定在画布面板的左上角，具有较小的相对偏移和更大的字体，以便玩家更容易阅读
- en: Now that we have the `Text` widget positioned and sized the way we need it to
    be, let's add a new binding to the text so that it will automatically update and
    match the value of the number of collectibles the player has.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Text`小部件已经定位和调整大小，让我们为文本添加一个新的绑定，以便它将自动更新并匹配玩家拥有的可收集物品的数量的值。
- en: With the `Text` widget selected, find the `Text` parameter in its `Details`
    panel, under the `Content` category. There, you will find the `Bind` option.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Text`小部件后，在其`Details`面板的`Content`类别下找到`Text`参数。在那里，您会找到`Bind`选项。
- en: '*Left-click* the `Bind` option and select `Create Binding`. When doing this,
    the new `Function Binding` will be created automatically and be given the name
    `GetText_0`. Please refer to the following screenshot:![Figure 15.11: It is important
    to always rename the bind functions'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*`Bind`选项，然后选择`Create Binding`。这样做时，新的`Function Binding`将自动创建，并被命名为`GetText_0`。请参考以下截图：![图15.11：重命名绑定函数非常重要'
- en: because their default names are too generic
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它们的默认名称太通用了
- en: '](img/B16183_15_11.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_11.jpg)'
- en: 'Figure 15.11: It is important to always rename the bind functions because their
    default names are too generic'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11：重命名绑定函数非常重要，因为它们的默认名称太通用了
- en: Rename this function `Get Number of Collectables`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此函数重命名为`获取可收集物品的数量`。
- en: 'Before continuing with this function, create a new object reference variable
    called `Player` that''s of the `SuperSideScroller_Player` type. Make this variable
    `Public` and exposable on spawn by enabling both the `Instance Editable` and `Expose
    on Spawn` parameters of the variable, as shown in the following screenshot:![Figure
    15.12: The Player variable should now have the Instance Editable'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续使用此函数之前，创建一个名为`Player`的新对象引用变量，其类型为`SuperSideScroller_Player`。通过启用变量的`Instance
    Editable`和`Expose on Spawn`参数，使此变量成为`Public`并在生成时可公开，如下面的截图所示：![图15.12：现在，Player变量应该具有Instance
    Editable
- en: and Expose on Spawn parameters enabled
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 并启用了Expose on Spawn参数
- en: '](img/B16183_15_12.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_12.jpg)'
- en: 'Figure 15.12: The Player variable should now have the Instance Editable and
    Expose on Spawn parameters enabled'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12：现在，Player变量应该具有Instance Editable和Expose on Spawn参数
- en: By making the `Player` variable `Public` and exposed on spawn, you will be able
    to assign this variable when creating the widget and adding it to the screen.
    We will do this in *Exercise 15.05*, *Adding the Coin Counter UI to the Player
    Screen*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`Player`变量设置为`Public`并在生成时公开，您将能够在创建小部件并将其添加到屏幕时分配此变量。我们将在*练习15.05*中执行此操作，*将硬币计数器UI添加到玩家屏幕*。
- en: Now that we have a reference variable to `SuperSideScroller_Player`, let's continue
    with the `Get Number of Collectables` bind function.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个对`SuperSideScroller_Player`的引用变量，让我们继续使用`Get Number of Collectables`绑定函数。
- en: Add a `Getter` of the `Player` variable to the `Get Number of Collectables`
    function.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Player`变量的`Getter`添加到`Get Number of Collectables`函数中。
- en: 'From this variable, *left-click* and drag and from the context-sensitive drop-down
    menu, and find and select the `Get Current Number of Collectables` function. Please
    refer to the following screenshot:![Figure 15.13: The Get Current Numberof Collectables
    C++ function'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从此变量中，*左键单击* 并从上下文敏感的下拉菜单中拖动，并找到并选择`Get Current Number of Collectables`函数。请参阅下面的截图：![图15.13：您在练习15.03中创建的Get
    Current Numberof Collectables C++函数
- en: you created in Exercise 15.03
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您在练习15.03中创建的
- en: '](img/B16183_15_13.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_13.jpg)'
- en: 'Figure 15.13: The Get Current Numberof Collectables C++ function you created
    in Exercise 15.03'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13：您在练习15.03中创建的Get Current Numberof Collectables C++函数
- en: 'Next, *left-click* and drag out the `Return Value` text parameter of the `Get
    Number of Collectables` to `Return Node`. From the context-sensitive drop-down
    menu, search for and select the `Format Text` option, as shown in the following
    screenshot:![Figure 15.14: Now, we can create customized and formatted text'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，*左键单击* 并拖动 `Get Number of Collectables` 的 `Return Value` 文本参数到 `Return Node`。从上下文敏感的下拉菜单中，搜索并选择
    `Format Text` 选项，如下面的截图所示：![图15.14：现在，我们可以创建自定义和格式化的文本
- en: to suit the needs of the text
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以满足文本的需求
- en: '](img/B16183_15_14.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_14.jpg)'
- en: 'Figure 15.14: Now, we can create customized and formatted text to suit the
    needs of the text'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.14：现在，我们可以创建自定义和格式化的文本以满足文本的需求
- en: 'Within the `Format Text` function, add the following text:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Format Text`函数中添加以下文本：
- en: '[PRE31]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Please refer to the following screenshot:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅下面的截图：
- en: '![Figure 15.15: Now, there is a new input argument to the formatted'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.15：现在，格式化的文本有一个新的输入参数'
- en: text that we can use to display custom information
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的文本来显示自定义信息
- en: '](img/B16183_15_15.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_15.jpg)'
- en: 'Figure 15.15: Now, there is a new input argument to the formatted text that
    we can use to display custom information'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15：现在，格式化的文本有一个新的输入参数，我们可以使用它来显示自定义信息
- en: Remember that using the `{}` symbols denotes a text argument that allows you
    to pass variables into the text.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用`{}`符号表示允许您将变量传递到文本中的文本参数。
- en: 'Finally, connect the int `Return Value` of the `GetCurrentNumberofCollectables()`
    function to the wildcard `coins` input pin of the `Format Text` function, as shown
    here:![Figure 15.16: Now, the Text widget will update automatically based on the
    updated value returned from the Get Current Numberof Collectables function'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`GetCurrentNumberofCollectables()`函数的整数`Return Value`连接到`Format Text`函数的通配符`coins`输入引脚，如下所示：![图15.16：现在，文本小部件将根据从Get
    Current Numberof Collectables函数返回的更新值自动更新
- en: '](img/B16183_15_16.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_16.jpg)'
- en: 'Figure 15.16: Now, the Text widget will update automatically based on the updated
    value returned from the Get Current Numberof Collectables function'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.16：现在，文本小部件将根据从Get Current Numberof Collectables函数返回的更新值自动更新
- en: Compile and save the `BP_UI_CoinCollection` widget Blueprint.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并保存`BP_UI_CoinCollection`小部件蓝图。
- en: Note
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the assets and code for this exercise here: [https://packt.live/3eQJjTU](https://packt.live/3eQJjTU).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到此练习的资产和代码：[https://packt.live/3eQJjTU](https://packt.live/3eQJjTU)。
- en: With this exercise completed, you have created the `UI UMG` widget needed to
    display the current number of coins collected by the player. By using the `GetCurrentNumberofCollectables()`
    C++ function and the binding functionality of the `Text` widget, the UI will always
    update its value based on the number of coins collected. In the next exercise,
    we will add this UI to the player's screen, but first, we'll briefly learn about
    how to add and remove UMG from the player screen.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，您已经创建了显示玩家收集的硬币当前数量所需的`UI UMG`小部件。通过使用`GetCurrentNumberofCollectables()`
    C++函数和`Text`小部件的绑定功能，UI将根据收集的硬币数量始终更新其值。在下一个练习中，我们将将此UI添加到玩家的屏幕上，但首先，我们将简要了解如何向玩家屏幕添加和删除UMG。
- en: Adding and Creating UMG User Widgets
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和创建UMG用户小部件
- en: Now that we have created the Coin Collection UI in UMG, it is time to learn
    how to add and remove the UI to and from the player screen. By adding the Coin
    Collection UI to the player screen, the UI becomes visible to the player and can
    be updated as the player collects coins.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在UMG中创建了Coin Collection UI，是时候学习如何将UI添加到玩家屏幕上并从中移除了。通过将Coin Collection
    UI添加到玩家屏幕上，UI将对玩家可见，并且可以在玩家收集硬币时进行更新。
- en: 'In Blueprints, there is a function called `Create Widget`, as shown in the
    following screenshot. Without a class assigned, it will be labeled `Construct
    None`, but do not let this confuse you:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图中，有一个名为“Create Widget”的函数，如下面的屏幕截图所示。如果没有分配类，它将被标记为“Construct None”，但不要让这使你困惑：
- en: '![Figure 15.17: The Create widget as it is by default, without a class applied'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.17：默认情况下的Create小部件，没有应用类'
- en: '](img/B16183_15_17.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_17.jpg)'
- en: 'Figure 15.17: The Create widget as it is by default, without a class applied'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.17：默认情况下的Create小部件，没有应用类
- en: 'This function requires the class of the `User` widget to be created and requires
    a `Player Controller` that will be referenced as the owning player of this UI.
    This function then returns the spawned user widget as its `Return Value`, where
    you can then add to the player''s viewport using the `Add to Viewport` function.
    The `Create Widget` function only instantiates the widget object; it does not
    add this widget to the player''s screen. It is the `Add to Viewport` function
    that makes this widget visible on the player''s screen:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数要求创建“User”小部件的类，并需要一个“Player Controller”作为此UI的拥有玩家的引用。然后，此函数将生成的用户小部件作为其“Return
    Value”返回，然后您可以使用“Add to Viewport”函数将其添加到玩家的视口。 “Create Widget”函数只实例化小部件对象；它不会将此小部件添加到玩家的屏幕上。正是“Add
    to Viewport”函数使此小部件在玩家的屏幕上可见。
- en: '![Figure 15.18: Add to Viewport function with ZOrder'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.18：带有ZOrder的Add to Viewport函数'
- en: '](img/B16183_15_18.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_18.jpg)'
- en: 'Figure 15.18: Add to Viewport function with ZOrder'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.18：带有ZOrder的Add to Viewport函数
- en: 'The viewport is the game screen that overlays your view of the game world,
    and it uses what is called `ZOrder` to determine the overlay depth in cases where
    multiple UI elements need to overlap above or below one another. By default, the
    `Add to Viewport` function will add the `User` widget to the screen and make it
    fill the entire screen; that is, unless the `Set Desired Size In Viewport` function
    is called to set the size that it should fill manually:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 视口是游戏屏幕，覆盖了你对游戏世界的视图，并且它使用所谓的“ZOrder”来确定覆盖深度，在多个UI元素需要在彼此上方或下方重叠的情况下。默认情况下，“Add
    to Viewport”函数将把“User”小部件添加到屏幕上，并使其填满整个屏幕；也就是说，除非调用“Set Desired Size In Viewport”函数来手动设置它应该填充的大小：
- en: '![Figure 15.19: The Size parameter determines the desired size of the passed
    in User widget'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.19：Size参数确定传入的User小部件的期望大小'
- en: '](img/B16183_15_19.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_19.jpg)'
- en: 'Figure 15.19: The Size parameter determines the desired size of the passed
    in User widget'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.19：Size参数确定传入的User小部件的期望大小
- en: 'In C++, you also have a function called `CreateWidget()`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，您还有一个名为“CreateWidget（）”的函数：
- en: '[PRE32]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `CreateWidget()` function is available through the `UserWidget` class, which
    can be found in `/Engine/Source/Runtime/UMG/Public/Blueprint/UserWidget.h`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: “CreateWidget（）”函数可通过“UserWidget”类使用，在“/Engine/Source/Runtime/UMG/Public/Blueprint/UserWidget.h”中可以找到。
- en: 'An example of this can be found in *Chapter 8*, *User Interfaces*, where you
    used the `CreateWidget()` function to create `BP_HUDWidget`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在*第8章*“用户界面”中找到一个例子，您可以使用“CreateWidget（）”函数创建“BP_HUDWidget”：
- en: '[PRE33]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Refer back to *Chapter 8*, *User Interfaces*, and *Exercise 8.06,* *Creating
    the Health Bar C++ Logic*, for more information regarding the `CreateWidget()`
    function in C++.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 有关C++中“CreateWidget（）”函数的更多信息，请参阅*第8章*“用户界面”和*Exercise 8.06*“创建健康条C++逻辑”。
- en: This function works almost identically to its Blueprint counterpart because
    it takes in the `Owning Object` parameter, much like the `Owning Player` parameter
    of the Blueprint function, and it requires the `User Widget` class to be created.
    The C++ `CreateWidget()` function also takes in an `FName` parameter to represent
    the widget's name.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数几乎与其蓝图对应函数的工作方式相同，因为它接受“Owning Object”参数，就像蓝图函数的“Owning Player”参数一样，并且需要创建“User
    Widget”类。C++的“CreateWidget（）”函数还接受一个“FName”参数来表示小部件的名称。
- en: Now that we have learned about the methods to use to add UI to the player screen,
    let's put this knowledge to the test. In the following exercise, you will be implementing
    the `Create Widget` and `Add to Viewport` Blueprint functions so that we can add
    the coin collection UI that we created in *Exercise 15.04*, *Creating the Coin
    Counter UI HUD Element*, to the player screen.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了用于向玩家屏幕添加UI的方法，让我们将这些知识付诸实践。在以下练习中，您将实现“Create Widget”和“Add to Viewport”蓝图函数，以便我们可以将我们在*Exercise
    15.04*中创建的硬币收集UI添加到玩家屏幕上。
- en: 'Exercise 15.05: Adding the Coin Counter UI to the Player Screen'
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.05：将硬币计数器UI添加到玩家屏幕
- en: 'In this exercise, you will be creating a new `Player Controller` class so that
    you can use the player controller to add the `BP_UI_CoinCollection` widget Blueprint
    to the player''s screen. From there, you will also create a new `Game Mode` class
    and apply this game mode to the `SuperSideScroller` project. Perform the following
    steps to complete this exercise:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个新的“Player Controller”类，以便您可以使用玩家控制器将“BP_UI_CoinCollection”小部件蓝图添加到玩家的屏幕上。然后，您还将创建一个新的“Game
    Mode”类，并将此游戏模式应用于“SuperSideScroller”项目。执行以下步骤完成此练习：
- en: In the Unreal Engine 4 editor, navigate to `File` and then `New C++ Class`.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚幻引擎4编辑器中，导航到“文件”，然后选择“新建C++类”。
- en: From the `Choose Parent Class` dialog window, find and select the `Player Controller`
    option.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“选择父类”对话框中，找到并选择“Player Controller”选项。
- en: Name the new `Player Controller` class `SuperSideScroller_Controller` and then
    *left-click* the `Create Class` button. Visual Studio will automatically generate
    and open the source and header files for the `SuperSideScroller_Controller` class,
    but for now, we will stay inside the Unreal Engine 4 editor.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的“Player Controller”类命名为“SuperSideScroller_Controller”，然后*左键单击*“创建类”按钮。Visual
    Studio将自动生成并打开“SuperSideScroller_Controller”类的源文件和头文件，但现在我们将留在虚幻引擎4编辑器内。
- en: In the `Content Browser` window, under the `MainCharacter` folder directory,
    create a new folder called `PlayerController`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“内容浏览器”窗口中，在“MainCharacter”文件夹目录下，创建一个名为“PlayerController”的新文件夹。
- en: 'In the `PlayerController` folder, *right-click* and create a new `Blueprint
    Class` using the new `SuperSideScroller_Controller` class. Please refer to the
    following screenshot:![Figure 15.20: Finding the new SuperSideScroller_Controller
    class'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerController`文件夹中，*右键*并使用新的`SuperSideScroller_Controller`类创建一个新的`Blueprint
    Class`。请参考以下截图：![图15.20：找到新的SuperSideScroller_Controller类
- en: to create a new Blueprint from
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的蓝图
- en: '](img/B16183_15_20.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_20.jpg)'
- en: 'Figure 15.20: Finding the new SuperSideScroller_Controller class to create
    a new Blueprint from'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.20：找到新的SuperSideScroller_Controller类以创建一个新的蓝图
- en: Name this new Blueprint `BP_SuperSideScroller_PC` and then *double-left-click*
    the asset to open it.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新的蓝图命名为`BP_SuperSideScroller_PC`，然后*双击*该资产以打开它。
- en: To add the `BP_UI_CoinCollection` widget to the screen, we need to use the `Add
    to Viewport` function and the `Create Widget` function. We want the UI to be added
    to the player's screen after the player character has been `Possessed` by the
    player controller.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`BP_UI_CoinCollection` widget添加到屏幕上，我们需要使用`Add to Viewport`函数和`Create Widget`函数。我们希望在玩家角色被玩家控制器`Possess`之后，将UI添加到玩家的屏幕上。
- en: '*Right-click* inside the Blueprint graph and from the context-sensitive menu,
    find the `Event On Possess` option and *left-click* to add it to the graph. Please
    refer to the following screenshot:![Figure 15.21: The Event On Possess option
    will be called each time'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键*在蓝图图表中，并从上下文敏感菜单中找到`Event On Possess`选项，*左键*将其添加到图表中。请参考以下截图：![图15.21：每次调用Event
    On Possess选项'
- en: this controller class possesses a new pawn
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器类拥有一个新的pawn
- en: '](img/B16183_15_21.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_21.jpg)'
- en: 'Figure 15.21: The Event On Possess option will be called each time this controller
    class possesses a new pawn'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.21：每次这个控制器类拥有一个新的pawn时，将调用Event On Possess选项
- en: The `Event On Possess` event node returns `Possessed Pawn`. We will use this
    pawn to pass into our `BP_UI_CoinCollection UI Widget`, but first, we need to
    `Cast To` the `SuperSideScroller_Player` class.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event On Possess`事件节点返回`Possessed Pawn`。我们将使用这个pawn传递给我们的`BP_UI_CoinCollection
    UI Widget`，但首先，我们需要`Cast To` `SuperSideScroller_Player`类。'
- en: '*Left-click* and drag from the output the `Possessed Pawn` parameter of the
    `Event On Possess` node. Then, search for and find the `Cast to SuperSideScroller_Player`
    node. Please refer to the following screenshot:![Figure 15.22: We need to Cast
    To SuperSideScroller_Player to ensure we are casting to the right player character
    class'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键*并从`Event On Possess`节点的`Possessed Pawn`参数输出中拖动。然后，搜索并找到`Cast to SuperSideScroller_Player`节点。请参考以下截图：![图15.22：我们需要转换为SuperSideScroller_Player以确保我们转换到正确的玩家角色类'
- en: '](img/B16183_15_22.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_22.jpg)'
- en: 'Figure 15.22: We need to Cast To SuperSideScroller_Player to ensure we are
    casting to the right player character class'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.22：我们需要转换为SuperSideScroller_Player以确保我们转换到正确的玩家角色类
- en: Now, *right-click* and search for the `Create Widget` function to add it to
    the Blueprint graph.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，*右键*并搜索`Create Widget`函数将其添加到蓝图图表中。
- en: 'From the drop-down class parameter, find and assign the `BP_UI_CoinCollection`
    asset you created in *Exercise 15.04*, *Creating the Coin Counter UI HUD Element*.
    Please refer to the following screenshot:![Figure 15.23: The Create Widget function
    will create a new UI object'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉类参数中，找到并分配在*Exercise 15.04*中创建的`BP_UI_CoinCollection`资产，*Creating the Coin
    Counter UI HUD Element*。请参考以下截图：![图15.23：Create Widget函数将创建一个新的UI对象
- en: using the UMG class passed into it
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传递给它的UMG类
- en: '](img/B16183_15_23.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_23.jpg)'
- en: 'Figure 15.23: The Create Widget function will create a new UI object using
    the UMG class passed into it'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.23：Create Widget函数将使用传递给它的UMG类创建一个新的UI对象
- en: After updating the `Class` parameter to the `BP_UI_CoinCollection` class, you
    will notice that the `Create Widget` function will update to show the `Player`
    variable you created, set to `Exposed on Spawn`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Class`参数更新为`BP_UI_CoinCollection`类后，您会注意到`Create Widget`函数将更新以显示您创建的`Player`变量，设置为`Exposed
    on Spawn`。
- en: '*Right-click* in the Blueprint graph to search for and find the `Self` reference
    variable from the context-sensitive drop-down menu. Connect the `Self` object
    variable to the `Owning Player` parameter of the `Create Widge`t function, as
    shown in the following screenshot:![Figure 15.24: The Owning Player input parameter
    is of the Player Controller type'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键*在蓝图图表中搜索并找到`Self`引用变量。将`Self`对象变量连接到`Create Widget`函数的`Owning Player`参数，如下图所示：![图15.24：Owning
    Player输入参数是Player Controller类型'
- en: '](img/B16183_15_24.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_24.jpg)'
- en: 'Figure 15.24: The Owning Player input parameter is of the Player Controller
    type'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.24：Owning Player输入参数是Player Controller类型
- en: The `Owning Player` parameter refers to the `Player Controller` type that will
    show and own this UI object. Since we are adding this UI to the `SuperSideScroller_Controller`
    Blueprint, we can just use the `Self` reference variable to pass into the function.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`拥有玩家`参数是指将显示和拥有此UI对象的`Player Controller`类型。由于我们将此UI添加到`SuperSideScroller_Controller`蓝图中，我们可以直接使用`Self`引用变量传递给函数。'
- en: 'Next, pass in the returned `SuperSideScroller_Player` variable from the `Cast`
    node to the `Player` input node of the `Create Widget` function. Then, connect
    the execution pins of the `Cast` node and the `Create Widget` function, as shown
    in the following screenshot:![Figure 15.25: If the Cast To SuperSideScroller_Player
    is valid, we can create the BP_UI_CoinCollection widget and pass in the player
    that has been possessed'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将返回的`SuperSideScroller_Player`变量从`Cast`节点传递到`Create Widget`函数的`Player`输入节点。然后，连接`Cast`节点和`Create
    Widget`函数的执行引脚，如下图所示：![图15.25：如果Cast To SuperSideScroller_Player有效，我们可以创建BP_UI_CoinCollection
    widget并传递被占有的玩家
- en: '](img/B16183_15_25.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_25.jpg)'
- en: 'Figure 15.25: If the Cast To SuperSideScroller_Player is valid, we can create
    the BP_UI_CoinCollection widget and pass in the player that has been possessed'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.25：如果Cast To SuperSideScroller_Player有效，我们可以创建BP_UI_CoinCollection widget并传递被占有的玩家
- en: Note
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3f89m99](https://packt.live/3f89m99).'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到前面截图的全分辨率以获得更好的查看体验：[https://packt.live/3f89m99](https://packt.live/3f89m99)。
- en: '*Right-click* inside the Blueprint graph again to search and find the `Add
    to Viewport` function so that you can place it in the graph.'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*蓝图图表内部再次搜索并找到`Add to Viewport`函数，以便将其放置在图表中。'
- en: Connect the output `Return Value` parameter of the `Create Widget` function
    to the `Target` input parameter of the `Add to Viewport` function; do not change
    the `ZOrder` parameter.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Create Widget`函数的输出`Return Value`参数连接到`Add to Viewport`函数的`Target`输入参数；不要更改`ZOrder`参数。
- en: 'Lastly, connect the execution pins of the `Create Widget` and `Add to Viewport`
    functions, as shown here:![Figure 15.26: After creating the BP_UI_CoinCollection
    widget, we can'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，连接`Create Widget`和`Add to Viewport`函数的执行引脚，如下所示：![图15.26：创建完BP_UI_CoinCollection小部件后，我们可以
- en: add it to the player viewport
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 将其添加到玩家视口
- en: '](img/B16183_15_26.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_26.jpg)'
- en: 'Figure 15.26: After creating the BP_UI_CoinCollection widget, we can add it
    to the player viewport'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.26：创建完BP_UI_CoinCollection小部件后，我们可以将其添加到玩家视口
- en: Note
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/2UwufBd](https://packt.live/2UwufBd).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到前面截图的全分辨率以获得更好的查看体验：[https://packt.live/2UwufBd](https://packt.live/2UwufBd)。
- en: Now that the player controller adds the `BP_UI_CoinCollection` widget to the
    player's viewport, we need to create a `GameMode` Blueprint and apply both the
    `BP_SuperSideScroller_MainCharacter` and `BP_SuperSideScroller_PC` classes to
    this game mode.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩家控制器将`BP_UI_CoinCollection`小部件添加到玩家视口，我们需要创建一个`GameMode`蓝图，并将`BP_SuperSideScroller_MainCharacter`和`BP_SuperSideScroller_PC`类应用到这个游戏模式中。
- en: In the `Content Browser` window, create a new folder by *right-clicking* the
    `Content` folder and selecting `New Folder`. Name this folder `GameMode`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content Browser`窗口中，通过*右键单击*`Content`文件夹并选择`New Folder`来创建一个新文件夹。将此文件夹命名为`GameMode`。
- en: Next, *right-click* and select `Blueprint Class` to begin creating the game
    mode Blueprint. From the `Pick Parent Class` dialog window, search for and find
    `SuperSideScrollerGameMode` under `All Classes`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，*右键单击*并选择`Blueprint Class`开始创建游戏模式蓝图。从`Pick Parent Class`对话框中搜索并找到`SuperSideScrollerGameMode`，位于`All
    Classes`下。
- en: Name this new `GameMode` Blueprint `BP_SuperSideScroller_GameMode`. *Double-left-click*
    this asset to open it.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新的`GameMode`蓝图命名为`BP_SuperSideScroller_GameMode`。*双击*此资产以打开它。
- en: The `GameMode` Blueprint contains a list of classes that you can customize with
    your unique classes. For now, we will only worry about `Player Controller Class`
    and `Default Pawn Class`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameMode`蓝图包含一个类列表，您可以使用自己的类进行自定义。目前，我们只需要担心`Player Controller Class`和`Default
    Pawn Class`。'
- en: '*Left-click* the `Player Controller Class` dropdown to find and select the
    `BP_SuperSideScroller_PC` Blueprint you created earlier in this exercise.'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*左键单击*`Player Controller Class`下拉菜单，找到并选择之前在此练习中创建的`BP_SuperSideScroller_PC`蓝图。'
- en: Then, *left-click* the `Default Pawn Class` dropdown to find and select the
    `BP_SuperSideScroller_MainCharacter` Blueprint.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，*左键单击*`Default Pawn Class`下拉菜单，找到并选择`BP_SuperSideScroller_MainCharacter`蓝图。
- en: Now that we have a custom `GameMode` that utilizes our custom `Player Controller`
    and `Player Character` classes, let's add this game mode to the `Project Settings`
    window so that the game mode is used by default when using PIE and when cooking
    builds of the project.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个自定义的`GameMode`，它利用我们自定义的`Player Controller`和`Player Character`类，让我们将这个游戏模式添加到`Project
    Settings`窗口，这样在使用PIE和构建项目时，默认情况下会使用游戏模式。
- en: From the Unreal Engine 4 editor, navigate to the `Edit` option at the top of
    the screen. *Left-click* this option and from the drop-down menu, find and select
    the `Project Settings` option.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Unreal Engine 4编辑器中，导航到屏幕顶部的`Edit`选项。*左键单击*此选项，并从下拉菜单中找到并选择`Project Settings`选项。
- en: On the left-hand side of the `Project Settings` window, you are provided with
    a list of categories divided into sections. Under the `Project` section, *left-click*
    the `Maps & Modes` category.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Project Settings`窗口的左侧，您将看到一个分成几个部分的类别列表。在`Project`部分下，*左键单击*`Maps & Modes`类别。
- en: In the `Maps & Modes` section, you have a handful of parameters related to your
    project's default maps and game mode. At the top of this section, you have the
    `Default GameMode` option. *Left-click* this dropdown to find and select the `SuperSideScroller_GameMode`
    Blueprint you created earlier in this exercise.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Maps & Modes`部分，您有一些与项目默认地图和游戏模式相关的参数。在此部分的顶部，您有`Default GameMode`选项。*左键单击*此下拉菜单，找到并选择之前在此练习中创建的`SuperSideScroller_GameMode`蓝图。
- en: Note
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Changes made to the `Maps & Modes` section are automatically saved and written
    to the `DefaultEngine.ini` file, which can be found in your project's `Config`
    folder. `Default GameMode` can be overwritten per level by updating the `GameMode
    Override` parameter, which can be found in the `World Settings` window of your
    level.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Maps & Modes`部分的更改会自动保存并写入`DefaultEngine.ini`文件，该文件位于项目的`Config`文件夹中。可以通过更新`GameMode
    Override`参数来覆盖每个级别的`Default GameMode`，该参数位于级别的`World Settings`窗口中。
- en: 'Close the `Project Settings` window and return to your level. Use PIE and start
    collecting coins. Observe that the `BP_UI_CoinCollection` widget is shown and
    updated each time you collect a coin, as shown in the following screenshot:![Figure
    15.27: Now, every coin you collect will appear on the player UI'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`Project Settings`窗口并返回到您的级别。使用PIE并开始收集硬币。观察到每次收集硬币时，`BP_UI_CoinCollection`小部件都会显示并更新，如下图所示：![图15.27：现在，您收集的每个硬币都将显示在玩家UI上
- en: '](img/B16183_15_27.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_27.jpg)'
- en: 'Figure 15.27: Now, every coin you collect will appear on the player UI'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.27：现在，您收集的每个硬币都将显示在玩家UI上
- en: Note
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the assets and code for this exercise here: [https://packt.live/2JRfSFz](https://packt.live/2JRfSFz).'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到此练习的资产和代码：[https://packt.live/2JRfSFz](https://packt.live/2JRfSFz)。
- en: With this exercise complete, you have created the `UI UMG` widget needed to
    display the current number of coins collected by the player. By using the `GetCurrentNumberofCollectables()`
    C++ function and the binding functionality of the `Text` widget, the UI will always
    update its value based on the number of coins collected.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此练习后，您已经创建了“UI UMG”小部件，该小部件用于显示玩家收集的当前硬币数量。通过使用“GetCurrentNumberofCollectables()”C++函数和“Text”小部件的绑定功能，UI将根据收集的硬币数量始终更新其值。
- en: So far, we have focused on the collectible coin and allowing players to collect
    these coins and add the total coins collected to the player's UI. Now, we will
    focus on the potion power-up and granting movement speed and jump height increases
    to the player for a short period of time. To implement this functionality, we
    first need to study timers.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经专注于可收集的硬币，并允许玩家收集这些硬币并将总硬币数添加到玩家的UI中。现在，我们将专注于药水增益，并为玩家在短时间内提供移动速度和跳跃高度增加。为了实现这个功能，我们首先需要研究计时器。
- en: Timers
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时器
- en: Timers in Unreal Engine 4 allow you to perform actions after a delay or every
    X number of seconds. In the case of the `SuperSideScroller` potion power-up, a
    timer will be used to restore the player's movement and jump to their defaults
    after 8 seconds.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎4中的计时器允许您在延迟后执行操作，或者每隔X秒执行一次。在“SuperSideScroller”药水增益的情况下，将使用计时器在8秒后将玩家的移动和跳跃恢复到默认状态。
- en: Note
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Blueprints, you can use a Delay node in addition to Timer Handles to achieve
    the same results. However, in C++, Timers are the best means to achieve delays
    and reoccurring logic.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图中，您可以使用延迟节点以及计时器句柄来实现相同的结果。但是，在C++中，计时器是实现延迟和重复逻辑的最佳手段。
- en: 'Timers are managed by `Timer Manager`, or `FTimerManager`, which exists in
    the `UWorld` object. There are two main functions that you will be using from
    the `FTimerManager` class, called `SetTimer()` and `ClearTimer()`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器由“计时器管理器”或“FTimerManager”管理，它存在于“UWorld”对象中。您将从“FTimerManager”类中使用的两个主要函数称为“SetTimer()”和“ClearTimer()”：
- en: '[PRE34]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You may have noticed that, in both functions, there is a required `FTimerHandle`.
    This handle is used to control the timer you have set. Using this handle, you
    can pause, resume, clear, and even extend the timer.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在两个函数中都需要“FTimerHandle”。此句柄用于控制您设置的计时器。使用此句柄，您可以暂停、恢复、清除甚至延长计时器。
- en: The `SetTimer()` function also has other parameters to help you customize this
    `Timer` when initially setting it. The callback function will be called after
    the `Timer` has been completed, and if the `InbLoop` parameter is `True`, it will
    continue to call the callback function indefinitely, until the timer has been
    stopped. The `InRate` parameter is the duration of the timer itself, while `InFirstDelay`
    is an initial delay that's applied to the timer before it begins its timer for
    `InRate`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: “SetTimer()”函数还有其他参数可帮助您在最初设置计时器时自定义此“计时器”。回调函数将在“计时器”完成后调用，如果“InbLoop”参数为“True”，则它将继续无限期调用回调函数，直到计时器停止。
    “InRate”参数是计时器本身的持续时间，而“InFirstDelay”是在计时器开始计时之前应用于计时器的初始延迟。
- en: 'The header file for the `FTimerManager` class can be found here: `/Engine/Source/Runtime/Engine/Public/TimerManager.h`.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: “FTimerManager”类的头文件可以在此处找到：/Engine/Source/Runtime/Engine/Public/TimerManager.h。
- en: Note
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more about timers and `FTimerHandle` by reading the documentation
    here: [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Timers/index.html](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Timers/index.html).'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过阅读此处的文档了解有关计时器和“FTimerHandle”的更多信息：[https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Timers/index.html](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Timers/index.html)。
- en: In the following exercise, you will create your own `FTimerHandle` in the `SuperSideScroller_Player`
    class and use it to handle to control how long the effects of the potion power-up
    last on the player.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，您将在“SuperSideScroller_Player”类中创建自己的“FTimerHandle”，并使用它来控制药水增益对玩家的持续时间。
- en: 'Exercise 15.06: Adding the Potion Power-Up Behavior to the Player'
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.06：将药水增益行为添加到玩家
- en: 'In this exercise, you will be creating the logic behind the potion power-up
    and how it will affect the player character. You will take advantage of timers
    and timer handles to ensure that the power-up effects only last for a short duration.
    Follow these steps to accomplish this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在此练习中，您将创建药水增益背后的逻辑，以及它将如何影响玩家角色。您将利用计时器和计时器句柄，以确保增益效果只持续很短的时间。按照以下步骤完成此操作：
- en: In Visual Studio, navigate to and open the `SuperSideScroller_Player.h` header
    file.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，导航到并打开“SuperSideScroller_Player.h”头文件。
- en: 'Under `our Private Access Modifier`, add a new variable of the `FTimerHandle`
    type and name it `PowerupHandle`:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“我们的私有访问修饰符”下，添加一个名为“PowerupHandle”的“FTimerHandle”类型的新变量：
- en: '[PRE35]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This timer handle will be responsible for keeping track of how much time has
    elapsed since it was initiated. This will allow us to control how long the potion
    power-up's effects will last.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 此计时器句柄将负责跟踪自启动以来经过的时间。这将允许我们控制药水增益效果持续多长时间。
- en: 'Next, add a Boolean variable under our `Private Access Modifier` called `bHasPowerupActive`:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的“私有访问修饰符”下添加一个名为“bHasPowerupActive”的布尔变量：
- en: '[PRE36]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We will use this Boolean variable when updating the `Sprint()` and `StopSprinting()`
    functions to ensure we update the player's sprint movement speed appropriately
    based on whether the power-up is active.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新“Sprint()”和“StopSprinting()”函数时，我们将使用此布尔变量来确保根据增益是否激活来适当更新玩家的冲刺移动速度。
- en: 'Next, declare a new void function called `IncreaseMovementPowerup()` under
    our `Public Access Modifier`:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的“公共访问修饰符”下声明一个名为“IncreaseMovementPowerup()”的新void函数：
- en: '[PRE37]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is the function that will be called from the potion power-up class to enable
    the effects of the power-up for the player.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将从药水增益类调用的函数，以启用玩家的增益效果。
- en: 'Finally, you need to create a function that handles when the power-up effects
    end. Create a function called `EndPowerup()` under `Protected Access Modifier`:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您需要创建一个处理电源增强效果结束时的函数。在`Protected Access Modifier`下创建一个名为`EndPowerup()`的函数：
- en: '[PRE38]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With all the necessary variables and functions declared, it's time to start
    defining these new functions and handling the power-up effects on the player.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有必要的变量和声明的函数，现在是时候开始定义这些新函数并处理玩家的电源增强效果了。
- en: Navigate to the `SuperSideScroller_Player.cpp` source file.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`SuperSideScroller_Player.cpp`源文件。
- en: First, add the header file `#include "TimerManager.h"` to the top of the source
    file; we will need this class in order to use `Timers`.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在源文件的顶部添加头文件`#include "TimerManager.h"`；我们将需要这个类来使用`Timers`。
- en: 'Define the `IncreaseMovementPowerup()` function by adding the following code
    to the source file:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在源文件中添加以下代码来定义`IncreaseMovementPowerup()`函数：
- en: '[PRE39]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When this function is called, the first thing we need to do is set the `bHasPowerupActive`
    variable to `true`. Add the following code to the `IncreaseMovementPowerup()`
    function:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调用此函数时，我们需要做的第一件事是将`bHasPowerupActive`变量设置为`true`。将以下代码添加到`IncreaseMovementPowerup()`函数中：
- en: '[PRE40]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, add the following code to increase both the `MaxWalkSpeed` and `JumpZVelocity`
    components of the player character movement component:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下代码来增加玩家角色移动组件的`MaxWalkSpeed`和`JumpZVelocity`组件：
- en: '[PRE41]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we are changing `MaxWalkSpeed` from the default `300.0f` value to `500.0f`.
    As you may recall, the default sprinting speed is also `500.0f`. We will address
    this later in this activity to increase the sprinting speed when the power-up
    is active.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`MaxWalkSpeed`从默认值`300.0f`更改为`500.0f`。您可能还记得，默认的冲刺速度也是`500.0f`。我们将在本活动的后续部分中解决这个问题，以在电源增强状态下增加冲刺速度。
- en: 'To take advantage of timers, we need to get a reference to the `UWorld` object.
    Add the following code:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用计时器，我们需要获得对`UWorld`对象的引用。添加以下代码：
- en: '[PRE42]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As we've done many times before in this project, we're using the `GetWorld()`
    function to get a reference to the `UWorld` object and saving this reference in
    its variable.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 与项目中以前做过的许多次一样，我们使用`GetWorld()`函数来获取对`UWorld`对象的引用，并将此引用保存在其变量中。
- en: 'Now that we have the reference to the `World` object and have performed a validity
    check, it is safe to use the `TimerManager` to set the power-up timer. Add the
    following code within the `if()` statement shown in the previous step:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了对`World`对象的引用，并且已经执行了有效性检查，可以安全地使用`TimerManager`来设置电源增强计时器。在上一步中显示的`if()`语句中添加以下代码：
- en: '[PRE43]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, you are using the `TimerManager` class to set a timer. The `SetTimer()`
    function takes in the `FTimerHandle` component to use; in this case, the `PowerupHandle`
    variable you created. Next, we need to pass in a reference to the player class
    by using the `this` keyword. Then, we need to provide the callback function to
    call after the timer has ended, which in this case is the `&ASuperSideScroller_Player::EndPowerup`
    function. `8.0f` represents the duration of the timer; feel free to adjust this
    as you see fit, but for now, 8 seconds is fine. Lastly, there is the parameter
    that determines whether this timer should loop; in this case, it should not.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您正在使用`TimerManager`类来设置计时器。`SetTimer()`函数接受要使用的`FTimerHandle`组件；在这种情况下，是您创建的`PowerupHandle`变量。接下来，我们需要通过使用`this`关键字传递对玩家类的引用。然后，我们需要提供在计时器结束后调用的回调函数，这种情况下是`&ASuperSideScroller_Player::EndPowerup`函数。`8.0f`表示计时器的持续时间；随时根据需要进行调整，但目前8秒是可以的。最后，还有一个参数，用于确定此计时器是否应该循环；在这种情况下，不应该循环。
- en: 'Create the function definition for the `EndPowerup()` function:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`EndPowerup()`函数的函数定义：
- en: '[PRE44]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The first thing to do when the `EndPowerup()` function is called is set the
    `bHasPowerupActive` variable to `false`. Add the following code within the `EndPowerup()`
    function:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调用`EndPowerup()`函数时，首先要做的是将`bHasPowerupActive`变量设置为`false`。在`EndPowerup()`函数中添加以下代码：
- en: '[PRE45]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, change the `MaxWalkSpeed` and `JumpZVelocity` parameters of the character
    movement component back to their default values. Add the following code:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将角色移动组件的`MaxWalkSpeed`和`JumpZVelocity`参数更改回它们的默认值。添加以下代码：
- en: '[PRE46]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we are changing both the `MaxWalkSpeed` and `JumpZVelocity` parameters
    of the character movement component to their default values.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在将角色移动组件的`MaxWalkSpeed`和`JumpZVelocity`参数都更改为它们的默认值。
- en: 'Again, to take advantage of the timers and to clear the timer to handle `PowerupHandle`,
    we need to get a reference to the `UWorld` object. Add this code:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次利用计时器并清除`PowerupHandle`的计时器处理，我们需要获得对`UWorld`对象的引用。添加以下代码：
- en: '[PRE47]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we can add the code to clear the timer handle''s `PowerupHandle`:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以添加代码来清除计时器句柄的`PowerupHandle`：
- en: '[PRE48]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: By using the `ClearTimer()` function and passing in `PowerupHandle`, we are
    ensuring that this timer is no longer valid and will no longer affect the player.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`ClearTimer()`函数并传入`PowerupHandle`，我们确保此计时器不再有效，并且不再影响玩家。
- en: Now that we have created the functions that handle the power-up effects and
    the timer associated with the effects, we need to update both the `Sprint()` and
    `StopSprinting()` functions so that they also take into account the speed of the
    player when the power-up is active.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了处理电源增强效果和与效果相关的计时器的函数，我们需要更新`Sprint()`和`StopSprinting()`函数，以便它们在玩家处于电源增强状态时也考虑到速度。
- en: 'Update the `Sprint()` function to the following:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Sprint()`函数更新为以下内容：
- en: '[PRE49]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, we are updating the `Sprint()` function to take into account whether
    `bHasPowerupActive` is true. If this variable is true, then we increase `MaxWalkSpeed`
    while sprinting from `500.0f` to `900.0f`, as shown here:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在更新`Sprint()`函数以考虑`bHasPowerupActive`是否为true。如果此变量为true，则我们在冲刺时将`MaxWalkSpeed`从`500.0f`增加到`900.0f`，如下所示：
- en: '[PRE50]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If `bHasPowerupActive` is false, then we increase `MaxWalkSpeed` to `500.0f`,
    as we did by default.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`bHasPowerupActive`为false，则我们将`MaxWalkSpeed`增加到`500.0f`，就像默认情况下一样。
- en: 'Update the `StopSprinting()` function to the following:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`StopSprinting()`函数更新为以下内容：
- en: '[PRE51]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here, we are updating the `StopSprinting()` function to take into account whether
    `bHasPowerupActive` is true. If this variable is true, then we set the `MaxWalkSpeed`
    value to `500.0f` instead of `300.0f`, as shown here:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们更新`StopSprinting()`函数，以考虑`bHasPowerupActive`是否为真。如果这个变量为真，则将`MaxWalkSpeed`值设置为`500.0f`，而不是`300.0f`，如下所示：
- en: '[PRE52]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If `bHasPowerupActive` is false, then we set `MaxWalkSpeed` to `300.0f`, as
    we did by default.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`bHasPowerupActive`为假，则将`MaxWalkSpeed`设置为`300.0f`，就像默认情况下一样。
- en: Finally, all we need to do is recompile the C++ code.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只需要重新编译C++代码。
- en: Note
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the assets and code for this exercise here: [https://packt.live/3eP39yL](https://packt.live/3eP39yL).'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到这个练习的资产和代码：[https://packt.live/3eP39yL](https://packt.live/3eP39yL)。
- en: With this exercise complete, you have created the potion power-up effects within
    the player character. The power-up increases both the default movement speed of
    the player and increases their jump height. Moreover, the effects of the power-up
    increase the sprinting speed. By using timer handles, you were able to control
    how long the power-up effect would last.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，您已经在玩家角色中创建了药水增益效果。增益效果增加了玩家的默认移动速度，并增加了他们的跳跃高度。此外，增益效果还增加了奔跑速度。通过使用计时器句柄，您能够控制增益效果持续的时间。
- en: Now, it is time to create the potion power-up actor so that we can have a representation
    of this power-up in the game.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建药水增益角色了，这样我们就可以在游戏中有一个这个增益的表示了。
- en: 'Activity 15.03: Creating the Potion Power-Up Actor'
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动15.03：创建药水增益角色
- en: 'Now that the `SuperSideScroller_Player` class handles the effects of the potion
    power-up, it''s time to create the potion power-up class and Blueprint. The aim
    of this activity is to create the potion power-up class, inherit from the `PickableActor_Base`
    class, implement the overlap functionality to grant the movement effects that
    you implemented in *Exercise 15.06*, *Adding the Potion Power-Up Behavior to the
    Player*, and to create the Blueprint actor for the potion power-up. Perform these
    steps to create the potion power-up class and to create the potion Blueprint actor:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`SuperSideScroller_Player`类处理了药水增益的效果，是时候创建药水增益类和蓝图了。这个活动的目的是创建药水增益类，继承自`PickableActor_Base`类，实现重叠功能以授予您在*练习15.06*中实现的移动效果，*将药水增益行为添加到玩家*，并创建药水蓝图角色。执行这些步骤来创建药水增益类和创建药水蓝图角色：
- en: Create a new C++ class that inherits from the `PickableActor_Base` class and
    name this new class `PickableActor_Powerup`.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++类，继承自`PickableActor_Base`类，并将这个新类命名为`PickableActor_Powerup`。
- en: Add the override function declarations for both the `BeginPlay()` and `PlayerPickedUp()`
    functions.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`BeginPlay()`和`PlayerPickedUp()`函数的重写函数声明。
- en: Create the function definition for the `BeginPlay()` function. Within the `BeginPlay()`
    function, add the call to the parent class function.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`BeginPlay()`函数创建函数定义。在`BeginPlay()`函数中，添加对父类函数的调用。
- en: Create the function definition for the `PlayerPickedUp()` function. Within the
    `PlayerPickedUp()` function, add the call to the `PlayerPickedUp()` parent class
    function.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`PlayerPickedUp()`函数创建函数定义。在`PlayerPickedUp()`函数中，添加对`PlayerPickedUp()`父类函数的调用。
- en: Next, add the necessary `#include` file for the `SuperSideScroller_Player` class
    so that we can reference the player class and its functions.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`#include`文件，引用`SuperSideScroller_Player`类，以便我们可以引用玩家类及其函数。
- en: In the `PlayerPickedUp()` function, use the `Player` input parameter of the
    function itself to make the function call to `IncreaseMovementPowerup()`.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlayerPickedUp()`函数中，使用函数本身的`Player`输入参数来调用`IncreaseMovementPowerup()`函数。
- en: From `Epic Games Launcher`, find the `Action RPG` project from the `Learn` tab,
    under the `Games` category. Use this to create and install a new project.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Epic Games Launcher`中，在`Learn`选项卡的`Games`类别下找到`Action RPG`项目。使用这个来创建并安装一个新项目。
- en: Migrate the `A_Character_Heal_Mana_Cue` and `SM_PotionBottle` assets, as well
    as all of their referenced assets, from the `Action RPG` project to your `SuperSideScroller`
    project.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`A_Character_Heal_Mana_Cue`和`SM_PotionBottle`资产以及它们所有引用的资产从`Action RPG`项目迁移到您的`SuperSideScroller`项目。
- en: Create a new folder in the `Content Browser` window within the `PickableItems`
    directory called `Powerup`. Create a new Blueprint within this directory based
    on the `PickableActor_Powerup` class and name this asset `BP_Powerup`.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PickableItems`目录中的`Content Browser`窗口中创建一个名为`Powerup`的新文件夹。在该目录中基于`PickableActor_Powerup`类创建一个新的蓝图，并将此资产命名为`BP_Powerup`。
- en: In `BP_Powerup`, update the `MeshComp` component in order to use the `SM_PotionBottle`
    static mesh.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BP_Powerup`中，更新`MeshComp`组件以使用`SM_PotionBottle`静态网格。
- en: Next, add `A_Character_Heal_Mana_Cue`, which you imported as the `Pickup Sound`
    parameter.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`A_Character_Heal_Mana_Cue`，将其导入为`Pickup Sound`参数。
- en: Finally, update the `RotationComp` component so that the actor will rotate 60
    degrees per second around the `Pitch` axis and rotate 180 degrees per second around
    the `Yaw` axis.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新`RotationComp`组件，使得角色每秒绕`Pitch`轴旋转60度，绕`Yaw`轴旋转180度。
- en: Add `BP_Powerup` to your level and use PIE to observe the results when overlapping
    with the power-up.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BP_Powerup`添加到您的级别中，并使用PIE观察与增益重叠时的结果。
- en: 'Expected output:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出：
- en: '![Figure 15.28: The potion power-up now has a nice visual representation and
    can be overlapped by the player to enable its power-up effects'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.28：药水增益现在有了一个很好的视觉表示，玩家可以重叠以启用其增益效果'
- en: '](img/B16183_15_28.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_28.jpg)'
- en: 'Figure 15.28: The potion power-up now has a nice visual representation and
    can be overlapped by the player to enable its power-up effects'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.28：药水增益现在有了一个很好的视觉表示，玩家可以重叠以启用其增益效果
- en: Note
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在这里找到：[https://packt.live/338jEBx](https://packt.live/338jEBx)。
- en: With this activity complete, you were able to put your knowledge to the test
    in terms of creating a new C++ class that inherits from the `PickableActor_Base`
    class and overrides the `PlayerPickedUp()` function to add custom logic. By adding
    the call to the `IncreaseMovementPowerup()` function from the player class, you
    were able to add the movement power-up effects to the player when overlapping
    with the actor. Then, by using a custom mesh, material, and audio assets, you
    were able to bring the Blueprint actor to life from the `PickableActor_Powerup`
    class.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，您能够在创建一个新的C++类方面进行知识测试，该类继承自`PickableActor_Base`类，并覆盖`PlayerPickedUp()`函数以添加自定义逻辑。通过从玩家类中添加对`IncreaseMovementPowerup()`函数的调用，您能够在与该角色重叠时为玩家添加移动增益效果。然后，通过使用自定义网格、材质和音频资产，您能够从`PickableActor_Powerup`类中为蓝图角色赋予生命。
- en: 'Now that we have created the coin collectible and the potion power-up, we need
    to implement a new gameplay feature into the project: the `Brick` class. In games
    such as Super Mario, bricks contain hidden coins and power-ups for the players
    to find. These bricks also serve as a means of reaching elevated platforms and
    areas within the level. In our `SuperSideScroller` project, the `Brick` class
    will serve the purpose of containing hidden coin collectibles for the player,
    and as a means of allowing the player to reach areas of the level by using the
    bricks as paths to access hard-to-reach locations. So, in the next section, we
    will create the `Brick` class that needs to be broken to find the hidden coins.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了硬币可收集物品和药水增益，我们需要将一个新的游戏功能实现到项目中：`Brick`类。在超级马里奥等游戏中，砖块中包含玩家可以找到的隐藏硬币和增益物品。这些砖块还可以用作到达高架平台和关卡内区域的手段。在我们的`SuperSideScroller`项目中，`Brick`类将用于包含玩家的隐藏硬币可收集物品，并作为允许玩家通过使用砖块作为路径来访问难以到达位置的手段。因此，在下一节中，我们将创建需要被打破以找到隐藏硬币的`Brick`类。
- en: 'Exercise 15.07: Creating the Brick Class'
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.07：创建Brick类
- en: 'Now that we have created the coin collectible and the potion power-up, it is
    time to create the `Brick` class, which will contain hidden coins for the player.
    The brick is the final gameplay element of the `SuperSideScroller` project. In
    this exercise, you will be creating the `Brick` class, which will be used as part
    of the platforming mechanic of the `SuperSideScroller` game project, but also
    as a means to hold collectibles for players to find. Follow these steps to create
    this `Brick` class and its Blueprint:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了硬币可收集物品和药水增益，是时候创建`Brick`类了，这将为玩家包含隐藏的硬币。砖块是`SuperSideScroller`项目的最终游戏元素。在这个练习中，您将创建`Brick`类，这将作为`SuperSideScroller`游戏项目的平台机制的一部分使用，同时也作为一个容纳玩家可收集物品的手段。按照以下步骤创建`Brick`类及其蓝图：
- en: In the Unreal Engine 4 editor, navigate to `File` and then `New C++ Class`.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在虚幻引擎4编辑器中，导航到`文件`，然后选择`新建C++类`。
- en: From the `Choose Parent Class` dialog window, find and select the `Actor` class.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`选择父类`对话框中，找到并选择`Actor`类。
- en: Name this class `SuperSideScroller_Brick` and *left-click* `Create Class`. Visual
    Studio and Unreal Engine will recompile the code and open this class for you.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此类命名为`SuperSideScroller_Brick`并*左键单击*`Create Class`。Visual Studio和虚幻引擎将重新编译代码并为您打开此类。
- en: By default, the `SuperSideScroller_Brick` class comes with the `Tick()` function,
    but we will not need this function for the `Brick` class. Remove the function
    declaration for `Tick()` from the `SuperSideScroller_Brick.h` header file and
    remove the function definition from the `SuperSideScroller_Brick.cpp` source file
    before continuing.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`SuperSideScroller_Brick`类带有`Tick()`函数，但我们不需要这个函数用于`Brick`类。在继续之前，从`SuperSideScroller_Brick.h`头文件中删除`Tick()`函数声明，并从`SuperSideScroller_Brick.cpp`源文件中删除函数定义。
- en: 'Under the `Private Access Modifier` for the `SuperSideScroller_Brick.h` file,
    add the following code to declare a new `UStaticMeshComponent* UPROPERTY()` function
    to represent the brick in our game world:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SuperSideScroller_Brick.h`文件的`Private Access Modifier`下，添加以下代码来声明一个新的`UStaticMeshComponent*
    UPROPERTY()`函数，以表示游戏世界中的砖块：
- en: '[PRE53]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we need to create a `UBoxComponent UPROPERTY()` that will handle the
    collision with the player character. Add the following code to add this component
    under our `Private Access Modifier`:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个`UBoxComponent UPROPERTY()`，用于处理与玩家角色的碰撞。在我们的`Private Access Modifier`下添加以下代码来添加这个组件：
- en: '[PRE54]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create the `UFUNCTION()` declaration for the `OnHit()` function under our `Private
    Access Modifier`. This will be used to determine when `UBoxComponent` is hit by
    the player:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`Private Access Modifier`下创建`UFUNCTION()`声明`OnHit()`函数。这将用于确定`UBoxComponent`何时被玩家击中：
- en: '[PRE55]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Recall that you used the `OnHit()` function when developing the `PlayerProjectile`
    class in *Chapter 13*, *Enemy Artificial Intelligence*, for this project. Please
    review that chapter for more information about the `OnHit()` function.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中开发`PlayerProjectile`类时，您在*第13章* *敌人人工智能*中使用了`OnHit()`函数。请查看该章节以获取有关`OnHit()`函数的更多信息。
- en: 'Next, create a new Boolean `UPROPERTY()` under our `Private Access Modifier`
    using the `EditAnywhere` keyword called `bHasCollectable`:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的`Private Access Modifier`下创建一个新的布尔`UPROPERTY()`，使用`EditAnywhere`关键字，命名为`bHasCollectable`：
- en: '[PRE56]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This Boolean will determine whether the brick contains a coin collectible for
    the player.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这个布尔值将确定砖块是否包含玩家的硬币可收集物品。
- en: 'Now, we need a variable that holds how many coin collectibles are available
    within this brick for the player. We will do this by creating an integer variable
    called `Collectable Value`. Make this a `UPROPERTY()`, under the `private access
    modifier`, with the `EditAnywhere` keyword, and give it a default value of `1`,
    as shown here:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个变量来保存此砖块中有多少硬币可收集物品供玩家使用。我们将通过创建一个名为`Collectable Value`的整数变量来实现这一点。将其放在`private
    access modifier`下，使用`EditAnywhere`关键字，并将其默认值设置为`1`，如下所示：
- en: '[PRE57]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The brick will need to contain a unique sound and particle system so that it
    has a nice layer of polish for when the brick is destroyed by the player. We'll
    add these properties next.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 砖块将需要包含一个独特的声音和粒子系统，以便在玩家摧毁砖块时具有良好的光泽层。我们将在下面添加这些属性。
- en: Create a new `Public Access Modifier` in the `SuperSideScroller_Brick.h` header
    file.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“SuperSideScroller_Brick.h”头文件中创建一个新的“Public Access Modifier”。
- en: 'Next, create a new `UPROPERTY()` using the `EditAnywhere` and `BlueprintReadOnly`
    keywords for a variable of the `USoundBase` class. Name this variable `HitSound`,
    as shown here:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用“EditAnywhere”和“BlueprintReadOnly”关键字为“USoundBase”类的变量创建一个新的“UPROPERTY()”。将此变量命名为“HitSound”，如下所示：
- en: '[PRE58]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then, create a new `UPROPERTY()` using the `EditAnywhere` and `BlueprintReadOnly`
    keywords for a variable of the `UParticleSystem` class. Make sure to put this
    under the `public access modifier`, and name this variable `Explosion`, as shown
    here:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用“EditAnywhere”和“BlueprintReadOnly”关键字为“UParticleSystem”类的变量创建一个新的“UPROPERTY()”。确保将其放在“public
    access modifier”下，并将此变量命名为“Explosion”，如下所示：
- en: '[PRE59]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now that we have all the necessary properties for the `Brick` class, let's move
    onto the `SuperSideScroller_Brick.cpp` source file, where we will initialize the
    components.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为“Brick”类准备好了所有必要的属性，让我们继续进行“SuperSideScroller_Brick.cpp”源文件，在那里我们将初始化组件。
- en: 'Let''s start by adding the following `#include` directories for `StaticMeshComponent`
    and `BoxComponent`. Add the following code to the `#include` list of the source
    file:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先添加以下用于“StaticMeshComponent”和“BoxComponent”的“#include”目录。将以下代码添加到源文件的“#include”列表中：
- en: '[PRE60]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'First, initialize the `BrickMesh` component by adding the following code to
    the `ASuperSideScroller_Brick::ASuperSideScroller_Brick()` constructor function:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过将以下代码添加到“ASuperSideScroller_Brick::ASuperSideScroller_Brick()”构造函数来初始化“BrickMesh”组件：
- en: '[PRE61]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, the `BrickMesh` component should have collision so that the player can
    walk on top of it for platforming gameplay purposes. To ensure this occurs by
    default, add the following code to set the collision to `"BlockAll"`:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，“BrickMesh”组件应该具有碰撞，以便玩家可以在其上行走，用于平台游戏目的。为了确保这种情况默认发生，添加以下代码将碰撞设置为“BlockAll”：
- en: '[PRE62]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Lastly, the `BrickMesh` component will serve as the root component of the `Brick`
    actor. Add the following code to do this:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，“BrickMesh”组件将作为“Brick”角色的根组件。添加以下代码来实现这一点：
- en: '[PRE63]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, add the following code to the constructor function to initialize our `BrickCollision
    UBoxComponent`:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过将以下代码添加到构造函数中来初始化我们的“BrickCollision UBoxComponent”：
- en: '[PRE64]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Just like the `BrickMesh` component, the `BrickCollision` component will also
    need to have its collision set to `"BlockAll"` in order to receive the `OnHit()`
    callback events we will be adding later in this exercise. Add the following code:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像“BrickMesh”组件一样，“BrickCollision”组件也需要将其碰撞设置为“BlockAll”，以便在本练习的后续步骤中添加“OnHit()”回调事件。添加以下代码：
- en: '[PRE65]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, the `BrickCollision` component needs to be attached to the `BrickMesh`
    component. We can do this by adding the following code:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，需要将“BrickCollision”组件附加到“BrickMesh”组件上。我们可以通过添加以下代码来实现这一点：
- en: '[PRE66]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Before we can finish the initialization of the `BrickCollision` component,
    we need to add the function definition for the `OnHit()` function. Add the following
    definition to the source file:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成“BrickCollision”组件的初始化之前，我们需要为“OnHit()”函数添加函数定义。将以下定义添加到源文件中：
- en: '[PRE67]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now that we have the `OnHit()` function defined, we can assign the `OnComponentHit`
    callback to the `BrickCollision` component. Add the following code to the constructor
    function:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了“OnHit()”函数，我们可以将“OnComponentHit”回调分配给“BrickCollision”组件。将以下代码添加到构造函数中：
- en: '[PRE68]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Compile the C++ code for the `SuperSideScroller_Brick` class and return to the
    Unreal Engine 4 editor.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译“SuperSideScroller_Brick”类的C++代码，并返回到Unreal Engine 4编辑器。
- en: In the `Content Browser` window, *right-click* on the `Content` folder and select
    the `New Folder` option. Name this folder `Brick`.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“内容浏览器”窗口中，*右键单击*“内容”文件夹，然后选择“新建文件夹”选项。将此文件夹命名为“砖块”。
- en: '*Right-click* inside the `Brick` folder and select `Blueprint Class`. From
    the `All Classes` search bar in the `Pick Parent Class` dialog window, search
    for and select the `SuperSideScroller_Brick` class.'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Brick”文件夹内*右键单击*，然后选择“蓝图类”。在“选择父类”对话框窗口的“所有类”搜索栏中，搜索并选择“SuperSideScroller_Brick”类。
- en: Name this new Blueprint `BP_Brick`, and then *double-left-click* the asset to
    open it.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新的蓝图命名为“BP_Brick”，然后*双击*该资源以打开它。
- en: Select the `BrickMesh` component from the `Components` tab and set its `Static
    Mesh` parameter to the `Shape_Cube` mesh.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“组件”选项卡中选择“BrickMesh”组件，并将其“Static Mesh”参数设置为“Shape_Cube”网格。
- en: With the `BrickMesh` component still selected, set the `Element 0` material
    parameter to `M_Brick_Clay_Beveled`. `M_Brick_Clay_Beveled` is a material provided
    by Epic Games by default when creating a new project. It can be found within the
    `StarterContent` directory, in the `Content Browser` window.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然选择“BrickMesh”组件，将“Element 0”材质参数设置为“M_Brick_Clay_Beveled”。在创建新项目时，Epic Games默认提供了“M_Brick_Clay_Beveled”材质。它可以在“内容浏览器”窗口的“StarterContent”目录中找到。
- en: The last thing we need to do with the `BrickMesh` component is to adjust its
    scale so that it fits the needs of the player character, as well as the platforming
    mechanics of the `SuperSideScroller` game project.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 与玩家角色的需求以及“SuperSideScroller”游戏项目的平台机制相适应，我们需要调整“BrickMesh”组件的比例。
- en: 'With the `BrickMesh` component selected, make the following change to its `Scale`
    parameter:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“BrickMesh”组件后，对其“Scale”参数进行以下更改：
- en: '[PRE69]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now that the `BrickMesh` component is `75%` of its normal size, the `Brick`
    actor will become more manageable for us as designers when we place the actor
    into the game world, as well as when we're developing interesting platforming
    sections within the level.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，“BrickMesh”组件的大小为其正常大小的“75%”，当我们将角色放入游戏世界时，以及在我们在关卡中开发有趣的平台部分时，“Brick”角色将变得更易于我们作为设计者管理。
- en: The final step here is to update the location of the `BrickCollision` component
    so that it only has some of its collision sticking out from the bottom of the
    `BrickMesh` component.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是更新`BrickCollision`组件的位置，使其只有一部分碰撞从`BrickMesh`组件的底部伸出。
- en: 'Select the `BrickCollision` component from the `Components` tab and update
    its `Location` parameter to the following values:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Components`选项卡中选择`BrickCollision`组件，并将其`Location`参数更新为以下值：
- en: '[PRE70]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `BrickCollision` component should now be positioned as follows:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '`BrickCollision`组件现在应该定位如下：'
- en: '![Figure 15.29: Now, the BrickCollision component is just barely outside'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.29：现在，BrickCollision组件刚好在BrickMesh组件之外'
- en: the BrickMesh component
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: BrickMesh组件
- en: '](img/B16183_15_29.jpg)'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_29.jpg)'
- en: 'Figure 15.29: Now, the BrickCollision component is just barely outside the
    BrickMesh component'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.29：现在，BrickCollision组件刚好在BrickMesh组件之外
- en: We are making this adjustment to the position of the `BrickCollision` component
    so that the player can only hit `UBoxComponent` when jumping underneath the brick.
    By making it slightly outside of the `BrickMesh` component, we can control this
    better and ensure that this component cannot be hit by the player in any other
    way.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调整`BrickCollision`组件的位置，以便玩家只能在砖块下跳时击中`UBoxComponent`。通过使其略微超出`BrickMesh`组件，我们可以更好地控制这一点，并确保玩家无法以其他方式击中该组件。
- en: Note
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the assets and code for this exercise here: [https://packt.live/3kr7rh6](https://packt.live/3kr7rh6).'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到此练习的资产和代码：[https://packt.live/3kr7rh6](https://packt.live/3kr7rh6)。
- en: With this exercise complete, you were able to create the base framework for
    the `SuperSideScroller_Brick` class and put together the Blueprint actor to represent
    the brick in the game world. By adding a cube mesh and brick material, you added
    a nice visual polish to the brick. In the following exercise, you will add the
    remaining C++ logic to the brick. This will allow the player to destroy the brick
    and obtain a collectible.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个练习后，您已经能够为`SuperSideScroller_Brick`类创建基本框架，并组合蓝图角色以在游戏世界中表示砖块。通过添加立方体网格和砖块材质，您为砖块添加了良好的视觉效果。在接下来的练习中，您将为砖块添加剩余的C++逻辑。这将允许玩家摧毁砖块并获得可收集物品。
- en: 'Exercise 15.08: Adding the Brick Class C++ Logic'
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.08：添加Brick类C++逻辑
- en: 'In the previous exercise, you created the base framework for the `SuperSideScroller_Brick`
    class by adding the necessary components and creating the `BP_Brick` Blueprint
    actor. In this exercise, you will add on top of the C++ code of *Exercise 15.07*,
    *Creating the Brick Class*, to grant logic to the `Brick` class. This will allow
    the brick to give players coin collectibles. Perform the following steps to accomplish
    this:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，通过添加必要的组件并创建`BP_Brick`蓝图角色，您为`SuperSideScroller_Brick`类创建了基本框架。在这个练习中，您将在*练习15.07*，*创建Brick类*的C++代码的基础上添加逻辑，以赋予`Brick`类逻辑。这将允许砖块给玩家金币收藏品。执行以下步骤来完成这个过程：
- en: 'To begin, we need to create a function that will add the collectible to the
    player. Add the following function declaration to the `SuperSideScroller_Brick.h`
    header file, under our `Private Access Modifier`:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个函数，将可收集物品添加到玩家。在我们的`Private Access Modifier`下，在`SuperSideScroller_Brick.h`头文件中添加以下函数声明：
- en: '[PRE71]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We want to pass in a reference to the `SuperSideScroller_Player` class so that
    we can call the `IncrementNumberofCollectables()` function from that class.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望传递对`SuperSideScroller_Player`类的引用，以便我们可以从该类调用`IncrementNumberofCollectables()`函数。
- en: 'Next, create a void function declaration called `PlayHitSound()` under our
    `Private Access Modifier`:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的`Private Access Modifier`下创建一个名为`PlayHitSound()`的void函数声明：
- en: '[PRE72]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `PlayHitSound()` function will be responsible for spawning the `HitSound`
    property you created in *Exercise 15.07*, *Creating the Brick Class*.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayHitSound()`函数将负责生成您在*练习15.07*，*创建Brick类*中创建的`HitSound`属性。'
- en: 'Finally, create another void function declaration called `PlayHitExplosion()`
    under our `Private Access Modifier`:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的`Private Access Modifier`下创建另一个名为`PlayHitExplosion()`的void函数声明：
- en: '[PRE73]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `PlayHitExplosion()` function will be responsible for spawning the `Explosion`
    property you created in *Exercise 15.07*, *Creating the Brick Class*.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayHitExplosion()`函数将负责生成您在*练习15.07*中创建的`Explosion`属性。'
- en: With the remaining functions needed for the `SuperSideScroller_Brick` class
    declared in the header file, let's move on and define these functions inside the
    source file.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在头文件中声明了`SuperSideScroller_Brick`类所需的其余函数后，让我们继续在源文件中定义这些函数。
- en: 'At the top of the `SuperSideScroller_Brick.cpp` source file, add the following
    `#includes` to the list of `include` directories that already exist for this class:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SuperSideScroller_Brick.cpp`源文件的顶部，将以下`#includes`添加到已存在的`include`目录列表中：
- en: '[PRE74]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The includes for the `World` and `GameplayStatics` classes are necessary to
    spawn both the `HitSound` and the `Explosion` effects for the brick. Including
    the `SuperSideScroller_Player` class is required to make the call to the `IncrementNumberofCollectables()`
    class function.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`World`和`GameplayStatics`类的包含是必要的，以生成砖块的`HitSound`和`Explosion`效果。包括`SuperSideScroller_Player`类是为了调用`IncrementNumberofCollectables()`类函数。'
- en: 'Let''s start with the function definition for the `AddCollectable()` function.
    Add the following code:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`AddCollectable()`函数的函数定义开始。添加以下代码：
- en: '[PRE75]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, make the call to the `IncrementNumberofCollectables()` function by using
    the `Player` function input parameter:'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过使用`Player`函数输入参数调用`IncrementNumberofCollectables()`函数：
- en: '[PRE76]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'For the `PlayHitSound()` function, you will need to get a reference to the
    `UWorld*` object and verify whether the `HitSound` property is valid before making
    the function call to `SpawnSoundAtLocation` from the `UGameplayStatics` class.
    This is a process you have done many times, so this is the entire function code:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`PlayHitSound()`函数，您需要获取对`UWorld*`对象的引用，并在从`UGameplayStatics`类调用`SpawnSoundAtLocation`函数之前验证`HitSound`属性是否有效。这是您已经做过许多次的过程，所以这是整个函数代码：
- en: '[PRE77]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Just like the `PlayHitSound()` function, the `PlayHitExplosion()` function
    will work in an almost similar way, and it''s a process you have done many times
    in this project. Add the following code to create the function definition:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像`PlayHitSound()`函数一样，`PlayHitExplosion()`函数将以几乎相似的方式工作，这是您在此项目中已经做过许多次的过程。添加以下代码以创建函数定义：
- en: '[PRE78]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: With these functions defined, let's update the `OnHit()` function so that if
    the player does hit the `BrickCollision` component, we can spawn `HitSound` and
    `Explosion`, and also add a coin collectible to the player's collection.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些函数的定义，让我们更新`OnHit()`函数，以便如果玩家确实击中了`BrickCollision`组件，我们可以生成`HitSound`和`Explosion`，并将一个硬币可收集物品添加到玩家的收集物品中。
- en: 'First, in the `OnHit()` function, create a new variable called `Player` of
    the `ASuperSideScroller_Player` type that equals the `Cast` of the `OtherActor`
    input parameter of the function, as shown here:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`OnHit()`函数中，创建一个名为`Player`的新变量，类型为`ASuperSideScroller_Player`，其值等于函数的`OtherActor`输入参数的`Cast`，如下所示：
- en: '[PRE79]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Next, we only want to continue with this function if `Player` is valid and
    `bHasCollectable` is `True`. Add the following `if()` statement:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只想在`Player`有效且`bHasCollectable`为`True`时继续执行此函数。添加以下`if()`语句：
- en: '[PRE80]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If the conditions in the `if()` statement are met, that is when we need to
    make the calls to the `AddCollectable()`, `PlayHitSound()`, and `PlayHitExplosion()`
    functions. Make sure to also pass in the `Player` variable inside the `AddCollectable()`
    function:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`if()`语句中的条件满足，那么我们需要调用`AddCollectable()`、`PlayHitSound()`和`PlayHitExplosion()`函数。确保在`AddCollectable()`函数中也传入`Player`变量：
- en: '[PRE81]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, add the function call to destroy the brick inside of the `if()` statement:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`if()`语句内添加销毁砖块的函数调用：
- en: '[PRE82]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: With the `OnHit()` function defined as we need, recompile the C++ code but do
    not return to the Unreal Engine 4 editor just yet.
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们需要的`OnHit()`函数定义好了，重新编译C++代码，但暂时不要返回到虚幻引擎4编辑器。
- en: 'For the VFX and SFX of the brick''s explosion, we will need to migrate assets
    from two separate projects available to us from `Epic Games Launcher`: the `Blueprints`
    project and the `Content Examples` project.'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于砖块爆炸的VFX和SFX，我们需要从`Epic Games Launcher`提供给我们的两个不同项目中迁移资源：`Blueprints`项目和`Content
    Examples`项目。
- en: Using your knowledge from previous exercises, download and install these projects
    using engine version 4.24\. Both projects can be found in the `Learn` tab, under
    the `Engine Feature Samples` category.
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用您之前练习中的知识，使用引擎版本4.24下载并安装这些项目。这两个项目都可以在`Learn`选项卡的`Engine Feature Samples`类别下找到。
- en: Once installed, open the `Content Examples` project and find the `P_Pixel_Explosion`
    asset in the `Content Browser` window.
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，打开`Content Examples`项目，并在`Content Browser`窗口中找到`P_Pixel_Explosion`资源。
- en: '*Right-click* this asset, then select `Asset Actions` and then `Migrate`. Migrate
    this asset and all its referenced assets into your `SuperSideScroller` project.'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*此资源，然后选择`资源操作`，然后选择`迁移`。将此资源及其所有引用的资源迁移到您的`SuperSideScroller`项目中。'
- en: Once this asset has been successfully migrated, close the `Content Examples`
    project and open the `Blueprints` project.
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦成功迁移了此资源，关闭`Content Examples`项目，然后打开`Blueprints`项目。
- en: From the `Content Browser` window of the `Blueprints` project, find the `Blueprints_TextPop01`
    asset.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Blueprints`项目的`Content Browser`窗口中找到`Blueprints_TextPop01`资源。
- en: '*Right-click* this asset, then select `Asset Actions`, and then `Migrate`.
    Migrate this asset and all its referenced assets into your `SuperSideScroller`
    project.'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*此资源，然后选择`资源操作`，然后选择`迁移`。将此资源及其所有引用的资源迁移到您的`SuperSideScroller`项目中。'
- en: With these assets migrated to your project, return to the Unreal Engine 4 editor
    of your `SuperSideScroller` project.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些资源迁移到您的项目后，返回到您的`SuperSideScroller`项目的虚幻引擎4编辑器中。
- en: Navigate to the `Brick` folder in the `Content Browser` window and *double-left-click*
    the `BP_Brick` asset to open it.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content Browser`窗口中导航到`Brick`文件夹，*双击*`BP_Brick`资源以打开它。
- en: In the `Details` panel of the actor, find the `Super Side Scroller Brick` section
    and set the `HitSound` parameter to the `Blueprints_TextPop01` soundwave you imported.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色的`Details`面板中，找到`Super Side Scroller Brick`部分，并将`HitSound`参数设置为您导入的`Blueprints_TextPop01`声波。
- en: Next, add the `P_Pixel_Explosion` particle you imported into the `Explosion`
    parameter.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将您导入的`P_Pixel_Explosion`粒子添加到`Explosion`参数中。
- en: Recompile the `BP_Brick` Blueprint and add two of these actors to your level.
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编译`BP_Brick`蓝图并将两个这样的角色添加到您的关卡中。
- en: 'Set one of the bricks so that the `bHasCollectable` parameter is `True`; set
    the other to `False`. Please refer to the following screenshot:![Figure 15.30:
    This Brick actor is set to have a collectible spawn'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其中一个砖块的`bHasCollectable`参数设置为`True`；将另一个设置为`False`。请参考以下截图：![图15.30：此砖块角色设置为生成可收集物品
- en: '](img/B16183_15_30.jpg)'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_30.jpg)'
- en: 'Figure 15.30: This Brick actor is set to have a collectible spawn'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.30：此砖块角色设置为生成可收集物品
- en: 'Using PIE, observe the differences in behavior between the two brick actors
    when you attempt to hit the bottom of the brick with the character''s head when
    jumping, as shown in the following screenshot:![Figure 15.31: Now, the player
    can hit the brick and it will be destroyed'
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用PIE，观察当您尝试用角色的头部跳跃击中砖块底部时，两个砖块角色之间行为的差异，如下截图所示：![图15.31：现在，玩家可以击中砖块并将其摧毁
- en: '](img/B16183_15_31.jpg)'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_15_31.jpg)'
- en: 'Figure 15.31: Now, the player can hit the brick and it will be destroyed'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.31：现在，玩家可以击中砖块并将其摧毁
- en: When `bHasCollectable` is `True`, `SuperSideScroller_Brick` will play our `HitSound`,
    spawn the `Explosion` particle system, add a coin collectible to the player, and
    be destroyed.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 当`bHasCollectable`为`True`时，`SuperSideScroller_Brick`将播放我们的`HitSound`，生成`Explosion`粒子系统，向玩家添加一个硬币可收集物品，并被摧毁。
- en: Note
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find the assets and code for this exercise here: [https://packt.live/3pjhoAv](https://packt.live/3pjhoAv).'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到此练习的资产和代码：[https://packt.live/3pjhoAv](https://packt.live/3pjhoAv)。
- en: With this exercise complete, you have now finished developing the gameplay mechanics
    for the `SuperSideScroller` game project. Now, the `SuperSideScroller_Brick` class
    can be used for both the platforming gameplay and the coin collecting mechanic
    that we want for the game.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你现在已经完成了“SuperSideScroller”游戏项目的游戏机制开发。现在，“SuperSideScroller_Brick”类可以用于平台游戏玩法和我们想要的游戏中的金币收集机制。
- en: Now that the brick can be destroyed and hidden coins can be collected, all the
    gameplay elements that we set out to create for the `SuperSideScroller` game project
    are complete.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 现在砖块可以被摧毁，隐藏的金币可以被收集，我们为“SuperSideScroller”游戏项目设定的所有游戏元素都已经完成。
- en: Summary
  id: totrans-591
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you put your knowledge to the test to create the remaining
    gameplay mechanics for the `SuperSideScroller` game project. Using a combination
    of C++ and Blueprints, you developed the potion power-up and coins for the player
    to collect in the level. Also, by using your knowledge from *Chapter 14*, *Spawning
    the Player Projectile*, you added unique audio and visual assets to these collectible
    items to add a nice layer of polish to the game.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将你的知识付诸实践，为“SuperSideScroller”游戏项目创建了剩余的游戏机制。通过结合C++和蓝图，你开发了玩家可以在关卡中收集的药水能力提升和金币。此外，通过使用你在第14章“生成玩家投射物”中学到的知识，你为这些可收集物品添加了独特的音频和视觉资产，为游戏增添了一层精美的润色。
- en: You learned and took advantage of the `UMG UI` system within Unreal Engine 4
    to create a simple, yet effective, UI feedback system to display the number of
    coins that the player has collected. By using the binding feature of the `Text`
    widget, you were able to keep the UI updated with the number of coins the player
    has currently collected. Lastly, you created a `Brick` class using the knowledge
    you learned from the `SuperSideScroller` project to hide coins for the player
    so that they can collect and find them.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习并利用了虚幻引擎4中的“UMG UI”系统，创建了一个简单而有效的UI反馈系统，用于显示玩家已经收集的金币数量。通过使用“Text”小部件的绑定功能，你能够保持UI与玩家当前已经收集的金币数量保持更新。最后，你使用了从“SuperSideScroller”项目中学到的知识创建了一个“Brick”类，用于为玩家隐藏金币，让他们可以收集和找到它们。
- en: The `SuperSideScroller` project has been an extensive project that expanded
    over many of the tools and practices available within Unreal Engine 4\. In *Chapter
    10*, *Creating a SuperSideScroller Game*, we imported custom skeleton and animation
    assets to use in developing the Animation Blueprint of the player character. In
    *Chapter 11*, *Blend Spaces 1D, Key Bindings, and State Machines*, we used `Blend
    spaces` to allow the player character to blend between idle, walking, and sprinting
    animations, while also using an `Animation State Machine` to handle the jumping
    and movement states of the player character. We then learned how to control the
    player's movement and jump height using the character movement component.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: “SuperSideScroller”项目是一个庞大的项目，涵盖了虚幻引擎4中许多可用的工具和实践。在第10章“创建SuperSideScroller游戏”中，我们导入了自定义的骨骼和动画资产，用于开发玩家角色的动画蓝图。在第11章“Blend
    Spaces 1D, Key Bindings, and State Machines”中，我们使用了“Blend spaces”允许玩家角色在空闲、行走和奔跑动画之间进行混合，同时使用“Animation
    State Machine”来处理玩家角色的跳跃和移动状态。然后，我们学习了如何使用角色移动组件来控制玩家的移动和跳跃高度。
- en: In *Chapter 12*, *Animation Blending and Montages*, we learned more about animation
    blending inside `Animation Blueprints` by using the `Layered Blend per Bone` function
    and `Saved Cached Poses`. By adding a new `AnimSlot` for the upper body animation
    of the player character's throw animation, we were able to have both the player
    movement animations and the throw animation blend together smoothly. In *Chapter
    13*, *Enemy Artificial Intelligence*, we used the robust systems of Behavior Trees
    and Blackboards to develop AI behavior for the enemy. We created our own `Task`
    that will allow the enemy AI to move in-between points from a custom Blueprint
    that we also developed to determine patrol points for the AI.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在第12章“Animation Blending and Montages”中，我们通过使用“Layered Blend per Bone”功能和“Saved
    Cached Poses”更多地了解了动画蓝图中的动画混合。通过为玩家角色的投掷动画添加一个新的“AnimSlot”，我们能够使玩家的移动动画和投掷动画平滑地混合在一起。在第13章“Enemy
    Artificial Intelligence”中，我们使用了行为树和黑板的强大系统来为敌人开发AI行为。我们创建了自己的“Task”，使敌人AI能够在我们还开发的自定义蓝图中的巡逻点之间移动。
- en: In *Chapter 14*, *Spawning the Player Projectile*, we learned how to create
    an `Anim Notify` and how to implement this notify in our `Animation Montage` for
    the player character's throw to spawn the player projectile. Then, we learned
    about how to create projectiles and how to use `Projectile Movement Component`
    to have the player projectile move in the game world.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在第14章“生成玩家投射物”中，我们学习了如何创建“Anim Notify”，以及如何在玩家角色的投掷动画中实现这个通知来生成玩家投射物。然后，我们学习了如何创建投射物，以及如何使用“Projectile
    Movement Component”让玩家投射物在游戏世界中移动。
- en: Finally, in this chapter, we learned how to create UI using the `UMG` toolset
    for the coin collectible, as well as how to manipulate our `Character Movement
    Component` to create the potion power-up for the player. Lastly, you created a
    `Brick` class that can be used to hide coins for the player to find and collect.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这一章中，我们学习了如何使用“UMG”工具集为可收集的金币创建UI，以及如何操纵我们的“Character Movement Component”为玩家创建药水能力提升。最后，你创建了一个“Brick”类，可以用来为玩家隐藏金币，让他们找到并收集。
- en: 'This summarization only really scratches the surface of what we learned and
    accomplished in the `SuperSideScroller` project. Before you move on, here are
    some challenges for you to test your knowledge and expand upon the project:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 这个总结只是对我们在“SuperSideScroller”项目中学到和完成的内容进行了初步的介绍。在你继续之前，这里有一些挑战供你测试知识并扩展项目：
- en: Add a new power-up that lowers the gravity that's applied to the player character.
    Import a custom mesh and audio assets to give this power-up a unique look compared
    to the potion power-up you made.
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的能力提升，降低应用于玩家角色的重力。导入自定义网格和音频资产，使这个能力提升与你制作的药水能力提升有独特的外观。
- en: When the player character collects 10 coins, grant the player a power-up.
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家角色收集到10个硬币时，给予玩家一个力量增强道具。
- en: Implement the functionality that allows the player to be destroyed when it's
    overlapping with the AI. Include being able to respawn the player when this happens.
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现当玩家与AI重叠时允许玩家被摧毁的功能。包括当发生这种情况时，能够让玩家重新生成。
- en: Add another power-up that gives immunity to the player so that they cannot be
    destroyed when they're overlapping with an enemy. (In fact, when overlapping an
    enemy with this power-up, it could destroy the enemy.)
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个能让玩家免疫的力量增强道具，这样当他们与敌人重叠时就不会被摧毁。（事实上，拥有这个力量增强道具时，与敌人重叠时可能会摧毁敌人。）
- en: Using all the gameplay elements you've developed for the `SuperSideScroller`
    project, create a new level that takes advantage of these elements to make an
    interesting platforming arena to play in.
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用您为“SuperSideScroller”项目开发的所有游戏元素，创建一个新的关卡，利用这些元素打造一个有趣的平台竞技场。
- en: Add multiple enemies with interesting patrol points to challenge the player
    when they're navigating the area.
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加多个具有有趣巡逻点的敌人，挑战玩家在导航区域时。
- en: Place power-ups in hard-to-reach areas so that players need to improve their
    platforming skills to obtain them.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将力量增强道具放置在难以到达的地方，以便玩家需要提高他们的平台技能来获取它们。
- en: Create dangerous pitfalls for the player to navigate across and add functionality
    that will destroy the player if they fall off the map.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为玩家创建危险的陷阱，使他们需要跨越，并添加功能，当玩家从地图上掉下去时会摧毁玩家。
- en: In the next chapter, you will learn about the basics of multiplayer, server-client
    architectures, and the gameplay framework classes used for multiplayer inside
    Unreal Engine 4\. You will use this knowledge to expand upon the multiplayer FPS
    project in Unreal Engine 4.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习关于多人游戏的基础知识，服务器-客户端架构，以及在虚幻引擎4中用于多人游戏的游戏框架类。您将利用这些知识来扩展虚幻引擎4中的多人射击游戏项目。
