- en: Understanding Pure Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解纯函数
- en: Pure functions are the core building blocks of functional programming. They
    are immutable functions, which allow them to be simple and predictable. Writing
    pure functions in C++ is easy, but there are a few things that you'll need to
    be aware of. Since functions in C++ are mutable by default, we need to learn the
    syntax that tells the compiler how to prevent mutations. We'll also explore how
    to separate mutable code from immutable code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是函数式编程的核心构建模块。它们是不可变的函数，这使它们简单和可预测。在C++中编写纯函数很容易，但是有一些事情你需要注意。由于C++中的函数默认是可变的，我们需要学习告诉编译器如何防止变异的语法。我们还将探讨如何将可变代码与不可变代码分开。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding what a pure function is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解纯函数是什么
- en: Writing pure functions in C++ and functions that return multiple arguments using
    tuples
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++中编写纯函数和使用元组返回多个参数的函数
- en: Ensuring immutability in C++ pure functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保C++纯函数的不可变性
- en: Understanding why I/O is mutable and needs to be separated from pure functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么I/O是可变的，需要与纯函数分开
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need a C++ compiler that supports C++ 17\. I'm using GCC version 7.3.0\.
    Code samples are on GitHub ([https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp))
    in the `Chapter02` folder and have a `makefile` file for your convenience.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个支持C++ 17的C++编译器。我使用的是GCC版本7.3.0。代码示例在GitHub（[https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp](https://github.com/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)）的`Chapter02`文件夹中，并且有一个`makefile`文件供您使用。
- en: What is a pure function?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是纯函数？
- en: 'Let''s take a moment to think about a simple everyday experience. When you
    turn the light switch, one of two things happen:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间思考一个简单的日常体验。当你打开灯开关时，会发生两种情况之一：
- en: If the light is on, it turns off
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果灯是开着的，它就会关掉
- en: If the light is off, it turns on
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果灯是关着的，它就会打开
- en: The behavior of a light switch is highly predictable. It's so predictable that,
    when the light doesn't turn on, you immediately think that something is wrong—that
    is, with the light bulb, the fuses, or the switch itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 灯开关的行为是非常可预测的。它是如此可预测，以至于当灯不亮时，你立刻认为有什么地方出了问题——可能是灯泡、保险丝或开关本身。
- en: 'Here are some of the things that you don''t expect to happen when you turn
    the switch on or off:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你打开或关闭开关时不希望发生的一些事情：
- en: Your fridge doesn't go off
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的冰箱不会关掉
- en: Your neighbor's lights don't turn on
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你邻居的灯不会亮起
- en: Your bathroom sink water doesn't turn on
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的浴室水槽不会打开
- en: Your mobile phone doesn't reset
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的手机不会重置
- en: Why would all these things happen when you turn the light switch on? That would
    be highly chaotic; we wouldn't want chaos in our lives, right?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开灯开关时为什么会发生所有这些事情？那将是非常混乱的；我们不希望生活中出现混乱，对吧？
- en: Yet, programmers often experience such behaviors in code. Calling a function
    often results in changes to the state of the program; when this happens, we say
    that a function has **side effects**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，程序员经常在代码中遇到这种行为。调用函数通常会导致程序状态的改变；当这种情况发生时，我们说函数具有**副作用**。
- en: 'Functional programming tries to reduce the chaos caused by a state change through
    the extended use of pure functions. Pure functions are functions that have two
    constraints:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程试图通过广泛使用纯函数来减少状态变化引起的混乱。纯函数是具有两个约束的函数：
- en: They always return the same output values for the same argument values.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们总是对相同的参数值返回相同的输出值。
- en: They don't have side effects.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们没有副作用。
- en: 'Let''s explore how we would write the code for the light switch. We''ll assume
    that the bulb is an external entity that we can call; think of it as the output
    from **input/output** (**I/O**) for our program. The natural code for a structured/object-oriented
    programmer would look something like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨如何编写灯开关的代码。我们假设灯泡是一个我们可以调用的外部实体；把它看作我们程序的**输入/输出**（**I/O**）的输出。结构化/面向对象程序员的自然代码看起来可能是这样的：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are two things happening with this function. Firstly, it uses an input
    that's not part of the list of parameters, that is, `switchIsOn`. Secondly, it
    directly produces side effects on the bulb.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有两个问题。首先，它使用了不属于参数列表的输入，即`switchIsOn`。其次，它直接对灯泡产生了副作用。
- en: 'So, what does a pure function look like? Well, in the first instance, all of
    its parameters are visible:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，纯函数是什么样子的呢？首先，它的所有参数都是可见的：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Second, we need to get rid of the side effect. How can we do that? Let''s separate
    the computation of the next state from the action of turning the light bulb on
    or off:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要消除副作用。我们该如何做呢？让我们将下一个状态的计算与打开或关闭灯泡的动作分开：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The function is now pure, and we''ll discuss this in more detail later; however,
    for now, let''s simplify it as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数现在是纯的，我们稍后会更详细地讨论这一点；但是，现在让我们简化如下：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s make things even clearer (I''ll assume the function is part of a class):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更清晰一些（我会假设该函数是一个类的一部分）：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function is terribly uninteresting: it''s very predictable, it''s easy
    to read, and it doesn''t have side effects. This sounds exactly like a well-designed
    light switch. Moreover, it sounds exactly like what we want when we maintain a
    huge number of lines of code for tens of years.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常无聊：它非常可预测，易于阅读，而且没有副作用。这听起来就像一个设计良好的灯开关。而且，这正是我们在维护数十年的大量代码时所希望的。
- en: We now understand what a pure function is and why it's useful. We also demonstrated
    an example of separating pure functions from side effects (usually I/O). It's
    an interesting concept, but where can it take us? Can we really build complex
    programs using such simple constructs? We'll discuss how to compose pure functions
    in the following chapters. For now, let's focus on understanding how to write
    pure functions in C++.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在了解了纯函数是什么以及它为什么有用。我们还演示了如何将纯函数与副作用（通常是I/O）分离的例子。这是一个有趣的概念，但它能带我们到哪里？我们真的可以使用这样简单的构造来构建复杂的程序吗？我们将在接下来的章节中讨论如何组合纯函数。现在，让我们专注于理解如何在C++中编写纯函数。
- en: Pure functions in C++
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的纯函数
- en: 'You''ve already seen, in the preceding example, the basic syntax that we need
    to use for pure functions in C++. You just need to remember the following four
    ideas:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您已经看到了我们在C++中需要使用的纯函数的基本语法。您只需要记住以下四个想法：
- en: Pure functions don't have side effects; if they are part of a class, they can
    be `static` or `const`.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数没有副作用；如果它们是类的一部分，它们可以是`static`或`const`。
- en: Pure functions don't change their parameters, so every parameter has to be of
    the `const`, `const&`, or `const* const` type.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数不改变它们的参数，因此每个参数都必须是`const`、`const&`或`const* const`类型。
- en: Pure functions always return values. Technically, we can return a value through
    an output parameter, but it's usually simpler to just return a value. This means
    that pure functions usually don't have a void return type.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数总是返回值。从技术上讲，我们可以通过输出参数返回一个值，但通常更简单的是直接返回一个值。这意味着纯函数通常没有void返回类型。
- en: None of the preceding points guarantee the lack of side effects or immutability,
    but they take us close. For example, data members can be marked as mutable and
    the `const` methods could change them.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的观点都不能保证没有副作用或不可变性，但它们让我们接近了。例如，数据成员可以标记为可变，`const`方法可以改变它们。
- en: We'll explore, in the following sections, how to write pure functions both as
    free functions and as class methods. When we go through the examples, remember
    that we are exploring the syntax for now, focusing on how to use the compiler
    to get as close as possible to pure functions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨如何编写自由函数和类方法作为纯函数。当我们浏览示例时，请记住我们现在正在探索语法，重点是如何使用编译器尽可能接近纯函数。
- en: Pure functions without arguments
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有参数的纯函数
- en: 'Let''s start simple. Can we use pure functions without arguments? Certainly.
    One example is when we need a default value. Let''s consider the following example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的开始。我们可以在没有参数的情况下使用纯函数吗？当然可以。一个例子是当我们需要一个默认值时。让我们考虑以下例子：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is a standalone function. Let''s understand how to write a pure function
    inside a class as well:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个独立的函数。让我们了解如何在类中编写纯函数：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, `static` tells us that the function doesn''t change any non-static data
    member. However, this doesn''t prevent the code from changing the value of a `static`
    data member:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`static`告诉我们该函数不会改变任何非静态数据成员。但是，这并不能阻止代码改变`static`数据成员的值：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Fortunately, we''ll see that we can solve most mutable state problems with
    well-placed `const` keywords. The following case is no exception:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们会发现我们可以通过恰当使用`const`关键字来解决大多数可变状态问题。以下情况也不例外：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have gained some understanding of how to write pure functions without
    arguments, it's time to add more arguments.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对如何编写没有参数的纯函数有了一些了解，是时候添加更多参数了。
- en: Pure functions with one or more arguments
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有一个或多个参数的纯函数
- en: 'Let''s start with one pure class method with one parameter, as shown in the
    following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个带有一个参数的纯类方法开始，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'How about two parameters? Sure, let''s consider the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 两个参数呢？当然，让我们考虑以下代码：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can do the same with reference types, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用引用类型做同样的事情，如下所示：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Additionally, we can do the same with pointer types, albeit with a bit more
    syntactic sugar:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以用指针类型做同样的事情，尽管有点更多的语法糖：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Congratulations—you now know how to write pure functions in C++!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜——您现在知道如何在C++中编写纯函数了！
- en: Well, kind of; unfortunately, immutability is a bit more complex to implement
    in C++ than what we've seen so far. We need to look at various situations in more
    depth.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，有点；不幸的是，不可变性在C++中实现起来比我们迄今所见到的要复杂一些。我们需要更深入地研究各种情况。
- en: Pure functions and immutability
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数和不可变性
- en: The 1995 movie, *Apollo 13*, is one of my favorite thrillers. It involves space,
    a real story, and multiple engineering problems. Between many memorable scenes,
    there's one in particular that can teach us a lot about programming. While the
    team of astronauts is preparing a complex procedure, the commander, played by
    Tom Hanks notices, that his colleague placed a sticker on one of the command switches
    saying *Don't flip this.* The commander asks his colleague why he did that, and
    his answer is something along the lines of *My head wasn't clear, and I was afraid
    I would flip this and send you to space. So, I wrote this to remind myself not
    to make this mistake.*
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 1995年的电影《阿波罗13号》是我最喜欢的惊悚片之一。它涉及太空、一个真实的故事和多个工程问题。在许多令人难忘的场景中，有一个特别能教给我们很多关于编程的场景。当宇航员团队正在准备一个复杂的程序时，由汤姆·汉克斯扮演的指挥官注意到，他的同事在一个指令开关上贴了一张标签，上面写着“不要按动”。指挥官问他的同事为什么这样做，他的回答大致是“我的头脑不清醒，我害怕我会按动这个开关把你送上太空。所以，我写下这个来提醒自己不要犯这个错误。”
- en: If this technique works for astronauts, it should work for programmers. Fortunately,
    we have the compiler to tell us when we do something wrong. However, we need to
    tell the compiler what we want it to check.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种技术对宇航员有效，那么对程序员也应该有效。幸运的是，我们有编译器告诉我们何时做错了。但是，我们需要告诉编译器我们希望它检查什么。
- en: After all, we can write pure functions without any `const` or `static`. Function
    purity is not a matter of syntax, but a concept. Having the right stickers in
    place can prevent us from making mistakes. We'll see, however, that the compiler
    can only go so far.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 毕竟，我们可以编写纯函数，而不需要任何`const`或`static`。函数纯度不是语法问题，而是一个概念。正确地放置标签可以防止我们犯错。然而，我们会看到，编译器只能做到这一点。
- en: 'Let''s take a look at another way to implement the increment function that
    we discussed previously:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一种实现我们之前讨论过的递增函数的方法：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is not a pure function. Can you see why? The answer is on the following
    line:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个纯函数。你能看出为什么吗？答案就在下一行：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`++value` not only increments `value`, but it also changes the input parameter.
    While it''s not a problem in this case (the `value` parameter is passed by value,
    so only its copy is modified), it''s still a side effect. This shows how easy
    it is to write side effects in C++, or in any language that doesn''t enforce immutability
    by default. Fortunately, the compiler can help us, as long as we tell it exactly
    what we want.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`++value`不仅会递增`value`，还会改变输入参数。虽然在这种情况下并不是问题（`value`参数是按值传递的，所以只有它的副本被修改），但这仍然是一个副作用。这显示了在C++中编写副作用有多容易，或者在任何不默认强制不可变性的语言中。幸运的是，只要我们告诉编译器我们确切地想要什么，编译器就可以帮助我们。'
- en: 'Recall the previous implementation as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下之前的实现如下：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you try to write `++value` or `value++` in the body of this function, the
    compiler will immediately tell you that you're trying to change a `const` input
    parameter. That's very nice of the compiler, isn't it?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在这个函数的主体中写`++value`或`value++`，编译器会立即告诉你，你试图改变一个`const`输入参数。这真是太好了，不是吗？
- en: What about the parameters passed by reference though?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 那么通过引用传递的参数呢？
- en: Immutability and passing by reference
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性和通过引用传递
- en: 'The problem could have been worse. Imagine the following function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 问题本来可能更糟。想象一下以下函数：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''re avoiding a pass by value, which involves a few more bytes of memory.
    But what happens with the value? Let''s take a look at the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免了按值传递，这涉及更多的内存字节。但是值会发生什么变化呢？让我们看看以下代码：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `value` parameter started at `0`, but when we called the function, it was
    incremented, so now its `value` is `1`. That''s like every time you turn on the
    light, your refrigerator door opens. Fortunately, if we just add a small `const`
    keyword, we will see the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`value`参数开始为`0`，但当我们调用函数时，它被递增，所以现在它的`value`是`1`。这就像每次你打开灯时，冰箱门都会打开。幸运的是，如果我们只添加一个小小的`const`关键字，我们会看到以下结果：'
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, the compiler is once again nice enough to tell us that we can't use `++value`
    or `value++` in its body.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编译器再次友好地告诉我们，在函数体中不能使用`++value`或`value++`。
- en: That's cool, but what about pointer arguments?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷，但指针参数呢？
- en: Immutability and pointers
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性和指针
- en: 'When using pointers as input parameters, preventing unwanted changes becomes
    more complex. Let''s see what happens when we try calling this function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用指针作为输入参数时，防止不需要的更改变得更加复杂。让我们看看当我们尝试调用这个函数时会发生什么：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following things could change:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下事情可能会改变：
- en: The value pointed by `pValue` could change.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pValue`指向的值可能会改变。'
- en: The pointer could change its address.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针可能会改变其地址。
- en: 'The value pointed by `pValue` can change in similar conditions, as we discovered
    previously. For example, consider the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`pValue`指向的值在类似条件下可能会改变，就像我们之前发现的那样。例如，考虑以下代码：'
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will change the pointed value as well as return it. To make it impossible
    to change, we need to use a well-placed `const` keyword:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将改变指向的值并返回它。要使其不可更改，我们需要使用一个恰到好处的`const`关键字：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The changes to the pointer address are trickier than you''d expect. Let''s
    take a look at an example that will behave in an unexpected way:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 指针地址的更改比你期望的要棘手。让我们看一个会以意想不到的方式行为的例子：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running this on my laptop gives the following result:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的笔记本上运行这个程序会得到以下结果：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The address doesn't change, even though we're incrementing it in the function
    by using `++pValue`. The same also happens with `pValue++`, but why is this the
    case?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 地址不会改变，即使我们在函数中使用`++pValue`进行递增。`pValue++`也是如此，但为什么会这样呢？
- en: 'Well, the pointer address is a value, and it''s passed by value, so any change
    within the function body only applies to the function scope. To make the address
    change, you need to pass the address by reference, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，指针地址是一个值，它是按值传递的，所以函数体内的任何更改只适用于函数范围。要使地址更改，您需要按引用传递地址，如下所示：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This tells us that, fortunately, it''s not easy to write functions that change
    a pointer address. I still feel safer telling the compiler to enforce this rule
    for me:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，幸运的是，编写更改指针地址的函数并不容易。我仍然觉得告诉编译器强制执行这个规则更安全：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Of course, this doesn''t block you from changing the value pointed to:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不妨碍你改变指向的值：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To enforce immutability for both the value and the address, you need to use
    even more `const` keywords, as shown in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制不可变性，无论是值还是地址，你需要使用更多的`const`关键字，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This covers all types of class functions. However, C++ allows us to write functions
    outside classes. So, does `static` still work in this situation? (Spoiler alert:
    not quite as you would expect).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了所有类型的类函数。但是，C++允许我们在类外编写函数。那么在这种情况下，`static`还有效吗？（剧透警告：并不完全如你所期望）。
- en: Immutability and non-class functions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性和非类函数
- en: 'All the examples so far assume that the functions are part of a class. C++
    allows us to write functions that are not part of any class. For example, we could
    write the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的所有示例都假设函数是类的一部分。C++允许我们编写不属于任何类的函数。例如，我们可以编写以下代码：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You may have noticed that we're not using `static` anymore. You can use `static`,
    but you need to be aware that it has a completely different meaning to the functions
    in a class. `static` applied to a standalone function means that *you can't use
    it from a different translation unit*; so, if you write the function in a CPP
    file, it will just be available in that file and it will be ignored by the linker.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们不再使用`static`了。您可以使用`static`，但需要注意它对类中的函数具有完全不同的含义。应用于独立函数的`static`意味着*您无法从不同的翻译单元中使用它*；因此，如果您在CPP文件中编写函数，它将只在该文件中可用，并且链接器会忽略它。
- en: We've covered all types of class and non-class functions. But what about functions
    that have output parameters? As it turns out, they need a bit of work.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了所有类型的类和非类函数。但是对于具有输出参数的函数呢？事实证明，它们需要一些工作。
- en: Immutability and output parameters
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性和输出参数
- en: 'Sometimes, we want a function to change the data that we pass in. There are
    many examples in **Standard Template Library*** (***STL**), and the easiest one
    to provide as an example is `sort`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望函数改变我们传入的数据。在**标准模板库**（**STL**）中有许多例子，其中最简单的一个例子是`sort`：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, this doesn''t fit the idea of pure functions; a pure equivalent of
    `sort` would be as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不符合纯函数的概念；`sort`的纯函数等价物如下：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: I can hear you thinking, *but the STL implementation works in place for optimization
    reasons, so are pure functions less optimized?* Well, as it turns out, pure functional
    programming languages, such as Haskell or Lisp, also optimize such operations;
    a `pureSort` implementation would just move the pointers around and only allocate
    more memory when one of the pointed values is changed. These are, however, two
    different contexts; C++ has to support multiple programming paradigms, while Haskell
    or Lisp optimize for immutability and functional style. We will discuss optimization
    further in [Chapter 10](4612efcd-7520-4ae3-9813-0c42acee664a.xhtml), *Performance
    Optimization*. For now, let's examine how to make these types of functions pure.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我能听到你在想，“但STL实现是为了优化而在原地工作，那么纯函数是否 less optimized呢？”事实证明，纯函数式编程语言，比如Haskell或Lisp，也会优化这样的操作；`pureSort`的实现只会移动指针，并且只有在指向的值之一发生变化时才会分配更多的内存。然而，这是两种不同的上下文；C++必须支持多种编程范式，而Haskell或Lisp则优化了不可变性和函数式风格。我们将在[第10章](4612efcd-7520-4ae3-9813-0c42acee664a.xhtml)中进一步讨论优化，即*性能优化*。现在，让我们来看看如何使这些类型的函数成为纯函数。
- en: 'We''ve discovered how to deal with one output parameter. But how can we write
    pure functions that will have multiple output parameters? Let''s consider the
    following example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经发现了如何处理一个输出参数。但是我们如何编写纯函数，使其具有多个输出参数呢？让我们考虑以下例子：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A simple solution to this problem would be to replace the two arguments with `vector<int>`.
    But what happens if the parameters have different types? Then, we could use a
    struct. But what if this is the only time we need it? Fortunately, STL offers
    a solution to this problem, that is, through tuples:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一个简单方法是用`vector<int>`替换这两个参数。但是如果参数具有不同的类型会怎么样？那么，我们可以使用一个结构体。但如果这是我们唯一需要它的时候呢？幸运的是，STL提供了解决这个问题的方法，即通过元组：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Tuples have a number of advantages, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 元组有许多优点，如下所示：
- en: They can be used with multiple values.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以用于多个值。
- en: The values can have different data types.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些值可以具有不同的数据类型。
- en: They are easy to build—just one function call.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们易于构建——只需一个函数调用。
- en: They don't require an additional data type.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不需要额外的数据类型。
- en: From my experience, tuples are a great solution when you are trying to render
    a function that has multiple output parameters pure, or a return value and an
    output parameter. However, I often try to refactor them toward named *struct*s
    or data classes after I figure out how to design them. Nonetheless, using tuples
    is a very useful technique; just use them sparingly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，当您尝试将具有多个输出参数的函数渲染为纯函数，或者返回值和输出参数时，元组是一个很好的解决方案。但是，我经常在设计完成后尝试将它们重构为命名的*struct*或数据类。尽管如此，使用元组是一个非常有用的技术；只是要适度使用。
- en: By now, we have used a lot of `static` functions. But aren't they bad practice?
    Well, that depends on a number of things; we'll discuss this in more detail next.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了很多`static`函数。但它们不是不好的实践吗？嗯，这取决于很多因素；我们将在接下来更详细地讨论这个问题。
- en: Aren't static functions bad practice?
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`static`函数不是不好的实践吗？'
- en: By now, you may be wondering whether pure functions are good since they contradict
    with the rules of **object-oriented programming** (**OOP**) or clean code, that
    is, to avoid `static`. However, until now, we've only written `static` functions.
    So, are they good or bad?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能会想知道纯函数是否好，因为它们与**面向对象编程**（**OOP**）或干净的代码规则相矛盾，即避免使用`static`。然而，直到现在，我们只编写了`static`函数。那么，它们是好的还是坏的呢？
- en: There are two arguments against using `static` functions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`static`函数有两个反对意见。
- en: The first argument against `static` functions is that they hide the global state.
    Since `static` functions can only access `static` values, those values become
    global state. Global state is bad because it's hard to understand who changes
    it, and it's also hard to debug when its value is unexpected.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对`static`函数的第一个反对意见是它们隐藏了全局状态。由于`static`函数只能访问`static`值，这些值就成为了全局状态。全局状态是不好的，因为很难理解是谁改变了它，当其值出乎意料时也很难调试。
- en: But remember the rules for pure functions—a pure function should return the
    same output values for the same input values. Therefore, a function is pure if,
    and only if, it does not depend on global state. Even when the program has a state,
    all the necessary values are sent to the pure functions as input parameters. Unfortunately,
    we cannot easily enforce this using the compiler; it has to be the practice of
    the programmer to avoid using any kind of global variable and to turn it into
    a parameter instead.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但要记住纯函数的规则——纯函数应该对相同的输入值返回相同的输出值。因此，只有当函数不依赖于全局状态时，函数才是纯的。即使程序有状态，所有必要的值也作为输入参数发送给纯函数。不幸的是，我们无法轻易地通过编译器来强制执行这一点；避免使用任何类型的全局变量并将其转换为参数，这必须成为程序员的实践。
- en: 'There''s an edge case for this situation, specifically when using global constants.
    While constants are an immutable state, it''s important to consider their evolution
    as well. For instance, consider the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，特别是在使用全局常量时有一个特例。虽然常量是不可变状态，但考虑它们的演变也很重要。例如，考虑以下代码：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, you should know that there will come a time when the constant will become
    a variable, and then you'll have to change a bunch of code to implement the new
    requirement. My advice is that it's usually better to pass in the constants as
    well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你应该知道，总会有一个时刻，常量会变成变量，然后你将不得不改变大量的代码来实现新的要求。我的建议是，通常最好也将常量作为参数传递进去。
- en: The second argument against `static` functions is that they shouldn't be part
    of a class. We will discuss this argument in more detail in the following chapters;
    suffice to say that, for now, classes should group cohesive functions, and, sometimes,
    the pure functions should fit together neatly in a class. There's also an alternative
    to grouping cohesive pure functions in a class—just use a namespace.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对`static`函数的第二个反对意见是它们不应该是类的一部分。我们将在接下来的章节中更详细地讨论这一观点；暂且可以说，类应该将具有内聚性的函数分组在一起，有时纯函数应该在类中整齐地组合在一起。将具有内聚性的纯函数分组在一个类中还有另一种选择——只需使用一个命名空间。
- en: Fortunately, we don't necessarily have to use `static` functions in classes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不一定要在类中使用`static`函数。
- en: Alternatives to static functions
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态函数的替代方案
- en: 'We discovered in the previous section how to write pure functions in a `Number`
    class by using `static` functions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中发现了如何通过使用`static`函数在`Number`类中编写纯函数：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'However, there''s another alternative; C++ allows us to avoid `static`, but
    keep the functions immutable:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有另一种选择；C++允许我们避免`static`，但保持函数不可变：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `const` keyword after each function signature just tells us that the function
    can access data members of the `Number` class, but can never change them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数签名后面的`const`关键字只告诉我们该函数可以访问`Number`类的数据成员，但永远不能改变它们。
- en: 'If we change this code slightly, we can ask an interesting question about immutability
    in the context of a class. If we initialize the number with a value and always
    add to the initial value, we obtain the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们稍微改变这段代码，我们可以在类的上下文中提出一个有趣的不可变性问题。如果我们用一个值初始化数字，然后总是加上初始值，我们就得到了以下代码：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here is an interesting question: is the `addToInitial` function pure? Let''s
    check the criteria as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的问题：`addToInitial`函数是纯的吗？让我们按照以下标准来检查：
- en: Does it have side effects? No, it doesn't.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有副作用吗？不，它没有。
- en: Does it return the same output value for the same input value? This is a tricky
    question because the function has a hidden parameter, that is, the `Number` class
    or its initial value. However, nobody can change `initialValue` from outside the
    `Number` class. In other words, the `Number` class is immutable. Therefore, the
    function will return the same output value for the same `Number` instance and
    the same parameter.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对相同的输入值返回相同的输出值吗？这是一个棘手的问题，因为函数有一个隐藏的参数，即`Number`类或其初始值。然而，没有人可以从`Number`类的外部改变`initialValue`。换句话说，`Number`类是不可变的。因此，该函数将对相同的`Number`实例和相同的参数返回相同的输出值。
- en: Does it change the values of its parameters? Well, it only receives one parameter,
    and it doesn't change it.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它改变了参数的值吗？嗯，它只接收一个参数，并且不改变它。
- en: The result is that the function is, in fact, pure. We will discover in the following
    chapter that it is also a *partially applied function*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是函数实际上是纯的。我们将在下一章中发现它也是*部分应用函数*。
- en: We previously mentioned that everything can be pure inside a program, except
    I/O. So, what do we do with the code that does I/O?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到程序中的一切都可以是纯的，除了I/O。那么，我们对执行I/O的代码怎么办？
- en: Pure functions and I/O
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数和I/O
- en: 'Take a look at the following and consider whether the function is pure:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下内容，并考虑该函数是否是纯的：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Well, let's see—it doesn't have arguments, so no value is changed. But something
    is off when compared to our previous example, that is, it doesn't return values.
    Instead, it calls a few functions, of which at least one is pure.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们看看——它没有参数，所以值没有改变。但与我们之前的例子相比，有些不对劲，也就是它没有返回值。相反，它调用了一些函数，其中至少有一个是纯的。
- en: 'So, does it have side effects? Well, yes; one on almost every line of code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它有副作用吗？嗯，几乎每行代码都有一个：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This line of code writes a line of string on the console, which is a side effect!
    `cout` is based on a mutable state, so it's not a pure function. Moreover, due
    to its external dependency, `cout` may fail, leading to exceptions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码在控制台上写了一行字符串，这是一个副作用！`cout`基于可变状态，因此它不是一个纯函数。此外，由于它的外部依赖性，`cout`可能会失败，导致异常。
- en: We need I/O in our programs though, so what can we do? Well, that's easy—simply
    separate the mutable from the immutable parts. Separate the side effects from
    the non-side effects and reduce the impure functions as much as possible.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的程序中需要I/O，但我们可以做什么呢？嗯，很简单——只需将可变部分与不可变部分分开。将副作用与非副作用分开，并尽量减少不纯的函数。
- en: 'So, how can we make this happen here? Well, there''s a pure function waiting
    to get out of this impure function. The key is to start from the problem; so,
    let''s separate `cout` as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在这里实现呢？嗯，有一个纯函数等待从这个不纯函数中脱颖而出。关键是从问题开始；所以，让我们将`cout`分离如下：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We have moved the side effects due to `cout` into another function, and have
    made the intent for the initial function clearer—which is that it's formatting
    something rather than printing. It seems as though we cleanly separated the pure
    function from the impure one.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将由`cout`引起的副作用移到另一个函数中，并使初始函数的意图更清晰——即格式化而不是打印。看起来我们很干净地将纯函数与不纯函数分开了。
- en: But did we? Let's check `formatResults` again. It doesn't have side effects,
    as it did before. We are using `stringstream`, which might not be pure, and are
    allocating memory, but all these things are local to the function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们真的吗？让我们再次检查`formatResults`。它没有副作用，就像以前一样。我们正在使用`stringstream`，这可能不是纯函数，并且正在分配内存，但所有这些都是函数内部的局部变量。
- en: Is memory allocation a side effect? Can a function that allocates memory be
    pure? After all, memory allocation may fail. However, it's virtually impossible
    to avoid some kind of memory allocation in functions. We will accept, therefore,
    that a pure function may fail if there's some kind of memory failure.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配是副作用吗？分配内存的函数可以是纯函数吗？毕竟，内存分配可能会失败。但是，在函数中几乎不可能避免某种形式的内存分配。因此，我们将接受一个纯函数可能会在某种内存失败的情况下失败。
- en: 'So, what about its output? Does it change? Well, it has no input parameters,
    but its output can change depending on the memory address allocated by the `new`
    operator. So, it''s not yet a pure function. How do we make it pure? That''s easy—let''s
    pass in a parameter, `pValue`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它的输出呢？它会改变吗？嗯，它没有输入参数，但它的输出可以根据`new`运算符分配的内存地址而改变。所以，它还不是一个纯函数。我们如何使它成为纯函数呢？这很容易——让我们传入一个参数，`pValue`：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we isolated ourselves from the side effects and mutable state. The code
    no longer depends on I/O or the `new` operator. Our function is pure, which brings
    additional benefits—it only does one thing, it's easier to understand what it
    does, it's predictable, and we can test it pretty easily.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使自己与副作用和可变状态隔离。代码不再依赖I/O或`new`运算符。我们的函数是纯的，这带来了额外的好处——它只做一件事，更容易理解它的作用，可预测，并且我们可以很容易地测试它。
- en: 'As for our function with side effects, consider the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 关于具有副作用的函数，考虑以下代码：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: I think that we can all agree that it's easy to understand what it does, and
    we can safely ignore it as long as all our other functions are pure.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们都可以同意，很容易理解它的作用，只要我们的其他函数都是纯函数，我们可以安全地忽略它。
- en: In conclusion, to obtain code that's more predictable, we should separate pure
    from impure functions, and push the impure functions to the boundaries of the
    system as much as possible. There may be situations when this change is expensive,
    and it's perfectly fine to have impure functions in your code. Just make sure
    you know which are which.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，为了获得更可预测的代码，我们应该尽可能地将纯函数与不纯函数分开，并尽可能将不纯函数推到系统的边界。在某些情况下，这种改变可能很昂贵，拥有不纯函数在代码中也是完全可以的。只要确保你知道哪个是哪个。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we explored how to write pure functions in C++. Since there
    are a few tricks that you need to remember, here''s a list of the recommended
    syntax:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何在C++中编写纯函数。由于有一些需要记住的技巧，这里是推荐的语法列表：
- en: 'Class functions for pass by value:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过值传递的类函数：
- en: '`static int increment(const int value)`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static int increment(const int value)`'
- en: '`int increment(const int value) const`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int increment(const int value) const`'
- en: 'Class functions for pass by reference:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引用传递的类函数：
- en: '`static int increment(const int& value)`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static int increment(const int& value)`'
- en: '`int increment(const int&value) const`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int increment(const int&value) const`'
- en: 'Class functions for pass pointer by value:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过值传递指针的类函数：
- en: '`static const int* increment(const int* const value)`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static const int* increment(const int* const value)`'
- en: '`const int* increment(const int* const value) const`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const int* increment(const int* const value) const`'
- en: 'Class functions for pass pointer by reference:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引用传递的类函数：
- en: '`static const int* increment(const int* const& value)`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static const int* increment(const int* const& value)`'
- en: '`const int* increment(const int* const& value) const`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const int* increment(const int* const& value) const`'
- en: 'A standalone function for pass by value: ``int increment(const int value)``'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过值传递的独立函数：`int increment(const int value)`
- en: 'A standalone function for pass by reference: `int increment(const int& value)`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引用传递的独立函数：`int increment(const int& value)`
- en: 'A standalone function for pass pointer by value: `const int* increment(const
    int* value)`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过值传递指针的独立函数：`const int* increment(const int* value)`
- en: A standalone function for pass pointer by reference: `const int* increment(const
    int* const& value)`
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引用传递的独立函数：`const int* increment(const int* const& value)`
- en: 'We''ve also discovered that, while the compiler is helpful to reduce side effects,
    it doesn''t always tell us when a function is pure or not. We always need to remember
    the criteria to use when writing a pure function, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现，虽然编译器有助于减少副作用，但并不总是告诉我们函数是纯函数还是不纯函数。我们始终需要记住编写纯函数时要使用的标准，如下所示：
- en: It always returns the same output values for the same input values.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它总是对相同的输入值返回相同的输出值。
- en: It has no side effects.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有副作用。
- en: It does not change the values of the input parameters.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会改变输入参数的值。
- en: Finally, we saw how to separate side effects, usually related to I/O, from our
    pure functions. It's pretty easy, and it usually requires passing in values and
    extracting functions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了如何将通常与I/O相关的副作用与我们的纯函数分离。这很容易，通常需要传入值并提取函数。
- en: It's now time to move forward. We can do much more with functions when we treat
    them as first class citizens of our designs. To do that, we need to learn what
    lambdas are and how they are useful. We'll do this in the next chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向前迈进了。当我们将函数视为设计的一等公民时，我们可以做更多事情。为此，我们需要学习lambda是什么以及它们如何有用。我们将在下一章中学习这个。
- en: Questions
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a pure function?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是纯函数？
- en: How is immutability related to pure functions?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不可变性与纯函数有什么关系？
- en: How can you tell the compiler to prevent changes to a variable that's passed
    by value?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何告诉编译器防止对按值传递的变量进行更改？
- en: How can you tell the compiler to prevent changes to a variable that's passed
    by reference?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何告诉编译器防止对按引用传递的变量进行更改？
- en: How can you tell the compiler to prevent changes to a pointer address that's
    passed by reference?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何告诉编译器防止对按引用传递的指针地址进行更改？
- en: How can you tell the compiler to prevent changes to the value that's pointed
    by a pointer?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何告诉编译器防止对指针指向的值进行更改？
