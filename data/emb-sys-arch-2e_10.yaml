- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Parallel Tasks and Scheduling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行任务和调度
- en: When the complexity of the system increases and the software has to manage multiple
    peripherals and events at the same time, it is more convenient to rely on an operating
    system to coordinate and synchronize all the different operations. Separating
    the application logic into different threads offers a few important architectural
    advantages. Each component performs the designed operation within its running
    unit, and it may release the CPU while it is suspended, or waiting for input or
    a timeout event.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统的复杂性增加，软件需要同时管理多个外围设备和事件时，依赖操作系统来协调和同步所有不同的操作会更加方便。将应用程序逻辑分离到不同的线程中提供了一些重要的架构优势。每个组件在其运行单元内执行设计的操作，并且当它暂停或等待输入或超时事件时，它可以释放CPU。
- en: In this chapter, the mechanisms used to implement a multithreading embedded
    operating system will be covered. This will be done through the development of
    a minimalistic operating system tailored to the reference platform, and written
    step by step from scratch, providing a working scheduler to run multiple tasks
    in parallel.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将介绍实现多线程嵌入式操作系统的机制。这将通过开发针对参考平台定制的最小化操作系统来完成，并从头开始逐步编写，提供一个可运行的调度器以并行运行多个任务。
- en: The scheduler’s internals are mostly implemented within system service calls,
    and its design impacts the system’s performance and other features, such as different
    priority levels and time constraints for real-time-dependent tasks. Some of the
    possible scheduling policies, for different contexts, will be explained and implemented
    in the example code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器的内部实现主要在系统服务调用中完成，其设计影响系统的性能和其他特性，例如实时相关任务的优先级水平和时间约束。在示例代码中，将解释和实现一些可能的调度策略，针对不同的上下文。
- en: Running multiple threads in parallel implies that resources can be shared, and
    there is the possibility of concurrent access to the same memory. Most microprocessors
    designed to run multithreading systems provide primitive functions, accessible
    through specific assembly instructions, to implement locking mechanisms such as
    semaphores. Our example operating system exposes mutex and semaphore primitives
    that can be used by the threads to control access to shared resources.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 并行运行多个线程意味着资源可以被共享，并且存在对同一内存的并发访问的可能性。大多数设计用于运行多线程系统的微处理器提供原始函数，通过特定的汇编指令可访问，以实现如信号量之类的锁定机制。我们的示例操作系统公开了互斥锁和信号量原始函数，线程可以使用它们来控制对共享资源的访问。
- en: By introducing memory protection mechanisms, it is possible to provide a separation
    of the resources based on their addresses and let the kernels supervise all the
    operations involving the hardware through a system call interface. Most real-time
    embedded operating systems prefer a flat model with no segmentation to keep the
    kernel code as small as possible, and with a minimal API to optimize the resources
    available for the applications. The example kernel will show us how to create
    a system call API to centralize the control of the resources, using physical memory
    segmentation to protect the resources of the kernel, the system control block,
    the mapped peripherals, and the other tasks, to increase the level of safety of
    the system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入内存保护机制，可以根据它们的地址提供资源分离，并让内核通过系统调用接口监督所有涉及硬件的操作。大多数实时嵌入式操作系统更喜欢无段化的扁平模型，以尽可能减小内核代码的大小，并使用最小化的API来优化应用程序可用的资源。示例内核将向我们展示如何创建系统调用API来集中控制资源，使用物理内存分段来保护内核、系统控制块、映射的外围设备和其他任务，以增加系统的安全性级别。
- en: 'This chapter is split into the following sections:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为以下部分：
- en: Task management
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务管理
- en: Scheduler implementation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度器实现
- en: Synchronization
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步
- en: System resource separation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统资源分离
- en: By the end of this chapter, you will have learned how to build a multithreaded
    embedded environment.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学会如何构建一个多线程嵌入式环境。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter10).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码文件，链接为[https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Embedded-Systems-Architecture-Second-Edition/tree/main/Chapter10)。
- en: Task management
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务管理
- en: An operating system provides the abstraction of parallel running processes and
    threads by alternating the applications to run in parallel. In fact, on systems
    with a single CPU, there can only be one running thread at a time. While the running
    thread executes, all the others are waiting in line until the next task switch.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统通过交替运行并行应用程序来提供并行运行进程和线程的抽象。实际上，在单CPU系统中，一次只能有一个运行线程。当运行线程执行时，所有其他线程都在等待队列中，直到下一个任务切换。
- en: In a cooperative model, switching the task is always a voluntary action requested
    by the thread implementation. The opposite approach, known as **preemption**,
    requires that the kernel periodically interrupts tasks at any point of their execution,
    to temporarily save the status and resume the next task in line.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在协作模型中，任务切换始终是线程实现请求的自愿行为。相反的方法，称为**抢占**，要求内核在任务的任何执行点定期中断任务，暂时保存状态并恢复下一个任务。
- en: Switching the running task consists of storing the values of the CPU registers
    in RAM, and loading from memory those of the next task that has been selected
    for running. This operation is better known as **context switching** and is the
    core of the scheduling system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 切换正在运行的任务包括将CPU寄存器的值存储在RAM中，并从内存中加载已选为运行的下个任务的值。这个操作更广为人知的是**上下文切换**，它是调度系统的核心。
- en: The task block
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务块
- en: Tasks are represented in the system in the form of a task block structure. This
    object contains all the information needed for the scheduler to keep track of
    the state of the task at all times and is dependent on the design of the scheduler.
    Tasks might be defined at compile time and started after the kernel boots, or
    spawned and terminated while the system is running.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中，任务以任务块结构的形式表示。此对象包含调度器在所有时间跟踪任务状态所需的所有信息，并且依赖于调度器的设计。任务可能在编译时定义，在内核启动后启动，或者在系统运行时生成和终止。
- en: Each task block may contain a pointer to the start function, which defines the
    beginning of the code that is executed when the task is spawned, and a set of
    optional arguments. Memory is assigned for each task to use as its private stack
    region. This way, the execution context of each thread and process is separated
    from all the others, and the values of the registers can be stored in a task-specific
    memory area when the task is interrupted. The task-specific stack pointer is stored
    in the task block structure, and it is used to store the values of the CPU register
    upon context switches.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务块可能包含一个指向起始函数的指针，该函数定义了在任务生成时执行的代码的开始，以及一组可选参数。为每个任务分配内存作为其私有堆栈区域。这样，每个线程和进程的执行上下文就与其他所有上下文分离，当任务被中断时，寄存器的值可以存储在特定于任务的内存区域中。特定于任务的堆栈指针存储在任务块结构中，并在上下文切换时用于存储CPU寄存器的值。
- en: Running with separate stacks requires that some memory is reserved in advance,
    and associated with each task. In the simplest case, all tasks using a stack of
    the same size are created before the scheduler starts and cannot be terminated.
    This way, the memory that has been reserved to be associated with private stacks
    can be contiguous and associated with each new task. The memory region used for
    the stack areas can be defined in the linker script.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单独的堆栈运行需要预先保留一些内存，并将其与每个任务关联。在最简单的情况下，所有使用相同大小堆栈的任务都在调度器启动之前创建，并且不能被终止。这样，已保留以与私有堆栈关联的内存可以连续，并关联到每个新任务。用于堆栈区域的内存区域可以在链接脚本中定义。
- en: 'The reference platform has a separate core-coupled memory, mapped at `0x10000000`.
    Among the many ways to arrange the memory sections, we have decided to map the
    start of the stack space, used to associate stack areas with the threads, at the
    beginning of the CCRAM. The remaining CCRAM space is used as a stack for the kernel,
    which leaves all the SRAM, excluding the `.data` and `.bss` sections, for heap
    allocation. The pointers are exported by the linker script with the following
    `PROVIDE` instructions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 参考平台有一个独立的内核耦合内存，映射在`0x10000000`。在众多安排内存段的方法中，我们决定将用于将堆栈区域与线程关联的堆栈空间起始部分映射到CCRAM的开始处。剩余的CCRAM空间用作内核的堆栈，这样就将所有SRAM（除了`.data`和`.bss`部分）留给了堆分配。指针通过链接脚本中的以下`PROVIDE`指令导出：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the kernel source, `stack_space` is declared as external, because it is
    exported by the linker script. We also declare the amount of space reserved for
    the execution stack of each task (expressed in four-byte words):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核源代码中，`stack_space`被声明为外部，因为它由链接脚本导出。我们还声明了为每个任务的执行堆栈保留的空间量（以四字节词表示）：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Every time a new task is created, the next kilobyte in the stack space is assigned
    as its execution stack, and the initial stack pointer is set at the highest address
    in the area since the execution stack grows backward:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建新任务时，堆栈空间中的下一个千字节被分配为其执行堆栈，初始堆栈指针被设置为该区域的最高地址，因为执行堆栈向后增长：
- en: '![Figure 10.1 – Memory configuration used to provide separate execution stacks
    to tasks](img/B18730_10_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 为任务提供单独执行堆栈所使用的内存配置](img/B18730_10_01.jpg)'
- en: Figure 10.1 – Memory configuration used to provide separate execution stacks
    to tasks
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 为任务提供单独执行堆栈所使用的内存配置
- en: 'A simple task block structure can then be declared, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可以声明一个简单的任务块结构，如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A global array is defined to contain all the task blocks of the system. We
    must use a global index to keep track of the tasks already created so that we
    can use the position in memory relative to the task identifier and the ID of the
    currently running task:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个全局数组来包含系统的所有任务块。我们必须使用全局索引来跟踪已创建的任务，以便我们可以使用相对于任务标识符和当前运行任务的ID在内存中的位置：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this model, the task block is pre-allocated in the data section, and the
    fields are initialized in place, keeping track of the index. The first element
    of the array is reserved for the task block of the kernel, which is the currently
    running process.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此模型，任务块在数据段中预先分配，字段就地初始化，并跟踪索引。数组的第一个元素是为内核的任务块保留的，它是当前正在运行的过程。
- en: 'In our example, tasks are created by invoking the `task_create` function and
    providing a name, an entry point, and its argument. For a static configuration
    with a predefined number of tasks, this is done when the kernel is initialized,
    but more advanced schedulers may allow us to allocate new control blocks to spawn
    new processes at runtime, while the scheduler is running:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，通过调用`task_create`函数并提供一个名称、入口点和其参数来创建任务。对于具有预定义任务数量的静态配置，这通常在内核初始化时完成，但更高级的调度器可能允许我们在调度器运行时分配新的控制块以在运行时生成新进程：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To implement the `task_stack_init` function, which initializes the values in
    the stack for the process to start running, we need to understand how the context
    switch works, and how new tasks are started when the scheduler is running.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`task_stack_init`函数，该函数初始化进程开始运行时堆栈中的值，我们需要了解上下文切换的工作原理，以及当调度器运行时如何启动新任务。
- en: Context switch
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文切换
- en: 'The context switch procedure consists of getting the values of the CPU register
    during the execution and saving them at the bottom of the stack of the currently
    running task. Then, we must restore the values for the next task to resume its
    execution. This operation must happen in the interrupt context, and its internal
    mechanisms are CPU-specific. On the reference platform, any interrupt handler
    can replace the currently running task and restore another context, but this operation
    is more often done within interrupt service routines associated with system events.
    Cortex-M provides two CPU exceptions that are designed to provide the basic support
    for context switching because they can be arbitrarily triggered in any context:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文切换过程包括在执行期间获取CPU寄存器的值，并将它们保存在当前正在运行的任务的堆栈底部。然后，我们必须恢复下一个任务的值以恢复其执行。此操作必须在中断上下文中发生，其内部机制是CPU特定的。在参考平台上，任何中断处理程序都可以替换当前正在运行的任务并恢复另一个上下文，但这种操作更常在关联于系统事件的断电服务例程中完成。Cortex-M提供了两个CPU异常，它们旨在为上下文切换提供基本支持，因为它们可以在任何上下文中任意触发：
- en: '**PendSV**: This is the default way for a preemptive kernel to force an interrupt
    in the immediate future, after setting one bit in a specific register within the
    system control block, and it is usually associated with the context switch of
    the next task.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PendSV**：这是抢占式内核在设置系统控制块中特定寄存器的一个位后，强制在不久的将来发生中断的默认方式，它通常与下一个任务的上下文切换相关联。'
- en: '**SVCall**: This is the main entry point for the user application to submit
    a formal request to access a resource that is managed by the kernel. This feature
    is designed to provide an API to access the kernel safely to request operations
    from a component or a driver. As the result of the operation may be not immediately
    available, SVCall can also permit preempting the calling task to provide the abstraction
    of blocking system calls.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SVCall**：这是用户应用程序提交正式请求以访问由内核管理的资源的入口点。这个特性是为了提供一个 API 来安全地访问内核，请求从组件或驱动程序的操作。由于操作的结果可能不会立即可用，SVCall
    还可以允许抢占调用任务以提供阻塞系统调用的抽象。'
- en: 'The routines used to store and restore the values of the CPU registers to/from
    memory during the context switch are partially implemented in hardware on the
    Cortex-M CPU. This means that, when the interrupt is entered, a copy of part of
    the register is automatically pushed into the stack. The copy of the registers
    in the stack is called the **stack frame**, and contains registers **R0** to **R3**,
    **R12**, **LR**, **PC**, and **xPSR**, in the order shown in the following figure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文切换期间用于将 CPU 寄存器的值存储到或从内存中恢复的例程在 Cortex-M CPU 上部分由硬件实现。这意味着当进入中断时，寄存器的一部分副本会自动推送到堆栈中。堆栈中的寄存器副本称为
    **堆栈帧**，包含 **R0** 到 **R3**、**R12**、**LR**、**PC** 和 **xPSR** 寄存器，顺序如下所示：
- en: '![Figure 10.2 – Registers are automatically copied to the stack when entering
    an interrupt handler](img/B18730_10_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 当进入中断处理程序时，寄存器会自动复制到堆栈中](img/B18730_10_02.jpg)'
- en: Figure 10.2 – Registers are automatically copied to the stack when entering
    an interrupt handler
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 当进入中断处理程序时，寄存器会自动复制到堆栈中
- en: 'The stack pointer, however, does not include the other half of the CPU registers
    – that is, R4 to R11\. For this reason, to complete the context switch successfully,
    a system handler that intends to replace the running process must store the extra
    stack frame containing the value for these registers, and restore the extra stack
    frame of the next task just before returning from the handler. ARM Thumb-2 assembly
    provides instructions on how to push the value of contiguous CPU registers to
    the stack and pop them back in place. The following two functions are used to
    push and pop the extra stack frame in the stack:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，堆栈指针不包括 CPU 寄存器的另一半 – 即 R4 到 R11。因此，为了成功完成上下文切换，打算替换正在运行的进程的系统处理程序必须存储包含这些寄存器值的额外堆栈帧，并在从处理程序返回之前恢复下一个任务的额外堆栈帧。ARM
    Thumb-2 汇编提供了如何将连续 CPU 寄存器的值推送到堆栈并恢复到原位的指令。以下两个函数用于在堆栈中推入和弹出额外堆栈帧：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `((naked))` attribute is used to prevent GCC from putting prologue and epilogue
    sequences, consisting of a few assembly instructions each, into the compiled code.
    The prologue would change the values of some of the registers in the extra stack
    frame area, which would be restored in the epilogue, and this conflicts with the
    purpose of the functions accessing register values using assembly instructions.
    Due to the missing epilogue, the `naked` functions return by jumping back to the
    calling instruction, which is stored in the LR register.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`((naked))` 属性用于防止 GCC 将由几个汇编指令组成的序言和尾随序列放入编译代码中。序言会改变额外堆栈帧区域中的一些寄存器的值，这些值将在尾随中恢复，这与使用汇编指令访问寄存器值的函数的目的相冲突。由于缺少尾随，`naked`
    函数通过跳转回调用指令（存储在 LR 寄存器中）来返回。'
- en: 'As a result of the assembly push operation, this is how the stack of the process
    being preempted looks:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于汇编 push 操作的结果，被抢占的进程的堆栈看起来是这样的：
- en: "![Figure 10.3 – The remaining register values are copied to the stack to complete\
    \ the co\uFEFFntext switch](img/B18730_10_03.jpg)"
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 剩余的寄存器值被复制到堆栈中以完成上下文切换](img/B18730_10_03.jpg)'
- en: Figure 10.3 – The remaining register values are copied to the stack to complete
    the context switch
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 剩余的寄存器值被复制到堆栈中以完成上下文切换
- en: Creating tasks
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建任务
- en: When the system is running, all the tasks except the one running are in a *wait*
    state, which means that the full stack frame is saved at the bottom of the stack,
    and the stack pointer is stored in the control block to be used by the scheduler
    to resume each process.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统运行时，除了正在运行的进程外，所有任务都处于 *等待* 状态，这意味着完整的堆栈帧被保存在堆栈底部，堆栈指针被存储在控制块中以供调度器用于恢复每个进程。
- en: A newly created task will wake up for the first time in the middle of the context
    switch. At that point, the task is expected to have preserved the previous state
    of its CPU registers, but obviously, a new task does not have such a thing. Upon
    stack creation, a forged stack frame is pushed to the end of the stack so that
    when the task resumes, the values stored are copied into the system registers,
    and the task can resume from its entry point.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的任务将在上下文切换的中间醒来第一次。在那个时刻，预期任务将保留其CPU寄存器的先前状态，但显然，新任务没有这样的东西。在堆栈创建时，一个伪造的堆栈帧被推到堆栈的末尾，以便当任务恢复时，存储的值被复制到系统寄存器中，任务可以从其入口点恢复。
- en: 'The `task_create` function relies on a stack initialization function, `task_stack_init`,
    which pushes the initial values for the system registers to allow the task to
    be restored and moves the stored stack pointer to the beginning of the extra frame,
    which can be left uninitialized. To easily access the stored register in the stack
    frame, we must declare a `stack_frame` structure that uses one field per register,
    and an `extra_frame` structure, just for completeness:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`task_create`函数依赖于一个堆栈初始化函数`task_stack_init`，该函数将系统寄存器的初始值推送到堆栈，以便任务可以恢复，并将存储的堆栈指针移动到额外帧的开始，该帧可以留作未初始化。为了方便访问堆栈帧中存储的寄存器，我们必须声明一个`stack_frame`结构，该结构使用一个字段对应一个寄存器，以及一个`extra_frame`结构，仅为了完整性：'
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once the context has been restored, the exception handler return procedure
    automatically restores the context from the stack frame we are forging. The registers
    for the starting task are initialized as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上下文已恢复，异常处理程序返回过程会自动从我们正在构建的堆栈帧中恢复上下文。起始任务的寄存器初始化如下：
- en: The **program counter** (**PC**) contains the address of the start function,
    where the system will jump to switch to this task for the first time.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序计数器**（**PC**）包含起始函数的地址，系统将跳转到该地址以切换到该任务，这是第一次切换到该任务。'
- en: '`task_create`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`task_create`。'
- en: The **execution program status register** (**xPSR**) must be programmed to have
    only the mandatory thumb flag set at bit 24.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行程序状态寄存器**（**xPSR**）必须编程为仅在位24处设置强制性的Thumb标志。'
- en: The `task_terminated` function is just an infinite loop, and it is considered
    a system error. In other cases, if tasks are allowed to terminate, a function
    can be set as a common exit point for the tasks, to perform the cleanup operations
    required upon returning from the start function.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`task_terminated`函数只是一个无限循环，被视为系统错误。在其他情况下，如果允许任务终止，可以设置一个函数作为任务的通用退出点，以执行从起始函数返回所需的清理操作。'
- en: 'Once the initial stack frame has been created, the task can participate in
    multitasking, and can be picked by the scheduler at any time to resume the execution,
    from the same state as all the other tasks not running:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了初始堆栈帧，任务就可以参与多任务，并且可以在任何时间被调度器选中以恢复执行，从与所有其他未运行任务相同的状态：
- en: '![Figure 10.4 – Stack pointers of three tasks during different execution states](img/B18730_10_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 在不同执行状态下三个任务的栈指针](img/B18730_10_04.jpg)'
- en: Figure 10.4 – Stack pointers of three tasks during different execution states
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 在不同执行状态下三个任务的栈指针
- en: 'Our simple kernel main function can now create processes and prepare the stack
    but is not yet actually able to run them until we implement the scheduler internals.
    Timekeeping is useful in this case, so `SysTick` is enabled at startup to keep
    track of time in the system. The task block of the kernel is initialized, and
    two new tasks are created:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的内核主函数现在可以创建进程并准备堆栈，但尚未实际运行它们，直到我们实现了调度器的内部机制。在这种情况下，时间跟踪很有用，因此`SysTick`在启动时被启用以跟踪系统中的时间。内核的任务块被初始化，并创建了两个新任务：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The two main tasks are created so that they point to different start functions,
    and both have `NULL` as argument. Both functions should never return and can be
    interrupted and resumed according to the implemented scheduler policy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的两个主要任务指向不同的起始函数，并且两者都将参数设置为`NULL`。这两个函数都不应该返回，并且可以根据实现的调度器策略被中断和恢复。
- en: To proceed from this point, the scheduler’s internals need to be implemented
    to start and alternate the execution of the parallel tasks we just defined.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要从这一点继续，需要实现调度器的内部机制以启动和交替执行我们刚刚定义的并行任务。
- en: Scheduler implementation
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度器实现
- en: The architecture of the system depends on the way the scheduler is implemented.
    Tasks can be running in a cooperative model until they voluntarily decide to yield
    the CPU to the next task, or the OS can decide to trigger an interrupt to swap
    the running task behind the scenes, applying a specific policy to decide the interval
    in between task switches and the priority for the selection of the next task.
    In both cases, the context switch happens within one of the supervisor calls available,
    set to decide which tasks to schedule next, and to perform the context switch.
    In this section, the full context switch procedure through PendSV will be added
    to our example, and then a few of the possible scheduling policies will be analyzed
    and implemented.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的架构取决于调度器的实现方式。任务可以在协作模式下运行，直到它们自愿决定将 CPU 交由下一个任务，或者操作系统可以决定触发中断以在幕后交换正在运行的任务，并应用特定策略来决定任务切换之间的间隔以及选择下一个任务的优先级。在两种情况下，上下文切换都发生在可用的监督调用之一中，用于决定下一个要调度的任务，并执行上下文切换。在本节中，将通过
    PendSV 添加完整的上下文切换过程到我们的示例中，然后分析并实现一些可能的调度策略。
- en: Supervisor calls
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监督调用
- en: 'The core component of the scheduler consists of the exception handler associated
    with the system interrupt events, such as PendSV and SVCall. On Cortex-M, a PendSV
    exception can be triggered at any time by the software by setting the `PENDSET`
    flag, corresponding to bit 28 of the interrupt control and state register, located
    in the SCB at address `0xE000ED04`. A simple macro is defined to initiate the
    context switch by setting the flag:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器的核心组件是与系统中断事件（如 PendSV 和 SVCall）关联的异常处理器。在 Cortex-M 上，可以通过设置 `PENDSET` 标志在任何时候由软件触发
    PendSV 异常，对应于中断控制和状态寄存器的第 28 位，位于地址 `0xE000ED04` 的 SCB 中。定义了一个简单的宏来通过设置标志来启动上下文切换：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The call to schedule from the kernel, and all the subsequent calls, will cause
    a context switch, which can now be implemented in the PendSV handler. To complete
    a context switch, the handler has to perform the following steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 来自内核的调度调用以及所有后续调用都将导致上下文切换，现在可以在 PendSV 处理器中实现。为了完成上下文切换，处理器必须执行以下步骤：
- en: Store the current stack pointer from the SP register in the task block.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前栈指针从 SP 寄存器存储到任务块中。
- en: Push the extra stack frame to the stack by calling `store_context`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `store_context` 将额外的栈帧推入栈中。
- en: Change the state of the current task to `TASK_READY`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前任务的状态更改为 `TASK_READY`。
- en: Select a new task to resume.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个新任务以恢复。
- en: Change the state of the new task to `TASK_RUNNING`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新任务的状态更改为 `TASK_RUNNING`。
- en: Retrieve the new stack pointer from the associated task block.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从关联的任务块中检索新的栈指针。
- en: Pop the extra stack frame from the stack by calling `restore_context`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `restore_context` 从栈中弹出额外的栈帧。
- en: Set a special return value for the interrupt handler to activate thread mode
    at the end of the PendSV service routine.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为中断处理器设置一个特殊的返回值，以在 PendSV 服务例程结束时激活线程模式。
- en: 'The `isr_pendsv` function must be naked because it accesses the CPU register
    directly through the `store` and `restore_context` functions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`isr_pendsv` 函数必须是裸函数，因为它通过 `store` 和 `restore_context` 函数直接访问 CPU 寄存器：'
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The value that is loaded in the LR before returning is used to indicate that
    we are returning to thread mode at the end of this interrupt. Depending on the
    value of the last 3 bits, the service routine informs the CPU which stack pointer
    to use when returning from the interrupt. The `0xFFFFFFF9` value used in this
    case corresponds to thread mode using the main stack pointer. Different values
    will be needed later on when the example is expanded to support separate stack
    pointers between the kernel and the process.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回之前加载到 LR 的值用于指示我们在中断结束时返回到线程模式。根据最后 3 位值的差异，服务例程通知 CPU 在从中断返回时使用哪个栈指针。在这种情况下使用的
    `0xFFFFFFF9` 值对应于使用主栈指针的线程模式。在示例扩展以支持内核和进程之间具有单独栈指针时，将需要不同的值。
- en: With that, the complete context has been implemented inside the PendSV service
    routine, which for now is simply selecting the next task and wraps around to execute
    the kernel with an ID of `0` after the last task in the array. The service routine
    is triggered to run in handler mode every time the schedule macro is called.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，完整的上下文已经在 PendSV 服务例程中实现，目前它只是选择下一个任务，并在数组中的最后一个任务之后执行具有 ID `0` 的内核。每当调用调度宏时，都会触发服务例程以处理模式运行。
- en: Cooperative scheduler
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作调度器
- en: Different policies can be defined to alternate the execution of the tasks in
    the system. In the simplest case, the main functions of each task voluntarily
    suspend its execution by invoking the schedule macro.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义不同的策略来交替系统中任务的执行。在最简单的情况下，每个任务通过调用调度宏自愿挂起其执行。
- en: 'In this example implementation, two threads have been defined. Both will turn
    on an LED and hold the CPU in a busy loop for 1 second before turning off the
    LED and explicitly calling the `schedule()` function to trigger a context switch:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例实现中，定义了两个线程。它们都将打开一个LED，并在关闭LED并显式调用`schedule()`函数以触发上下文切换之前，在忙循环中占用CPU
    1秒钟：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The little operating system is finally working, and the kernel is scheduling
    the two tasks in sequence. The task with an ID of `0` is also resumed at the beginning
    of each loop, but in this simple case, the kernel task is only calling the schedule
    in a loop, immediately resuming the task with an ID of `1`. With this design,
    the reactivity of the system depends entirely on the implementation of the tasks,
    as each task can hold the CPU indefinitely, and prevent other tasks from running.
    The cooperative model is only used in very specific scenarios, where each task
    is directly responsible for regulating its CPU cycles and cooperating with the
    other threads, and may impact the responsiveness and the fairness of the entire
    system.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小操作系统终于运行起来了，内核正在按顺序调度两个任务。具有ID `0` 的任务在每个循环的开始时也会恢复，但在这种简单的情况下，内核任务只是在循环中调用调度，立即恢复ID为
    `1` 的任务。这种设计下，系统的反应性完全取决于任务的实现，因为每个任务可以无限期地占用CPU，从而阻止其他任务运行。协作模型仅在非常特定的场景中使用，其中每个任务直接负责调节其CPU周期并与其他线程协作，这可能会影响整个系统的响应性和公平性。
- en: For the sake of simplicity, this implementation does not take into account the
    wrap-around of the `jiffies` variable. If incremented every millisecond, `jiffies`
    would overflow its maximum value after about 42 days. Real operating systems,
    unlike our simplistic example, must implement an appropriate mechanism to compare
    time variables, not shown here, that can detect the wrap-around while calculating
    time differences.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，这个实现没有考虑到`jiffies`变量的回绕。如果每毫秒增加一次，`jiffies`会在大约42天后溢出其最大值。与我们的简单示例不同，真正的操作系统必须实现一个适当的机制来比较时间变量，这里没有展示，该机制可以在计算时间差时检测到回绕。
- en: Concurrency and timeslices
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发和时间片
- en: A different approach consists of assigning short intervals of CPU time to each
    task and continuously swapping processes at very short intervals. A preemptive
    scheduler autonomously interrupts the running task to resume the next one without
    an explicit request from the task itself. It can also impose its policy regarding
    the selection of the next task to run and the duration of the interval where the
    CPU is assigned to each task, namely its timeslice.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是为每个任务分配短时间段的CPU时间，并在非常短的时间间隔内不断交换进程。抢占式调度器可以自主中断正在运行的任务，以恢复下一个任务，而无需任务本身的显式请求。它还可以强制执行其关于选择下一个要运行的任务以及CPU分配给每个任务的持续时间（即其时间片）的政策。
- en: 'From the task’s point of view, the execution can now be continuous and completely
    independent from the scheduler, which acts behind the scenes to interrupt and
    resume each task continuously, giving the illusion that all the tasks are running
    at the same time. The threads can be redefined to blink the LEDs at two different
    intervals:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从任务的角度来看，执行现在可以连续进行，并且完全独立于调度器，调度器在幕后不断中断和恢复每个任务，给人一种所有任务都在同时运行的错觉。可以将线程重新定义为在两个不同的间隔闪烁LED：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To alternate tasks in a round-robin fashion, we can trigger the execution of
    PendSV from within the SysTick handler, which results in a task switch that occurs
    at regular intervals. The new SysTick handler triggers a context switch every
    `TIMESLICE` milliseconds:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以轮询方式交替任务，我们可以在SysTick处理程序内部触发PendSV的执行，这会导致在固定间隔发生任务切换。新的SysTick处理程序每`TIMESLICE`毫秒触发一次上下文切换：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this new configuration, we now have a more complete model, allowing multiple
    tasks to run independently, and the scheduling to be supervised completely by
    the kernel.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的配置中，我们现在有一个更完整的模型，允许多个任务独立运行，并且调度完全由内核监督。
- en: Blocking tasks
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻塞任务
- en: 'The simple scheduler we have implemented so far provides only two states for
    the tasks: `TASK_READY` and `TASK_RUNNING`. A third state can be implemented to
    define a task that does not need to be resumed because it has been blocked and
    is waiting for an event or a timeout. A task can be waiting for a system event
    of some type, such as the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止实现的简单调度器只为任务提供了两种状态：`TASK_READY`和`TASK_RUNNING`。可以实施第三个状态来定义一个不需要恢复的任务，因为它已被阻塞并正在等待事件或超时。任务可以等待某种类型的系统事件，如下所示：
- en: Interrupt events from an **input/output** (**I/O**) device in use by the task
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自正在使用的**输入/输出**（**I/O**）设备的中断事件
- en: Communication from another task, such as the TCP/IP stack
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自另一个任务的通信，例如TCP/IP堆栈
- en: Synchronization mechanisms, such as a mutex or a semaphore, to access a shared
    resource in the system that is currently unavailable
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步机制，如互斥锁或信号量，用于访问系统中当前不可用的共享资源
- en: Timeout events
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超时事件
- en: 'To manage the different states, the scheduler may implement two or more lists
    to separate the tasks currently running, or ready to run, from those waiting for
    an event. The scheduler then selects the next task among those in the `TASK_READY`
    state, and ignores the ones in the list of blocked tasks:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理不同的状态，调度器可以实施两个或更多列表来区分当前正在运行或准备运行的任务与等待事件的那些任务。然后，调度器从`TASK_READY`状态的那些任务中选择下一个任务，并忽略列表中阻塞的任务：
- en: '![Figure 10.5 – State machine describing the task’s execution states](img/B18730_10_05.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 描述任务执行状态的有限状态机](img/B18730_10_05.jpg)'
- en: Figure 10.5 – State machine describing the task’s execution states
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 描述任务执行状态的有限状态机
- en: 'This second version of the scheduler keeps track of the currently running task
    using a global pointer, instead of the index of the array, and organizes the tasks
    into two lists:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调度器的第二个版本使用全局指针跟踪当前正在运行的任务，而不是数组的索引，并将任务组织成两个列表：
- en: '`tasklist_active`: This contains the task block for the running task and all
    the tasks in the `TASK_READY` state, waiting to be scheduled'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasklist_active`：这包含正在运行的任务的任务块以及所有处于`TASK_READY`状态的等待调度任务'
- en: '`tasklist_waiting`: This contains the task block of the tasks currently blocked'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasklist_waiting`：这包含当前阻塞的任务的任务块'
- en: 'The easiest showcase to implement for this new mechanism is a `sleep_ms` function,
    which can be used by tasks to temporarily switch to a waiting state and set up
    a resume point in the future to be scheduled again. Providing this kind of facility
    allows our tasks to sleep in between LED toggle actions, instead of running a
    busy loop that repeatedly checks whether the timer expired. These new tasks are
    not only more efficient, because they do not waste CPU cycles in a busy loop,
    but are also more readable:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种新机制，最容易实现的展示是`sleep_ms`函数，它可以由任务用来临时切换到等待状态并在未来设置一个恢复点以便再次调度。提供这种设施允许我们的任务在LED切换动作之间休眠，而不是运行一个忙等待循环，反复检查计时器是否已过期。这些新任务不仅更高效，因为它们不会在忙等待循环中浪费CPU周期，而且也更易于阅读：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To arrange the task blocks into lists, a pointer to the next element must be
    added to the structure so that the two lists are populated at runtime. To manage
    the `sleep_ms` function, a new field must be added to keep track of the system
    time when the task is supposed to be put in the active list to be resumed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将任务块排列成列表，必须在结构中添加一个指向下一个元素的指针，以便在运行时填充两个列表。为了管理`sleep_ms`函数，必须添加一个新的字段来跟踪任务应该被放入活动列表以恢复时的时间系统：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These lists can be managed with two simple functions to the insert/delete elements:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列表可以用两个简单的函数来管理，用于插入/删除元素：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Two additional functions must be added to move the tasks from the active list
    to the waiting list and vice versa, which additionally change the state of the
    task itself:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 必须添加两个额外的函数来将任务从活动列表移动到等待列表，反之亦然，这还会改变任务本身的状态：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `sleep_ms` function sets the resume time and moves the task to the waiting
    state, then activates the scheduler so that the task is preempted:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep_ms`函数设置恢复时间并将任务移动到等待状态，然后激活调度器以使任务被抢占：'
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The new PendSV handler selects the next task to run from the active list, which
    is assumed to always contain at least one task as the kernel main task is never
    put in the waiting state. The new thread is selected through the `tasklist_next_ready`
    function, which also ensures that if the current task has been moved from the
    active list, or is the last in line, the head of the active list is selected for
    the next timeslice:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 PendSV 处理器从活动列表中选择下一个要运行的任务，假设该列表始终至少包含一个任务，因为内核主任务永远不会被置于等待状态。新线程通过 `tasklist_next_ready`
    函数选择，该函数还确保如果当前任务已从活动列表中移除，或者处于队列末尾，则选择活动列表的头部作为下一个时间片：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This small function is the core of the new scheduler based on the double list,
    and is invoked in the middle of each context switch to select the next active
    task in PendSV:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小型函数是新基于双列表调度器的核心，在每个上下文切换的中间调用以选择 PendSV 中的下一个活动任务：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, to check the wake-up time of each sleeping task, the kernel visits
    the list of waiting tasks and moves the task blocks back to the active list whenever
    the wake-up time has elapsed. The kernel initialization now includes a few extra
    steps to ensure that the kernel task itself is put in the list of running tasks
    at boot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了检查每个休眠任务的唤醒时间，内核遍历等待任务列表，并在唤醒时间到达时将任务块移回活动列表。内核初始化现在包括一些额外的步骤，以确保内核任务本身在启动时被放入运行任务列表中：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Waiting for resources
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待资源
- en: Blocking at a given time interval is only one of the possibilities for a task
    to be temporarily excluded from the active list. The kernel may implement other
    event and interrupt handlers to bring the tasks back into the scheduler loop so
    that the task may block, waiting for I/O events from a specific set of resources
    while in a `TASK_WAITING` state.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定时间间隔内阻塞只是任务暂时从活动列表中排除的一种可能性。内核可能实现其他事件和中断处理程序，以便将任务带回到调度循环中，从而使任务可以阻塞，在 `TASK_WAITING`
    状态下等待来自特定资源集的 I/O 事件。
- en: 'In our example code, a read function can be implemented to retrieve the status
    of the button from a task, which would block and only return once the button is
    pressed. Until then, the calling task remains on the waiting list and is never
    scheduled. A task that toggles the green LED every time the button is pressed
    relies on `button_read()` as its blocking point:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例代码中，可以实现一个读取函数来从任务中检索按钮的状态，该任务会阻塞，直到按钮被按下才返回。在此期间，调用任务保持在等待列表中，并且永远不会被调度。每次按钮被按下时切换绿色
    LED 的任务依赖于 `button_read()` 作为其阻塞点：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `button_read` function keeps track of the calling task, so the `button_task`
    pointer is used to wake it up when the button is pressed. The task is moved to
    the waiting list and the read operation is initiated in the driver, and then the
    task is preempted:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`button_read` 函数跟踪调用任务，因此当按钮被按下时，使用 `button_task` 指针唤醒它。任务被移动到等待列表中，并在驱动程序中启动读取操作，然后任务被抢占：'
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To notify the scheduler whenever the button is pressed, the driver uses a callback,
    specified by the kernel during initialization, and passes it as an argument to
    `button_setup`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在按钮按下时通知调度器，驱动程序使用一个回调，该回调由内核在初始化时指定，并将其作为参数传递给 `button_setup`：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The kernel associates the `button_wakeup` function with the driver callback
    so that when an event occurs, if a task is awaiting the button press notification,
    it is moved back to the active tasks list and resumes as soon as the scheduler
    selects it to run:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 内核将 `button_wakeup` 函数与驱动程序回调相关联，以便当发生事件时，如果任务正在等待按钮按下通知，它将被移回活动任务列表，并在调度器选择它运行时立即恢复：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the button driver, to initiate the blocking operation, the interrupt is
    enabled and associated with the rising edge of a signal, which corresponds to
    the button press event:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮驱动程序中，为了启动阻塞操作，启用中断并将其与信号的上升沿相关联，这对应于按钮按下事件：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The callback is executed in the interrupt context when the event is detected.
    The interrupt is disabled until the next call to `button_start_read`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测到事件时，回调函数在中断上下文中执行。中断被禁用，直到下一次调用 `button_start_read`：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Any device driver or system module that relies on interrupt handling to unlock
    the associated task may use a callback mechanism to interact with the scheduler.
    Using a similar blocking strategy, read and write operations can be implemented
    to keep the calling task on the waiting list until the desired event is detected
    and handled toward a callback in the scheduler code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 任何依赖中断处理来解锁相关任务的设备驱动程序或系统模块都可能使用回调机制与调度器交互。使用类似的阻塞策略，可以实施读写操作，以保持调用任务在等待列表中，直到检测到所需事件并处理调度器代码中的回调。
- en: Other system components and libraries designed for bare-metal embedded applications
    may require an additional layer to integrate into the operating system with blocking
    calls. Embedded TCP/IP stack implementations, such as lwIP and picoTCP, provide
    a portable RTOS integration layer, including blocking socket calls, implemented
    by running the loop functions in a dedicated task, which manages the communication
    with the socket API used in the other tasks. Locking mechanisms, such as mutexes
    and semaphores, are expected to implement blocking calls, which would suspend
    the task when the resource requested is unavailable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 其他为裸机嵌入式应用设计的系统组件和库可能需要额外的层来通过阻塞调用集成到操作系统中。嵌入式TCP/IP堆栈实现，如lwIP和picoTCP，提供了一个可移植的RTOS集成层，包括通过在专用任务中运行循环函数实现的阻塞套接字调用，该任务管理与其他任务中使用的套接字API的通信。预期将互斥锁和信号量等锁定机制实现为阻塞调用，当请求的资源不可用时，将挂起任务。
- en: The scheduling policy we have implemented so far is very reactive and gives
    a perfect level of interaction among tasks, but it does not foresee priority levels,
    which is necessary when designing real-time systems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止实施的调度策略非常反应灵敏，在任务之间提供了完美的交互水平，但它没有预见优先级级别，这在设计实时系统时是必要的。
- en: Real-time scheduling
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时调度
- en: One of the key requirements for real-time operating systems is the ability to
    react to a selected number of events by executing the associated code within a
    short and predictable amount of time. To implement features with strict timing
    requirements, the operating system must focus on quick interrupt handling and
    dispatching, rather than other metrics, such as throughput or fairness. Each task
    might have specific requirements, such as *deadlines*, indicating the exact time
    when the execution must start or stop, or related to shared resources that might
    introduce dependencies to other tasks in the system. A system that can execute
    tasks with a *deterministic* time requirement must be able to meet the deadlines
    within a measurable, fixed amount of time.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 实时操作系统的一个关键要求是能够通过在短时间内执行相关代码来对选定的几个事件做出反应。为了实现具有严格时间要求的特性，操作系统必须专注于快速中断处理和调度，而不是其他指标，如吞吐量或公平性。每个任务可能有特定的要求，例如*截止日期*，表示执行必须开始或停止的确切时间，或者与可能引入系统其他任务依赖的共享资源相关。一个能够以*确定性*时间要求执行任务的系统必须能够在可测量的固定时间内满足截止日期。
- en: Approaching real-time scheduling is a complex matter. Authoritative literature
    exists on the topic, so the subject will not be extensively explained here. Research
    has indicated that several approaches based on *priorities* assigned to each task,
    combined with an appropriate strategy used to switch the tasks at runtime, provide
    a sufficient approximation to provide a generic solution to real-time requirements.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接近实时调度是一个复杂的问题。关于这个主题有权威的文献，因此这里不会对主题进行详细解释。研究表明，基于为每个任务分配的*优先级*的几种方法，结合在运行时切换任务的适当策略，可以提供足够的近似，以提供针对实时要求的通用解决方案。
- en: 'To support hard real-time tasks with deterministic deadlines, an operating
    system should consider implementing the following characteristics:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持具有确定截止日期的硬实时任务，操作系统应考虑实现以下特性：
- en: A fast context switch procedure implemented in the scheduler
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调度器中实现快速上下文切换过程
- en: Measurable intervals where the system runs with the interrupts disabled
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统在禁用中断的情况下运行的可测量间隔
- en: Short interrupt handlers
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短中断处理程序
- en: Support for interrupt priorities
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持中断优先级
- en: Support for task priorities to minimize the latency of hard real-time tasks
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持任务优先级以最小化硬实时任务的延迟
- en: From the point of view of task scheduling, the latency for real-time tasks is
    mostly related to the ability of the system to resume the task when an external
    event occurs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从任务调度的角度来看，实时任务的延迟主要与系统在外部事件发生时恢复任务的能力有关。
- en: To guarantee a deterministic delay for a selected group of tasks, RTOSs often
    implement fixed-priority levels, which are assigned to tasks upon creation, and
    determine the order in which the next task is selected at each execution of the
    supervisor call of the scheduler.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保证一组选定任务具有确定性的延迟，RTOS通常实现固定优先级级别，这些级别在任务创建时分配，并在调度器监督调用每次执行时确定下一个任务的选择顺序。
- en: Time-critical operations should be implemented in tasks with a higher priority.
    Many scheduler policies have been researched to optimize the reaction time of
    real-time tasks while keeping the system responsive and allowing issues related
    to the possible starvation of the tasks with a lower priority. Finding an optimal
    scheduling policy for a specific scenario can be very hard; the details regarding
    deterministically calculating the latency and jitter of a real-time system are
    outside the scope of this book.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 应当在具有较高优先级的任务中实现时间关键操作。已经研究了多种调度策略，以优化实时任务的反应时间，同时保持系统响应，并允许与可能饥饿的较低优先级任务相关的问题。为特定场景找到最优的调度策略可能非常困难；关于确定性地计算实时系统延迟和抖动的细节超出了本书的范围。
- en: One of the proposed approaches is very popular among real-time operating systems.
    It provides immediate context switches for real-time tasks by selecting the task
    with the highest priority among those ready for execution, upon every invocation
    of the scheduler supervisor call. This scheduling policy, known as **static priority-driven
    preemptive scheduling**, is not optimal in all cases, as the latency of the tasks
    depends on the number of tasks at the same priority level, and foresees no mechanism
    to prevent potential starvation of tasks with a lower priority in the case of
    higher system loads. However, the mechanism is simple enough that it can be easily
    implemented to demonstrate the impact of priority mechanisms on the latency of
    real-time tasks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的一种方法在实时操作系统（RTOS）中非常受欢迎。它通过在调度器监督调用每次调用时，从准备执行的任务中选择具有最高优先级的任务，为实时任务提供立即的上下文切换。这种称为**静态优先级驱动抢占式调度**的调度策略在所有情况下都不是最优的，因为任务的延迟取决于同一优先级级别的任务数量，并且没有预见任何机制来防止在系统负载较高的情况下，具有较低优先级的任务可能出现的饥饿问题。然而，该机制足够简单，可以轻松实现以展示优先级机制对实时任务延迟的影响。
- en: Another possible approach would consist of reassigning priorities dynamically
    at runtime, based on the characteristics of the tasks. Real-time schedulers may
    benefit from a mechanism that ensures that the task with the closest deadline
    is selected first. This approach, known as `SCHED_DEADLINE` scheduler, included
    in Linux starting from version 3.14, is an implementation of this mechanism, which
    is less popular in embedded operating systems despite being relatively simple
    to implement.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能的方法是在运行时根据任务的特征动态重新分配优先级。实时调度器可能从一种确保首先选择最接近截止日期的任务的机制中受益。这种称为`SCHED_DEADLINE`调度器的做法，从Linux
    3.14版本开始包含在内，是实现这种机制的实现，尽管实现起来相对简单，但在嵌入式操作系统中并不那么受欢迎。
- en: 'This example shows a simplistic implementation of a static priority-driven
    scheduler. We are using four separate lists to store the active tasks, one for
    each priority level supported on the system. A priority level is assigned to each
    task upon creation, and the kernel is kept at priority `0`, with its main task
    running only when all the other tasks are sleeping, and whose unique purpose is
    to check the timers of the sleeping tasks. Tasks can be inserted into the active
    task list with the corresponding priority level when they become ready, and they
    are moved to the waiting list when they are blocked. To keep track of the static
    priority of the task, the priority field is added to the task block:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了静态优先级驱动调度器的简单实现。我们使用四个独立的列表来存储活动任务，每个列表对应于系统支持的每个优先级级别。每个任务在创建时都会分配一个优先级级别，内核的优先级保持在`0`，其主要任务仅在所有其他任务都处于睡眠状态时运行，其唯一目的是检查睡眠任务的计时器。当任务准备好时，可以将它们插入具有相应优先级级别的活动任务列表中，当它们被阻塞时，它们将被移动到等待列表中。为了跟踪任务的静态优先级，将优先级字段添加到任务块中：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Two shortcut functions must be defined to quickly add and remove the task block
    from the list of tasks with the same priority:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 必须定义两个快捷函数来快速将任务块添加到具有相同优先级的任务列表中，并从中移除：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'They can then be used in the new versions of the `task_waiting` and `task_ready`
    functions when the task is removed or inserted into the corresponding list of
    active tasks at the given priority:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务被移除或插入到给定优先级的活动任务列表中时，它们可以用于新的`task_waiting`和`task_ready`函数版本：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The three tasks are created on the system, but the one that would block upon
    the button press event is created with a higher priority level:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中创建了三个任务，但按钮按下事件会阻塞的那个任务具有更高的优先级级别：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The function that selects the next task is reworked to find the task with the
    highest priority among those ready to run. To do so, the priority lists are visited,
    from highest to lowest. If the list with the highest priority is the same as one
    of the current tasks, the next task in the same level is selected, if possible,
    to guarantee a round-robin mechanism in the case of tasks competing for the CPU
    within the same priority level. In any other case, the first task in the list
    with the highest priority is selected:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 选择下一个任务的功能被重新设计，以找到那些准备运行的任务中优先级最高的任务。为此，从最高优先级到最低优先级遍历优先级列表。如果最高优先级的列表与当前任务之一相同，则如果可能，选择同一级别的下一个任务，以确保在相同优先级级别内竞争CPU的任务之间有一个轮询机制。在其他任何情况下，选择最高优先级列表中的第一个任务：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The major difference between this scheduler and the one with a single priority
    level in terms of reacting to the button press event in the task with an ID equal
    to `2` is the time interval between the button press event and the reaction from
    the task itself. Both schedulers implement preemption by immediately putting the
    task back into the ready state within the interrupt handler of the button event.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与具有单个优先级级别的调度器相比，在处理ID等于`2`的任务的按钮按下事件时，主要区别在于按钮按下事件和任务本身的反应之间的时间间隔。这两个调度器都通过在按钮事件的中断处理程序中立即将任务放回就绪状态来实现抢占。
- en: However, in the first case, the task comes back to the carousel of the tasks
    being scheduled to compete with the other tasks on the same priority level, which
    can cause a delay in the reaction of the task. We can estimate this to be *N*
    * `TIMESLICE` in the worst-case scenario, where *N* is the number of processes
    ready to run at the moment when the interrupt occurs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在第一种情况下，任务会回到正在调度的任务轮询中，与其他相同优先级的任务竞争，这可能导致任务反应的延迟。在最坏的情况下，我们可以估计这将是*N* *
    `TIMESLICE`，其中*N*是中断发生时准备运行的过程数。
- en: With the priority-driven scheduling approach, there is a degree of certainty
    that the real-time task is the first one to be scheduled after the interrupt occurs
    so that the time required from the interrupt to resuming the task is measurable,
    and in the order of a few microseconds, as the CPU executes a predictable amount
    of instructions to perform all the actions in between.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于优先级的调度方法，在发生中断后，实时任务是第一个被调度的任务，这样从中断到恢复任务所需的时间是可测量的，大约是几微秒，因为CPU执行可预测数量的指令以执行所有中间操作。
- en: Real-time embedded OSs are fundamental to implementing life-critical systems,
    mostly in the transport and medical industries. On the other hand, they rely on
    simplified models to keep the basic system operations as lightweight as possible,
    and with minimum overhead for system call interfaces and system APIs. An opposite
    approach could consist of increasing the complexity of the kernel to introduce
    optimizations in terms of throughput, task interaction, memory safety improvements,
    and other performance indicators, which may be a better fit in embedded systems
    with loose or non-existent real-time requirements. Stricter priority-based scheduling
    policies improve latency and guarantee real-time responses in well-controlled
    scenarios but are less flexible to use in a general-purpose embedded system where
    other constraints are more compelling than task latency, where a time-based preemption-scheduling
    approach may provide better results.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 实时嵌入式操作系统对于实现生命关键系统至关重要，主要是在交通和医疗行业。另一方面，它们依赖于简化的模型来尽可能保持基本系统操作轻量级，并具有最小的系统调用接口和系统API开销。相反的方法可能包括增加内核的复杂性，以引入吞吐量、任务交互、内存安全性改进和其他性能指标方面的优化，这可能更适合具有宽松或不存在实时要求的嵌入式系统。更严格的基于优先级的调度策略可以提高延迟并保证在受控场景中的实时响应，但在通用嵌入式系统中使用时不太灵活，在其他约束比任务延迟更有力的情况下，基于时间的抢占式调度方法可能提供更好的结果。
- en: Synchronization
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步
- en: In a multithreaded environment where memory, peripherals, and system accesses
    are shared, a system should provide synchronization mechanisms to allow the tasks
    to cooperate on the arbitration of the access to system-wide available resources.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个多线程环境中，内存、外设和系统访问是共享的，系统应提供同步机制，以允许任务在系统级可用资源的仲裁上协作。
- en: Mutexes and semaphores are two of the most commonly used mechanisms of synchronization
    between parallel threads as they provide the minimal set to solve most concurrency
    problems. Functions that could block the calling tasks must be able to interact
    with the scheduler, to move the task to the waiting state whenever the resource
    is not available and until the lock is released or the semaphore is incremented.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁和信号量是并行线程之间最常用的同步机制，因为它们提供了解决大多数并发问题的最小集合。可能阻塞调用任务的函数必须能够与调度器交互，在资源不可用且锁未释放或信号量增加之前，将任务移动到等待状态。
- en: Semaphores
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号量
- en: A semaphore is the most common synchronization primitive, which provides a counter
    with exclusive access, and it is used by two or more threads to cooperate on the
    arbitration of the usage of a specific shared resource. The API provided to the
    tasks must guarantee that the object can be used to implement a counter with exclusive
    access, which, in general, requires some auxiliary features on the CPU. For this
    reason, the internal implementation of the synchronization strategies is dependent
    on the microcode implemented in the target processor.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是最常见的同步原语，它提供了一个具有独占访问权限的计数器，并且被两个或更多线程用于在特定共享资源的仲裁上协作。提供给任务提供的API必须保证该对象可以用来实现一个具有独占访问权限的计数器，这通常需要在CPU上提供一些辅助功能。因此，同步策略的内部实现依赖于目标处理器中实现的微代码。
- en: 'On Cortex-M3/M4, the implementation of locking mechanisms relies on instructions
    provided by the CPU to perform exclusive operations. The instruction set of the
    reference platform provides the following two instructions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cortex-M3/M4上，锁定机制的实现依赖于CPU提供的执行独占操作的指令。参考平台的指令集提供了以下两个指令：
- en: '**Load Register Exclusive** (**LDREX**): Loads a value from an address in memory
    into a CPU register.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载寄存器独占**（**LDREX**）：从内存中的地址加载一个值到CPU寄存器中。'
- en: '**Store Register Exclusive** (**STREX**): Attempts to store the new value contained
    in the register in an address in memory corresponding to the last LDREX instruction.
    If the STREX succeeds, the CPU guarantees that writing the value in memory happened
    exclusively and that the value has not been modified since the last LDREX call.
    Between two concurrent LDREX/STREX sections, only one will result in a successful
    write to the register; the second STREX instruction will fail, returning zero.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储寄存器独占**（**STREX**）：尝试将寄存器中包含的新值存储在内存中的地址，该地址对应于最后一个LDREX指令。如果STREX成功，CPU保证内存中的值写入是独占的，并且自上次LDREX调用以来该值没有被修改。在两个并发LDREX/STREX部分之间，只有一个将导致寄存器成功写入；第二个STREX指令将失败，返回零。'
- en: The characteristics of these instructions guarantee exclusive access to a counter,
    which is then used to implement the primitive functions at the base of semaphores
    and mutexes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的特性保证了独占访问一个计数器，然后用于实现信号量和互斥锁的基本功能。
- en: The `sem_trywait` function attempts to decrement the value of the semaphore.
    The operation is always allowed unless the value of the semaphore is `0`, which
    results in an immediate failure. The function returns `0` upon success, and `-1`
    if the semaphore value is zero, and it is impossible to decrement the semaphore
    value at this time.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`sem_trywait`函数尝试减少信号量的值。除非信号量的值为`0`，否则操作总是允许的，这将导致立即失败。函数在成功时返回`0`，如果信号量值为零，则返回`-1`，此时不可能减少信号量的值。'
- en: 'The sequence of the events in `sem_trywait` is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`sem_trywait`事件序列如下：'
- en: The value of the semaphore variable (an integer accessed with exclusive load
    and store instructions) is read from the memory pointed to by the function argument
    into the register, R1.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信号量变量的值（一个通过独占加载和存储指令访问的整数）从函数参数指向的内存中读取到寄存器R1中。
- en: If the value of R1 is `0`, the semaphore cannot be acquired, and the function
    returns `-1`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果R1的值为`0`，则信号量无法获取，函数返回`-1`。
- en: The value of R1 is decremented by one.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R1的值减一。
- en: The value of R1 is stored in the memory pointed to by the function argument,
    and the result of the STREX operation is put into R2.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R1 的值存储在由函数参数指向的内存中，STREX 操作的结果放入 R2。
- en: If the operation succeeds, R2 contains `0`, the semaphore is acquired and successfully
    decremented, and the function can return with a success status.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果操作成功，R2 包含 `0`，信号量被获取并成功递减，函数可以返回成功状态。
- en: If the store operation fails (concurrent access is attempted), the procedure
    is immediately repeated for a second attempt.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存储操作失败（尝试并发访问），则立即重复该过程进行第二次尝试。
- en: 'Here is the assembly routine implementing all of the steps, returning `0` upon
    success and `-1` when the decrement fails:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下汇编例程实现了所有步骤，成功时返回 `0`，递减失败时返回 `-1`：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following code is the corresponding function to increase the semaphore,
    which is similar to the wait routine, except that the counting semaphore is increased
    instead, and the operation is eventually going to succeed, even if multiple tasks
    are trying to access the semaphore at the same time. The function returns `0`
    on success, except if the value before the counter was zero, in which case it
    returns `1`, to remind the caller to notify any listener in a wait state that
    the value has increased and the associated resource is now available:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是增加信号量的相应函数，它与等待例程类似，除了计数信号量被增加，并且操作最终将成功，即使多个任务同时尝试访问信号量。函数在成功时返回 `0`，除非计数器之前的值是零，在这种情况下它返回
    `1`，以提醒调用者通知任何处于等待状态下的监听者值已增加，相关资源现在可用：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To integrate the blocking status of the `sem_wait` function into the scheduler,
    the semaphore interface exposed by the OS to the tasks wraps the non-blocking
    `sem_trywait` call into its blocking version, which blocks the task when the value
    of the semaphore is zero.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 `sem_wait` 函数的阻塞状态集成到调度器中，操作系统对任务公开的信号量接口将非阻塞的 `sem_trywait` 调用包装成其阻塞版本，当信号量的值为零时，该任务将被阻塞。
- en: 'To implement a blocking version of the semaphore interface, the `semaphore`
    object may keep track of the tasks accessing the resources and waiting for a post
    event. In this case, the identifiers of the tasks are stored in an array named
    `listeners`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现信号量接口的阻塞版本，`semaphore` 对象可能跟踪访问资源并等待后置事件的任务。在这种情况下，任务的标识符存储在名为 `listeners`
    的数组中：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When a wait operation fails, the task is blocked and it will try again only
    after a successful post operation from another task. The task identifier is added
    to the array of listeners for this resource:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当等待操作失败时，任务将被阻塞，并且只有在另一个任务成功执行后置操作后才会再次尝试。任务标识符被添加到该资源的监听者数组中：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The assembly routine, `sem_dopost`, returns a positive value if the post operation
    has triggered an increment from zero to one, which means that the listeners, if
    present, must be resumed to try to acquire the resource that just became available.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编例程 `sem_dopost` 如果后置操作触发了从零到一的增量，则返回正值，这意味着如果存在监听者，它们必须恢复以尝试获取刚刚变得可用的资源。
- en: Mutexes
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互斥锁
- en: '`1` to allow the first lock operation.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`1` 允许第一个锁定操作。'
- en: Due to the property of the semaphore, which would fail any attempt to decrement
    its counter after its value has reached `0`, our quick implementation of the mutex
    interface renames the semaphore primitives `sem_wait` and `sem_post` to `mutex_lock`
    and `mutex_unlock`, respectively.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 由于信号量的性质，在值达到 `0` 之后尝试递减其计数器将失败，因此我们快速实现的互斥锁接口将信号量原语 `sem_wait` 和 `sem_post`
    分别重命名为 `mutex_lock` 和 `mutex_unlock`。
- en: 'Two tasks can try to decrement an unlocked mutex at the same time, but only
    one will succeed; the other will fail. In the blocking version of the mutex for
    the example scheduler, the wrappers for the mutex API built on top of the semaphore
    functions are as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 两个任务可以同时尝试递减未上锁的互斥锁，但只有一个会成功；另一个将失败。在示例调度器的互斥锁的阻塞版本中，基于信号量函数构建的互斥锁 API 包装器如下：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For both semaphores and mutexes, the example operating system written so far
    offers a complete API for synchronization mechanisms integrated with the scheduler.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对于信号量和互斥锁，到目前为止编写的示例操作系统为与调度器集成的同步机制提供了一个完整的 API。
- en: Priority inversion
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先级反转
- en: A phenomenon that is often encountered when developing operating systems with
    preemptive, priority-based schedulers using integrated synchronization mechanisms
    is priority inversion. This condition affects the reactivity time of the real-time
    tasks that share resources with other tasks with a lower priority, and, in some
    cases, may cause the higher-priority tasks to starve for an unpredictable amount
    of time. This event occurs when the high-priority task is waiting for a resource
    to be freed by a lower-priority one, which in the meanwhile may be preempted by
    other unrelated tasks in the system.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用基于抢占和优先级的调度器以及集成同步机制开发操作系统时，经常会遇到优先级反转现象。这种情况会影响与其他低优先级任务共享资源的实时任务的反应时间，在某些情况下，可能会导致高优先级任务因不可预测的时间而饥饿。当高优先级任务等待低优先级任务释放资源时，这一事件发生，而此时低优先级任务可能被系统中的其他无关任务抢占。
- en: 'In particular, the sequence of events that might trigger this phenomenon is
    as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，可能触发此现象的事件序列如下：
- en: T1, T2, and T3 are three of the running tasks, with priority 1, 2, and 3, respectively.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: T1、T2和T3是三个正在运行的任务，分别具有1、2和3的优先级。
- en: T1 acquires a lock using a mutex on resource *X*.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: T1使用资源*X*上的互斥锁获取锁。
- en: T1 is preempted by T3, which has a higher priority.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: T1被优先级更高的T3抢占。
- en: T3 tries to access the shared resource, *X*, and blocks on the mutex.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: T3试图访问共享资源*X*，并在互斥锁上阻塞。
- en: T1 resumes the execution in the critical section.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: T1在临界区恢复执行。
- en: T1 is preempted by T2, which has a higher priority.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: T1被优先级更高的T2抢占。
- en: An arbitrary number of tasks with priorities greater than 1 can interrupt the
    execution of T1 before it can release the lock and wake up T3.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在T1释放锁并唤醒T3之前，任意数量的优先级大于1的任务可以中断T1的执行。
- en: One of the possible mechanisms that can be implemented to avoid this situation
    is called **priority inheritance**. This mechanism consists of temporarily increasing
    the priority of a task sharing a resource to the highest priority of all the tasks
    accessing the resource. This way, a task with a lower priority does not cause
    scheduling delays for the higher-priority ones, and the real-time requirements
    are still met.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种情况的一种可能机制称为**优先级继承**。该机制包括临时将共享资源的任务的优先级提高到所有访问该资源的任务的最高优先级。这样，低优先级任务不会导致高优先级任务的调度延迟，并且实时需求仍然得到满足。
- en: System resource separation
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统资源分离
- en: The example operating system we have built throughout this chapter already has
    many interesting features, but it is still characterized by a flat model, with
    no memory segmentation or privilege separation. Minimalist systems do not provide
    any mechanisms to separate system resources and regulate access to the memory
    space. Instead, tasks in the system are allowed to perform any privileged operation,
    including reading and altering other tasks’ memory, executing operations in the
    address space of the kernel, and directly accessing peripherals and CPU registers
    at runtime.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中构建的示例操作系统已经具有许多有趣的功能，但它仍然具有扁平模型的特点，没有内存分段或权限分离。简约系统不提供任何机制来分离系统资源并规范对内存空间的访问。相反，系统中的任务被允许执行任何特权操作，包括读取和修改其他任务的内存，在内核地址空间中执行操作，以及在运行时直接访问外围设备和CPU寄存器。
- en: 'Different approaches are available on the target platform, aimed at increasing
    the level of safety on the system by introducing a limited number of modifications
    to the kernel to:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 目标平台上有不同的方法，旨在通过在内核中引入有限数量的修改来提高系统的安全性：
- en: Implement kernel/process privilege separation
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施内核/进程权限分离
- en: Integrate memory protection in the scheduler
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调度器中集成内存保护
- en: Provide a system call interface through the supervisor call to access resources
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过监督调用提供系统调用接口以访问资源
- en: Let’s discuss each in detail.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论每个方法。
- en: Privilege levels
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权限级别
- en: The Cortex-M CPU is designed to run code with two different levels of privilege.
    Privilege separation is important whenever untrusted application code is running
    on the system, allowing the kernel to keep control of the execution at all times,
    and prevent system failures due to a misbehaving user thread. The default execution
    level at boot is privileged, to allow the kernel to boot. Applications can be
    configured to execute at the user level and use a different stack-pointer register
    during the context switch operations.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Cortex-M CPU 设计为以两种不同的特权级别运行代码。当在系统上运行不受信任的应用程序代码时，特权分离非常重要，允许内核始终保持对执行的掌控，并防止由于用户线程的不当行为而导致系统故障。启动时的默认执行级别是特权级别，以允许内核启动。应用程序可以配置为在用户级别执行，并在上下文切换操作期间使用不同的栈指针寄存器。
- en: Changing privilege levels is possible only during an exception handler, and
    it is done using the special exception return value, which is stored in LR before
    it is returned from an exception handler that performed the context switch. The
    flag that controls the privilege level is the lowest bit of the `CONTROL` register,
    which can be changed during context switches before returning from the exception
    handler, to relegate application threads to run at the user privilege level.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 特权级别的更改只能在异常处理程序期间进行，并且是通过使用特殊的异常返回值来完成的，该值在从执行上下文切换的异常处理程序返回之前存储在 LR 中。控制特权级别的标志是
    `CONTROL` 寄存器的最低位，可以在返回异常处理程序之前在上下文切换期间更改，以将应用程序线程降级到用户特权级别运行。
- en: 'Moreover, most Cortex-M CPUs provide two separate stack-pointer CPU registers:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大多数 Cortex-M CPU 提供了两个独立的栈指针 CPU 寄存器：
- en: A **Master Stack** **Pointer** (**MSP**)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主栈指针**（**MSP**）'
- en: A **Process Stack** **Pointer** (**PSP**)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程栈指针**（**PSP**）'
- en: Following the ARM recommendation, operating systems must use PSP to execute
    user threads, while MSP is used by interrupt handlers and the kernel. The stack
    selection depends on the special return value at the end of the exception handler.
    The scheduler we have implemented so far has this value hardcoded to `0xFFFFFFF9`,
    which is used to return in thread mode after an interrupt and keeps executing
    the code at a privileged level. Returning the `0xFFFFFFFD` value from the interrupt
    handler tells the CPU to select the PSP as a stack-pointer register when returning
    to thread mode.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循 ARM 的推荐，操作系统必须使用 PSP 来执行用户线程，而 MSP 则由中断处理程序和内核使用。栈的选择取决于异常处理程序结束时的特殊返回值。我们迄今为止实现的调度器将此值硬编码为
    `0xFFFFFFF9`，用于在中断后以线程模式返回，并保持以特权级别执行代码。从中断处理程序返回 `0xFFFFFFFD` 值会告诉 CPU 在返回线程模式时选择
    PSP 作为栈指针寄存器。
- en: 'To implement privilege separation properly, the PendSV handler used for switching
    tasks has to be modified to save and restore the context using the right stack
    pointer for the task being preempted and the stack selected. The `store_context`
    and `restore_context` functions we have used so far are renamed to `store_kernel_context`
    and `restore_kernel_context`, respectively, because the kernel is still using
    the master stack pointer. Two new functions are added to the store and restore
    thread contexts from the new context switch routine, which uses the PSP register
    instead, for storing and restoring the contexts of the threads:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确实现特权分离，用于切换任务的 PendSV 处理程序必须修改为使用被抢占任务的正确栈指针来保存和恢复上下文。我们迄今为止使用的 `store_context`
    和 `restore_context` 函数分别重命名为 `store_kernel_context` 和 `restore_kernel_context`，因为内核仍在使用主栈指针。还添加了两个新函数，用于从新的上下文切换例程中存储和恢复线程上下文，该例程使用
    PSP 寄存器，用于存储和恢复线程的上下文：
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the safe version of the scheduler, the PendSV service routine selects the
    correct stack pointer for storing and restoring the context and calls the associated
    routines. Depending on the new context, the return value stored in LR is used
    to select the register used as a new stack pointer, and the privilege level is
    set in the `CONTROL` register to switch to the user or privileged level in the
    upcoming thread mode, using values of `1` or `0`, respectively:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在调度器的安全版本中，PendSV 服务例程选择正确的栈指针来存储和恢复上下文，并调用相关的例程。根据新的上下文，存储在 LR 中的返回值用于选择用作新栈指针的寄存器，并将特权级别设置在
    `CONTROL` 寄存器中，以便在即将到来的线程模式中使用 `1` 或 `0` 的值分别切换到用户或特权级别：
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A task running with the privilege mode bit set in the `CONTROL` register has
    restricted access to the resources of the system. In particular, threads cannot
    access registers in the SCB region, which means that some basic operations, such
    as enabling and disabling interrupts through the NVIC, are reserved for the exclusive
    use of the kernel. When used in combination with the MPU, privilege separation
    improves the safety of the system even further by imposing memory separation at
    the access level, which can detect and interrupt misbehaving application code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CONTROL`寄存器中设置特权模式位运行的任务对系统的资源访问有限制。特别是，线程无法访问SCB区域中的寄存器，这意味着一些基本操作，例如通过NVIC启用和禁用中断，仅限于内核的专用使用。当与MPU结合使用时，通过在访问级别实施内存分离，特权分离可以进一步提高系统的安全性，从而检测并中断行为不当的应用程序代码。
- en: Memory segmentation
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存分段
- en: Dynamic memory segmentation strategies can be integrated into the scheduler
    to ensure that the single tasks do not access memory regions associated with system-critical
    components and that the resources that require kernel supervision can be accessed
    from user space.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内存分段策略可以集成到调度器中，以确保单个任务不会访问与系统关键组件关联的内存区域，并且需要内核监督的资源可以从用户空间访问。
- en: 'In [*Chapter 5*](B18730_05.xhtml#_idTextAnchor149), *Memory Management*, we
    saw how the MPU can be used to delimit contiguous segments of memory and disallow
    access to specific areas by any of the code running on the systems. The MPU controller
    provides a permission mask to change the attributes of the single-memory regions
    with more granularity. In particular, we can only allow access to some areas if
    the CPU is running at a privileged level, which is an efficient way of preventing
    user applications from accessing certain areas of the system without the supervision
    of the kernel. A safe operating system may decide to completely exclude the application
    tasks from accessing the peripheral region and the system registers by using kernel-only
    permission flags for these areas. The values associated with specific permissions
    in the MPU region attribute register can be defined as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B18730_05.xhtml#_idTextAnchor149) *内存管理*中，我们看到了如何使用MPU来界定连续的内存段，并禁止系统上运行的任何代码访问特定区域。MPU控制器提供了一个权限掩码，以更细粒度地更改单个内存区域的属性。特别是，只有当CPU在特权级别运行时，我们才允许访问某些区域，这是一种有效的方法，可以防止用户应用程序在没有内核监督的情况下访问系统的某些区域。一个安全的操作系统可能会决定完全排除应用程序任务访问外围区域和系统寄存器，为此可以使用仅内核权限标志对这些区域进行设置。与MPU区域属性寄存器中特定权限相关联的值可以定义如下：
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The MPU configuration can be enforced at boot by the kernel. In this example,
    we have set the flash region to be globally readable, as region `0`, using `RASR_RDONLY`,
    and the SRAM region to be globally accessible, as region `1`, mapped at an address
    of `0x20000000`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: MPU配置可以在引导时由内核强制执行。在这个例子中，我们将闪存区域设置为全局可读，作为区域`0`，使用`RASR_RDONLY`，并将SRAM区域设置为全局可访问，作为区域`1`，映射到地址`0x20000000`：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A stricter policy may even restrict the usage of the SRAM by the user tasks
    in non-privileged mode, but it would require a reorganization of the `.data` and
    `.bss` regions that are mapped when the task is started. In this example, we are
    simply demonstrating how to integrate the per-task memory protection policy into
    the scheduler to prevent access to system resources and protect the stack areas
    of the other tasks. The CCRAM is the area we want to protect as it contains the
    execution stack of the kernel, as well as those of the other tasks in the system.
    To do so, the CCRAM area must be marked to be of exclusive access of the kernel
    as region `2`. Later, an exception must be created for the selected task during
    the context switch, to permit access to its own stack space:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 更严格的策略甚至可以限制非特权模式下用户任务对SRAM的使用，但这需要对任务启动时映射的`.data`和`.bss`区域进行重新组织。在这个例子中，我们只是演示了如何将每个任务的内存保护策略集成到调度器中，以防止访问系统资源并保护其他任务的堆栈区域。CCRAM是我们想要保护的区域，因为它包含内核的执行堆栈，以及系统中其他任务的堆栈。为此，CCRAM区域必须标记为仅对内核专有的访问权限，作为区域`2`。随后，在上下文切换期间必须为选定的任务创建一个异常，以允许访问其自己的堆栈空间：
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Peripheral regions and system registers are restricted areas in our system,
    so they too are marked for exclusive kernel access at runtime. In our safe OS
    design, tasks that want to access peripherals must use system calls to perform
    supervised privileged operations:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 外围区域和系统寄存器是我们系统中的受限区域，因此在运行时它们也被标记为仅限内核访问。在我们的安全操作系统设计中，想要访问外围设备的任务必须使用系统调用来执行受监督的特权操作：
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'During the context switch, just before returning from the `isr_pendsv` service
    routine, the scheduler can invoke the function that is exported by our custom
    MPU module to temporarily permit access to the stack area of the task selected
    to run next in non-privileged mode:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文切换期间，在从`isr_pendsv`服务例程返回之前，调度器可以调用我们自定义MPU模块导出的函数，以临时允许以非特权模式访问下一个要运行的任务的堆栈区域：
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: These further restrictions have limited the possibility for the currently implemented
    tasks to access any resources directly. To maintain the same functionalities as
    before, the example system must now export a new safe API for the tasks to request
    system operations.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这些进一步的限制限制了当前实现的任务直接访问任何资源的可能性。为了保持与之前相同的功能，示例系统现在必须导出一个新的安全API，以便任务请求系统操作。
- en: System calls
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统调用
- en: The latest evolution of the example operating system we have implemented in
    this chapter no longer allows our tasks to control system resources, such as input
    and output peripherals, and does not even allow the tasks to block voluntarily
    as the `sleep_ms` function is not allowed to set the pending flag to initiate
    a context switch.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们实现的示例操作系统的最新版本不再允许我们的任务控制系统资源，例如输入输出外围设备，甚至不允许任务自愿阻塞，因为`sleep_ms`函数不允许设置挂起标志以启动上下文切换。
- en: The operating system exports an API that is accessible by the tasks through
    a system call mechanism via the SVCall exception, which is handled by the `isr_svc`
    service routine, and triggered at any time from tasks through the `svc` instruction.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统导出一个API，任务可以通过系统调用机制通过SVCall异常访问该API，该异常由`isr_svc`服务例程处理，并且可以在任何时间通过`svc`指令从任务触发。
- en: 'In this simple example, we are using the `svc 0` assembly instruction to switch
    to handler mode by defining a shortcut macro, `SVC()`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的示例中，我们使用`svc 0`汇编指令通过定义快捷宏`SVC()`来切换到处理程序模式：
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We wrap this instruction within a C function so that we can pass arguments
    to it. The ABI for the platform provides the first four arguments of the call
    across the mode switch inside the R0-R3 registers. Our example API does not allow
    us to pass any arguments to the system calls, but uses the first argument in R0
    to identify the request that has been passed from the application to the kernel:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个指令封装在一个C函数中，以便我们可以向它传递参数。平台提供的ABI在模式切换过程中通过R0-R3寄存器传递调用参数的前四个参数。我们的示例API不允许我们将任何参数传递给系统调用，而是使用R0中的第一个参数来识别从应用程序传递到内核的请求：
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This way, we implement the entire system call interface for this operating
    system, which consists of the following system calls with no arguments. Each system
    call has an associated identification number, passed as `arg0`. The list of system
    calls is the contract for the interface between the tasks and the kernel, and
    the only way for the tasks to use the protected resources in the system:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们为这个操作系统实现了整个系统调用接口，该接口由以下无参数的系统调用组成。每个系统调用都有一个关联的识别号，通过`arg0`传递。系统调用列表是任务和内核之间接口的契约，也是任务使用系统保护资源的唯一方式：
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Each of these system calls must be handled in `isr_svc`. Controlling peripherals
    and system block registers can be done by calling the driver functions in the
    handler context, even if this is done just for brevity here. In a proper design,
    operations that take more than a few instructions to complete should be deferred
    to be run by the kernel task the next time it is scheduled. The following code
    has been used just to show a possible implementation of `isr_svc` that reacts
    to user requests allowed by the system API, to control the LED and the button
    on the board, while also providing a mechanism that can be expanded to implement
    blocking system calls.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统调用必须在`isr_svc`中处理。通过调用处理程序上下文中的驱动程序函数来控制外围设备和系统阻塞寄存器是可以完成的，即使在这里这样做只是为了简洁。在适当的设计中，需要多个指令才能完成的操作应该推迟到内核任务下次调度时运行。以下代码仅用于展示一个可能的`isr_svc`实现，该实现响应系统API允许的用户请求，以控制板上的LED和按钮，同时提供一个可以扩展以实现阻塞系统调用的机制。
- en: The `svc` service routine executes the requested command, passed as an argument
    to the handler itself. If the system call is blocking, such as the `SYS_SCHEDULE`
    system call, a new task is selected to complete a task switch within the handler.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`svc`服务例程执行由处理程序本身传递的请求命令。如果系统调用是阻塞的，例如`SYS_SCHEDULE`系统调用，则处理程序内会选择一个新的任务以完成任务切换。'
- en: 'The `svc` routine can now handle internal commands, as shown in the following
    example handler function:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`svc`例程现在可以处理内部命令，如下面的示例处理函数所示：'
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The context is resumed at the end of the routine, in the same way as within
    `PendSV`. Though it is optional, a task switch might occur if the call must block:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与`PendSV`中一样，在例程结束时恢复上下文，尽管这是可选的，但如果调用必须阻塞，则可能会发生任务切换：
- en: '[PRE48]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'While limited in its functionalities, the new system exports all the APIs needed
    for our application threads to run again, once all the prohibited privileged calls
    have been removed from the task code, and the newly created system calls are invoked
    instead:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然功能有限，但新系统导出所有必要的API，以便我们的应用程序线程在从任务代码中移除所有禁止的特权调用并调用新创建的系统调用后再次运行：
- en: '[PRE49]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The code size of a safe operating system may grow quickly if it implements all
    the operations in kernel space and has to provide the implementation of all the
    system calls allowed. On the other hand, it provides physical memory separation
    among tasks, and it protects system resources and other memory areas from accidental
    errors in the application code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安全操作系统在内核空间中实现所有操作并必须提供所有允许的系统调用的实现，其代码大小可能会迅速增长。另一方面，它为任务之间提供了物理内存分离，并保护系统资源和其他内存区域免受应用程序代码中意外错误的影响。
- en: Embedded operating systems
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式操作系统
- en: As illustrated in the previous sections of this chapter, building a scheduler
    tailored to a custom solution from scratch is not impossible and, if done properly,
    would provide the closest approximation of the desired architecture and focus
    on the specific characteristics offered by the target hardware. In a real-life
    scenario, however, it is advisable to consider one of the many embedded operating
    systems options available and ready to be integrated into the architecture among
    those supporting the selected hardware platform, and providing the features that
    we have learned about in this chapter.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前几节所示，从头开始构建针对定制解决方案的调度器并非不可能，如果做得恰当，将提供与所需架构最接近的近似，并专注于目标硬件提供的特定特性。然而，在现实场景中，建议考虑许多可用的嵌入式操作系统选项之一，这些选项已准备好集成到架构中，并支持所选硬件平台，同时提供本章中我们了解到的功能。
- en: Many of the available kernel implementations for microcontrollers are open source
    and in a healthy development state, so they are deserving of their well-established
    role in the embedded market. A few of them are sufficiently popular and widely
    tested to provide a foundation for building reliable embedded multitasking applications.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 许多适用于微控制器的内核实现都是开源的，并且处于良好的开发状态，因此它们在嵌入式市场中的既定角色是当之无愧的。其中一些足够流行且经过广泛测试，可以为构建可靠的嵌入式多任务应用程序提供基础。
- en: OS selection
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统选择
- en: Selecting the operating system that best fits the purpose and the platform under
    development is a delicate task that impacts the overall architecture, may have
    consequences on the whole development model, and may introduce API lock-ins in
    the application code base. The criteria for selection vary according to the hardware
    characteristics, the integration with the other components, such as third-party
    libraries, the facilities offered to interact with peripherals and interfaces,
    and, most importantly, the range of use cases that the system is designed to cover.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最适合开发目的和开发平台操作系统的任务是一项微妙的工作，它会影响整体架构，可能对整个开发模型产生影响，并可能在应用程序代码库中引入API锁定。选择标准根据硬件特性、与其他组件（如第三方库）的集成、提供与外围设备和接口交互的设施以及最重要的是，系统设计旨在覆盖的使用案例范围而有所不同。
- en: 'With a few exceptions, operating systems include, alongside the scheduler and
    the memory management, a set of integrated libraries, modules, and tools. Depending
    on the purpose, an embedded OS may provide a suite that covers several areas,
    including the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调度器和内存管理之外，操作系统通常还包括一系列集成库、模块和工具。根据目的，嵌入式操作系统可能提供一套覆盖多个领域的套件，包括以下内容：
- en: Platform-specific hardware abstraction layers
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台特定的硬件抽象层
- en: Device drivers for common peripherals
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见外设的设备驱动程序
- en: TCP/IP stack integration for connectivity
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP/IP堆栈集成以实现连接性
- en: Filesystems and file abstractions
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统和文件抽象
- en: Integrated power management systems
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成电源管理系统
- en: Depending on the implementation of the thread model in the scheduler, some systems
    are expected to run with a fixed amount of predefined tasks, configured at compile
    time, while others opt for more complex processes and thread hierarchies that
    allow us to create new threads at runtime, and terminate them at any point in
    the execution. However, dynamic task creation and termination are rarely a requirement
    on embedded systems, and in most of these cases, an alternative design may help
    us work around it.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 根据调度器中线程模型的实现，一些系统可能会以预定义的任务数量运行，这些任务在编译时配置，而其他系统则选择更复杂的进程和线程层次结构，允许我们在运行时创建新的线程，并在执行过程中的任何时刻终止它们。然而，在嵌入式系统中，动态任务创建和终止很少是必需的，在这些情况下，替代的设计可能有助于我们绕过这一限制。
- en: More complex systems introduce some overhead due to the additional logic in
    the system exceptions code and are less fit for critical real-time operations,
    which is the reason why most successful RTOSs nowadays maintain their simple architecture,
    providing the bare minimum to run multiple threads with a flat-memory mode that
    is easy to manage and does not require additional context switches to manage the
    privilege of the operations, keeping the latency low and measurable to comply
    with real-time requirements.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的系统由于系统异常代码中的额外逻辑而引入了一些开销，并且不太适合关键实时操作，这也是为什么如今大多数成功的实时操作系统（RTOS）都保持其简单的架构，提供运行多个线程所需的最基本功能，采用易于管理的平坦内存模式，并且不需要额外的上下文切换来管理操作权限，以保持低延迟并符合实时要求。
- en: Due to the many options available and the continuous evolution following technological
    progress, providing an exhaustive list of operating systems for embedded devices
    is outside the scope of this book. Unlike the PC domain, where less than a handful
    of operating systems dominate the entire market, the several embedded OSs are
    all very different from each other in terms of their design, APIs, drivers, supported
    hardware, and build tools.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可用的选项众多，以及随着技术进步的持续发展，提供嵌入式设备的操作系统的详尽列表超出了本书的范围。与PC领域不同，那里只有少数几个操作系统主导整个市场，而嵌入式操作系统在设计和API、驱动程序、支持的硬件以及构建工具等方面都彼此非常不同。
- en: In this last section of this chapter, we will explore two of the most popular
    open-source operating systems for embedded devices, FreeRTOS and Riot OS, by comparing
    their design choices for parallel task execution, memory management, and accessory
    features available.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将通过比较并行任务执行、内存管理和可用辅助功能的设计选择，来探讨两种最流行的嵌入式设备开源操作系统：FreeRTOS和Riot OS。
- en: FreeRTOS
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FreeRTOS
- en: Possibly the most popular among the open-source operating systems for embedded
    devices, approaching 20 years of active development at the time of writing, FreeRTOS
    is extremely portable across many embedded platforms, with tens of available hardware
    ports and support for most, if not all, embedded CPU architectures.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，FreeRTOS可能是嵌入式设备开源操作系统中最受欢迎的，其活跃开发已接近20年，FreeRTOS在许多嵌入式平台上具有极高的可移植性，拥有数十个可用的硬件端口，并支持大多数，如果不是所有嵌入式CPU架构。
- en: 'Designed with a small code footprint and simple interfaces in mind, this system
    does not offer a complete driver’s platform or advanced CPU-specific features,
    but rather focuses on two things: real-time scheduling of the threads and heap
    memory management. The simplicity of its design allows it to be ported to a large
    number of platforms and keeps the development focus on a restricted amount of
    well-tested and reliable operations.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统在设计时考虑到代码占用小和接口简单，不提供完整的驱动程序平台或高级CPU特定功能，而是专注于两个方面：线程的实时调度和堆内存管理。其设计的简单性使其能够移植到大量平台上，并使开发重点集中在少量经过充分测试和可靠的操作上。
- en: On the other hand, third-party libraries and example code provided by hardware
    manufacturers often integrate FreeRTOS into their software kit, most of the time
    as the only alternative to the bare-metal approach for test applications and examples.
    Since third-party code is not directly included in FreeRTOS, this promotes competition
    among different solutions, as, for example, it is possible to integrate it with
    many TCP/IP stack implementations to provide networking support, even though none
    of them are part of the core system or tightly integrated with the kernel. Device
    drivers are not included in the kernel, but there are several demos of complete
    systems based on the integration of FreeRTOS with board support packages both
    distributed by the manufacturers or as part of a broader ecosystem, where FreeRTOS
    is included as a kernel.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，硬件制造商提供的第三方库和示例代码通常将FreeRTOS集成到他们的软件套件中，大多数情况下作为测试应用程序和示例中裸机方法的唯一替代方案。由于第三方代码不是直接包含在FreeRTOS中，这促进了不同解决方案之间的竞争，例如，它可以与许多TCP/IP堆栈实现集成以提供网络支持，尽管它们都不是核心系统的一部分或与内核紧密集成。设备驱动程序不包括在内核中，但有一些基于FreeRTOS与板级支持包集成的完整系统演示，这些板级支持包由制造商分发或作为更广泛生态系统的一部分，其中FreeRTOS作为内核的一部分。
- en: 'The scheduler is preemptive, with fixed priority levels and priority inheritance
    through shared mutexes. Priority levels and stack space sizes for all threads
    are decided upon when the thread is created. A typical FreeRTOS application starts
    from its `main` function, which is in charge of initializing the threads and starting
    the scheduler. A new task can be spawned using the `xTaskCreate` function:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器是抢占式的，具有固定的优先级级别，并通过共享互斥锁实现优先级继承。所有线程的优先级级别和堆栈空间大小是在创建线程时确定的。一个典型的FreeRTOS应用程序从其`main`函数开始，负责初始化线程和启动调度器。可以使用`xTaskCreate`函数创建新任务：
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The first parameter is a pointer to the `main` function, which will be the entry
    point for the task. When the entry point of the task is invoked, the custom parameters,
    which are specified as the fourth parameter here, will be passed as the sole argument
    for the function, allowing us to share a user-defined parameter with the thread
    upon task creation. The second argument of `xTaskCreate` is just the name of the
    task in a printable string, which is used for debugging purposes. The third and
    fifth parameters specify the stack size and the priority for this task, respectively.
    Finally, the last argument is an optional pointer to the internal struct of the
    task that will be populated when `xTaskCreate` returns, if a valid pointer was
    provided. This object, which is of the `TaskHandle_t` type, is required to access
    some of the task functionalities, such as task notifications or generic task utilities.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是`main`函数的指针，它将是任务的入口点。当任务入口点被调用时，作为第四个参数指定的自定义参数将作为函数的唯一参数传递，允许我们在任务创建时与线程共享用户定义的参数。`xTaskCreate`的第二个参数只是任务的可打印字符串名称，用于调试目的。第三个和第五个参数分别指定此任务的堆栈大小和优先级。最后，最后一个参数是可选的指向任务内部结构的指针，当`xTaskCreate`返回时，如果提供了有效的指针，则会填充。此对象是`TaskHandle_t`类型，用于访问一些任务功能，例如任务通知或通用任务实用工具。
- en: 'Once the application has created its tasks, the main function invokes the main
    scheduler by calling the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序创建了其任务，主函数通过调用以下内容来调用主调度器：
- en: '[PRE51]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If everything goes well, this function never returns and the main function of
    the application becomes the actual kernel task, which is in charge of scheduling
    the tasks defined earlier and newer tasks that can be added later on.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，此函数永远不会返回，并且应用程序的主函数成为实际的内核任务，负责调度之前定义的任务以及以后可以添加的新任务。
- en: 'One of the most interesting features offered by FreeRTOS is heap memory management,
    which is available in five flavors optimized for different designs:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS提供的最有趣的功能之一是堆内存管理，它提供了五种针对不同设计优化的风味：
- en: '**Heap 1**: Allows only one-time, static allocation in the heap, with no possibility
    of freeing up the memory. This is useful if the applications can allocate all
    the space needed at the beginning, as the memory will never become available to
    the system again.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆1**：允许在堆中只进行一次性的静态分配，没有释放内存的可能性。如果应用程序可以在开始时分配所有所需的空间，那么这很有用，因为内存将永远不会再次对系统可用。'
- en: '**Heap 2**: Allows freeing memory, but does not reassemble the freed blocks.
    This mechanism is suitable for implementations with a limited number of heap allocations,
    especially if they keep the same size as previously freed objects. If used improperly,
    this model may result in a heavily fragmented stack with the risk of running out
    of heap in the long run, even if the total size of the allocated object does not
    increase, due to the lack of memory reorganization.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆 2**：允许释放内存，但不重新组装已释放的块。此机制适用于具有有限堆分配数量的实现，特别是如果它们保持与之前释放的对象相同的大小。如果使用不当，此模型可能会导致严重碎片化的堆栈，长期运行中存在堆耗尽的风险，即使分配对象的总体大小没有增加，也是由于缺乏内存重组。'
- en: '`malloc`/`free` implementation provided by a third-party library that ensures
    that the wrapped memory operations become thread-safe when used within the FreeRTOS
    multithreading context. This model allows us to define a custom memory management
    method by defining the `malloc`/`free` function in a separate model, or by using
    the library implementation and attaching the `sbrk()` system call, as seen in
    [*Chapter 5*](B18730_05.xhtml#_idTextAnchor149), *Memory Management*.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由第三方库提供的 `malloc`/`free` 实现确保在 FreeRTOS 多线程上下文中使用时，包装的内存操作成为线程安全的。此模型允许我们通过在单独的模型中定义
    `malloc`/`free` 函数或使用库实现并附加 `sbrk()` 系统调用来定义自定义的内存管理方法，正如在 [*第 5 章*](B18730_05.xhtml#_idTextAnchor149)
    中所见，*内存管理*。
- en: '`free` blocks are merged and some housekeeping is done to optimize the use
    of the heap across heterogeneous allocations from different threads. This method
    limits the fragmentation of the heap and improves memory usage in the long run.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`free` 块被合并，并执行一些维护工作以优化来自不同线程的异构分配的堆使用。此方法限制了堆的碎片化并提高了长期内存使用效率。'
- en: '**Heap 5**: This method uses the same mechanism as heap 4, but allows us to
    define multiple non-contiguous memory regions to be part of the same heap space.
    This method is a ready-to-use solution for physical fragmentation, provided that
    the regions are defined during initialization time and provided to the system
    through the available API.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆 5**：此方法与堆 4 使用相同的机制，但允许我们定义多个非连续内存区域作为同一堆空间的组成部分。只要在初始化时定义这些区域并通过可用的 API
    提供给系统，这种方法就是解决物理碎片化的现成解决方案。'
- en: Selecting a specific heap model consists of including one of the available source
    files defining the same functions with different implementations. These files
    are part of the FreeRTOS distribution under recognizable names (`heap_1.c`, `heap_2.c`,
    and so on). Only one is chosen and must be linked to the final application to
    manage memory.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 选择特定的堆模型包括包含定义相同函数但实现不同的可用源文件之一。这些文件是 FreeRTOS 分发的一部分，具有可识别的名称（`heap_1.c`、`heap_2.c`
    等）。只能选择其中一个，并将其链接到最终应用程序以管理内存。
- en: The important functions that are exposed by the heap memory manager in FreeRTOS
    are `pvPortMalloc` and `pvPortFree`, both of which have similar signatures and
    effects as the `malloc` and `free` functions that we saw in [*Chapter 5*](B18730_05.xhtml#_idTextAnchor149),
    *Memory Management*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS 堆内存管理器公开的重要函数是 `pvPortMalloc` 和 `pvPortFree`，它们与我们在 [*第 5 章*](B18730_05.xhtml#_idTextAnchor149)
    中看到的 `malloc` 和 `free` 函数具有类似的签名和效果，*内存管理*。
- en: Support for MPU and thread mode is available, and threads can be run in restricted
    mode, where the only memory that is accessible is the one assigned to the specific
    thread. When running threads in restricted mode, the system API is still available
    as the system functions are mapped in a specific area in memory. The main safety
    strategy consists of voluntarily placing tasks in restricted mode and defining
    memory access boundaries by allowing the task to only access its own stack and
    up to three configurable regions in the mapped memory.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 MPU 和线程模式，线程可以在受限模式下运行，此时唯一可访问的内存是分配给特定线程的内存。当在受限模式下运行线程时，系统 API 仍然可用，因为系统函数被映射到内存中的特定区域。主要安全策略是通过自愿将任务置于受限模式并允许任务仅访问其自己的堆栈以及映射内存中的最多三个可配置区域来定义内存访问边界。
- en: Low-power management is limited to sleep mode, and no deep sleep mechanism is
    implemented by default. The system, however, allows us to redefine the scheduler
    callback functions to enter custom low-power modes, which may be used as starting
    points to implement tailored power-saving strategies.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 低功耗管理仅限于睡眠模式，默认情况下没有实现深度睡眠机制。然而，系统允许我们重新定义调度回调函数以进入自定义的低功耗模式，这些模式可以作为实施定制节能策略的起点。
- en: Recent versions of FreeRTOS include specific distributions with third-party
    code as a starting point for building a secure connected platform for IoT systems.
    The same authors have created a TCP/IP stack that is designed for FreeRTOS, and
    it is distributed in a FreeRTOS Plus bundle package alongside the kernel and wolfSSL
    library to support secure socket communication.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS 的最新版本包括特定的第三方代码分发版，作为构建安全连接平台（用于物联网系统）的起点。相同的作者还创建了一个为 FreeRTOS 设计的
    TCP/IP 栈，它作为 FreeRTOS Plus 套件的一部分与内核和 wolfSSL 库一起分发，以支持安全套接字通信。
- en: RIOT OS
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RIOT OS
- en: Mostly built on top of constrained microcontrollers, such as the Cortex-M0,
    low-power embedded systems are often little, battery-powered, or energy-harvesting
    devices, sporadically connecting to remote services using wireless technologies.
    These small, inexpensive systems are used in both IoT projects and install-and-forget
    scenarios, where they can operate for years on a single integrated power source
    with nearly no maintenance costs.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 主要建立在受限制的微控制器之上，如 Cortex-M0，低功耗嵌入式系统通常是小型、电池供电或能量收集设备，偶尔使用无线技术连接到远程服务。这些小型、低成本的系统在物联网项目和即装即用场景中都有应用，它们可以在单一集成电源上运行多年，几乎无需维护成本。
- en: Bare-metal architectures are still very popular in these use cases. However,
    a few very lightweight operating systems have been designed to organize and synchronize
    tasks using as few resources as possible, while still keeping a specific focus
    on power saving and connectivity. The challenge when developing this kind of operating
    system is to find a way to fit complex networking protocols into a few kilobytes
    of memory. Future-proof systems designed for the IoT services offer native IPv6
    networking, often through 6LoWPAN, and fully equipped yet minimalist TCP/IP stacks,
    designed to sacrifice throughput in favor of smaller memory footprints.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些用例中，裸机架构仍然非常流行。然而，一些非常轻量级的操作系统被设计出来，以尽可能少的资源来组织和同步任务，同时仍然专注于节能和连接性。开发这类操作系统时的挑战是找到一种方法，将复杂的网络协议放入几千字节内存中。为物联网服务设计的未来证明系统提供了本机
    IPv6 网络连接，通常通过 6LoWPAN 实现，并配备了完整的、极简的 TCP/IP 栈，旨在牺牲吞吐量以换取更小的内存占用。
- en: Due to their small code size, these systems may lack some advanced features
    by design. For example, they may not provide any memory safety strategies, or
    have a limited connectivity stack to save resources. It is not uncommon to have
    these kinds of systems run on a UDP-only network stack.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的代码量小，这些系统可能由于设计而缺乏一些高级功能。例如，它们可能不提供任何内存安全策略，或者具有有限的连接栈以节省资源。在仅使用 UDP 网络栈上运行这类系统并不罕见。
- en: Riot OS has a fast-growing community of enthusiasts and system developers. The
    goal of the project is to provide a system designed for low power consumption,
    taking into account the requirements to integrate the device into larger distributed
    systems. The core system is very scalable, as single components can be excluded
    at compile time.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Riot OS 拥有一个快速增长的爱好者群体和系统开发者社区。项目的目标是提供一个为低功耗设计的系统，考虑到将设备集成到更大分布式系统的需求。核心系统非常可扩展，因为单个组件可以在编译时排除。
- en: The approach used by Riot OS differs from the minimalist concept we saw in FreeRTOS,
    where the bare minimum amount of code is part of the core operating system, and
    everything else is integrated as external components. Riot OS offers a wide selection
    of libraries and device support code, including network stacks and wireless drivers
    communication, which makes this system particularly IoT-friendly. Components that
    are not part of the core functionality of the OS are divided into optional modules,
    with a custom, makefile-based build system designed to facilitate the inclusion
    of the modules in the application.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Riot OS 使用的方案与我们在 FreeRTOS 中看到的极简主义概念不同，在 FreeRTOS 中，最基本数量的代码是操作系统核心的一部分，而其他所有内容都作为外部组件集成。Riot
    OS 提供了广泛的库和设备支持代码，包括网络栈和无线驱动程序通信，这使得该系统特别适合物联网。不属于操作系统核心功能的组件被划分为可选模块，并设计了一个基于
    makefile 的自定义构建系统，以方便将这些模块包含到应用程序中。
- en: From an API point of view, the choice of the Riot community is an attempt to
    mimic the POSIX interface as much as possible. This improves the experience of
    embedded application development for programmers coming from different backgrounds
    and is used to write code using the APIs offered by the standard C language to
    access the resources on the system. The system, however, still runs on a flat
    model. Privilege separation is not implemented at the system level, and user space
    applications are still supposed to access system resources by referencing the
    system memory directly.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 从 API 角度来看，Riot 社区的选择是尽可能模仿 POSIX 接口。这改善了来自不同背景的程序员进行嵌入式应用程序开发的体验，并用于使用标准 C
    语言提供的 API 编写代码以访问系统资源。然而，系统仍然运行在平面模型上。系统级别没有实现权限分离，用户空间应用程序仍然应该通过直接引用系统内存来访问系统资源。
- en: As an additional safety measure, the MPU can be used to detect stack overflows
    in the single threads by placing a small read-only area at the bottom of the stack,
    which triggers an exception if threads are attempting to write past the limit
    of their assigned stack space.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的安全措施，MPU 可以通过在堆栈底部放置一个小型只读区域来检测单线程中的堆栈溢出，如果线程试图超出其分配的堆栈空间写入，则会触发异常。
- en: Riot implements a few communication stacks as modules, including a minimalist
    IP stack called **GNRC**. GNRC is an IPv6-only implementation tailored to the
    features of the underlying 802.15.4 network and provides a socket implementation
    to write lightweight IoT applications. The support for networking includes a lwIP
    compatibility layer. lwIP is included as a module to provide more complete TCP/IP
    implementations when required. WolfSSL is also available in a module, opening
    up possibilities for securing socket communication using the latest TLS version,
    as well as utilizing cryptography functionality to secure data at rest, for example.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Riot 实现了一些通信堆栈作为模块，包括一个名为 **GNRC** 的最小化 IP 堆栈。GNRC 是一个仅支持 IPv6 的实现，针对底层 802.15.4
    网络的特性进行了优化，并提供了一个套接字实现，用于编写轻量级的物联网应用程序。网络支持包括一个 lwIP 兼容层。lwIP 作为模块包含在内，以便在需要时提供更完整的
    TCP/IP 实现。WolfSSL 也作为一个模块提供，这为使用最新 TLS 版本来保护套接字通信以及利用加密功能来保护静态数据（例如）提供了可能性。
- en: One of the features offered by Riot is access to the configuration of low-power
    modes, which is integrated into the system through the power management module.
    This module provides an abstraction for managing platform-specific features, such
    as the stop and standby modes on Cortex-M platforms. Low-power modes can be activated
    at runtime from the application code to facilitate the integration of low-power
    strategies in the architecture. This is done using the real-time clock, the watchdog
    timer, or other external signals to return to normal running mode.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Riot 提供的一个功能是访问低功耗模式的配置，该配置通过电源管理模块集成到系统中。该模块为管理特定平台的功能提供了抽象，例如 Cortex-M 平台上的停止和待机模式。低功耗模式可以在运行时从应用程序代码中激活，以促进在架构中集成低功耗策略。这是通过实时时钟、看门狗定时器或其他外部信号返回到正常运行模式来实现的。
- en: The scheduler in Riot OS is tickless and based mostly on cooperation. Tasks
    can suspend themselves explicitly by calling the `task_yield` function, or by
    calling any of the blocking functions to access kernel features (such as IPC and
    timers) and hardware peripherals. Riot OS does not enforce any concurrency based
    on timeslices; a task is forcibly interrupted uniquely in case a hardware interrupt
    is received. Programming applications with this scheduler requires particular
    attention, because accidentally creating a busy loop in one task may lock up the
    entire system to starvation.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Riot OS 中的调度器是无滴答的，主要基于协作。任务可以通过调用 `task_yield` 函数或通过调用任何阻塞函数来访问内核功能（如 IPC 和定时器）和硬件外围设备来显式地挂起自己。Riot
    OS 不强制基于时间片的并发；当接收到硬件中断时，任务会被唯一地强制中断。使用此调度器编程应用程序需要特别注意，因为在一个任务中意外创建一个忙循环可能会导致整个系统因饥饿而锁定。
- en: 'Tasks in Riot OS can be created through the `thread_create` function:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Riot OS 中的任务可以通过 `thread_create` 函数创建：
- en: '[PRE52]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: While the syntax of `thread_create` may look similar to that of the equivalent
    function in FreeRTOS, we can spot a few differences in the approach to the two
    schedulers. In Riot OS, for example, the memory reserved for the stack space of
    the task being created must be allocated by the caller. The stack space cannot
    be automatically allocated upon task creation, which means more code in the caller
    but also more flexibility for customizing the location of each stack space in
    memory. As we mentioned previously, the scheduler is tickless, so there is no
    necessity to start it manually. Tasks can be created and stopped at any time during
    the execution.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `thread_create` 的语法可能看起来与 FreeRTOS 中等效函数的语法相似，但我们可以在两个调度器的处理方法中找到一些差异。例如，在
    Riot OS 中，为创建的任务保留的堆栈空间必须由调用者分配。堆栈空间不能在任务创建时自动分配，这意味着调用者需要更多的代码，但也提供了在内存中自定义每个堆栈空间位置的更多灵活性。正如我们之前提到的，调度器是无滴答的，因此没有必要手动启动它。任务可以在执行过程中随时创建和停止。
- en: 'Being designed for embedded targets with little RAM available, the use of dynamically
    allocated memory is discouraged in Riot OS. However, the system offers three different
    approaches for heap memory management:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 由于是为具有少量可用 RAM 的嵌入式目标设计的，Riot OS 中不建议使用动态分配的内存。然而，该系统提供了三种不同的堆内存管理方法：
- en: '`malloc` function uses this implementation, and the `free` function has no
    effect.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc` 函数使用此实现，而 `free` 函数没有效果。'
- en: '**Memory-array allocator**: A statically allocated buffer can be used as a
    memory pool for pseudo-dynamic allocation requests of a fixed, predefined size.
    This allocator may be useful in those scenarios where multiple buffers of the
    same size are handled by the application. This allocator has a custom API and
    does not modify the behavior of the default malloc function.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存数组分配器**：一个静态分配的缓冲区可以用作固定、预定义大小的伪动态分配请求的内存池。这种分配器在应用程序处理多个相同大小的缓冲区的情况下可能很有用。这个分配器有一个自定义的
    API，并且不会修改默认的 malloc 函数的行为。'
- en: '`malloc` is available as an optional module. When compiled in, the module replaces
    the `malloc` and `free` functions provided by the one-time allocator, which is
    then disabled.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc` 是一个可选模块。当编译进模块时，该模块将替换一次性分配器提供的 `malloc` 和 `free` 函数，然后禁用该分配器。'
- en: Riot OS is an interesting choice as a starting point for IoT systems. It provides
    a wide range of device drivers and modules, built and integrated on top of a lightweight
    and energy-aware core system, including a microkernel with a pre-emptive scheduler.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Riot OS 是一个有趣的起点，用于物联网系统。它提供了一系列设备驱动程序和模块，这些驱动程序和模块是在一个轻量级且节能的核心系统之上构建和集成的，包括一个具有抢占式调度器的微内核。
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the typical components of an embedded operating
    system by implementing one from scratch, with the only purpose of studying the
    internals of the system, how the various mechanisms can be integrated into the
    scheduler, and how blocking calls, driver APIs, and synchronization mechanisms
    can be provided to tasks.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过从头开始实现一个嵌入式操作系统，仅为了研究系统的内部结构，以及各种机制如何集成到调度器中，以及如何为任务提供阻塞调用、驱动程序 API
    和同步机制，从而探讨了嵌入式操作系统的典型组件。
- en: We then analyzed the components of two of the many very popular open-source,
    real-time operating systems for embedded microcontrollers, namely FreeRTOS and
    Riot OS, to highlight the differences in the design choices, implementation, and
    APIs provided for the applications to work with threads and memory management.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们分析了两个非常流行的开源实时嵌入式微控制器操作系统的组件，即 FreeRTOS 和 Riot OS，以突出设计选择、实现和为应用程序提供的工作线程和内存管理
    API 的差异。
- en: At this point, we can select the most appropriate OS for our architecture, and
    even write one ourselves when needed, by implementing our favorite scheduling,
    priority mechanisms, privilege separation between tasks and the kernel itself,
    and memory segmentation.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以选择最适合我们架构的操作系统，并在需要时通过实现我们喜欢的调度、优先级机制、任务和内核本身的特权分离以及内存分段来编写自己的操作系统。
- en: In the next chapter, we will take a closer look at **Trusted Execution Environments**
    (**TEEs**), with a particular focus on the TrustZone-M features recently introduced
    by ARM in their latest family of microcontrollers, which adds a new orthogonal
    level of privilege separation.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更深入地探讨**可信执行环境**（**TEEs**），特别是 ARM 在其最新系列微控制器中最近引入的 TrustZone-M 功能，它增加了新的正交特权分离级别。
