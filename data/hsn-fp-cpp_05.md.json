["```cpp\nauto increment = [](const int value) { return value + 1; };\n\nTEST_CASE(\"Increments value\"){\n    CHECK_EQ(2, increment(1));\n}\n```", "```cpp\nTEST_CASE(\"Increments twice\"){\n    CHECK_EQ(3, increment(increment(1)));\n}\n```", "```cpp\nauto incrementTwiceLambda = [](int value){return increment(increment(value));};\n\nTEST_CASE(\"Increments result of addition with lambda\"){\n    CHECK_EQ(3, incrementTwiceLambda(1));\n}\n```", "```cpp\nauto square = [](int value){ return value * value; };\n\nTEST_CASE(\"Squares the number\"){\n    CHECK_EQ(4, square(2));\n}\n```", "```cpp\nauto incrementSquareLambda = [](int value) { return increment(square(value));};\n\nTEST_CASE(\"Increments the squared number\"){\n    CHECK_EQ(5, incrementSquareLambda(2));\n}\n\n```", "```cpp\nauto incrementTwiceLambda = [](int value){ return increment(increment(value)); };\nauto incrementSquareLambda = [](int value) { return increment(square(value)); };\n```", "```cpp\ndef incrementTwiceLambda = increment << increment\ndef incrementSquareLambda = increment << square\n```", "```cpp\nauto compose(auto f, auto g){\n    return [f, g](auto x){ return f(g(x); };\n}\n\nTEST_CASE(\"Increments twice with composed lambda\"){\n    auto incrementTwice = compose(increment, increment);\n    CHECK_EQ(3, incrementTwice(1));\n}\n```", "```cpp\nfunction<int(int)> compose(function<int(int)> f,  function<int(int)> g){\n    return [f, g](auto x){ return f(g(x); };\n}\n\nTEST_CASE(\"Increments twice with composed lambda\"){\n    auto incrementTwice = compose(increment, increment);\n    CHECK_EQ(3, incrementTwice(1));\n}\n```", "```cpp\ntemplate <class F, class G>\nauto compose(F f, G g){\n    return [=](auto value){return f(g(value));};\n}\n\nTEST_CASE(\"Increments twice with composed lambda\"){\n    auto incrementTwice = compose(increment, increment);\n    CHECK_EQ(3, incrementTwice(1));\n}\n\nTEST_CASE(\"Increments square with composed lambda\"){\n    auto incrementSquare = compose(increment, square);\n    CHECK_EQ(5, incrementSquare(2));\n}\n```", "```cpp\nauto incrementSquare = compose(increment, square);\nauto squareIncrement = compose(square, increment);\n```", "```cpp\nauto increment = [](const int value) { return value + 1; };\nauto multiply = [](const int first, const int second){ return first * second; };\n```", "```cpp\ntemplate <class F, class G>\nauto compose(F f, G g){\n    return [=](auto value){return f(g(value));};\n}\n```", "```cpp\ntemplate <class F1, class G2>\nauto compose12(F1 f, G2 g){\n    return [=](auto first, auto second){ return f(g(first, second)); };\n}\n\nTEST_CASE(\"Increment result of multiplication\"){\n    CHECK_EQ(5, compose12(increment, multiply)(2, 2));\n}\n```", "```cpp\ntemplate <class F2, class G1>\nauto compose21(F2 f, G1 g){\n    return [=](auto first, auto second){ return f(g(first), g(second)); };\n}\n\nTEST_CASE(\"Multiplies two incremented values\"){\n    CHECK_EQ(4, compose21(multiply, increment)(1, 1));\n}\n```", "```cpp\nauto multiply = [](const int first, const int second){ return first *  \n    second; };\n```", "```cpp\ntemplate <class F, class G>\nauto compose(F f, G g){\n    return [=](auto value){return f(g(value));};\n}\n```", "```cpp\nauto multiplyDecomposed = [](const int first) { \n    return [=](const int second){ return first * second; }; \n};\n\nTEST_CASE(\"Adds using single parameter functions\"){\n    CHECK_EQ(4, multiplyDecomposed(2)(2));\n}\n```", "```cpp\ntemplate<class F>\nauto decomposeToOneParameter(F f){\n    return [=](auto first){\n        return [=](auto second){\n            return f(first, second);\n        };\n    };\n}\n\nTEST_CASE(\"Multiplies using single parameter functions\"){\n    CHECK_EQ(4, decomposeToOneParameter(multiply)(2)(2));\n}\n```", "```cpp\nTEST_CASE(\"Increment result of multiplication\"){\n    int first = 2;\n    int second = 2;\n    auto incrementResultOfMultiplication = compose(increment, \n        multiplyDecomposed);\n    CHECK_EQ(5, incrementResultOfMultiplication(first)(second));\n}\n```", "```cpp\nTEST_CASE(\"Increment result of multiplication\"){\n    int first = 2;\n    int second = 2;\n    auto incrementResultOfMultiplication = compose(increment, \n        multiplyDecomposed(first));\n    CHECK_EQ(5, incrementResultOfMultiplication(second));\n}\n```", "```cpp\nTEST_CASE(\"Increment result of multiplication final\"){\n    auto incrementResultOfMultiplication = [](int first, int second) {\n        return compose(increment, multiplyDecomposed(first))(second);\n    };\n\n    CHECK_EQ(5, incrementResultOfMultiplication(2, 2));\n}\n```", "```cpp\nTEST_CASE(\"Increment result of multiplication\"){\n    auto incrementResultOfMultiplication = [](int first, int second) { \n        return compose(increment, decomposeToOneParameter(multiply) \n            (first)) (second);\n };\n    int result = incrementResultOfMultiplication(2, 2);\n    CHECK_EQ(5, result);\n}\n```", "```cpp\nTEST_CASE(\"Multiply incremented values no compose\"){\n    auto multiplyIncrementedValues = [](int first, int second){\n        return multiply(increment(first), increment(second)); \n    };\n    int result = multiplyIncrementedValues(2, 2);\n    CHECK_EQ(9, result);\n}\n```", "```cpp\nTEST_CASE(\"Multiply incremented values decompose\"){\n    auto multiplyIncrementedValues = [](int first, int second){\n        return multiplyDecomposed(increment(first))(increment(second)); \n    };\n    int result = multiplyIncrementedValues(2, 2);\n    CHECK_EQ(9, result);\n}\n```", "```cpp\nTEST_CASE(\"Multiply incremented values compose simple\"){\n    auto multiplyIncrementedValues = [](int first, int second){\n        return compose(multiplyDecomposed, increment)(first)\n            (increment(second)); \n    };\n\n    int result = multiplyIncrementedValues(2, 2);\n    CHECK_EQ(9, result);\n}\n```", "```cpp\nTEST_CASE(\"Multiply incremented values decompose first\"){\n    auto multiplyIncrementedValues = [](int first, int second){\n        return compose(\n                decomposeToOneParameter(multiply), \n                increment\n               )(first)(increment(second)); \n    };\n    int result = multiplyIncrementedValues(2, 2);\n    CHECK_EQ(9, result);\n}\n```", "```cpp\n auto incrementResultOfMultiplication = [](int first, int second) { \n     return compose(increment, decomposeToOneParameter(multiply) \n        (first))(second);\n  };\n```", "```cpp\ntemplate <class F, class G>\nauto composeWithTwoParameters(F f, G g){\n    return [=](auto first, auto second) { \n        return compose(\n                f, \n                decomposeToOneParameter(g)(first)\n                )(second);\n   };\n};\n\nTEST_CASE(\"Increment result of multiplication\"){\n    auto incrementResultOfMultiplication =  \n    composeWithTwoParameters(increment, multiply);\n    int result = incrementResultOfMultiplication(2, 2);\n    CHECK_EQ(5, result);\n}\n```", "```cpp\n    auto multiplyIncrementedValues = [](int first, int second){\n        return compose(\n                 decomposeToOneParameter(multiply), \n                 increment\n                 )(first)(increment(second)); \n    };\n```", "```cpp\ntemplate<class F, class G>\nauto composeWithFunctionCallAllParameters(F f, G g){\n    return [=](auto first, auto second){\n        return compose(\n                decomposeToOneParameter(f), \n                g \n                )(first)(g(second)); \n    };\n};\n\nTEST_CASE(\"Multiply incremented values generalized\"){\n    auto multiplyIncrementedValues = \n    composeWithFunctionCallAllParameters(multiply, increment);\n    int result = multiplyIncrementedValues(2, 2);\n    CHECK_EQ(9, result);\n}\n```"]