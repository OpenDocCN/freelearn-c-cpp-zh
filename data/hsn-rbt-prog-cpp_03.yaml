- en: Implementing Blink with wiringPi
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用wiringPi实现Blink
- en: After setting up the Raspberry Pi, it's now time to connect different electronics
    components to it and program it using the C++ programming language. To use C++,
    we will first have to download and install a library called **wiringPi**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设置树莓派后，现在是时候连接不同的电子元件并使用C++编程语言对其进行编程了。要使用C++，我们首先需要下载并安装一个名为**wiringPi**的库。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Installing the `wiringPi` library inside the Raspberry Pi
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在树莓派内安装`wiringPi`库
- en: Making an LED blink
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让LED闪烁
- en: Smart Light—working with a digital sensor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能灯—使用数字传感器
- en: Pulse Width Modulation using softPwm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用softPwm进行脉宽调制
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The hardware requirements for this chapter are as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的硬件要求如下：
- en: 1 LED (any color)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个LED（任何颜色）
- en: 1 **LDR** (**Light Dependent Resistor**) sensor module
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 **LDR**（**光敏电阻**）传感器模块
- en: Raspberry Pi 3B+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派3B+
- en: 5-6 female to female connecting wires
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5-6个母对母连接线
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter02).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以从以下网址下载：[https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter02)。
- en: Installing the wiringPi library in the Raspberry Pi
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在树莓派中安装wiringPi库
- en: 'wiringPi is a pin-based GPIO access library that is written in C. Using this
    library, you can control the Raspberry Pi using C/C++ programming. The `wiringPi`
    library is easy to set up. Once installed, the Raspberry Pi GPIO pins will have
    wiringPi pin numbering. Let''s take a look at how to download and install wiringPi:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: wiringPi是一个基于引脚的GPIO访问库，用C语言编写。使用这个库，你可以用C/C++编程控制树莓派。`wiringPi`库很容易设置。一旦安装，树莓派GPIO引脚将具有wiringPi引脚编号。让我们看看如何下载和安装wiringPi：
- en: 'First, open the Terminal window by clicking on its icon from the taskbar:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，点击任务栏上的图标打开终端窗口：
- en: '![](img/ccf56d38-8928-47cc-be0c-ead4119c57fb.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccf56d38-8928-47cc-be0c-ead4119c57fb.png)'
- en: 'Before installing the `wiringPi` library, we first need to verify that our
    Raspberry Pi is up to date by checking for updates. If your Raspberry Pi is not
    updated, you may face errors while installing the `wiringPi` library. To update
    your Raspberry Pi, type the following command:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装`wiringPi`库之前，我们首先需要验证我们的树莓派是否有更新。如果你的树莓派没有更新，安装`wiringPi`库时可能会出现错误。要更新你的树莓派，输入以下命令：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding command can be seen as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![](img/177fcaa3-a9d0-4bda-8218-6d0564a55064.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/177fcaa3-a9d0-4bda-8218-6d0564a55064.png)'
- en: Depending on your internet speed, it will take around 10-15 minutes for the
    updates to download and install. Make sure that you place your Raspberry Pi near
    your Wi-Fi router.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的互联网速度，更新下载和安装需要大约10-15分钟。确保你将树莓派放在Wi-Fi路由器附近。
- en: 'After the update, type in the following command to upgrade the Raspberry Pi:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新后，输入以下命令升级树莓派：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'While upgrading, you may get a message asking you to download a particular
    component. Type `Y` and then press *Enter*. It will take around 30-40 minutes
    for the upgrade to complete. Once the upgrade is done, you will see the following
    message:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在升级过程中，你可能会收到一个要求下载特定组件的消息。输入`Y`然后按*Enter*。升级需要大约30-40分钟。升级完成后，你会看到以下消息：
- en: '![](img/e293e669-4a8c-47e0-bccf-b65446f782d9.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e293e669-4a8c-47e0-bccf-b65446f782d9.png)'
- en: 'After updating your Raspberry Pi, you will need to download and `install git-core`
    inside your Raspberry Pi. To install Git, type the following command:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新树莓派后，你需要在树莓派内下载和安装`git-core`。要安装Git，输入以下命令：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](img/e96c7786-8561-4382-aaf7-8739fa6bf47b.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e96c7786-8561-4382-aaf7-8739fa6bf47b.png)'
- en: 'After this, to download the `wiringPi` library from `git`, type in the following
    command:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，要从`git`下载`wiringPi`库，输入以下命令：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](img/e10ba477-59d4-4a5b-9a9f-d2e4dca0d243.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e10ba477-59d4-4a5b-9a9f-d2e4dca0d243.png)'
- en: 'Now, if you click on the File Manager option and click on the `pi` folder,
    you should see the `wiringPi` folder:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你点击文件管理器选项并点击`pi`文件夹，你应该会看到`wiringPi`文件夹：
- en: '![](img/fc5142f9-d5d1-49dd-b68e-420c27a6db79.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc5142f9-d5d1-49dd-b68e-420c27a6db79.png)'
- en: 'Next, change the directory to `wiringPi`, so that the wiringPi files are downloaded
    and installed inside this particular folder. The command for changing the directory
    is `cd`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更改目录到`wiringPi`，以便wiringPi文件被下载并安装到这个特定文件夹内。更改目录的命令是`cd`：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](img/9df6e314-f099-4b15-86f9-98a351c609a6.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9df6e314-f099-4b15-86f9-98a351c609a6.png)'
- en: You should now see the directory pointing toward the `wiringPi` folder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该看到指向`wiringPi`文件夹的目录。
- en: 'Next, to fetch the Git files from their `origin` directory, type in the following command:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为了从`origin`目录获取Git文件，输入以下命令：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/fc06f480-b074-47f2-9e8b-d2a95b47d84d.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc06f480-b074-47f2-9e8b-d2a95b47d84d.png)'
- en: 'Finally, for building the files, type in the following command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了构建文件，输入以下命令：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/e722c4f6-128b-43e4-868e-cf22a2718159.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e722c4f6-128b-43e4-868e-cf22a2718159.png)'
- en: 'Once everything is done, you will see an `All done` message:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都完成后，你会看到一个`All done`消息：
- en: '![](img/2c66fbdf-02e9-4d2f-87bb-8c148679e580.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c66fbdf-02e9-4d2f-87bb-8c148679e580.png)'
- en: Now that we have installed the wiringPi library, we can move on and understand
    wiringPi pin configurations on the RPi.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了wiringPi库，我们可以继续了解RPi上的wiringPi引脚配置。
- en: Accessing Raspberry Pi GPIO pins via wiringPi
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过wiringPi访问树莓派GPIO引脚
- en: 'Since we have installed wiringPi, we can now look at the wiringPi pin numbering,
    as shown in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经安装了wiringPi，现在我们可以看一下wiringPi引脚编号，如下截图所示：
- en: '![](img/8cf066e9-8e3b-4f0d-ab08-90c43e25de71.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cf066e9-8e3b-4f0d-ab08-90c43e25de71.png)'
- en: The `Physical` column represents the Raspberry Pi numbering from `1-40`. On
    both sides of the `Physical` column, you will see the wiringPi (`wPi`) columns.
    The arrows pointing from the `Physical` column to `wPi` represent the wiringPi
    pin numbering for a particular physical pin of a Raspberry Pi.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`物理`列代表树莓派编号从`1-40`。在`物理`列的两侧，您将看到wiringPi（`wPi`）列。从`物理`列指向`wPi`的箭头代表树莓派的特定物理引脚的wiringPi引脚编号。'
- en: 'Take a look at the following examples:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例：
- en: Physical pin number 3 has a wiringPi pin number of 8
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理引脚号3的wiringPi引脚号为8
- en: Physical pin number 5 has a wiringPi pin number of 9
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理引脚号5的wiringPi引脚号为9
- en: Physical pin number 8 has a wiringPi pin number of 15
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理引脚号8的wiringPi引脚号为15
- en: Physical pin number 11 has a wiringPi pin number of 0
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理引脚号11的wiringPi引脚号为0
- en: Physical pin number 40 has a wiringPi pin number of 29
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理引脚号40的wiringPi引脚号为29
- en: By consulting this table, you can figure out which of the remaining physical
    pins correspond to which wiringPi pins.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查阅这个表，您可以找出剩下的物理引脚对应的wiringPi引脚。
- en: wiringPi pin numbers from **17-20** do not exist. After **wPi pin 16**, we skip
    straight to **wPi pin 21**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: wiringPi引脚号从17到20不存在。在wPi引脚16之后，我们直接跳到wPi引脚21。
- en: 'To better understand the relationship between the wiringPi pins and the physical
    pins, you can refer to the following diagram:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解wiringPi引脚和物理引脚之间的关系，您可以参考以下图表：
- en: '![](img/97c2efb3-a563-478b-9e1c-441935552691.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97c2efb3-a563-478b-9e1c-441935552691.png)'
- en: 'The wiringPi pin numbering is what you will need to remember while programming.
    We can use a total of **28** wiringPi pins for programming. As well as these,
    we have the following pins, which can be used for providing power and can be used
    as ground pins:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: wiringPi引脚编号是编程时需要记住的。我们可以使用总共28个wiringPi引脚进行编程。除此之外，我们还有以下引脚，可以用于提供电源并可用作接地引脚：
- en: Physical pin numbers **6**, **9**, **14**, **20**, **25**, **30**, **34**, and
    **39** are ground pins
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理引脚号6、9、14、20、25、30、34和39是接地引脚
- en: Physical pin numbers **2** and **4** provide a +5V supply
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理引脚号2和4提供+5V电源
- en: Physical pin numbers **1** and **17** provide a +3.3V supply
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理引脚号1和17提供+3.3V电源
- en: Let's move on to writing our first C++ program for Raspberry Pi.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续编写我们的第一个树莓派C++程序。
- en: Making an LED blink
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让LED闪烁
- en: 'The very first project that we are going to create is making an LED blink.
    For this project, we require the following hardware components:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的第一个项目是让LED闪烁。对于这个项目，我们需要以下硬件组件：
- en: Raspberry Pi
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派
- en: 1 LED
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个LED
- en: Two female-to-female wires
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两根母对母导线
- en: Wiring connections
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接线连接
- en: 'Connecting the LED to the Raspberry Pi is straightforward. Before doing this,
    however, let''s take a closer look at the pins of the LED:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将LED连接到树莓派非常简单。不过，在这之前，让我们仔细看一下LED的引脚：
- en: '![](img/a8e06d09-ca03-4a3b-812f-6d932b5ef25a.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8e06d09-ca03-4a3b-812f-6d932b5ef25a.png)'
- en: The LED contains one positive pin and one negative pin. The long pin is the
    positive pin, which you can connect to any data pin of the Raspberry Pi. The short
    pin is the negative pin, which can be connected to the ground pin of the Raspberry
    Pi.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: LED包含一个正极引脚和一个负极引脚。长引脚是正极引脚，可以连接到树莓派的任何数据引脚上。短引脚是负极引脚，可以连接到树莓派的接地引脚上。
- en: 'Let''s connect it up. First, connect the negative pin of the LED to the ground
    pin (physical pin number **6**) of the Raspberry Pi. Next, connect the positive
    pin of the LED to wiringPi pin number **15**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们连接它。首先，将LED的负极引脚连接到树莓派的接地引脚（物理引脚号6）。接下来，将LED的正极引脚连接到wiringPi引脚号15：
- en: '**![](img/0f6a2e67-aebb-4272-8974-1d153da87637.png) **'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/0f6a2e67-aebb-4272-8974-1d153da87637.png) **'
- en: Now the we've connected the LED to the Raspberry Pi, let's write a program to
    make the LED blink.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将LED连接到树莓派，让我们编写一个程序让LED闪烁。
- en: The blinking program
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闪烁程序
- en: 'To write our first C++ program, we are going to use Geany Programmer''s Editor.
    To open Geany, click on the **Raspberry icon**, go to Programming, and then select **Geany
    Programmer''s Editor**:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写我们的第一个C++程序，我们将使用Geany程序编辑器。要打开Geany，点击**树莓**图标，转到**编程**，然后选择**Geany程序编辑器**：
- en: '![](img/a90522b4-7b0a-4787-864c-b73596641d0a.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a90522b4-7b0a-4787-864c-b73596641d0a.png)'
- en: After opening Geany, you will see an unsaved file called `Untitled`. The first
    thing that we need to do is save the file. Click on File | Save as and give this
    file the name `Blink.cpp`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Geany后，您会看到一个名为`Untitled`的未保存文件。我们需要做的第一件事是保存文件。点击文件|另存为，并将此文件命名为`Blink.cpp`。
- en: 'Inside this file, write the following code to make the LED blink. You can download
    the `Blink.cpp` program from the `Chapter02` folder of GitHub repository:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，写入以下代码使LED闪烁。您可以从GitHub存储库的`Chapter02`文件夹中下载`Blink.cpp`程序：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you have done Arduino programming before, you are likely to have understood
    around 90% of this code. This is because wiringPi allows us to write C++ programs
    in Arduino format:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前做过Arduino编程，您可能已经理解了这段代码的大约90%。这是因为wiringPi允许我们以Arduino格式编写C++程序：
- en: In the preceding code, we first import the `iostream` and the `wiringPi` library.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们首先导入了`iostream`和`wiringPi`库。
- en: Next, we have the main function, called `int main`***.*** Since this function
    does not have any arguments, we write a `void` statement inside the round brackets.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有主函数，称为`int main`。由于这个函数没有任何参数，我们在圆括号内写入`void`语句。
- en: After this, the `wiringPisetup()` function initializes `wiringPi`. It assumes
    that this program will use the wiringPi numbering scheme.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，`wiringPisetup()`函数初始化了`wiringPi`。它假定这个程序将使用wiringPi编号方案。
- en: Next, with the `pinMode(15, OUTPUT)` command, we are setting the wiringPi pin
    number `15` as the `OUTPUT` pin. This is the pin we have connected to the positive
    pin of the LED.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`pinMode(15, OUTPUT)`命令，我们将wiringPi引脚号15设置为`OUTPUT`引脚。这是我们连接到LED正极引脚的引脚。
- en: After that, we have an infinite `for` loop. The code written inside it will
    run infinitely, unless we stop it manually from the coding editor.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们有一个无限的`for`循环。其中写入的代码将无限运行，除非我们从编码编辑器手动停止它。
- en: With the `digitalWrite(15,HIGH)` command, we write a `HIGH` signal on the LED,
    which means the LED will turn on. Instead of `HIGH`, we could also put the number
    `1`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`digitalWrite(15,HIGH)`命令，我们在LED上写入`HIGH`信号，这意味着LED将打开。我们也可以使用数字`1`代替`HIGH`。
- en: After this, with the `delay(1000)` command, we ensure that the LED is only **on**
    for one second.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过`delay(1000)`命令，我们确保LED只亮**一秒**。
- en: Next, with the `digitalWrite(15,LOW)` command, we write a `LOW` signal on the
    LED. This means that the LED will turn **off** for one second.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过`digitalWrite(15,LOW)`命令，在LED上写入`LOW`信号。这意味着LED将**关闭**一秒钟。
- en: Since this code is inside a for loop, the LED will keep turning **on** and **off**
    until we instruct it otherwise.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于此代码位于for循环中，LED将保持**开**和**关**，直到我们另行指示为止。
- en: Uploading the code to the Raspberry Pi
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码上传到树莓派
- en: 'Since we are using wiringPi numbering conventions, we will add the `-lwiringPi` command inside
    the Build command so that our C++ program with the `wiringPi` library is compiled
    and built successfully. To open the Build command, click on Build | Set Build
    Commands. Inside the command boxes next to the Compile and Build buttons, add `-lwiringPi` at
    the end and then click OK:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是wiringPi编号约定，我们将在Build命令中添加`-lwiringPi`命令，以便我们的C++程序能够成功编译和构建`wiringPi`库。要打开Build命令，点击Build
    | Set Build Commands。在Compile和Build按钮旁的命令框中，添加`-lwiringPi`，然后点击OK：
- en: '![](img/e30cbd86-64fc-45f5-b473-f0a539dea459.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e30cbd86-64fc-45f5-b473-f0a539dea459.png)'
- en: 'Next, to compile the code, click on the **compilation button** (the brown icon).
    Finally, to upload the code to the Raspberry Pi, press the **build button** (the
    airplane icon):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，要编译代码，请点击**编译按钮**（棕色图标）。最后，要将代码上传到树莓派，请按**构建按钮**（飞机图标）：
- en: '![](img/95a1fd04-a578-4b78-933d-6ad76438007c.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95a1fd04-a578-4b78-933d-6ad76438007c.png)'
- en: The compilation icon will check for errors in the code. If there aren't any,
    click the build icon to test the blinking output. After building the code, the
    build icon will turn into a red circle. Click on the red circle to stop the program.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 编译图标将检查代码中的错误。如果没有错误，点击构建图标以测试闪烁输出。构建代码后，构建图标将变成红色圆圈。点击红色圆圈停止程序。
- en: Smart light – working with digital sensor
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能灯 - 与数字传感器一起工作
- en: 'After writing our first C/C++ program for Raspberry Pi, we can now write a
    program that will take input from an LDR sensor and turn the LED on or off. For
    this project, you will need the following hardware components:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在为树莓派编写我们的第一个C/C++程序之后，我们现在可以编写一个程序，该程序将从LDR传感器接收输入并控制LED的开关。对于这个项目，您将需要以下硬件组件：
- en: 1 LDR sensor module
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个LDR传感器模块
- en: 1 LED
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个LED
- en: Raspberry Pi
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派
- en: 5 female-to-female connecting wires
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5根母对母连接线
- en: First, let's explore how the LDR sensor works.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探讨一下LDR传感器的工作原理。
- en: The LDR sensor and the way it works
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LDR传感器及其工作原理
- en: 'An LDR sensor is an analog input sensor that consists of a variable resistor
    whose resistance varies depending on the amount of light falling on its surface.
    When there is no light in the room, the resistance of the LDR sensor is HIGH (up
    to 1 M ohm) and in the presence of light, the resistance of the LDR sensor is
    LOW. The LDR sensor consists of two pins. These pins do not have positive and
    negative polarity. We can use any pin as a data or ground pin and because of this,
    the LDR sensor is sometimes referred to as a special type resistor. The image
    of the LDR sensor is shown in the following photo:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: LDR传感器是一种模拟输入传感器，由可变电阻器组成，其电阻取决于其表面上落下的光线数量。当房间里没有光时，LDR传感器的电阻很高（高达1兆欧姆），而在有光的情况下，LDR传感器的电阻很低。LDR传感器由两个引脚组成。这些引脚没有正负极性。我们可以使用任何引脚作为数据或地引脚，因此LDR传感器有时被称为特殊类型的电阻器。LDR传感器的图像如下图所示：
- en: '![](img/64d208de-ef4f-4fef-8c6f-952cfc431afe.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64d208de-ef4f-4fef-8c6f-952cfc431afe.png)'
- en: 'Since LDR is an analog sensor, we cannot connect it directly to the RPi as
    this does not contain an **analog to digital converter** (**ADC**) circuit. Because
    of this, RPi cannot read incoming analog data from an LDR sensor. So, instead
    of an LDR sensor, we will use an LDR digital sensor module, which will provide
    digital data to the RPi:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于LDR是模拟传感器，我们不能直接将其连接到RPi，因为RPi不包含**模拟到数字转换器**（**ADC**）电路。因此，RPi无法读取来自LDR传感器的模拟数据。因此，我们将使用LDR数字传感器模块，而不是LDR传感器，该模块将向RPi提供数字数据：
- en: '![](img/a9d1de05-fc00-46b5-a57d-f16da16039a9.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9d1de05-fc00-46b5-a57d-f16da16039a9.png)'
- en: 'An LDR sensor module will read the incoming analog data from the LDR sensor
    and provide digital data in the form of HIGH or LOW as output. The LDR sensor
    module consists of 3 pins: **D0** (**data output**), ground, and Vcc. D0 will
    provide digital data as output, which is further provided as input to RPi pins.
    The D0 pin will be HIGH in low light and will be LOW in the presence of light.
    The sensor module also consists of a potentiometer sensor, which can be used to
    vary the resistance of the LDR sensor.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: LDR传感器模块将读取来自LDR传感器的模拟数据，并以高电平或低电平的形式提供数字数据作为输出。LDR传感器模块由3个引脚组成：**D0**（**数据输出**）、地和Vcc。D0将提供数字数据作为输出，然后作为输入提供给RPi引脚。在光线较暗时，D0引脚将为高电平，在有光时，D0引脚将为低电平。传感器模块还包括一个电位器传感器，可用于改变LDR传感器的电阻。
- en: Practical uses of the LDR sensor module is seen in street lamps, which automatically
    turn off during day time and turn on during night time. The smart light program
    that we are going to write is somewhat similar to this application, but instead
    of a street lamp, we are going to use an LED to keep things simple.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: LDR传感器模块的实际用途可见于街灯，它们在白天自动关闭，在夜晚自动打开。我们将要编写的智能灯程序与此应用有些类似，但我们将使用LED来简化事情，而不是街灯。
- en: Now that we've gained an understanding of the basic way in which an LDR sensor
    works, next let's connect the LDR sensor module to Raspberry Pi.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了LDR传感器的基本工作原理，接下来让我们将LDR传感器模块连接到树莓派。
- en: Wiring connection
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接线连接
- en: 'With a wiring connection, we can connect the LDR sensor module and a LED to
    the RPi:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接线连接，我们可以将LDR传感器模块和LED连接到RPi：
- en: '![](img/72d9bc67-5467-4d05-a5a0-af7d7bc7fbff.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72d9bc67-5467-4d05-a5a0-af7d7bc7fbff.png)'
- en: 'The wiring connections are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接线连接如下：
- en: wiringPi pin 8 of the RPi is connected to the D0 pin of the LDR sensor module
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RPi的wiringPi引脚8连接到LDR传感器模块的D0引脚
- en: Physical pin 2 of the RPi is connected to the Vcc pin of the LDR sensor module
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RPi的物理引脚2连接到LDR传感器模块的Vcc引脚
- en: Physical pin 6 of the RPi is connected to the Gnd pin of the LDR sensor module
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RPi的物理引脚6连接到LDR传感器模块的Gnd引脚
- en: wiringPi pin 0 is connected to the positive pin of the LED
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: wiringPi引脚0连接到LED的正极
- en: Physical pin 14 is connected to the negative pin of the LED
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理引脚14连接到LED的负极
- en: Now that we have connected the LDR sensor module and LED to the RPi, let's write
    the program to turn the LED on/off by taking inputs from the LDR sensor.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经连接了LDR传感器模块和LED到RPi，让我们编写程序，通过从LDR传感器获取输入来控制LED的开关。
- en: Smart light program
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能灯程序
- en: 'In this smart light program, we will first read input from the LDR sensor and,
    based on the input value, we will turn the LED on or off. The program for smart
    light is described as follows. You can download the `SmartLight.cpp` program from
    the `Chapter02` folder of this book''s GitHub repository:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个智能灯程序中，我们将首先从LDR传感器读取输入，并根据输入值来控制LED的开关。智能灯的程序描述如下。您可以从本书的GitHub存储库的`Chapter02`文件夹中下载`SmartLight.cpp`程序：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The explanation of the preceding program is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序的解释如下：
- en: Inside the `main` function, we have set wiringPi pin 8 as the input pin and
    wiringPi pin 0 as the output pin.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们将wiringPi引脚8设置为输入引脚，将wiringPi引脚0设置为输出引脚。
- en: Next, in the `for` loop, using the `digitalRead(8)` function, we are reading
    the incoming digital data from the digital pin(D0) of the LDR sensor and storing
    it inside the `ldrstate` variable. From the LDR sensor, we will receive HIGH(1)
    data or LOW(0) data. The `ldrstate` variable will be HIGH when there is no light
    and it will be LOW when there is light.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，在`for`循环中，使用`digitalRead(8)`函数，我们从LDR传感器的数字引脚(D0)读取传入的数字数据，并将其存储在`ldrstate`变量中。从LDR传感器，我们将接收HIGH(1)数据或LOW(0)数据。当没有光时，`ldrstate`变量将为HIGH，当有光时，`ldrstate`变量将为LOW。
- en: Next, we will check whether the data inside the `ldrstate` variable is HIGH
    or LOW using an `if...else` condition.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将检查`ldrstate`变量内的数据是HIGH还是LOW，使用`if...else`条件。
- en: Using `if(ldrstate == HIGH)`, we are comparing whether the data inside the `ldrstate`
    variable is HIGH. If it is HIGH, we are turning the LED on using `digitalWrite(0,HIGH)`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if(ldrstate == HIGH)`，我们比较`ldrstate`变量内的数据是否为HIGH。如果是HIGH，我们使用`digitalWrite(0,HIGH)`来打开LED。
- en: If the `ldrstate` is LOW, then the `else` condition will execute and by using
    `digitalWrite(0,LOW)`, we are turning the LED off. Next, you can click on the
    Compile button to compile the code and then test it by clicking the Build button.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`ldrstate`为LOW，则`else`条件将执行，并且通过使用`digitalWrite(0,LOW)`，我们将关闭LED。接下来，您可以单击“编译”按钮来编译代码，然后单击“构建”按钮来测试代码。
- en: Now that we understand the SmartLight program, we will explore the concept of
    **Pulse Width Modulation** (**PWM**) and use a library called softPWM to change
    the brightness of an LED.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了SmartLight程序，我们将探讨**脉宽调制**（**PWM**）的概念，并使用一个名为softPWM的库来改变LED的亮度。
- en: Pulse Width Modulation using softPWM
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用softPWM的脉宽调制
- en: PWM is a powerful technique that can use to control the power that's delivered
    to an electronic component like LEDs and motors. Using PWM, we can perform operations
    like controlling the brightness of an LED or reducing the speed of a motor. In
    this section, we will first understand the way in which a PWM works and then we
    will write a simple PWM program to increase the brightness of an LED, step by
    step.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: PWM是一种强大的技术，可以用来控制传递给LED和电机等电子元件的电源。使用PWM，我们可以执行控制LED亮度或减速电机速度等操作。在本节中，我们将首先了解PWM的工作原理，然后逐步编写一个简单的PWM程序来增加LED的亮度。
- en: How PWM works
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PWM的工作原理
- en: 'In the previous `Blink.cpp` program, we applied a digital signal from the RPi
    to the LED. Digital signals either have a HIGH state or a LOW state. In, HIGH,
    state the Raspberry Pi pins produces a voltage of 3.3V and in a LOW state, the
    pins produce a voltage of 0V. Consequently, at 3.3V, the LED is on with full brightness
    and at 0V, the LED is turned off:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的`Blink.cpp`程序中，我们将数字信号从RPi应用到LED。数字信号可以处于HIGH状态或LOW状态。在HIGH状态下，树莓派引脚产生3.3V的电压，在LOW状态下，引脚产生0V的电压。因此，在3.3V时，LED以全亮度开启，在0V时，LED关闭：
- en: '![](img/6afde46d-da33-4d13-9f5b-5bb3dfaa1799.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6afde46d-da33-4d13-9f5b-5bb3dfaa1799.png)'
- en: 'To reduce the brightness of the LED, we need to reduce the voltage. To reduce
    the voltage, we use PWM. In PWM, a single wave with one full repetition is called
    a cycle and the time taken for a cycle to complete itself is called a period.
    In the following diagram, the red lines represent one complete cycle. The time
    taken to complete that cycle is called a period:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了降低LED的亮度，我们需要降低电压。为了降低电压，我们使用PWM。在PWM中，一个完整的重复波形称为一个周期，完成一个周期所需的时间称为周期。在下图中，红线代表一个完整的周期。完成该周期所需的时间称为周期：
- en: '![](img/ab19827a-aa9f-4400-afc5-4c4ae26df015.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab19827a-aa9f-4400-afc5-4c4ae26df015.png)'
- en: 'The time duration for which a signal remains HIGH is called a duty cycle, as
    shown in the following diagram:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 信号保持高电平的时间称为占空比，如下图所示：
- en: '![](img/abbf8698-365d-473e-9aff-ac95c0e6e752.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/abbf8698-365d-473e-9aff-ac95c0e6e752.png)'
- en: 'The duty cycle is represented in percentage format, and the formula for calculating
    the duty cycle is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 占空比以百分比格式表示，计算占空比的公式如下：
- en: '*Duty cycle = (time duration for HIGH signal / total time) X 100 *'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*占空比 =（高信号的时间持续时间/总时间）X 100*'
- en: 'In the preceding diagram, the signal remains HIGH for 7 milliseconds, and the
    total time period for a single cycle is 10 milliseconds:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，信号保持高电平7毫秒，单个周期的总时间为10毫秒：
- en: '![](img/7584af2b-571e-46c8-9570-c94b1466b4d4.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7584af2b-571e-46c8-9570-c94b1466b4d4.png)'
- en: Duty cycle =  70% or 0.7
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 占空比 = 70% 或 0.7
- en: 'Consequently, the duty cycle is 0.7 or 70%. Next, to find the new voltage value,
    we need to multiply the duty cycle with the maximum voltage value, which is 3.3V:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，占空比为0.7或70%。接下来，为了找到新的电压值，我们需要将占空比乘以最大电压值3.3V：
- en: '*Vout = Duty cycle X Vmax*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*Vout = 占空比 X Vmax*'
- en: '*Vout = 0.7 X 3.3*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*Vout = 0.7 X 3.3*'
- en: '*Vout = 2.31V*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*Vout = 2.31V*'
- en: At a duty cycle of 70%, the voltage that's provided to the LED will be 2.31V
    and the brightness of the LED will reduce slightly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在70%的占空比下，提供给LED的电压将为2.31V，LED的亮度将略有降低。
- en: 'Now, if we reduce the duty cycle to 40%, then the voltage that''s provided
    to the LED will be 1.32V, as shown in the following diagram:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们将占空比降低到40%，那么提供给LED的电压将为1.32V，如下图所示：
- en: '![](img/6c676d13-34c8-465f-8948-eba0df3491dc.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c676d13-34c8-465f-8948-eba0df3491dc.png)'
- en: Now that we have understand how PWM is used to reduce the voltage at RPi data
    pins, let's take a look at the softPWM library, using which data pins can be used
    as PWM pins.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了PWM如何用于降低RPi数据引脚的电压，让我们来看看softPWM库，使用该库可以将数据引脚用作PWM引脚。
- en: The softPWM library
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: softPWM库
- en: 'wiringPi consists of a softPWM library, using which we can get PWM signal output
    from any data pin of the RPi. The softPWM library contains two main functions:
    `softPwmCreate` and `softPwmWrite`. Both of these functions work as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: wiringPi包含一个softPWM库，使用该库可以从RPi的任何数据引脚获得PWM信号输出。softPWM库包含两个主要函数：`softPwmCreate`和`softPwmWrite`。这两个函数的工作原理如下：
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `softPwmCreate` function is used to create a PWM pin. It consists of three
    main parameters:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`softPwmCreate`函数用于创建PWM引脚。它包括三个主要参数：'
- en: '`pin number`: Pin number represents the wiringPi pin that we want to set as
    a PWM pin.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`引脚编号`：引脚编号表示我们要设置为PWM引脚的wiringPi引脚。'
- en: '`initial duty cycle value`: In initial duty cycle value we have to provide
    as the minimum value of the duty cycle. The initial duty cycle value is ideally
    set to `0`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`初始占空比值`：在初始占空比值中，我们必须提供作为占空比最小值的值。初始占空比值理想情况下设置为`0`。'
- en: '`max duty cycle value`: In the max duty cycle value, we have to provide the
    maximum value of the duty cycle. This value must be set to `100`:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`最大占空比值`：在最大占空比值中，我们必须提供占空比的最大值。此值必须设置为`100`：'
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `softPwmWrite` function is used to write PWM data on the output device
    (for example, LED). It consists of two parameters:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`softPwmWrite`函数用于在输出设备（例如LED）上写入PWM数据。它包括两个参数：'
- en: '`pin number`: Pin number represents the wiringPi pin on which we have to write
    the PWM data.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`引脚编号`：引脚编号表示我们必须在其上写入PWM数据的wiringPi引脚。'
- en: '`duty cycle value`: In this parameter, we have to provide the duty cycle value.
    The duty cycle value must be between the initial duty cycle value and max duty
    cycle value, that is, in the range of 0 to 100.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`占空比值`：在此参数中，我们必须提供占空比值。占空比值必须在初始占空比值和最大占空比值之间，即在0到100的范围内。'
- en: Now that we understand the two functions inside the softPWM library, we will
    write a simple C++ program to make an LED blink at different intensities.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了softPWM库中的两个函数，我们将编写一个简单的C++程序，以使LED以不同的强度闪烁。
- en: Making an LED blink with the softPWM library
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用softPWM库使LED闪烁
- en: 'For the blinking LED program using softPWM, you will need one led. In my case,
    I have connected the negative pin of the LED to physical pin 6 (ground pin) of
    the RPi, and the positive pin of the LED is connected to wiringPi pin 15\. The
    wiring connection is shown in the following diagram:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用softPWM的LED闪烁程序，您将需要一个LED。在我的情况下，我已将LED的负极连接到RPi的物理引脚6（地引脚），LED的正极连接到wiringPi引脚15。连接方式如下图所示：
- en: '![](img/6c4edb3d-6fda-4910-8058-9b013f70b0fd.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c4edb3d-6fda-4910-8058-9b013f70b0fd.png)'
- en: 'After connecting the led to the RPi, it''s time to write the program. The program
    for blinking the led using the softPWM library is as follows. This program is
    called `Soft_PWM_Blink.cpp`, and you can download this program from the `Chapter02`
    folder of this book''s GitHub repository:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将LED连接到RPi后，是时候编写程序了。使用softPWM库闪烁LED的程序如下。此程序称为`Soft_PWM_Blink.cpp`，您可以从本书的GitHub存储库的`Chapter02`文件夹中下载此程序：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The explanation of the preceding program is as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前面程序的解释如下：
- en: In this program, we first import the `wiringPi` and `iostream` libraries, along
    with the `softPwm` library.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此程序中，我们首先导入了`wiringPi`和`iostream`库，以及`softPwm`库。
- en: Next, in the `main` function, using the `softPwmCreate` function, we are setting
    wiringPi pin 15 as the PWM pin. The initial duty cycle value is set to `0` and
    the max duty cycle value is set to `100`.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，在`main`函数中，使用`softPwmCreate`函数，我们将wiringPi引脚15设置为PWM引脚。初始占空比值设置为`0`，最大占空比值设置为`100`。
- en: After that, inside the `for` loop, we have six `softPwmWrite` functions, and
    by using these functions, we turn on the LED at different brightness levels.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，在`for`循环内，我们有六个`softPwmWrite`函数，通过使用这些函数，我们以不同的亮度级别打开LED。
- en: With the `softPwmWrite(15,25)` function code, the LED will be HIGH with 25%
    brightness. Since the delay is set to 1,000, the LED will be HIGH for 1 second.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`softPwmWrite(15,25)`函数代码，LED将以25%的亮度保持高电平。由于延迟设置为1,000，LED将保持高电平1秒。
- en: After this, since the duty cycle value is set to `0`, the led will be LOW for
    1 second in the `softPwmWrite(15 , 0)` function code.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，由于占空比值设置为`0`，LED将在`softPwmWrite(15 , 0)`函数代码中保持低电平1秒。
- en: Next, with the `softPwmWrite(15,50)` command, the LED will be HIGH with 50%
    brightness for 1 second. After this, we are again turning the LED LOW for 1 second.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，使用`softPwmWrite(15,50)`命令，LED将以50%的亮度保持高电平1秒。之后，我们再次将LED设置为低电平1秒。
- en: Finally, with the `softPwmWrite(15 , 100)` function code, the LED will be HIGH
    with 100% brightness for 1 second. Next, we again turn the led OFF for 1 second.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用`softPwmWrite(15 , 100)`函数代码，LED将以100%的亮度保持高电平1秒。接下来，我们再次将LED关闭1秒。
- en: After writing the code, you can click on the compile button to compile the code
    and after that, hit the build button to test the code.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写代码后，您可以单击编译按钮来编译代码，然后点击构建按钮来测试代码。
- en: This is how we control the brightness of an LED using the softPWM library.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何使用softPWM库来控制LED亮度的方法。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations—you have successfully written your first C++ program and run
    it on your Raspberry Pi! In this chapter, we first installed the `wiringPi` library
    and understood the wiringPi pin connections for the Raspberry Pi. Next, we wrote
    a simple C++ program to blink an led. After that, we understood the working of
    the LDR sensor module and turned the LED on/off depending on the input from the
    LDR sensor module. After this, we understood PWM and used the softPWM library
    to write a program to vary the brightness of the led.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您成功地编写了您的第一个C++程序并在树莓派上运行！在本章中，我们首先安装了`wiringPi`库，并了解了树莓派的wiringPi引脚连接。接下来，我们编写了一个简单的C++程序来让LED闪烁。之后，我们了解了LDR传感器模块的工作原理，并根据LDR传感器模块的输入打开/关闭LED。之后，我们了解了PWM，并使用softPWM库编写了一个程序来改变LED的亮度。
- en: In the next chapter, we will look at the different parts that are required to
    create a car robot. Next, we will understand the workings of DC motors and motor
    drivers, and learn how to create a car robot. After this, we will write a C++
    program to move the robot in different directions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看创建汽车机器人所需的不同部件。接下来，我们将了解直流电机和电机驱动器的工作原理，并学习如何创建汽车机器人。之后，我们将编写一个C++程序来控制机器人朝不同方向移动。
- en: Questions
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How many ground pins are there on the Raspberry Pi?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 树莓派上有多少个接地针脚？
- en: In a dark environment, is the resistance of the LDR sensor HIGH or LOW?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在黑暗环境中，LDR传感器的电阻是高还是低？
- en: What command is used for reading values from a sensor?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于从传感器读取值的命令是什么？
- en: What is the for loop command to make the LED blink six times?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使LED闪烁六次的for循环命令是什么？
- en: What will be the output voltage at a duty cycle at 20%, assuming the maximum
    voltage is 5V?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设最大电压为5V，占空比为20%时的输出电压是多少？
