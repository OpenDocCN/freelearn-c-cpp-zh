- en: AI and Steering Behaviors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI和转向行为
- en: The game we have been writing is loosely based on the computer game *Spacewar!*
    If you are not familiar with *Spacewar!*, it was the first computer game ever
    written. It originally ran on a PDP-1 owned by MIT and was written by an MIT student
    named Steve Russel, in 1962\. Back then, just getting a computer to display graphical
    output was difficult enough. *Spacewar!*, as well as many other early game systems
    such as *Pong*, were designed to be played by more than one person. That was because
    programming a computer to behave like a human was a very difficult thing. That
    is still somewhat true today, although more processing power and data allows modern
    **Artificial Intelligence** (**AI**) algorithms to behave much more intelligently
    than they have in the past.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在编写的游戏 loosly 基于计算机游戏*Spacewar!* 如果你不熟悉*Spacewar!*，它是有史以来第一款计算机游戏。它最初在麻省理工学院拥有的PDP-1上运行，并由麻省理工学院的一名名叫史蒂夫·拉塞尔的学生于1962年编写。那时，让计算机显示图形输出已经足够困难了。*Spacewar!*以及许多其他早期游戏系统，如*Pong*，都是设计供多人玩的。那是因为编程让计算机像人一样行为是非常困难的。尽管现代**人工智能**（**AI**）算法比过去更智能，但这在某种程度上仍然是真的。
- en: Because our game is a single-player web game, we do not have the benefit of
    using a second human intelligence to power our enemy spaceship. Before this chapter,
    we used an AI stub to allow our enemy spaceship to move and shoot randomly around
    our gameplay area. That might have worked for us up to this point, but now we
    want our player to feel threatened by the enemy ship. It should be intelligent
    enough to fight and kill our player in one-on-one combat.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的游戏是单人玩家网络游戏，我们无法利用第二个人类智能来驱动我们的敌人飞船。在本章之前，我们使用了一个AI存根，允许我们的敌人飞船在游戏区域内随机移动和射击。这在这一点上可能对我们有用，但现在我们希望我们的玩家感到受到敌人飞船的威胁。它应该足够聪明，可以在一对一的战斗中与我们的玩家战斗和杀死他。
- en: 'You will need to include several images in your build to make this project
    work. Make sure you include the `/Chapter10/sprites/` folder from the project''s
    GitHub. If you haven''t yet downloaded the GitHub project, you can get it online
    at: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在构建中包含几个图像才能使此项目工作。确保您从项目的GitHub中包含`/Chapter10/sprites/`文件夹。如果您还没有下载GitHub项目，您可以在网上获取它：[https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)。
- en: 'In this chapter, we will be doing the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Introducing the concept of AI and Game AI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入AI和游戏AI的概念
- en: Adding obstacles to the game for avoidance AI (and increasing the canvas size)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避开AI（并增加画布大小），在游戏中添加障碍物
- en: Adding new collision detection for a line of sight
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为视线引入新的碰撞检测
- en: Introducing the concept of a **Finite State Machine** (**FSM**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入**有限状态机**（**FSM**）的概念
- en: Introducing the concept of **autonomous agents**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入**自主代理**的概念
- en: Introducing the concept of **steering behaviors**
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入**转向行为**的概念
- en: Adding force fields to our game
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将力场添加到我们的游戏中
- en: Using FSMs and steering behaviors to create an AI
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FSM和转向行为创建AI
- en: Tuning our AI to allow the enemy spaceship to navigate obstacles
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整我们的AI以允许敌人飞船避开障碍物
- en: What is Game AI?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是游戏AI？
- en: Many early video games avoided AI because it was a very challenging problem
    with the hardware available at the time. For example, *Space Invaders*, *Galaga*,
    and *Galaxian* all had aliens that moved in specific non-intelligent patterns.
    Early Atari games were either two-player games (*Pong*) or had the player interact
    with a non-intelligent environment (*Breakout*). One early and successful attempt
    at a game with AI was *PAC-MAN*. Each ghost in *PAC-MAN* had a different personality
    and would behave a little differently in the same circumstances. *PAC-MAN* also
    used a simple **Finite State Machine** (**FSM**). That is a type of AI where the
    AI behaves differently under different environmental circumstances. If the player
    ate a *power pellet* in *PAC-MAN*, the ghosts would all turn blue and suddenly
    become edible in a *hunter-becomes-the-hunted* reversal of fortune. While the
    ghosts could be eaten, it would have been easier for the programmers to have those
    ghosts continue to hunt down *PAC-MAN*, as they did before. That would make the
    ghosts look either stupid or suicidal, which is the kind of behavior we would
    like to avoid when writing an AI.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 许多早期的视频游戏避免了AI，因为当时的硬件条件下这是一个非常具有挑战性的问题。例如，*Space Invaders*，*Galaga*和*Galaxian*都有以特定非智能模式移动的外星人。早期的Atari游戏要么是双人游戏（*Pong*），要么是玩家与非智能环境互动（*Breakout*）。早期成功尝试具有AI的游戏之一是*PAC-MAN*。*PAC-MAN*中的每个幽灵都有不同的个性，并且在相同的情况下会有不同的行为。*PAC-MAN*还使用了简单的**有限状态机**（**FSM**）。这是一种AI类型，在不同的环境情况下AI会有不同的行为。如果玩家在*PAC-MAN*中吃了一个*能量豆*，幽灵们会变成蓝色，并突然变得可以被吃掉，这是一种*猎人成为猎物*的命运逆转。虽然幽灵可以被吃掉，但对程序员来说让这些幽灵继续追捕*PAC-MAN*可能更容易。这会让幽灵看起来要么愚蠢要么自杀，这是我们在编写AI时想要避免的行为。
- en: In 1950, the mathematical and computer genius Alan Turing proposed a benchmark
    for AI that he called "the imitation game," but it would later become known as
    *the Turing test*. He proposed a game having human players interacting with humans
    and computers through a text-based interface. If a computer could convince a human
    that they were interacting with another human and not a computer, that computer
    should be considered to be intelligent. Personally, I feel as if we passed this
    threshold a long time ago. But when machines threaten human intelligence, humans
    like to move the goal posts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在1950年，数学和计算机天才艾伦·图灵提出了一个他称之为“模仿游戏”的AI基准，但后来它被称为*图灵测试*。他提出了一个游戏，让人类玩家通过基于文本的界面与人类和计算机互动。如果计算机能够说服人类他们正在与另一个人而不是计算机互动，那么该计算机应被认为是智能的。就我个人而言，我觉得我们很久以前就通过了这个门槛。但是当机器威胁到人类智能时，人类喜欢改变目标。
- en: In 1964, Joseph Weizenbaum of MIT wrote a chatbot named ELIZA. ELIZA pretended
    to be a psychotherapist at the other end of a chat system. ELIZA managed to fool
    quite a few people into believing it was a real psychotherapist, which is probably
    as much a commentary on psychotherapy as it is on human intelligence. Anyone looking
    for a chatbot would easily be able to tell ELIZA was not human, but Joesph Weizenbaum
    was quite disturbed by the number of people willing to pour their heart out to
    ELIZA as if she were a real person.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 1964年，麻省理工学院的约瑟夫·魏岑鲍姆编写了一个名为ELIZA的聊天机器人。ELIZA假装是聊天系统另一端的心理医生。ELIZA成功地愚弄了不少人，让他们相信她是一个真正的心理医生，这可能既是对心理治疗的评论，也是对人类智慧的评论。任何寻找聊天机器人的人都很容易就能发现ELIZA不是人类，但约瑟夫·魏岑鲍姆对愿意向ELIZA倾诉心事的人数感到非常不安。
- en: The Loebner prize is an annual Turing test competition, where a series of judges
    who are AI experts have yet to be fooled by a chatbot. Today, many programs routinely
    fool people into thinking they are humans. I would argue that needing a human
    expert to determine whether an AI has passed the Turing test is moving the goalposts
    significantly from where Alan Turing initially set them. I believe if we had a
    large sample of non-experts that were fooled by a chatbot, we should consider
    that chatbot to be intelligent, but I digress.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Loebner奖是一项年度图灵测试竞赛，一系列的AI专家评委至今还没有被聊天机器人愚弄。如今，许多程序经常愚弄人们，让他们认为自己是人类。我认为，需要一个人类专家来确定一个AI是否通过了图灵测试，这已经明显地改变了艾伦·图灵最初设定的目标。我相信，如果我们有一个被聊天机器人愚弄的非专家大样本，我们应该认为那个聊天机器人是智能的，但我岔开了话题。
- en: My point in bringing up the Turing test is that a Game AI needs to pass a modified
    form of the Turing test. When you write a Game AI, your goal is to convince the
    player that they are not playing a game against a total loser. All Game AIs are,
    more or less, lame. For the time being, we will not be able to create a Game AI
    version of IBM's Watson (the AI that defeated Ken Jennings in Jeopardy). Like
    everything in a computer game, we need to learn to work within the constraints
    of the system. And for a web-based game, those constraints may be significant.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 提到图灵测试的目的是，游戏人工智能需要通过修改后的图灵测试。当你编写游戏人工智能时，你的目标是说服玩家，让他们相信他们不是在与一个彻底失败的游戏对手对战。所有的游戏人工智能都或多或少地很差劲。目前，我们将无法创建IBM的沃森（在《危险边缘》中击败肯·詹宁斯的人工智能）的游戏人工智能版本。就像电脑游戏中的一切，我们需要学会在系统的限制内工作。对于基于网络的游戏来说，这些限制可能是相当重要的。
- en: 'Remember, it is OK to cheat, but don''t get caught. Many Game AIs cheat. An
    RTS may be able to see through the fog of war. An AI poker player may be able
    to peak at the player''s cards. One way we are going to cheat is to allow our
    enemy spaceship to accelerate in directions that are not allowed for the player.
    The key to cheating with a Game AI is to make sure that the behavior or movement
    does not look unnatural. Many years ago, I wrote an online version of the card
    game Spades, playable at [https://www.icardgames.com/spades.html](https://www.icardgames.com/spades.html).
    The player''s partner AI is allowed to peak at everyone''s cards. One common complaint
    I get is that the player''s partner will frequently trump the player''s high card.
    That is because the AI is looking not at who is currently winning the trick, but
    whether the player that will follow him can win the trick if he does not play
    a higher card than the one the player lead with. Not realizing this behavior is
    helping them, I get many frustrated complaints from players about the partner
    trumping their card. This is an example of a case where the player is actually
    doing better because of the AI but leaves with the impression that the AI is making
    stupid choices. My point is, Game AI is all about impression. Remember what the
    AI host said in the HBO television show *Westworld*, when one of the characters
    asked her if she was real: "If you can''t tell, does it really matter?"'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，作弊是可以的，但不要被抓住。许多游戏人工智能都作弊。实时战略游戏可能能够看穿战争迷雾。AI扑克玩家可能能够偷看玩家的牌。我们要作弊的一种方式是允许我们的敌方太空飞船在玩家不允许的方向加速。作弊的关键是确保行为或移动看起来不是不自然的。许多年前，我写了一个在线版本的纸牌游戏Spades，可以在[https://www.icardgames.com/spades.html](https://www.icardgames.com/spades.html)上玩。玩家的伙伴人工智能被允许偷看每个人的牌。我经常收到的一个常见抱怨是，玩家的伙伴经常会打出玩家的高牌。这是因为AI不是看谁当前赢得了这一轮，而是看他后面的玩家是否能赢得这一轮，如果他不打出比玩家出的更高的牌。由于玩家没有意识到这种行为对他们有帮助，我经常收到玩家对伙伴打出高牌的沮丧抱怨。这是一个例子，玩家实际上因为AI的行为而表现更好，但却留下了AI在做愚蠢选择的印象。我的观点是，游戏人工智能都是关于印象的。记住HBO电视剧《西部世界》中AI主持人说的话，当其中一个角色问她是否真实时：“如果你分辨不出来，那真的重要吗？”
- en: Autonomous agents versus top-down AI
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自主代理与自上而下的人工智能
- en: In 1986, Craig Reynolds created a well-regarded AI program called *Boids* (a
    combination of bird and droids). This program created a fascinating bird-like
    flocking behavior, where little triangles moved around the screen in ways that
    remind the observer of flocking birds or fish. When the environment had obstacles,
    the boids broke up to steer around the obstacles and rejoin later. A collision
    between two flocks will usually end up in the flocks joining up and moving on.
    The Boids algorithm is an implementation of autonomous agents for AI. Each individual
    boid makes decisions based on a few simple rules and its immediate environment.
    That results in what is called **emergent behavior**, which is behavior that looks
    as if it was designed from the top down, but is not. The irony is that a top-down-implemented
    AI frequently looks less intelligent than allowing the individual agents to make
    their own decisions. It's a little like the old Soviet top-down command-and-control
    economy, versus a capitalist economy where individuals make decisions based on
    their immediate environment. In games, as in economics, you can also have a mixed
    system, where a top-down AI can send messages to autonomous agents giving them
    new goals or instructions. In the game we are writing, we have a single enemy
    spaceship, so the decision to manage AI from the top down or through autonomous
    agents does not really matter much, but because you may choose to expand the game
    in the future to support multiple enemies and their AIs, our agent will manage
    itself autonomously.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 1986年，Craig Reynolds创建了一个备受推崇的AI程序，名为“Boids”（鸟和机器人的组合）。这个程序创建了一种迷人的鸟群行为，小三角形在屏幕上移动，让观察者想起鸟群或鱼群的行为。当环境中有障碍时，boids会分开以绕过障碍物，然后重新聚集。两个群体之间的碰撞通常会导致它们合并并继续前进。Boids算法是AI的自主代理的实现。每个个体boid都根据一些简单的规则和其周围的环境做出决策。这导致了所谓的“新兴行为”，这种行为看起来好像是自上而下设计的，但实际上不是。讽刺的是，一个自上而下实施的AI经常看起来比让个体代理根据自己的环境做出决策要不那么智能。这有点像旧的苏联自上而下的指挥和控制经济，与个体根据其周围环境做出决策的资本主义经济相比。在游戏中，就像在经济学中一样，你也可以有一个混合系统，其中自上而下的AI可以向自主代理发送消息，给它们新的目标或指令。在我们编写的游戏中，我们有一个单独的敌人飞船，所以从自上而下管理AI还是通过自主代理管理并不重要，但因为你可能选择在将来扩展游戏以支持多个敌人及其AI，我们的代理将自主管理自己。
- en: What is an FSM?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是有限状态机？
- en: FSMs are very common in games. As I mentioned before, PAC-MAN was an early game
    that had an AI with more than one state. The ghosts could be in a *hunt* or a
    *flee* state based on a global condition flipped when PAC-MAN would eat a large
    dot on the screen, commonly known as a **power pellet**. A specific state in an
    FSM can be either a global condition or, in the case of a **finite** **state automaton**,
    could be a state that is specific to any *autonomous agent* within the game. Managing
    behaviors or state transitions could be as simple as using a switch statement,
    or they could be more complicated systems that load and unload AI modules when
    different states are triggered. A state may choose when a transition to a different
    state occurs, or state transitions could be managed by the game from the top down.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有限状态机在游戏中非常常见。正如我之前提到的，PAC-MAN是一个早期的游戏，其中的AI具有多个状态。鬼魂可以处于“追逐”或“逃跑”状态，这取决于PAC-MAN在屏幕上吃掉一个大点时全局条件的改变，这通常被称为“能量豆”。有限状态机中的特定状态可以是全局条件，或者在有限状态自动机的情况下，可以是游戏中的任何“自主代理”特定的状态。管理行为或状态转换可以简单地使用开关语句，也可以是更复杂的系统，当不同状态被触发时加载和卸载AI模块。一个状态可能会选择何时发生到不同状态的转换，或者状态转换可以由游戏自上而下地管理。
- en: 'The FSM we will be writing for this game will be very basic. It will be a simple
    switch that will perform different behaviors based on the current state. The enemy
    ship''s position relative to the player and whether there is an unobstructed line
    of sight between them will be used to determine the transitions between states.
    Our FSM will have four basic states:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个游戏编写的有限状态机非常基础。它将是一个简单的开关，根据当前状态执行不同的行为。敌船相对于玩家的位置以及它们之间是否有无障碍的视线将用于确定状态之间的转换。我们的有限状态机将有四种基本状态：
- en: '`WANDER`'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 漫游
- en: '`APPROACH`'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接近
- en: '`ATTACK`'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 攻击
- en: '`FLEE`'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逃跑
- en: 'The conditions for entering these states are as follows: If the enemy ship
    does not have an unobstructed path to the player ship, it enters a `WANDER` state
    where it wanders around the gameplay area checking periodically for a line of
    sight path to the player. Once there is a line-of-sight path to the player, the
    enemy ship will enter an `APPROACH` state, where it will attempt to get close
    enough to the player ship to attack it. Once the player is close enough, it enters
    the `ATTACK` state, where it fires on the player ship. If the player ship gets
    too close to the enemy ship, the enemy will `FLEE`, attempting to increase the
    distance between itself and the player ship.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 进入这些状态的条件如下：如果敌船没有到玩家船的无障碍路径，它将进入“漫游”状态，在游戏区域四处漫游，定期检查到玩家的视线路径。一旦有了到玩家的视线路径，敌船将进入“接近”状态，试图靠近玩家船以进行攻击。一旦玩家靠近，它进入“攻击”状态，向玩家船开火。如果玩家船离敌船太近，敌人将“逃跑”，试图增加与玩家船之间的距离。
- en: Introducing steering behaviors
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入转向行为
- en: Steering behaviors are a force-based approach to navigation toward, or away
    from, specific points while avoiding obstacles. It was originally discussed in
    a presentation by Craig Reynolds (the *Boids* guy) at the **Game Developer's Conference**
    (**GDC**) in 1999, and the original paper discussing steering behaviors can be
    found online at [https://www.red3d.com/cwr/steer/gdc99/](https://www.red3d.com/cwr/steer/gdc99/).
    Unlike pathfinding algorithms such as the A* or Dijkstra's algorithms, steering
    behaviors are tactical in nature. They involve a goal position and forces drawing
    the autonomous agent toward its goal, while simultaneously pushing the agent away
    from obstacles you would like it to avoid. In the case of our game, the enemy
    spaceship is our autonomous agent that will be using the steering behaviors. It
    will be in pursuit of the player spaceship while avoiding obstacles including
    asteroids, projectiles, and the star in the center of the gameplay area. We will
    be discussing several steering behaviors in detail in the next few sections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 转向行为是一种基于力的导航方法，用于朝向或远离特定点，同时避开障碍物。它最初是在1999年的**游戏开发者大会**（**GDC**）上由Craig Reynolds（*Boids*的创造者）在一次演讲中讨论的，关于转向行为的原始论文可以在网上找到[https://www.red3d.com/cwr/steer/gdc99/](https://www.red3d.com/cwr/steer/gdc99/)。与A*或Dijkstra算法等寻路算法不同，转向行为是战术性的。它涉及一个目标位置和力，将自主代理引向其目标，同时将代理推开您希望它避开的障碍物。在我们的游戏中，敌人的飞船是我们将使用转向行为的自主代理。它将追逐玩家的飞船，同时避开包括小行星、抛射物和游戏区域中心的星星在内的障碍物。在接下来的几节中，我们将详细讨论几种转向行为。
- en: The seek behavior
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找行为
- en: 'The **seek steering behavior** is a force that points the agent (the enemy
    ship) at the desired target and moves the agent in the direction of that target.
    This behavior attempts to hit a maximum velocity and reach its target in the minimum
    amount of time. The seek behavior assumes that the position it is seeking is static
    and is not subject to change over time. This diagram shows what the seek behavior
    looks like:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻找转向行为**是一个力，指向期望的目标，并使代理朝着该目标的方向移动。这种行为试图以最大速度到达目标，并在最短时间内到达目标。寻找行为假设它正在寻找的位置是静态的，并且随时间不会改变。这张图表展示了寻找行为的外观：'
- en: '![](img/be373985-1267-43f6-841e-9c1153c9ed8e.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be373985-1267-43f6-841e-9c1153c9ed8e.png)'
- en: The seek behavior
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找行为
- en: The flee behavior
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逃避行为
- en: '**Flee** is a steering behavior that is the opposite of seek behavior. This
    behavior takes a position or game object and attempts to get as far away from
    it as possible.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 逃避是一种与寻找行为相反的转向行为。这种行为会接受一个位置或游戏对象，并试图尽可能远离它。
- en: 'Fleeing is the behavior you demonstrate when chased by a bear. Your only goal
    is to put as much distance between you and the current location of that bear as
    you can. So, the next time a bear chases you, stop for a moment and think, "*Wow,
    my brain is currently implementing a version of the autonomous agent steering
    behavior known as* flee." Or you could keep running. The choice is yours. Take
    a look at the next diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 逃避是被熊追赶时所表现的行为。你的唯一目标是尽可能远离你和熊当前位置之间的距离。所以下次被熊追赶时，停下来想一想，“哇，我的大脑目前正在实施一种名为逃避的自主代理转向行为。”或者你可以继续奔跑。选择权在你手中。看一下下一个图表：
- en: '![](img/9d89bc0a-4783-4973-bc39-b34168a6135a.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d89bc0a-4783-4973-bc39-b34168a6135a.png)'
- en: An artist's rendering of a bear eating the reader
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一位艺术家描绘了一只熊正在吃读者
- en: 'You can program the flee behavior by negating the direction of the seek behavior.
    In other words, if the seek behavior produces a direction vector force of 1,1,
    the flee steering behavior would produce a direction vector force of -1,-1\. This
    diagram depicts flee behavior:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过否定寻找行为的方向来编程逃避行为。换句话说，如果寻找行为产生一个方向向量力为1,1，逃避转向行为将产生一个方向向量力为-1,-1。这张图表描述了逃避行为：
- en: '![](img/95bd7792-7a2a-4e73-933c-633246625c9a.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95bd7792-7a2a-4e73-933c-633246625c9a.png)'
- en: The flee behavior
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 逃避行为
- en: The arrival behavior
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 到达行为
- en: 'The problem with the seek steering behavior is that it won''t be satisfied
    until the agent reaches its target position. The other problem is that because
    it tries to reach that position at maximum speed, it will almost always overshoot
    it, resulting in oscillation around the desired destination. The **arrival steering
    behavior** allows the seek behavior to end gracefully by beginning to decelerate
    when it is in an **arrival range** of the target. As long as the target destination
    is within the desired range, the arrival behavior will reduce movement toward
    the seek position. The following diagram depicts the arrival behavior:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找转向行为的问题在于，直到代理达到目标位置，它都不会满意。另一个问题是，因为它试图以最大速度到达该位置，它几乎总是会超过目标位置，导致在期望目的地周围振荡。到达转向行为允许寻找行为在到达目标的**到达范围**时开始减速，从而优雅地结束。只要目标位置在期望范围内，到达行为就会减少朝向寻找位置的移动。以下图表描述了到达行为：
- en: '![](img/9d63484e-dbbf-4987-bf91-7a9593292d5d.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d63484e-dbbf-4987-bf91-7a9593292d5d.png)'
- en: The arrival behavior
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到达行为
- en: The pursuit behavior
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追逐行为
- en: We build the **pursuit behavior** on top of the seek behavior. Where the seek
    behavior is looking to reach a static point, the pursuit behavior assumes that
    the target is moving. Because our agent (the enemy ship) wishes to track down
    and destroy the player, which is usually moving, we will be using the pursuit
    steering behavior. The pursuit behavior looks at the velocity of the target. Instead
    of heading directly for the target's current position, it attempts to locate an
    intercept point where it predicts the target will be. Seek reminds me a little
    of a children's soccer team. All the kids run to where the ball is, not where
    the ball will be. Because of this, everyone on the soccer field runs as one large
    unit up and down the field. Someday, they will grow up and incorporate the pursuit
    steering behavior into their soccer strategy.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在寻找行为的基础上构建了追逐行为。寻找行为试图到达一个静态点，而追逐行为假设目标在移动。因为我们的代理（敌船）希望追踪并摧毁通常在移动的玩家，我们将使用追逐转向行为。追逐行为查看目标的速度。它不是直接朝着目标的当前位置前进，而是试图找到一个拦截点，预测目标将在那里。寻找行为让我想起了一个儿童足球队。所有孩子都跑到球所在的地方，而不是球将要到达的地方。因此，足球场上的每个人都像一个大团体一样上下奔跑。总有一天，他们会长大，并将追逐转向行为纳入他们的足球战略中。
- en: 'The next diagram depicts the pursuit behavior:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图表描述了追逐行为：
- en: '![](img/8f81489f-b09c-4751-8fec-6a85da83f056.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f81489f-b09c-4751-8fec-6a85da83f056.png)'
- en: The pursuit behavior
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 追逐行为
- en: The evade behavior
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逃避行为
- en: '**Evade** is to *pursuit* as *flee* is to *seek*. Like pursuit, the **evade
    steering behavior** is attempting to determine where the obstacle you are avoiding
    will be, and moves as far away from that point as possible. In other words, it
    takes the same point we found in the pursuit behavior and then runs away from
    that point. The next diagram depicts the evade behavior:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 逃避就像追逐一样，逃避转向行为试图确定你要避免的障碍物将在哪里，并尽可能远离那个点。换句话说，它采用了我们在追逐行为中找到的相同点，然后远离那个点。下一个图表描述了逃避行为：
- en: '![](img/5951f12c-2eef-48be-a168-5863dad8d48c.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5951f12c-2eef-48be-a168-5863dad8d48c.png)'
- en: The evade behavior
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 逃避行为
- en: Obstacle avoidance
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避障
- en: '**Obstacle avoidance** differs from the flee and evade behaviors in that an
    obstacle may potentially be in the path of our agent as it attempts to seek out
    a new location. Flee and evade cause us to try to move as far away as possible
    from the location of the object or the position we are fleeing, whereas obstacle
    avoidance is more about avoiding a collision with an obstacle on the way to a
    target. In the case of our game, obstacles to be avoided include asteroids, projectiles,
    and the star in the center of the game screen. Obstacle avoidance usually involves
    only seeking to avoid the most threatening (nearest) obstacle. Our agent has a
    given lookahead distance that looks in the direction it is moving. If a line between
    its current position and the maximum lookahead in the direction it is moving collides
    with an object, obstacle avoidance requires we adjust our direction. The area
    we avoid should be larger than the collision detection area for the obstacle to
    give us a buffer to avoid, especially because the asteroids and projectiles are
    moving in the game.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 避障与逃避行为和逃避行为不同，因为障碍物可能潜在地阻碍我们的代理在寻找新位置时。逃避和逃避会导致我们试图尽可能远离对象的位置或我们正在逃离的位置，而避障更多地是关于避免与前往目标途中的障碍物碰撞。在我们的游戏中，需要避免的障碍物包括小行星、抛射物和游戏屏幕中心的星星。避障通常只涉及寻找避免最具威胁（最近）的障碍物。我们的代理有一个给定的前瞻距离，它朝着移动的方向查看。如果当前位置和移动方向上的最大前瞻之间的线与对象发生碰撞，避障要求我们调整我们的方向。我们避免的区域应该比障碍物的碰撞检测区域大，以给我们一个避免的缓冲区，特别是因为小行星和抛射物在游戏中是移动的。
- en: 'The next diagram depicts obstacle avoidance:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图表描述了避障：
- en: '![](img/558939ad-5d41-4b33-8c37-29b4547e82c9.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/558939ad-5d41-4b33-8c37-29b4547e82c9.png)'
- en: Obstacle avoidance
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 避障
- en: The wander behavior
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漫游行为
- en: '**Wander** is a state in which the agent is moving somewhat randomly around
    the game screen. Causing the direction of the enemy spaceship to rotate every
    frame randomly would result in very erratic behavior. Instead, there should be
    a random number of milliseconds (200-2,000) where the spaceship maintains its
    current direction. When the ship has gone the random number of milliseconds, it
    should randomly choose to turn left or turn right, but should have a biased chance
    of turning in the same direction it did the previous time, with that bias decreasing
    each time it chooses the same direction after the initial choice. That will give
    the wandering behavior a little more consistency and appear a little less jittery.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 漫游是一种状态，在这种状态下，代理在游戏屏幕周围有些随机移动。导致敌方飞船的方向每一帧都随机旋转会导致非常不稳定的行为。相反，应该有一个随机的毫秒数（200-2,000），在这段时间内飞船保持当前方向。当飞船经过随机的毫秒数后，它应该随机选择向左转或向右转，但应该有一个偏向于选择上次相同方向的概率，每次在初始选择后选择相同方向的偏向概率会减少。这将使漫游行为具有更多的一致性，看起来不那么抖动。
- en: 'See how the wander behavior chooses a point at random and moves toward it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 看看漫游行为如何随机选择一个点并朝着它移动：
- en: '![](img/93567b37-73f1-48e3-ade1-8b5e61fdb426.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93567b37-73f1-48e3-ade1-8b5e61fdb426.png)'
- en: Demonstrating the wander behavior
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 演示漫游行为
- en: Combining forces
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并力量
- en: Our earlier discussion of the reader using the flee behavior to escape a bear
    was oversimplified. It assumes you are fleeing that bear in a large open field.
    If you are running from a bear in the woods, you will both need to avoid running
    into the trees and get yourself as far away from that bear as you can. You have
    to blend these two activities seamlessly, or get eaten by that bear. If we want
    the enemy ship to pursue or flee from the player ship, and avoid obstacles at
    the same time, we are going to need to combine steering forces. The highest priority
    always has to be avoiding obstacles. If you run into a tree while fleeing that
    bear, he's still going to end up eating you. The general strategy our steering
    behavior will implement is finding a line-of-sight vector with the player ship.
    There are several opportunities we have to find a line of sight, because of the
    way our game level wraps around on itself. If that line of sight is longer than
    a chosen distance, we will wander until our distance is short enough that we can
    pursue the player while shooting at him. While we are wandering, we will want
    to combine any wandering force with forces that help the enemy ship avoid hitting
    asteroids or the star. Once we are in pursuit, we will want to continue to avoid
    obstacles. There will be a large arrival area where our ship will slow to a stop
    and fire in the direction of the player. Once the player closes in a specific
    range, our ship will flee.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的读者使用逃避行为逃离熊的情况过于简化了。它假设你在一个大片开阔的地方逃离那只熊。如果你在树林里逃离熊，你需要避免撞到树，并尽可能远离那只熊。你必须无缝地融合这两种活动，否则会被那只熊吃掉。如果我们希望敌舰追逐或逃离玩家舰船，并同时避开障碍物，我们将需要结合转向力。最高优先级始终是避开障碍物。如果你在逃离那只熊时撞到了树，他最终还是会吃掉你。我们的转向行为将实现的一般策略是找到与玩家舰船的视线向量。由于我们的游戏级别在自身上环绕，我们有几次机会找到视线。如果那条视线比选择的距离长，我们将徘徊，直到我们的距离足够短，可以追逐玩家并向他射击。在我们徘徊时，我们将希望将任何徘徊力与帮助敌舰避免撞到小行星或恒星的力结合起来。一旦我们开始追逐，我们将希望继续避开障碍物。将有一个大的到达区域，我们的舰船将减速并朝着玩家方向开火。一旦玩家接近特定范围，我们的舰船将逃离。
- en: Modifying game.hpp
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改game.hpp
- en: 'Before we get too far into our new code, I want to make some quick changes
    to the `game.hpp` file to add some functionality we will be using later in this
    chapter. The first thing I want to add near the top of the `game.hpp` file is
    a few macros that will let us quickly convert from an angle in degrees to radians,
    and also from radians to degrees. I find myself doing this a lot when using SDL
    because SDL, for some reason, wants rotations in degrees, and every other library
    out there uses radians. So, let''s go ahead and add the following two lines of
    code somewhere near the top of the `game.hpp` file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入新的代码之前，我想快速对`game.hpp`文件进行一些更改，以添加我们将在本章后面使用的一些功能。我想在`game.hpp`文件的顶部附近添加一些宏，让我们能够快速将角度从度转换为弧度，以及从弧度转换为度。我在使用SDL时经常这样做，因为SDL出于某种原因希望以度为单位旋转，而其他所有库都使用弧度。因此，让我们在`game.hpp`文件的顶部附近的某个地方添加以下两行代码：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will be changing the size of our canvas from 320 x 200 to 800 x 600\. To
    make this easy to switch later, let''s go ahead and define a few macros we will
    use for the canvas width and height and put those somewhere near the top of the
    `game.hpp` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把画布的大小从320 x 200改为800 x 600。为了以后更容易切换，让我们先定义一些宏，用于画布的宽度和高度，并将其放在`game.hpp`文件的顶部附近的某个地方：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `rand()` function, used in C and C++ to get a random number, can only be
    used to return an integer. I will be adding a function to get a random number
    that falls between minimum and maximum floating-point values, so I will need to
    add an external reference to that function to our `game.hpp` file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`rand()`函数，用于在C和C++中获取随机数，只能用于返回整数。我将添加一个函数来获取落在最小和最大浮点值之间的随机数，因此我需要在我们的`game.hpp`文件中添加对该函数的外部引用：'
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We are also starting to need circular references in our classes. The `FiniteStateMachine`
    class will need a reference to the `EnemyShip` class, and the `EnemyShip` class
    will need a reference to the `FiniteStateMachine` class. Unfortunately, we need
    to define one of these classes before the other. In the past, we have been able
    to define our classes in a specific order to avoid this problem, but now we will
    need a group of class declarations before any of our class definitions. That will
    allow the compiler to know that a class will be defined before the definition.
    Add this block of class declarations somewhere near the top of the `game.hpp`
    file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类也开始需要循环引用。`FiniteStateMachine`类将需要引用`EnemyShip`类，而`EnemyShip`类将需要引用`FiniteStateMachine`类。不幸的是，我们需要先定义其中一个类。过去，我们可以按特定顺序定义类以避免这个问题，但现在我们需要在任何类定义之前添加一组类声明。这将允许编译器知道类将在定义之前被定义。在`game.hpp`文件的顶部附近添加这个类声明块：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will add an enumeration to keep track of our FSM states. As I mentioned
    earlier, there are four states in our FSM: `APPROACH`, `ATTACK`, `FLEE`, and `WANDER`.
    We will define these states in an enumeration called `FSM_STATE`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个枚举来跟踪我们的FSM状态。正如我之前提到的，我们的FSM有四个状态：`APPROACH`，`ATTACK`，`FLEE`和`WANDER`。我们将在一个名为`FSM_STATE`的枚举中定义这些状态：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: One of the first classes we defined in `game.hpp` was the `Point` class. This
    class has *x* and *y* attributes and a few useful functions such as `Rotate`.
    We are going to need to greatly expand the use of this class and what it can do.
    So much so, that calling it *point* is no longer accurate. I would prefer to call
    this class *vector*, because we will be using it for vector mathematics from now
    on. The only problem I have with this name is that it might be confusing because
    we are using the `std::vector` to handle array-like data in our code. Because
    of this, I have decided we will call this class `Vector2D`. We will be greatly
    expanding the functionality of this class to include a function that will normalize
    the vector (that is, change its magnitude to 1). We need two functions that will
    determine the magnitude and the square magnitude of the vector. We will need a
    function that will project the vector on to another vector (to help us in the
    line-of-sight collision detection). We will need to be able to find the dot product
    of two vectors. We will also need to be able to find the rotation of a given vector.
    In addition to these new functions, we will overload operators on our vectors
    to allow us to add vectors, subtract vectors, and multiply and divide vectors
    by a scalar value.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`game.hpp`中定义的第一个类之一是`Point`类。这个类有*x*和*y*属性，以及一些有用的函数，比如`Rotate`。我们需要大大扩展这个类的用途和功能。因此，称其为*point*已不再准确。我更愿意将这个类称为*vector*，因为我们将从现在开始使用它进行向量数学运算。我对这个名称唯一的问题是，它可能会让人困惑，因为我们在代码中使用`std::vector`来处理类似数组的数据。因此，我决定我们将把这个类称为`Vector2D`。我们将大大扩展这个类的功能，包括一个将向量归一化（即将其大小改为1）的函数。我们需要两个函数来确定向量的大小和平方大小。我们需要一个函数来将向量投影到另一个向量上（以帮助我们进行视线碰撞检测）。我们需要能够找到两个向量的点积。我们还需要能够找到给定向量的旋转。除了这些新函数，我们还将重载我们的向量运算符，以便我们可以相加向量、相减向量，并用标量值相乘和相除向量。
- en: 'Go ahead and delete the `Point` class definition, and replace that code with
    the new `Vector2D` class definition:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 继续删除`Point`类定义，并用新的`Vector2D`类定义替换该代码：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our new collision detection will also need a `Range` class. A range represents
    a range of values between a minimum and a maximum. We can add two ranges together.
    We can find the overlap between the two ranges. We can extend a range by a given
    scalar value, or we can clamp a value to fall inside a given range. Here is what
    the new `Range` class definition looks like:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新碰撞检测还需要一个`Range`类。范围表示最小值和最大值之间的一系列值。我们可以将两个范围相加。我们可以找到两个范围之间的重叠部分。我们可以通过给定的标量值扩展一个范围，或者将一个值夹在给定范围内。以下是新的`Range`类定义的样子：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you scroll down to the `Collider` class, we will be adding a few new functions
    and a few new attributes. I want to use our `Collider` class to support new steering
    behaviors. So, we will need some steering-specific attributes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向下滚动到`Collider`类，我们将添加一些新函数和一些新属性。我想使用我们的`Collider`类来支持新的转向行为。因此，我们需要一些特定于转向的属性：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`m_SteeringRadius` is a new attribute that is a multiple of `m_Radius`. For
    steering purposes, we want to make sure that the sizes of the objects we want
    to avoid is smaller than the object''s collision area. That creates an additional
    margin for our steering behavior that will help us to avoid these objects. The
    `m_SteeringRadiusSQ` attribute is the square of the steering radius. That will
    keep us from having to square the steering radius for collision checks over and
    over again.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_SteeringRadius`是一个新属性，是`m_Radius`的倍数。为了转向目的，我们希望确保我们想要避免的对象的大小小于对象的碰撞区域。这为我们的转向行为创建了额外的边距，这将帮助我们避开这些对象。`m_SteeringRadiusSQ`属性是转向半径的平方。这将使我们不必一遍又一遍地对转向半径进行碰撞检查。'
- en: 'We will also need to add the declarations of the following functions:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加以下函数的声明：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `SteeringLineTest` and `SteeringRecTest` functions will differ from a real
    line and rectangle collision test. The steering rectangle test (`SterringRectTest`)
    will be used to limit the number of objects we must test for object avoidance
    purposes. We only want our AI to worry about objects that are within a box around
    the enemy ship that is 200 x 200 pixels. That will be useful if we have a large
    number of objects to test. To keep this test fast, we will be checking against
    the objects in that box as if they are points and will not take the object's radius
    into account. The `SteeringLineTest` function will be testing to see whether the
    steering radius of this collider hits a line defined by two points in the test.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`SteeringLineTest`和`SteeringRecTest`函数将与真实的线和矩形碰撞测试不同。转向矩形测试（`SterringRectTest`）将用于限制我们必须测试以进行对象避让的对象数量。我们只希望我们的AI担心在敌舰周围的一个200
    x 200像素的框内的对象。如果我们有大量对象要测试，这将非常有用。为了使这个测试快速，我们将检查该框内的对象，就好像它们是点，并且不考虑对象的半径。`SteeringLineTest`函数将测试这个碰撞体的转向半径是否击中了测试中由两个点定义的线。'
- en: 'In our game, we have not added a hit point system. A single collision with
    an asteroid or projectile results in instant death. That makes the game really
    short. To increase the game time, we will be adding shields to our ship. These
    shields will cause the player or enemy to be invulnerable for as long as the shields
    are active. While you use the shields, they will slowly turn from green to red,
    and at some point, they will stop working. That will all depend on the amount
    of time that you have used the shields during the given game to encourage the
    player to use the shields only when needed. Here is what the `Shield` class definition
    will look like:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们还没有添加命中点系统。与小行星或抛射物的单次碰撞会导致即时死亡。这使得游戏变得非常短暂。为了增加游戏时间，我们将为我们的飞船添加护盾。这些护盾将使玩家或敌人在护盾激活期间无敌。在使用护盾时，它们将从绿色慢慢变成红色，并且在某个时刻它们将停止工作。这将取决于您在给定游戏中使用护盾的时间长度，以鼓励玩家仅在需要时使用护盾。以下是`Shield`类定义的样子：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After the `Shield` class definition, we will need to add a class definition
    for our `Asteroid` class. Unlike the Atari game *Asteroids*, we cannot destroy
    these asteroids by shooting them. They are meant to be obstacles, but we will
    (for the moment) allow the asteroids to be destroyed if the player crashes into
    them with their shields active. They will move slowly around the game screen and
    provide obstacles for the player and the enemy AI to navigate during gameplay.
    Here is the code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Shield`类定义之后，我们需要为我们的`Asteroid`类添加一个类定义。与Atari游戏*Asteroids*不同，我们不能通过射击来摧毁这些小行星。它们被设计为障碍物，但我们（暂时）允许玩家在他们的护盾激活时撞毁小行星。它们将在游戏屏幕周围缓慢移动，并为玩家和敌方AI在游戏过程中提供障碍。以下是代码：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will also be adding a big star to the center of the gameplay area. That
    is similar to the black hole that was in the center of the game *Spacewar!*, which
    we are loosely basing our game on. This star will eventually provide gravitational
    attraction to make the game a bit more challenging. We will be animating a star
    image and adding some solar flares using particle emitters:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在游戏区域中心添加一个大星星。这类似于游戏*Spacewar!*中心的黑洞，我们的游戏是基于它的。这颗星星最终将提供引力吸引力，使游戏变得更具挑战性。我们将通过粒子发射器对星星图像进行动画处理，并添加一些太阳耀斑：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we can make a few modifications to our `Ship` class. Here is what it will
    look like once we finish:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以对我们的`Ship`类进行一些修改。完成后，它将如下所示：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first thing we will do is add the `m_Shield` attribute, which is a pointer
    to a `Shield` object:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是添加`m_Shield`属性，这是一个指向`Shield`对象的指针：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After that, we use separate variables for the *x* direction and *y* direction,
    as well as different variables for the *x* velocity and *y* velocity, like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用不同的变量来表示*x*方向和*y*方向，以及不同的变量来表示*x*速度和*y*速度，就像这样：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s remove all of that code and swap it for some `Vector2D` objects, representing
    the direction vector and the velocity vector, like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除所有这些代码，并用一些`Vector2D`对象来替换，表示方向向量和速度向量，就像这样：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, to prevent code duplication between our enemy ship and our player
    ship, we will add a `Shoot()` function that will fire a projectile from the ship:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了防止我们的敌舰和玩家舰之间的代码重复，我们将添加一个`Shoot()`函数，从舰船发射抛射物：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next class we need to modify is our `EnemyShip` class. We need to add a
    string with the filename of our `Shield` sprite. We also need to remove our old
    `AIStub()` function and replace it with a pointer to our FSM. Here is what the
    new version of the `EnemyShip` class looks like:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改的下一个类是我们的`EnemyShip`类。我们需要添加一个包含我们`Shield`精灵文件名的字符串。我们还需要删除旧的`AIStub()`函数，并用指向我们FSM的指针替换它。以下是`EnemyShip`类的新版本：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A significant new class we will be adding is the `FiniteStateMachine` class.
    This class will be doing all of the AI''s heavy lifting. Here is the class definition
    that you must add to `game.hpp`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加的一个重要新类是`FiniteStateMachine`类。这个类将承担所有AI的繁重工作。以下是你必须添加到`game.hpp`的类定义：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At the top of this class definition are nine constants:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类定义的顶部有九个常量：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first two constants, `c_AttackDistSq` and `c_FleeDistSq`, are the values
    used by the FSM to determine whether it will change states into either the `ATTACK`
    or `FLEE` states; `c_MinRandomTurnMS` and `c_RandTurnMS` are both constants used
    by the `WANDER` state to determine when the AI will next decide to change directions
    randomly. The `c_ShieldDist` constant is the distance at which an obstacle will
    cause the AI to turn on its shields. The `c_AvoidDist` constant gives us the range
    at which an AI makes corrective adjustments to avoid an object. The `c_StarAvoidDistSQ`
    function is the distance at which the AI will make course adjustments to avoid
    the star in the center of the play area. The `c_ObstacleAvoidForce` constant is
    a steering force added to the velocity of an object to help it avoid obstacles,
    and `c_StarAvoidForce` is a similar force used to avoid the star.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个常量`c_AttackDistSq`和`c_FleeDistSq`是FSM用来确定它是否会转换为`ATTACK`或`FLEE`状态的值；`c_MinRandomTurnMS`和`c_RandTurnMS`都是`WANDER`状态使用的常量，用于确定AI何时决定下一次随机改变方向。`c_ShieldDist`常量是障碍物会导致AI打开护盾的距离。`c_AvoidDist`常量给出了AI进行校正调整以避免对象的范围。`c_StarAvoidDistSQ`函数是AI将进行航向调整以避免游戏区域中心的星星的距离。`c_ObstacleAvoidForce`常量是添加到对象速度的转向力，以帮助它避开障碍物，`c_StarAvoidForce`是用于避开星星的类似力。
- en: 'After the constants, we have a block of attributes that are used by the FSM
    to make state-based decisions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在常量之后，我们有一块由FSM用于基于状态做出决策的属性：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `m_CurrentState` attribute holds the current state of our FSM. The `m_Ship`
    attribute contains a pointer to the ship. Right now, this is always the single
    enemy ship that is in our game, but in the future, you may want to add multiple
    enemy ships. The `m_HasLOS` attribute is a `boolean` that keeps track of whether
    our ship currently has an unobstructed line of sight with the player. The `m_LastTurnLeft`
    attribute is a `boolean` that keeps track of the direction, in which the ship
    last turned while in the `WANDER` state. The `m_SameTurnPct` attribute is the
    percentage chance that the ship will continue turning in the same direction while
    in the `WANDER` state. The `m_NextTurnMS` attribute is the number of milliseconds
    a ship in the `WANDER` state will continue before making a directional heading
    change. The `m_CheckCycle` variable is used to break up the AI into performing
    different checks during different frame rendering cycles. If you have your AI
    do all the work between each frame render each time, you could potentially bog
    the system down. It is usually better practice to break the AI into multiple parts
    and only do part of the logic with each frame render. The `m_DesiredRotation`
    attribute is the desired heading of the AI, and, finally, `m_PlayerDistSQ` is
    the squared distance between the enemy ship and the player ship.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: “m_CurrentState”属性保存了我们有限状态机的当前状态。“m_Ship”属性包含了指向飞船的指针。现在，这总是我们游戏中的单个敌人飞船，但在将来，您可能希望添加多个敌人飞船。“m_HasLOS”属性是一个布尔值，用于跟踪我们的飞船当前是否与玩家有无阻挡的视线。“m_LastTurnLeft”属性是一个布尔值，用于跟踪飞船在“WANDER”状态下上次转向的方向。“m_SameTurnPct”属性是飞船在“WANDER”状态下继续向同一方向转向的百分比几率。“m_NextTurnMS”属性是飞船在“WANDER”状态下继续进行方向改变之前的毫秒数。“m_CheckCycle”变量用于在不同的帧渲染周期中分解AI以执行不同的检查。如果您让AI在每次帧渲染之间做所有工作，可能会使系统陷入困境。通常最好将AI分解为多个部分，并且每次帧渲染只执行部分逻辑。“m_DesiredRotation”属性是AI的期望航向，最后，“m_PlayerDistSQ”是敌人飞船和玩家飞船之间的平方距离。
- en: 'We need to modify the `Projectile` class to use a `Vector2D` to keep track
    of the velocity instead of two floating-point variables, `m_VX` and `m_VY`. Here
    is the new version of the `Projectile` class after the modifications:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改“Projectile”类，使用“Vector2D”来跟踪速度，而不是两个浮点变量“m_VX”和“m_VY”。这是修改后的“Projectile”类的新版本：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At the end of the `game.hpp` file, we should add a few external references
    to our new list of asteroids, and the star that will be going in the center of
    the gameplay area:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在“game.hpp”文件的末尾，我们应该添加一些新的小行星列表和将要放在游戏区域中心的星星的外部引用：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that we have taken care of the modifications we need to make to our `game.hpp`
    file, let's get into the obstacles we are adding.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了对“game.hpp”文件的修改，让我们开始添加我们正在添加的障碍物。
- en: Adding obstacles to our game
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的游戏中添加障碍物
- en: 'Right now, we do not have anything in our game for an AI to steer around. We
    need to add some obstacles that can get in the way of our enemy ship. We want
    our enemy ship to do what it can to avoid these obstacles while attempting to
    approach and attack our player''s spaceship. The first thing we will add is a
    big star right in the middle of our gameplay area. We can animate this star and
    add some nice particle effects for the star''s corona. In the last section, we
    created the class definition of this star in the `game.hpp` file and it looked
    like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的游戏中还没有任何AI可以操纵。我们需要添加一些障碍物，可以妨碍我们的敌人飞船。我们希望我们的敌人飞船尽力避开这些障碍物，同时试图接近并攻击我们玩家的太空船。我们将首先添加的是一个大星星，就在我们游戏区域的中间。我们可以为这颗星星制作动画，并为它的日冕添加一些漂亮的粒子效果。在上一节中，我们在“game.hpp”文件中创建了这颗星星的类定义，它看起来像这样：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will need to create a new file called `star.cpp` to accompany this class
    definition. In it, we should define our constructor and the `Move` and `Render`
    functions. As with all of our CPP files, the first thing we do is include the
    `game.hpp` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为“star.cpp”的新文件来配合这个类定义。在其中，我们应该定义我们的构造函数和“Move”和“Render”函数。与我们所有的CPP文件一样，我们首先包含“game.hpp”文件：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that, we have a few `#define` directives that we use to define the sprite
    files we will be using to render our star and the flare particle systems:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有一些“#define”指令，用于定义我们将用来渲染星星和耀斑粒子系统的精灵文件：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The constructor is fairly long, but a lot of it should look pretty familiar:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数相当长，但其中很多部分应该看起来很熟悉：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This constructor starts by inheriting the `Collider` constructor passing it
    a radius of `32`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数首先通过继承“Collider”构造函数传递一个半径为“32”：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It then creates a sprite texture to use when rendering the star. This part
    of the code should look pretty familiar:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个精灵纹理，用于渲染星星。这部分代码应该看起来很熟悉：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After setting up the sprite texture, the constructor sets some of the attributes,
    including radius and position:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好精灵纹理后，构造函数设置了一些属性，包括半径和位置：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, it adds emitters to the `m_FlareList` vector. These will be some solar
    flare particle systems. I used the particle system configuration tool to come
    up with the values we are creating in these emitters. You can play with the values
    if you like, but I felt that these values created a nice-looking flare effect:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它向“m_FlareList”向量添加了发射器。这些将是一些太阳耀斑粒子系统。我使用了粒子系统配置工具来得出我们正在创建的值。您可以根据需要调整这些值，但我觉得这些值创造了一个漂亮的耀斑效果：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The star''s `Move` function is pretty simple. It cycles through the eight frames
    of the star''s animation sequence:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 星星的“Move”函数非常简单。它循环遍历星星动画序列的八个帧：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The star''s `Render` function is a little bit more complicated because it needs
    to loop over the flare emitters, and move them before it renders the star''s sprite
    texture:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 星星的“Render”函数稍微复杂一些，因为它需要循环遍历耀斑发射器，并在渲染星星精灵纹理之前移动它们：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we need to define the `asteroid.cpp` file. That will hold the function
    definitions for our `Asteroid` class. Here is our class definition for `Asteroid`
    in the `games.hpp` file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义`asteroid.cpp`文件。这将保存我们`Asteroid`类的函数定义。以下是`games.hpp`文件中`Asteroid`类的定义：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Inside our `asteroid.cpp` file, we will need to define the `Asteroid` constructor,
    the `Move` function, the `Render` function, and the `Explode` function. At the
    top of the `asteroid.cpp` file, we will need to `#include` the `game.hpp` file
    and define the location of our asteroid sprite file in the virtual filesystem.
    Here are what those first few lines of code look like:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`asteroid.cpp`文件中，我们需要定义`Asteroid`构造函数、`Move`函数、`Render`函数和`Explode`函数。在`asteroid.cpp`文件的顶部，我们需要`#include`
    `game.hpp`文件，并在虚拟文件系统中定义我们的小行星精灵文件的位置。以下是这些代码的前几行的样子：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first function we will define is our constructor. Here is the constructor
    function in its entirety:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义的第一个函数是我们的构造函数。以下是构造函数的完整函数：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The definition of the constructor calls the parent constructor in the `Collider`
    class, passing in a radius for the `Collider` of `8.0`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的定义调用了`Collider`类中的父构造函数，传入了`Collider`的半径为`8.0`：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After that, the constructor loads and initializes the sprite texture using
    SDL, a process we should all be pretty familiar with by now:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，构造函数使用SDL加载和初始化精灵纹理，这是一个我们现在应该都非常熟悉的过程：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then define our explosion emitter. This emitter will be activated if our
    asteroid is destroyed:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了我们的爆炸发射器。如果我们的小行星被摧毁，这个发射器将被激活：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After that, we create a second emitter that will shoot out little chunks of
    rock when our asteroid is destroyed. That is meant to compliment the `m_Explosion`
    emitter, and it will run at the same time as the asteroid explodes:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建了第二个发射器，当我们的小行星被摧毁时会发射一些小块石头。这是为了补充`m_Explosion`发射器，并且它将在小行星爆炸时同时运行：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The last several lines set the starting values for our asteroid''s attributes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几行设置了我们小行星属性的起始值：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The next function we will be defining is the `Move` function. Here is what
    it looks like:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要定义的下一个函数是`Move`函数。以下是它的样子：
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The first batch of code dealing with `m_NextFrameTime` and `m_CurrentFrame`
    simply alternates between the sprite frames based on the amount of time that has
    passed:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`m_NextFrameTime`和`m_CurrentFrame`的第一批代码只是根据经过的时间量交替切换精灵帧：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'After that, we update the position based on the time delta and current velocity:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们根据时间增量和当前速度更新位置：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Finally, the `WrapPosition` function is called. This function moves our asteroid
    back to the right side of the screen if it went off the screen to the left, and
    moves it to the top if it goes off the bottom. Whenever an asteroid moves off
    the screen in a given direction, its position will be wrapped around to the other
    side of the gameplay area.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`WrapPosition`函数。这个函数会将我们的小行星移到屏幕的右侧，如果它偏离了屏幕的左侧，并且如果它偏离了底部，它会移到顶部。每当一个小行星朝着特定方向移出屏幕时，它的位置将被包裹到游戏区域的另一侧。
- en: 'After the `Move` function, we define the `Asteroid Render` function. The complete
    function is shown here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Move`函数之后，我们定义了`Asteroid Render`函数。完整的函数如下所示：'
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The first two lines move the explosion emitter and the chunks emitter. If the
    asteroid has not been destroyed, these functions will not do anything. If the
    asteroid has been destroyed, the functions will run the particle emitter. These
    emitters do not loop, so when their emission time is up, they will stop:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行移动了爆炸发射器和碎片发射器。如果小行星还没有被摧毁，这些函数将不会执行任何操作。如果小行星已经被摧毁，这些函数将运行粒子发射器。这些发射器不会循环，所以当它们的发射时间结束时，它们将停止：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After that, we check to see whether the asteroid is alive, and if it is not,
    we exit this function. The reason we do this after moving our emitters is that
    we must continue to run the emitter after an asteroid is destroyed:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们检查小行星是否存活，如果不是，我们退出这个函数。我们在移动我们的发射器之后执行这个操作的原因是，我们必须在小行星被摧毁后继续运行发射器：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The final thing we do in this function is to render our asteroid sprite texture,
    a process that should look pretty familiar by now:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们做的最后一件事是渲染我们的小行星精灵纹理，这个过程现在应该看起来非常熟悉：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The last function in our `asteroid.cpp` file is the `Explode` function. This
    function will run when an asteroid is destroyed. The function will run our two
    emitters, which were designed to create an explosion effect. It will also set
    the asteroid''s alive flag to `false`. Here is the code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`asteroid.cpp`文件中的最后一个函数是`Explode`函数。这个函数将在小行星被摧毁时运行。该函数将运行我们设计的两个发射器，以创建爆炸效果。它还会将小行星的存活标志设置为`false`。以下是代码：
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now that we have defined our game obstacles, let's look into what it will take
    to create some shields for our spaceships.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的游戏障碍，让我们来看看为我们的太空飞船创建一些护盾需要做些什么。
- en: Adding force fields
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加力场
- en: 'Currently, in our game, our spaceships are destroyed with a single collision.
    This ends up creating a game that is over very quickly. It would be nice to have
    a force field to prevent the ship''s destruction when a collision is about to
    occur. This will also give our AI something else it can do in its bag of tricks.
    When the shields are up, there will be a little force-field animation surrounding
    the spaceship that is using it. There is a time limit to shield use. That will
    prevent the player or the AI from keeping the shield up for the entire game. While
    the shield is active, the color of the shields will transition from green to red.
    The closer the color gets to red, the closer the shields are to running out of
    power. Every time the shields get hit, the player or AI''s shields will have additional
    time taken off them. We have already created the class definition inside of the
    `game.hpp` file. Here is what it looks like:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在我们的游戏中，我们的飞船在一次碰撞中被摧毁。这最终导致游戏很快就结束了。当即将发生碰撞时，希望有一个力场来防止飞船的破坏。这也会给我们的人工智能一些其他可以做的事情。当护盾启用时，使用它的飞船周围将有一个小的力场动画。护盾使用有时间限制。这将防止玩家或人工智能在整个游戏中保持护盾。当护盾激活时，护盾的颜色将从绿色过渡到红色。颜色越接近红色，护盾的能量就越接近耗尽。每次护盾受到打击时，玩家或人工智能的护盾都会减少额外的时间。我们已经在`game.hpp`文件中创建了类定义。它看起来像这样：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To accompany this class definition, we will need a `shield.cpp` file, where
    we can define all of the functions used by this class. The first function we will
    define inside our `shield.cpp` file is the `Shield` constructor function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配合这个类定义，我们需要一个`shield.cpp`文件，在这里我们可以定义这个类使用的所有函数。我们将在`shield.cpp`文件中定义的第一个函数是`Shield`构造函数：
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `Shield` constructor function will call the `Collider` constructor function,
    with a radius of `12.0`. That is a larger radius than the ship''s radius. We will
    want this `Collider` to be hit instead of the ship, if the shields are active.
    The first block of code in this constructor function sets the starting values
    for the attributes of this class:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shield`构造函数将调用`Collider`构造函数，半径为`12.0`。这是比飞船半径更大的半径。如果护盾激活，我们希望击中这个`Collider`而不是飞船。在这个构造函数中的第一个代码块设置了这个类属性的起始值：'
- en: '[PRE51]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Notice that we set `m_ttl` to `25500`. That is the time you can use the shield
    in milliseconds. That amounts to 25.5 seconds. I wanted it to be a multiple of
    255, so that the green color will transition from 255 to 0, based on the time
    left.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`m_ttl`设置为`25500`。这是你可以在毫秒内使用护盾的时间。这相当于25.5秒。我希望它是255的倍数，这样绿色就会根据剩余时间从255过渡到0。
- en: 'Conversely, the red color will transition from 0 to 255, also based on the
    time left. After that, we create the shield''s sprite texture in the standard
    way:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，红色将根据剩余时间从0过渡到255。之后，我们以标准方式创建护盾的精灵纹理：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After the constructor, we need to define our `Move` function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数之后，我们需要定义我们的`Move`函数：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If the shield is not active, this function does not do anything. If it is active,
    the `m_ttl` parameter is decremented based on the number of milliseconds passed
    since the last frame. Then, we increment the current frame if the proper number
    of milliseconds has elapsed. If the shield's time left drops below 0, the shields
    are deactivated.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果护盾未激活，此函数将不执行任何操作。如果激活了，根据自上一帧以来经过的毫秒数，将减少`m_ttl`参数。然后，如果已经过了适当数量的毫秒，我们会增加当前帧。如果护盾的剩余时间低于0，护盾将被停用。
- en: 'After we have defined our `Move` function, we will define our `Render` function:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义了`Move`函数之后，我们将定义我们的`Render`函数：
- en: '[PRE54]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Like the `Move` function, the `Render` function does not do anything if the
    active flag is false. We calculate the colors based on the time left using the
    following formulas:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Move`函数一样，如果激活标志为false，`Render`函数将不执行任何操作。我们使用以下公式根据剩余时间计算颜色：
- en: '[PRE55]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'That will smoothly transition the color of our shields from green to red. We
    use a call to `SDL_SetTextureColorMod` to set the sprite texture''s color:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将平滑地将我们的护盾颜色从绿色过渡到红色。我们使用`SDL_SetTextureColorMod`来设置精灵纹理的颜色：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Everything else in the `Shield::Render` function is pretty standard and should
    look very familiar by now.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shield::Render`函数中的其他内容都很标准，现在应该看起来非常熟悉。'
- en: More collision detection
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多碰撞检测
- en: 'Let''s take a look at the modifications we need to make to our `Collider` class.
    As we discussed earlier, our AI will be implementing steering behaviors. These
    steering behaviors will require some new attributes and functions in our `Collider`
    class. Here is what the new `Collider` class is going to look like:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们需要对`Collider`类进行的修改。正如我们之前讨论的，我们的人工智能将实现转向行为。这些转向行为将需要在我们的`Collider`类中添加一些新的属性和函数。新的`Collider`类将如下所示：
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We have three new functions, two of them are for steering. One of the functions,
    `WrapPosition()`, will be used to wrap objects moving off the screen in one direction
    so that they reappear on the other side of the game screen. Let''s open up `collider.cpp`
    and take a look. The first thing we need to change is the constructor function.
    Here is what the new version of the constructor looks like:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个新函数，其中两个是用于转向的。其中一个函数`WrapPosition()`将用于将移出屏幕的对象包裹到游戏屏幕的另一侧。让我们打开`collider.cpp`来看一看。我们需要改变的第一件事是构造函数。新版本的构造函数如下所示：
- en: '[PRE58]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The last two lines are the only modifications. You will notice that we set the
    `m_SteeringRadius` attribute to `1.5` times the `m_Radius` value. This additional
    buffer space is to prevent our enemy ship from getting too close to the asteroids,
    especially if they are moving. This factor effectively makes the steering behavior
    more wary of collisions with asteroids. The multiple of `1.5` was chosen somewhat
    arbitrarily because it worked well when I tested it. If you would like your AI
    to be less concerned with asteroid collisions and more likely to pursue the player
    by putting itself in danger, you could reduce this value, maybe to something like
    `1.1`. You could also increase this value to make the AI even more wary of asteroids.
    Setting the value too high will result in an AI that is too timid. Setting it
    too low will have it pursue the player under almost any circumstance, mimicking
    the infamous words of Admiral David Farragut during the Battle of Mobile Bay,
    "*Damn the torpedoes—full speed ahead!*"
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行是唯一的修改。您会注意到我们将`m_SteeringRadius`属性设置为`1.5`倍的`m_Radius`值。这个额外的缓冲空间是为了防止我们的敌舰过于靠近小行星，特别是如果它们在移动。这个因素有效地使得转向行为更加警惕地避免与小行星的碰撞。`1.5`的倍数是相当任意地选择的，因为在我测试时效果很好。如果您希望您的AI对小行星碰撞不太关心，更有可能追逐玩家并置自己于危险之中，您可以减小这个值，也许到`1.1`之类的值。您也可以增加这个值，使AI更加警惕小行星。将值设置得太高将导致AI过于胆小。将它设置得太低将使它在几乎任何情况下都追逐玩家，仿佛是战斗的著名话语：“*该死的鱼雷——全速前进！*”
- en: 'Next, we will need to add the new function, `SteeringLineText`, to `collider.cpp`.
    This new function will do circle-line collision detection between a line connecting
    our enemy ship and our player, and detect all of the asteroids and projectiles
    our ship could hit along that path. It is a line-of-sight test to determine whether
    there is a clear path to the player from our position. Circle-line collision detection
    is somewhat complicated, compared to circle-circle or rectangle-rectangle collision
    detection. I borrowed heavily from a solution I created on [embed.com](https://www.embed.com)
    at the following address: [https://www.embed.com/typescript-games/multiple-type-collision-detection.html](https://www.embed.com/typescript-games/multiple-type-collision-detection.html).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将新函数`SteeringLineText`添加到`collider.cpp`中。这个新函数将在我们的敌舰和玩家之间连接的线之间进行圆线碰撞检测，并检测我们的飞船沿着这条路径可能撞到的所有小行星和抛射物。这是一种视线测试，用于确定从我们的位置到玩家是否有一条清晰的路径。与圆圆或矩形矩形碰撞检测相比，圆线碰撞检测有点复杂。我在[embed.com](https://www.embed.com)上创建的解决方案中大量借鉴了以下地址：[https://www.embed.com/typescript-games/multiple-type-collision-detection.html](https://www.embed.com/typescript-games/multiple-type-collision-detection.html)。
- en: Circle-line collision detection
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 圆线碰撞检测
- en: 'The first step in determining whether a circle and line collide is the simplest:
    Check whether either of the endpoints of your line falls within the circle''s
    radius. That is done by a simple distance check using the Pythagorean theorem.
    If the distance between one of the points and the center of our circle is less
    than the radius, the line is inside the circle. Here is a diagram of a point falling
    inside the radius of the circle:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 确定圆和线是否相撞的第一步是最简单的：检查线的任一端点是否落在圆的半径内。这是通过使用毕达哥拉斯定理进行简单的距离检查来完成的。如果一个点与我们的圆的中心之间的距离小于半径，那么线就在圆内。这是一个点落在圆的半径内的图示：
- en: '![](img/c99d9002-ff23-456d-b5ab-d208f912ad0e.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c99d9002-ff23-456d-b5ab-d208f912ad0e.png)'
- en: The line's p2 point falls inside the circle radius
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 线的p2点落在圆的半径内
- en: If either point falls within the radius of the circle, we know that the line
    and the circle collide. If neither point falls within the radius of the circle,
    we are not done. Then what we will need to do is find the closest point on the
    line to the center of the circle. Let me digress for a moment to get a little
    more technical. Technically, all lines are infinite. When we have two points and
    draw a “line” in between those points, it is a line segment. To find the closest
    point between a line and our circle, we are going to need to talk about something
    called **vector projection**.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任一点落在圆的半径内，我们知道线和圆相撞。如果没有点落在圆的半径内，我们还没有完成。然后我们需要做的是找到线上距离圆心最近的点。让我稍微偏离一下，来更加技术化。从技术上讲，所有的线都是无限的。当我们有两个点并在这些点之间画一条“线”时，它是一条线段。要找到线和我们的圆之间的最近点，我们需要谈论一些叫做**向量投影**的东西。
- en: Vector projection
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量投影
- en: Vector projection is a little bit complicated. If you project a given vector
    b on to vector *a*, you get a scalar multiple of vector *a* (we will call this
    scalar multiple *c*), where you can add a vector perpendicular to vector *ca*
    to get vector *b*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 向量投影有点复杂。如果你将给定的向量b投影到向量*a*上，你会得到向量*a*的标量倍数（我们将称这个标量倍数为*c*），你可以添加一个垂直于向量*ca*的向量来得到向量*b*。
- en: 'The following diagram is an example of projecting vector *b* onto vector *a*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示是将向量*b*投影到向量*a*的示例：
- en: '![](img/adfb214e-e771-4370-9e06-b044e38c8569.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/adfb214e-e771-4370-9e06-b044e38c8569.png)'
- en: An example of projecting vector b onto vector a
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将向量b投影到向量a的示例
- en: 'Another way to look at this is that a projection of vector b on to vector a
    gives us the closest point to the end point of vector b that is on a line segment,
    as defined by any scalar multiple of vector a. You may be wondering what this
    has to do with detecting a collision between a circle and a line. Well, if we
    assume that vector b represents the position of the center point of our circle,
    we can figure out what the closest point on our line is to the center point of
    that circle. We then test for a collision between the point we found with our
    projection and the center of the circle. See how vector projection can be used
    to determine the closest point on a line to a circle in the following diagram:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待这个问题的方式是，向量b在向量a上的投影给出了距离向量b的终点最近的点，该点位于由向量a的任意标量倍数定义的线段上。也许你会想知道这与检测圆和直线之间的碰撞有什么关系。如果我们假设向量b表示我们圆的中心点的位置，我们就可以找出我们直线上离圆的中心点最近的点。然后我们测试我们的投影找到的点与圆的中心之间是否发生碰撞。看看向量投影如何用于确定下图中直线上距离圆最近的点：
- en: '![](img/8f4d3c2b-0da5-4bb8-8dcc-486984f5aca3.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f4d3c2b-0da5-4bb8-8dcc-486984f5aca3.png)'
- en: Notice that projecting the vector onto our line gives us the closest point on
    the line to the circle
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将向量投影到我们的线上会给我们圆上最接近的点
- en: 'There is another potential problem you have to look at. The projection onto
    vector a might give you a value for c (the scalar multiple) that is greater than
    1\. If this is the case, it might be that our line collides with the circle beyond
    our ending point. Because of this, we will also need to do some range checks to
    see whether we are past the end of our line:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要考虑另一个潜在的问题。对向量a的投影可能会给你一个大于1的c值（标量倍数）。如果是这种情况，可能是我们的线段与圆发生了碰撞，超出了我们的结束点。因此，我们还需要进行一些范围检查，以查看我们是否超出了线段的末端：
- en: '![](img/ee892c81-12aa-41a8-b496-7c1cc2cf8132.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee892c81-12aa-41a8-b496-7c1cc2cf8132.png)'
- en: Projecting the circle's vector on to our line gives us the closest point that
    is passed the range of our line segment
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 将圆的向量投影到我们的线上会给我们超出线段范围的最接近点
- en: 'Now that I have explained what vector projection is, let''s take a look at
    the code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经解释了向量投影是什么，让我们来看看代码：
- en: '[PRE59]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As we discussed earlier, the first thing we do is test the start and end point
    distance to the location of this `Collider` object. If the distance squared is
    less than the steering radius squared for either of the points, we know that the
    line collides with our steering radius:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，我们首先要做的是测试起点和终点到这个`Collider`对象位置的距离。如果距离的平方小于任一点的转向半径的平方，我们就知道该线段与我们的转向半径发生了碰撞：
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If neither point falls inside the circle, we will need to test against the
    projection. We will need to turn the line segment into a vector that goes through
    the origin. To do this, we will need to subtract the starting point from the ending
    point, and we will also need to adjust the position of the circle by the same
    amount:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个点都不在圆内，我们将需要对投影进行测试。我们需要将线段转换为通过原点的向量。为此，我们需要从结束点减去起始点，并且我们还需要调整圆的位置相同的量：
- en: '[PRE61]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We need to make sure that the point closest to the collider is still on the
    line segment. That can be done with a simple range test against the starting and
    ending *x* and *y* values. If both the *x* and *y* coordinates fall into our range,
    we know that the point must lie somewhere on the line segment. If it does not,
    we know that the line does not collide with the circle:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保距离碰撞器最近的点仍然在线段上。这可以通过对起始和结束的*x*和*y*值进行简单的范围测试来完成。如果*x*和*y*坐标都在我们的范围内，我们就知道该点必须位于线段上。如果不是，我们就知道该线段与圆不相交：
- en: '[PRE62]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If we have not returned with a `false` value at this point, we know what the
    nearest point to the collider is on our line segment. Now we can test the distance
    from that point to our collider to see whether it is close enough to collide with
    our steering radius; if it is, we return `true`, and if it is not, we return `false`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们此时还没有返回`false`值，我们就知道碰撞器最近的点在我们的线段上。现在我们可以测试从该点到我们的碰撞器的距离，以查看它是否足够接近与我们的转向半径发生碰撞；如果是，我们返回`true`，如果不是，我们返回`false`：
- en: '[PRE63]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The Vector2D class
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vector2D类
- en: 'I mentioned earlier that we needed to scrap our old `Point` class in favor
    of something that has a lot more functionality. The new `Vector2D` class will
    add several new functions to the `Point` class we were using earlier. Let''s take
    another look at the function definition we have inside our `game.hpp` file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到，我们需要放弃旧的`Point`类，转而使用功能更多的东西。新的`Vector2D`类将为我们之前使用的`Point`类添加几个新的函数。让我们再次看看我们在`game.hpp`文件中的函数定义：
- en: '[PRE64]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Unlike points, vectors have a magnitude. Because it is faster to calculate,
    we will also add a squared magnitude, `MagSQ`, function. Vectors can be normalized,
    which means they can be modified to have a magnitude of 1\. We discussed vector
    projection earlier, and we have created a `Project` function to allow us to do
    that. Finding the dot product of two vectors is a very useful operation in games.
    The dot product of two normalized vectors is a scalar value that ranges between
    1 and -1, depending on the angle between those two vectors. The value is 1 if
    the vectors point in the same direction, -1 if they point in the opposite direction,
    and 0 if the two vectors are perpendicular to each other.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与点不同，向量有一个大小。因为计算速度更快，我们还将添加一个平方大小，`MagSQ`函数。向量可以被标准化，这意味着它们可以被修改为大小为1。我们之前讨论过向量投影，并创建了一个`Project`函数来允许我们这样做。找到两个向量的点积在游戏中是一个非常有用的操作。两个标准化向量的点积是一个标量值，取决于这两个向量之间的角度，范围在1到-1之间。如果向量指向相同的方向，则该值为1，如果它们指向相反的方向，则为-1，如果两个向量互相垂直，则为0。
- en: The dot product of two normalized vectors is the same as the cosine of the angle
    between those two normalized vectors. Getting the dot product of any two vectors,
    *a* and *b*, gives you the (magnitude of *a*) * (magnitude of *b*) * cosine (angle
    between *a* and *b*). The reason we normalize these vectors first is to set the
    magnitude of *a* and the magnitude of *b* to 1, which causes our normalized dot
    product to return the cosine of the angle between vectors *a* and *b*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 两个归一化向量的点积等同于这两个归一化向量之间的角度的余弦。得到任意两个向量 *a* 和 *b* 的点积，你会得到（*a* 的大小）*（*b* 的大小）*
    余弦（*a* 和 *b* 之间的角度）。我们首先归一化这些向量的原因是为了将 *a* 和 *b* 的大小设置为 1，这会导致我们的归一化点积返回 *a* 和
    *b* 之间的余弦角度。
- en: We will also add a `FindAngle` function that will tell us the directional angle
    of this function. We will overload many operators to allow for easier vector manipulation.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一个 `FindAngle` 函数，它将告诉我们这个函数的方向角。我们将重载许多运算符，以便更容易地对向量进行操作。
- en: 'Let''s take a look at `vector.cpp` in its entirety:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `vector.cpp` 的全部内容：
- en: '[PRE65]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The first two functions are constructors, and they are essentially the same
    as the constructors that were in the `Point` class:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数是构造函数，它们本质上与 `Point` 类中的构造函数相同：
- en: '[PRE66]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'After that, we have our overloaded operators. That allows us to add, subtract,
    multiply, and divide vectors easily:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们有了我们重载的运算符。这使我们能够轻松地对向量进行加法、减法、乘法和除法：
- en: '[PRE67]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `Rotate` function is one of the few functions that existed on the `Point`
    class. It has not changed from the `Point` class version:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rotate` 函数是 `Point` 类上存在的少数函数之一。它与 `Point` 类版本没有变化：'
- en: '[PRE68]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `Normalize` function changes the magnitude of the vector to a value of
    1\. It does this by determining the magnitude of the vector and dividing the *x*
    and *y* value by that magnitude:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Normalize` 函数将向量的大小更改为 1。它通过确定向量的大小并将 *x* 和 *y* 值除以该大小来实现这一点：'
- en: '[PRE69]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `Project` function uses the dot product of the normalized angles and multiplies
    that scalar value by the vector to determine the new projected vector:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`Project` 函数使用归一化角度的点积，并将标量值乘以向量来确定新的投影向量：'
- en: '[PRE70]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Our `Dot` product function is actually a dot product of the normalized vectors.
    That gives us information on the angle between the two vectors. We are normalizing
    first because we are using this dot product only in our vector projection:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Dot` 乘积函数实际上是归一化向量的点积。这给了我们关于两个向量之间角度的信息。我们首先进行归一化，因为我们只在我们的向量投影中使用这个点积：
- en: '[PRE71]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `FindAngle` function uses the inverse tangent to find the angle in radians
    between two vectors:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindAngle` 函数使用反正切来找到两个向量之间的弧度角度：'
- en: '[PRE72]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The final two functions get the vector''s magnitude and squared magnitude:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个函数获取向量的大小和平方大小：
- en: '[PRE73]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Writing an FSM
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写有限状态机
- en: 'Now that we have the tools we need in our `Collider` and `Vector2D` classes,
    we can build our FSM. The `FiniteStateMachine` class will manage our AI. Our FSM
    will have four states: `SEEK`, `FLEE`, `ATTACK`, and `WANDER`. It will implement
    steering behaviors and add an avoid force whenever it is trying to navigate through
    obstacles such as asteroids. The AI will also need to check whether the enemy
    ship should raise or lower its shields. Let''s take a second look at the definition
    of the `FiniteStateMachine` class as we have defined it in our `game.hpp` file:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在 `Collider` 和 `Vector2D` 类中有了我们需要的工具，我们可以构建我们的 FSM。`FiniteStateMachine`
    类将管理我们的 AI。我们的 FSM 将有四种状态：`SEEK`、`FLEE`、`ATTACK` 和 `WANDER`。它将实现导航行为，并在尝试穿越如小行星等障碍物时添加一个避免力。AI
    还需要检查敌舰是否应该升高或降低护盾。让我们再次看看我们在 `game.hpp` 文件中定义的 `FiniteStateMachine` 类的定义：
- en: '[PRE74]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now let''s spend a little time going through all of the functions that we will
    define in our `finite_state_machine.cpp` file. The constructor function at the
    beginning of this file does not do anything complicated. It does some basic initialization:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们花点时间来浏览我们在 `finite_state_machine.cpp` 文件中定义的所有函数。这个文件开头的构造函数并不复杂。它只做一些基本的初始化：
- en: '[PRE75]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'After the constructor, we have four state functions defined: `SeekState`, `FleeState`,
    `WanderState`, and `AttackState`. The first of these four states causes our enemy
    ship to seek out a specific point in our gameplay area. That point will either
    be calculated in our `Move` function or inside our `AttackState` function. Here
    is what the code looks like:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数之后，我们定义了四个状态函数：`SeekState`、`FleeState`、`WanderState` 和 `AttackState`。这四种状态中的第一种会导致我们的敌舰在游戏区域中寻找特定的点。这一点要么在我们的
    `Move` 函数中计算，要么在我们的 `AttackState` 函数内部计算。代码如下：
- en: '[PRE76]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The first thing the function does is determine what angle the ship should point
    at to seek out the destination point:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第一件事是确定飞船应该指向的角度，以寻找目的地点：
- en: '[PRE77]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Based on the `rotate_direction` value we calculated, the AI makes a decision
    to rotate the ship left or right:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们计算的 `rotate_direction` 值，AI 决定将飞船向左或向右旋转：
- en: '[PRE78]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You may be wondering why there are two calls to `RotateRight()` and `RotateLeft()`.
    Well, that is a bit of AI cheating. I want the enemy spaceship to rotate and accelerate
    faster than the player, so we call the `Rotate` functions twice and the `Accelerate`
    function four times. The amount of cheating you do depends on personal preference,
    and how obvious your cheating is. Generally speaking, you want your AI to be challenging,
    but not too challenging. An AI that is obviously cheating will upset the player.
    Above all, if you cheat, make sure you don't get caught!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么有两次调用 `RotateRight()` 和 `RotateLeft()`。嗯，这有点作弊。我希望敌方飞船的旋转和加速比玩家更快，所以我们调用
    `Rotate` 函数两次，`Accelerate` 函数四次。你作弊的程度取决于个人喜好，以及你的作弊有多明显。一般来说，你希望你的 AI 具有挑战性，但不要太具有挑战性。一个明显作弊的
    AI 会让玩家感到不快。最重要的是，如果你作弊，确保你不被抓到！
- en: 'After the rotations, we end the function with the four calls to `Accelerate()`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转后，我们通过四次调用 `Accelerate()` 函数结束函数。
- en: '[PRE79]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'After our `SEEK` state, we need to define the function we run when we are in
    the `FLEE` state. The `FLEE` state is the opposite of the `SEEK` state in that
    the AI is trying to get as far away from the flee position as possible. We do
    a little less cheating in our version of the `FLEE` state, but this can be changed
    based on personal taste:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`SEEK`状态之后，我们需要定义当我们处于`FLEE`状态时运行的函数。`FLEE`状态是`SEEK`状态的相反，即AI试图尽可能远离逃跑位置。在我们的`FLEE`状态版本中，我们作弊的少一些，但这可以根据个人口味进行更改：
- en: '[PRE80]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `WANDER` state is a state in which the AI wanders around the gameplay area.
    This state runs if the enemy ship does not have an unobstructed line of sight
    to the player ship. The AI will wander around the gameplay area looking for an
    unobstructed path to the player. In the `WANDER` state, the ship is more likely
    to continue turning in the direction it turned the last time than choose a new
    direction. Here is the code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`WANDER`状态是AI在游戏区域中徘徊的状态。如果敌方飞船没有清晰的视线到玩家飞船，就会运行这个状态。AI会在游戏区域中四处徘徊，寻找到玩家的无阻挡路径。在`WANDER`状态下，飞船更有可能继续朝上次转向的方向转向，而不是选择新的方向。以下是代码：'
- en: '[PRE81]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `Attack` state calls the `Seek` state while shooting at the player:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`Attack`状态在向玩家射击时调用`Seek`状态：'
- en: '[PRE82]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To know where to go when we seek and attack, we could point our enemy ship
    directly at the player''s current location. It would be better if we could predict
    where the player''s ship will be by the time we get there. We have a `PredictPosition`
    function that will predict where the player will be, using its current velocity.
    Here is our `PredictPosition` function:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道我们寻找和攻击时要去哪里，我们可以直接将敌方飞船指向玩家当前的位置。如果我们能预测到我们到达那里时玩家飞船的位置会更好。我们有一个`PredictPosition`函数，它将使用玩家当前的速度来预测玩家的位置。以下是我们的`PredictPosition`函数：
- en: '[PRE83]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: That is only a guess, and it is imperfect. We use this function to predict both
    where we will seek and where we will attack. If we were seeking the player, we
    would probably want to predict the distance the player will move, which will be
    about the same as the current distance between the enemy ship and the player ship.
    However, it is more important that we predict where our projectiles will be when
    we fire them. The projectiles move quite a bit faster than our ship, so we divide
    the distance between the enemy ship and the player ship by a factor of 10 to make
    our prediction. The projectiles do not actually move 10 times as fast, but, as
    with many of the constant values we choose for our AI, trial and error and what
    looks right trump actual data. Dropping the multiple to a factor of 5 will double
    the distance we will lead the player ship with each shot. Making the value 20
    would cut that lead in half. A value of 10 is what looked right to me when I was
    testing the AI, but you can tweak this number to your taste. You could even add
    a random factor if you like.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个猜测，而且是不完美的。我们使用这个函数来预测我们将寻找和攻击的位置。如果我们正在寻找玩家，我们可能想要预测玩家将移动的距离，这将与敌方飞船和玩家飞船之间的当前距离大致相同。然而，更重要的是我们预测我们发射抛射物的位置。抛射物的移动速度比我们的飞船快得多，所以我们将敌方飞船和玩家飞船之间的距离除以10来进行预测。抛射物实际上并不是移动10倍快，但是，与我们AI选择的许多常数值一样，试错和外观优于实际数据。将多重值降低到5倍将使我们每次射击领先玩家飞船的距离加倍。将值设为20将使这个领先减半。当我测试AI时，值为10看起来对我来说是正确的，但你可以根据自己的口味调整这个数字。你甚至可以添加一个随机因素。
- en: The AvoidForce function
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AvoidForce函数
- en: 'The `AvoidForce` function is also a bit of a cheat. Steering behaviors use
    an avoid force to prevent autonomous agents from colliding with obstacles. If
    the avoid force value is set too high, it will look as if the enemy ship is magically
    repelled from the obstacles. If it is too low, it will crash right into them.
    Our `AvoidForce` function will look for the closest obstacle to our enemy ship
    and will increase the velocity of the enemy ship to steer it around any obstacles.
    Here is what that function looks like:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`AvoidForce`函数也有点作弊。转向行为使用避免力来防止自主代理与障碍物碰撞。如果避免力值设置得太高，敌方飞船看起来会像是被障碍物神奇地排斥。如果太低，它会直接撞上它们。我们的`AvoidForce`函数将寻找离我们的敌方飞船最近的障碍物，并增加敌方飞船的速度以绕过任何障碍物。以下是该函数的样子：'
- en: '[PRE84]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Our first check in this function is how close we are to the star in the center
    of the gameplay area. This star is the biggest thing we need to avoid. It is the
    only object that will destroy us even if our shields are on, so the AI needs to
    be extra certain it does not hit the star. This check involves finding the squared
    distance between the center of the play area and the enemy spaceship, and checking
    that value against a constant we set in our class definition call, `c_StarAvoidDistSQ`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中的第一个检查是我们离游戏区域中心的星星有多近。这颗星星是我们需要避免的最大的东西。即使我们的护盾打开，它也是唯一会摧毁我们的物体，所以AI需要特别确保它不会撞到星星。这个检查涉及找到游戏区域中心和敌方飞船之间的平方距离，并将该值与我们在类定义调用中设置的常数`c_StarAvoidDistSQ`进行比较：
- en: '[PRE85]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'You can tweak the value of `c_StarAvoidDistSQ` to allow the enemy spaceship
    to get closer to, or stay further away from, the center of the game screen. If
    our enemy ship is not too close to the viewable game area, we look to see whether
    any obstacles are close to the spaceship:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调整`c_StarAvoidDistSQ`的值，以允许敌方飞船靠近或远离游戏屏幕的中心。如果我们的敌方飞船离可视游戏区域不太近，我们会查看飞船附近是否有障碍物：
- en: '[PRE86]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We do a rectangle test against all of the asteroids and projectiles in our
    game. At the beginning of the `if` block, we set up the corners of our rectangle
    test:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对游戏中的所有陨石和抛射物进行矩形测试。在`if`块的开始，我们设置了我们的矩形测试的角落：
- en: '[PRE87]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `c_AvoidDist` constant is set in the `FiniteStateMachine` class definition
    and can be changed based on your taste. Increasing the avoid distance makes the
    AI keep a greater distance from all the projectiles. If you set this value too
    high, your AI will be rather timid. Reduce the distance and the AI will tolerate
    flying much closer to the obstacles. If it''s too low, it will frequently crash
    into them. After determining the values to use for our rectangle test, we loop
    over all of our asteroids, looking for an asteroid that is both active and within
    the bounds of our rectangle test:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`c_AvoidDist`常数在`FiniteStateMachine`类定义中设置，可以根据你的喜好进行更改。增加避让距离会使AI保持与所有抛射物的更大距离。如果设置这个值太高，你的AI会变得相当胆小。减小距离，AI将容忍飞得更接近障碍物。如果太低，它会经常撞上它们。确定了用于我们的矩形测试的值后，我们循环遍历所有的小行星，寻找一个既活跃又在我们的矩形测试范围内的小行星：'
- en: '[PRE88]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'When adding avoid forces, we are only avoiding the closest obstacle. You could
    write a more complicated version of this, capable of adding an avoiding force
    for several objects within our bounding box, but avoiding the closest obstacle
    works reasonably well. After checking all of our asteroids, we check to see whether
    there is a projectile that is active and closer than the closest asteroid:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加避让力时，我们只避免最近的障碍物。你可以编写一个更复杂的版本，能够在我们的边界框内为几个对象添加避让力，但避免最近的障碍物效果还不错。在检查所有的小行星后，我们检查是否有一个抛射物是活跃的并且比最近的小行星更近：
- en: '[PRE89]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If we find at least one object in our bounding box, we want to both rotate
    our spaceship so that it moves to avoid it naturally as the player would, and
    we also add an avoid force, which is a bit of a cheat. The avoid force pushes
    our enemy spaceship away from the object based on a constant, `c_ObstacleAvoidForce`,
    that we set in our class definition. That value can be tweaked up and down. In
    general, I like to keep this value high, risking the player may realize that this
    is a cheat. You may modify the value of `c_ObstacleAvoidForce` based on your preferences:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在我们的边界框中找到至少一个物体，我们希望旋转我们的飞船，使其自然地避开它，就像玩家一样，并且我们还添加一个避让力，这有点作弊。避让力根据我们在类定义中设置的常数`c_ObstacleAvoidForce`将我们的敌方飞船推离物体。这个值可以进行上下调整。一般来说，我喜欢保持这个值较高，冒着玩家可能意识到这是作弊的风险。你可以根据自己的喜好修改`c_ObstacleAvoidForce`的值：
- en: '[PRE90]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The obstacle branch runs if the enemy ship is not too close to the star. If
    the object is too close to the star, the code jumps into the `else` block. This
    code creates an avoid force that pushes and steers the ship away from the center
    of the play area. It has its own constant avoid force that we set inside the class
    definition:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果敌舰离星球不太近，就会执行障碍物分支。如果物体离星球太近，代码就会跳到`else`块。这段代码创建了一个避让力，将飞船推离游戏区域中心。它有自己的避让力常数，我们在类定义中设置：
- en: '[PRE91]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `ShieldCheck` function is similar to the avoid force function, in that
    it checks a bounding rectangle to see whether there is an obstacle close to our
    ship. It then determines whether the ship is unlikely to avoid a collision. No
    matter how good our steering forces, sometimes we are not able to avoid an asteroid
    or projectile. If this is the case, we want to raise our shields. We do not need
    to check whether we are close to the star because the star will kill us whether
    our shields are up or not, so there is no need to bother worrying about that in
    the `ShieldCheck` function:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShieldCheck`函数类似于避让力函数，它检查一个边界矩形，看看我们的飞船附近是否有障碍物。然后确定飞船是否不太可能避免碰撞。无论我们的转向力有多好，有时我们都无法避免撞上小行星或抛射物。如果是这种情况，我们希望提高我们的护盾。我们不需要检查是否靠近星球，因为星球无论我们的护盾是否升起，都会杀死我们，所以在`ShieldCheck`函数中不需要担心这个问题：'
- en: '[PRE92]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Like the avoid force check, we set up a bounding rectangle around our ship with
    the `c_ShieldDist` constant. This value should be lower than the avoid force.
    If it is not, we will raise our shields needlessly when we could avoid the object.
    Just like everything else in our AI, if the value of `c_ShieldDist` is set too
    high, we will be raising our shields when we do not need to. Our shields have
    limited use, so this would waste shield time that we could otherwise use later.
    If we set the value too low, we risk hitting an obstacle that the ship is accelerating
    toward before we have a chance to raise the shields.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 就像避让力检查一样，我们用`c_ShieldDist`常数在我们的飞船周围设置一个边界矩形。这个值应该比避让力低。如果不是，我们将不必要地提高我们的护盾，而我们本来可以避开这个物体。就像我们AI中的其他一切一样，如果`c_ShieldDist`的值设置得太高，我们将在不需要的时候提高我们的护盾。我们的护盾使用次数有限，所以这会浪费我们本来可以在以后使用的护盾时间。如果我们将值设置得太低，我们会冒着在飞船加速向障碍物撞击之前没有机会升起护盾的风险。
- en: 'The next function, `LOSCheck`, is a line-of-sight check. That means that it
    looks to see whether a straight line could be drawn between the enemy ship and
    the player''s ship without intersecting any obstacles. If there is a clear line
    of sight, this function returns `true`. If there is an obstacle blocking the line
    of sight, the function returns `false`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOSCheck`函数是一个视线检查。这意味着它会查看敌舰和玩家舰之间是否可以画一条直线而不与任何障碍物相交。如果有清晰的视线，这个函数返回`true`。如果有障碍物挡住了视线，函数返回`false`。'
- en: '[PRE93]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'One thing we will frequently want to make checks against is the player''s distance
    to the enemy ship. Because the square root is a time-consuming operation, we eliminate
    it by checking against a squared distance. We use the `GetPlayerDistSq` function
    to get the squared distance between the enemy ship and the player ship:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要检查的一件事是玩家到敌舰的距离。因为平方根是一个耗时的操作，我们通过检查平方距离来消除它。我们使用`GetPlayerDistSq`函数来获取敌舰和玩家舰之间的平方距离：
- en: '[PRE94]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The FSM''s `Move` function is the function that runs our AI every frame. It
    performs a series of checks to determine what state the AI should be in and executes
    that state''s function. It also checks to see whether the AI should raise or lower
    the spaceship''s shields. Here is the function in its entirety:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: FSM的`Move`函数是我们每帧运行AI的函数。它执行一系列检查来确定AI应该处于什么状态，并执行该状态的函数。它还检查AI是否应该提高或降低飞船的盾牌。以下是完整的函数：
- en: '[PRE95]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We use the `m_CheckCycle` attribute to cycle through the different state checks
    we perform to reduce the burden on the CPU. That is not really necessary for an
    AI as simple as this one. There is only one agent in our game executing this AI,
    but if we ever expanded this to use multiple agents, we might set up each of those
    agents starting on a different cycle check number to spread out our computations.
    Right now, this cycle check is included for demonstration purposes:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`m_CheckCycle`属性来循环执行我们执行的不同状态检查，以减轻CPU的负担。对于这么简单的AI来说，这并不是真正必要的。在我们的游戏中只有一个代理执行这个AI，但如果我们将来扩展到使用多个代理，我们可能会设置每个代理从不同的周期检查号开始，以分散我们的计算。现在，这个周期检查是为了演示目的而包含的：
- en: '[PRE96]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: As you can see, if we are on cycle 0, we run the line-of-sight check, and if
    we do not have a line of sight, we set the current state to `WANDER`. In cycle
    1, we look to see whether we had a line of sight on the last frame, and if we
    did, we figure out whether we want to approach, flee, or attack, based on the
    distance between the enemy ship and the player ship. On cycle 2, we add any avoid
    forces and reset our check cycle attribute.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果我们在周期0上，我们运行视线检查，如果我们没有视线，我们将当前状态设置为`WANDER`。在周期1上，我们查看上一帧是否有视线，如果有，我们根据敌船和玩家船之间的距离来确定我们是要接近、逃离还是攻击。在周期2上，我们添加任何避免力，并重置我们的检查周期属性。
- en: 'Then we perform a shield check every cycle. I initially had the shield check
    performed on every fourth cycle, but the enemy ship was getting hit too often
    when it was struck by a projectile head on. Because of this, I changed the code
    to perform the shield check on every cycle. That is the kind of manual tweaking
    you end up doing in Game AI to make it work. There is a lot of trial and error:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们每个周期执行一次盾牌检查。最初我是在每四个周期执行一次盾牌检查，但是当敌船被抛射物正面击中时，它经常被击中。因此，我改变了代码，使得每个周期执行一次盾牌检查。这就是你在游戏AI中最终需要做的手动调整。这需要大量的试验和错误：
- en: '[PRE97]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The last few blocks of code are just a series of `if` and `else if` statements
    that look to see what the current state is, and calls the appropriate function
    based on that state:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几个代码块只是一系列`if`和`else if`语句，用于查看当前状态，并根据该状态调用适当的函数：
- en: '[PRE98]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Compiling the ai.html file
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译ai.html文件
- en: 'We are now ready to compile and test our `ai.html` file. The screenshot for
    this version of the game will look quite a bit different than our previous version:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备编译和测试我们的`ai.html`文件。这个游戏版本的屏幕截图看起来会和之前的版本有很大不同：
- en: '[PRE99]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The new version of the game will have a much larger canvas, with asteroids
    and a star in the middle. The enemy spaceship will seek out the player and attack.
    Here is a screenshot:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的新版本将拥有一个更大的画布，中间有小行星和一颗星星。敌人的飞船将寻找玩家并发动攻击。这是一个屏幕截图：
- en: '![](img/d777e80d-46b6-4267-9d9c-18343538ce48.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d777e80d-46b6-4267-9d9c-18343538ce48.png)'
- en: A screenshot of ai.html
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ai.html的屏幕截图
- en: Remember that you must run WebAssembly apps using a web server, or with `emrun`.
    If you would like to run your WebAssembly app using `emrun`, you must compile
    it with the `--emrun` flag. The web browser requires a web server to stream the
    WebAssembly module. If you attempt to open an HTML page that uses WebAssembly
    in a browser directly from your hard drive, that WebAssembly module will not load.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您必须使用Web服务器或`emrun`来运行WebAssembly应用程序。如果您想使用`emrun`运行WebAssembly应用程序，您必须使用`--emrun`标志进行编译。Web浏览器需要一个Web服务器来流式传输WebAssembly模块。如果您尝试直接从硬盘驱动器在浏览器中打开使用WebAssembly的HTML页面，那么WebAssembly模块将无法加载。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed Game AI, what it is, and how it is different than
    academic AI. We talked about using autonomous agents versus a top-down AI, and
    the benefits of each AI style, as well as how we can mix the two styles.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了游戏AI，它是什么，以及它与学术AI的不同之处。我们谈到了使用自主代理与自上而下的AI，以及每种AI风格的好处，以及我们如何可以混合这两种风格。
- en: I introduced the concept of an FSM and mentioned early uses of FSMs in games
    such as *PAC-MAN*, and we explored steering behaviors, and the kinds of steering
    behaviors we will use to direct the agent in our game. We added asteroids and
    a star as obstacles to our game and increased the size of our gameplay area. We
    added new forms of collision detection to allow our AI to determine when it has
    a line of sight with our player. We also added rectangle collision detection to
    determine whether there is an obstacle close enough for our AI to use an avoid
    force. We expanded our `Point` class to a `Vector2D` class and added new functionality
    including projection, magnitude, and dot product calculations. We wrote an FSM
    and used it to determine what steering forces we will be using, and under what
    circumstances.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我介绍了FSM的概念，并提到了在游戏中早期使用FSM的游戏，比如*PAC-MAN*，我们探讨了转向行为，以及我们将在游戏中用来引导代理的转向行为的种类。我们将小行星和一颗星星添加为游戏的障碍物，并增加了游戏区域的大小。我们添加了新形式的碰撞检测，以便我们的AI确定何时与玩家有视线。我们还添加了矩形碰撞检测，以确定是否有足够接近的障碍物供我们的AI使用避免力。我们将我们的`Point`类扩展为`Vector2D`类，并添加了新功能，包括投影、大小和点积计算。我们编写了一个FSM，并用它来确定我们将使用的转向力，并在什么情况下使用。
- en: In the next chapter, we will be greatly expanding the size of our level and
    adding a camera so that we can move our spaceship around this larger version of
    the gameplay area.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将大大扩展我们的关卡大小，并添加一个摄像机，以便我们可以在游戏区域的更大版本中移动我们的飞船。
