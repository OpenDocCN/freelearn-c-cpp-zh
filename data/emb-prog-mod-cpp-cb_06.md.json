["```cpp\n#include <cstdint>\n#include <string.h>\n\nconstexpr size_t kMaxFileNameSize = 256;\nconstexpr size_t kBufferSize = 4096;\nconstexpr size_t kMaxDevices = 16;\n\nclass SerialDevice {\n    char device_file_name[256];\n    uint8_t input_buffer[kBufferSize];\n    uint8_t output_buffer[kBufferSize];\n    int file_descriptor;\n    size_t input_length;\n    size_t output_length;\n\n  public:\n    SerialDevice():\n      file_descriptor(-1), input_length(0), output_length(0) {}\n\n    bool Init(const char* name) {\n      strncpy(device_file_name, name, sizeof(device_file_name));\n    }\n\n    bool Write(const uint8_t* data, size_t size) {\n      if (size > sizeof(output_buffer)) {\n        throw \"Data size exceeds the limit\";\n      }\n      memcpy(output_buffer, data, size);\n    }\n\n    size_t Read(uint8_t* data, size_t size) {\n      if (size < input_length) {\n        throw \"Read buffer is too small\";\n      }\n      memcpy(data, input_buffer, input_length);\n      return input_length;\n    }\n};\n```", "```cpp\nint main() {\n  SerialDevice devices[kMaxDevices];\n  size_t number_of_devices = 0;\n\n  uint8_t data[] = \"Hello\";\n  devices[0].Init(\"test\");\n  devices[0].Write(data, sizeof(data));\n  number_of_devices = 1;\n\n  return 0;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(prealloc)\nadd_executable(prealloc prealloc.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++17\")\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\n  SerialDevice devices[kMaxDevices];\n```", "```cpp\n  char device_file_name[kMaxFileNameSize];\n  uint8_t input_buffer[kBufferSize];\n  uint8_t output_buffer[kBufferSize];\n```", "```cpp\n  size_t input_length;\n  size_t output_length;\n```", "```cpp\n  size_t number_of_devices = 0;\n```", "```cpp\n#include <iostream>\n\ntemplate<class T, size_t N>\nclass ObjectPool {\n  private:\n    T objects[N];\n    size_t available[N];\n    size_t top = 0;\n  public:\n    ObjectPool(): top(0) {\n      for (size_t i = 0; i < N; i++) {\n        available[i] = i;\n      }\n    }\n```", "```cpp\n    T& get() {\n      if (top < N) {\n        size_t idx = available[top++];\n        return objects[idx];\n      } else {\n        throw std::runtime_error(\"All objects are in use\");\n      }\n    }\n```", "```cpp\n    void free(const T& obj) {\n      const T* ptr = &obj;\n      size_t idx = (ptr - objects) / sizeof(T);\n      if (idx < N) {\n        if (top) {\n          top--;\n          available[top] = idx;\n        } else {\n          throw std::runtime_error(\"Some object was freed more than once\");\n        }\n      } else {\n        throw std::runtime_error(\"Freeing object that does not belong to\n       the pool\");\n      }\n     }\n```", "```cpp\n    size_t requested() const { return top; }\n    };\n```", "```cpp\nstruct Point {\n  int x, y;\n};\n```", "```cpp\nint main() {\n  ObjectPool<Point, 10> points;\n\n  Point& a = points.get();\n  a.x = 10; a.y=20;\n  std::cout << \"Point a (\" << a.x << \", \" << a.y << \") initialized, requested \"        <<\n    points.requested() << std::endl;\n\n  Point& b = points.get();\n  std::cout << \"Point b (\" << b.x << \", \" << b.y << \") not initialized, requested \" <<\n    points.requested() << std::endl;\n\n  points.free(a);\n  std::cout << \"Point a(\" << a.x << \", \" << a.y << \") returned, requested \" <<\n    points.requested() << std::endl;\n\n  Point& c = points.get();\n  std::cout << \"Point c(\" << c.x << \", \" << c.y << \") not intialized, requested \" <<\n    points.requested() << std::endl;\n\n  Point local;\n  try {\n    points.free(local);\n  } catch (std::runtime_error e) {\n    std::cout << \"Exception caught: \" << e.what() << std::endl;\n  }\n  }\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(objpool)\nadd_executable(objpool objpool.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\n     T objects[N];\n     size_t available[N];\n```", "```cpp\n      for (size_t i = 0; i < N; i++) {\n        available[i] = i;\n      }\n```", "```cpp\n      size_t idx = available[top++];\n      return objects[idx];\n```", "```cpp\n      throw std::runtime_error(\"All objects are in use\");\n```", "```cpp\n      const T* ptr = &obj;\n      size_t idx = (ptr - objects) / sizeof(T);\n```", "```cpp\n  top--;\n  available[top] = idx;\n```", "```cpp\n     throw std::runtime_error(\"Freeing object that does not belong to the pool\");\n```", "```cpp\n     size_t requested() const { return top; }\n```", "```cpp\n struct Point {\n  int x, y;\n };\n```", "```cpp\n    ObjectPool<Point, 10> points;\n```", "```cpp\n Point& a = points.get();\n a.x = 10; a.y=20;\n```", "```cpp\n  Point local;\n  try {\n    points.free(local);\n  } catch (std::runtime_error e) {\n    std::cout << \"Exception caught: \" << e.what() << std::endl;\n  }\n```", "```cpp\n#include <iostream>\n\ntemplate<class T, size_t N>\nclass RingBuffer {\n  private:\n    T objects[N];\n    size_t read;\n    size_t write;\n    size_t queued;\n  public:\n    RingBuffer(): read(0), write(0), queued(0) {}\n```", "```cpp\n    T& push() {\n      T& current = objects[write];\n      write = (write + 1) % N;\n      queued++;\n      if (queued > N) {\n        queued = N;\n        read = write;\n      }\n      return current;\n    }\n\n```", "```cpp\n    const T& pull() {\n      if (!queued) {\n        throw std::runtime_error(\"No data in the ring buffer\");\n      }\n      T& current = objects[read];\n      read = (read + 1) % N;\n      queued--;\n      return current;\n    }\n```", "```cpp\nbool has_data() {\n  return queued != 0;\n}\n};\n```", "```cpp\nstruct Frame {\n  uint32_t index;\n  uint8_t data[1024];\n};\n```", "```cpp\nint main() {\n  RingBuffer<Frame, 10> frames;\n\n  std::cout << \"Frames \" << (frames.has_data() ? \"\" : \"do not \")\n      << \"contain data\" << std::endl;\n  try {\n    const Frame& frame = frames.pull();\n  } catch (std::runtime_error e) {\n    std::cout << \"Exception caught: \" << e.what() << std::endl;\n  }\n```", "```cpp\nfor (size_t i = 0; i < 5; i++) {\nFrame& out = frames.push();\nout.index = i;\nout.data[0] = 'a' + i;\nout.data[1] = '\\0';\n  }\nstd::cout << \"Frames \" << (frames.has_data() ? \"\" : \"do not \")\n<< \"contain data\" << std::endl;\nwhile (frames.has_data()) {\nconst Frame& in = frames.pull();\n    std::cout << \"Frame \" << in.index << \": \" << in.data << std::endl;\n  }\n```", "```cpp\n    for (size_t i = 0; i < 26; i++) {\n    Frame& out = frames.push();\n    out.index = i;\n    out.data[0] = 'a' + i;\n    out.data[1] = '\\0';\n    }\n    std::cout << \"Frames \" << (frames.has_data() ? \"\" : \"do not \")\n      << \"contain data\" << std::endl;\n    while (frames.has_data()) {\n    const Frame& in = frames.pull();\n    std::cout << \"Frame \" << in.index << \": \" << in.data << std::endl;\n    }\n    }\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(ringbuf)\nadd_executable(ringbuf ringbuf.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nT& current = objects[write];\nwrite = (write + 1) % N;\nqueued++;\n```", "```cpp\n if (queued > N) {\n  queued = N;\n  read = write;\n }\n```", "```cpp\n const T& pull() {\n```", "```cpp\n  if (!queued) {\n   throw std::runtime_error(\"No data in the ring buffer\");\n  }\n```", "```cpp\n  read = (read + 1) % N;\n  queued--;\n```", "```cpp\n  bool has_data() {\n  return queued != 0;\n  }\n```", "```cpp\n  uint32_t index;\n  uint8_t data[1024];\n  };\n```", "```cpp\n  RingBuffer<Frame, 10> frames;\n```", "```cpp\n  for (size_t i = 0; i < 5; i++) {\n    Frame& out = frames.push();\n    out.index = i;\n    out.data[0] = 'a' + i;\n    out.data[1] = '\\0';\n  }\n```", "```cpp\n  while (frames.has_data()) {\n    const Frame& in = frames.pull();\n    std::cout << \"Frame \" << in.index << \": \" << in.data << std::endl;\n  }\n```", "```cpp\n for (size_t i = 0; i < 26; i++) {\n    Frame& out = frames.push();\n    out.index = i;\n    out.data[0] = 'a' + i;\n    out.data[1] = '\\0';\n  }\n```", "```cpp\n#include <algorithm>\n#include <iostream>\n#include <chrono>\n#include <thread>\n\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n\nconst char* kSharedMemPath = \"/sample_point\";\nconst size_t kPayloadSize = 16;\n\nusing namespace std::literals;\n\ntemplate<class T>\nclass SharedMem {\n  int fd;\n  T* ptr;\n  const char* name;\n\n  public:\n```", "```cpp\nSharedMem(const char* name, bool owner=false) {\nfd = shm_open(name, O_RDWR | O_CREAT, 0600);\nif (fd == -1) {\nthrow std::runtime_error(\"Failed to open a shared memory region\");\n}\nif (ftruncate(fd, sizeof(T)) < 0) {\nclose(fd);\nthrow std::runtime_error(\"Failed to set size of a shared memory \nregion\");\n};\nptr = (T*)mmap(nullptr, sizeof(T), PROT_READ | PROT_WRITE, \nMAP_SHARED, fd, 0);\nif (!ptr) {\nclose(fd);\n    throw std::runtime_error(\"Failed to mmap a shared memory region\");\n}\n    this->name = owner ? name : nullptr;\n    std::cout << \"Opened shared mem instance \" << name << std::endl;\n}\n```", "```cpp\n    ~SharedMem() {\n      munmap(ptr, sizeof(T));\n      close(fd);\n      if (name) {\n        std::cout << \"Remove shared mem instance \" << name << std::endl;\n        shm_unlink(name);\n      }\n      }\n```", "```cpp\n    T& get() const {\n      return *ptr;\n    }\n    };\n```", "```cpp\nstruct Payload {\n  uint32_t index;\n  uint8_t raw[kPayloadSize];\n};\n```", "```cpp\nvoid producer() {\n  SharedMem<Payload> writer(kSharedMemPath);\n  Payload& pw = writer.get();\n  for (int i = 0; i < 5; i++) {\n    pw.index = i;\n    std::fill_n(pw.raw, sizeof(pw.raw) - 1, 'a' + i);\n    pw.raw[sizeof(pw.raw) - 1] = '\\0';\n    std::this_thread::sleep_for(150ms);\n  }\n}\n```", "```cpp\nvoid consumer() {\n  SharedMem<Payload> point_reader(kSharedMemPath, true);\n  Payload& pr = point_reader.get();\n  for (int i = 0; i < 10; i++) {\n    std::cout << \"Read data frame \" << pr.index << \": \" << pr.raw << std::endl;\n    std::this_thread::sleep_for(100ms);\n  }\n  }\n```", "```cpp\nint main() {\n\n  if (fork()) {\n    consumer();\n  } else {\n    producer();\n  }\n  }\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(shmem)\nadd_executable(shmem shmem.cpp)\ntarget_link_libraries(shmem rt)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++14\")\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\ntemplate<class T>\nclass SharedMem {\n```", "```cpp\nfd = shm_open(name, O_RDWR | O_CREAT, 0600);\n```", "```cpp\nif (ftruncate(fd, sizeof(T)) < 0) {\n```", "```cpp\nptr = (T*)mmap(nullptr, sizeof(T), PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n```", "```cpp\nint fd;\nT* ptr;\nconst char* name;\n```", "```cpp\n munmap(ptr, sizeof(T));\n```", "```cpp\n if (name) {\n   std::cout << \"Remove shared mem instance \" << name << std::endl;\n shm_unlink(name);\n }\n```", "```cpp\n  T& get() const {\n      return *ptr;\n  }\n```", "```cpp\n  if (fork()) {\n    consumer();\n  } else {\n    producer();\n  }\n```", "```cpp\n  struct Payload {\n  uint32_t index;\n  uint8_t raw[kPayloadSize];\n  };\n```", "```cpp\n  SharedMem<Payload> writer(kSharedMemPath);\n```", "```cpp\n  SharedMem<Payload> point_reader(kSharedMemPath, true);\n```", "```cpp\nOpened shared mem instance /sample_point\nRead data frame 0: \nOpened shared mem instance /sample_point\n```", "```cpp\n#include <iostream>\n#include <chrono>\n#include <system_error>\n#include <thread>\n\n#include <fcntl.h>\n#include <sys/mman.h>\n\nconstexpr uint32_t kTimerBase = 0x3F003000;\n\nstruct SystemTimer {\n  uint32_t CS;\n  uint32_t counter_lo;\n  uint32_t counter_hi;\n};\n```", "```cpp\nint main() {\n\n  int memfd = open(\"/dev/mem\", O_RDWR | O_SYNC);\n  if (memfd < 0) {\n  throw std::system_error(errno, std::generic_category(),\n  \"Failed to open /dev/mem. Make sure you run as root.\");\n  }\n\n  SystemTimer *timer = (SystemTimer*)mmap(NULL, sizeof(SystemTimer),\n  PROT_READ|PROT_WRITE, MAP_SHARED,\n  memfd, kTimerBase);\n  if (timer == MAP_FAILED) {\n  throw std::system_error(errno, std::generic_category(),\n  \"Memory mapping failed\");\n  }\n\n  uint64_t prev = 0;\n  for (int i = 0; i < 10; i++) {\n   uint64_t time = ((uint64_t)timer->counter_hi << 32) + timer->counter_lo;\n   std::cout << \"System timer: \" << time;\n   if (i > 0) {\n   std::cout << \", diff \" << time - prev;\n    }\n    prev = time;\n    std::cout << std::endl;\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n  }\n  return 0;\n }\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(timer)\nadd_executable(timer timer.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\n\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\nconstexpr uint32_t kTimerBase = 0x3F003000;\n```", "```cpp\nstruct SystemTimer {\n  uint32_t CS;\n  uint32_t counter_lo;\n  uint32_t counter_hi;\n};\n```", "```cpp\nint memfd = open(\"/dev/mem\", O_RDWR | O_SYNC);\n```", "```cpp\nSystemTimer *timer = (SystemTimer*)mmap(NULL, sizeof(SystemTimer),\nPROT_READ|PROT_WRITE, MAP_SHARED, memfd, kTimerBase);\n```"]