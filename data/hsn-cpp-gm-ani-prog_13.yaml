- en: '*Chapter 13*: Implementing Inverse Kinematics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第13章*：实现逆运动学'
- en: '**Inverse Kinematics** (**IK**) is the process of solving how a set of joints
    should be oriented to reach a specified point in world space. For example, you
    could specify a point for a character to touch. By using IK, you can figure out
    how to rotate the character''s shoulder, elbow, and wrist in a way that the character''s
    finger is always touching a specific point.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**逆运动学**（**IK**）是解决一组关节应该如何定位以达到世界空间中指定点的过程。例如，您可以为角色指定一个触摸的点。通过使用IK，您可以找出如何旋转角色的肩膀、肘部和手腕，使得角色的手指始终触摸特定点。'
- en: 'There are two algorithms commonly used for IK, that is, CCD and FABRIK. Both
    will be covered in this chapter. By the end of this chapter, you should be able
    to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 常用于IK的两种算法是CCD和FABRIK。本章将涵盖这两种算法。通过本章结束时，您应该能够做到以下事情：
- en: Understand how CCD IK works
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解CCD IK的工作原理
- en: Implement a CCD solver
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现CCD求解器
- en: Understand how FABRIK works
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解FABRIK的工作原理
- en: Implement a FABRIK solver
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现FABRIK求解器
- en: Implement ball-and-socket constraints
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现球和套约束
- en: Implement hinge constraints
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现铰链约束
- en: Understand where and how IK solvers fit into an animation pipeline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解IK求解器在动画流水线中的位置和方式
- en: Creating a CCD solver
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CCD求解器
- en: In this section, you will learn about and implement the CCD IK algorithm. **CCD**
    stands for **Cyclic Coordinate Descent**. This algorithm can be used to pose a
    chain of joints in a way that the last joint on the chain comes as close as possible
    to touching a target. You will be able to use CCD to create limb and other IK
    systems where a chain needs to be solved using a target point.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习并实现CCD IK算法。**CCD**代表**循环坐标下降**。该算法可用于以使链条上的最后一个关节尽可能接近触摸目标的方式来摆放一系列关节。您将能够使用CCD来创建需要使用目标点解决链条的肢体和其他IK系统。
- en: There are three important concepts for CCD. First, there is the **goal**, the
    point in space you are trying to touch. Next is the **IK chain**, which is a list
    of all of the joints that will need to rotate to reach the goal. Finally, there
    is the **end effector**, which is the last joint in the chain (the one that needs
    to touch the goal).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CCD有三个重要概念。首先是**目标**，即您试图触摸的空间点。接下来是**IK链**，它是需要旋转以达到目标的所有关节的列表。最后是**末端执行器**，它是链条中的最后一个关节（需要触摸目标的关节）。
- en: 'With a goal, chain, and end effector, the CCD algorithm in pseudocode looks
    like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有了目标、链和末端执行器，CCD算法的伪代码如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The CCD algorithm looks simple but how does it work? Start with the joint right
    before the effector. Rotating the effector would have no effect on the chain.
    Find a vector from the joint before the effector to the target, and then a vector
    from the joint to the effector. Rotate the joint in question so that the two vectors
    line up. Repeat for each joint until the base joint:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: CCD算法看起来很简单，但它是如何工作的呢？从末端执行器前面的关节开始。旋转执行器对链条没有影响。找到从执行器前面的关节到目标的向量，然后找到从关节到执行器的向量。旋转相关的关节，使得这两个向量对齐。对每个关节重复此过程，直到基本关节为止。
- en: '![](img/Figure_13.1_B16191.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_13.1_B16191.jpg)'
- en: 'Figure 13.1: Visualizing the CCD algorithm'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：CCD算法的可视化
- en: Looking at *Figure 13.1*, the end effector does not touch the target. Why not?
    CCD is an iterative algorithm and the preceding steps describe one iteration.
    Multiple iterations per frame are needed to achieve convergence. In the following
    sections, we will learn how to declare the CCD solver, which will lead us to the
    implementation of the `CCDSolver` class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 观察*图13.1*，末端执行器没有触摸目标。为什么？CCD是一个迭代算法，前面的步骤描述了一个迭代。需要多次迭代才能实现收敛。在接下来的章节中，我们将学习如何声明CCD求解器，这将引导我们实现`CCDSolver`类。
- en: Declaring the CCD solver
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明CCD求解器
- en: In this section, you will declare the CCD solver. This will give you a chance
    to familiarize yourself with the API and understand how the class works at a high
    level before diving into the implementation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将声明CCD求解器。这将让您有机会在实现之前，熟悉API并了解类在高层次上的工作方式。
- en: 'Create a new file, `CCDSolver.h`, that the `CCDSolver` class will be declared
    in this file. The `CCDSolver` class should contain a vector of transforms that
    make up the IK chain. Assume that the IK chain has a parent-child relationship
    where every index is the child of the index before it, making 0 our root node.
    As such, every transform in the IK chain is declared in local space. Follow these
    steps to declare the CCD IK solver:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`CCDSolver.h`，`CCDSolver`类将在此文件中声明。`CCDSolver`类应包含组成IK链的变换向量。假设IK链具有父子关系，其中每个索引都是前一个索引的子级，使0成为我们的根节点。因此，IK链中的每个变换都是在本地空间中声明的。按照以下步骤声明CCD
    IK求解器：
- en: 'Begin by declaring the `CCDSolver` class with three variables: a list of transforms
    to form the IK chain, the number of iterations to perform, and some small delta
    that can be used to control how close the target has to be to the goal before
    the chain is considered solved. Declare the default constructor as well:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先声明`CCDSolver`类，包含三个变量：用于形成IK链的变换列表、要执行的迭代次数和可以用来控制目标与目标之间的距离的小增量。同时声明默认构造函数：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implement getter and setter functions for the size of the IK chain, the number
    of steps, and the threshold values. Declare which `[] operator` is to be used
    to get and set local joint transform. Declare the `GetGlobalTransform` function,
    which will return the global transform of a joint:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为IK链的大小、步数和阈值值实现getter和setter函数。声明要使用的`[] operator`来获取和设置本地关节变换。声明`GetGlobalTransform`函数，它将返回关节的全局变换：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Declare the `Solve` function, which will be called to solve the IK chain. A
    transform is provided, but only the position component of the transform is ever
    used. The `Solve` function returns `true` if the chain was solved, otherwise,
    it returns `false`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`Solve`函数，用于解决IK链。提供一个变换，但只使用变换的位置分量。如果链被解决，则`Solve`函数返回`true`，否则返回`false`：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `mNumSteps` variable is used to make sure the solver doesn't fall into an
    infinite loop. There is no guarantee that the end effector will ever reach the
    goal. Limiting the number of iterations helps to avoid a potential infinite loop.
    In the following section, you will start to implement the CCD solver.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`mNumSteps`变量用于确保求解器不会陷入无限循环。不能保证末端执行器会达到目标。限制迭代次数有助于避免潜在的无限循环。在接下来的部分，您将开始实现CCD求解器。'
- en: Implementing the CCD solver
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现CCD求解器
- en: 'Create a new file, `CCDSolver.cpp`, in which to implement the CCD solver. Follow
    these steps to implement the CCD solver:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`CCDSolver.cpp`的新文件，用于实现CCD求解器。按照以下步骤实现CCD求解器：
- en: 'Define the default constructor to assign values to the number of steps and
    the threshold. Use a small threshold such as `0.0001f`. Use `15` for the default
    number of steps:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义默认构造函数，为步数和阈值赋值。使用小阈值，如`0.0001f`。默认步数为`15`：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Implement the `Size` and `Resize` functions, which control the size of the
    IK chain, and `[] operator` contains the value of each joint in the chain:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Size`和`Resize`函数，控制IK链的大小，`[]运算符`包含链中每个关节的值：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implement getter and setter functions for the number of steps and the threshold
    that the solver contains:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为求解器包含的步数和阈值实现获取器和设置器函数：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implement the `GetGlobalTransform` function, which probably looks familiar.
    It concatenates the transform of the specified joint with the transform of all
    of its parent joints and returns the global transform of the specified joint:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`GetGlobalTransform`函数，这可能看起来很熟悉。它将指定关节的变换与所有父关节的变换连接起来，并返回指定关节的全局变换：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement the `Solve` function by making sure the size of the chain is valid
    and storing local variables for the index of the last element and the vector of
    the target position:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过确保链的大小有效并存储最后一个元素的索引和目标位置的向量来实现`Solve`函数：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Loop from `0` to `mNumSteps` to perform the correct number of iterations. On
    every iteration, get the position of the end effector and check whether it''s
    close enough to the goal. If it is close enough, return early:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环从`0`到`mNumSteps`，执行正确数量的迭代。在每次迭代中，获取末端执行器的位置，并检查它是否足够接近目标。如果足够接近，提前返回：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In each iteration, loop through the entire IK chain. Start the iteration at
    `size - 2`; since `size - 1` is the last element, rotating the last element has
    no effect on any bones:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每次迭代中，循环遍历整个IK链。从`size - 2`开始迭代；因为`size - 1`是最后一个元素，旋转最后一个元素对任何骨骼都没有影响：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For each joint in the IK chain, get the world transform of the joint. Find
    a vector from the position of the joint to the position of the end effector. Find
    another vector from the position of the current joint to the position of the goal:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于IK链中的每个关节，获取关节的世界变换。找到从关节位置到末端执行器位置的向量。找到从当前关节位置到目标位置的另一个向量：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, find a quaternion that rotates from the position to effector vector to
    the position to goal vector. There is an edge case in which the vector pointing
    to the effector or to the goal could be a zero vector:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，找到一个四元数，将位置到末端执行器的向量旋转到位置到目标向量。有一种特殊情况，指向末端执行器或目标的向量可能是零向量：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Use this vector to rotate the joint into the correct orientation in the world
    space. Rotate the world space orientation of the joint by the inverse of the joint''s
    previous world rotation to move the quaternion back into the joint space:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个向量将关节旋转到世界空间中的正确方向。通过关节的上一个世界旋转的逆来旋转关节的世界空间方向，将四元数移回关节空间：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As the joint moves, check how close the end effector moved to the goal at each
    iteration. If it''s close enough, return early from the function, with a value
    of `true`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着关节的移动，检查末端执行器在每次迭代中移动到目标的距离。如果足够接近，从函数中提前返回，返回值为`true`：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If the goal wasn''t reached, the IK chain can''t be solved, at least not in
    the number of iterations specified. Simply return `false` to signal that the function
    failed to reach its target:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果未达到目标，则IK链无法解决，至少不是在指定的迭代次数内。简单地返回`false`以表示函数未能达到目标：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This CCD solver can be used to solve a single chain that has one origin and
    one end effector. There are more advanced ways of handling IK chains where a single
    chain could have multiple end effectors. However, those are much less common due
    to the additional implementation complexity. In the next section, you will start
    to explore a different IK algorithm, FABRIK.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个CCD求解器可以用来解决具有一个起点和一个末端执行器的单链。然而，处理IK链的更高级方法是，一个单链可以有多个末端执行器。然而，由于额外的实现复杂性，这些方法要少得多。在下一节中，您将开始探索另一种IK算法，FABRIK。
- en: Creating a FABRIK solver
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个FABRIK求解器
- en: '**FABRIK** (**Forward And Backward Reaching Inverse Kinematics**) has a more
    natural, humanoid looking convergence. Like CCD, FABRIK works with an IK chain
    that has a base, end effector, and target to reach for. Unlike CCD, FABRIK works
    with positions, not rotations. The FABRIK algorithm is easier to understand since
    it can be implemented using only vectors.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**FABRIK**（**前向和后向逆运动学**）具有更自然、类人的收敛性。与CCD一样，FABRIK处理具有基础、末端执行器和要达到的目标的IK链。与CCD不同，FABRIK处理的是位置，而不是旋转。FABRIK算法更容易理解，因为它可以仅使用向量来实现。'
- en: In many ways, FABRIK can be used as a drop-in replacement for CCD. Both algorithms
    address the same problem, but they take different approaches to address it. FABRIK
    tends to converge faster and look better for humanoid animation, so you will probably
    use it as the solver for character limbs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，FABRIK可以被用作CCD的替代品。这两种算法解决了同样的问题，但它们采取了不同的方法来解决。FABRIK倾向于更快地收敛，并且对于人形动画效果更好，因此您可能会将其用作角色肢体的求解器。
- en: Working with positions instead of rotations will not work well when it comes
    to humanoid rigs, which need to be animated by rotating joints. This can be solved
    by adding a pre- and post-process step to the algorithm. The pre-process step
    will convert all transforms in the IK chain into world space position vectors.
    The post-process step will convert those vectors into rotation data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理人形角色绑定时，使用位置而不是旋转将无法很好地工作，因为需要通过旋转关节来进行动画。这可以通过向算法添加预处理和后处理步骤来解决。预处理步骤将把IK链中的所有变换转换为世界空间位置向量。后处理步骤将把这些向量转换为旋转数据。
- en: The FABRIK algorithm has two parts. First, iterate backward from the end effector
    to the base. When iterating backward, move the effector to the target. Next, move
    every bone so they are relative to the effector; this will keep the chain intact.
    Next, move the base back to its original position and move every bone relative
    to the base so the chain stays intact.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: FABRIK算法有两个部分。首先，从末端执行器向基座进行反向迭代。在进行反向迭代时，将执行器移动到目标位置。接下来，移动每根骨骼，使它们相对于执行器保持不变；这将保持链的完整性。然后，将基座移回原始位置，并将每根骨骼相对于基座移动，以保持链的完整性。
- en: 'In pseudocode, the FABRIK algorithm looks like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在伪代码中，FABRIK算法如下所示：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To visualize FABRIK, set the end effector to where the target is. Find a vector
    from the end effector to the last joint. Move the last joint to be along this
    vector, maintaining its distance to the end effector. Repeat for each joint until
    the base is reached. This will move the base joint out of position.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要可视化FABRIK，将末端执行器设置到目标位置。找到从末端执行器到最后一个关节的向量。将最后一个关节移动到沿着这个向量的位置，保持其与末端执行器的距离。对每个关节重复此操作，直到达到基座。这将使基座关节移出位置。
- en: 'To do the forward iteration, put the base back to where it should be. Find
    a vector to the next joint. Place the next joint on this vector, maintaining its
    distance to the base. Repeat this all of the way down the chain:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行正向迭代，将基座放回原来的位置。找到到下一个关节的向量。将下一个关节放在这个向量上，保持其与基座的距离。沿着整个链重复这个过程：
- en: '![Figure 13.2 Visualizing the FABRIK algorithm'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.2 可视化FABRIK算法'
- en: '](img/Figure_13.2_B16191.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.2_B16191.jpg)'
- en: 'Figure 13.2: Visualizing the FABRIK algorithm'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：可视化FABRIK算法
- en: Both FABRIK and CCD will try to solve an IK chain, but they converge on the
    goal differently. CCD tends to curl, while FABRIK tends to stretch. FABRIK usually
    generates more natural results for humanoid animation. In the following section,
    you will start to declare the `FABRIKSolver` class, followed by the implementation
    of the class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: FABRIK和CCD都会尝试解决IK链，但它们以不同的方式收敛到目标。CCD倾向于卷曲，而FABRIK倾向于拉伸。FABRIK通常为人形动画生成更自然的结果。在接下来的部分，您将开始声明`FABRIKSolver`类，然后实现该类。
- en: Declaring the FABRIK solver
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明FABRIK求解器
- en: The FABRIK solver will need more memory to run since it has to convert local
    joint transformations into global positions. The algorithm can be broken down
    into several steps that can all be implemented as protected helper functions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: FABRIK求解器将需要更多的内存来运行，因为它必须将本地关节变换转换为全局位置。该算法可以分解为几个步骤，所有这些步骤都可以作为受保护的辅助函数实现。
- en: 'Create a new file, `FABRIKSolver.h`. This file will be used to declare the
    `FABRIKSolver` class. Follow these steps to declare the `FABRIKSolver` class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，`FABRIKSolver.h`。这个文件将用于声明`FABRIKSolver`类。按照以下步骤声明`FABRIKSolver`类：
- en: 'Begin by declaring the `FABRIKSolver` class, which needs to keep track of the
    IK chain, the maximum number of steps, and some distance threshold. Declare a
    vector of world space positions and a vector of joint lengths. These vectors are
    needed because the FABRIK algorithm does not take rotations into account:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先声明`FABRIKSolver`类，该类需要跟踪IK链、最大步数和一些距离阈值。声明一个世界空间位置向量和一个关节长度向量。这些向量是必需的，因为FABRIK算法不考虑旋转：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Declare helper functions to copy the IK chain into the world position vector,
    to iterate forward, to iterate backward, and to copy the final world positions
    back into the IK chain:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明辅助函数，将IK链复制到世界位置向量中，进行正向迭代，进行反向迭代，并将最终的世界位置复制回IK链中：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Declare a default constructor, getter and setter functions for the size of
    the chain, the number of iterations to solve the chain, and the epsilon value
    of how far the end joint needs to be from the target:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明默认构造函数，获取器和设置器函数用于链的大小、解决链所需的迭代次数以及末端关节需要与目标的距离的epsilon值：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Declare getter and setter functions for the local transforms stored in the
    IK chain. Declare a function to retrieve the global transform of a joint. Finally,
    declare the `Solve` function, which solves the IK chain when given a target:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明用于存储IK链中本地变换的获取器和设置器函数。声明一个函数来检索关节的全局变换。最后，声明`Solve`函数，当给定一个目标时解决IK链：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The FABRIK algorithm is a little more complicated to implement than the CCD
    algorithm was, but the steps are easier to break down into functions. In the following
    section, you will start to implement the functions of the `FABRIKSolver` class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: FABRIK算法的实现比CCD算法更复杂，但步骤更容易分解为函数。在接下来的部分，您将开始实现`FABRIKSolver`类的函数。
- en: Implementing the FABRIK solver
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现FABRIK求解器
- en: The FABRIK algorithm works on world space positions. This means, for each iteration,
    the IK chain will need to convert local joint transformations into world positions
    and store the result. After the chain is solved, the world positions vector will
    need to be converted back into relative offsets and stored back in the IK chain.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: FABRIK算法基于世界空间位置。这意味着，每次迭代时，IK链都需要将本地关节变换转换为世界位置并存储结果。解决链条后，世界位置向量需要转换回相对偏移并存储回IK链中。
- en: 'Create a new file, `FABRIKSolver.cpp`; the `FABRIKSolver` class will be implemented
    in this file. Follow these steps to implement the `FABRIKSolver` class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`FABRIKSolver.cpp`；`FABRIKSolver`类将在这个文件中实现。按照以下步骤实现`FABRIKSolver`类：
- en: 'Implement the constructor of the `FABRIKSolver` class. It needs to set the
    number of steps and the threshold to default values:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`FABRIKSolver`类的构造函数。需要将步数和阈值设置为默认值：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement the trivial getter and setter functions for the number of steps and
    the threshold values:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现步数和阈值值的简单getter和setter函数：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Implement a getter and setter function for the size of the chain. The setter
    function needs to set the size of the chain, the world chain, and the lengths''
    vector:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现链条大小的getter和setter函数。setter函数需要设置链条的大小、世界链条和长度向量：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Implement methods for getting and setting the local transform of an element
    in the IK chain:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现获取和设置IK链中元素的本地变换的方法：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement the getter function to retrieve the global transform and concatenate
    all of the transforms to the root:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现获取函数以检索全局变换，并将所有变换连接到根：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Implement the `IKChainToWorld` function, which will copy the IK chain into
    the world transform vector and record the segment lengths. The lengths array stores
    the distance of a joint from its parent. This means that the root joint will always
    contain the length `0`. For non-root joints, the distance at the `i` index is
    the distance between the joints `i` and `i–1`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`IKChainToWorld`函数，将IK链复制到世界变换向量中并记录段长度。长度数组存储了关节与其父节点之间的距离。这意味着根关节将始终包含长度`0`。对于非根关节，索引`i`处的距离是关节`i`和`i-1`之间的距离：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Implement the `WorldToIKChain` function next, which will convert the world
    position IK chain back into local space transforms. Loop through all of the joints.
    For each joint, find the world space transform of the current joint and the next
    one. Cache the world space position and rotation of the current joint:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来实现`WorldToIKChain`函数，它将把世界位置IK链转换回本地空间变换。循环遍历所有关节。对于每个关节，找到当前关节和下一个关节的世界空间变换。缓存当前关节的世界空间位置和旋转：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a vector that points from the current joint to the next one. This is
    the rotation between the current node and the next node:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个向量，指向当前关节到下一个关节的位置。这是当前节点和下一个节点之间的旋转：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Construct a vector that points from the world space IK chain of the next joint
    to the current position. This is the rotation between the current node and the
    desired position of the next node:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造一个向量，指向下一个关节的世界空间IK链到当前位置的位置。这是当前节点和下一个节点之间的旋转：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Align these two vectors by using the `fromTo` quaternion function. Apply the
    final delta rotation to the current joint''s IK chain rotation:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fromTo`四元数函数将这两个向量对齐。将最终的增量旋转应用于当前关节的IK链旋转：
- en: '[PRE30]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, implement the `IterateBackward` function, which sets the last element
    in the chain to be at the goal. This breaks the IK chain. Adjust all other joints
    using the stored distanced so that the chain remains intact. After this function
    executes, the end effector is always at the goal and the initial joint is probably
    no longer at the base:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现`IterateBackward`函数，将链条中的最后一个元素设置为目标位置。这会打破IK链。使用存储的距离调整所有其他关节，以保持链条完整。执行此函数后，末端执行器始终位于目标位置，初始关节可能不再位于基底位置：
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement the `IterateForward` function. This function rearranges the IK chain
    so that the first link starts at the origin of the chain. This function needs
    to set the initial joint to be at the base, and it iterates through all other
    joints, adjusting them to keep the IK chain intact. After this function executes,
    the end effector might be at the goal if the chain is solvable and has sufficient
    iterations:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`IterateForward`函数。此函数重新排列IK链，使第一个链接从链的原点开始。此函数需要将初始关节设置为基底，并迭代所有其他关节，调整它们以保持IK链完整。执行此函数后，如果链条可解并且迭代次数足够，末端执行器可能位于目标位置：
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Start to implement the `Solve` function by copying the IK chain into the world
    positions vector and fill out the lengths vector. This can be done with the `IKChainToWorld`
    helper function. Cache the base and goal positions:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将IK链复制到世界位置向量并填充长度向量来开始实现`Solve`函数。可以使用`IKChainToWorld`辅助函数完成。缓存基础和目标位置：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Iterate from `0` to `mNumSteps`. For each iteration, check whether the goal
    and end effector are close enough for the chain to be solved. If they are, copy
    the world positions back into the chain with the `WorldToIKChain` helper function
    and return early. If they are not close enough, do the iteration by calling the
    `IterateBackward` and `IterateForward` methods:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`0`迭代到`mNumSteps`。对于每次迭代，检查目标和末端执行器是否足够接近以解决链条问题。如果足够接近，则使用`WorldToIKChain`辅助函数将世界位置复制回链条，并提前返回。如果它们不够接近，则通过调用`IterateBackward`和`IterateForward`方法进行迭代：
- en: '[PRE34]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After the iteration loop, copy the world positions vector back into the IK
    chain regardless of whether the solver was able to solve the chain. Check one
    last time whether the end effector has reached its goal, and return the appropriate
    Boolean:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代循环后，无论求解器是否能够解决链条问题，都将世界位置向量复制回IK链。最后再次检查末端执行器是否已经达到目标，并返回适当的布尔值：
- en: '[PRE35]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The FABRIK algorithm is popular because it tends to converge on the end goal
    fast, the results look good for humanoid characters, and the algorithm is easy
    to implement. In the next section, you will learn how to add constraints to either
    the FABRIK or CCD solver.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: FABRIK算法很受欢迎，因为它往往会快速收敛到最终目标，对于人形角色来说结果看起来不错，并且该算法易于实现。在下一节中，您将学习如何向FABRIK或CCD求解器添加约束。
- en: Implementing constraints
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施约束
- en: Both CCD and FABRIK solvers produce good results, but neither produces predictable
    results. In this section, you will learn what constraints are, where the IK solver
    constraints can be applied, and how to apply constraints. This will let you build
    much more realistic IK solvers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: CCD和FABRIK求解器都能产生良好的结果，但都不能产生可预测的结果。在本节中，您将学习约束是什么，IK求解器约束可以应用在哪里，以及如何应用约束。这将让您构建更加逼真的IK求解器。
- en: Consider an IK chain that is supposed to represent a leg. You would want to
    make sure that the motion of each joint is predictable, for example, the knee
    should probably not bend forward.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个应该代表腿的IK链。您希望确保每个关节的运动是可预测的，例如，膝盖可能不应该向前弯曲。
- en: This is where constraints are useful. The knee joint is a hinge; if a hinge
    constraint is applied, the leg IK chain will look more realistic. Using constraints,
    you can set rules for each joint in an IK chain.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是约束有用的地方。膝盖关节是一个铰链；如果应用了铰链约束，腿的IK链看起来会更逼真。使用约束，您可以为IK链中的每个关节设置规则。
- en: 'The following steps will show you where to apply constraints in both the CCD
    and FABRIK solvers:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将向您展示在CCD和FABRIK求解器中应用约束的位置：
- en: 'Constraints can be applied to both CCD and FABRIK solvers, and they must be
    applied after each iteration. For CCD, this means inserting a bit of code here:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 约束可以应用于CCD和FABRIK求解器，并且必须在每次迭代后应用。对于CCD，这意味着在这里插入一小段代码：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Applying constraints to the FABRIK solver is more complex. The constraint is
    applied to each iteration, and the IK chain needs to be converted between the
    world position chain and IK chain on every iteration. Apply constraints every
    iteration after copying the data to the transform chain:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将约束应用于FABRIK求解器更加复杂。约束应用于每次迭代，并且IK链需要在每次迭代时在世界位置链和IK链之间转换。在将数据复制到变换链后，每次迭代都应用约束：
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The reason that the `Solve` function is virtual is so you can extend each of
    the `IKChain` classes into specific types of chains such as `LegIKChain` or `ArmIKChain`
    and add the constraint code to the solve method directly. In the following sections,
    you will explore common types of constraints.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Solve`函数是虚拟的原因是您可以将每个`IKChain`类扩展为特定类型的链，例如`LegIKChain`或`ArmIKChain`，并直接将约束代码添加到解决方法中。在接下来的几节中，您将探索常见类型的约束。'
- en: Ball-and-socket constraint
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 球和插座约束
- en: 'Bal- and-socket joints work like a shoulder joint. The joint can rotate on
    all three axes, but there is an angle constraint preventing it from rotating freely.
    *Figure 13.3* shows what a ball-and-socket constraint looks like visually:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 球和插座关节的工作原理类似于肩关节。关节可以在所有三个轴上旋转，但有一个角度约束阻止它自由旋转。*图13.3*显示了球和插座约束的外观：
- en: '![Figure 13.3 A ball and socket constraint visualized'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3 可视化的球和插座约束'
- en: '](img/Figure_13.3_B16191.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.3_B16191.jpg)'
- en: 'Figure 13.3: A ball-and-socket constraint visualized'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：可视化的球和插座约束
- en: To build a ball-and-socket constraint, you need to know the rotation of both
    the current joint and its parent. You can construct forward vectors from these
    quaternions and check the angle of the forward vectors. If the angle is greater
    than a provided limit, the rotation needs to be adjusted.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建球和插座约束，您需要知道当前关节及其父关节的旋转。您可以从这些四元数构造前向矢量，并检查前向矢量的角度。如果角度大于提供的限制，需要调整旋转。
- en: 'To limit the rotation, find the rotation axis. The cross product between the
    two forward directions is perpendicular to both; this is the rotation axis. Create
    a quaternion that brings the angle limit along this axis into the local space
    of the current joint and set that quaternion to be the rotation of the joint:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制旋转，找到旋转轴。两个前向方向的叉乘垂直于两者；这是旋转轴。创建一个四元数，将角度限制沿着这个轴带入当前关节的局部空间，并将该四元数设置为关节的旋转：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The ball-and-socket constraint is usually applied to the hip or shoulder joints
    of a character. These also tend to be the root joints for the limb IK chains.
    In the next section, you will explore another type of constraint, that is, the
    hinge constraint.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 球和插座约束通常应用于角色的髋部或肩部关节。这些也往往是肢体IK链的根关节。在下一节中，您将探索另一种类型的约束，即铰链约束。
- en: Hinge constraint
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 铰链约束
- en: 'The hinge constraint is like an elbow or a knee. It only allows for rotation
    on one specific axis. *Figure 13.4* demonstrates what a hinge joint looks like
    visually:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '铰链约束类似于肘部或膝盖。它只允许在一个特定轴上旋转。*图13.4*展示了铰链关节的外观： '
- en: '![Figure 13.4 A hinge constraint visualized'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.4 可视化的铰链约束'
- en: '](img/Figure_13.4_B16191.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.4_B16191.jpg)'
- en: 'Figure 13.4: A hinge constraint visualized'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：可视化的铰链约束
- en: 'To implement a hinge constraint, you need to know the world space rotation
    of the current joint and the parent joint. Multiply the axis normal by both rotation
    quaternions and find a quaternion between the two; this is the amount you need
    to rotate to constrain the joint to an axis. Bring this rotation back into the
    joint space and apply the rotation:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要实施铰链约束，您需要知道当前关节和父关节的世界空间旋转。将轴法线分别乘以旋转四元数，并找到两者之间的四元数；这是您需要旋转以约束关节到一个轴的量。将此旋转带回关节空间并应用旋转：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Hinge constraints are often used for elbow or knee joints. In the following
    section, you will explore how to use IK to align a character's feet to the ground.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 铰链约束通常用于肘部或膝盖关节。在下一节中，您将探讨如何使用IK将角色的脚对齐到地面。
- en: Using IK to align a character's feet to the ground
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IK将角色的脚对齐到地面
- en: In this section, you will learn how IK can be used to modify an animation so
    it looks more correct. Specifically, you will learn how to use IK to stop a character's
    feet from going through the ground when walking over uneven surfaces.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用IK来修改动画，使其看起来更加正确。具体来说，您将学习如何使用IK在行走时阻止角色的脚穿过不平整的地面。
- en: Now that you can solve IK chains using CCD or FABRIK, let's explore how these
    solvers can be used. There are two common uses for IK, that is, to position hands
    or to position feet. In this section, you will explore what it takes to clamp
    a character's foot to the ground as the character is walking.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用CCD或FABRIK来解决IK链，让我们探讨这些求解器如何使用。IK的两个常见用途是定位手部或脚部。在本节中，您将探讨在角色行走时如何将角色的脚夹紧在地面上的方法。
- en: 'To solve foot clamping, you could check the last global position of the foot
    against the current global position. If the foot motion hits anything on the way,
    pin the foot to the ground. Even the most trivial solutions have edge cases: what
    happens if the up motion is too far away? At what point in the animation cycle
    can we interpolate between pinned and non-pinned positions?'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 解决脚部夹紧问题，可以检查脚的最后全局位置与当前全局位置是否相符。如果脚部运动在途中碰到任何东西，就将脚固定在地面上。即使最琐碎的解决方案也有边缘情况：如果上升运动距离太远会发生什么？在动画循环的哪个时刻可以在固定和非固定位置之间进行插值？
- en: To make implementation easier, the ground clamping strategy for this chapter
    will remain simple. First, check whether the foot is colliding with anything above
    it, clipping through the terrain, for example. To do this, cast a ray from the
    hip of the character to the ankle.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使实现更容易，本章的地面夹紧策略将保持简单。首先，检查脚部是否与其上方的任何东西发生碰撞，例如穿过地形。为此，从角色的臀部到脚踝投射一条射线。
- en: If the ray hits anything, the hit point will be the goal of the leg IK chain.
    If the ray does not hit anything, the current position of the character's ankle
    will be the goal of the leg IK chain. Next, do the same ray cast, but do not stop
    at the ankle of the character; just keep going.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果射线击中了任何东西，击中点将成为腿部IK链的目标。如果射线没有击中任何东西，则角色脚踝的当前位置将成为腿部IK链的目标。接下来，进行相同的射线投射，但不要停在角色的脚踝处；继续向下。
- en: If this ray hits anything, the hit point is a future IK goal. If the ray does
    not hit anything, set the future IK goal to the current IK goal. Now there are
    two goals, one that's in free motion and one that's pinned to the ground.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这条射线击中了任何东西，击中点将成为未来的IK目标。如果射线没有击中任何东西，则将未来的IK目标设置为当前的IK目标。现在有两个目标，一个自由运动，一个固定在地面上。
- en: If you use the current goal, the feet of the character might snap to the ground
    abruptly. If you use the future goal, the character won't walk—it will just drag
    its feet on the ground. Instead, you have to interpolate between the two goals
    by some value.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用当前目标，角色的脚可能会突然贴在地面上。如果使用未来目标，角色将无法行走——它只会在地面上拖着脚。相反，您必须通过某个值在两个目标之间进行插值。
- en: The interpolation value should come from the animation itself. When the character's
    foot is down, the current goal should be used; when it's up, the future goal should
    be used. As the character's foot is being placed up or down, the goal position
    should `lerp`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 插值值应该来自动画本身。当角色的脚着地时，应使用当前目标；当脚抬起时，应使用未来目标。当角色的脚被抬起或放下时，目标位置应该进行插值。
- en: With the IK goal known, the IK solver can figure out how to bend the character's
    leg. Once the leg joints are in world space, we adjust the head of the foot to
    always be on the terrain following some similar steps as you did to solve the
    legs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有了IK目标后，IK求解器可以计算出如何弯曲角色的腿。一旦腿部关节处于世界空间中，我们就调整脚的位置，使其始终在地形上，采取与解决腿部相似的步骤。
- en: In the following sections, you will explore each of the steps described here
    in more detail. However, there is a bit of a catch. Most of the values that are
    needed are specific to the model that is being used for rendering; a different
    character will need values tuned differently.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将更详细地探讨这里描述的每个步骤。然而，有一个小问题。大部分需要的值都是特定于用于渲染的模型的；不同的角色将需要不同调整的值。
- en: Finding the foot goals
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找脚的目标
- en: 'Cast a ray straight down from a bit below the hip of the character to a bit
    below the ankle. This ray cast should go straight down, following the position
    of the ankle. However, how far under the hit the ray should start and how far
    below the ankle it should go are model-specific:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从角色的臀部下方一点到脚踝下方一点向下投射一条射线。这条射线应该直直地向下，沿着脚踝的位置。然而，射线应该从哪里开始，脚踝下方应该走多远，这取决于模型的具体情况：
- en: '![Figure 13.5 Ray cast to find the foot goal'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.5 射线投射以找到脚的目标'
- en: '](img/Figure_13.5_B16191.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.5_B16191.jpg)'
- en: 'Figure 13.5: Ray cast to find the foot goal'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5：射线投射以找到脚的目标
- en: Record the result of this ray cast regardless of how far away the hit point
    is. This point will be treated as the IK goal, which is always clamped to the
    ground. Check whether the ray has hit anything between its origin and the bottom
    of the ankle. If it did, that will be the ankle goal. If it did not, the ankle
    goal will be the position of the ankle.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 记录这条射线投射的结果，无论击中点有多远。这一点将被视为IK目标，始终被夹紧在地面上。检查射线是否击中了其起点和脚踝底部之间的任何东西。如果击中了，那将是脚踝的目标。如果没有击中，脚踝的目标将是脚踝的位置。
- en: 'It is important to keep in mind that the character''s ankle is being positioned,
    not the bottom of its foot. Therefore, the goal point needs to be moved up by
    the distance of the ankle to the floor:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，定位的是角色的脚踝，而不是脚底。因此，目标点需要上移脚踝到地面的距离：
- en: '![Figure 13.6 Offset to position the character''s ankle'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.6 偏移以定位角色的脚踝'
- en: '](img/Figure_13.6_B16191.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.6_B16191.jpg)'
- en: 'Figure 13.6: Offset to position the character''s ankle'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：偏移以定位角色的脚踝
- en: These foot goals will control how the IK system overrides the animation. When
    walking, and if the foot motion is not obstructed, the IK system should not be
    noticeable. In the next section, you will learn how to control the interpolation
    of the foot between the animated and the pinned goal points.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚部目标将控制IK系统如何覆盖动画。在行走时，如果脚部运动没有受到阻碍，IK系统就不应该被注意到。在下一节中，您将学习如何控制脚部在动画和固定目标点之间的插值。
- en: Interpolating the foot goals
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插值脚部目标
- en: To interpolate between the current and future IK goals, you will need some knowledge
    of the animation clip that is currently playing. Specifically, you need to know
    what phase the leg is in; is it grounded, being lifted, suspended, or being placed?
    A common way to encode this information is with a scalar curve.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在当前和未来的IK目标之间进行插值，您需要了解当前播放的动画片段。具体来说，您需要知道腿处于什么阶段；它是着地的，被抬起的，悬停的，还是被放置的？编码这些信息的常见方法是使用标量曲线。
- en: 'The idea is to create two scalar curves, one for the left and one for the right
    leg. These curves correspond to the stride of the current step. For example, when
    the left foot is off the ground, the value of the left scalar curve needs to be
    0\. If the left foot is on the ground, the value of the left curve needs to be
    1\. The curve looks like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是创建两条标量曲线，一条用于左腿，一条用于右腿。这些曲线对应于当前步伐的幅度。例如，当左脚离开地面时，左曲线的值需要为0。如果左脚着地，左曲线的值需要为1。曲线看起来像这样：
- en: '![Figure 13.7 Walk cycle stride expressed as scalar curves'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.7 步行循环幅度表示为标量曲线'
- en: '](img/Figure_13.7_B16191.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.7_B16191.jpg)'
- en: 'Figure 13.7: Walk cycle stride expressed as scalar curves'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7：步行循环幅度表示为标量曲线
- en: Sample these curves based on the current normalized playback time. The resulting
    value will be between 0 and 1\. Use this 0 to 1 value as the blend weight when
    blending the non-IK adjusted animation and the IK adjusted animation together.
    This curve is usually authored by eye using a curve editor. The curve is specific
    to the animation that is currently playing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前的归一化播放时间对这些曲线进行采样。结果值将在0和1之间。使用这个0到1的值作为混合权重，将非IK调整的动画和IK调整的动画混合在一起。这条曲线通常是通过使用曲线编辑器进行手动编写的。该曲线是特定于当前播放的动画的。
- en: In the next section, you will explore how to adjust the vertical placement of
    the IK character to avoid hyperextending limbs.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将探讨如何调整IK角色的垂直位置，以避免过度伸展肢体。
- en: Vertical character placement
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垂直角色定位
- en: 'Next, the character needs to be positioned vertically so that it looks good.
    If the character is placed too far up, it would end up with the legs in a hyperextended
    state. Too low, and the IK system will bend the legs too much:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，角色需要垂直定位，以便看起来好看。如果角色放得太高，它会以过度伸展的状态结束。太低，IK系统会过度弯曲腿：
- en: '![Figure 13.8 IK hyperextension compared to sampled animation'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.8 IK过度伸展与采样动画比较'
- en: '](img/Figure_13.8_B16191.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.8_B16191.jpg)'
- en: 'Figure 13.8: IK hyperextension compared to sampled animation'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8：IK过度伸展与采样动画比较
- en: How the character is positioned is relative to how it was modeled. If the character
    was modeled assuming (0, 0, 0) is the center point on the ground, you can place
    it right on the surface below, and sink it into the surface just a bit.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 角色的定位是相对于建模时的情况。如果角色是在假定（0, 0, 0）是地面上的中心点进行建模的，您可以将其放在下方的表面上，并将其稍微陷入表面。
- en: 'The character needs to be sunk into the surface a little bit to allow the IK
    system to do some work and avoid hyperextension. This raises the question: what
    is the surface that the character''s feet need to be aligned with? The alignment
    position can come from a collision/physics system, or in a simpler example, just
    a ray cast going straight down from the character.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 角色需要稍微陷入表面，以便IK系统能够进行一些工作并避免过度伸展。这带来了一个问题：角色的脚需要与哪个表面对齐？对齐位置可以来自碰撞/物理系统，或者在一个更简单的例子中，只是从角色正下方向下进行射线投射。
- en: 'Collision surfaces and visual surfaces are not the same. Consider a staircase:
    the collision geometry is usually a ramp. The display geometry is what looks like
    an actual staircase. In a situation like this, the character''s position should
    be relative to the collision geometry, but the IK goals should be positioned in
    relation to the visual geometry.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞表面和视觉表面并不相同。考虑一个楼梯：碰撞几何通常是一个坡道。显示几何是看起来像实际楼梯的样子。在这种情况下，角色的位置应该是相对于碰撞几何的，但IK目标应该是相对于视觉几何定位的。
- en: What if there is only one geometry used for both collisions and visuals? In
    this scenario, place the character to either of the clamped IK goals, whichever
    one is lower. This will ensure that the ground is always reachable without hyperextension.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只有一个几何用于碰撞和视觉，该怎么办？在这种情况下，将角色放置在夹紧的IK目标之一，无论哪一个更低。这将确保地面始终可以到达，而不会过度伸展。
- en: IK pass
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IK传递
- en: It's time to solve the leg IK chain. Before doing this, copy joints from the
    animated pose into the IK solver. For each leg, copy the global transform of the
    hip joint into the root of the IK solver. Copy the local transform of the knee
    into joint 1, and the local transform of the ankle into joint 2\. Then, run the
    IK solver. The solver will place the character's feet at the goal points, which
    are clamped to the ground.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是解决腿部IK链的时候了。在这之前，将动画姿势中的关节复制到IK求解器中。对于每条腿，将髋关节的全局变换复制到IK求解器的根部。将膝盖的局部变换复制到关节1，将脚踝的局部变换复制到关节2。然后，运行IK求解器。求解器将把角色的脚放在目标点上，并将其夹紧在地面上。
- en: Foot alignment
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚部对齐
- en: 'The clamped foot animation is smooth at this point, and the feet will no longer
    clip inside the ground. But only the leg of the character looks correct, not the
    feet. Take a look at the foot of a character on a non-flat surface—there is still
    a decent amount of clipping happening:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，夹紧的脚部动画是平滑的，脚部将不再在地面内部剪切。但是只有角色的腿看起来正确，而脚没有。看看角色在非平坦表面上的脚部-仍然有相当多的剪切发生：
- en: '![Figure 13.9 The leg is clamped to the ground, but the foot is oriented wrong'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.9：腿被夹紧到地面，但脚的方向错误'
- en: '](img/Figure_13.9_B16191.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.9_B16191.jpg)'
- en: 'Figure 13.9: The leg is clamped to the ground, but the foot is oriented wrong'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9：腿被夹紧到地面，但脚的方向错误
- en: 'To solve this, create a toe ray. The toe ray will be positioned at the ankle
    joint of the character, and some distance along the forward axis of the character.
    This will ensure that the toe target is always looking forward, even if, in the
    animation, the toe is pointing down. Adjust the vertical position of the toe ray
    to shoot from above the knee to a little below the toe:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，创建一个脚尖射线。脚尖射线将位于角色的踝关节处，并沿着角色的前向轴一定距离。这将确保脚尖目标始终朝前，即使在动画中脚尖指向下。调整脚尖射线的垂直位置，使其从膝盖上方射到脚尖以下一点的位置：
- en: '![Figure 13.10 To cast the offset forward, even if the toe points down'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.10：即使脚尖朝下，也要向前投射偏移'
- en: '](img/Figure_13.10_B16191.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.10_B16191.jpg)'
- en: 'Figure 13.10: To cast the offset forward, even if the toe points down'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10：即使脚尖朝下，也要向前投射偏移
- en: Position the toe similar to how the leg was positioned. Find a goal that is
    the position of the current toe, clamped to the ground. Interpolate between the
    ground clamped goal and the active animation goal by the current normalized time
    of the animation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚尖定位类似于腿的定位。找到一个目标，即当前脚尖的位置，被夹紧到地面上。通过动画的当前归一化时间在夹紧到地面的目标和活动动画目标之间插值。
- en: This toe goal will be used to rotate the foot. Find a vector from the ankle
    to the current toe position. Find a vector from the ankle to the goal toe position.
    Create a quaternion that rotates between these two vectors. Rotate the ankle by
    this quaternion.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚尖目标将用于旋转脚。找到从踝到当前脚尖位置的向量。找到从踝到目标脚尖位置的向量。创建一个在这两个向量之间旋转的四元数。用这个四元数旋转踝部。
- en: In this section, you learned how to find foot goals, interpolate between them,
    and use those goals and the IK system to align a character's feet to the ground.
    Ground alignment is just one of the use cases for IK solvers. Similar systems
    can be used with arms to grab things or the whole body to create a ragdoll system.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何找到脚目标，在它们之间插值，并使用这些目标和IK系统将角色的脚对齐到地面。地面对齐只是IK求解器的用例之一。类似的系统可以用于手臂抓取物体或整个身体创建一个布娃娃系统。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you implemented CCD and FABRIK IK solvers. Both solvers can
    solve an IK chain, but they converge differently. Which algorithm works better
    is very much context-dependent.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您实现了CCD和FABRIK IK求解器。这两个求解器都可以解决IK链，但它们的收敛方式不同。哪种算法更好很大程度上取决于上下文。
- en: You also learned how constraints can be used to limit the range of motion for
    a specific joint. With the right constraints in place, an IK system modifies the
    current animation so that it interacts with the environment. You explored how
    to achieve this in the feet grounding section of this chapter.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学习了如何使用约束来限制特定关节的运动范围。通过正确的约束，IK系统修改当前动画，使其与环境互动。您探讨了如何在本章的脚着地部分实现这一点。
- en: In the downloadable content for this book, there are 4 samples for this chapter.
    `Sample00` contains the code up to this point. `Sample01` demonstrates how a CCD
    solver can be used, and `Sample02` demonstrates how a FABRIK solver can be used.
    `Sample03` demonstrates foot clamping and ground alignment for a character walking
    along a path.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的可下载内容中，本章有4个样本。`Sample00` 包含到目前为止的代码。`Sample01` 演示了如何使用CCD求解器，`Sample02`
    演示了如何使用FABRIK求解器。`Sample03` 演示了角色沿着路径行走时的脚夹和地面对齐。
- en: In the next chapter, you will learn how dual quaternions can be used for skinning.
    Dual quaternion skinning better maintains the volume of a mesh than linear blended
    skinning when the mesh is bent or rotated.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使用双四元数进行蒙皮。当网格弯曲或旋转时，双四元数蒙皮比线性混合蒙皮更好地保持了网格的体积。
- en: Further reading
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Other than FABRIK and CCD, IK chains are sometimes solved analytically or with
    Jacobian matrices:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 除了FABRIK和CCD，IK链有时会用解析方法或雅可比矩阵来求解：
- en: For more [info on analytical IK solvers, check out htt](http://theorangeduck.com/page/simple-two-joint)p://theorangeduck.com/page/simple-two-joint.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关分析IK求解器的更多信息，请访问[此处](http://theorangeduck.com/page/simple-two-joint)。
- en: A complete Jacobian solver implementation is covered in *Game Programming Gems
    4*.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的雅可比求解器实现在*游戏编程宝石4*中有介绍。
