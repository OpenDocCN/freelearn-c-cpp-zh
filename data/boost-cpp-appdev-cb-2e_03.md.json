["```cpp\n#include <sstream> \n\nvoid sample1() {\n    std::istringstream iss(\"100\");\n    int i;\n    iss >> i;\n\n    // ...\n}\n```", "```cpp\n#include <cstdlib> \n\nvoid sample2() {\n    char * end;\n    const int i = std::strtol (\"100\", &end, 10);\n\n    // ...\n}\n```", "```cpp\n#include <boost/lexical_cast.hpp> \n\nvoid sample3() {\n    const int i = boost::lexical_cast<int>(\"100\");\n    // ...\n}\n```", "```cpp\n#include <boost/lexical_cast.hpp>\n\nvoid sample4() {\n    char chars[] = {'x', '1', '0', '0', 'y' }; \n    const int i = boost::lexical_cast<int>(chars + 1, 3); \n    assert(i == 100); \n}\n```", "```cpp\n#include <boost/lexical_cast.hpp>\n#include <iostream>\n\nvoid sample5() {\n    try {\n        // short usually may not store values greater than 32767\n        const short s = boost::lexical_cast<short>(\"1000000\");\n        assert(false); // Must not reach this line.\n    } catch (const boost::bad_lexical_cast& e) {\n        std::cout << e.what() << '\\n';\n    }\n}\n```", "```cpp\nbad lexical cast: source type value could not be interpreted as target.\n```", "```cpp\n#include <boost/lexical_cast.hpp>\n#include <iostream>\n\nvoid sample6() {\n    try {\n        const int i = boost::lexical_cast<int>(\"This is not a number!\");\n        assert(false); // Must not reach this line.\n    } catch (const boost::bad_lexical_cast& /*e*/) {}\n}\n```", "```cpp\n#include <boost/lexical_cast.hpp>\n#include <cassert>\n\nvoid sample7() {\n    int i = 0;\n    const bool ok = boost::conversion::try_lexical_convert(\"Bad stuff\", i);\n    assert(!ok);\n}\n```", "```cpp\n#include <boost/lexical_cast.hpp>\n#include <locale> \n\nvoid sample8() {\n    try {\n        std::locale::global(std::locale(\"ru_RU.UTF8\"));\n        // In Russia coma sign is used as a decimal separator.\n        float f = boost::lexical_cast<float>(\"1,0\");\n        assert(f < 1.01 && f > 0.99);\n        std::locale::global(std::locale::classic()); // Restoring C locale\n    } catch (const std::runtime_error&) { /* locale is not supported */ }\n} \n```", "```cpp\n#include <cassert>\n#include <boost/lexical_cast.hpp> \n\nvoid lexical_cast_example() {\n    const std::string s = boost::lexical_cast<std::string>(100);\n    assert(s == \"100\");\n}\n```", "```cpp\n#include <cassert>\n#include <sstream> \n\nvoid cpp_convert_example() {\n    std::stringstream ss;  // Slow/heavy default constructor.\n    ss << 100;\n    std::string s;\n    ss >> s;\n\n    // Variable 'ss' will dangle all the way, till the end\n    // of scope. Multiple virtual methods and heavy \n    // operations were called during the conversion.\n    assert(s == \"100\");\n}\n```", "```cpp\n#include <cassert>\n#include <cstdlib> \n\nvoid c_convert_example() {\n     char buffer[100];\n     std::sprintf(buffer, \"%i\", 100);\n\n     // You will need an unsigned long long int type to \n     // count how many times errors were made in 'printf' \n     // like functions all around the world. 'printf' \n     // functions are a constant security threat! \n\n     // But wait, we still need to construct a std::string.\n     const std::string s = buffer;\n     // Now we have a 'buffer' variable that is not used.\n\n     assert(s == \"100\");\n}\n```", "```cpp\nvoid some_function(unsigned short param); \nint foo(); \n\nvoid do_something() {\n    // Some compilers may warn, that int is being converted to  \n    // unsigned short and that there is a possibility of loosing  \n    // data.\n    some_function(foo());\n} \n```", "```cpp\n// Warning suppressed.\nsome_function( \n    static_cast<unsigned short>(foo()) \n); \n```", "```cpp\n// Returns -1 if error occurred.\nint foo() { \n    if (some_extremely_rare_condition()) { \n        return -1; \n    } else if (another_extremely_rare_condition()) { \n        return 1000000; \n    } \n    return 42; \n}\n```", "```cpp\n#include <boost/numeric/conversion/cast.hpp> \n\nvoid correct_implementation() { \n    // 100% correct.\n    some_function( \n        boost::numeric_cast<unsigned short>(foo()) \n    ); \n} \n\nvoid test_function() {\n    for (unsigned int i = 0; i < 100; ++i) {\n        try {\n            correct_implementation();\n        } catch (const boost::numeric::bad_numeric_cast& e) {\n            std::cout << '#' << i << ' ' << e.what() << std::endl;\n        }\n    }\n}\n```", "```cpp\n#47 bad numeric conversion: negative overflow \n#58 bad numeric conversion: positive overflow \n```", "```cpp\nvoid test_function1() { \n   for (unsigned int i = 0; i < 100; ++i) { \n       try { \n           correct_implementation(); \n       } catch (const boost::numeric::positive_overflow& e) { \n           // Do something specific for positive overflow. \n           std::cout << \"POS OVERFLOW in #\" << i << ' '\n                     << e.what() << std::endl; \n       } catch (const boost::numeric::negative_overflow& e) { \n           // Do something specific for negative overflow. \n           std::cout <<\"NEG OVERFLOW in #\" << i << ' '\n                     << e.what() << std::endl; \n       } \n   } \n} \n```", "```cpp\nNEG OVERFLOW in #47 bad numeric conversion: negative overflow \nPOS OVERFLOW in #59 bad numeric conversion: positive overflow \n```", "```cpp\ntemplate <class SourceT, class TargetT> \nstruct mythrow_overflow_handler {\n    void operator() (boost::numeric::range_check_result r) { \n        if (r != boost::numeric::cInRange) { \n            throw std::logic_error(\"Not in range!\"); \n        } \n    } \n}; \n\ntemplate <class TargetT, class SourceT> \nTargetT my_numeric_cast(const SourceT& in) { \n    typedef boost::numeric::conversion_traits<\n        TargetT, SourceT\n    > conv_traits; \n    typedef boost::numeric::converter < \n        TargetT, \n        SourceT, \n        conv_traits, // default conversion traits\n        mythrow_overflow_handler<SourceT, TargetT> // !!! \n    > converter; \n\n    return converter::convert(in); \n} \n```", "```cpp\nvoid example_with_my_numeric_cast() {\n    short v = 0;\n    try {\n        v = my_numeric_cast<short>(100000);\n    } catch (const std::logic_error& e) {\n        std::cout << \"It works! \" << e.what() << std::endl;\n    }\n}\n```", "```cpp\nIt works! Not in range!\n```", "```cpp\n#include <iostream>\n#include <stdexcept>\n\n// Negative number that does not store minus sign.\nclass negative_number {\n    unsigned short number_; \n\npublic:\n    explicit negative_number(unsigned short number = 0)\n        : number_(number)\n    {} \n\n    // ...\n    unsigned short value_without_sign() const {\n        return number_;\n    }\n}; \n\ninline std::ostream&\n    operator<<(std::ostream& os, const negative_number& num)\n{\n    os << '-' << num.value_without_sign();\n    return os;\n}\n\ninline std::istream& operator>>(std::istream& is, negative_number& num)\n{\n    char ch;\n    is >> ch;\n    if (ch != '-') {\n        throw std::logic_error(\n            \"negative_number class stores ONLY negative values\"\n        );\n    }\n\n    unsigned short s;\n    is >> s;\n    num = negative_number(s);\n    return is;\n}\n```", "```cpp\n#include <boost/lexical_cast.hpp>\n#include <boost/array.hpp>\n#include <cassert>\n\nvoid example1() {\n    const negative_number n\n        = boost::lexical_cast<negative_number>(\"-100\");\n    assert(n.value_without_sign() == 100);\n\n    const int i = boost::lexical_cast<int>(n);\n    assert(i == -100);\n\n    typedef boost::array<char, 10> arr_t;\n    const arr_t arr = boost::lexical_cast<arr_t>(n);\n    assert(arr[0] == '-');\n    assert(arr[1] == '1');\n    assert(arr[2] == '0');\n    assert(arr[3] == '0');\n    assert(arr[4] == 0);\n} \n```", "```cpp\ntemplate <class CharT> \nstd::basic_ostream<CharT>& \n    operator<<(std::basic_ostream<CharT>& os, const negative_number& num)\n{ \n    os << static_cast<CharT>('-') << num.value_without_sign(); \n    return os; \n} \n\ntemplate <class CharT> \nstd::basic_istream<CharT>& \n    operator>>(std::basic_istream<CharT>& is, negative_number& num)\n{ \n    CharT ch; \n    is >> ch; \n    if (ch != static_cast<CharT>('-')) { \n        throw std::logic_error(\n            \"negative_number class stores ONLY negative values\"\n        ); \n    } \n    unsigned short s; \n    is >> s; \n    num = negative_number(s); \n    return is; \n} \n\nvoid example2() { \n    const negative_number n = boost::lexical_cast<negative_number>(L\"-1\"); \n    assert(n.value_without_sign() == 1); \n\n    typedef boost::array<wchar_t, 10> warr_t; \n    const warr_t arr = boost::lexical_cast<warr_t>(n); \n    assert(arr[0] == L'-'); \n    assert(arr[1] == L'1'); \n    assert(arr[2] == 0); \n} \n```", "```cpp\nstruct base {\n    virtual void some_methods() = 0;\n    virtual ~base();\n};\n\nstruct derived: public base {\n    void some_methods() /*override*/;\n    virtual void derived_method() const;\n\n    ~derived() /*override*/;\n};\n```", "```cpp\n#include <boost/shared_ptr.hpp>\nboost::shared_ptr<const base> construct_derived();\nvoid im_accepting_derived(boost::shared_ptr<const derived> p);\n```", "```cpp\nvoid trying_hard_to_pass_derived() {\n    boost::shared_ptr<const base> d = construct_derived();\n\n    // Oops! Compile time error:\n    // \u2018const struct base; has no member named \u2018derived_method;.\n    d->derived_method();\n\n    // Oops! Compile time error:\n    // could not convert \u2018d; to \u2018boost::shared_ptr<const derived>;.\n    im_accepting_derived(d);\n}\n```", "```cpp\nvoid trying_hard_to_pass_derived2() {\n    boost::shared_ptr<const derived> d\n        = boost::dynamic_pointer_cast<const derived>(\n            construct_derived()\n        );\n\n    if (!d) {\n        throw std::runtime_error(\n            \"Failed to dynamic cast\"\n        );\n    }\n\n    d->derived_method();\n    im_accepting_derived(d);\n} \n```", "```cpp\nstruct object { \n    virtual ~object() {} \n}; \n\nstruct banana: public object { \n    void eat() const {} \n    virtual ~banana(){} \n}; \n\nstruct penguin: public object { \n    bool try_to_fly() const {\n        return false; // penguins do not fly\n    }\n    virtual ~penguin(){} \n}; \n\nobject* try_produce_banana(); \n```", "```cpp\nvoid try_eat_banana_impl1() { \n    const object* obj = try_produce_banana(); \n    if (!obj) { \n        throw std::bad_cast(); \n    } \n    dynamic_cast<const banana&>(*obj).eat(); \n} \n```", "```cpp\n#include <boost/cast.hpp> \n\nvoid try_eat_banana_impl2() { \n    const object* obj = try_produce_banana(); \n    boost::polymorphic_cast<const banana*>(obj)->eat(); \n} \n```", "```cpp\nYYYY-MM-DD \n```", "```cpp\n2013-03-01 \n2012-12-31  // (woo-hoo, it almost a new year!) \n```", "```cpp\n   date-fullyear   = 4DIGIT \n   date-month      = 2DIGIT  ; 01-12 \n   date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on \n                             ; month/year \n   full-date       = date-fullyear \"-\" date-month \"-\" date-mday \n```", "```cpp\n#include <boost/spirit/include/qi.hpp>\n#include <boost/spirit/include/phoenix_core.hpp>\n#include <boost/spirit/include/phoenix_operator.hpp>\n#include <cassert>\n```", "```cpp\nstruct date {\n    unsigned short year;\n    unsigned short month;\n    unsigned short day;\n};\n```", "```cpp\n// See recipe \"Type 'reference to string'\" for a better type\n// than std::string for parameter 's'\ndate parse_date_time1(const std::string& s) {\n    using boost::spirit::qi::_1;\n    using boost::spirit::qi::ushort_;\n    using boost::spirit::qi::char_;\n    using boost::phoenix::ref;\n\n    date res;\n    const char* first = s.data();\n    const char* const end = first + s.size();\n    const bool success = boost::spirit::qi::parse(first, end,\n\n        // Implementation of 'full-date' rule from EBNF grammar.\n        ushort_[ ref(res.year) = _1 ] >> char_('-')\n           >> ushort_[ ref(res.month) = _1 ] >> char_('-')\n           >> ushort_[ ref(res.day) = _1 ]\n\n    ); \n\n    if (!success || first != end) {\n        throw std::logic_error(\"Parsing failed\");\n    }\n    return res;\n}\n```", "```cpp\nint main() {\n    const date d = parse_date_time1(\"2017-12-31\");\n    assert(d.year == 2017);\n    assert(d.month == 12);\n    assert(d.day == 31);\n}\n```", "```cpp\nconst bool success = boost::spirit::qi::parse(first, end, \n     ushort_ >> char_('-') >> ushort_ >> char_('-') >> ushort_ \n); \n```", "```cpp\ndate-fullyear \"-\" date-month \"-\" date-md \n```", "```cpp\nconst auto y = [&res](unsigned short s) { res.year = s; };\n// ...\n\nushort_[y] >> char_('-') >> // ...\n```", "```cpp\nushort_[ ref(res.month) = _1 ] \n```", "```cpp\ndate parse_date_time2(const std::string& s) { \n    using boost::spirit::qi::_1; \n    using boost::spirit::qi::uint_parser; \n    using boost::spirit::qi::char_; \n    using boost::phoenix::ref; \n\n    date res; \n\n    // Use unsigned short as output type; require Radix 10 and\n    // from 2 to 2 digits.\n    uint_parser<unsigned short, 10, 2, 2> u2_; \n\n    // Use unsigned short as output type; require Radix 10 and\n    // from 4 to 4 digits.\n    uint_parser<unsigned short, 10, 4, 4> u4_; \n\n    const char* first = s.data(); \n    const char* const end = first + s.size(); \n    const bool success = boost::spirit::qi::parse(first, end, \n\n        u4_ [ ref(res.year) = _1 ] >> char_('-') \n            >> u2_ [ ref(res.month) = _1 ] >> char_('-')\n            >> u2_ [ ref(res.day) = _1 ] \n\n    ); \n    if (!success || first != end) { \n        throw std::logic_error(\"Parsing failed\"); \n    } \n    return res; \n} \n```", "```cpp\n// Header file.\n#ifndef MY_PROJECT_PARSE_DATE_TIME\n#define MY_PROJECT_PARSE_DATE_TIME\n\n#include <string>\n\nstruct date { \n    unsigned short year; \n    unsigned short month; \n    unsigned short day; \n}; \n\ndate parse_date_time2(const std::string& s);\n\n#endif // MY_PROJECT_PARSE_DATE_TIME\n```", "```cpp\ndate parse_date_time2_cxx(const std::string& s) {\n    using boost::spirit::qi::uint_parser; \n    using boost::spirit::qi::char_; \n\n    date res; \n\n    uint_parser<unsigned short, 10, 2, 2> u2_; \n    uint_parser<unsigned short, 10, 4, 4> u4_; \n\n    const auto y = [&res](unsigned short s) { res.year = s; };\n    const auto m = [&res](unsigned short s) { res.month = s; };\n    const auto d = [&res](unsigned short s) { res.day = s; };\n\n    const char* first = s.data(); \n    const char* const end = first + s.size();\n    const bool success = boost::spirit::qi::parse(first, end, \n        u4_[y] >> char_('-') >> u2_[m] >> char_('-') >> u2_[d] \n    );\n\n    if (!success || first != end) { \n        throw std::logic_error(\"Parsing failed\"); \n    } \n    return res;\n}\n```", "```cpp\n2012-10-20T10:00:00Z      // date time with zero zone offset \n2012-10-20T10:00:00       // date time without zone offset \n2012-10-20T10:00:00+09:15 // date time with zone offset \n2012-10-20-09:15          // date time with zone offset \n10:00:09+09:15            // time with zone offset \n```", "```cpp\n#include <stdexcept>\n#include <cassert>\n\nstruct datetime {\n    enum zone_offsets_t {\n        OFFSET_NOT_SET,\n        OFFSET_Z,\n        OFFSET_UTC_PLUS,\n        OFFSET_UTC_MINUS\n    };\n\nprivate:\n    unsigned short year_;\n    unsigned short month_;\n    unsigned short day_;\n\n    unsigned short hours_;\n    unsigned short minutes_;\n    unsigned short seconds_;\n\n    zone_offsets_t zone_offset_type_;\n    unsigned int zone_offset_in_min_;\n\n    static void dt_assert(bool v, const char* msg) {\n        if (!v) {\n            throw std::logic_error(\n                \"Assertion failed in datetime: \" + std::string(msg)\n            );\n        }\n    }\n\npublic:\n    datetime()\n        : year_(0), month_(0), day_(0)\n        , hours_(0), minutes_(0), seconds_(0)\n        , zone_offset_type_(OFFSET_NOT_SET), zone_offset_in_min_(0)\n    {}\n\n    // Getters: year(), month(), day(), hours(), minutes(),\n    // seconds(), zone_offset_type(), zone_offset_in_min()\n    // ...\n\n    // Setters: set_year(unsigned short), set_day(unsigned short), ...\n    //\n    // void set_*(unsigned short val) {\n    //     Some dt_assert.\n    //     Setting the '*_' to 'val'.\n    // }\n    // ...\n\n}; \n```", "```cpp\nvoid set_zone_offset(datetime& dt, char sign, unsigned short hours\n    , unsigned short minutes)\n{\n    dt.set_zone_offset(\n        sign == '+'\n        ? datetime::OFFSET_UTC_PLUS\n        : datetime::OFFSET_UTC_MINUS\n    );\n    dt.set_zone_offset_in_min(hours * 60 + minutes);\n}\n```", "```cpp\n// Default includes for Boost.Spirit.\n#include <boost/spirit/include/qi.hpp>\n#include <boost/spirit/include/phoenix_core.hpp>\n#include <boost/spirit/include/phoenix_operator.hpp>\n\n// We'll use bind() function from Boost.Spirit,\n// because it interates better with parsers.\n#include <boost/spirit/include/phoenix_bind.hpp>\n\ndatetime parse_datetime(const std::string& s) {\n    using boost::spirit::qi::_1;\n    using boost::spirit::qi::_2;\n    using boost::spirit::qi::_3;\n    using boost::spirit::qi::uint_parser;\n    using boost::spirit::qi::char_;\n    using boost::phoenix::bind;\n    using boost::phoenix::ref;\n\n    datetime ret;\n\n    // Use unsigned short as output type; require Radix 10 and\n    // from 2 to 2 digits.\n    uint_parser<unsigned short, 10, 2, 2> u2_;\n\n    // Use unsigned short as output type; require Radix 10 and\n    // from 4 to 4 digits.\n    uint_parser<unsigned short, 10, 4, 4> u4_;\n\n    boost::spirit::qi::rule<const char*, void()> timezone_parser\n        = -( // unary minus means optional rule\n\n            // Zero offset\n            char_('Z')[ bind(\n                &datetime::set_zone_offset, &ret, datetime::OFFSET_Z\n            ) ]\n\n            | // OR\n\n            // Specific zone offset\n            ((char_('+')|char_('-')) >> u2_ >> ':' >> u2_) [\n                bind(&set_zone_offset, ref(ret), _1, _2, _3)\n            ]\n        );\n```", "```cpp\n    boost::spirit::qi::rule<const char*, void()> date_parser =\n           u4_ [ bind(&datetime::set_year, &ret, _1) ] >> '-'\n        >> u2_ [ bind(&datetime::set_month, &ret, _1) ] >> '-'\n        >> u2_ [ bind(&datetime::set_day, &ret, _1) ]; \n\n    boost::spirit::qi::rule<const char*, void()> time_parser =\n            u2_ [ bind(&datetime::set_hours, &ret, _1) ] >> ':'\n         >> u2_ [ bind(&datetime::set_minutes, &ret, _1) ] >> ':'\n         >> u2_ [ bind(&datetime::set_seconds, &ret, _1) ]; \n\n    const char* first = s.data();\n    const char* const end = first + s.size();\n    const bool success = boost::spirit::qi::parse(first, end,\n        (\n            (date_parser >> 'T' >> time_parser)\n            | date_parser\n            | time_parser\n        )\n        >> timezone_parser\n    );\n\n    if (!success || first != end) {\n        throw std::logic_error(\"Parsing of '\" + s + \"' failed\");\n    }\n    return ret;\n} // end of parse_datetime() function\n```", "```cpp\n// Somewhere in header file \nclass example_1 { \n    boost::spirit::qi::rule<const char*, void()> some_rule_; \npublic: \n    example_1(); \n}; \n\n// In source file \nexample_1::example_1() { \n    some_rule_ = /* ... a lot of parser code ... */; \n} \n```"]