["```cpp\n#pragma once \n#include <SFML/Graphics.hpp> \n\nusing namespace sf; \n\nclass Bullet \n{ \nprivate: \n   // Where is the bullet? \n   Vector2f m_Position; \n\n   // What each bullet looks like \n   RectangleShape m_BulletShape; \n\n   // Is this bullet currently whizzing through the air \n   bool m_InFlight = false; \n\n   // How fast does a bullet travel? \n   float m_BulletSpeed = 1000; \n\n   // What fraction of 1 pixel does the bullet travel,  \n   // Horizontally and vertically each frame? \n   // These values will be derived from m_BulletSpeed \n   float m_BulletDistanceX; \n   float m_BulletDistanceY; \n\n   // Some boundaries so the bullet doesn't fly forever \n   float m_MaxX; \n   float m_MinX; \n   float m_MaxY; \n   float m_MinY; \n\n// Public function prototypes go here \n\n```", "```cpp\n// Public function prototypes go here \npublic:\n   // The constructor\n   Bullet();\n\n   // Stop the bullet\n   void stop();\n\n   // Returns the value of m_InFlight\n   bool isInFlight();\n\n   // Launch a new bullet\n   void shoot(float startX, float startY,\n     float xTarget, float yTarget);\n\n   // Tell the calling code where the bullet is in the world\n   FloatRect getPosition();\n\n   // Return the actual shape (for drawing)\n   RectangleShape getShape();\n\n   // Update the bullet each frame\n   void update(float elapsedTime);\n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"bullet.h\" \n\n// The constructor \nBullet::Bullet() \n{ \n   m_BulletShape.setSize(sf::Vector2f(2, 2)); \n}\n```", "```cpp\nvoid Bullet::shoot(float startX, float startY, \n   float targetX, float targetY) \n{ \n   // Keep track of the bullet \n   m_InFlight = true; \n   m_Position.x = startX; \n   m_Position.y = startY; \n\n   // Calculate the gradient of the flight path \n   float gradient = (startX - targetX) / (startY - targetY); \n\n   // Any gradient less than 1 needs to be negative \n   if (gradient < 0) \n   { \n      gradient *= -1; \n   } \n\n   // Calculate the ratio between x and y \n   float ratioXY = m_BulletSpeed / (1 + gradient); \n\n   // Set the \"speed\" horizontally and vertically \n   m_BulletDistanceY = ratioXY; \n   m_BulletDistanceX = ratioXY * gradient; \n\n   // Point the bullet in the right direction \n   if (targetX < startX) \n   { \n      m_BulletDistanceX *= -1; \n   } \n\n   if (targetY < startY) \n   { \n      m_BulletDistanceY *= -1; \n   } \n\n   // Set a max range of 1000 pixels \n   float range = 1000; \n   m_MinX = startX - range; \n   m_MaxX = startX + range; \n   m_MinY = startY - range; \n   m_MaxY = startY + range; \n\n   // Position the bullet ready to be drawn \n   m_BulletShape.setPosition(m_Position); \n\n```", "```cpp\nvoid Bullet::shoot(float startX, float startY, float targetX, float targetY)\n```", "```cpp\n// Keep track of the bullet \nm_InFlight = true; \nm_Position.x = startX; \nm_Position.y = startY;\n```", "```cpp\n// Calculate the gradient of the flight path \nfloat gradient = (startX - targetX) / (startY - targetY); \n\n// Any gradient less than zero needs to be negative \nif (gradient < 0) \n{ \n   gradient *= -1; \n} \n\n// Calculate the ratio between x and y \nfloat ratioXY = m_BulletSpeed / (1 + gradient); \n\n// Set the \"speed\" horizontally and vertically \nm_BulletDistanceY = ratioXY; \nm_BulletDistanceX = ratioXY * gradient;\n```", "```cpp\n// Set a max range of 1000 pixels in any direction \nfloat range = 1000; \nm_MinX = startX - range; \nm_MaxX = startX + range; \nm_MinY = startY - range; \nm_MaxY = startY + range;\n```", "```cpp\n// Position the bullet ready to be drawn \nm_BulletShape.setPosition(m_Position);\n```", "```cpp\nvoid Bullet::stop() \n{ \n   m_InFlight = false; \n} \n\nbool Bullet::isInFlight() \n{ \n   return m_InFlight; \n} \n\nFloatRect Bullet::getPosition() \n{ \n   return m_BulletShape.getGlobalBounds(); \n} \n\nRectangleShape Bullet::getShape() \n{ \n   return m_BulletShape; \n\n```", "```cpp\nvoid Bullet::update(float elapsedTime) \n{ \n   // Update the bullet position variables \n   m_Position.x += m_BulletDistanceX * elapsedTime; \n   m_Position.y += m_BulletDistanceY * elapsedTime; \n\n   // Move the bullet \n   m_BulletShape.setPosition(m_Position); \n\n   // Has the bullet gone out of range? \n   if (m_Position.x < m_MinX || m_Position.x > m_MaxX || \n      m_Position.y < m_MinY || m_Position.y > m_MaxY) \n   { \n      m_InFlight = false; \n   } \n}\n```", "```cpp\n#include \"stdafx.h\" \n#include <SFML/Graphics.hpp> \n#include \"ZombieArena.h\" \n#include \"Player.h\" \n#include \"TextureHolder.h\" \n#include \"Bullet.h\" using namespace sf;\n```", "```cpp\n// Prepare for a horde of zombies \nint numZombies; \nint numZombiesAlive; \nZombie* zombies = NULL; \n\n// 100 bullets should do\nBullet bullets[100];\nint currentBullet = 0;\nint bulletsSpare = 24;\nint bulletsInClip = 6;\nint clipSize = 6;\nfloat fireRate = 1;\n// When was the fire button last pressed?\nTime lastPressed; \n\n// The main game loop \nwhile (window.isOpen())\n```", "```cpp\n// Handle events \nEvent event; \nwhile (window.pollEvent(event)) \n{ \n   if (event.type == Event::KeyPressed) \n   { \n      // Pause a game while playing \n      if (event.key.code == Keyboard::Return && \n         state == State::PLAYING) \n      { \n         state = State::PAUSED; \n      } \n\n      // Restart while paused \n      else if (event.key.code == Keyboard::Return && \n         state == State::PAUSED) \n      { \n         state = State::PLAYING; \n         // Reset the clock so there isn't a frame jump \n         clock.restart(); \n      } \n\n      // Start a new game while in GAME_OVER state \n      else if (event.key.code == Keyboard::Return && \n         state == State::GAME_OVER) \n      { \n         state = State::LEVELING_UP; \n      } \n\n      if (state == State::PLAYING) \n      { \n // Reloading\n        if (event.key.code == Keyboard::R)\n        {\n           if (bulletsSpare >= clipSize)\n           {\n             // Plenty of bullets. Reload.\n             bulletsInClip = clipSize;\n             bulletsSpare -= clipSize;\n           }\n           else if (bulletsSpare > 0)\n           {\n             // Only few bullets left\n             bulletsInClip = bulletsSpare;\n             bulletsSpare = 0;\n           }\n           else\n           {\n             // More here soon?!\n           }\n       } \n      } \n\n   } \n}// End event polling\n```", "```cpp\nif(bulletsSpare >= clipSize) \n   ... \nelse if(bulletsSpare > 0) \n   ... \nelse \n   ...\n```", "```cpp\n   if (Keyboard::isKeyPressed(Keyboard::D)) \n   { \n      player.moveRight(); \n   } \n   else \n   { \n      player.stopRight(); \n   } \n\n // Fire a bullet\n   if (Mouse::isButtonPressed(sf::Mouse::Left))\n   {\n     if (gameTimeTotal.asMilliseconds()\n        - lastPressed.asMilliseconds()\n        > 1000 / fireRate && bulletsInClip > 0)\n     {\n\n        // Pass the center of the player\n        // and the center of the crosshair\n        // to the shoot function\n        bullets[currentBullet].shoot(\n           player.getCenter().x, player.getCenter().y,\n           mouseWorldPosition.x, mouseWorldPosition.y);\n\n        currentBullet++;\n        if (currentBullet > 99)\n        {\n           currentBullet = 0;\n        }\n        lastPressed = gameTimeTotal;\n        bulletsInClip--;\n     }\n   }// End fire a bullet\n}// End WASD while playing\n\n```", "```cpp\n   // Loop through each Zombie and update them \n   for (int i = 0; i < numZombies; i++) \n   { \n      if (zombies[i].isAlive()) \n      { \n         zombies[i].update(dt.asSeconds(), playerPosition); \n      } \n   } \n\n // Update any bullets that are in-flight\n   for (int i = 0; i < 100; i++)\n   {\n     if (bullets[i].isInFlight())\n     {\n        bullets[i].update(dtAsSeconds);\n     }\n   } }// End updating the scene\n```", "```cpp\n/* \n ************** \n Draw the scene \n ************** \n */ \n\nif (state == State::PLAYING) \n{ \n   window.clear(); \n\n   // set the mainView to be displayed in the window \n   // And draw everything related to it \n   window.setView(mainView); \n\n   // Draw the background \n   window.draw(background, &textureBackground); \n\n   // Draw the zombies \n   for (int i = 0; i < numZombies; i++) \n   { \n      window.draw(zombies[i].getSprite()); \n   } \n\n for (int i = 0; i < 100; i++)\n   {\n     if (bullets[i].isInFlight())\n     {\n        window.draw(bullets[i].getShape());\n     }\n   } \n\n   // Draw the player \n   window.draw(player.getSprite()); \n}\n```", "```cpp\n// 100 bullets should do \nBullet bullets[100]; \nint currentBullet = 0; \nint bulletsSpare = 24; \nint bulletsInClip = 6; \nint clipSize = 6; \nfloat fireRate = 1; \n// When was the fire button last pressed? \nTime lastPressed; \n\n// Hide the mouse pointer and replace it with crosshair\nwindow.setMouseCursorVisible(true);\nSprite spriteCrosshair;\nTexture textureCrosshair =\n    TextureHolder::GetTexture(\"graphics/crosshair.png\");\n\nspriteCrosshair.setTexture(textureCrosshair);\nspriteCrosshair.setOrigin(25, 25); \n// The main game loop \nwhile (window.isOpen())\n```", "```cpp\n/* \n **************** \n UPDATE THE FRAME \n **************** \n */ \nif (state == State::PLAYING) \n{ \n   // Update the delta time \n   Time dt = clock.restart(); \n   // Update the total game time \n   gameTimeTotal += dt; \n   // Make a decimal fraction of 1 from the delta time \n   float dtAsSeconds = dt.asSeconds(); \n\n   // Where is the mouse pointer \n   mouseScreenPosition = Mouse::getPosition(); \n\n   // Convert mouse position to world coordinates of mainView \n   mouseWorldPosition = window.mapPixelToCoords( \n      Mouse::getPosition(), mainView); \n\n // Set the crosshair to the mouse world location\n   spriteCrosshair.setPosition(mouseWorldPosition); \n\n   // Update the player \n   player.update(dtAsSeconds, Mouse::getPosition());\n```", "```cpp\n/* \n ************** \n Draw the scene \n ************** \n */ \n\nif (state == State::PLAYING) \n{ \n   window.clear(); \n\n   // set the mainView to be displayed in the window \n   // And draw everything related to it \n   window.setView(mainView); \n\n   // Draw the background \n   window.draw(background, &textureBackground); \n\n   // Draw the zombies \n   for (int i = 0; i < numZombies; i++) \n   { \n      window.draw(zombies[i].getSprite()); \n   } \n\n   for (int i = 0; i < 100; i++) \n   { \n      if (bullets[i].isInFlight()) \n      { \n         window.draw(bullets[i].getShape()); \n      } \n   } \n\n   // Draw the player \n   window.draw(player.getSprite()); \n\n //Draw the crosshair\n   window.draw(spriteCrosshair);\n}\n\n```", "```cpp\n#pragma once \n#include <SFML/Graphics.hpp> \n\nusing namespace sf; \n\nclass Pickup \n{ \nprivate: \n   //Start value for health pickups \n   const int HEALTH_START_VALUE = 50; \n   const int AMMO_START_VALUE = 12; \n   const int START_WAIT_TIME = 10; \n   const int START_SECONDS_TO_LIVE = 5; \n\n   // The sprite that represents this pickup \n   Sprite m_Sprite; \n\n   // The arena it exists in \n   IntRect m_Arena; \n\n   // How much is this pickup worth? \n   int m_Value; \n\n   // What type of pickup is this?  \n   // 1 = health, 2 = ammo \n   int m_Type; \n\n   // Handle spawning and disappearing \n   bool m_Spawned; \n   float m_SecondsSinceSpawn; \n   float m_SecondsSinceDeSpawn; \n   float m_SecondsToLive; \n   float m_SecondsToWait;   \n\n   // Public prototypes go here \n};\n```", "```cpp\n// Public prototypes go here \npublic:\n   Pickup::Pickup(int type);\n\n   // Prepare a new pickup\n   void setArena(IntRect arena);\n   void spawn();\n\n   // Check the position of a pickup\n   FloatRect getPosition();\n\n   // Get the sprite for drawing\n   Sprite getSprite();\n\n   // Let the pickup update itself each frame\n   void update(float elapsedTime);\n\n   // Is this pickup currently spawned?\n   bool isSpawned();\n\n   // Get the goodness from the pickup\n   int gotIt();\n\n   // Upgrade the value of each pickup\n   void upgrade();\n};\n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"Pickup.h\" \n#include \"TextureHolder.h\" \n\nPickup::Pickup(int type) \n{ \n   // Store the type of this pickup \n   m_Type = type; \n\n   // Associate the texture with the sprite \n   if (m_Type == 1) \n   { \n      m_Sprite = Sprite(TextureHolder::GetTexture( \n         \"graphics/health_pickup.png\")); \n\n      // How much is pickup worth \n      m_Value = HEALTH_START_VALUE; \n\n   } \n   else \n   { \n      m_Sprite = Sprite(TextureHolder::GetTexture( \n         \"graphics/ammo_pickup.png\")); \n\n      // How much is pickup worth \n      m_Value = AMMO_START_VALUE; \n   } \n\n   m_Sprite.setOrigin(25, 25); \n\n   m_SecondsToLive = START_SECONDS_TO_LIVE; \n   m_SecondsToWait = START_WAIT_TIME; \n}\n```", "```cpp\nvoid Pickup::setArena(IntRect arena) \n{ \n\n   // Copy the details of the arena to the pickup's m_Arena \n   m_Arena.left = arena.left + 50; \n   m_Arena.width = arena.width - 50; \n   m_Arena.top = arena.top + 50; \n   m_Arena.height = arena.height - 50; \n\n   spawn(); \n}\n```", "```cpp\nvoid Pickup::spawn() \n{ \n   // Spawn at a random location \n   srand((int)time(0) / m_Type); \n   int x = (rand() % m_Arena.width); \n   srand((int)time(0) * m_Type); \n   int y = (rand() % m_Arena.height); \n\n   m_SecondsSinceSpawn = 0; \n   m_Spawned = true; \n\n   m_Sprite.setPosition(x, y); \n}\n```", "```cpp\nFloatRect Pickup::getPosition() \n{ \n   return m_Sprite.getGlobalBounds(); \n} \n\nSprite Pickup::getSprite() \n{ \n   return m_Sprite; \n} \n\nbool Pickup::isSpawned() \n{ \n   return m_Spawned; \n} \n\n```", "```cpp\n\nint Pickup::gotIt() \n{ \n   m_Spawned = false; \n   m_SecondsSinceDeSpawn = 0; \n   return m_Value; \n}\n```", "```cpp\nvoid Pickup::update(float elapsedTime) \n{ \n   if (m_Spawned) \n   { \n      m_SecondsSinceSpawn += elapsedTime; \n   } \n   else \n   { \n      m_SecondsSinceDeSpawn += elapsedTime; \n   } \n\n   // Do we need to hide a pickup? \n   if (m_SecondsSinceSpawn > m_SecondsToLive && m_Spawned) \n   { \n      // Remove the pickup and put it somewhere else \n      m_Spawned = false; \n      m_SecondsSinceDeSpawn = 0; \n   } \n\n   // Do we need to spawn a pickup \n   if (m_SecondsSinceDeSpawn > m_SecondsToWait && !m_Spawned) \n   { \n      // spawn the pickup and reset the timer \n      spawn(); \n   } \n\n}\n```", "```cpp\nvoid Pickup::upgrade() \n{ \n   if (m_Type == 1) \n   { \n      m_Value += (HEALTH_START_VALUE * .5); \n   } \n   else \n   { \n      m_Value += (AMMO_START_VALUE * .5); \n   } \n\n   // Make them more frequent and last longer \n   m_SecondsToLive += (START_SECONDS_TO_LIVE / 10); \n   m_SecondsToWait -= (START_WAIT_TIME / 10); \n}\n```", "```cpp\n#include \"stdafx.h\" \n#include <SFML/Graphics.hpp> \n#include \"ZombieArena.h\" \n#include \"Player.h\" \n#include \"TextureHolder.h\" \n#include \"Bullet.h\" \n#include \"Pickup.h\" using namespace sf;\n```", "```cpp\n// Hide the mouse pointer and replace it with crosshair \nwindow.setMouseCursorVisible(true); \nSprite spriteCrosshair; \nTexture textureCrosshair = TextureHolder::GetTexture(\"graphics/crosshair.png\"); \nspriteCrosshair.setTexture(textureCrosshair); \nspriteCrosshair.setOrigin(25, 25); \n\n// Create a couple of pickups\nPickup healthPickup(1);\nPickup ammoPickup(2); \n\n// The main game loop \nwhile (window.isOpen())\n```", "```cpp\nif (state == State::PLAYING) \n{ \n   // Prepare thelevel \n   // We will modify the next two lines later \n   arena.width = 500; \n   arena.height = 500; \n   arena.left = 0; \n   arena.top = 0; \n\n   // Pass the vertex array by reference  \n   // to the createBackground function \n   int tileSize = createBackground(background, arena); \n\n   // Spawn the player in the middle of the arena \n   player.spawn(arena, resolution, tileSize); \n\n // Configure the pickups\n   healthPickup.setArena(arena);\n   ammoPickup.setArena(arena); \n\n   // Create a horde of zombies \n   numZombies = 10; \n\n   // Delete the previously allocated memory (if it exists) \n   delete[] zombies; \n   zombies = createHorde(numZombies, arena); \n   numZombiesAlive = numZombies; \n\n   // Reset the clock so there isn't a frame jump \n   clock.restart(); \n}\n```", "```cpp\n// Loop through each Zombie and update them \n   for (int i = 0; i < numZombies; i++) \n   { \n      if (zombies[i].isAlive()) \n      { \n         zombies[i].update(dt.asSeconds(), playerPosition); \n      } \n   } \n\n   // Update any bullets that are in-flight \n   for (int i = 0; i < 100; i++) \n   { \n      if (bullets[i].isInFlight()) \n      { \n         bullets[i].update(dtAsSeconds); \n      } \n   } \n\n // Update the pickups\n   healthPickup.update(dtAsSeconds);\n   ammoPickup.update(dtAsSeconds); }// End updating the scene\n```", "```cpp\n   // Draw the player \n   window.draw(player.getSprite()); \n\n // Draw the pickups, if currently spawned\n   if (ammoPickup.isSpawned())\n   {\n     window.draw(ammoPickup.getSprite());\n   }\n   if (healthPickup.isSpawned())\n   {\n     window.draw(healthPickup.getSprite());\n   } \n\n   //Draw the crosshair \n   window.draw(spriteCrosshair); \n}\n```", "```cpp\nif(objectA.getPosition().right > objectB.getPosition().left \n   && objectA.getPosition().left < objectB.getPosition().right ) \n{     \n   // objectA is intersecting enemy on x axis     \n   // But they could be at different heights     \n\n   if(objectA.getPosition().top < objectB.getPosition().bottom          \n      && objectA.getPosition().bottom > objectB.getPosition().top ) \n      {        \n         // objectA is intersecting objectB on y axis as well  \n         // Collision detected   \n      }  \n}\n```", "```cpp\n// Create a couple of pickups \nPickup healthPickup(1); \nPickup ammoPickup(2); \n\n// About the game\nint score = 0;\nint hiScore = 0; \n\n// The main game loop \nwhile (window.isOpen())\n```", "```cpp\n// Update the pickups \nhealthPickup.update(dtAsSeconds); \nammoPickup.update(dtAsSeconds); \n\n// Collision detection\n// Have any zombies been shot?\nfor (int i = 0; i < 100; i++)\n{\n   for (int j = 0; j < numZombies; j++)\n   {\n     if (bullets[i].isInFlight() &&\n         zombies[j].isAlive())\n     {\n        if (bullets[i].getPosition().intersects\n           (zombies[j].getPosition()))\n        {\n           // Stop the bullet\n           bullets[i].stop();\n           // Register the hit and see if it was a kill\n           if (zombies[j].hit())\n           {\n             // Not just a hit but a kill too\n             score += 10;\n             if (score >= hiScore)\n             {\n                hiScore = score;\n             }\n             numZombiesAlive--;\n             // When all the zombies are dead (again)\n             if (numZombiesAlive == 0)\n             {\n                state = State::LEVELING_UP;\n             }\n           }\n        }\n     }\n   }\n}// End zombie being shot\n\n```", "```cpp\n// Collision detection \n// Have any zombies been shot? \nfor (int i = 0; i < 100; i++) \n{ \n   for (int j = 0; j < numZombies; j++) \n   { \n      ... \n      ... \n      ... \n   } \n}\n```", "```cpp\n        if (bullets[i].isInFlight() && zombies[j].isAlive())\n    ```", "```cpp\n        if (bullets[i].getPosition().intersects (zombies[j].getPosition()))\n    ```", "```cpp\n        // Stop the bullet\n        bullets[i].stop();\n    ```", "```cpp\n        // Register the hit and see if it was a kill \n        if (zombies[j].hit()) {\n    ```", "```cpp\n// Not just a hit but a kill too \nscore += 10; \nif (score >= hiScore) \n{ \n   hiScore = score; \n} \n\nnumZombiesAlive--; \n\n// When all the zombies are dead (again) \nif (numZombiesAlive == 0)  \n{ \n   state = State::LEVELING_UP; \n}\n```", "```cpp\n}// End zombie being shot \n\n// Have any zombies touched the player\nfor (int i = 0; i < numZombies; i++)\n{\n  if (player.getPosition().intersects\n    (zombies[i].getPosition()) && zombies[i].isAlive())\n  {\n    if (player.hit(gameTimeTotal))\n    {\n      // More here later\n    }\n    if (player.getHealth() <= 0)\n    {\n      state = State::GAME_OVER;\n    }\n  } }// End player touched\n```", "```cpp\n   }// End player touched \n\n // Has the player touched health pickup\n   if (player.getPosition().intersects\n     (healthPickup.getPosition()) && healthPickup.isSpawned())\n   {\n     player.increaseHealthLevel(healthPickup.gotIt());\n   }\n\n   // Has the player touched ammo pickup\n   if (player.getPosition().intersects\n     (ammoPickup.getPosition()) && ammoPickup.isSpawned())\n   {\n     bulletsSpare += ammoPickup.gotIt();\n   }\n}// End updating the scene\n\n```"]