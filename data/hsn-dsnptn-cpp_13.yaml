- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Virtual Constructors and Factories
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚构造函数和工厂
- en: In C++, any member function of any class, including its destructor, can be made
    virtual - any member function except one—the constructor. Without virtual functions,
    the exact type of object on which the member function is invoked is known at compile
    time. Therefore, the type of object that is constructed is always known at compile
    time, at the point of the constructor call. Nonetheless, we often need to construct
    objects whose type is not known until runtime. This chapter describes several
    related patterns and idioms that address this design problem in various ways,
    including the Factory pattern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，任何类的任何成员函数，包括其析构函数，都可以被声明为虚函数——唯一的例外是构造函数。没有虚函数，在编译时就可以知道调用成员函数的对象的确切类型。因此，构造的对象类型在编译时总是已知的，在构造函数调用时已知。尽管如此，我们经常需要构造在运行时才知道类型的对象。本章描述了几个相关的模式和惯用法，以各种方式解决这个设计问题，包括工厂模式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Why there is no way to make a constructor virtual
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么无法使构造函数成为虚函数
- en: How to use the Factory pattern to defer the choice of the constructed object
    type until compile time
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用工厂模式来延迟构造对象类型的选择，直到编译时
- en: Using C++ idioms to construct and copy objects polymorphically
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++惯用法来多态地构造和复制对象
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The example code for this chapter can be found at the following GitHub link:
    [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter13).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在以下GitHub链接中找到：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP_Second_Edition/tree/master/Chapter13).
- en: Why constructors cannot be virtual
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么构造函数不能是虚函数
- en: We already understand how polymorphism works—when a virtual function is called
    through a pointer or a reference to the base class, that pointer or reference
    is used to access the v-pointer in the class. The v-pointer is used to identify
    the true type of the object, that is, the type that the object was created with.
    It could be the base class itself, or any one of the derived classes. The member
    function on that object is actually called. So, why can’t the same be done for
    constructors? Let’s investigate this.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经理解了多态是如何工作的——当通过基类指针或引用调用虚函数时，该指针或引用用于访问类中的v指针。v指针用于识别对象的真正类型，即对象创建时所用的类型。这可能就是基类本身，或者是任何派生类之一。实际上调用的是该对象上的成员函数。那么，为什么构造函数不能这样做呢？让我们来调查一下。
- en: When does an object get its type?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象何时获得其类型？
- en: It is pretty easy to understand why the process that we described previously
    cannot work for creating *virtual constructors*. First of all, it is evident from
    the description of the preceding process—as a part of it, we *identify the type
    that the object was created with*. That can only happen after the object is constructed—before
    construction, we don’t have an object of this type yet, just some uninitialized
    memory. Another way to look at it is this—before the virtual function is dispatched
    to the correct type, the v-pointer needs to be looked up. Who puts the right value
    into the v-pointer? Considering that the v-pointer uniquely identifies the type
    of object, it can only be initialized during construction. This implies that it
    wasn’t initialized before construction. But if it wasn’t initialized, it can’t
    be used to dispatch virtual function calls. And so again, we realize that constructors
    cannot be virtual.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易理解为什么我们之前描述的过程不能用于创建*虚构造函数*。首先，从先前过程的描述中可以明显看出——作为其中的一部分，我们*识别了对象创建时所用的类型*。这只能在对象构造之后发生——在构造之前，我们还没有这种类型的对象，只有一些未初始化的内存。另一种看待方式是——在虚函数被调度到正确的类型之前，需要查找v指针。谁将正确的值放入v指针中？考虑到v指针唯一地标识了对象的类型，它只能在构造过程中初始化。这意味着它在此之前没有被初始化。但如果它没有被初始化，就不能用它来调度虚函数调用。因此，我们再次意识到构造函数不能是虚函数。
- en: 'For derived classes in the hierarchy, the process of establishing the type
    is even more complex. We can try to observe the type of an object as it is being
    constructed. The easiest way to do this is to use the `typeid` operator, which
    returns information about the object’s type, including the name of the type:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于层次结构中的派生类，确定类型的流程更加复杂。我们可以尝试观察对象在构造过程中的类型。最简单的方法是使用 `typeid` 操作符，它返回有关对象类型的详细信息，包括类型的名称：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running this program produces the following result:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个程序产生以下结果：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The type name returned by the `std::typeinfo::name()` call is the so-called
    mangled type name—it’s the internal name that the compiler uses to identify types,
    instead of human-readable names such as `class A`. If you want to know the unmangled
    type, you can use a demangler such as the `c++filt` program that comes with GCC:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::typeinfo::name()` 调用返回的类型名称是所谓的名称混淆类型名称——这是编译器用来识别类型的内部名称，而不是像 `class
    A` 这样的可读名称。如果你想了解未混淆的类型，你可以使用像 GCC 中的 `c++filt` 程序这样的去混淆器：'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can also write a small C++ function to demangle type names, but the way
    to do it varies from one compiler to another (there is no portable version). For
    example, this is what you would write for GCC:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以编写一个小的 C++ 函数来去混淆类型名称，但实现方式因编译器而异（没有可移植版本）。例如，这是为 GCC 编写的代码：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that the demangler function returns a C string (a `char*` pointer) that
    must be explicitly freed by the caller. The program now prints demangled names
    such as `A`, `B`, and `C`. This is enough for our use, but in some cases, you
    might notice that the type is not printed exactly as it should be:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，去混淆函数返回一个 C 字符串（一个 `char*` 指针），必须由调用者显式释放。现在程序打印去混淆后的名称，如 `A`、`B` 和 `C`。这足以满足我们的需求，但在某些情况下，你可能会注意到类型并没有按预期打印出来：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we call the function `f()`, the type is reported as `C` but not `const C`
    as we might expect (the object is `const` inside a `const` member function). This
    is because the `typeid` operator removed the `const` and `volatile` qualifiers
    as well as any references from the type. To print those, you have to figure them
    out by yourself:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用函数 `f()`，其类型报告为 `C`，而不是我们可能预期的 `const C`（对象在 `const` 成员函数内部是 `const` 的）。这是因为
    `typeid` 操作符移除了 `const` 和 `volatile` 限定符以及类型中的任何引用。要打印这些，你必须自己找出它们：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Regardless of how you choose to print the types, how many objects were constructed
    in these examples? The source code says just one, the `c` object of type `C`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择如何打印类型，在这些示例中构造了多少个对象？源代码只说了一个，类型为 `C` 的 `c` 对象：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The runtime output says three, that is, one of each type. Both answers are correct—when
    an object of type `C` is constructed, the base class, `A`, has to be constructed
    first, and so its constructor is called. Then, the intermediate base class, `B`,
    is constructed, and only then will `C` be. The destructors are executed in reverse
    order. The type of the object inside its constructor or destructor, as reported
    by the `typeid` operator, is the same as the type of object whose constructor
    or destructor is running.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时输出显示三个，即每种类型的一个。两个答案都是正确的——当类型为 `C` 的对象被构造时，必须首先构造基类 `A`，因此会调用其构造函数。然后，构造中间基类
    `B`，之后才会构造 `C`。析构函数的执行顺序是相反的。由 `typeid` 操作符报告的对象构造函数或析构函数中的类型与正在运行构造函数或析构函数的对象的类型相同。
- en: 'It appears that the type, as indicated by the virtual pointer, is changing
    during the construction! That is, of course, assuming that the `typeid` operator
    returns the dynamic type, the type indicated by the virtual pointer, and not the
    static type that can be determined at compile time. The standard says that this
    is, indeed, the case. Does this mean that, if we called the same virtual method
    from each constructor, we would really be calling three different overrides of
    this method? It’s easy enough to find out:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，类型，如虚拟指针所示，在构造过程中正在改变！当然，这是假设 `typeid` 操作符返回的是动态类型，即虚拟指针指示的类型，而不是在编译时可以确定的静态类型。标准指出，这确实是情况。这意味着，如果我们从每个构造函数中调用相同的虚拟方法，我们实际上会调用这个方法的三种不同的重写吗？这很容易找到答案：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we will create the object of type `C`, and the call to `whoami()` after
    the creation confirms it – the dynamic type of the object is `C`. That was true
    from the beginning of the construction process; we asked the compiler to construct
    one object of type `C`, but the dynamic type of the object changed during construction:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个类型为`C`的对象，并在创建之后调用`whoami()`来确认它——对象的动态类型是`C`。这是从构造过程的开始就是正确的；我们要求编译器构造一个类型为`C`的对象，但在构造过程中对象的动态类型发生了变化：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is clear that the virtual pointer value has changed as the construction
    of the object progressed. In the beginning, it was identifying the object type
    as `A`, even though the final type is `C`. Is this because we created the object
    on the stack? Would it be any different if the object was created on the heap?
    We can easily find out:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，随着对象构造的进行，虚拟指针值已经改变。一开始，它将对象类型识别为`A`，即使最终类型是`C`。这是否因为我们是在栈上创建了对象？如果对象是在堆上创建的，会有所不同吗？我们可以很容易地找到答案：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Running the modified program produces exactly the same results as the original.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 运行修改后的程序会产生与原始程序完全相同的结果。
- en: Another reason that the constructor cannot be virtual, or, more generally, why
    the type of the object being constructed has to be known at compile time at the
    point of construction, is that the compiler has to know how much memory to allocate
    for the object. The amount of memory is determined by the size of the type, that
    is, by the `sizeof` operator. The result of `sizeof(C)` is a compile-time constant,
    so the amount of memory allocated for the new object is always known at compile
    time. This is true whether we create the object on the stack or on the heap.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是因为构造函数不能是虚拟的，或者更普遍地说，为什么正在构造的对象的类型必须在构造点在编译时已知，是因为编译器必须知道为对象分配多少内存。内存量由类型的大小决定，即由`sizeof`运算符。`sizeof(C)`的结果是一个编译时常量，因此为新对象分配的内存量始终在编译时已知。这无论是我们在栈上还是堆上创建对象都是正确的。
- en: The bottom line is this—if the program creates an object of the `T` type, somewhere
    in the code there is an explicit call to the `T::T` constructor. After that, we
    can hide the `T` type in the rest of the program, for example, by accessing the
    object through a base class pointer, or by erasing the type (see [*Chapter 6*](B19262_06.xhtml#_idTextAnchor266),
    *Understanding Type Erasure*). But there has to be at least one explicit mention
    of the `T` type in the code, and that is at the point of construction.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 核心问题是这样的——如果程序创建了一个`T`类型的对象，那么在代码的某个地方会有一个对`T::T`构造函数的显式调用。之后，我们可以在程序的其余部分隐藏`T`类型，例如，通过通过基类指针访问对象，或者通过擦除类型（参见[*第6章*](B19262_06.xhtml#_idTextAnchor266)，*理解类型擦除*）。但是，代码中必须至少有一个对`T`类型的显式提及，那就是在构造的时候。
- en: On the one hand, we now have a very reasonable explanation of why constructing
    objects can never be polymorphic. On the other hand, this does nothing to address
    a design challenge that may require constructing an object whose type is not known
    at compile time. Consider designing a game—a player can recruit or summon any
    number of adventurers for their party and build settlements and cities. It would
    be reasonable to have a separate class for each creature kind and each building
    type, but then we have to construct an object of one of these types when an adventurer
    joins the party, or a building is erected, and until the player selects it, the
    game cannot know which object to construct.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，我们现在有一个非常合理的解释，说明了为什么构造对象永远不能是多态的。另一方面，这并没有解决可能需要构造一个在编译时类型未知的设计挑战。考虑设计一个游戏——玩家可以为他们的团队招募或召唤任意数量的冒险者，并建立定居点和城市。为每种生物种类和每种建筑类型拥有一个单独的类似乎是合理的，但当我们有一个冒险者加入团队或一座建筑被建立时，我们必须构造这些类型之一的对象，直到玩家选择它，游戏才能知道要构造哪个对象。
- en: As usual in software, the solution involves adding another level of indirection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如同软件中的常规做法，解决方案涉及添加另一个间接层。
- en: The Factory pattern
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂模式
- en: The problem we are faced with, that is, how to decide at runtime to create an
    object of a particular type, is obviously a very common design problem. Design
    patterns are the solutions for just such problems, and there is a pattern for
    this problem as well—it’s called the Factory pattern. The Factory pattern is a
    creational pattern, and it provides solutions for several related problems—how
    to delegate the decision of which object to create to a derived class, how to
    create objects using a separate factory method, and so on. We will review these
    variations of the Factory pattern one by one, starting with the basic factory
    method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临的问题，即如何在运行时决定创建特定类型的对象，显然是一个非常常见的设计问题。设计模式正是针对这类问题的解决方案，而且对于这个问题也有一个模式——它被称为工厂模式。工厂模式是一种创建型模式，它为几个相关的问题提供了解决方案——如何将创建哪个对象的决策委托给派生类，如何使用单独的工厂方法创建对象，等等。我们将逐一回顾工厂模式的这些变体，从基本的工厂方法开始。
- en: The basics of the Factory method
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂方法的基本原理
- en: 'In its simplest form, the factory method constructs an object of a type that’s
    specified at runtime:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，工厂方法构建一个在运行时指定的类型的对象：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How do we identify at runtime which object to create? We need a runtime identifier
    for each type that the factory can create. In the simplest case, the list of these
    types is known at compile time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在运行时识别要创建的对象？我们需要为工厂可以创建的每种类型提供一个运行时标识符。在最简单的情况下，这些类型的列表在编译时是已知的。
- en: 'Consider a game design where a player selects the type of building to construct
    from a menu. The program has a list of buildings that can be constructed, each
    represented by an object, with an identifier for each one:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个游戏设计，玩家可以从菜单中选择要构建的建筑类型。程序有一个可以构建的建筑列表，每个建筑由一个对象表示，并为每个对象分配一个标识符：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the player selects the building type, the corresponding identifier value
    is also selected by the game program. Now, the program can construct the building
    using the factory method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家选择建筑类型时，游戏程序也会选择相应的标识符值。现在，程序可以使用工厂方法构建建筑：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that the factory takes the type identifier argument and returns the pointer
    to the base class. The returned object should have the type that corresponds to
    the type identifier. How is the factory implemented? Remember the conclusion of
    the last section—somewhere in the program, every object has to be explicitly constructed
    with its true type. The Factory pattern does not remove this requirement; it merely
    hides the place where the construction happens:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，工厂函数接受类型标识符参数并返回基类的指针。返回的对象应该具有与类型标识符相对应的类型。工厂是如何实现的？记住上一节的结论——在程序的某个地方，每个对象都必须显式地使用其真实类型进行构造。工厂模式并不取消这一要求；它只是隐藏了构造发生的地方：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The correspondence between the type identifier and the object type is encoded
    in the `switch` statement inside the factory. The return type has to be the same
    for all types that are constructed by the factory since there is only one factory
    method, and its type is declared at compile time. In the simplest case, it is
    the base class pointer, although if you follow the modern memory ownership idioms
    described in [*Chapter 3*](B19262_03.xhtml#_idTextAnchor110), *Memory and Ownership*,
    of this book, the factory should return a unique pointer to the base class, `std::unique_ptr<Building>`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 类型标识符与对象类型之间的对应关系编码在工厂内部的`switch`语句中。由于只有一个工厂方法，并且其类型在编译时声明，因此返回类型必须对所有由工厂构建的类型相同。在最简单的情况下，它是基类指针，尽管如果你遵循本书中描述的现代内存所有权习惯用法[*第3章*](B19262_03.xhtml#_idTextAnchor110)，*内存和所有权*，那么工厂应该返回对基类的唯一指针，`std::unique_ptr<Building>`。
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In rare cases when the shared ownership is really needed, the shared pointer,
    `std::shared_ptr<Building>`, can be constructed by moving the object from the
    unique pointer (but this is the decision to be made by the caller, not the factory
    itself).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数需要共享所有权的场合，可以通过将对象从唯一指针移动到共享指针`std::shared_ptr<Building>`来创建共享所有权（但这是由调用者做出的决定，而不是工厂本身）。
- en: The other design choice that we made here (independently of using the owning
    pointer) is to move the type identifiers and the factory function into the base
    class. This is useful for encapsulation and to keep all related code and types
    closer together.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做出的另一个设计选择（独立于使用拥有指针）是将类型标识符和工厂函数移动到基类中。这对于封装和保持所有相关代码和类型更接近是有用的。
- en: This is the basic form of the factory method. There are many variations that
    make it more suitable for a particular problem. We will review some of these variations
    here.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是工厂方法的基本形式。有许多变体使其更适合特定问题。我们将在下面回顾其中的一些变体。
- en: Factory clarification
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂方法的澄清
- en: 'Note that there is some ambiguity in the use of the term “factory method.”
    In this chapter, we use it to describe the function that creates objects of different
    types based on some run-time information. There is another, not related, design
    pattern that is sometimes introduced with the same name: instead of constructing
    different classes, this pattern constructs the same class but in different ways.
    Here is a brief example: suppose we have a class to represent a point on a plain.
    The point is described by its coordinates, `x` and `y`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，“工厂方法”这个术语的使用存在一些歧义。在本章中，我们用它来描述基于某些运行时信息创建不同类型对象的函数。还有一个与之不相关的、有时以相同名称引入的设计模式：这个模式不是构建不同的类，而是以不同的方式构建相同的类。以下是一个简短的例子：假设我们有一个类来表示平面上的一个点。这个点由其坐标
    `x` 和 `y` 描述：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So far, so good. But the same point can be described using, for example, polar
    coordinates. Because these are two ways to describe the same point, we do not
    need a separate class, but we may want a new constructor that creates a cartesian
    point from the specified polar coordinates:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但同一个点可以用极坐标，例如，来描述。因为这些是描述同一个点的两种方式，我们不需要一个单独的类，但我们可能想要一个新的构造函数，它可以从指定的极坐标创建笛卡尔点：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But this is not going to work: the new constructor and the original constructor
    from `x` and `y` both take exactly the same arguments, so there is no way for
    the overload resolution to figure out which one you meant. One solution is to
    use different types for quantities that are measured in different units (length
    and angle, in our case). But they have to be truly different types, not just aliases.
    Sometimes, such a unit template library is just what you need, but if you’re staying
    with doubles, you need some other way of invoking different constructors based
    on the caller’s intent and not just the arguments.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但这行不通：新的构造函数和从 `x` 和 `y` 来的原始构造函数都接受完全相同的参数，因此重载解析无法确定你指的是哪一个。一个解决方案是使用不同单位测量的量（在我们的例子中是长度和角度）使用不同的类型。但它们必须是真正不同的类型，而不仅仅是别名。有时，这样的单位模板库正是你所需要的，但如果你坚持使用双精度浮点数，你需要其他方法来根据调用者的意图调用不同的构造函数，而不仅仅是根据参数。
- en: 'One way to handle this problem is to switch to factory construction. Instead
    of using the constructors, we will construct all `Point` objects using static
    factory methods. Note that the constructor itself is usually made private when
    using this approach:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的方法之一是切换到工厂构建。我们不会使用构造函数，而是将所有 `Point` 对象都使用静态工厂方法来构建。请注意，在使用这种方法时，构造函数本身通常是私有的：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This design works, but in modern C++, the more popular alternative is to use
    multiple constructors and disambiguate them with uniquely defined type tags:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计是可行的，但在现代 C++ 中，更受欢迎的替代方案是使用多个构造函数，并通过唯一定义的类型标签来区分它们：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we create two unique types, `Point::polar_t` and `Point::cartesian_t`,
    along with the corresponding variables, and use them as tags to specify what kind
    of construction we want. The constructor overloads are no longer ambiguous since
    each one has a unique first parameter type. Delegating constructors makes this
    approach even more attractive.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了两个独特的类型，`Point::polar_t` 和 `Point::cartesian_t`，以及相应的变量，并使用它们作为标签来指定我们想要的构建类型。构造函数的重载不再模糊，因为每个都有一个独特的第一参数类型。委托构造函数使这种方法更具吸引力。
- en: While the use of static functions to construct objects of the same type in different
    ways is sometimes called a factory method, it can also be seen as a variant of
    the builder pattern (especially when, instead of static methods, we use a separate
    builder class with similar methods). In any case, the more modern pattern – using
    tags – can replace both of these patterns. Having clarified the terminology, let
    us return to the original problem of constructing objects of different types based
    on run-time information.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用静态函数以不同方式构建相同类型的对象有时被称为工厂方法，但它也可以被视为建造者模式的一个变体（特别是当我们使用具有类似方法的单独建造者类而不是静态方法时）。无论如何，更现代的模式——使用标签——可以替代这两种模式。在明确了术语之后，让我们回到基于运行时信息构建不同类型对象的原问题。
- en: Arguments for factory methods
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂方法的论据
- en: 'In our simple example, the constructor took no arguments. Passing arguments
    to the constructor presents a bit of a problem if the constructors of different
    types have different parameters—after all, the `MakeBuilding()` function has to
    be declared with some specific parameters. One option that appears straightforward
    is to make the factory a variadic template and simply forward the arguments to
    each constructor. The straightforward implementation might look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简单示例中，构造函数没有接受任何参数。如果不同类型的构造函数有不同的参数，向构造函数传递参数会带来一些问题——毕竟，`MakeBuilding()`
    函数必须用一些特定的参数声明。一个看起来很直接的选择是将工厂做成可变模板，并将参数简单地转发给每个构造函数。直接的实现可能看起来像这样：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code might even compile for a while, but, sooner or later, you are going
    to run into the following error. Let us give the two classes we build some constructor
    arguments:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能甚至会在一段时间内编译，但迟早你会遇到以下错误。让我们给我们要构建的两个类提供一些构造函数参数：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Forge` class uses a bitmask as flags to mark which services are provided
    at the forge (a simple and efficient solution to handle a small number of non-exclusive
    options). For example, if `(services & Forge::farrier)` is `true`, one of the
    2 craftsmen working at the forge can shoe horses. Simple, elegant, and … doesn’t
    compile.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Forge` 类使用位掩码作为标志来标记在锻造处提供哪些服务（处理少量非排他性选项的一个简单且有效的方法）。例如，如果 `(services & Forge::farrier)`
    为 `true`，那么在锻造处工作的两位工匠中的一位可以为马钉蹄铁。简单、优雅，但……无法编译。'
- en: 'The compiler error will mention that there is no matching constructor for the
    `Farm` class that could be used to construct a `Farm` from two integers. But we
    are not trying to construct a `Farm`! This error gets everybody sooner or later.
    The problem is that, at compile-time, it is impossible to be sure that we are
    not trying to construct a `Farm`: that is a run-time decision. The function `MakeBuilding()`
    must compile, which means its entire implementation must compile, including the
    line starting with `case FARM`. Your first thought might be to replace the `switch`
    statement with `if constexpr`, but that’s not going to work because the condition
    we use to select which class to build is not `constexpr`, it’s a run-time value
    – that’s the whole point of the factory pattern.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器错误将提到没有匹配的构造函数可用于从两个整数构造 `Farm` 类。但我们并不是试图构造一个 `Farm`！这个错误迟早会困扰到每个人。问题是，在编译时，我们无法确定我们不是试图构造一个
    `Farm`：这是一个运行时决策。函数 `MakeBuilding()` 必须编译，这意味着其整个实现必须编译，包括以 `case FARM` 开头的行。你第一个想法可能是用
    `if constexpr` 替换 `switch` 语句，但这不会起作用，因为我们用来选择要构建哪个类的条件不是 `constexpr`，而是一个运行时值——这正是工厂模式的意义所在。
- en: 'Trying to construct a `Farm` with the arguments meant for a `Forge` is an error.
    However, it is a run-time error, and it can only be detected at run time. This
    still leaves us with the problem of how to make valid the code we never want to
    run. The problem is that the Farm doesn’t have a constructor we could use for
    all the wrong arguments (but hopefully never will). The easiest workaround is
    to provide one:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用为 `Forge` 准备的参数来构造一个 `Farm` 是一个错误。然而，这是一个运行时错误，并且只能在运行时检测到。这仍然让我们面临如何使永远不会运行的代码有效的问题。问题是，农场没有我们可以用于所有错误参数的构造函数（但希望永远不会），最简单的解决方案是提供一个：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have to do the same for all types we may construct with our factory. The
    variadic function constructor is an “overload of the last resort” – it is selected
    only if no other overload matches the arguments. Since it matches any arguments,
    the compilation errors will be gone, replaced by run-time errors if something
    does go wrong in the program. Why not simply add this constructor to the base
    class? We could, but base class constructors are not visible in derived classes
    without a `using` statement, so we still have to add something to every derived
    class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须对我们可能用工厂构造的所有类型都做同样的事情。可变参数函数构造器是“最后的手段”重载——它仅在没有任何其他重载与参数匹配时才会被选中。因为它匹配任何参数，所以编译错误将消失，如果程序中出现问题，将被运行时错误所取代。为什么不简单地将这个构造函数添加到基类中呢？我们可以这样做，但基类构造函数在没有
    `using` 语句的情况下在派生类中是不可见的，所以我们仍然必须为每个派生类添加一些内容。
- en: 'Having to modify every class just so it can be used with the factory creation
    pattern is definitely a disadvantage, especially since the new constructor could
    be used anywhere, not just in the factory function (with unfortunate consequences).
    As usual, with one more layer of indirection, we could solve this problem as well
    by introducing an overloaded template for constructing our objects:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了让每个类能够与工厂创建模式一起使用而必须修改每个类，这确实是一个缺点，尤其是新的构造函数可以在任何地方使用，而不仅仅是工厂函数中（不幸的是，这会产生不良后果）。像往常一样，通过引入一个重载模板，我们可以通过引入一个重载模板来解决这个问题，以构建我们的对象：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The good news is that now we do not need to modify any of the classes: any
    factory call with the correct arguments compiles and is forwarded to the right
    constructor, while any attempt to create an object with the wrong arguments is
    a run-time error. The bad news is that any attempt to create an object with the
    wrong arguments is a run-time error. That includes the dead code we never plan
    to run (such as creating a `Farm` with `Forge`’s arguments), but it also includes
    any mistakes we could make when calling the factory.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，现在我们不需要修改任何类：任何带有正确参数的工厂调用都会编译并转发到正确的构造函数，而任何尝试使用错误参数创建对象的操作都会导致运行时错误。坏消息是，任何尝试使用错误参数创建对象的操作都会导致运行时错误。这包括我们从未计划运行的死代码（例如，使用`Forge`的参数创建`Farm`），也包括我们在调用工厂时可能犯的任何错误。
- en: 'If the variadic template solution looks much less attractive once you start
    implementing it, there is a simpler option: create a parameter object with the
    hierarchy matching the hierarchy of the objects we create. Let’s assume that,
    in our game, the player can select upgrades for each building to be constructed.
    The user interface will have to offer building-specific options, of course, and
    the results of the user selections are stored in a building-specific object:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始实现可变参数模板解决方案，它可能看起来就不那么有吸引力了，有一个更简单的选择：创建一个参数对象，其层次结构与我们要创建的对象的层次结构相匹配。让我们假设，在我们的游戏中，玩家可以为要构建的每个建筑选择升级。用户界面当然必须提供特定于建筑的选项，用户选择的结果存储在特定于建筑的对象中：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that we included the type identifier with the argument object, there is
    no reason to call the factory method with two arguments that must always correctly
    match each other; it only creates the possibility of an error occurring. This
    way, we are guaranteed that the type identifier and the arguments match in every
    factory call:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在参数对象中包含了类型标识符，没有理由用两个必须始终正确匹配的参数调用工厂方法；这只会增加出错的可能性。这样，我们就可以保证在每个工厂调用中类型标识符和参数是一致的：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that the factory pattern often works well with the named arguments pattern
    we saw in [*Chapter 9*](B19262_09.xhtml#_idTextAnchor406), *Named Arguments, Method
    Chaining, and the Builder Pattern* to avoid having to specify long argument lists.
    The spec objects themselves become the options objects we can use to specify named
    arguments:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，工厂模式通常与我们在[*第9章*](B19262_09.xhtml#_idTextAnchor406)中看到的命名参数模式配合得很好，*命名参数、方法链和构建器模式*，以避免需要指定长的参数列表。规范对象本身就成了我们可以用来指定命名参数的选项对象：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This technique can be combined with some of the other factory variations that
    are shown in the following sections so that we can pass arguments when the constructors
    require them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以与以下章节中展示的其他工厂变体结合使用，这样我们就可以在构造函数需要时传递参数。
- en: Dynamic type registry
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态类型注册
- en: 'So far, we have assumed that the complete list of the types is known at compile
    time and can be encoded in the type identifier correspondence table (implemented
    with a switch statement, in our example). The former requirement is unavoidable
    in the scope of the entire program: since every constructor call is explicit somewhere,
    the total list of types that can be constructed is known at compile time. However,
    our solution is more constrained than that—we have a list of all types that are
    hard-coded in the factory method. No additional derived classes can be created
    without also adding them to the factory. Sometimes, this restriction is not as
    bad as it appears—for example, the list of buildings in the game may not change
    very often, and even when it does, there is a complete list that must be manually
    updated for the right menu to be generated, the pictures and sounds to appear
    in the right places, and so on.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们假设类型的完整列表在编译时已知，并且可以编码在类型标识符对应表中（在我们的例子中通过switch语句实现）。在程序的全局范围内，这个要求是不可避免的：因为每个构造函数调用都必须在某个地方显式编写，因此可以构造的类型列表在编译时是已知的。然而，我们的解决方案比这更受限制——我们有一个硬编码在工厂方法中的所有类型的列表。没有添加到工厂中，就不能创建额外的派生类。有时，这种限制并不像看起来那么糟糕——例如，游戏中的建筑列表可能不会经常改变，即使它改变了，也必须有一个完整的列表手动更新，以便正确生成菜单，图片和声音出现在正确的位置等等。
- en: Nonetheless, one of the advantages of the hierarchical designs is that derived
    classes can be added later without modifying any of the code written to operate
    on the hierarchy. The new virtual function simply plugs into the existing control
    flow and provides the necessary customized behavior. We can implement the same
    idea for the factory constructor.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，分层设计的优点之一是，可以在不修改任何操作该层次结构的代码的情况下，稍后添加派生类。新的虚拟函数只需插入到现有的控制流程中，并提供必要的定制行为。我们可以为工厂构造函数实现同样的想法。
- en: 'First of all, each derived class has to be responsible for constructing itself.
    This is necessary because, as we have already learned, the explicit call to the
    constructor has to be written somewhere. If it’s not in the generic code, it has
    to be a part of the code that is added when a new derived class is created. For
    example, we can have a static factory function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，每个派生类都必须负责构建自身。这是必要的，因为我们已经了解到，显式调用构造函数必须在某个地方编写。如果它不在通用代码中，它就必须是创建新派生类时添加的代码的一部分。例如，我们可以有一个静态工厂函数：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Second, the list of the types has to be extensible at runtime instead of being
    fixed at compile time. We could still use an `enum`, but then it would have to
    be updated every time a new derived class is added. Alternatively, we could assign
    each derived class an integer identifier at runtime, making sure that the identifiers
    are unique. Either way, we need a map of these identifiers to the factory functions,
    and it cannot be a `switch` statement or anything else that is fixed at compile
    time. The map has to be extensible. We could use `std::map` for this, but, if
    the type identifiers are integers, we can also use a `std::vector` of function
    pointers indexed by the type identifier:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，类型的列表必须在运行时可扩展，而不是在编译时固定。我们仍然可以使用`enum`，但每次添加新的派生类时，它都必须更新。或者，我们可以在运行时为每个派生类分配一个整数标识符，确保标识符是唯一的。无论如何，我们需要一个将这些标识符映射到工厂函数的映射，而且它不能是一个在编译时固定的`switch`语句或其他任何东西。这个映射必须是可扩展的。我们可以使用`std::map`来实现这一点，但如果类型标识符是整数，我们也可以使用一个按类型标识符索引的函数指针的`std::vector`：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, to register a new type, we just need to generate a new identifier and
    add the corresponding factory function to the vector:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了注册一个新的类型，我们只需生成一个新的标识符，并将相应的工厂函数添加到向量中：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This registration machinery can be encapsulated in the base class itself:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种注册机制可以封装在基类本身中：
- en: '[PRE29]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This base class has the factory function table and the count of registered
    derived types as static data members. It also has two static functions: one to
    register new types and one to construct an object of one of the types registered
    with the class. Note that the registration function returns the type identifier
    it has associated with the factory function. We are going to use this momentarily.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基类具有工厂函数表和已注册派生类型的计数作为静态数据成员。它还具有两个静态函数：一个用于注册新类型，另一个用于构造类中注册的一个类型的对象。请注意，注册函数返回与工厂函数关联的类型标识符。我们很快就会用到这个。
- en: 'Now, we just need to add every new building type to the registry. This is done
    in two steps—first, we need to add a registration method to every building class,
    like so:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将每个新的建筑类型添加到注册表中。这是分两步完成的——首先，我们需要为每个建筑类添加一个注册方法，如下所示：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Second, we need to arrange for all `Register()` methods to be called before
    the game begins and make sure we know the right identifier for every building
    type. This is where the value returned by the `RegisterBuilding()` function becomes
    important because we are going to store it as the type identifier inside the class
    itself:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们需要确保在游戏开始之前调用所有`Register()`方法，并确保我们知道每个建筑类型的正确标识符。这就是`RegisterBuilding()`函数返回的值变得重要的地方，因为我们将它作为类型标识符存储在类内部：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The registration happens during the initialization of the static variables,
    sometime before `main()` is started.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注册发生在静态变量的初始化过程中，在`main()`开始之前。
- en: 'The factory functions do not have to be static member functions: anything that
    can be invoked via a function pointer will work. For example, we could use a lambda
    without captures:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂函数不必是静态成员函数：任何可以通过函数指针调用的东西都可以工作。例如，我们可以使用没有捕获的lambda：
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have to explicitly specify the return type because the function pointer type
    is defined as a function with no argument that returns `Building*`, while the
    lambda is deduced as a function returning `Farm*` unless we cast the return value
    or specify the return type.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须显式指定返回类型，因为函数指针类型被定义为没有参数且返回`Building*`的函数，而lambda被推断为返回`Farm*`的函数，除非我们转换返回值或指定返回类型。
- en: 'Now, a call to `Building::MakeBuilding(tag)` will construct an object of the
    type that’s registered with the identifier `tag`. The value of the tag – the type
    identifier – is stored as a static member in every class, so we don’t have to
    know what it is and can’t make a mistake:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，调用`Building::MakeBuilding(tag)`将构造一个与标识符`tag`注册的类型对象。标签的值——类型标识符——作为每个类的静态成员存储，因此我们不必知道它，也不会出错：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In our solution, the correspondence between the identifier values and the types
    is not known until runtime—we cannot say what building has the ID of 5 until we
    run the program. Usually, we do not need to know that since the right value is
    automatically stored in each class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的解决方案中，标识符值与类型之间的对应关系直到运行时才知道——在我们运行程序之前，我们无法说出哪个建筑物的ID是5。通常，我们不需要知道这一点，因为正确的值会自动存储在每个类中。
- en: Note that this implementation is very similar to the code that the compilers
    generate for true virtual functions—virtual function calls are done through function
    pointers that are stored in tables and accessed by means of a unique identifier
    (the virtual pointer). The main difference is that the unique identifier is the
    static data member associated with each type. Nonetheless, this is as close to
    a *virtual constructor* as you can get.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个实现与编译器为真正的虚函数生成的代码非常相似——虚函数调用是通过存储在表中并通过唯一标识符（虚指针）访问的函数指针完成的。主要区别是唯一标识符是与每个类型关联的静态数据成员。尽管如此，这几乎就是一个*虚拟构造函数*。
- en: There are many variants of this dynamic type registry pattern. In some cases,
    it is preferable to explicitly specify the type identifiers instead of generating
    them at the program startup time. In particular, readable names such as “farm”
    and “forge” can be useful. In this case, instead of a vector, we can store the
    factory function pointers in a `std::map` container indexed by strings (`std::map<std::string,
    BuildingFactory>`).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种动态类型注册模式有许多变体。在某些情况下，显式指定类型标识符比在程序启动时生成它们更好。特别是像“农场”和“锻造厂”这样的可读名称可能很有用。在这种情况下，我们可以将工厂函数指针存储在以字符串为索引的`std::map`容器中（`std::map<std::string,
    BuildingFactory>`）。
- en: 'Another modification is to allow more general callable objects as factory functions.
    We can generalize the `BuildingFactory` type by using `std::function` instead
    of the function pointer:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个修改是允许更通用的可调用对象作为工厂函数。我们可以通过使用`std::function`而不是函数指针来泛化`BuildingFactory`类型：
- en: '[PRE34]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can still register and use static factory methods as factories for our derived
    classes, but we can also use lambdas and custom functors:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以将静态工厂方法注册并用作派生类的工厂，但我们也可以使用lambda和自定义仿函数：
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The implementation of these dynamic factories, whether it is done with a function
    pointer or a more general std::function, strongly resembles the type erasure pattern
    we have explored in [*Chapter 6*](B19262_06.xhtml#_idTextAnchor266), *Understanding
    Type Erasure*. The concrete type of object to construct is embedded in the code
    of the function or functor whose declaration makes no mention of these types.
    This allows us to store these functions in a single function table or map. Other
    implementations of type erasure from [*Chapter 6*](B19262_06.xhtml#_idTextAnchor266),
    *Understanding Type Erasure*, can be used as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动态工厂的实现，无论是使用函数指针还是更通用的 std::function，都与我们在[*第6章*](B19262_06.xhtml#_idTextAnchor266)，“理解类型擦除”中探讨的类型擦除模式非常相似。要构建的对象的具体类型嵌入在函数或函数对象的代码中，其声明没有提及这些类型。这允许我们将这些函数存储在单个函数表或映射中。同样，[*第6章*](B19262_06.xhtml#_idTextAnchor266)，“理解类型擦除”中的其他类型擦除实现也可以使用。
- en: 'For simplicity, we did not use any arguments for our factory methods. We did,
    however, explore the options for passing arguments in the previous section. The
    variadic templates do not work well with function pointers (we have to declare
    the signature of the factory function upfront), so the most likely pattern for
    passing arguments is going to be the parameter spec object:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们没有为我们的工厂方法使用任何参数。然而，我们在上一节中探讨了传递参数的选项。可变模板与函数指针（我们必须提前声明工厂函数的签名）配合得不好，因此传递参数的最可能模式将是参数规范对象：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In all of our factory constructors so far, the decision about which object to
    construct was driven by the external input to the program, and the construction
    was done by the same factory method (possibly using delegation to the derived
    classes). We will now see a different variant of the factory, which is used to
    address a slightly different scenario.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止的所有工厂构造函数中，关于构建哪个对象的决策是由程序的外部输入驱动的，并且构建是通过相同的工厂方法完成的（可能使用对派生类的委托）。现在我们将看到工厂的不同变体，它用于解决一个稍微不同的场景。
- en: Polymorphic factory
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态工厂
- en: Consider a slightly different problem—imagine that, in our game, each building
    produces a unit of some kind, and the type of the unit is uniquely associated
    with the type of the building. The Castle recruits knights, the Wizard Tower trains
    mages, and the Spider Mound produces giant spiders. Now, our generic code not
    only constructs a building of the type that is selected at runtime but also creates
    new units whose types are also not known at compile time. We already have the
    building factory. We could implement the Unit factory in a similar way, where
    every building has a unique unit identifier associated with it. But this design
    exposes the correspondence between the units and the buildings to the rest of
    the program, and that is really not necessary—each building knows how to build
    the *right* unit; there is no reason for the rest of the program to know it too.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个稍微不同的问题——想象在我们的游戏中，每个建筑都生产某种单位，并且单位的类型与建筑的类型唯一相关联。城堡招募骑士，巫师塔训练法师，蜘蛛山产生巨型蜘蛛。现在，我们的通用代码不仅构建在运行时选择的建筑类型，还创建新的单位，其类型在编译时也不为人知。我们已经有建筑工厂。我们可以以类似的方式实现单位工厂，其中每个建筑都有一个与其关联的唯一单位标识符。但这个设计将单位与建筑之间的对应关系暴露给了程序的其他部分，这实际上并不是必要的——每个建筑都知道如何构建*正确的*单位；程序的其他部分没有必要也知道它。
- en: 'This design challenge calls for a slightly different factory—the factory method
    determines that a unit is created, but exactly which unit is decided by the building.
    This is the Template pattern in action, combined with the Factory pattern—the
    overall design is the Factory, but the unit type is customized by the derived
    classes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计挑战需要一种稍微不同的工厂——工厂方法决定创建一个单位，但确切是哪个单位则由建筑来决定。这是模板模式的应用，结合了工厂模式——整体设计是工厂，但单位类型由派生类定制：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Each building has a factory for creating the corresponding unit, and we can
    access these factory methods through the base class `Building`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每座建筑都有一个用于创建相应单位的工厂，我们可以通过基类 `Building` 访问这些工厂方法：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The factory that uses polymorphism and is accessed via a virtual function in
    the base class – usually a pure virtual function – is known as the Abstract Factory
    pattern.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多态并通过基类中的虚拟函数（通常是纯虚拟函数）访问的工厂被称为抽象工厂模式。
- en: The factory methods for the buildings themselves are not shown in this example—the
    Unit factory can coexist with any of the building factory implementations we have
    learned (the source code example that accompanies this chapter uses the building
    factory from Example 12). The generic code that constructs units from buildings
    is written once and does not need to change when new derived classes for buildings
    and units are added.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中没有展示建筑本身的工厂方法——单元工厂可以与我们所学的任何建筑工厂实现共存（伴随本章的源代码示例使用的是示例 12 中的建筑工厂）。从建筑构建单位的通用代码只写一次，当添加新的建筑和单位派生类时不需要更改。
- en: Note that the return types of all `MakeUnit()` functions are different. Nonetheless,
    they are all overrides of the same virtual `Building::MakeUnit()` function. These
    are known as the *covariant return types*—the return type of the override method
    may be a derived class of the return type of the overridden method. In our case,
    return types match the class types, but in general, this is not required. Any
    base and derived classes can be used as covariant types, even if they come from
    a different hierarchy. However, only such types can be covariant, and, other than
    that exception, the return type of the override must match the base class virtual
    function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有 `MakeUnit()` 函数的返回类型都不同。尽管如此，它们都是同一虚拟 `Building::MakeUnit()` 函数的重写。这些被称为**协变返回类型**——重写方法的返回类型可能是被重写方法返回类型的派生类。在我们的例子中，返回类型与类类型相匹配，但通常这并不是必需的。任何基类和派生类都可以用作协变类型，即使它们来自不同的层次结构。然而，只有这样的类型才能是协变的，除此之外的例外，重写的返回类型必须与基类虚拟函数相匹配。
- en: The strict rules for covariant return types present some problems when we try
    and make factories return anything other than a raw pointer. For example, let’s
    assume that we want to return `std::unique_ptr` instead of the raw pointer. But,
    unlike `Unit*` and `Knight*`, `std::unique_ptr<Unit>` and `std::unique_ptr<Knight>`
    are not covariant types and cannot be used as return types for a virtual method
    and its override.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使工厂返回除原始指针之外的内容时，协变返回类型的严格规则会带来一些问题。例如，假设我们想要返回 `std::unique_ptr` 而不是原始指针。但是，与
    `Unit*` 和 `Knight*` 不同，`std::unique_ptr<Unit>` 和 `std::unique_ptr<Knight>` 不是协变类型，不能用作虚拟方法和其重写的返回类型。
- en: We will consider solutions for this, and several other C++-specific problems
    related to factory methods, in the next section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节考虑这个解决方案以及与工厂方法相关的几个其他特定于 C++ 的问题。
- en: Factory-like patterns in C++
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 中的工厂类似模式
- en: There are many variations of the basic Factory patterns used in C++ to address
    specific design needs and constraints. In this section, we will consider several
    of them. This is by no means an exclusive list of factory-like patterns in C++,
    but understanding these variants should prepare the reader for combining the techniques
    that they have learned from this book to address various design challenges related
    to object factories.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中，用于解决特定设计需求和约束的基本工厂模式的变体有很多。在本节中，我们将考虑其中的一些。这绝对不是 C++ 中工厂类似模式的独家列表，但理解这些变体应该为读者准备将他们从本书中学到的技术结合起来，以解决与对象工厂相关的各种设计挑战。
- en: Polymorphic copy
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态复制
- en: So far, we have considered factory alternatives to the object constructor—either
    the default constructor or one of the constructors with arguments. However, a
    similar pattern can be applied to the copy constructor—we have an object, and
    we want to make a copy.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们考虑了对象构造函数的替代方案——要么是默认构造函数，要么是带有参数的构造函数之一。然而，可以将类似的模式应用于复制构造函数——我们有一个对象，我们想要复制它。
- en: This is a similar problem in many ways—we have an object that’s accessed through
    the base class pointer, and we want to call its copy constructor. For the reasons
    we discussed earlier, not the least of which is that the compiler needs to know
    how much memory to allocate, the actual constructor call has to be done on the
    statically determined type. However, the control flow that gets us to a particular
    constructor call can be determined at runtime, and that, again, calls for an application
    of the Factory pattern.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这在许多方面是一个类似的问题——我们有一个通过基类指针访问的对象，我们想要调用它的复制构造函数。由于我们之前讨论的原因，包括编译器需要知道分配多少内存在内的原因，实际的构造函数调用必须在静态确定的类型上完成。然而，将我们带到特定构造函数调用的控制流可以在运行时确定，这再次需要应用工厂模式。
- en: 'The factory method we will use to implement a polymorphic copy is somewhat
    similar to the Unit factory example from the previous section—the actual construction
    has to be done by each derived class, and the derived class knows what type of
    object to construct. The base class implements the control flow that dictates
    that someone’s copy will be constructed, and the derived class customizes the
    construction part:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的工厂方法来实现多态复制与上一节中的 Unit 工厂示例有些相似——实际的构建必须由每个派生类来完成，派生类知道要构建哪种类型的对象。基类实现了控制流，决定了将构建某个人的副本，并且派生类定制了构建部分：
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can use the typeid operator (possibly with the demangling function we used
    earlier in this chapter) to verify that the pointer `b1` does indeed point to
    a `Derived` object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 typeid 操作符（可能结合本章前面使用过的解名函数）来验证指针 `b1` 确实指向一个 `Derived` 对象。
- en: 'We have just implemented polymorphic copying using inheritance. Earlier, in
    [*Chapter 6*](B19262_06.xhtml#_idTextAnchor266), *Understanding Type Erasure*,
    we have seen another way to copy objects whose type was known at construction
    time but later lost (or erased). The two approaches are not fundamentally different:
    when implementing type-erased copying, we built a virtual table ourselves. In
    this chapter, we had the compiler do it for us. The preferred implementation in
    any particular case will depend mostly on what else is going on in the code around
    it.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚通过继承实现了多态复制。在[*第 6 章*](B19262_06.xhtml#_idTextAnchor266) *理解类型擦除*中，我们看到了另一种在构建时已知类型但后来丢失（或擦除）的对象的复制方法。这两种方法在本质上并没有不同：在实现类型擦除复制时，我们自行构建了一个虚表。在本章中，我们让编译器为我们完成这项工作。在任何特定情况下，首选的实现方式主要取决于代码周围的其它内容。
- en: 'Note that, once again, we are using covariant return types, and, therefore,
    are limited to the raw pointers. Let’s say that we want to return unique pointers
    instead. Since only the raw pointers to the base and derived types are considered
    covariant, we have to always return the unique pointer to the base class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们又使用了协变返回类型，因此我们被限制为只能返回原始指针。假设我们想返回唯一指针。由于只有基类和派生类的原始指针被认为是协变的，我们必须始终返回基类唯一指针：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In many cases, this is not a significant limitation. Sometimes, however, it
    can lead to unnecessary conversions and casts. If returning a smart pointer to
    the exact type is important, there is another version of this pattern that we
    will consider next.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，这并不是一个重大的限制。然而，有时它可能导致不必要的转换和强制类型转换。如果返回精确类型的智能指针很重要，我们将考虑这个模式的另一个版本。
- en: CRTP Factory and return types
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRTP 工厂和返回类型
- en: 'The only way we could return `std::unique_ptr<Derived>` from the factory copy
    constructor of the derived class is to make the virtual `clone()` method of the
    base class return the same type. But this is impossible, at least if we have more
    than one derived class—for each derived class, we would need the return type of
    `Base::clone()` to be that class. But there is only one `Base::clone()`! Or is
    there? Fortunately, in C++, we have an easy way of making many out of one—the
    templates. If we template the base class, we could make the base of each derived
    class return the right type. But to do this, we need the base class to somehow
    know the type of the class that will be derived from it. Of course, there is a
    pattern for that, too—in C++, it is called the Curiously Recurring Template Pattern,
    which we looked at in [*Chapter 8*](B19262_08.xhtml#_idTextAnchor360), *The Curiously
    Recurring Template Pattern*. Now, we can combine the CRTP and the Factory patterns:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从派生类的工厂复制构造函数中返回 `std::unique_ptr<Derived>` 的唯一方法是将基类的虚拟 `clone()` 方法返回相同的类型。但这是不可能的，至少如果我们有多个派生类——对于每个派生类，我们需要
    `Base::clone()` 的返回类型是该类。但只有一个 `Base::clone()`！或者有吗？幸运的是，在 C++ 中，我们有一种简单的方法可以将一个变成多个——那就是模板。如果我们模板化基类，我们就可以使每个派生类的基类返回正确的类型。但要做到这一点，我们需要基类以某种方式知道将从它派生出的类的类型。当然，也有一个模式，在
    C++ 中被称为“奇特重复模板模式”，我们在[*第 8 章*](B19262_08.xhtml#_idTextAnchor360) *奇特重复模板模式*中讨论过。现在，我们可以结合
    CRTP 和工厂模式：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`auto` return types make writing code like this significantly less verbose.
    In this book, we generally don’t use them to make it clear which function returns
    what.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto` 返回类型使得编写这样的代码显著减少了冗余。在这本书中，我们通常不使用它们来明确指出哪个函数返回什么。'
- en: 'The template parameter of the `Base` class is one of the classes derived from
    it, hence the naming. If you wish, you can even enforce this restriction with
    a static assert:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Base`类的模板参数是从它派生的一个类，因此得名。如果你愿意，甚至可以使用静态断言来强制这种限制：'
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The reason we had to hide the static assert in the class constructor is that
    within the declaration of the class itself, the type `Derived` is incomplete.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将静态断言隐藏在类构造函数中的原因是在类本身的声明中，`Derived`类型是不完整的。
- en: 'Note that, since the `Base` class now knows the type of the derived class,
    we don’t even need the `clone()` method to be virtual:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`Base`类现在知道派生类的类型，我们甚至不需要`clone()`方法为虚函数：
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There are significant downsides to this method, at least regarding the way we
    have implemented it so far. First of all, we had to make the base class a template,
    which means that we no longer have a common pointer type to use in our general
    code (or we have to make an even wider use of templates). Second, this approach
    only works if no more classes are derived from the `Derived` class, because the
    type of the base class does not track the second derivation—only the one that
    instantiated the `Base` template. Overall, except for the specific cases where
    it is very important to return the exact type instead of the base type, this approach
    cannot be recommended.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法存在一些显著的缺点，至少就我们迄今为止的实现方式而言。首先，我们必须将基类做成模板，这意味着我们不再有一个通用的指针类型可以在我们的通用代码中使用（或者我们必须更广泛地使用模板）。其次，这种方法只有在没有更多类从`Derived`类派生时才有效，因为基类的类型不跟踪第二次派生——只有实例化了`Base`模板的那个派生。总的来说，除了在必须返回确切类型而不是基类型的情况下非常重要的一些特定情况外，这种方法不推荐使用。
- en: On the other hand, there are some attractive features of this implementation
    that we may want to preserve. Specifically, we got rid of the multiple copies
    of the `clone()` function, one per each derived class, and got a template to generate
    them for us automatically. In the next section, we will show you how to retain
    that useful feature of the CRTP implementation, even if we have to give up on
    extending the notion of *covariant return types* to cover smart pointers by playing
    template tricks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这种实现有一些吸引人的特性，我们可能希望保留。具体来说，我们消除了`clone()`函数的多个副本，每个派生类一个，并得到了一个模板来为我们自动生成它们。在下一节中，我们将向您展示如何保留CRTP实现的有用特性，即使我们必须放弃通过模板技巧将协变返回类型的概念扩展到智能指针。
- en: CRTP for Factory implementation
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRTP用于工厂实现
- en: 'We have mentioned several times by now that, while CRTP is sometimes used as
    a design instrument, it is just as likely to be used as an implementation technique.
    We will now focus on using CRTP to avoid writing the `clone()` function in every
    derived class. This is not just done to reduce typing—the more code is written—especially
    very similar code that gets copied and modified—the more likely you are to make
    an error. We have already seen how to use CRTP to generate a version of `clone()`
    for every derived class automatically. We just don’t want to give up the common
    (non-template) base class to do so. We don’t really have to do so if we delegate
    the cloning to the special base class that handles only that:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经多次提到，虽然CRTP有时被用作设计工具，但它同样可能被用作实现技术。现在我们将专注于使用CRTP来避免在每个派生类中编写`clone()`函数。这不仅仅是为了减少打字——代码写得越多——特别是那些被复制和修改的非常相似的代码——你犯错误的可能性就越大。我们已经看到如何使用CRTP自动为每个派生类生成一个`clone()`版本。我们只是不想为了这样做而放弃通用的（非模板）基类。如果我们把克隆委托给只处理那个的特殊基类，我们实际上并不需要这样做：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, for simplicity, we went back to returning raw pointers, although we could
    also return `std::unique_ptr<Base>`. What we cannot do is return `Derived*` since,
    at the time when the template for the `Cloner` is parsed, it is not known that
    `Derived` is always derived from `Base`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为了简单起见，我们回到了返回原始指针，尽管我们也可以返回`std::unique_ptr<Base>`。我们无法返回`Derived*`，因为在解析`Cloner`模板时，并不知道`Derived`总是从`Base`派生。
- en: 'This design allows us to derive any number of classes from `Base`, indirectly
    through `Cloner`, and not have to write another `clone()` function ever again.
    It still has the limitation that, if we derive another class from `Derived`, it
    will not be copied correctly. In many designs, this is not an issue—enlightened
    self-interest should guide you to avoid deep hierarchies and make all classes
    be one of two kinds: abstract base classes that are never instantiated, and concrete
    classes that are derived from one of these base classes, but never from another
    concrete class.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计使我们能够从`Base`派生出任意数量的类，通过`Cloner`间接实现，而且再也不需要编写另一个`clone()`函数。它仍然存在一个限制，即如果我们从`Derived`派生另一个类，它将无法正确复制。在许多设计中，这并不是一个问题——明智的自利应该引导你避免深层层次结构，并使所有类成为两种类型之一：永远不会实例化的抽象基类，以及从这些基类之一派生出来的具体类，但永远不会从另一个具体类派生。
- en: Factory and Builder
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂和Builder
- en: 'So far, we have been using mostly factory functions, or, more generally, functors
    such as lambdas. In practice, it is just as likely that we will need a factory
    class. This usually happens because the run-time information needed to construct
    an object is more complex than just the type identifier and a few arguments. These
    are the same reasons we may choose to use the Builder pattern to create objects,
    so a factory class can also be viewed as a builder class with a factory method
    used to create the concrete objects. The Unit factory we have seen earlier in
    this chapter is an example of such a pattern: the Building class and all of its
    derived classes act like a builder for the unit objects (and the fact that the
    building objects themselves are created by another factory only serves as yet
    another demonstration that even a simple piece of code can rarely be reduced to
    a single pattern). In that case, however, we had a special motive for using the
    factory class: each derived building class constructs its own unit objects.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要使用的是工厂函数，或者更一般地说，是像lambda这样的函数对象。在实践中，我们同样可能需要一个工厂类。这通常是因为构建对象所需的运行时信息比仅仅类型标识符和一些参数更复杂。这也是我们可能选择使用Builder模式来创建对象的原因，因此工厂类也可以被视为一个具有工厂方法的构建类，用于创建具体对象。我们在本章前面看到的Unit工厂就是一个这样的模式示例：Building类及其所有派生类充当单元对象的构建器（而且建筑对象本身是由另一个工厂创建的，这又是一个证明，即即使是简单的代码也很难仅用一种模式来简化）。然而，在这种情况下，我们使用工厂类有一个特殊的原因：每个派生建筑类都构建自己的单元对象。
- en: 'Let us now consider a more common case for using a factory class: the overall
    complexity of the run-time data that goes into deciding which class to construct
    and how, as well as the non-trivial amount of code we need to do so. While it
    is possible to handle it all with a factory function and some global objects,
    it would be a poor design, lacking in cohesion and encapsulation. It is going
    to be error-prone and difficult to maintain. It is much better to encapsulate
    all related code and data into one class or a small number of related classes.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在考虑使用工厂类的一个更常见的场景：决定构建哪个类以及如何构建的运行时数据的整体复杂性，以及我们需要执行此操作的非平凡代码量。虽然我们可以使用工厂函数和一些全局对象来处理所有这些，但这将是一个糟糕的设计，缺乏凝聚力和封装。这将容易出错且难以维护。将所有相关代码和数据封装到一个类或少数相关类中会更好。
- en: For this example, we are going to tackle the very common (and still very challenging)
    serialization/deserialization problem. In our case, we have a number of objects
    derived from the same base class. We want to implement the framework necessary
    to serialize them by writing them into a file and then restoring the objects from
    this file. In this final example of the chapter, we are going to combine several
    methods we have learned to design and implement the factory.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将解决一个非常常见（但仍然具有挑战性）的序列化/反序列化问题。在我们的情况下，我们有一些从相同基类派生的对象。我们希望通过将它们写入文件来实现序列化，然后从该文件中恢复对象。在本章的最后一个例子中，我们将结合我们学到的几种方法来设计和实现工厂。
- en: 'We are going to start with the base class. The base class is going to utilize
    the dynamic type registry we learned earlier. Also, it is going to declare a pure
    virtual `Serialize()` function that every derived class needs to implement to
    serialize itself into a file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从基类开始。基类将利用我们之前学到的动态类型注册表。此外，它将声明一个纯虚`Serialize()`函数，每个派生类都需要实现以将自身序列化到文件中：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Any derived class needs to implement the `Serialize()` function as well as
    register the deserialization function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 任何派生类都需要实现`Serialize()`函数以及注册反序列化函数：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Only the derived class itself has the information about its state, what must
    be saved in order to reconstitute the object, and how to do so. In our example,
    the serialization is always done in the `Serialize()` function, while the deserialization
    is done in the lambda we register with the type registry. Needless to say, the
    two must be consistent with each other. There are template-based tricks that can
    ensure this consistency, but they aren’t relevant to the factory construction
    we are studying now.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 只有派生类本身才有关于其状态的信息，为了重新构成对象必须保存什么，以及如何保存。在我们的例子中，序列化总是在`Serialize()`函数中完成的，而反序列化是在我们向类型注册表中注册的lambda中完成的。不用说，这两者必须相互一致。有一些基于模板的技巧可以确保这种一致性，但它们与我们正在研究的工厂构建无关。
- en: 'We have the serialization part handled – all we need to do is call Serialize
    on any object we have:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经处理了序列化部分——我们只需要在任何一个对象上调用Serialize即可：
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The deserialization itself is not particularly hard (most of the work is done
    by the derived classes), but there is enough boilerplate code there to justify
    a factory class. A factory object will read the entire file and deserialize (re-create)
    all objects recorded there. There are, of course, many options for the destination
    of such objects. Since we are constructing objects whose types are not known at
    compile-time, we have to access them through the base class pointers. For example,
    we can store them in a container of unique pointers:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化本身并不特别困难（大部分工作由派生类完成），但其中足够的样板代码足以证明工厂类的必要性。工厂对象将读取整个文件并反序列化（重新创建）其中记录的所有对象。当然，这些对象有许多可能的用途。由于我们正在构建在编译时类型未知的对象，我们必须通过基类指针来访问它们。例如，我们可以将它们存储在唯一指针的容器中：
- en: '[PRE48]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This factory reads the entire file, line by line. First, it reads just the
    type identifier (which each object must write during serialization). Based on
    that identifier, it dispatches the rest of the deserialization process to the
    correct function registered for the corresponding type. The factory uses an inserter
    iterator (such as a back-inserter) to store all deserialized objects in a container:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工厂逐行读取整个文件。首先，它只读取类型标识符（每个对象在序列化时都必须写入）。基于这个标识符，它将剩余的反序列化过程调度到为相应类型注册的正确函数。工厂使用插入迭代器（如后插入迭代器）将所有反序列化的对象存储在容器中：
- en: '[PRE49]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With this approach, we can handle any class derived from SerializerBase, as
    long as we can come up with a way to write it into a file and restore it. We can
    handle a more complex state and constructors with multiple arguments:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以处理任何从SerializerBase派生的类，只要我们能想出一个将其写入文件并恢复的方法。我们可以处理更复杂的状态和具有多个参数的构造函数：
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can equally easily deal with classes that have multiple constructors as
    long as we know how a particular object should be constructed again:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们知道如何再次构造一个特定的对象，我们同样可以轻松地处理具有多个构造函数的类：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: There are many more variations of the factory pattern in C++. If you understood
    the explanations and followed through with the examples in this chapter, none
    of these alternatives should present a particular challenge for you.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: C++中有许多工厂模式的变体。如果你理解了本章的解释并跟随了示例，这些替代方案对你来说应该不会构成特别的挑战。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned why constructors cannot be made virtual, and
    what to do when we really want a virtual constructor anyway. We have learned how
    to construct and copy objects whose type becomes known at runtime by using the
    Factory pattern and one of its variations. We also explored several implementations
    of the Factory constructor that differ in the way that the code is organized and
    that the behavior is delegated to different components of the system, and compared
    their advantages and trade-offs. We have also seen how multiple design patterns
    interact with each other.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了为什么不能使构造函数成为虚拟的，以及当我们真的需要一个虚拟构造函数时应该做什么。我们学习了如何通过使用工厂模式和其变体之一来构建和复制在运行时类型已知的对象。我们还探讨了几个工厂构造函数的实现，它们在代码组织方式和将行为委派给系统不同组件的方式上有所不同，并比较了它们的优缺点。我们还看到了多个设计模式如何相互作用。
- en: While in C++, the constructor has to be invoked with the true type of the object
    to construct—always—this does not mean that the application code has to specify
    the complete type. The Factory pattern allows us to write code that specifies
    the type indirectly, using an identifier that is associated with the type elsewhere
    (*create an object of the third kind*), or an associated object type (*create
    a unit that goes with this building type*), or even the same type (*make me a
    copy of this, whatever* *it is*).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然，在C++中，构造函数必须使用要构造的对象的真实类型来调用——总是这样——但这并不意味着应用程序代码必须指定完整的类型。工厂模式允许我们编写代码，通过使用与类型关联的标识符间接指定类型（*创建第三种类型的对象*），或关联的对象类型（*创建与这种建筑类型相匹配的单位*），甚至相同的类型（*给我一个这个的副本，无论它是什么*）。
- en: The next design pattern we will study in the following chapter is the Template
    Method pattern, one of the classic object-oriented patterns that, in C++, has
    additional implications for the way we design class hierarchies.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习的设计模式是模板方法模式，这是经典面向对象模式之一，在C++中，它对我们设计类层次结构有额外的含义。
- en: Questions
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why does C++ not allow a virtual constructor?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么C++不允许虚拟构造函数？
- en: What is the Factory pattern?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂模式是什么？
- en: How do you use the Factory pattern to achieve the effect of a virtual constructor?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用Factory模式来实现虚拟构造函数的效果？
- en: How do you achieve the effect of a virtual copy constructor?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何实现虚拟拷贝构造函数的效果？
- en: How do you use the Template and Factory patterns together?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何一起使用模板和Factory模式？
- en: How do you use the Builder and the Factory patterns together?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何一起使用Builder和Factory模式？
