- en: '*Chapter 3*: Testing with LLVM LIT'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第三章*：使用LLVM LIT进行测试'
- en: In the previous chapter, we learned how to take advantage of LLVM's own CMake
    utilities to improve our development experience. We also learned how to seamlessly
    integrate LLVM into other out-of-tree projects. In this chapter, we're going to
    talk about how to get hands-on with LLVM's own testing infrastructure, LIT.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何利用LLVM自己的CMake工具来提高我们的开发体验。我们还学习了如何无缝地将LLVM集成到其他树外项目中。在本章中，我们将讨论如何亲身体验LLVM自己的测试基础设施LIT。
- en: '**LIT** is a testing infrastructure that was originally developed for running
    LLVM''s regression tests. Now, it''s not only the harness for running all the
    tests in LLVM (both **unit** and **regression tests)** but also a generic testing
    framework that can be used outside of LLVM. It also provides a wide range of testing
    formats to tackle different scenarios. This chapter will give you a thorough tour
    of the components in this framework and help you master LIT.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**LIT**是一个最初为运行LLVM回归测试而开发的测试基础设施。现在，它不仅是运行LLVM中所有测试的框架（包括**单元**和**回归测试**），而且还是一个可以在LLVM之外使用的通用测试框架。它还提供了一系列测试格式来应对不同的场景。本章将为您详细介绍该框架的组件，并帮助您掌握LIT。'
- en: 'We are going to cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using LIT in out-of-tree projects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在树外项目中使用LIT
- en: Learning about advanced FileCheck tricks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解高级FileCheck技巧
- en: Exploring the TestSuite framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索TestSuite框架
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The core of LIT is written in *Python*, so please make sure you have Python
    2.7 or Python 3.x installed (Python 3.x is preferable, as LLVM is gradually retiring
    Python 2.7 now).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: LIT的核心是用*Python*编写的，所以请确保您已安装Python 2.7或Python 3.x（Python 3.x更佳，因为LLVM现在正在逐步淘汰Python
    2.7）。
- en: 'In addition, there are a bunch of supporting utilities, such as `FileCheck`,
    which will be used later. To build those utilities, the fastest way, unfortunately,
    is to build any of the `check-XXX` (phony) targets. For example, we could build
    `check-llvm-support`, as shown in the following code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些支持工具，例如`FileCheck`，稍后将使用。不幸的是，构建这些工具最快的方法是构建任何`check-XXX`（伪）目标。例如，我们可以构建`check-llvm-support`，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Finally, the last section requires that `llvm-test-suite` has been built, which
    is a separate repository from `llvm-project`. We can clone it by using the following
    command:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一节要求已构建`llvm-test-suite`，这是一个与`llvm-project`分开的仓库。我们可以使用以下命令克隆它：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The easiest way to configure the build will be using one of the cached CMake
    configs. For example, to build the test suite with optimizations (`O3`), we will
    use the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 配置构建的最简单方法之一是使用缓存的CMake配置文件。例如，为了以优化（`O3`）构建测试套件，我们将使用以下代码：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we can build it normally using the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令正常构建它：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using LIT in out-of-tree projects
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在树外项目中使用LIT
- en: 'Writing an in-tree LLVM IR regression test is pretty easy: all you need to
    do is annotate the IR file with testing directives. Look at the following script,
    for example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 编写树内LLVM IR回归测试非常简单：您只需在IR文件上添加测试指令即可。例如，看看以下脚本：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This script checks if `InstCombine` (triggered by the `-instcombine` command-line
    option shown in the preceding snippet) simplifies two succeeding arithmetic adds
    into one. After putting this file into an arbitrary folder under `llvm/test`,
    the script will automatically be picked and run as part of the regression test
    when you're executing the `llvm-lit` command-line tool.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本检查`InstCombine`（由前面片段中显示的`-instcombine`命令行选项触发）是否将两个连续的算术加法简化为一个。将此文件放入`llvm/test`下的任意文件夹后，当您执行`llvm-lit`命令行工具时，脚本将自动被选中并作为回归测试的一部分运行。
- en: Despite its convenience, this barely helps you use LIT in out-of-tree projects.
    Using LIT out-of-tree is especially useful when your project needs some end-to-end
    testing facilities, such as a format converter, a text processor, a linter, and,
    of course, a compiler. This section will show you how to bring LIT to your out-of-tree
    projects, and then provide you with a complete picture of the running flow of
    LIT.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它很方便，但这几乎不能帮助您在树外项目中使用LIT。在树外使用LIT特别有用，当您的项目需要一些端到端测试功能时，例如格式转换器、文本处理器、代码检查器和，当然，编译器。本节将向您展示如何将LIT带入您的树外项目，并提供LIT运行流程的完整概述。
- en: Preparing for our example project
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的示例项目做准备
- en: 'In this section, we will use an out-of-tree CMake project. This example project
    builds a command-line tool, `js-minifier`, that *minifies* arbitrary JavaScript
    code. We will transform the following JavaScript code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用树外 CMake 项目。此示例项目构建一个命令行工具，`js-minifier`，它可以*压缩*任意 JavaScript 代码。我们将转换以下
    JavaScript 代码：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will be transformed into some other *semantic-equivalent* code that is
    as short as possible:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被转换成尽可能短的*语义等效*代码：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Instead of teaching you how to write this `js-minifier`, the goal of this section
    is to show you how to create a LIT testing environment to *test* this tool.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是教您如何编写这个 `js-minifier`，本节的目标是向您展示如何创建一个 LIT 测试环境来*测试*这个工具。
- en: 'The example project has the following folder structure:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例项目具有以下文件夹结构：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The files under the `/src` folder contain the source code for `js-minifier`
    (which we are not going to cover here). What we will focus on here are the files
    that will be used for testing `js-minifier`, which sit under the `/test` folder
    (for now, there is only one file, `test.js`).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`/src` 文件夹下的文件包含 `js-minifier` 的源代码（我们在这里不会涉及）。我们将关注的是用于测试 `js-minifier` 的文件，这些文件位于
    `/test` 文件夹下（目前只有一个文件，`test.js`）。'
- en: 'In this section, we are going to set up a testing environment so that when
    we run `llvm-lit` – the testing driver and main character of this section – under
    the CMake `/build` folder, it will print testing results, like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设置一个测试环境，以便当我们运行 CMake `/build` 文件夹下的 `llvm-lit`（本节的测试驱动和主要角色）时，它会打印测试结果，如下所示：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This shows how many and what test cases have passed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了通过了多少个以及哪些测试用例。
- en: 'Here is the testing script, `test.js`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试脚本，`test.js`：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, it is a simple testing process that runs the `js-minifier` tool
    – represented by the `%jsm` directive, which will be replaced by the real path
    to `js-minifier` executable, as explained later – and checks the running result
    with `FileCheck` by using its `CHECK` and `CHECK-SAME` directives.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是一个简单的测试过程，它运行 `js-minifier` 工具（由 `%jsm` 指令表示，稍后将替换为 `js-minifier` 可执行文件的实际路径）并使用
    `FileCheck` 的 `CHECK` 和 `CHECK-SAME` 指令检查运行结果。
- en: With that, we've set up our example project. Before we wrap up the preparation,
    there is one final tool we need to create.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经设置了我们的示例项目。在我们完成准备工作之前，我们还需要创建一个最终的工具。
- en: 'Since we''re trying to cut down on our reliance on the LLVM source tree, recreate
    the `llvm-lit` command-line tool using the `LIT` package available in the *PyPi
    repository* (that is, the `pip` command-line tool). All you need to do is install
    that package:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们试图减少对 LLVM 源树的依赖，我们将使用 *PyPi 仓库*（即 `pip` 命令行工具）中可用的 `LIT` 包重新创建 `llvm-lit`
    命令行工具。您需要做的只是安装该包：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, wrap the package with the following script:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，用以下脚本包装该包：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, we can use LIT without building an LLVM tree! Next, we will create some
    LIT configuration scripts that will drive the whole testing flow.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 LIT 而不必构建 LLVM 树！接下来，我们将创建一些 LIT 配置脚本，这些脚本将驱动整个测试流程。
- en: Writing LIT configurations
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 LIT 配置
- en: 'In this subsection, we''ll show you how to write LIT configuration scripts.
    These scripts describe the testing process – where the files will be tested, the
    testing environment (if we need to import any tool, for example), the policy when
    there is a failure, and so on. Learning these skills can greatly improve how you
    use LIT in places outside the LLVM tree. Let''s get started:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将向您展示如何编写 LIT 配置脚本。这些脚本描述了测试过程——文件将在哪里被测试，测试环境（如果我们需要导入任何工具，例如），失败时的策略等等。学习这些技能可以极大地提高您在
    LLVM 树外使用 LIT 的效率。让我们开始吧：
- en: 'Inside the `/JSMinifier/test` folder, create a file called `lit.cfg.py` that
    contains the following content:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/JSMinifier/test` 文件夹内，创建一个名为 `lit.cfg.py` 的文件，其中包含以下内容：
- en: '[PRE12]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Following on from the code snippet in the previous step, LIT now needs two
    other pieces of information: the *root path* to the test files and the *working
    directory*:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步的代码片段之后，LIT 现在需要另外两块信息：测试文件的*根路径*和*工作目录*：
- en: '[PRE13]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `%jsm` directive we saw earlier in `test.js` is used as a placeholder that
    will eventually be replaced with the real/absolute path of the `js-minifier` executable.
    The following lines will set up the replacements:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `test.js` 中之前看到的 `%jsm` 指令用作占位符，最终将被替换为 `js-minifier` 可执行文件的实际/绝对路径。以下行将设置替换：
- en: '[PRE14]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, create a new file called `lit.site.cfg.py.in` and put it under the `/JSMinifier/test`
    folder. The first part of this file looks like this:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `lit.site.cfg.py.in` 的新文件，并将其放置在 `/JSMinifier/test` 文件夹下。该文件的前部分看起来如下：
- en: '[PRE15]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The mystery `config.my_obj_root` field is finally resolved here, but instead
    of pointing to a normal string, it is assigned to a weird value called `@CMAKE_BINARY_DIR@`.
    Again, this will be replaced by CMake with the real path later. The same goes
    for the `config.my_src_root` field.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个神秘的 `config.my_obj_root` 字段最终在这里得到了解决，但它不是指向一个普通字符串，而是被分配了一个叫做 `@CMAKE_BINARY_DIR@`
    的奇怪值。同样，这将在稍后由 CMake 替换为真实路径。对于 `config.my_src_root` 字段也是如此。
- en: 'Finally, `lit.site.cfg.py.in` is wrapped up by these lines:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`lit.site.cfg.py.in` 由以下行封装：
- en: '[PRE16]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, it''s time to replace those weird @-clamped strings with real values
    using CMake''s `configure_file` function. In `/JSMinifier/test/CMakeLists.txt`,
    add the following line somewhere inside the file:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，是时候使用 CMake 的 `configure_file` 函数替换那些奇怪的 @-夹住的字符串为真实值了。在 `/JSMinifier/test/CMakeLists.txt`
    中，在文件中某处添加以下行：
- en: '[PRE17]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: name = "@FOO@"
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: name = "@FOO@"
- en: age = @AGE@
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: age = @AGE@
- en: '[PRE18]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: set(FOO "John Smith")
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set(FOO "John Smith")
- en: set(AGE 87)
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set(AGE 87)
- en: configure_file(demo.txt.in
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: configure_file(demo.txt.in
- en: demo.txt @ONLY)
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: demo.txt @ONLY)
- en: '[PRE19]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: name = "John Smith"
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: name = "John Smith"
- en: age = 87
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: age = 87
- en: '[PRE20]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Back to the `lit.site.cfg.py.in` snippets, since `CMAKE_SOURCE_DIR` and `CMAKE_BINARY_DIR`
    are always available, they point to the root source folder and the `build` folder,
    respectively. The resulting `/JSMinifier/build/test/lit.site.cfg.py` will contain
    the following content:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `lit.site.cfg.py.in` 片段，由于 `CMAKE_SOURCE_DIR` 和 `CMAKE_BINARY_DIR` 总是可用的，它们分别指向根源文件夹和
    `build` 文件夹。生成的 `/JSMinifier/build/test/lit.site.cfg.py` 将包含以下内容：
- en: '[PRE21]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With that, we have learned how to write LIT configuration scripts for our example
    project. Now, it is time to explain some details of how LIT works internally,
    and why we need so many files (`lit.cfg.py`, `lit.site.cfg.py.in`, and `lit.site.cfg.py`).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学会了如何为我们的示例项目编写 LIT 配置脚本。现在，是时候解释一些 LIT 内部工作细节以及为什么我们需要这么多文件（`lit.cfg.py`、`lit.site.cfg.py.in`
    和 `lit.site.cfg.py`）了。
- en: LIT internals
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LIT 内部机制
- en: 'Let''s look at the following diagram, which illustrates the workflow of running
    LIT tests in the demo project we just created:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下图表，它说明了在我们刚刚创建的演示项目中运行 LIT 测试的工作流程：
- en: '![Figure 3.1 – The forking flow of LIT in our example project'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – LIT 在我们的示例项目中的分支流程'
- en: '](img/B14590_03_01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14590_03_01.jpg)'
- en: Figure 3.1 – The forking flow of LIT in our example project
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – LIT 在我们的示例项目中的分支流程
- en: 'Let''s take a look at this diagram in more detail:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个图表：
- en: '`lit.site.cfg.py.in` is copied to `/JSMinifier/build/lit.site.cfg.py`, which
    carries some CMake variable values.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lit.site.cfg.py.in` 被复制到 `/JSMinifier/build/lit.site.cfg.py`，它携带一些 CMake 变量值。'
- en: The `llvm-lit` command is launched inside `/JSMinifier/build`. It will execute
    `lit.site.cfg.py` first.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`llvm-lit` 命令在 `/JSMinifier/build` 内部启动。它将首先执行 `lit.site.cfg.py`。'
- en: '`lit.site.cfg.py` then uses the `load_configure` Python function to load the
    main LIT configurations (`lit.cfg.py`) and run all the test cases.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lit.site.cfg.py` 然后使用 `load_configure` Python 函数加载主 LIT 配置（`lit.cfg.py`）并运行所有测试用例。'
- en: 'The most crucial part of this diagram is explaining the roles of `lit.site.cfg.py`
    and `lit.site.cfg.py.in`: many parameters, such as the absolute path to the `build`
    folder, will remain unknown until the CMake configuration process is complete.
    So, a *trampoline* script – that is, `lit.site.cfg.py` – is placed inside the
    `build` folder to relay that information to the real test runner.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图表中最关键的部分是解释 `lit.site.cfg.py` 和 `lit.site.cfg.py.in` 的作用：许多参数，如 `build` 文件夹的绝对路径，将在
    CMake 配置过程完成之前保持未知。因此，放置了一个 *跳板* 脚本——即 `lit.site.cfg.py`——在 `build` 文件夹中，以将信息传递给真正的测试运行器。
- en: In this section, we learned how to write LIT configuration scripts for our out-of-tree
    example project. We also learned how LIT works under the hood. Knowing this can
    help you use LIT in a wide variety of projects, in addition to LLVM. In the next
    section, we will focus on `FileCheck`, a crucial and commonly used LIT utility
    that performs advanced pattern checking.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何为我们的树外示例项目编写 LIT 配置脚本。我们还学习了 LIT 在底层是如何工作的。了解这一点可以帮助你在除了 LLVM 以外的各种项目中使用
    LIT。在下一节中，我们将重点关注 `FileCheck`，这是一个关键且常用的 LIT 工具，它执行高级模式检查。
- en: Learning useful FileCheck tricks
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习有用的 FileCheck 技巧
- en: '`grep` command-line tool available in Unix/Linux systems, but provides a more
    powerful yet straightforward syntax for line-based contexts. Furthermore, the
    fact that you can put `FileCheck` directives beside the testing targets makes
    the test cases self-contained and easy to understand.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep` 命令行工具在 Unix/Linux 系统中可用，但提供了更强大且直观的基于行的上下文语法。此外，你可以在测试目标旁边放置 `FileCheck`
    指令，这使得测试用例自包含且易于理解。'
- en: Though basic `FileCheck` syntax is easy to get hands-on with, there are many
    other `FileCheck` functionalities that truly unleash the power of `FileCheck`
    and greatly improve your testing experiences – creating more concise testing scripts
    and parsing more complex program output, to name a few. This section will show
    you some of those skills.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基本的 `FileCheck` 语法很容易上手，但还有许多其他 `FileCheck` 功能真正释放了 `FileCheck` 的力量，并大大提高了你的测试体验——创建更简洁的测试脚本和解析更复杂的程序输出，仅举几例。本节将向你展示其中的一些技巧。
- en: Preparing for our example project
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备我们的示例项目
- en: 'The `FileCheck` command-line tool needs to be built first. Similar to the previous
    section, building one of the `check-XXX` (phony) targets in the LLVM tree is the
    easiest way to do so. The following is an example of this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要构建 `FileCheck` 命令行工具。类似于前面的章节，在 LLVM 树中构建一个 `check-XXX`（伪）目标是这样做最容易的方法。以下是一个示例：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this section, we are going to use an imaginary command-line tool called
    `js-obfuscator`, a JavaScript obfuscator, for our example. **Obfuscation** is
    a common technique that''s used to hide intellectual properties or enforce security
    protections. For example, we could use a real-world JavaScript obfuscator on the
    following JavaScript code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一个虚构的命令行工具 `js-obfuscator`，一个 JavaScript 混淆器，作为我们的示例。**混淆**是一种常用的技术，用于隐藏知识产权或实施安全保护。例如，我们可以在以下
    JavaScript 代码上使用一个真实的 JavaScript 混淆器：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This would transform it into the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将转换成以下代码：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This tool will try to make the original script as human-unreadable as possible.
    The challenge for the testing part is to verify its correctness while still reserving
    enough space for randomness. Simply put, `js-obfuscator` will only apply four
    obfuscation rules:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具将尝试使原始脚本尽可能难以阅读。测试部分的挑战是在保留足够随机空间的同时验证其正确性。简单来说，`js-obfuscator` 将仅应用四种混淆规则：
- en: Only obfuscate local variable names, including formal parameters. The formal
    parameter names should always be obfuscated in *<lower case word><argument index
    number>* format. The local variable names will always be obfuscated into a combination
    of lowercase and uppercase letters.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅混淆局部变量名，包括形式参数。形式参数名应始终以 *<小写单词><参数索引号>* 格式混淆。局部变量名将始终被混淆成小写和大写字母的组合。
- en: If we are declaring functions with the arrow syntax – for example, `let foo
    = (arg1, arg2) => {…}` – the arrow and the left curly brace (`=> {`) need to be
    put in the next line.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使用箭头语法声明函数——例如，`let foo = (arg1, arg2) => {…}`——箭头和左花括号（`=> {`）需要放在下一行。
- en: Replace a literal number with the same value but in a different representation;
    for example, replacing *87* with *0x57* or *87.000*.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个字面数字替换为相同值但不同表示形式；例如，将 *87* 替换为 *0x57* 或 *87.000*。
- en: When you supply the tool with the `--shuffle-funcs` command-line option, shuffle
    the declaration/appearing order of the top-level functions.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你向工具提供 `--shuffle-funcs` 命令行选项时，会打乱顶层函数的声明/出现顺序。
- en: 'Finally, the following JavaScript code is the example to be used with the `js-obfuscator`
    tool:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下 JavaScript 代码是用于 `js-obfuscator` 工具的示例：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Writing FileCheck directives
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 FileCheck 指令
- en: 'The following steps are going to fill in all the `TODO` comments that appeared
    in the preceding code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将填充前面代码中出现的所有 `TODO` 注释：
- en: 'Going according to the line number, the first task is to check whether the
    local variables and parameters have been obfuscated properly. According to the
    spec, formal parameters have special renaming rules (that is, *<lower case word><argument
    index number>*), so using the normal `CHECK` directive with FileCheck''s own regex
    syntax will be the most suitable solution here:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据行号，第一个任务是检查局部变量和参数是否被正确混淆。根据规范，形式参数有特殊的重命名规则（即，*<小写单词><参数索引号>*），因此使用正常的 `CHECK`
    指令与 FileCheck 的正则表达式语法将是此处最合适的解决方案：
- en: '[PRE26]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: FileCheck uses a subset of regular expressions for pattern matching, which are
    enclosed by either `{{…}}` or `[[…]]` symbols. We will cover the latter one shortly.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: FileCheck使用正则表达式的一个子集进行模式匹配，这些正则表达式被`{{…}}`或`[[…]]`符号包围。我们将在稍后介绍后者。
- en: 'This code looks pretty straightforward. However, the semantics of the code
    also need to be correct once obfuscation has been performed. So, in addition to
    checking the format, the succeeding references to those parameters need to be
    refactored as well, which is where FileCheck''s pattern binding comes in:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码看起来相当简单。然而，一旦执行了混淆，代码的语义也需要是正确的。所以，除了检查格式外，对那些参数的后续引用也需要重构，这就是FileCheck的模式绑定发挥作用的地方：
- en: '[PRE27]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s not forget the second rule – the arrow and left curly brace of the function
    header need to be put in the second line. To implement the concept of "the line
    after," we can use the `CHECK-NEXT` directive:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不要忘记第二条规则——函数头部的箭头和左花括号需要放在第二行。为了实现“下一行”的概念，我们可以使用`CHECK-NEXT`指令：
- en: '[PRE28]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, all the local variables and formal parameters are checked in `my_func1`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`my_func1`中检查所有局部变量和形式参数：
- en: '[PRE29]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '// CHECK: let [[OUT:[a-zA-Z]+]] ='
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '// CHECK: let [[OUT:[a-zA-Z]+]] ='
- en: '// CHECK: [[A0]] + [[IM]] - [[A1]];'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '// CHECK: [[A0]] + [[IM]] - [[A1]];'
- en: '[PRE30]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: let BGHr =
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let BGHr =
- en: r0 + jkF + r1;
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: r0 + jkF + r1;
- en: '[PRE31]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Going into `my_func2`, now, it''s time to check if the literal numbers have
    been obfuscated properly. The checking statement here is designed to accept any
    instances/patterns *except* the original numbers. Therefore, the `CHECK-NOT` directive
    will be sufficient here:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，进入`my_func2`，是时候检查数字是否被正确混淆了。这里的检查语句被设计为接受任何实例/模式*除了*原始数字。因此，`CHECK-NOT`指令在这里就足够了：
- en: '[PRE32]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, only one obfuscation rule needs to be verified: when the `js-obfuscator`
    tool is supplied with an additional command-line option, `--shuffle-funcs`, which
    effectively shuffles all top-level functions, we need to check whether the top-level
    functions maintain certain ordering, even after they have been shuffled. In JavaScript,
    functions are resolved when they''re called. This means that `cube`, `square`,
    `my_func1`, and `my_func2` can have an arbitrary ordering, as long as they''re
    placed before the `console.log(…)` statement. To express this kind of flexibility,
    the `CHECK-DAG` directive can be pretty useful.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只需要验证一条混淆规则：当`js-obfuscator`工具提供额外的命令行选项`--shuffle-funcs`，它实际上会打乱所有顶级函数的顺序时，我们需要检查顶级函数在打乱顺序后是否保持了一定的顺序。在JavaScript中，函数在调用时会被解析。这意味着`cube`、`square`、`my_func1`和`my_func2`可以有一个任意的顺序，只要它们放在`console.log(…)`语句之前。为了表达这种灵活性，`CHECK-DAG`指令非常有用。
- en: 'Adjacent `CHECK-DAG` directives will match texts in arbitrary orders. For example,
    let''s say we have the following directives:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相邻的`CHECK-DAG`指令将按任意顺序匹配文本。例如，假设我们有以下指令：
- en: '[PRE33]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'These directives will match the following content:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些指令将匹配以下内容：
- en: '[PRE34]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'They will also match the following content:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们也会匹配以下内容：
- en: '[PRE35]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, this freedom of ordering will not hold across either a `CHECK` or
    `CHECK-NOT` directive. For example, let''s say we have these directives:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这种排序的自由度在`CHECK`或`CHECK-NOT`指令中都不会保持。例如，假设我们有以下指令：
- en: '[PRE36]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'These directives will match the following text:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些指令将匹配以下文本：
- en: '[PRE37]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'However, they will not match the following text:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，它们不会匹配以下文本：
- en: '[PRE38]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Back to our motivated example, the obfuscation rule can be checked by using
    the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们的动机示例，可以通过以下代码检查混淆规则：
- en: '[PRE39]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The idea of the check prefix in `FileCheck` is pretty simple: you can create
    a *check suite* that runs independently with other suites. Instead of using the
    `CHECK` string, each suite will replace it with another string in all the directives
    mentioned earlier (`CHECK-NOT` and `CHECK-SAME`, to name a few), including `CHECK`
    itself, in order to distinguish it from other suites in the same file. For example,
    you can create a suite with the `YOLO` prefix so that that part of the example
    now looks as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FileCheck`中检查前缀的想法相当简单：你可以创建一个独立运行的*检查套件*，与其他套件分开。而不是使用`CHECK`字符串，每个套件都会在前面提到的所有指令（包括`CHECK-NOT`和`CHECK-SAME`等）中替换成另一个字符串，包括`CHECK`本身，以便区分同一文件中的其他套件。例如，你可以创建一个带有`YOLO`前缀的套件，这样示例的这部分现在看起来如下所示：'
- en: '[PRE40]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: $ cat test.out.js | FileCheck --check-prefix=YOLO test.js
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ cat test.out.js | FileCheck --check-prefix=YOLO test.js
- en: '[PRE41]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, let''s go back to our example. The last obfuscation rule can be solved
    by using an alternative prefix for those `CHECK-DAG` directives:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们回到我们的示例。最后一个混淆规则可以通过为那些 `CHECK-DAG` 指令使用一个替代前缀来解决：
- en: '[PRE42]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This must be combined with the default check suite. All the checks mentioned
    in this section can be run in two separate commands, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这必须与默认的检查套件结合使用。本节中提到的所有检查都可以通过两个单独的命令运行，如下所示：
- en: '[PRE43]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this section, we have shown some advanced and useful `FileCheck` skills through
    our example project. These skills provide you with different ways to write validation
    patterns and make your LIT test script more concise.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们通过我们的示例项目展示了某些高级且有用的 `FileCheck` 技巧。这些技巧为你提供了不同的方式来编写验证模式，并使你的 LIT 测试脚本更加简洁。
- en: So far, we have been talking about the testing methodology, which runs tests
    in a shell-like environment (that is, in the `ShTest` LIT format). In the next
    section, we are going to introduce an alternative LIT framework – the TestSuite
    framework and testing format that was originated from the `llvm-test-suite` project
    – which provides a *different kind* of useful testing methodology for LIT.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在讨论测试方法，该方法在类似 shell 的环境中运行测试（即在 `ShTest` LIT 格式中）。在下一节中，我们将介绍一个替代的
    LIT 框架——源自 `llvm-test-suite` 项目的 TestSuite 框架和测试格式——它为 LIT 提供了一种 *不同类型* 的有用测试方法。
- en: Exploring the TestSuite framework
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 TestSuite 框架
- en: In the previous sections, we learned how regression tests were performed in
    LLVM. More specifically, we looked at the `ShTest` testing format (recalling the
    `config.test_format = lit.formats.ShTest(…)` line), which basically runs end-to-end
    tests in a shell script fashion. The `ShTest` format provides more flexibility
    when it comes to validating results since it can use the `FileCheck` tool we introduced
    in the previous section, for example.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何在 LLVM 中执行回归测试。更具体地说，我们看了 `ShTest` 测试格式（回忆一下 `config.test_format
    = lit.formats.ShTest(…)` 这一行），它基本上以 shell 脚本的方式运行端到端测试。`ShTest` 格式在验证结果方面提供了更多的灵活性，因为它可以使用我们在上一节中介绍的
    `FileCheck` 工具，例如。
- en: 'This section is going to introduce another kind of testing format: `llvm-test-suite`
    project – a collection of test suites and benchmarks created for testing and benchmarking
    LLVM. Similar to `ShTest`, this LIT format is also designed to run end-to-end
    tests. However, TestSuite aims to make developers'' lives easier when they want
    to integrate *existing* executable-based test suites or benchmark codebases. For
    example, if you want to use the famous **SPEC benchmark** as one of your test
    suites, all you need to do is add a build description and the expected output
    in plain text. This is also useful when your testing logic cannot be expressed
    using a **textual testing script**, as we saw in previous sections.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将要介绍另一种测试格式：`llvm-test-suite` 项目——为测试和基准测试 LLVM 而创建的测试套件和基准测试集合。类似于 `ShTest`，这种
    LIT 格式也是为了运行端到端测试而设计的。然而，TestSuite 的目标是让开发者在使用基于现有可执行文件的测试套件或基准测试代码库时更加方便。例如，如果你想将著名的
    **SPEC 基准测试** 作为你的测试套件之一，你所需要做的只是添加一个构建描述和预期的纯文本输出。这在你的测试逻辑无法使用 **文本测试脚本** 表达时也很有用，正如我们在前面的章节中看到的。
- en: In this section, we will learn how to import an existing test suite or benchmark
    codebase into the `llvm-test-suite` project.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何将现有的测试套件或基准测试代码库导入到 `llvm-test-suite` 项目中。
- en: Preparing for our example project
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的示例项目做准备
- en: First, please follow the instructions at the beginning of this chapter to build
    `llvm-test-suite`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请按照本章开头提供的说明构建 `llvm-test-suite`。
- en: The rest of the section is going to use a pseudo test suite project called `GeoDistance`
    project uses C++ and a GNU `Makefile` to build a command-line tool, `geo-distance`,
    that calculates and prints out the total distance of a path constructed by a list
    of latitude and longitude pairs provided by the input file.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分将使用一个名为 `GeoDistance` 的伪测试套件项目。该项目使用 C++ 和 GNU `Makefile` 构建一个命令行工具 `geo-distance`，该工具计算并打印出由输入文件提供的经纬度对列表构建的路径的总距离。
- en: 'It should have the following folder structure:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该具有以下文件夹结构：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here, the `Makefile` looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Makefile` 的样子如下：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To run the `geo-distance` command-line tool, use the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 `geo-distance` 命令行工具，请使用以下命令：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This prints out the floating-point distance to `stdout`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在 `stdout` 上打印出浮点距离：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The floating-point precision requirement here is `0.001`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的浮点精度要求是 `0.001`。
- en: Importing code into llvm-test-suite
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将代码导入到 llvm-test-suite
- en: 'Basically, there are only two things we need to do to import existing test
    suites or benchmarks into `llvm-test-suite`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们只需要做两件事就可以将现有的测试套件或基准测试导入到`llvm-test-suite`中：
- en: Use CMake as the build system
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CMake作为构建系统
- en: Compose verification rules
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写验证规则
- en: 'To use CMake as the build system, the project folder needs to be put under
    the `MultiSource/Applications` subdirectory inside the `llvm-test-suite` source
    tree. Then, we need to update the enclosing `CMakeLists.txt` accordingly:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用CMake作为构建系统，项目文件夹需要放在`llvm-test-suite`源树中的`MultiSource/Applications`子目录下。然后，我们需要相应地更新外部的`CMakeLists.txt`文件：
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To migrate from our GNU `Makefile` to `CMakeLists.txt`, instead of rewriting
    it using the built-in CMake directives such as `add_executable`, LLVM provides
    some handy functions and macros for you:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要从我们的GNU `Makefile`迁移到`CMakeLists.txt`，而不是使用内置的CMake指令（如`add_executable`）重写它，LLVM为您提供了一些方便的函数和宏：
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There are some new CMake directives here. `llvm_multisource` and its sibling,
    `llvm_singlesource`, add a new executable build target from multiple source files
    or only a single source file, respectively. They're basically `add_executable`,
    but as shown in the previous code, you can choose to leave the source file list
    empty, and it will use all the C/C++ source files shown in the current directory
    as input.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些新的CMake指令。`llvm_multisource`及其兄弟指令`llvm_singlesource`分别从多个源文件或单个源文件添加一个新的可执行文件构建目标。它们基本上是`add_executable`，但如前所述的代码所示，您可以选择留空源文件列表，它将使用当前目录中显示的所有C/C++源文件作为输入。
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If there are multiple source files but you're using `llvm_singlesource`, every
    source file will be treated as a standalone executable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个源文件但您使用的是`llvm_singlesource`，每个源文件都将被视为一个独立的可执行文件。
- en: '`llvm_test_data` copies any resource/data files you want to use during runtime
    to the proper working directory. In this case, it''s the `sample_input.txt` file.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm_test_data`将您希望在运行时使用的任何资源/数据文件复制到正确的工作目录。在这种情况下，是`sample_input.txt`文件。'
- en: 'Now that the skeleton has been set up, it''s time to configure the compilation
    flags using the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在骨架已经设置好了，是时候使用以下代码配置编译标志了：
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, TestSuite needs to know how to run the test and how to verify the
    result:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，TestSuite需要知道如何运行测试以及如何验证结果：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `RUN_OPTIONS` CMake variable is pretty straightforward – it provides the
    command-line options for the testing executable.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN_OPTIONS` CMake变量非常直观——它提供了测试可执行文件的命令行选项。'
- en: For the verification part, by default, TestSuite will use an enhanced diff to
    compare the output of `stdout` and the exit code against files whose filename
    end with `.reference_output`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于验证部分，默认情况下，TestSuite将使用增强的diff来比较`stdout`的输出和退出代码与以`.reference_output`结尾的文件。
- en: 'For example, in our case, a `GeoDistance/geo-distance.reference_output` file
    is created with the expected answer and exit status code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的案例中，创建了一个`GeoDistance/geo-distance.reference_output`文件，其中包含预期的答案和退出状态代码：
- en: '[PRE52]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You might find that the expected answer here is slightly different from the
    output at the beginning of this section (`94.873467`), and that's because the
    comparison tool allows you to designate the desired floating-point precision,
    which is controlled by the `FP_TOLERANCE` CMake variable shown previously.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现这里的预期答案与本节开头（`94.873467`）的输出略有不同，这是因为比较工具允许您指定所需的浮点精度，这由之前显示的`FP_TOLERANCE`
    CMake变量控制。
- en: In this section, we learned how to leverage the `llvm-test-suite` project and
    its TestSuite framework to test executables that are either from an existing codebase
    or are unable to express testing logic using textual scripts. This will help you
    become more efficient in testing different kinds of projects using LIT.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何利用`llvm-test-suite`项目及其TestSuite框架来测试来自现有代码库或无法使用文本脚本表达测试逻辑的可执行文件。这将帮助您在使用LIT测试不同类型的项目中变得更加高效。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: LIT is a general-purpose testing framework that can not only be used inside
    LLVM, but also arbitrary projects with little effort. This chapter tried to prove
    this point by showing you how to integrate LIT into an out-of-tree project without
    even needing to build LLVM. Second, we saw FileCheck – a powerful pattern checker
    that's used by many LIT test scripts. These skills can reinforce the expressiveness
    of your testing scripts. Finally, we presented you with the TestSuite framework,
    which is suitable for testing different kinds of program and complements the default
    LIT testing format.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: LIT 是一个通用测试框架，不仅可以用于 LLVM 内部，还可以轻松地用于任意项目。本章试图通过向你展示如何将 LIT 集成到树外项目中，甚至无需构建
    LLVM 来证明这一点。其次，我们看到了 FileCheck——一个被许多 LIT 测试脚本使用的强大模式检查器。这些技能可以增强你测试脚本的表达能力。最后，我们向你介绍了
    TestSuite 框架，它适用于测试不同类型的程序，并补充了默认的 LIT 测试格式。
- en: 'In the next chapter, we will explore another supporting framework in the LLVM
    project: **TableGen**. We will show you that TableGen is also a *general toolbox*
    that can solve problems in out-of-tree projects, albeit almost being exclusively
    used by backend development in LLVM nowadays.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 LLVM 项目中的另一个支持框架：**TableGen**。我们将向你展示 TableGen 也是一个 *通用工具箱*，可以解决树外项目的各种问题，尽管如今它几乎仅被用于
    LLVM 的后端开发。
- en: Further reading
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Currently, the source code for FileCheck – written in C++ – is still inside
    LLVM's source tree. Try to replicate its functionality using Python ([https://github.com/mull-project/FileCheck.py](https://github.com/mull-project/FileCheck.py)),
    which will effectively help you use FileCheck without building LLVM, just like
    LIT!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，FileCheck 的源代码——用 C++ 编写——仍然位于 LLVM 的源树中。尝试使用 Python ([https://github.com/mull-project/FileCheck.py](https://github.com/mull-project/FileCheck.py))
    来复制其功能，这将有效地帮助你使用 FileCheck 而无需构建 LLVM，就像 LIT 一样！
