- en: Chapter 8. Getting Physical – Box2D
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章. 获得物理感 – Box2D
- en: '*It''s time to tackle physics! Cocos2d-x comes bundled with Box2D and Chipmunk.
    These are so-called 2D physics engines – the first written in C++ and the second
    in C. Chipmunk has a more recent Objective-C port but Cocos2d-x must use the original
    one written in C for portability.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*是时候处理物理了！Cocos2d-x 随带 Box2D 和 Chipmunk。这些都是所谓的 2D 物理引擎 – 第一个是用 C++ 编写的，第二个是用
    C 编写的。Chipmunk 有一个更近期的 Objective-C 版本，但 Cocos2d-x 必须使用用 C 编写的原始版本以保持兼容性。*'
- en: '*We''ll be using Box2D for the examples in this book. The next two games I''ll
    show you will be developed with that engine, starting with a simple pool game
    to illustrate all the main points about using Box2D in your projects.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将在这本书的示例中使用 Box2D。接下来两个我将展示的游戏将使用该引擎开发，从简单的台球游戏开始，以展示在项目中使用 Box2D 的所有主要点。*'
- en: 'In this chapter, you will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: How to set up and run a Box2D simulation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置和运行 Box2D 模拟
- en: How to create bodies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建刚体
- en: How to use the debug draw feature to quickly test your concepts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用调试绘制功能快速测试你的概念
- en: How to use collision filters and listeners
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用碰撞过滤器监听器
- en: Building a Box2D project with Cocos2d-x
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cocos2d-x 构建 Box2D 项目
- en: With version 3.x of the framework, we no longer need to specify that we want
    to use a physics engine. The projects add these APIs by default. So, all you need
    in order to create a Box2D project is to create a regular Cocos2d-x project as
    we've been doing with the examples so far.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用框架的 3.x 版本，我们不再需要指定我们想要使用物理引擎。项目默认添加了这些 API。因此，为了创建一个 Box2D 项目，你只需要创建一个常规的
    Cocos2d-x 项目，就像我们到目前为止在示例中所做的那样。
- en: There is, however, one extra step you need to perform if you wish to use something
    called a debug draw in your project. So let's set that up now.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想在项目中使用一个名为调试绘制的功能，你需要执行一个额外的步骤。所以，让我们现在设置它。
- en: Time for action – using debug draw in your Box2D project
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 在你的 Box2D 项目中使用调试绘制
- en: 'Let''s start by creating the project. In my machine, I created a game called
    MiniPool in my desktop. Here are the steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建项目。在我的机器上，我在桌面上创建了一个名为 MiniPool 的游戏。以下是步骤：
- en: 'Open Terminal and enter the following command:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并输入以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Open the new project in Xcode.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Xcode 中打开新项目。
- en: Now navigate to the `Tests` folder inside the Cocos2d-x framework folder. This
    can be found in `tests/cpp-tests/Classes`. Then open the `Box2DTestBed` folder.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，导航到 Cocos2d-x 框架文件夹内的 `Tests` 文件夹。这可以在 `tests/cpp-tests/Classes` 中找到。然后打开
    `Box2DTestBed` 文件夹。
- en: Drag the files `GLES-Render.h` and `GLES-Render.cpp` to your project in Xcode.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件 `GLES-Render.h` 和 `GLES-Render.cpp` 拖到你的 Xcode 项目中。
- en: You can also open the `Box2dTest.cpp` class in the test folder `Box2DTest`,
    as we're going to copy and paste a few of the methods from there.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以打开测试文件夹 `Box2DTest` 中的 `Box2dTest.cpp` 类，因为我们将从那里复制并粘贴一些方法。
- en: 'In the `HelloWorldScene.h` header file, leave the includes in place, but change
    the class declarations to match these:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `HelloWorldScene.h` 头文件中，保留现有的包含，但将类声明更改为以下内容：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then add this `include` statement at the top:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在顶部添加以下 `include` 语句：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, in the `HelloWorldScene.cpp` implementation file, replace the lines between
    the `using namespace CocosDenshion` and `HelloWorld::scene` methods with these:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `HelloWorldScene.cpp` 实现文件中，将 `using namespace CocosDenshion` 和 `HelloWorld::scene`
    方法之间的行替换为以下内容：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now comes the implementation of the `draw` methods. You can copy and paste
    most of this code from the `Box2DTest` folder:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是 `draw` 方法的实现时间。你可以从 `Box2DTest` 文件夹复制并粘贴大部分代码：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*What just happened?*'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: The `GLES-Render` class is necessary to use the debug draw feature in Box2D.
    This will draw all the elements from the simulation on the screen. The debug draw
    object is created inside the `initPhysics` method alongside the Box2D simulation
    (`b2World`). We'll go over that logic in a moment.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`GLES-Render` 类是使用 Box2D 中的调试绘制功能所必需的。这将在屏幕上绘制模拟的所有元素。调试绘制对象在 `initPhysics`
    方法中与 Box2D 模拟（`b2World`）一起创建。我们稍后会介绍这个逻辑。'
- en: As the comment inside the `draw` method states, the debug draw feature should
    be switched off once you're done developing your game. So all the lines pertaining
    to that object as well as the `draw` method should be commented out when you're
    ready for a release version.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `draw` 方法中的注释所述，一旦你完成游戏开发，应该关闭调试绘制功能。因此，当你准备发布版本时，应该注释掉与该对象以及 `draw` 方法相关的所有行。
- en: So what is a physics engine?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么物理引擎是什么？
- en: The famous Isaac Newton said, *every action has a reaction*. Right after he
    said, *who the hell threw that apple?*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 著名的艾萨克·牛顿曾说，*每一个作用力都有一个反作用力*。就在他说完这句话后，他问道，*谁他妈扔的那个苹果？*
- en: 'So far in our games, we have covered very simple collision systems, basically
    only ever checking to see if simple shapes (circles and rectangles) overlapped
    each other. The reactions from these collisions were also very simple in our games
    so far: with vector inversions or simply by making things disappear once they
    touch. With Box2D, you get way more!'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的游戏中，我们涵盖了非常简单的碰撞系统，基本上只是检查简单的形状（圆形和矩形）是否重叠。到目前为止，我们游戏中这些碰撞的反应也非常简单：通过向量反转或者简单地让物体在接触后消失。使用
    Box2D，你将得到更多！
- en: Box2D is a very robust collision detection engine and can certainly be used
    just for that purpose. But the simulation will also process and return a bunch
    of information derived from the collisions and the interactions between bodies,
    meaning how the objects should behave, based on their shapes, mass, and all the
    forces at play in the simulation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D 是一个非常健壮的碰撞检测引擎，当然可以仅为此目的使用。但模拟还会处理并返回从碰撞和物体之间的相互作用中派生的一组信息，这意味着根据它们的形状、质量和模拟中所有作用力，物体应该如何表现。
- en: Meeting Box2D
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认识 Box2D
- en: At the core of the engine, you have the `b2World` object. This is the simulation.
    You fill the world with `b2Body` objects, and then you step through the simulation
    with `b2World->Step()`. And you take the results of the simulation and display
    them to the user through your sprites, by grabbing a `b2Body` object's position
    and rotation and applying them to a sprite.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在引擎的核心，你有一个 `b2World` 对象。这就是模拟。你用 `b2Body` 对象填充世界，然后通过 `b2World->Step()` 来遍历模拟。然后你从模拟中获取结果，并通过你的精灵将它们显示给用户，通过获取一个
    `b2Body` 对象的位置和旋转并将其应用到精灵上。
- en: The debug draw object allows you to see the simulation without using any sprites.
    Sort of like a version of our test project from [Chapter 6](part0087_split_000.html#page
    "Chapter 6. Quick and Easy Sprite – Victorian Rush Hour"), *Quick and Easy Sprite
    – Victorian Rush Hour*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 调试绘图对象允许你不用任何精灵就能看到模拟。有点像我们[第 6 章](part0087_split_000.html#page "第 6 章. 快速简单的精灵
    – 维多利亚时代的交通高峰")中的测试项目版本，*快速简单的精灵 – 维多利亚时代的交通高峰*。
- en: Meeting the world
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认识世界
- en: Most of the time, the physics simulation will mean the creation of a `b2World`
    object. Note, however, that you *can* get interesting results managing more than
    one `world` object in the same game, for multiple views for instance. But that's
    for another book.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，物理模拟意味着创建一个 `b2World` 对象。然而，请注意，你*可以*在同一个游戏中管理多个 `world` 对象，例如为了多个视角。但这将是另一本书的内容。
- en: 'In our simplified basic project, the world is created like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简化基本项目中，世界的创建方式如下：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Box2D has its own vector structure, `b2Vec2`, and we use it here to create the
    world's gravity. The `b2World` object receives that as its parameter. A simulation
    does not always require gravity, of course; in that case, the argument will be
    a `(0, 0)` vector.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D 有自己的向量结构，`b2Vec2`，我们在这里用它来创建世界的重力。`b2World` 对象接收这个作为它的参数。当然，模拟并不总是需要重力；在这种情况下，参数将是一个
    `(0, 0)` 向量。
- en: '`SetAllowSleeping` means if objects are not moving and therefore not generating
    derived data, skip checking for derived data from those objects.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetAllowSleeping` 表示如果对象没有移动并且因此没有生成派生数据，则跳过检查这些对象的派生数据。'
- en: '`SetContinuousPhysics` means we have some fast objects in our hands, which
    we''ll later point out to the simulation, so it can pay extra attention for collisions.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetContinuousPhysics` 表示我们手中有一些快速的对象，我们稍后会将其指向模拟，以便它对碰撞给予额外的关注。'
- en: Then we create the debug draw object. This is optional, as I said before. The
    flags indicate what you wish to see in the drawing. In the code we saw before,
    we only want to see the shapes of the objects.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建调试绘图对象。正如我之前所说的，这是可选的。标志指示你希望在绘图中看到什么。在之前的代码中，我们只想看到物体的形状。
- en: Then comes `PTM_RATIO`, the defined constant we passed as a parameter to the
    debug draw. Box2D uses meters instead of pixels for a variety of reasons that
    are really entirely unnecessary for anyone to know. Except for one reason, **pixel
    to meter** (**PTM**), so every pixel position value used in the game will be divided
    by this ratio constant. If the result from this division ever gets above 10 or
    below 0.1, increase or decrease the value for `PTM_RATIO` accordingly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是`PTM_RATIO`，这是我们传递给debug draw的参数定义的常量。Box2D出于各种原因使用米而不是像素，这些原因对任何人来说都完全没有必要知道。除了一个原因，**像素到米**（**PTM**），所以游戏中使用的每个像素位置值都将除以这个比例常数。如果这个除法的结果超过10或低于0.1，相应地增加或减少`PTM_RATIO`的值。
- en: You have some leeway, of course. By all means, play with this value once your
    game is completed, and pay special attention to the subtle differences in speed
    (another common value for this ratio is 100).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你有一些灵活性。一旦你的游戏完成，不妨玩玩这个值，并特别注意速度上的细微差别（这个比例的另一个常见值是100）。
- en: Running the simulation
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行模拟
- en: 'As I said before, you use the `Step` method to run the simulation, usually
    inside your main loop, though not necessarily:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，你使用`Step`方法来运行模拟，通常在主循环内部进行，尽管不一定是这样：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You need to pass it the time step, here represented by the delta time in the
    main loop. Then pass the number of velocity iterations and position iterations
    in the step. This basically means how many times velocity and position will be
    processed inside a step.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要传递给它时间步长，这里由主循环中的delta时间表示。然后传递步中的速度迭代次数和位置迭代次数。这基本上意味着速度和位置将在一个步长内被处理多少次。
- en: In the previous example, I'm using the default values from the Box2D template
    in Cocos2d-x. Usually, a fixed time step is better than the delta, and a higher
    value for position iteration may be necessary if things move really fast in your
    game. But always remember to play with these values, aiming at finding the lowest
    possible ones.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我使用了Cocos2d-x中Box2D模板的默认值。通常，固定时间步长比delta更好，如果你的游戏中的物体移动得很快，可能还需要更高的位置迭代值。但始终记得玩这些值，目标是找到尽可能低的值。
- en: No Ref objects in Box2D
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Box2D中没有Ref对象
- en: 'Box2D does not use `Ref` objects. So, no memory management! Remember to get
    rid of all the Box2D objects through `delete` and not `release`. If you knew it
    already... well, you remember:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D不使用`Ref`对象。所以，没有内存管理！记得通过`delete`而不是`release`来删除所有Box2D对象。如果你已经知道了……嗯，你记得：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As I mentioned before, C++11 introduces smart pointers, which are memory managed,
    meaning you *don't* have to delete these objects yourself. However, the topic
    of shared pointers is beyond the scope of this book, and using unique pointers
    in this chapter would add way too many lines that had nothing to do with Box2D.
    And although smart pointers are amazing, their syntax and usage is, well, let's
    say very "C++ish".
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，C++11引入了智能指针，它们是内存管理的，这意味着你*不需要*自己删除这些对象。然而，共享指针的话题超出了本书的范围，在本章中使用唯一指针会添加很多与Box2D无关的行。尽管智能指针很棒，但它们的语法和用法，嗯，让我们说非常“C++风格”。
- en: Meeting the bodies
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遇到物体
- en: 'The `b2Body` object is the thing you''ll spend most of your time dealing with
    inside a Box2D simulation. You have three main types of `b2Bodies`: dynamic, static,
    and kinematic. The first two are of greater importance and are the ones we''ll
    use in our game.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`b2Body`对象是你在Box2D模拟中花费大部分时间处理的东西。你有三种主要的`b2Bodies`类型：动态、静态和运动学。前两种更为重要，也是我们在游戏中会使用的类型。'
- en: Bodies are created by combining a body definition with a body fixture. The body
    definition is a structure that holds information about type, position, velocity,
    and angle, among other things. The fixture holds information about the shape,
    including its density, elasticity, and friction.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 物体是通过将身体定义与身体固定件组合来创建的。身体定义是一个包含类型、位置、速度和角度等信息的数据结构。固定件包含有关形状的信息，包括其密度、弹性和摩擦。
- en: 'So, to create a circle that is 40 pixels wide, you would use the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要创建一个宽度为40像素的圆形，你会使用以下方法：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To create a box that is 40 pixels wide, you would use this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个宽度为40像素的盒子，你会使用以下方法：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that you use the `world` object to create the bodies. And also note that
    boxes are created with half their desired width and height.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你使用`world`对象来创建物体。还要注意，盒子是用其期望宽度和高度的一半创建的。
- en: Density, friction, and restitution all have default values, so you don't always
    need to set these.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 密度、摩擦和恢复系数都有默认值，所以你不必总是设置这些。
- en: Our game – MiniPool
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的游戏 – MiniPool
- en: Our game consists of sixteen balls (circles), one cue (box), and a pool table
    made out of six lines (edges) and six pockets (circles). This is all there is
    to it as far as the Box2D simulation is concerned.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏由十六个球（圆形）、一个球杆（矩形）以及由六条线（边缘）和六个球洞（圆形）组成的台球桌组成。从 Box2D 模拟的角度来看，这就是全部内容。
- en: 'Download the final project from this book''s **Support** page if you wish to
    follow along with the final code. Box2D is a complex API and it will be best to
    review and expose the logic rather than work on it by doing a lot of typing. So
    there will be no start project to work from this time. You may choose any manner
    to add files from the finished project to the one we started when I showed you
    how to set up the debug draw object. The final game will look like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望跟随最终代码，请从本书的 **支持** 页面下载最终项目。Box2D 是一个复杂的 API，最好是通过审查和暴露逻辑而不是通过大量输入来工作。所以这次将没有起始项目可供工作。你可以选择任何方式将完成的项目中的文件添加到我在展示如何设置调试绘制对象时开始的项目中。最终游戏将看起来像这样：
- en: '![Our game – MiniPool](img/00030.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![我们的游戏 – MiniPool](img/00030.jpeg)'
- en: Game settings
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏设置
- en: This is a portrait-orientation-only game, with no screen rotation allowed, and
    universal application. The game is designed for the regular iPhone (320 x 480)
    and its resolution size is set to `kResolutionShowAll`. This will show borders
    around the main screen in devices that do not match the 1.5 screen ratio of the
    iPhone.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个仅支持竖屏的游戏，不允许屏幕旋转，并且是通用应用。游戏是为标准 iPhone（320 x 480）设计的，其分辨率大小设置为 `kResolutionShowAll`。这将显示不匹配
    iPhone 1.5 屏幕比例的设备上的主屏幕周围的边框。
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that I use the iPhone's dimensions to identify larger screens. So the iPad
    and the iPhone retina are considered to be two times 320 x 480 and the retina
    iPad is considered to be four times 320 x 480.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我使用 iPhone 的尺寸来识别更大的屏幕。所以 iPad 和 iPhone retina 被认为是 320 x 480 的两倍，而视网膜 iPad
    被认为是 320 x 480 的四倍。
- en: Sprite plus b2Body equal to b2Sprite
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精灵加 b2Body 等于 b2Sprite
- en: The most common way to work with `b2Body` objects in Cocos2d-x is to combine
    them with sprites. In the games I'll show you, I created a class called `b2Sprite`
    that extends sprite with the addition of a `_body` member property that points
    to its very own `b2Body`. I also add a few helper methods to deal with our pesky
    `PTM_RATIO`. Feel free to add as many of these as you think necessary.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cocos2d-x 中处理 `b2Body` 对象最常见的方式是将它们与精灵结合使用。在我将要展示的游戏中，我创建了一个名为 `b2Sprite`
    的类，它扩展了精灵并添加了一个 `_body` 成员属性，该属性指向其自己的 `b2Body`。我还添加了一些辅助方法来处理我们讨厌的 `PTM_RATIO`。请随意添加您认为必要的这些方法。
- en: '`b2Body` objects have an incredibly helpful property called `userData`. You
    can store anything you wish inside it and the bodies will carry it with them throughout
    the simulation. So, what most developers do is that they store inside the body''s
    `userData` property a reference to the instance of sprite wrapping it. So `b2Sprite`
    knows about its body, and the body knows about its `b2Sprite`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`b2Body` 对象有一个极其有用的属性，称为 `userData`。你可以在其中存储任何你希望的内容，并且这些对象将携带它穿过整个模拟。所以，大多数开发者会这样做，他们在对象的
    `userData` 属性中存储一个指向包裹它的精灵实例的引用。所以 `b2Sprite` 知道它的 `body`，而 `body` 知道它的 `b2Sprite`。'
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As a matter of fact, composition is key when working with Box2D. So, when designing
    your games, make sure every object knows of every other object or can get to them
    quickly. This will help immensely.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在处理 Box2D 时，组合是关键。所以，在设计你的游戏时，确保每个对象都知道其他对象或可以快速访问它们。这将非常有帮助。
- en: Creating the pool table
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建台球桌
- en: 'In the debug draw view, this is what the table looks like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试绘制视图中，桌子看起来是这样的：
- en: '![Creating the pool table](img/00031.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![创建台球桌](img/00031.jpeg)'
- en: All the elements seen here are created inside the `initPhysics` method in `GameLayer.cpp`.
    The table has no visual representation other than the background image we use
    in the game. So there are no sprites attached to the individual pockets, for example.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里看到的所有元素都是在 `GameLayer.cpp` 中的 `initPhysics` 方法内部创建的。桌子除了我们游戏中使用的背景图像外没有视觉表示。所以没有精灵附加到单个球洞上，例如。
- en: 'The `pocket` bodies are created inside a `for` loop, with the best algorithm
    I could come up with to distribute them correctly on screen. This logic is found
    in the `initPhysics` method, so let''s take a look at that and see how our first
    `b2Body` objects are created:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 球洞对象是在 `for` 循环内部创建的，我使用了我能想到的最佳算法来正确地在屏幕上分布它们。这个逻辑可以在 `initPhysics` 方法中找到，所以让我们看看它，看看我们的第一个
    `b2Body` 对象是如何创建的：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `pocket` bodies are static bodies and we determine in their fixture definition
    that they should behave like sensors:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`pocket`物体是静态物体，我们在它们的固定定义中确定它们应该像传感器一样行为：'
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This switches off all the physics from an object and turns it into a collision
    hot spot. A sensor serves only to determine if something is touching it or not.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将关闭一个对象的全部物理属性，将其变成碰撞热点。传感器仅用于确定是否有物体接触它。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's almost always best to ignore Box2D sensors and use your own sprites or
    points in your collision logic. One neat feature in sensors is that they make
    it very easy to determine when something has just ceased touching them, as you'll
    see once we cover contact listeners.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是最好忽略Box2D传感器，并使用自己的精灵或点在你的碰撞逻辑中。传感器的一个很酷的功能是，它们使得确定某物刚刚停止接触它们变得非常容易，正如我们一旦覆盖了接触监听器就会看到的那样。
- en: Creating edges
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建边缘
- en: 'If a shape can only be hit on one side, an edge is probably what you need.
    Here is how we create edges in our game:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个形状只能从一侧被击中，那么边缘可能就是你需要的东西。以下是我们如何在游戏中创建边缘的方法：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So the same `b2Body` object can have as many edges as you need. You set an edge
    with its start and end points (in this case, the `b2Vec2` structures) and add
    it as a fixture to the body, with a density of `0`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，同一个`b2Body`对象可以有你需要的大量边缘。你设置一个边缘，指定其起点和终点（在这种情况下，是`b2Vec2`结构），并将其作为固定件添加到身体中，密度为`0`。
- en: Creating the ball objects
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建球对象
- en: 'In the game, there is a class called `Ball` that extends `b2Sprite`, used for
    both the target balls and the cue ball. These objects are also created inside
    the `initPhysics` method. Here is the basic configuration of that object:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，有一个名为`Ball`的类，它扩展了`b2Sprite`，用于目标球和球杆球。这些对象也是在`initPhysics`方法内部创建的。以下是该对象的基本配置：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `friction` fixture property involves the reaction of two touching surfaces
    (two bodies). In this case, we want to create "friction" with the table surface,
    which is not a body at all. So what we need to use instead is **damping**. This
    will apply a similar effect to friction, but without the need for an extra surface.
    Damping can be applied to the linear velocity vector of a body as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`friction`固定属性涉及两个接触表面（两个物体）的反应。在这种情况下，我们想要与桌面表面创建“摩擦”，而桌面根本不是一个物体。因此，我们需要使用的是**阻尼**。这将产生与摩擦类似的效果，但不需要额外的表面。阻尼可以应用于物体的线性速度向量，如下所示：'
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And to the angular velocity as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 并且将其角速度设置为如下：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also, the white ball is set to be a bullet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，白球被设置为子弹形状：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will make the simulation pay extra attention to this object in terms of
    collision. We could make all balls in the game behave as bullets, but this is
    not only unnecessary (something revealed through testing) but also not very processing-friendly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使模拟在碰撞方面对这个对象给予额外的关注。我们本可以将游戏中的所有球都设置为子弹形状，但这不仅是不必要的（通过测试揭示的事实），而且也不太适合处理。
- en: Creating collision filters
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建碰撞过滤器
- en: In the `ball` object, there is a `filter` property inside the fixture definition
    that we use to mask collisions. Meaning we determine what bodies can collide with
    each other. The cue ball receives a different value for `categoryBits` than the
    other balls.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ball`对象中，固定定义内部有一个`filter`属性，我们使用它来屏蔽碰撞。这意味着我们确定哪些物体可以相互碰撞。球杆球接收与其它球不同的`categoryBits`值。
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we create the cue body, we set a `maskBits` property in its fixture definition
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建球杆体时，我们在其固定定义中设置了一个`maskBits`属性，如下所示：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We set this to the same value as the white ball's `categoryBits`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其设置为与白球的`categoryBits`相同的值。
- en: The result of all this? Now the cue can only hit bodies with the same `categoryBits`,
    which here means the cue can only collide with the white ball.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的结果？现在球杆只能击中具有相同`categoryBits`的物体，在这里这意味着球杆只能与白球碰撞。
- en: 'It is possible to add more than one category to a mask with a bitwise `|` option,
    as seen here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用位运算符`|`将多个类别添加到屏蔽中，如下所示：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Or to collide with everything except the cue ball, for instance, as seen in
    the following line:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，例如，不与球杆球碰撞，如下所示：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating the cue
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建球杆
- en: The cue ball also extends `b2Sprite`, and its body is set as a box.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 球杆球也扩展了`b2Sprite`，其身体被设置为盒子形状。
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It has very high damping values because, in the rare occasions when the player
    misses the cue ball, the cue will not fly off the screen but halt a few pixels
    from the white ball.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有非常高的阻尼值，因为在玩家偶尔错过母球的情况下，球杆不会飞出屏幕，而是在白球几像素之外停止。
- en: 'If we wanted to create the cue ball as a trapezium or a triangle, we would
    need to give the `b2PolygonShape` option the vertices we want. Here''s an example
    of this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将球杆创建为梯形或三角形，我们需要给`b2PolygonShape`选项提供我们想要的顶点。以下是一个例子：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And the vertices must be added counterclockwise to the array. Meaning, if we
    add the top vertex of the triangle first, the next vertex must be the one to the
    left.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 并且顶点必须逆时针添加到数组中。这意味着，如果我们首先添加三角形的顶点，下一个顶点必须是左边的那个。
- en: 'Once all the elements are in place, the debug draw looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有元素都到位，调试绘制看起来是这样的：
- en: '![Creating the cue](img/00032.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![创建球杆](img/00032.jpeg)'
- en: Creating a contact listener
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建接触监听器
- en: Besides collision filters, one other feature in Box2D that helps with collision
    management is the creation of a contact listener.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了碰撞过滤器之外，Box2D中还有另一个有助于碰撞管理的功能，那就是创建一个接触监听器。
- en: 'Inside the `initPhysics` method, we create the `world` object like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`initPhysics`方法内部，我们创建`world`对象如下：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our `CollisionListener` class extends the Box2D `b2ContactListener` class,
    and it must implement at least one of the following methods:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`CollisionListener`类扩展了Box2D的`b2ContactListener`类，并且必须实现以下方法中的至少一个：
- en: '`void BeginContact(b2Contact* contact);`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void BeginContact(b2Contact* contact);`'
- en: '`void EndContact(b2Contact* contact);`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void EndContact(b2Contact* contact);`'
- en: '`void PreSolve(b2Contact* contact, const b2Manifold* oldManifold);`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void PreSolve(b2Contact* contact, const b2Manifold* oldManifold);`'
- en: '`void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse);`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse);`'
- en: These events are all related to a contact (collision) and are fired at different
    stages of a contact.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件都与一个接触（碰撞）相关，并在接触的不同阶段触发。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sensor objects can only ever fire the `BeginContact` and `EndContact` events.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器对象只能触发`BeginContact`和`EndContact`事件。
- en: 'In our game, we implement two of these methods. The first is:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们实现了这两种方法中的两种。第一种是：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can see now how important the `userData` property is. We can quickly access
    sprites attached to the bodies listed in the `b2Contact` object through the `userData`
    property.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到`userData`属性有多么重要。我们可以通过`userData`属性快速访问`b2Contact`对象中列出的身体所附加的精灵。
- en: Besides that, all our sprites have a `_type` property that behaves like identifying
    tags in our logic. Note that you could certainly use the Cocos2d-x tags for that,
    but I find that at times, if you can combine the `Sprite` tags with their `_type`
    value, you may produce interesting sorting logic.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了那之外，我们所有的精灵都有一个`_type`属性，它在我们的逻辑中就像标识标签。注意，你当然可以使用Cocos2d-x标签来做到这一点，但我发现有时，如果你可以将`Sprite`标签与它们的`_type`值结合起来，你可能会产生有趣的排序逻辑。
- en: So, in `BeginContact`, we track the collisions between balls and pockets. But
    we also track collision between balls. In the first case, the balls are turned
    invisible when they touch the pockets. And, in the second case, we play a sound
    effect whenever two balls touch each other, but only if they are at a certain
    speed (we determine that through a `b2Sprite` helper method that retrieves the
    squared magnitude of a sprite's velocity vector).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`BeginContact`中，我们跟踪球和袋之间的碰撞。但我们还跟踪球之间的碰撞。在第一种情况下，当球接触到袋时，球会变得不可见。在第二种情况下，每当两个球以一定速度（我们通过一个`b2Sprite`辅助方法检索精灵速度向量的平方模量来确定）相撞时，我们会播放音效。
- en: 'The other method in our listener is:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器中的另一种方法是：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we listen to a collision before its reactions are calculated. If there
    is a collision between the cue and white ball, we play a sound effect and we hide
    the cue.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在计算反应之前监听碰撞。如果球杆和白球之间发生碰撞，我们会播放音效，并隐藏球杆。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to force your own logic to the collision reaction and override Box2D
    on this, you should do so in the `PreSolve` method. In this game, however, we
    could have added all this collision logic to the `BeginContact` method and it
    would work just as well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要强制自己的逻辑到碰撞反应并覆盖Box2D，你应该在`PreSolve`方法中这样做。然而，在这个游戏中，我们本可以将所有这些碰撞逻辑添加到`BeginContact`方法中，效果也会一样好。
- en: The game controls
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏控制
- en: In the game, the player must click on the white ball and then drag his or her
    finger to activate the cue ball. The farther the finger gets from the white ball,
    the more powerful the shot will be.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，玩家必须点击白球，然后拖动手指来激活球杆。手指离白球越远，射击力就越强。
- en: So let's add the events to handle user input.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们添加事件来处理用户输入。
- en: Time for action – adding the touch events
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候添加触摸事件了
- en: We'll deal with `onTouchBegan` first.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先处理`onTouchBegan`。
- en: 'In the `onTouchBegan` method, we start by updating the game state:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onTouchBegan` 方法中，我们首先更新游戏状态：
- en: '[PRE27]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we check on the value of `_canShoot`. This returns `true` if the white
    ball is not moving.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查 `_canShoot` 的值。如果白球没有移动，它将返回 `true`。
- en: '[PRE28]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we determine whether the touch is landing on the white ball. If it is,
    we start the game if it is not currently running yet and we make our timer visible.
    Here''s the code to do this:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们确定触摸是否落在白球上。如果是，如果游戏尚未运行，我们就开始游戏并使计时器可见。以下是执行此操作的代码：
- en: '[PRE29]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that we use a larger radius for the white ball in our logic (four times
    larger). This is because we don't want the target area to be too small, since
    this game will run on both iPhones and iPads. We want the player to comfortably
    hit the white ball with his or her finger.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们在我们的逻辑中使用了一个较大的白球半径（四倍大）。这是因为我们不希望目标区域太小，因为这个游戏将在iPhone和iPad上运行。我们希望玩家能够舒适地用手指击打白球。
- en: 'We store where in the ball the point lies. This way, the player can hit the
    ball at different spots, causing it to move at different angles:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们存储点在球中的位置。这样，玩家就可以在不同的位置击打球，使其以不同的角度移动：
- en: '[PRE30]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since we made the white ball a much larger target for our `touch` event, now
    we must make sure the actual point picked by the player lies within the ball.
    So we may have to make some adjustments here.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们使白球成为 `touch` 事件的一个更大的目标，现在我们必须确保玩家实际选择的点位于球内。因此，我们可能需要在这里做一些调整。
- en: 'We pass the point to our `LineContainer` object and we prepare the cue body
    to be used, as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将点传递给我们的 `LineContainer` 对象，并准备要使用的球杆身体，如下所示：
- en: '[PRE31]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We once again have a `LineContainer` node so we can draw a dashed line between
    the cue and the spot on the ball where the cue will hit. This serves as a visual
    aid for the player to prepare his or her shot. The visual aid effect is demonstrated
    here:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们再次有一个 `LineContainer` 节点，这样我们就可以在提示和球上将要击中的点之间画一条虚线。这为玩家准备他们的击球提供了一个视觉辅助。视觉辅助效果如下所示：
- en: '![Time for action – adding the touch events](img/00033.jpeg)'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![执行动作时间 - 添加触摸事件](img/00033.jpeg)'
- en: In `onTouchMoved`, we only need to move the cue body based on the position of
    the player's finger. So we calculate the distance between the moving touch and
    the white ball. If the cue body is still too close to the ball, we set its `body`
    object to `sleep` and its `texture` object to `invisible`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onTouchMoved` 中，我们只需要根据玩家手指的位置移动球杆身体。因此，我们计算移动触摸和白球之间的距离。如果球杆身体仍然太靠近球，我们将将其
    `body` 对象设置为 `sleep` 并将其 `texture` 对象设置为 `invisible`。
- en: '[PRE32]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Otherwise, we awaken the body and call the `placeCue` method as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们唤醒身体并按照以下方式调用 `placeCue` 方法：
- en: '[PRE33]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This method then calculates the angle and position of the cue body and transforms
    the cue's `b2Body` method accordingly. The `SetTransform` option of a `b2Body`
    method takes care of both its position and angle.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法随后计算球杆身体的角位置和相应地转换球杆的 `b2Body` 方法。`b2Body` 方法的 `SetTransform` 选项负责其位置和角度。
- en: 'Finally, in `onTouchEnded`, we let go of the cue body as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `onTouchEnded` 中，我们按照以下方式释放球杆身体：
- en: '[PRE34]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We use `ApplyLinearImpulse`. This method receives a vector for the impulse to
    be applied and the position on the body where this impulse should be applied.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `ApplyLinearImpulse`。这个方法接收一个表示要施加的冲量的向量以及应该在身体上应用此冲量的位置。
- en: The `_pullback` variable stores the information of how far the cue body was
    from the ball when the player released the cue body. The farther it was, the strongest
    the shot will be.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`_pullback` 变量存储了玩家释放球杆身体时球杆身体与球之间的距离信息。它越远，射击力就越强。'
- en: '*What just happened?*'
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么事？*'
- en: We added the `touch` events that allow the player to hit the white ball with
    the cue body. The process is a very simple one. We first need to make sure the
    player is touching the white ball; then we move the cue body as the player drags
    his or her finger. Finally, when the touch is released, we make the cue spring
    towards the white ball with `ApplyLinearImpulse`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了允许玩家用球杆身体击打白球的 `touch` 事件。这个过程非常简单。我们首先需要确保玩家正在触摸白球；然后，当玩家拖动手指时，我们移动球杆身体。最后，当触摸释放时，我们使用
    `ApplyLinearImpulse` 使球杆弹簧向白球弹射。
- en: We may also move a body in Box2D by using `SetLinearVelocity` or `ApplyForce`,
    each with subtle and not-so-subtle differences. I recommend that you play around
    with these.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用 `SetLinearVelocity` 或 `ApplyForce` 在Box2D中移动一个身体，每个都有细微和不太细微的差异。我建议你尝试一下这些。
- en: The main loop
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主循环
- en: As I showed you before, the simulation only requires that you call its `Step()`
    method inside the main loop. Box2D takes care of all of its side of the bargain.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所展示的，模拟只需要你在主循环中调用它的`Step()`方法。Box2D会处理其所有方面。
- en: 'What remains usually is the rest of the game logic: scoring, game states, and
    updating your sprites to match the `b2Bodies` method.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通常剩下的就是游戏逻辑的其余部分：得分、游戏状态，以及更新你的精灵以匹配`b2Bodies`方法。
- en: 'It''s important to call the `update` method of each ball and cue. This is what
    our `b2Sprite update` method looks like:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 调用每个球和球杆的`update`方法是很重要的。这是我们的`b2Sprite update`方法的样子：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All you need to do is make sure the `Sprite` method matches the information
    in the `b2Body` object. And make sure that you convert meters back to pixels when
    you do so.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的只是确保`Sprite`方法与`b2Body`对象中的信息相匹配。并且确保在这样做的时候将米转换回像素。
- en: So let's add our main loop.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们添加我们的主循环。
- en: Time for action – adding the main loop
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 添加主循环
- en: It's inside our main loop that we update our `b2World` object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在我们的主循环中更新我们的`b2World`对象的地方。
- en: 'Start by updating the simulation as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，按照以下方式更新模拟：
- en: '[PRE36]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we need to determine if the game has finished by checking on the number
    of balls currently in play. We use the following for that:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要通过检查当前游戏中球的数量来确定游戏是否结束。我们使用以下方法：
- en: '[PRE37]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we continue to update the sprites as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们继续按照以下方式更新精灵：
- en: '[PRE38]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And we also determine when it''s time to allow the player a new shot. I decided
    to only let that happen if the white ball has stopped. And the quickest way to
    determine that is to check on its vector. Here''s how:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还确定何时允许玩家进行新的射击。我决定只有在白球停止时才允许这样做。而确定这一点最快的方法是检查它的向量。下面是如何做的：
- en: '[PRE39]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*What just happened?*'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We added our main loop. This will update the Box2D simulation and then it's
    up to us to take care of positioning our sprites based on the resulting information.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了主循环。这将更新Box2D模拟，然后我们负责根据结果信息定位我们的精灵。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One very important aspect of Box2D is understanding what can be changed inside
    a `b2World::Step` call and what can't.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D的一个非常重要的方面是理解在`b2World::Step`调用内部可以更改什么，不能更改什么。
- en: For instance, a body cannot be made inactive (`b2Body::SetActive`) or be destroyed
    (`b2World::DestroyBody`) inside a step. You will need to check on conditions outside
    the step to make these changes. For instance, in our game, we check to see if
    the ball sprites are visible or not, and if not then we set their bodies as inactive.
    And all this is done *after* the call to `b2World::Step`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个物体不能在步骤内部被设置为不活跃（`b2Body::SetActive`）或被销毁（`b2World::DestroyBody`）。你需要检查步骤之外的条件来做出这些更改。例如，在我们的游戏中，我们检查球精灵是否可见，如果不可见，则将它们的身体设置为不活跃。所有这些都是在调用`b2World::Step`之后完成的。
- en: Adding a timer to our game
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的游戏添加计时器
- en: In MiniPool, we count the number of seconds it takes the player to clear the
    table. Let me show you how to do that.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在MiniPool中，我们计算玩家清理桌子的秒数。让我给你展示如何做到这一点。
- en: Time for action – creating a timer
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建计时器
- en: We create timers in pretty much the same way we create our main loop.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建计时器的方式基本上与我们创建主循环的方式相同。
- en: 'First, we add a second scheduled event by adding this line to our `GameLayer`
    constructor:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们通过在`GameLayer`构造函数中添加以下行来添加第二个计划的事件：
- en: '[PRE40]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With this, we create a separate timer that will run the `ticktock` method every
    `1.5` seconds (I decided in the end that `1.5` seconds looked better).
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这样，我们创建了一个单独的计时器，每`1.5`秒运行一次`ticktock`方法（我最终决定`1.5`秒看起来更好）。
- en: The method keeps updating the value of the `_time` property and displaying it
    in the `_timer` label.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法持续更新`_time`属性的价值，并在`_timer`标签中显示它。
- en: '[PRE41]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*What just happened?*'
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We added a timer to our game by scheduling a second update—specifying the time
    interval we wanted—using the `schedule` method.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过安排第二个更新（指定我们想要的时间间隔）使用`schedule`方法来为我们的游戏添加计时器。
- en: If you wish to remove a timer, all you need to do is call the `unschedule(SEL_SCHEDULE
    selector)` method of nodes anywhere in your class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望移除计时器，你只需要在任何地方调用你类中的`unschedule(SEL_SCHEDULE selector)`方法。
- en: Now, let's take our Box2D game to Android.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的Box2D游戏带到Android上。
- en: Time for action – running the game in Android
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 在Android上运行游戏
- en: 'Follow these steps to deploy a Box2D game to Android:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤部署Box2D游戏到Android：
- en: Open the `Android.mk` file in a text editor (you'll find it in the folder `proj.android/jni`).
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`Android.mk`文件（你可以在`proj.android/jni`文件夹中找到它）。
- en: 'Edit the lines in `LOCAL_SRC_FILES` to read:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`LOCAL_SRC_FILES`中的行，使其读取：
- en: '[PRE42]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Open the manifest file and set the app orientation to `portrait`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开清单文件并将应用方向设置为`portrait`。
- en: Import the game into Eclipse and wait till all classes are compiled.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏导入Eclipse，等待所有类编译完成。
- en: Build and run your application.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行你的应用程序。
- en: '*What just happened?*'
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: That was it. There is no difference between building a game that uses Box2D
    and one that does not. The Box2D API is already included in the `make` file, in
    the line where the classes in the external folder are imported.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。使用Box2D构建的游戏和不使用Box2D构建的游戏之间没有区别。Box2D API已经包含在`make`文件中，在外部文件夹中的类导入行。
- en: And, of course, you don't need to add the `GLES-Render` class in your final
    project.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不需要在你的最终项目中添加`GLES-Render`类。
- en: Have a go hero
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: 'A few changes to make gameplay more interesting could be: add a limit to the
    number of times the white ball can hit a pocket; and another option is to have
    the timer work as a countdown one, so the player has a limited time to clear the
    table before time runs out.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使游戏更有趣，可以做一些改动：限制白色球击中球袋的次数；另一个选项是让计时器作为一个倒计时，这样玩家在时间耗尽前有有限的时间来清理桌面。
- en: Also, this game could do with a few animations. An `Action` method to scale
    down and fade out a ball when it hits a pocket would look very nice.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这款游戏还需要一些动画。当球击中球袋时，使用`Action`方法缩小并淡出球会看起来非常漂亮。
- en: Pop quiz
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验
- en: Q1\. What is the main object in a Box2D simulation?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. Box2D模拟中的主要对象是什么？
- en: '`b2Universe`.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`b2Universe`。'
- en: '`b2d`.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`b2d`。'
- en: '`b2World`.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`b2World`。'
- en: '`b2Simulation`.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`b2Simulation`。'
- en: Q2\. A `b2Body` object can be of which type?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 一个`b2Body`对象可以是哪种类型？
- en: '`b2_dynamicBody`, `b2_sensorBody`, `b2_liquidBody`.'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`b2_dynamicBody`，`b2_sensorBody`，`b2_liquidBody`。'
- en: '`b2_dynamicBody`, `b2_staticBody`, `b2_kinematicBody`.'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`b2_dynamicBody`，`b2_staticBody`，`b2_kinematicBody`。'
- en: '`b2_staticBody`, `b2_kinematicBody`, `b2_debugBody`.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`b2_staticBody`，`b2_kinematicBody`，`b2_debugBody`。'
- en: '`b2_kinematicBody`, `b2_transparentBody`, `b2_floatingBody`.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`b2_kinematicBody`，`b2_transparentBody`，`b2_floatingBody`。'
- en: Q3\. Which of the following list of properties can be set in a fixture definition?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Q3\. 以下哪些属性可以在固定定义中设置？
- en: Density, friction, restitution, shape.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密度，摩擦，恢复力，形状。
- en: Position, density, bullet state.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位置，密度，子弹状态。
- en: Angular damping, active state, friction.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 角阻尼，活动状态，摩擦。
- en: Linear damping, restitution, fixed rotation.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线性阻尼，恢复力，固定旋转。
- en: 'Q4\. If two bodies have the same unique value for their `maskBits` property
    in their fixture definition, this means:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Q4\. 如果两个物体在它们的固定定义中具有相同的唯一值`maskBits`属性，这意味着：
- en: The two bodies can never collide.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个物体永远不会发生碰撞。
- en: The two bodies will only trigger begin contact events.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个物体只会触发开始接触事件。
- en: The two bodies can only collide with each other.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个物体只能相互碰撞。
- en: The two bodies will only trigger end contact events.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个物体只会触发结束接触事件。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Nowadays, it seems like everybody in the world has played or will play a physics-based
    game at some point in their lives. Box2D is by far the most popular engine in
    the casual games arena. The commands you learned here can be found in pretty much
    every port of the engine, including a JavaScript one that is growing in popularity
    as we speak.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，似乎世界上每个人在某个时刻都玩过或将要玩一款基于物理的游戏。Box2D无疑是休闲游戏领域最受欢迎的引擎。你在这里学到的命令几乎可以在引擎的每个端口中找到，包括一个正在变得越来越受欢迎的JavaScript端口。
- en: Setting up the engine and getting it up and running is remarkably simple—perhaps
    too much so. A lot of testing and value tweaking goes into developing a Box2D
    game and pretty soon you learn that keeping the engine performing as you wish
    is the most important skill to master when developing physics-based games. Picking
    the right values for friction, density, restitution, damping, time step, PTM ratio,
    and so on can make or break your game.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 设置引擎并使其运行起来非常简单——也许过于简单。开发Box2D游戏需要大量的测试和值调整，很快你就会发现，在开发基于物理的游戏时，保持引擎按你的意愿运行是最重要的技能。选择合适的摩擦、密度、恢复力、阻尼、时间步长、PTM比率等值可以使你的游戏成功或失败。
- en: In the next chapter, we'll continue to use Box2D, but we'll focus on what else
    Cocos2d-x can do to help us organize our games.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续使用Box2D，但我们将关注Cocos2d-x还能做些什么来帮助我们组织游戏。
