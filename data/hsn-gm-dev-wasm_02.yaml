- en: HTML5 and WebAssembly
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5和WebAssembly
- en: In this chapter, we will show you how the C code we write to target WebAssembly
    comes together with HTML5, JavaScript, and CSS to create a web page. We will teach
    you how to create a new HTML shell file to be used by Emscripten in the creation
    of our WebAssembly app. We will discuss the `Module` object and how Emscripten
    uses it as an interface between our JavaScript and the WebAssembly module. We
    will show you how to call WebAssembly functions written in C from within JavaScript
    on our HTML page. We will also show you how to call JavaScript functions from
    our C code. We will discuss how to use CSS to improve the look of our web page.
    We will introduce you to the HTML5 Canvas element and show how it is possible
    to display images to the canvas from within JavaScript. We will briefly discuss
    moving those images around the canvas from our WebAssembly module. This chapter
    will give you an understanding of how everything works together and lays the foundation
    for other features we are developing for our WebAssembly applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示我们编写的用于目标WebAssembly的C代码如何与HTML5、JavaScript和CSS结合在一起，创建一个网页。我们将教您如何创建一个新的HTML外壳文件，供Emscripten在创建我们的WebAssembly应用程序时使用。我们将讨论`Module`对象以及Emscripten如何将其用作JavaScript和WebAssembly模块之间的接口。我们将向您展示如何在我们的HTML页面上从JavaScript中调用用C编写的WebAssembly函数。我们还将向您展示如何从我们的C代码中调用JavaScript函数。我们将讨论如何使用CSS来改善我们网页的外观。我们将向您介绍HTML5
    Canvas元素，并展示如何可以从JavaScript中向画布显示图像。我们将简要讨论如何从我们的WebAssembly模块移动这些图像。本章将让您了解所有内容是如何协同工作的，并为我们为WebAssembly应用程序开发的其他功能奠定基础。
- en: 'Beginning with this chapter and continuing through the remainder of the book,
    you will need image and font files from the GitHub project to compile the examples.
    For this chapter, you will need the `/Chapter02/spaceship.png` image file from
    the project directory. Please download the project from the following URL: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，一直到本书的其余部分，您将需要从GitHub项目中获取图像和字体文件来编译示例。对于本章，您将需要从项目目录中获取`/Chapter02/spaceship.png`图像文件。请从以下网址下载项目：[https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly)。
- en: 'I highly recommend working along as you read each section of this chapter.
    You may use your favorite code editor and the command line to follow along. Even
    though we have provided links to download the code directly, it cannot be emphasized
    enough how much you will learn by actually following edits suggested in this chapter.
    You are going to make mistakes and learn a lot from them. If you decide to work
    along, another suggestion is the following: do not proceed to the next section
    unless your edit/steps in the current section are successful. If you need help,
    contact me on twitter (`@battagline`).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您在阅读本章的每个部分时进行实际操作。您可以使用您喜欢的代码编辑器和命令行进行跟随。尽管我们已经提供了直接下载代码的链接，但无法强调您通过实际跟随本章建议的编辑来学到多少。您将犯错误并从中学到很多。如果您决定跟随操作，另一个建议是：除非当前部分的编辑/步骤成功，否则不要继续进行下一部分。如果需要帮助，请在Twitter上联系我（`@battagline`）。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The Emscripten minimal shell file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Emscripten最小外壳文件
- en: Creating a new HTML shell and C file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的HTML外壳和C文件
- en: Defining our CSS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义我们的CSS
- en: HTML5 and game development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML5和游戏开发
- en: Adding a canvas to the Emscripten template
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Emscripten模板添加画布
- en: The Emscripten minimal shell file
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Emscripten最小外壳文件
- en: The first build we created with Emscripten used a default HTML shell file. If
    you have a website, this is probably not the way you would prefer your web page
    to look. You would probably prefer to design your look and feel using CSS and
    HTML5 specific to your design or business needs. For instance, the templates I
    use for my websites typically include advertisements to the left and right of
    the game's canvas. That is how traffic to these sites is monetized. You may choose
    to add a logo for your website above your game's canvas. There is also a text
    area where Emscripten logs output from `printf` or other standard IO calls. You
    may choose to remove this `textarea` element altogether, or you may keep it, but
    keep it hidden because it is useful for debugging later.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Emscripten创建的第一个构建使用了默认的HTML外壳文件。如果您有一个网站，这可能不是您希望网页看起来的方式。您可能更喜欢使用CSS和HTML5来设计您的外观和感觉，以满足您的设计或业务需求。例如，我用于我的网站的模板通常在游戏画布的左右两侧包括广告。这就是这些网站的流量变现方式。您可能选择在您的网站上方添加一个标志。还有一个文本区域，Emscripten从`printf`或其他标准IO调用中记录输出。您可以选择完全删除这个`textarea`元素，或者您可以保留它，但将其隐藏，因为它对以后的调试很有用。
- en: 'To build the HTML file based on a new shell file that is not the default Emscripten
    shell, we must use the `--shell-file` parameter, passing it the new HTML template
    file we would like to use, instead of Emscripten''s default. The new `emcc` command
    will look like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要基于不是默认Emscripten外壳的新外壳文件构建HTML文件，我们必须使用`--shell-file`参数，将新的HTML模板文件传递给它，而不是Emscripten的默认文件。新的`emcc`命令将如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Do not execute this command just yet. We do not currently have a `new_shell.html`
    file in our project directory, so running the command before that file exists
    will result in an error message. We need to create the `new_shell.html` file and
    use it as the HTML shell instead of Emscripten''s default HTML shell. This shell
    file must follow a specific format. To construct it, we have to start with Emscripten''s
    minimum HTML shell file, which you can find at GitHub here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时不要执行这个命令。我们目前在项目目录中没有`new_shell.html`文件，因此在该文件存在之前运行该命令将导致错误消息。我们需要创建`new_shell.html`文件，并将其用作HTML外壳，而不是Emscripten的默认HTML外壳。这个外壳文件必须遵循特定的格式。为了构建它，我们必须从Emscripten的最小HTML外壳文件开始，您可以在GitHub上找到它：
- en: '[https://github.com/emscripten-core/emscripten/blob/master/src/shell_minimal.html](https://github.com/emscripten-core/emscripten/blob/master/src/shell_minimal.html)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/emscripten-core/emscripten/blob/master/src/shell_minimal.html](https://github.com/emscripten-core/emscripten/blob/master/src/shell_minimal.html)'
- en: 'We will be writing our own HTML shell, using the `shell_minimal.html` file
    as a starting point. Much of what is in the minimal shell is not required, so
    we will make some significant edits to it. We will remove much of the code to
    suit our purpose. When you open `shell_minimal.html` in your text editor, you
    will see that it starts with a standard HTML header and a `style` tag:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写自己的 HTML 外壳，使用 `shell_minimal.html` 文件作为起点。最小外壳中的大部分内容都不是必需的，因此我们将对其进行一些重大编辑。我们将删除大部分代码以适应我们的目的。当您在文本编辑器中打开
    `shell_minimal.html` 时，您会看到它以标准的 HTML 头部和 `style` 标签开头：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code is based on the version of `shell_minimal.html` available at the time
    of writing. No changes to this file are anticipated. However, WebAssembly is evolving
    quickly. Unfortunately, we cannot say with complete certainty that this file will
    remain unchanged by the time you read this. As mentioned earlier, if you run into
    problems, please feel free to contact me on Twitter (`@battagline`).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是基于撰写时可用的 `shell_minimal.html` 版本。不预期对此文件进行任何更改。然而，WebAssembly 发展迅速。不幸的是，我们无法完全肯定在您阅读此文时，该文件是否会保持不变。如前所述，如果遇到问题，请随时在
    Twitter 上联系我（`@battagline`）。
- en: 'We remove this style tag so you can style your code any way you like. It is
    necessary if you like their spinner loading image and want to keep it, but it
    is preferable to yank all of this out and replace it with CSS loaded externally
    from a CSS file with the link tag, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删除此样式标签，以便您可以按自己的喜好设置代码样式。如果您喜欢他们的旋转加载图像并希望保留它，这是必需的，但最好将所有这些都删除，并用链接标签从外部加载
    CSS 文件替换它，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Scroll down a little further, and you will see the loading indicators they
    use. We are going to replace that with our own eventually, but for now, we are
    testing all of this locally, and our files are all tiny, so we would remove this
    code as well:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动一点，您会看到它们使用的加载指示器。我们最终将用我们自己的加载指示器替换它，但现在我们正在本地测试所有这些，我们的文件都很小，所以我们也会删除这些代码：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After that, there is an HTML5 `canvas` element and some other tags related
    to it. We will eventually need to add a `canvas` element back in, but for now,
    we will not be using the `canvas`, so that part of the code is not necessary either:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之后是一个 HTML5 `canvas` 元素和与之相关的一些其他标签。我们最终需要重新添加一个 `canvas` 元素，但现在我们不会使用 `canvas`，因此代码的这部分也是不必要的：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After the `canvas`, there is a `textarea` element. That is also not necessary,
    but it would be good to use it as the location where any `printf` commands executed
    from my C code are printed. The shell has surrounded it with two `<hr/>` tags,
    used for formatting, so we can remove those as well:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `canvas` 之后，有一个 `textarea` 元素。这也是不必要的，但最好将其用作从我的 C 代码执行的任何 `printf` 命令的打印位置。外壳用两个
    `<hr/>` 标签将其包围，用于格式化，因此我们也可以删除这些标签：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next thing we have is our JavaScript. That starts with three variables
    that represent HTML elements that we removed earlier, so we are going to need
    to remove all of those JavaScript variables as well:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们的 JavaScript。它以三个变量开头，这些变量代表我们之前删除的 HTML 元素，因此我们也需要删除所有这些 JavaScript 变量：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Module` object inside JavaScript is the interface that the Emscripten-generated
    JavaScript *glue* code uses to interact with our WebAssembly module. It is the
    most crucial part of a shell HTML file, and it is essential to understand what
    it is doing. The `Module` object begins with two arrays, `preRun`, and `postRun`.
    These are arrays of functions that will run before and after the module is loaded,
    respectively.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的 `Module` 对象是 Emscripten 生成的 JavaScript *粘合* 代码用来与我们的 WebAssembly
    模块交互的接口。这是 shell HTML 文件中最重要的部分，了解它正在做什么是至关重要的。`Module` 对象以两个数组 `preRun` 和 `postRun`
    开始。这些是在模块加载之前和之后运行的函数数组，分别。
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For demonstration purposes, we could add functions to these arrays like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 出于演示目的，我们可以像这样向这些数组添加函数：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This would produce the following output from our hello WASM app that we created
    in [Chapter1](2a47a921-b081-4857-9040-de3ff6298a43.xhtml), *Introduction to WebAssembly
    and Emscripten*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从我们在 [Chapter1](2a47a921-b081-4857-9040-de3ff6298a43.xhtml) 中创建的 hello WASM
    应用程序产生以下输出，*WebAssembly 和 Emscripten 简介*：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that the `preRun` and `postRun` functions run in the reverse order in
    which they are placed in the array. We could use the `postRun` array to call a
    function that would initialize our WebAssembly wrappers, but, for demonstration
    purposes, we will instead call a JavaScript function from within our C `main()`
    function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`preRun` 和 `postRun` 函数按照它们在数组中的顺序相反的顺序运行。我们可以使用 `postRun` 数组来调用一个函数，该函数将初始化我们的
    WebAssembly 封装器，但是，出于演示目的，我们将在我们的 C `main()` 函数中调用 JavaScript 函数。
- en: 'The next two functions inside the `Module` object are the `print` and `printErr`
    functions. The `print` function is used to print out the output of the `printf`
    calls to both the console and to the `textarea` that we have named `output`. You
    can change this `output` to print out to any HTML tag, but, if your output is
    raw HTML, there are several commented-out text replace calls that must run. Here
    is what the `print` function looks like:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Module` 对象内的下两个函数是 `print` 和 `printErr` 函数。`print` 函数用于将 `printf` 调用的输出打印到控制台和我们命名为
    `output` 的 `textarea` 中。您可以将此 `output` 更改为打印到任何 HTML 标记，但是，如果您的输出是原始 HTML，则必须运行几个已注释掉的文本替换调用。`print`
    函数如下所示：'
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `printErr` function is run by the glue code when an error or warning occurs
    in either our WebAssembly module or the glue code itself. The output of `printErr`
    is only the console, although, in principle, if you wanted to add code that would
    write to an HTML element, you could do that as well. Here is the `printErr` code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`printErr` 函数在粘合代码中运行，当我们的 WebAssembly 模块或粘合代码本身发生错误或警告时。`printErr` 的输出只在控制台中，尽管原则上，如果你想添加代码来写入
    HTML 元素，你也可以这样做。这是 `printErr` 代码：'
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After the `print` functions, there is a `canvas` function. This function is
    set up to alert the user to a lost WebGL context. We do not need that code right
    now, because we have removed the HTML Canvas. When we add the `canvas` element
    back in, we will need to restore this function. It also makes sense to update
    it to handle a lost context event, instead of just alerting the user.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`print`函数之后，还有一个`canvas`函数。此函数设置为警告用户丢失了WebGL上下文。目前我们不需要该代码，因为我们已经删除了HTML Canvas。当我们重新添加`canvas`元素时，我们将需要恢复此函数。更新它以处理丢失上下文事件，而不仅仅是警告用户也是有意义的。
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are several different situations when your web page could lose its WebGL
    context. The context is your portal into the GPU, and your app's access to the
    GPU is managed by both the browser and the operating system. Let's take a trip
    to *The Land of Metaphor*, where we imagine the GPU is a bus, the web browser
    is the bus driver, and the apps using their context are a bunch of rowdy middle
    school kids. If the bus driver (browser) feels that the kids (apps) are getting
    too rowdy, he can stop the bus (GPU), throw all the kids off the bus (make the
    apps lose their context), and let them come back one at a time if they promise
    to behave.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网页可能丢失其WebGL上下文的几种不同情况下。上下文是您进入GPU的门户，您的应用程序对GPU的访问由浏览器和操作系统共同管理。让我们来到*隐喻之地*，在那里我们想象GPU是一辆公共汽车，Web浏览器是公共汽车司机，使用其上下文的应用程序是一群吵闹的中学生。如果公共汽车司机（浏览器）觉得孩子们（应用程序）太吵闹，他可以停下公共汽车（GPU），让所有孩子下车（使应用程序失去上下文），然后让他们一个接一个地上车，如果他们答应表现好的话。
- en: 'After that, the minimal shell has some code that keeps track of the module''s
    status and dependencies. In this code, we can remove references to the `spinnerElement`,
    `progressElement`, and `statusElement`. Later, if we choose, we can replace these
    with elements to keep track of the state of loaded modules, but, for the moment,
    they are not needed. Here is the status and run dependency monitoring code in
    the minimal shell:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，最小外壳文件中有一些代码用于跟踪模块的状态和依赖关系。在这段代码中，我们可以删除对`spinnerElement`、`progressElement`和`statusElement`的引用。稍后，如果我们选择，可以用元素替换这些内容，以跟踪加载模块的状态，但目前不需要。以下是最小外壳中的状态和运行依赖监控代码：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The final piece of JavaScript code inside the minimal shell file determines
    what JavaScript will do in the event of a browser error:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码的最后一部分在最小外壳文件中确定了在浏览器错误发生时JavaScript将会做什么：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After our JavaScript, there is one more important line:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的JavaScript之后，还有一行非常重要的代码：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This tag tells Emscripten to place the link to the JavaScript glue code here.
    Here is an example of what gets compiled into the final HTML file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此标记告诉Emscripten将JavaScript粘合代码的链接放在这里。以下是编译到最终HTML文件中的示例：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`shell-min.js` is the JavaScript glue code that is built by Emscripten. In
    the next section, we will learn how to create our own HTML shell file.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`shell-min.js`是由Emscripten构建的JavaScript粘合代码。在下一节中，我们将学习如何创建自己的HTML外壳文件。'
- en: Creating a new HTML shell and C file
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的HTML外壳和C文件
- en: 'In this section, we are going to create a new `shell.c` file that exposes several
    functions called from our JavaScript. We will also use `EM_ASM` to call the `InitWrappers`
    function that we will define inside the new HTML shell file that we will be creating.
    This function will create wrappers inside JavaScript that can call functions defined
    in the WebAssembly module. Before creating the new HTML shell file, we need to
    create the C code that will be called by the JavaScript wrappers inside the HTML
    shell:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将创建一个新的`shell.c`文件，其中公开了从JavaScript调用的几个函数。我们还将使用`EM_ASM`调用`InitWrappers`函数，该函数将在我们即将创建的新HTML外壳文件中定义。此函数将在JavaScript中创建包装器，可以调用WebAssembly模块中定义的函数。在创建新的HTML外壳文件之前，我们需要创建将由HTML外壳内的JavaScript包装器调用的C代码：
- en: 'Create the new `shell.c` file as follows:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式创建新的`shell.c`文件：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `main` function runs when the WebAssembly module is loaded. At this point,
    the `Module` object can use `cwrap` to create a JavaScript version of that function
    that we can tie to `onclick` events on the HTML elements. Inside the `main` function,
    the `EM_ASM( InitWrappers() );` code calls an `InitWrappers()` function that is
    defined inside JavaScript in the HTML shell file. The DOM uses events to call
    the next four functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当WebAssembly模块加载时，`main`函数将运行。此时，`Module`对象可以使用`cwrap`创建该函数的JavaScript版本，我们可以将其绑定到HTML元素的`onclick`事件上。在`main`函数内部，`EM_ASM(
    InitWrappers() );`代码调用了在HTML外壳文件中的JavaScript中定义的`InitWrappers()`函数。DOM使用事件来调用接下来的四个函数。
- en: 'Another way we could have initialized the wrappers is by calling the `InitWrappers()`
    function from the `Module` object `postRun: []` array.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '我们初始化包装器的另一种方式是从`Module`对象的`postRun: []`数组中调用`InitWrappers()`函数。'
- en: We will tie a call to the `test()` function to a button click in the DOM. The
    `int_test` function will be passed as a value from an input field in the DOM and
    will print a message to the console and `textarea` element that includes that
    integer, by using a `printf` statement. The `float_test` function will be passed
    a number as a floating point, printed to the console and `textarea` element. The
    `string_test` function will print out a string that is passed in from JavaScript.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在DOM中将对`test()`函数的调用与按钮点击绑定。`int_test`函数将作为一个值从DOM中的输入字段传递，并通过使用`printf`语句将一个消息打印到控制台和`textarea`元素中，其中包括该整数。`float_test`函数将作为一个浮点数传递一个数字，并打印到控制台和`textarea`元素中。`string_test`函数将打印从JavaScript传入的字符串。
- en: Now, we are going to add the following code to an HTML shell file and call it
    `new_shell.html`. The code is based on the *Emscripten minimal shell file* created
    by the Emscripten team and explained in the previous section. We will present
    the entire HTML page divided into four parts.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在HTML外壳文件中添加以下代码，并将其命名为`new_shell.html`。该代码基于Emscripten团队创建的*Emscripten最小外壳文件*，并在前一节中进行了解释。我们将整个HTML页面分为四个部分呈现。
- en: 'To begin with, there is the beginning of the HTML file and the `head` element:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是HTML文件的开头和`head`元素：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, is the beginning of the `body` tag. After that, we have several HTML
    `input` elements as well as the `textarea` element:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`body`标签的开始。在此之后，我们有几个HTML `input`元素以及`textarea`元素：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After our HTML, we have the beginning of our `script` tag, and some JavaScript
    code we have added to the default shell file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的HTML之后，我们有`script`标签的开始，以及我们添加到默认shell文件中的一些JavaScript代码：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we have the `Module` object that we brought in from the default shell
    file. After the `Module` object, we have the end to the `script` tag, the `{{{
    SCRIPT }}}` tag, which is replaced by Emscripten when compiled, and the ending
    tags in our file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们从默认shell文件中引入的`Module`对象。在`Module`对象之后，我们有`script`标签的结束，`{{{ SCRIPT }}}`标签，在编译时由Emscripten替换，以及我们文件中的结束标签：
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These previous four sections all make up a single shell file called `new_shell.html`.
    You can create this code by typing out the last four parts into a file you name
    `new_shell.html`, or you can download the file from our GitHub page at [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly/blob/master/Chapter02/new_shell.html](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly/blob/master/Chapter02/new_shell.html).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这前面的四个部分组成了一个名为`new_shell.html`的单个shell文件。您可以通过将最后四个部分输入到一个名为`new_shell.html`的文件中来创建此代码，或者您可以从我们的GitHub页面下载该文件[https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly/blob/master/Chapter02/new_shell.html](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly/blob/master/Chapter02/new_shell.html)。
- en: 'Now that we have seen the entire `new_shell.html` file in large chunks, we
    can spend a little time breaking down the essential parts and going over it at
    a granular level. You will notice that we removed all of the CSS style code and
    have created a new `shell.css` file included with the following line:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经大块地看完了整个`new_shell.html`文件，我们可以花一点时间来分解其中的重要部分，并以更细粒度的方式进行讨论。您会注意到我们删除了所有的CSS样式代码，并创建了一个新的`shell.css`文件，并在其中包含了以下行：
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we have reworked the HTML code inside this file to create elements that
    will interact with the WebAssembly module. First, we are going to add a button
    that will call the `test()` function inside the WebAssembly module:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们重新设计了这个文件中的HTML代码，以创建与WebAssembly模块交互的元素。首先，我们将添加一个按钮，该按钮将调用WebAssembly模块内的`test()`函数：
- en: '[PRE23]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will style the button and its included `div` element inside the `shell.css`
    file that we have created. We will need to define the function that will be called
    by the `onclick` event of this `button` element inside the JavaScript code we
    will write later. We will do something similar for the two input/button pairs
    we will define in the HTML, as demonstrated in the following code block:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们创建的`shell.css`文件中对按钮及其包含的`div`元素进行样式设置。我们需要定义将在稍后编写的JavaScript代码中由此`button`元素的`onclick`事件调用的函数。我们将在HTML中定义的两个输入/按钮对中做类似的事情，如下面的代码块所示：
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Like we did with the first `button` element, we will tie these next two buttons
    to functions that will make calls into the WebAssembly module. These function
    calls will also pass the values defined in the `input` elements into the WebAssembly
    functions. We have left the `textarea` element as an output for the `printf` calls
    that happen within the WebAssembly module. We have styled it differently in the
    CSS file, but we will leave the functionality unchanged:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对第一个`button`元素所做的那样，我们将把接下来的两个按钮与将调用WebAssembly模块的函数联系起来。这些函数调用还将把`input`元素中定义的值传递到WebAssembly函数中。我们将`textarea`元素留作WebAssembly模块内的`printf`调用的输出。我们在CSS文件中对其进行了不同的样式设置，但我们将保持功能不变：
- en: '[PRE25]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Underneath the `textarea` element, we have added one more `button` and a `string`
    `input` element. This button will call the `string_test` function inside the WebAssembly
    module, passing it the value inside the `string_input` element as a C `char*`
    parameter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`textarea`元素下面，我们添加了另一个`button`和一个`string` `input`元素。这个按钮将调用WebAssembly模块内的`string_test`函数，并将`string_input`元素中的值作为C
    `char*`参数传递给它。
- en: 'Now that we have defined all of the elements we need in the HTML, we will go
    through and add some JavaScript code to tie the JavaScript and WebAssembly module
    together. The first thing we need to do is define the `InitWrappers` function.
    `InitWrappers` will be called from within the `main` function in the C code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经在HTML中定义了所有需要的元素，我们将逐步添加一些JavaScript代码，以将JavaScript和WebAssembly模块联系在一起。我们需要做的第一件事是定义`InitWrappers`函数。`InitWrappers`将从C代码的`main`函数内部调用：
- en: '[PRE26]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This function uses `Module.cwrap` to create JavaScript function wrappers around
    the exported functions inside the WebAssembly module. The first parameter we pass
    to `cwrap` is the name of the C function we are wrapping. All of these JavaScript
    functions will return `undefined`. JavaScript does not have a `void` type like
    C, so when we declare the `return` type in JavaScript, we need to use the `undefined`
    type instead. If the function were to return an `int` or a `float,` we would need
    to put the `'number'` value here. The final parameter passed into `cwrap` is an
    array of strings that represent the C type of the parameters passed into the WebAssembly
    module.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使用`Module.cwrap`来创建围绕WebAssembly模块内导出函数的JavaScript函数包装器。我们传递给`cwrap`的第一个参数是我们要包装的C函数的名称。所有这些JavaScript函数都将返回`undefined`。JavaScript没有像C那样的`void`类型，因此当我们在JavaScript中声明`return`类型时，我们需要使用`undefined`类型。如果函数要返回`int`或`float`，我们需要在这里放置`'number'`值。传递给`cwrap`的最后一个参数是一个字符串数组，表示传递给WebAssembly模块的参数的C类型。
- en: 'After we have defined the JavaScript wrappers around the functions, we need
    to call them from the buttons. The first one of these calls is to the WebAssembly
    `int_test` function. Here is how we set the `onclick` event for the `int_button`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义了函数的JavaScript包装器之后，我们需要从按钮中调用它们。其中一个调用是对WebAssembly的`int_test`函数。以下是我们为`int_button`设置`onclick`事件的方式：
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first thing we will do is check to see whether `int_test` is defined. If
    so, we call the `int_test` wrapper we explained earlier, passing it the value
    from the `int_num` input. We then do something similar for all of the other buttons.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是检查`int_test`是否已定义。如果是这样，我们调用我们之前解释的`int_test`包装器，将`int_num`输入的值传递给它。然后我们对所有其他按钮做类似的事情。
- en: 'The next thing we do is create a `runbefore` and `runafter` function that we
    place in the `preRun` and `postRun` arrays on the `Module` object:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要做的是创建一个`runbefore`和`runafter`函数，将它们放在`Module`对象的`preRun`和`postRun`数组中：
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That will cause "before module load" to be printed to the console before the
    module is loaded, and "after module load" is printed after the module is loaded.
    These functions are not required; they are designed to show how you might run
    code before and after a WebAssembly module is loaded. If you do not want to call
    the `InitWrappers` function from the `main` function in the WebAssembly module,
    you could instead put that function inside the `postRun` array.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致在模块加载之前在控制台上打印“before module load”，并且在模块加载后打印“after module load”。这些函数不是必需的；它们旨在展示您如何在加载WebAssembly模块之前和之后运行代码。如果您不想从WebAssembly模块的`main`函数中调用`InitWrappers`函数，您可以将该函数放在`postRun`数组中。
- en: The remainder of the JavaScript code is similar to what you would find inside
    the `shell_minimal.html` file created by Emscripten. We have removed code that
    is superfluous for this demonstration, such as code related to the `spinnerElement`,
    `progressElement`, and `statusElement`, as well as code having to do with the
    HTML5 `canvas`. It is not that there is anything wrong with leaving that code
    in JavaScript, but it is not truly necessary for our demonstration, so we have
    removed it to reduce this shell to the minimum required.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码的其余部分与Emscripten创建的`shell_minimal.html`文件中的内容类似。我们已删除了对于本演示多余的代码，例如与HTML5`canvas`相关的代码，以及与`spinnerElement`、`progressElement`和`statusElement`相关的代码。这并不是说在JavaScript中留下这些代码有什么问题，但对于我们的演示来说并不是真正必要的，因此我们已将其删除以减少所需的最小代码。
- en: Defining the CSS
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义CSS
- en: Now that we have some basic HTML, we need to create a new `shell.css` file.
    Without any CSS styling, our page looks pretty terrible.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一些基本的HTML，我们需要创建一个新的`shell.css`文件。没有任何CSS样式，我们的页面看起来非常糟糕。
- en: 'A page without styling will be similar to the one shown as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 没有样式的页面将类似于以下所示：
- en: '![](img/f8b0d833-eab2-4125-9705-d44e21ddf664.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8b0d833-eab2-4125-9705-d44e21ddf664.png)'
- en: 'Figure 2.1: The Hello WebAssembly app without a CSS style'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：没有CSS样式的Hello WebAssembly应用程序
- en: 'Luckily for us, a little bit of CSS goes a long way to make our web page look
    presentable. Here is what the new `shell.css` file we are creating looks like:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一点点CSS可以让我们的网页看起来很不错。以下是我们正在创建的新`shell.css`文件的样子：
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let me quickly walk through what we need to do to style this page. This book
    is not a book on CSS, but it does not hurt to cover the topic in a cursory fashion.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我快速浏览一下我们需要做的样式化页面的步骤。这本书不是一本关于CSS的书，但简要地介绍一下这个主题也无妨。
- en: 'The first thing we will do is put a little 20-pixel margin on the page body
    to put a little bit of space between the browser toolbar and the content on our
    page:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是在页面主体上放置20像素的小边距，以在浏览器工具栏和页面内容之间留出一点空间：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We have created five input boxes that take up `20%` of the browser width each.
    The boxes on the left and the right have nothing in them, so that the content
    takes up 60% of the browser width. They are displayed as an inline-block, so that
    they line up horizontally across the screen. Here is the CSS that makes it happen:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已创建了五个输入框，每个输入框占浏览器宽度的`20%`。左右两侧的框中都没有内容，因此内容占据了浏览器宽度的60%。它们以内联块的形式显示，这样它们就可以在屏幕上水平排列。以下是使其发生的CSS：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We then have a few classes to style our buttons using a class called `em_button`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们有一些类来使用名为`em_button`的类来样式化我们的按钮：
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have set the button width to take up `45%` of the containing element. We
    set the button height to 40 pixels. We have set the button's color to `orangered`,
    and the text color to `white`. We remove the border by setting its width to 0
    pixels. We have set the font size to 20 pixels and given it an 8 pixel border-radius,
    which provides the button with a rounded look. The last line sets the amount of
    time it takes to transition to a new color when the user hovers over the button.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将按钮宽度设置为占包含元素的`45%`。我们将按钮高度设置为40像素。我们已将按钮的颜色设置为`orangered`，文本颜色设置为`白色`。我们通过将边框宽度设置为0像素来移除边框。我们已将字体大小设置为20像素，并给它设置了8像素的边框半径，这样按钮就呈现出圆角外观。最后一行设置了用户悬停在按钮上时过渡到新颜色所需的时间。
- en: After we finish the definition of the `em_button` class, we define the `em_button:hover`
    class, which changes the color of the button when the user hovers over it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`em_button`类之后，我们定义了`em_button:hover`类，当用户悬停在按钮上时，它会改变按钮的颜色。
- en: 'Some versions of Safari require the line `-webkit-transition-duration: 0.2s;`
    inside the `em_button` class definition to have a transition to the hover state.
    Without this line, the button would instantly change from `orangered` to `orange`
    in some versions of Safari, rather than transitioning over 200 milliseconds.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '某些版本的Safari需要在`em_button`类定义内部包含一行`-webkit-transition-duration: 0.2s;`，才能实现悬停状态的过渡。没有这一行，在某些版本的Safari中，按钮会立即从`orangered`变为`orange`，而不是在200毫秒内过渡。'
- en: 'The next class we define is for the `input` elements:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的下一个类是用于`input`元素的：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have set its `height`, `width`, and `font-size` at the beginning. We set
    the background color to a `darkslategray` with `white` text. We have added `6`
    pixels of padding so that there is a small space between the font and the edge
    of the `input` element.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在开头设置了它的`高度`、`宽度`和`字体大小`。我们将背景颜色设置为`darkslategray`，文本为`白色`。我们添加了`6`像素的填充，以便在`input`元素的字体和边缘之间有一小段空间。
- en: 'The `#` in front of the name of a CSS element styles an ID instead of a class.
    An ID defines a specific element where a class (preceded by a `.` in CSS) can
    be assigned to multiple elements in your HTML. The next bit of CSS styles the
    `textarea` that has the ID of output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS元素名称前面的`#`样式化ID而不是类。ID定义了特定的元素，而类（在CSS中以`.`开头）可以分配给HTML中的多个元素。CSS的下一部分样式化了具有ID输出的`textarea`：
- en: '[PRE34]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first two lines set the background and text color. We set the font size
    to `16` pixels and add `10` pixels of padding. The next two lines use the left
    and right margin to center the `textarea`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行设置了背景和文本颜色。我们将字体大小设置为`16`像素，并添加了`10`像素的填充。接下来的两行使用左右边距将`textarea`居中：
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Setting `display: block;` puts this element on a line by itself. Setting the
    width to `60%` makes the element take up `60%` of the containing element, which,
    in this case, is the browser''s `body` tag.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '设置`display: block;`将此元素放在一行上。将宽度设置为`60%`使元素占据包含元素的`60%`，在这种情况下是浏览器的`body`标记。'
- en: 'Finally, we style the `string_box` and `string_input` elements:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对`string_box`和`string_input`元素进行了样式设置：
- en: '[PRE36]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `string_box` is the box that contains the string button and the string
    input elements. We pad the top of the box to add some space between the `string_box`
    and the `textarea` above it. `margin-left: auto` and `margin-right: auto` center
    the box. Then, we use `display:block` and `width: 60%` to have it take up `60%`
    of the web browser.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_box`是包含字符串按钮和字符串输入元素的框。我们在框的顶部填充了一些空间，以在其上方的`textarea`和`string_box`之间添加一些空间。`margin-left:
    auto`和`margin-right: auto`将框居中。然后，我们使用`display:block`和`width: 60%`使其占据浏览器的`60%`。'
- en: 'For the `string_input` element, we set the font size and the colors and pad
    it by 6 pixels. We set a left margin of 5 pixels to put some space on the left
    between the element and its button. We set it to take up `45%` of the width of
    the containing element, while the `float: right` style pushes the element to the
    right side of the containing element.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '对于`string_input`元素，我们设置了字体大小和颜色，并在其周围填充了6像素。我们设置了左边距为5像素，以在元素和其按钮之间留出一些空间。我们将其设置为占包含元素宽度的`45%`，而`float:
    right`样式将元素推到包含元素的右侧。'
- en: 'To build our app, we need to run `emcc`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们的应用程序，我们需要运行`emcc`：
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`EXPORTED_FUNCTIONS` is used to define all of the functions called from JavaScript.
    They are listed with a preceding `_` character. `EXTRA_EXPORTED_RUNTIME_METHODS`
    is used to make the `cwrap` and `ccall` methods available to the JavaScript inside
    our shell file. We are not currently using `ccall`, which is an alternative to
    `cwrap`, which we may choose to use in the future.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPORTED_FUNCTIONS`用于定义从JavaScript调用的所有函数。它们在前面加上`_`字符。`EXTRA_EXPORTED_RUNTIME_METHODS`用于使`cwrap`和`ccall`方法在我们的shell文件内部的JavaScript中可用。我们目前没有使用`ccall`，这是`cwrap`的替代方法，我们将来可能选择使用它。'
- en: It is important to remember that you must run WebAssembly apps using a web server,
    or with `emrun`. If you would like to run your WebAssembly app using `emrun`,
    you must compile it with the `--emrun` flag. The web browser requires a web server
    to stream the WebAssembly module. If you attempt to open an HTML page that uses
    WebAssembly in a browser directly from your hard drive, that WebAssembly module
    will not load.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，您必须使用Web服务器或`emrun`来运行WebAssembly应用程序。如果您想使用`emrun`运行WebAssembly应用程序，您必须使用`--emrun`标志进行编译。Web浏览器需要Web服务器来流式传输WebAssembly模块。如果您尝试直接从硬盘驱动器在浏览器中打开使用WebAssembly的HTML页面，那么WebAssembly模块将无法加载。
- en: 'Now that we have added some CSS styling, we have a much nicer looking app:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了一些CSS样式，我们的应用程序看起来好多了：
- en: '![](img/e8381064-6edf-40d8-8e9d-2f1e4f4b678c.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8381064-6edf-40d8-8e9d-2f1e4f4b678c.png)'
- en: 'Figure 2.2: The Hello WebAssembly app with a CSS style'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：带有CSS样式的Hello WebAssembly应用程序
- en: In the next section, we will discuss HTML5 web game development.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论HTML5网络游戏开发。
- en: HTML5 and game development
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML5和游戏开发
- en: Most HTML rendering is done through the HTML **Document Object Model** (**DOM**).
    The DOM is what is known as a *retained mode* graphical library. Retained mode
    graphics retain a tree known as a **scene graph**. This scene graph keeps track
    of all the graphical elements in our model and how to render them. The nice thing
    about retained mode graphics is that they are straightforward for a developer
    to manage. The graphical library does all the heavy lifting and keeps track of
    our objects for us as well as where they render. The downside is that a retained
    mode system takes up a lot more memory and provides a lot less control to the
    developer. When we write HTML5 games, we could take images rendered in the DOM
    using `<IMG>` HTML elements and move those elements around using JavaScript or
    CSS animations to manipulate the positions of those images within the DOM directly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数HTML渲染是通过HTML **文档对象模型**（**DOM**）完成的。DOM是一种称为*保留模式*的图形库。保留模式图形保留了一个称为**场景图**的树。这个场景图跟踪我们模型中的所有图形元素以及如何渲染它们。保留模式图形的好处是它们对开发人员来说很容易管理。图形库完成了所有繁重的工作，并为我们跟踪了对象以及它们的渲染位置。缺点是保留模式系统占用了更多的内存，并且为开发人员提供了更少的控制权。当我们编写HTML5游戏时，我们可以使用`<IMG>`
    HTML元素在DOM中渲染图像，并使用JavaScript或CSS动画移动这些元素，直接在DOM中操作这些图像的位置。
- en: However, this would, in most circumstances, make the game painfully slow. Every
    time we move an object in our DOM, it forces our browser to recalculate the position
    of all other objects within our DOM. Because of this, manipulating objects from
    within our DOM to make web games is usually a non-starter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数情况下，这会使游戏变得非常缓慢。每次我们在DOM中移动一个对象时，都会强制浏览器重新计算DOM中所有其他对象的位置。因此，通常情况下，通过在DOM中操作对象来制作网络游戏通常是行不通的。
- en: Immediate mode versus retained mode
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即时模式与保留模式
- en: Immediate mode is frequently thought of as the opposite of retained mode, but,
    in practice, when we write code for an immediate mode system, we may build on
    top of an API that gives us some of the functionality of a retained mode library.
    Immediate mode forces the developer to do all or most of the heavy lifting done
    by a retained mode library. We, as developers, are forced to manage our scene
    graph, and understand what graphical objects we need to render and how and when
    those objects must render. In short, it is a lot more work, but if done well,
    the payoff is a game that will render much faster than what is possible to render
    using the DOM.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 即时模式经常被认为是保留模式的相反，但实际上，当我们为即时模式系统编写代码时，我们可能会在保留模式库的API之上构建一些功能。 即时模式迫使开发人员完成保留模式库所做的所有或大部分繁重工作。
    我们作为开发人员被迫管理我们的场景图，并了解我们需要渲染的图形对象以及这些对象必须何时以何种方式渲染。 简而言之，这是更多的工作，但如果做得好，游戏将比使用DOM渲染更快地渲染。
- en: 'You might be asking yourself right now: *How do I go about using this Immediate
    Mode thingy*? Enter the HTML5 Canvas! In 2004, Apple Inc. developed the canvas
    element as an immediate mode display tag for Apple''s proprietary browser technology.
    The canvas partitions off a section of our web page, which allows us to render
    to that area using immediate mode rendering. That will enable us to render to
    a part of the DOM (the canvas) without requiring the browser to recalculate the
    position of all the elements from within the DOM. That allows the browser to optimize
    the rendering of the canvas further, using the computer''s **Graphical Processing
    Unit** (**GPU**).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己：*我该如何使用这个Immediate Mode*？进入HTML5画布！ 2004年，苹果公司开发了画布元素作为苹果专有浏览器技术的即时模式显示标签。
    画布将我们网页的一部分分隔出来，允许我们使用即时模式渲染到该区域。 这将使我们能够在不需要浏览器重新计算DOM中所有元素的位置的情况下，渲染到DOM的一部分（画布）。
    这允许浏览器进一步优化画布的渲染，使用计算机的**图形处理单元**（**GPU**）。
- en: Adding a canvas to the Emscripten template
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Emscripten模板添加画布
- en: In an earlier part of this chapter, we discussed making calls to the Emscripten
    WebAssembly app from a shell template. Now that you know how to make the interaction
    work between JavaScript and WebAssembly, we can add a `canvas` element back into
    the template and start to manipulate that `canvas` using the WebAssembly module.
    We are going to create a new `.c` file that will call a JavaScript function passing
    it an `x` and `y` coordinate. The JavaScript function will manipulate a spaceship
    image, moving it around the `canvas`. We will also create a brand new shell file
    called `canvas_shell.html`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的较早部分，我们讨论了从shell模板调用Emscripten WebAssembly应用程序。 现在您知道如何使JavaScript和WebAssembly之间的交互工作，我们可以将`canvas`元素添加回模板，并开始使用WebAssembly模块操纵该`canvas`。
    我们将创建一个新的`.c`文件，该文件将调用一个JavaScript函数，传递一个`x`和`y`坐标。 JavaScript函数将操纵太空船图像，将其移动到`canvas`周围。
    我们还将创建一个名为`canvas_shell.html`的全新shell文件。
- en: As we did for the previous version of our shell, we will start by breaking this
    file down into four sections to discuss it at a high level. We will then discuss
    the essential parts of this file a piece at a time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们为之前版本的shell所做的一样，我们将首先将此文件分成四个部分，以便从高层次讨论它。 然后我们将逐一讨论该文件的基本部分。
- en: 'The beginning of the HTML file starts with the opening `HTML` tag and the `head`
    element:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTML文件的开头以开头的`HTML`标签和`head`元素开始：
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After that, we have the opening `body` tag, and we have removed many of the
    HTML elements that we had in the earlier version of this file:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那之后，我们有了开头的`body`标签，并且删除了在此文件的早期版本中存在的许多HTML元素：
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, there is the opening `script` tag, a few global JavaScript variables,
    and a few new functions that we added:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是开头的`script`标签，一些全局JavaScript变量和一些我们添加的新函数：
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After the new JavaScript functions, we have the new definition of the `Module`
    object:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的JavaScript函数之后，我们有`Module`对象的新定义：
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The last few lines close out our tags and include the `{{{ SCRIPT }}}` Emscripten
    tag:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几行关闭了我们的标签，并包括了`{{{ SCRIPT }}}` Emscripten标签：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Those previous four blocks of code define our new `canvas_shell.html` file.
    If you would like to download the file, you can find it on GitHub at the following
    address: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly/blob/master/Chapter02/canvas.html](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly/blob/master/Chapter02/canvas.html).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些前面的四个代码块定义了我们的新`canvas_shell.html`文件。 如果您想下载该文件，可以在GitHub上找到它，地址为：[https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly/blob/master/Chapter02/canvas.html](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly/blob/master/Chapter02/canvas.html)。
- en: 'Now that we have looked at the code at a high level, we can look at the source
    in more detail. In the `head` section of the HTML, we are changing the `title`
    and the `name` of the CSS file that we are linking. Here is the change in the
    HTML `head`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从高层次查看了代码，我们可以更详细地查看源代码。 在HTML的`head`部分，我们正在更改我们链接的`title`和`CSS`文件的`name`。
    这是HTML`head`中的更改：
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We do not need most of the elements that were in the previous `<body>` tag.
    We need a `canvas`, which we had removed from the `shell_minimal.html` file provided
    by Emscripten, but now we need to add it back in. We are keeping the `textarea`
    that was initially in the minimal shell, and we are adding a new `img` tag that
    has a spaceship image taken from a TypeScript canvas tutorial on the [embed.com](https://www.embed.com)
    website at [https://www.embed.com/typescript-games/draw-image.html](https://www.embed.com/typescript-games/draw-image.html).
    Here are the new HTML tags in the `body` element:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要之前`<body>`标签中的大多数元素。 我们需要一个`canvas`，这是我们从Emscripten提供的`shell_minimal.html`文件中删除的，但现在我们需要将其添加回去。
    我们保留了最初在最小shell中的`textarea`，并添加了一个新的`img`标签，其中包含从[embed.com](https://www.embed.com)网站上的TypeScript画布教程中获取的太空船图像，网址为[https://www.embed.com/typescript-games/draw-image.html](https://www.embed.com/typescript-games/draw-image.html)。
    这是`body`元素中的新HTML标签：
- en: '[PRE44]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we need to change the JavaScript code. The first thing we are going
    to do is add three variables at the beginning to hold a reference to the `canvas`
    element, the canvas context, and the new spaceship `img` element:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更改JavaScript代码。我们要做的第一件事是在开头添加三个变量，用于保存对`canvas`元素、画布上下文和新的飞船`img`元素的引用：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The next thing we are adding to the JavaScript is a function that renders the
    spaceship image to the canvas at a given `x` and `y` coordinate:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要添加到JavaScript中的是一个函数，用于将飞船图像渲染到给定的*x*和*y*坐标的画布上：
- en: '[PRE46]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This function first checks to see whether the `img` variable is a value other
    than `null`. That will let us know if the module has been loaded or not because
    the `img` variable starts set to null. The next thing we do is clear the canvas
    with the color black using the `ctx.fillStyle = “black”` line to set the context
    fill style to the color `black`, before calling `ctx.fillRect` to draw a rectangle
    that fills the entire canvas with a black rectangle. The next four lines save
    off the canvas context, translate the context position to the ship's `x` and `y`
    coordinate value, and then draw the ship image to the canvas. The last one of
    these four lines performs a context restore to set our translation back to (0,0)
    where it started.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先检查`img`变量是否为`null`以外的值。这将让我们知道模块是否已加载，因为`img`变量最初设置为null。接下来我们要做的是使用`ctx.fillStyle
    = “black”`清除画布的黑色，将上下文填充样式设置为颜色`black`，然后调用`ctx.fillRect`绘制填充整个画布的黑色矩形。接下来的四行保存了画布上下文，将上下文位置转换为飞船的`x`和`y`坐标值，然后将飞船图像绘制到画布上。这四行中的最后一行执行上下文恢复，将我们的平移设置回到(0,0)的起始位置。
- en: 'After defining this function, the WebAssembly module can call it. We need to
    set up some initialization code to initialize those three variables when the module
    is loaded. Here is that code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了这个函数之后，WebAssembly模块可以调用它。当模块加载时，我们需要设置一些初始化代码来初始化这三个变量。以下是该代码：
- en: '[PRE47]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `ModuleLoaded` function uses `getElementById` to set `img` and `canvas`
    to the spaceship and `canvas` HTML elements, respectively. We will then call `canvas.getContext(”2d”)`
    to get the 2D canvas context and set the `ctx` variable to that context. All of
    this gets called when the `Module` object finishes loading because we added the
    `ModuleLoaded` function to the `postRun` array.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModuleLoaded`函数使用`getElementById`将`img`和`canvas`分别设置为飞船和画布的HTML元素。然后我们将调用`canvas.getContext(”2d”)`来获取2D画布上下文，并将`ctx`变量设置为该上下文。所有这些都在`Module`对象完成加载时调用，因为我们将`ModuleLoaded`函数添加到`postRun`数组中。'
- en: 'We have also added back the `canvas` function that was on the `Module` object
    in the minimum shell file, which we had removed along with the canvas in an earlier
    tutorial. That code watches the canvas context and alerts the user if that context
    is lost. Eventually, we will want this code to fix the problem, but, for now,
    it is good to know when it happens. Here is that code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在最小的shell文件中添加了`canvas`函数，该函数在之前的教程中已经删除了。该代码监视画布上下文，并在上下文丢失时向用户发出警报。最终，我们希望这段代码能够解决问题，但目前知道发生了什么是很好的。以下是该代码：
- en: '[PRE48]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To go along with this new HTML shell file, we have created a new `canvas.c`
    file to compile into a WebAssembly module. Be aware that, in the long run, we
    will be doing a lot less in our JavaScript and a lot more inside our WebAssembly
    C/C++ code. Here is the new `canvas.c` file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配合这个新的HTML shell文件，我们创建了一个新的`canvas.c`文件，用于编译成WebAssembly模块。请注意，从长远来看，我们将在JavaScript中做的事情要少得多，而在WebAssembly
    C/C++代码中要多得多。以下是新的`canvas.c`文件：
- en: '[PRE49]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To start, we create a `ship_x` and `ship_y` variable to track the ship's *x*
    and *y* coordinates. After that, we create a `MoveShip` function. This function
    increments the ship's *x* position by `2` and the ship's *y* position by `1` each
    time it is called. It also checks to see whether the ship's x coordinates have
    left the canvas on the right side, which moves it back to the left side if it
    has, and does something similar if the ship has moved off the canvas on the bottom.
    The last thing this function does is call our JavaScript `ShipPosition` function,
    passing it the ship's *x* and *y* coordinates. That final step is what will draw
    our spaceship to the new coordinates on the HTML5 canvas element.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`ship_x`和`ship_y`变量来跟踪飞船的*x*和*y*坐标。之后，我们创建一个`MoveShip`函数。每次调用该函数时，该函数将飞船的*x*位置增加`2`，飞船的*y*位置增加`1`。它还检查飞船的x坐标是否离开了画布的右侧，如果是，则将其移回左侧，如果飞船已经移出画布底部，则执行类似的操作。该函数的最后一步是调用我们的JavaScript`ShipPosition`函数，传递飞船的*x*和*y*坐标。这最后一步将在HTML5画布元素上以新坐标绘制我们的飞船。
- en: 'In the new version of our `main` function, we have the following line:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`main`函数的新版本中，有以下一行：
- en: '[PRE50]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This line turns the function passed in as the first parameter into a game loop.
    We will go into more detail about how `emscripten_set_main_loop` works in a later
    chapter, but for the moment, know that this causes the `MoveShip` function to
    be called every time a new frame is rendered to our canvas.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这行将作为第一个参数传递的函数转换为游戏循环。我们将在后面的章节中详细介绍`emscripten_set_main_loop`的工作原理，但目前只需知道这会导致每次渲染新帧时调用`MoveShip`函数。
- en: 'Finally, we will create a new `canvas.css` file that keeps the code for the
    `body` and `#output` CSS and adds a new `#canvas` CSS class. Here are the contents
    of the `canvas.css` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个新的`canvas.css`文件，其中包含`body`和`#output` CSS的代码，并添加一个新的`#canvas` CSS类。以下是`canvas.css`文件的内容：
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After everything is complete, we will use `emcc` to compile the new `canvas.html`
    file as well as `canvas.wasm` and the `canvas.js` glue code. Here is what the
    call to `emcc` will look like:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一切完成后，我们将使用`emcc`编译新的`canvas.html`文件，以及`canvas.wasm`和`canvas.js`的粘合代码。以下是对`emcc`的调用示例：
- en: '[PRE52]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Immediately after `emcc`, we pass in the name of the `.c` file, `canvas.c`,
    which will be used to compile our WASM module. The `-o` flag tells our compiler
    that the next argument will be the output. Using an output file with a `.html`
    extension tells `emcc` to compile the WASM, JavaScript, and HTML files. The next
    flag passed in is `--shell-file`, which tells `emcc` that the argument to follow
    is the name of the HTML shell file, which will be used to create the HTML file
    of our final output.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`emcc`之后，我们传入`.c`文件的名称`canvas.c`，这将用于编译我们的WASM模块。`-o`标志告诉我们的编译器下一个参数将是输出。使用扩展名为`.html`的输出文件告诉`emcc`编译WASM、JavaScript和HTML文件。接下来传入的标志是`--shell-file`，告诉`emcc`后面的参数是HTML外壳文件的名称，这将用于创建我们最终输出的HTML文件。
- en: It is important to remember that you must run WebAssembly apps using a web server,
    or with `emrun`. If you would like to run your WebAssembly app using `emrun`,
    you must compile it with the `--emrun` flag. The web browser requires a web server
    to stream the WebAssembly module. If you attempt to open an HTML page that uses
    WebAssembly in a browser directly from your hard drive, that WebAssembly module
    will not load.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，您必须使用Web服务器或`emrun`来运行WebAssembly应用程序。如果您想使用`emrun`运行WebAssembly应用程序，您必须使用`--emrun`标志进行编译。Web浏览器需要一个Web服务器来流式传输WebAssembly模块。如果您尝试直接从硬盘驱动器在浏览器中打开使用WebAssembly的HTML页面，那么WebAssembly模块将无法加载。
- en: 'The following is a screenshot of `canvas.html`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`canvas.html`的屏幕截图：
- en: '![](img/d8f3036f-4633-49d4-85ac-8e6324bebfa5.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8f3036f-4633-49d4-85ac-8e6324bebfa5.png)'
- en: 'Figure 2.3: Our first WebAssembly HTML5 canvas app'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：我们的第一个WebAssembly HTML5画布应用程序
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the Emscripten minimal shell HTML file, what its
    various components are, and how they work. We also wrote about what parts of the
    file we can do without, if we are not using our shell to generate canvas code.
    You learned about the `Module` object, and how it is the interface that uses the
    JavaScript glue code to tie the JavaScript in our HTML and our WebAssembly together.
    We then created a new WebAssembly module that contained functions we exported
    to allow JavaScript to use `Module.cwrap` to create JavaScript functions we could
    then call from our DOM that executes our WebAssembly functions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Emscripten最小外壳HTML文件，它的各个组件以及它们的工作原理。我们还写了关于文件的哪些部分可以不用，如果我们不使用我们的外壳来生成画布代码。您了解了`Module`对象，以及它是使用JavaScript粘合代码将我们的HTML中的JavaScript和我们的WebAssembly联系在一起的接口。然后，我们创建了一个包含我们导出的函数的新的WebAssembly模块，以允许JavaScript使用`Module.cwrap`来创建我们可以从DOM中调用的JavaScript函数，从而执行我们的WebAssembly函数。
- en: We created a brand new HTML shell file that used some of the `Module` code from
    the Emscripten minimal shell, but rewrote the HTML and CSS of the original shell
    almost entirely. We were then able to compile that new C code and HTML shell file
    into a working WebAssembly app that was able to call WebAssembly functions from
    JavaScript, as well as call JavaScript functions from WebAssembly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个全新的HTML外壳文件，使用了Emscripten最小外壳的一些`Module`代码，但几乎完全重写了原始外壳的HTML和CSS。然后，我们能够将新的C代码和HTML外壳文件编译成一个能够从JavaScript调用WebAssembly函数，并且能够从WebAssembly调用JavaScript函数的工作WebAssembly应用程序。
- en: We discussed the benefits of using the HTML5 canvas element, and the differences
    between immediate and retained mode graphics. We also explained why it makes sense
    for games and other graphics-intensive tasks to use immediate mode instead of
    retained mode.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了使用HTML5画布元素的好处，以及即时模式和保留模式图形之间的区别。我们还解释了为什么对于游戏和其他图形密集型任务来说，使用即时模式而不是保留模式是有意义的。
- en: We then created a shell file to make use of the HTML5 canvas element. We added
    JavaScript code to draw an image to the canvas and wrote C code that used WebAssembly
    to modify the position of that image on the canvas every frame creating the appearance
    of a moving spaceship on the HTML5 canvas.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个外壳文件来利用HTML5画布元素。我们添加了JavaScript代码来将图像绘制到画布上，并编写了使用WebAssembly在每帧修改画布上图像位置的C代码，从而在HTML5画布上创建出移动的太空飞船的外观。
- en: In the next chapter, we will introduce you to WebGL, what it is, and how it
    improves graphics rendering on the web.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向您介绍WebGL，它是什么，以及它如何改进Web上的图形渲染。
