- en: Creating User Interfaces in VR
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在VR中创建用户界面
- en: In the previous chapter, we learned how to create virtual hands driven by the
    motion controllers. This enabled our users not only to look around the world and
    move through it, but also to begin to interact with it. In this chapter, we're
    going to take this further, and learn how to create **user interfaces** (**UIs**)
    that communicate information and accept input.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们学习了如何通过动作控制器创建虚拟手。这使得我们的用户不仅可以环顾四周并在其中移动，还可以开始与之互动。在本章中，我们将进一步学习如何创建传达信息并接受输入的用户界面（UI）。
- en: You should seriously consider whether your application really requires a graphical
    UI. Just because most applications need a GUI doesn't necessarily mean that's
    the case for all of them. Artificial-seeming UI elements can break immersion.
    When building UI elements, try to figure out how to fit them meaningfully into
    the world so that they look as though they belong there. Don't fall too much in
    love with buttons either. They're commonly used in 2D UI designs because they
    work well with a mouse, but VR hand controllers offer a much, much wider range
    of potential actions. Think beyond the button.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该认真考虑您的应用程序是否真的需要图形用户界面。并不是所有应用程序都需要图形用户界面，虚拟界面元素可能会破坏沉浸感。在构建用户界面元素时，尝试找出如何将它们有意义地融入到世界中，使其看起来像是属于那里的一部分。也不要过于迷恋按钮。它们在2D用户界面设计中常用，因为它们与鼠标配合使用效果很好，但是VR手柄提供了更广泛的潜在操作方式。要超越按钮的限制。
- en: Most applications we develop for VR will require a **Graphical User Interface**
    (**GUI**) of some sort, but UIs in VR pose new challenges that we didn't have
    to face on the flat screen. Most of the time, when we're building a flat-screen
    UI, we can simply overlay 2D UI elements on top of our 3D environment using a
    **head-up display** (**HUD**) and then read mouse, gamepad, or keyboard input
    to allow the user to interact with it. This doesn't work in VR.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为VR开发的大多数应用程序都需要某种形式的图形用户界面（GUI），但是VR中的用户界面提出了我们在平面屏幕上没有遇到的新挑战。大多数情况下，当我们构建平面屏幕用户界面时，我们可以简单地将2D用户界面元素叠加在我们的3D环境之上，使用HUD读取鼠标、游戏手柄或键盘输入来允许用户与之交互。但是在VR中这种方法行不通。
- en: If we simply draw a 2D interface over each eye's view, its position is going
    to appear the same for each eye. The problem with this is that our stereo vision scopic
    interprets an object that looks the same to both eyes as being infinitely far
    away. This means that, when 3D objects in the world appear behind the UI on the
    screen, those objects are going to appear to be closer than the UI, even though
    the UI is drawn over them. This will look terrible and will almost certainly make
    your user uncomfortable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们简单地在每只眼睛的视图上绘制一个2D界面，它的位置对于每只眼睛来说都是相同的。这样做的问题是，我们的立体视觉会将两只眼睛看到的相同物体解释为无限远。这意味着，当世界中的3D物体出现在屏幕上的UI后面时，这些物体将看起来比UI更近，即使UI是绘制在它们上面。这看起来很糟糕，几乎肯定会让用户感到不舒服。
- en: The solution to this is to incorporate UI elements into the 3D world, but it
    isn't enough to simply create an HUD panel in front of the player's face and project
    onto this, either (we'll talk more about why that is when we get to the player's
    UI later in this chapter). There's no way around the reality that you have to
    re-think UIs in VR. Think of what you're doing as re-creating objects you interact
    with in the real worlds rather than as re-creating 2D metaphors from the flat-screen
    world.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将用户界面元素融入到3D世界中，但仅仅在玩家面前创建一个HUD面板并投射到上面是不够的（我们将在本章后面讨论为什么）。无论如何，你都必须重新思考VR中的用户界面。将你所做的视为重新创建与之交互的真实世界对象，而不是重新创建平面屏幕世界的2D隐喻。
- en: We need to re-think how we interact with UI in the 3D world as well. We don't
    have access to a mouse cursor in VR (which wouldn't work for us anyway, because
    it's a 2D input device), and keyboard commands aren't a great idea, since your
    user can't see the keyboard. We're going to need new ways to communicate input
    into the system. Fortunately, Unreal gives us a solid set of tools to handle 3D
    UIs in ways that will work well in VR.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要重新思考在3D世界中如何与用户界面进行交互。在VR中，我们无法使用鼠标光标（对我们来说也不适用，因为它是一个2D输入设备），键盘命令也不是一个好主意，因为用户看不到键盘。我们需要新的方式来将输入传达到系统中。幸运的是，虚幻提供了一套强大的工具，可以很好地处理VR中的3D用户界面。
- en: In this chapter, we're going to run through the process of creating the various
    elements we'll need to create a functional UI in VR by creating a simple AI-controlled
    companion character with an indicator displaying its current AI state, and a control
    interface on the player character that allows us to change that state.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过创建一个简单的AI控制的伴侣角色，并在其上显示当前AI状态的指示器，以及在玩家角色上创建一个控制界面，来介绍在VR中创建功能性UI所需的各种元素的过程。
- en: 'Specifically, we''re going to cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主题：
- en: Creating an AI-controlled character and giving it a simple behavior
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个AI控制的角色并赋予其简单的行为
- en: Creating interfaces in 3D space using **Unreal Motion Graphics** (**UMG**) UI
    designer to display information
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚幻运动图形（UMG）UI设计师在3D空间中创建界面以显示信息
- en: Attaching UI elements to objects in the world
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户界面元素附加到世界中的对象上
- en: Using widget interaction components to interact with these interfaces and affect
    objects in the world
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用小部件交互组件与这些界面进行交互并影响世界中的对象
- en: Displaying the widget interaction component to the user
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户显示小部件交互组件
- en: Let's get to it!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Getting started
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: For this project, we're going to begin by simply taking the previous chapter's
    project and making a new copy. In previous chapters, we've explored a few ways
    of creating new projects using material from other projects. Simply duplicating
    and renaming a project can often be the simplest way to do this, and is appropriate
    if you're taking the work you've done in a previous project and expanding on it,
    as we are here. (It's also perfectly reasonable for this chapter's work to keep
    working from the previous project, if you'd like to.)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将从上一章的项目开始，创建一个新的副本。在之前的章节中，我们已经探索了一些使用其他项目材料创建新项目的方法。简单地复制和重命名一个项目通常是最简单的方法，如果你正在对之前的项目所做的工作进行扩展，那么这种方法是合适的（如果你愿意，也可以继续使用本章的工作从之前的项目中继续工作）。
- en: Creating a new Unreal project from an existing project
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从现有项目创建一个新的虚幻项目
- en: 'When creating a new project by copying, there really isn''t a lot that needs
    to be done. It''s enough to simply do the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过复制创建一个新项目时，实际上并不需要做很多事情。只需要简单地执行以下操作即可：
- en: Copy the old project directory.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制旧项目目录。
- en: Rename the new directory and the `.uproject` file.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名新目录和`.uproject`文件。
- en: Delete the generated files from the old project.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除旧项目中生成的文件。
- en: 'Let''s run through this process using our project from [Chapter 5](f9975ede-59dd-4728-b0d4-db3c41a1970a.xhtml),
    *Interacting with the Virtual World – Part I*, as a starting point for our work
    in this chapter:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们在[第5章](f9975ede-59dd-4728-b0d4-db3c41a1970a.xhtml)中的项目作为本章工作的起点：
- en: With Unreal Editor closed, find the location of the previous chapter's Unreal
    project.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭虚幻编辑器，找到之前章节的虚幻项目的位置。
- en: Make a copy of the project directory and give it a new name.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制项目目录并给它一个新的名称。
- en: Inside the new directory, rename the `.uproject` file. You're not required to
    match the name of the project file to the name of the directory that contains
    it, but it's good practice to do so.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新目录中，重命名`.uproject`文件。你不需要将项目文件的名称与包含它的目录名称匹配，但这是一个好的做法。
- en: Delete the `Intermediate` and `Saved` directories from your new project directory.
    These will be regenerated when you open the new project, and stray data left over
    from old projects can cause problems. It's always better to start clean with these.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新项目目录中删除`Intermediate`和`Saved`目录。当你打开新项目时，它们将被重新生成，而旧项目中残留的杂乱数据可能会引起问题。最好始终从干净的状态开始。
- en: Open up the new `.uproject` file. You'll see that the `Intermediate` and `Saved`
    directories you just deleted are regenerated for the new project. The project
    should open to the default map (`LV_Soul_Slum_Mobile`) we set in the last chapter.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的`.uproject`文件。你会看到刚刚删除的`Intermediate`和`Saved`目录已经为新项目重新生成。项目应该会打开到上一章中设置的默认地图（`LV_Soul_Slum_Mobile`）。
- en: Hit the toolbar's Build button to rebuild its lighting.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击工具栏的构建按钮以重新构建其光照。
- en: Test the project by launching a VR preview. Everything should work as it did
    in the previous project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启动VR预览来测试项目。一切应该与之前的项目一样正常工作。
- en: As we mentioned before, it's also fine simply to continue working from the previous
    chapter's project. Either way, we're now ready to add the AI character we're going
    to control.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，从上一章的项目继续工作也是可以的。无论哪种方式，我们现在准备添加我们要控制的AI角色。
- en: We’re not alone – adding an AI character
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们并不孤单-添加一个AI角色
- en: Creating an AI-controlled character from scratch would take us into areas that
    fall outside the scope of this book, so, instead, we're going to repurpose the
    standard player character from the third-person template and change the way it's
    controlled.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始创建一个AI控制的角色将使我们进入超出本书范围的领域，因此我们将重新使用第三人称模板中的标准玩家角色并改变其控制方式。
- en: 'If you already have a project created using the third-person template available,
    open it up. If not, create one:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一个使用第三人称模板创建的项目，请打开它。如果没有，请创建一个：
- en: Select File | New Project, and create a new Blueprint project using the third-person
    template. It's fine to leave other settings at their default values – they won't
    affect anything we're doing.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择“文件 | 新建项目”，使用第三人称模板创建一个新的蓝图项目。可以将其他设置保留为默认值-它们不会影响我们正在做的任何事情。
- en: Migrating the third-person character blueprint
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移第三人称角色蓝图
- en: 'Whether we''ve taken an existing third-person template project or created a
    new one, what we want to do now is migrate the `ThirdPersonCharacter` blueprint:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是使用现有的第三人称模板项目还是创建一个新项目，我们现在要做的是迁移`ThirdPersonCharacter`蓝图：
- en: In the third-person project's content browser, navigate to `Content/ThirdPersonBP/Blueprints` and
    select the `ThirdPersonCharacter` blueprint.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三人称项目的内容浏览器中，导航到`Content/ThirdPersonBP/Blueprints`，并选择`ThirdPersonCharacter`蓝图。
- en: Right-click and select Asset Actions | Migrate. Migrate the character into the
    `Content` directory for this chapter's project.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并选择“资产操作 | 迁移”。将角色迁移到本章项目的“Content”目录中。
- en: Now, we can close this and return to our working project. A new `ThirdPersonBP`
    directory should have been added by our content migration.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以关闭这个并返回到我们的工作项目。我们的内容迁移应该已经添加了一个新的`ThirdPersonBP`目录。
- en: Navigate to `Content/ThirdPersonBP/Blueprints`, and find the `ThirdPersonCharacter`
    blueprint. Open it up.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`Content/ThirdPersonBP/Blueprints`，找到`ThirdPersonCharacter`蓝图。打开它。
- en: Cleaning up the third-person character blueprint
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理第三人称角色蓝图
- en: 'There are a few things we don''t need here that we can safely clear out:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们不需要的东西，我们可以安全地清除：
- en: First, select everything in Event Graph and delete it. We don't need any of
    these input handlers.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在事件图中选择所有内容并删除。我们不需要任何这些输入处理程序。
- en: 'We also don''t need the FollowCamera and CameraBoom items in the Components
    list, so delete those:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还不需要组件列表中的FollowCamera和CameraBoom项目，所以删除它们：
- en: '![](img/26ac5371-fd6a-4677-8fe5-d71edc52666b.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26ac5371-fd6a-4677-8fe5-d71edc52666b.png)'
- en: Now, we have a clean character that's going to work out well for what we need
    it to do.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个干净的角色，它将很好地完成我们需要它做的工作。
- en: Examining the animation blueprint
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查动画蓝图
- en: Even though we took a shortcut and migrated our character, it's still not a
    bad idea to take a look at how it works.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们采取了捷径并迁移了我们的角色，但看一下它是如何工作的仍然不是一个坏主意。
- en: 'Select the character''s `Mesh` component and look at the Animation section
    of the Details panel. You''ll see that this character is animated using an animation
    blueprint called `ThirdPerson_AnimBP`. Use the magnifying glass beside the Anim
    Class property to navigate to the animation blueprint and then open it up so we
    can see what''s inside:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 选择角色的`Mesh`组件，并查看详细面板的动画部分。您会看到这个角色使用一个名为`ThirdPerson_AnimBP`的动画蓝图进行动画化。使用Anim
    Class属性旁边的放大镜导航到动画蓝图，然后打开它以查看内部内容：
- en: '![](img/67893e0a-85fe-48dd-8de3-3547e971d6e5.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67893e0a-85fe-48dd-8de3-3547e971d6e5.png)'
- en: It would take us outside the scope of this book to discuss animation blueprints
    in depth, but, in general what you should understand about them is that, just
    as we saw with the controlled hands, they're responsible for determining how a
    skeletal mesh animates in response to whatever factors govern its animation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论动画蓝图的深入内容超出了本书的范围，但是总的来说，您应该了解它们与受控手部一样，负责确定骨骼网格如何根据其动画的各种因素进行动画化。
- en: You saw a simple example of an animation blueprint driving the hand pose. This
    one's doing a similar job, but driving a character skeleton. It's not a bad idea
    to take some time to burrow through this blueprint to see how it works. You can
    find further documentation at [https://docs.unrealengine.com/en-us/Engine/Animation/AnimBlueprints](https://docs.unrealengine.com/en-us/Engine/Animation/AnimBlueprints).
    When you're done looking around, feel free to close the animation blueprint. We
    won't need to change anything here.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到了一个简单的示例，其中动画蓝图驱动手部姿势。这个示例执行了类似的工作，但驱动了一个角色骨架。花点时间浏览一下这个蓝图，看看它是如何工作的，这不是一个坏主意。您可以在[https://docs.unrealengine.com/en-us/Engine/Animation/AnimBlueprints](https://docs.unrealengine.com/en-us/Engine/Animation/AnimBlueprints)找到更多文档。当您完成浏览后，可以随意关闭动画蓝图。我们不需要在这里做任何更改。
- en: Creating a companion character subclass
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个伙伴角色子类
- en: 'Since we''re going to be adding new behaviors and components to this character,
    it''s going to be a good idea for us to create a new character blueprint and derive
    it from this one:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将向该角色添加新的行为和组件，所以为我们创建一个新的角色蓝图并从这个蓝图派生出来是个好主意。
- en: 'Right-click the `ThirdPersonCharacter` blueprint and select Create Child Blueprint
    Class from the context menu:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`ThirdPersonCharacter`蓝图并从上下文菜单中选择创建子蓝图类：
- en: '![](img/8310bb3d-981c-4cff-8f0c-bfb772449939.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8310bb3d-981c-4cff-8f0c-bfb772449939.png)'
- en: Let's name the new class `BP_CompanionCharacter` and move it to our project's
    subdirectory inside the `Content` folder.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将新类命名为`BP_CompanionCharacter`并将其移动到`Content`文件夹内的项目子目录中。
- en: 'Now, we can drag an instance of `BP_CompanionCharacter` into the level:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将`BP_CompanionCharacter`的一个实例拖入关卡中：
- en: '![](img/f282d4aa-a474-4282-8cda-61891cd94e7e.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f282d4aa-a474-4282-8cda-61891cd94e7e.png)'
- en: Place your companion character somewhere that's covered by the navigation mesh.
    Previously, we used a navigation mesh to allow us to indicate which areas of the
    map were valid teleport destinations. Now, in addition to this, we're going to
    use it for its intended purpose. Navigation meshes provide a simplified model
    of the walkable space of a map that can be used by AI-controlled characters to
    find their way around. Remember that you can use the *P* key to show and hide
    your navmesh if you need to check its coverage.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的伙伴角色放置在导航网格覆盖的位置。之前，我们使用导航网格来允许我们指示地图上哪些区域是有效的传送目的地。现在，除此之外，我们还将使用它来实现其预期的目的。导航网格提供了地图可行走空间的简化模型，可以供AI控制的角色在其中找到路径。请记住，您可以使用*P*键显示和隐藏导航网格，以检查其覆盖范围。
- en: Adding a follow behavior to our companion character
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的伙伴角色添加跟随行为
- en: 'Let''s give our character a simple behavior. We''ll have him follow the player:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给角色一个简单的行为。我们让他跟随玩家：
- en: Open the `BP_CompanionCharacter` event graph and find or create an Event Tick
    node.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_CompanionCharacter`事件图，并找到或创建一个Event Tick节点。
- en: Right-click in the graph and create a Simple Move to Actor node.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中右键单击并创建一个Simple Move to Actor节点。
- en: Create a Get Controller node and feed its output into the Simple Move to Actor
    node's Controller input.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Get Controller节点，并将其输出连接到Simple Move to Actor节点的Controller输入。
- en: 'Create a Get Player Pawn node and feed its output into the Simple Move to Actor
    node''s Goal input:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Get Player Pawn节点，并将其输出连接到Simple Move to Actor节点的Goal输入：
- en: '![](img/d10b4777-1653-4a5d-a080-e48631baef1c.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d10b4777-1653-4a5d-a080-e48631baef1c.png)'
- en: Launch your map. Our companion character should run to your location (if he
    doesn't, verify that he's starting on the navmesh and that the navmesh section
    where he's standing can access your PlayerStart location).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 启动您的地图。我们的伙伴角色应该跑到您的位置（如果他没有，请验证他是否在导航网格上启动，并且他站立的导航网格部分可以访问您的PlayerStart位置）。
- en: Examining the AI controller
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查AI控制器
- en: 'Let''s take a moment to talk about what''s going on here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一点时间来讨论这里发生的事情：
- en: Shut down the gameplay session, select the Simple Move to Actor node, and hit
    *F9* to set a **breakpoint** there.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭游戏会话，选择Simple Move to Actor节点，并按下*F9*键在那里设置一个**断点**。
- en: A breakpoint is a debugging tool that instructs the Blueprint interpreter to
    pause execution when it hits the point you've set. While you're in the paused
    state, you can roll over variable and function outputs to see what they contain,
    and you can step through the code to see how it executes. We'll cover using breakpoints
    and debugging tools in depth in a later chapter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 断点是一种调试工具，它指示蓝图解释器在达到您设置的点时暂停执行。在暂停状态下，您可以将鼠标悬停在变量和函数输出上，以查看它们包含的内容，并可以逐步执行代码以查看其执行方式。我们将在后面的章节中详细介绍使用断点和调试工具。
- en: 'Run the map again, but don''t bother putting the VR headset on – we just want
    to see what happens when the breakpoint is hit:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行地图，但不需要戴上VR头盔-我们只想看看断点被触发时会发生什么：
- en: '![](img/0df23c33-35f0-45b5-b8e7-146128ad30b5.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0df23c33-35f0-45b5-b8e7-146128ad30b5.png)'
- en: When execution stops at the breakpoint, roll over the output from the Get Controller
    node. You'll see that this character is currently controlled by an AI Controller
    that was automatically created for it.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行停在断点处时，将鼠标悬停在“获取控制器”节点的输出上。你会看到这个角色当前由一个自动为其创建的AI控制器控制。
- en: Any pawn or character in your level must be **possessed** by a controller before
    it can execute commands. The pawn or character you control as a player is possessed
    by a player controller. Characters that are expected to behave autonomously need
    to be possessed by an AI controller.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行命令之前，你的关卡中的任何角色或者角色必须被一个控制器**控制**。作为玩家控制的角色或者角色是由一个玩家控制器控制的。预期自主行为的角色需要被一个AI控制器控制。
- en: Select the Simple Move to Actor node again if it's been deselected, and hit
    F9 to clear the breakpoint.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Simple Move to Actor节点已经取消选择，请再次选择它，并按下F9清除断点。
- en: Click on Resume on the toolbar to return to normal execution.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击工具栏上的“恢复”按钮返回正常执行。
- en: The character should run to your location.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 角色应该跑到你的位置。
- en: Setting breakpoints in your blueprints is a valuable way of debugging them and
    seeing how they operate. If you're working with a blueprint written by another
    developer, setting a breakpoint and stepping through the execution can be a valuable
    way of figuring out how it works. You can set and clear breakpoints by hitting
    *F9,* and step through execution by using *F10*. *F11* and *Alt* + *Shift* + *F11*
    allow you to step into and out of child methods in a blueprint. You can view the
    values currently set in your blueprint by mousing over input and output connectors.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图中设置断点是调试它们和查看它们如何运行的有价值的方式。如果你正在使用另一个开发者编写的蓝图，设置一个断点并逐步执行可以帮助你弄清楚它的工作原理。你可以通过按下*F9*来设置和清除断点，并通过使用*F10*来逐步执行。*F11*和*Alt*
    + *Shift* + *F11*允许你在蓝图中进入和退出子方法。你可以通过将鼠标悬停在输入和输出连接器上来查看当前设置在蓝图中的值。
- en: 'If we take a look at the `BP_CompanionCharacter` class'' **Details** | **Pawn**,
    we can see that Auto Possess AI is set to Placed in World, meaning that the specified
    AI controller will automatically take control of this pawn if it''s placed in
    the world. Other options here allow us to specify that the AI controller should
    possess the pawn when it''s spawned, or should not auto-possess at all. The AI
    Controller Class specifies which AI Controller class will possess this pawn. If
    we needed to, we could select a new AI controller class here. In our case, we
    don''t need to do this because the default controller can do everything we need
    it to do:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`BP_CompanionCharacter`类的**Details** | **Pawn**，我们可以看到Auto Possess AI被设置为Placed
    in World，这意味着如果这个角色被放置在世界中，指定的AI控制器将自动控制这个角色。这里的其他选项允许我们指定AI控制器在角色生成时应该控制角色，或者根本不自动控制。AI
    Controller Class指定了哪个AI控制器类将控制这个角色。如果需要的话，我们可以在这里选择一个新的AI控制器类。在我们的情况下，我们不需要这样做，因为默认的控制器可以做我们需要它做的一切：
- en: '![](img/71c8a8c7-94b3-4bc2-a6c9-753f70df0505.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71c8a8c7-94b3-4bc2-a6c9-753f70df0505.png)'
- en: As with the depths of animation blueprints, a deep discussion of AI controllers
    and decision trees falls outside the scope of this book, but if you wanted to
    take it further, it's worthwhile exploring the documentation at [https://docs.unrealengine.com/en-us/Gameplay/AI](https://docs.unrealengine.com/en-us/Gameplay/AI).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与动画蓝图的深度讨论一样，AI控制器和决策树的深入讨论超出了本书的范围，但如果你想进一步了解，可以在[https://docs.unrealengine.com/en-us/Gameplay/AI](https://docs.unrealengine.com/en-us/Gameplay/AI)上查阅文档是值得的。
- en: It's worthwhile spending some time poking around with these elements. If you're
    developing applications that involve visible non-player characters, time spent
    learning about the animation blueprint and the AI controller is absolutely well
    spent.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 花一些时间来研究这些元素是值得的。如果你正在开发涉及可见非玩家角色的应用程序，学习动画蓝图和AI控制器的时间绝对是值得的。
- en: Improving the companion's follow behavior
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进伙伴的跟随行为
- en: Now that we've gotten our character following us, let's improve its behavior.
    It tends to crowd us a bit, and it would improve things if our companion only
    tried to follow us when we got a specified distance away from him.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们让角色跟随我们，让我们改进它的行为。它倾向于有点拥挤，如果我们的伙伴只在我们离他一定距离时尝试跟随我们，情况会有所改善。
- en: 'First, for the sake of organization, we should bundle our movement behavior
    into a function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了组织起来，我们应该将我们的移动行为捆绑到一个函数中：
- en: Select the Simple Move to Actor node and the Get Controller and Get Player Pawn
    nodes feeding it.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Simple Move to Actor节点和Get Controller和Get Player Pawn节点，并将它们连接到它。
- en: Right-click and collapse them to a function named `FollowPlayer`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并将它们折叠到名为“FollowPlayer”的函数中。
- en: 'Now, let''s improve the way it works:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们改进它的工作方式：
- en: Open up the new function.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新的函数。
- en: Drag an output from `GetPlayerPawn` and select Promote to local variable. Name
    the new variable `LocalPlayerPawn`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GetPlayerPawn拖动一个输出，并选择Promote to local variable。将新变量命名为LocalPlayerPawn。
- en: Use local variables in functions whenever you access a piece of information
    that would cost time to collect again. Since we know we're going to need to use
    the player pawn a few times in this function, it's faster to get it once and save
    the value rather than to re-fetch it every time we need it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中使用局部变量，每当你访问一个需要花费时间重新收集的信息时。由于我们知道在这个函数中我们将需要多次使用玩家角色，所以获取它一次并保存值比每次需要时重新获取它要快。
- en: Connect the setter that was automatically created for you to the function input.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自动为您创建的setter连接到函数输入。
- en: Create a Get Squared Distance To node from the Local Player Pawn node's output.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Local Player Pawn节点的输出创建一个Get Squared Distance To节点。
- en: 'Right-click, select Get a reference to self, and feed Self into the Get Squared
    Distance To node''s Other Actor input:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击，选择Get a reference to self，并将Self输入到Get Squared Distance To节点的Other Actor输入中：
- en: '![](img/db569b7e-4ce8-43d9-92bf-93b148ea384e.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db569b7e-4ce8-43d9-92bf-93b148ea384e.png)'
- en: Create a float variable named `FollowDistance`, compile, and set its value to
    `320.0`. (Feel free to tune this value later on once the behavior is running.)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FollowDistance`的浮点变量，编译并将其值设置为`320.0`。（一旦行为运行起来，可以随时调整该值。）
- en: 'Square the `FollowDistance` (remember that the Square node will appear in the
    graph as ^2), and test to see whether the result of Get Squared Distance To is
    greater than the square of the follow distance. Create a Branch node from the
    result:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`FollowDistance`进行平方（记住平方节点将在图表中显示为^2），并测试Get Squared Distance To的结果是否大于跟随距离的平方。从结果创建一个分支节点：
- en: '![](img/4414527d-b81c-4e45-a86e-6ff173b1bd2f.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4414527d-b81c-4e45-a86e-6ff173b1bd2f.png)'
- en: Recall that we mentioned previously that square roots are expensive to calculate,
    so when you're just comparing distances but don't care what those actual distances
    are, use squared distances instead.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们之前提到过计算平方根是昂贵的，所以当你只是比较距离但不关心实际距离时，使用平方距离代替。
- en: This Branch node will return True when we move beyond the follow distance from
    the companion character, and False while we're within that distance.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们距离伴侣角色超过跟随距离时，该分支节点将返回True，而在该距离内时返回False。
- en: Connect the Branch node's True output to your Simple Move To Actor node.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将分支节点的True输出连接到Simple Move To Actor节点。
- en: Connect the False output to a `Return Node` since we don't need to do anything
    if we're within the follow distance.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将False输出连接到`Return Node`，因为如果我们在跟随距离内，我们不需要做任何事情。
- en: Grab an instance of `LocalPlayerPawn` and plug it into the Simple Move to Actor
    node's Goal input.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一个`LocalPlayerPawn`的实例，并将其插入Simple Move to Actor节点的Goal输入。
- en: '`Get Controller` should still be connected to your Simple Move to Actor node''s
    Controller input.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get Controller`仍然连接到你的Simple Move to Actor节点的Controller输入。'
- en: 'Add a `Return Node` to the Simple Move to Actor node''s exit:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Simple Move to Actor节点的退出处添加一个`Return Node`：
- en: '![](img/6b76d0b9-d613-4edb-bd7f-464d6f8e9099.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b76d0b9-d613-4edb-bd7f-464d6f8e9099.png)'
- en: 'Try it out. The companion pawn should now wait until you get more than 320
    units away from him before trying to follow you again:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 试一下。伴侣角色现在应该在你离开他超过320个单位之前等待再次跟随你：
- en: '![](img/98c3c24e-3060-48b8-b711-0c9ca019717d.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98c3c24e-3060-48b8-b711-0c9ca019717d.png)'
- en: Not bad. This is a very simple behavior, but it's a good start.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错。这是一个非常简单的行为，但是这是一个好的开始。
- en: For AI behaviors of any meaningful complexity or behaviors that need to be executed
    by many characters simultaneously, it's a good idea to implement them using **behavior
    trees** instead of Blueprint tick operations. Behavior trees allow us to construct
    very complex behaviors in a clean, readable way, and run much more efficiently
    than simple Blueprint operations on the tick event. We built our character's behavior
    in Blueprint here to avoid going too far onto a tangent, but a behavior tree would
    really be a better structure to use here.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何有意义的复杂AI行为或需要由许多角色同时执行的行为，最好使用**行为树**来实现，而不是使用蓝图的tick操作。行为树允许我们以清晰、可读的方式构建非常复杂的行为，并且比tick事件上的简单蓝图操作运行得更高效。我们在这里使用蓝图构建了角色的行为，以避免走得太远，但是行为树实际上是一个更好的结构来使用的。
- en: Now that we have our companion character executing behaviors, it's time for
    us to move on to the real meat of this chapter, which is adding UI elements to
    the world.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的伴侣角色正在执行行为，是时候进入本章的真正内容了，即向世界添加UI元素。
- en: Adding a UI indicator to the companion pawn
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向伴侣角色添加一个UI指示器
- en: Now that our character is moving through the world, we're going to give it another
    behavior state and allow the player to instruct it to wait.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的角色正在世界中移动，我们将给它添加另一个行为状态，并允许玩家指示它等待。
- en: Before we create this new state, however, we're first going to create a simple
    UI element to indicate the companion character's current state. We'll build it
    as a placeholder first, since we haven't yet created its new state, and then,
    once we have, we'll update it to reflect the real underlying data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们创建这个新状态之前，我们首先要创建一个简单的UI元素来指示伴侣角色的当前状态。我们将首先构建它作为一个占位符，因为我们还没有创建它的新状态，然后一旦我们创建了它，我们将更新它以反映真实的基础数据。
- en: Creating a UI widget using UMG
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UMG创建一个UI小部件
- en: 'Unreal provides a powerful tool for constructing UI elements. UMG allows developers
    to lay out UI elements on a visual layout tool, and to tie Blueprint behaviors
    directly to the objects in the layout. We call UI elements **widgets**. Let''s
    learn how to create them:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal提供了一个强大的工具来构建UI元素。UMG允许开发人员在可视化布局工具上布置UI元素，并将蓝图行为直接与布局中的对象关联起来。我们称之为UI元素**小部件**。让我们学习如何创建它们：
- en: 'In your project''s `Content` directory, right-click to create a new asset.
    Select UI | Widget Blueprint:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的`Content`目录中，右键创建一个新资产。选择UI | Widget Blueprint：
- en: '![](img/b6e5473a-a891-40ea-a379-ce8e72826c13.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6e5473a-a891-40ea-a379-ce8e72826c13.png)'
- en: Name it `WBP_CompanionIndicator` and open it up.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`WBP_CompanionIndicator`并打开它。
- en: You'll be presented with the UMG UI Designer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到UMG UI Designer。
- en: Unreal offers two toolsets for creating UIs. The original, called **Slate**,
    is only usable in native C++. Much of the editor itself is written using Slate,
    and some of the older game examples, such as ShooterGame, implement their interfaces
    in Slate. **UMG** provides a much more flexible and user-friendly method of creating
    UI objects in Unreal, and this is what we'll be using to build our interface elements.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal提供了两个用于创建UI的工具集。原始的称为**Slate**，只能在本机C++中使用。编辑器本身的大部分是使用Slate编写的，一些较旧的游戏示例（如ShooterGame）也使用Slate实现其界面。**UMG**提供了一种更灵活和用户友好的方法来创建虚幻引擎中的UI对象，这是我们将用来构建界面元素的方法。
- en: 'UMG is a very robust and deep system. You can create nearly any sort of interface
    element imaginable by using it. We''re not going to be able to cover everything
    UMG can do in this example, so, when you''re ready to go further, we encourage
    you to explore the documentation at [https://docs.unrealengine.com/en-us/Engine/UMG](https://docs.unrealengine.com/en-us/Engine/UMG):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: UMG是一个非常强大和深入的系统。您可以使用它创建几乎任何类型的界面元素。在这个例子中，我们无法涵盖UMG的所有功能，所以当您准备进一步时，我们鼓励您探索文档：[https://docs.unrealengine.com/en-us/Engine/UMG](https://docs.unrealengine.com/en-us/Engine/UMG)：
- en: '![](img/46c345c3-6c78-4bf2-ae93-5311e9538478.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46c345c3-6c78-4bf2-ae93-5311e9538478.png)'
- en: 'To begin with, notice that the UMG designer consists of two tabs: Designer,
    and Graph. The Designer tab is your layout tool. The Graph, just as with other
    contexts within Unreal, is where you specify the widget''s behaviors.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意UMG设计器由两个选项卡组成：设计师和图形。设计师选项卡是您的布局工具。图形选项卡与虚幻引擎中的其他上下文一样，用于指定小部件的行为。
- en: 'Let''s set up a simple UI to begin with, just so we can get all the parts into
    place:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先设置一个简单的用户界面，这样我们就可以把所有的部分放到正确的位置上：
- en: In the upper-right corner of the Designer window, find the Fill Screen drop-down
    menu, and set it to Custom.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设计师窗口的右上角，找到Fill Screen下拉菜单，并将其设置为Custom。
- en: It's very common in flat-screen applications to design a UI widget to scale
    itself with the screen, but this isn't a feasible approach in VR, where our UI
    elements need to exist in 3D space. Setting this value to Custom allows us to
    specify the UI widget's dimensions explicitly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在平面屏幕应用程序中，设计一个可以根据屏幕自动缩放的UI小部件非常常见，但在VR中这不是可行的方法，因为我们的UI元素需要存在于3D空间中。将此值设置为Custom允许我们明确指定UI小部件的尺寸。
- en: 'Set the Custom dimension to Width=320, Height=100 (you can also use the resizing
    tool to the lower right of the widget outline to adjust this):'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自定义尺寸设置为宽度=320，高度=100（您也可以使用小部件轮廓右下角的调整工具来调整）：
- en: '![](img/8566f2e7-6b97-4f71-a801-5e44e9b5fc97.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8566f2e7-6b97-4f71-a801-5e44e9b5fc97.png)'
- en: Grab a Common | Text object from the Palette and drag it into the widget's Hierarchy
    panel as a child of the Canvas Panel.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Palette中获取一个Common | Text对象，并将其拖放到Canvas Panel的层次结构面板中作为子对象。
- en: You can add elements to the canvas by dragging them directly onto the designer
    workspace, or by dragging them into the Hierarchy panel.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将元素直接拖放到设计师工作区或将其拖放到层次结构面板中来向画布添加元素。
- en: Let's center this text object in our panel.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个文本对象居中在我们的面板中。
- en: Select the `Text` object in our hierarchy if it isn't already selected.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未选择，请在层次结构中选择“Text”对象。
- en: Set its name to `txt_StateIndicator`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其名称设置为“txt_StateIndicator”。
- en: You're not required to name your widgets, but if you create a complicated UI,
    and everything is named `TextBlock_128327`, you're going to have an unpleasant
    time finding what you're looking for in your outline. It's a good practice to
    name your stuff sensibly when you make it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必为小部件命名，但如果您创建了一个复杂的UI，并且所有内容都被命名为“TextBlock_128327”，那么在大纲中找到您要查找的内容将会很困难。当您创建时，给您的东西起一个合理的名称是一个好习惯。
- en: 'From the Anchors drop-down menu, select the centered anchor and click it:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从锚点下拉菜单中选择居中的锚点并单击它：
- en: '![](img/cedb97bd-cbf4-45e4-8efa-63d041e679b5.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cedb97bd-cbf4-45e4-8efa-63d041e679b5.png)'
- en: Set its Position X and Position Y properties to `0.0`. You'll see the text object
    move so its upper-left corner is aligned with the center anchor.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其Position X和Position Y属性设置为0.0。您将看到文本对象移动，使其左上角与中心锚点对齐。
- en: Set its Alignment to X=0.5, Y=0.5\. You'll see the text object move so that
    its center is now aligned with the center anchor.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其对齐方式设置为X=0.5，Y=0.5。您将看到文本对象移动，使其中心与中心锚点对齐。
- en: Set its Size to Content to true.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其Size设置为Content为true。
- en: Set its Justification to Align Text Center.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其对齐方式设置为居中对齐文本。
- en: Set its Text to read Following (we're going to set this dynamically later on).
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其文本设置为“Following”（我们稍后会动态设置）。
- en: Anchors are an important concept to get the hang of in building UIs using UMG.
    When an object is placed on the canvas panel, its position is considered to be
    relative to whatever it's using as its anchor. For a UI canvas that doesn't change
    size, this may not matter much – you could simply leave everything anchored to
    the upper-left corner, but as soon as you start changing the size of your UI,
    anchors matter. It's a good idea to get used to using the appropriate anchors
    for wherever you want your object to appear. You'll save yourself a lot of re-working
    later.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点是使用UMG构建UI时必须掌握的重要概念。当一个对象放置在画布面板上时，它的位置被认为是相对于其锚点的。对于不改变大小的UI画布，这可能并不重要 -
    您可以简单地将所有内容锚定在左上角，但是一旦您开始改变UI的大小，锚点就很重要了。最好习惯于使用适当的锚点来确定对象的出现位置。这样您将节省很多重新工作的时间。
- en: An object's **alignment** determines where it considers its origin to be, on
    a scale of (0,0) to (1,1), so an alignment of `(0,0)` places the origin at the
    object's upper-left corner, while an alignment of `(1,1)` places it at the lower-right.
    `(0.5, 0.5)` centers the origin on the object.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的对齐方式确定其认为原点在哪里，范围从（0,0）到（1,1），因此对齐方式为（0,0）将原点放在对象的左上角，而对齐方式为（1,1）将其放在右下角。
    （0.5,0.5）将原点居中于对象。
- en: You can use *Ctrl + *click and *Shift *+ click when selecting an anchor to set
    the object's position and alignment values automatically when you select the anchor.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择锚点时，您可以使用Ctrl +单击和Shift +单击来自动设置对象的位置和对齐值。
- en: 'Take a look at the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下屏幕截图：
- en: '![](img/b8fc1921-692d-4b1f-af16-0c826d499219.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8fc1921-692d-4b1f-af16-0c826d499219.png)'
- en: So, to recap, when you're placing an object on a UMG canvas, choose an anchor
    that determines where the object considers the position (0,0) on the layout board
    to be. This can differ between objects, and that's a powerful thing. Next, determine
    where on the object it should consider its own origin to be using its Alignment
    setting. Finally, set its position.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简要回顾一下，在将对象放置在UMG画布上时，选择一个锚点，确定对象在布局板上将位置（0,0）视为何处。这可能因对象而异，这是一个强大的功能。接下来，确定对象在其自身原点上应该考虑其自身原点的位置，使用其对齐设置。最后，设置其位置。
- en: When thinking about designing interfaces in UMG, you'll have an easier time
    if you think of what you're doing as setting up the *rules by which objects arrange
    themselves* on the panel, rather than setting their locations explicitly. UMG
    is designed to make it easy to create interfaces that scale properly with different
    widget and screen sizes, and respond dynamically to the data that's driving them.
    It does this very well but it can be confusing to new users, until you shift your
    mindset away from thinking of static layouts and toward thinking of it as a dynamic
    system of rules.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在UMG中设计界面时，如果您将自己的工作视为在面板上设置对象如何排列的规则，而不是明确设置其位置，那么您将更容易。 UMG旨在使创建与不同小部件和屏幕尺寸正确缩放的界面，并对驱动它们的数据动态响应变得容易。它做得很好，但对于新用户来说可能会感到困惑，直到您将思维方式从静态布局转变为动态规则系统。
- en: We're done with this object for now, so we can close it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时完成了这个对象，所以我们可以关闭它。
- en: Adding a UI widget to an actor
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将UI小部件添加到角色
- en: 'Now that we''ve created our indicator widget, it''s time to add it to our companion
    pawn:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了指示器小部件，是时候将其添加到伴侣角色中了：
- en: Open up `BP_CompanionCharacter`, and from its Components panel, select +Add
    Component | UI | Widget.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_CompanionCharacter`，并从其组件面板中选择+添加组件| UI | Widget。
- en: Name the new component `Indicator Widget`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新组件命名为“指示器小部件”。
- en: Under its Details | UI, set its Widget Class to the `WBP_CompanionIndicator`
    class we just created.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其详细信息| UI下，将其小部件类设置为我们刚刚创建的`WBP_CompanionIndicator`类。
- en: 'Set its Draw Size to match the custom size we set for our widget layout: (X=320,
    Y=100).'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其绘制大小设置为与我们为小部件布局设置的自定义大小相匹配：（X=320，Y=100）。
- en: Jump over to your Viewport if you're not already in that view.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有在视口中，请跳转到视口。
- en: You should now see your widget displayed along with the pawn, but it's too large
    and not yet in the right position.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该看到您的小部件与角色一起显示，但它太大了，而且位置不正确。
- en: UI widgets displayed in 3D space will tend to look blurry if they're displayed
    at 100% of the scale at which they were built. It's a better idea to build the
    widget to be larger than you need it to be and then scale it down when you attach
    it to the actor. This will cause it to display at a higher resolution than it
    would if you built the widget to be smaller and displayed at full scale.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在以3D空间显示的UI小部件中，如果以构建时的100％比例显示，它们往往会显得模糊。最好的做法是将小部件构建得比实际需要的尺寸大，然后在将其附加到角色时缩小它。这将使其以比构建较小并以全尺寸显示的小部件更高的分辨率显示。
- en: Set its Location to (X=0.0, Y=0.0, Z=100.0).
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其位置设置为（X=0.0，Y=0.0，Z=100.0）。
- en: 'Set its Scale to (X=0.3, Y=0.3, Z=0.3):'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其比例设置为（X=0.3，Y=0.3，Z=0.3）：
- en: '![](img/9a45f9cd-abf4-444d-b575-032b74ed1d7d.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/9a45f9cd-abf4-444d-b575-032b74ed1d7d.png)
- en: The indicator widget is attached to the pawn's Capsule Component and will move
    with the pawn.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 指示器小部件附加到角色的胶囊组件上，并将随角色移动。
- en: Let's test it in the level. Not bad, but there's a problem – the indicator faces
    in the direction the pawn is facing, so it's difficult or impossible to read if
    the companion pawn isn't facing you. We can fix this.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在关卡中进行测试。不错，但有一个问题-指示器面向角色的方向，因此如果伴侣角色没有面向您，很难或不可能阅读。我们可以解决这个问题。
- en: Orienting the indicator widget to face the player
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将指示器小部件定位到玩家
- en: We're going to create a function that orients the indicator to face the camera.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个函数，将指示器定位到相机。
- en: Under My Blueprint | Functions, create a new function named `AlignUI`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我的蓝图|函数下，创建一个名为`AlignUI`的新函数。
- en: Set its Category to UI, and its Access Specifier to Private (setting categories
    and access specifiers isn't required, but it's a very good practice to follow.
    It will make your life easier when your project gets larger).
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其类别设置为UI，将其访问说明符设置为Private（设置类别和访问说明符不是必需的，但这是一个非常好的实践。当您的项目变得更大时，这将使您的生活更轻松）。
- en: Open it up.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它。
- en: Implementing the Align UI function
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Align UI函数
- en: 'Within the body of this function, we''re going to find the location of the
    player''s camera and orient the indicator widget to face it:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数的主体中，我们将找到玩家相机的位置，并将指示器小部件定位到面向相机：
- en: Drag the Indicator Widget from the Components list into the function graph.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从组件列表中将指示器小部件拖动到函数图中。
- en: Call SetWorldRotation on the Indicator Widget and connect the function's execution
    input to this call.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指示器小部件上调用SetWorldRotation，并将函数的执行输入连接到此调用。
- en: Drag another connector from Indicator Widget and call GetWorldLocation on it.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从指示器小部件中拖动另一个连接器，并在其上调用GetWorldLocation。
- en: Create a Get Player Camera Manager node and call GetActorLocation on the result.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个获取玩家相机管理器节点，并在结果上调用GetActorLocation。
- en: Create a Find Look at Rotation node and feed the Indicator Widget component's
    location into the Start input and the Camera Manager node's location into its
    Target.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个查找朝向旋转节点，并将指示器小部件的位置馈入Start输入，将相机管理器节点的位置馈入其Target。
- en: Feed its result into the `SetWorldRotation` function's New Rotation input.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其结果馈入`SetWorldRotation`函数的New Rotation输入。
- en: 'Give the function a `Return Node`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给函数一个`Return Node`：
- en: '![](img/f1aba3d1-bddd-4646-be40-99ad3b7d9bbc.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/f1aba3d1-bddd-4646-be40-99ad3b7d9bbc.png)
- en: By getting the location of the player camera manager, we've gotten the location
    from which the player is looking into the scene. The `Find Look at Rotation` method
    returns a rotator whose forward vector points from the start location, where the
    widget is, to the target location, where the camera is. Calling `SetWorldRotation`
    using this rotator causes the UI widget to face the camera.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过获取玩家摄像机管理器的位置，我们已经得到了玩家从场景中观察的位置。`Find Look at Rotation`方法返回一个旋转器，其前向矢量从起始位置（小部件所在位置）指向目标位置（相机所在位置）。使用此旋转器调用`SetWorldRotation`会使UI小部件面向相机。
- en: Calling Align UI from the Tick event
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Tick事件中调用Align UI
- en: 'Now let''s call the `AlignUI` function on Event Tick:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在Event Tick上调用`AlignUI`函数：
- en: Jump back out to your event graph.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳回到您的事件图。
- en: Drag a new execution line from Event Tick and type `seq` on release. Select
    Sequence from the resulting list and create a Sequence node.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Event Tick拖动一个新的执行线，并在释放时输入`seq`。从结果列表中选择Sequence并创建一个Sequence节点。
- en: 'The Sequence node will interpose itself automatically between Event Tick and
    the Follow Player call that was previously connected to it:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Sequence节点将自动插入到Event Tick和之前连接到它的Follow Player调用之间：
- en: '![](img/06cced41-b278-4559-905d-9a589a5e0547.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06cced41-b278-4559-905d-9a589a5e0547.png)'
- en: 'Call `Align UI` from the Sequence node''s Then 1 output:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Sequence节点的Then 1输出调用`Align UI`：
- en: '![](img/311ae60c-298f-4017-92dd-5ac2db00d2c7.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/311ae60c-298f-4017-92dd-5ac2db00d2c7.png)'
- en: 'Try it out in the level. The UI indicator should now orient itself to face
    the camera regardless of where the companion pawn is looking:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在关卡中试一试。无论伴侣棋子朝向何处，UI指示器现在都应该面向相机：
- en: '![](img/dab471d4-72a4-459e-8489-375b9d3e98e5.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dab471d4-72a4-459e-8489-375b9d3e98e5.png)'
- en: Good. We've created a simple UI element for our companion pawn. Of course it
    doesn't do much yet, since the pawn only has one state, but we're ready to fix
    that now.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。我们为伴侣棋子创建了一个简单的UI元素。当然，由于棋子只有一个状态，它还没有做太多事情，但我们现在准备解决这个问题。
- en: Adding a new AI state to the companion pawn
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向伴侣棋子添加一个新的AI状态
- en: 'First, let''s give our companion pawn a way to know what state it''s in. This
    information is best stored in an enumeration:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们给伴侣棋子一种知道自己处于什么状态的方法。这些信息最好存储在一个枚举中：
- en: In the Content Browser, wherever you saved `BP_CompanionCharacter`, right-click
    to add a new object, and select Blueprints | Enumeration. Name it `ECompanionState`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中，无论您将`BP_CompanionCharacter`保存在何处，右键单击以添加一个新对象，并选择蓝图|枚举。将其命名为`ECompanionState`。
- en: 'Open it up and add two items to the enumerator, named Following and Waiting,
    as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它并向枚举器添加两个项目，分别命名为Following和Waiting，如下所示：
- en: '![](img/3e73f313-24d4-4002-8711-99cb1d089741.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e73f313-24d4-4002-8711-99cb1d089741.png)'
- en: Save and close the new enumerator.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭新的枚举器。
- en: Implementing a simple AI state
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个简单的AI状态
- en: 'Now that we''ve created an enumerator to name our character''s AI states, let''s
    define the behavior we already created as the character''s `Following` state:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了一个枚举器来命名角色的AI状态，让我们将我们已经创建的行为定义为角色的“Following”状态：
- en: Open `BP_CompanionCharacter` and create a new variable. Set its name to `CompanionState` and
    its Type to the `ECompanionState` enum we just created.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BP_CompanionCharacter`并创建一个新的变量。将其名称设置为`CompanionState`，类型设置为我们刚刚创建的`ECompanionState`枚举。
- en: Find Event Tick in your event graph.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件图中找到Event Tick。
- en: Hold *Ctrl* anddrag the `CompanionState` variable onto the graph.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*Ctrl*并将`CompanionState`变量拖动到图表中。
- en: Drag a connector from its output, and type `sw` in the search box to filter
    your search to `Switch on ECompanionState`. Add the node.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其输出拖动一个连接器，并在搜索框中输入`sw`以将搜索结果过滤为`Switch on ECompanionState`。添加节点。
- en: Hold *Ctrl* and drag to move the execution input leading to your `Follow Player`
    call from that node's input to the execution input to your new switch statement.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*Ctrl*并拖动执行输入，将其从该节点的输入移动到新的switch语句的执行输入。
- en: 'Connect the switch statement''s Following output to your `Follow Player` call:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将switch语句的Following输出连接到您的`Follow Player`调用：
- en: '![](img/a18fd849-1bcc-4d25-b762-64c1a2d03b71.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a18fd849-1bcc-4d25-b762-64c1a2d03b71.png)'
- en: Now, when your companion pawn's `Companion State` is set to `Following`, it
    will execute the follow behavior, but if that state is set to `Waiting` instead,
    it won't.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您的伴侣棋子的`Companion State`设置为`Following`时，它将执行跟随行为，但如果该状态设置为`Waiting`，则不会执行。
- en: Indicating AI states using the UI indicator
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UI指示器指示AI状态
- en: Before we go ahead and create our character's next AI state, let's update our
    UI element to reflect the state the character is in. We'll want this shortly when
    we begin changing it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续创建角色的下一个AI状态之前，让我们更新我们的UI元素以反映角色所处的状态。当我们开始更改它时，我们很快就会需要它。
- en: 'Since we want our indicator UI to display information about the pawn to which
    it''s attached, we need to tell it about that pawn:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望指示器UI显示与其附加的棋子相关的信息，我们需要告诉它关于该棋子的信息：
- en: Open up `WBP_CompanionIndicator` and select `txt_StateIndicator` from the design
    panel or from the Hierarchy tab.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`WBP_CompanionIndicator`并从设计面板或层次结构选项卡中选择`txt_StateIndicator`。
- en: 'Set its Is Variable property to true:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其Is Variable属性设置为true：
- en: '![](img/e204d01d-fd34-4e88-b2de-188cefce2824.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e204d01d-fd34-4e88-b2de-188cefce2824.png)'
- en: By setting `txt_StateIndicator` as a variable, we've given ourselves access
    to the object in this widget's event graph, so we can grab a reference to it and
    change its value.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`txt_StateIndicator`设置为变量，我们可以在此小部件的事件图中访问该对象，因此我们可以获取对它的引用并更改其值。
- en: Flip to the Graph tab.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到图表选项卡。
- en: Create a new function and name it `UpdateDisplayedState`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的函数并命名为`UpdateDisplayedState`。
- en: Add an input to the function named `NewState` and set its type to `ECompanionState`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向函数添加一个名为`NewState`的输入，并将其类型设置为`ECompanionState`。
- en: Open the function.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开该函数。
- en: '`txt_StateIndicator` should now be visible in your Variables list. Hold *Ctrl*
    and drag it onto the function''s graph.'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`txt_StateIndicator`现在应该在您的变量列表中可见。按住*Ctrl*并将其拖动到函数的图表中。'
- en: Drag a connector from `txt_StateIndicator` and call `SetText` on it.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`txt_StateIndicator`拖动一个连接器，并调用`SetText`。
- en: 'Drag a connector from your NewState input and type `se` into the search box.
    A Select node should be available. Place it in the graph as follows:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从NewState输入拖动连接器，并在搜索框中键入`se`。应该会出现一个Select节点。将其放置在图表中如下所示：
- en: '![](img/37a8cd47-19f0-4262-8d18-721396065f8e.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37a8cd47-19f0-4262-8d18-721396065f8e.png)'
- en: Your newly-created Select node will have been automatically populated with options
    for each of the `ECompanionState` enum's values. Select statements can be used
    to select a wide variety of data types. To set its type, simply connect it to
    any other function or variable's input or output, and it will take on the type
    of whatever you connect to it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您新创建的Select节点将自动填充每个`ECompanionState`枚举值的选项。Select语句可用于选择各种数据类型。要设置其类型，只需将其连接到任何其他函数或变量的输入或输出，它将采用您连接到它的任何内容的类型。
- en: Connect the `Select` statement's Return Value to your Set Text node's In Text
    input.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Select`语句的返回值连接到Set Text节点的In Text输入。
- en: You'll see that the `Select` statement has now taken on the Text data type,
    and you can now enter values for the Following and Waiting options.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现`Select`语句现在已经采用了文本数据类型，您现在可以为Following和Waiting选项输入值。
- en: Populate the select statement's text inputs with the names of the appropriate
    states.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当状态的名称填充选择语句的文本输入。
- en: 'Connect the function''s execution input with the SetText node:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数的执行输入与SetText节点连接起来：
- en: '![](img/7758f824-4d0e-4eb2-b293-43ac93e65e4f.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7758f824-4d0e-4eb2-b293-43ac93e65e4f.png)'
- en: Now, whenever we call `Update Displayed State` on this UI element, it will update
    the displayed text to whatever we've entered in our `Select` statement for the
    newly-supplied state.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们在此UI元素上调用`Update Displayed State`时，它将根据我们在新提供的状态的`Select`语句中输入的内容更新显示的文本。
- en: You've seen in this example, and the previous how we can use switch statements
    and select statements with enumerators. These are valuable techniques and worth
    remembering, as they're easily readable, and will update automatically if you
    add values to an enumerator or remove them. Enumerators and switch and select
    statements are your friends.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您在此示例中以及之前看到了如何使用枚举器使用switch语句和select语句。这些是有价值的技术，值得记住，因为它们易于阅读，并且如果您向枚举器添加或删除值，它们将自动更新。枚举器、switch语句和select语句是您的朋友。
- en: 'It''s worth noting here that there''s another way we could have updated this
    UI, and it''s a method you''ll commonly see taught. We could have stashed a reference
    to the pawn that owns this widget in a variable, and then we could have used the
    Bind method to set up a real-time update for the text element:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们还可以通过另一种方法更新此UI，这是一种常见的教学方法。我们可以将拥有此小部件的角色的引用存储在变量中，然后使用Bind方法设置文本元素的实时更新：
- en: '![](img/370c8818-9c5f-4f06-9b8c-a631c8c28b5c.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/370c8818-9c5f-4f06-9b8c-a631c8c28b5c.png)'
- en: This is a good opportunity to talk about a few important considerations in UI
    development, and explain why we didn't use Bind in this instance.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个讨论UI开发中几个重要考虑因素的好机会，并解释为什么在这种情况下我们没有使用Bind。
- en: Using events to update, rather than polling
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件进行更新，而不是轮询。
- en: First, the Bind method updates with every UI update. For values that change
    continuously, this is something you'll want, but for a value like the pawn's AI
    state that only changes only occasionally, and only when you perform an action
    that changes it, it's wasteful to check on every single tick to see whether it
    needs to display a new value. Whenever possible, you should favor updating your
    UI only when you know a value you're displaying needs to be updated, rather than
    having your UI poll the underlying data to see whether what it's displaying is
    still accurate. This will really start to matter if you build an interface with
    a lot of different elements and you have every single one of them updating every
    frame. Planning for efficiency in your UI pays off.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Bind方法会在每次UI更新时更新。对于连续变化的值，这是您想要的，但对于像角色的AI状态这样只在偶尔变化，且仅在执行更改它的操作时才变化的值，每次都检查是否需要显示新值是很浪费的。尽可能地，您应该在只有在您知道要更新的值时才更新UI，而不是让UI轮询底层数据以查看其显示的内容是否仍然准确。如果您构建了一个具有许多不同元素的界面，并且每个元素都在每一帧更新，那么这将真正开始变得重要。在UI中考虑效率会带来回报。
- en: Being careful of circular references
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意避免循环引用
- en: 'The other reason we want to be careful about doing this is a bit more subtle,
    but it''s important to know about. If we were to stash a reference to the pawn
    on the widget blueprint, and simultaneously stash a reference to the widget blueprint
    on the pawn, we''ve introduced the possibility of a **circular reference** (sometimes
    also called a **cyclic dependency**):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要小心的另一个原因有点微妙，但很重要。如果我们将对小部件蓝图的pawn的引用存储在小部件蓝图上，并同时将对小部件蓝图的引用存储在pawn上，那么我们就引入了可能的循环引用（有时也称为循环依赖）：
- en: '![](img/905f0f08-e6b4-491a-94ca-2cee1b5d8ea8.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/905f0f08-e6b4-491a-94ca-2cee1b5d8ea8.png)'
- en: 'A circular reference: class A can''t compile until B is built, but class B
    can''t compile until A is built'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 循环引用：类A在B构建之前无法编译，但类B在A构建之前无法编译
- en: A circular reference occurs when one class needs to know about another class
    before it can be built, but that other class needs to know about the first class
    before *it* can be built. This is a bad situation that can create very difficult-to-find
    bugs.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 循环引用是指一个类在构建之前需要了解另一个类，但是那个类在构建之前需要了解第一个类。这是一种糟糕的情况，可能会导致非常难以找到的错误。
- en: In the event of a circular reference between the widget blueprint and the pawn,
    the widget blueprint might not be able to compile correctly because it needs the
    pawn to be compiled first, but the pawn might not compile correctly because it
    needs the widget blueprint compiled first (we say "might not" because a lot of
    other factors can affect the order in which objects are built, so it may sometimes
    work. You may not immediately realize you've created a circular reference because
    things could work for a while, and then stop working when you change something
    seemingly unrelated). You don't need to be paranoid about this. Unreal's build
    system is very good at figuring out how to determine the right order to build
    things, but if you try to keep your references going in one direction, you'll
    save yourself what can turn into a very challenging bug-hunt.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在小部件蓝图和角色之间存在循环引用的情况下，小部件蓝图可能无法正确编译，因为它需要先编译角色，但是角色可能无法正确编译，因为它需要先编译小部件蓝图（我们说“可能不会”是因为许多其他因素可能会影响对象构建的顺序，因此有时可能会工作。您可能不会立即意识到自己创建了循环引用，因为在一段时间内可能会工作，然后在更改某些看似无关的东西时停止工作）。您不需要对此过于担心。虚幻引擎的构建系统非常擅长确定构建对象的正确顺序，但是如果您尝试保持引用的单向性，您将避免遇到非常具有挑战性的错误。
- en: Using the event-driven structure we've set up, the widget blueprint doesn't
    need to know anything about the pawn. Only the pawn needs to know about the widget
    blueprint, so the compiler can easily figure out which object it needs to build
    before it can build the other, and no circular reference occurs.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们设置的事件驱动结构，小部件蓝图不需要了解角色的任何信息。只有角色需要了解小部件蓝图，因此编译器可以轻松确定在构建另一个对象之前需要构建哪个对象，从而避免循环引用。
- en: Ensuring that UI is updated when our state is changed
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保在状态更改时更新UI
- en: Now, because we've chosen to use an event-driven model rather than a polling
    model to drive our indicator UI, we have to ensure that any time the `BP_CompanionCharacter` class' `Companion
    State` changes, the UI is updated.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们选择使用事件驱动模型而不是轮询模型来驱动我们的指示器UI，我们必须确保每当`BP_CompanionCharacter`类的`Companion
    State`发生变化时，UI都会更新。
- en: To do this, we'll want to make the variable private, and force any other object
    changing this value to use an event or function call to change it. By forcing
    outside objects to use a function call to change this value, we can ensure that
    any other operations that need to happen when that value changes will happen by
    including them in the function or event's implementation. Because we've set the
    variable to private, we're preventing anybody else from changing it without calling
    this function.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们希望将变量设置为私有，并强制任何其他更改此值的对象使用事件或函数调用来更改它。通过强制外部对象使用函数调用来更改此值，我们可以确保在函数或事件的实现中包含任何其他需要在该值更改时发生的操作。因为我们将变量设置为私有，所以我们阻止任何其他人在不调用此函数的情况下更改它。
- en: This is a common practice in software development and a good one to internalize.
    If there's a possibility that you might need to perform operations in response
    to a variable's value changing, don't let outside objects change it directly.
    Make the variable private, and only allow other objects to change it through a
    public function call. If you make a habit of doing this, you'll save yourself
    a lot of headaches when your project gets large.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是软件开发中的一种常见做法，也是一个很好的内化。如果有可能需要根据变量的值执行操作，请不要让外部对象直接更改它。将变量设置为私有，并只允许其他对象通过公共函数调用来更改它。如果您养成这样的习惯，当项目变得庞大时，将会节省很多麻烦。
- en: 'Let''s create a function to handle setting the companion state, and make the
    variable private so that developers are forced to use it when they want to change
    the AI''s state:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个函数来处理设置伴侣状态，并将变量设置为私有，以便开发人员在想要更改AI状态时被迫使用它：
- en: Select the `BP_CompanionCharacter` class' `Companion State` variable, and, in
    its Details, set its Private flag to true.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`BP_CompanionCharacter`类的`Companion State`变量，并在其详细信息中将其私有标志设置为true。
- en: In the event graph, create a new custom event and name it `SetNewCompanionState`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件图中，创建一个新的自定义事件，并将其命名为`SetNewCompanionState`。
- en: Add an input to this event. Name it `NewState`, and set its Type to `ECompanionState`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向此事件添加一个输入。将其命名为`NewState`，并将其类型设置为`ECompanionState`。
- en: 'Hold *Alt *and drag a `CompanionState` setter onto the graph, and connect its
    execution and its new value to the new event:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*Alt*并将`CompanionState`设置器拖动到图表上，并将其执行和新值连接到新事件：
- en: '![](img/62d9d79e-07e9-4039-aab5-42d722424fb7.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62d9d79e-07e9-4039-aab5-42d722424fb7.png)'
- en: Now we need to tell the indicator widget that this state has changed.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要告诉指示器小部件状态已经改变。
- en: Drag a reference to the `IndicatorWidget` component onto the graph.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对`IndicatorWidget`组件的引用拖动到图表上。
- en: Call `Get User Widget Object` on the `IndicatorWidget` reference (remember that
    `IndicatorWidget` is not a reference to the widget itself, but to the component
    that holds it).
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`IndicatorWidget`引用上调用`Get User Widget Object`（记住`IndicatorWidget`不是对小部件本身的引用，而是对持有它的组件的引用）。
- en: Cast the `Get User Widget Object` component's return value to `WBP_CompanionIndicator`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Get User Widget Object`组件的返回值转换为`WBP_CompanionIndicator`。
- en: 'Call Update Displayed State on the cast result:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在转换结果上调用`Update Displayed State`：
- en: '![](img/2095000f-c2ad-430d-8912-d80fac6b4434.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2095000f-c2ad-430d-8912-d80fac6b4434.png)'
- en: Now, because `Companion State` is private, it can only be changed by calling
    `SetNewCompanionState`, and we can be sure that the UI indicator will be updated
    whenever this happens.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为`Companion State`是私有的，只能通过调用`SetNewCompanionState`来更改它，并且我们可以确保每当发生更改时，UI指示器将被更新。
- en: Adding an interactive UI
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个交互式UI
- en: 'Now it''s time to give ourselves a way to change our companion pawn''s state.
    To do this, we''re going to add a widget component to our player pawn, along with
    a widget interaction component we can use to interact with it:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为自己提供一种改变伴侣角色状态的方法了。为此，我们将向玩家角色添加一个小部件组件，以及一个我们可以用来与其交互的小部件交互组件：
- en: In the Content Browser, find the location of `BP_VRPawn`—our player pawn.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中，找到`BP_VRPawn`（我们的玩家角色）的位置。
- en: In the same directory, create a UI | Widget Blueprint, and name it `WBP_CompanionController`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的目录中，创建一个UI | Widget Blueprint，并将其命名为`WBP_CompanionController`。
- en: Save it and open it.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并打开它。
- en: In its Designer window, change `Fill Screen` to `Custom` as we did with our
    previous widget.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其设计窗口中，将`Fill Screen`更改为`Custom`，就像我们之前的小部件一样。
- en: Set its size to Width=300, Height=300.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其大小设置为Width=300，Height=300。
- en: 'From the Palette, select Panel | Vertical Box, and drag it onto your Hierarchy
    as a child of the Canvas Panel:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Palette中，选择Panel | Vertical Box，并将其作为Canvas Panel的子项拖放到层次面板中：
- en: '![](img/f8f8a41f-9d72-42f7-9c3b-bb3130589db3.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/f8f8a41f-9d72-42f7-9c3b-bb3130589db3.png)
- en: 'Set its Anchors to fill the entire panel by selecting the lower-rightmost option
    (in addition to managing placement rules, anchors can also manage stretching rules):'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择右下角的选项（除了管理放置规则外，锚点还可以管理拉伸规则），将其锚定填充整个面板：
- en: '![](img/633a251b-e5f7-45d6-802d-70bd7450390d.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/633a251b-e5f7-45d6-802d-70bd7450390d.png)
- en: Set its Offset Left, Offset Top, Offset Right, and Offset Bottom to `0.0`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其Offset Left，Offset Top，Offset Right和Offset Bottom设置为`0.0`。
- en: From the Palette, select Common | Button, and drag it onto the Vertical Box.
    Name it `btn_Follow`.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Palette中，选择Common | Button，并将其拖放到Vertical Box中。将其命名为`btn_Follow`。
- en: 'Drag another button onto the same Vertical Box and name this one `btn_Wait`:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个按钮拖放到同一个Vertical Box中，并将其命名为`btn_Wait`：
- en: '![](img/67212a86-052b-46e5-b491-a0dfbe21d3b1.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/67212a86-052b-46e5-b491-a0dfbe21d3b1.png)
- en: Drag a Common | Text widget onto your `btn_Follow`. Set its Text to `Follow`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个Common | Text小部件拖放到`btn_Follow`上。将其文本设置为`Follow`。
- en: Drag another Common | Text widget onto `btn_Wait` and set its Text to `Wait`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将另一个Common | Text小部件拖放到`btn_Wait`上，并将其文本设置为`Wait`。
- en: You may have noticed that we gave our buttons meaningful names when we created
    them, but we didn't bother to rename our text blocks. The reason for this is that
    these buttons are variables and we're going to refer to them in the widget blueprint's
    graph, while the text labels won't be referenced anywhere else, so their names
    don't really matter. You can apply your own judgment in choosing which items to
    name explicitly, but generally, your rule should be that if you're going to refer
    to the object anywhere else, it should have a meaningful name. You don't want
    to return to a widget blueprint after months of working on something else to find
    a forest of references to Button376 in the graph.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们在创建按钮时给它们起了有意义的名称，但我们没有费心为文本块重新命名。原因是这些按钮是变量，我们将在小部件蓝图的图表中引用它们，而文本标签不会在其他任何地方引用，因此它们的名称并不重要。在选择要明确命名的项目时，您可以根据自己的判断进行选择，但通常，您的规则应该是，如果您将在其他任何地方引用该对象，则应该有一个有意义的名称。您不希望在数月后返回到小部件蓝图，发现图表中引用了Button376的一片引用。
- en: Our buttons are pretty small, and not well-placed on the widget. Let's do a
    little bit of layout work to fix this.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的按钮非常小，并且在小部件上放置得不好。让我们进行一些布局工作来修复这个问题。
- en: Right-click `btn_Follow` in the Hierarchy panel or on the layout designer, and
    select Wrap With... | Size Box.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次面板上右键单击`btn_Follow`，然后选择Wrap With... | Size Box。
- en: 'Select the Size Box that just appeared in the Hierarchy panel, and set its
    Height Override to 80.0:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次面板中选择刚刚出现的Size Box，并将其Height Override设置为80.0：
- en: '![](img/eb650566-22e9-49d8-8f12-2c97792a9d7d.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/eb650566-22e9-49d8-8f12-2c97792a9d7d.png)
- en: '**Size boxes** are used to set specific sizes for UMG widgets. If you don''t
    use a size box, the widget will scale automatically according to its rules. Wrapping
    it with a size box allows you to override these rules and set selected dimensions
    explicitly, while still allowing the rest to scale automatically.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**Size Box**用于设置UMG小部件的特定大小。如果不使用Size Box，小部件将根据其规则自动缩放。使用Size Box包装它可以允许您覆盖这些规则并显式设置选定的尺寸，同时仍然允许其余部分自动缩放。'
- en: Wrap `btn_Wait` with a Size Box and set its Height Override to 80.0.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Size Box包装`btn_Wait`，并将其Height Override设置为80.0。
- en: Now, let's center these buttons vertically on the panel. We'll do this by adding
    Spacers.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在面板上垂直居中这些按钮。我们将通过添加间隔器来实现这一点。
- en: From the Palette, drag a Primitive | Spacer onto the Vertical Box in the Hierarchy panel.
    Place it before the Size Box surrounding `btn_Follow`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Palette中，将一个Primitive | Spacer拖放到层次面板中的Vertical Box上。将其放置在围绕`btn_Follow`的Size
    Box之前。
- en: Set its Size to `Fill`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其大小设置为`Fill`。
- en: 'Drag another Spacer onto the Vertical Box, after the Size Box surrounding `btn_Wait`,
    and set its Size to Fill as well:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Size Box围绕`btn_Wait`之后，再次将一个Spacer拖放到Vertical Box中，并将其大小设置为Fill：
- en: '![](img/60c6a912-7c1a-4b93-a74e-6927d27801f9.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/60c6a912-7c1a-4b93-a74e-6927d27801f9.png)
- en: Let's add one more spacer to separate the buttons a little.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个间隔器来稍微分隔一下按钮。
- en: Drag a Spacer onto the Hierarchy panel before the Size Box surrounding `btn_Wait`.
    Leave its Size as Auto, and set its Padding to 4.0.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Size Box围绕`btn_Wait`之前，再次将一个Spacer拖放到层次面板上。将其大小保持为Auto，并将其Padding设置为4.0。
- en: Here, we've seen an example of using spacers to tell the layout how to deal
    with space that isn't occupied by other widgets, and also to force some separation
    between widgets. By placing Fill spacers before and after the buttons, we centered
    them in the vertical box, and by placing an Auto spacer between the buttons, we
    separated them by a fixed amount.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了使用间隔器告诉布局如何处理未被其他小部件占用的空间的示例，还可以强制在小部件之间添加一些间隔。通过在按钮之前和之后放置Fill间隔器，我们使它们在垂直框中居中，并通过在按钮之间放置Auto间隔器，我们将它们分隔了一个固定的距离。
- en: Adjusting the button colors
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整按钮颜色
- en: 'These default button colors are going to appear too bright to be readable in
    our fairly dark scene. We can fix this by adjusting their background color properties:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这些默认按钮颜色在我们相当暗的场景中看起来太亮，无法阅读。我们可以通过调整其背景颜色属性来解决这个问题：
- en: Select `btn_Follow` and hit the color swatch for its Details | Appearance |
    Background Color.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`btn_Follow`，点击其Details | Appearance | Background Color的颜色样本。
- en: In the resulting color picker's HSV input, set its Value to 0.05.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在结果颜色选择器的HSV输入中，将其Value设置为0.05。
- en: 'Do the same for `btn_Wait`:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`btn_Wait`也执行相同的操作：
- en: '![](img/11f409af-9bd2-4420-8ff0-1bd48dd243b8.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11f409af-9bd2-4420-8ff0-1bd48dd243b8.png)'
- en: This will dim the button's background enough to allow us to read it clearly
    under the environment's lighting.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使按钮的背景变暗，以便我们可以在环境的照明下清楚地阅读它。
- en: Adding event handlers to our buttons
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的按钮添加事件处理程序
- en: 'Now, let''s make our buttons do something when they''re clicked:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在按钮被点击时执行一些操作：
- en: 'Select `btn_Follow`, and from its Details | Events, hit the + button for its
    On Clicked event:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择btn_Follow，并在其Details | Events中，点击On Clicked事件的+按钮：
- en: '![](img/6f5854ab-daf3-4c3f-bed9-ec8239f7da27.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f5854ab-daf3-4c3f-bed9-ec8239f7da27.png)'
- en: You'll be taken to the widget's event graph, where a new event named `On Clicked
    (btn_Follow)` has been created.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您将进入小部件的事件图表，其中创建了一个名为On Clicked (btn_Follow)的新事件。
- en: Create a Get All Actors of Class node in your graph, and set its Actor Class to
    `BP_CompanionCharacter`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图表中创建一个Get All Actors of Class节点，并将其Actor Class设置为BP_CompanionCharacter。
- en: Drag a connector from its Out Actors array, and create a ForEachLoop from it.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其Out Actors数组中拖动一个连接器，并创建一个ForEachLoop。
- en: 'Drag a connector from the Array Element output of ForEachLoop, and make a call
    to the Set New Companion State event we created on BP_CompanionCharacter. Set
    the state to Following:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从ForEachLoop的Array Element输出拖动一个连接器，并调用我们在BP_CompanionCharacter上创建的Set New Companion
    State事件。将状态设置为Following：
- en: '![](img/6708b737-a7ac-4ce5-b2ea-78ed6c804cb4.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6708b737-a7ac-4ce5-b2ea-78ed6c804cb4.png)'
- en: Let's do the same thing for `btn_Wait`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对btn_Wait做同样的事情。
- en: Again, select `btn_Wait` from the Designer tab, and create an On Clicked event
    for it.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次从Designer选项卡中选择btn_Wait，并为其创建一个On Clicked事件。
- en: Select the nodes connected to the `On Clicked (btn_Follow)` event, and hit *Ctrl
    + **W* to duplicate them.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择与On Clicked (btn_Follow)事件连接的节点，并按下Ctrl + W进行复制。
- en: Change the companion state we're setting to `Waiting`.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们设置的伴侣状态更改为Waiting。
- en: Attaching the UI element to the player pawn
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将UI元素附加到玩家角色
- en: Now, just as we did with our companion pawn's overhead indicator, we need to
    place this UI somewhere in the world.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像我们对伴侣角色的顶部指示器所做的那样，我们需要将此UI放置在世界中的某个位置。
- en: The natural response for someone used to designing for flat-screen applications
    would be to follow the design principles they already knew and create some sort
    of HUD to display in the headset. This isn't such a good idea.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于习惯于设计平面应用程序的人来说，自然的反应是遵循他们已经了解的设计原则，并创建一些在头戴式显示器中显示的HUD。这不是一个好主意。
- en: First, any UI you attach to the headset is attached to the player's head. When
    they turn their head to look at it, it's just going to keep moving away. This
    gets old fast and can induce motion sickness in some users. This problem is compounded
    by the fact that the fresnel lenses in VR headsets are much less clear at the
    edges than they are at the center, so UI elements at the edge of the player's
    vision are going to be difficult to read. Finally, we face the problem that there's
    no easy way to interact with a UI element that's been bolted to our forehead.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您附加到头戴式显示器的任何UI都会附加到玩家的头部。当他们转动头部看它时，它只会继续移动。这很快就会变得无聊，并且可能会引起一些用户的晕动病。这个问题的复杂性在于VR头戴式显示器的菲涅耳透镜在边缘处的清晰度要比中心处的清晰度低得多，因此玩家视野边缘的UI元素将很难阅读。最后，我们面临的问题是没有简单的方法与我们额头上的UI元素进行交互。
- en: 'A better solution is to attach the UI to something the player can control,
    like their wrist. Let''s do this now:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是将UI附加到玩家可以控制的东西上，比如他们的手腕。现在让我们这样做：
- en: Open up `BP_VRPawn`, and find `Hand_L` in its components list.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开BP_VRPawn，并在其组件列表中找到Hand_L。
- en: Add a Widget component as a child of `Hand_L`. Name it `CompanionController`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个小部件组件作为Hand_L的子级。将其命名为CompanionController。
- en: Set `WBP_CompanionController` as the widget's Widget Class.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将WBP_CompanionController设置为小部件的Widget Class。
- en: Set its Draw Size to (X=300, Y=300) to match the size at which we created it.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其绘制大小设置为(X=300，Y=300)，以与创建时的大小匹配。
- en: Now let's get it attached.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将其附加。
- en: Find your `BP_VRPawn` player's `BeginPlay` event.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到您的BP_VRPawn玩家的BeginPlay事件。
- en: Drag a new connector from `BeginPlay` and create a Sequence node. Our `Set Tracking
    Origin` call should automatically attach to the Sequence node's Then 0 output.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从BeginPlay拖动一个新的连接器，并创建一个Sequence节点。我们的Set Tracking Origin调用应自动连接到Sequence节点的Then
    0输出。
- en: Drag a reference to the `CompanionController` widget, which we just added to
    the pawn, onto the graph.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将刚刚添加到角色中的CompanionController小部件的引用拖动到图表中。
- en: Drag a connector from it and create an Attach to Component node.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从它拖动一个连接器并创建一个Attach to Component节点。
- en: 'Remember that there are two variants of this node: Target is Actor, and Target
    is Scene Component. Select the node designed to work with a scene component.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此节点有两个变体：目标是Actor和目标是Scene Component。选择与场景组件一起使用的节点。
- en: Drag an execution line from the Sequence node's Then 1 output to the Attach
    to Component node's execution input.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Sequence节点的Then 1输出中拖动一个执行线到Attach to Component节点的执行输入。
- en: We could also simply have dragged a connector from Set Tracking Origin output
    to the GetHand_L call, but it's a better practice to keep unrelated operations
    on separate execution lines so it's easier to see what really belongs together.
    By putting Set Tracking Origin on one sequence output, and the GetHand_L call
    on another, we're making it clear to the reader that these are two separate jobs
    being done.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以简单地从Set Tracking Origin输出拖动一个连接器到GetHand_L调用，但是将不相关的操作保持在单独的执行线上是更好的做法，这样更容易看出真正属于一起的内容。通过将Set
    Tracking Origin放在一个序列输出上，将GetHand_L调用放在另一个序列输出上，我们向读者清楚地表明这是两个独立的任务。
- en: Drag out an instance of the `Get Hand Mesh for Hand` method we created earlier
    (if you want to set up for a left-handed player, change its Hand value to Right;
    otherwise just leave it at the default Left).
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖出我们之前创建的“Get Hand Mesh for Hand”方法的一个实例（如果您想为左撇子玩家设置，将其Hand值更改为Right；否则保持默认的Left）。
- en: 'Feed the resulting hand mesh into the AttachToComponent node''s Parent input:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果手部网格输入到AttachToComponent节点的Parent输入中：
- en: '![](img/f7b876fd-1ed8-474b-8208-a45bd83c0f42.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f7b876fd-1ed8-474b-8208-a45bd83c0f42.png)'
- en: Let's run it. It's tremendous and not yet correctly aligned, but it's moving
    with the left hand as we intended.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行它。它很大，但还没有正确对齐，但它会随着我们的左手移动。
- en: Drag another connector from `CompanionController`, and call `Set Relative Transform` on
    it.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“CompanionController”拖动另一个连接器，并在其上调用“Set Relative Transform”。
- en: Right-click the New Transform input and split the struct pin.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击New Transform输入并拆分结构引脚。
- en: 'Enter the following values:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下值：
- en: 'New Transform Location: (X=0.0, Y=-10.0, Z=0.0)'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的变换位置：（X=0.0，Y=-10.0，Z=0.0）
- en: 'New Transform Rotation: (X=0.0, Y=0.0, Z=90.0)'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的变换旋转：（X=0.0，Y=0.0，Z=90.0）
- en: 'New Transform Scale: (X=-0.05, Y=0.05, Z=0.05)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的变换比例：（X=-0.05，Y=0.05，Z=0.05）
- en: '![](img/10f117cb-6c25-46e3-8a98-33038de7b8cc.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/10f117cb-6c25-46e3-8a98-33038de7b8cc.png)
- en: Note that we're negating the Scale's X value here. If you recall, we flipped
    our left-hand mesh by inverting its scale. Since we're attaching to that flipped
    mesh, we need to negate the scale here too, otherwise our widget will appear mirrored
    (if we're instead attaching this to the right hand, set the scale's X value to
    positive 0.05 instead, and set the rotation's Z value to positive 90.0).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里否定了比例的X值。如果您还记得，我们通过反转其比例来翻转了左手网格。由于我们要附加到翻转的网格，我们在这里需要否定比例，否则我们的小部件将显示为镜像（如果我们将其附加到右手，则将比例的X值设置为正0.05，并将旋转的Z值设置为正90.0）。
- en: Run it again and we'll see that the wrist menu is now much better aligned with
    our wrist.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行它，我们会看到手腕菜单现在与我们的手腕更好地对齐了。
- en: 'Now for the next challenge: how do we press one of these buttons?'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的挑战是：我们如何按下其中一个按钮？
- en: Using widget interaction components
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用小部件交互组件
- en: 'UIs in virtual reality pose a significant problem: how do we allow the user
    to interact with them? Early solutions often used gaze-based controls. The user
    would push a button by looking at it for a fixed amount of time. Yes, it was as
    clunky as it sounds. Thankfully, with the advent of hand controls, we no longer
    need to do it this way.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟现实中的用户界面存在一个重大问题：我们如何允许用户与其进行交互？早期的解决方案通常使用凝视控制。用户通过凝视固定时间来按下按钮。是的，它就像听起来的那样笨拙。幸运的是，随着手部控制的出现，我们不再需要以这种方式进行操作。
- en: In Unreal, we most commonly interact with UI elements in VR by using a **widget
    interaction component**, which acts as a pointer in the scene and can simulate
    mouse interactions when used with UMG widgets.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，我们最常使用**小部件交互组件**与VR中的UI元素进行交互，它在场景中充当指针，并且在与UMG小部件一起使用时可以模拟鼠标交互。
- en: 'Let''s add one to our right hand:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在右手上添加一个：
- en: Open up `BP_VRPawn` and add a Widget Interaction component to its Components
    list (its default name is fine).
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“BP_VRPawn”，并将Widget Interaction组件添加到其组件列表中（默认名称即可）。
- en: In its Details panel, set its Show Debug flag to `True`.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其详细信息面板中，将其Show Debug标志设置为“True”。
- en: 'On our Event Graph, find the Sequence node on our `Begin Play` event, and use
    the Add pin button to add a new output:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的事件图中，找到“Begin Play”事件上的Sequence节点，并使用Add pin按钮添加一个新的输出：
- en: '![](img/43a112d4-f84c-440f-a530-6aea644b1d48.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/43a112d4-f84c-440f-a530-6aea644b1d48.png)
- en: Drag a reference to our `Widget Interaction` component onto the graph.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对我们的“Widget Interaction”组件的引用拖到图表上。
- en: Drag a connector from the `Widget Interaction` reference and create an Attach
    To Component (Scene Component) node with `Widget Interaction` as its target.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“Widget Interaction”引用中拖动一个连接器，并创建一个“Attach To Component (Scene Component)”节点，将“Widget
    Interaction”作为其目标。
- en: Drag a `Get Hand Mesh for Hand` function call onto the graph, and set its Hand
    property to Right (or Left if you attached the UI to the right hand).
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Get Hand Mesh for Hand”函数调用拖到图表上，并将其Hand属性设置为Right（如果您将UI附加到右手，则设置为Left）。
- en: 'Feed its Hand Mesh output into the Attach To Component node''s Parent input:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其Hand Mesh输出馈入“Attach To Component”节点的Parent输入：
- en: '![](img/30984984-90ff-46fc-bb32-f8386aa7412c.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/30984984-90ff-46fc-bb32-f8386aa7412c.png)
- en: We're now attaching the controller UI to the left hand and the Widget Interaction
    component to the right hand.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将控制器UI附加到左手，将小部件交互组件附加到右手。
- en: 'Now, let''s test it:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下：
- en: '![](img/7288effe-f791-4319-b942-89c744d18f83.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/7288effe-f791-4319-b942-89c744d18f83.png)
- en: Good. The widget interaction component's default placement and alignment aren't
    bad. We could adjust it by using a `Set Relative Transform` call if we wanted,
    but for what we're doing here, this is fine.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。小部件交互组件的默认放置和对齐效果不错。如果我们想要调整它，可以使用“Set Relative Transform”调用，但对于我们在这里要做的事情来说，这样就可以了。
- en: Another way of setting the placement of objects we're attaching to another object
    is to place a socket on the target object's skeleton. If you add a socket to a
    skeleton, simply put its name in the Attach to Component node's Socket Name property.
    In the interest of staying on topic, we're sticking to simple Set Relative Transform
    calls, but if you want to explore using sockets, the directions on [https://docs.unrealengine.com/en-us/Engine/Content/Types/SkeletalMeshes/Sockets](https://docs.unrealengine.com/en-us/Engine/Content/Types/SkeletalMeshes/Sockets)
    will apply.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 设置我们附加到另一个对象的对象的放置的另一种方法是在目标对象的骨架上放置一个插座。如果您向骨架添加插座，只需将其名称放在“Attach to Component”节点的“Socket
    Name”属性中。为了保持主题的连贯性，我们将坚持使用简单的“Set Relative Transform”调用，但如果您想探索使用插座，可以参考[https://docs.unrealengine.com/en-us/Engine/Content/Types/SkeletalMeshes/Sockets](https://docs.unrealengine.com/en-us/Engine/Content/Types/SkeletalMeshes/Sockets)上的说明。
- en: Now that we have our widget interaction component attached to our hand, we're
    ready to pass input through it.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经将小部件交互组件连接到手上，我们准备通过它传递输入。
- en: Sending input through widget interaction components
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过小部件交互组件发送输入
- en: 'First off, we''re going to need to choose what input should drive our widget
    interaction. Since we''re only using our triggers to grab objects, it should work
    out fine to add our widget interactions to these same inputs:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要选择什么输入来驱动我们的小部件交互。由于我们只使用扳机来抓取对象，所以将我们的小部件交互添加到这些相同的输入中应该可以正常工作：
- en: Find the `InputAction_GrabLeft` and `GrabRight` event handlers on the `BP_VRPawn` player's
    event graph.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“BP_VRPawn”玩家的事件图中找到“InputAction_GrabLeft”和“GrabRight”事件处理程序。
- en: Drag a reference to your `Widget Interaction` component onto the graph.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对`Widget Interaction`组件的引用拖动到图表中。
- en: Drag a connection from the `Widget Interaction` component, and call `Press Pointer
    Key` from the connection. Set its Key drop-down to `Left Mouse Button`.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Widget Interaction`组件拖动一个连接，并从连接中调用`Press Pointer Key`。将其键下拉菜单设置为`Left Mouse
    Button`。
- en: Drag another connection from `Widget Interaction` and call `Release Pointer
    Key`. Set this Key drop-down to `Left Mouse Button` as well.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Widget Interaction`拖动另一个连接，并调用`Release Pointer Key`。将此键下拉菜单设置为`Left Mouse
    Button`。
- en: If you've attached your `Widget Interaction` component to the right hand, call
    `Press Pointer Key` from the end of the `InputAction_GrabRight` component's Pressed
    event chain after the `Grab Actor` call (if the interaction component is on the
    left hand, call it from `GrabLeft` instead).
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您将`Widget Interaction`组件附加到右手，请在`InputAction_GrabRight`组件的Pressed事件链的末尾调用`Press
    Pointer Key`，在`Grab Actor`调用之后调用它（如果交互组件在左手上，请改为从`GrabLeft`调用）。
- en: 'Call `Release Pointer Key` from the `InputAction_GrabRight` component''s Released
    chain, after the `Release Actor` call:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`InputAction_GrabRight`组件的Released链中调用`Release Pointer Key`，在`Release Actor`调用之后：
- en: '![](img/b0373e21-74e9-46c5-9dfe-6a8c3b95cd54.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0373e21-74e9-46c5-9dfe-6a8c3b95cd54.png)'
- en: What we're doing here is telling the widget interaction component to communicate
    with the widget as though the user had moved a mouse pointer over it and pressed
    the left button. This is a powerful and flexible system—you can recreate nearly
    any input event and pass it through the interaction component.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是告诉小部件交互组件，让它与小部件通信，就像用户将鼠标指针移动到上面并按下左键一样。这是一个强大而灵活的系统 - 您可以重新创建几乎任何输入事件并通过交互组件传递它。
- en: Let's test it. You should now be able to point the widget interaction component
    at your wrist controller and pull the trigger to activate a button. Try running
    around the level and switching your companion between the Follow and Wait states.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下。现在，您应该能够将小部件交互组件对准手腕控制器并按下扳机以激活按钮。尝试在关卡中四处奔跑，并在跟随和等待状态之间切换您的伴侣。
- en: Making a better pointer for our interaction component
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的交互组件创建一个更好的指针
- en: The last thing we should probably improve before wrapping this up is that obtrusive-looking
    debug beam on our widget interaction component. Let's take a moment to replace
    it with something better-looking.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束之前，我们应该改进一下小部件交互组件上那个显眼的调试光束。让我们花点时间用更好看的东西来替换它。
- en: In `BP_VRPawn`, select the `Widget Interaction` component and turn off its Show
    Debug flag.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BP_VRPawn`中，选择`Widget Interaction`组件并关闭其Show Debug标志。
- en: In the Components panel, add a Static Mesh component as a child of `WidgetInteraction`.
    Name it `InteractionBeam`.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件面板中，将一个静态网格组件添加为`WidgetInteraction`的子组件。将其命名为`InteractionBeam`。
- en: Set its Static Mesh property to `/Engine/BasicShapes/Cylinder`.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其静态网格属性设置为`/Engine/BasicShapes/Cylinder`。
- en: Set its Location to (X=50.0, Y=0.0, Z=0.0)
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其位置设置为（X=50.0，Y=0.0，Z=0.0）。
- en: Set its Rotation to (Roll=0.0, Pitch=-90.0, Yaw=0.0). Remember that `Pitch`
    is mapped to Y in the UI.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其旋转设置为（Roll=0.0，Pitch=-90.0，Yaw=0.0）。请记住，`Pitch`在UI中映射到Y。
- en: Set its Scale to `(X=0.005, Y=0.005, Z=1.0)`.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其比例设置为`(X=0.005，Y=0.005，Z=1.0)`。
- en: Set its Collision | Can Character Step Up On to `No`, and its Collision Presets
    to `NoCollision`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其碰撞|可以踩上的角色设置为`No`，将其碰撞预设设置为`NoCollision`。
- en: If you add a UI or other attached element to a hand and you suddenly find that
    your movement is blocked, check to see whether you've turned its collision off.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在手上添加了UI或其他附加元素，并突然发现您的移动被阻止，请检查是否已关闭其碰撞。
- en: Try it out. We now have a gray cylinder indicating our interaction component.
    We should give it a more suitable material.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 试一下。现在我们有一个灰色的圆柱体表示我们的交互组件。我们应该给它一个更合适的材质。
- en: Creating an interaction beam material
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个交互光束材质
- en: 'We''re going to give our interaction beam a simple translucent material. We
    want to be able to see it in the world, but we don''t want it to be so obtrusive
    that it distracts our attention from the world:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为交互光束提供一个简单的半透明材质。我们希望能在世界中看到它，但又不希望它过于显眼，分散我们对世界的注意力：
- en: Find the location in our `Content` directory where we saved the `M_Indicator`
    material we used for teleportation.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到我们保存了用于传送的`M_Indicator`材质的`Content`目录中的位置。
- en: Create a new material in this directory and name it `M_WidgetInteractionBeam`.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此目录中创建一个新的材质，并将其命名为`M_WidgetInteractionBeam`。
- en: 'Open it up and set its Blend Mode to `Translucent`. (Remember: to set material
    properties, select the output node.)'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它并将其混合模式设置为`Translucent`。（记住：要设置材质属性，请选择输出节点。）
- en: Hold down the *V* key and click to create a Vector Parameter node. Name it `BaseColor`.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*V*键并单击以创建一个矢量参数节点。将其命名为`BaseColor`。
- en: Set the BaseColor node's default value to pure white – (R=1.0, G=1.0, B=1.0,
    A=0.0).
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将BaseColor节点的默认值设置为纯白色 - （R=1.0，G=1.0，B=1.0，A=0.0）。
- en: Feed its output into the BaseColor and EmissiveColor material inputs.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其输出连接到BaseColor和EmissiveColor材质输入。
- en: Right-click in the material graph and create a Texture Coordinate node.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在材质图中右键单击并创建一个纹理坐标节点。
- en: Right-click and create a Linear Gradient node with the texture coordinate's
    output feeding into its UV Channel input.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并创建一个线性渐变节点，将纹理坐标的输出连接到其UV通道输入。
- en: Hold the *M* key and click to create a Multiply node.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*M*键并单击以创建一个乘法节点。
- en: Drag the LinearGradient node's VGradient output into the Multiply node's A input.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将线性渐变节点的VGradient输出连接到乘法节点的A输入。
- en: Hold *S* and click to create a Scalar parameter. Name it `OpacityMultiplier`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*S*键并单击以创建一个标量参数。将其命名为`OpacityMultiplier`。
- en: Set its Slider Max to 1.0 and its Default Value to 0.25.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其滑块最大值设置为1.0，将其默认值设置为0.25。
- en: Feed its output into the Multiply node's B input.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其输出连接到Multiply节点的B输入。
- en: 'Feed the result of the Multiply node into the material''s Opacity input:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Multiply节点的结果连接到材质的不透明度输入：
- en: '![](img/ef34f7fa-d2a4-400b-9e53-080eaf6ca526.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef34f7fa-d2a4-400b-9e53-080eaf6ca526.png)'
- en: We're going to need to tune this material to work with our environment. We can
    make our life easier by creating a **material instance**. Material instances are
    derived from materials, but only those parameters that have been exposed in the
    parent material can be changed. Because material instances don't include any changes
    to the material graph, just value changes, they don't need to be recompiled when
    those changes are made. It's much faster to change values in a material instance
    than in a material.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调整这个材质以适应我们的环境。通过创建**材质实例**，我们可以更轻松地完成工作。材质实例是从材质派生出来的，但只能更改在父材质中公开的那些参数。因为材质实例不包括对材质图的任何更改，只有值的更改，所以当进行这些更改时，它们不需要重新编译。在材质实例中更改值比在材质中更改值要快得多。
- en: Right-click `M_WidgetInteractionBeam`, and select Material Actions | Create
    Material Instance.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`M_WidgetInteractionBeam`，选择Material Actions | Create Material Instance。
- en: Name the new instance `MI_WidgetInteractionBeam`.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新实例命名为`MI_WidgetInteractionBeam`。
- en: Assign `MI_WidgetInteractionBeam` to the `InteractionBeam` static mesh component
    on `BP_VRPawn`.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MI_WidgetInteractionBeam`分配给`BP_VRPawn`上的`InteractionBeam`静态网格组件。
- en: Run the map. It's still pretty bright.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 运行地图。它仍然很亮。
- en: Open `MI_WidgetInteractionBeam` and set its OpacityMultiplier to 0.01\. (Put
    a checkmark beside a value you plan to change.)
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MI_WidgetInteractionBeam`并将其OpacityMultiplier设置为0.01。 （在您计划更改的值旁边打勾。）
- en: Run it again. That's much better.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行。好多了。
- en: Creating an impact effect
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个碰撞效果
- en: Now we need an impact effect to show where the beam is intersecting a target.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个碰撞效果来显示光束与目标的交叉点。
- en: Create a new Static Mesh component as a child of the `BP_VRPawn` player's root
    component (the `Capsule Component`).
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的静态网格组件，作为`BP_VRPawn`玩家的根组件（`Capsule Component`）的子组件。
- en: Name it `InteractionBeamTarget`.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`InteractionBeamTarget`。
- en: Set its Static Mesh property to `Engine/BasicShapes/Sphere`.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其静态网格属性设置为`Engine/BasicShapes/Sphere`。
- en: Set its Scale to `(X=0.01, Y=0.01, Z=0.01)`.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其缩放设置为`(X=0.01, Y=0.01, Z=0.01)`。
- en: Set its Collision | Can Character Step Up On to `No`, and its Collision Presets to `NoCollision`.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其碰撞| Can Character Step Up On设置为`No`，将其碰撞预设设置为`NoCollision`。
- en: This target sphere needs a material too. For this, we'll create an emissive
    material with a dark outline so it shows up clearly on both light and dark backgrounds.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目标球体也需要一个材质。为此，我们将创建一个带有深色轮廓的自发光材质，以便在明亮和暗背景上清晰显示。
- en: Create a new material named `M_WidgetInteractionTarget`.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`M_WidgetInteractionTarget`的新材质。
- en: Hold the *V* key and click to create a vector parameter. Name it `BaseColor` and
    set its default value to pure white.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*V*键并点击创建一个矢量参数。将其命名为`BaseColor`并将其默认值设置为纯白色。
- en: Drag an output from `BaseColor` and click `–` to create a Subtract node.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`BaseColor`拖动一个输出并点击`-`创建一个Subtract节点。
- en: Feed the result of the Subtract node into the material's Base Color and Emissive
    inputs.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Subtract节点的结果输入到材质的Base Color和Emissive输入中。
- en: Right-click and create a Fresnel node.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并创建一个Fresnel节点。
- en: Hold the 1 key and click to create a scalar material expression constant. Set
    its value to 15.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住1键并点击创建一个标量材质表达式常量。将其值设置为15。
- en: Feed it into the Fresnel node's ExponentIn.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其输入到Fresnel节点的ExponentIn中。
- en: Hit *Ctrl *+ *W* to duplicate it, set the new constant's value to 0, and feed
    it into the Fresnel node's BaseReflectFractionIn.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl*+*W*进行复制，将新常量的值设置为0，并将其输入到Fresnel节点的BaseReflectFractionIn中。
- en: Hold *M* and click to create a Multiply node.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*M*并点击创建一个Multiply节点。
- en: Feed the Fresnel node's result into the Multiply node's A input.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Fresnel节点的结果输入到Multiply节点的A输入中。
- en: Hold *S* and click to create a scalar parameter. Name it `OutlineThickness` and
    set its default value to 10.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住*S*并点击创建一个标量参数。将其命名为`OutlineThickness`并将其默认值设置为10。
- en: Feed OutlineThickness into the Multiply node's B input.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将OutlineThickness输入到Multiply节点的B输入中。
- en: 'Feed the Multiply node''s result into the Subtract node''s B input:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Multiply节点的结果输入到Subtract节点的B输入中：
- en: '![](img/cc745b2c-0a82-4319-bf08-367821dc9dc3.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc745b2c-0a82-4319-bf08-367821dc9dc3.png)'
- en: In your content browser, create a material instance from this material named
    `MI_WidgetInteractionTarget`.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中，从该材质创建一个名为`MI_WidgetInteractionTarget`的材质实例。
- en: Assign `MI_WidgetInteractionTarget` to the `InteractionBeamTarget` sphere we
    created on `BP_VRPawn`.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MI_WidgetInteractionTarget`分配给我们在`BP_VRPawn`上创建的`InteractionBeamTarget`球体。
- en: Finally, we need to set its position to the interaction component's impact location.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将其位置设置为交互组件的碰撞位置。
- en: In `BP_VRPawn` player's event graph, find the `Event Tick` and create a Sequence
    node between `Event Tick` and the `UpdateTeleport_Implementation` collapsed graph.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BP_VRPawn`玩家的事件图中，找到`Event Tick`并在`Event Tick`和`UpdateTeleport_Implementation`折叠图之间创建一个Sequence节点。
- en: Drag a reference to `WidgetInteraction` onto the graph, and call `Get Last Hit
    Result` on its output.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对`WidgetInteraction`的引用拖动到图中，并在其输出上调用`Get Last Hit Result`。
- en: Right-click the Return Value and select Split Struct Pin.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击返回值并选择拆分结构引脚。
- en: Drag a reference to the `InteractionBeamTarget` static mesh component onto the
    graph.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对`InteractionBeamTarget`静态网格组件的引用拖动到图中。
- en: Call `SetWorldLocation` on it, and feed the Return Value Impact Point from `Get
    Last Hit Result` into its new location.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其上调用`SetWorldLocation`，并将`Get Last Hit Result`的返回值Impact Point输入到其新位置中。
- en: Connect the Sequence node's Then 1 output to the SetWorldLocation node's execution
    input.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Sequence节点的Then 1输出连接到SetWorldLocation节点的执行输入中。
- en: 'Select these new nodes, right-click, and select Collapse Nodes. Name the collapsed
    graph `UpdateWidgetInteractionTarget_Implementation`:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择这些新节点，右键单击，选择折叠节点。将折叠的图命名为`UpdateWidgetInteractionTarget_Implementation`：
- en: '![](img/b67c8a4a-f236-46ce-b2d4-22c8447fcffd.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b67c8a4a-f236-46ce-b2d4-22c8447fcffd.png)'
- en: Open up the collapsed graph and clean it up.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开折叠的图并进行清理。
- en: 'The collapsed graph should look like this:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠的图应该是这样的：
- en: '![](img/f32f3377-898b-403b-8158-7d3e6d6e8e22.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f32f3377-898b-403b-8158-7d3e6d6e8e22.png)'
- en: 'Test it out. The beam isn''t bad, and the target point is fairly easy to spot:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一下。光束不错，目标点也很容易找到：
- en: '![](img/6efd78d1-54b6-4d5c-9558-b34744d49593.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6efd78d1-54b6-4d5c-9558-b34744d49593.png)'
- en: There's quite a lot more we could do with this, like cutting off the beam where
    it hits a widget, and adjusting the target sphere's scale based on how close it
    is to the player's view, but what we have here is a very good starting ground.
    This system does a lot, and does it in ways that would be easy to extend and improve
    upon.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以做很多其他事情，比如在光束碰到小部件时切断它，并根据它与玩家视图的接近程度调整目标球的比例，但我们在这里已经有了一个非常好的起点。这个系统功能强大，并且可以很容易地扩展和改进。
- en: Explore the level and try out the companion controller. While what we've put
    together here is fairly streamlined, it contains the seeds for quite a lot of
    things we might want to do.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 探索关卡并尝试使用伴侣控制器。虽然我们在这里所做的相当简化，但它包含了我们可能想要做的很多事情的基础。
- en: Summary
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we added a major remaining piece to our development repertoire
    and added functional UI elements to our project.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为我们的开发工具库添加了一个重要的剩余部分，并为我们的项目添加了功能性的UI元素。
- en: In this chapter, we learned how to create a simple AI-controlled character and
    animate it, and we learned how to create a UI in 3D space using UMG, which also
    allowed us to change the character's AI state.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何创建一个简单的AI控制角色并对其进行动画处理，还学习了如何使用UMG在3D空间中创建UI，这也使我们能够改变角色的AI状态。
- en: In the next chapter, we're going to move on from creating characters and interfaces,
    and begin to explore creating environments for use in VR.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续从创建角色和界面转向探索创建用于VR的环境。
