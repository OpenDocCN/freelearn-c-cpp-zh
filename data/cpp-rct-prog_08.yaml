- en: RxCpp – the Key Elements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxCpp - 关键元素
- en: 'In the previous chapter, we were introduced to the RxCpp library and its programming
    model. We wrote some programs to understand workings of the library and  also
    covered the most essential elements of the RxCpp library. In this chapter, we
    will cover, in some depth, the key elements of reactive programming , which includes
    the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了RxCpp库及其编程模型。我们编写了一些程序来了解库的工作原理，并介绍了RxCpp库的最基本元素。在本章中，我们将深入介绍响应式编程的关键元素，包括以下内容：
- en: Observables
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Observables
- en: Observers and their variants (Subscribers)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者及其变体（订阅者）
- en: Subjects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题
- en: Schedulers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度程序
- en: Operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符
- en: 'In effect, the key aspects of reactive programming are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，响应式编程的关键方面如下：
- en: Observables are Streams to which Observers can subscribe for notifications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Observables是观察者可以订阅以获取通知的流
- en: A Subject is a combination of Observable and Observer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题是Observable和Observer的组合
- en: Schedulers execute the Action associated with Operators and help the flow of
    data from Observables to Observers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度程序执行与操作符相关的操作，并帮助数据从Observables流向Observers
- en: Operators are functions that take an Observable and emit another Observable
    (well, almost!)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符是接受Observable并发出另一个Observable的函数（嗯，几乎是！）
- en: Observables
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observables
- en: In the previous chapter, we created Observables from the  scratch and  subscribed
    to those Observables. In all of our examples, the Observables created an instance
    of the  (data)  `Producer` class. The `Producer` class produces an event Stream.
    In other words, Observables are functions that connect Subscribers (Observers)
    to Producers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们从头开始创建了Observables并订阅了这些Observables。在我们的所有示例中，Observables创建了`Producer`类的实例（数据）。`Producer`类产生一个事件流。换句话说，Observables是将订阅者（观察者）连接到生产者的函数。
- en: 'Before we proceed, let''s dissect an Observable and the core activities related
    to it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们剖析一下Observable及其相关的核心活动：
- en: An Observable is a function that takes an Observer as a parameter and returns
    a function
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Observable是一个以Observer作为参数并返回函数的函数
- en: An Observable connects an Observer to a Producer (Producer is opaque to the
    Observer)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Observable将Observer连接到Producer（Producer对Observer是不透明的）
- en: A Producer is a source of values for an Observable
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产者是Observable的值来源
- en: An Observer is an object that has the `on_next`, `on_error`, and `on_completed`
    methods
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者是一个具有`on_next`、`on_error`和`on_completed`方法的对象
- en: What's a Producer?
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产者是什么？
- en: In a nutshell,A Producer is a source of value for an Observable. Producers can
    be  GUI windows, Timers, WebSockets, DOM trees, Iterators over collections/containers,
    and so on. They can be anything that can be a source of values that can be passed
    on to  OnNext method of the  Observer ( In `RxCpp`, `observer.on_next(value)`.)
    . Of course, values can passed on to Operators,which in turn will be passed on
    to the internal Observer of Operators .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，生产者是Observable的值来源。生产者可以是GUI窗口、定时器、WebSockets、DOM树、集合/容器上的迭代器等。它们可以是任何可以成为值来源并传递给Observer的值的东西（在`RxCpp`中，`observer.on_next(value)`）。当然，值可以传递给操作符，然后传递给操作符的内部观察者。
- en: Hot versus Cold Observables
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热Observable与冷Observable
- en: 'In most  examples in the previous chapter, we saw that Producers were created
    in Observable functions. A Producer can also  be created outside an Observable
    function, and a reference to the Producer can be put inside the Observable function.
    An Observable that refers to a Producer which was created outside its scope is
    called a hot Observable. Any Observable where we created a Producer instance inside
    (an Observable)  is called a cold Observable. To make matters clear, let''s write
    a program to demonstrate a cold Observable:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的大多数示例中，我们看到Producers是在Observable函数中创建的。生产者也可以在Observable函数之外创建，并且可以将对生产者的引用放在Observable函数内。引用到在其范围之外创建的生产者的Observable称为热Observable。任何我们在Observable中创建了生产者实例的Observable称为冷Observable。为了搞清楚问题，让我们编写一个程序来演示冷Observable：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the above code, the interval method created a cold Observable, as the Producer
    for the event Stream is instantiated int the `interval` function. A cold Observable
    will emit data when a Subscriber or an Observer is attached to it. Even if there
    is a delay in subscription between two Observers, the result will be consistent.
    This means both Observers we will get all the data emitted by the Observable:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，interval方法创建了一个冷Observable，因为事件流的生产者是在`interval`函数中实例化的。当订阅者或观察者附加到冷Observable时，它将发出数据。即使在两个观察者之间订阅存在延迟，结果也将是一致的。这意味着我们将获得Observable发出的所有数据的两个观察者：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output emitted by the program is given below. For each run, the order of
    content in the console may change, as we are scheduling the execution of  Observer
    methods in the same thread. But, there won''t be any data loss, due to the delay
    in subscription:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 程序发出的输出如下。对于每次运行，控制台中内容的顺序可能会改变，因为我们在同一线程中调度执行观察者方法。但是，由于订阅延迟，不会有数据丢失：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Hot Observables
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热Observable
- en: 'We can convert a cold Observable into a hot Observable by invoking the Observable''s
    `publish` method. The consequence of converting a cold Observable to a hot Observable
    will be the fact that data can be missed by later subscriptions. A hot Observable
    emits data whether there is a subscription or not. The following program demonstrates
    the behavior:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用Observable的`publish`方法将冷Observable转换为热Observable。将冷Observable转换为热Observable的后果是数据可能会被后续的订阅所错过。热Observable会发出数据，无论是否有订阅。以下程序演示了这种行为：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the next example, we will take a look at the `publish_synchronized` mechanism
    supported by  the  `RxCpp library.` From a programming interface perspective,
    this is just a small change. Take a look at the following program:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将看一下`RxCpp库`支持的`publish_synchronized`机制。从编程接口的角度来看，这只是一个小改变。看一下以下程序：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the program is as follows. We can see that the output is well
    synchronized, that is, the output is displayed in the correct order:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下。我们可以看到输出很好地同步，即输出按正确的顺序显示：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Hot Observables and the replay mechanism
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热可观察对象和重放机制
- en: 'A hot Observable emits data, whether there is a Subscriber available or not.
    This can be an issue in scenarios where we expect, subscribers to receive data
    consistently. There is a mechanism within reactive programming to cache data so
    that later subscribers can be notified of the data available with an Observable.
    We can use the `.replay()` method to create such an Observable. Let''s write a
    program that will demonstrate the replay mechanism, which is useful when writing
    programs involving hot Observables:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 热可观察对象会发出数据，无论是否有订阅者可用。这在我们期望订阅者持续接收数据的情况下可能会成为问题。在响应式编程中有一种机制可以缓存数据，以便稍后的订阅者可以被通知可观察对象的可用数据。我们可以使用`.replay()`方法来创建这样的可观察对象。让我们编写一个程序来演示重放机制，这在编写涉及热可观察对象的程序时非常有用：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When writing reactive programs, you really need to understand the semantic difference
    between hot and cold Observables. We have only touched up on  some aspects of
    this topic. Please refer to the RxCpp documentation and ReactiveX documentation
    to learn more. about hot and cold Observables There are countless articles available
    on internet about this topic.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写响应式程序时，您确实需要了解热和冷可观察对象之间的语义差异。我们只是涉及了这个主题的一些方面。请参考RxCpp文档和ReactiveX文档以了解更多关于热和冷可观察对象的信息。互联网上有无数关于这个主题的文章。
- en: Observers and their variants (Subscribers)
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者及其变体（订阅者）
- en: 'An Observer subscribes to an Observable and waits for events to be notified.
    Observers were already covered in the previous chapter. Hence, we will be focusing
    on Subscribers, which are a combination of Observers and subscriptions. A  Subscriber
    has the facility to unsubscribe from the Observer,where as  with a "vanilla" 
    Observer, you can only subscribe. The following program explain these concepts
    very well:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者订阅可观察对象并等待事件通知。观察者已经在上一章中介绍过了。因此，我们将专注于订阅者，它们是观察者和订阅的组合。订阅者有取消订阅观察者的功能，而“普通”观察者只能订阅。以下程序很好地解释了这些概念：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For writing nontrivial programs with concurrency and dynamism (asynchronous
    time varying events), the ability to subscribe and unsubscribe can be very handy.
    Take a deeper look at the topic by consulting the RxCpp documentation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用并发和动态性（异步时间变化事件）编写复杂程序，订阅和取消订阅的能力非常方便。通过查阅RxCpp文档来更深入地了解这个主题。
- en: Subjects
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题
- en: 'A  Subject is an entity that is both an Observer and an Observable. It helps
    to relay notifications from one Observable (typically)  to a set of Observers.
    We can implement sophisticated techniques such as the caching and buffering of
    data using a Subject. We can also use a Subject to transform a hot Observable
    into a cold Observable. There are four variants of subjects implemented in `RxCpp
    library.` They are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 主题是既是观察者又是可观察对象的实体。它有助于从一个可观察对象（通常）传递通知给一组观察者。我们可以使用主题来实现诸如缓存和数据缓冲之类的复杂技术。我们还可以使用主题将热可观察对象转换为冷可观察对象。在`RxCpp库`中实现了四种主题的变体。它们如下：
- en: '`SimpleSubject`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimpleSubject`'
- en: '`BehaviorSubject`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为主题
- en: '`ReplaySubject`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReplaySubject`'
- en: '`SynchronizeSubject`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SynchronizeSubject`'
- en: Let's write a simple program that will demonstrate the work of a Subject. The
    code listing will demonstrate how we can push data to a Subject and retrieve them
    using the Observer side of the Subject.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的程序来演示主题的工作。代码清单将演示如何将数据推送到主题并使用主题的观察者端检索它们。
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`The BehaviorSubject` is a variant of Subject that stores the last emitted
    (current) value as part of its implementation. Any new Subscriber will get the
    *current value* immediately. Otherwise, it behaves like a normal Subject. The `BehaviorSubject`
    is also called a property or a cell in some realm. It is useful in scenarios where
    we update a particular cell or memory area with a series of data, such as in a
    transaction context. Let''s write a program that demonstrates the workings of
    `BehaviorSubject`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`BehaviorSubject`是Subject的一种变体，它作为其实现的一部分存储最后发出的（当前）值。任何新的订阅者都会立即获得*当前值*。否则，它的行为就像一个普通的Subject。`BehaviorSubject`在某些领域中也被称为属性或单元。它在我们更新特定单元或内存区域的一系列数据时非常有用，比如在事务上下文中。让我们编写一个程序来演示`BehaviorSubject`的工作原理：'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`The ReplaySubject` is a variant of Subject that stores data that has already
    been emitted. We can specify parameters to indicate how many values have to be
    retained by a Subject. This is very handy when dealing with hot Observables. The
    function prototypes  of various replay overloads are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReplaySubject`是Subject的一种变体，它存储已经发出的数据。我们可以指定参数来指示主题必须保留多少个值。在处理热可观察对象时，这非常方便。各种重放重载的函数原型如下：'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s write a program to understand the semantics of `ReplaySubject`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序来理解`ReplaySubject`的语义：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We have covered three variants of a Subject in this section. The primary use
    case is harnessing events and data from different sources by using the Observable
    interface and allowing a group of subscribers to consume the harnessed data. A`SimpleSubject`
    can act as both an Observable and an Observer to process a stream of values. The `BehaviorSubject`
    is useful for monitoring changes in a property or variable over a period of time
    and a`ReplaySubject` will help you to avoid loss of data due to latency in a subscription.
    Finally, a `SynchronizeSubject` is a subject that has synchronization logic built
    into its implementation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了主题的三种变体。主要用例是通过使用可观察接口从不同来源获取事件和数据，并允许一组订阅者消耗获取的数据。`SimpleSubject`可以作为可观察对象和观察者来处理一系列值。`BehaviorSubject`用于监视一段时间内属性或变量的变化，而`ReplaySubject`将帮助您避免由于订阅延迟而导致的数据丢失。最后，`SynchronizeSubject`是一个具有同步逻辑的主题。
- en: Schedulers
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度器
- en: The RxCpp library has got a declarative threading mechanism, thanks to the robust
    scheduling subsystem packaged with it. From an Observable, data can be streamed
    through different paths along the change propagation graph. By giving hints to
    the Stream processing pipeline, we can schedule the execution of Operators and
    Observer methods in the same thread,different threads,  or a background thread.
    This helps to capture the intent of the programmer much better.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxCpp`库拥有一个声明性的线程机制，这要归功于其内置的强大调度子系统。从一个Observable中，数据可以通过不同的路径流经变化传播图。通过给流处理管道提供提示，我们可以在相同线程、不同线程或后台线程中安排操作符和观察者方法的执行。这有助于更好地捕捉程序员的意图。'
- en: 'The declarative scheduling model in RxCpp is possible because of the immutability
    of the Streams in an Operator''s implementation. A Stream Operator takes an Observable
    as a parameter and returns a fresh Observable as the result. The input parameter
    is not mutated at all ( the behavior is implicitly expected from the Operator
    implementation). This helps in out-of-order execution. The scheduling subsystem
    of RxCpp contains the following constructs: ( specific to Rxcpp v2)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxCpp`中的声明性调度模型是可能的，因为操作符实现中的流是不可变的。流操作符将一个Observable作为参数，并返回一个新的Observable作为结果。输入参数根本没有被改变（这种行为从操作符的实现中隐含地期望）。这有助于无序执行。`RxCpp`的调度子系统包含以下构造（特定于Rxcpp
    v2）：'
- en: Scheduler
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度程序
- en: Worker
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Worker
- en: Coordination
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调
- en: Coordinator
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调员
- en: Schedulable
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可调度的
- en: TimeLine
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间线
- en: 'The Version 2 of RxCpp borrows its scheduling architecture from the `RxJava`
    system. It relies on Scheduler and Worker idioms used by `RxJava`. Here are some
    important facts about Scheduler:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxCpp`的第2版从`RxJava`系统中借用了其调度架构。它依赖于`RxJava`使用的调度程序和Worker习语。以下是关于调度程序的一些重要事实：'
- en: The Scheduler has a timeline.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度程序有一个时间线。
- en: The Scheduler can create lot of Workers in the timeline.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度程序可以在时间线上创建许多Worker。
- en: The Worker owns a queue of schedulable in the timeline.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Worker拥有时间线上的可调度队列。
- en: The `schedulable` owns a function (often called `Action`) and has a lifetime.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schedulable`拥有一个函数（通常称为`Action`）并拥有生命周期。'
- en: A `Coordination` functions as a  factory for a coordinator and has a Scheduler.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Coordination`函数作为协调员的工厂，并拥有一个调度程序。'
- en: 'Every Coordinator has a Worker and is a factory for the following:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个协调员都有一个Worker，并且是以下内容的工厂：
- en: Coordinated `schedulable`
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调的`schedulable`
- en: Coordinated Observables and subscribers
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调的Observables和订阅者
- en: 'We have been using Rx Schedulers in our programs, without bothering about how
    they work under the hood. Let''s write a toy program, which will help us understand
    how scheduling works under the hood:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在程序中使用Rx调度程序，而不用担心它们在幕后是如何工作的。让我们编写一个玩具程序，来帮助我们理解调度程序在幕后是如何工作的：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In `RxCpp`, all Operators that take multiple streams as input, or deal with
    tasks that have a bearing on time, take a `Coordination` function as a parameter.
    Some of the `Coordination` functions using a particular Scheduler are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RxCpp`中，所有接受多个流作为输入或涉及对时间有影响的任务的操作符都将`Coordination`函数作为参数。一些使用特定调度程序的`Coordination`函数如下：
- en: '`identity_immediate()`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`identity_immediate()`'
- en: '`identity_current_thread()`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`identity_current_thread()`'
- en: '`identity_same_worker(worker w)`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`identity_same_worker(worker w)`'
- en: '`serialize_event_loop()`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serialize_event_loop()`'
- en: '`serialize_new_thread()`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serialize_new_thread()`'
- en: '`serialize_same_worker(worker w)`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serialize_same_worker(worker w)`'
- en: '`observe_on_event_loop()`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`observe_on_event_loop()`'
- en: '`observe_on_new_thread()`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`observe_on_new_thread()`'
- en: 'In the previous program, we manually scheduled an Action (which, in fact, is
    nothing but a lambda). Let''s move on to the declarative aspects of the Scheduler.
    We will write a program that will schedule tasks using a `Coordination` function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们手动安排了一个操作（实际上只是一个lambda）。让我们继续调度程序的声明方面。我们将编写一个使用`Coordination`函数安排任务的程序：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We created a hot Observable using the replay mechanism to take care of the late
    subscription by some Observers. We also created a Worker to do the scheduling
    for subscription and to connect the Observers with the Observable. The previous
    program demonstrates how the Scheduler works in `RxCpp`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用重放机制创建了一个热Observable来处理一些观察者的延迟订阅。我们还创建了一个Worker来进行订阅的调度，并将观察者与Observable连接起来。前面的程序演示了`RxCpp`中调度程序的工作原理。
- en: ObserveOn versus SubscribeOn
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ObserveOn与SubscribeOn
- en: 'The `ObserveOn` and `SubscribeOn` operators behave in a different manner, and
    this has been a source of confusion for reactive programming newbies. The `ObserveOn`
    operator changes the thread of the Operators and Observers below it. In the case
    of `SubscribeOn`, it affects Operators and methods that are above and below it
    as well. The following program demonstrates subtle changes in the runtime  behavior 
    of a program, caused by the way the `SubscribeOn` and `ObserveOn` operators behave.
    Let''s write a program that uses the `ObserveOn` operator:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObserveOn`和`SubscribeOn`操作符的行为方式不同，这一直是反应式编程新手困惑的来源。`ObserveOn`操作符改变了其下方的操作符和观察者的线程。而`SubscribeOn`则影响其上方和下方的操作符和方法。以下程序演示了`SubscribeOn`和`ObserveOn`操作符的行为方式对程序运行时行为的微妙变化。让我们编写一个使用`ObserveOn`操作符的程序：'
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前述程序的输出如下：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the preceding program clearly shows that map worked in the primary
    thread and the `subscribe` methods got scheduled in a secondary thread. This clearly
    shows that `ObserveOn` only worked on Operators and Subscribers below it. Let''s
    write a more or less identical program that uses the `SubscribeOn` operator instead
    of the `ObserveOn` operator. Take a look at this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前述程序的输出清楚地显示了`map`在主线程中工作，而`subscribe`方法在次要线程中被调度。这清楚地表明`ObserveOn`只对其下方的操作符和订阅者起作用。让我们编写一个几乎相同的程序，使用`SubscribeOn`操作符而不是`ObserveOn`操作符。看一下这个：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前述程序的输出如下：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output of the preceding program shows that both map and subscription methods
    worked in the secondary thread. This clearly shows that `SubscribeOn` changes
    the threading behavior of items before and after it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前述程序的输出显示map和订阅方法都在次要线程中工作。这清楚地显示了`SubscribeOn`改变了它之前和之后的项目的线程行为。
- en: The RunLoop Scheduler
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RunLoop调度程序
- en: 'The RxCpp library does not have a notion of  built-in main thread Scheduler.
    The closest you can do is to leverage the `run_loop` class to simulate scheduling
    in the main thread. In the following program, the Observable executes in a background
    thread, and the subscription methods run in the main thread. We are using `subscribe_on`
    and `observe_on` to achieve this objective:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: RxCpp库没有内置的主线程调度程序的概念。你能做的最接近的是利用`run_loop`类来模拟在主线程中进行调度。在下面的程序中，Observable在后台线程执行，订阅方法在主线程运行。我们使用`subscribe_on`和`observe_on`来实现这个目标：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前述程序的输出如下：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can see that map was scheduled in the worker thread and subscription methods
    were executed in the main thread. This is enabled because of the judicious placement
    of the subscribe_on and observe_on  Operators, which we covered in the previous
    section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到map被调度在工作线程中，订阅方法在主线程中执行。这是因为我们巧妙地放置了subscribe_on和observe_on运算符，这是我们在前一节中介绍的。
- en: Operators
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: 'An Operator is a function that applies on an Observable to produce a new Observable.
    In the process, the original Observable is not mutated  and can be considered 
    as  a pure function. We have already covered lot of Operators in our  sample programs
    that we have written. In [Chapter 10](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=79&action=edit#post_86), *Creating
    Custom Operators in Rxcpp*, we will learn how to create custom Operators which
    work on Observables. The fact that an Operator does not mutate an (input) Observable
    is the  reason why declarative scheduling works in the Rx programming model. Rx
    Operators can be categorized as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符是应用于Observable以产生新的Observable的函数。在这个过程中，原始Observable没有被改变，并且可以被认为是一个纯函数。我们已经在我们编写的示例程序中涵盖了许多运算符。在[第10章](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=79&action=edit#post_86)中，*在Rxcpp中创建自定义运算符*，我们将学习如何创建在Observables上工作的自定义运算符。运算符不改变（输入）Observable的事实是声明式调度在Rx编程模型中起作用的原因。Rx运算符可以被分类如下：
- en: Creation Operators
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建运算符
- en: Transformation Operators
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变换运算符
- en: Filtering Operators
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤运算符
- en: Combining Operators
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合运算符
- en: Error-handling Operators
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理运算符
- en: Utility Operators
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实用运算符
- en: Boolean Operators
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔运算符
- en: Mathematical Operators
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学运算符
- en: There are some more Operators available that do not fall into  any of these
    categories. We will provde a list of  key Operators from preceding categories
    , as a table for quick reference. As a developer one can pick Operators depending
    on the context, by consulting the tables given below
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些更多的运算符不属于这些类别。我们将提供一个来自前述类别的关键运算符列表，作为一个快速参考的表格。作为开发人员，可以根据上面给出的表格来选择运算符，根据上下文来选择运算符。
- en: Creational Operators
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建运算符
- en: 'These Operators will help a developer  to create various kind of Observables,from 
    the input data. We have already demonstrated the use of create, from, interval,
    and range Operators in our example code. Consult those examples and the RxCpp
    documentation to learn more about them. A table containing some of the Operators
    are given below :'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符将帮助开发人员从输入数据中创建各种类型的Observables。我们已经在我们的示例代码中演示了create、from、interval和range运算符的使用。请参考这些示例和RxCpp文档以了解更多信息。下面给出了一张包含一些运算符的表格：
- en: '| **Observables** | **Description** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '**Observables** | **描述**'
- en: '| `create` | Create an observable by calling the Observer method programmatically
    |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '`create` | 通过以编程方式调用Observer方法创建一个Observable'
- en: '| `defer` | Create a fresh Observable for each Observer/Subscriber |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '`defer` | 为每个Observer/Subscriber创建一个新的Observable'
- en: '| `empty` | Create an Observable that does not emit anything (emits only on_completed)
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '`empty` | 创建一个不发出任何内容的Observable（只在完成时发出）'
- en: '| `from` | Create an Observable based on the parameters (Polymorphic) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '`from` | 根据参数创建一个Observable（多态）'
- en: '| `interval` | Create an Observable that emits a sequence of values in a time
    interval |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '`interval` | 创建一个在时间间隔内发出一系列值的Observable'
- en: '| `just` | Create an Observable that emits a single value |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '`just` | 创建一个发出单个值的Observable'
- en: '| `range` | Create an Observable that emits a range of values |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '`range` | 创建一个发出一系列值的Observable'
- en: '| `never` | Create an Observable that never emits anything |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '`never` | 创建一个永远不发出任何内容的Observable'
- en: '| `repeat` | Create an Observable that repeats a stream of values |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '`repeat` | 创建一个重复发出值的Observable'
- en: '| `timer` | Create an Observable that emits a value after a delay factor, which
    can be specified as a parameter |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '`timer` | 创建一个在延迟因子之后发出值的Observable，可以将其指定为参数'
- en: '| `throw` | Create an Observable that emits an error |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '`throw` | 创建一个发出错误的Observable'
- en: Transformation Operators
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变换运算符
- en: These Operators help developers to create a new Observable without modifying
    the source Observable. They act on individual items in the source Observable by
    applying a lambda or a functor on them. A table containing some of the most useful
    transformation Operators are given below.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符帮助开发人员创建一个新的Observable，而不修改源Observable。它们通过在源Observable上应用lambda或函数对象来作用于源Observable中的单个项目。下面给出了一张包含一些最有用的变换运算符的表格。
- en: '| **Observables** | **Description** |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '**Observables** | **描述**'
- en: '| `buffer` | Observable that collects values in the past and emits them when
    signaled |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '`buffer` | 收集过去的值并在收到信号时发出的Observable'
- en: '| `flat_map` | Observable that emits results of applying a function to a pair
    of values emitted by the source Observable and the collection Observable |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '`flat_map` | 发出应用于源Observable和集合Observable发出的一对值的函数的结果的Observable'
- en: '| `group_by` | Observable that helps to group values from an Observable |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '`group_by` | 帮助从Observable中分组值的Observable'
- en: '| `map` | Observable that emits items from the source Observable, transformed
    by the specified function |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `map` | 通过指定的函数转换源Observable发出的项目的Observable |'
- en: '| `scan` | Observable that emits results of each call to the accumulator function
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `scan` | 发出累加器函数的每次调用的结果的Observable |'
- en: '| `window` | Observable that emits connected, non-overlapping windows of items.
    Each window will contain a particular number of item, which is given as a parameter.
    The parameter name is count.  |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `window` | 发出连接的、不重叠的项目窗口的Observable。 每个窗口将包含特定数量的项目，该数量作为参数给出。 参数名为count。
    |'
- en: Filtering Operators
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤运算符
- en: 'The ability to filter Streams is a common activity in Stream processing. It
    is not unusual that the Rx programming model defines a lot of Operators in the
    filtering category. Filtering operators are mostly predicate functions or lambdas.
    The following table contains a list of filtering  Operators:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤流的能力是流处理中的常见活动。 Rx编程模型定义了许多过滤类别的运算符并不罕见。 过滤运算符主要是谓词函数或lambda。 以下表格包含过滤运算符的列表：
- en: '| **Observables** | **Description** |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **Observables** | **Description** |'
- en: '| `debounce` | Observable that emits an item if a particular time span has
    passed without emitting another item from the source Observable |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `debounce` | 如果经过一段特定的时间间隔而没有从源Observable发出另一个项目，则发出一个项目的Observable |'
- en: '| `distinct` | Observable that emits those items from the source Observable
    that are distinct |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `distinct` | 发出源Observable中不同的项目的Observable |'
- en: '| `element_at` | Observable that emits an item located at a specified index
    location |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `element_at` | 发出位于指定索引位置的项目的Observable |'
- en: '| `filter` | Observable that emits only those items emitted by the source Observable
    that the filter evaluates as true |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `filter` | 只发出由过滤器评估为true的源Observable发出的项目的Observable |'
- en: '| `first` | Observable that emits only the very first item emitted by the source
    Observable |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `first` | 只发出源Observable发出的第一个项目的Observable |'
- en: '| `ignore_eleements` | Observable that emits a termination notification from
    the source Observable |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `ignore_eleements` | 从源Observable发出终止通知的Observable |'
- en: '| `last` | Observable that emits only the very last item emitted by the source
    Observable |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `last` | 只发出源Observable发出的最后一个项目的Observable |'
- en: '| `sample` | Observable that emits the most recent items emitted by the source
    Observable within a periodic time interval. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `sample` | 在周期时间间隔内发出源Observable发出的最近的项目的Observable |'
- en: '| `skip` | Observable that is identical to the source Observable, except that
    it does not emit the first t items that the source Observable emits |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `skip` | 与源Observable相同的Observable，只是它不会发出源Observable发出的前t个项目 |'
- en: '| `skip_last` | Observable that is identical to the source Observable, except
    that it does not emit the last t items that the source Observable emits |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `skip_last` | 与源Observable相同的Observable，只是它不会发出源Observable发出的最后t个项目 |'
- en: '| `take` | Observable that emits only the first t items emitted by the source
    Observable, or all of the items from the source Observable if that Observable
    emits fewer than t items |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `take` | 只发出源Observable发出的前t个项目，或者如果该Observable发出的项目少于t个，则发出源Observable的所有项目
    |'
- en: '| `take_last` | Observable that emits only the last t items emitted by the
    source Observable |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `take_last` | 只发出源Observable发出的最后t个项目的Observable |'
- en: Combining Operators
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合运算符
- en: 'One of the primary goals of the Rx programming model is to decouple the event
    source from event sinks. Obviously, there is a need for Operators that can combine
    Streams from various sources. The RxCpp library implements a set of such Operators.
    The following table outlines a set of commonly used combining Operators:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Rx编程模型的主要目标之一是将事件源与事件接收器解耦。 显然，需要能够组合来自各种来源的流的运算符。 RxCpp库实现了一组此类运算符。 以下表格概述了一组常用的组合运算符：
- en: '| **Observables** | **Description** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **Observables** | **Description** |'
- en: '| `combine_latest` | When an item is emitted by either of two Observables,
    combine the latest item emitted by each Observable via a specified function and
    emit items based on the results of this function |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `combine_latest` | 当两个Observables中的任一Observable发出项目时，通过指定的函数组合每个Observable发出的最新项目，并根据该函数的结果发出项目
    |'
- en: '| `merge` | This combines multiple Observables into one by merging their emissions
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `merge` | 通过合并它们的发射将多个Observables合并为一个 |'
- en: '| `start_with` | This emits a specified sequence of items before beginning
    to emit the items from the source Observable |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `start_with` | 在开始发出源Observable的项目之前，发出指定的项目序列 |'
- en: '| `switch_on_next` | This converts an Observable that emits Observables into
    a single Observable that emits the items emitted by the most recently emitted
    of those Observables |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `switch_on_next` | 将发出Observables的Observable转换为发出最近发出的Observable发出的项目的单个Observable
    |'
- en: '| `zip` | This combines the emissions of multiple Observables together via
    a specified function and emits single items for each combination based on the
    results of this functions |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `zip` | 通过指定的函数将多个Observables的发射组合在一起，并根据该函数的结果发出每个组合的单个项目 |'
- en: Error-handling Operators
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理运算符
- en: These are operators that help  us to do error recovery when exceptions  occur 
    while pipeline execution is going on.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在管道执行过程中发生异常时帮助我们进行错误恢复的运算符。
- en: '| **Observables** | **Description** |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **Observables** | **Description** |'
- en: '| `Catch` | Not supported by `RxCpp` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `Catch` | `RxCpp`不支持 |'
- en: '| `retry` | An observable that mirrors the source Observable, resubscribing
    to it if it calls `on_error` up to a specified number of retries |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `retry` | 如果调用`on_error`，则会重新订阅源Observable的Observable，最多重试指定次数 |'
- en: Observable utility Operators
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable实用程序运算符
- en: The following is a toolbox of useful  utility Operators for working with Observables:.
    The observe_on and subscribe_on Operators  help us to do declarative scheduling.
    We have already covered them in the previous chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于处理Observables的有用实用程序运算符工具箱： observe_on和subscribe_on运算符帮助我们进行声明式调度。 我们已经在上一章中介绍过它们。
- en: '| **Observables** | **Description** |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| **Observables** | **Description** |'
- en: '| `finally` | Observable that emits the same items as the source Observable,
    then invokes the given action |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `finally` | Observable发出与源Observable相同的项目，然后调用给定的操作 |'
- en: '| `observe_on` | Specify the Scheduler on which an Observer will observe this
    Observable |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `observe_on` | 指定观察者将观察此Observable的调度程序 |'
- en: '| `subscribe` | Operate upon the emissions and notifications from an Observable
    |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `subscribe` | 对Observable的发射和通知进行操作 |'
- en: '| `subscribe_on` | Specify the Scheduler an Observable should use when it is
    subscribed to |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `subscribe_on` | 指定Observable订阅时应使用的调度程序 |'
- en: '| `scope` | Create a disposable resource that has the same lifespan as the
    Observable |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `scope` | 创建与Observable寿命相同的一次性资源 |'
- en: Conditional and Boolean Operators
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件和布尔运算符
- en: 'The Conditional and Boolean Operators  are Operators that evaluate one or more
    Observables or items emitted by Observables:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 条件和布尔运算符是评估一个或多个Observable或Observable发出的项目的运算符：
- en: '| **Observables** | **Description** |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **Observables** | **Description** |'
- en: '| `all` | Observable that emits true if every item emitted by the source Observable
    satisfies a specified condition; otherwise, it emits false |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `all` | 如果源Observable发出的每个项目都满足指定条件，则发出true的Observable；否则，它发出false |'
- en: '| `amb` | Observable that emits  same sequence as whichever of  source Observables
    first emitted an item or sent a termination notification |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `amb` | Observable发出与源Observables中首先发出项目或发送终止通知的相同序列 |'
- en: '| `contains` | An Observable that emits true if the source Observable emitted
    a specified item; otherwise it emits false |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `contains` | 如果源Observable发出了指定的项目，则发出true的Observable；否则发出false |'
- en: '| `default_if_empty` | An Observable that emits true if the source Observable
    emitted a specified item; otherwise it emits false |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `default_if_empty` | 如果源Observable发出了指定的项目，则发出true的Observable；否则发出false |'
- en: '| `sequence_equal` | Observable that emits true only if both sequences terminate
    normally after emitting the same sequence of items in the same order; otherwise,
    it will emit false |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `sequence_equal` | 只有在发出相同顺序的相同项目序列后正常终止时，Observable才会发出true；否则，它将发出false
    |'
- en: '| `skip_until` | Discard items emitted by an Observable until a second Observable
    emits an item |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `skip_until` | 直到第二个Observable发出项目之前，丢弃由Observable发出的项目 |'
- en: '| `skip_while` | Discard items emitted by an Observable until a specified condition
    becomes false |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `skip_while` | 直到指定条件变为false后，丢弃由Observable发出的项目 |'
- en: '| `take_until` | Discard items emitted by an Observable after a second Observable
    emits an item or terminates |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `take_until` | 在第二个Observable发出项目或终止后，丢弃由Observable发出的项目 |'
- en: '| `take_while` | Discard items emitted by an Observable after a specified condition
    becomes false |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `take_while` | 在指定条件变为false后，丢弃由Observable发出的项目 |'
- en: Mathematical and Aggregate operators
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学和聚合运算符
- en: 'These Mathematical and Aggregate  Operators are a category of Operators which 
    operate on an  entire sequence of items emitted by an Observable: They basically
    reduce an Observable<T> to some value of the type T. They do not return  an  Observable.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数学和聚合运算符是一类操作符，它们对Observable发出的整个项目序列进行操作：它们基本上将Observable<T>减少为类型T的某个值。它们不会返回Observable。
- en: '| **Observables** | **Description** |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **Observables** | **Description** |'
- en: '| `average` | Calculate the average of numbers emitted by an Observable and
    emit this average |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `average` | 计算Observable发出的数字的平均值并发出此平均值 |'
- en: '| `concat` | Emit the emissions from two or more Observables without interleaving
    them |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `concat` | 发出两个或多个Observable的发射，而不对它们进行交错 |'
- en: '| `count` | Count the number of items emitted by the source Observable and
    emit only this value |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `count` | 计算源Observable发出的项目数量并仅发出此值 |'
- en: '| `max` | Determine and emit the maximum-valued item emitted by an Observable
    |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `max` | 确定并发出Observable发出的最大值项目 |'
- en: '| `min` | Determine and emit the minimum-valued item emitted by an Observable
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `min` | 确定并发出Observable发出的最小值项目 |'
- en: '| `reduce` | Apply a function to each item emitted by an Observable, sequentially,
    and emit the final value |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `reduce` | 对Observable发出的每个项目依次应用函数，并发出最终值 |'
- en: '| `sum` | Calculate the sum of numbers emitted by an Observable and emit this
    sum |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `sum` | 计算Observable发出的数字的总和并发出此总和 |'
- en: Connectable Observable Operators
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可连接的Observable运算符
- en: The Connectable Observable are special Observables that have more precisely
    controlled subscription dynamics. The following table lists some key Operators
    with advanced subscription semantics
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 可连接的Observable是具有更精确控制的订阅动态的特殊Observable。以下表格列出了一些具有高级订阅语义的关键运算符
- en: '| **Observables** | **Description** |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| **Observables** | **Description** |'
- en: '| `connect` | Instruct a Connectable Observable to begin emitting items to
    its subscribers |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `connect` | 指示可连接的Observable开始向其订阅者发出项目 |'
- en: '| `publish` | Convert an ordinary Observable into a Connectable Observable
    |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `publish` | 将普通Observable转换为可连接的Observable |'
- en: '| `ref_count` | Make a Connectable Observable behave like an ordinary Observable
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `ref_count` | 使可连接的Observable表现得像普通的Observable |'
- en: '| `replay` | Ensure that all Observers see the same sequence of emitted items,
    even if they subscribe after the Observable has begun emitting items. This Operator
    is used with hot Observables |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `replay` | 确保所有观察者看到相同的发出项目序列，即使它们在Observable开始发出项目后订阅。此运算符与热Observable一起使用
    |'
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we gained an understanding of how pieces of the Rx programming
    model fits together. We started with Observables and quickly moved on to the topic
    of hot and cold Observables. Then, we covered the subscription mechanism and its
    use. We then moved on to the important topic of Subjects and understood how a
    number of variants of Scheduler implementation works. Finally, we classified various
    Operators available with the RxCpp system. In the next chapter, we will learn
    how we can use the knowledge gained so far, to write GUI programs in a reactive
    manner, using the Qt framework.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Rx编程模型的各个部分是如何配合的。我们从Observables开始，迅速转移到热和冷Observables的主题。然后，我们讨论了订阅机制及其使用。接着，我们转向了Subjects这一重要主题，并了解了多种Scheduler实现的工作方式。最后，我们对RxCpp系统中提供的各种操作符进行了分类。在下一章中，我们将学习如何利用迄今为止所学的知识，以一种反应式的方式使用Qt框架编写GUI程序。
