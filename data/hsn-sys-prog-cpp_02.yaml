- en: Learning the C, C++17, and POSIX Standards
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习C、C++17和POSIX标准
- en: As stated in [Chapter 1](af8579a6-71c4-4315-818c-733257355bfe.xhtml), *Getting
    Started with System Programming*, system programming is the act of making system
    calls to perform various actions in coordination with the underlying operating
    system. Each operating system has its own set of system calls, and how these system
    calls are made is different.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](af8579a6-71c4-4315-818c-733257355bfe.xhtml)所述，*开始系统编程*，系统编程是通过进行系统调用与底层操作系统协调来执行各种操作的行为。每个操作系统都有自己的一套系统调用，以及这些系统调用的执行方式也各不相同。
- en: To prevent the system programmer from having to rewrite their program for each
    different operating system, several standards have been put into place that wrap
    the operating system's ABI with a well-defined API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止系统程序员不得不为每个不同的操作系统重新编写他们的程序，已经制定了几个标准，这些标准用一个明确定义的API包装了操作系统的ABI。
- en: In this chapter, we will discuss three standards—the C standard, the C++ standard,
    and the POSIX standard. The C and POSIX standards provide the fundamental language
    syntax and APIs that wrap an operating system's ABI. Specifically, the C standard
    defines program linking and execution, the standard C syntax (which a number of
    higher-level languages, such as C++, are based on), and the C libraries that provide
    the ABI-to-API wrappers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论三个标准——C标准、C++标准和POSIX标准。C和POSIX标准提供了包装操作系统ABI的基本语言语法和API。具体来说，C标准定义了程序链接和执行，标准C语法（许多高级语言，如C++，都是基于此），以及提供ABI到API包装的C库。
- en: The C libraries can be thought of as a subset of the greater POSIX standard,
    which defines a much larger subset of APIs, including, but not limited to, filesystem,
    network, and threading libraries.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: C库可以被视为更大的POSIX标准的子集，后者定义了更大的API子集，包括但不限于文件系统、网络和线程库。
- en: Finally, the C++ standard defines the C++ syntax, program linking and execution,
    and the C++ libraries that provide higher-level abstractions of the C and POSIX
    standards. The majority of this book will revolve around these standard APIs and
    how to use them with C++17.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，C++标准定义了C++语法、程序链接和执行，以及提供C和POSIX标准更高级抽象的C++库。本书的大部分内容将围绕这些标准API以及如何在C++17中使用它们。
- en: 'This chapter has the following objectives:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有以下目标：
- en: Learning about the C, C++, and POSIX standards
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习C、C++和POSIX标准
- en: Understanding program linking and execution, and the differences between C and
    C++
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解程序链接和执行，以及C和C++之间的区别
- en: Providing a brief overview of the facilities these standards provide, each of
    which will be discussed in greater detail later in the book
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要概述这些标准提供的功能，每个功能将在本书的后面更详细地讨论
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to follow the examples in this chapter, the reader must have:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章的示例，读者必须具备：
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够编译和执行C++17的基于Linux的系统（例如，Ubuntu 17.10+）
- en: GCC 7+
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 7+
- en: CMake 3.6+
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.6+
- en: An internet connection
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: To download all the code in this chapter, including the examples and code snippets,
    go to the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter02).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载本章中的所有代码，包括示例和代码片段，请转到以下链接：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter02)。
- en: Beginning with the C standard language
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从C标准语言开始
- en: The C programming language is one of the oldest languages available. Unlike
    other higher-level languages, C is similar enough to assembly language programming,
    while still providing some high-level programming abstractions, that it has become
    a firm favorite among system, embedded, and kernel-level programmers alike.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C编程语言是最古老的语言之一。与其他高级语言不同，C足够类似汇编语言编程，同时又提供了一些高级编程抽象，因此成为系统、嵌入式和内核级程序员的首选。
- en: Almost every major operating system is rooted in C. In addition, most higher-level
    languages, including C++, build upon C to provide their higher-level constructs,
    and therefore still require some of the components of the C standard.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个主要的操作系统都源自C。此外，大多数高级语言，包括C++，都是基于C构建其高级构造，因此仍然需要C标准的一些组件。
- en: The C standard is a huge standard that is managed by the **International Organization
    for Standardization** (**ISO**). We assume the reader has some basic knowledge
    of the C standard and how to write C code: [http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C标准是由**国际标准化组织**（**ISO**）管理的一个庞大标准。我们假设读者对C标准和如何编写C代码有一些基本知识：[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf)。
- en: For these reasons, the goal of this section is to discuss some topics that are
    discussed in lesser detail in other books, as well as portions of the C standard
    that are relevant to this book and system programming, but are missing from the
    other chapters.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本节的目标是讨论一些在其他书中讨论得较少的主题，以及本书和系统编程相关的C标准的部分，但在其他章节中缺失。
- en: For additional information on the C programming language and how to write C
    programs, please see the *Further reading* section of this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有关C编程语言和如何编写C程序的更多信息，请参阅本章的*进一步阅读*部分。
- en: How the standard is organized
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准的组织方式
- en: 'The specification is broken up into three sections:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 该规范分为三个部分：
- en: Environment
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境
- en: Language
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言
- en: Libraries
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库
- en: Let's briefly discuss the purpose of each section. After that, we will discuss
    specific portions of the C standard that are relevant to system programming but
    are not discussed elsewhere in this book.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论每个部分的目的。之后，我们将讨论C标准的特定部分，这些部分与系统编程相关，但在本书的其他地方没有讨论。
- en: Environment
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境
- en: The Environment section of the standard provides information that is mainly
    needed by compiler writers to better understand how to create a compiler for C.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的环境部分提供了主要由编译器编写者需要的信息，以更好地理解如何为C创建编译器。
- en: It describes the minimum limitations the compiler must adhere to (such as the
    minimum number of nested `if()` statements that must be supported), as well as
    how programs are linked and started.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它描述了编译器必须遵守的最低限制（例如必须支持的最小嵌套`if()`语句数量），以及程序是如何链接和启动的。
- en: In this chapter, we will discuss program linking and execution to provide a
    better understanding of what is required to create a C program.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论程序链接和执行，以更好地理解创建C程序所需的内容。
- en: Language
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言
- en: The Language section of the standard provides all the details associated with
    the C syntax, including what a variable is, how to write a function, the difference
    between a `for()` loop and a `while()` loop, and all of the operators that are
    supported and how they work.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的语言部分提供了与C语法相关的所有细节，包括变量是什么，如何编写函数，`for()`循环和`while()`循环之间的区别，以及支持的所有运算符以及它们的工作原理。
- en: This book assumes the reader has general knowledge of this section of the standard,
    and only touches on system programming-specific nuances of the standard C syntax
    that the reader is likely to run into (such as issues associated with pointers).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书假设读者对标准的这一部分有一般的了解，并且只涉及标准C语法的系统编程特定细微差别，读者可能会遇到的问题（比如与指针相关的问题）。
- en: Libraries
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库
- en: The Libraries section of the standard describes all of the library facilities
    that are provided by the standard C language. This includes facilities such as
    outputting strings to `stdout`, allocating memory, and working with time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的库部分描述了标准C语言提供的所有库设施。这包括向`stdout`输出字符串、分配内存和处理时间等设施。
- en: System programming largely revolves around these library facilities, and the
    bulk of this book will focus on these libraries, what they provide, and how to
    use them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 系统编程主要围绕这些库设施展开，本书的大部分内容将集中在这些库设施上，它们提供了什么以及如何使用它们。
- en: How a C program starts
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C程序的启动方式
- en: 'One part of the standard that is relevant to system programming, but is not
    as widely discussed in literature, is how a C program starts. A common misconception
    is that a C program starts with the following two entry points:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 标准中与系统编程相关但在文献中没有被广泛讨论的一部分是C程序如何启动。一个常见的误解是C程序从以下两个入口点开始：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although this is, in fact, the first function call that a C programmer provides,
    it is not the first function called when your C program starts. It is not the
    first code that executes either, nor is it the first code provided by the user
    that executes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这实际上是C程序员提供的第一个函数调用，但它并不是C程序启动时调用的第一个函数。它也不是执行的第一段代码，也不是用户提供的第一段执行的代码。
- en: A lot of work is carried out, both by the operating system and the standard
    C environment, as well as the user, prior to the `main()` function ever executing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数执行之前，操作系统和标准C环境以及用户都进行了大量的工作。
- en: 'Let''s look at how your compiler creates a simple `Hello World\n` example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看编译器如何创建一个简单的`Hello World\n`示例：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To better understand the start up process of a C program, let''s look at how
    this simple program is compiled:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解C程序的启动过程，让我们看看这个简单程序是如何编译的：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By adding the `-v` option to GCC, we are able to see each step the compiler
    takes to compile our simple `Hello World\n` program.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向GCC添加`-v`选项，我们可以看到编译器编译我们的简单的`Hello World\n`程序所采取的每一步。
- en: 'To start, the compiler converts the program to a format that can be processed
    by `gnu-as`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，编译器将程序转换为可以由`gnu-as`处理的格式：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Not only can you see how the initial compilation is performed, but you can see
    the default flags that your operating system provides.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以看到初始编译是如何执行的，还可以看到操作系统提供的默认标志。
- en: 'Next, the compiler converts the output to an object file, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编译器将输出转换为一个目标文件，如下所示：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, the last step links the resulting object files into a single executable
    using the `collect2` utility, which is a wrapper around the linker:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一步使用`collect2`实用程序将生成的目标文件链接成一个单独的可执行文件，这是一个围绕链接器的包装器：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are a couple of important things to take note of here with respect to
    how the program is linked:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个重要的事情需要注意关于程序是如何链接的：
- en: '`-lc`: The use of this flag tells the linker to link in `libc`. Like the rest
    of the libraries being discussed here, we didn''t tell the compiler to link against
    `libc`. By default, GCC links `libc` for us.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-lc`：使用此标志告诉链接器链接`libc`。像这里讨论的其他库一样，我们没有告诉编译器链接`libc`。默认情况下，GCC会为我们链接`libc`。'
- en: '`-lgcc_s`: This is a static library that is linked automatically by GCC to
    provide support for compiler-specific operations including 64-bit operations on
    a 32-bit CPU, and facilities such as exception unwinding (a topic that will be
    discussed in [Chapter 13](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml), *Error
    - Handling with Exceptions*).'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-lgcc_s`：这是一个静态库，由GCC自动链接，用于支持特定于编译器的操作，包括在32位CPU上进行64位操作，以及诸如异常展开（这是一个将在[第13章](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml)中讨论的主题，*异常处理*）。'
- en: '`Scrt1.o`, `crti.o`, `crtbeginS.o`, `crtendS.o`, and `crtn.o`: These libraries
    provide the code needed to start and stop your application.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scrt1.o`、`crti.o`、`crtbeginS.o`、`crtendS.o`和`crtn.o`：这些库提供了启动和停止应用程序所需的代码。'
- en: 'Specifically, the **C run-time** **libraries** (**CRT**) libraries are the
    libraries of interest here. These libraries provide the code that is needed to
    bootstrap the application, including:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，**C运行时** **库**（**CRT**）库是这里感兴趣的库。这些库提供了引导应用程序所需的代码，包括：
- en: Executing global constructors and destructors (as GCC supports constructors
    and destructors in C, even though this is not a standard C facility).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行全局构造函数和析构函数（尽管这不是标准C的功能，GCC支持C中的构造函数和析构函数）。
- en: Setting up unwinding to support exception supporting. Although this is mainly
    needed for C++ exceptions, which are not needed in a standard C-only application,
    they are still needed for linking in the set jump exception logic, a topic that
    will be explained in [Chapter 13](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml),
    *Error - Handling with Exceptions*.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置展开以支持异常支持。虽然这主要是为了C++异常，对于仅需要标准C的应用程序来说是不需要的，但它们仍然需要链接到set jump异常逻辑中，这个话题将在[第13章](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml)中进行解释，*异常处理*。
- en: Providing the `_start` function, which is the actual entry point to any C-based
    application using a default GCC compiler.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供`_start`函数，这是使用默认GCC编译器的任何基于C的应用程序的实际入口点。
- en: Finally, all these libraries are responsible for providing the `main()` function
    with the arguments that are passed to it, as well as intercepting the return value
    of the `main()` function, and executing the `exit()` function on your behalf,
    as needed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有这些库都负责为`main()`函数提供传递给它的参数，并拦截`main()`函数的返回值，并在需要时代表您执行`exit()`函数。
- en: The most important takeaway here is that the first piece of code to execute
    in your program is not the `main()` function, and if you register a global constructor,
    it is not the first piece of code that you provide that executes either. While
    system programming, if you experience issues with the initialization of your program,
    this is where to look first.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最重要的一点是，在您的程序中执行的第一段代码不是`main()`函数，如果您注册了全局构造函数，它也不是您提供的第一段代码。在系统编程中，如果您遇到程序初始化的问题，这是首先要查看的地方。
- en: All about linking
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于链接的一切
- en: Linking is an extremely complex topic that varies from operating system to operating
    system. For example, Windows links programs quite differently to Linux. For this
    reason, we will limit our discussion to Linux.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 链接是一个非常复杂的主题，因操作系统而异。例如，Windows和Linux链接程序的方式完全不同。因此，我们将把讨论限制在Linux上。
- en: 'When a C source file is compiled, it is compiled into what is called an **object
    file**, which contains the compiled source code with each function that is defined
    in the program in a binary format, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当C源文件被编译时，它被编译成所谓的**目标文件**，其中包含以二进制格式定义程序中每个函数的编译源代码，如下所示：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As shown here, the compiler creates an object file, which contains the compiler
    (that is, binary) version of the source code. An important note here is that that
    the `main()` function is labeled *main*, in plain text.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，编译器创建了一个目标文件，其中包含源代码的编译（即二进制）版本。这里的一个重要说明是，`main()`函数被标记为*main*，以纯文本形式。
- en: 'Let''s expand this example to include another function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展这个例子来包括另一个函数：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Compiling this source, we get the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 编译这个源文件，我们得到以下结果：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As shown here, each function that is compiled is labeled using the same name
    as the function. That is, the name of each function is not *mangled* (unlike in
    C++). Name mangling will be explained in further detail in the next section, as
    well as why this is important with respect to linking.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，每个编译的函数都使用与函数相同的名称标记。也就是说，每个函数的名称都不是*混编*的（不像C++）。名称混编将在下一节中进一步详细解释，以及为什么这在链接方面很重要。
- en: 'Going beyond a simple source file, a C program is split into groups of source
    files that are compiled and linked together. Specifically, an executable is the
    combination of object files and libraries. Libraries are a combination of additional
    object files, divided into two different types:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 超越简单的源文件，C程序被分成编译和链接在一起的源文件组。具体来说，可执行文件是目标文件和库的组合。库是额外目标文件的组合，分为两种不同的类型：
- en: '**Static libraries**: libraries that are linked at compile time'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态库**：在编译时链接的库'
- en: '**Dynamic libraries**: libraries that are linked at load time'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态库**：在加载时链接的库'
- en: Static libraries
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态库
- en: Static libraries are a collection of object files that are linked at compile
    time. In Linux (and most UNIX-based systems), static libraries are nothing more
    than an archive of object files. You can easily take an existing static library
    and use the `AR` tool to extract the original object files.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 静态库是一组在编译时链接的目标文件。在Linux（和大多数基于UNIX的系统中），静态库只是一组目标文件的存档。您可以轻松地获取现有的静态库并使用`AR`工具来提取原始的目标文件。
- en: Unlike object files that are linked as part of your program, object files that
    are linked as part of a static library only include the source code needed by
    that static library, providing optimization that removes unused code from your
    program, ultimately reducing the total size of your program.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与作为程序一部分链接的目标文件不同，作为静态库一部分链接的目标文件只包括静态库所需的源代码，提供了优化，从程序中删除未使用的代码，最终减少了程序的总大小。
- en: The downside to this approach is that the order in which a program is linked
    using static libraries matters. If a library is linked before the code that needs
    the library is provided (on the command line, that is), a link error will occur,
    as the code from the static library will be optimized out.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，使用静态库链接程序的顺序很重要。如果在提供需要该库的代码之前（即在命令行上）链接库，将会发生链接错误，因为静态库中的代码将被优化掉。
- en: Libraries provided by the operating system usually do not support static linking
    either, and, typically, static linking of operating system libraries is not needed
    as those libraries are likely to have been loaded into memory by your operating
    system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统提供的库通常也不支持静态链接，并且通常不需要静态链接操作系统库，因为这些库可能已经被操作系统加载到内存中。
- en: Dynamic libraries
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态库
- en: Dynamic libraries are libraries that are linked at load time. Dynamic libraries
    are more like executables without an entry point. They contain code needed by
    your program, and the load-time linker is responsible for providing the location
    of each required function to your program while your program is being loaded.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 动态库是在加载时链接的库。动态库更像是没有入口点的可执行文件。它们包含程序所需的代码，加载时链接器负责为程序提供每个所需函数的位置。
- en: It is also possible for your program to link itself while it executes during
    runtime as an optimization, only linking functions that are needed (a process
    known as **lazy loading**).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 程序也可以在运行时链接自身作为优化，只链接需要的函数（这个过程称为**延迟加载**）。
- en: 'Most of the libraries provided by the operating system are dynamic libraries.
    To see which dynamic libraries are needed by your program, you can use the LDD
    tool, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统提供的大多数库都是动态库。要查看程序需要哪些动态库，可以使用LDD工具，如下所示：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, we used the LDD tool to list the dynamic libraries needed
    by our simple `Hello World\n` example. As shown, the following libraries are needed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用LDD工具列出了我们简单的`Hello World\n`示例所需的动态库。如下所示，需要以下库：
- en: '`vdso`: a library provided by the operating system to speed up the process
    of making system calls'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vdso`：操作系统提供的库，用于加速系统调用的过程'
- en: '`libc`: the standard C library'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libc`：标准C库'
- en: '`ld-linux-x86-64`: the dynamic linker itself, responsible for lazy-loading'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ld-linux-x86-64`：动态链接器本身，负责延迟加载'
- en: Scope
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: One addition to the C language that distinguishes it dramatically from assembly
    language programming is the use of *scope*. In assembly, a function prefix and
    postfix must be hand-coded, and the process for doing this depends entirely on
    the **instruction set architecture** (**ISA**) your CPU provides, and the ABI
    the programmer decides to use.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: C语言的一个特点是它使用*作用域*，这使它与汇编语言编程有了明显的区别。在汇编中，函数的前缀和后缀必须手动编码，而这个过程完全取决于CPU提供的**指令集架构**（ISA）和程序员决定使用的ABI。
- en: 'In C, the scope of a function is defined automatically for you using the `{}`
    syntax. For example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，函数的作用域会自动使用`{}`语法为您定义。例如：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In our simple `Hello World\n` example, scope is used to define the start and
    end of our `main()` function. The scope of other primitives can also be defined
    using the `{}` syntax. For example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们简单的`Hello World\n`示例中，作用域用于定义`main()`函数的开始和结束。其他基本类型的作用域也可以使用`{}`语法来定义。例如：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous example, we define the scope of both our `main()` function and
    our `for()` loop.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们定义了`main()`函数和`for()`循环的作用域。
- en: 'The `{}` syntax can also be used to create *scope* for anything. For example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`{}`语法也可以用于为任何内容创建*作用域*。例如：'
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the previous example, we are able to use the `i` variable twice without accidentally
    redefining it, because we wrapped the definition of `i` in a `{}`. Not only does
    this tell the compiler the scope of `i`, it also tells the compiler to automatically
    create a prefix and postfix for us if they are needed (as optimizations can remove
    the need for a prefix and postfix).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们能够在不小心重新定义它的情况下两次使用`i`变量，因为我们将`i`的定义包裹在`{}`中。这不仅告诉编译器`i`的作用域，还告诉编译器如果需要的话自动为我们创建前缀和后缀（因为优化可能消除了前缀和后缀的需要）。
- en: Scope is also used to define what the compiler exposes with respect to linking.
    In standard C, the `static` keyword tells the compiler that a variable is only
    visible (that is, scoped) to the object file it is being compiled to, providing
    not only an optimization to the linker, but also preventing two global variables
    or functions from colliding with each other.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域还用于定义编译器在链接方面公开的内容。在标准C中，`static`关键字告诉编译器变量只对正在编译的目标文件可见（即具有作用域），这不仅为链接器提供了优化，还防止两个全局变量或函数相互冲突。
- en: For this reason, if a function is not intended to be called by another source
    file (or library), it should be labeled static.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果一个函数不打算被另一个源文件（或库）调用，它应该被标记为静态。
- en: In the context of system programming, scope is important because system programming
    typically requires the acquisition of system-level resources. As will be seen
    in [Chapter 4](57bdbfbb-03ce-45e3-b3ac-108daf3ac728.xhtml), *C++, RAII, and the
    GSL Refresher*, C++ provides the ability to create objects whose life can be scoped
    using standard C `{}` syntax, providing a safe mechanism for resource acquisition
    and release.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程的上下文中，作用域很重要，因为系统编程通常需要获取系统级资源。正如将在[第4章](57bdbfbb-03ce-45e3-b3ac-108daf3ac728.xhtml)中看到的那样，*C++，RAII和GSL刷新器*，C++提供了使用标准C`{}`语法创建生命周期可作用域对象的能力，为资源获取和释放提供了安全机制。
- en: Pointers and arrays
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针和数组
- en: 'In school, I had a teacher who once told me:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在学校里，我有一位老师曾经告诉过我：
- en: '"No matter how experienced you are, nobody truly understands pointers completely."'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: “无论你有多有经验，没有人完全理解指针。”
- en: 'No statement could be truer. In standard C, a pointer is a variable whose value
    points to a location in memory. The problem with standard C is that this location
    in memory is not associated with a particular type. Instead, the pointer type
    itself defines the type of memory the pointer is pointing to, as in the following
    example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 没有比这更真实的陈述了。在标准C中，指针是一个值指向内存中的位置的变量。标准C的问题在于，这个内存位置与特定类型无关。相反，指针类型本身定义了指针指向的内存类型，如下例所示：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the previous example, we created an integer, and then created a pointer
    and pointed it at the previously-defined integer. We could, however, do the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们创建了一个整数，然后创建了一个指针，并将其指向先前定义的整数。但是，我们可以这样做：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this program, we create a pointer to an integer, but we define the pointer
    type as `void *`, which tells the compiler we are creating a pointer with no type.
    We then create two additional pointers—a pointer to an integer, and a pointer
    to a floating point number. Both of these additional pointers are initialized
    using the `void *` pointer we created earlier.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们创建了一个指向整数的指针，但我们将指针类型定义为`void *`，这告诉编译器我们正在创建一个没有类型的指针。然后我们创建了另外两个指针——一个指向整数，一个指向浮点数。这两个额外的指针都是使用我们之前创建的`void
    *`指针进行初始化的。
- en: 'The problem with this example is that the standard C compiler is performing
    automatic type casting, changing a `void *` into both an integer pointer and a
    floating point number pointer. If both of these pointers were used, corruption
    would occur in a couple of ways:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的问题在于标准C编译器执行自动类型转换，将`void *`转换为整数指针和浮点数指针。如果同时使用这两个指针，将会发生一些损坏：
- en: Depending on the architecture, a buffer overflow could occur, as an integer
    could be larger than a float and vice versa. It depends on the CPU being used;
    a topic that will be discussed in more detail in [Chapter 3](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml), *System
    Types for C and C++*.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据架构的不同，缓冲区溢出可能会发生，因为整数可能比浮点数大，反之亦然。这取决于所使用的CPU；这是一个将在[第3章](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml)中更详细讨论的话题，*C和C++的系统类型*。
- en: Under the hood, an integer and a floating point number are stored differently
    in the same memory, meaning any attempt to set one value would corrupt the other.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部，整数和浮点数在同一内存中以不同的方式存储，这意味着任何尝试设置一个值都会破坏另一个值。
- en: Thankfully, modern C compilers have flags that are capable of detecting this
    type of type casting error, but these warnings must be enabled as they are not
    on by default, as shown previously.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，现代C编译器具有能够检测这种类型转换错误的标志，但是这些警告必须启用，因为它们默认情况下是关闭的，如前所示。
- en: The obvious issue with pointers is not just that they can point to anything
    in memory and redefine that memory's meaning, but that they can also take on a
    null value. In other words, pointers are considered optional. They either optionally
    contain a valid value and point to memory, or they are null.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的明显问题不仅在于它们可以指向内存中的任何内容并重新定义该内存的含义，而且它们还可以取空值。换句话说，指针被认为是可选的。它们可以选择包含有效值并指向内存，或者它们可以是空的。
- en: 'For this reason, pointers should not be used until their value is determined
    to be valid, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在确定其值有效之前，不应使用指针，如下所示：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the previous example, we create a pointer to an integer that is initialized
    with the location of a previously-defined integer with an initial value of `42`.
    We check to make sure `p` is not a null pointer, and then output its value to
    `stdout`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个指向整数的指针，它被初始化为先前定义的一个初始值为`42`的整数的位置。我们检查确保`p`不是一个空指针，然后将其值输出到`stdout`。
- en: The addition of the `if()` statement is not only cumbersome—it isn't performant.
    For this reason, most programmers would leave out the `if()` statement, knowing
    that, in this example, `p` is never a null pointer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`if()`语句的添加不仅麻烦，而且性能不佳。因此，大多数程序员会省略`if()`语句，因为在这个例子中，`p`永远不会是一个空指针。'
- en: The problem with this is, at some point, the programmer could add code to this
    simple example that contradicts this assumption, while simultaneously forgetting
    to add the `if()` statement, resulting in code that has the potential to generate
    a hard-to-find segmentation fault.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在于，程序员可能会在这个简单的例子中添加与这个假设相矛盾的代码，同时忘记添加`if()`语句，导致潜在生成难以发现的分段错误的代码。
- en: As will be shown in the next section, the C++ standard addresses this issue
    by introducing the notion of a *reference*, which is a non-optional pointer, meaning
    it is a pointer that must always point to a valid, typed, memory location. To
    address this issue in standard C, null pointer checks are usually (although not
    always) checked by public-facing APIs. Private APIs typically do not check for
    null pointers to improve performance, making the assumption, that so long as the
    public-facing API cannot accept a null pointer, it's likely the private API will
    never see an invalid pointer.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如将在下一节中所示，C++标准通过引入*引用*的概念来解决这个问题，它是一个非可选指针，这意味着它必须始终指向一个有效的、有类型的内存位置。为了解决这个问题，在标准C中，通常（虽然不总是）通过公共API来检查空指针。私有API通常不会检查空指针以提高性能，这样做的假设是，只要公共API不能接受空指针，私有API很可能永远不会看到无效的指针。
- en: 'Standard C arrays are similar to pointers. The only difference is that a C
    array leverages a syntax capable of indexing into the memory pointed to by a pointer,
    as in the following example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C数组类似于指针。唯一的区别在于C数组利用了一种能够对指针指向的内存进行索引的语法，就像下面的例子中所示：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the previous example, we create an array of integers with 2 elements initialized
    to the values `42` and `43`. We then create a pointer that points to the array.
    Note that the `&` is no longer needed. This is because the array is a pointer,
    thus, we are simply setting one pointer to the value of another (instead of having
    to extract a pointer from an existing memory location).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个包含2个元素的整数数组，初始化为值`42`和`43`。然后我们创建一个指向该数组的指针。请注意，不再需要`&`。这是因为数组本身就是一个指针，因此我们只是将一个指针设置为另一个指针的值（而不是必须从现有内存位置提取指针）。
- en: Finally, we print the value of each element in the array using both the array
    itself and the pointer to the array using pointer arithmetic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用指针算术来打印数组中每个元素的值，既使用数组本身，又使用指向数组的指针。
- en: As will be discussed in [Chapter 4](57bdbfbb-03ce-45e3-b3ac-108daf3ac728.xhtml),
    *C++, RAII, and the GSL Refresher*, there is little difference between an array
    and a pointer. Both perform what is known as **pointer arithmetic** when an attempt
    is being made to access an element in an array.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如将在[第4章](57bdbfbb-03ce-45e3-b3ac-108daf3ac728.xhtml)中讨论的那样，数组和指针之间几乎没有区别。当尝试访问数组中的元素时，两者都执行所谓的**指针算术**。
- en: 'With respect to system programming, pointers are used extensively. Examples
    include the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程方面，指针被广泛使用。例如：
- en: Since standard C doesn't contain the notion of a *reference* as C++ does, system
    APIs that must be passed by a reference because they are too large to be passed
    by a value, or must be modified by the API, must be passed by a pointer, resulting
    in the heavy use of pointers when making system calls.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于标准C不像C++那样包含*引用*的概念，必须通过引用传递的系统API（因为它们太大而无法通过值传递，或者必须由API修改）必须通过指针传递，因此在进行系统调用时会大量使用指针。
- en: System programming often involves interacting with pointers to a location in
    memory, designed to define the layout of that memory. Pointers provide a convenient
    way to accomplish this.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统编程通常涉及与内存中的位置指针交互，旨在定义该内存的布局。指针提供了一种方便的方法来实现这一点。
- en: Libraries
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库
- en: 'Standard C not only defines a syntax, the environment, and how programs are
    linked, it also provides a set of libraries that may be leveraged by a programmer
    to perform system programming. Some of these libraries are as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C不仅定义了语法、环境和程序链接方式，还提供了一组库，程序员可以利用这些库来进行系统编程。其中一些库如下：
- en: '`errno.h`: Provides the code needed for working with errors. This library will
    be discussed in further detail in [Chapter 13](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml),
    *Error - Handling with Exceptions*.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`errno.h`：提供处理错误所需的代码。这个库将在[第13章](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml)中进一步讨论，*异常处理*。'
- en: '`inttypes.h`: Provides type information, which will be discussed in [Chapter
    3](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml), *System Types for C and C++.*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inttypes.h`：提供类型信息，将在[第3章](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml)中讨论，*C和C++的系统类型*。'
- en: '`limits.h`: Provides information about the limits of each type, which will
    be discussed in [Chapter 3](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml), **System
    Types for C and C++.**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limits.h`：提供每种类型的限制信息，将在[第3章](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml)中讨论，*C和C++的系统类型*。'
- en: '`setjump.h`: Provides the APIs for C-style exception handling, which will be
    discussed in [Chapter 13](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml), *Error
    - Handling with Exceptions*.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setjump.h`：提供C风格的异常处理的API，将在[第13章](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml)中讨论，*异常处理*。'
- en: '`signal.h`: Provides APIs for handling signals sent from the system to your
    program, which will be discussed in [Chapter 5](c2403e99-dbe5-46ae-858f-afe6102f2aeb.xhtml), *Programming
    Linux/Unix Systems*.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signal.h`：提供处理系统发送到程序的信号的API，将在[第5章](c2403e99-dbe5-46ae-858f-afe6102f2aeb.xhtml)中讨论，*Linux/Unix系统编程*。'
- en: '`stdbool.h`: Provides type information, which will be discussed in [Chapter
    3](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml), *System Types for C and C++.*'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdbool.h`：提供类型信息，将在[第3章](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml)中讨论，*C和C++的系统类型*。'
- en: '`stddef.h`: Provides type information, which will be discussed in [Chapter
    3](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml), *System Types for C and  C++.*'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stddef.h`：提供类型信息，将在[第3章](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml)中讨论，*C和C++的系统类型*。'
- en: '`stdint.h`: Provides type information, which will be discussed in [Chapter
    3](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml), *System Types for C and C++.*'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdint.h`：提供类型信息，将在[第3章](eebe3299-c81b-441e-8e47-23dbc6ec4fe1.xhtml)中讨论，*C和C++的系统类型*。'
- en: '`stdio.h`: Provides functions for working with input and output while system
    programming, which will be discussed in [Chapter 6](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml), *Learning
    to Program Console Input/Output*, and [Chapter 8](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml), *Learning
    to Program File Input/Output*.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdio.h`：提供在系统编程中处理输入和输出的函数，将在[第6章](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml)和[第8章](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml)中讨论，*学习控制台输入/输出*和*学习文件输入/输出*。'
- en: '`stdlib.h`: Provides various utilities, including dynamic memory allocation
    APIs, which will be discussed in [Chapter 7](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml), *A
    Comprehensive Look at Memory Management*.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdlib.h`：提供各种实用程序，包括动态内存分配API，将在[第7章](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml)中讨论，*全面了解内存管理*。'
- en: '`time.h`: Provides facilities for working with clocks, which will be discussed
    in [Chapter 11](037338df-a0a2-455e-b03a-c16e6b3c3c3d.xhtml), *Time Interfaces
    in Unix.*'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.h`：提供处理时钟的功能，将在[第11章](037338df-a0a2-455e-b03a-c16e6b3c3c3d.xhtml)中讨论，*Unix中的时间接口*。'
- en: As stated previously, the bulk of this book will focus on these facilities and
    how they support system programming.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，本书的大部分内容将集中在这些功能上，以及它们如何支持系统编程。
- en: Learning about the C++ standard
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习C++标准
- en: The C++ programming language (originally called C with Classes) was designed
    specifically to provide higher-level facilities than C, including better type
    safety and object-oriented programming, with system programming in mind. Specifically,
    C++ aims to provide the performance and efficiency of C programs, while still
    providing the features of higher-level languages.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: C++编程语言（最初称为带类的C）专门设计为提供比C更高级的功能，包括更好的类型安全性和面向对象编程，同时考虑了系统编程。具体来说，C++旨在提供C程序的性能和效率，同时仍提供更高级语言的特性。
- en: Today, C++ is one of the most popular programming languages in the world, used
    in everything from avionics to banking.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，C++是世界上最流行的编程语言之一，应用于从航空电子学到银行业的各个领域。
- en: Like the C standard, the C++ standard is huge and is managed by the ISO. We
    assume the reader has some basic knowledge of the C++ standard and how to write
    C code: [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4713.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4713.pdf).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与C标准一样，C++标准也很庞大，并由ISO管理。我们假设读者对C++标准和如何编写C代码有一些基本的了解：[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4713.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4713.pdf)。
- en: For these reasons, the goal of this section is to discuss some topics that are
    discussed in lesser detail in other books, as well as portions of the C++ standard
    that are relevant to this book and system programming but are missing from the
    other chapters. Please see the *Further reading* section of this chapter for additional
    information on the C++ programming language, and how to write C++ programs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本节的目标是讨论一些在其他书中没有详细讨论的主题，以及与本书和系统编程相关的C++标准的部分，但在其他章节中缺失。有关C++编程语言以及如何编写C++程序的更多信息，请参阅本章的*进一步阅读*部分。
- en: How the standard is organized
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准的组织方式
- en: 'Like the C standard specification, the C++ specification is broken up into
    three major groups of sections:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与C标准规范一样，C++规范分为三大组部分：
- en: General conventions and concepts
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般约定和概念
- en: Language syntax
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言语法
- en: Libraries
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库
- en: It should be noted that the C++ standard is considerably larger than the C standard.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意到，C++标准比C标准要大得多。
- en: General conventions and concepts
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般约定和概念
- en: The first four sections in the standard are dedicated to conventions and concepts.
    They define types, program start-up and shutdown, memory, and linking. They also
    outline all of the definitions and keywords that are needed to understand the
    rest of the specification.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 标准中的前四个部分专门讨论约定和概念。它们定义了类型、程序的启动和关闭、内存和链接。它们还概述了理解规范其余部分所需的所有定义和关键字。
- en: As in the standard C specification, there are a lot of things defined in these
    sections that are important to system programmers, as they define what the compiler
    will output when a program is compiled, and how that program will be executed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准C规范一样，在这些部分中定义了许多对系统程序员很重要的东西，因为它们定义了编译器在编译程序时将输出什么，以及程序将如何执行。
- en: Language syntax
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言语法
- en: The next 12 sections in the specification define the C++ language syntax itself.
    This includes C++ features such as classes, overloading, templates, and exception
    handling. There are entire books written on just these sections of the specification.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 规范中的接下来12个部分定义了C++语言的语法本身。这包括C++的特性，如类、重载、模板和异常处理。有整本书只是针对规范的这些部分写的。
- en: We assume the reader has a general understanding of C++ and we do not go over
    this part of the specification in the book, except the C++17-specific modifications
    in [Chapter 4](57bdbfbb-03ce-45e3-b3ac-108daf3ac728.xhtml), *C++, RAII, and the
    GSL Refresher*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设读者对C++有一般的了解，我们在书中不再讨论这部分规范，除了[第4章](57bdbfbb-03ce-45e3-b3ac-108daf3ac728.xhtml)中关于C++17的修改，*C++，RAII和GSL刷新*。
- en: Libraries
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库
- en: The remaining 14 sections in the specification define the libraries that C++
    provides as part of the specification. It should be noted that the bulk of this
    book revolves around this part of the specification.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 规范中剩下的14个部分定义了C++作为规范一部分提供的库。应该注意到，本书的大部分内容都围绕着规范的这一部分。
- en: Specifically, we discuss in great detail the facilities that C++ provides for
    system programmers, and how to use those facilities in practice.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们详细讨论了C++为系统程序员提供的设施，以及如何在实践中使用这些设施。
- en: Linking C++ applications
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接C++应用程序
- en: As in C, C++ applications typically start from a `main()` function with the
    same signatures that C already provides. Also, as in C programs, the actual entry
    point of the code is actually the `_start` function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与C一样，C++应用程序通常从一个具有与C相同签名的`main()`函数开始。同样，与C程序一样，代码的实际入口点实际上是`_start`函数。
- en: 'Unlike in C, however, C++ is far more complicated, including a lot more code
    for a simple example. To demonstrate this, let''s look at a simple `Hello World\n` example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与C不同，C++要复杂得多，包括了更多的代码来演示一个简单的例子。为了证明这一点，让我们看一个简单的`Hello World\n`示例：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'First and foremost, the C++ application example is slightly longer than the
    equivalent C example from the previous section:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，C++应用程序示例比上一节中等价的C示例略长：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we look at the symbols in our example, we get the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下我们的示例中的符号，我们得到以下内容：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As previously stated, our program contains a `main()` function and a `_start()`
    function. The `_start()` function is the actual entry point of the application,
    while the `main()` function is called by the `_start()` function after initialization
    has completed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的程序包含一个`main()`函数和一个`_start()`函数。`_start()`函数是应用程序的实际入口点，而`main()`函数在初始化完成后由`_start()`函数调用。
- en: The `_init()` and `_fini()` functions are responsible for global construction
    and destruction. In the case of our example, the `_init()` function creates the
    code needed by the C++ library to support `std::cout`, while the `_fini()` function
    is responsible for destroying these global objects. To do this, the global objects
    register with the `__cxa_atexit()` function, and are eventually destroyed using
    the `__cxa_finalize()` function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`_init()`和`_fini()`函数负责全局构造和销毁。在我们的示例中，`_init()`函数创建了C++库支持`std::cout`所需的代码，而`_fini()`函数负责销毁这些全局对象。为此，全局对象使用`__cxa_atexit()`函数注册，并最终使用`__cxa_finalize()`函数销毁。'
- en: The rest of the symbols make up the code for `std::cout`, including references
    to `ios_base{}` and `basic_ostream{}`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的符号构成了`std::cout`的代码，包括对`ios_base{}`和`basic_ostream{}`的引用。
- en: The important thing to note here is that, as in C, there is a lot of code that
    executes both before and after the `main()` function, and using global objects
    in C++ only adds to the complexity of starting and stopping your application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要事情是，与C语言一样，有很多代码在`main()`函数之前和之后执行，并且在C++中使用全局对象只会增加启动和停止应用程序的复杂性。
- en: 'In the preceding example, we use the `_C` option to demangle our function names.
    Let''s look at the same output with this option:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`_C`选项来解开我们的函数名。让我们看看使用这个选项的相同输出：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As shown, some of these functions are still readable, while others are not.
    Specifically, the C++ specification dictates that certain support functions are
    linked using C linkage, preventing mangling. In our example, this includes the
    `__cxa_xxx()` functions, `_init()`, `_fini()`, `main()`, and `_start()`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，一些函数仍然可读，而另一些则不可读。具体来说，C++规范规定某些支持函数使用C链接进行链接，防止名称编码。在我们的例子中，这包括`__cxa_xxx()`函数、`_init()`、`_fini()`、`main()`和`_start()`。
- en: 'The C++ library functions that support `std::cout`, however, are managed with
    an almost unreadable syntax. On most POSIX-compliant systems, these mangled names
    can be demangled using the `C++filt` command, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，支持`std::cout`的C++库函数的语法几乎无法阅读。在大多数符合POSIX标准的系统上，可以使用`C++filt`命令来解开这些编码的名称，如下所示：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'These names are mangled because they contain the entire function signature
    in their name, including the arguments and specializations (for example, the `noexcept`
    keyword). To demonstrate this, let''s create two function overloads:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称被编码是因为它们的名称中包含了整个函数签名，包括参数和特化（例如，`noexcept`关键字）。为了证明这一点，让我们创建两个函数重载：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the previous example, we created two functions with the same name, but with
    different function signatures, a process known as **function overloading**, which
    is specific to C++.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了两个具有相同名称但不同函数签名的函数，这个过程称为**函数重载**，这是C++特有的。
- en: 'Now let''s look at the symbols in our test application:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们测试应用程序中的符号：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are a couple of reasons why function names are mangled in C++:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名在C++中被编码的原因有几个：
- en: Encoding function arguments in the function's name means functions can be overloaded,
    and the compiler and the linker will know which function does what. Without name
    mangling, two functions with the same name but different arguments would look
    identical to the linker, and errors would occur.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数名中编码函数参数意味着函数可以重载，并且编译器和链接器将知道哪个函数做什么。没有名称编码，具有相同名称但不同参数的两个函数对于链接器来说看起来是相同的，会导致错误。
- en: By encoding this type of information in the function name, the linker is able
    to identify whether a function for a library was compiled using a different signature.
    Without this information, it would be possible for the linker to link, for example,
    a library compiled with a different signature (and therefore a different implementation)
    to the same function name, which would lead to a hard-to-find error, and likely
    corruption.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在函数名中编码这种类型的信息，链接器能够识别库函数是否使用了不同的签名进行编译。没有这些信息，链接器可能会将使用不同签名（因此不同实现）编译的库链接到相同的函数名，这将导致难以发现的错误，很可能会导致损坏。
- en: The biggest issue with C++ name mangling is that small changes to a public-facing
    API result in a library no longer being able to link with already-existing code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: C++名称编码的最大问题是对公共API进行微小更改会导致库无法再与已经存在的代码链接。
- en: There are many ways to overcome this problem, but, in general, it's simply important
    to understand that C++ encodes a lot of information about how you write your code
    in a function's name, making it imperative that public-facing APIs do not change
    unless a version change is expected.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以克服这个问题，但总的来说，重要的是要理解C++在函数名中编码了关于你如何编写代码的大量信息，这使得公共API不改变除非期望进行版本更改至关重要。
- en: Scope
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: 'One major difference between C and C++ is how the construction and destruction
    of an object is handled. Let''s take the following example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++之间的一个主要区别是对象的构造和销毁是如何处理的。让我们看下面的例子：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Unlike in C, in C++ we are able to use the `{}` operator to define how we would
    like the data values of the structure to be initialized. This is possible because,
    in C++, objects (both structures and classes) contain constructors and destructors
    that define how the object is initialized on construction and destroyed on destruction.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与C语言不同，在C++中，我们可以使用`{}`运算符来定义结构的数据值应该如何初始化。这是可能的，因为在C++中，对象（包括结构和类）包含构造函数和析构函数，定义了对象在构造时如何初始化和在销毁时如何销毁。
- en: When system programming, this scheme will be used extensively, and the idea
    of the construction and destruction of objects will be leveraged throughout this
    book when handling system resources. Specifically, a scope will be leveraged to
    define the lifetime of an object, and thus the system resource that the object
    owns, using a concept called **Resource Acquisition is Initialization** (**RAII**).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程时，这种方案将被广泛使用，并且在处理系统资源时，构造和销毁对象的概念将贯穿本书。具体来说，将利用作用域来定义对象的生命周期，从而定义对象拥有的系统资源，使用一种称为**资源获取即初始化**（**RAII**）的概念。
- en: Pointers versus references
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针与引用
- en: In the previous section, we discussed pointers in length, including how pointers
    can take on two values—valid or null (assuming corruption is not part of the equation).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们详细讨论了指针，包括指针可以取两个值——有效或空（假设损坏不是方程式的一部分）。
- en: 'The problem with this is that the user must check whether the pointer is valid
    or not. This is normally not an issue when using pointers to define the contents
    of memory (for example, laying out memory using a data structure), but often,
    pointers in C must be used simply to reduce the overhead of passing a large object
    to a function, as in the following example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于用户必须检查指针是否有效。当使用指针来定义内存的内容（例如，使用数据结构布局内存）时，通常不会出现问题，但在C中，指针经常必须简单地用于减少将大型对象传递给函数的开销，就像以下示例中一样：
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the previous example, we create a structure that has eight variables in it.
    Passing this type of structure with a value would result in the use of the stack
    (that is, several memory accesses). It is far more efficient to pass this structure
    with a pointer in C to reduce the cost of passing the structure to a single register,
    likely removing all memory accesses entirely.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个包含八个变量的结构。以值传递这种类型的结构将导致使用堆栈（即，多次内存访问）。在C中，通过指针传递这种结构以减少将结构传递给单个寄存器的成本更加高效，很可能完全消除所有内存访问。
- en: The problem is that, now, the test function must check to make sure the pointer
    is valid before it can use it. Therefore, the function trades a set of memory
    accesses for a branch statement and possible pipeline flush in the CPU, when all
    we are trying to do is reduce the cost of passing a large object to a function.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，现在，test函数必须在使用指针之前检查指针是否有效。因此，该函数将一组内存访问交换为分支语句和可能导致CPU流水线刷新的操作，而我们所要做的只是减少将大型对象传递给函数的成本。
- en: 'As stated in the previous section, the solution is to simply not verify the
    validity of the pointer. In C++, however, we have another option, and that is
    to pass the structure with a reference, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，解决方案就是简单地不验证指针的有效性。然而，在C++中，我们还有另一个选择，那就是通过引用传递结构，如下所示：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the previous example, our `test()` function takes a reference to `mystruct{}`
    instead of a pointer. When we call the `test()` function, there is no need to
    get the address of the structure, as we are not using a pointer.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们的`test()`函数接受了`mystruct{}`的引用，而不是指针。当我们调用`test()`函数时，无需获取结构的地址，因为我们没有使用指针。
- en: C++ references will be leveraged heavily throughout this book, as they greatly
    increase both the performance and stability of a program, especially while system
    programming, where resources, performance, and stability are critical.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: C++引用将在本书中大量使用，因为它们极大地提高了程序的性能和稳定性，特别是在系统编程中，资源、性能和稳定性至关重要。
- en: Libraries
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库
- en: 'C++ not only defines the basic environment and language syntax—it also provides
    a set of libraries that may be leveraged by a programmer to perform system programming.
    These include the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: C++不仅定义了基本的环境和语言语法，还提供了一组库，程序员可以利用这些库进行系统编程。这些包括以下内容：
- en: '**Console input/output libraries**: These include the `iostream`, `iomanip`,
    and `string` libraries, which provide the ability to work with strings, format
    them, and output them (or grab input from the user). We will discuss most of these
    libraries in [Chapter 6](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml), *Learning
    to Program Console Input/Output*.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台输入/输出库**：这些包括`iostream`，`iomanip`和`string`库，它们提供了处理字符串、格式化字符串和输出字符串（或从用户那里获取输入）的能力。我们将在[第6章](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml)中讨论大多数这些库，*学习编程控制台输入/输出*。'
- en: '**Memory management libraries**: These include the memory library, which contains
    memory management utilities that help to prevent dangling pointers. They will
    be discussed in [Chapter 7](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml), *A Comprehensive
    Look at Memory Management.*'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存管理库**：这些包括内存库，其中包含有助于防止悬空指针的内存管理实用程序。它们将在[第7章](9ce08850-517a-42c0-9dcc-f30b94d96498.xhtml)中讨论*全面了解内存管理*。'
- en: '**File input/output libraries**: These include the `fstream` and `filesystem`
    (new to C++17) libraries, which will be discussed in [Chapter 8](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml), *Learning
    to Program File Input/Output.*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件输入/输出库**：这些包括`fstream`和`filesystem`（C++17中新增）库，在[第8章](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml)中将讨论*学习文件输入/输出*。'
- en: '**Time libraries**: These include the `chrono` library, which will be discussed
    in [Chapter 11](037338df-a0a2-455e-b03a-c16e6b3c3c3d.xhtml), *Time Interfaces
    in Unix.*'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间库**：这些包括`chrono`库，在[第11章](037338df-a0a2-455e-b03a-c16e6b3c3c3d.xhtml)中将讨论*Unix中的时间接口*。'
- en: '**Threading libraries**: These include the `thread`, `mutex`, and `conditional_variable`
    libraries, which will be discussed in [Chapter 12](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml), *Learn
    to Program POSIX and C++ Threads*.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程库**：这些包括`thread`，`mutex`和`conditional_variable`库，在[第12章](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml)中将讨论*学习编程POSIX和C++线程*。'
- en: '**Error-handling libraries**: These include the exception support libraries,
    which will be discussed in [Chapter 13](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml), *Error
    - Handling with Exceptions*'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理库**：这些包括异常支持库，在[第13章](0385fdf3-e7d6-4688-94ea-230f7b128e33.xhtml)中将讨论*使用异常进行错误处理*'
- en: Beginning with the POSIX standard
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从POSIX标准开始
- en: The POSIX standard defines all of the functionality a POSIX-compliant operating
    system must implement. With respect to system programming, the POSIX standard
    defines the system call interface (that is, the APIs, not the ABIs) that the operating
    system must support.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX标准定义了符合POSIX的操作系统必须实现的所有功能。在系统编程方面，POSIX标准定义了操作系统必须支持的系统调用接口（即API，而不是ABI）。
- en: Under the hood, most of the system-level APIs that C and C++ provide actually
    execute POSIX functions, or are POSIX functions themselves (as is this case with
    a lot of C library APIs). In fact, `libc` is generally considered to be a subset
    of the greater POSIX standard, while C++ leverages `libc` and POSIX to implement
    its higher-level APIs such as threading, memory management, error handling, file
    operations, and input/output. For more information, refer to [https://ieeexplore.ieee.org/document/8277153/](https://ieeexplore.ieee.org/document/8277153/).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，C和C ++提供的大多数系统级API实际上执行POSIX函数，或者它们本身就是POSIX函数（就像很多C库API一样）。事实上，`libc`通常被认为是更大的POSIX标准的子集，而C
    ++利用`libc`和POSIX来实现其更高级的API，如线程，内存管理，错误处理，文件操作和输入/输出。有关更多信息，请参阅[https://ieeexplore.ieee.org/document/8277153/](https://ieeexplore.ieee.org/document/8277153/)。
- en: In this section, we will discuss some components of the POSIX standard that
    are relevant to system programming. All of these topics will be discussed in further
    detail in later chapters.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论与系统编程相关的POSIX标准的一些组件。所有这些主题将在后面的章节中进一步详细讨论。
- en: Memory management
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: All of the memory management functions that `libc` provides are considered POSIX
    APIs as well. In addition, there are some POSIX-specific memory management functions
    that `libc` doesn't provide, such as aligned memory.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`libc`提供的所有内存管理函数也被视为POSIX API。此外，还有一些`libc`不提供的POSIX特定内存管理函数，如对齐内存。'
- en: 'For example, the following demonstrates how to allocate aligned dynamic (heap)
    memory using POSIX:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下演示了如何使用POSIX分配对齐的动态（堆）内存：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, we use the `posix_memalign()` function to allocate an array
    of `42` integers, which is aligned to a page. This is a POSIX-specific function.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`posix_memalign()`函数来分配一个对齐到页面的`42`个整数的数组。这是一个POSIX特定的函数。
- en: In addition, we leverage the `std::clog()` function to output an error to `stderr`,
    which, under the hood, leverages POSIX-specific functions for outputting character
    strings to `stderr`. We also use `::exit()`, which is a `libc` and POSIX function
    for exiting an application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还利用`std::clog()`函数将错误输出到`stderr`，在底层利用了POSIX特定函数将字符串输出到`stderr`。我们还使用了`::exit()`，这是一个用于退出应用程序的`libc`和POSIX函数。
- en: Finally, we leverage both the `std::cout()` and `free()` functions. `std::cout()`
    uses POSIX functions to output character strings to `stdout`, while `free()` is
    both a `libc` and POSIX-specific function for freeing up memory.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们利用了`std::cout()`和`free()`函数。`std::cout()`使用POSIX函数将字符串输出到`stdout`，而`free()`是用于释放内存的`libc`和POSIX特定函数。
- en: In this simple example, we are leveraging several C, C++, and POSIX-specific
    functionalities to perform system programming. Throughout this book, we will discuss
    how to leverage POSIX heavily to program the system to accomplish specific tasks.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们利用了几个C、C++和POSIX特定的功能来执行系统编程。在本书中，我们将讨论如何大量利用POSIX来编程系统以完成特定任务。
- en: Filesystems
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统
- en: POSIX not only defines how to read and write a file from a POSIX-compliant operating
    system, it also defines where files should be located on the filesystem. In [Chapter
    8](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml), *Learning to Program File Input/Output*,
    we will go into great detail about how to read and write to a filesystem using
    C, C++, and POSIX.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX不仅定义了如何从符合POSIX的操作系统中读取和写入文件，还定义了文件应该位于文件系统上的位置。在[第8章](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml)中，《学习使用C、C++和POSIX进行文件输入/输出编程》，我们将详细介绍如何使用C、C++和POSIX读取和写入文件系统。
- en: 'With respect to the layout of the filesystem, POSIX defines where files should
    be located, including common folders such as the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 关于文件系统的布局，POSIX定义了文件应该位于的位置，包括以下常见文件夹：
- en: '`/bin`: for binaries used by all users'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin`：所有用户使用的二进制文件'
- en: '`/boot`: for files needed to boot the operating system'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/boot`：启动操作系统所需的文件'
- en: '`/dev`: for physical and virtual devices'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev`：物理和虚拟设备'
- en: '`/etc`: for configuration files needed by the operating system'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc`：操作系统需要的配置文件'
- en: '`/home`: for user-specific files'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home`：用户特定的文件'
- en: '`/lib`: for libraries needed by executables'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/lib`：可执行文件需要的库'
- en: '`/mnt and /media`: used as temporary mount points'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/mnt和/media`：用作临时挂载点'
- en: '`/sbin`: for system-specific binaries'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sbin`：系统特定的二进制文件'
- en: '`/tmp`: for files that are deleted on reboot'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tmp`：在重启时删除的文件'
- en: '`/usr`: for user-specific versions of the preceding folders'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr`：前述文件夹的用户特定版本'
- en: Sockets
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字
- en: To perform networking on a POSIX-compliant operating system, you need to leverage
    the POSIX sockets API. The socket programming interface provided by POSIX is a
    good example of a set of APIs that is provided by neither C nor C++, but is needed
    for networking on POSIX-compliant operating systems.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要在符合POSIX的操作系统上进行网络编程，您需要利用POSIX套接字API。POSIX提供的套接字编程接口是一个很好的例子，它既不是由C也不是由C++提供的一组API，但在符合POSIX的操作系统上进行网络编程时是必需的。
- en: In [Chapter 10](2d0b3ea6-499f-4064-a278-c480d2c74c75.xhtml), *Programming POSIX
    Sockets Using C++*, we will discuss how to perform networking using the POSIX
    sockets API, while leveraging C++. Specifically, we will show how C++ can be leveraged
    to simplify the implementation of socket-based networking, and provide several
    examples of how to perform networking.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](2d0b3ea6-499f-4064-a278-c480d2c74c75.xhtml)中，《使用C++编程POSIX套接字》，我们将讨论如何使用POSIX套接字API执行网络编程，同时利用C
    ++。具体来说，我们将展示如何利用C ++简化基于套接字的网络编程的实现，并提供如何执行网络编程的几个示例。
- en: Threading
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程
- en: Threads provide a system programmer with a means to perform parallel execution.
    Specifically, a thread is a unit of execution that the operating system schedules
    when it deems appropriate. Both C++ and POSIX provide APIs for working with threads,
    with the C++ APIs arguably being easier to work with.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 线程为系统程序员提供了执行并行执行的手段。具体来说，线程是操作系统在适当时安排的执行单元。C++和POSIX都提供了用于处理线程的API，其中C++的API可能更容易使用。
- en: It should be noted that, under the hood, C++ leverages the POSIX threads library
    (pthreads)—so, even though C++ provides a set of APIs for working with threads,
    in the end, POSIX threads are responsible for threading in all cases.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，在幕后，C++利用了POSIX线程库（pthreads）-因此，即使C++提供了一组用于处理线程的API，最终，POSIX线程负责所有情况下的线程。
- en: The reason for this is simple. POSIX defines the interface a program leverages
    to talk to the operating system. In this case, if you wish to tell the operating
    system to create a thread, you must do so by leveraging the APIs defined by the
    operating system. If the operating system is POSIX-compliant, those interfaces
    are POSIX, regardless of any abstractions that might be put in place to make working
    with the APIs easier.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为原因很简单。 POSIX定义了程序与操作系统交流的接口。在这种情况下，如果您希望告诉操作系统创建一个线程，您必须通过利用操作系统定义的API来实现。如果操作系统符合POSIX标准，那么这些接口就是POSIX，而不管可能会被放置在那里以使API更容易使用的任何抽象。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we learned about three different standards: C, C++, and POSIX.
    The C standard defines the popular C syntax, C-style program linking and execution,
    and the standard C libraries that provide cross-platform APIs to wrap an operating
    system''s ABIs.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了三种不同的标准：C、C++和POSIX。 C标准定义了流行的C语法，C风格的程序链接和执行，以及提供跨平台API的标准C库，以包装操作系统的ABI。
- en: We also learned about the C++ standard, and how it defines the C++ syntax, program
    linking and execution, and the high-level C++ APIs that wrap underlying C and
    POSIX APIs to C++.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解了C++标准，以及它如何定义C++语法，程序链接和执行，以及高级C++ API，以包装底层的C和POSIX API到C++。
- en: Finally, we saw how the POSIX standard provides additional APIs that go beyond
    C. These APIs include (but are not limited to) memory management, networking,
    and threading. In general, the POSIX standard defines all the standards needed
    for an application to perform its functions in a cross-platform way on any POSIX-compliant
    operating system.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到POSIX标准提供了超出C的额外API。这些API包括（但不限于）内存管理、网络和线程。一般来说，POSIX标准定义了应用程序在任何符合POSIX标准的操作系统上以跨平台方式执行其功能所需的所有标准。
- en: The remainder of this book will focus on the APIs defined in these standards,
    and how they can be used to perform system programming in C++17\. In the next
    chapter specifically, we will cover the system types provided by C, C++, and POSIX,
    and how they affect system programming.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其余部分将重点关注这些标准中定义的API，以及它们如何用于在C++17中进行系统编程。在下一章中，我们将专门介绍由C、C++和POSIX提供的系统类型，以及它们如何影响系统编程。
- en: Questions
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is the C standard part of the POSIX standard? If so, name an API that is common
    to both standards.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C标准是否是POSIX标准的一部分？如果是，列举一个在两个标准中都常见的API。
- en: What is the difference between the `_start()` and `main()` functions?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_start()`和`main()`函数之间有什么区别？'
- en: List one of the responsibilities of the C runtime?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举C运行时的一个职责。
- en: Are global constructors executed before or after the `main()` function?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局构造函数是在`main()`函数之前还是之后执行的？
- en: What is C++ name mangling, and why is it needed?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++名称修饰是什么，为什么需要？
- en: Name one difference between C and C++ program linking.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举C和C++程序链接之间的一个区别。
- en: What is the difference between a pointer and a reference?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指针和引用之间有什么区别？
- en: Further reading
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
