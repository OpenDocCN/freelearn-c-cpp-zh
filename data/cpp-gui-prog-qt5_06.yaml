- en: Integrating Web Content
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成网络内容
- en: In the previous chapter, we learned how to use item views and dialogs in Qt.
    In this chapter, we will learn how to integrate web content into our Qt application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在Qt中使用项目视图和对话框。在这一章中，我们将学习如何将网络内容集成到我们的Qt应用程序中。
- en: Starting from the dotcom era in the late 90s and early 2000s, our world has
    become more and more connected by the internet. Naturally, the applications running
    on our computers are also evolving in that direction. Nowadays, most—if not all—of
    our software is in some way connected to the internet, usually to retrieve useful
    information and display it to their users. The easiest way to do this is to embed
    a web browser display (also known as a web view) into the application's user interface.
    That way, the users can not only view the information, but do so in an aesthetic
    way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从90年代末和21世纪初的互联网时代开始，我们的世界变得越来越被互联网连接。自然地，运行在我们计算机上的应用程序也朝着这个方向发展。如今，我们大多数——如果不是全部——的软件在某种程度上都与互联网连接，通常是为了检索有用的信息并将其显示给用户。最简单的方法是将网络浏览器显示（也称为网络视图）嵌入到应用程序的用户界面中。这样，用户不仅可以查看信息，而且可以以美观的方式进行查看。
- en: By using the web view, developers can take advantage of its rendering capability
    and decorate their contents using the powerful combination of **HTML** (**Hypertext
    Markup Language**) and **CSS** (**Cascading Style Sheets**). In this chapter,
    we will explore Qt's web engine module and create our very own web browser.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用网络视图，开发人员可以利用其渲染能力，并使用**HTML**（超文本标记语言）和**CSS**（层叠样式表）的强大组合来装饰他们的内容。在这一章中，我们将探索Qt的web引擎模块，并创建我们自己的网络浏览器。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Creating your own web browser
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你自己的网络浏览器
- en: Sessions, cookies, and cache
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话、cookie和缓存
- en: Integrating JavaScript and C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成JavaScript和C++
- en: Without further ado, let's check out how to create our own web browser in Qt!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说，让我们看看如何在Qt中创建我们自己的网络浏览器！
- en: Creating your own web browser
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你自己的网络浏览器
- en: Once upon a time, Qt used a different module called **WebKit** to render web
    contents on its user interface. However, the WebKit module has been completely
    deprecated since version 5.5 and replaced by a new module called **WebEngine**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从前，Qt使用一个名为**WebKit**的不同模块在其用户界面上渲染网络内容。然而，自5.5版本以来，WebKit模块已完全被弃用，并被一个名为**WebEngine**的新模块所取代。
- en: 'The new WebEngine module is based on the **Chromium** framework built by Google,
    and it will only work on the **Visual C++** compiler on the Windows platform.
    Therefore, if you''re running Windows, please make sure that you have installed
    **Microsoft Visual Studio** on your computer as well as all the **MSVC** components
    for Qt that match the version of Visual Studio installed on your computer. Other
    than that, the Qt WebEngine component is also required for this particular chapter.
    If you have skipped the components during Qt''s installation, all you need to
    do is to run the same installer again and install it there:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 新的WebEngine模块是基于谷歌构建的**Chromium**框架，它只能在Windows平台上的**Visual C++**编译器上运行。因此，如果你在运行Windows，确保你已经在你的计算机上安装了**Microsoft
    Visual Studio**以及与你的计算机上安装的Visual Studio版本匹配的Qt的**MSVC**组件。除此之外，这个特定章节还需要Qt WebEngine组件。如果你在Qt的安装过程中跳过了这些组件，你只需要再次运行相同的安装程序并在那里安装它：
- en: '![](img/02f1ed42-5efc-43a4-b0d7-40c1610c382e.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02f1ed42-5efc-43a4-b0d7-40c1610c382e.png)'
- en: Adding the web view widget
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加网络视图小部件
- en: 'Once you are ready, let''s get started! First, open up Qt Creator and create
    a new Qt Widgets Application project. After that, open up the project (`.pro`)
    file and add in the following text to enable the modules:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好了，让我们开始吧！首先，打开Qt Creator并创建一个新的Qt Widgets应用程序项目。之后，打开项目（`.pro`）文件并添加以下文本以启用模块：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you didn't install the MSVC component (on Windows) or the Qt WebEngine component,
    error messages will appear at this point if you are trying to build the project.
    Please run the Qt installer again if that's the case.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装MSVC组件（在Windows上）或Qt WebEngine组件，如果你尝试构建项目，此时将会出现错误消息。如果是这种情况，请再次运行Qt安装程序。
- en: 'Next, open up `mainwindow.h` and add the following header files:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开`mainwindow.h`并添加以下头文件：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After that, open up `mainwindow.h` and add the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，打开`mainwindow.h`并添加以下代码：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, add the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加以下代码：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Build and run the program now and you should see the following result:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建并运行程序，你应该看到以下结果：
- en: '![](img/d9118fa0-3227-49b7-a2bb-714e581d8784.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9118fa0-3227-49b7-a2bb-714e581d8784.png)'
- en: It's actually that simple. You have now successfully placed a web view on your
    application!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单。你现在已经成功地在你的应用程序上放置了一个网络视图！
- en: 'The reason why we''re writing C++ code to create the web view is that the default
    Qt Designer used by the Qt Creator doesn''t have web view in the widget box. The
    preceding code simply creates the `QWebEngineView` object, sets its parent object
    (in this case, the central widget), and sets the URL of the web page before showing
    the web view widget. If you want to use Qt Designer to place a web engine view
    on your UI, you must run the standalone Qt Designer located in your Qt installation
    directory. For example, if you''re running Windows, it''s located in `C:QtQt5.10.25.10.2msvc2017_64bin`.
    Please note that it''s located in the directory with the compiler name that supports
    the web engine:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用C++代码创建网络视图的原因是，Qt Creator使用的默认Qt Designer在小部件框中没有网络视图。前面的代码简单地创建了`QWebEngineView`对象，设置了它的父对象（在这种情况下是中央小部件），并在显示网络视图小部件之前设置了网页的URL。如果你想使用Qt
    Designer在你的UI上放置一个web引擎视图，你必须运行独立的Qt Designer，它位于你的Qt安装目录中。例如，如果你在Windows上运行，它位于`C:QtQt5.10.25.10.2msvc2017_64bin`。请注意，它位于支持web引擎的编译器名称的目录中：
- en: '![](img/0ff18712-2f53-4ce9-a66c-939f467147e6.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ff18712-2f53-4ce9-a66c-939f467147e6.png)'
- en: Creating a UI for a web browser
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为网络浏览器创建用户界面
- en: 'Next, we are going to turn this into a proper web browser. First, we need to
    add a few layout widgets so that we can put other widgets in place afterwards.
    Drag a Vertical Layout (1) onto the centralWidget and select the centralWidget
    from the object list. Then, click the Lay Out Vertically button (2) located at
    the top:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把它变成一个合适的网络浏览器。首先，我们需要添加一些布局小部件，以便稍后可以放置其他小部件。将垂直布局(1)拖放到centralWidget上，并从对象列表中选择centralWidget。然后，点击位于顶部的Lay
    Out Vertically按钮(2)：
- en: '![](img/bf92deaf-aeb4-44b2-9ae7-84a690721694.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf92deaf-aeb4-44b2-9ae7-84a690721694.png)'
- en: 'After that, select the newly added vertical layout, right-click and select
    Morph into | QFrame. The reason why we''re doing this is that we want to place
    the web view widget under this QFrame object instead of the central widget. We
    must convert the layout widget to a QFrame (or any QWidget-inherited) object so
    that it can *adopt* the web view as its child. Finally, rename the QFrame object
    to `webviewFrame`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，选择新添加的垂直布局，右键单击，选择Morph into | QFrame。我们这样做的原因是，我们希望将web视图小部件放在这个QFrame对象下，而不是中心小部件下。我们必须将布局小部件转换为QFrame(或任何继承自QWidget的)对象，以便它可以*采用*web视图作为其子对象。最后，将QFrame对象重命名为`webviewFrame`：
- en: '![](img/4c9ede35-a9f9-4f09-9158-12a6773bb646.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c9ede35-a9f9-4f09-9158-12a6773bb646.png)'
- en: 'Once you''re done with that, let''s drag and drop a Horizontal Layout widget
    above the QFrame object. Now we can see that the size of both the Horizontal Layout
    widget and the QFrame object are the same, and we don''t want that. Next, select
    the QFrame object and set its Vertical Policy to Expanding:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，让我们将水平布局小部件拖放到QFrame对象上方。现在我们可以看到水平布局小部件和QFrame对象的大小是相同的，我们不希望这样。接下来，选择QFrame对象，并将其垂直策略设置为Expanding：
- en: '![](img/41a44341-e29f-4869-be90-c8c26479e052.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41a44341-e29f-4869-be90-c8c26479e052.png)'
- en: 'Then, you will see the top layout widget is now very thin. Let''s temporarily
    set its height to `20`, like so:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您会看到顶部布局小部件现在非常窄。让我们暂时将其高度设置为`20`，如下所示：
- en: '![](img/804fd92d-c9dd-4e0c-8085-4f938384d1a4.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/804fd92d-c9dd-4e0c-8085-4f938384d1a4.png)'
- en: 'After that, drag and drop three push buttons to the horizontal layout and we
    can now set its top margin back to `0`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，将三个按钮拖放到水平布局中，现在我们可以将其顶部边距设置回`0`：
- en: '![](img/073c8c36-2d6a-4ab1-9c34-a62fdefd8695.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/073c8c36-2d6a-4ab1-9c34-a62fdefd8695.png)'
- en: Set the buttons' labels to `Back`, `Forward`, and `Refresh` respectively. You
    may also use icons instead of text to display on these buttons. If you wish to
    do that, simply set the text property to empty and select an icon from the icon
    property. For the sake of simplicity, we'll just display texts on the buttons
    for this tutorial.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将按钮的标签分别设置为`Back`、`Forward`和`Refresh`。您也可以使用图标而不是文本显示在这些按钮上。如果您希望这样做，只需将文本属性设置为空，并从图标属性中选择一个图标。为了简单起见，我们将在本教程中只在按钮上显示文本。
- en: 'Next, place a line edit widget on the right-hand side of the three buttons,
    followed by adding another push button with a `Go`label:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在三个按钮的右侧放置一个行编辑小部件，然后再添加另一个带有`Go`标签的按钮：
- en: '![](img/7c621b7f-d77a-4bab-8c9f-a4f45f2ca11c.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c621b7f-d77a-4bab-8c9f-a4f45f2ca11c.png)'
- en: After that, right-click on each of the buttons and select Go to slot. A window
    will pop up, select clicked() and press OK.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，右键单击每个按钮，然后选择转到插槽。窗口将弹出，选择clicked()，然后按OK。
- en: '![](img/ba8acc39-41ae-4c97-9b68-464ec3008baa.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba8acc39-41ae-4c97-9b68-464ec3008baa.png)'
- en: 'The signal functions for these buttons will look something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些按钮的信号函数将看起来像这样：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Basically, the `QWebEngineView`class already provided us with functions such
    as `back()`, `forward()` and `reload()`, so we just have to call these functions
    when the respective button is pressed. The `loadPage()` function, however, is
    a custom function that we will write:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`QWebEngineView`类已经为我们提供了`back()`、`forward()`和`reload()`等函数，所以我们只需在按下相应按钮时调用这些函数。然而，`loadPage()`函数是我们将编写的自定义函数。
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Remember to add the declaration for `loadPage()` in `mainwindow.h` as well.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在`mainwindow.h`中添加`loadPage()`的声明。
- en: 'Instead of just calling the `load()` function, I think we should do something
    more. Normally, users will not include the `http://` (or `https://)` scheme when
    typing the URL of the web page, but it is required when we are passing the URL
    to the web view. To solve this problem, we automatically check for the existence
    of the scheme. If none has been found, we will manually add the `http://` scheme
    to the URL. Also, don''t forget to call it at the beginning to replace the `load()`
    function:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该只调用`load()`函数，我认为我们应该做更多的事情。通常，用户在输入网页URL时不会包括`http://`(或`https://`)方案，但当我们将URL传递给web视图时，这是必需的。为了解决这个问题，我们会自动检查方案的存在。如果没有找到任何方案，我们将手动将`http://`方案添加到URL中。还要记得在开始时调用它来替换`load()`函数：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, right-click on the text input and select Go to slot. Then, select returnPressed()
    and click the OK button:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，右键单击文本输入，然后选择转到插槽。然后，选择returnPressed()，点击OK按钮：
- en: '![](img/a722c4f2-e653-4d97-bb37-5547c61835d4.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a722c4f2-e653-4d97-bb37-5547c61835d4.png)'
- en: 'This slot function will be called when the user presses the *Return* key on
    the keyboard once they have finished typing the web page URL. Logically, the user
    would expect the page to start loading not have to press the Go button every time
    they are done typing the URL. The code is really simple, we''ll just call the
    `loadPage()` function we just created in the previous step:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在完成输入网页URL后，按键盘上的*Return*键时，将调用此插槽函数。从逻辑上讲，用户希望页面开始加载，而不必每次输入URL后都要按Go按钮。代码非常简单，我们只需调用前面步骤中创建的`loadPage()`函数：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have done a significant amount of code, let''s build and run our
    project and see how it turns out:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了大量的代码，让我们构建并运行我们的项目，看看结果如何：
- en: '![](img/e0729566-832f-4121-9b6c-d68ddf187c50.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0729566-832f-4121-9b6c-d68ddf187c50.png)'
- en: 'The result shown doesn''t really look that great. For some reason, the new
    web view doesn''t seem to scale properly even on an expanding size policy, at
    least on Qt version 5.10, which is being used when writing this book. It might
    be fixed in the future version, but let''s find a way to solve this issue. What
    I did was to override an inherited function in the main window called `paintEvent()`.
    In `mainwindow.h`, simply add the function declaration, like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的结果看起来并不是很好。由于某种原因，新的 Web 视图似乎在扩展大小策略上也无法正确缩放，至少在编写本书时使用的 Qt 版本 5.10 上是如此。这个问题可能会在将来的版本中得到修复，但让我们找到解决这个问题的方法。我所做的是重写主窗口中继承的函数`paintEvent()`。在`mainwindow.h`中，只需添加函数声明，就像这样：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, write its definition in `mainwindow.cpp` like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`mainwindow.cpp`中编写其定义，就像这样：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This `paintEvent()` function will be automatically called by Qt whenever the
    main window needs to re-render its widgets (such as when the window is being resized).
    Since this function will be called when the application is being initialized and
    also when the window is being resized, we will use this function to manually resize
    the web view to fit with its parent widget.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当主窗口需要重新渲染其部件时（例如当窗口被调整大小时），Qt 会自动调用`paintEvent()`函数。由于这个函数在应用程序初始化时和窗口调整大小时都会被调用，我们将使用这个函数手动调整
    Web 视图的大小以适应其父部件。
- en: 'Build and run the program again and you should be able to get the web view
    to fit nicely, regardless of how you resize the main window. Additionally, I also
    removed the menu bar, toolbar, and status bar to make the whole interface look
    more tidy, since we''re not using any of those in this application:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建和运行程序，你应该能够让 Web 视图很好地适应，无论你如何调整主窗口的大小。此外，我还删除了菜单栏、工具栏和状态栏，以使整个界面看起来更整洁，因为我们在这个应用程序中没有使用这些功能：
- en: '![](img/244f4c48-0ee6-4dab-9873-101bfac0d247.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/244f4c48-0ee6-4dab-9873-101bfac0d247.png)'
- en: 'Next, we need a progress bar to show users the current progression of the page
    load. To do that, first we need to place a progress bar widget below the web view:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个进度条来显示用户当前页面加载的进度。为此，首先我们需要在 Web 视图下方放置一个进度条部件：
- en: '![](img/d092b79b-87d6-4b15-b1a9-f91c1cfb5e94.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d092b79b-87d6-4b15-b1a9-f91c1cfb5e94.png)'
- en: 'Then, add these two slot functions to `mainwindow.h`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`mainwindow.h`中添加这两个槽函数：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Their function definition in `mainwindow.cpp` looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在`mainwindow.cpp`中的函数定义如下：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first function, `webviewLoading()` simply takes the progression level (in
    the form of a percentage value) from the web view and directly supplies it to
    the progress bar widget.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`webviewLoading()`简单地从 Web 视图中获取进度级别（以百分比值的形式）并直接提供给进度条部件。
- en: 'The second function `webviewLoaded()` will replace the URL text on the address
    input with the actual URL of the web page loaded by the web view. Without this
    function, the address input will not display the correct URL after you''ve pressed
    the back button or the forward button. Once you''re done, let''s compile and run
    the project again. The result looks amazing:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数`webviewLoaded()`将用 Web 视图加载的网页的实际 URL 替换地址输入框上的 URL 文本。如果没有这个函数，地址输入框在你按下返回按钮或前进按钮后将不会显示正确的
    URL。完成后，让我们再次编译和运行项目。结果看起来很棒：
- en: '![](img/39428977-f800-4408-bbd9-451b45561382.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39428977-f800-4408-bbd9-451b45561382.png)'
- en: You will ask me, what's the actual use of this if I'm not making a web browser
    using Qt? There are many other uses for embedding a web view into your application,
    for instance, showing the latest news and updates of your product to the users
    through a nicely decorated HTML page, which is a common method used by most of
    the online games in the gaming market. The stream client, for example, also uses
    a web view to display the latest games and discounts to their players.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问我，如果我不是使用 Qt 制作 Web 浏览器，这有什么实际用途？将 Web 视图嵌入到应用程序中还有许多其他用途，例如，通过精美装饰的 HTML
    页面向用户展示产品的最新新闻和更新，这是游戏市场上大多数在线游戏使用的常见方法。例如，流媒体客户端也使用 Web 视图来向玩家展示最新的游戏和折扣。
- en: These are often called hybrid applications, which combine web content with native
    x, so you can leverage both dynamic contents from the web as well as code running
    natively that has the benefits of high performance and a consistent look and feel.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通常被称为混合应用程序，它们将 Web 内容与本地 x 结合在一起，因此你可以利用来自 Web 的动态内容以及具有高性能和一致外观和感觉优势的本地运行的代码。
- en: Other than that, you can also use it to display the printable report in HTML
    format. You can easily send the report to the printer, or save it as a PDF file
    by calling `webview->page()->print()` or `webview->page()->printToPdf()`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，你还可以使用它来以 HTML 格式显示可打印的报告。你可以通过调用`webview->page()->print()`或`webview->page()->printToPdf()`轻松地将报告发送到打印机，或将其保存为
    PDF 文件。
- en: 'To learn more about printing from the web view, check out the following link:
    [http://doc.Qt.io/Qt-5/qwebenginepage.html#print.](http://doc.Qt.io/Qt-5/qwebenginepage.html#print)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于从 Web 视图打印的信息，请查看以下链接：[http://doc.Qt.io/Qt-5/qwebenginepage.html#print.](http://doc.Qt.io/Qt-5/qwebenginepage.html#print)
- en: You might also want to create the entire user interface of your program using
    HTML and embed all the HTML, CSS and image files into Qt's resource package and
    run it locally from the web view. The possibilities are endless, the only limit
    is your imagination!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想使用 HTML 创建程序的整个用户界面，并将所有 HTML、CSS 和图像文件嵌入到 Qt 的资源包中，并从 Web 视图本地运行。可能性是无限的，唯一的限制是你的想象力！
- en: 'To learn more about Qt WebEngine, check out the documentation here: [https://doc.Qt.io/Qt-5/qtwebengine-overview.html.](https://doc.Qt.io/Qt-5/qtwebengine-overview.html)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Qt WebEngine 的信息，请查看这里的文档：[https://doc.Qt.io/Qt-5/qtwebengine-overview.html.](https://doc.Qt.io/Qt-5/qtwebengine-overview.html)
- en: Managing browser history
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理浏览器历史记录
- en: Qt's web engine stores all the links which the user has visited into an array
    structure for later use. The web view widget uses this to move back and forth
    between history by calling `back()` and `forward()`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 的 Web 引擎将用户访问过的所有链接存储在一个数组结构中以供以后使用。Web 视图部件使用这个结构通过调用`back()`和`forward()`在历史记录中来回移动。
- en: 'If you need to manually access this browsing history, add the following header
    to `mainwindow.h`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要手动访问此浏览历史记录，请在`mainwindow.h`中添加以下头文件：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After that, use the following code to obtain the browsing history in the form
    of a `QWebEngineHistory` object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下代码以获取以`QWebEngineHistory`对象形式的浏览历史记录：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can get the entire list of visited links from `history->items()` or navigate
    between history using functions such as `back()` or `forward()`. To clear the
    browsing history, call `history->clear()`. Alternatively, you can also do this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`history->items()`获取访问链接的完整列表，或者使用`back()`或`forward()`等函数在历史记录之间导航。要清除浏览历史记录，请调用`history->clear()`。或者，您也可以这样做：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To learn more about the `QWebEngineHistory` class, visit the following link:
    [http://doc.Qt.io/Qt-5/qwebenginehistory.html.](http://doc.Qt.io/Qt-5/qwebenginehistory.html)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`QWebEngineHistory`类的信息，请访问以下链接：[http://doc.Qt.io/Qt-5/qwebenginehistory.html.](http://doc.Qt.io/Qt-5/qwebenginehistory.html)
- en: Sessions, cookies, and cache
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话、cookie和缓存
- en: 'Just like any other web browser, the `WebEngine` module also supports mechanisms
    used to store temporary data and persistent data for session and cache. Sessions
    and cache are very important as they allow websites to remember your last visit
    and associate you with data, such as a shopping cart. The definitions of a session,
    a cookie, and a cache are shown as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他网络浏览器一样，`WebEngine`模块还支持用于存储临时数据和持久数据的机制，用于会话和缓存。会话和缓存非常重要，因为它们允许网站记住您的上次访问并将您与数据关联，例如购物车。会话、cookie和缓存的定义如下所示：
- en: '**Session**: Normally, sessions are server-side files that contain user information
    with a unique identifier, which gets sent from the client side to map them to
    a specific user. In Qt, however, a session simply means a cookie that doesn''t
    have any expiration date, and hence it will be gone when the program is closed.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话**：通常，会话是包含用户信息和唯一标识符的服务器端文件，从客户端发送以将它们映射到特定用户。然而，在Qt中，会话只是指没有任何过期日期的cookie，因此当程序关闭时它将消失。'
- en: '**Cookie**: Cookies are client-side files that contain user information or
    any other information that you want to save. Unlike sessions, cookies have an
    expiration date which means they will remain valid and can be retrieved before
    reaching the expiration date, even if the program has been closed and re-opened
    again.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cookie**：Cookie是包含用户信息或任何您想要保存的其他信息的客户端文件。与会话不同，cookie具有过期日期，这意味着它们将保持有效，并且可以在到达过期日期之前检索，即使程序已关闭并重新打开。'
- en: '**Cache**: Caching is a method used to speed up page loading by saving the
    page and its resources to a local disk during its first load. If the user loads
    the same page again on the next visit, the web browser will reuse the cached resources
    instead of waiting for the download to complete, which can significantly speed
    up the page loading time.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：缓存是一种用于加快页面加载速度的方法，通过在首次加载时将页面及其资源保存到本地磁盘。如果用户在下次访问时再次加载同一页面，Web浏览器将重用缓存的资源，而不是等待下载完成，这可以显著加快页面加载时间。'
- en: Managing sessions and cookies
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理会话和cookie
- en: By default, `WebEngine` doesn't save any cookie and treats all user information
    as temporary sessions, which means when you close the program, your login session
    on the web page will automatically become invalid.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`WebEngine`不保存任何cookie，并将所有用户信息视为临时会话，这意味着当您关闭程序时，您在网页上的登录会话将自动失效。
- en: 'To enable cookies on Qt''s `WebEngine `module, first add the following header
    to `mainwindow.h`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Qt的`WebEngine`模块上启用cookie，首先在`mainwindow.h`中添加以下头文件：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, simply call the following function to force persistent cookies:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需调用以下函数以强制使用持久性cookie：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After calling the preceding function, your login session will continue to exist
    after closing the program. To revert it to non-persistent cookies, we simply call:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 调用上述函数后，您的登录会话将在关闭程序后继续存在。要恢复为非持久性cookie，我们只需调用：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Other than that, you can also change the directory in which your Qt program
    stores the cookies. To do that, add the following code to your source file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，您还可以更改Qt程序存储cookie的目录。要做到这一点，请将以下代码添加到您的源文件中：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If, for some reason, you want to manually delete all the cookies, use the following
    code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，您想手动删除所有cookie，请使用以下代码：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Managing cache
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理缓存
- en: Next, let's talk about a cache. There are two types of cache which you can use
    in the web engine module, namely, Memory Cache and Disk Cache. Memory Cache uses
    the computer's memory to store the cache, which will be gone once you've closed
    the program. On the other hand, Disk Cache saves all the files in the hard disk,
    and hence they will still remain, even after you've turned off your computer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈缓存。在Web引擎模块中，有两种类型的缓存，即内存缓存和磁盘缓存。内存缓存使用计算机的内存来存储缓存，一旦关闭程序就会消失。另一方面，磁盘缓存将所有文件保存在硬盘中，因此它们将在关闭计算机后仍然存在。
- en: 'By default, the web engine module saves all the cache to the disk, if you need
    to change them to Memory Cache, call the following function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Web引擎模块将所有缓存保存到磁盘，如果需要将它们更改为内存缓存，请调用以下函数：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively, you can also disable caching completely by calling:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以通过调用完全禁用缓存：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As for changing the folder to which your program saves the cache files, call
    the `setCachePath()` function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改程序保存缓存文件的文件夹，请调用`setCachePath()`函数：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lastly, to delete all the cache files, call `clearHttpCache()`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要删除所有缓存文件，请调用`clearHttpCache()`：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are many other functions that you can use to change the settings related
    to cookies and cache.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他函数可用于更改与cookie和缓存相关的设置。
- en: You can read more about it at the following link: [https://doc.Qt.io/Qt-5/qwebengineprofile.html](https://doc.Qt.io/Qt-5/qwebengineprofile.html)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中了解更多信息：[https://doc.Qt.io/Qt-5/qwebengineprofile.html](https://doc.Qt.io/Qt-5/qwebengineprofile.html)
- en: Integrating JavaScript and C++
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成JavaScript和C++
- en: One powerful feature of using Qt's web engine module is that it can call JavaScript
    functions from C++, as well as calling C++ functions from JavaScript. This makes
    it more than just a web browser. You can use this to access features that are
    not supported by the web browser standard, such as file management and hardware
    integration. Things like that are not possible with W3C standards; hence, it is
    not possible to do it in native JavaScript. However, you can implement these features
    using C++ and Qt, then simply call the C++ functions from your JavaScript. Let's
    take a look at how we can achieve this with Qt.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Qt的Web引擎模块的一个强大功能是它可以从C++调用JavaScript函数，以及从JavaScript调用C++函数。这使它不仅仅是一个Web浏览器。您可以使用它来访问Web浏览器标准不支持的功能，例如文件管理和硬件集成。这些功能在W3C标准中是不可能的；因此，无法在原生JavaScript中实现。但是，您可以使用C++和Qt来实现这些功能，然后简单地从JavaScript中调用C++函数。让我们看看如何在Qt中实现这一点。
- en: Calling JavaScript functions from C++
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从C++调用JavaScript函数
- en: 'After that, add in the following code to the HTML file we just created:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，将以下代码添加到我们刚创建的HTML文件中：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'These are the basic HTML tags which show you nothing other than a line of words
    that says `Hello World!`. You can try and load it using your web browser:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是基本的HTML标记，除了显示一行文字`Hello World!`之外，什么也不显示。您可以尝试使用Web浏览器加载它：
- en: '![](img/84001c1c-aabc-4ff1-80bf-b05771ab51cf.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84001c1c-aabc-4ff1-80bf-b05771ab51cf.png)'
- en: 'After that, let''s go back to our Qt project and go to File | New File or Project
    and create a Qt Resource File:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们返回到我们的Qt项目中，然后转到文件|新建文件或项目，并创建一个Qt资源文件：
- en: '![](img/1d9d3c88-e775-4c5e-bd46-ab54e7a7ab81.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d9d3c88-e775-4c5e-bd46-ab54e7a7ab81.png)'
- en: 'Then, open up the Qt resource file we just created and add in an `/html` prefix
    followed by adding the HTML file to the resource file, like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开我们刚创建的Qt资源文件，并在HTML文件中添加`/html`前缀，然后将HTML文件添加到资源文件中，就像这样：
- en: '![](img/8c17bb18-d44b-4989-a04d-0e8b7ea3b91e.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c17bb18-d44b-4989-a04d-0e8b7ea3b91e.png)'
- en: 'Right-click on text.html while the resource file is still opened, then select
    Copy Resource Path to Clipboard. Right after that, change the URL of your web
    view to:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源文件仍然打开的情况下，右键单击`text.html`，然后选择复制资源路径到剪贴板。然后，立即更改您的Web视图的URL：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can use the link you just copied from the resource file, but make sure
    you add the URL scheme `qrc://` at the front of the link. Build and run your project
    now and you should be able to see the result instantly:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用刚从资源文件中复制的链接，但请确保在链接前面添加URL方案`qrc://`。现在构建并运行您的项目，您应该能够立即看到结果：
- en: '![](img/3908ba70-8603-4631-bfef-3994e2929583.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3908ba70-8603-4631-bfef-3994e2929583.png)'
- en: 'Next, we need to set up a function in JavaScript that will be called by C++
    in just a moment. We''ll just create a simple function that pops up a simple message
    box and changes the `Hello World!` text to something else when called:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在JavaScript中设置一个函数，稍后将由C++调用。我们将创建一个简单的函数，当调用时弹出一个简单的消息框并将`Hello World!`文本更改为其他内容：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that I have added an ID to the `Hello World!` text so that we are able
    to find it and change its text. Once you're done, let's go to our Qt project again.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已经为`Hello World!`文本添加了一个ID，以便我们能够找到它并更改其文本。完成后，让我们再次转到我们的Qt项目。
- en: 'Let''s proceed to add a push button to our program UI, and when the button
    is pressed, we want our Qt program to call the `hello()` function we just created
    in JavaScript. It''s actually very easy to do that in Qt; you simply call the
    `runJavaScript()` function from the `QWebEnginePage` class, like so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续向程序UI添加一个按钮，当按钮被按下时，我们希望我们的Qt程序调用我们刚刚在JavaScript中创建的`hello()`函数。在Qt中做到这一点实际上非常容易；您只需从`QWebEnginePage`类中调用`runJavaScript()`函数，就像这样：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The result is pretty astounding, as you can see from the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 结果非常惊人，您可以从以下截图中看到：
- en: '![](img/e860b594-575b-49c9-81dc-922f1dbb9067.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e860b594-575b-49c9-81dc-922f1dbb9067.png)'
- en: You can do a lot more than just change the text or call a message box. For example,
    you can start or stop an animation in an HTML canvas, show or hide an HTML element,
    trigger an Ajax event to retrieve information from a PHP script, and so on and
    so forth... endless possibilities!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以做的远不止更改文本或调用消息框。例如，您可以在HTML画布中启动或停止动画，显示或隐藏HTML元素，触发Ajax事件以从PHP脚本中检索信息，等等...无限的可能性！
- en: Calling C++ functions from JavaScript
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从JavaScript调用C++函数
- en: 'Next, let''s take a look at how we can call C++ functions from JavaScript instead.
    For the sake of demonstration, I''ll put a text label above the web view and we
    will change its text using a JavaScript function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何从JavaScript中调用C++函数。为了演示，我将在Web视图上方放置一个文本标签，并使用JavaScript函数更改其文本：
- en: '![](img/a962a250-b7c4-4945-93ad-ddc7ae12a78b.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a962a250-b7c4-4945-93ad-ddc7ae12a78b.png)'
- en: 'Normally, JavaScript can only work within the HTML environment and hence, is
    only able to alter HTML elements and not something outside the web view. However,
    Qt allows us to do just that by using the web channel module. So let''s open up
    our project (`.pro`) file and add the web channel module to the project:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，JavaScript只能在HTML环境中工作，因此只能更改HTML元素，而不能更改Web视图之外的内容。但是，Qt允许我们通过使用Web通道模块来做到这一点。因此，让我们打开我们的项目（`.pro`）文件并将Web通道模块添加到项目中：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After that, open up `mainwindow.h` and add in the `QWebChannel` header:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，打开`mainwindow.h`并添加`QWebChannel`头文件：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'At the same time, we also declare a function called `doSomething()`, with a
    `Q_INVOKABLE` macro in front of it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们还声明一个名为`doSomething()`的函数，并在其前面加上`Q_INVOKABLE`宏：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `Q_INVOKABLE` macro tells Qt to expose the function to the JavaScript engine,
    and thus the function can then be called from JavaScript (and QML, since QML is
    also based on JavaScript).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q_INVOKABLE`宏告诉Qt将函数暴露给JavaScript引擎，因此该函数可以从JavaScript（以及QML，因为QML也基于JavaScript）中调用。'
- en: Then in `mainwindow.cpp`, we'll have to first create a `QWebChannel` object
    and register our main window as a JavaScript object. You can register any Qt object
    as a JavaScript object as long as it is derived from the `QObject` class.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`mainwindow.cpp`中，我们首先需要创建一个`QWebChannel`对象，并将我们的主窗口注册为JavaScript对象。只要从`QObject`类派生，就可以将任何Qt对象注册为JavaScript对象。
- en: 'Since we''re going to call the `doSomething()` function from JavaScript, we
    must register the main window to the JavaScript engine. After that, we also need
    to set the `QWebChannel` object we just created as the web channel of our web
    view. The code looks like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将从JavaScript中调用`doSomething（）`函数，因此我们必须将主窗口注册到JavaScript引擎。之后，我们还需要将刚刚创建的`QWebChannel`对象设置为我们的web视图的web通道。代码如下所示：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once you''re done with that, let''s define the `doSomething()` function. We''re
    just going to do something simple—change the text label on our Qt GUI, and that''s
    all:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，让我们定义`doSomething（）`函数。我们只是做一些简单的事情——改变我们的Qt GUI上的文本标签，就这样：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We''re done with the C++ code, let''s open up our HTML file. There are couple
    of things we need to do to make this work. First, we need to include the `qwebchannel.js`
    script that is embedded in your Qt program by default, so you don''t have to search
    for that file in your Qt directory. Add the following code in between the `head`
    tags:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了C++代码，让我们打开HTML文件。我们需要做一些事情才能使其工作。首先，我们需要包含默认嵌入在Qt程序中的`qwebchannel.js`脚本，这样您就不必在Qt目录中搜索该文件。在`head`标签之间添加以下代码：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, we create a `QWebChannel` object in JavaScript when the document is successfully
    being loaded by web view and link the `mainwindow` variable to the actual main
    window object from Qt (which we registered earlier in C++). This step must only
    be done after the web page has been loaded (through `window.onload` callback);
    otherwise, there might be problems creating the web channel:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在JavaScript中，当文档成功被web视图加载时，我们创建一个`QWebChannel`对象，并将`mainwindow`变量链接到之前在C++中注册的实际主窗口对象。这一步必须在网页加载后才能完成（通过`window.onload`回调）；否则，可能会出现创建web通道的问题：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After that, we create a JavaScript function that calls the `doSomething()`
    function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建一个调用`doSomething（）`函数的JavaScript函数：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, add a button to the HTML body and make sure `myFunction()` is called
    when the button is pressed:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在HTML主体中添加一个按钮，并确保在按下按钮时调用`myFunction（）`：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Build and run the program now and you should be able to get the following result:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建并运行程序，您应该能够获得以下结果：
- en: '![](img/eebf2409-5486-476d-b772-06ec44cbed98.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eebf2409-5486-476d-b772-06ec44cbed98.png)'
- en: 'You can do a lot of useful things using this method other than altering the
    properties of a Qt widget. For example, saving a file to the local hard disk,
    getting scanned data from a barcode scanner, and so on. There is no longer any
    barrier between native and web technology. However, do be extra aware of any possible
    security implications of this technique. As the old saying goes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更改Qt小部件的属性之外，您可以使用此方法做很多有用的事情。例如，将文件保存到本地硬盘，从条形码扫描仪获取扫描数据等。本地和Web技术之间不再有障碍。但是，请格外注意此技术可能带来的安全影响。正如古话所说：
- en: '"With great power comes great responsibility."'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: “伟大的力量带来伟大的责任。”
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to create our own web browser and make
    it interact with the native code. Qt provides us with the web channel technology
    that makes Qt a very powerful platform for software development.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学会了如何创建自己的网络浏览器，并使其与本地代码交互。Qt为我们提供了Web通道技术，使Qt成为软件开发的一个非常强大的平台。
- en: It takes advantage of both the power of Qt and the beauty of web technology,
    which means you can have a lot more options when it comes to development and not
    just be limited to Qt's methods. I'm really excited and can't wait to see what
    you can achieve with this!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 它充分利用了Qt的强大功能和Web技术的美感，这意味着在开发时你可以有更多的选择，而不仅仅局限于Qt的方法。我非常兴奋，迫不及待地想看看你能用这个技术实现什么！
- en: Join us in the next chapter to learn how to create a map viewer similar to Google
    Maps, using Qt!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的下一章，学习如何创建一个类似Google Maps的地图查看器，使用Qt！
