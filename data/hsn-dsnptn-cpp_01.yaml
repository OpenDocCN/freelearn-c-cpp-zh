- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: An Introduction to Inheritance and Polymorphism
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和多态简介
- en: '**C++** is, first and foremost, an object-oriented language, and objects are
    the fundamental building blocks of a C++ program. Class hierarchies are used to
    express relationships and interactions between different parts of a software system,
    define and implement interfaces between components, and organize data and code.
    While this isn’t a book for teaching C++, the aim of this chapter is to give the
    reader enough knowledge about C++ language features as they relate to classes
    and inheritance, which will be used in later chapters. To that end, we won’t attempt
    to completely describe the C++ tools for working with classes but introduce the
    concepts and language constructs that will be used throughout this book.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**C++**首先是一种面向对象的语言，对象是C++程序的基本构建块。类层次结构用于表达软件系统不同部分之间的关系和交互，定义和实现组件之间的接口，以及组织和代码。虽然这不是一本专门教授C++的书，但本章的目的是让读者对与类和继承相关的C++语言特性有足够的了解，这些特性将在后面的章节中使用。为此，我们不会试图完全描述用于处理类的C++工具，而是介绍本书中将使用的概念和语言结构。'
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What are classes and what is their role in C++?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是类以及它们在C++中的作用？
- en: What are class hierarchies and how does C++ use inheritance?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是类层次结构以及C++是如何使用继承的？
- en: What is runtime polymorphism and how is it used in C++?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时多态是什么以及如何在C++中使用它？
- en: Classes and objects
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象
- en: Object-oriented programming is a way to structure a program by combining the
    algorithms and the data that the algorithms operate on into single entities called
    **objects**. Most object-oriented languages, including C++, are class-based. A
    **class** is a definition of an object—it describes the algorithms and the data,
    its format, and its relations to other classes. An object is a concrete instantiation
    of a class, that is, a variable. An object has an address, which is a location
    in memory. A class is a user-defined type. In general, any number of objects can
    be instantiated from the definition provided by the class (some classes limit
    the number of objects that can be created, but this is an exception, not the norm).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是一种通过将算法及其操作的数据组合成单个实体（称为**对象**）来结构化程序的方法。大多数面向对象的语言，包括C++，都是基于类的。**类**是对对象的定义——它描述了算法和数据，其格式以及与其他类的关系。对象是类的具体实例化，即变量。对象有一个地址，它是内存中的一个位置。类是用户定义的类型。一般来说，可以从类提供的定义中实例化任意数量的对象（有些类限制了可以创建的对象数量，但这是一种例外，而不是常态）。
- en: In C++, the data contained in a class is organized as a collection of data members,
    or variables, of different types. The algorithms are implemented as functions—the
    methods of the class. While there’s no language requirement that the data members
    of a class should be somehow relevant to the implementation of its methods, it’s
    one of the signs of good design when the data is well encapsulated in the classes,
    and the methods have limited interaction with external data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，类中包含的数据被组织为不同类型的数据成员或变量的集合。算法通过函数实现——类的成员方法。虽然没有语言要求类中的数据成员必须以某种方式与方法的实现相关，但当数据在类中得到良好的封装，并且方法与外部数据的交互有限时，这是良好设计的一个标志。
- en: 'This concept of **encapsulation** is central to the classes in C++—the language
    allows us to control which data members and methods are public—visible outside
    of the class, and which are internal—private to the class. A well-designed class
    has mostly, or only, private data members, and the only public methods are those
    needed to express the public interface of the class—in other words, what the class
    does. This public interface is like a contract—the class designer promises that
    this class provides certain features and operations. The private data and methods
    of the class are part of the implementation, and they can be changed as long as
    the public interface, the contract we’ve committed to, remains valid. For example,
    the following class represents a rational number and supports the increment operation,
    as exposed by its public interface:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种**封装**的概念是 C++ 中类的基础——该语言允许我们控制哪些数据成员和方法是公共的——在类外可见，哪些是内部的——私有的。一个设计良好的类主要或只有私有数据成员，唯一的公共方法是需要表达类的公共接口的方法——换句话说，类做什么。这个公共接口就像一份合同——类的设计者承诺这个类提供某些特性和操作。类的私有数据和方法是实现的一部分，只要公共接口，我们承诺的合同保持有效，它们就可以被更改。例如，以下类表示一个有理数并支持增量操作，如其公共接口所公开的：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A well-designed class doesn’t expose any more of the implementation details
    than it has to through its public interface. The implementation isn’t part of
    the contract, although the documented interface may impose some restrictions on
    it. For example, if we promise that all rational numbers don’t contain any common
    multipliers in the numerator and denomination, the addition should include the
    step of canceling them. That would be a good use of a private member function—the
    implementation of several other operations will need to call it, but the client
    of the class never needs to call it because every rational number is already reduced
    to its lowest terms before it’s exposed to the callers:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的类不会通过其公共接口暴露比它必须暴露的更多实现细节。实现不是合同的一部分，尽管文档化的接口可能对它施加一些限制。例如，如果我们承诺所有有理数在分子和分母中不包含任何公共的乘数，那么加法应该包括取消这些乘数的步骤。这将是一个很好的使用私有成员函数的例子——实现其他几个操作将需要调用它，但类的客户端永远不需要调用它，因为每个有理数在暴露给调用者之前都已经化简到最简形式：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The class methods have special access to the data members—they can access the
    private data of the class. Note the distinction between the class and the object
    here—`operator+=()` is a method of the `Rational` class and is invoked on the
    object, `a`. However, it has access to the private data of the `b` object as well,
    because `a` and `b` are objects of the same class. If a member function references
    a class member by name without any additional qualifiers, then it’s accessing
    a member of the same class it’s invoked on (we can make it explicit by writing
    `this->n_` and `this->d_`). Accessing members of another object of the same class
    requires a pointer or a reference to that object, but is otherwise not restricted,
    as would have been the case if we tried to access a private data member from a
    non-member function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法可以特殊访问数据成员——它们可以访问类的私有数据。注意这里类和对象的区别——`operator+=()` 是 `Rational` 类的方法，并在对象
    `a` 上调用。然而，它也可以访问 `b` 对象的私有数据，因为 `a` 和 `b` 是同一类的对象。如果一个成员函数通过名称引用类成员而没有任何额外的限定符，那么它是在访问它所调用的同一类的成员（我们可以通过写入
    `this->n_` 和 `this->d_` 来使其更明确）。访问同一类中另一个对象的成员需要一个指向该对象的指针或引用，但除此之外没有其他限制，就像我们尝试从一个非成员函数访问私有数据成员时的情况一样。
- en: By the way, C++ also supports C-style structs. But in C++, a struct isn’t limited
    to just an aggregate of data members—it can have methods, public and private access
    modifiers, and anything else classes have. From a language point of view, the
    only difference between a class and a struct is the default access—in a class,
    all members and methods are private by default, while in a struct they’re public.
    Beyond that, the use of structs instead of classes is a matter of convention—traditionally,
    structs are used for C-style structs (structs that would be legal in C) as well
    as *almost* C-style structs, for example, a struct with only a constructor added.
    Of course, this boundary isn’t precise and is a matter of coding styles and practices
    in each project or team.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，C++ 也支持 C 风格的结构体。但在 C++ 中，结构体不仅仅是一个数据成员的聚合——它可以有方法、公有和私有访问修饰符，以及类具有的一切。从语言的角度来看，类和结构体之间的唯一区别是默认访问——在类中，所有成员和方法默认为私有，而在结构体中它们是公有的。除此之外，使用结构体而不是类是一个约定问题——传统上，结构体用于
    C 风格的结构体（在 C 中合法的结构体）以及*几乎*是 C 风格的结构体，例如，只添加了构造函数的结构体。当然，这个边界并不精确，是每个项目或团队编码风格和实践的问题。
- en: In addition to the methods and data members we’ve seen, C++ also supports static
    data and methods. A static method is very similar to a regular non-member function—it
    isn’t invoked on any particular object, and the only way it can get access to
    an object of any type is through its arguments. However, unlike a non-member function,
    a static method retains its privileged access to the private data of the class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们看到的 方法和数据成员之外，C++ 还支持静态数据和静态方法。静态方法与常规的非成员函数非常相似——它不会在特定的对象上调用，它能够访问任何类型的对象的方式只有通过其参数。然而，与非成员函数不同，静态方法保留了其对类私有数据的特权访问。
- en: Classes by themselves are a useful way to group together (encapsulate) the algorithms
    and the data they operate on and to limit access to some data. However, the most
    powerful object-oriented features of C++ are inheritance and the resulting class
    hierarchies.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 类本身是一种将算法和它们操作的数据（封装）在一起的有用方式，并限制对某些数据的访问。然而，C++ 最强大的面向对象特性是继承和由此产生的类层次。
- en: Inheritance and class hierarchies
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和类层次
- en: Class hierarchies in C++ serve a dual purpose. On the one hand, they allow us
    to express relations between objects. On the other hand, they let us compose more
    complex types from simpler ones. Both uses are accomplished through inheritance.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的类层次具有双重作用。一方面，它们允许我们表达对象之间的关系。另一方面，它们使我们能够从更简单的类型组合出更复杂的类型。这两种用途都是通过继承实现的。
- en: The concept of inheritance is central to the C++ use of classes and objects.
    Inheritance allows us to define new classes as extensions of existing ones. When
    a derived class is inherited from the base class, it contains, in some form, all
    of the data and the algorithms that were in the base class, and it adds some of
    its own. In C++, it’s important to distinguish between two primary types of inheritance—public
    and private.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的概念是 C++ 中类和对象使用的关键。继承使我们能够将新类定义为现有类的扩展。当一个派生类从基类继承时，它以某种形式包含了基类中的所有数据和算法，并添加了一些自己的。在
    C++ 中，区分两种主要的继承类型——公有继承和私有继承——非常重要。
- en: Public inheritance inherits the public interface of the class. It also inherits
    the implementation—the data members of the base class are also a part of the derived
    class. But the inheritance of the interface is what distinguishes public inheritance—the
    derived class has, as a part of its public interface, the public member functions
    of the base class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 公有继承继承了类的公共接口。它也继承了实现——基类的数据成员也是派生类的一部分。但接口的继承是区分公有继承的关键——派生类作为其公共接口的一部分，包含了基类的公共成员函数。
- en: Remember that the public interface is like a contract—we promise to the clients
    of the class that it supports certain operations, maintains some invariants, and
    obeys the specified restrictions. By publicly inheriting from the base class,
    we bind the derived class to the same contract (plus any extensions of the contract,
    should we decide to define additional public interfaces). Because the derived
    class also respects the interface contract of the base class, we could use a derived
    class in any place in the code where a base class is expected—we would not be
    able to use any of the extensions to the interface (the code expects the base
    class, we don’t know about any extensions at that point), but the base class interface
    and its restrictions have to be valid.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，公共接口就像一份契约——我们向类的客户端承诺它支持某些操作，维护某些不变性，并遵守指定的限制。通过从基类公开继承，我们将派生类绑定到相同的契约（以及如果我们决定定义额外的公共接口，契约的任何扩展）。因为派生类也尊重基类的接口契约，所以我们可以将派生类用于代码中任何期望基类的地方——我们无法使用接口的任何扩展（代码期望基类，我们不知道在那个点有任何扩展），但基类接口及其限制必须是有效的。
- en: 'This is often expressed as the *is-a principle*—an instance of a derived class
    is also an instance of the base class. However, the way we interpret the *is-a*
    relationship in C++ isn’t exactly intuitive. For example, is a square a rectangle?
    If it is, then we can derive the `Square` class from the `Rectangle` class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常被表达为“is-a原则”——派生类的实例也是基类的实例。然而，我们在C++中对“is-a”关系的解释并不完全直观。例如，正方形是矩形吗？如果是的话，那么我们可以从`Rectangle`类派生出`Square`类：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Right away, there’s something that doesn’t seem right—the derived class has
    two data members for dimensions, but it really needs only one. We would have to
    somehow enforce that they’re always the same. This doesn’t seem so bad—the `Rectangle`
    class has the interface that allows for any positive values of length and width,
    and the `Square` imposes additional restrictions. But it’s worse than that—the
    `Rectangle` class has a contract that allows the user to make the dimensions different.
    This can be quite explicit:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 立刻就有一些事情看起来不对——派生类有两个表示尺寸的数据成员，但实际上只需要一个。我们必须以某种方式强制它们始终相同。这看起来并不那么糟糕——`Rectangle`类有一个接口，允许长度和宽度的任何正值，而`Square`施加了额外的限制。但问题更严重——`Rectangle`类有一个允许用户使尺寸不同的契约。这可以非常明确：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we have a public method that allows us to distort the rectangle, altering
    its aspect ratio. As with any other public method, it’s inherited by the derived
    classes, so now the `Square` class has it too. In fact, by using public inheritance,
    we assert that a `Square` object can be used anywhere a `Rectangle` object is
    used, without even knowing that it’s really a `Square`. Clearly, this is a promise
    we can’t keep—when the client of our class hierarchy tries to change the aspect
    ratio of a square, we can’t do it. We could ignore the call or report an error
    at runtime. Either way, we’ve violated the contract provided by the base class.
    There’s only one solution—in C++, a square isn’t a rectangle. Note that a rectangle
    is usually not a square, either—the contract provided by the `Square` interface
    could contain any number of guarantees that we can’t maintain if we derive the
    `Rectangle` class from `Square`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个公共方法，允许我们扭曲矩形，改变其宽高比。与其他任何公共方法一样，它被派生类继承，所以现在`Square`类也有这个方法。实际上，通过使用公共继承，我们断言一个`Square`对象可以在任何需要`Rectangle`对象的地方使用，即使不知道它实际上是一个`Square`。显然，这是一个我们无法兑现的承诺——当我们的类层次结构的客户端试图改变正方形的宽高比时，我们无法做到。我们可以忽略这个调用或在运行时报告错误。无论如何，我们都违反了基类提供的契约。唯一的解决方案是——在C++中，正方形不是矩形。注意，矩形通常也不是正方形——`Square`接口提供的契约可能包含任何我们无法维持的保证，如果我们从`Square`派生出`Rectangle`类。
- en: Similarly, a penguin isn’t a bird in C++ if the bird interface includes flying.
    The correct design for such cases usually includes a more abstract base class,
    `Bird`, that doesn’t make any promises that at least one derived class can’t keep
    (for example, a `Bird` object doesn’t make a guarantee that it can fly). Then,
    we create intermediate-based classes, such as `FlyingBird` and `FlightlessBird`,
    that are derived from the common base class and serve as base classes for the
    more specific classes such as `Eagle` or `Penguin`. The important lesson here
    is that whether or not a penguin is a bird in C++ depends on how we define what
    a bird is, or, in C++ terms, what the public interface of the `Bird` class is.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在C++中，如果鸟类接口包括飞行，那么企鹅不是鸟类。对于这种情况的正确设计通常包括一个更抽象的基类`Bird`，它不做出任何承诺，即至少有一个派生类无法保持（例如，`Bird`对象不保证它可以飞行）。然后，我们创建基于中间类的类，例如`FlyingBird`和`FlightlessBird`，这些类是从公共基类派生出来的，并作为更具体类（如`Eagle`或`Penguin`）的基类。这里的重要教训是，企鹅在C++中是否是鸟类取决于我们如何定义鸟类，或者用C++术语来说，`Bird`类的公共接口是什么。
- en: 'Because the public inheritance implies the *is-a* relationship, the language
    allows a wide range of conversions between references and pointers to different
    classes in the same hierarchy. First of all, a conversion from a pointer to a
    derived class into a pointer to the base class is implicit (this is the same for
    references):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于公有继承隐含了`is-a`关系，语言允许在同一层次结构中不同类的引用和指针之间进行广泛的转换。首先，从派生类指针到基类指针的转换是隐式的（这同样适用于引用）：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This conversion is always valid because an instance of the derived class is
    also an instance of the base class. The inverse conversion is possible but has
    to be made explicit:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换始终有效，因为派生类的实例也是基类的实例。逆转换是可能的，但必须明确进行：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The reason this conversion isn’t implicit is that it’s valid only if the base
    class pointer really points to a derived object (otherwise, the behavior is undefined).
    The programmer, therefore, must explicitly assert, using the static cast, that
    somehow, through the logic of the program or a prior test or by some other means,
    it’s known that this conversion is valid. If you aren’t sure that the conversion
    is valid, there’s a safer way to try it without causing undefined behavior; we’ll
    learn about this in the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转换不是隐式的，因为只有在基类指针确实指向一个派生对象时才是有效的（否则行为是未定义的）。因此，程序员必须显式地断言，通过程序的逻辑、先前的测试或其他方式，已知这种转换是有效的。如果你不确定转换是否有效，有一种更安全的方法来尝试它而不会导致未定义的行为；我们将在下一节中了解这一点。
- en: 'Note that the static (or implicit) conversion between pointers to base and
    derived classes is not quite as straightforward as you might think. The first
    base of any object always has the same address as the derived object itself, but
    then it gets more complicated. There is generally no standard requirement on the
    memory layout of derived classes with multiple bases:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，基类和派生类指针之间的静态（或隐式）转换并不像你想象的那么简单。任何对象的第一个基类始终具有与派生对象本身相同的地址，但之后事情就变得复杂了。对于具有多个基类的派生类的内存布局通常没有标准要求：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Most compilers will lay out the base classes first, then the data members of
    the derived class:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编译器会首先布局基类，然后是派生类的数据成员：
- en: '![](img/Figure_1.1_B19262.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_1.1_B19262.jpg)'
- en: Figure 1.1 – Possible memory layout of a derived class
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 派生类的可能内存布局
- en: 'From *Figure 1**.1*, it is evident that pointer conversion between the base
    and derived classes generally involves offset calculations. We can easily see
    this in an example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从**图1.1**可以看出，基类和派生类之间的指针转换通常涉及偏移量计算。我们可以在一个例子中轻松地看到这一点：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The program prints something like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会打印出类似以下内容：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can see that the `Base1` object is located at the same address as the `Derived`
    object, and `Base2` starts with an offset (16 bytes, in our case). Seems like
    the cast is an easy calculation: If you have a pointer to `Derived` and you want
    to cast to `Base2`, add 16\. The offsets between base classes are known at compile
    time, and the compiler knows the layout it is using. Pointer offset calculations
    are usually implemented in hardware (all modern CPUs support them and do not require
    a separate addition instruction). This doesn’t sound so hard at all.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到 `Base1` 对象位于与 `Derived` 对象相同的地址，而 `Base2` 从一个偏移量（在我们的例子中是16字节）开始。看起来类型转换是一个简单的计算：如果你有一个指向
    `Derived` 的指针，并且想要转换到 `Base2`，就加16。基类之间的偏移量在编译时是已知的，编译器知道它使用的布局。指针偏移量计算通常在硬件中实现（所有现代CPU都支持它们，并且不需要单独的加法指令）。这听起来并不那么困难。
- en: 'Now, what do you do if the pointer is `null`? The pointer has a value of 0\.
    If you apply the same *conversion*, you get `16 (0x10)`, and now your check for
    `null` fails:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果指针是 `null`，你会怎么做？指针的值为0。如果你应用相同的 *转换*，你会得到 `16 (0x10)`，现在你的 `null` 检查失败了：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Obviously, this would be very bad, so we can assume that `null` pointers remain
    so. Indeed, they do:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这会很糟糕，因此我们可以假设 `null` 指针仍然保持原样。确实如此：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This prints the same values for all pointers:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这会为所有指针打印相同的值：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the only way to do casts, but it implies that a simple implicit cast
    from `Derived*` to `Base*` hides inside a conditional computation with a `null`
    pointer check.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是进行类型转换的唯一方法，但它意味着从 `Derived*` 到 `Base*` 的简单隐式转换隐藏在一个带有 `null` 指针检查的条件计算中。
- en: The other kind of inheritance in C++ is **private inheritance**. When inheriting
    privately, the derived classes don’t extend the public interface of the base class—all
    base class methods become private in the derived class. Any public interface has
    to be created by the derived class, starting from a clean slate. There’s no assumption
    that an object of the derived class can be used in place of an object of the base
    class. What the derived class does get from the base class is the implementation
    details—both the methods and the data members can be used by the derived class
    to implement its own algorithms. It’s said, therefore, that private inheritance
    implements a *has-a* relationship—the derived object has an instance of the base
    class contained inside of it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的另一种继承类型是 **私有继承**。当私有继承时，派生类不会扩展基类的公共接口——所有基类方法在派生类中都变为私有。任何公共接口都必须由派生类创建，从一张白纸开始。没有假设派生类的对象可以替代基类的对象。派生类从基类获得的是实现细节——方法和数据成员都可以由派生类用来实现自己的算法。因此，可以说私有继承实现了
    *has-a* 关系——派生对象在其内部包含基类的一个实例。
- en: 'The relation of the privately derived class to its base class is, therefore,
    similar to that of the relationship of a class to its data members. The latter
    implementation technique is known as `using` declaration:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，私有派生类与其基类之间的关系类似于类与其数据成员之间的关系。后者实现技术被称为 `using` 声明：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This can be useful in rare cases, but it’s also equivalent to an inline forwarding
    function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在罕见情况下可能很有用，但它也相当于一个内联转发函数：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Second, a pointer or reference to a derived object can be converted into a pointer
    or reference to the base object, but only inside a member function of the derived
    class. Again, the equivalent functionality for composition is provided by taking
    the address of a data member. So far, we haven’t seen a good reason to use private
    inheritance, and indeed, the common advice is to prefer composition. But the next
    two reasons are more significant, and either one could be motivation enough to
    use private inheritance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，派生对象的指针或引用可以转换为基对象的指针或引用，但仅限于派生类成员函数内部。同样，组合的等效功能是通过取数据成员的地址来提供的。到目前为止，我们还没有看到使用私有继承的好理由，确实，常见的建议是优先考虑组合。但接下来的两个理由更为重要，任何一个都可能是使用私有继承的动机。
- en: 'One good reason to use private inheritance has to do with the size of the composed
    or derived objects. It isn’t uncommon to have base classes that provide only methods
    but no data members. Such classes have no data of their own and, therefore, should
    not occupy any memory. But in C++, they have to be given a non-zero size. This
    has to do with the requirement that any two different objects or variables have
    different and unique addresses. Typically, if we have two variables declared one
    after the other, the address of the second one is the address of the first one,
    plus the size of the first one:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用私有继承的一个好理由与组合或派生对象的大小有关。基类只提供方法而不提供数据成员的情况并不少见。这样的类没有自己的数据，因此不应该占用任何内存。但在C++中，它们必须被赋予一个非零的大小。这与任何两个不同的对象或变量都必须有不同的唯一地址的要求有关。通常，如果我们连续声明两个变量，第二个变量的地址将是第一个变量的地址加上第一个变量的大小：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To avoid the need to handle zero-sized objects differently, C++ assigns an
    empty object the size of one. If such an object is used as a data member of a
    class, it occupies at least 1 byte (the alignment requirements for the next data
    member may increase this value). This is wasted memory; it’ll never be used for
    anything. On the other hand, if an empty class is used as a base class, there’s
    no requirement that the base part of an object must have a non-zero size. The
    entire object of the derived class must have a non-zero size, but the address
    of a derived object, its base object, and its first data member can all be at
    the same address. Therefore, it’s legal in C++ to allocate no memory for an empty
    base class, even though `sizeof()` returns 1 for this class. While legal, such
    empty base class optimization isn’t required and is considered an optimization.
    Nonetheless, most modern compilers do this optimization:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免需要以不同的方式处理零大小对象，C++ 将空对象的大小分配为1。如果这样的对象被用作类的数据成员，它至少占用1个字节（下一个数据成员的对齐要求可能会增加这个值）。这是浪费的内存；它永远不会被用于任何事情。另一方面，如果空类被用作基类，没有要求对象的部分必须有非零的大小。派生类的整个对象必须有非零的大小，但派生对象的地址、其基对象和其第一个数据成员都可以在同一个地址。因此，在C++中，即使
    `sizeof()` 返回1，也可以为空基类分配零内存。虽然这是合法的，但这种空基类优化不是必需的，并且被认为是一种优化。尽管如此，大多数现代编译器都会进行这种优化：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we create many derived objects, the memory saved by the empty base optimization
    can be significant.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建许多派生对象，空基优化可以节省显著的内存。
- en: The second reason to possibly use private inheritance has to do with virtual
    functions, and this will be explained in the next section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用私有继承的第二个理由与虚函数有关，这将在下一节中解释。
- en: Polymorphism and virtual functions
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性和虚函数
- en: 'When we discussed public inheritance earlier, we mentioned that a derived object
    can be used in any place where a base object is expected. Even with this requirement,
    it’s often useful to know what the actual type of the object is—in other words,
    what type the object was created as:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们之前讨论公有继承时，我们提到派生对象可以在任何期望基对象的地方使用。即使有这个要求，了解对象的实际类型通常很有用——换句话说，对象被创建的类型：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`some_method()` is a part of the public interface of the `Base` class and has
    to be valid for the `Derived` class as well. But, within the flexibility allowed
    by the contract of the base class interface, it can do something different. As
    an example, we’ve already used the avian hierarchy before to represent different
    birds, in particular, birds that can fly. The `FlyingBird` class can be assumed
    to have a `fly()` method, and every specific bird class derived from it has to
    support flight. But eagles fly differently from vultures, and so the implementation
    of the `fly()` method in the two derived classes, `Eagle` and `Vulture`, can be
    different. Any code that operates on arbitrary `FlyingBird` objects can call the
    `fly()` method, but the results will vary depending on the actual type of the
    object.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`some_method()` 是 `Base` 类公共接口的一部分，并且对于 `Derived` 类也必须有效。但是，在基类接口合同允许的灵活性内，它可以执行不同的操作。作为一个例子，我们之前已经使用鸟类层次结构来表示不同的鸟类，特别是会飞的鸟类。可以假设
    `FlyingBird` 类有一个 `fly()` 方法，并且从它派生出的每个特定鸟类类都必须支持飞行。但是老鹰和秃鹫的飞行方式不同，因此 `Eagle`
    和 `Vulture` 两个派生类中 `fly()` 方法的实现可以不同。任何操作任意 `FlyingBird` 对象的代码都可以调用 `fly()` 方法，但结果将取决于对象的实际类型。'
- en: 'This functionality is implemented in C++ using virtual functions. A virtual
    public function must be declared in the base class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能在C++中是通过虚函数实现的。必须在一个基类中声明虚公有函数：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A derived class inherits both the declaration and the implementation of this
    function. The declaration and the contract it provides must be respected. If the
    implementation meets the needs of the derived class, there’s no need to do anything
    more. But if the derived class needs to change the implementation, it can override
    the implementation of the base class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 派生类继承了该函数的声明和实现。必须遵守声明及其提供的契约。如果实现满足派生类的需求，则无需做任何事情。但如果派生类需要更改实现，它可以覆盖基类的实现：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the keyword `virtual`, when used in a derived class for methods that
    override base class virtual functions, is entirely optional and has no effect;
    we will see later that there are good reasons to omit that.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当在派生类中使用关键字`virtual`来覆盖基类虚函数的方法时，这是完全可选的，并且没有任何效果；我们稍后会看到省略它的原因。
- en: 'When a virtual function is called, the C++ runtime system must determine what
    the real type of the object is. Usually, this information isn’t known at compile
    time and must be determined at runtime:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用虚函数时，C++运行时系统必须确定对象的实际类型。通常，这种信息在编译时并不为人所知，必须在运行时确定：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The programming technique where some code operates on any number of base objects
    and invokes the same methods, but the results depend on the actual type of these
    objects, is known as **runtime polymorphism**, and the objects that support this
    technique are **polymorphic**. In C++, polymorphic objects must have at least
    one virtual function, and only the parts of their interface that use virtual functions
    for some or all of the implementation are polymorphic.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一种编程技术，其中某些代码可以作用于任意数量的基类对象，并调用相同的方法，但结果取决于这些对象的实际类型，这种技术被称为**运行时多态**，支持这种技术的对象被称为**多态**。在C++中，多态对象必须至少有一个虚函数，并且只有它们接口中使用虚函数实现的部分才是多态的。
- en: It should be evident from this explanation that the declaration of the virtual
    function and its overrides should be identical—the programmer calls the function
    on a base object, but the version that’s implemented in the derived class runs
    instead. This can happen only if the two functions have identical arguments and
    return types. One exception is that if a virtual function in the base class returns
    a pointer or a reference to an object of some type, the override can return a
    pointer or a reference to an object derived from that type (this is known as **covariant**
    **return types**).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个解释中应该很明显，虚函数的声明及其重写应该是相同的——程序员在基类对象上调用该函数，但运行的是派生类中实现的版本。这只有在两个函数具有相同的参数和返回类型的情况下才会发生。一个例外是，如果基类中的虚函数返回某种类型的指针或对该类型的对象的引用，则重写可以返回对该类型派生对象的指针或对该类型派生对象的引用（这被称为**协变****返回类型**）。
- en: A very common special case of polymorphic hierarchies is one where the base
    class doesn’t have a good *default* implementation of the virtual function. For
    example, all flying birds fly, but they all fly at different speeds, so there’s
    no reason to select one speed as the default. In C++, we can refuse to provide
    any implementation for a virtual function in the base class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 多态层次结构的一个非常常见的特殊情况是基类没有好的**默认**虚函数实现。例如，所有飞行的鸟都会飞，但它们的飞行速度各不相同，因此没有必要选择一个速度作为默认值。在C++中，我们可以拒绝在基类中为虚函数提供任何实现。
- en: 'Such functions are called **pure virtual**, and any base class that contains
    a pure virtual function is known as an **abstract class**:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数被称为**纯虚函数**，任何包含纯虚函数的基类都被称为**抽象类**：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: An abstract class defines an interface only; it’s the job of the concrete derived
    classes to implement it. If the base class contains a pure virtual function, every
    derived class that’s instantiated in the program must provide an implementation.
    In other words, an object of a base class can’t be created (a derived class could
    also be an abstract class, but then it cannot be instantiated directly either,
    we must derive another class from it). We can, however, have a pointer or a reference
    to an object of a base class—they really point to a derived class, but we can
    operate on it through the base class interface.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类仅定义了一个接口；具体派生类的任务是实现它。如果基类包含一个纯虚函数，程序中实例化的每个派生类都必须提供实现。换句话说，不能创建基类对象（派生类也可以是抽象类，但那时也不能直接实例化，我们必须从它派生另一个类）。然而，我们可以有一个指向基类对象的指针或引用——它们实际上指向派生类，但我们可以通过基类接口来操作它。
- en: 'A few notes on the C++ syntax—when overriding a virtual function, it isn’t
    required to repeat the `virtual` keyword. If the base class declares a virtual
    function with the same name and arguments, the one in the derived class will always
    be a virtual function and will override the one from the base class. Note that,
    if the arguments differ, the derived class function doesn’t override anything
    and instead shadows the name of the base class function. This can lead to subtle
    bugs where the programmer intended to override a base class function but didn’t
    copy the declaration correctly:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C++语法的几点说明——在重写虚函数时，不需要重复`virtual`关键字。如果基类声明了一个具有相同名称和参数的虚函数，派生类中的函数将始终是虚函数，并覆盖基类中的函数。注意，如果参数不同，派生类函数不会覆盖任何内容，而是会隐藏基类函数的名称。这可能导致程序员意图覆盖基类函数但未正确复制声明的微妙错误：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, the types of the arguments are slightly different. The `Eagle::fly()`
    function is also virtual, but it doesn’t override `FlyingBird::fly()`. If the
    latter is a pure virtual function, the bug will be caught because every pure virtual
    function must be implemented in a derived class. But if `FlyingBird::fly()` has
    the default implementation, then the bug will go undetected by the compiler. C++11
    provides a very useful feature that greatly simplifies finding such bugs—any function
    that’s intended to be an override of a base class virtual function can be declared
    with the `override` keyword:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，参数的类型略有不同。`Eagle::fly()`函数也是虚函数，但它没有覆盖`FlyingBird::fly()`。如果后者是一个纯虚函数，错误将被捕获，因为每个纯虚函数都必须在派生类中实现。但如果`FlyingBird::fly()`有默认实现，那么错误将不会被编译器检测到。C++11提供了一个非常有用的功能，可以极大地简化查找此类错误——任何打算覆盖基类虚函数的函数都可以使用`override`关键字声明：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `virtual` keyword is still optional, but if the `FlyingBird` class doesn’t
    have a virtual function that we could be overriding with this declaration, this
    code won’t compile.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`virtual`关键字仍然是可选的，但如果`FlyingBird`类没有我们可以用此声明覆盖的虚函数，则此代码无法编译。'
- en: 'It is also possible to prevent the derived classes from overriding a virtual
    function by declaring it `final`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过将虚函数声明为`final`来防止派生类覆盖虚函数：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that the use of the `final` keyword is rare: it is unusual for the design
    to require that from this point on, the customizations should be disabled in the
    hierarchy. The `final` keyword can also be applied to the entire class: it means
    that no more classes can be derived from this one. Again, this is a rare situation.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用`final`关键字的情况很少：通常情况下，设计不需要从这一点开始禁用层次结构中的自定义设置。`final`关键字也可以应用于整个类：这意味着不能从这个类派生出更多的类。同样，这也是一种罕见的情况。
- en: 'So, should or shouldn’t you use the `virtual` keyword on overrides? This is
    a matter of style, but the style affects the readability and maintainability of
    the code. The following is the recommended practice:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，是否应该在覆盖时使用`virtual`关键字呢？这是一个风格问题，但风格会影响代码的可读性和可维护性。以下是一种推荐的做法：
- en: Any virtual function that does not override one in the base class must use the
    `virtual` keyword. This includes both the functions in classes that have no bases
    and the functions added in derived classes.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何不覆盖基类中函数的虚函数都必须使用`virtual`关键字。这包括没有基类的类中的函数和在派生类中添加的函数。
- en: Any other virtual function should not use the `virtual` keyword. All overrides
    should use the `override` keyword, with the following exception, which is also
    another rule.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他虚拟函数都不应该使用 `virtual` 关键字。所有覆盖都应该使用 `override` 关键字，以下例外除外，这也是另一条规则。
- en: A final override must use the `final` keyword and should not use the `override`
    keyword.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终覆盖必须使用 `final` 关键字，并且不应该使用 `override` 关键字。
- en: 'There are two advantages to this approach. The first is clarity and readability:
    if you see `virtual`, this is a virtual function that does not override anything.
    If you see `override`, this must be an override (otherwise the code would not
    compile). If you see `final`, this is also an override (again, the code would
    not compile otherwise) and it’s the last such in the hierarchy. The second advantage
    shows up during code maintenance. One of the greatest problems with maintaining
    hierarchies is the base class fragility: you write a set of base and derived classes,
    someone else comes along and adds an argument to the base class function, and
    suddenly all your derived class functions don’t override the base class ones and
    never get called. With consistent use of the `override` keyword, this will not
    happen.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有两个优点。第一个是清晰度和可读性：如果你看到 `virtual`，这是一个没有覆盖任何内容的虚拟函数。如果你看到 `override`，这必须是一个覆盖（否则代码将无法编译）。如果你看到
    `final`，这也是一个覆盖（否则代码将无法编译），并且是层次结构中的最后一个。第二个优点在代码维护期间显现出来。维护层次结构最大的问题之一是基类脆弱性：你编写了一组基类和派生类，其他人随后向基类函数添加了一个参数，突然间，所有派生类函数都没有覆盖基类函数，并且永远不会被调用。通过一致地使用
    `override` 关键字，这种情况不会发生。
- en: 'The most common use of virtual functions, by far, is in hierarchies that use
    public inheritance—since every derived object is also a base object (*is-a* relationship),
    a program can often operate on a collection of derived objects as if they were
    all of the same types, and the virtual function overrides ensure that the right
    processing happens for every object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟函数最常见的使用是在使用公共继承的层次结构中——因为每个派生对象也是一个基类对象（*is-a* 关系），程序通常可以像处理同一类型的对象集合一样处理派生对象集合，而虚拟函数覆盖确保对每个对象都执行正确的处理：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But virtual functions can also be used with private inheritance. The use is
    less straightforward (and much less common)—after all, an object that’s derived
    privately can’t be accessed through a base class pointer (a private base class
    is referred to as an **inaccessible base**, and an attempt to cast a derived class
    pointer to the base class will fail). However, there’s one context in which this
    cast is permitted, and that’s within a member function of the derived class. Here’s,
    then, the way to arrange a virtual function call from a privately inherited base
    class to the derived one:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但虚拟函数也可以与私有继承一起使用。这种用法不太直接（并且远不如公共继承常见）——毕竟，通过私有继承派生的对象无法通过基类指针访问（私有基类被称为**不可访问基类**，尝试将派生类指针强制转换为基类指针将失败）。然而，有一种情况下这种转换是被允许的，那就是在派生类的成员函数内部。那么，从私有继承的基类到派生类的虚拟函数调用可以这样安排：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The public methods of the `Base` class become private in the `Derived` class,
    so we can’t call them directly. We can, however, call them from another method
    of the `Derived` class, such as the public method `h()`. We can then call `f()`
    directly from `h()`, but that doesn’t prove anything—it would come as no surprise
    if `Derived::h()` invoked `Derived::f()`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Base` 类的公共方法在 `Derived` 类中变为私有，因此我们无法直接调用它们。然而，我们可以从 `Derived` 类的另一个方法中调用它们，例如公共方法
    `h()`。然后我们可以直接从 `h()` 中调用 `f()`，但这并不能证明什么——如果 `Derived::h()` 调用了 `Derived::f()`，这并不会让人感到惊讶。'
- en: Instead, we call the `Base::g()` function that’s inherited from the `Base` class.
    Inside that function, we’re in the `Base` class—the body of this function may
    have been written and compiled long before the `Derived` class was implemented.
    And yet, in this context, the virtual function override works correctly and `Derived::f()`
    is called, just as it would if the inheritance were public.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们调用从 `Base` 类继承的 `Base::g()` 函数。在该函数内部，我们处于 `Base` 类中——这个函数的主体可能是在 `Derived`
    类实现之前编写和编译的。然而，在这个上下文中，虚拟函数覆盖仍然可以正确工作，并且会调用 `Derived::f()`，就像继承是公共的一样。
- en: In the previous section, we recommended that composition is preferred to private
    inheritance unless there’s a reason to do otherwise. There’s no good way to implement
    similar functionality using composition; so, if the virtual function behavior
    is desired, private inheritance is the only way to go.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们建议，除非有其他原因，否则优先使用组合而不是私有继承。没有好的方法使用组合来实现类似的功能；因此，如果需要虚函数行为，私有继承是唯一的选择。
- en: A class with a virtual method has to have its type encoded into every object—this
    is the only way to know, at runtime, what was the type of the object when it was
    constructed, after we converted the pointer into a base class pointer and lost
    any other information about the original type. That type information isn’t free;
    it takes space—a polymorphic object is always larger than an object with the same
    data members but no virtual methods (usually by the size of a pointer).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 具有虚方法的类必须将其类型编码到每个对象中——这是在运行时知道对象在构造时的类型，在我们将指针转换为基类指针并丢失任何其他原始类型信息之后的唯一方法。这种类型信息不是免费的；它需要空间——多态对象总是比具有相同数据成员但没有虚函数的对象大（通常是一个指针的大小）。
- en: 'The extra size doesn’t depend on how many virtual functions the class has—at
    long as it has one, the type information must be encoded in the object. Now, recall
    that a pointer to the base class can be converted into a pointer to the derived
    class, but only if we know the correct type of the derived class. With the static
    cast, there’s no way to test whether our knowledge is correct. For non-polymorphic
    classes (classes without any virtual functions), there can be no better way; once
    their original type is lost, there is no way to recover it. But for polymorphic
    objects, the type is encoded in the object, so there has to be a way to use that
    information to check whether our assumption is correct about which derived object
    this really is. Indeed, there is a way. It’s provided by the dynamic cast:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的空间大小并不取决于类有多少个虚函数——只要有一个，类型信息就必须编码在对象中。现在，回想一下，基类指针可以被转换为派生类指针，但前提是我们知道派生类的正确类型。使用静态转换，我们无法测试我们的知识是否正确。对于非多态类（没有虚函数的类），没有更好的方法；一旦它们的原始类型丢失，就无法恢复。但对于多态对象，类型信息编码在对象中，因此必须有一种方法来使用这些信息来检查我们的假设是否正确，即这个派生对象的真实类型是什么。确实，有一种方法。它由动态转换提供：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The dynamic cast doesn’t tell us what the real type of the object is; rather,
    it allows us to ask the question—Is the real type `Derived`? If our guess at the
    type is correct, the cast succeeds and returns the pointer to the derived object.
    If the real type is something else, the cast fails and returns a `null` pointer.
    The dynamic cast can also be used with references, with similar effects, save
    one—there’s no *null reference*. A function that returns a reference must always
    return a reference to some valid object. Since the dynamic cast can’t return a
    reference to a valid object if the requested type doesn’t match the actual type.
    The only alternative is to throw an exception.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 动态转换不会告诉我们对象的真正类型；相反，它允许我们提出问题——这个对象的真正类型是`Derived`吗？如果我们的类型猜测正确，转换成功并返回派生对象的指针。如果真实类型是其他类型，转换失败并返回一个`null`指针。动态转换也可以与引用一起使用，效果相似，但有一个例外——没有`null`引用。返回引用的函数必须始终返回对某个有效对象的引用。由于动态转换无法在请求的类型与实际类型不匹配时返回对有效对象的引用，唯一的替代方案是抛出异常。
- en: 'For performance-conscious code, it is important to be aware of the run-time
    cost of the dynamic cast. Naively, one might think that a virtual function call
    and a dynamic cast take about the same time: both boil down to the question –
    is this pointer to `Base` really a pointer to `Derived`? A simple benchmark shows
    that this is not so:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于注重性能的代码，了解动态转换的运行时成本非常重要。天真地认为，虚拟函数调用和动态转换花费的时间差不多：两者都归结为同一个问题——这个指向`Base`的指针是否真的是指向`Derived`的指针？一个简单的基准测试表明并非如此：
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The benchmark results should look something like this (the absolute numbers
    will depend on the hardware): 1 nanosecond for the virtual call, and 5 to 10 nanoseconds
    for the dynamic cast. Why is the dynamic cast so expensive? We need to learn more
    about the hierarchies before we can answer this question.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 基准结果应该看起来像这样（绝对数值将取决于硬件）：虚函数调用为1纳秒，动态转换为5到10纳秒。为什么动态转换如此昂贵？在我们能够回答这个问题之前，我们需要更多地了解层次结构。
- en: So far, we’ve limited ourselves to only one base class. While it’s much easier
    to think about class hierarchies if we imagine them as trees, with the base class
    and the root and branches where multiple classes are derived from the same base,
    C++ doesn’t impose such limitations. Next, we’ll learn about inheriting from several
    base classes at once.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只限制了自己使用一个基类。虽然如果我们想象它们作为树，基类是根，分支是多个类从同一个基类派生，这样思考类层次结构会容易得多，但C++并没有强加这样的限制。接下来，我们将学习一次性从多个基类继承。
- en: Multiple inheritance
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: 'In C++, a class can be derived from several base classes. Going back to our
    birds, let’s make an observation—while flying birds have a lot in common with
    each other, they also have something in common with other flying animals, specifically,
    the ability to fly. Since flight isn’t limited to birds, we may want to move the
    data and the algorithms related to processing flight into a separate base class.
    But there’s also no denying that an eagle is a bird. We could express this relation
    if we used two base classes to construct the `Eagle` class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，一个类可以从多个基类派生。回到我们的鸟类，让我们做一个观察——虽然飞行的鸟类彼此之间有很多共同之处，但它们也与其他飞行动物有共同之处，特别是飞行的能力。由于飞行并不局限于鸟类，我们可能希望将处理飞行相关的数据和算法移动到一个单独的基类中。但也不能否认，老鹰也是一种鸟类。如果我们使用两个基类来构建`Eagle`类，我们可以表达这种关系：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this case, the inheritance from both base classes is public, which means
    that the derived class inherits both interfaces and must fulfill two separate
    contracts. What happens if both interfaces define a method with the same name?
    If this method isn’t virtual, then an attempt to invoke it on the derived class
    is ambiguous, and the program doesn’t compile. If the method is virtual and the
    derived class has an override for it, then there’s no ambiguity since the method
    of the derived class is called. Also, `Eagle` is now both `Bird` and `FlyingAnimal`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，从两个基类的继承都是公开的，这意味着派生类继承了两个接口，并且必须满足两个单独的合同。如果两个接口定义了具有相同名称的方法会发生什么？如果这个方法不是虚拟的，那么在派生类上调用它的尝试是模糊的，程序无法编译。如果方法是虚拟的，并且派生类有对它的重写，那么由于派生类的方法被调用，因此没有歧义。此外，`Eagle`现在既是`Bird`也是`FlyingAnimal`：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Both conversions from the derived class into the base class pointer are allowed.
    The reverse conversions must be made explicitly using a static or a dynamic cast.
    There’s another interesting conversion—if we have a pointer to a `FlyingAnimal`
    class that’s also a `Bird` class, can we cast from one to the other? Yes, we can
    with a dynamic cast:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从派生类转换为基类指针的转换是允许的。反向转换必须显式地使用静态或动态转换。还有一个有趣的转换——如果我们有一个指向`FlyingAnimal`类的指针，它也是一个`Bird`类，我们能否从一个类转换到另一个类？是的，我们可以使用动态转换：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When used in this context, the dynamic cast is sometimes called a **cross-cast**—we
    aren’t casting up or down the hierarchy (between derived and based classes) but
    across the hierarchy—between the classes on different branches of the hierarchy
    tree.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，动态转换有时被称为**交叉转换**——我们不是在层次结构（派生类和基类之间）的上下文中进行转换，而是在层次结构之间进行转换——在层次结构树的不同分支上的类之间。
- en: Cross-cast is also mostly responsible for the high runtime cost of the dynamic
    cast we have seen in the previous section. While the most common use of `dynamic_cast`
    is to cast from `Base*` to `Derived*` to verify that a given object is really
    of the derived class, the cast could also be used to cast between bases of the
    same derived class. This is a much harder problem. If you just want to check that
    the base class object is really a derived one, the compiler knows the `Derived`
    type at this point (you cannot use the dynamic cast on incomplete types).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉转换也主要是我们之前章节中看到的动态转换高运行时成本的原因。虽然`dynamic_cast`最常见的使用是从`Base*`到`Derived*`转换以验证给定的对象确实是派生类，但这种转换也可以用于在相同派生类的基类之间进行转换。这是一个更难的问题。如果你只想检查基类对象确实是派生类，编译器此时知道`Derived`类型（你不能在未完成类型上使用动态转换）。
- en: 'Therefore, the compiler knows exactly what base classes this derived type has
    and can trivially check if yours is one of them. But when casting across the hierarchy,
    the compiler knows only two base classes: at the time when this code was written,
    a derived class that combines both may not exist, it will be written later. But
    the compiler must generate the correct code now. So, the compiler has to generate
    code that, at run time, digs through all the possible classes that are derived
    from both base classes to see if yours is one of them (the actual implementation
    is less straightforward and more efficient than that, but the task to be accomplished
    remains the same).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编译器确切地知道这个派生类型有哪些基类，并且可以轻易地检查你的类型是否是其中之一。但是，在跨越层次结构进行类型转换时，编译器只知道两个基类：在编写此代码时，可能不存在同时结合这两个基类的派生类，它将在以后被编写。但是，编译器必须现在就生成正确的代码。因此，编译器必须生成在运行时挖掘所有可能从这两个基类派生出来的类，以查看你的类型是否是其中之一（实际的实现比这更直接且更高效，但需要完成的任务仍然是相同的）。
- en: 'In reality, this overhead is often unnecessary because, most of the time, the
    dynamic cast is indeed used to find out whether the base class pointer really
    points to a derived object. In many cases, the overhead is not significant. But
    if better performance is required, there is no way to make the dynamic cast faster.
    If you want a fast way to check whether a polymorphic object is really of a given
    type, you have to use virtual functions and, unfortunately, a list of all possible
    types (or at least all the ones you might be interested in):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种开销通常是不必要的，因为，大多数时候，动态类型转换确实用于确定基类指针是否真正指向一个派生对象。在许多情况下，这种开销并不显著。但是，如果需要更好的性能，就没有办法使动态类型转换更快。如果你想快速检查一个多态对象是否确实是给定类型，你必须使用虚函数，而且不幸的是，你必须使用所有可能的类型（或者至少是你可能感兴趣的）的列表：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Multiple inheritance is often maligned and disfavored in C++. Much of this advice
    is outdated and stems from the time when compilers implemented multiple inheritance
    poorly and inefficiently. Today, with modern compilers, this isn’t a concern.
    It’s often said that multiple inheritance makes the class hierarchy harder to
    understand and reason about. Perhaps it would be more accurate to say that it’s
    harder to design a good multiple inheritance hierarchy that accurately reflects
    the relations between different properties, and that a poorly designed hierarchy
    is difficult to understand and reason about.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，多重继承经常受到诋毁和不被青睐。大部分这些建议已经过时，并且源于编译器在实现多重继承时表现不佳且效率低下的时候。如今，随着现代编译器的出现，这已不再是问题。人们常说多重继承使得类层次结构更难以理解和推理。或许更准确的说法是，设计一个能够准确反映不同属性之间关系的良好多重继承层次结构更困难，而设计不良的层次结构则难以理解和推理。
- en: 'These concerns mostly apply to hierarchies that use public inheritance. Multiple
    inheritance can be private as well. There’s even less reason to use multiple private
    inheritance instead of composition than there was to use single private inheritance.
    However, the empty base optimization can be done on multiple empty base classes
    and remains a valid reason to use private inheritance, if it applies:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些担忧主要适用于使用公有继承的层次结构。多重继承也可以是私有的。与使用单一私有继承相比，没有更多的理由使用多重私有继承而不是组合。然而，在多个空基类上进行空基优化仍然是一个有效的理由来使用私有继承，如果适用的话：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Multiple inheritance can be particularly effective when the derived class represents
    a system that combines several unrelated, non-overlapping attributes. We’ll encounter
    such cases throughout this book when we explore various design patterns and their
    C++ representations.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当派生类代表一个结合了几个不相关、不重叠属性的系统时，多重继承可以特别有效。在我们探索各种设计模式和它们的C++表示时，本书中我们将遇到这样的案例。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While by no means a complete guide or reference to classes and objects, this
    chapter introduced and explained the concepts you will need to understand the
    examples and explanations in the rest of this book. As our interest is and will
    be in representing design patterns in C++, this chapter focused on the proper
    use of classes and inheritance. We paid particular attention to what relations
    are expressed through different C++ features—it’s through these features we’ll
    express relations and interactions between different components that form a design
    pattern.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这绝对不是类和对象的完整指南或参考，但本章介绍了并解释了您需要理解本书其余部分示例和解释的概念。由于我们的兴趣和将会是表示 C++ 中的设计模式，本章重点介绍了类和继承的正确使用。我们特别注意了通过不同的
    C++ 特征表达的关系——正是通过这些特征，我们将表达构成设计模式的不同组件之间的关系和交互。
- en: The next chapter will similarly cover knowledge of C++ templates, which will
    be necessary to understand the subsequent chapters of this book.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将类似地涵盖 C++ 模板的知识，这对于理解本书后续章节是必要的。
- en: Questions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the importance of objects in C++?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 中对象的重要性是什么？
- en: Which relation is expressed by public inheritance? Which relation is expressed
    by private inheritance? What is a polymorphic object?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共继承和私有继承分别表达了哪种关系？多态对象是什么？
- en: What is the difference between the dynamic cast and the static cast? Why is
    the dynamic cast so expensive?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态转换和静态转换之间的区别是什么？为什么动态转换如此昂贵？
- en: Further reading
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Deciphering Object-Oriented Programming with* *C++*: [https://www.packtpub.com/product/deciphering-object-oriented-programming-with-c/9781804613900](https://www.packtpub.com/product/deciphering-object-oriented-programming-with-c/9781804613900)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用 C++ 解密面向对象编程*：[https://www.packtpub.com/product/deciphering-object-oriented-programming-with-c/9781804613900](https://www.packtpub.com/product/deciphering-object-oriented-programming-with-c/9781804613900)'
- en: '*Software Architecture with* *C++*: [https://www.packtpub.com/product/software-architecture-with-c/9781838554590](https://www.packtpub.com/product/software-architecture-with-c/9781838554590)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 C++ 进行软件架构*：[https://www.packtpub.com/product/software-architecture-with-c/9781838554590](https://www.packtpub.com/product/software-architecture-with-c/9781838554590)'
- en: '*C++* *Fundamentals*: [https://www.packtpub.com/product/c-fundamentals](https://www.packtpub.com/product/c-fundamentals)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++* 基础：[https://www.packtpub.com/product/c-fundamentals](https://www.packtpub.com/product/c-fundamentals)'
- en: '*C++ Data Structures and* *Algorithms*: [https://www.packtpub.com/product/c-data-structures-and-algorithm-design-principles](https://www.packtpub.com/product/c-data-structures-and-algorithm-design-principles)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++ 数据结构和算法*：[https://www.packtpub.com/product/c-data-structures-and-algorithm-design-principles](https://www.packtpub.com/product/c-data-structures-and-algorithm-design-principles)'
- en: '*Mastering C++* *Programming*: [https://www.packtpub.com/product/mastering-c-programming](https://www.packtpub.com/product/mastering-c-programming)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精通 C++* 编程：[https://www.packtpub.com/product/mastering-c-programming](https://www.packtpub.com/product/mastering-c-programming)'
- en: '*Beginning C++* *Programming*: [https://www.packtpub.com/product/beginning-c-programming](https://www.packtpub.com/product/beginning-c-programming)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++ 编程入门*：[https://www.packtpub.com/product/beginning-c-programming](https://www.packtpub.com/product/beginning-c-programming)'
