- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: 'Space Rocks: Build a 2D Arcade Classic with Physics'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间岩石：使用物理构建2D街机经典游戏
- en: 'By now, you should be getting more comfortable with working in Godot: adding
    nodes, creating scripts, modifying properties in the Inspector, and so on. If
    you find yourself stuck or feeling like you don’t remember how something is done,
    you can jump back to a project where it was first explained. As you repeat the
    more common actions in Godot, they’ll start to feel more and more familiar. At
    the same time, each chapter will introduce you to more nodes and techniques to
    expand your understanding of Godot’s features.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经对在Godot中工作感到更加舒适：添加节点、创建脚本、在检查器中修改属性等等。如果你发现自己遇到了困难或者感觉不记得如何做某事，你可以回到最初解释该项目的项目。随着你在Godot中重复执行更常见的操作，它们将变得越来越熟悉。同时，每一章都会向你介绍更多节点和技术，以扩展你对Godot功能的理解。
- en: 'In this project, you’ll make a space shooter game similar to the arcade classic
    *Asteroids*. The player will control a ship that can rotate and move in any direction.
    The goal will be to avoid the floating “space rocks” and shoot them with the ship’s
    laser. Here’s a screenshot of the final game:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将制作一个类似于街机经典游戏《小行星》的空间射击游戏。玩家将控制一艘可以旋转和向任何方向移动的飞船。目标将是避开漂浮的“太空岩石”并用飞船的激光射击它们。以下是最终游戏的截图：
- en: '![Figure 3.1: Space Rocks screenshot](img/B19289_03_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：空间岩石截图](img/B19289_03_01.jpg)'
- en: 'Figure 3.1: Space Rocks screenshot'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：空间岩石截图
- en: 'You’ll learn about the following key topics in this project:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将学习以下关键主题：
- en: Using custom input actions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义输入操作
- en: Physics using `RigidBody2D`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RigidBody2D`进行物理运算
- en: Organizing game logic with finite state machines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用有限状态机组织游戏逻辑
- en: Building a dynamic, scalable UI
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建动态、可扩展的用户界面
- en: Sound and music
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频和音乐
- en: Particle effects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒子效果
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Download the game assets from the following link below and unzip them into
    your new project folder: [https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下链接下载游戏资源，并将其解压缩到你的新项目文件夹中：[https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads)
- en: 'You can also find the complete code for this chapter on GitHub at: [https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter03%20-%20Space%20Rocks](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter03%20-%20Space%20Rocks)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在GitHub上找到本章的完整代码：[https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter03%20-%20Space%20Rocks](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Chapter03%20-%20Space%20Rocks)
- en: Setting up the project
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'Create a new project and download the project assets from the following URL:
    [https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目，并从以下URL下载项目资源：[https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads](https://github.com/PacktPublishing/Godot-4-Game-Development-Projects-Second-Edition/tree/main/Downloads).
- en: For this project, you’ll set up custom input actions in the **Input Map**. Using
    this feature, you can define custom input events and assign different keys, mouse
    events, or other inputs to them. This allows more flexibility in designing your
    game, as your code can be written to respond to the “jump” input, for example,
    without needing to know exactly what key and/or button the user pressed to make
    that event happen. This allows you to make the same code work on different devices,
    even if they have different hardware. In addition, since many gamers expect to
    be able to customize a game’s inputs, this enables you to provide that option
    to the user as well.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你需要在**输入映射**中设置自定义输入操作。使用这个功能，你可以定义自定义输入事件并将不同的键、鼠标事件或其他输入分配给它们。这使你在设计游戏时具有更大的灵活性，因为你的代码可以编写为响应“跳跃”输入，例如，而不需要确切知道用户按下了哪个键和/或按钮来触发该事件。这允许你在不同设备上使用相同的代码，即使它们具有不同的硬件。此外，由于许多玩家期望能够自定义游戏的输入，这也使你能够为用户提供此选项。
- en: To set up the inputs for this game, open **Project** | **Project Settings**
    and select the **Input** **Map** tab.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置这个游戏的输入，请打开**项目** | **项目设置**并选择**输入** **映射**选项卡。
- en: 'You’ll need to create four new input actions: `rotate_left`, `rotate_right`,
    `thrust`, and `shoot`. Type the name of each action into the **Add New Action**
    box and hit *Enter* or click the **Add** button. Make sure you type the names
    exactly as shown since they’ll be used in code later.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要创建四个新的输入动作：`rotate_left`、`rotate_right`、`thrust`和`shoot`。将每个动作的名称输入到**添加新动作**框中，然后按*Enter*键或点击**添加**按钮。确保你输入的名称与显示的完全一致，因为它们将在后面的代码中使用。
- en: 'Then, for each action, click the **+** button to its right. In the pop-up window,
    you can manually select a specific type of input, or you can press the physical
    button and Godot will detect it. You can add multiple inputs to each action. For
    example, to allow players to use both the arrow keys and the WASD keys, the setup
    will look like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每个动作，点击其右侧的**+**按钮。在弹出的窗口中，你可以手动选择特定的输入类型，或者按物理按钮，Godot将检测它。你可以为每个动作添加多个输入。例如，为了允许玩家使用箭头键和WASD键，设置将看起来像这样：
- en: '![Figure 3.2: Input actions](img/B19289_03_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：输入动作](img/B19289_03_02.jpg)'
- en: 'Figure 3.2: Input actions'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：输入动作
- en: If you have a gamepad or other controller connected to your computer, you can
    also add its inputs to the actions in the same way.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将游戏手柄或其他控制器连接到你的电脑，你也可以以相同的方式将其输入添加到动作中。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We’re only considering button-style inputs at this stage, so while you’ll be
    able to use a D-pad for this project, using an analog joystick would require changes
    to the project’s code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们只考虑按钮式输入，所以虽然你将能够在这个项目中使用D-pad，但使用模拟摇杆将需要更改项目的代码。
- en: Rigid body physics
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚体物理
- en: In game development, you often need to know when two objects in the game space
    intersect or come into contact. This is known as **collision detection**. When
    a collision is detected, you typically want something to happen. This is known
    as **collision response**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，你经常需要知道游戏空间中的两个物体是否相交或接触。这被称为**碰撞检测**。当检测到碰撞时，你通常希望发生某些事情。这被称为**碰撞响应**。
- en: 'Godot offers three kinds of physics bodies, grouped under the `PhysicsBody2D`
    node type:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Godot提供了三种类型的物理体，它们被归类在`PhysicsBody2D`节点类型下：
- en: '`StaticBody2D`: A static body is one that is not moved by the physics engine.
    It participates in collision detection but does not move in response. This type
    of body is most often used for objects that are part of the environment or do
    not need to have any dynamic behavior, such as walls or the ground.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StaticBody2D`：静态体是指不会被物理引擎移动的物体。它参与碰撞检测，但不会移动响应。这种类型的物体通常用于环境的一部分或不需要任何动态行为的物体，例如墙壁或地面。'
- en: '`RigidBody2D`: This is the physics body that provides simulated physics. This
    means that you don’t control a `RigidBody2D` physics body’s position directly.
    Instead, you apply forces to it (gravity, impulses, and so on) and Godot’s built-in
    physics engine calculates the resultant movement, including collisions, bouncing,
    rotating, and other effects.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RigidBody2D`：这是提供模拟物理的物理体。这意味着你不会直接控制`RigidBody2D`物理体的位置。相反，你对其施加力（重力、冲量等），然后Godot的内置物理引擎计算结果运动，包括碰撞、弹跳、旋转和其他效果。'
- en: '`CharacterBody2D`: This body type provides collision detection but no physics.
    All movement must be implemented in code, and you must implement any collision
    response yourself. Kinematic bodies are most often used for player characters
    or other actors that require *arcade-style* physics rather than realistic simulation,
    or when you need more precise control over how the body moves.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CharacterBody2D`：这种类型的物体提供碰撞检测，但没有物理属性。所有运动都必须在代码中实现，你必须自己实现任何碰撞响应。运动学体通常用于玩家角色或其他需要*街机风格*物理而不是真实模拟的演员，或者当你需要更精确地控制物体移动时。'
- en: Understanding when to use a particular physics body type is a big part of building
    your game. Using the right type can simplify your development, while trying to
    force the wrong node to do the job can lead to frustration and poor results. As
    you work with each type of body, you’ll come to learn their pros and cons and
    get a feel for when they can help build what you need.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 了解何时使用特定的物理体类型是构建游戏的重要组成部分。使用正确的类型可以简化你的开发，而试图强制错误的节点执行任务可能会导致挫败感和不良结果。随着你与每种类型的物体一起工作，你会了解它们的优缺点，并学会何时它们可以帮助构建你需要的东西。
- en: In this project, you’ll be using the `RigidBody2D` node for the ship as well
    as the rocks themselves. You’ll learn about the other body types in later chapters.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用`RigidBody2D`节点来控制船只以及岩石本身。你将在后面的章节中学习其他类型的物体。
- en: Individual `RigidBody2D` nodes have many properties you can use to customize
    their behavior, such as **Mass**, **Friction**, or **Bounce**. These properties
    can be set in the Inspector.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 单个 `RigidBody2D` 节点有许多你可以用来自定义其行为的属性，例如 **质量**、**摩擦** 或 **弹跳**。这些属性可以在检查器中设置。
- en: Rigid bodies are also affected by global properties, which can be set in **Project
    Settings** under **Physics** | **2D**. These settings apply to all bodies in the
    world.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 刚体也受到全局属性的影响，这些属性可以在 **项目设置** 下的 **物理** | **2D** 中设置。这些设置适用于世界中的所有物体。
- en: '![Figure 3.3: Project physics settings](img/B19289_03_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3：项目物理设置](img/B19289_03_03.jpg)'
- en: 'Figure 3.3: Project physics settings'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：项目物理设置
- en: In most cases, you won’t need to modify these settings. However, note that by
    default, gravity has a value of `980` and a direction of `(0, 1)`, or downward.
    If you want to change the world’s gravity, you can do that here.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不需要修改这些设置。但是，请注意，默认情况下，重力值为 `980`，方向为 `(0, 1)`，即向下。如果你想改变世界的重力，你可以在这里进行更改。
- en: 'If you click the **Advanced Settings** toggle in the upper right of the **Project
    Settings** window, you’ll see many advanced configuration values for the physics
    engine. You should be aware of two of them in particular: **Default Linear Damp**
    and **Default Angular Damp**. These properties control how quickly a body will
    lose forward speed and rotation speed, respectively. Setting them to lower values
    will make the world feel frictionless, while using larger values will make it
    feel like your objects are moving through mud. This can be a great way to apply
    different movement styles to suit various game objects and environments.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击 **项目设置** 窗口右上角的 **高级设置** 切换按钮，你将看到许多物理引擎的高级配置值。你应该特别注意其中的两个：**默认线性阻尼**
    和 **默认角阻尼**。这些属性分别控制物体失去前进速度和旋转速度的快慢。将它们设置为较低的值会使世界感觉没有摩擦，而使用较大的值会使物体移动时感觉像穿过泥浆。这可以是一种很好的方式，将不同的运动风格应用于各种游戏对象和环境。
- en: Area physics override
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 区域物理覆盖
- en: '`Area2D` nodes can also be used to influence rigid body physics by using their
    **Space Override** property. Custom gravity and damping values will then be applied
    to any bodies that enter the area.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Area2D` 节点也可以通过使用它们的 **Space Override** 属性来影响刚体物理。然后，将应用自定义的重力和阻尼值到进入该区域的任何物体上。'
- en: Since this game will be taking place in outer space, gravity won’t be needed,
    so set `0`. You can leave the other settings as they are.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这款游戏将在外太空进行，因此不需要重力，所以设置为 `0`。你可以保留其他设置不变。
- en: That completes the project setup tasks. It’s a good idea to look back through
    this section and make sure you didn’t miss anything, since the changes you’ve
    made here will affect the behavior of many game objects. You’ll see this in the
    next section, where you’ll make the player’s ship.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了项目设置任务。回顾这一节并确保你没有遗漏任何内容是个好主意，因为你在这里所做的更改将影响许多游戏对象的行为。你将在下一节中看到这一点，那时你将制作玩家的飞船。
- en: The player’s ship
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家的飞船
- en: The player’s ship is the heart of this game. Most of the code you’ll write for
    this project will be about making the ship work. It will be controlled in the
    classic “Asteroids style, with left/right rotation and forward thrust. The player
    will also be able to fire the laser and destroy floating rocks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的飞船是这款游戏的核心。你将为这个项目编写的绝大部分代码都将关于使飞船工作。它将以经典的“小行星风格”进行控制，包括左右旋转和前进推进。玩家还将能够发射激光并摧毁漂浮的岩石。
- en: '![Figure 3.4: The player’s ship](img/B19289_03_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4：玩家的飞船](img/B19289_03_04.jpg)'
- en: 'Figure 3.4: The player’s ship'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：玩家的飞船
- en: Body and physics setup
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身体和物理设置
- en: Create a new scene and add a `RigidBody2D` named `Player` as the root node,
    with `Sprite2D` and `CollisionShape2D` children. Add the `res://assets/player_ship.png`
    image to the `Sprite2D`. The ship image is quite large, so set the `Sprite2D`
    to `(0.5, 0.5)` and `90`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并添加一个名为 `Player` 的 `RigidBody2D` 作为根节点，带有 `Sprite2D` 和 `CollisionShape2D`
    子节点。将 `res://assets/player_ship.png` 图像添加到 `Sprite2D`。飞船图像相当大，所以将 `Sprite2D` 设置为
    `(0.5, 0.5)` 和 `90`。
- en: '![Figure 3.5: Player sprite settings](img/B19289_03_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5：玩家精灵设置](img/B19289_03_05.jpg)'
- en: 'Figure 3.5: Player sprite settings'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：玩家精灵设置
- en: Sprite orientation
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵方向
- en: The image for the ship is drawn pointing upward. In Godot, a rotation of `0`
    degrees points to the right (along the `x`-axis). This means that you need to
    rotate the sprite so that it will match the body’s direction. If you use art that
    is drawn in the correct orientation, you can avoid this step. However, it’s very
    common to find art that’s drawn in an upward orientation, so you should know what
    to do.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 飞船的图像是向上绘制的。在 Godot 中，`0` 度的旋转指向右侧（沿 `x` 轴）。这意味着你需要旋转精灵，使其与身体的朝向相匹配。如果你使用正确方向的绘画艺术，你可以避免这一步。然而，发现向上方向的绘画艺术是非常常见的，所以你应该知道该怎么做。
- en: In the `CollisionShape2D`, add a `CircleShape2D` and scale it to cover the image
    as closely as possible.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CollisionShape2D` 中添加一个 `CircleShape2D` 并将其缩放以尽可能紧密地覆盖图像。
- en: '![Figure 3.6: Player collision shape](img/B19289_03_06.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6：玩家碰撞形状](img/B19289_03_06.jpg)'
- en: 'Figure 3.6: Player collision shape'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：玩家碰撞形状
- en: The player ship is drawn in a pixel art style, but if you zoom in, you may notice
    it looks vary blurred and “smoothed out.” Godot’s default filter setting for drawing
    textures uses this smoothing technique, which looks good with some art, but typically
    isn’t wanted for pixel art. You can set the filtering individually on each sprite
    (in the **CanvasItem** section), or you can set it globally in **Project Settings**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家飞船以像素艺术风格绘制，但如果你放大查看，可能会注意到它看起来非常模糊和“平滑”。Godot 默认的纹理绘制过滤器设置使用这种平滑技术，这对于某些艺术作品来说看起来不错，但对于像素艺术通常是不想要的。你可以在每个精灵（在
    **CanvasItem** 部分中）上单独设置过滤器，或者你可以在 **项目设置** 中全局设置。
- en: Open **Project Settings** and check the **Advanced Settings** toggle, and then
    find the **rendering/textures** section. Near the bottom, you’ll see two settings
    for **Canvas Textures**. Set **Default Texture Filter** to **Nearest**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 **项目设置** 并检查 **高级设置** 开关，然后找到 **渲染/纹理** 部分。在底部附近，你会看到两个 **Canvas Textures**
    设置。将 **默认纹理过滤器** 设置为 **最近邻**。
- en: '![Figure 3.7: Default Texture Filter settings](img/B19289_03_07.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7：默认纹理过滤器设置](img/B19289_03_07.jpg)'
- en: 'Figure 3.7: Default Texture Filter settings'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：默认纹理过滤器设置
- en: Save the scene. When working on larger-scale projects, it is recommended to
    organize your scenes and scripts into folders based on each game object rather
    than saving them all in the root project folder. For example, if you make a “player”
    folder, you can save all player-related files there. This makes it easier to find
    and modify your various game objects. While this project is relatively small –
    you’ll only have a few scenes – it’s a good habit to adopt as your projects grow
    in size and complexity.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 保存场景。在处理更大规模的项目时，建议根据每个游戏对象将场景和脚本组织到文件夹中，而不是将它们全部保存在根项目文件夹中。例如，如果你创建一个“玩家”文件夹，你可以将所有与玩家相关的文件保存在那里。这使得查找和修改你的各种游戏对象变得更加容易。虽然这个项目相对较小——你将只有几个场景——但随着项目规模和复杂性的增加，养成这种习惯是很好的。
- en: State machines
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态机
- en: The player’s ship can be in a number of different states during gameplay. For
    example, when *alive*, the ship is visible and can be controlled by the player,
    but it is vulnerable to being hit by rocks. On the other hand, when *invulnerable*,
    the ship should appear semi-transparent, and it is immune to damage.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家飞船在游戏过程中可以处于多种不同的状态。例如，当 *存活* 时，飞船是可见的，并且可以被玩家控制，但它容易受到岩石的撞击。另一方面，当 *无敌* 时，飞船应该看起来半透明，并且对伤害免疫。
- en: One way that programmers often handle situations like this is to add Boolean
    variables, or *flags*, to the code. For example, the `invulnerable` flag is set
    to `true` when the player first spawns, or `alive` is set to `false` when the
    player is dead. However, this can lead to errors and strange situations when,
    for some reason, both `alive` and `invulnerable` are set to `false` at the same
    time. What happens when a rock hits the player in this situation? It would be
    better if the ship could only be in one clearly defined state at a time.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员处理此类情况的一种常见方式是在代码中添加布尔变量，或 *标志*。例如，当玩家首次生成时，将 `invulnerable` 标志设置为 `true`，或者当玩家死亡时，将
    `alive` 设置为 `false`。然而，当由于某种原因同时将 `alive` 和 `invulnerable` 都设置为 `false` 时，这可能会导致错误和奇怪的情况。在这种情况下，如果一块石头撞击玩家会发生什么？如果飞船只能处于一个明确定义的状态，那就更好了。
- en: A solution to this problem is to use a **finite state machine** (**FSM**). When
    using an FSM, an entity can only be in one state at a given time. To design your
    FSM, you define a number of states and what events or actions can cause a transition
    from one state to another.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法之一是使用**有限状态机**（**FSM**）。当使用FSM时，实体在给定时间只能处于一个状态。为了设计你的FSM，你定义了多个状态以及什么事件或动作可以导致从一个状态转换到另一个状态。
- en: 'The following diagram depicts the FSM for the player’s ship:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了玩家飞船的FSM：
- en: '![Figure 3.8: State machine diagram](img/B19289_03_08.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8：状态机图](img/B19289_03_08.jpg)'
- en: 'Figure 3.8: State machine diagram'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：状态机图
- en: There are four states, shown by the ovals, and the arrows indicate what transitions
    can occur between states, as well as what triggers the transition. By checking
    the current state, you can decide what the player is allowed to do. For example,
    in the **DEAD** state, don’t allow input, or in the **INVULNERABLE** state, allow
    movement but don’t allow shooting.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个状态，由椭圆形表示，箭头指示状态之间可以发生什么转换，以及什么触发转换。通过检查当前状态，你可以决定玩家被允许做什么。例如，在**死亡**状态中，不允许输入，或者在**无敌**状态中，允许移动但不允许射击。
- en: Advanced FSM implementations can become quite complex, and the details are beyond
    the scope of this book (see the *Appendix* for further reading). In the purest
    sense, you won’t be creating a true FSM here, but for the purposes of this project,
    it will be sufficient to illustrate the concept and keep you from running into
    the Boolean flag problem.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 高级FSM实现可能相当复杂，细节超出了本书的范围（参见*附录*以获取进一步阅读）。在最纯粹的意义上，你在这里不会创建一个真正的FSM，但为了这个项目的目的，它将足以说明这个概念并防止你遇到布尔标志问题。
- en: 'Add a script to the `Player` node and start by creating the skeleton of the
    FSM implementation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本添加到`Player`节点，并首先创建FSM实现的骨架：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An `enum` statement in the preceding code is equivalent to writing the following
    code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的`enum`语句等同于编写以下代码：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, create the `change_state()` function to handle state transitions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`change_state()`函数以处理状态转换：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Whenever you need to change the state of the player, you’ll call the `change_state()`
    function and pass it the value of the new state. Then, by using a `match` statement,
    you can execute whatever code should accompany the transition to the new state
    or disallow it if you don’t want that transition to happen. To illustrate this,
    the `CollisionShape2D` node is being enabled/disabled by the new state. In `_ready()`,we
    set `ALIVE` as the initial state – this is for testing, but we’ll change it to
    `INIT` later.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你需要更改玩家的状态时，你将调用`change_state()`函数并传递新状态的价值。然后，通过使用`match`语句，你可以执行伴随新状态转换的任何代码，或者如果你不希望发生该转换，则禁止它。为了说明这一点，`CollisionShape2D`节点将由新状态启用/禁用。在`_ready()`中，我们设置`ALIVE`为初始状态——这是为了测试，但稍后我们将将其更改为`INIT`。
- en: Adding player controls
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加玩家控制
- en: 'Add the following variables at the top of the script:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的顶部添加以下变量：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`engine_power` and `spin_power` control how fast the ship can accelerate and
    turn. `thrust` represents the force being applied by the engine: either `(0, 0)`
    when coasting or a vector pointing forward when the engine is on. `rotation_dir`
    represents in which direction the ship is turning so that you can apply a *torque*
    or rotational force.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`engine_power`和`spin_power`控制飞船加速和转向的速度。`thrust`代表引擎施加的力：当滑行时为`(0, 0)`，当引擎开启时为一个指向前方的向量。`rotation_dir`表示飞船转向的方向，以便你可以施加一个*扭矩*或旋转力。'
- en: As we saw earlier in `1` and `5`. You can adjust these later to change how the
    ship handles.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前在`1`和`5`中看到的。你可以稍后调整它们以改变飞船的处理方式。
- en: 'The next step is to detect the input and move the ship:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是检测输入并移动飞船：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `get_input()` function captures the key actions and sets the ship’s thrust
    on or off. Note that the direction of the thrust is based on the body’s `transform.x`,
    which always represents the body’s “forward” direction (see the *Appendix* for
    an overview of transforms).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_input()`函数捕获按键动作并设置飞船的推力开启或关闭。请注意，推力的方向基于身体的`transform.x`，它始终代表身体的“前进”方向（参见*附录*以获取变换的概述）。'
- en: '`Input.get_axis()` returns a value based on two inputs, representing negative
    and positive values. So, `rotation_dir` will be clockwise, counter-clockwise,
    or zero, depending on the state of the two input actions.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Input.get_axis()`根据两个输入返回一个值，代表负值和正值。因此，`rotation_dir`将表示顺时针、逆时针或零，具体取决于两个输入动作的状态。'
- en: Finally, when using physics bodies, their movement and related functions should
    always be called in `_physics_process()`. Here, you can apply the forces set by
    the inputs to actually move the body.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当使用物理体时，它们的运动和相关函数应该始终在`_physics_process()`中调用。在这里，你可以应用由输入设置的力，以实际移动物体。
- en: Play the scene, and you should be able to fly around freely.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 播放场景，你应该能够自由地飞来飞去。
- en: Screen wrap
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 屏幕环绕
- en: 'Another feature of classic 2D arcade games is *screen wrap*. If the player
    goes off one side of the screen, they appear on the other side. In practice, you
    teleport the ship to the other side by instantly changing its position. You’ll
    need to know the size of the screen, so add the following variable to the top
    of the script:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 经典2D街机游戏的一个特点是*屏幕环绕*。如果玩家离开屏幕的一侧，他们就会出现在另一侧。在实践中，你通过瞬间改变其位置来将飞船传送到另一侧。你需要知道屏幕的大小，所以请将以下变量添加到脚本顶部：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And add this to `_ready()`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其添加到`_ready()`：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Later, you can have the game’s main script handle setting `screensize` for all
    the game’s objects, but for now, this will allow you to test the screen wrapping
    with just the player’s scene.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你可以让游戏的主脚本处理设置所有游戏对象的`screensize`，但就目前而言，这将允许你仅通过玩家的场景来测试屏幕环绕效果。
- en: 'When first approaching this problem, you might think you could use the body’s
    `position` property and, if it exceeds the bounds of the screen, set it to the
    opposite side. And if you were using any other node type, that would work just
    fine; however, when using `RigidBody2D`, you can’t directly set `position` because
    that would conflict with the movement that the physics engine is calculating.
    A common mistake is to try adding something like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次接触这个问题时，你可能认为可以使用物体的`position`属性，如果它超出了屏幕的边界，就将其设置为对面的边。如果你使用任何其他节点类型，那将工作得很好；然而，当使用`RigidBody2D`时，你不能直接设置`position`，因为这会与物理引擎正在计算的运动发生冲突。一个常见的错误是尝试添加如下内容：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And if you wanted to try this with the `Area2D` in *Coin Dash*, it would work
    perfectly fine. Here, it will fail, trapping the player on the edge of the screen
    and glitching unpredictably at the corners. So, what is the answer?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在*Coin Dash*中的`Area2D`尝试这个，它将完美地工作。在这里，它将失败，将玩家困在屏幕边缘，并在角落处出现不可预测的故障。那么，答案是什么？
- en: 'To quote the `RigidBody2D` documentation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 引用`RigidBody2D`文档：
- en: 'Note: You should not change a RigidBody2D’s `position` or `linear_velocity`
    every frame or even very often. If you need to directly affect the body’s state,
    use `_integrate_forces`, which allows you to directly access the physics state.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你不应该在每一帧或非常频繁地更改RigidBody2D的`position`或`linear_velocity`。如果你需要直接影响物体的状态，请使用`_integrate_forces`，这允许你直接访问物理状态。
- en: 'And in the description for `_integrate_forces()`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在`_integrate_forces()`的描述中：
- en: (It) Allows you to read and safely modify the simulation state for the object.
    Use this instead of `_physics_process` if you need to directly change the body’s
    position or other physics properties.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: （它）允许你读取并安全地修改对象的模拟状态。如果你需要直接更改物体的位置或其他物理属性，请使用此方法代替`_physics_process`。
- en: So, the answer is to use this separate function when you want to directly affect
    the rigid body’s position. Using `_integrate_forces(`) gives you access to the
    body’s `PhysicsDirectBodyState2D` – a Godot object containing a great deal of
    useful information about the current state of the body. Since you want to change
    the body’s location, that means you need to modify its `Transform2D`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，答案是当你想直接影响刚体的位置时使用这个单独的函数。使用`_integrate_forces(`)让你可以访问物体的`PhysicsDirectBodyState2D`
    – 一个包含大量关于物体当前状态的有用信息的Godot对象。由于你想改变物体的位置，这意味着你需要修改它的`Transform2D`。
- en: A `origin` property of the `Transform2D`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transform2D`的`origin`属性。'
- en: 'Using this information, you can implement the wrap-around effect by adding
    the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，你可以通过添加以下代码来实现环绕效果：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `wrapf()` function takes a value (the first argument) and “wraps” it between
    any min/max values you choose. So, if the value goes below `0`, it becomes `screensize.x`,
    and vice versa.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapf()`函数接受一个值（第一个参数）并将其“环绕”在你选择的任何最小/最大值之间。所以，如果值低于`0`，它就变成`screensize.x`，反之亦然。'
- en: Note that you’re using `physics_state` for the parameter name rather than the
    default of `state`. This is to avoid confusion since `state` is already being
    used to track the player’s state.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你使用的是`physics_state`作为参数名，而不是默认的`state`。这是为了避免混淆，因为`state`已经被用来跟踪玩家的状态。
- en: Run the scene again and check that everything is working as expected. Make sure
    you try wrapping around in all four directions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行场景，并检查一切是否按预期工作。确保你尝试在所有四个方向上环绕。
- en: Shooting
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 射击
- en: Now it’s time to give your ship some weapons. When pressing the `shoot` action,
    a bullet/laser should be spawned at the front of the ship and then travel in a
    straight line until it exits the screen. The player isn’t allowed to shoot again
    until a small amount of time has passed (also known as a **cooldown**).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是给你的船装备一些武器的时候了。当按下 `shoot` 动作时，一个子弹/激光应该出现在船的前端，然后沿直线飞行，直到飞出屏幕。玩家在经过一小段时间后（也称为
    **冷却时间**）才能再次射击。
- en: Bullet scene
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子弹场景
- en: 'This is the node setup for the bullet:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是子弹的节点设置：
- en: '`Area2D` named `Bullet`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Area2D` 命名为 `Bullet`'
- en: '`Sprite2D`'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite2D`'
- en: '`CollisionShape2D`'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollisionShape2D`'
- en: '`VisibleOnScreenNotifier2D`'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VisibleOnScreenNotifier2D`'
- en: 'Use `res://assets/laser.png` from the assets folder for the `Sprite2D` and
    a `CapsuleShape2D` for the collision shape. You’ll need to set `CollisionShape2D`
    to `90` so that it is oriented correctly. You should also scale `Sprite2D` down
    to about half the size: `(``0.5, 0.5)`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用从资源文件夹 `res://assets/laser.png` 的 `Sprite2D` 和一个 `CapsuleShape2D` 作为碰撞形状。你需要将
    `CollisionShape2D` 设置为 `90` 以确保它正确对齐。你还应该将 `Sprite2D` 缩小到大约一半的大小：`(``0.5, 0.5)`。
- en: 'Add the following script to the `Bullet` node:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下脚本添加到 `Bullet` 节点：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You’ll call the `start()` function whenever you spawn a new bullet. By passing
    it a transform, you can give it the correct position *and* rotation – typically
    that of the ship’s gun (more about this later).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你生成一个新的子弹时，你将调用 `start()` 函数。通过传递一个变换，你可以给它正确的位置和旋转——通常是船的炮口（关于这一点稍后会有更多介绍）。
- en: 'The `VisibleOnScreenNotifier2D` is a node that informs you (via a signal) whenever
    a node becomes visible/invisible. You can use this to automatically delete a bullet
    that goes offscreen. Connect the node’s `screen_exited` signal and add this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`VisibleOnScreenNotifier2D` 是一个节点，每当一个节点变为可见或不可见时，它会通过一个信号通知你。你可以使用这个功能来自动删除飞出屏幕的子弹。连接节点的
    `screen_exited` 信号并添加以下内容：'
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, connect the bullet’s `body_entered` signal so that it can detect when
    it hits a rock. The bullet doesn’t need to know anything about rocks, just that
    it has hit something. When you create the rock, you’ll add it to a group called
    `rocks` and give it an `explode()` method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，连接子弹的 `body_entered` 信号，以便它可以检测到它击中了一块石头。子弹不需要知道任何关于石头的事情，只需要知道它击中了某个东西。当你创建石头时，你将把它添加到一个名为
    `rocks` 的组中，并给它一个 `explode()` 方法：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Firing bullets
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发射子弹
- en: The next step is to create instances of the `Bullet` scene whenever the player
    presses the `shoot` action. However, if you make the bullet a child of the player,
    then it will move and rotate along with the player instead of moving independently.
    You could add the bullet to the main scene using `get_parent().add_child()`, since
    the `Main` scene will be the parent of the player when the game is running. However,
    this would mean that you could no longer run and test the `Player` scene by itself.
    Or, if you decided to rearrange your `Main` scene, making the player a child of
    some other node, the bullet wouldn’t be added where you expect.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在玩家按下 `shoot` 动作时创建 `Bullet` 场景的实例。然而，如果你把子弹变成玩家的子节点，那么它会随着玩家移动和旋转，而不是独立移动。你可以使用
    `get_parent().add_child()` 将子弹添加到主场景中，因为当游戏运行时，`Main` 场景将是玩家的父节点。但是，这意味着你将无法单独运行和测试
    `Player` 场景。或者，如果你决定重新排列你的 `Main` 场景，使玩家成为某个其他节点的子节点，子弹就不会出现在你期望的位置。
- en: In general, it is a bad idea to write code that assumes a fixed tree layout.
    Especially try to avoid situations where you use `get_parent()` if at all possible.
    You may find it difficult to think this way at first, but it will result in a
    much more modular design and prevent some common mistakes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，编写假设固定树布局的代码是一个坏主意。特别是尽量避免使用 `get_parent()` 的情况。一开始你可能觉得很难这样思考，但这将导致一个更模块化的设计，并防止一些常见的错误。
- en: In any case, the `SceneTree` will always exist, and for this game, it will be
    fine to make the bullet a child of the tree’s root, which is the `Window` containing
    the game.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，`SceneTree` 总是存在的，对于这个游戏来说，将子弹作为树的根节点（即包含游戏的 `Window`）的子节点是完全可以的。
- en: Add a `Marker2D` node to the player and name it `Muzzle`. This will mark the
    muzzle of the gun – the location where the bullet will spawn. Set `(50, 0)` to
    place it directly in front of the ship.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家上添加一个名为 `Muzzle` 的 `Marker2D` 节点。这将标记枪的枪口——子弹将生成的位置。将 `(50, 0)` 设置为将其直接放置在船的前方。
- en: Next, add a `Timer` node and name it `GunCooldown`. This will provide a cooldown
    to the gun, preventing a new bullet from firing until a certain amount of time
    has passed. Check the **One Shot** and **Autostart** boxes to “on.”
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个`Timer`节点并将其命名为`GunCooldown`。这将给枪提供冷却时间，防止在经过一定时间后发射新的子弹。勾选**One Shot**和**Autostart**复选框以“开启”。
- en: 'Add these new variables to the player’s script:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下新变量添加到玩家的脚本中：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Drag the `bullet.tscn` file onto the new **Bullet** property in the Inspector.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将`bullet.tscn`文件拖放到检查器中新的**Bullet**属性。
- en: 'Add this line to `_ready()`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将此行添加到`_ready()`中：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And this to `get_input()`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 并将此添加到`get_input()`中：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now create the `shoot()` function, which will handle creating the bullet(s):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个`shoot()`函数，该函数将处理创建子弹：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When shooting, you first set `can_shoot` to `false` so that the action no longer
    calls `shoot()`. Then you add the new bullet as a child of whatever node is the
    root of the scene tree. Finally, you call the bullet’s `start()` function and
    give it the muzzle node’s *global* transform. Note that if you used `transform`
    here, you’d be giving it the muzzle’s position relative to the player (which is
    `(50, 0)`, remember?), and so the bullet would spawn in entirely the wrong place.
    This is another example of how important it is to understand the distinction between
    local and global coordinates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 射击时，首先将`can_shoot`设置为`false`，这样动作就不会再调用`shoot()`。然后，将新子弹作为场景树根节点的子节点添加。最后，调用子弹的`start()`函数，并给它提供枪口节点的*全局*变换。注意，如果你在这里使用`transform`，你会给出相对于玩家的枪口位置（记住是`(50,
    0)`），因此子弹会在完全错误的位置生成。这是理解局部和全局坐标之间区别重要性的另一个例子。
- en: 'To allow the gun to shoot again, connect the `timeout` signal of `GunCooldown`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许枪再次射击，连接`GunCooldown`的`timeout`信号：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Testing the player’s ship
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试玩家的飞船
- en: Create a new scene using a `Node` named `Main` and add a `Sprite2D` named `Background`
    as a child. Use `res://assets/space_background.png` in the `Player` to the scene.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，使用名为`Main`的`Node`，并添加一个名为`Background`的`Sprite2D`作为子节点。在`Player`场景中使用`res://assets/space_background.png`。
- en: Play the main scene and test that you can fly and shoot.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 播放主场景并测试是否可以飞行和射击。
- en: Now that your player’s ship works, it’s a good time to pause and check your
    understanding. Working with rigid bodies can be tricky; take a few minutes to
    experiment with some of the settings and code from this section. Just make sure
    to change them back before moving on to the next section, where you’ll add the
    asteroids to the game.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家的飞船工作正常，是时候暂停并检查你的理解了。与刚体一起工作可能会有点棘手；花几分钟时间实验本节中的一些设置和代码。只是确保在进入下一节之前将它们改回原样，下一节你将添加小行星到游戏中。
- en: Adding the rocks
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加岩石
- en: The goal of the game is to destroy the floating space rocks, so now that you
    can shoot, it’s time to add them. Like the ship, the rocks will use `RigidBody2D`,
    which will make them travel in a straight line at a steady speed unless disturbed.
    They’ll also bounce off each other in a realistic fashion. To make things more
    interesting, rocks will start out large and, when you shoot them, break into multiple
    smaller rocks.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的目标是摧毁漂浮的太空岩石，所以现在你可以射击了，是时候添加它们了。像飞船一样，岩石将使用`RigidBody2D`，这将使它们以恒定的速度直线运动，除非受到干扰。它们还会以逼真的方式相互弹跳。为了使事情更有趣，岩石将开始时很大，当你射击它们时，会分裂成多个更小的岩石。
- en: Scene setup
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景设置
- en: Start a new scene with a `RigidBody2D` node named `Rock`, and add a `Sprite2D`
    child using the `res://assets/rock.png` texture. Add a `CollisionShape2D`, but
    *don’t* set its shape yet. Because you’ll be spawning different-sized rocks, the
    collision shape will need to be set in code and adjusted to the correct size.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，使用名为`Rock`的`RigidBody2D`节点，并添加一个使用`res://assets/rock.png`纹理的`Sprite2D`子节点。添加一个`CollisionShape2D`，但*不要*设置其形状。因为你会生成不同大小的岩石，所以碰撞形状需要在代码中设置并调整到正确的大小。
- en: You don’t want the rocks coasting to a stop, so they need to ignore the default
    linear and angular damping. Set both `0` and `New PhysicsMaterial` and then click
    on it to expand. Set the displayed `1`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望岩石滑行到停止，所以它们需要忽略默认的线性和角阻尼。将两个都设置为`0`和`New PhysicsMaterial`，然后点击它以展开。设置显示为`1`。
- en: Variable size rocks
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量大小岩石
- en: 'Attach a script to `Rock` and define the member variables:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本附加到`Rock`上并定义成员变量：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Main` script will handle spawning new rocks, both at the beginning of a
    level as well as the smaller rocks that will appear after a large one explodes.
    A large rock will have a size of `3`, break into rocks of size `2`, and so on.
    The `scale_factor` is multiplied by `size` to set the `Sprite2D` scale, the collision
    radius, and so on. You can adjust this later to change how big each category of
    rock is.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`主`脚本将处理生成新岩石，包括在关卡开始时以及在大岩石爆炸后出现的较小岩石。一个大岩石将有一个大小为`3`，分解成大小为`2`的岩石，依此类推。`scale_factor`乘以`size`来设置`Sprite2D`缩放、碰撞半径等。你可以稍后调整它来改变每个岩石类别的尺寸。'
- en: 'All of this will be set by the `start()` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都将通过`start()`方法设置：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is where you calculate the correct collision size based on the rock’s `size`.
    Note that since `position` and `size` are already in use as class variables, you
    can use an underscore for the function’s arguments to prevent conflict.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你根据岩石的`size`计算正确碰撞大小的地方。请注意，由于`position`和`size`已经被用作类变量，你可以使用下划线作为函数的参数以防止冲突。
- en: 'The rocks also need to wrap around the screen like the player, so use the same
    technique with `_integrate_forces()`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 岩石也需要像玩家一样绕屏幕滚动，所以使用相同的技术与`_integrate_forces()`：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The one difference here is that including the rock’s `radius` in the calculation
    results in smoother-looking teleportation. The rock will appear to fully exit
    the screen before entering the opposite side. You may want to do the same thing
    with the player’s ship. Try it and see which you like better.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个区别是，将岩石的`radius`包含在计算中会导致看起来更平滑的传送效果。岩石看起来会完全退出屏幕，然后进入对面。你可能也想用同样的方法处理玩家的飞船。试试看，看看你更喜欢哪一个。
- en: Instantiating rocks
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化岩石
- en: When new rocks are spawned, the main scene will need to pick a random starting
    location. To do this, you could use some math to pick a random point along the
    perimeter of the screen, but instead, you can take advantage of another Godot
    node type. You’ll draw a path around the edge of the screen, and the script will
    pick a random location along that path.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成新的岩石时，主场景需要选择一个随机的起始位置。为此，你可以使用一些数学方法来选择屏幕边缘的随机点，但相反，你可以利用另一种Godot节点类型。你将在屏幕边缘绘制一个路径，脚本将选择该路径上的一个随机位置。
- en: 'In the `Main` scene, add a `Path2D` node and name it `RockPath`. When you select
    the node, you will see some new buttons appear at the top of the editor window:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`主`场景中，添加一个`Path2D`节点并将其命名为`RockPath`。当你选择该节点时，你将在编辑器窗口的顶部看到一些新的按钮：
- en: '![Figure 3.9: Path drawing tools](img/B19289_03_09.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9：路径绘制工具](img/B19289_03_09.jpg)'
- en: 'Figure 3.9: Path drawing tools'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：路径绘制工具
- en: 'Select the middle one (**Add Point**) to draw the path by clicking the points
    shown in the following screenshot. To make the points align, make sure **Use Grid
    Snap** is checked. This option is found in the icon bar at the top of the editor
    window:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 选择中间的（**添加点**）通过点击以下截图所示的点来绘制路径。为了使点对齐，请确保**使用网格吸附**被勾选。此选项位于编辑器窗口顶部的图标栏中：
- en: '![Figure 3.10: Enabling grid snapping](img/B19289_03_10.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10：启用网格吸附](img/B19289_03_10.jpg)'
- en: 'Figure 3.10: Enabling grid snapping'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：启用网格吸附
- en: 'Draw the points in the order shown in the following screenshot. After clicking
    the fourth point, click the **Close Curve** button (marked *5* in the screenshot)
    and your path will be complete:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下截图所示的顺序绘制点。点击第四个点后，点击**关闭曲线**按钮（截图中标为*5*），你的路径将完成：
- en: '![Figure 3.11: Path drawing order](img/B19289_03_11.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11：路径绘制顺序](img/B19289_03_11.jpg)'
- en: 'Figure 3.11: Path drawing order'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：路径绘制顺序
- en: Don’t click in the editor window again if you have `RockPath` selected! If you
    do, you’ll add additional points to the curve, and your rocks may not spawn where
    you want them to. You can press *Ctrl* + *Z* to undo any extra points you may
    have added.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了`RockPath`，请不要再次在编辑器窗口中点击！如果你这样做，你会在曲线上添加额外的点，你的岩石可能不会出现在你想要的位置。你可以按*Ctrl*
    + *Z*来撤销你可能添加的任何额外点。
- en: Now that the path is defined, add a `PathFollow2D` as a child of `RockPath`
    and name it `RockSpawn`. This node’s purpose is to automatically move along its
    parent path using its **Progress** property, which represents an offset along
    the path. The higher the offset, the further along the path it goes. Since our
    path is closed, it will also loop if the offset value is bigger than the path’s
    length.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在路径已经定义，将 `PathFollow2D` 添加为 `RockPath` 的子节点，并命名为 `RockSpawn`。此节点的目的是使用其 **Progress**
    属性自动沿着其父路径移动，该属性表示路径上的偏移量。偏移量越高，它沿着路径移动得越远。由于我们的路径是闭合的，如果偏移量值大于路径长度，它也会循环。
- en: 'Add the following script to `Main.gd`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下脚本添加到 `Main.gd`：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You start by getting the `screensize` so that you can pass it to the rocks when
    they’re spawned. Then, you spawn three rocks of size `3`. Don’t forget to drag
    `rock.tscn` onto the **Rock** property.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先获取 `screensize`，以便在石头生成时传递给它。然后，生成三个大小为 `3` 的石头。别忘了将 `rock.tscn` 拖到 **Rock**
    属性上。
- en: 'Here is the `spawn_rock()` function:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `spawn_rock()` 函数：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This function serves two purposes. When called with only a `size` parameter,
    it picks a random position along the `RockPath` and a random velocity. However,
    if those values are provided, it will use them instead. This will let you spawn
    the smaller rocks at the location of the explosion by specifying their properties.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有两个作用。当只调用一个 `size` 参数时，它会在 `RockPath` 上选择一个随机位置和一个随机速度。然而，如果提供了这些值，它将使用它们。这将允许你通过指定它们的属性在爆炸位置生成较小的石头。
- en: Run the game and you should see three rocks floating around, but your bullets
    don’t affect them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏后，你应该看到三块石头在周围漂浮，但你的子弹对它们没有影响。
- en: Exploding rocks
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 爆炸石头
- en: 'The bullet checks for bodies in the `rocks` group, so in the `Rock` scene,
    select the `rocks` and click **Add**:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹检查 `rocks` 组中的身体，所以在 `Rock` 场景中，选择 `rocks` 并点击 **Add**：
- en: '![Figure 3.12: Adding a “rocks” group](img/B19289_03_12.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12：添加“rocks”组](img/B19289_03_12.jpg)'
- en: 'Figure 3.12: Adding a “rocks” group'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12：添加“rocks”组
- en: 'Now, if you run the game and shoot a rock, you’ll see an error message because
    the bullet is trying to call the rock’s `explode()` method, which you haven’t
    defined yet. This method needs to do three things:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行游戏并射击一块石头，你会看到一个错误消息，因为子弹正在尝试调用石头的 `explode()` 方法，但你还没有定义它。此方法需要做三件事：
- en: Remove the rock
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除石头
- en: Play an explosion animation
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放爆炸动画
- en: Notify `Main` to spawn new, smaller rocks
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知 `Main` 生成新的、更小的石头
- en: Explosion scene
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 爆炸场景
- en: 'The explosion will be a separate scene, which you can add to the `Rock` and
    later to the `Player`. It will contain two nodes:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 爆炸将是一个独立的场景，你可以将其添加到 `Rock`，然后添加到 `Player`。它将包含两个节点：
- en: '`Sprite2D` named `Explosion`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite2D` 命名为 `Explosion`'
- en: '`AnimationPlayer`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnimationPlayer`'
- en: For the `Sprite2D` node’s `res://assets/explosion.png`. You’ll notice this is
    a `Sprite2D` node supports using them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Sprite2D` 节点的 `res://assets/explosion.png`。你会注意到这是一个 `Sprite2D` 节点，它支持使用它们。
- en: In the Inspector, find the sprite’s `8`. This will slice the sprite sheet into
    its 64 individual images. You can verify this by changing the `0` and `63`. Make
    sure to set it back to `0` before you continue.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器中，找到精灵的 `8`。这将把精灵图集切成64个单独的图像。你可以通过更改 `0` 和 `63` 来验证这一点。确保在继续之前将其设置回 `0`。
- en: '![Figure 3.13: Sprite Animation settings](img/B19289_03_13.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13：精灵动画设置](img/B19289_03_13.jpg)'
- en: 'Figure 3.13: Sprite Animation settings'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13：精灵动画设置
- en: 'The `AnimationPlayer` node can be used to animate any property of any node.
    You’ll use it to change the **Frame** property over time. Start by selecting the
    node and you’ll see the **Animation** panel open at the bottom:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimationPlayer` 节点可以用来动画化任何节点的任何属性。你将使用它来随时间改变 **Frame** 属性。首先选择节点，你会在底部打开
    **Animation** 面板：'
- en: '![Figure 3.14: Animation panel](img/B19289_03_14.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14：动画面板](img/B19289_03_14.jpg)'
- en: 'Figure 3.14: Animation panel'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14：动画面板
- en: Click the `explosion`. Set `0.64` and `0.01`. Select the `Sprite2D` node and
    you’ll notice that each property in the Inspector now has a key symbol next to
    it. Clicking on a key will create a *keyframe* in the current animation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `explosion`。设置 `0.64` 和 `0.01`。选择 `Sprite2D` 节点，你会注意到检查器中现在每个属性旁边都有一个键符号。点击一个键将在当前动画中创建一个
    *关键帧*。
- en: '![Figure 3.15: Animation time settings](img/B19289_03_15.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15：动画时间设置](img/B19289_03_15.jpg)'
- en: 'Figure 3.15: Animation time settings'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15：动画时间设置
- en: Click the key next to the `Explosion` node’s `AnimationPlayer` that at time
    `0`, you want the sprite’s `0`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `Explosion` 节点的 `AnimationPlayer` 旁边的键，在时间 `0` 时，你想让精灵的 `0`。
- en: 'Slide the scrubber to time `0.64` (you can adjust the zoom using the slider
    if you can’t see it). Set `63` and click the key again. Now the animation knows
    to use the last image at the animation’s final time. However, you also need to
    let the `AnimationPlayer` know that you want to use all the intermediate values
    in the times between those two points. At the right side of the animation track
    is an **Update Mode** dropdown. It’s currently set to **Discrete**, and you need
    to change it to **Continuous**:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动刮擦器到时间`0.64`（如果看不到，可以使用滑块调整缩放）。设置`63`并再次点击键。现在动画知道在动画的最终时间使用最后一张图像。然而，你还需要让`AnimationPlayer`知道你希望在两个点之间的时间使用所有中间值。在动画轨道的右侧有一个**更新模式**下拉菜单。它目前设置为**离散**，你需要将其更改为**连续**：
- en: '![Figure 3.16: Setting Update Mode](img/B19289_03_16.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图3.16：设置更新模式](img/B19289_03_16.jpg)'
- en: 'Figure 3.16: Setting Update Mode'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16：设置更新模式
- en: Click the **Play** button in the **Animation** panel to see the animation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**播放**按钮，在**动画**面板中查看动画。
- en: 'You can now add the explosion to the rock. In the `Rock` scene, add an instance
    of `Explosion` and click the eye icon next to the node to make it hidden. Add
    this line to `start()`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以将爆炸添加到岩石上。在`Rock`场景中，添加一个`Explosion`实例，并点击节点旁边的眼睛图标使其隐藏。将此行添加到`start()`中：
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will ensure the explosion is scaled to match the rock’s size.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保爆炸的缩放与岩石的大小相匹配。
- en: 'Add a signal called `exploded` at the top of the script, then add the `explode()`
    function, which will be called when the bullet hits the rock:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本顶部添加一个名为`exploded`的信号，然后添加`explode()`函数，该函数将在子弹击中岩石时被调用：
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, you hide the rock and play the explosion, waiting for it to finish before
    removing the rock. When you emit the `exploded` signal, you also include all the
    rock’s information, so that `spawn_rock()` in `Main` will be able to spawn the
    smaller rocks at the same location.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你隐藏岩石并播放爆炸，等待爆炸完成后才移除岩石。当你发出`exploded`信号时，你还包括所有岩石的信息，这样`Main`中的`spawn_rock()`就可以在相同的位置生成较小的岩石。
- en: Test the game and check that you can see explosions when you shoot the rocks.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 测试游戏并确认在射击岩石时可以看到爆炸效果。
- en: Spawning smaller rocks
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成较小的岩石
- en: 'The `Rock` scene is emitting the signal, but `Main` isn’t listening for it
    yet. You can’t connect the signal in the `spawn_rock()`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rock`场景正在发出信号，但`Main`还没有监听它。你无法在`spawn_rock()`中连接信号：'
- en: '[PRE24]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This connects the rock’s signal to a function in `Main`, which you also need
    to create:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把岩石的信号连接到`Main`中的一个函数，你也需要创建它：
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this function, you create two new rocks unless the rock that was just destroyed
    was of size `1` (the smallest size). The `offset` loop variable ensures that the
    two new rocks travel in opposite directions (that is, one’s velocity will be negative).
    The `dir` variable finds the vector between the player and the rock, then uses
    `orthogonal()` to get a vector that’s perpendicular. This ensures that the new
    rocks don’t fly straight toward the player.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，除非刚刚被摧毁的岩石大小为`1`（最小尺寸），否则你将创建两个新的岩石。`offset`循环变量确保两个新的岩石向相反方向移动（即，一个的速度将是负值）。`dir`变量找到玩家和岩石之间的向量，然后使用`orthogonal()`得到一个垂直的向量。这确保了新的岩石不会直接飞向玩家。
- en: '![Figure 3.17: Explosion diagram](img/B19289_03_17.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图3.17：爆炸图](img/B19289_03_17.jpg)'
- en: 'Figure 3.17: Explosion diagram'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17：爆炸图
- en: Play the game once again and check that everything is working as expected.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 再次播放游戏并检查一切是否按预期工作。
- en: 'This is a good place to stop and review what you’ve done so far. You’ve completed
    all the basic functionality of the game: the player can fly around and shoot;
    the rocks float, bounce, and explode; and new rocks are spawned. You should be
    feeling more comfortable using rigid bodies at this point. In the next section,
    you’ll start building the interface to allow the player to start the game and
    see important information during gameplay.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的地方停下来回顾你已经做了什么。你已经完成了游戏的所有基本功能：玩家可以飞行并射击；岩石漂浮、弹跳和爆炸；并且会生成新的岩石。你现在应该对使用刚体感到更加自在。在下一节中，你将开始构建界面，允许玩家开始游戏并在游戏过程中查看重要信息。
- en: Creating the UI
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: Creating a UI for your game can be very complex, or at least time-consuming.
    Precisely placing individual elements and ensuring they work across different-sized
    screens and devices is the least interesting part of game development for many
    programmers. Godot provides a wide variety of `Control` nodes to assist in this
    process. Learning how to use the various `Control` nodes will help lessen the
    pain of creating a polished UI.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的游戏创建 UI 可能非常复杂，或者至少很耗时。精确放置单个元素并确保它们在不同尺寸的屏幕和设备上都能正常工作，对于许多程序员来说，这是游戏开发中最不有趣的部分。Godot
    提供了各种 `Control` 节点来协助这个过程。学习如何使用各种 `Control` 节点将有助于减轻创建精美 UI 的痛苦。
- en: 'For this game, you don’t need a very complex UI. The game needs to provide
    the following information and interactions:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个游戏，你不需要一个非常复杂的 UI。游戏需要提供以下信息和交互：
- en: Start button
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始按钮
- en: Status message (such as “Get Ready” or “Game Over”)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态信息（例如“准备”或“游戏结束”）
- en: Score
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得分
- en: Lives counter
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命值计数器
- en: 'Here is a preview of what you will make:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你将要制作的内容预览：
- en: '![Figure 3.18: UI layout](img/B19289_03_18.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.18：UI 布局](img/B19289_03_18.jpg)'
- en: 'Figure 3.18: UI layout'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18：UI 布局
- en: Create a new scene and add a `CanvasLayer` node with the name `HUD` as the root
    node. You’ll build the UI on this layer using the `Control` node’s layout features.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并将名为 `HUD` 的 `CanvasLayer` 节点作为根节点。你将在这个层上使用 `Control` 节点的布局功能来构建 UI。
- en: Layout
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局
- en: Godot’s `Control` nodes include a number of specialized containers. These nodes
    can be nested inside each other to create the exact layout you need. For example,
    a `MarginContainer` automatically adds padding around its contents, while `HBoxContainer`
    and `VBoxContainer` organize their contents in rows or columns, respectively.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 的 `Control` 节点包括许多专用容器。这些节点可以嵌套在一起以创建所需的精确布局。例如，`MarginContainer` 会自动为其内容添加填充，而
    `HBoxContainer` 和 `VBoxContainer` 分别按行或列组织其内容。
- en: 'Follow these steps to build the layout:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤构建布局：
- en: Start by adding `Timer` and `MarginContainer children`, which will hold the
    score and life counters. In the **Layout** dropdown, select **Top Wide**.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加 `Timer` 和 `MarginContainer` 子节点，它们将包含得分和生命值计数器。在 **布局** 下拉菜单中，选择 **Top
    Wide**。
- en: '![Figure 3.19: Top Wide control alignment](img/B19289_03_19.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.19：Top Wide 控件对齐](img/B19289_03_19.jpg)'
- en: 'Figure 3.19: Top Wide control alignment'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19：Top Wide 控件对齐
- en: In the Inspector, set the four margins in **Theme Overrides/Constants** to 20.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中，将 **主题覆盖/常量** 中的四个边距设置为 20。
- en: Set the `Timer` to on and its `2`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Timer` 设置为开启并设置为 `2`。
- en: As a child of the container, add an `HBoxContainer`, which will position the
    score counter on the left and the lives counter on the right. Under this container,
    add a `Label` (name it `ScoreLabel`) and another `HBoxContainer` (named `LivesCounter`).
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为容器的子节点，添加一个 `HBoxContainer`，它将把得分计数器放在左边，生命值计数器放在右边。在这个容器下，添加一个 `Label`（命名为
    `ScoreLabel`）和一个 `HBoxContainer`（命名为 `LivesCounter`）。
- en: Set the `ScoreLabel's` `0`, and under `res://assets/kenvector_future_thin.ttf`
    and setting the font size to `64`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `ScoreLabel` 的值设置为 `0`，并在 `res://assets/kenvector_future_thin.ttf` 下设置字体大小为
    `64`。
- en: Select `LivesCounter` and set `20`, then add a child `TextureRect` and name
    it `L1`. Drag `res://assets/player_small.png` to the `L1` node selected and press
    *duplicate* (*Ctrl* + *D*) twice to create `L2` and `L3` (they’ll be named automatically).
    During the game, the `HUD` will show or hide these three textures to indicate
    how many lives the player has left.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `LivesCounter` 并设置 `20`，然后添加一个子节点 `TextureRect` 并命名为 `L1`。将 `res://assets/player_small.png`
    拖到选中的 `L1` 节点，并按 *duplicate* (*Ctrl* + *D*) 键两次以创建 `L2` 和 `L3`（它们将被自动命名）。在游戏过程中，`HUD`
    将显示或隐藏这三个纹理，以指示玩家剩余的生命值。
- en: In a larger, more complex UI, you might save this section as its own scene and
    embed it in other section(s) of the UI. However, this game only needs a few more
    elements, so it’s fine to combine them all in one scene.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更大、更复杂的 UI 中，你可能将这一部分保存为其自己的场景，并将其嵌入 UI 的其他部分。然而，这个游戏只需要几个更多元素，所以将它们全部组合在一个场景中是完全可以的。
- en: As a child of `HUD`, add a `VBoxContainer`, and inside it, add a `Label` named
    `Message` and a `TextureButton` named `StartButton`. Set the layout of the `VBoxContainer`
    to `100`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为 `HUD` 的子节点，添加一个 `VBoxContainer`，并在其中添加一个名为 `Message` 的 `Label` 和一个名为 `StartButton`
    的 `TextureButton`。将 `VBoxContainer` 的布局设置为 `100`。
- en: In the `res://assets` folder, there are two textures for `StartButton`, one
    normal (`play_button.png`) and one to show when the mouse is hovering over it
    (`'play_button_h.png`). Drag these to **Textures/Normal** and **Textures/Hover**
    in the Inspector. Set the button’s **Layout/Container Sizing/Horizontal** to **Shrink
    Center** so that it will be centered horizontally.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res://assets`文件夹中，有两个`StartButton`的纹理，一个是正常的（`play_button.png`），另一个是在鼠标悬停时显示的（`'play_button_h.png'`）。将这些拖到检查器的**Textures/Normal**和**Textures/Hover**中。将按钮的**布局/容器大小/水平**设置为**收缩居中**，这样它就会在水平方向上居中。
- en: Set the `Message` text to “Space Rocks!” and set its font using the same settings
    as `ScoreLabel`. Set **Horizontal Alignment** to **Center**.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Message`文本设置为“Space Rocks!”，并使用与`ScoreLabel`相同的设置来设置其字体。将**水平对齐**设置为**居中**。
- en: 'When finished, your scene tree should look like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你的场景树应该看起来像这样：
- en: '![Figure 3.20: HUD node layout](img/B19289_03_20.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图3.20：HUD节点布局](img/B19289_03_20.jpg)'
- en: 'Figure 3.20: HUD node layout'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20：HUD节点布局
- en: Scripting the UI
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写UI脚本
- en: You’ve completed the UI layout, now add a script to `HUD`. Since the nodes you’ll
    need to reference are located under containers, you can store references to them
    in variables at the start. Since this needs to happen after nodes are added to
    the tree, you can use the `@onready` decorator to cause the variable’s value to
    be set at the same time as the `_ready()` function runs.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了UI布局，现在向`HUD`添加一个脚本。由于你将需要引用的节点位于容器下，你可以在开始时将这些节点的引用存储在变量中。由于这需要在节点添加到树之后发生，你可以使用`@onready`装饰器来使变量的值在`_ready()`函数运行时同时设置。
- en: '[PRE26]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You’ll emit the `start_game` signal when the player clicks the `StartButton`.
    The `lives_counter` variable is an array holding references to the three life-counter
    images so they can be hidden/shown as needed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家点击`StartButton`时，你会发出`start_game`信号。`lives_counter`变量是一个包含三个生命计数器图像引用的数组，这样它们就可以根据需要隐藏/显示。
- en: 'Next, you need functions to handle updating the displayed information:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要函数来处理更新显示信息：
- en: '[PRE27]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`Main` will call these functions whenever the relevant value changes. Now add
    a function to handle the end of the game:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`将在相关值更改时调用这些函数。现在添加一个处理游戏结束的函数：'
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Connect the `pressed` signal of `StartButton` and the `timeout` signal of `Timer`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将`StartButton`的`pressed`信号和`Timer`的`timeout`信号连接起来：
- en: '[PRE29]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The Main scene’s UI code
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主场景的UI代码
- en: 'Add an instance of the `HUD` scene to the `Main` scene. Add these variables
    to `main.gd`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 将`HUD`场景的一个实例添加到`Main`场景中。将这些变量添加到`main.gd`中：
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And a function to handle starting a new game:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个处理开始新游戏的函数：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note the `$Player.reset()` line – don’t worry, you’ll add that soon.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`$Player.reset()`这一行——别担心，你很快就会添加它。
- en: 'When the player destroys all the rocks, they’ll advance to the next level:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家摧毁所有岩石时，他们会进入下一级：
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You’ll call this function every time the level changes. It announces the level
    number and spawns a number of rocks to match. Note that since you initialized
    `level` to `0`, this will set it to `1` for the first level. You should also remove
    the code that’s spawning rocks in `_ready()` – you don’t need that anymore.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在每次关卡变化时调用这个函数。它宣布关卡编号，并生成与数量相匹配的岩石。注意，由于你初始化`level`为`0`，这会将它设置为`1`，用于第一个关卡。你还应该删除`_ready()`中生成岩石的代码——你不再需要它了。
- en: 'To detect when the level has ended, you need to check how many rocks are left:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测关卡何时结束，你需要检查还剩下多少岩石：
- en: '[PRE33]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, you need to connect the `HUD`’s `start_game` signal to the `new_game()`
    function of Main.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要将`HUD`的`start_game`信号连接到`Main`的`new_game()`函数。
- en: 'Select the `HUD` instance in `Main` and find its `start_game` signal in the
    `Main`, and you can select the `new_game()` function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`中选择`HUD`实例，并在`Main`中找到其`start_game`信号，然后你可以选择`new_game()`函数：
- en: '![Figure 3.21: Connecting a signal to an existing function](img/B19289_03_21.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图3.21：将信号连接到现有函数](img/B19289_03_21.jpg)'
- en: 'Figure 3.21: Connecting a signal to an existing function'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21：将信号连接到现有函数
- en: 'Add this function to handle what happens when the game ends:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这个函数来处理游戏结束时会发生什么：
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Player code
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家代码
- en: 'Add the new signals and a new variable to `player.gd`:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 向`player.gd`添加新的信号和新的变量：
- en: '[PRE35]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For the `lives` variable, you’ve added something called a `lives` changes, the
    `set_lives()` function will be called. This lets you automatically emit the signal
    as well as checking when it reaches `0`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`lives`变量，你添加了一个名为`lives`的变化，`set_lives()`函数将被调用。这让你可以自动发出信号，同时检查它何时达到`0`。
- en: 'The `reset()` function is called by `Main` when a new game starts:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当新游戏开始时，`Main`会调用`reset()`函数：
- en: '[PRE36]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Resetting the player means setting its position back to the center of the screen.
    As we saw before, that needs to be done in `_integrate_forces()` in order to work.
    Add this to that function:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 重置玩家意味着将其位置设置回屏幕中心。正如我们之前看到的，这需要在`_integrate_forces()`中完成。将此添加到该函数中：
- en: '[PRE37]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Back in the `Main` scene, select the `Player` instance and find its `lives_changed`
    signal in the `HUD` node and type `update_lives` in **Receiver Method**.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`Main`场景，选择`Player`实例，并在`HUD`节点中找到其`lives_changed`信号，然后在**接收方法**中输入`update_lives`。
- en: '![Figure 3.22: Connecting the player signal to HUD](img/B19289_03_22.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图3.22：将玩家信号连接到HUD](img/B19289_03_22.jpg)'
- en: 'Figure 3.22: Connecting the player signal to HUD'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22：将玩家信号连接到HUD
- en: 'In this section, you made a much more complex UI than in previous projects,
    including some new `Control` nodes such as `TextureProgressBar`, and used signals
    to connect everything together. In the next section, you’ll handle the end of
    the game: what should happen when the player dies.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你创建了一个比以前项目更复杂的UI，包括一些新的`Control`节点，如`TextureProgressBar`，并使用信号将所有内容连接在一起。在下一节中，你将处理游戏的结束：玩家死亡时应该发生什么。
- en: Ending the game
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束游戏
- en: In this section, you’ll make the player detect when it is hit by rocks, add
    an invulnerability feature, and end the game when the player runs out of lives.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将使玩家检测它被岩石击中，添加无敌功能，并在玩家生命耗尽时结束游戏。
- en: Add an instance of the `Explosion` scene to the `Player` scene and uncheck its
    `Timer` node named `InvulnerabilityTimer` and set `2` and **One Shot** to “on.”
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Explosion`场景的一个实例添加到`Player`场景中，取消选中其名为`InvulnerabilityTimer`的`Timer`节点，并将`2`和**单次**设置为“开启”。
- en: 'You’ll emit the `dead` signal to notify `Main` that the game should end. Before
    that, however, you need to update the state machine to do a little more with each
    state:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你将发出`dead`信号来通知`Main`游戏应该结束。在此之前，你需要更新状态机，以便对每个状态进行更多操作：
- en: '[PRE38]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `modulate.a` property of a sprite sets its alpha channel (transparency).
    Setting it to `0.5` makes it semi-transparent, while `1.0` is solid.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一个精灵的`modulate.a`属性设置其alpha通道（透明度）。将其设置为`0.5`使其半透明，而`1.0`则是实心的。
- en: 'After entering the `INVULNERABLE` state, you start the timer. Connect its `timeout`
    signal:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`INVULNERABLE`状态后，开始计时器。连接其`timeout`信号：
- en: '[PRE39]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Detecting collisions between rigid bodies
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测刚体之间的碰撞
- en: 'When you fly around, the ship bounces off rocks because both are rigid bodies.
    However, if you want to make something happen when two rigid bodies collide, you
    need to enable `Player` scene, select the `Player` node, and in the Inspector,
    set `1`. Now the player will emit a signal when it comes into contact with another
    body. Click on the `body_entered` signal:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当你飞来飞去时，飞船会从岩石上弹开，因为两者都是刚体。然而，如果你想当两个刚体碰撞时发生某些事情，你需要启用`Player`场景，选择`Player`节点，然后在检查器中将其设置为`1`。现在玩家在接触到另一个物体时会发出信号。点击`body_entered`信号：
- en: '[PRE40]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now go to the `Main` scene and connect the `Player` instance’s `dead` signal
    to the `game_over()` method. Play the game and try running into a rock. Your ship
    should explode, become invulnerable for two seconds, and lose one life. Also check
    that the game ends if you get hit three times.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到`Main`场景，将`Player`实例的`dead`信号连接到`game_over()`方法。玩游戏并尝试撞上岩石。你的飞船应该会爆炸，两秒内无敌，并失去一条生命。还要检查如果你被击中三次，游戏是否会结束。
- en: 'In this section, you learned about rigid body collisions and used them to handle
    the ship colliding with rocks. The full game cycle is now complete: the start
    screen leads to gameplay, which ends with a game over display. In the remaining
    sections of the chapter, you’ll add some additional features to the game, such
    as a pause function.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了刚体碰撞，并使用它们来处理船只与岩石碰撞的情况。现在整个游戏周期已经完成：起始屏幕引导到游戏玩法，最后以游戏结束显示结束。在章节的剩余部分，你将添加一些额外的游戏功能，例如暂停功能。
- en: Pausing the game
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停游戏
- en: 'Many games require some sort of pause mode to allow the player to take a break
    from the action. In Godot, pausing is a function of the `SceneTree` and can be
    set using its `paused` property. When the `SceneTree` is paused, three things
    happen:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏需要某种暂停模式，以便玩家可以从动作中休息。在Godot中，暂停是`SceneTree`的功能，可以通过其`paused`属性设置。当`SceneTree`暂停时，会发生三件事：
- en: The physics thread stops running
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理线程停止运行
- en: '`_process()` and `_physics_process()` are no longer called on any nodes'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_process()`和`_physics_process()`不再在任何节点上调用'
- en: The `_input()` and `_input_event()` methods are also not called for inputs
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_input()`和`_input_event()`方法也不会调用输入'
- en: When pause mode is triggered, every node in the running game reacts accordingly,
    based on how you’ve configured it. This behavior is set via the node’s **Process/Mode**
    property, which you’ll find near the bottom of the Inspector list.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当暂停模式被触发时，运行中的游戏中的每个节点都会根据您的配置做出相应的反应。这种行为是通过节点的**Process/Mode**属性设置的，您可以在检查器列表的底部找到它。
- en: 'The pause mode can be set to the following values:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停模式可以设置为以下值：
- en: '`Inherit` – The node uses the same mode as its parent'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`继承` – 节点使用与其父节点相同的模式'
- en: '`Pausable` – The node pauses when the scene tree is paused'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`可暂停` – 当场景树暂停时，节点会暂停'
- en: '`When Paused` – The node only runs when the tree is paused'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`当暂停时` – 节点仅在树暂停时运行'
- en: '`Always` – The node always runs, ignoring the tree’s paused state'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`始终` – 节点始终运行，忽略树的暂停状态'
- en: '`Disabled` – The node never runs, ignoring the tree’s paused state'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`禁用` – 节点永远不会运行，忽略树的暂停状态'
- en: Open the `pause`. Assign a key you’d like to use to toggle pause mode. `P` is
    a good choice.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`pause`。分配一个您想要用于切换暂停模式的键。`P`是一个不错的选择。
- en: 'Add the following function to `Main.gd`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下函数添加到`Main.gd`：
- en: '[PRE41]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This code detects pressing the key and toggles the tree’s `paused` state to
    the opposite of its current state. It also displays **Paused** on the screen so
    that it doesn’t just appear that the game has frozen.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码检测按键按下并切换树的`paused`状态为其当前状态的相反。它还在屏幕上显示**暂停**，这样就不会让人误以为游戏已经冻结。
- en: If you were to run the game now, you’d have a problem – all nodes are paused,
    including `Main`. That means it’s not processing `_input()` anymore, so it can’t
    detect the input again to unpause the game! To fix this, set `Main` node to **Always**.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行游戏，您会遇到问题——所有节点都处于暂停状态，包括`Main`。这意味着它不再处理`_input()`，因此无法再次检测输入来暂停游戏！为了解决这个问题，将`Main`节点设置为**始终**。
- en: The pause function is a very useful one to know about. You can use this technique
    in any game you make, so review it to make sure you understand how it works. You
    can even try going back and adding it to *Coin Dash*. Our next section adds to
    the action by adding enemies to the game.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停功能是一个非常有用的功能，您可以在您制作的任何游戏中使用此技术，因此请复习它以确保您理解它是如何工作的。您甚至可以尝试回到并添加到*Coin Dash*。我们下一节通过向游戏中添加敌人来增加动作。
- en: Enemies
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌人
- en: Space is filled with more dangers than just rocks. In this section, you’ll create
    an enemy spaceship that will periodically appear and shoot at the player.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 空间中不仅有岩石，还有更多的危险。在本节中，您将创建一个敌人飞船，它将定期出现并向玩家射击。
- en: Following a path
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 沿着路径行走
- en: When the enemy appears, it should follow a path across the screen. It’ll also
    look better if it’s not just a straight line. To keep it from looking too repetitive,
    you can create multiple paths and randomly choose one when the enemy appears.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当敌人出现时，它应该在屏幕上沿着路径行走。如果它不是一条直线，看起来会更好。为了防止它看起来过于重复，您可以创建多个路径，并在敌人出现时随机选择一个。
- en: 'Create a new scene and add a `Node`. Name it `EnemyPaths` and save it. To draw
    the path, add a `Path2D` node. As you saw earlier, this node allows you to draw
    a series of connected points. Selecting this node displays a new menu bar:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景并添加一个`Node`。将其命名为`EnemyPaths`并保存。要绘制路径，添加一个`Path2D`节点。如您之前所见，此节点允许您绘制一系列连接的点。选择此节点会显示一个新的菜单栏：
- en: '![Figure 3.23: Path drawing options](img/B19289_03_23.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图3.23：路径绘制选项](img/B19289_03_23.jpg)'
- en: 'Figure 3.23: Path drawing options'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23：路径绘制选项
- en: 'These buttons let you draw and modify the path’s points. Click the one with
    the green **+** symbol to add points. Click to start the path somewhere just outside
    the game window, and then click a few more points to make a curve. Note that the
    arrows indicate the direction of the path. Don’t worry about making it smooth
    yet:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这些按钮让您可以绘制和修改路径的点。点击带有绿色**+**符号的按钮来添加点。点击游戏窗口稍外的地方开始路径，然后点击几个点来绘制曲线。请注意，箭头指示路径的方向。现在不必担心让它变得平滑：
- en: '![Figure 3.24: An example path](img/B19289_03_24.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图3.24：一个示例路径](img/B19289_03_24.jpg)'
- en: 'Figure 3.24: An example path'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24：一个示例路径
- en: 'When the enemy follows the path, it will not look very smooth when it hits
    the sharp corners. To smooth the curve, click the second button in the path toolbar
    (its tooltip says **Select Control Points**). Now, if you click and drag any of
    the curve’s points, you will add a control point that allows you to curve the
    line at that point. Smoothing the line above results in something like this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当敌人沿着路径移动时，当它遇到尖锐的角落时，看起来不会非常平滑。为了平滑曲线，点击路径工具栏中的第二个按钮（其工具提示说 **选择控制点**）。现在，如果您点击并拖动曲线上的任何点，您将添加一个控制点，允许您在该点弯曲线条。平滑上面的线条会产生类似这样的效果：
- en: '![Figure 3.25: Using control points](img/B19289_03_25.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.25：使用控制点](img/B19289_03_25.jpg)'
- en: 'Figure 3.25: Using control points'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.25：使用控制点
- en: 'Add two or three more `Path2D` nodes to the scene and draw the paths however
    you like. Adding loops and curves rather than straight lines will make the enemy
    look more dynamic (and make it harder to hit). Remember that the first point you
    click will be the start of the path, so make sure to start them on different sides
    of the screen for variety. Here are three example paths:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 向场景中添加两个或三个更多的 `Path2D` 节点，并按照您喜欢的样式绘制路径。添加环和曲线而不是直线会使敌人看起来更加动态（并且更难被击中）。请记住，您点击的第一个点将是路径的起点，因此请确保在不同的屏幕边缘开始，以增加多样性。以下有三个示例路径：
- en: '![Figure 3.26: Adding multiple paths](img/B19289_03_26.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.26：添加多个路径](img/B19289_03_26.jpg)'
- en: 'Figure 3.26: Adding multiple paths'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.26：添加多个路径
- en: Save the scene. You’ll add this to the enemy’s scene to give it the paths it
    can follow.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 保存场景。您将将其添加到敌人的场景中，以便它能够跟随这些路径。
- en: Enemy scene
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敌人场景
- en: 'Create a new scene for the enemy, using an `Area2D` as its root node. Add a
    `Sprite2D` child and use `res://assets/enemy_saucer.png` as its `3` so that you
    can choose between the different colored saucers:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 为敌人创建一个新的场景，使用 `Area2D` 作为其根节点。添加一个 `Sprite2D` 子节点，并使用 `res://assets/enemy_saucer.png`
    作为其 `3`，这样您就可以在不同颜色的飞碟之间进行选择：
- en: As you’ve done before, add a `CollisionShape2D` and give it a `CircleShape2D`
    scaled to cover the image. Add an instance of the `EnemyPaths` scene and an `AnimationPlayer`.
    In the `AnimationPlayer`, you’ll add an animation to create a flash effect when
    the saucer is hit.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您之前所做的那样，添加一个 `CollisionShape2D` 并将其缩放为 `CircleShape2D` 以覆盖图像。添加一个 `EnemyPaths`
    场景实例和一个 `AnimationPlayer`。在 `AnimationPlayer` 中，您将添加一个动画，以便在飞碟被击中时产生闪光效果。
- en: Add an animation named `flash`. Set `0.25` and `0.01`. The property you’ll be
    animating is the `Sprite2D`’s `0.04` and change the `0.04` and change the color
    back to white.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `flash` 的动画。设置为 `0.25` 和 `0.01`。您将动画化的属性是 `Sprite2D` 的 `0.04` 并将颜色从 `0.04`
    改变回来，使其变回白色。
- en: Repeat this process two more times so that you have three flashes in total.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程两次，以便总共有三个闪光效果。
- en: Add an instance of the `Explosion` scene and hide it. Add a `Timer` node named
    `GunCooldown` to control how often the enemy will shoot. Set `1.5` and **Autostart**
    to on.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `Explosion` 场景实例并将其隐藏。添加一个名为 `GunCooldown` 的 `Timer` 节点来控制敌人射击的频率。设置为 `1.5`
    并将 **Autostart** 设置为开启。
- en: Add a script to the enemy and connect the timer’s `timeout`. Don’t add anything
    to the function yet.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向敌人添加一个脚本并连接计时器的 `timeout`。暂时不要向函数中添加任何内容。
- en: In the `enemies`. As with the rocks, this will give you a way to identify the
    object, even if there are multiple enemies on the screen at the same time.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `enemies` 中。与岩石一样，这将为您提供一种识别对象的方法，即使屏幕上同时有多个敌人。
- en: Moving the enemy
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动敌人
- en: 'To begin, you’ll write the code to select a path and move the enemy along it:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将编写代码来选择路径并将敌人沿着它移动：
- en: '[PRE42]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Recall that the `PathFollow2D` node automatically moves along a parent `Path2D`.
    By default, it loops around the path when it reaches the end, so you need to set
    that to `false` to disable it.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`PathFollow2D` 节点会自动沿着父 `Path2D` 移动。默认情况下，当它到达路径的末尾时，它会绕路径循环，因此您需要将其设置为
    `false` 以禁用它。
- en: 'The next step is to move along the path and remove the enemy when it reaches
    the end of the path:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是沿着路径移动并在敌人到达路径末尾时将其移除：
- en: '[PRE43]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can detect the end of the path when `progress` is greater than the total
    path length. However, it’s more straightforward to use `progress_ratio`, which
    varies from zero to one over the length of the path, so you don’t need to know
    how long each path is.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `progress` 大于路径总长度时，您可以检测路径的末尾。然而，使用 `progress_ratio` 更为直接，它在路径长度上从零变化到一，因此您不需要知道每个路径有多长。
- en: Spawning enemies
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敌人生成
- en: 'In the `Main` scene, add a new `Timer` node called `EnemyTimer`. Set its `main.gd`,
    add a variable to reference the enemy scene:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Main` 场景中，添加一个新的 `Timer` 节点，称为 `EnemyTimer`。设置其 `main.gd`，添加一个变量来引用敌人场景：
- en: '[PRE44]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add this line to `new_level()`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 将此行添加到 `new_level()` 中：
- en: '[PRE45]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Connect the `EnemyTimer`’s `timeout` signal:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 连接 `EnemyTimer` 的 `timeout` 信号：
- en: '[PRE46]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This code instances the enemy whenever `EnemyTimer` times out. You don’t want
    another enemy for a while, so the timer is restarted with a longer delay.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在 `EnemyTimer` 超时时实例化敌人。你一段时间内不想有另一个敌人，所以计时器会以更长的延迟重新启动。
- en: Play the game, and you should see a saucer appear and fly along its path.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 开始游戏，你应该会看到一个飞碟出现并沿着其路径飞行。
- en: Shooting and collisions
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 射击和碰撞
- en: The enemy needs to shoot at the player as well as react when hit by the player
    or the player’s bullets.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人需要向玩家射击，并且当被玩家或玩家的子弹击中时需要做出反应。
- en: The enemy’s bullet will be similar to the player’s, but we’ll use a different
    texture. You can create it again from scratch or use the following process to
    reuse the node setup.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人的子弹将与玩家的子弹相似，但我们将使用不同的纹理。你可以从头开始创建它，或者使用以下过程来重用节点设置。
- en: Open the `Bullet` scene and choose `enemy_bullet.tscn` (afterward, don’t forget
    to rename the root node as well). Remove the script by clicking the **Detach the
    script** button. Disconnect the signal connections by clicking the **Node** tab
    and choosing **Disconnect**. You can see which nodes have their signals connected
    by looking for the ![](img/B19289_03_27.png) icon next to the node name.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Bullet` 场景，选择 `enemy_bullet.tscn`（之后，别忘了将根节点重命名）。通过点击**分离脚本**按钮移除脚本。通过点击**节点**选项卡并选择**断开连接**来断开信号连接。你可以通过查找节点名称旁边的
    ![](img/B19289_03_27.png) 图标来查看哪些节点有信号连接。
- en: Replace the sprite’s texture with the `laser_green.png` image, and add a new
    script to the root node.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 将精灵的纹理替换为 `laser_green.png` 图像，并在根节点上添加一个新的脚本。
- en: 'The script for the enemy bullet will be very similar to the regular bullet.
    Connect the area’s `body_entered` signal and the `screen_exited` signal of `VisibleOnScreenNotifier2D`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人子弹的脚本将与普通子弹非常相似。连接区域的 `body_entered` 信号和 `VisibleOnScreenNotifier2D` 的 `screen_exited`
    信号：
- en: '[PRE47]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that you’ll need to specify a position and direction for the bullet. That’s
    because, unlike the player, who always shoots forward, the enemy will always shoot
    toward the player.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要指定子弹的位置和方向。这是因为，与总是向前射击的玩家不同，敌人总是朝向玩家射击。
- en: For now, the bullet won’t do any damage to the player. You’ll be adding a shield
    to the player in the next section, so you can add it at that time.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，子弹对玩家不会造成任何伤害。你将在下一节中为玩家添加护盾，所以你可以那时添加它。
- en: Save the scene and drag it into the `Enemy`.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 保存场景并将其拖入 `Enemy`。
- en: 'In `enemy.gd`, add a variable for some random variation to the bullet, and
    the `shoot()` function:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `enemy.gd` 中，添加一个变量以对子弹进行一些随机变化，并添加 `shoot()` 函数：
- en: '[PRE48]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: First, you find the vector pointing to the player’s position, then add a little
    bit of randomness so that it can “miss.”
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，找到指向玩家位置的向量，然后添加一点随机性，使其可以“错过”。
- en: 'Call the `shoot()` function whenever `GunCooldown` times out:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `GunCooldown` 超时时调用 `shoot()` 函数：
- en: '[PRE49]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For an extra challenge, you can make the enemy shoot in pulses or multiple
    rapid shots:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加难度，你可以让敌人以脉冲或多次快速射击的方式射击：
- en: '[PRE50]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This will shoot a given number of bullets, `n`, with `delay` seconds between
    them. You can call this instead when the cooldown triggers:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发射一定数量的子弹，`n`，子弹之间有 `delay` 秒的延迟。当冷却时间触发时，你可以调用此方法：
- en: '[PRE51]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will shoot a pulse of `3` bullets with `0.15` seconds between them. Tough
    to dodge!
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发射一串 `3` 发子弹，子弹之间间隔 `0.15` 秒。很难躲避！
- en: Next, the enemy needs to take damage when it’s hit by a shot from the player.
    It will flash using the animation you made and then explode when its health reaches
    `0`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当敌人被玩家射击时，它需要受到伤害。它将使用你制作的动画闪烁，并在其健康值达到 `0` 时爆炸。
- en: 'Add these functions to `enemy.gd`:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下函数添加到 `enemy.gd` 中：
- en: '[PRE52]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Also, connect the enemy’s `body_entered` signal so that the enemy will explode
    if the player runs into it:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，连接敌人的 `body_entered` 信号，以便当玩家撞到敌人时，敌人会爆炸：
- en: '[PRE53]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Again, you’re waiting for the player shield to be implemented before doing damage
    to the player, so for now, this collision only destroys the enemy.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你需要在玩家护盾实现之前对玩家造成伤害，所以现在这个碰撞只会摧毁敌人。
- en: 'Currently, the player’s bullet is only detecting rocks because its `body_entered`
    signal isn’t triggered by the enemy, which is an `Area2D`. To detect the enemy,
    go to the `Bullet` scene and connect the `area_entered` signal:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，玩家的子弹只能检测到岩石，因为它的 `body_entered` 信号不会被敌人触发，而敌人是一个 `Area2D`。为了检测敌人，请转到 `Bullet`
    场景并连接 `area_entered` 信号：
- en: '[PRE54]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Try playing the game again and you’ll be doing battle with an aggressive alien
    opponent! Verify that all the collision combinations are being handled (except
    for the enemy shooting the player). Also note that the enemy’s bullets can be
    blocked by rocks – maybe you can hide behind them for cover!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试再次玩游戏，你将与一个侵略性的外星对手战斗！验证所有碰撞组合是否被处理（除了敌人射击玩家）。还请注意，敌人的子弹可以被岩石阻挡——也许你可以躲在它们后面作为掩护！
- en: 'Now that the game has enemies, it’s a lot more challenging. If you still find
    it too easy, try increasing the enemy’s properties: how often it appears, how
    much damage it does, and how many shots it takes to destroy it. It’s OK if you
    make it too hard because, in the next section, you’ll give the player a little
    help by adding a shield to absorb damage.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏有了敌人，它变得更加具有挑战性。如果你仍然觉得太简单，尝试增加敌人的属性：它出现的频率、它造成的伤害以及摧毁它所需的射击次数。如果你让它变得太难是完全可以的，因为在下一节中，你将通过添加一个吸收伤害的护盾来为玩家提供一些帮助。
- en: Player shield
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家护盾
- en: In this section, you’ll add a shield to the player and a display element to
    the `HUD` showing the current shield level.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将为玩家添加一个护盾，并在 `HUD` 中添加一个显示当前护盾级别的显示元素。
- en: 'First, add the following to the top of the `player.gd` script:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将以下内容添加到 `player.gd` 脚本的顶部：
- en: '[PRE55]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `shield` variable works similarly to `lives`, emitting a signal whenever
    it changes. Since the value will be added to by the shield’s regeneration, you
    need to make sure it doesn’t go above the `max_shield` value. Then, when you emit
    the `shield_changed` signal, you pass the ratio of `shield` / `max_shield` rather
    than the actual value. This way, the `HUD`’s display doesn’t need to know anything
    about how big the shield actually is, just its percentage.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`shield` 变量与 `lives` 类似，每当它发生变化时都会发出信号。由于值将由护盾的再生添加，你需要确保它不会超过 `max_shield`
    值。然后，当你发出 `shield_changed` 信号时，你传递 `shield` / `max_shield` 的比率而不是实际值。这样，`HUD`
    的显示就不需要知道护盾实际有多大，只需要知道它的百分比。'
- en: You should also remove the `explode()` line from `_on_body_entered()`, since
    you now don’t want just hitting a rock to blow up the ship – that will now only
    happen when the shield runs out.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该从 `_on_body_entered()` 中移除 `explode()` 行，因为你现在不希望仅仅击中岩石就会炸毁飞船——现在这只会发生在护盾耗尽时。
- en: 'Hitting a rock will damage the shield, and bigger rocks should do more damage:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 击中岩石会损坏护盾，较大的岩石应该造成更多的伤害：
- en: '[PRE56]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The enemy’s bullets should also do damage, so make this change to `enemy_bullet.gd`:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人的子弹也应该造成伤害，所以将此更改应用到 `enemy_bullet.gd`：
- en: '[PRE57]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Also, running into the enemy should damage the player, so update this in `enemy.gd`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，撞到敌人应该伤害玩家，所以更新 `enemy.gd` 中的此内容：
- en: '[PRE58]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If the player’s shield runs out and they lose a life, you should reset the
    shield to its maximum. Add this line to `set_lives()`:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家的护盾耗尽并且他们失去了一条生命，你应该将护盾重置为其最大值。将此行添加到 `set_lives()`：
- en: '[PRE59]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The last addition to the player script is to regenerate the shield each frame.
    Add this line to `_process()` in `player.gd`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家脚本中的最后一个添加是每帧再生护盾。将此行添加到 `player.gd` 中的 `_process()`：
- en: '[PRE60]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now that the code is complete, you need to add a new display element to the
    `HUD` scene. Rather than display the shield’s value as a number, you’ll make a
    `TextureProgressBar` is a `Control` node that displays a given value as a filled
    bar. It also allows you to assign a texture to be used for the bar.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码已经完成，你需要在 `HUD` 场景中添加一个新的显示元素。与其将护盾的值显示为数字，你将创建一个 `TextureProgressBar`，这是一个
    `Control` 节点，它将给定的值显示为一个填充的条形。它还允许你为条形分配一个要使用的纹理。
- en: 'Go to the `HUD` scene and add two new nodes as children of the existing `HBoxContainer`:
    `TextureRect` and `TextureProgressBar`. Rename `TextureProgressBar` to `ShieldBar`.
    Place them after the `Score` label and before `LivesCounter`. Your node setup
    should look like this:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 转到 `HUD` 场景，并将两个新节点作为现有 `HBoxContainer` 的子节点添加：`TextureRect` 和 `TextureProgressBar`。将
    `TextureProgressBar` 重命名为 `ShieldBar`。将它们放置在 `Score` 标签之后和 `LivesCounter` 之前。你的节点设置应该看起来像这样：
- en: '![Figure 3.27: Updated HUD node layout](img/B19289_03_28.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.27：更新后的 HUD 节点布局](img/B19289_03_28.jpg)'
- en: 'Figure 3.27: Updated HUD node layout'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.27：更新后的 HUD 节点布局
- en: Drag `res://assets/shield_gold.png` into the `TextureRect`. This will be an
    icon indicating that this bar shows the shield value. Change **Stretch Mode**
    to **Keep Centered** so that the texture won’t be distorted.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `res://assets/shield_gold.png` 拖入 `TextureRect`。这将是一个图标，表示这个条形图显示护盾值。将 **拉伸模式**
    设置为 **居中**，这样纹理就不会扭曲。
- en: The `ShieldBar` has three `res://assets/bar_green_200.png` into this property.
    The other two texture properties let you customize the appearance by setting an
    image to be drawn above or below the progress texture. Drag `res://assets/bar_glass_200.png`
    into the **Over** property.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShieldBar` 有三个 `res://assets/bar_green_200.png` 放入这个属性。其他两个纹理属性允许你通过设置一个图像来绘制在进度纹理之上或之下来自定义外观。将
    `res://assets/bar_glass_200.png` 拖入 **Over** 属性。'
- en: In the `0` and `1`, as this bar will show the ratio of the shield to its maximum,
    not its numerical value. This means `0.01`. `.75` to see the bar partly filled.
    Also, in the **Layout/Container Sizing** section, check the **Expand** box and
    set **Vertical** to **Shrink Center**.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `0` 和 `1` 中，因为这个条形图将显示护盾与其最大值的比率，而不是其数值。这意味着 `0.01` 到 `.75` 以看到条形图部分填充。此外，在
    **布局/容器大小** 部分，勾选 **扩展** 复选框并将 **垂直** 设置为 **收缩居中**。
- en: 'The `HUD` should look like this when you’re done:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，`HUD` 应该看起来像这样：
- en: '![Figure 3.28: Updated HUD with shield bar](img/B19289_03_29.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.28：更新后的带有护盾栏的 HUD](img/B19289_03_29.jpg)'
- en: 'Figure 3.28: Updated HUD with shield bar'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.28：更新后的带有护盾栏的 HUD
- en: 'You can now update the script to set the value of the shield bar, as well as
    to make it change color as it gets closer to zero. Add these variables to `hud.gd`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以更新脚本以设置护盾栏的值，以及使其在接近零时改变颜色。将这些变量添加到 `hud.gd` 中：
- en: '[PRE61]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In addition to the green bar, you also have red and yellow bars in the `assets`
    folder. This allows you to change the shield bar’s color as the value decreases.
    Loading the textures in this way makes them easier to access later in the script
    when you want to assign the appropriate image to the bar:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 除了绿色条形图，`assets` 文件夹中还有红色和黄色条形图。这允许你在值降低时更改护盾栏的颜色。以这种方式加载纹理使得在脚本中稍后更容易访问，当你想要为条形图分配适当的图像时：
- en: '[PRE62]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Finally, click on the `Main` scene’s `Player` node and connect the `shield_changed`
    signal to the `HUD`’s `update_shield()` function.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击 `Main` 场景的 `Player` 节点，并将 `shield_changed` 信号连接到 `HUD` 的 `update_shield()`
    函数。
- en: Run the game and verify that the shield is working. You may want to increase
    or decrease the shield regeneration rate to give it a speed you’re happy with.
    When you’re ready to move on, in the next section, you’ll add some sound to the
    game.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并验证护盾是否正常工作。你可能想要增加或减少护盾再生速率以获得你满意的速度。当你准备好继续时，在下一节中，你将为游戏添加一些声音。
- en: Sound and visual effects
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音和视觉效果
- en: The structure and gameplay of the game is complete. In this section, you’ll
    add some additional effects to the game to improve the game experience.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的结构和玩法已经完成。在本节中，你将添加一些额外的效果来提升游戏体验。
- en: Sound and music
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声音和音乐
- en: 'In the `res://assets/sounds` folder are several audio effects for the game.
    To play a sound, it needs to be loaded by an `AudioStreamPlayer` node. Add two
    of these nodes to the `Player` scene, naming them `LaserSound` and `EngineSound`.
    Drag the respective sound files into each node’s `shoot()` in `player.gd`:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `res://assets/sounds` 文件夹中包含了一些游戏音频效果。要播放声音，需要通过 `AudioStreamPlayer` 节点加载。将两个这样的节点添加到
    `Player` 场景中，分别命名为 `LaserSound` 和 `EngineSound`。将相应的声音文件拖入每个节点的 `player.gd` 中的
    `shoot()`：
- en: '[PRE63]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Play the game and try shooting. If you find the sound too loud, you can adjust
    the `-10` to start.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 播放游戏并尝试射击。如果你觉得声音太大，可以将 `-10` 调整一下。
- en: 'The engine sounds works a little differently. It needs to play when the thrust
    is on, but if you just try to call `play()` on the sound in the `get_input()`
    function when the player presses the key, it will restart the sound every frame.
    This doesn’t sound good, so you only want to start playing the sound if it isn’t
    already playing. Here is the relevant section of the `get_input()` function:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎声音的工作方式略有不同。它需要在推力开启时播放，但如果你只是尝试在玩家按下键时在 `get_input()` 函数中对声音调用 `play()`，它将每帧重新启动声音。这听起来不太好，所以你只想在声音尚未播放时开始播放声音。以下是
    `get_input()` 函数的相关部分：
- en: '[PRE64]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Note that a problem can occur: if the player dies while holding down the thrust
    key, the engine sound will remain stuck playing because, in the `$EngineSound.stop()`
    to the `change_state()`.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可能会出现一个问题：如果玩家在按下推力键时死亡，由于在 `$EngineSound.stop()` 到 `change_state()` 中，引擎声音将卡在播放状态。
- en: 'In the `Main` scene, add three more `AudioStreamPlayer` nodes: `ExplosionSound`,
    `LevelupSound`, and `Music`. In their `explosion.wav`, `levelup.ogg`, and `Funky-Gameplay_Looping.ogg`.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`场景中，添加三个更多的`AudioStreamPlayer`节点：`ExplosionSound`、`LevelupSound`和`Music`。在它们的`explosion.wav`、`levelup.ogg`和`Funky-Gameplay_Looping.ogg`中。
- en: Add `$ExplosionSound.play()` as the first line of `_on_rock_exploded()`, and
    add `$LevelupSound.play()` to `new_level()`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 将`$ExplosionSound.play()`作为`_on_rock_exploded()`的第一行，并将`$LevelupSound.play()`添加到`new_level()`。
- en: To start and stop the background music, add `$Music.play()` to `new_game()`
    and `$Music.stop()` to `game_over()`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始和停止背景音乐，将`$Music.play()`添加到`new_game()`，将`$Music.stop()`添加到`game_over()`。
- en: The enemy also needs `ExplosionSound` and `ShootSound` nodes. You can use `enemy_laser.wav`
    for their shooting sound.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人也需要`ExplosionSound`和`ShootSound`节点。你可以使用`enemy_laser.wav`作为它们的射击声音。
- en: Particles
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 粒子
- en: The player ship’s thrust is a perfect use of particle effects, creating a streaming
    flame from the engine.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家飞船的推力是粒子效果的一个完美应用，它从引擎处产生一条流火。
- en: Add a `CPUParticles2D` node and name it `Exhaust`. You might want to zoom in
    on the ship while you’re doing this part.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`CPUParticles2D`节点，并将其命名为`Exhaust`。你可能想在执行这部分操作时放大飞船。
- en: Particle node types
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子节点类型
- en: 'Godot offers two types of particle nodes: one that uses the CPU and one that
    uses the GPU for rendering. Since not all platforms, especially mobile or older
    desktops, support hardware acceleration for particles, you can use the CPU version
    for wider compatibility. If you know your game will be running on more powerful
    systems, you can use the GPU version.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: Godot提供了两种类型的粒子节点：一种使用CPU进行渲染，另一种使用GPU进行渲染。由于并非所有平台，尤其是移动或较旧的桌面，都支持粒子的硬件加速，因此你可以使用CPU版本以实现更广泛的兼容性。如果你知道你的游戏将在更强大的系统上运行，你可以使用GPU版本。
- en: You’ll see a line of white dots streaming down from the center of the ship.
    Your challenge now is to turn those dots into an exhaust flame.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到从飞船中心流下的一行白色点。你的挑战现在是将这些点变成尾气火焰。
- en: There are a very large number of properties to choose from when configuring
    particles. As you go through the process of setting up this effect, feel free
    to experiment with them to see how they affect the result.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 配置粒子时，有非常多的属性可供选择。在设置此效果的过程中，请随意尝试它们，看看它们如何影响结果。
- en: 'Set these properties of the `Exhaust` node:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`Exhaust`节点的这些属性：
- en: '`25`'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`25`'
- en: '**Drawing/Local** **Coords**: On'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绘图/局部坐标**：开启'
- en: '`(-``28, 0)`'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(-28, 0)`'
- en: '`180`'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`180`'
- en: '**Visibility/Show Behind** **Parent**: On'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可见性/显示在父级之后**：开启'
- en: The remaining properties you’ll change will affect the behavior of the particles.
    Start with `(1, 5)`. The particles are now emitted over a small area instead of
    a single point.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要更改的剩余属性将影响粒子的行为。从`(1, 5)`开始。现在粒子是在一个小区域内发射，而不是从单个点发射。
- en: Next, set `0` and `(0, 0)`. Note that the particles are not falling or spreading
    out, although they are moving very slowly.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置`0`和`(0, 0)`。注意，虽然粒子移动非常缓慢，但它们并没有下落或扩散。
- en: Set `400`, then scroll down to `8`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`400`，然后向下滚动到`8`。
- en: 'To make the size change over time, you can set **Scale Amount Curve**. Select
    **New Curve** and then click to open it. In the small graph that shows, right-click
    to add two points – one on the left and one on the right. Drag the right-hand
    dot down until the curve looks like this:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 要使大小随时间变化，你可以设置**缩放量曲线**。选择**新建曲线**然后点击打开它。在小图中，右键点击添加两个点——一个在左侧，一个在右侧。将右侧的点向下拖动，直到曲线看起来像这样：
- en: '![Figure 3.29: Adding a particle scale curve](img/B19289_03_30.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![图3.29：添加粒子缩放曲线](img/B19289_03_30.jpg)'
- en: 'Figure 3.29: Adding a particle scale curve'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.29：添加粒子缩放曲线
- en: You should now see the particles shrinking as they stream out from the back
    of the ship.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能看到粒子从飞船后方流出时逐渐缩小。
- en: 'The last section to adjust is **Color**. To make the particles appear like
    a flame, they should start out bright orange-yellow and shift to red as they fade
    out. In the **Color Ramp** property, click on **New Gradient**, and you’ll see
    a gradient editor that looks like this:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要调整的部分是**颜色**。为了让粒子看起来像火焰，它们应该从明亮的橙黄色开始，随着淡出而变为红色。在**颜色渐变**属性中，点击**新建渐变**，你会看到一个看起来像这样的渐变编辑器：
- en: '![Figure 3.30: Color Ramp settings](img/B19289_03_31.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![图3.30：颜色渐变设置](img/B19289_03_31.jpg)'
- en: 'Figure 3.30: Color Ramp settings'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.30：颜色渐变设置
- en: The two rectangular sliders labeled *1* and *2* set the starting and ending
    colors of the gradient. Clicking on either of them will show its color in the
    box labeled *3*. Select slider *1* and then click box *3* to open a color picker.
    Choose an orange color, and then do the same for slider *2*, choosing a dark red.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 标有 *1* 和 *2* 的两个矩形滑块设置渐变的起始和结束颜色。点击任何一个都会在标有 *3* 的框中显示其颜色。选择滑块 *1* 然后点击框 *3*
    以打开颜色选择器。选择橙色，然后对滑块 *2* 做同样的操作，选择深红色。
- en: Now that the particles have the correct appearance, they’re lasting far too
    long. In the node’s `0.1`.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在粒子有了正确的外观，但它们持续的时间太长了。在节点的 `0.1`。
- en: Hopefully, your ship’s exhaust looks somewhat like a flame. If it doesn’t, feel
    free to adjust the properties until you are happy with how it looks.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您的飞船尾气看起来有点像火焰。如果不像，请随意调整属性，直到您对其外观满意为止。
- en: Once the flame is looking good, it needs to be turned on and off based on the
    player’s input. Go to `player.gd` and add `$Exhaust.emitting = false` at the beginning
    of `get_input()`. Then, under the `if` statement that checks for `thrust` input,
    add `$Exhaust.emitting =` `true`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦火焰看起来不错，就需要根据玩家的输入来开启和关闭。转到 `player.gd` 并在 `get_input()` 的开头添加 `$Exhaust.emitting
    = false`。然后，在检查 `thrust` 输入的 `if` 语句下，添加 `$Exhaust.emitting = true`。
- en: Enemy trail
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敌人轨迹
- en: 'You can also use particles to give the enemy saucer a sparkling trail. Add
    a `CPUParticles2D` to the enemy scene and configure these settings:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用粒子来为敌人的飞碟添加一条闪耀的轨迹。将一个 `CPUParticles2D` 添加到敌人场景中，并配置以下设置：
- en: '`20`'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`20`'
- en: '**Visibility/Show Behind** **Parent**: On'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可见性/显示背后** **父级**: 开启'
- en: '`Sphere`'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sphere`'
- en: '`25`'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`25`'
- en: '`(``0, 0)`'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(``0, 0)`'
- en: You should now have particles appearing all across the radius of the saucer
    (you can hide the `Sprite2D` during this part if you want to see them better).
    The default shape for particles is a square, but you can also use a texture for
    even more visual appeal. Add `res://assets/corona.png` to **Drawing/Texture**.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该在整个飞碟半径上看到粒子出现（如果您想更好地看到它们，可以在这一部分隐藏 `Sprite2D`）。粒子的默认形状是正方形，但您也可以使用纹理来获得更多的视觉吸引力。将
    `res://assets/corona.png` 添加到 **绘图/纹理**。
- en: This image gives a nice glowing effect, but it’s quite large compared to the
    saucer, so set `0.1`. You’ll also notice that this image is white on a black background.
    In order to look correct, it needs its **blend mode** changed. To do this, find
    the **Material** property and select **New CanvasItemMaterial**. There, you can
    change **Blend Mode** from **Mix** to **Add**.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片提供了一个很好的发光效果，但与飞碟相比，它相当大，所以设置为 `0.1`。您还会注意到这张图片在黑色背景上是白色的。为了看起来正确，需要更改其
    **混合模式**。为此，找到 **材质** 属性并选择 **新建 CanvasItemMaterial**。在那里，您可以将 **混合模式** 从 **混合**
    更改为 **添加**。
- en: Finally, you can make the particles fade away by using **Scale Amount Curve**
    in the **Scale** section, just as you did with the player particles.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过在 **缩放** 部分的 **缩放量曲线** 中使用，使粒子逐渐消失，就像您对玩家粒子所做的那样。
- en: Play your game and admire the effects. What else could you add with particles?
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 播放您的游戏并欣赏效果。您还能用粒子添加些什么？
- en: Summary
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to work with `RigidBody2D` nodes and learned
    more about how Godot’s physics works. You also implemented a basic finite state
    machine – something you’ll find useful as your projects grow larger and that you’ll
    use again in future chapters. You saw how `Container` nodes help organize and
    keep UI nodes aligned. Finally, you added sound effects and got your first taste
    of advanced visual effects by using the `Animation` and `CPUParticles2D` nodes.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何与 `RigidBody2D` 节点一起工作，并更深入地了解了 Godot 物理的工作原理。您还实现了一个基本的有限状态机——随着您的项目变得更大，您会发现这很有用，您将在未来的章节中再次使用它。您看到了
    `Container` 节点如何帮助组织和保持 UI 节点对齐。最后，您添加了音效，并通过使用 `Animation` 和 `CPUParticles2D`
    节点，第一次尝到了高级视觉效果的滋味。
- en: You also continued to create game objects using standard Godot hierarchies,
    such as `CollisionShapes` attached to `CollisionObjects` and signals being used
    to handle communication between nodes. At this point, these practices should be
    starting to look familiar to you.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 您还继续使用标准的 Godot 层次结构创建游戏对象，例如将 `CollisionShapes` 附着到 `CollisionObjects` 上，以及使用信号来处理节点间的通信。到目前为止，这些做法应该开始对您熟悉了。
- en: Are you prepared to try and remake this project on your own? Try repeating all,
    or even part, of this chapter without looking at the book. It’s a good way to
    check what information you absorbed and what you need to review again. You can
    also try remaking it with your own variations rather than making an exact copy.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好尝试独立重做这个项目了吗？尝试在不看书的条件下，重复所有，甚至部分，本章内容。这是一个检查你吸收了哪些信息以及需要再次复习哪些内容的不错方法。你也可以尝试加入自己的变体来重做，而不仅仅是做一个精确的复制。
- en: 'When you’re ready to move on, in the next chapter, you’ll make another style
    of game that’s very popular: a platformer in the tradition of Super Mario Bros.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好继续前进，在下一章中，你将制作另一种非常流行的游戏风格：一款遵循超级马里奥兄弟传统的平台游戏。
