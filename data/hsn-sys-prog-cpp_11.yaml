- en: Time Interfaces in Unix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix中的时间接口
- en: In this chapter, the reader will learn how to program the POSIX and C++ time
    interfaces using C++17\. To start, this chapter will cover the UNIX epoch and
    POSIX `time.h` APIs and how to use them. Next, the C++ Chrono APIs will be briefly
    explained, how they relate to `time.h`, and some examples will also be provided.
    Finally, this chapter will conclude with two simple examples of how to use the
    time interfaces. The first example will demonstrate how to read the system clock
    and output the results to the console on an interval, and the second example will
    demonstrate how to benchmark software using the C++ high-resolution timer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者将学习如何使用C++17编程POSIX和C++时间接口。首先，本章将介绍UNIX纪元和POSIX `time.h` API以及如何使用它们。接下来，将简要解释C++
    Chrono API，它们与`time.h`的关系，并提供一些示例。最后，本章将以两个简单的示例结束，演示如何使用时间接口。第一个示例将演示如何读取系统时钟并在间隔上将结果输出到控制台，第二个示例将演示如何使用C++高分辨率计时器对软件进行基准测试。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Learning about POSIX `time.h` APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习POSIX `time.h` API
- en: The C++ Chrono APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ Chrono API
- en: Understanding the read system clock with an example
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过示例了解读取系统时钟
- en: An example involving a high-resolution timer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涉及高分辨率计时器的示例
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to compile and execute the examples in this chapter, the reader must
    have the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译和执行本章中的示例，读者必须具备以下条件：
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够编译和执行C++17的基于Linux的系统（例如，Ubuntu 17.10+）
- en: GCC 7+
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 7+
- en: CMake 3.6+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.6+
- en: An internet connection
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: To download all of the code in this chapter, including the examples and code
    snippets, please see the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter11).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载本章中的所有代码，包括示例和代码片段，请访问以下链接：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter11)。
- en: Learning about POSIX time.h APIs
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习POSIX `time.h` API
- en: We will begin this chapter by discussing POSIX `time.h` APIs, which provide
    APIs for reading various clocks and performing calculations on these clock times.
    Although these APIs are specific to standard C, as will be demonstrated in the
    following section, the C time interfaces are still needed when working with C++,
    a problem that is being addressed in C++20.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论POSIX `time.h` API开始，该API提供了用于读取各种时钟并对这些时钟时间进行计算的API。尽管这些API特定于标准C，但如下一节所示，当使用C++时仍然需要C时间接口，这是C++20正在解决的问题。
- en: Learning about the types of APIs
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习有关API类型
- en: 'The UNIX epoch defines the number of seconds from January 1, 1970\. Interfaces
    described in this chapter leverage the UNIX epoch to define the notion of time.
    The POSIX `time.h` APIs, for the purpose of this chapter, define three different,
    opaque types:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX纪元定义了从1970年1月1日起的秒数。本章描述的接口利用UNIX纪元来定义时间的概念。本章中描述的POSIX `time.h` API定义了三种不同的不透明类型：
- en: '`tm`: An opaque structure that holds a date and time.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tm`：一个不透明的结构，保存日期和时间。'
- en: '`time_t`: A `typedef` that stores a time that is typically implemented using
    an integer that stores the number of seconds from the UNIX epoch.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time_t`：一个`typedef`，通常使用存储从UNIX纪元起的秒数的整数来实现。'
- en: '`clock_t`: A `typedef` that stores the amount of processor time the application
    has executed.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clock_t`：一个`typedef`，用于存储应用程序执行的处理器时间量。'
- en: 'These APIs provide various functions for creating these types and manipulating
    them. It should be noted that there are different types of clocks:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API提供了各种函数来创建这些类型并对其进行操作。应该注意，有不同类型的时钟：
- en: '**System clock**: The system clock reads the clock that the operating system
    is maintaining and stores the date and time that is presented to the user (for
    example, the clock that is shown on the taskbar). This clock can be changed at
    any point in time, so using it for timing in an application is usually discouraged
    as the clock being used might move back/forward in time in unexpected ways.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统时钟**：系统时钟读取操作系统维护的时钟，并存储向用户呈现的日期和时间（例如，任务栏上显示的时钟）。这个时钟可以在任何时间改变，因此通常不建议在应用程序中使用它进行计时，因为所使用的时钟可能以意想不到的方式向后/向前移动。'
- en: '**Steady clock**: A steady clock is a clock that ticks as the program executes.
    The more the program executes, the larger this clock grows. It should be noted
    that this clock will not match the results of the system clock and typically,
    only the difference between two of these clocks has any real value.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定时钟**：稳定时钟是程序执行时会滴答作响的时钟。程序执行得越多，这个时钟就会变得越大。应该注意，这个时钟不会与系统时钟的结果匹配，通常只有两个这些时钟之间的差异才有真正的价值。'
- en: '**High-resolution clock**: This is the same as a steady clock, with the exception
    that the result being returned has a much higher resolution. These types of clocks
    are often used for benchmarking.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高分辨率时钟**：这与稳定时钟相同，唯一的区别是返回的结果具有更高的分辨率。这些类型的时钟通常用于基准测试。'
- en: The time() API
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`time()` API'
- en: 'The `time()` API returns the current system clock and takes on the following
    form:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`time()` API返回当前系统时钟，并采用以下形式：'
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can either provide the `time()` function with a previously-defined `time_t
    variable`, or it will return one for you (if you pass `nullptr` as the argument),
    as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用预先定义的`time_t`变量提供`time()`函数，或者它将为您返回一个（如果您将`nullptr`作为参数传递），如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, we create a variable, called `t`, using the `time()`
    API to get the current number of seconds from the UNIX epoch. We then output this
    value to `stdout`. It should be noted that the `time_t` typedef is usually implemented
    using an integer value, which is why we can output its value directly to `stdout`,
    as shown in the preceding example.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用`time()` API创建一个名为`t`的变量，以获取从UNIX纪元开始的当前秒数。然后将这个值输出到`stdout`。应该注意，`time_t`
    typedef通常使用整数值实现，这就是为什么我们可以直接将其值输出到`stdout`的原因，就像前面的例子中所示的那样。
- en: 'As stated, you can also provide `time()` with your own, previously-defined,
    variable, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，也可以像下面这样使用`time()`提供自己之前定义的变量：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding example is identical to the first example, but instead of storing
    the return value of `time()`, we pass in our `time_t` variable as an argument
    to the function. Although this syntax is supported, the former is preferred. `time()`
    will return `-1` in the event of an error, which can be checked and handled as
    needed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子与第一个例子相同，但是不是存储`time()`的返回值，而是将我们的`time_t`变量作为参数传递给函数。虽然这种语法是支持的，但前者更受青睐。`time()`在出现错误时会返回`-1`，可以根据需要进行检查和处理。
- en: The ctime() typedef
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ctime()` typedef'
- en: 'The `time_t` typedef is implementation-specific, and although it is typically
    implemented using an integer that stores the number of seconds from the Unix epoch,
    this is not guaranteed to be the case, meaning the preceding examples would likely
    not compile. Instead, to output the value of a `time_t` variable in a supported
    fashion, use the `ctime()` API, which takes on the following form:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`time_t` typedef是特定于实现的，尽管它通常使用存储从Unix纪元开始的秒数的整数实现，但不能保证这种情况，这意味着前面的例子可能不会编译。相反，要以支持的方式输出`time_t`变量的值，使用`ctime()`
    API，形式如下：'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `ctime()` API takes a pointer to a `time_t` variable and outputs a standard
    C character string. The memory that backs the string that is returned is maintained
    by the `time.h` API (and therefore does not need to be freed) and, as a result,
    is not thread-safe. This API may be used as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctime()` API接受一个指向`time_t`变量的指针，并输出一个标准的C字符串。返回的字符串所使用的内存由`time.h` API维护（因此不需要被释放），因此不是线程安全的。可以如下使用这个API：'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As can be seen from the preceding example, instead of the number of seconds
    from the Unix epoch being returned, a human-readable version of the current time
    and date is returned. It should also be noted that, in addition to the `ctime()`
    function not being thread-safe, it also does not provide a mechanism for adjusting
    its output format. As a result, the use of this function is typically discouraged
    in place of other `time.h` functions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子可以看出，返回的不是从Unix纪元开始的秒数，而是当前时间和日期的可读版本。还应该注意的是，除了`ctime()`函数不是线程安全的之外，它也没有提供调整输出格式的机制。因此，通常不鼓励使用这个函数，而是使用其他`time.h`函数。
- en: The localtime() and gmtime() APIs
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`localtime()`和`gmtime()` API'
- en: 'The `time()` API returns a `time_t` value that stores the number of seconds
    from the Unix epoch, as stated earlier. This value can further be processed to
    expose date and time information, providing us with the ability to convert the
    date and time to either the local time or **Greenwich Mean Time** (**GMT**). To
    do this, the POSIX API provides both the `localtime()` and `gmtime()` functions,
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`time()` API返回一个存储从Unix纪元开始的秒数的`time_t`值，正如前面所述。这个值可以进一步处理以暴露日期和时间信息，使我们能够将日期和时间转换为本地时间或**格林尼治标准时间**（**GMT**）。为此，POSIX
    API提供了`localtime()`和`gmtime()`函数，形式如下：'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Both of these functions take a pointer to a `time_t` variable and return a pointer
    to a `tm` opaque structure. It should be noted that the structure the return value
    points to is managed, like `ctime()`, by the `time.h` implementation, and thus
    is not freed by the user, meaning the results of this function are not thread-safe.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都接受一个指向`time_t`变量的指针，并返回一个指向`tm`不透明结构的指针。应该注意，返回值指向的结构像`ctime()`一样由`time.h`实现管理，因此不会被用户释放，这意味着这个函数的结果不是线程安全的。
- en: The asctime() function
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`asctime()`函数'
- en: 'To output an opaque `tm` structure to `stdout` (or, in general, just to convert
    the structure to a standard C string), the POSIX API provides the `asctime()`
    function, which has the following form:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要将不透明的`tm`结构输出到`stdout`（或者一般来说，只是将结构转换为标准的C字符串），POSIX API提供了`asctime()`函数，形式如下：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `asctime()` function takes the same form as `ctime()`, with the exception
    that a pointer to a `tm` structure is provided as the main argument instead of
    a `time_t` variable, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`asctime()`函数的形式与`ctime()`相同，唯一的区别是主要参数是指向`tm`结构的指针，而不是`time_t`变量，如下所示：'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As shown in the preceding example, there is no difference in the output between
    `ctime()` and `asctime(localtime())`. To output the same time in GMT instead of
    local time, use the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，`ctime()`和`asctime(localtime())`的输出没有区别。要输出GMT时间而不是本地时间，使用以下方式：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As shown in the preceding example, `gmtime()` and `localtime()` execute the
    same, with the only difference being a time zone change.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，`gmtime()`和`localtime()`执行相同，唯一的区别是时区的改变。
- en: The strftime() function
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`strftime()`函数'
- en: 'So far, the output of `ctime()` and `asctime()` was predetermined by the POSIX
    API. That is, there is no way to control the output format. In addition, these
    functions return internal memory, preventing their thread safety. To fix these
    issues, the POSIX API added the `strftime()` function, which is the recommended
    API for converting an opaque `tm` structure to a character string, and takes the
    following form:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`ctime()`和`asctime()`的输出是由POSIX API预先确定的。也就是说，没有办法控制输出格式。此外，这些函数返回内部内存，阻止了它们的线程安全性。为了解决这些问题，POSIX
    API添加了`strftime()`函数，这是将不透明的`tm`结构转换为字符串的推荐API，形式如下：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `str` parameter accepts a preallocated, standard C string, while the `count`
    parameter defines the size of the first parameter. The `format` parameter accepts
    a null-terminated, standard C string that defines the format to which to convert
    the date and time, while the final `time` parameter accepts the opaque `tm` structure
    to convert to a string. The format string that is provided to this function is
    similar to the format string provided to other POSIX functions, such as `printf()`.
    The next couple of examples will demonstrate some of these format specifiers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`str`参数接受预分配的标准C字符串，而`count`参数定义第一个参数的大小。`format`参数接受一个以空字符结尾的标准C字符串，定义要将日期和时间转换为的格式，而最终的`time`参数接受不透明的`tm`结构以转换为字符串。提供给此函数的格式字符串类似于提供给其他POSIX函数的格式字符串，例如`printf()`。接下来的几个示例将演示一些这些格式说明符。'
- en: 'To demonstrate the `strftime()` function, the following outputs the current
    date to `stdout`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`strftime()`函数，以下将当前日期输出到`stdout`：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As shown in the preceding example, the `time()` API is used to get the current
    date and time. The `localtime()` function is used to convert the result of `time()`
    (which is `time_t`) to an opaque `tm` structure that represents the local date
    and time. The resulting `tm` structure is passed to `strftime()` with a format
    string of `"%m/%d/%Y"`, which outputs *month/day/year* to the standard C string
    provided. Finally, this string is output to the `stdout`, resulting in `07/14/2018`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，`time()` API用于获取当前日期和时间。`localtime()`函数用于将`time()`的结果（即`time_t`）转换为表示本地日期和时间的不透明`tm`结构。得到的`tm`结构传递给`strftime()`，格式字符串为`"%m/%d/%Y"`，将*月/日/年*输出到提供的标准C字符串。最后，将此字符串输出到`stdout`，结果为`07/14/2018`。
- en: 'Likewise, this function may be used to output the current time:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，此函数可用于输出当前时间：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding example is identical to the previous example, the only difference
    being that the format specifier is `%H:%M`, which represents `hour:minute`, resulting
    in `15:41`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子与上一个例子相同，唯一的区别是格式说明符是`％H：％M`，表示`小时：分钟`，结果为`15:41`。
- en: 'Finally, to output the same string as `ctime()` and `asctime()`, use the following
    example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要输出与`ctime()`和`asctime()`相同的字符串，请使用以下示例：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding example is identical to the previous two examples, with the exception
    that the format specifier is `"%a %b %d %H:%M:%S %Y"`, which outputs the same
    results as `ctime()` and `asctime()`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子与前两个例子相同，唯一的区别是格式说明符为`"%a %b %d %H:%M:%S %Y"`，输出与`ctime()`和`asctime()`相同的结果。
- en: The difftime() function
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: difftime()函数
- en: 'Technically speaking, the `time_t` typedef is considered opaque (although it
    almost always is a signed 32-bit integer on Unix systems). For this reason, to
    ascertain the difference between two `time_t` values, the `difftime()` function
    is provided as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，`time_t` typedef被认为是不透明的（尽管在Unix系统上几乎总是一个带符号的32位整数）。因此，为了确定两个`time_t`值之间的差异，提供了`difftime()`函数，如下所示：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `difftime()` function takes two `time_t` values and returns the difference
    as a double (since a non-POSIX function might support fractional times):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`difftime()`函数接受两个`time_t`值，并将差异作为双精度返回（因为非POSIX函数可能支持分数时间）：'
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As shown in the preceding example, the `difftime()` function returns the difference
    between two times. It should be noted that although the preceding code compiles
    on most systems, `difftime()` should be used instead of the second example of
    directly subtracting two values.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，`difftime()`函数返回两个时间之间的差异。应该注意的是，尽管前面的代码在大多数系统上都可以编译，但应该使用`difftime()`而不是直接减去两个值的第二个示例。
- en: The mktime() function
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mktime()函数
- en: 'What if you have two opaque `tm` structures and you wish to calculate their
    difference? The problem here is that the `difftime()` function only takes `time_t`
    and not the `tm` structure. To support the reverse of the `localtime()` and `gmtime()`
    functions, which convert `time_t` into a `tm` structure, the `mktime()` function
    converts a `tm` structure back into a `time_t` value, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有两个不透明的`tm`结构，并希望计算它们的差异怎么办？问题在于`difftime()`函数只接受`time_t`而不是`tm`结构。为了支持`localtime()`和`gmtime()`函数的反向操作，它们将`time_t`转换为`tm`结构，`mktime()`函数将`tm`结构转换回`time_t`值，如下所示：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `mktime()` function takes a single parameter, which is the opaque `tm`
    structure you wish to convert to a `time_t` value:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`mktime()`函数接受一个参数，即您希望将其转换为`time_t`值的不透明`tm`结构：'
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding example gets the current time and date using the `time()` API,
    and converts the results into a `tm` structure using the `localtime()` API. The
    resulting `tm` structure is then converted back into a `time_t` value using `mktime()`,
    and the resulting is output to `stdout` using `ctime()`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子使用`time()` API获取当前时间和日期，并使用`localtime()` API将结果转换为`tm`结构。然后将得到的`tm`结构转换回`time_t`值，使用`mktime()`输出结果到`stdout`使用`ctime()`。
- en: The clock() function
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: clock()函数
- en: Up to this point, `time()` has been used to get the current system date and
    time. The problem with this type of clock is it returns the value the operating
    system is managing with respect to the current date and time, which can change
    at any point and time (for example, the user might be flying between time zones).
    This can be a problem, for example, if you are using the time APIs to keep track
    of how long something has executed. In this case, when a time zone change occurs,
    the application using `time()` might record the amount of time that has passed
    as being negative.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`time()`已用于获取当前系统日期和时间。这种类型的时钟的问题在于它返回操作系统管理的与当前日期和时间相关的值，这可以在任何时间点发生变化（例如，用户可能在不同时区之间飞行）。例如，如果您使用时间API来跟踪某个操作执行了多长时间，这可能是一个问题。在这种情况下，当时区发生变化时，使用`time()`的应用程序可能会记录经过的时间为负数。
- en: 'To overcome this issue, POSIX provides the `clock()` function, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，POSIX提供了`clock()`函数，如下所示：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `clock()` API returns a `clock_t` value, which is similar to a `time_t`
    value. The difference between `time()` and `clock()` is that `time()` returns
    the current system time, while `clock()` returns a value that represents the total
    amount of time that has passed since the start of the application, for example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`clock()` API返回一个`clock_t`值，它类似于`time_t`值。`time()`和`clock()`之间的区别在于，`time()`返回当前系统时间，而`clock()`返回一个代表自应用程序启动以来经过的总时间的值，例如：'
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding example, the result of `clock()` is output to `stdout`. As
    shown, the value is implementation-specific, and only the difference between two
    `clock_t` values has any meaning. To convert `clock_t` into seconds, POSIX provides
    the `CLOCKS_PER_SEC` macro, which provides the necessary conversion, as shown
    in the following example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`clock()`的结果输出到`stdout`。如图所示，该值是特定于实现的，只有两个`clock_t`值之间的差异才有意义。要将`clock_t`转换为秒，POSIX提供了`CLOCKS_PER_SEC`宏，它提供了必要的转换，如下例所示：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, the `clock()` API is used to get the first clock value,
    and then the application sleeps for two seconds. Once the application is executed
    again by the operating system, the clock value is read again and the difference
    is converted into milliseconds using `CLOCKS_PER_SEC` (and then multiplied by
    1,000). Notice the value does not equate to 2,000 milliseconds. This is because
    the application does not record execution while sleeping, and thus, only the execute
    time of the application is seen by `clock()`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，使用`clock()`API获取第一个时钟值，然后应用程序睡眠两秒。一旦操作系统再次执行应用程序，就会再次读取时钟值，并将差异转换为毫秒，使用`CLOCKS_PER_SEC`（然后乘以1,000）。请注意，该值不等于2,000毫秒。这是因为应用程序在睡眠时不记录执行时间，因此`clock()`只能看到应用程序的执行时间。
- en: 'To better demonstrate the difference in time, the following example demonstrates
    a one-to-one comparison of `clock()` and `time()`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地展示时间的差异，以下示例演示了`clock()`和`time()`的一对一比较：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding example is identical to the previous example, with the exception
    being we spin for two seconds using `time()` instead of sleeping for two seconds,
    resulting in the `clock()` returning two seconds.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子与前面的例子相同，唯一的区别是我们使用`time()`旋转两秒，而不是睡眠两秒，导致`clock()`返回两秒。
- en: Exploring C++ Chrono APIs
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索C++ Chrono API
- en: C++ includes the Chrono APIs which, mostly, provide C++ wrappers around the POSIX `time.h` APIs.
    For this reason, some time.h functions are still needed to provide full functionality,
    including the conversion to standard C strings. It should be noted that although
    some additions have been made in C++17 (specifically `floor()`, `ceil()`, and
    `round()`), the Chrono APIs are expected to see a relatively large overhaul with
    the introduction of C++20, which is outside the scope of this book. For this reason,
    the C++ Chrono APIs are briefly explained in this section to provide an overview
    of the current APIs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: C++包括Chrono API，大多数情况下提供了对POSIX `time.h` API的C++包装。因此，仍然需要一些time.h函数来提供完整的功能，包括转换为标准C字符串。值得注意的是，尽管在C++17中进行了一些添加（特别是`floor()`、`ceil()`和`round()`），但随着C++20的引入，Chrono
    API预计会进行相当大的改进，这超出了本书的范围。因此，本节简要解释了C++ Chrono API，以提供当前API的概述。
- en: The system_clock() API
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: system_clock() API
- en: 'The `std::chrono::system_clock{}` API is similar to `time()` in that it is
    capable of getting the system clock. `system_clock{}` is also the only clock that
    is capable of being converted into `time_t` (as it is likely implemented using
    `time()`), as shown in the following example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::chrono::system_clock{}` API类似于`time()`，它能够获取系统时钟。`system_clock{}`也是唯一能够转换为`time_t`的时钟（因为它很可能是使用`time()`实现的），如下例所示：'
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, the current system clock is read using the `system_clock::now()`
    API, and the result is converted into a `time_t` value using the `system_clock::to_time_t()`
    API. As with the previous example, the result is the number of seconds from the
    Unix epoch.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，使用`system_clock::now()`API读取当前系统时钟，并使用`system_clock::to_time_t()`API将结果转换为`time_t`值。与前面的例子一样，结果是从Unix纪元开始的秒数。
- en: The time_point API
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: time_point API
- en: 'The result of the `system_clock::now()` API is a `time_point{}`. C++ does not
    provide a function to convert a `time_point{}` to a string (it won''t until C++20),
    and as a result, the POSIX functions discussed in the previous section are still
    needed to perform this translation, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`system_clock::now()` API的结果是一个`time_point{}`。C++没有提供将`time_point{}`转换为字符串的函数（直到C++20才会提供），因此仍然需要使用前面讨论过的POSIX函数来执行这种转换，如下所示：'
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, we first define a user-defined overload for `time_point{}`,
    which is the result of the `std::chrono::system_clock::now()` API. This user-defined
    overload converts `time_point{}` into a `time_t` value using the C++ `std::chrono::system_clock::to_time_t()`
    API, and then converts `time_t` into a standard C string using `ctime()`, and
    streams the result to `stdout`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们首先为`std::chrono::system_clock::now()`API的结果`time_point{}`定义了一个用户定义的重载。这个用户定义的重载使用C++的`std::chrono::system_clock::to_time_t()`API将`time_point{}`转换为`time_t`值，然后使用`ctime()`将`time_t`转换为标准C字符串，并将结果流式输出到`stdout`。
- en: 'Unlike the POSIX `time.h` APIs, the Chrono libraries provided various functions
    for incrementing, decrementing, and comparing a `time_point{}` using C++ operator
    overloads, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与POSIX `time.h` API不同，Chrono库提供了各种函数来使用C++运算符重载对`time_point{}`进行递增、递减和比较，如下所示：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding example, the user-defined overload for `time_point{}` is provided
    as with the previous example. The current date and time are read using `std::chrono::system_clock::now()`,
    and the result is output to `stdout`. Finally, the resulting `time_point{}` is
    incremented by an hour, and then decremented by an hour (using the hour literal),
    and the results are also output to `stdout`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，提供了`time_point{}`的用户定义重载，与前面的例子一样。使用`std::chrono::system_clock::now()`读取当前日期和时间，并将结果输出到`stdout`。最后，将得到的`time_point{}`增加一个小时，然后减少一个小时（使用小时字面量），并将结果也输出到`stdout`。
- en: 'In addition, arithmetic comparisons are supported, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还支持算术比较，如下所示：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, the system clock is read twice, and the resulting
    `time_point{}` values are compared using the supported comparison operators. It
    should be noted that the results of this example could be different depending
    on the system this code is executed on, as the resolution of the time could be
    different.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，系统时钟被读取两次，然后使用支持的比较运算符比较得到的`time_point{}`值。应该注意，这个例子的结果可能因执行代码的系统不同而不同，因为时间的分辨率可能不同。
- en: Duration
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续时间
- en: The `time_point{}` type provides arithmetic to increment, decrement, and perform
    addition and subtraction. This arithmetic is all done using a C++ Chrono `duration{}`,
    which defines a range of time. Another way to view `duration{}` is that it would
    be the resulting abstraction of the POSIX `difftime()` call. In fact, the subtraction
    of two `time_point{}` types results in a `duration{}`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`time_point{}`类型提供了增加、减少、执行加法和减法的算术运算。所有这些算术运算都是使用C++ Chrono `duration{}`完成的，它定义了一段时间。另一种看待`duration{}`的方式是它将是POSIX
    `difftime()`调用的结果抽象。事实上，两个`time_point{}`类型的减法结果是一个`duration{}`。'
- en: 'In the preceding examples, `time_point{}` was incremented and decremented by
    an hour using the *h* duration literal for an hour. Like the hour literal, C++
    provides the following literals for a duration of time, which may be used for
    this arithmetic:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`time_point{}`使用*小时*持续时间字面量增加和减少了一个小时。与小时字面量类似，C++还为时间持续时间提供了以下字面量，可用于此类算术运算：
- en: '**Hour**: *h*'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小时**：*h*'
- en: '**Minute**: *min*'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分钟**：*min*'
- en: '**Second**: *s*'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秒**：*s*'
- en: '**Millisecond**: *ms*'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**毫秒**：*ms*'
- en: '**Microsecond**: *us*'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微秒**：*us*'
- en: '**Nanosecond**: *ns*'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纳秒**：*ns*'
- en: 'Durations have a relatively complex template structure, which is outside the
    scope of this book, for defining their resolution (that is, whether a duration
    is in seconds, milliseconds, or hours), and can technically take on almost any
    resolution as a result. Although this functionality exists, C++ provides some
    predefined helpers for converting from one duration to another, preventing you
    from needing to know the inner workings of `duration{}`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间具有相对复杂的模板结构，超出了本书的范围，用于定义它们的分辨率（即持续时间是以秒、毫秒还是小时为单位），并且在技术上可以以几乎任何分辨率进行。尽管存在这种功能，但C++提供了一些预定义的辅助程序，用于将一种持续时间转换为另一种，从而避免您需要了解`duration{}`的内部工作方式：
- en: '`std::chrono::nanoseconds`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::nanoseconds`'
- en: '`std::chrono::microseconds`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::microseconds`'
- en: '`std::chrono::milliseconds`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::milliseconds`'
- en: '`std::chrono::seconds`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::seconds`'
- en: '`std::chrono::minutes`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::minutes`'
- en: '`std::chrono::hours `'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::chrono::hours `'
- en: 'For example, below we will use these predefined helpers to convert the system
    clock to seconds and milliseconds:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面我们将使用这些预定义的辅助程序将系统时钟转换为秒和毫秒：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding example, the system clock is read twice, with a sleep for two
    seconds separating each read. The resulting `time_point{}` values are then subtracted
    to create a `duration{}`, and the resulting `duration{}` is converted into seconds,
    milliseconds, and nanoseconds, with the results being output to `stdout` using
    the `count()` member function, which simply returns the value of `duration{}`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，系统时钟被读取两次，每次读取之间间隔两秒的睡眠。然后将得到的`time_point{}`值相减以创建一个`duration{}`，并将得到的`duration{}`转换为秒、毫秒和纳秒，结果使用`count()`成员函数输出到`stdout`，该函数简单地返回`duration{}`的值。
- en: 'Like `time_point{}`, a duration can also be manipulated using arithmetic, as
    follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与`time_point{}`一样，持续时间也可以使用算术运算进行操作，如下所示：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding example, two `duration{}` variables are created that represent
    a second, one with the value of `0` seconds, and the second with a value of `42`
    seconds. Arithmetic is then performed on the first duration and the results are
    output to `stdout`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，创建了两个代表一秒的`duration{}`变量，一个值为`0`秒，另一个值为`42`秒。然后对第一个持续时间进行算术运算，并将结果输出到`stdout`。
- en: 'In addition, comparisons are also supported:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还支持比较：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding example, two durations are created that represent `0` seconds
    and `42` seconds respectively, and both durations are compared using the comparison
    operators.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，创建了两个分别代表`0`秒和`42`秒的持续时间，并使用比较运算符进行比较。
- en: 'Most of the modifications to the Chrono library that are taking place will
    likely occur in C++20 with a large number of APIs being added to address the relatively
    obvious shortcomings of the existing API. In C++17, however, the `floor()`, `ceil()`,
    `round()`, and `abs()` APIs were added to the Chrono APIs, which return the floor,
    ceil, round, or absolute values of a duration, as shown in the following example
    (with similar APIs also being added to the `time_point{}` type):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数对Chrono库的修改可能会在C++20中进行，大量的API将被添加以解决现有API的明显缺陷。然而，在C++17中，`floor()`、`ceil()`、`round()`和`abs()`
    API被添加到了Chrono API中，它们返回持续时间的floor、ceil、round或绝对值，如下例所示（类似的API也被添加到了`time_point{}`类型中）：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The steady_clock function
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稳定时钟函数
- en: '`system_clock{}` is similar to `time()`, while `steady_clock{}` is similar
    to `clock()`, and performs the same objective—to provide a clock that represents
    the amount of time the application has executed, regardless of the current system
    date and time (which might change depending on the user of the system); for example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`system_clock{}`类似于`time()`，而`steady_clock{}`类似于`clock()`，并且执行相同的目标——提供一个代表应用程序执行时间的时钟，而不考虑当前系统日期和时间（这可能会根据系统用户而改变）；例如：'
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding example, the `steady_clock::now()` function is read twice,
    with a sleep separating the two calls. The resulting values are subtracted, converted
    to seconds, milliseconds, and nanoseconds, and the result is output to `stdout`.
    It should be noted that unlike `clock()`, the resulting steady clock accounts
    for the time the application slept.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`steady_clock::now()`函数被调用两次，两次调用之间有一个睡眠。然后将得到的值相减，转换为秒、毫秒和纳秒，并将结果输出到`stdout`。需要注意的是，与`clock()`不同，得到的稳定时钟考虑了应用程序休眠的时间。
- en: The high_resolution_clock function
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高分辨率时钟函数
- en: 'On most systems, `high_resolution_clock{}` and `steady_clock{}` are the same.
    In general, `high_resolution_clock{}` represents the highest-resolution clock
    available as a steady clock and, as shown in the following example, the result
    is the same with `stead_clock{}`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数系统上，`high_resolution_clock{}`和`steady_clock{}`是相同的。一般来说，`high_resolution_clock{}`代表最高分辨率的稳定时钟，并且如下例所示，与`stead_clock{}`的结果相同：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding example, the `high_resolution_clock::now()` function is read
    twice, with a sleep separating the two calls. The resulting values are subtracted,
    converted into seconds, milliseconds, and nanoseconds, and the result is output
    to `stdout`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`high_resolution_clock::now()`函数被调用两次，两次调用之间有一个睡眠。然后将得到的值相减，转换为秒、毫秒和纳秒，并将结果输出到`stdout`。
- en: Studying an example on the read system clock
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究读取系统时钟的示例
- en: 'In this example, we will bring everything we learned in this chapter into a
    simple demonstration that reads the system clock at an interval specified by the
    user. To accomplish this, the following inclusions and namespaces are needed:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将把本章学到的所有内容融入到一个简单的演示中，该演示按用户指定的间隔读取系统时钟。为了实现这一点，需要以下包含和命名空间：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Like the examples throughout this chapter, a user-defined overload for `std::ostream{}`
    is provided to convert `time_point{}` into a standard C string, and then stream
    the result to `stdout`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的其他示例一样，提供了一个用户定义的`std::ostream{}`重载，将`time_point{}`转换为标准C字符串，然后将结果流式输出到`stdout`：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In our `protected_main()` function (which is a pattern used throughout this
    book), we output the current system time on an interval provided by the user,
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`protected_main()`函数中（这是本书中使用的一种模式），我们按用户提供的间隔输出当前系统时间，如下所示：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding code, we convert the arguments list into `gsl::span{}`, and
    then make sure we were given an argument. If no argument is provided, we exit
    the program. The argument is then converted into `cstring_span{}`, and an infinite
    loop is started. In the loop, the system clock is read and output to `stdout`,
    and then the program sleeps for the amount of time provided by the user:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们将参数列表转换为`gsl::span{}`，然后确保我们提供了一个参数。如果没有提供参数，我们就退出程序。然后将参数转换为`cstring_span{}`，并启动一个无限循环。在循环中，读取系统时钟并将其输出到`stdout`，然后程序休眠用户提供的时间：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As with all of our examples, the `protected_main()` function is executed by
    the `main()` function, which catches exceptions should they occur.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们所有的示例一样，`protected_main()`函数由`main()`函数执行，如果发生异常，`main()`函数会捕获异常。
- en: Compiling and testing
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和测试
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译这段代码，我们利用了与其他示例相同的`CMakeLists.txt`文件：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt)。
- en: 'With this code in place, we can compile this code using the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以使用以下命令编译这段代码：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To execute the example, run the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个示例，运行以下命令：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As shown in the preceding snippet, the example is run with an interval of two
    seconds, and the application outputs the system clock to the console every two
    seconds.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的片段所示，示例以两秒的间隔运行，并且应用程序每两秒将系统时钟输出到控制台。
- en: Studying an example on high-resolution timer
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究高分辨率定时器的示例
- en: 'In this example, we will create a simple benchmark using `high_resolution_clock{}`. To
    accomplish this, the following inclusions and namespaces are needed:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`high_resolution_clock{}`创建一个简单的基准测试。为了实现这一点，需要以下包含和命名空间：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To create a `benchmark` function, we use the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`benchmark`函数，我们使用以下内容：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This function has been seen before in [Chapter 8](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml),
    *Learning to Program File Input/Output*, The Logger Example. This code leverages
    functional programming to wrap a function call (likely a lambda) between two calls
    to the high-resolution clock. The results are then subtracted and returned. As
    we learned in this chapter, `high_resolution_clock{}` returns a `time_point{}`
    and their difference creates a `duration{}`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在[第8章](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml)中已经见过，*学习文件输入/输出编程*，日志示例。这段代码利用函数式编程将一个函数调用（可能是一个lambda）包装在两次高分辨率时钟调用之间。然后相减并返回结果。正如我们在本章中学到的，`high_resolution_clock{}`返回一个`time_point{}`，它们的差值创建一个`duration{}`。
- en: 'The `protected_main()` function is implemented as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected_main()`函数的实现如下：'
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding code, we convert the arguments list to a `gsl::span{}`, and
    then check to make sure we were given an argument. If no argument is provided,
    we exit the program. The argument is then converted into `cstring_span{}`, and
    a loop that runs for as long as the user wishes is benchmarked. The result of
    the `benchmark` is then converted into seconds, milliseconds, and nanoseconds
    and output to `stdout`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们将参数列表转换为`gsl::span{}`，然后检查确保我们得到了一个参数。如果没有提供参数，我们就退出程序。然后将参数转换为`cstring_span{}`，并对用户希望运行的时间进行基准测试。基准测试的结果然后转换为秒、毫秒和纳秒，并输出到`stdout`：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As with all of our examples, the `protected_main()` function is executed by
    the `main()` function, which catches exceptions should they occur.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们所有的示例一样，`protected_main()`函数由`main()`函数执行，如果发生异常，`main()`函数会捕获异常。
- en: Compiling and testing
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和测试
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译这段代码，我们利用了与其他示例相同的`CMakeLists.txt`文件：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt)。
- en: 'With this code in place, we can compile this code using the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以使用以下方法编译这段代码：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To execute the example, run the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个示例，运行以下命令：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As shown in the preceding snippet, the example is run with a loop of `1000000`
    iterations, and the amount of time it takes to execute that loop is output to
    the console.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的片段所示，示例是通过一个循环运行的，循环次数为`1000000`，并且执行该循环所需的时间被输出到控制台。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use both the POSIX and C++ time interfaces
    to read the system clock, and a steady clock for more precise timing. This chapter
    concluded with two examples; the first example demonstrated how to read the system
    clock and output the results to the console on a user-defined interval, and the
    second demonstrated how to benchmark software using the C++ high-resolution timer. In
    the next chapter, we will learn how to program both POSIX and C++ threads with
    examples that build upon the lessons learned in this chapter.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用POSIX和C++时间接口来读取系统时钟，以及使用稳定时钟进行更精确的计时。本章以两个示例结束；第一个示例演示了如何读取系统时钟并在用户定义的间隔内将结果输出到控制台，第二个示例演示了如何使用C++高分辨率计时器对软件进行基准测试。在下一章中，我们将学习如何使用POSIX和C++线程，并且会通过本章所学的知识构建示例。
- en: In the next chapter, we will discuss C++ threads, synchronization primitives
    such as mutexes, and how to program them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论C++线程、互斥锁等同步原语，以及如何对它们进行编程。
- en: Questions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the Unix epoch?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unix纪元是什么？
- en: What type does `time_t` usually represent?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`time_t`通常表示什么类型？'
- en: What is the difference between `time()` and `clock()`?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`time()`和`clock()`之间有什么区别？'
- en: Why does `difftime()` return a double?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么`difftime()`返回一个double？
- en: What is a C++ `duration{}`?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++ `duration{}`是什么？
- en: What is the difference between `steady_clock{}` and `high_resolution_clock{}`?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`steady_clock{}`和`high_resolution_clock{}`之间有什么区别？'
- en: Further reading
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
