["```cpp\n        auto si = std::to_string(42);      // si=\"42\" \n        auto sl = std::to_string(42l);     // sl=\"42\" \n        auto su = std::to_string(42u);     // su=\"42\" \n        auto sd = std::to_wstring(42.0);   // sd=L\"42.000000\" \n        auto sld = std::to_wstring(42.0l); // sld=L\"42.000000\"\n```", "```cpp\n        auto i1 = std::stoi(\"42\");                 // i1 = 42 \n        auto i2 = std::stoi(\"101010\", nullptr, 2); // i2 = 42 \n        auto i3 = std::stoi(\"052\", nullptr, 8);    // i3 = 42 \n        auto i4 = std::stoi(\"0x2A\", nullptr, 16);  // i4 = 42\n```", "```cpp\n        // d1 = 123.45000000000000 \n        auto d1 = std::stod(\"123.45\"); \n        // d2 = 123.45000000000000 \n        auto d2 = std::stod(\"1.2345e+2\"); \n        // d3 = 123.44999980926514 \n        auto d3 = std::stod(\"0xF.6E6666p3\");\n```", "```cpp\n    std::string to_string(int value); \n    std::string to_string(long value); \n    std::string to_string(long long value); \n    std::string to_string(unsigned value); \n    std::string to_string(unsigned long value); \n    std::string to_string(unsigned long long value); \n    std::string to_string(float value); \n    std::string to_string(double value); \n    std::string to_string(long double value); \n    std::wstring to_wstring(int value); \n    std::wstring to_wstring(long value); \n    std::wstring to_wstring(long long value); \n    std::wstring to_wstring(unsigned value); \n    std::wstring to_wstring(unsigned long value); \n    std::wstring to_wstring(unsigned long long value); \n    std::wstring to_wstring(float value); \n    std::wstring to_wstring(double value); \n    std::wstring to_wstring(long double value);\n```", "```cpp\n    int stoi(const std::string& str, std::size_t* pos = 0,  \n             int base = 10); \n    int stoi(const std::wstring& str, std::size_t* pos = 0,  \n             int base = 10); \n    long stol(const std::string& str, std::size_t* pos = 0,  \n             int base = 10); \n    long stol(const std::wstring& str, std::size_t* pos = 0,  \n             int base = 10); \n    long long stoll(const std::string& str, std::size_t* pos = 0,  \n                    int base = 10); \n    long long stoll(const std::wstring& str, std::size_t* pos = 0,  \n                    int base = 10); \n    unsigned long stoul(const std::string& str, std::size_t* pos = 0, \n                        int base = 10); \n    unsigned long stoul(const std::wstring& str, std::size_t* pos = 0,  \n                        int base = 10); \n    unsigned long long stoull(const std::string& str,  \n                              std::size_t* pos = 0, int base = 10); \n    unsigned long long stoull(const std::wstring& str,  \n                              std::size_t* pos = 0, int base = 10); \n    float       stof(const std::string& str, std::size_t* pos = 0); \n    float       stof(const std::wstring& str, std::size_t* pos = 0); \n    double      stod(const std::string& str, std::size_t* pos = 0); \n    double      stod(const std::wstring& str, std::size_t* pos = 0); \n    long double stold(const std::string& str, std::size_t* pos = 0); \n    long double stold(const std::wstring& str, std::size_t* pos = 0);\n```", "```cpp\n    auto i1 = std::stoi(\"42\");             // i1 = 42 \n    auto i2 = std::stoi(\"   42\");          // i2 = 42 \n    auto i3 = std::stoi(\"   42fortytwo\");  // i3 = 42 \n    auto i4 = std::stoi(\"+42\");            // i4 = 42 \n    auto i5 = std::stoi(\"-42\");            // i5 = -42\n```", "```cpp\n    auto i6 = std::stoi(\"052\", nullptr, 8); \n    auto i7 = std::stoi(\"052\", nullptr, 0); \n    auto i8 = std::stoi(\"0x2A\", nullptr, 16); \n    auto i9 = std::stoi(\"0x2A\", nullptr, 0); \n    auto i10 = std::stoi(\"101010\", nullptr, 2); \n    auto i11 = std::stoi(\"22\", nullptr, 20); \n    auto i12 = std::stoi(\"-22\", nullptr, 20); \n\n    auto pos = size_t{ 0 }; \n    auto i13 = std::stoi(\"42\", &pos);      // pos = 2 \n    auto i14 = std::stoi(\"-42\", &pos);     // pos = 3 \n    auto i15 = std::stoi(\"  +42dec\", &pos);// pos = 5\n```", "```cpp\n        try \n        { \n           auto i16 = std::stoi(\"\"); \n        } \n        catch (std::exception const & e) \n        { \n           // prints \"invalid stoi argument\" \n           std::cout << e.what() << std::endl; \n        }\n```", "```cpp\n        try \n        { \n           // OK\n           auto i17 = std::stoll(\"12345678901234\");  \n           // throws std::out_of_range \n           auto i18 = std::stoi(\"12345678901234\"); \n        } \n        catch (std::exception const & e) \n        { \n           // prints \"stoi argument out of range\"\n           std::cout << e.what() << std::endl; \n        }\n```", "```cpp\n    auto d1 = std::stod(\"123.45\");         // d1 =  123.45000000000000 \n    auto d2 = std::stod(\"+123.45\");        // d2 =  123.45000000000000 \n    auto d3 = std::stod(\"-123.45\");        // d3 = -123.45000000000000 \n    auto d4 = std::stod(\"  123.45\");       // d4 =  123.45000000000000 \n    auto d5 = std::stod(\"  -123.45abc\");   // d5 = -123.45000000000000 \n    auto d6 = std::stod(\"1.2345e+2\");      // d6 =  123.45000000000000 \n    auto d7 = std::stod(\"0xF.6E6666p3\");   // d7 =  123.44999980926514 \n\n    auto d8 = std::stod(\"INF\");            // d8 = inf \n    auto d9 = std::stod(\"-infinity\");      // d9 = -inf \n    auto d10 = std::stod(\"NAN\");           // d10 = nan \n    auto d11 = std::stod(\"-nanabc\");       // d11 = -nan\n```", "```cpp\n        template<typename T, typename I> \n        T minimum(I const start, I const end) \n        { \n          T minval = std::numeric_limits<T>::max(); \n          for (auto i = start; i < end; ++i) \n          { \n            if (*i < minval) \n              minval = *i; \n          } \n          return minval; \n        } \n\n        int range[std::numeric_limits<char>::max() + 1] = { 0 }; \n\n        switch(get_value()) \n        { \n          case std::numeric_limits<int>::min(): \n          break; \n        }\n```", "```cpp\n        auto n = 42; \n        std::bitset<std::numeric_limits<decltype(n)>::digits>  \n          bits { static_cast<unsigned long long>(n) };\n```", "```cpp\n    template<> class numeric_limits<bool>; \n    template<> class numeric_limits<char>; \n    template<> class numeric_limits<signed char>; \n    template<> class numeric_limits<unsigned char>; \ntemplate<> class numeric_limits<wchar_t>; \n    template<> class numeric_limits<char16_t>; \n    template<> class numeric_limits<char32_t>; \n    template<> class numeric_limits<short>; \n    template<> class numeric_limits<unsigned short>; \n    template<> class numeric_limits<int>; \n    template<> class numeric_limits<unsigned int>; \n    template<> class numeric_limits<long>; \n    template<> class numeric_limits<unsigned long>; \n    template<> class numeric_limits<long long>; \n    template<> class numeric_limits<unsigned long long>; \n    template<> class numeric_limits<float>; \n    template<> class numeric_limits<double>; \n    template<> class numeric_limits<long double>;\n```", "```cpp\n    template <typename T> \n    void print_type_properties() \n    { \n      std::cout  \n        << \"min=\"  \n        << std::numeric_limits<T>::min()        << std::endl \n        << \"max=\" \n        << std::numeric_limits<T>::max()        << std::endl \n        << \"bits=\" \n        << std::numeric_limits<T>::digits       << std::endl \n        << \"decdigits=\" \n        << std::numeric_limits<T>::digits10     << std::endl \n        << \"integral=\" \n        << std::numeric_limits<T>::is_integer   << std::endl \n        << \"signed=\" \n        << std::numeric_limits<T>::is_signed    << std::endl \n        << \"exact=\" \n        << std::numeric_limits<T>::is_exact     << std::endl \n        << \"infinity=\" \n        << std::numeric_limits<T>::has_infinity << std::endl; \n    }\n```", "```cpp\n        #include <random>\n```", "```cpp\n        std::random_device rd{};\n```", "```cpp\n        auto mtgen = std::mt19937{ rd() };\n```", "```cpp\n        auto ud = std::uniform_int_distribution<>{ 1, 6 };\n```", "```cpp\n        for(auto i = 0; i < 20; ++i) \n          auto number = ud(mtgen);\n```", "```cpp\n    auto mtgen = std::mt19937 {}; \n    for (auto i = 0; i < 10; ++i) \n      std::cout << mtgen() << std::endl;\n```", "```cpp\n    auto seed = std::chrono::high_resolution_clock::now() \n                .time_since_epoch() \n                .count(); \n    auto mtgen = std::mt19937{ static_cast<unsigned int>(seed) };\n```", "```cpp\n    std::random_device rd; \n    auto mtgen = std::mt19937 {rd()};\n```", "```cpp\n    void generate_and_print( \n      std::function<int(void)> gen,  \n      int const iterations = 10000) \n    { \n      // map to store the numbers and their repetition \n      auto data = std::map<int, int>{}; \n\n      // generate random numbers \n      for (auto n = 0; n < iterations; ++n) \n        ++data[gen()]; \n\n      // find the element with the most repetitions \n      auto max = std::max_element( \n                 std::begin(data), std::end(data),  \n                 [](auto kvp1, auto kvp2) { \n        return kvp1.second < kvp2.second; }); \n\n      // print the bars \n      for (auto i = max->second / 200; i > 0; --i) \n      { \n        for (auto kvp : data) \n        { \n          std::cout \n            << std::fixed << std::setprecision(1) << std::setw(3) \n            << (kvp.second / 200 >= i ? (char)219 : ' '); \n        } \n\n        std::cout << std::endl; \n      } \n\n      // print the numbers \n      for (auto kvp : data) \n      { \n        std::cout \n          << std::fixed << std::setprecision(1) << std::setw(3) \n          << kvp.first; \n      } \n\n      std::cout << std::endl; \n    }\n```", "```cpp\n    std::random_device rd{}; \n    auto mtgen = std::mt19937{ rd() }; \n    auto ud = std::uniform_int_distribution<>{ 1, 6 }; \n    generate_and_print([&mtgen, &ud]() {return ud(mtgen); });\n```", "```cpp\n    std::random_device rd{}; \n    auto mtgen = std::mt19937{ rd() }; \n    auto nd = std::normal_distribution<>{ 5, 2 }; \n\n    generate_and_print( \n      [&mtgen, &nd]() { \n        return static_cast<int>(std::round(nd(mtgen))); });\n```", "```cpp\n        std::random_device rd;\n```", "```cpp\n        std::array<int, std::mt19937::state_size> seed_data {};\n        std::generate(std::begin(seed_data), std::end(seed_data), \n                      std::ref(rd));\n```", "```cpp\n        std::seed_seq seq(std::begin(seed_data), std::end(seed_data));\n```", "```cpp\n        auto eng = std::mt19937{ seq };\n```", "```cpp\n        auto dist = std::uniform_real_distribution<>{ 0, 1 };\n```", "```cpp\n        T operator \"\" _suffix(unsigned long long int); \n        T operator \"\" _suffix(long double); \n        T operator \"\" _suffix(char); \n        T operator \"\" _suffix(wchar_t); \n        T operator \"\" _suffix(char16_t); \n        T operator \"\" _suffix(char32_t); \n        T operator \"\" _suffix(char const *, std::size_t); \n        T operator \"\" _suffix(wchar_t const *, std::size_t); \n        T operator \"\" _suffix(char16_t const *, std::size_t); \n        T operator \"\" _suffix(char32_t const *, std::size_t);\n```", "```cpp\n    namespace compunits \n    { \n      constexpr size_t operator \"\" _KB(unsigned long long const size) \n      { \n        return static_cast<size_t>(size * 1024); \n      } \n    } \n\n    auto size{ 4_KB };         // size_t size = 4096; \n\n    using byte = unsigned char; \n    auto buffer = std::array<byte, 1_KB>{};\n```", "```cpp\n        enum class unit { kilogram, liter, meter, piece, };\n```", "```cpp\n        template <unit U> \n        class quantity \n        {\n          const double amount; \n          public: \n            constexpr explicit quantity(double const a) : \n              amount(a) {} \n\n          explicit operator double() const { return amount; } \n        };\n```", "```cpp\n        template <unit U> \n        constexpr quantity<U> operator+(quantity<U> const &q1, \n                                        quantity<U> const &q2) \n        {\n          return quantity<U>(static_cast<double>(q1) + \n                             static_cast<double>(q2)); \n        } \n\n        template <unit U> \n        constexpr quantity<U> operator-(quantity<U> const &q1, \n                                        quantity<U> const &q2)\n        {\n          return quantity<U>(static_cast<double>(q1) - \n                             static_cast<double>(q2));\n        }\n```", "```cpp\n        namespace unit_literals \n        { \n          constexpr quantity<unit::kilogram> operator \"\" _kg( \n              long double const amount) \n          { \n            return quantity<unit::kilogram>  \n              { static_cast<double>(amount) }; \n          } \n\n          constexpr quantity<unit::kilogram> operator \"\" _kg( \n             unsigned long long const amount) \n          { \n            return quantity<unit::kilogram>  \n              { static_cast<double>(amount) }; \n          } \n\n          constexpr quantity<unit::liter> operator \"\" _l( \n             long double const amount) \n          { \n             return quantity<unit::liter>  \n               { static_cast<double>(amount) }; \n          } \n\n          constexpr quantity<unit::meter> operator \"\" _m( \n             long double const amount) \n          { \n            return quantity<unit::meter>  \n              { static_cast<double>(amount) }; \n          } \n\n          constexpr quantity<unit::piece> operator \"\" _pcs( \n             unsigned long long const amount) \n          { \n            return quantity<unit::piece>  \n              { static_cast<double>(amount) }; \n          } \n        }\n```", "```cpp\n    using namespace units; \n    using namespace unit_literals; \n\n    auto q1{ 1_kg };    // OK\n    auto q2{ 4.5_kg };  // OK\n    auto q3{ q1 + q2 }; // OK\n    auto q4{ q2 - q1 }; // OK\n\n    // error, cannot add meters and pieces \n    auto q5{ 1.0_m + 1_pcs }; \n    // error, cannot have an integer number of liters \n    auto q6{ 1_l }; \n    // error, can only have an integer number of pieces \n    auto q7{ 2.0_pcs}\n```", "```cpp\n        using namespace std::string_literals; \n\n        auto s1{  \"text\"s }; // std::string \n        auto s2{ L\"text\"s }; // std::wstring \n        auto s3{ u\"text\"s }; // std::u16string \n        auto s4{ U\"text\"s }; // std::u32string\n```", "```cpp\n        using namespace std::literals::chrono_literals; \n\n        // std::chrono::duration<long long> \n        auto timer {2h + 42min + 15s};\n```", "```cpp\n        using namespace std::literals::complex_literals; \n\n        auto c{ 12.0 + 4.5i }; // std::complex<double>\n```", "```cpp\n        T operator \"\" _suffix(const char*); \n\n        template<char...> T operator \"\" _suffix();\n```", "```cpp\n    namespace binary \n    { \n      using byte8  = unsigned char; \n      using byte16 = unsigned short; \n      using byte32 = unsigned int; \n\n      namespace binary_literals \n      { \n        namespace binary_literals_internals \n        { \n          template <typename CharT, char... bits> \n          struct binary_struct; \n\n          template <typename CharT, char... bits> \n          struct binary_struct<CharT, '0', bits...> \n          { \n            static constexpr CharT value{ \n              binary_struct<CharT, bits...>::value }; \n          }; \n\n          template <typename CharT, char... bits> \n          struct binary_struct<CharT, '1', bits...> \n          { \n            static constexpr CharT value{ \n              static_cast<CharT>(1 << sizeof...(bits)) | \n              binary_struct<CharT, bits...>::value }; \n          }; \n\n          template <typename CharT> \n          struct binary_struct<CharT> \n          { \n            static constexpr CharT value{ 0 }; \n          }; \n        } \n\n        template<char... bits> \n        constexpr byte8 operator\"\"_b8() \n        { \n          static_assert( \n            sizeof...(bits) <= 8, \n            \"binary literal b8 must be up to 8 digits long\"); \n\n          return binary_literals_internals:: \n                    binary_struct<byte8, bits...>::value; \n        } \n\n        template<char... bits> \n        constexpr byte16 operator\"\"_b16() \n        { \n          static_assert( \n            sizeof...(bits) <= 16, \n            \"binary literal b16 must be up to 16 digits long\"); \n\n          return binary_literals_internals:: \n                    binary_struct<byte16, bits...>::value; \n        } \n\n        template<char... bits> \n        constexpr byte32 operator\"\"_b32() \n        { \n          static_assert( \n             sizeof...(bits) <= 32, \n             \"binary literal b32 must be up to 32 digits long\"); \n\n          return binary_literals_internals:: \n                    binary_struct<byte32, bits...>::value; \n        } \n\n      } \n    }\n```", "```cpp\n    template <typename CharT, char... bits> \n    struct binary_struct;\n```", "```cpp\n    template <typename CharT, char... bits> \n    struct binary_struct<CharT, '0', bits...> \n    { \n      static constexpr CharT value{ \n        binary_struct<CharT, bits...>::value }; \n    }; \n\n    template <typename CharT, char... bits> \n    struct binary_struct<CharT, '1', bits...> \n    { \n      static constexpr CharT value{ \n        static_cast<CharT>(1 << sizeof...(bits)) | \n        binary_struct<CharT, bits...>::value }; \n    };\n```", "```cpp\n    template <typename CharT> \n    struct binary_struct<CharT> \n    { \n      static constexpr CharT value{ 0 }; \n    };\n```", "```cpp\n    using namespace binary; \n    using namespace binary_literals; \n    auto b1 = 1010_b8; \n    auto b2 = 101010101010_b16; \n    auto b3 = 101010101010101010101010_b32;\n```", "```cpp\n    // binary literal b8 must be up to 8 digits long \n    auto b4 = 0011111111_b8; \n    // binary literal b16 must be up to 16 digits long \n    auto b5 = 001111111111111111_b16; \n    // binary literal b32 must be up to 32 digits long \nauto b6 = 0011111111111111111111111111111111_b32;\n```", "```cpp\n        auto filename {R\"(C:\\Users\\Marius\\Documents\\)\"s};\n        auto pattern {R\"((\\w+)=(\\d+)$)\"s}; \n\n        auto sqlselect { \n          R\"(SELECT * \n          FROM Books \n          WHERE Publisher='Paktpub' \n          ORDER BY PubDate DESC)\"s};\n```", "```cpp\n        auto text{ R\"!!(This text contains both \"( and )\".)!!\"s }; \n        std::cout << text << std::endl;\n```", "```cpp\n    auto filename1 {R\"(C:\\Users\\Marius\\Documents\\)\"s}; \n    auto filename2 {R\"(C:\\\\Users\\\\Marius\\\\Documents\\\\)\"s}; \n\n    // prints C:\\Users\\Marius\\Documents\\  \n    std::cout << filename1 << std::endl; \n\n    // prints C:\\\\Users\\\\Marius\\\\Documents\\\\  \n    std::cout << filename2 << std::endl;\n```", "```cpp\n    auto t1{ LR\"(text)\"  };  // const wchar_t* \n    auto t2{ u8R\"(text)\" };  // const char* \n    auto t3{ uR\"(text)\"  };  // const char16_t* \n    auto t4{ UR\"(text)\"  };  // const char32_t* \n\n    auto t5{ LR\"(text)\"s  }; // wstring \n    auto t6{ u8R\"(text)\"s }; // string \n    auto t7{ uR\"(text)\"s  }; // u16string \n    auto t8{ UR\"(text)\"s  }; // u32string\n```", "```cpp\n    template <typename CharT> \n    using tstring =  \n       std::basic_string<CharT, std::char_traits<CharT>,  \n                         std::allocator<CharT>>; \n\n    template <typename CharT> \n    using tstringstream =  \n       std::basic_stringstream<CharT, std::char_traits<CharT>,  \n                               std::allocator<CharT>>;\n```", "```cpp\n        template<typename CharT> \n        inline tstring<CharT> to_upper(tstring<CharT> text) \n        { \n          std::transform(std::begin(text), std::end(text), \n                         std::begin(text), toupper); \n          return text; \n        } \n\n        template<typename CharT> \n        inline tstring<CharT> to_lower(tstring<CharT> text) \n        { \n          std::transform(std::begin(text), std::end(text),  \n                         std::begin(text), tolower); \n          return text; \n        }\n```", "```cpp\n        template<typename CharT> \n        inline tstring<CharT> reverse(tstring<CharT> text) \n        { \n          std::reverse(std::begin(text), std::end(text)); \n          return text; \n        }\n```", "```cpp\n        template<typename CharT> \n        inline tstring<CharT> trim(tstring<CharT> const & text) \n        { \n          auto first{ text.find_first_not_of(' ') }; \n          auto last{ text.find_last_not_of(' ') }; \n          return text.substr(first, (last - first + 1)); \n        } \n\n        template<typename CharT> \n        inline tstring<CharT> trimleft(tstring<CharT> const & text) \n        { \n          auto first{ text.find_first_not_of(' ') }; \n          return text.substr(first, text.size() - first); \n        } \n\n        template<typename CharT> \n        inline tstring<CharT> trimright(tstring<CharT> const & text) \n        { \n          auto last{ text.find_last_not_of(' ') }; \n          return text.substr(0, last + 1); \n        }\n```", "```cpp\n        template<typename CharT> \n        inline tstring<CharT> trim(tstring<CharT> const & text,  \n                                   tstring<CharT> const & chars) \n        { \n          auto first{ text.find_first_not_of(chars) }; \n          auto last{ text.find_last_not_of(chars) }; \n          return text.substr(first, (last - first + 1)); \n        } \n\n        template<typename CharT> \n        inline tstring<CharT> trimleft(tstring<CharT> const & text,  \n                                       tstring<CharT> const & chars) \n        { \n          auto first{ text.find_first_not_of(chars) }; \n          return text.substr(first, text.size() - first); \n        } \n\n        template<typename CharT> \n        inline tstring<CharT> trimright(tstring<CharT> const &text, \n                                        tstring<CharT> const &chars) \n        { \n          auto last{ text.find_last_not_of(chars) }; \n          return text.substr(0, last + 1); \n        }\n```", "```cpp\n        template<typename CharT> \n        inline tstring<CharT> remove(tstring<CharT> text,  \n                                     CharT const ch) \n        { \n          auto start = std::remove_if( \n                          std::begin(text), std::end(text),  \n                          [=](CharT const c) {return c ==  ch; }); \n          text.erase(start, std::end(text)); \n          return text; \n        }\n```", "```cpp\n        template<typename CharT> \n        inline std::vector<tstring<CharT>> split \n           (tstring<CharT> text, CharT const delimiter) \n        {\n          auto sstr = tstringstream<CharT>{ text }; \n          auto tokens = std::vector<tstring<CharT>>{}; \n          auto token = tstring<CharT>{}; \n          while (std::getline(sstr, token, delimiter))  \n          { \n            if (!token.empty()) tokens.push_back(token); \n          } \n          return tokens; \n        }\n```", "```cpp\n    auto ut{ string_library::to_upper(\"this is not UPPERCASE\"s) };  \n    // ut = \"THIS IS NOT UPPERCASE\" \n\n    auto lt{ string_library::to_lower(\"THIS IS NOT lowercase\"s) };  \n    // lt = \"this is not lowercase\"\n```", "```cpp\n    auto rt{string_library::reverse(\"cookbook\"s)}; // rt = \"koobkooc\"\n```", "```cpp\n    auto text1{\"   this is an example   \"s}; \n    // t1 = \"this is an example\" \n    auto t1{ string_library::trim(text1) }; \n    // t2 = \"this is an example   \" \n    auto t2{ string_library::trimleft(text1) }; \n    // t3 = \"   this is an example\" \n    auto t3{ string_library::trimright(text1) };\n```", "```cpp\n    auto chars1{\" !%\\n\\r\"s}; \n    auto text3{\"!!  this % needs a lot\\rof trimming  !\\n\"s}; \n    auto t7{ string_library::trim(text3, chars1) };        \n    // t7 = \"this % needs a lot\\rof trimming\" \n    auto t8{ string_library::trimleft(text3, chars1) };    \n    // t8 = \"this % needs a lot\\rof trimming  !\\n\" \n    auto t9{ string_library::trimright(text3, chars1) };   \n    // t9 = \"!!  this % needs a lot\\rof trimming\"\n```", "```cpp\n    auto text4{\"must remove all * from text**\"s}; \n    auto t10{ string_library::remove(text4, '*') };  \n    // t10 = \"must remove all  from text\" \n    auto t11{ string_library::remove(text4, '!') };  \n    // t11 = \"must remove all * from text**\"\n```", "```cpp\n    auto text5{\"this text will be split   \"s}; \n    auto tokens1{ string_library::split(text5, ' ') };  \n    // tokens1 = {\"this\", \"text\", \"will\", \"be\", \"split\"} \n    auto tokens2{ string_library::split(\"\"s, ' ') };    \n    // tokens2 = {}\n```", "```cpp\n        #include <regex> \n        #include <string> \n        using namespace std::string_literals;\n```", "```cpp\n        auto pattern {R\"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$)\"s};\n```", "```cpp\n        auto rx = std::regex{pattern};\n```", "```cpp\n        auto rx = std::regex{pattern, std::regex_constants::icase}; \n```", "```cpp\n        auto valid = std::regex_match(\"marius@domain.com\"s, rx);\n```", "```cpp\n    ^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$\n```", "```cpp\n    bool is_valid_email_format(std::string const & email) \n    { \n      auto pattern {R\"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$)\"s}; \n\n      auto rx = std::regex{pattern}; \n\n      return std::regex_match(email, rx); \n    }\n```", "```cpp\n    auto ltest = [](std::string const & email)  \n    { \n      std::cout << std::setw(30) << std::left  \n                << email << \" : \"  \n                << (is_valid_email_format(email) ?  \n                   \"valid format\" : \"invalid format\") \n                << std::endl; \n    }; \n\n    ltest(\"JOHN.DOE@DOMAIN.COM\"s);         // valid format \n    ltest(\"JOHNDOE@DOMAIL.CO.UK\"s);        // valid format \n    ltest(\"JOHNDOE@DOMAIL.INFO\"s);         // valid format \n    ltest(\"J.O.H.N_D.O.E@DOMAIN.INFO\"s);   // valid format \n    ltest(\"ROOT@LOCALHOST\"s);              // invalid format \n    ltest(\"john.doe@domain.com\"s);         // invalid format\n```", "```cpp\n    bool is_valid_email_format(std::string const & email) \n    { \n      auto rx = std::regex{ \n        R\"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$)\"s, \n        std::regex_constants::icase}; \n\n      return std::regex_match(email, rx); \n    }\n```", "```cpp\n    template <typename CharT> \n    using tstring = std::basic_string<CharT, std::char_traits<CharT>,  \n                                      std::allocator<CharT>>; \n\n    template <typename CharT> \n    bool is_valid_format(tstring<CharT> const & pattern,  \n                         tstring<CharT> const & text) \n    { \n      auto rx = std::basic_regex<CharT>{  \n        pattern, std::regex_constants::icase }; \n\n      return std::regex_match(text, rx); \n    }\n```", "```cpp\n    bool is_valid_email_format_w(std::wstring const & text) \n    { \n      return is_valid_format( \n        LR\"(^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}$)\"s,  \n        text); \n    } \n\n    auto ltest2 = [](auto const & email) \n    { \n      std::wcout << std::setw(30) << std::left \n         << email << L\" : \" \n         << (is_valid_email_format_w(email) ? L\"valid\" : L\"invalid\") \n         << std::endl; \n    }; \n\n    ltest2(L\"JOHN.DOE@DOMAIN.COM\"s);       // valid\n    ltest2(L\"JOHNDOE@DOMAIL.CO.UK\"s);      // valid\n    ltest2(L\"JOHNDOE@DOMAIL.INFO\"s);       // valid\n    ltest2(L\"J.O.H.N_D.O.E@DOMAIN.INFO\"s); // valid\n    ltest2(L\"ROOT@LOCALHOST\"s);            // invalid\n    ltest2(L\"john.doe@domain.com\"s);       // valid\n```", "```cpp\n    std::tuple<bool, std::string, std::string, std::string>\n    is_valid_email_format_with_result(std::string const & email) \n    { \n      auto rx = std::regex{  \n        R\"(^([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\\.([A-Z]{2,})$)\"s,  \n        std::regex_constants::icase }; \n      auto result = std::smatch{}; \n      auto success = std::regex_match(email, result, rx); \n\n      return std::make_tuple( \n        success,  \n        success ? result[1].str() : \"\"s, \n        success ? result[2].str() : \"\"s,  \n        success ? result[3].str() : \"\"s); \n    }\n```", "```cpp\n    auto ltest3 = [](std::string const & email) \n    { \n      auto [valid, localpart, hostname, dnslabel] =  \n       is_valid_email_format_with_result(email); \n\n      std::cout << std::setw(30) << std::left \n         << email << \" : \" \n         << std::setw(10) << (valid ? \"valid\" : \"invalid\") \n         << \"local=\" << localpart  \n         << \";domain=\" << hostname  \n         << \";dns=\" << dnslabel \n         << std::endl; \n    }; \n\n    ltest3(\"JOHN.DOE@DOMAIN.COM\"s); \n    ltest3(\"JOHNDOE@DOMAIL.CO.UK\"s); \n    ltest3(\"JOHNDOE@DOMAIL.INFO\"s); \n    ltest3(\"J.O.H.N_D.O.E@DOMAIN.INFO\"s); \n    ltest3(\"ROOT@LOCALHOST\"s); \n    ltest3(\"john.doe@domain.com\"s);\n```", "```cpp\n JOHN.DOE@DOMAIN.COM            : valid \n local=JOHN.DOE;domain=DOMAIN;dns=COM \n JOHNDOE@DOMAIL.CO.UK           : valid \n local=JOHNDOE;domain=DOMAIL.CO;dns=UK \n JOHNDOE@DOMAIL.INFO            : valid \n local=JOHNDOE;domain=DOMAIL;dns=INFO \n J.O.H.N_D.O.E@DOMAIN.INFO      : valid \n local=J.O.H.N_D.O.E;domain=DOMAIN;dns=INFO \n ROOT@LOCALHOST                 : invalid \n local=;domain=;dns= \n john.doe@domain.com            : valid \n local=john.doe;domain=domain;dns=com\n```", "```cpp\n        typedef basic_regex<char>    regex; \n        typedef basic_regex<wchar_t> wregex;\n```", "```cpp\n        typedef sub_match<const char *>            csub_match; \n        typedef sub_match<const wchar_t *>         wcsub_match; \n        typedef sub_match<string::const_iterator>  ssub_match; \n        typedef sub_match<wstring::const_iterator> wssub_match;\n```", "```cpp\n        typedef match_results<const char *>            cmatch; \n        typedef match_results<const wchar_t *>         wcmatch; \n        typedef match_results<string::const_iterator>  smatch; \n        typedef match_results<wstring::const_iterator> wsmatch;\n```", "```cpp\n    #remove # to uncomment the following lines \n    timeout=120 \n    server = 127.0.0.1 \n\n    #retrycount=3\n```", "```cpp\n    auto text { \n      R\"( \n        #remove # to uncomment the following lines \n        timeout=120 \n        server = 127.0.0.1 \n\n        #retrycount=3 \n      )\"s};\n```", "```cpp\n        #include <regex> \n        #include <string> \n        using namespace std::string_literals;\n```", "```cpp\n        auto pattern {R\"(^(?!#)(\\w+)\\s*=\\s*([\\w\\d]+[\\w\\d._,\\-:]*)$)\"s};\n```", "```cpp\n        auto rx = std::regex{pattern};\n```", "```cpp\n        auto match = std::smatch{}; \n        if (std::regex_search(text, match, rx)) \n        { \n          std::cout << match[1] << '=' << match[2] << std::endl; \n        }\n```", "```cpp\n        auto end = std::sregex_iterator{}; \n        for (auto it=std::sregex_iterator{ std::begin(text),  \n                                           std::end(text), rx }; \n             it != end; ++it) \n        { \n          std::cout << ''' << (*it)[1] << \"'='\"  \n                    << (*it)[2] << ''' << std::endl; \n        }\n```", "```cpp\n        auto end = std::sregex_token_iterator{}; \n        for (auto it = std::sregex_token_iterator{ \n                          std::begin(text),  std::end(text), rx }; \n             it != end; ++it) \n        { \n          std::cout << *it << std::endl; \n        }\n```", "```cpp\n    ^(?!#)(\\w+)\\s*=\\s*([\\w\\d]+[\\w\\d._,\\-:]*)$\n```", "```cpp\n timeout=120\n```", "```cpp\n 'timeout'='120' \n 'server'='127.0.0.1'\n```", "```cpp\n timeout=120 \n server = 127.0.0.1\n```", "```cpp\n    auto end = std::sregex_token_iterator{}; \n    for (auto it = std::sregex_token_iterator{ std::begin(text),  \n                   std::end(text), rx, 1 }; \n         it != end; ++it) \n    { \n      std::cout << *it << std::endl; \n    }\n```", "```cpp\n    auto end = std::sregex_token_iterator{}; \n    for (auto it = std::sregex_token_iterator{ std::begin(text),  \n                   std::end(text), rx, -1 }; \n         it != end; ++it) \n    { \n      std::cout << *it << std::endl; \n    }\n```", "```cpp\n\n #remove # to uncomment the following lines \n\n #retrycount=3\n```", "```cpp\n        #include <regex> \n        #include <string> \n        using namespace std::string_literals;\n```", "```cpp\n        auto text{\"abc aa bca ca bbbb\"s}; \n        auto rx = std::regex{ R\"(\\b[a|b|c]{3}\\b)\"s }; \n        auto newtext = std::regex_replace(text, rx, \"---\"s);\n```", "```cpp\n        auto text{ \"bancila, marius\"s }; \n        auto rx = std::regex{ R\"((\\w+),\\s*(\\w+))\"s }; \n        auto newtext = std::regex_replace(text, rx, \"$2 $1\"s);\n```", "```cpp\n    auto text{ \"abc aa bca ca bbbb\"s }; \n    auto rx = std::regex{ R\"(\\b[a|b|c]{3}\\b)\"s }; \n    auto newtext = std::regex_replace(text, rx, \"---\"s, \n                     std::regex_constants::format_first_only);\n```", "```cpp\n    auto text{\"this is a example with a error\"s}; \n    auto rx = std::regex{R\"(\\ba ((a|e|i|u|o)\\w+))\"s}; \n    auto newtext = std::regex_replace(text, rx, \"an $1\");\n```", "```cpp\n    auto text{\"today is 1.06.2016!!\"s}; \n    auto rx =  \n       std::regex{R\"((\\d{1,2})(\\.|-|/)(\\d{1,2})(\\.|-|/)(\\d{4}))\"s};       \n    // today is 2016.06.1!! \n    auto newtext1 = std::regex_replace(text, rx, R\"($5$4$3$2$1)\"); \n    // today is [today is ][1.06.2016][!!]!! \n    auto newtext2 = std::regex_replace(text, rx, R\"([$`][$&][$'])\");\n```", "```cpp\n    std::string_view get_filename(std::string_view str) \n    { \n      auto const pos1 {str.find_last_of('')}; \n      auto const pos2 {str.find_last_of('.')}; \n      return str.substr(pos1 + 1, pos2 - pos1 - 1); \n    } \n\n    char const file1[] {R\"(c:\\test\\example1.doc)\"}; \n    auto name1 = get_filename(file1); \n\n    std::string file2 {R\"(c:\\test\\example2)\"}; \n    auto name2 = get_filename(file2); \n\n    auto name3 = get_filename(std::string_view{file1, 16});\n```", "```cpp\n    std::string get_filename(std::string const & str) \n    { \n      auto const pos1 {str.find_last_of('')}; \n      auto const pos2 {str.find_last_of('.')}; \n      return str.substr(pos1 + 1, pos2 - pos1 - 1); \n    } \n\n    auto name1 = get_filename(R\"(c:\\test\\example1.doc)\"); // example1 \n    auto name2 = get_filename(R\"(c:\\test\\example2)\");     // example2 \n    if(get_filename(R\"(c:\\test\\_sample_.tmp)\").front() == '_') {}\n```", "```cpp\n    typedef basic_string_view<char>     string_view; \n    typedef basic_string_view<wchar_t>  wstring_view; \n    typedef basic_string_view<char16_t> u16string_view; \n    typedef basic_string_view<char32_t> u32string_view;\n```", "```cpp\n    std::string_view trim_view(std::string_view str) \n    { \n      auto const pos1{ str.find_first_not_of(\" \") }; \n      auto const pos2{ str.find_last_not_of(\" \") }; \n      str.remove_suffix(str.length() - pos2 - 1); \n      str.remove_prefix(pos1); \n\n      return str; \n    } \n\n    auto sv1{ trim_view(\"sample\") }; \n    auto sv2{ trim_view(\"  sample\") }; \n    auto sv3{ trim_view(\"sample  \") }; \n    auto sv4{ trim_view(\"  sample  \") }; \n\n    auto s1{ sv1.to_string() }; \n    auto s2{ sv2.to_string() }; \n    auto s3{ sv3.to_string() }; \n    auto s4{ sv4.to_string() };\n```"]