- en: Chapter 7. Adding the Looks – Victorian Rush Hour
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。添加外观 – 维多利亚时代高峰时段
- en: '*Now that we have our test game, it''s time to make it all pretty! We''ll go
    over the new sprite elements added to make the game look nice, and cover a new
    topic or two. However, by now, you should be able to understand everything in
    the final code of this project.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在我们有了测试游戏，是时候让它变得漂亮了！我们将介绍添加到游戏中以使其看起来更美观的新精灵元素，并涵盖一个或两个新主题。然而，到目前为止，你应该能够理解这个项目最终代码中的所有内容。*'
- en: '*So you can sit back and relax a bit. This time, I won''t make you type so
    much. Promise!*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*因此，你可以坐下来放松一下。这次，我不会让你打这么多字。我保证！*'
- en: 'In this chapter, you will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: How to use multiple sprites to texture a tiled terrain
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用多个精灵为瓦片地形贴图
- en: How to use multiple containers inside `SpriteBatchNode`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在`SpriteBatchNode`内部使用多个容器
- en: How to create a parallax effect
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建视差效果
- en: How to add a menu to your game
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在你的游戏中添加菜单
- en: How to build a game tutorial
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建游戏教程
- en: Victorian Rush Hour – the game
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维多利亚时代高峰时段 – 游戏画面
- en: Download the `4198_07_START_PROJECT.zip` file from this book's **Support** page
    ([www.packtpub.com/support](http://www.packtpub.com/support)) and run the project
    in Xcode. You should be able to recognize all the work we did in the test version,
    and pinpoint the few extra elements. You will also see that nothing was added
    to the actual gameplay.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的**支持**页面（[www.packtpub.com/support](http://www.packtpub.com/support)）下载`4198_07_START_PROJECT.zip`文件，并在Xcode中运行项目。你应该能够识别出我们在测试版本中所做的所有工作，并定位到一些额外的元素。你还会看到实际的游戏玩法中没有任何新增内容。
- en: In *Victorian Rush Hour*, I wanted to make the terrain the main challenge in
    the game, but I also wanted to show you how easily you can add new elements to
    the buildings and interact with them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在《维多利亚时代高峰时段》中，我想让地形成为游戏中的主要挑战，但我也想向你展示如何轻松地添加新元素到建筑中并与它们交互。
- en: You can later use the same logic to add enemies, obstacles, or pickups for the
    cyclist sprite. All you need to do really is extend the collision detection logic
    to check for the new items. You could, for instance, add umbrellas as pickups,
    and every time the `_player` object floated, he would be minus one umbrella.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以稍后使用相同的逻辑来添加敌人、障碍物或为自行车精灵添加拾取物。你真正需要做的只是扩展碰撞检测逻辑以检查新项目。例如，你可以添加雨伞作为拾取物，每次`_player`对象漂浮时，它就会少一把雨伞。
- en: Next, I'll list the new elements added to the game.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将列出添加到游戏中的新元素。
- en: '![Victorian Rush Hour – the game](img/00024.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![维多利亚时代高峰时段 – 游戏画面](img/00024.jpeg)'
- en: New sprites
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新精灵
- en: 'Quite a few sprites were added to our game:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏中添加了许多精灵：
- en: There is a group of cyclists at the beginning of the game representing the traffic.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏开始时有一群代表交通的自行车手。
- en: We add a background layer (`cityscape`) and a foreground layer (`lamp posts`)
    to help us with our parallax effect. The clouds in the background are also part
    of the effect.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个背景层（`cityscape`）和一个前景层（`lamp posts`），以帮助我们实现视差效果。背景中的云彩也是效果的一部分。
- en: We add chimneys to the buildings. These puff smoke as the player taps the screen.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为建筑添加了烟囱。当玩家点击屏幕时，烟囱会冒烟。
- en: And, of course, the usual stuff—score label, game logo, and a game over message.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，还有常规内容——得分标签、游戏标志和游戏结束信息。
- en: 'In the following screenshot, you can see an image of the `player` sprite and
    the group of cyclists:'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，你可以看到`player`精灵和一群自行车手的图像：
- en: '![New sprites](img/00025.jpeg)'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![新精灵](img/00025.jpeg)'
- en: Animations
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画
- en: 'Some of the sprites now run animation actions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一些精灵现在运行动画动作：
- en: The `_player` sprite runs an animation showing him riding the bicycle (`_rideAnimation`).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_player`精灵运行一个动画，展示他骑自行车的样子（`_rideAnimation`）。'
- en: I also added our old friend, the swinging animation, shown when the `_player`
    sprite is floating (`_floatAnimation`). This is the reason for the odd registration
    point on the cyclist sprite, as the swing animation looks better if the sprite's
    anchor point is not centered.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我还添加了我们老朋友摆动动画，当`_player`精灵漂浮时显示（`_floatAnimation`）。这也是为什么自行车精灵上的注册点看起来很奇怪的原因，因为摆动动画如果精灵的锚点不在中心位置看起来会更好。
- en: Our group of cyclists is also animated during the introduction section of the
    game, and is moved offscreen when the game starts (`_jamAnimate`, `_jamMove`).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏的介绍部分，我们的自行车手团队也被动画化，并在游戏开始时移出屏幕（`_jamAnimate`, `_jamMove`）。
- en: We show a puff of smoke coming out of the chimneys whenever the player jumps.
    This animation is stored inside the new `Block.cpp` class and it's created through
    a series of actions, including a frame animation (`_puffAnimation`, `_puffSpawn`,
    `_puffMove`, `_puffFade`, and `_puffScale`).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家跳跃时，我们显示从烟囱中冒出的烟。这个动画存储在新的 `Block.cpp` 类中，并通过一系列动作创建，包括帧动画 (`_puffAnimation`,
    `_puffSpawn`, `_puffMove`, `_puffFade` 和 `_puffScale`).
- en: In `GameLayer.cpp`, when the `_player` object dies, we run a few actions on
    a `_hat` sprite to make it rise in the air and drop down again, just to add some
    humor.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `GameLayer.cpp` 中，当 `_player` 对象死亡时，我们在 `_hat` 精灵上运行几个动作，使其在空中上升并再次落下，以增加一些幽默感。
- en: Now let's go over the added logic.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下添加的逻辑。
- en: Texturing our buildings with sprites
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用精灵纹理我们的建筑
- en: So in the test version we just coded, our game screen was divided into tiles
    of 128 pixels in the iPad retina screen. The width and height properties of the
    `Block` objects are based on this measurement. So a building two tiles wide and
    three tiles tall would have, in effect, 256 pixels in width and 384 pixels in
    height. A gap too would be measured this way, though its height is set to `0`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们刚刚编写的测试版本中，我们的游戏屏幕被分成了 iPad 视网膜屏幕上 128 像素的瓦片。`Block` 对象的宽度和高度属性基于这个测量。所以一个宽度为两个瓦片、高度为三个瓦片的建筑实际上宽度为
    256 像素，高度为 384 像素。间隙也会这样测量，尽管其高度设置为 `0`。
- en: The logic we use to texture the buildings will take these tiles into account.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于纹理建筑的逻辑将考虑这些瓦片。
- en: '![Texturing our buildings with sprites](img/00026.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![使用精灵纹理我们的建筑](img/00026.jpeg)'
- en: So let's take a look at the code to add texture to our buildings.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看添加纹理到我们建筑物的代码。
- en: Time for action – texturing the buildings
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候进行纹理处理了——给建筑物添加纹理
- en: 'There are a few changes to the way the `initBlock` method runs now:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`initBlock` 方法的运行方式现在有一些变化：'
- en: 'Each block will store references to four different types of texture, representing
    the four types of buildings used in the game (`_tile1`, `_tile2`, `_tile3`, and
    `_tile4`). So we now store that information in the `initBlock` method:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个方块将存储四种不同类型的纹理的引用，代表游戏中使用的四种类型的建筑 (`_tile1`, `_tile2`, `_tile3` 和 `_tile4`)。因此，我们现在在
    `initBlock` 方法中存储这些信息：
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each block also stores references to two types of textures for the building
    roof tile (`_roof1` and `_roof2`):'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '每个方块还存储了两种纹理的引用，用于建筑屋顶瓦片 (`_roof1` 和 `_roof2`):'
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we create and distribute the various sprite tiles that form our building:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建并分配形成我们建筑的各个精灵瓦片：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A block comprises 20 sprites stored inside a `_wallTiles` vector and five sprites
    stored in a `_roofTiles` vector. So, when we initialize a `Block` object, we in
    effect create a building that is five tiles wide and four tiles tall. I made the
    decision that no building in the game would exceed this size. If you decide to
    change this, then here is where you would need to do it.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个方块由 `_wallTiles` 向量中存储的 20 个精灵和 `_roofTiles` 向量中存储的 5 个精灵组成。因此，当我们初始化一个 `Block`
    对象时，实际上创建了一个宽度为五个瓦片、高度为四个瓦片的建筑。我决定游戏中的任何建筑都不会超过这个大小。如果你决定更改这个，那么你需要在的地方进行更改。
- en: The `initBlock` method also creates five chimney sprites and places them at
    the top of the building. These will be spread out later according to the building
    type and could be very easily turned into obstacles for our `_player` sprite.
    We also create the animation actions for the puffs of smoke, here inside `initBlock`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`initBlock` 方法还创建了五个烟囱精灵，并将它们放置在建筑的顶部。这些精灵稍后根据建筑类型分布，很容易变成我们的 `_player` 精灵的障碍。我们还在
    `initBlock` 中创建了烟雾动画动作。'
- en: 'Moving on to our new `setupBlock` method, this is where the unnecessary tiles
    and chimneys are turned invisible and where we spread out the visible chimneys.
    We begin the method as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是我们的新 `setupBlock` 方法，这是将不必要的瓦片和烟囱变为不可见并展开可见烟囱的地方。我们开始这个方法如下：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, based on building type, we give different `x` positions for the chimney
    sprites and determine the texture we''ll use on the wall tiles:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，根据建筑类型，我们为烟囱精灵提供不同的 `x` 位置，并确定我们将用于墙面瓦片的纹理：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The method then proceeds to position the visible chimneys. And we finally move
    to texturing the building. The logic to texture the roof and wall tiles is the
    same; for instance, here''s how the walls are tiled by changing the texture of
    each wall sprite through the `setDisplayFrame` method and then turning unused
    tiles invisible:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后该方法继续定位可见的烟囱。我们最终转向建筑的纹理化。纹理屋顶和墙砖的逻辑是相同的；例如，以下是墙壁如何通过通过`setDisplayFrame`方法更改每个墙精灵的纹理来铺贴，然后使未使用的砖块不可见：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*What just happened?*'
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么事？*'
- en: When we instantiate a block in `initBlock`, we create a 5 x 4 building made
    out of wall tiles and roof tiles, each a sprite. And when we need to turn this
    building into a 3 x 2 building, or a 4 x 4 building, or whatever, we simply turn
    the excess tiles invisible at the end of `setupBlock`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`initBlock`中实例化一个块时，我们创建了一个由墙砖和屋顶砖块组成的5 x 4建筑，每个都是一个精灵。当我们需要将这个建筑变成3 x 2建筑，或4
    x 4建筑，或任何其他建筑时，我们只需在`setupBlock`的末尾将多余的砖块设置为不可见。
- en: The texture used for the roof is picked randomly, but the one picked for the
    walls is based on building type (from our `patterns` array). It is also inside
    this `for` loop that all the tiles positioned at a point greater than the new
    building's width and height are turned invisible.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 屋顶使用的纹理是随机选择的，但墙壁使用的纹理是基于建筑类型（来自我们的`patterns`数组）。它也位于这个`for`循环中，所有定位在新建筑宽度高度点以上的砖块都被设置为不可见。
- en: Containers within containers
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器中的容器
- en: Before we move to the parallax effect logic, there is something I wanted to
    talk about related to the layering of our `_gameBatchNode` object, which you'll
    recall is a `SpriteBatchNode` object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向视差效果逻辑之前，我想谈谈与我们`_gameBatchNode`对象分层相关的一些事情，你可能还记得它是一个`SpriteBatchNode`对象。
- en: 'If you go to the static `create` method inside `Terrain.cpp`, you will notice
    that the object is still created with a reference to a `blank.png` texture:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入`Terrain.cpp`中的静态`create`方法，你会注意到对象仍然使用对`blank.png`纹理的引用创建：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In fact, the same 1 x 1 pixel image used in the test version is now in our sprite
    sheet, only this time the image is transparent.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，测试版本中使用的相同的1 x 1像素图像现在在我们的精灵图集中，只是这次图像是透明的。
- en: This is a bit of a hack, but necessary, because a sprite can only be placed
    inside a batch node if its texture source is the same used to create the batch
    node. But `Terrain` is just a container, it has no texture. However, by setting
    its `blank` texture to something contained in our sprite sheet, we can place `_terrain`
    inside `_gameBatchNode`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种有点黑客式的方法，但却是必要的，因为只有当精灵的纹理源与创建批处理节点使用的纹理相同时，才能将其放置在批处理节点内。但是`Terrain`只是一个容器，它没有纹理。然而，通过将其`blank`纹理设置为包含在我们的精灵图集中的某个东西，我们可以将`_terrain`放置在`_gameBatchNode`中。
- en: The same thing is done with the `Block` class, which now, in the final version
    of the game, behaves like another textureless container. It will contain the various
    sprites for the wall and roof tiles as well as chimneys and puff animations as
    its children.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的操作也应用于`Block`类，现在，在游戏的最终版本中，它表现得像一个没有纹理的容器。它将包含墙壁和屋顶砖块以及烟囱和冒烟动画作为其子项。
- en: The organization of the layers inside our `_gameBatchNode` object can seem complex
    and at times even absurd. After all, in the same node, we have a foreground "layer"
    of lampposts, a middle-ground "layer" of buildings, and a background "layer" containing
    a cityscape. The player is also placed in the background but on top of the cityscape.
    Not only that, but all three layers are moved at different speeds to create our
    parallax effect, and all this inside the same `SpriteBatchNode`!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`_gameBatchNode`对象内部层的组织可能看起来很复杂，有时甚至荒谬。毕竟，在同一个节点中，我们有一个前景“层”的街灯，一个中景“层”的建筑，以及一个背景“层”包含城市景观。玩家也被放置在背景中，但位于城市景观之上。不仅如此，这三个层以不同的速度移动以创建我们的视差效果，所有这些都在同一个`SpriteBatchNode`中！
- en: But the amount of code this arrangement saves us justifies any confusion we
    might have at times when attempting to keep the batch node organized. Now we can
    animate the puffs of smoke, for instance, and never worry about keeping them "attached"
    to their respective `chimney` sprite as the terrain scrolls to the left. The container
    will take care of keeping things together.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种安排为我们节省的代码量足以证明我们在尝试保持批处理节点组织时可能遇到的任何困惑。现在我们可以动画化烟的冒烟，例如，而不用担心当地形向左滚动时将它们“附着”到相应的`chimney`精灵上。容器将负责保持一切在一起。
- en: Creating a parallax effect
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建视差效果
- en: Cocos2d-x has a special node called `ParallaxNode`, and one surprising thing
    about it is how little you get to use it! `ParallaxNode` helps create a parallax
    effect with finite layers, or finite scrolling, which means that you can use it
    if your game screen has a limit to how much it can scroll each way. Implementing
    `ParallaxNode` to a game screen that can scroll indefinitely, such as the one
    in *Victorian Rush Hour*, usually requires more effort than it takes to build
    your own effect.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x有一个名为`ParallaxNode`的特殊节点，关于它的一个令人惊讶的事情是，你实际上很少能用到它！`ParallaxNode`有助于使用有限层或有限滚动创建透视效果，这意味着如果你的游戏屏幕有滚动限制，你可以使用它。将`ParallaxNode`应用于可以无限滚动的游戏屏幕，例如*Victorian
    Rush Hour*中的屏幕，通常需要比构建自己的效果更多的努力。
- en: 'A parallax effect is created by moving objects at different depths at different
    speeds. The farther a layer appears from the screen, the slower its speed should
    be. In a game, this usually means that the player sprite''s speed is fractioned
    to all the layers that appear behind it, and multiplied for the layers that appear
    in front of the player sprite:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在不同深度以不同速度移动对象来创建透视效果。一个层看起来离屏幕越远，其速度应该越慢。在游戏中，这通常意味着玩家精灵的速度被分成所有在其后面的层，并乘以出现在玩家精灵前面的层：
- en: '![Creating a parallax effect](img/00027.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![创建透视效果](img/00027.jpeg)'
- en: Let's add this to our game.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其添加到我们的游戏中。
- en: Time for action – creating a parallax effect
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在是时候创建透视效果了
- en: 'The parallax effect in our game takes place inside the main loop:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的透视效果发生在主循环中：
- en: 'So in our `update` method, you will find the following lines of code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在我们的`update`方法中，你会找到以下代码行：
- en: '[PRE7]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we move the `_background` sprite, which contains the cityscape texture
    repeated three times along the `x` axis, and we move it at one-fourth of the speed
    of the `_player` sprite.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们移动包含城市景观纹理沿`x`轴重复三次的`_background`精灵，并以`_player`精灵的四分之一速度移动它。
- en: 'The `_background` sprite scrolls to the left, and as soon as the first cityscape
    texture is off the screen, we shift the entire `_background` container to the
    right at precisely the spot where the second cityscape texture would appear if
    allowed to continue. We get this value by subtracting where the sprite would be
    from the total width of the sprite:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_background`精灵向左滚动，一旦第一张城市景观纹理离开屏幕，我们就将整个`_background`容器向右移动到第二张城市景观纹理应该出现的位置。我们通过从精灵的总宽度中减去精灵的位置来获取这个值：'
- en: '[PRE8]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, in effect, we only ever scroll the first texture sprite inside the container.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，实际上，我们只滚动容器内的第一个纹理精灵。
- en: 'A similar process is repeated with the `_foreground` sprite and the three lamppost
    sprites it contains. Only the `_foreground` sprite moves at four times the speed
    of the `_player` sprite. These are coded as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`_foreground`精灵及其包含的三个路灯精灵重复类似的过程。只有`_foreground`精灵以玩家精灵的四倍速度移动。这些代码如下所示：
- en: '[PRE9]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We also employ our `cloud` sprites in the parallax effect. Since they appear
    behind the cityscape, so even farther away from `_player`, the clouds move at
    an even lower rate (`0.15`):'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还在透视效果中使用了我们的`cloud`精灵。由于它们出现在城市景观之后，因此距离`_player`更远，云层的移动速度更低（`0.15`）：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*What just happened?*'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just added the parallax effect in our game by simply using the player speed
    at different ratios at different depths. The only slightly complicated part of
    the logic is how to ensure the sprites scroll continuously. But the math of it
    is very simple. You just need to make sure the sprites align correctly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是通过在不同深度使用不同比例的玩家速度，简单地在我们的游戏中添加了透视效果。逻辑中稍微复杂的一部分是如何确保精灵连续滚动。但数学上非常简单。你只需要确保精灵正确对齐。
- en: Adding a menu to our game
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的游戏中添加菜单
- en: Right now, we only see the game logo on our introduction screen. We need to
    add buttons to start the game and also for the option to play a tutorial.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只能在介绍屏幕上看到游戏标志。我们需要添加按钮来开始游戏，以及选择玩教程的选项。
- en: In order to do that, we'll use a special kind of `Layer` class, called `Menu`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用一种特殊的`Layer`类，称为`Menu`。
- en: '`Menu` is a collection of `MenuItems`. The layer is responsible for distributing
    its items as well as tracking touch events on all items. Items can be sprites,
    labels, images, and so on.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Menu`是一组`MenuItems`。层负责分配其项目以及跟踪所有项目上的触摸事件。项目可以是精灵、标签、图像等等。'
- en: '![Adding a menu to our game](img/00028.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![向我们的游戏中添加菜单](img/00028.jpeg)'
- en: Time for action – creating Menu and MenuItem
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在是时候创建菜单和MenuItem了
- en: In `GameLayer.cpp`, scroll down to the `createGameScreen` method. We'll add
    the new logic to the end of this method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameLayer.cpp`中，向下滚动到`createGameScreen`方法。我们将在这个方法的末尾添加新的逻辑。
- en: 'First, create the menu item for our start game button:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建开始游戏按钮的菜单项：
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We create a `MenuItemSprite` object by passing it one sprite per state of the
    button. When the user touches a `MenuItemSprite` object, the off state sprite
    is turned invisible and the on state sprite is turned visible, all inside the
    touch began event. If the touch is ended or cancelled, the off state is displayed
    once again.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们通过为按钮的每个状态传递一个精灵来创建一个`MenuItemSprite`对象。当用户触摸一个`MenuItemSprite`对象时，关闭状态的精灵变为不可见，而开启状态的精灵变为可见，所有这些操作都在触摸开始事件中完成。如果触摸结束或取消，关闭状态将再次显示。
- en: We also pass the callback function for this item; in this case, `GameLayer::StartGame`.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还传递了此项目的回调函数；在这种情况下，`GameLayer::StartGame`。
- en: 'Next, we add the tutorial button:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加教程按钮：
- en: '[PRE12]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then it''s time to create the menu:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后是创建菜单的时间：
- en: '[PRE13]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Menu` constructor can receive as many `MenuItemSprite` objects as you
    wish to display. These items are then distributed with one of the following calls:
    `alignItemsHorizontally`, `alignItemsHorizontallyWithPadding`, `alignItemsHorizontally`,
    `alignItemsVerticallyWithPadding`, `alignItemsInColumns`, and `alignItemsInRows`.
    And the items appear in the order they are passed to the `Menu` constructor.'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Menu`构造函数可以接收你希望显示的任意数量的`MenuItemSprite`对象。这些项目随后通过以下调用进行分布：`alignItemsHorizontally`、`alignItemsHorizontallyWithPadding`、`alignItemsVerticallyWithPadding`、`alignItemsInColumns`和`alignItemsInRows`。项目将按照传递给`Menu`构造函数的顺序显示。'
- en: 'Then we need to add our callback functions:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要添加我们的回调函数：
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These are called when our menu buttons are clicked on, one method to start the
    game and one to show the tutorial.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些是在我们的菜单按钮被点击时调用的，一个用于开始游戏，一个用于显示教程。
- en: '*What just happened?*'
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just created our game's main menu. `Menu` can save us a lot of time handling
    all the interactivity logic of buttons. Though it might not be as flexible as
    other items in Cocos2d-x, it's still good to know it's there if we need it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了游戏的主菜单。`Menu`可以为我们节省很多时间处理按钮的所有交互逻辑。尽管它可能不如Cocos2d-x中的其他项目灵活，但如果我们需要它，了解它的存在仍然是有用的。
- en: We'll tackle the tutorial section next.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节处理教程部分。
- en: Adding a tutorial to our game
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将教程添加到我们的游戏中
- en: Let's face it. With the possible exception of *Air Hockey*, every game so far
    in this book could benefit from a tutorial, or a "how to play" section. With *Victorian
    Rush Hour*, I'm going to show you a quick way to implement one.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们面对现实。除了*空气曲棍球*可能之外，这本书中到目前为止的每个游戏都可以从教程或“如何玩”部分中受益。在*维多利亚时代交通高峰期*中，我将向你展示一种快速实现教程的方法。
- en: The unspoken rule of game tutorials is—make it playable. And that's what we'll
    attempt to do here.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏教程的未言明规则是——使其可玩。这正是我们将在这里尝试的。
- en: 'We''ll create a game state for our tutorial, and we''ll add a `Label` object
    to our stage and make it invisible unless the tutorial state is on. We''ll use
    the `Label` object to display our tutorial text, as shown in the image here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的教程创建一个游戏状态，并将一个`Label`对象添加到我们的舞台中，除非教程状态开启，否则使其不可见。我们将使用`Label`对象来显示我们的教程文本，如图中所示：
- en: '![Adding a tutorial to our game](img/00029.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![将教程添加到我们的游戏中](img/00029.jpeg)'
- en: Let's go over the steps necessary to create our game tutorial.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下创建游戏教程所需的步骤。
- en: Time for action – adding a tutorial
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候添加教程了
- en: Let's move back to our `createGameScreen` method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`createGameScreen`方法。
- en: 'Inside that method, add the following lines to create our `Label` object:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个方法中，添加以下行以创建我们的`Label`对象：
- en: '[PRE15]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We add four states to our enumerated list of game states. These will represent
    the different steps in our tutorial:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在我们的游戏状态枚举列表中添加了四个状态。这些将代表教程中的不同步骤：
- en: '[PRE16]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first tutorial state, `kGameTutorial`, acts as a separator from all other
    game states. So, if the value for `_state` is greater than `kGameTutorial`, we
    are in tutorial mode.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个教程状态`kGameTutorial`作为与其他游戏状态的分隔符。因此，如果`_state`的值大于`kGameTutorial`，我们就处于教程模式。
- en: Now, depending on the mode, we display a different message and we wait on a
    different condition to change to a new tutorial state.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，根据模式的不同，我们显示不同的消息，并等待不同的条件来切换到新的教程状态。
- en: 'If you recall, our `showTutorial` method starts with a message telling the
    player to tap the screen to make the sprite jump:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还记得，我们的`showTutorial`方法从一条消息开始，告诉玩家触摸屏幕使精灵跳跃：
- en: '[PRE17]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, at the end of the `update` method, we start adding the lines that will
    display the rest of our tutorial information. First, if the player sprite is in
    the midst of a jump and has just begun falling, we use the following:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `update` 方法的末尾，我们开始添加显示我们教程剩余信息的行。首先，如果玩家精灵正在跳跃并且刚刚开始下落，我们使用以下代码：
- en: '[PRE18]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we let the player know that another tap will open the umbrella
    and cause the sprite to float.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，我们让玩家知道再次点击将打开雨伞并导致精灵漂浮。
- en: 'Next, as the sprite is floating, when it reaches a certain distance from the
    buildings, we inform the player that another tap will close the umbrella and cause
    the sprite to drop. Here''s the code for these instructions:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，当精灵在空中漂浮时，当它到达建筑物的一定距离时，我们通知玩家，再次点击将关闭雨伞并导致精灵下落。以下是这些指令的代码：
- en: '[PRE19]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After that, the tutorial will be complete and we show the message that the
    player may start the game:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，教程将完成，并显示玩家可以开始游戏的消息：
- en: '[PRE20]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Whenever we change a tutorial state, we pause the game momentarily and wait
    for a tap. We handle the rest of our logic inside `onTouchBegan`, so we'll add
    that next.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当我们更改教程状态时，我们会暂时暂停游戏并等待点击。我们将在 `onTouchBegan` 中处理其余的逻辑，所以我们将稍后添加它。
- en: 'Inside `onTouchBegan`, in the `switch` statement, add the following cases:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onTouchBegan` 函数内部，在 `switch` 语句中，添加以下情况：
- en: '[PRE21]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*What just happened?*'
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We added a tutorial to our game! As you can see, we used quite a few new states.
    But now we can incorporate the tutorial right into our game and have one flow
    smoothly into the other. All these changes can be seen in action in the final
    version of this project, `4198_07_FINAL_PROJECT.zip`, which you can find on this
    book's **Support** page.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的游戏中添加了一个教程！正如你所见，我们使用了相当多的新状态。但现在我们可以将教程直接整合到我们的游戏中，让一个状态流畅地过渡到另一个状态。所有这些更改都可以在项目的最终版本
    `4198_07_FINAL_PROJECT.zip` 中看到，你可以在本书的 **支持** 页面上找到。
- en: Now, you guessed it, let's run it in Android.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经猜到了，让我们在 Android 中运行它。
- en: Time for action – running the game in Android
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 在 Android 中运行游戏
- en: 'Follow these steps to deploy the game to Android:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将游戏部署到 Android：
- en: Open your project's `Android.mk` file in a text editor.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开你项目中的 `Android.mk` 文件。
- en: 'Edit the lines in `LOCAL_SRC_FILES` to read:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `LOCAL_SRC_FILES` 中的行编辑为以下内容：
- en: '[PRE22]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Import the game into Eclipse and wait until all classes are compiled.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏导入 Eclipse 并等待所有类编译完成。
- en: That's it. Save it and run your application.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样。保存并运行你的应用程序。
- en: '*What just happened?*'
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: You now have *Victorian Rush Hour* running in Android.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经可以在 Android 上运行 *维多利亚时代高峰时段* 了。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After we got all the gameplay details ironed out in our test game, bringing
    in a sprite sheet and game states seems remarkably simple and easy.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试游戏中，我们详细调整了游戏玩法后，引入精灵图集和游戏状态看起来非常简单和容易。
- en: But during this stage, we can also think of new ways to improve gameplay. For
    instance, the realization that clouds of smoke coming out of chimneys would offer
    a nice visual cue to the player to identify where the buildings were, if the cyclist
    happened to jump too high. Or that a hat flying through the air could be funny!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这个阶段，我们也可以考虑新的方法来改进游戏玩法。例如，意识到从烟囱冒出的烟雾云可以为玩家提供很好的视觉提示，以识别建筑物的位置，如果骑自行车的人跳得太高。或者，空中飞舞的帽子可能很有趣！
- en: Now it's time to bring physics to our games, so head on to the next chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将物理效果引入我们的游戏了，所以继续阅读下一章。
