- en: Memory Management and Smart Pointers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您可以在此章节中找到使用的源文件[https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)。
- en: Memory management comes at a price in C++. Concerned programmers often complain
    about C++ because of its manual memory management requirements. While languages
    like C# and Java use automatic memory management, it makes the programs run slower
    than their C++ counterparts. Manual memory management is often error-prone and
    unsafe. As we have already seen in the previous chapters, a program represents
    data and instructions. Almost every program uses computer memory to some extent.
    It's hard to imagine a useful program that doesn't require memory allocation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 技术要求
- en: Memory allocation and deallocation starts with the simplest call of a function.
    Calling a function usually implies passing arguments to it. The function needs
    space to store those arguments. To make life easier, it's handled automatically.
    The same automatic allocation happens when we declare objects in the code. Their
    lifetime depends on the scope they have declared. Whenever they go out of scope,
    they will be deallocated automatically. Most programming languages provide similar
    automatic deallocation functionality for dynamic memory. The dynamically allocated
    memory – as opposed to automatic allocation – is a term used by programmers to
    identify code portions that request new memory upon requirements. For example,
    this would be used in a program storing the list of customers' requests for new
    memory space upon the increase of the number of customers. To somehow differentiate
    between *types* of memory management, whether it's automatic or manual, programmers
    use memory segmentation. A program operates with several segments of memory, the
    stack, the heap, the read-only segment, and so on, although all of them have the
    same structure and are part of the same virtual memory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配和释放始于对函数的简单调用。调用函数通常意味着向其传递参数。函数需要空间来存储这些参数。为了简化生活，这些都是自动处理的。当我们在代码中声明对象时，同样会发生自动分配。它们的生命周期取决于它们声明的范围。无论何时它们超出范围，它们都将被自动释放。大多数编程语言为动态内存提供类似的自动释放功能。动态分配的内存
    - 与自动分配相对 - 是程序员用来识别根据需求请求新内存的代码部分的术语。例如，在存储客户请求列表的程序中，当客户数量增加时会使用这种功能来请求新的内存空间。
- en: Most languages provide simplified methods for accessing dynamic memory without
    being concerned with its deallocation strategies, leaving the hard work up to
    the runtime support environment. C++ programmers have to deal with the low-level
    details of memory management. Whether it's due to the philosophy, structure, or
    age of the language, C++ doesn't provide high-level memory management functionality.
    Therefore, a deep understanding of memory structure and its management is a must
    for every C++ programmer. Let's now illuminate the mystery behind memory and proper
    memory management techniques in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言提供了简化的方法来访问动态内存，而不必担心其释放策略，将繁重的工作留给运行时支持环境。C++程序员必须处理内存管理的低级细节。无论是由于语言的哲学、结构还是年龄，C++都没有提供高级内存管理功能。因此，对内存结构及其管理的深入理解对于每个C++程序员来说都是必不可少的。让我们在本章中揭示内存和适当的内存管理技术背后的奥秘。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用电路、继电器和逻辑门来设计一个能够存储位的简单设备。本节的目的是了解内存在其最低级别的结构。在本章中，我们将涵盖以下主题：
- en: What is memory and how do we access it in C++?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是内存，我们如何在C++中访问它？
- en: Memory allocation in detail
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很难描述设备如何存储这些变量。为了在那个神奇的过程中投下一些光芒，让我们试着设计一个存储一点信息的设备。
- en: Memory management techniques and idioms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理技术和习惯用法
- en: Garbage collection basics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细的内存分配
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾收集基础知识
- en: The `g++` compiler with the option `-std=c++2a` is used to compile the examples
    throughout the chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`g++`编译器和选项`-std=c++2a`编译本章中的示例。
- en: You can find the source files used in this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低级别的表示中，内存是一个存储位状态的设备。假设我们正在发明一个可以存储单个位信息的设备。现在，这似乎既毫无意义又神奇。毫无意义是因为发明已经在很久以前就已经发明了。神奇是因为程序员现在有幸福的稳定多功能环境，提供了大量的库、框架和工具来创建程序，甚至不需要了解它们的内部工作。声明变量或分配动态内存已经变得非常容易，就像下面的代码片段所示：
- en: Understanding computer memory
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中，内存管理是有代价的。关心的程序员经常抱怨C++因为它需要手动内存管理。而像C#和Java这样的语言使用自动内存管理，使得程序运行速度比它们的C++对应程序慢。手动内存管理经常容易出错和不安全。正如我们在前几章中已经看到的，程序代表数据和指令。几乎每个程序都在某种程度上使用计算机内存。很难想象一个有用的程序不需要内存分配。
- en: 'At the lowest level of representation, the memory is a device that stores the
    state of a bit. Let''s say we are inventing a device that can store a single bit
    of information. Nowadays, it seems both meaningless and magical at the same time.
    It''s meaningless to invent something that has already been invented, a long time
    ago. It''s magical because programmers nowadays have the luxury of stable multifunctional
    environments providing tons of libraries, frameworks, and tools to create programs
    without even understanding them under the hood. It has become ridiculously easy
    to declare a variable or allocate a dynamic memory, as shown in the following
    code snippet:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 理解计算机内存
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's hard to describe how the device stores these variables. To somehow shed
    some light on that magical process, let's try to design a device that stores a
    bit of information.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在内存管理的*类型*之间进行某种区分，无论是自动还是手动，程序员都使用内存分段。程序操作多个内存段，堆栈、堆、只读段等等，尽管它们都具有相同的结构并且是同一虚拟内存的一部分。
- en: Designing a memory storage device
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个内存存储设备
- en: We will use electrical circuits, relays, and logic gates to design a simple
    device able to store a bit. The purpose of this section is to understand the structure
    of the memory at its lowest level.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理和智能指针
- en: 'Here''s a simple illustration of an electric circuit that would be familiar
    to you from physics classes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的电路示例，您可能在物理课上熟悉：
- en: '![](img/e049c87e-55a0-431d-96bf-28b605e4c07e.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e049c87e-55a0-431d-96bf-28b605e4c07e.png)'
- en: 'It consists of a **wire** connecting the battery to the **light bulb**. The
    **wire** has a **switch** that controls the state of the light bulb. The **light
    bulb** is on when the switch is closed, otherwise, it''s off. We will add to this
    circuit two NOR logical elements. The NOR is short for Not OR. It''s usually represented
    the following way:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它由一根连接电池和灯泡的**导线**组成。**导线**上有一个控制灯泡状态的**开关**。当开关关闭时，灯泡亮起，否则灯泡熄灭。我们将在这个电路中添加两个NOR逻辑元件。NOR是非或的缩写。通常用以下方式表示：
- en: '![](img/4072ad42-c9a2-495f-aee5-06d736ddb9c9.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4072ad42-c9a2-495f-aee5-06d736ddb9c9.png)'
- en: 'It has two inputs (the wires leading into the element), each of which represents
    an electrical signal. We say that the output (the wire coming out from the element)
    is 1 if both inputs are 0\. That''s why we call it *Not OR* because the OR element
    outputs 1 if any of its inputs are 1\. The preceding NOR element is simply constructed
    using two relays. A relay is a switch that uses an electromagnet to close and
    open the contacts. Look at the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个输入（导线引入元件），每个代表一个电信号。如果两个输入都为0，我们说输出（从元件出来的导线）为1。这就是为什么我们称它为*非或*，因为如果任何一个输入为1，OR元件就会输出1。前述NOR元件只是使用两个继电器构建的。继电器是使用电磁铁来闭合和打开触点的开关。看看下面的图表：
- en: '![](img/99bb5ce8-b8cc-4b27-b767-ec65c76b7ddc.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99bb5ce8-b8cc-4b27-b767-ec65c76b7ddc.png)'
- en: 'When both **switches** of **relays** are closed (meaning the **relays** are
    working and pulling down the **switches** of the circuit), the light bulb is *off*.
    When we move the **switch** to the open position of both **relays**, the light
    bulb turns *on*. The preceding diagram is one of the ways to depict a NOR gate.
    At this point, we can create a logic element using electric wires, light bulbs,
    batteries, and relays. Now let''s see a strange combination of two NOR elements
    leading to an interesting discovery:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当**继电器**的两个**开关**关闭（意味着**继电器**正在工作并拉下电路的**开关**）时，灯泡是*关闭*的。当我们将**继电器**的两个**开关**移动到开放位置时，灯泡就会*亮起*。上图是描述NOR门的一种方式。此时，我们可以使用电线、灯泡、电池和继电器创建逻辑元件。现在让我们看看两个NOR元件的奇怪组合，引发了一个有趣的发现：
- en: '![](img/767e57ea-e066-4eef-b2eb-afc2868604c2.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/767e57ea-e066-4eef-b2eb-afc2868604c2.png)'
- en: The preceding diagram is the typical representation of an **R-S flip-flop**.
    **R** is for *reset*, **S** is for *set*. The device built by the preceding scheme
    can store one bit. The output **Q** is the wire from which we can read the contents
    of the device. If we set the flip-flop to store the bit, the output will be 1\.
    You should carefully examine the diagram and imagine passing signals to its inputs
    one by one or both at the same time and see the output at **Q**. When the input
    **S** is 1, **Q** becomes 1\. When **R** is 1, **Q** becomes 0\. This way we *set*
    or *reset* the bit. It will store the bit as long as we supply current to the
    device.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上图是典型的**R-S触发器**的表示。**R**代表*复位*，**S**代表*设置*。前述方案构建的设备可以存储一个位。输出**Q**是我们可以读取设备内容的导线。如果我们设置触发器来存储位，输出将为1。您应该仔细检查图表，并想象逐个或同时向其输入传递信号，并查看**Q**的输出。当输入**S**为1时，**Q**变为1。当**R**为1时，**Q**变为0。这样我们就可以*设置*或*复位*位。只要我们向设备提供电流，它就会存储位。
- en: Now imagine having a lot of devices as designed earlier interconnected together
    so that we will store more than one bit of information. This way, we can construct
    complex memory devices storing bytes or even **kilobytes** (**KB**), of data.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，将之前设计的许多设备相互连接，以便存储多于一个位的信息。这样，我们可以构建复杂的内存设备，存储字节甚至**千字节**（**KB**）的数据。
- en: The preceding device is similar to those used in computers before the invention
    of transistors. A transistor is a much smaller device capable of storing bits.
    Transistors differ in types. Modern devices don't use relays; instead, they incorporate
    millions of transistors to store and manipulate data. A **Central Processing Unit**
    (**CPU**) register is an example of a device that leverages transistors to store
    a specified amount of bits. Usually, a general-purpose register stores up to 64
    bits of data. However, you can't store all your programs and data using only registers.
    The organization of computer memory is much more sophisticated. Let's now move
    on to examining the hierarchy of computer memory from a higher-level perspective.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前述设备类似于在晶体管发明之前计算机中使用的设备。晶体管是一种更小的设备，能够存储位。晶体管有不同的类型。现代设备不使用继电器；相反，它们集成了数百万个晶体管来存储和操作数据。**中央处理单元**（**CPU**）寄存器就是利用晶体管存储指定数量位的设备的一个例子。通常，通用寄存器最多可以存储64位数据。但是，您不能仅使用寄存器来存储所有程序和数据。计算机内存的组织要复杂得多。现在让我们从更高层次的角度来研究计算机内存的层次结构。
- en: Understanding computer memory from a higher-level perspective
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从更高层次的角度理解计算机内存
- en: Knowing the details of computer memory and data storage is crucial in writing
    professional programs. When programmers refer to the term *memory*, most of the
    time they mean the virtual memory. Virtual memory is an abstraction supported
    by the **Operating System** (**OS**) that controls and provides memory space for
    processes. Each process has its address space represented as a collection of several
    segments. We discussed what memory segments there are and how a given program
    uses each in [Chapter 2](06590f85-3b2c-4909-8bf0-a6a6f5d07c22.xhtml), *Low-Level
    Programming with C++*. From the programmer's perspective, accessing a memory space
    is mostly limited to an object declaration and use. Whether we declare an object
    on the stack, heap, or static memory, we access the same memory abstraction –
    the virtual memory. Although complicated, virtual memory makes life a lot easier.
    Working directly with physical memory is harder, although it is a great advancement
    in a programmer's skills. You should at least know what memory storage units there
    are and how you can leverage that knowledge to write better code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 了解计算机内存和数据存储的细节对于编写专业程序至关重要。当程序员提到“内存”一词时，大多数情况下他们指的是虚拟内存。虚拟内存是由操作系统（OS）支持的抽象，用于控制和为进程提供内存空间。每个进程都有其地址空间，表示为几个段的集合。我们在《使用C++进行低级编程》的第2章中讨论了有哪些内存段，以及给定程序如何使用每个内存段。从程序员的角度来看，访问内存空间主要限于对象声明和使用。无论我们在堆栈、堆还是静态内存中声明对象，我们都访问相同的内存抽象——虚拟内存。虽然复杂，但虚拟内存使生活变得更加轻松。直接使用物理内存更加困难，尽管这是程序员技能的重大进步。你至少应该知道有哪些内存存储单元，以及如何利用这些知识来编写更好的代码。
- en: In this section, we have discussed the physical memory hierarchy. We call it
    a *hierarchy* because each memory unit at a lower level provides faster access
    but a smaller space. Each consecutively higher level of memory provides more space
    in exchange for slower access.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经讨论了物理内存层次结构。我们称之为“层次结构”，因为较低级别的每个内存单元提供更快的访问速度，但空间较小。每个连续更高级别的内存提供更多的空间，但访问速度较慢。
- en: 'We discuss the physical memory hierarchy because it will help us design better
    code. Knowing how memory works at each level improves us as programmers and allows
    us to organize data manipulation better. The following diagram illustrates the
    memory hierarchy:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论物理内存层次结构是因为它将帮助我们设计更好的代码。了解每个级别的内存如何工作可以提高我们作为程序员的水平，并使我们能够更好地组织数据操作。以下图表说明了内存层次结构：
- en: '![](img/3485e166-6d8d-4a59-8fe8-da8e249cd123.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: （图片）
- en: Registers are the fastest accessible memory units placed in the CPU. The number
    of registers is limited so we can't keep all the program data in them. On the
    other hand, **Dynamic RAM** (**DRAM**) is able to store a wide range of data for
    the program. It takes much longer to access data from the DRAM because of its
    physical structure and distance from the CPU. The CPU accesses DRAM via the data
    bus, which is a set of wires transferring data between the CPU and DRAM. To signal
    to the DRAM controller whether it will read or write data, the CPU uses the control
    bus. We will refer to DRAM as the *main memory*. Let's look at the memory hierarchy in
    detail.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器是放置在CPU中的最快可访问的内存单元。寄存器的数量是有限的，因此我们无法将所有程序数据都保存在其中。另一方面，动态RAM能够存储程序的各种数据。由于其物理结构和与CPU的距离，从DRAM中访问数据需要更长的时间。CPU通过数据总线访问DRAM，数据总线是一组在CPU和DRAM之间传输数据的导线。为了向DRAM控制器发出读取或写入数据的信号，CPU使用控制总线。我们将DRAM称为“主内存”。让我们详细看看内存层次结构。
- en: Registers
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寄存器
- en: Registers hold a fixed amount of data. The CPU word size is usually defined
    by the maximum length of a register, for example, eight bytes or four bytes. We
    can't directly access a register from a C++ program.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器保存固定数量的数据。CPU字长通常由寄存器的最大长度定义，例如八字节或四字节。我们无法直接从C++程序中访问寄存器。
- en: C++ supports embedding assembly code using the `asm` declaration, for example,
    `asm("mov edx, 4")`. It's a platform-specific and artificial augmentation to the
    code, so we don't suggest using it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: C++支持使用“asm”声明嵌入汇编代码，例如“asm("mov edx, 4")”。这是一种特定于平台的人为代码增强，因此我们不建议使用它。
- en: 'In older versions of the language, we could use the `register` keyword when
    declaring a variable:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在较早版本的语言中，我们可以在声明变量时使用“register”关键字：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The modifier specified the compiler to store the variable in the register. This
    way, it gave programmers a fake sense of code optimization.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符指定编译器将变量存储在寄存器中。这样，它给程序员一种虚假的代码优化感觉。
- en: Compilers are sophisticated tools translating higher-level C++ code into machine
    code. In the translation process, the code takes several transformations, including
    code optimizations. When programmers apply *tricks* to force the compiler to optimize
    a portion of the code, the compiler takes them as suggestions rather than commands.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器是将高级C++代码转换为机器代码的复杂工具。在翻译过程中，代码经历了多次转换，包括代码优化。当程序员对代码的一部分应用“技巧”来强制编译器优化时，编译器将其视为建议而不是命令。
- en: 'For example, accessing a variable in a loop will be faster if that variable
    is placed in a register rather than in the DRAM. For example, the following loop
    accesses objects one million times:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在循环中访问变量，如果将该变量放在寄存器中而不是DRAM中，访问速度将更快。例如，以下循环一百万次访问对象：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As we know, the `number` has an automatic storage duration (it has nothing
    to do with the `auto` keyword) and is placed on the stack. The stack is a segment
    in the virtual memory, and the virtual memory is an abstraction over the physical
    DRAM. It''s way faster to access the object in a register than in DRAM. Let''s
    suppose reading the value of `number` from the DRAM is five times slower than
    from a `register`. It might seem obvious to optimize the preceding loop using
    the `register` keyword, as shown:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，`number`具有自动存储期限（与`auto`关键字无关），并放置在堆栈上。堆栈是虚拟内存中的一个段，虚拟内存是对物理DRAM的抽象。从寄存器中访问对象比从DRAM中访问对象要快得多。假设从DRAM中读取`number`的值比从`寄存器`中读取的值慢五倍。显然，通过使用`寄存器`关键字来优化前面的循环似乎是显而易见的，如下所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, compilers make better optimizations nowadays, so the need for the modifier
    has faded over time and it is now a deprecated language feature. A better optimization
    would be getting rid of the `number` object altogether.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在编译器进行了更好的优化，因此对修改器的需求随着时间的推移而减弱，现在已经是一个不推荐使用的语言特性。更好的优化是完全摆脱`number`对象。
- en: 'For example, the following code represents the compile-optimized version that
    uses the actual value rather than accessing it via the variable that resides in
    the DRAM:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码表示使用实际值而不是通过驻留在DRAM中的变量访问该值的编译优化版本：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Although the preceding example is arguably simple, we should consider compiler
    optimizations that take place during compilation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的示例可以说是简单的，但我们应该考虑在编译过程中进行的编译器优化。
- en: 'Discovering the registers improves our understanding of program execution details.
    The point is that everything the CPU performs happens via the registers, including
    the instructions that the CPU should decode and execute are accessed using a specific
    register, commonly referred to as the **instruction pointer**. When we run the
    program, the CPU accesses its instructions and decodes and executes them. Reading
    data from the main memory and writing data to the memory is performed by copying
    it from and to the registers. Usually, general-purpose registers are used to temporarily
    hold data while the CPU performs operations on it. The following diagram depicts
    an abstract view of the **CPU** and its interaction with the main memory via buses:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 发现寄存器可以提高我们对程序执行细节的理解。关键是CPU执行的所有操作都是通过寄存器进行的，包括CPU应该解码和执行的指令都是使用特定的寄存器访问的，通常称为**指令指针**。当我们运行程序时，CPU访问其指令并解码和执行它们。从主存中读取数据和向内存写入数据是通过从寄存器复制数据来执行的。通常，通用寄存器用于在CPU对其执行操作时临时保存数据。以下图表描述了**CPU**及其通过总线与主存的交互的抽象视图：
- en: '![](img/b98cbe03-4c6c-4b6c-acb8-5079eee59237.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b98cbe03-4c6c-4b6c-acb8-5079eee59237.png)'
- en: As you can see, the communication between the CPU and DRAM happens via various
    buses. In [Chapter 2](06590f85-3b2c-4909-8bf0-a6a6f5d07c22.xhtml), *Low-Level
    Programming with C++*, we discussed the low-level representation of C++ programs
    – you should take a quick look at that to better understand the following example.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，CPU和DRAM之间的通信是通过各种总线进行的。在[第2章](06590f85-3b2c-4909-8bf0-a6a6f5d07c22.xhtml)中，我们讨论了C++程序的低级表示
    - 您应该快速查看以更好地理解以下示例。
- en: 'Now, let''s see registers in action. The following C++ code declares two variables
    and stores their sum in the third variable:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看寄存器的运行情况。以下C++代码声明了两个变量，并将它们的和存储在第三个变量中：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To execute the sum instruction, the CPU moves values of variables `a` and `b`
    into its registers. After calculating the sum, it then moves the result into another
    register. An assembler pseudo-code representation of the program looks similar
    to the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行求和指令，CPU将变量`a`和`b`的值移入其寄存器。在计算总和后，它将结果移入另一个寄存器。程序的汇编伪代码表示类似于以下内容：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It's not mandatory for the compiler to generate code that maps each variable
    to one register – the number of registers is limited. You just need to remember
    that you should keep regularly accessed variables small enough to fit into one
    of the registers. For larger objects, the cache memory comes to the rescue. Let's
    see how.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不一定要生成将每个变量映射到一个寄存器的代码 - 寄存器的数量是有限的。您只需要记住，应该将经常访问的变量保持足够小，以适应其中一个寄存器。对于较大的对象，高速缓存内存会发挥作用。让我们看看。
- en: Cache memory
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高速缓存内存
- en: 'The idea of caching is common in programming and computer systems. Images loaded
    in the browser are cached to avoid further requests to the web server to download
    it in case the user visits the website again in the future. Caching makes programs
    run faster. The concept can be leveraged in many forms, including in single functions.
    For example, the following recursive function calculates the factorial of a number:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的概念在编程和计算机系统中很常见。在浏览器中加载的图像会被缓存，以避免在用户再次访问网站时向Web服务器发出进一步的请求以下载它。缓存使程序运行更快。这个概念可以以许多形式利用，包括在单个函数中。例如，以下递归函数计算一个数字的阶乘：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The function doesn''t remember its previously calculated values, so the following
    calls lead to five and six recursive calls, respectively:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数不记得其先前计算的值，因此以下调用分别导致五次和六次递归调用：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can cache already calculated values at each step by storing them in a globally
    accessible variable, as shown:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将它们存储在全局可访问的变量中来缓存每一步已计算的值。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The modifications optimize further calls to the function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 修改进一步调用函数的优化：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The same way the concept of caching makes the factorial function run faster,
    an actual memory device named the **cache** is placed inside the CPU. This device
    stores recently accessed data in order to make further access to that data faster.
    The following diagram depicts **registers** and **cache memory** inside the CPU:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与缓存概念使阶乘函数运行更快的方式相同，CPU内部实际存储设备名为**缓存**。该设备存储最近访问的数据，以便使对该数据的进一步访问更快。以下图表描述了CPU内部的**寄存器**和**缓存内存**：
- en: '![](img/3ab977f8-8e12-4e36-b903-b72c9da9b7ff.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ab977f8-8e12-4e36-b903-b72c9da9b7ff.png)'
- en: 'The cache size usually ranges from 2 KB to 64 KB (and, rarely, 128 KB). While
    it doesn''t seem big enough for applications such as Photoshop, where the image
    data size can be way bigger than the cache size itself, it really does help in
    many scenarios. For example, suppose we store more than 1,000 numbers in a vector:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的大小通常范围从2KB到64KB（很少为128KB）。虽然对于诸如Photoshop之类的应用程序来说，缓存的大小可能远远不够，因为图像数据的大小可能远远大于缓存本身，但在许多情况下，它确实会有所帮助。例如，假设我们在一个向量中存储了超过1000个数字：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following code prints the vector items:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码打印向量项：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Suppose that to print the item, the **CPU** copies it from memory to the rax
    register, then calls the operator `<<`, which prints the value of the rax to the
    screen. On each iteration of the loop, the **CPU** copies the next item of the
    vector into the rax register and calls the function to print its value. Each copy
    operation requires the **CPU** to place the address of the item on the **address
    bus** and set the **control bus** to a read mode. The **DRAM** microcontroller
    accesses the data by the address received by the address bus and copies its value
    to the data bus, thereby sending the data to the **CPU**. The **CPU** directs
    the value to the rax register and then executes instructions to print its value.
    The following diagram shows this interaction between the **CPU** and **DRAM**:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设要打印该项，**CPU**将其从内存复制到rax寄存器，然后调用运算符`<<`，将rax的值打印到屏幕上。在循环的每次迭代中，**CPU**将向rax寄存器复制向量的下一项，并调用函数打印其值。每次复制操作都需要**CPU**将该项的地址放在**地址总线**上，并将**控制总线**设置为读模式。**DRAM**微控制器通过地址总线接收到的地址访问数据，并将其值复制到数据总线，从而将数据发送给**CPU**。**CPU**将值传递给rax寄存器，然后执行指令打印其值。下图显示了**CPU**和**DRAM**之间的交互：
- en: '![](img/38e99ee6-c6b8-4007-8a8b-3705975066fd.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38e99ee6-c6b8-4007-8a8b-3705975066fd.png)'
- en: 'To optimize the loop, the CPU maintains an idea of data locality, that is, it
    copies the whole vector into the cache and accesses vector items from the cache,
    omitting the unnecessary requests to DRAM. In the following diagram, you can see
    that the data received from the DRAM via the data bus is then stored in the **cache
    memory**:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化循环，CPU保持了**数据局部性**的概念，即将整个向量复制到缓存中，并从缓存中访问向量项，省略了对DRAM的不必要请求。在下图中，您可以看到通过数据总线从DRAM接收的数据然后存储在**缓存内存**中：
- en: '![](img/a638de34-c3d8-4c57-9edc-078fb8563b94.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a638de34-c3d8-4c57-9edc-078fb8563b94.png)'
- en: The cache residing in the CPU is known as **level 1** (**L1**) **cache**. This
    is the smallest in capacity and resides inside the CPU. Many architectures have
    **level 2** (**L2**) **cache**, which resides outside the CPU (though closer than
    the main memory) and is accessed the same way as the DRAM. The difference between
    the L2 Cache and DRAM is the physical structure and data access patterns. The
    L2 Cache represents **Static RAM** (**SRAM**), which is faster than DRAM but also
    is much more expensive.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在CPU中的缓存被称为**一级**（**L1**）**缓存**。这是容量最小的缓存，位于CPU内部。许多体系结构都有**二级**（**L2**）**缓存**，它位于CPU外部（尽管比主存储器更接近），并且与DRAM的访问方式相同。L2缓存和DRAM之间的区别在于物理结构和数据访问模式。L2缓存代表**静态RAM**（**SRAM**），比DRAM更快，但也更昂贵。
- en: Some runtime environments leverage the idea of caching when implementing garbage
    collection. They separate the objects into categories based on their lifetime
    with objects that have the smallest lifetime, such as the ones allocated in the
    local scope of the code, being placed in the cache both to be accessed and deallocated
    faster.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一些运行时环境在实现垃圾回收时利用了缓存的概念。它们根据对象的生命周期将对象分成不同的类别，生命周期最短的对象，比如在代码的局部范围内分配的对象，被放入缓存中以便更快地访问和释放。
- en: New levels of cache memories serve as caches for the lower level. For example,
    the L2 Cache serves as a cache memory for the L1 Cache. When the CPU encounters
    a cache miss, it requests the L2 Cache, and so on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 新的缓存级别用作较低级别的缓存。例如，L2缓存用作L1缓存的缓存内存。当CPU遇到缓存未命中时，它会请求L2缓存，依此类推。
- en: Main memory
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主存储器
- en: The physical structure of the DRAM forces it to refresh its charge to keep the
    data stable, while the SRAM doesn't need to be refreshed like DRAM. We call DRAM
    the main memory mostly because programs are loaded into it; the OS maintains virtual
    memory and maps it to DRAM. All the actual work happens through the main memory
    first.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: DRAM的物理结构迫使它刷新其电荷以保持数据稳定，而SRAM不需要像DRAM那样刷新。我们之所以称DRAM为主存储器，主要是因为程序加载到其中；操作系统维护虚拟内存并将其映射到DRAM。所有实际的工作都是通过主存储器进行的。
- en: As we already discussed, the main memory represents a sequence of addressable
    bytes of data. Each byte has its own unique address and is accessed using that
    address. We mentioned earlier how the CPU places the address of the data on the
    address bus, thereby letting the DRAM microcontroller fetch the requested data
    and send it via the data bus.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，主存储器代表了一系列可寻址的数据字节。每个字节都有自己独特的地址，并且可以使用该地址进行访问。我们之前提到过，CPU将数据的地址放在地址总线上，从而让DRAM微控制器获取请求的数据并通过数据总线发送出去。
- en: 'As we know, the OS introduces virtual memory as an abstraction over the physical
    memory. It maps the contents of the virtual memory to the physical memory, which
    involves the CPU''s **Translation Lookaside Buffer** (**TLB**). The TLB is another
    form of cache memory: it stores the recent translations of **virtual memory**
    to **physical memory**, thereby caching it for future requests. As shown in the
    following diagram, the **CPU** coordinates with the **TLB** in order to properly
    translate virtual addresses to physical addresses:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，操作系统引入了虚拟内存作为对物理内存的抽象。它将虚拟内存的内容映射到物理内存，这涉及到CPU的**转换旁路缓存**（**TLB**）。TLB是另一种缓存内存的形式：它存储了**虚拟内存**到**物理内存**的最近转换，从而为将来的请求进行缓存。如下图所示，**CPU**与**TLB**协调以正确地将虚拟地址转换为物理地址：
- en: '![](img/38b916ec-a8a1-40f4-aa32-f99bc44eaebf.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38b916ec-a8a1-40f4-aa32-f99bc44eaebf.png)'
- en: Though memory management is sophisticated, the OS provides us a simple enough
    abstraction to manage memory required for our programs. We have the ability to
    allocate it either automatically using the stack, or dynamically on the heap.
    The automatic memory allocation actually doesn't involve many concerns and difficulties;
    we just declare objects and they are placed on the stack and then automatically
    removed whenever the execution leaves the scope. In the case of dynamic memory
    (not to be confused with the hardware DRAM mentioned earlier), both the allocation
    and deallocation should be done manually, which creates possibilities for making
    errors leading to memory leaks.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管内存管理很复杂，但操作系统为我们提供了一个足够简单的抽象来管理程序所需的内存。我们有能力使用堆栈自动分配内存，也可以在堆上动态分配内存。自动内存分配实际上并不涉及太多问题和困难；我们只需声明对象，它们就会放在堆栈上，然后在执行离开作用域时自动删除。在动态内存的情况下（不要与前面提到的硬件DRAM混淆），分配和释放都应该手动完成，这会导致可能导致内存泄漏的错误。
- en: Permanent storage
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 永久存储
- en: When we turn off the computer, the contents of the main memory are erased (because
    the charge is not refreshed anymore). To store the data permanently even when
    the power is off, computers are equipped with a **Hard Disk Drive** (**HDD**)
    or a **Solid-State Drive** (**SSD**). From the perspective of programmers, permanent
    storage is used to store programs with their necessary data. We already know that
    in order to run a program, it should be loaded into the main memory, that is, copied
    from the HDD to the DRAM. The OS handles it using the loader and creates a program
    image in memory, commonly referred to as a process. When the program is done or
    the user closes it, the OS marks the address range of the process as free to use.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们关闭计算机时，主内存的内容会被擦除（因为电荷不再刷新）。为了在断电时永久存储数据，计算机配备了硬盘驱动器（HDD）或固态硬盘驱动器（SSD）。从程序员的角度来看，永久存储用于存储程序及其必要的数据。我们已经知道，为了运行程序，它应该被加载到主内存中，也就是从硬盘驱动器复制到DRAM中。操作系统使用加载器处理这个过程，并在内存中创建一个程序映像，通常称为进程。当程序完成或用户关闭它时，操作系统将进程的地址范围标记为可用。
- en: Let's suppose we use a text editor to write notes while learning C++. The text
    typed into the editor resides in the main memory unless we save it on the HDD.
    This is important to note because most programs keep track of recent user activity
    and also allow the user to modify program settings. To keep these settings the
    way the user modified them even after the program is relaunched, the program stores
    them as a separate *settings* file on the HDD. The next time the program runs,
    it first reads the corresponding settings file or files from the HDD and updates
    itself to apply the recent modifications of settings.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用文本编辑器在学习C++时写笔记。在编辑器中键入的文本将驻留在主内存中，除非我们将其保存在硬盘驱动器上。这一点很重要，因为大多数程序会跟踪最近的用户活动，并允许用户修改程序设置。为了保持用户修改后的设置，即使程序重新启动，程序会将它们存储为硬盘上的单独的*设置*文件。下次程序运行时，它首先从硬盘驱动器中读取相应的设置文件，然后更新自身以应用最近的设置修改。
- en: Usually, permanent storage has a much bigger capacity compared to the main memory,
    which makes it possible to use the HDD as a backup for virtual memory. The OS
    can maintain the virtual memory and fake its size, making it bigger than the physical
    DRAM. For example, the DRAM's two GB maximum capacity could be quickly exhausted
    by launching several heavyweight applications. However, the OS still can maintain
    a larger virtual memory by backing up its additional space with the HDD. When
    the user switches between applications, the OS copies the exceeding bytes of virtual
    memory to the HDD and maps the currently running application to the physical memory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，永久存储的容量比主内存大得多，这使得可以将硬盘驱动器用作虚拟内存的备份。操作系统可以维护虚拟内存并伪装其大小，使其比物理DRAM更大。例如，启动几个重量级应用程序可能会迅速耗尽DRAM的最大容量。然而，操作系统仍然可以通过将其额外的空间备份到硬盘驱动器来维护更大的虚拟内存。当用户在应用程序之间切换时，操作系统将虚拟内存的超出字节复制到硬盘驱动器，并将当前运行的应用程序映射到物理内存。
- en: This makes programs and the OS run slower but allows us to keep them open without
    caring about the limited size of the main memory. Let's now dive a little deeper
    into memory management in C++.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得程序和操作系统运行得更慢，但允许我们保持它们打开，而不必担心主内存的有限大小。现在让我们深入了解C++中的内存管理。
- en: The basics of memory management
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理的基础
- en: 'Most of the time, issues arising during memory management happen when programmers
    forget about deallocating memory space. This results in memory leaks. A memory
    leak is a widespread issue in almost every program. When the program requests
    a new memory space for its data, the OS marks the provided space as **busy**.
    That is, no other instruction of the program or any other program can request
    that busy memory space. When the portion of the program is done with the memory
    space, ideally, it must notify the OS to remove the busy label to make the space
    available for others. Some languages provide automatic control over dynamically
    allocated memory, leaving the programmer to worry about the logic of the application
    rather than constantly being concerned with deallocating memory resources. However,
    C++ assumes that the programmer is responsible and smart (which is not always
    the case). Dynamically allocated memory management is the programmer''s responsibility.
    That''s why the language provides both "new" and "delete" operators to deal with
    memory space, where the new operator allocates memory space and the delete operator
    deallocates it. In other words, the ideal code dealing with dynamically allocated
    memory looks like the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，内存管理中出现的问题是程序员忘记释放内存空间。这导致内存泄漏。内存泄漏是几乎每个程序中普遍存在的问题。当程序请求新的内存空间来存储其数据时，操作系统会将提供的空间标记为“忙碌”。也就是说，程序的任何其他指令或任何其他程序都无法请求该忙碌的内存空间。当程序部分完成内存空间时，理想情况下，它必须通知操作系统去除忙碌标签，以便为其他程序释放空间。一些语言提供对动态分配内存的自动控制，使程序员只需担心应用程序的逻辑，而不必不断担心释放内存资源。然而，C++假设程序员是负责和聪明的（这并不总是事实）。动态分配的内存管理是程序员的责任。这就是为什么语言提供了“new”和“delete”运算符来处理内存空间，其中new运算符分配内存空间，而delete运算符释放内存空间。换句话说，处理动态分配内存的理想代码如下所示：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Forgetting to call the delete operator makes the allocated memory space *busy
    forever*. By *forever*, we mean as long as the program is running. Now imagine
    a web browser that is always open on the user computer. Memory leaks here and
    there might lead to memory starvation over time, and sooner or later the user
    has to restart the program or, even worse, the OS.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记调用delete运算符会使分配的内存空间“永远忙碌”。所谓的“永远”，是指程序运行的时间。现在想象一下一个总是在用户计算机上打开的网络浏览器。这里发生的内存泄漏可能会导致内存饥饿，最终用户不得不重新启动程序，甚至更糟糕的是重新启动操作系统。
- en: This issue is applicable to any resource that we work with, whether it's a file
    or a socket we forget to close (more about sockets in [Chapter 12](e28727f2-afc0-4e0c-9375-4031720a5d48.xhtml),
    *Networking and Security*). To solve this issue, C++ programmers use the **Resource
    Acquisition Is Initialization** (**RAII**) idiom, stating that a resource should
    be acquired on its initialization, which allows it to be properly released later.
    Let's see it in action.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题适用于我们使用的任何资源，无论是我们忘记关闭的文件还是套接字（关于套接字的更多信息请参见[第12章](e28727f2-afc0-4e0c-9375-4031720a5d48.xhtml)，*网络和安全*）。为了解决这个问题，C++程序员使用**资源获取即初始化**（**RAII**）习惯用法，该习惯用法规定资源应该在初始化时获取，这样可以在以后正确释放它。让我们看看它的实际应用。
- en: An example of memory management
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理的一个例子
- en: 'Consider the following function that dynamically allocates an array of 420
    `shorts`, reads their values from the user input, prints them in ascending order,
    and deallocates the array:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数，该函数动态分配了一个包含420个“shorts”的数组，从用户输入中读取它们的值，按升序打印它们，并释放数组：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We already made a mistake in the preceding code by using the wrong `delete`
    operator to deallocate the memory. To deallocate an array, we must use the `delete[]`
    operator, otherwise, the code leads to memory leaks. Here''s how we illustrate
    the allocation of the array:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已经犯了一个错误，即使用错误的`delete`运算符来释放内存。要释放数组，我们必须使用`delete[]`运算符，否则代码会导致内存泄漏。以下是我们如何说明数组的分配：
- en: '![](img/073fb3c2-f36b-4002-bfc3-fecbeb34ecdf.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/073fb3c2-f36b-4002-bfc3-fecbeb34ecdf.png)'
- en: 'Let''s say we release the space using `delete` instead of `delete[]`. It will
    treat the `arr` as a short pointer, and therefore will remove the first two bytes
    starting at the address contained in the `arr` pointer, as shown in the following
    diagram:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用`delete`而不是`delete[]`来释放空间。它将把`arr`视为一个short指针，因此将删除从`arr`指针中包含的地址开始的前两个字节，如下图所示：
- en: '![](img/50d84dee-769a-47cc-b579-5967570ec8ed.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50d84dee-769a-47cc-b579-5967570ec8ed.png)'
- en: So now we removed the first item out of 420 items and left the 419 `shorts`
    untouched on the heap. Whenever we need new space on the heap, that small section
    containing the 419 **untouchables** won't be ever reused again. Though the family
    of new and delete operators is implementation-defined, we shouldn't really hope
    for the best implementation that avoids memory leaks.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们从420个项目中移除了第一个项目，剩下的419个“shorts”保持在堆上不变。每当我们需要堆上的新空间时，包含419个“untouchables”的小部分将永远不会被再次重用。虽然new和delete运算符的家族是实现定义的，但我们不应该真的指望最好的实现来避免内存泄漏。
- en: 'Let''s modify the preceding code to properly release the allocated memory for
    the array and let''s make sure we eliminate the possibility of inputting negative
    numbers:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改前面的代码，正确释放数组的分配内存，并确保消除输入负数的可能性：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding modifications are another example of a possible memory leak,
    though we clearly wrote ugly code for the sake of simplicity. The point is, whenever
    the user inputs a negative number, the function returns. This leaves us with 420
    orphan `shorts` that should be released somehow. However, the only access to the
    allocated memory was the `arr` pointer, which is declared on the stack, therefore
    it will be automatically deleted (the pointer variable, not the memory space pointed
    to it) when the function returns. To eliminate the possibility of a memory leak,
    we should simply call the `delete[]` operator before the function exits:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的修改是可能的内存泄漏的另一个例子，尽管我们显然为了简单起见写了丑陋的代码。关键是，每当用户输入一个负数时，函数就会返回。这让我们有420个应该被释放的“shorts”孤立。然而，分配的内存的唯一访问是“arr”指针，它在堆栈上声明，因此当函数返回时它将被自动删除（指针变量，而不是指向它的内存空间）。为了消除内存泄漏的可能性，我们应该在函数退出之前简单地调用“delete[]”运算符：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The code gets somewhat ugly but it fixes the memory leak. What if we modify
    the function further and use a third-party library function to sort the array:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码变得有些丑陋，但它修复了内存泄漏。如果我们进一步修改函数并使用第三方库函数来对数组进行排序：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Turns out that the `strange_sort::sort` throws an exception when the value
    of the array item exceeds 420 (that''s why it''s a strange sort, after all). If
    the exception is left uncaught, it will bubble up to the caller function unless
    it is caught somewhere or the program crashes. The uncaught exception leads to
    stack unwinding, which leads to automatic destruction of the `arr` variable (the
    pointer), so we face another possibility of a memory leak. To fix it, we could
    wrap the `strange_sort::sort` in a try-catch block:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，“strange_sort::sort”在数组项的值超过420时会抛出异常（毕竟这就是一个奇怪的排序）。如果异常没有被捕获，它将冒泡到调用者函数，除非它在某处被捕获，或者程序崩溃。未捕获的异常导致堆栈展开，这导致“arr”变量（指针）的自动销毁，因此我们面临另一个内存泄漏的可能性。为了解决这个问题，我们可以将“strange_sort::sort”包装在try-catch块中：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: C++ programmers constantly seek ways to deal with memory leaks, such as the
    RAII idiom and smart pointers, which we will discuss in the next sections.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: C++程序员不断寻求处理内存泄漏的方法，例如RAII习惯用法和智能指针，我们将在接下来的章节中讨论。
- en: Using smart pointers
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用智能指针
- en: 'There are many languages supporting automated garbage collection. For example,
    memory acquired for an object is tracked by the runtime environment. It will deallocate
    the memory space after the object with a reference to it goes out of the scope.
    Consider the following, for example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多支持自动垃圾收集的语言。例如，为对象获取的内存由运行时环境跟踪。当具有对它的引用的对象超出范围时，它将释放内存空间。例如，考虑以下情况：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code block, the `p` reference (usually, references in garbage-collected
    languages are similar to pointers in C++) refers to the memory location returned
    by the `new` operator. The automatic garbage collector manages the lifetime of
    the object created by the `new` operator. It also tracks references to that object.
    Whenever the object has no references on it, the garbage collector deallocates
    its space. Something similar to that might be achieved by using the RAII idiom
    in C++. Let's see it in action.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，“p”引用（通常，垃圾收集语言中的引用类似于C++中的指针）指的是“new”运算符返回的内存位置。自动垃圾收集器管理“new”运算符创建的对象的生命周期。它还跟踪对该对象的引用。每当对象没有引用时，垃圾收集器就会释放其空间。通过在C++中使用RAII习惯用法，可以实现类似的功能。让我们看看它的实际应用。
- en: Leveraging the RAII idiom
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用RAII习惯用法
- en: 'As already mentioned, the RAII idiom suggests acquiring the resource on its
    initialization. Look at the following class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，RAII习惯用法建议在初始化时获取资源。看看下面的类：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `print_sorted` function can now use the `ArrayManager` to properly release
    the allocated array:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: “print_sorted”函数现在可以使用“ArrayManager”来正确释放分配的数组：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We suggest using standard containers such as `std::vector` rather than `ArrayManager`,
    though it''s a good example of the RAII application: acquiring the resource on
    initialization. We created an instance of `ArrayManager` and initialized it with
    the memory resource. From that point, we can forget about its release because
    the actual release happens in the destructor of `ArrayManager`. And as we declared
    the `ArrayManager` instance on the stack, it will be automatically destroyed when
    the function returns or an uncaught exception occurs, and the destructor will
    be called.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用标准容器，如“std::vector”，而不是“ArrayManager”，尽管它是RAII应用的一个很好的例子：在初始化时获取资源。我们创建了一个“ArrayManager”的实例，并用内存资源对其进行了初始化。从那时起，我们可以忘记它的释放，因为实际的释放发生在“ArrayManager”的析构函数中。由于我们在堆栈上声明了“ArrayManager”实例，当函数返回或发生未捕获的异常时，它将被自动销毁，并且析构函数将被调用。
- en: 'Using a standard container is preferred in this scenario, so let''s implement
    the RAII idiom for single pointers. The following code dynamically allocates memory
    for a `Product` instance:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用标准容器是首选，因此让我们为单个指针实现RAII习惯用法。以下代码动态为“Product”实例分配内存：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we apply the RAII idiom to the preceding code, it will release the resource
    at the proper point of code execution:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将RAII习惯用法应用于前面的代码，它将在代码执行的适当点释放资源：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `ResourceManager` class should also overload operators `*` and `->` because
    it has to behave like a pointer in order to properly acquire and manage a pointer:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: “ResourceManager”类还应该重载运算符“*”和“->”，因为它必须像指针一样行为，以便正确获取和管理指针：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `ResourceManager` class cares about the idea of the smart pointer in C++.
    C++11 introduced several types of smart pointers. We name them *smart* because
    they wrap around the resource and manage its automatic deallocation. It happens
    solely because of the fact that the destructor of an object will be called when
    the object is set to destroy. That said, we operate with the dynamically allocated
    space through the object with an automatic storage duration. When the handler
    object goes out of scope, its destructor executes the necessary actions to deallocate
    the underlying resource.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceManager`类关心C++中的智能指针的概念。C++11引入了几种类型的智能指针。我们将它们称为*智能*，是因为它们包装资源并管理其自动释放。这仅仅是因为当对象被设置为销毁时，对象的析构函数将被调用。也就是说，我们通过具有自动存储期的对象操作动态分配的空间。当处理程序对象超出范围时，其析构函数执行必要的操作以释放底层资源。'
- en: 'However, smart pointers might bring additional issues. The simple smart pointer
    discussed in the preceding paragraph has several issues that would arise eventually.
    For example, we didn''t take care of the `ResourceManager` copying:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，智能指针可能带来额外的问题。在前面段落讨论的简单智能指针中，最终会出现几个问题。例如，我们没有处理`ResourceManager`的复制：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code leads to undefined behavior. The following diagram shows
    the disguised problem:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码会导致未定义的行为。以下图表显示了伪装的问题：
- en: '![](img/8a9ce9cc-43a7-4a58-a6f1-53b386cae052.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a9ce9cc-43a7-4a58-a6f1-53b386cae052.png)'
- en: Both **res** and **apple** acquire the same resource. Whenever one of them goes
    out of scope (**apple**), the underlying resource is released, which leaves the
    other `ResourceManager` instance with a dangling pointer. When the other `ResourceManager` instance goes
    out of scope, it will try to delete the pointer twice. Usually, programmers are
    aware of the *kind* of smart pointer they need in a specific case. That's why
    C++ provides several types of smart pointers that, which we will discuss further.
    To use them in your programs, you should import the `<memory>` header.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**res**和**apple**都获取了相同的资源。每当它们中的一个超出范围（**apple**），底层资源就会被释放，这会导致另一个`ResourceManager`实例拥有悬空指针。当另一个`ResourceManager`实例超出范围时，它将尝试两次删除指针。通常，程序员会意识到在特定情况下需要哪种智能指针。这就是为什么C++提供了几种类型的智能指针，我们将进一步讨论。要在程序中使用它们，您应该导入`<memory>`头文件。'
- en: std::unique_ptr
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::unique_ptr
- en: 'Similar to the `ResourceManager` instance we implemented earlier, `std::unique_ptr`
    represents a basic smart pointer. For example, to manage the `Product` object
    using this smart pointer, we do the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前实现的`ResourceManager`实例类似，`std::unique_ptr`代表了一个基本的智能指针。例如，要使用这个智能指针来管理`Product`对象，我们这样做：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note how we access the `Product` member function `set_name`. We treat the `res`
    object as something that has the type `Pointer*`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何访问`Product`成员函数`set_name`。我们将`res`对象视为具有类型`Pointer*`的东西。
- en: '`unique_ptr` is named unique because it provides a semantics of strict ownership—
    it is obligated to destroy the acquired object. More interestingly, `unique_ptr`
    can''t be copied. It doesn''t have a copy constructor or assignment operator.
    That''s why its **ownership** is *strict*. Of course, that doesn''t mean that
    we can''t move a `unique_ptr` class. In that case, we completely pass the ownership
    to the other instance of the unique pointer.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr`之所以被称为unique，是因为它提供了严格所有权的语义-它有责任销毁所获得的对象。更有趣的是，`unique_ptr`不能被复制。它没有复制构造函数或赋值运算符。这就是为什么它的**所有权**是*严格*的。当然，这并不意味着我们不能移动`unique_ptr`类。在这种情况下，我们完全将所有权转移到唯一指针的另一个实例。'
- en: 'One of the main requirements for smart pointers is keeping them lightweight.
    We can surely agree on that. While `unique_ptr` is a full class with several member
    functions, it doesn''t *pollute* with additional data members. It''s just a wrapper
    around the raw pointer to the allocated object. We can access that raw pointer
    by calling the `release()` member function of `unique_ptr`, as shown:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针的主要要求之一是保持它们的轻量级。我们肯定会同意这一点。虽然`unique_ptr`是一个完整的类，有几个成员函数，但它不会通过附加数据成员来“污染”。它只是一个围绕分配对象的原始指针的包装器。我们可以通过调用`unique_ptr`的`release()`成员函数来访问该原始指针，如下所示：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that the `release()` function doesn''t call the delete operator. It only
    gives back ownership. After calling the `release()` function, the `unique_ptr` no
    longer owns the resource. To reuse a `unique_ptr` that already owns a resource,
    you should use the `reset()` member function. It calls the delete operator for
    the underlying pointer and *resets* the unique pointer for further use. On the
    other hand, if you want to get the underlying object without releasing the ownership,
    you should call the `get()` member function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`release()`函数不会调用删除运算符。它只是归还所有权。调用`release()`函数后，`unique_ptr`不再拥有资源。要重用已拥有资源的`unique_ptr`，您应该使用`reset()`成员函数。它调用底层指针的删除运算符并“重置”唯一指针以供进一步使用。另一方面，如果要获取底层对象而不释放所有权，应该调用`get()`成员函数：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can''t use a `unique_ptr` class in the following scenario because it can''t
    be copied:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在以下情况中使用`unique_ptr`类，因为它无法被复制：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: However, it's not what we look for in the preceding code. You can consider the
    preceding code a bad design, because it confuses the ownership details. Let's
    move on to the next smart pointer in C++ that, which solves the issue of passing
    `unique_ptr` to functions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是我们在前面的代码中寻找的。您可以将前面的代码视为糟糕的设计，因为它混淆了所有权细节。让我们继续讨论C++中的下一个智能指针，它解决了将`unique_ptr`传递给函数的问题。
- en: std::shared_ptr and std::weak_ptr
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::shared_ptr和std::weak_ptr
- en: 'We need a smart pointer providing *shared ownership*. What we need was introduced
    back in C++11 as `std::shared_ptr`. It''s harder to implement a smart pointer
    with shared ownership, because you should take care of the correct deallocation
    of the resource. For example, when the `print_name()` function in the preceding
    code block finishes its work, its arguments and local objects will be destroyed.
    Destroying a smart pointer leads to the proper deallocation of the resource it
    owns. How would the smart pointer know if that resource is still owned by another
    smart pointer? One of the popular solutions is keeping the count of references
    to the resource. The `shared_ptr` class does the same: it keeps the number of
    pointers pointing to the underlying object and deletes it when the use count becomes
    0\. Therefore, several shared pointers can own the same object.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个提供*共享所有权*的智能指针。我们需要的东西在C++11中被引入，称为`std::shared_ptr`。实现具有共享所有权的智能指针更难，因为您应该注意正确释放资源。例如，当前面代码块中的`print_name()`函数完成其工作时，它的参数和局部对象将被销毁。销毁智能指针会导致所拥有的资源得到适当的释放。智能指针如何知道该资源是否仍然被另一个智能指针所拥有呢？其中一个流行的解决方案是保持对资源的引用计数。`shared_ptr`类也是如此：它保持指向底层对象的指针的数量，并在使用计数变为0时删除它。因此，几个共享指针可以拥有相同的对象。
- en: 'Now, the example we just discussed should be rewritten like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们刚才讨论的示例应该重写如下：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After calling the `print_name()` function, the use count of the shared pointer
    increases by 1\. It will decrease by 1 when the function finishes its work but
    the managed object won''t be deallocated. It''s because the `res` object is not
    yet out of the scope. Let''s slightly modify the example to print the count of
    references to the shared object:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`print_name()`函数后，共享指针的使用计数增加了1。当函数完成其工作时，使用计数将减少1，但托管对象不会被释放。这是因为`res`对象尚未超出范围。让我们稍微修改示例以打印对共享对象的引用计数：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding code will print the following to the screen:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将在屏幕上打印如下内容：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When the last `shared_ptr` goes out of scope, it also destroys the underlying
    object. However, you should be careful when sharing an object between shared pointers.
    The following code shows an obvious issue with shared ownership:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当最后一个`shared_ptr`超出范围时，它也会销毁底层对象。然而，在共享指针之间共享对象时，您应该小心。以下代码显示了共享所有权的一个明显问题：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Both `ptr1` and `ptr2` point to the same object, but they are not aware of each
    other. So when we modify the `Product` object via `ptr2`, it will affect `ptr1`.
    When `ptr2` goes out of scope (after the `if` statement), it will destroy the
    underlying object, which is still owned by `ptr1`. It happens because we make
    `ptr2` own the object by passing the raw `temp` pointer to it. `ptr1` can't track
    that.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`ptr1`和`ptr2`都指向同一个对象，但它们彼此不知道。因此，当我们通过`ptr2`修改`Product`对象时，它会影响`ptr1`。当`ptr2`超出范围（在`if`语句之后）时，它将销毁底层对象，而该对象仍然被`ptr1`拥有。这是因为我们通过将原始的`temp`指针传递给它，使`ptr2`拥有了该对象。`ptr1`无法跟踪到这一点。'
- en: The ownership can be shared only using the copy constructor or the assignment
    operator of `std::shared_ptr`. This way, we avoid deleting the object if it's
    in use by another `shared_ptr` instance. Shared pointers implement shared ownership
    using control blocks. Each shared pointer holds two pointers, one to the object
    it manages, and a pointer to the control block. The control block represents a
    dynamically allocated space containing the use count of the resource. It also
    contains several other things crucial for `shared_ptr`, for example, the `allocator`
    and the `deleter` of the resource. We will introduce allocators in the next section.
    The `deleter` usually is the regular `delete` operator.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 只能使用`std::shared_ptr`的复制构造函数或赋值运算符来共享所有权。这样，我们避免了如果它正在被另一个`shared_ptr`实例使用时删除对象。共享指针使用控制块实现共享所有权。每个共享指针持有两个指针，一个指向它管理的对象，一个指向控制块。控制块表示动态分配的空间，包含资源的使用计数。它还包含对于`shared_ptr`至关重要的其他几个东西，例如资源的`allocator`和`deleter`。我们将在下一节介绍分配器。`deleter`通常是常规的`delete`运算符。
- en: The control block also contains the number of weak references. It's done because
    the owned resource might be pointed to a weak pointer, too. `std::weak_ptr` is
    the smaller brother of `std::shared_ptr`. It refers to an object managed by a `shared_ptr` instance,
    but doesn't own it. `weak_ptr` is a way to access and use the resource owned by
    `shared_ptr` without owning it. However, there is a way to convert a `weak_ptr` instance
    to `shared_ptr` using the `lock()` member function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 控制块还包含弱引用的数量。这是因为所拥有的资源也可能被弱指针指向。`std::weak_ptr`是`std::shared_ptr`的小兄弟。它指的是由`shared_ptr`实例管理的对象，但并不拥有它。`weak_ptr`是一种访问和使用由`shared_ptr`拥有的资源而不拥有它的方法。然而，有一种方法可以使用`lock()`成员函数将`weak_ptr`实例转换为`shared_ptr`。
- en: 'Both `unique_ptr` and `shared_ptr` can be used for managing dynamically allocated
    arrays. The template parameter must be specified correctly:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr`和`shared_ptr`都可以用于管理动态分配的数组。必须正确指定模板参数：'
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To access an element of the underlying array, we use the `[]` operator of the
    shared pointer. Also, note that using a smart pointer won''t have drawbacks when
    used in dynamic polymorphism. For example, let''s suppose we have the following
    class hierarchy:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问底层数组的元素，我们使用共享指针的`[]`运算符。还要注意，当在动态多态性中使用智能指针时，不会有缺点。例如，假设我们有以下类层次结构：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following code works as expected and outputs `Derived::test()` to the screen:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码按预期工作，并将`Derived::test()`输出到屏幕上。
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Although the use of smart pointers might seem to spoil the beauty of pointers,
    it is suggested to intensively use smart pointers to avoid memory leaks. However,
    it's worth noting that replacing all pointers with smart pointers, whether it's
    a `unique_ptr` or a `shared_ptr` pointer, will not solve all the memory leak problems.
    They have their disadvantages, too. Consider a balanced approach, or better, thoroughly
    understand both the problem and the smart pointers themselves in detail before
    applying them to the problem.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用智能指针可能会破坏指针的美感，但建议大量使用智能指针以避免内存泄漏。然而，值得注意的是，用`unique_ptr`或`shared_ptr`指针替换所有指针，也无法解决所有内存泄漏问题。它们也有缺点。在应用它们解决问题之前，考虑一种平衡的方法，或者更好地彻底了解问题和智能指针本身的细节。
- en: Managing memory in C++ programs comes at a price. The most important thing that
    we've discussed is the proper deallocation of memory space. The language doesn't
    support automatic memory deallocation, but it's worth mentioning garbage collectors.
    However, to have a complete garbage collector, we need language-level support.
    C++ doesn't provide any of that. Let's try to imitate a garbage collector in C++.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++程序中管理内存是有代价的。我们讨论的最重要的事情是正确释放内存空间。该语言不支持自动内存释放，但值得一提的是垃圾收集器。然而，要有一个完整的垃圾收集器，我们需要语言级别的支持。C++没有提供任何支持。让我们尝试在C++中模拟垃圾收集器。
- en: Garbage collection
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾收集
- en: 'A garbage collector is a separate module usually incorporated in the runtime
    environments of interpretable languages. For example, C# and Java both have garbage
    collectors, which makes the life of programmers a lot easier. The garbage collector
    tracks all the object allocations in the code and deallocates once they are not
    in use anymore. It''s called a **garbage collector** because it deletes the memory
    resource after it''s been used: it collects the garbage left by programmers.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器通常是可解释语言的运行时环境中的一个单独模块。例如，C#和Java都有垃圾收集器，这使得程序员的生活变得更加轻松。垃圾收集器跟踪代码中的所有对象分配，并在它们不再使用时释放。它被称为**垃圾收集器**，因为它在使用后删除内存资源：它收集程序员留下的垃圾。
- en: It's said that C++ programmers don't leave garbage after them, that's why the
    language doesn't have support for a garbage collector. Though programmers tend
    to defend the language stating that it doesn't have a garbage collector because
    it's a fast language, the truth is that it can survive without one.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 据说C++程序员不会留下垃圾，这就是为什么该语言不支持垃圾收集器的原因。尽管程序员倾向于辩护该语言，称其之所以没有垃圾收集器是因为它是一种快速的语言，但事实是它可以在没有垃圾收集器的情况下生存。
- en: 'Languages like C# compile the program into intermediate byte-code representation,
    which is then  interpreted and executed by the runtime environment. The garbage
    collector is a part of the environment and is actively tracking all object allocations.
    It is a sophisticated beast that tries its best to manage the memory in a reasonable
    time. The following diagram depicts a typical runtime environment that allocates
    memory supervised by the garbage collector:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 像C#这样的语言将程序编译成中间字节码表示，然后由运行时环境解释和执行。垃圾收集器是环境的一部分，并且积极跟踪所有对象分配。它是一个复杂的机制，尽最大努力在合理的时间内管理内存。以下图表描述了典型的运行时环境，该环境分配由垃圾收集器监督的内存：
- en: '![](img/2421ee02-8ebd-4784-8109-1c53318b8124.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2421ee02-8ebd-4784-8109-1c53318b8124.png)'
- en: We manually call the `delete` operator to release the memory space in C++ even
    when using smart pointers. Smart pointers just acquire the object and delete the
    object when it goes out of scope. The key point is that even though smart pointers
    introduce some semi-automatic behavior, they still act as if the programmer didn't
    forget to release the resource at a specified point of the code. The garbage collector
    does that automatically and usually uses separate execution threads. It tries
    its best not to slow down the actual program execution speed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用智能指针，我们仍然需要手动调用`delete`运算符来释放C++中的内存空间。智能指针只是在获取对象时获取对象，并在对象超出范围时删除对象。关键点是，即使智能指针引入了一些半自动行为，它们仍然表现得好像程序员没有忘记在代码的指定点释放资源。垃圾收集器会自动执行这些操作，并通常使用单独的执行线程。它尽力不要减慢实际程序执行速度。
- en: 'Some of the garbage collection implementation techniques include classifying
    objects by their lifetime duration. Classification makes the garbage collector
    visit the objects and release the memory space if objects aren''t in use anymore.
    To make this process faster, objects with short lifetime duration should be visited
    more often than objects with longer duration. Take, for example, the following
    code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一些垃圾收集实现技术包括根据对象的生命周期持续时间对对象进行分类。分类使垃圾收集器访问对象并在对象不再使用时释放内存空间。为了加快这个过程，应该更频繁地访问生命周期短的对象，而不是生命周期长的对象。例如，考虑以下代码：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If C++ had a garbage collector, then the objects `g1`, `g2`, and `g3` would
    be deleted in different time slots of the program execution. If the garbage collector
    classifies them by their lifetime duration, then `g2` would have the shortest
    lifetime and should be visited first in order to release it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果C++有垃圾收集器，那么对象`g1`、`g2`和`g3`将在程序执行的不同时间段被删除。如果垃圾收集器根据它们的生命周期持续时间对它们进行分类，那么`g2`的生命周期将是最短的，并且应该首先被访问以释放它。
- en: 'To really implement a garbage collector in C++, we should make it a part of
    the program. The garbage collector should first take care of allocating memory
    to track and remove it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正在C++中实现垃圾收集器，我们应该将其作为程序的一部分。垃圾收集器应该首先负责分配内存来跟踪并删除它：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding class keeps track of objects allocated through the static `allocate()` function. If
    the object is in use, it deletes it through the `deallocate()` function. Here''s
    how `GarbageCollector` can be used:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类通过静态的`allocate()`函数跟踪通过分配的对象。如果对象正在使用，则通过`deallocate()`函数删除它。以下是`GarbageCollector`的使用方法：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Actually, this class makes memory management a little bit harder than smart
    pointers. Basically, there is no need to implement a garbage collector in C++
    because smart pointers provide handling almost any scenario regarding *automatic*
    memory deallocation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个类使得内存管理比智能指针稍微困难一些。基本上，在C++中没有必要实现垃圾收集器，因为智能指针几乎可以处理关于*自动*内存释放的任何情况。
- en: 'However, let''s see one of the tricks that will allow the garbage collector
    to properly deallocate the space pointed to by some pointer. In our simplest possible
    preceding implementation, we kept track of all the pointers that we provided to
    users. Each pointer points to some space on the heap that should be freed at some
    point in the program execution. In `GarbageCollector`, we would use the standard
    `delete` operator. The question is, how does it know how many bytes should be
    freed? Take a look at the following example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们看看一种技巧，它将允许垃圾收集器正确释放某个指针指向的空间。在我们最简单的前面的实现中，我们跟踪了我们提供给用户的所有指针。每个指针指向堆上的一些空间，应该在程序执行的某个时刻被释放。在`GarbageCollector`中，我们将使用标准的`delete`运算符。问题是，它如何知道应该释放多少字节？看看下面的例子：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let's suppose that a `Student` instance takes 40 bytes of memory and an integer
    takes four bytes. We should somehow pass that information to the delete operator.
    In the preceding code, we delete both `ptr` and `ip`, each of which points to
    memory space of different sizes. So how does it know that 40 bytes should be marked
    as free in the case of `ptr` and four bytes should be marked as free in the case
    of `ip`? There is more than one solution to this problem, so let's look at one
    of them.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个`Student`实例占用40个字节的内存，一个整数占用4个字节。我们应该以某种方式将这些信息传递给删除运算符。在前面的代码中，我们删除了`ptr`和`ip`，它们分别指向不同大小的内存空间。那么它如何知道在`ptr`的情况下应该将40个字节标记为自由，而在`ip`的情况下应该将4个字节标记为自由？对于这个问题有不止一种解决方案，让我们看看其中一种。
- en: 'Whenever we allocate memory, the new operator puts the size of the allocated
    space just before the actual memory space, as shown in the following diagram:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们分配内存时，`new`运算符将分配空间的大小放在实际内存空间之前，如下图所示：
- en: '![](img/10cfb979-45e6-41f9-9d2f-7fcb0fff9408.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/10cfb979-45e6-41f9-9d2f-7fcb0fff9408.png)'
- en: This information is then used by the `delete` operator, which reads the size
    of the memory space by reading the corresponding bytes placed before the memory
    space. One of the top concerns of C++ is managing memory for collections of data.
    STL containers, such as `std::vector` and `std::list`, described in [Chapter 6](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml),
    *Digging into Data Structures and Algorithms in STL*, have different models for
    working with memory. By default, a container has a specified memory allocator
    that handles the memory allocation and deallocation for container elements. Let's
    tackle an allocator in more detail.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息然后被`delete`运算符使用，它通过读取内存空间之前放置的相应字节来读取内存空间的大小。C++的一个主要关注点是管理数据集合的内存。STL容器，如`std::vector`和`std::list`，在[第6章](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml)中描述的《深入STL中的数据结构和算法》中，对处理内存有不同的模型。默认情况下，容器有一个指定的内存分配器，用于处理容器元素的内存分配和释放。让我们更详细地了解一下分配器。
- en: Using allocators
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用分配器
- en: 'The idea behind an allocator is to provide control to container memory management.
    In simpler words, an allocator is an advanced garbage collector for C++ containers.
    Although we discuss allocators in the scope of container memory management, you
    can surely expand the idea to a generic garbage collector. At the beginning of
    this section, we implemented a badly designed garbage collector. When examining
    allocators, you will find a lot of similarities between the poorly designed `GarbageCollector`
    class and the default allocator in C++. Defined in the `<memory>`, the default
    allocator has two basic functions – `allocate()` and `deallocate()`. The `allocate()`
    function is defined as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 分配器的理念是为容器内存管理提供控制。简单来说，分配器是C++容器的高级垃圾收集器。虽然我们在容器内存管理范围内讨论分配器，但您肯定可以将这个想法扩展到通用的垃圾收集器。在本节的开头，我们实现了一个设计不良的垃圾收集器。当研究分配器时，您会发现`GarbageCollector`类和C++中的默认分配器之间有很多相似之处。默认分配器在`<memory>`中定义，它有两个基本函数-`allocate()`和`deallocate()`。`allocate()`函数定义如下：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `allocate()` function acquires space for `num` objects of type `T`. Pay
    attention to the `[[nodiscard]]` attribute – it means that the return value should
    not be discarded by the caller. The compiler will print a warning message otherwise.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`allocate()`函数获取类型为`T`的`num`个对象的空间。注意`[[nodiscard]]`属性-这意味着调用者不应该丢弃返回值。否则，编译器将打印警告消息。'
- en: 'Let''s use the allocator to acquire space for five integers:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用分配器为五个整数获取空间：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note how we used `std::allocator_traits` to construct objects in the allocated
    space. The following illustration shows
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用`std::allocator_traits`在分配的空间中构造对象。下图显示了
- en: 'The `deallocate()` function is defined as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`deallocate()`函数定义如下：'
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the previous code snippet, we used the `deallocate()` function by passing
    the pointer returned by the `allocate()` function.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个代码片段中，我们使用`allocate()`函数返回的指针来调用`deallocate()`函数。
- en: You might not use allocators in your project directly, however, whenever you
    need a custom behavior for memory management, using existing or introducing new
    allocators can be helpful. STL containers use allocators mostly because they are
    different in structure and behavior, which leads to the need to have specialized
    behavior for memory allocation and deallocation. We will discuss STL containers
    in more detail in the next chapter.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不会直接在项目中使用分配器，但是每当您需要自定义内存管理行为时，使用现有的或引入新的分配器可能会有所帮助。STL容器主要使用分配器，因为它们在结构和行为上有所不同，这导致需要为内存分配和释放具有专门的行为。我们将在下一章更详细地讨论STL容器。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Garbage collectors in languages like C# are provided by the environment. They
    work in parallel with the user program and try to clean up after the program whenever
    it seems efficient. We cannot do the same in C++; all we can achieve is the implementation
    of a garbage collector directly in the program, providing a semi-automatic way
    of freeing the used memory resource. This mechanism is properly covered by the
    smart pointers introduced in the language since C++11.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 像C#这样的语言中的垃圾收集器是由环境提供的。它们与用户程序并行工作，并在程序看起来有效时尝试清理。我们无法在C++中做同样的事情；我们能做的只是在程序中直接实现垃圾收集器，提供一种半自动的方式来释放已使用的内存资源。自C++11以来，这种机制已经得到了语言中智能指针的适当覆盖。
- en: Memory management is one of the key components of every computer program. A
    program should be able to request memory dynamically during its execution. Good
    programmers understand the inner details of memory management. That helps them
    to design and implement more performant applications. While manual memory management
    is considered an advantage, it tends to become painful in larger applications.
    We have learned in this chapter how we can avoid errors and handle memory deallocation
    using smart pointers. Having this basic understanding, you should grow your confidence
    in designing programs that avoid memory leaks.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理是每个计算机程序的关键组成部分之一。程序应该能够在执行过程中动态请求内存。优秀的程序员了解内存管理的内部细节。这有助于他们设计和实现性能更好的应用程序。虽然手动内存管理被认为是一种优势，但在较大的应用程序中往往变得痛苦。在本章中，我们已经学会了如何通过智能指针避免错误并处理内存释放。有了这种基本的理解，您应该对设计避免内存泄漏的程序更有信心。
- en: 'In the next chapter, we will learn about STL, focusing on data structures and
    algorithms, and will dive into their STL implementation. Besides comparing data
    structures and algorithms, we will introduce one of the notable new features in
    C++20: concepts.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习STL，重点关注数据结构和算法，并深入研究它们的STL实现。除了比较数据结构和算法，我们还将介绍C++20中一个显著的新特性：概念。
- en: Questions
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Explain computer memory.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释计算机内存。
- en: What is virtual memory?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是虚拟内存？
- en: Which are the operators used for memory allocation and deallocation?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于内存分配和释放的运算符是哪些？
- en: What is the difference between `delete` and `delete[]`?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`delete`和`delete[]`之间有什么区别？'
- en: What is a garbage collector and why doesn't C++ support one?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是垃圾收集器，为什么C++不支持垃圾收集器？
- en: Further reading
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, refer to the following links:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅以下链接：
- en: What every programmer should know about memory, by Ulrich Drepper, at [https://people.freebsd.org/~lstewart/articles/cpumemory.pdf](https://people.freebsd.org/~lstewart/articles/cpumemory.pdf)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个程序员都应该了解的关于内存的知识，作者乌尔里希·德雷珀，网址为[https://people.freebsd.org/~lstewart/articles/cpumemory.pdf](https://people.freebsd.org/~lstewart/articles/cpumemory.pdf)
- en: 'Code: The hidden language of computer hardware and software, by Charles Petzold,
    at [https://www.amazon.com/Code-Language-Computer-Hardware-Software/dp/0735611319/](https://www.amazon.com/Code-Language-Computer-Hardware-Software/dp/0735611319/)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《代码：计算机硬件和软件的隐藏语言》，作者查尔斯·佩兹德，网址为[https://www.amazon.com/Code-Language-Computer-Hardware-Software/dp/0735611319/](https://www.amazon.com/Code-Language-Computer-Hardware-Software/dp/0735611319/)
