- en: Getting Started with GLSL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用GLSL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Using a loading library to access the latest OpenGL functionality
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加载库访问最新的OpenGL功能
- en: Using GLM for mathematics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GLM进行数学计算
- en: Determining the GLSL and OpenGL version
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定GLSL和OpenGL版本
- en: Compiling a shader
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译着色器
- en: Linking a shader program
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接着色器程序
- en: Saving and loading a shader binary
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存和加载着色器二进制文件
- en: Loading a SPIR-V shader program
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载SPIR-V着色器程序
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The **OpenGL Shading Language** (**GLSL**) Version 4 brings unprecedented power
    and flexibility to programmers interested in creating modern, interactive, and
    graphical programs. It allows us to harness the power of modern **Graphics Processing
    Units** (**GPUs**) in a straightforward way by providing a simple yet powerful
    language and API. Of course, the first step toward using GLSL is to create a program
    that utilizes the OpenGL API. GLSL programs don't stand on their own; they must
    be a part of a larger OpenGL program. In this chapter, we will provide some tips
    and techniques for getting started. We'll cover how to load, compile, link, and
    export a GLSL shader program. First, let's start with some background.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenGL着色语言**（**GLSL**）的4.0版本为对创建现代、交互式和图形程序感兴趣的程序员带来了前所未有的力量和灵活性。它通过提供一个简单而强大的语言和API，以直接的方式利用现代**图形处理单元**（**GPU**）的力量。当然，使用GLSL的第一步是创建一个利用OpenGL
    API的程序。GLSL程序不能独立存在；它们必须成为更大的OpenGL程序的一部分。在本章中，我们将提供一些入门的技巧和技术。我们将介绍如何加载、编译、链接和导出GLSL着色器程序。首先，让我们从一些背景知识开始。'
- en: GLSL
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GLSL
- en: The GLSL is a fundamental and integral part of the OpenGL API. Every program
    written using the OpenGL API will internally utilize one or several GLSL programs.
    These "mini-programs" are referred to as **shader programs**. A shader program
    usually consists of several components called **shaders**. Each shader executes
    within a different stage of the OpenGL pipeline. Each shader runs on the GPU,
    and as the name implies, they (typically) implement the algorithms related to
    lighting and shading effects. However, shaders are capable of doing much more
    than just shading. They can perform animation, generate additional geometry, tessellate
    geometry, or even perform generalized computation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL（OpenGL着色语言）是OpenGL API的基本和不可或缺的部分。使用OpenGL API编写的每个程序都会在内部使用一个或多个GLSL程序。这些“小程序”被称为**着色器程序**。一个着色器程序通常由几个称为**着色器**的组件组成。每个着色器在OpenGL管道的不同阶段执行。每个着色器都在GPU上运行，正如其名称所暗示的，它们（通常是）实现与光照和着色效果相关的算法。然而，着色器能够做的远不止着色。它们可以执行动画、生成额外的几何形状、对几何形状进行细分，甚至执行通用计算。
- en: The field of study called **General Purpose Computing on Graphics Processing
    Units** (**GPGPU**) is concerned with the utilization of GPUs (often using specialized
    APIs such as CUDA or OpenCL) to perform general-purpose computations such as fluid
    dynamics, molecular dynamics, and cryptography. With compute shaders, introduced
    in OpenGL 4.3, we can now do GPGPU within OpenGL. See [Chapter 11](d67e01c8-8212-4d49-937f-6b1c62a57744.xhtml),
    *Using Compute Shaders*, for details about using compute shaders.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 研究领域称为**通用计算在图形处理单元上**（**GPGPU**）关注的是利用GPU（通常使用如CUDA或OpenCL之类的专用API）执行通用计算，如流体动力学、分子动力学和密码学。随着OpenGL
    4.3中引入的计算着色器，我们现在可以在OpenGL中执行GPGPU。有关使用计算着色器的详细信息，请参阅[第11章](d67e01c8-8212-4d49-937f-6b1c62a57744.xhtml)，*使用计算着色器*。
- en: Shader programs are designed for direct execution on the GPU and are executed
    in parallel. For example, a fragment shader might be executed once for every pixel,
    with each execution running simultaneously. The number of processors on the graphics
    card determines how many can be executed at one time. This makes shader programs
    incredibly efficient, and provides the programmer with a simple API for implementing
    highly-parallel computation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器程序是为在GPU上直接执行而设计的，并且是并行执行的。例如，片段着色器可能为每个像素执行一次，每次执行都是同时进行的。显卡上的处理器数量决定了可以同时执行的数量。这使得着色器程序非常高效，并为程序员提供了一个简单的API来实现高度并行的计算。
- en: Shader programs form essential parts of the *OpenGL pipeline*. Prior to OpenGL
    Version 2.0, the shading algorithm was *hardcoded* into the pipeline and had only
    limited configurability. When we wanted to implement custom effects, we used various
    tricks to force the fixed-function pipeline into being more flexible than it really
    was. With the advent of GLSL, we now have the ability to replace this hardcoded
    functionality with our own programs written in GLSL, thus giving us a great deal
    of additional flexibility and power. For more details on this programmable pipeline,
    see the introduction to [Chapter 3](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml),
    *The Basics of GLSL Shaders*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器程序是*OpenGL管道*的基本部分。在OpenGL版本2.0之前，着色算法被**硬编码**到管道中，并且只有有限的配置能力。当我们想要实现自定义效果时，我们使用各种技巧来强制固定功能管道比它实际更灵活。随着GLSL的出现，我们现在能够用我们用GLSL编写的自己的程序来替换这个硬编码的功能，从而给我们带来大量的额外灵活性和能力。有关这个可编程管道的更多详细信息，请参阅[第3章](74703f9d-f69a-4b08-bb38-6e1066371207.xhtml)的介绍，*GLSL着色器的基础*。
- en: In fact, OpenGL Version 3.2 and above not only provide this capability, but
    they require shader programs as part of every OpenGL program. The old fixed-function
    pipeline has been deprecated in favor of a new programmable pipeline, a key part
    of which is the shader program written in GLSL.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，OpenGL版本3.2及以上不仅提供了这种能力，而且它们要求每个OpenGL程序都包含着色器程序。旧的固定功能管道已被弃用，转而采用新的可编程管道，其关键部分是使用GLSL编写的着色器程序。
- en: Profiles – core versus compatibility
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置文件 - 核心与兼容性
- en: OpenGL Version 3.0 introduced a **deprecation model**, which allowed for the
    gradual removal of functions from the OpenGL specification. Functions or features
    can be marked as deprecated, meaning that they are expected to be removed from
    a future version of OpenGL. For example, immediate mode-rendering using `glBegin`/`glEnd`
    was marked as deprecated in version 3.0 and removed in version 3.1.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL版本3.0引入了**弃用模型**，允许逐步从OpenGL规范中删除函数。函数或特性可以被标记为已弃用，这意味着它们预计将在OpenGL的未来版本中被移除。例如，使用`glBegin`/`glEnd`进行即时模式渲染在版本3.0中被标记为已弃用，并在版本3.1中被移除。
- en: In order to maintain backwards compatibility, **compatibility profiles** were
    introduced with OpenGL 3.2\. A programmer that is writing code for a particular
    version of OpenGL (with older features removed) would use the **core profile**.
    Those who wanted to maintain compatibility with older functionality could use
    the compatibility profile.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持向后兼容性，OpenGL 3.2引入了**兼容性配置文件**。一个为特定版本的OpenGL（移除了旧功能）编写代码的程序员会使用**核心配置文件**。那些希望与旧功能保持兼容的人可以使用兼容性配置文件。
- en: It may be somewhat confusing that there is also the concept of a **forward-compatible** context,
    which is distinguished slightly from the concept of a core/compatibility profile.
    A context that is considered forward-compatible basically indicates that all deprecated
    functionality has been removed. In other words, if a context is forward-compatible,
    it only includes functions that are in the core, but not those that were marked
    as deprecated. Some Windows APIs provide the ability to select a forward-compatible
    status along with the profile.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有些令人困惑的是，还有一个**向前兼容**上下文的概念，它与核心/兼容配置文件的概念略有区别。一个被认为是向前兼容的上下文基本上表明所有已弃用的功能都已移除。换句话说，如果一个上下文是向前兼容的，它只包括核心中的函数，但不包括那些被标记为已弃用的。一些Windows
    API提供了选择与配置文件一起的向前兼容状态的能力。
- en: 'The steps for selecting a core or compatibility profile depend on the Windows
    system''s API. For example, with GLFW, one can select a forward-compatible, 4.6
    core profile using the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 选择核心或兼容配置文件步骤取决于Windows系统的API。例如，使用GLFW，可以通过以下代码选择一个向前兼容的4.6核心配置文件：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All programs in this book are designed to be compatible with a forward-compatible
    OpenGL 4.6 core profile. However, many of them can be used with older versions
    or even compatibility profiles.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有程序都设计为与向前兼容的OpenGL 4.6核心配置文件兼容。然而，许多程序也可以用于较旧版本或甚至兼容配置文件。
- en: Using a loading library to access the latest OpenGL functionality
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加载库访问最新的OpenGL功能
- en: The OpenGL **application binary interface** (**ABI**) is frozen to OpenGL Version
    1.1 on Windows. Unfortunately for Windows developers, that means that it is not
    possible to link directly to functions that are provided in newer versions of
    OpenGL. Instead, one must gain access to the OpenGL functions by acquiring a function
    pointer at runtime. Getting access to the function pointers is not difficult,
    but requires somewhat tedious work, and has a tendency to clutter code. Additionally,
    Windows typically comes with a standard OpenGL `gl.h` file that also conforms
    to OpenGL 1.1.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，OpenGL的**应用程序二进制接口**（**ABI**）被冻结在OpenGL版本1.1。不幸的是，对于Windows开发者来说，这意味着无法直接链接到OpenGL新版本中提供的函数。相反，必须通过在运行时获取函数指针来访问OpenGL函数。获取函数指针并不困难，但需要一些繁琐的工作，并且有使代码杂乱无章的倾向。此外，Windows通常附带一个符合OpenGL
    1.1标准的标准OpenGL `gl.h`文件。
- en: The OpenGL wiki states that Microsoft has no plans to ever update the `gl.h`
    and `opengl32.lib` that come with their compilers. Thankfully, others have provided
    libraries that manage all of this for us by transparently providing the needed
    function pointers, while also exposing the needed functionality in header files.
    Such a library is called an **OpenGL Loading Library** (or **OpenGL function loader**),
    and there are several such libraries available. One of the oldest is **OpenGL
    Extension Wrangler** (**GLEW**). However, there are a few issues with GLEW. First,
    it provides one large header file that includes everything from all versions of
    OpenGL. It might be preferable to have a more streamlined header file that only
    includes functions that we might use. Second, GLEW is distributed as a library
    that needs to be compiled separately and linked into our project. I find it preferable
    to have a loader that can be included into a project simply by adding the source
    files and compiling them directly into our executable, avoiding the need to support
    another link-time dependency.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL维基百科指出，微软没有计划更新他们编译器附带的`gl.h`和`opengl32.lib`。幸运的是，其他人已经提供了通过透明地提供所需函数指针，同时在头文件中公开所需功能来为我们管理所有这些的库。这样的库被称为**OpenGL加载库**（或**OpenGL函数加载器**），有多个这样的库可用。其中最古老的一个是**OpenGL扩展包装器**（**GLEW**）。然而，GLEW有几个问题。首先，它提供了一个包含OpenGL所有版本中所有内容的单个大头文件。可能更倾向于有一个更精简的头文件，只包含我们可能使用的函数。其次，GLEW作为需要单独编译并链接到我们的项目的库进行分发。我发现有一个加载器，只需添加源文件并将其直接编译到我们的可执行文件中，就可以将其包含到项目中，避免了支持另一个链接时依赖的需要。
- en: In this recipe, we'll use a loader generator named GLAD, available from [https://github.com/Dav1dde/glad](https://github.com/Dav1dde/glad).
    This very flexible and efficient library can generate a header that includes only
    the needed functionality, and also generates just a few files (a source file and
    a few headers) that we can add directly into our project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用一个名为GLAD的加载器生成器，它可以从[https://github.com/Dav1dde/glad](https://github.com/Dav1dde/glad)获取。这个非常灵活且高效的库可以生成只包含所需功能的头文件，并且只生成几个文件（一个源文件和一些头文件），我们可以直接将其添加到我们的项目中。
- en: Getting ready
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use GLAD, you can either download and install it using `pip` (or from [https://github.com/Dav1dde/glad](https://github.com/Dav1dde/glad) ),
    or you can use the web service available here: [http://glad.dav1d.de/](http://glad.dav1d.de/).
    If you choose to install it, you'll need Python. The install is simple and described
    in detail on the GitHub page.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用GLAD，您可以通过`pip`下载并安装它（或从[https://github.com/Dav1dde/glad](https://github.com/Dav1dde/glad)），或者您可以使用这里提供的网络服务：[http://glad.dav1d.de/](http://glad.dav1d.de/)。如果您选择安装它，您将需要Python。安装很简单，GitHub页面上有详细的描述。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做这件事...
- en: 'The first step is to generate the header and source files for the OpenGL version
    and profile of your choice. For this example, we''ll generate files for an OpenGL
    4.6 core profile. We can then copy the files into our project and compile them
    directly alongside our code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是生成您选择的OpenGL版本和配置的头文件和源文件。在这个例子中，我们将为OpenGL 4.6核心配置生成文件。然后我们可以将这些文件复制到我们的项目中，并直接与我们的代码一起编译：
- en: 'To generate the header and source files, run the following command:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要生成头文件和源文件，请运行以下命令：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The previous step will generate its output into a directory named `GL`. There
    will be two directories: `GL/include` and `GL/src`. You can move the GL directory
    into your project as is, or move the individual files into appropriate locations.
    Include `GL/src/glad.c` in your build, and put `GL/include` into your `include`
    path. Within your program code, include `glad/glad.h` whenever you need access
    to the OpenGL functions. Note that this fully replaces `gl.h`, so there is no
    need to include that.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一步将生成输出到名为`GL`的目录中。将会有两个目录：`GL/include`和`GL/src`。你可以直接将GL目录移动到你的项目中，或者将单个文件移动到适当的位置。在构建时包含`GL/src/glad.c`，并将`GL/include`放入你的`include`路径中。在程序代码中，每当需要访问OpenGL函数时，请包含`glad/glad.h`。请注意，这完全替换了`gl.h`，因此不需要包含它。
- en: 'In order to initialize the function pointers, you need to make sure to call
    a function that does so. The needed function is `gladLoadGL()`. Somewhere just
    after the GL context is created (typically in an initialization function), and
    before any OpenGL functions are called, use the following code:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了初始化函数指针，你需要确保调用一个执行此操作的函数。所需的函数是`gladLoadGL()`。在创建GL上下文之后（通常在初始化函数中），在调用任何OpenGL函数之前，使用以下代码：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That's all there is to it!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The command in step 1 generates a few header files and a source file. The header
    provides prototypes for all of the selected OpenGL functions, redefines them as
    function pointers, and defines all of the OpenGL constants as well. The source
    file provides initialization code for the function pointers as well as some other
    utility functions. We can include the `glad/glad.h` header file wherever we need
    prototypes for OpenGL functions, so all function entry points are available at
    compile time. At runtime, the `gladLoadGL()` call will initialize all available
    function pointers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第1步的命令生成了一些头文件和源文件。头文件提供了所有选定OpenGL函数的原型，将它们重新定义为函数指针，并定义了所有OpenGL常量。源文件提供了函数指针的初始化代码以及一些其他实用函数。我们可以在需要OpenGL函数原型的任何地方包含`glad/glad.h`头文件，因此所有函数入口点在编译时都可用。在运行时，`gladLoadGL()`调用将初始化所有可用的函数指针。
- en: Some function pointers may not be successfully initialized. This might happen
    if your driver does not support the requested OpenGL version. If that happens,
    calling the functions will fail.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数指针可能无法成功初始化。这可能发生在你的驱动程序不支持请求的OpenGL版本时。如果发生这种情况，调用这些函数将失败。
- en: The command-line arguments available to GLAD are fully documented on the GitHub
    site and are available via `glad -h`. One can select any OpenGL version, select
    core/compatibility profiles, include desired extensions, and/or create debug callbacks.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: GLAD的可用命令行参数在GitHub网站上进行了全面文档记录，并且可以通过`glad -h`访问。可以选择任何OpenGL版本，选择核心/兼容性配置文件，包含所需的扩展，以及/或创建调试回调。
- en: There's more...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: GLAD provides a web service at [http://glad.dav1d.de/](http://glad.dav1d.de/)
    that makes it easy to generate the loader source and header files without installing
    GLAD. Simply visit the URL, select the desired configuration, and the loader files
    will be generated and downloaded.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: GLAD提供了一个位于[http://glad.dav1d.de/](http://glad.dav1d.de/)的Web服务，这使得在不安装GLAD的情况下生成加载器源文件和头文件变得容易。只需访问URL，选择所需的配置，加载器文件就会被生成并下载。
- en: See also
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `ingredients/scenerunner.h` file in the example code
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`ingredients/scenerunner.h`文件
- en: GLEW, an older, popular loader and extension manager, available from [http://glew.sourceforge.net](http://glew.sourceforge.net)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GLEW，一个较老但流行的加载器和扩展管理器，可以从[http://glew.sourceforge.net](http://glew.sourceforge.net)获取
- en: Using GLM for mathematics
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GLM进行数学运算
- en: Mathematics is the core to all of computer graphics. In earlier versions, OpenGL
    provided support for managing coordinate transformations and projections using
    the standard matrix stacks (`GL_MODELVIEW` and `GL_PROJECTION`). In modern versions
    of core OpenGL however, all of the functionality supporting the matrix stacks
    has been removed. Therefore, it is up to us to provide our own support for the
    usual transformation and projection matrices, and then pass them into our shaders.
    Of course, we could write our own matrix and vector classes to manage this, but
    some might prefer to use a ready-made, robust library.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数学是计算机图形学的核心。在早期版本中，OpenGL通过标准矩阵栈（`GL_MODELVIEW`和`GL_PROJECTION`）提供了管理坐标变换和投影的支持。然而，在现代核心OpenGL版本中，所有支持矩阵栈的功能都已删除。因此，我们必须提供自己的支持来处理通常的变换和投影矩阵，然后将它们传递到我们的着色器中。当然，我们可以编写自己的矩阵和向量类来管理这些，但有些人可能更喜欢使用现成的、健壮的库。
- en: One such library is **OpenGL Mathematics** (**GLM**), written by Christophe
    Riccio. Its design is based on the GLSL specification, so the syntax will be familiar
    to anyone using GLSL. Additionally, it provides extensions that include functionality
    similar to some of the much-missed OpenGL utility functions, such as `glOrtho`,
    `glRotate`, or `gluLookAt`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有这样一个库，就是由Christophe Riccio编写的**OpenGL Mathematics**（**GLM**）。其设计基于GLSL规范，因此语法对使用GLSL的人来说很熟悉。此外，它还提供了包含类似于一些被广泛怀念的OpenGL实用函数的功能的扩展，例如`glOrtho`、`glRotate`或`gluLookAt`。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Since GLM is a header-only library, the installation is simple. Download the
    latest GLM distribution from [http://glm.g-truc.net](http://glm.g-truc.net). Then,
    unzip the archive file, and copy the `glm` directory contained inside to anywhere
    in your compiler's include path.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GLM是一个仅包含头文件的库，安装很简单。从[http://glm.g-truc.net](http://glm.g-truc.net)下载最新的GLM发行版。然后，解压缩存档文件，并将包含在其中的`glm`目录复制到编译器的包含路径中的任何位置。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To use the GLM libraries, include the core header file, and headers for any
    extensions. For this example, we''ll include the matrix transform extension:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用GLM库，需要包含核心头文件以及任何扩展的头文件。对于这个例子，我们将包含矩阵变换扩展：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The GLM classes are available in the `glm` namespace. The following is an example
    of how you might go about making use of some of them:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: GLM类在`glm`命名空间中可用。以下是如何使用其中一些类的示例：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The GLM library is a header-only library. All of the implementation is included
    within the header files. It doesn't require separate compilation and you don't
    need to link your program to it. Just placing the header files in your include
    path is all that's required!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: GLM库是一个仅包含头文件的库。所有的实现都包含在头文件中。它不需要单独编译，也不需要将你的程序链接到它。只需将头文件放在你的包含路径中即可！
- en: The previous example first creates `vec4` (a four-component vector), which represents
    a position. Then, it creates a 4 x 4 view matrix by using the `glm::lookAt` function.
    This works in a similar fashion to the old `gluLookAt` function. Here, we set
    the camera's location at (0, 0, 5), looking toward the origin, with the *up* direction
    in the direction of the positive *y* axis. We then go on to create the model matrix
    by first storing the identity matrix in the `model` variable (via the single-argument
    constructor), and multiplying it by a rotation matrix using the `glm::rotate`
    function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子首先创建了一个`vec4`（一个四分量向量），它代表一个位置。然后，它使用`glm::lookAt`函数创建了一个4 x 4的视图矩阵。这与旧的`gluLookAt`函数类似。在这里，我们将摄像机的位置设置为(0,
    0, 5)，朝向原点，*向上*方向沿着正*y*轴。然后，我们继续创建模型矩阵，首先将单位矩阵存储在`model`变量中（通过单参数构造函数），然后使用`glm::rotate`函数乘以一个旋转矩阵。
- en: The multiplication here is implicitly done by the `glm::rotate` function. It
    multiplies its first parameter by the rotation matrix (on the right) that is generated
    by the function. The second parameter is the angle of rotation (in degrees), and
    the third parameter is the axis of rotation. Since before this statement, `model`
    is the identity matrix, the net result is that `model` becomes a rotation matrix
    of 90 degrees around the *y* axis.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的乘法是由`glm::rotate`函数隐式完成的。它将其第一个参数乘以由函数生成的旋转矩阵（在右侧）。第二个参数是旋转角度（以度为单位），第三个参数是旋转轴。由于在此语句之前，`model`是单位矩阵，所以最终结果是`model`变成了绕*y*轴旋转90度的旋转矩阵。
- en: Finally, we create our model-view matrix (`mv`) by multiplying the `view` and
    `model` variables, and then use the combined matrix to transform the position.
    Note that the multiplication operator has been overloaded to behave in the expected
    way.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将`view`和`model`变量相乘来创建我们的模型视图矩阵（`mv`），然后使用组合矩阵来变换位置。请注意，乘法运算符已被重载以按预期的方式工作。
- en: The order is important here. Typically, the model matrix represents a transformation
    from object space to world space, and the view matrix is a transformation from
    world space to camera space. So to get a single matrix that transforms from object
    space to camera space, we want the model matrix to apply first. Therefore, the
    model matrix is multiplied on the right-hand side of the view matrix.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序在这里很重要。通常，模型矩阵表示从对象空间到世界空间的转换，视图矩阵是从世界空间到相机空间的转换。因此，为了得到一个从对象空间到相机空间的转换的单个矩阵，我们希望模型矩阵首先应用。因此，模型矩阵被乘在视图矩阵的右侧。
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It is *not recommended* to import all of the GLM namespaces using the following
    command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议使用以下命令导入所有GLM命名空间：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will most likely cause a number of namespace clashes. Instead, it is preferable
    to import symbols one at a time with the `using` statements as needed. For example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这很可能会引起许多命名空间冲突。因此，最好根据需要使用`using`语句逐个导入符号。例如：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the GLM types as input to OpenGL
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GLM类型作为OpenGL的输入
- en: 'GLM supports directly passing a GLM type to OpenGL using one of the OpenGL
    vector functions (with the `v` suffix). For example, to pass `mat4` named `proj`
    to OpenGL, we can use the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: GLM支持直接使用OpenGL的其中一个OpenGL向量函数（带有`v`后缀）将GLM类型传递给OpenGL。例如，要将名为`proj`的`mat4`传递给OpenGL，我们可以使用以下代码：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, rather than using the ampersand operator, we can use the `glm::value_ptr`
    function to get a pointer to the content of the GLM type:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，而不是使用和号运算符，我们可以使用`glm::value_ptr`函数来获取GLM类型内容的指针：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The latter version requires including the header file `glm/gtc/type_ptr.hpp`.
    The use of `value_ptr` is arguably cleaner, and works for any GLM type.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 后者版本需要包含头文件`glm/gtc/type_ptr.hpp`。使用`value_ptr`可以说是更干净的方法，并且适用于任何GLM类型。
- en: See also
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The Qt SDK includes many classes for vector/matrix mathematics, and is another
    good option if you're already using Qt
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt SDK包括许多用于向量/矩阵数学的类，如果你已经在使用Qt，这也是一个不错的选择。
- en: The GLM website ([http://glm.g-truc.net](http://glm.g-truc.net)) has additional
    documentation and examples
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GLM网站([http://glm.g-truc.net](http://glm.g-truc.net))有额外的文档和示例
- en: Determining the GLSL and OpenGL version
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定GLSL和OpenGL版本
- en: 'In order to support a wide range of systems, it is essential to be able to
    query for the supported OpenGL and GLSL version of the current driver. It is quite
    simple to do so, and there are two main functions involved: `glGetString` and
    `glGetIntegerv`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持广泛系统，能够查询当前驱动程序支持的OpenGL和GLSL版本是至关重要的。这样做相当简单，涉及两个主要函数：`glGetString`和`glGetIntegerv`。
- en: Note that these functions must be called after the OpenGL context has been created.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些函数必须在OpenGL上下文创建之后调用。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The following code will print the version information to `stdout`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将版本信息打印到`stdout`：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Note that there are two different ways to retrieve the OpenGL version: using
    `glGetString` and `glGetIntegerv`. The former can be useful for providing readable
    output, but may not be as convenient for programmatically checking the version
    because of the need to parse the string. The string provided by `glGetString(GL_VERSION)`
    should always begin with the major and minor versions separated by a dot, however,
    the minor version could be followed with a vendor-specific build number. Additionally,
    the rest of the string can contain additional vendor-specific information and
    may also include information about the selected profile (see the *Introduction*
    section of this chapter). It is important to note that the use of `glGetIntegerv`
    to query for version information requires OpenGL 3.0 or greater.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有两种不同的方式来检索OpenGL版本：使用`glGetString`和`glGetIntegerv`。前者可以提供可读的输出，但由于需要解析字符串，可能不适合程序化检查版本。`glGetString(GL_VERSION)`提供的字符串应该始终以点分隔的主版本和次版本开始，然而，次版本可能后面跟着供应商特定的构建号。此外，字符串的其余部分可以包含额外的供应商特定信息，也可能包括所选配置文件的信息（参见本章的*简介*部分）。重要的是要注意，使用`glGetIntegerv`查询版本信息需要OpenGL
    3.0或更高版本。
- en: The queries for `GL_VENDOR` and `GL_RENDERER` provide additional information
    about the OpenGL driver. The `glGetString(GL_VENDOR)` call returns the company
    responsible for the OpenGL implementation. The call to `glGetString(GL_RENDERER)`
    provides the name of the renderer, which is specific to a particular hardware
    platform (such as the ATI Radeon HD 5600 Series). Note that both of these do not
    vary from release to release, so they can be used to determine the current platform.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`GL_VENDOR`和`GL_RENDERER`的查询提供了关于OpenGL驱动程序额外的信息。`glGetString(GL_VENDOR)`调用返回负责OpenGL实现的公司的名称。`glGetString(GL_RENDERER)`调用提供渲染器的名称，这是特定于某个硬件平台（例如ATI
    Radeon HD 5600系列）的。请注意，这两个值在版本之间不会变化，因此可以用来确定当前平台。
- en: Of more importance to us in the context of this book is the call to `glGetString(GL_SHADING_LANGUAGE_VERSION)`, which
    provides the supported GLSL version number. This string should begin with the
    major and minor version numbers separated by a period, but similar to the `GL_VERSION`
    query, may include other vendor-specific information.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的上下文中，对我们来说更重要的是对`glGetString(GL_SHADING_LANGUAGE_VERSION)`的调用，它提供了支持的GLSL版本号。这个字符串应该以点分隔的主版本号和次版本号开始，但与`GL_VERSION`查询类似，可能包含其他供应商特定的信息。
- en: There's more...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'It is often useful to query for the supported extensions of the current OpenGL
    implementation.  Extension names are indexed and can be individually queried by
    index. We use the `glGetStringi` variant for this. For example, to get the name
    of the extension stored at index `i`, we use `glGetStringi(GL_EXTENSIONS, i)`.
    To print a list of all extensions, we could use the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 查询当前OpenGL实现的受支持扩展通常很有用。扩展名称是索引的，并且可以通过索引单独查询。我们使用`glGetStringi`变体来完成这个操作。例如，要获取存储在索引`i`处的扩展名称，我们使用`glGetStringi(GL_EXTENSIONS,
    i)`。要打印所有扩展的列表，我们可以使用以下代码：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Compiling a shader
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译着色器
- en: To get started, we need to know how to compile our GLSL shaders. The GLSL compiler
    is built right into the OpenGL library, and shaders can only be compiled within
    the context of a running OpenGL program.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要知道如何编译我们的GLSL着色器。GLSL编译器直接构建在OpenGL库中，着色器只能在运行中的OpenGL程序上下文中编译。
- en: OpenGL 4.1 added the ability to save compiled shader programs to a file, enabling
    OpenGL programs to avoid the overhead of shader compilation by loading precompiled
    shader programs (see the *Saving and loading a shader binary* recipe). OpenGL
    4.6 added the ability to load shader programs compiled to (or written in) SPIR-V,
    an intermediate language for defining shaders. See the *Loading an SPIR-V shader* recipe
    later in this chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 4.1增加了将编译的着色器程序保存到文件的能力，使OpenGL程序能够通过加载预编译的着色器程序来避免着色器编译的开销（请参阅*保存和加载着色器二进制文件*食谱）。OpenGL
    4.6增加了加载编译为（或用）SPIR-V的着色器程序的能力，SPIR-V是定义着色器的中间语言。请参阅本章后面的*加载SPIR-V着色器*食谱。
- en: 'Compiling a shader involves creating a shader object, providing the source
    code (as a string or set of strings) to the shader object, and asking the shader
    object to compile the code. The process is roughly represented by the following
    diagram:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 编译着色器涉及创建一个着色器对象，向着色器对象提供源代码（作为字符串或字符串集），并要求着色器对象编译代码。这个过程大致可以用以下图表表示：
- en: '![](img/90cfaa2f-79fa-495e-ae00-ce05d1b0152a.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90cfaa2f-79fa-495e-ae00-ce05d1b0152a.png)'
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To compile a shader, we''ll need a basic example to work with. Let''s start
    with the following simple vertex shader. Save it in a file named `basic.vert.glsl`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译一个着色器，我们需要一个基本示例来工作。让我们从以下简单的顶点着色器开始。将其保存为名为`basic.vert.glsl`的文件：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In case you're curious about what this code does, it works as a "pass-through"
    shader. It takes the `VertexPosition` and `VertexColor` input attributes and passes
    them to the fragment shader via the `gl_Position` and `Color` output variables.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对这段代码的功能感到好奇，它作为一个“传递”着色器工作。它接受`VertexPosition`和`VertexColor`输入属性，并通过`gl_Position`和`Color`输出变量将它们传递给片段着色器。
- en: Next, we'll need to build a basic shell for an OpenGL program using a Window
    toolkit that supports OpenGL. Examples of cross-platform toolkits include GLFW,
    GLUT, FLTK, Qt, and wxWidgets. Throughout this text, I'll make the assumption
    that you can create a basic OpenGL program with your favorite toolkit. Virtually
    all toolkits have a hook for an initialization function, a resize callback (called
    upon resizing the window), and a drawing callback (called for each window refresh).
    For the purposes of this recipe, we need a program that creates and initializes
    an OpenGL context; it need not do anything other than display an empty OpenGL
    window. Note that you'll also need to load the OpenGL function pointers (refer
    to the *Using a loading library to access the latest OpenGL functionality* recipe).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用支持OpenGL的窗口工具包构建一个OpenGL程序的基本外壳。跨平台工具包的例子包括GLFW、GLUT、FLTK、Qt和wxWidgets。在整个文本中，我将假设您可以使用您喜欢的工具包创建一个基本的OpenGL程序。几乎所有的工具包都有一个初始化函数的钩子、一个窗口调整大小回调（在调整窗口大小时调用）和一个绘制回调（在每次窗口刷新时调用）。为了本食谱的目的，我们需要一个创建并初始化OpenGL上下文的程序；它不需要做任何事情，只需显示一个空的OpenGL窗口。请注意，您还需要加载OpenGL函数指针（请参阅*使用加载库访问最新的OpenGL功能*食谱）。
- en: Finally, load the shader source code into `std::string` (or the char array).
    The following example assumes that the `shaderCode` variable is `std::string`
    containing the shader source code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将着色器源代码加载到`std::string`（或字符数组）中。以下示例假设`shaderCode`变量是一个包含着色器源代码的`std::string`。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To compile a shader, use the following steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译一个着色器，请按照以下步骤操作：
- en: 'Create the shader object:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建着色器对象：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Copy the source code into the shader object:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源代码复制到着色器对象中：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compile the shader:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译着色器：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Verify the compilation status:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证编译状态：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first step is to create the shader object using the `glCreateShader` function.
    The argument is the type of shader, and can be one of the following: `GL_VERTEX_SHADER`,
    `GL_FRAGMENT_SHADER`, `GL_GEOMETRY_SHADER`, `GL_TESS_EVALUATION_SHADER`, `GL_TESS_CONTROL_SHADER`,
    or (as of version 4.3) `GL_COMPUTE_SHADER`. In this case, since we are compiling
    a vertex shader, we use `GL_VERTEX_SHADER`. This function returns the value used
    for referencing the vertex shader object, sometimes called the **object handle**.
    We store that value in the `vertShader` variable. If an error occurs while creating
    the shader object, this function will return 0, so we check for that and if it
    occurs, we print an appropriate message and terminate.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用`glCreateShader`函数创建着色器对象。参数是着色器的类型，可以是以下之一：`GL_VERTEX_SHADER`、`GL_FRAGMENT_SHADER`、`GL_GEOMETRY_SHADER`、`GL_TESS_EVALUATION_SHADER`、`GL_TESS_CONTROL_SHADER`，或者（自版本4.3起）`GL_COMPUTE_SHADER`。在这种情况下，由于我们正在编译顶点着色器，我们使用`GL_VERTEX_SHADER`。这个函数返回用于引用顶点着色器对象的值，有时称为**对象句柄**。我们将该值存储在`vertShader`变量中。如果在创建着色器对象时发生错误，此函数将返回0，因此我们检查该错误，如果发生，我们打印一条适当的消息并终止。
- en: Following the creation of the shader object, we load the source code into the
    shader object using the `glShaderSource` function. This function is designed to
    accept an array of strings (as opposed to just a single one) in order to support
    the option of compiling multiple sources (files, strings) at once. So before we
    call `glShaderSource`, we place a pointer to our source code into an array named
    `sourceArray`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建着色器对象之后，我们使用`glShaderSource`函数将源代码加载到着色器对象中。这个函数被设计用来接受一个字符串数组（而不是单个字符串），以便支持一次性编译多个源代码（文件、字符串）的选项。因此，在我们调用`glShaderSource`之前，我们将源代码的指针放入一个名为`sourceArray`的数组中。
- en: The first argument to `glShaderSource` is the handle to the shader object. The
    second is the number of source code strings that are contained in the array. The
    third argument is a pointer to an array of source code strings. The final argument
    is an array of `GLint` values that contain the length of each source code string
    in the previous argument.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`glShaderSource`的第一个参数是着色器对象的句柄。第二个是数组中包含的源代码字符串的数量。第三个参数是指向源代码字符串数组的指针。最后一个参数是一个`GLint`值数组，包含前一个参数中每个源代码字符串的长度。'
- en: In the previous code, we pass a value of `NULL`, which indicates that each source
    code string is terminated by a null character. If our source code strings were
    not null terminated, then this argument must be a valid array. Note that once
    this function returns, the source code has been copied into the OpenGL internal
    memory, so the memory used to store the source code can be freed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们传递了一个`NULL`值，这表示每个源代码字符串由一个空字符终止。如果我们的源代码字符串没有空终止，那么这个参数必须是一个有效的数组。请注意，一旦这个函数返回，源代码已经被复制到OpenGL内部内存中，因此可以释放存储源代码的内存。
- en: The next step is to compile the source code for the shader. We do this by simply
    calling `glCompileShader`, and passing the handle to the shader that is to be
    compiled. Of course, depending on the correctness of the source code, the compilation
    may fail, so the next step is to check whether the compilation was successful.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是编译着色器的源代码。我们通过简单地调用`glCompileShader`并传递要编译的着色器的句柄来完成这个操作。当然，根据源代码的正确性，编译可能会失败，所以下一步是检查编译是否成功。
- en: We can query for the compilation status by calling `glGetShaderiv`, which is
    a function for querying the attributes of a shader object. In this case, we are
    interested in the compilation status, so we use `GL_COMPILE_STATUS` as the second
    argument. The first argument is of course the handle to the shader object, and
    the third argument is a pointer to an integer where the status will be stored.
    The function provides a value of either `GL_TRUE` or `GL_FALSE` in the third argument,
    indicating whether the compilation was successful.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用 `glGetShaderiv` 来查询编译状态，这是一个用于查询着色器对象属性的函数。在这种情况下，我们感兴趣的是编译状态，所以我们使用
    `GL_COMPILE_STATUS` 作为第二个参数。第一个参数当然是着色器对象的句柄，第三个参数是一个指向整数的指针，其中将存储状态。该函数在第三个参数中提供一个值为
    `GL_TRUE` 或 `GL_FALSE` 的值，指示编译是否成功。
- en: If the compile status is `GL_FALSE`, we can query for the shader log, which
    will provide additional details about the failure. We do so by first querying
    for the length of the log by calling `glGetShaderiv` again with a value of `GL_INFO_LOG_LENGTH`.
    This provides the length of the log in the `logLen` variable. Note that this includes
    the null termination character. We then allocate space for the log, and retrieve
    the log by calling `glGetShaderInfoLog`. The first parameter is the handle to
    the shader object, the second is the size of the character buffer for storing
    the log, the third argument is a pointer to an integer where the number of characters
    actually written (excluding the null terminator character) will be stored, and
    the fourth argument is a pointer to the character buffer for storing the log itself.
    Once the log is retrieved, we print it to `stderr` and free its memory space.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译状态为 `GL_FALSE`，我们可以查询着色器日志，这将提供关于失败原因的额外详细信息。我们通过再次调用 `glGetShaderiv` 并传入值
    `GL_INFO_LOG_LENGTH` 来查询日志的长度。这将在 `logLen` 变量中提供日志的长度。请注意，这包括空终止字符。然后我们为日志分配空间，并通过调用
    `glGetShaderInfoLog` 来检索日志。第一个参数是着色器对象的句柄，第二个参数是用于存储日志的字符缓冲区的大小，第三个参数是一个指向整数的指针，其中将存储实际写入的字符数（不包括空终止字符），第四个参数是用于存储日志本身的字符缓冲区的指针。一旦检索到日志，我们就将其打印到
    `stderr` 并释放其内存空间。
- en: There's more...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The previous example only demonstrated how to compile a vertex shader. There
    are several other types of shaders, including fragment, geometry, and tessellation
    shaders. The technique for compiling is nearly identical for each shader type.
    The only significant difference is the argument to `glCreateShader`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例仅演示了如何编译顶点着色器。还有几种其他类型的着色器，包括片段、几何和细分着色器。每种着色器类型的编译技术几乎相同。唯一的显著区别是 `glCreateShader`
    的参数。
- en: It is also important to note that shader compilation is only the first step.
    Similar to a language like C++, we need to link the program. While shader programs
    can consist of a single shader, for many use cases we have to compile two or more
    shaders, and then the shaders must be linked together into a shader program object.
    We'll see the steps involved in linking in the next recipe.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，着色器编译只是第一步。类似于 C++ 这样的语言，我们需要链接程序。虽然着色器程序可以只包含一个着色器，但对于许多用例，我们必须编译两个或更多着色器，然后这些着色器必须链接成一个着色器程序对象。我们将在下一个配方中看到链接的步骤。
- en: Deleting a shader object
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除着色器对象
- en: Shader objects can be deleted when no longer needed by calling `glDeleteShader`.
    This frees the memory used by the shader and invalidates its handle. Note that
    if a shader object is already attached to a program object (refer to the *Linking
    a shader program* recipe), it will not be immediately deleted, but flagged for
    deletion when it is detached from the program object.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再需要时，可以通过调用 `glDeleteShader` 来删除着色器对象。这将释放着色器使用的内存并使句柄无效。请注意，如果着色器对象已经附加到程序对象（参考
    *链接着色器程序* 配方），则它不会立即被删除，而是在从程序对象断开连接时标记为删除。
- en: See also
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter01/scenebasic.cpp` file in the example code
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter01/scenebasic.cpp` 文件
- en: The *Linking a shader program* recipe
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*链接着色器程序* 的配方'
- en: Linking a shader program
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接着色器程序
- en: Once we have compiled our shaders and before we can actually install them into
    the OpenGL pipeline, we need to link them together into a shader program. Among
    other things, the linking step involves making the connections between input variables
    from one shader to output variables of another, and making the connections between
    the input/output variables of a shader to appropriate locations in the OpenGL
    environment.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编译了我们的着色器之后，在我们实际上可以将它们安装到 OpenGL 管道之前，我们需要将它们链接成一个着色器程序。链接步骤包括将一个着色器的输入变量与另一个着色器的输出变量之间的连接，以及将着色器的输入/输出变量与
    OpenGL 环境中的适当位置之间的连接。
- en: 'Linking involves steps that are similar to those involved in compiling a shader.
    We attach each shader object to a new shader program object and then tell the
    shader program object to link (making sure that the shader objects are compiled
    before linking):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 链接涉及与编译着色器时涉及的步骤相似的步骤。我们将每个着色器对象附加到一个新的着色器程序对象上，然后告诉着色器程序对象进行链接（确保在链接之前着色器对象已经编译）：
- en: '![](img/c60725c9-ea4e-48c4-bc30-0ac5979bc266.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c60725c9-ea4e-48c4-bc30-0ac5979bc266.png)'
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll assume that you've already compiled two shader objects
    whose handles are stored in the `vertShader` and `fragShader` variables.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们假设你已经编译了两个着色器对象，其句柄存储在 `vertShader` 和 `fragShader` 变量中。
- en: 'For this and a few other recipes in this chapter, we''ll use the following
    source code for the fragment shader:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的这个和其他几个配方，我们将使用以下源代码作为片段着色器：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For the vertex shader, we'll use the source code from the previous recipe, *Compiling
    a shader*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于顶点着色器，我们将使用前一个配方中的源代码，*编译着色器*。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In our OpenGL initialization function, and after the compilation of shader
    objects referred to by `vertShader` and `fragShader`, perform the following steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 OpenGL 初始化函数中，并在 `vertShader` 和 `fragShader` 指向的着色器对象编译之后，执行以下步骤：
- en: 'Create the program object using the following code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建程序对象：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Attach the shaders to the program object as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式将着色器附加到程序对象上：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Link the program:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接程序：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Verify the link status:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证链接状态：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If linking is successful, we can install the program into the OpenGL pipeline
    with `glUseProgram`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果链接成功，我们可以使用 `glUseProgram` 将程序安装到 OpenGL 管道中：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Regardless of whether the link was successful, it is a good idea to clean up
    our shader objects. Once the program is linked, they are not needed anymore:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 无论链接是否成功，清理我们的着色器对象都是一个好主意。一旦程序链接，它们就不再需要了：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start by calling `glCreateProgram` to create an empty program object. This
    function returns a handle to the program object, which we store in a variable
    named `programHandle`. If an error occurs with program creation, the function
    will return 0\. We check for that, and if it occurs, we print an error message
    and exit.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用 `glCreateProgram` 来创建一个空的程序对象。这个函数返回程序对象的句柄，我们将其存储在一个名为 `programHandle`
    的变量中。如果程序创建出现错误，该函数将返回 0。我们检查这一点，如果发生错误，我们打印一条错误消息并退出。
- en: Next, we attach each shader to the program object using `glAttachShader`. The
    first argument is the handle to the program object, and the second is the handle
    to the shader object to be attached.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `glAttachShader` 将每个着色器附加到程序对象上。第一个参数是程序对象的句柄，第二个是要附加的着色器对象的句柄。
- en: Then, we link the program by calling `glLinkProgram`, providing the handle to
    the program object as the only argument. As with compilation, we check for the
    success or failure of the link, with the subsequent query.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用 `glLinkProgram` 并提供程序对象的句柄作为唯一参数来链接程序。与编译类似，我们检查链接的成功或失败，并进行后续查询。
- en: We check the status of the link by calling `glGetProgramiv`. Similar to `glGetShaderiv`,
    `glGetProgramiv` allows us to query various attributes of the shader program.
    In this case, we ask for the status of the link by providing `GL_LINK_STATUS`
    as the second argument. The status is returned in the location pointed to by the
    third argument, in this case named `status`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `glGetProgramiv` 来检查链接状态。类似于 `glGetShaderiv`，`glGetProgramiv` 允许我们查询着色器程序的各种属性。在这种情况下，我们通过提供
    `GL_LINK_STATUS` 作为第二个参数来请求链接状态。状态被返回到第三个参数指向的位置，在这个例子中命名为 `status`。
- en: The link status is either `GL_TRUE` or `GL_FALSE`, indicating the success or
    failure of the link. If the value of the status is `GL_FALSE`, we retrieve and
    display the program information log, which should contain additional information
    and error messages. The program log is retrieved by the call to `glGetProgramInfoLog`.
    The first argument is the handle to the program object, the second is the size
    of the buffer to contain the log, the third is a pointer to a `GLsizei` variable
    where the number of bytes written to the buffer will be stored (excluding the
    null terminator), and the fourth is a pointer to the buffer that will store the
    log. The buffer can be allocated based on the size returned by the call to `glGetProgramiv`
    with the `GL_INFO_LOG_LENGTH` parameter. The string that is provided in `log`
    will be properly null terminated.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 链接状态为`GL_TRUE`或`GL_FALSE`，表示链接成功或失败。如果状态值为`GL_FALSE`，我们将检索并显示程序信息日志，其中应包含额外的信息和错误消息。程序日志是通过调用`glGetProgramInfoLog`检索的。第一个参数是程序对象的句柄，第二个是包含日志的缓冲区大小，第三个是指向一个`GLsizei`变量的指针，其中将存储写入缓冲区的字节数（不包括空终止符），第四个是指向将存储日志的缓冲区的指针。缓冲区可以根据调用`glGetProgramiv`时返回的大小来分配，参数为`GL_INFO_LOG_LENGTH`。`log`中提供的字符串将被正确地空终止。
- en: Finally, if the link is successful, we install the program into the OpenGL pipeline
    by calling `glUseProgram`, providing the handle to the program as the argument.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果链接成功，我们通过调用`glUseProgram`将程序安装到OpenGL管道中，提供程序句柄作为参数。
- en: It is a good idea to detach and delete the shader object, regardless of whether
    the link is successful. However, if the shader objects might be needed to link
    another program, you should detach it from this program and skip deletion until
    later.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 无论链接是否成功，将着色器对象分离并删除都是一个好主意。然而，如果着色器对象可能需要链接另一个程序，你应该将其从该程序中分离出来，并跳过删除操作，直到稍后。
- en: 'With the simple fragment shader from this recipe and the vertex shader from
    the previous recipe compiled, linked, and installed into the OpenGL pipeline,
    we have a complete OpenGL pipeline and are ready to begin rendering. Drawing a
    triangle and supplying different values for the `Color` attribute yields an image
    of a multi-colored triangle where the vertices are red, green, and blue, and inside
    the triangle, the three colors are interpolated, causing a blending of colors
    throughout:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编译、链接并将本食谱中的简单片元着色器和前一个食谱中的顶点着色器安装到OpenGL管道中，我们得到了一个完整的OpenGL管道，并准备好开始渲染。绘制一个三角形并为`Color`属性提供不同的值，可以得到一个多色三角形的图像，其中顶点是红色、绿色和蓝色，三角形内部三种颜色被插值，导致颜色在整个三角形中混合：
- en: '![](img/701126dc-268e-476c-8980-95009dce1ceb.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/701126dc-268e-476c-8980-95009dce1ceb.png)'
- en: For details on how to render the triangle, see [Chapter 2](15752c1f-eee7-4117-9632-f08f84a9405d.xhtml),
    *Working with GLSL Programs*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何渲染三角形的详细信息，请参阅[第2章](15752c1f-eee7-4117-9632-f08f84a9405d.xhtml)，*使用GLSL程序*。
- en: There's more...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: You can use multiple shader programs within a single OpenGL program. They can
    be swapped in and out of the OpenGL pipeline by calling `glUseProgram` to select
    the desired program.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在单个OpenGL程序中使用多个着色器程序。可以通过调用`glUseProgram`来选择所需的程序，在OpenGL管道中交换它们。
- en: Shader input/output variables
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器输入/输出变量
- en: You may have noticed that the `Color` variable is used to send data from the
    vertex shader to the fragment shader. There is an output variable (`out vec3`)
    in the vertex shader and an input variable (`in vec3`) in the fragment shader,
    both with the same name. The value that the fragment shader receives is a value
    that is interpolated from the values of the corresponding output variable for
    each of the vertices (hence the blended colors in the earlier image). This interpolation
    is automatically done by hardware rasterizer before the execution of the fragment
    stage.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，`Color`变量被用来从顶点着色器向片元着色器发送数据。在顶点着色器中有一个输出变量（`out vec3`），在片元着色器中有一个输入变量（`in
    vec3`），它们具有相同的名称。片元着色器接收到的值是从每个顶点相应的输出变量的值插值得到的（因此产生了前面图像中的混合颜色）。这种插值是在执行片元阶段之前由硬件光栅化器自动完成的。
- en: When linking a shader program, OpenGL makes the connections between input and
    output variables in the vertex and fragment shaders (among other things). If a
    vertex shader's output variable has the same name and type as a fragment shader's
    input variable, OpenGL will automatically *link* them together.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当链接着色器程序时，OpenGL会在顶点着色器和片段着色器（以及其他方面）之间建立输入和输出变量的连接。如果一个顶点着色器的输出变量与片段着色器的输入变量具有相同的名称和类型，OpenGL将自动将它们*链接*在一起。
- en: 'It is possible to connect (link) variables that do not have the same name or
    type by using layout qualifiers. With a layout qualifier, we can specify the location
    for each variable specifically. For example, suppose that I used this set of output
    variables in my vertex shader:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用布局限定符来连接（链接）名称或类型不同的变量。使用布局限定符，我们可以为每个变量指定特定的位置。例如，假设我在我的顶点着色器中使用了这组输出变量：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'I could use these variables in the fragment shader:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在片段着色器中使用这些变量：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Despite the fact that these have different names (and for `Color`, types), they
    will be connected by the linker when the program is linked due to the fact that
    they are assigned the same locations. In this example, `VertColor` will be linked
    to `Color`, and `VertNormal` will be linked to `Normal`. This makes things more
    convenient. We're not required to use the same names for input/output variables,
    which gives us the flexibility to use names that might be more descriptive in
    each shader stage. More importantly, it is part of a larger framework, called
    **separate shader objects**. A full example of separate shader objects can be
    found in the *Using program pipelines* recipe.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些变量具有不同的名称（以及对于`Color`，类型），但由于它们被分配了相同的地址，它们将在程序链接时由链接器连接。在这个例子中，`VertColor`将被链接到`Color`，而`VertNormal`将被链接到`Normal`。这使得事情更加方便。我们不需要为输入/输出变量使用相同的名称，这给了我们使用在每个着色器阶段可能更具描述性的名称的灵活性。更重要的是，它是称为**独立着色器对象**的更大框架的一部分。可以在*使用程序管道*菜谱中找到独立着色器对象的完整示例。
- en: In fact, this use of layout qualifiers to specify variable locations *is required*
    when compiling to SPIR-V (see the *Loading an SPIR-V shader program* recipe).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当编译到SPIR-V时，使用布局限定符来指定变量位置是*必需的*（请参阅*加载SPIR-V着色器程序*菜谱）。
- en: Deleting a shader program
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除着色器程序
- en: If a program is no longer needed, it can be deleted from OpenGL memory by calling
    `glDeleteProgram`, providing the program handle as the only argument. This invalidates
    the handle and frees the memory used by the program. Note that if the program
    object is currently in use, it will not be immediately deleted, but will be flagged
    for deletion when it is no longer in use.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不再需要程序，可以通过调用`glDeleteProgram`从OpenGL内存中删除它，将程序句柄作为唯一参数提供。这将使句柄无效并释放程序使用的内存。请注意，如果程序对象当前正在使用中，它将不会立即被删除，而是在不再使用时被标记为删除。
- en: Also, the deletion of a shader program detaches the shader objects that were
    attached to the program but does not delete them unless those shader objects have
    already been flagged for deletion by a previous call to `glDeleteShader`. Therefore,
    as mentioned before, it is a good idea to detach and delete them immediately,
    as soon as the program is linked, to avoid accidentally leaking shader objects.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，删除着色器程序会断开附加到程序上的着色器对象，但不会删除它们，除非这些着色器对象已经被之前的`glDeleteShader`调用标记为删除。因此，正如之前提到的，在程序链接后立即断开并删除它们是一个好主意，以避免意外泄漏着色器对象。
- en: See also
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter01/scenebasic.cpp` file in the example code
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter01/scenebasic.cpp`文件
- en: The *Compiling a shader* recipe
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编译着色器*菜谱'
- en: The *Using program pipelines* recipe
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用程序管道*菜谱'
- en: The *Loading an SPIR-V shader program* recipe
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载SPIR-V着色器程序*菜谱'
- en: Saving and loading a shader binary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和加载着色器二进制文件
- en: OpenGL 4.1 introduced the `glGetProgramBinary` and `glProgramBinary` functions,
    which allow us to save and load compiled shader program binaries. Note that this
    functionality is still quite dependent on the OpenGL driver, and is not widely
    supported. For example, the Intel drivers on macOS do not support any binary formats.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL 4.1引入了`glGetProgramBinary`和`glProgramBinary`函数，允许我们保存和加载编译后的着色器程序二进制文件。请注意，此功能仍然非常依赖于OpenGL驱动程序，并且支持范围有限。例如，macOS上的Intel驱动程序不支持任何二进制格式。
- en: Unfortunately, Apple has deprecated OpenGL in macOS Mojave.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，苹果公司在macOS Mojave中已经弃用了OpenGL。
- en: In this recipe, we'll outline the steps involved in saving and loading a compiled
    shader program.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将概述保存和加载编译后的着色器程序所需的步骤。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll begin assuming that a shader program has been successfully compiled, and
    its ID is in the `program` variable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设一个着色器程序已经成功编译，并且其 ID 存储在 `program` 变量中。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To save the shader binary, first verify that the driver supports at least one
    shader binary format:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存着色器二进制文件，首先验证驱动程序至少支持一种着色器二进制格式：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, assuming at least one binary format is available, use `glGetProgramBinary`
    to retrieve the compiled shader code and write it to a file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，假设至少有一个二进制格式可用，使用 `glGetProgramBinary` 来检索编译后的着色器代码并将其写入文件：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To load and use a shader binary, retrieve the compiled program from storage,
    and use `glProgramBinary` to load it into the OpenGL context:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载和使用着色器二进制文件，从存储中检索编译后的程序，并使用 `glProgramBinary` 将其加载到 OpenGL 上下文中：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Drivers can support zero or more binary formats. The call to `glGetIntegerv`
    with the `GL_NUM_PROGRAM_BINARY_FORMATS` constant queries the driver to see how
    many are available. If this number is zero, the OpenGL driver does not support
    reading or writing shader binaries. If the value is one or more, we're good to
    go.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序可以支持零个或多个二进制格式。使用 `GL_NUM_PROGRAM_BINARY_FORMATS` 常量调用 `glGetIntegerv` 会查询驱动程序以查看有多少可用。如果这个数字是零，OpenGL
    驱动程序不支持读取或写入着色器二进制文件。如果值为一或更多，我们就可以开始了。
- en: If at least one binary format is available, we can use `glGetProgramBinary`
    to retrieve the compiled shader code shown earlier. The function will write the
    binary format used to the location pointed to by the fourth parameter. In the
    preceding example, the data is stored in the vector named `buffer`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果至少有一个二进制格式可用，我们可以使用 `glGetProgramBinary` 来检索前面显示的编译后的着色器代码。该函数将把使用的二进制格式写入第四个参数指向的位置。在前面的示例中，数据存储在名为
    `buffer` 的向量中。
- en: To load the shader binary, we can use `glProgramBinary`. This function will
    load a previously saved shader binary. It requires the binary format to be passed
    as the second parameter. We can then check `GL_LINK_STATUS` to verify that it
    was loaded without error.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载着色器二进制文件，我们可以使用 `glProgramBinary`。此函数将加载之前保存的着色器二进制文件。它需要将二进制格式作为第二个参数传递。然后我们可以检查
    `GL_LINK_STATUS` 以验证它是否加载无误。
- en: See also
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter01/scenebasic.cpp` file in the example code
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter01/scenebasic.cpp` 文件
- en: The *Loading an SPIR-V shader program* recipe
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载 SPIR-V 着色器程序* 的配方'
- en: Loading a SPIR-V shader program
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载 SPIR-V 着色器程序
- en: '**Standard, Portable Intermediate Representation - V** (**SPIR-V**) is an intermediate
    language designed and standardized by the Khronos Group for shaders. It is intended
    to be a compiler target for a number of different languages. In the Vulkan API,
    shaders are required to be compiled to SPIR-V before they can be loaded. SPIR-V
    is intended to provide developers with the freedom to develop their shaders in
    any language they want (as long as it can be compiled to SPIR-V), and avoid the
    need for an OpenGL (or Vulkan) implementation to provide compilers for multiple
    languages.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**标准、可移植中间表示 - V** (**SPIR-V**) 是由 Khronos Group 设计和标准化的一个中间语言，用于着色器。它旨在成为多种不同语言的编译器目标。在
    Vulkan API 中，着色器在加载之前必须编译为 SPIR-V。SPIR-V 的目的是为开发者提供自由，让他们可以使用任何他们想要的编程语言（只要它可以编译为
    SPIR-V）来开发他们的着色器，并避免需要 OpenGL（或 Vulkan）实现为多种语言提供编译器的需求。'
- en: Support for SPIR-V shader binaries was added to OpenGL core with version 4.6,
    but is also available via the `ARB_gl_spirv` extension for earlier OpenGL versions.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: SPIR-V 着色器二进制文件的支持被添加到 OpenGL 核心版本 4.6 中，但也可以通过 `ARB_gl_spirv` 扩展在较早的 OpenGL
    版本中使用。
- en: Currently, the Khronos Group provides a reference compiler for compiling GLSL
    to SPIR-V. It is available on GitHub at [https://github.com/KhronosGroup/glslang](https://github.com/KhronosGroup/glslang).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Khronos Group 为编译 GLSL 到 SPIR-V 提供了一个参考编译器。它可在 GitHub 上找到，网址为 [https://github.com/KhronosGroup/glslang](https://github.com/KhronosGroup/glslang)。
- en: In this recipe, we'll go through the steps involved in precompiling a GLSL shader
    pair to SPIR-V, and then load it into an OpenGL program.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将介绍将 GLSL 着色器对预编译到 SPIR-V 并将其加载到 OpenGL 程序中的步骤。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Download and compile the OpenGL shader validator from [https://github.com/KhronosGroup/glslang](https://github.com/KhronosGroup/glslang).
    Make sure that the `glslangValidator` binary is available in your `PATH` command
    line. In this example, we'll use the shader pair located in the `basic.vert.glsl`
    and `basic.frag.glsl` files.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [https://github.com/KhronosGroup/glslang](https://github.com/KhronosGroup/glslang)
    下载并编译 OpenGL 着色器验证器。请确保 `glslangValidator` 二进制文件已添加到您的 `PATH` 命令行中。在本例中，我们将使用位于
    `basic.vert.glsl` 和 `basic.frag.glsl` 文件中的着色器对。
- en: Note that you'll need to use explicit locations for all of your input/output
    variables in the shaders. For details, see the *Linking a shader program* recipe.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要在着色器中为所有输入/输出变量使用显式位置。有关详细信息，请参阅*链接着色器程序*配方。
- en: All variables used for input/output interfaces (in/out variables) must have
    a location assigned.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于输入/输出接口（输入/输出变量）的变量都必须分配一个位置。
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Start by compiling the shader pair into SPIR-V using the `glslangValidator`
    tool:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`glslangValidator`工具将着色器对编译成SPIR-V：
- en: '[PRE28]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If successful, this produces the `basic.vert.spv` and `basic.frag.spv` SPIR-V
    output files.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，这将生成`basic.vert.spv`和`basic.frag.spv` SPIR-V输出文件。
- en: 'To load your SPIR-V shaders into an OpenGL program, use `glShaderBinary` and
    `glSpecializeShader`. With `glShaderBinary`, use `GL_SHADER_BINARY_FORMAT_SPIR_V`
    as the binary format:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的SPIR-V着色器加载到OpenGL程序中，使用`glShaderBinary`和`glSpecializeShader`。使用`glShaderBinary`时，使用`GL_SHADER_BINARY_FORMAT_SPIR_V`作为二进制格式：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The process is nearly exactly the same for the fragment shader; just use `GL_FRAGMENT_SHADER`
    instead of `GL_VERTEX_SHADER` on the first line.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于片段着色器的过程几乎完全相同；只需在第一行使用`GL_FRAGMENT_SHADER`而不是`GL_VERTEX_SHADER`。
- en: Finally, we create the program object, attach the shaders, and link. This process
    is identical to that shown in the *Linking a shader program* recipe, so we won't
    reproduce it here.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建程序对象，附加着色器，并链接。这个过程与*链接着色器程序*配方中所示的过程相同，因此我们在这里不会重复它。
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `glShaderBinary` function provides us with the ability to load shaders that
    have been compiled to the SPIR-V format. This part is fairly straightforward.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`glShaderBinary`函数为我们提供了加载已编译为SPIR-V格式的着色器的功能。这部分相当直接。'
- en: The function that might be a bit more confusing is `glSpecializeShader`. We
    are required to call this function before the shader stage can be linked. This
    call is needed because a single SPIR-V file can have multiple entry points, and
    SPIR-V files can have *specialization constants*, which are parameters that the
    user can provide before it is compiled into native code.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有点令人困惑的函数是`glSpecializeShader`。在着色器阶段可以链接之前，我们必须调用此函数。这个调用是必需的，因为单个SPIR-V文件可以有多个入口点，SPIR-V文件可以有*专门化常量*，这些是用户在编译成本地代码之前可以提供的参数。
- en: At a minimum, we need to define the entry point for our shader. Since the source
    language is GLSL, the entry point is `main`. We specify the entry point(s) via
    the second argument. For GLSL, we simply use the `main` constant string. The last
    three parameters can be used to define the specialization constants. The first
    of the three is the number of constants, the next is a pointer to an array of
    constant indices, and the last is a pointer to an array of constant values.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，我们需要定义我们的着色器的入口点。由于源语言是GLSL，入口点是`main`。我们通过第二个参数指定入口点（s）。对于GLSL，我们简单地使用`main`常量字符串。最后三个参数可以用来定义专门化常量。三个中的第一个是常量的数量，下一个是指向常量索引数组的指针，最后是指向常量值数组的指针。
- en: The process of specializing an SPIR-V shader is similar to compiling a GLSL
    shader. Before calling `glSpecializeShader`, or if specialization fails, the compile
    status will be `GL_FALSE`. If specialization succeeds, the compile status will
    be `GL_TRUE`. As with GLSL shaders, we can query the shader info log to get detailed
    error messages (see the *Compiling a shader* recipe).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 专门化SPIR-V着色器的过程类似于编译GLSL着色器。在调用`glSpecializeShader`之前，或者如果专门化失败，编译状态将是`GL_FALSE`。如果专门化成功，编译状态将是`GL_TRUE`。与GLSL着色器一样，我们可以查询着色器信息日志以获取详细的错误消息（参见*编译着色器*配方）。
- en: There's more...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: SPIR-V appears to be the future of shader programming in the Vulkan/OpenGL space.
    However, GLSL is not going away anytime soon. GLSL compilers still ship with OpenGL
    and there's currently no sign that they will be removed or deprecated. The OpenGL
    specification still considers GLSL to be the primary shading language.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: SPIR-V似乎将成为Vulkan/OpenGL空间中着色器编程的未来。然而，GLSL并不会在短时间内消失。GLSL编译器仍然与OpenGL一起提供，目前没有任何迹象表明它们将被移除或弃用。OpenGL规范仍然将GLSL视为主要的着色语言。
- en: However, if you're interested in getting on board with SPIR-V early, or you
    have an interest in moving toward Vulkan, it might be valuable to you to start
    working with SPIR-V now in OpenGL. Fortunately, that's possible, at least in recent
    versions of OpenGL.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想在SPIR-V早期加入，或者你对转向Vulkan感兴趣，那么现在在OpenGL中开始使用SPIR-V可能对你来说是有价值的。幸运的是，至少在OpenGL的最近版本中，这是可能的。
- en: The future of SPIR-V is very bright. There is already a (mostly complete) compiler
    for HLSL that targets SPIR-V, and it is likely that other languages will be developed
    soon. It's an exciting time for shader programming!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: SPIR-V 的未来非常光明。已经有一个（大部分完成）针对 SPIR-V 的 HLSL 编译器，并且很可能很快会有其他语言被开发出来。这是着色器编程的激动人心时刻！
- en: See also
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter01/scenebasic.cpp` file in the example code
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter01/scenebasic.cpp` 文件
- en: The *Compiling a shader* recipe
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编译着色器* 菜单'
- en: The *Linking a shader program* recipe
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*链接着色器程序* 菜单'
