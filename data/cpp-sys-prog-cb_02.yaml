- en: Revisiting C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重温C++
- en: This chapter acts as a refresher on C++ 11-20, which will be used throughout
    this book. We'll explain why C++ represents a great opportunity that shouldn't
    be missed when it comes to writing good quality code that's concise and more portable
    than ever.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章作为C++ 11-20的复习，将贯穿本书。我们将解释为什么C++代表了一个绝佳的机会，不容错过，当涉及编写比以往更简洁和更具可移植性的高质量代码时。
- en: This chapter does not contain *all* the new features introduced by C++ (11 through
    20) – just the ones we will be using for the rest of this book. Specifically,
    you'll get a refresher (if you already know) or learn (if you are new) about the
    most essential new C++ skills needed to write modern code. You'll work, hands-on,
    with lambda expressions, atomics, and move semantics, just to mention a few.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不包含C++（11到20）引入的*所有*新功能，只包括本书其余部分将使用的功能。具体来说，您将复习（如果您已经知道）或学习（如果您是新手）编写现代代码所需的最基本的新C++技能。您将亲自动手使用lambda表达式、原子操作和移动语义等。
- en: 'This chapter will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下示例：
- en: Understanding C++ primitive types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解C++原始类型
- en: Lambda expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: Automatic type deduction and `decltype`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动类型推断和`decltype`
- en: Learning how atomic works
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习原子操作的工作原理
- en: Learning how `nullptr` works
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习`nullptr`的工作原理
- en: Smart pointers – `unique_ptr` and `shared_ptr`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能指针 - `unique_ptr` 和 `shared_ptr`
- en: Learning how semantics works
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习语义的工作原理
- en: Understanding concurrency
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并发性
- en: Understanding the filesystem
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解文件系统
- en: The C++ Core Guidelines
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++核心指南
- en: Adding GSL to your makefile
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将GSL添加到您的makefile
- en: Understanding concepts
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解概念
- en: Using span
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用span
- en: Learning how Ranges work
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习范围如何工作
- en: Learning how modules work
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习模块的工作原理
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To let you try out the programs in this chapter immediately, we've set up a
    Docker image that has all the tools and libraries we'll need throughout this book.
    It's based on Ubuntu 19.04.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您立即尝试本章中的程序，我们设置了一个Docker镜像，其中包含本书中将需要的所有工具和库。它基于Ubuntu 19.04。
- en: 'In order to set it up, follow these steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置它，请按照以下步骤进行：
- en: Download and install the Docker Engine from [www.docker.com](http://www.docker.com).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[www.docker.com](http://www.docker.com)下载并安装Docker Engine。
- en: Pull the image from Docker Hub: `docker pull kasperondocker/system_programming_cookbook:latest`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Docker Hub拉取镜像：`docker pull kasperondocker/system_programming_cookbook:latest`。
- en: The image should now be available. Type in the following command to view the
    image: `docker images`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应该可以使用该镜像。输入以下命令查看镜像：`docker images`。
- en: Now, you should have the following image: `kasperondocker/system_programming_cookbook`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您应该有以下镜像：`kasperondocker/system_programming_cookbook`。
- en: Run the Docker image with an interactive shell with the help of the following
    command: `docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行Docker镜像并打开交互式shell：`docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest
    /bin/bash`。
- en: The shell on the running container is now available. Use `root@39a5a8934370/#
    cd /BOOK/` to get all the programs that have been developed for the chapters in
    this book.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正在运行的容器上的shell现在可用。使用`root@39a5a8934370/# cd /BOOK/`获取为本书章节开发的所有程序。
- en: The `--cap-add sys_ptrace` argument is needed to allow GDB to set breakpoints
    in the Docker container which, by default, Docker does not allow.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 需要`--cap-add sys_ptrace`参数以允许GDB在Docker容器中设置断点，默认情况下Docker不允许。
- en: '**Disclaimer**: The C++20 standard has been approved (that is, technically
    finalized) by WG21 in a meeting in Prague at the end of February. This means that
    the GCC compiler version that this book uses, 8.3.0, does not include (or has
    very, very limited support for) the new and cool C++20 features. For this reason,
    the Docker image does not include the C++20 recipe code. GCC keeps the development
    of the newest features in branches (you have to use appropriate flags for that,
    for example, `-std=c++2a`); therefore, you are encouraged to experiment with them
    by yourself. So, clone and explore the GCC contracts and module branches and have
    fun.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**免责声明**：C++20标准已经在二月底的布拉格会议上得到批准（即技术上已经最终确定）。这意味着本书使用的GCC编译器版本8.3.0不包括（或者对C++20的新功能支持非常有限）。因此，Docker镜像不包括C++20示例代码。GCC将最新功能的开发保留在分支中（您必须使用适当的标志，例如`-std=c++2a`）；因此，鼓励您自己尝试。因此，请克隆并探索GCC合同和模块分支，并尽情玩耍。'
- en: Understanding C++ primitive types
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解C++原始类型
- en: This recipe will show all the primitive data types defined by the C++ standard,
    as well as their size.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将展示C++标准定义的所有原始数据类型，以及它们的大小。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll have a closer look at what primitives the C++ standard
    defines and what other information is important. We''ll also learn that although
    the standard does not define a size for each, it defines another important parameter:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更仔细地查看C++标准定义的原始类型以及其他重要信息。我们还将了解到，尽管标准没有为每个类型定义大小，但它定义了另一个重要参数：
- en: 'First, open a new Terminal and type in the following program:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开一个新的终端并输入以下程序：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, build (compile and link) `g++ primitives.cpp`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建（编译和链接）`g++ primitives.cpp`。
- en: This will produce an executable file with the (default) name of `a.out`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将生成一个可执行文件，名称为`a.out`（默认）。
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The output of the preceding program will be something like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前面程序的输出将类似于这样：
- en: '![](img/17a5c520-563d-45b6-b17d-5e3c197d535a.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17a5c520-563d-45b6-b17d-5e3c197d535a.png)'
- en: This represents the minimum and maximum values that a type can represent and
    the size in bytes for the current platform.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了类型可以表示的最小和最大值，以及当前平台的字节大小。
- en: The C++ standard **does not** define the size of each type, but it does define
    the minimum **width***:*
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准**不**定义每种类型的大小，但它定义了最小**宽度**：
- en: '`char`: Minimum width = 8'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`: 最小宽度= 8'
- en: '`short int`: Minimum width = 16'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short int`: 最小宽度= 16'
- en: '`int`: Minimum width = 16'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`: 最小宽度= 16'
- en: '`long int`: Minimum width = 32'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long int`: 最小宽度= 32'
- en: '`long int int`: Minimum width = 64'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long int int`: 最小宽度= 64'
- en: 'This point has huge implications as different platforms can have different
    sizes and a programmer should cope with this. To help us get some guidance regarding
    data types, there is the concept of a data model. A **data model** is a set of
    choices (a specific size for each type) made by each implementation (the psABI
    of the architecture that compilers and operating systems adhere to) to define
    all the primitive data types. The following table shows a subset of various types
    and data models that exist:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点有着巨大的影响，因为不同的平台可能有不同的大小，程序员应该应对这一点。为了帮助我们获得关于数据类型的一些指导，有一个数据模型的概念。**数据模型**是每个实现（编译器和操作系统遵循的体系结构的psABI）所做的一组选择（每种类型的特定大小）来定义所有原始数据类型。以下表格显示了存在的各种类型和数据模型的子集：
- en: '| **Data type** | **LP32** | **ILP32** | **LLP64** | **LP64** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **LP32** | **ILP32** | **LLP64** | **LP64** |'
- en: '| `char` | 8 | 8 | 8 | 8 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `char` | 8 | 8 | 8 | 8 |'
- en: '| `short int` | 16 | 16 | 16 | 16 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `short int` | 16 | 16 | 16 | 16 |'
- en: '| `int`  | 16 | 32 | 32 | 32 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `int`  | 16 | 32 | 32 | 32 |'
- en: '| `long` | 32 | 32 | 32 | 64 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 32 | 32 | 32 | 64 |'
- en: '| `pointer` | 32 | 32 | 64 | 64 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `指针` | 32 | 32 | 64 | 64 |'
- en: The Linux kernel uses the LP64 data model for 64-bit architectures (x86_64).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核对64位体系结构（x86_64）使用LP64数据模型。
- en: 'We briefly touched on the psABI topic (short for **platform-specific Application
    Binary Interfaces** (**ABIs**)). Each architecture (for example, x86_64) has a
    psABI specification that the OS adheres to. The **GNU Compiler Collection** (**GCC**)
    has to know these details as it has to know the sizes of the primitive types it
    compiles. The `i386.h` GCC header file contains the size of the primitive data
    types for that architecture:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要地提到了psABI主题（**特定于平台的应用程序二进制接口**（**ABIs**）的缩写）。每个体系结构（例如x86_64）都有一个psABI规范，操作系统遵循这个规范。**GNU编译器集合**（**GCC**）必须知道这些细节，因为它必须知道它编译的原始类型的大小。`i386.h`
    GCC头文件包含了该体系结构的原始数据类型的大小：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The program output shows that the current OS (actually, the Ubuntu image we're
    running) uses the LP64 data model as expected and that the machine's architecture
    is x86_64.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 程序输出显示，当前操作系统（实际上是我们正在运行的Ubuntu镜像）使用了LP64数据模型，这是预期的，并且机器的体系结构是x86_64。
- en: There's more...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As we''ve seen, the C++ standard defines the following primitive data types:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，C++标准定义了以下原始数据类型：
- en: Integer: `int`
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数：`int`
- en: Character: `char`
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符：`char`
- en: Boolean: `bool`
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值：`bool`
- en: Floating point: `float`
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数：`float`
- en: Double floating point: `double`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双精度浮点数：`double`
- en: Void: `void`
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空：`void`
- en: Wide character: `wchar_t`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宽字符：`wchar_t`
- en: Null pointer: `nullptr_­t`
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空指针：`nullptr_­t`
- en: 'Data types can have other information so that their types can be defined:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型可以包含其他信息，以便定义它们的类型：
- en: Modifiers: `signed`, `unsigned`, `long`, and `short`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修饰符：`signed`、`unsigned`、`long`和`short`
- en: Qualifiers: `const` and `restrict`
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限定词：`const`和`restrict`
- en: Storage type: `auto`, `static`, `extern`, and `mutable`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储类型：`auto`、`static`、`extern`和`mutable`
- en: Obviously, not all these additional attributes can be applied to all the types;
    for example, `unsigned` cannot be applied to the `float` and `double` types (their
    respective IEEE standards would not allow that).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，并非所有这些附加属性都可以应用于所有类型；例如，`unsigned`不能应用于`float`和`double`类型（它们各自的IEEE标准不允许这样做）。
- en: See also
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Specifically for Linux, the Linux kernel documentation is generally a good place
    to start digging more into this: [https://www.kernel.org/doc/html/latest](https://www.kernel.org/doc/html/latest/).
    The GCC source code shows the sizes of the primitive data types for every supported
    architecture. Refer to the following link to find out more: [https://github.com/gcc-mirror/gcc](https://github.com/gcc-mirror/gcc).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是对于Linux，Linux内核文档通常是深入研究这个问题的好地方：[https://www.kernel.org/doc/html/latest](https://www.kernel.org/doc/html/latest/)。GCC源代码显示了每个支持的体系结构的原始数据类型的大小。请参考以下链接以了解更多信息：[https://github.com/gcc-mirror/gcc](https://github.com/gcc-mirror/gcc)。
- en: Lambda expressions
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: A **lambda expression** (or **lambda** **function**) is a convenient way of
    defining an anonymous, small, and one-time use function to be used in the place
    right where it is needed. Lambda is particularly useful with **Standard Template
    Library** (**STL**), as we'll see.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**lambda表达式**（或**lambda** **函数**）是一种方便的方式，用于定义一个匿名的、小型的、一次性使用的函数，以便在需要的地方使用。Lambda在**标准模板库**（**STL**）中特别有用，我们将会看到。'
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll write some code in order to get familiar with lambda
    expressions. Although the mechanics are important, pay attention to the code readability
    with lambda, especially in conjunction with STL. Follow these steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一些代码，以便熟悉lambda表达式。尽管机制很重要，但要特别注意lambda的代码可读性，特别是与STL结合使用。按照以下步骤：
- en: 'In this program, the lambda function gets an integer and prints it to standard
    output. Let''s open a file named `lambda_01.cpp` and write the following code
    in it:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个程序中，lambda函数获取一个整数并将其打印到标准输出。让我们打开一个名为`lambda_01.cpp`的文件，并在其中写入以下代码：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this second program, the lambda function captures a prefix by reference
    and prepends it to the integer in the standard output. Let''s write the following
    code in a file called `lambda_02.cpp`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这第二个程序中，lambda函数通过引用捕获一个前缀，并将其添加到标准输出的整数前面。让我们在一个名为`lambda_02.cpp`的文件中写入以下代码：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, we compile it with `g++ lambda_02.cpp`.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们用`g++ lambda_02.cpp`编译它。
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first example, the lambda function just gets an integer as input and
    prints it. Note that the code is concise and readable. Lambda can capture the
    variables in scope by reference, `&`, or by value, `=`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，lambda函数只是获取一个整数作为输入并打印它。请注意，代码简洁且可读。Lambda可以通过引用`&`或值`=`捕获作用域中的变量。
- en: 'The output of the second program is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个程序的输出如下：
- en: '![](img/271646b2-f3b5-450a-ad5c-ed95229b6c34.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/271646b2-f3b5-450a-ad5c-ed95229b6c34.png)'
- en: 'In the second example, the lambda **captures**the variable prefix by reference,
    making it visible to the lambda. Here, we captured the `prefix` variable by reference,
    but we might have captured any of the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，lambda通过引用**捕获**了变量前缀，使其对lambda可见。在这里，我们通过引用捕获了`prefix`变量，但我们也可以捕获以下任何一个：
- en: All the variables by reference `[&]`
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有变量按引用`[&]`
- en: All the variables by value `[=]`
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有变量按值`[=]`
- en: Specifying *what variables to capture* and *how to capture them* `[&var1, =var2]`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定*要捕获的变量*和*如何捕获它们*`[&var1, =var2]`
- en: 'There are cases where we have to be explicit about the type to return, as in
    this case:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，我们必须明确指定要返回的类型，就像这种情况：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `-> std::vector<int>` operator, called **trailing return type**, tells the
    compiler that this lambda will return a vector of integers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`-> std::vector<int>`运算符，称为**尾返回类型**，告诉编译器这个lambda将返回一个整数向量。'
- en: There's more...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Lambda can be decomposed into six parts:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda可以分解为六个部分：
- en: Capture clause: `[]`
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕获子句：`[]`
- en: Parameter list: `()`
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数列表：`()`
- en: Mutable specification: `mutable`
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可变规范：`mutable`
- en: Exception specification: `noexcept`
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异常规范：`noexcept`
- en: Trailing return type: `-> type`
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尾返回类型：`-> type`
- en: Body: `{}`
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主体：`{}`
- en: Here, *1*, *2*, and *6* are mandatory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*1*、*2*和*6*是强制性的。
- en: Although optional, mutable specification and exception specification are worth
    having a look at as they might be handy in some circumstances. The mutable specification
    allows a by-valueparameter to be modified by the body of the lambda. A variable
    in the parameter list is typically captured *const-by-value*, so the mutable specification
    just removes this restriction. The second case is the exception specification,
    which we can use to specify the exceptions the lambda might throw.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可选，但可变规范和异常规范值得一提，因为它们在某些情况下可能很方便。可变规范允许通过lambda主体修改按值传递的参数。参数列表中的变量通常是以*const-by-value*方式捕获的，因此`mutable`规范只是去除了这个限制。第二种情况是异常规范，我们可以用它来指定lambda可能抛出的异常。
- en: See also
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Scott Meyers的《Effective Modern C++》和Bjarne Stroustrup的《C++程序设计语言》详细介绍了这些主题。
- en: Automatic type deduction and decltype
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动类型推断和decltype
- en: 'C++ offers two mechanisms for deducting types from an expression: `auto` and
    `decltype()`. `auto` is used to deduce a type from its initializer, while `decltype()`
    is used to deduce a type for more complex cases. This recipe will show examples
    of how to use both.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了两种从表达式中推断类型的机制：`auto`和`decltype()`。`auto`用于从其初始化程序推断类型，而`decltype()`用于更复杂的情况推断类型。本文将展示如何使用这两种机制的示例。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'It might be handy (and it actually is) to avoid explicitly specifying the type
    of variable that will be used, especially when it is particularly long and used
    very locally:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 避免明确指定将使用的变量类型可能很方便（实际上确实如此），特别是当它特别长并且在本地使用时：
- en: 'Let''s start with a typical example:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从一个典型的例子开始：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let''s rewrite it with `auto`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用`auto`来重写它：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s look at another example:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看另一个例子：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`decltype()` is another mechanism offered by C++ that can deduce the type of
    expression when the expression is more complex than the `auto` case.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`decltype()`是C++提供的另一种机制，可以在表达式比`auto`更复杂的情况下推断表达式的类型。'
- en: 'Let''s look at this using an example:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用一个例子来看看：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Could we use `auto` instead of `decltype()` in these two examples? We'll take
    a look in the next section.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个例子中，我们能否使用`auto`代替`decltype()`？我们将在下一节中看一看。
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first example with `auto` shows that the type is deduced, at compile time,
    from the right-hand parameter. `auto` is used in simple cases.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个使用`auto`的例子显示，类型是在编译时从右侧参数推断出来的。`auto`用于简单的情况。
- en: '`decltype()` deduces the type of expression. In the example, it defines the
    `y` variable so that it''s the same type as `a`. As you can imagine, this would
    not be possible with `auto`. Why? This is pretty simple: `decltype()` tells the
    compiler to *define a variable of a specific type*; in the first example, `y`
    is a variable with the same type as `a`. With `auto`*,* the type is deduced automatically.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`decltype()`推断表达式的类型。在这个例子中，它定义了`y`变量，使其与`a`的类型相同。正如你可以想象的那样，这是不可能用`auto`来实现的。为什么？这很简单：`decltype()`告诉编译器*定义一个特定类型的变量*；在第一个例子中，`y`是一个与`a`相同类型的变量。而使用`auto`，类型会自动推断。'
- en: We should use `auto` and `decltype()` anytime we don't have to explicitly specify
    the type of a variable; for example, when we need a `double` type (and not a `float`).
    It's worth mentioning that both `auto` and `decltype()` deduct types of expressions
    that are already known to the compiler, so **they are not runtime mechanisms**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在不必显式指定变量类型的情况下使用`auto`和`decltype()`；例如，当我们需要`double`类型（而不是`float`）时。值得一提的是，`auto`和`decltype()`都推断编译器已知的表达式的类型，因此它们不是运行时机制。
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There is a specific case that must be mentioned. When `auto` uses `{}` (uniform
    initializers) for type deduction, it can cause some headaches (or at least behaviors
    that we wouldn''t expect). Let''s look at an example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊情况必须提到。当`auto`使用`{}`（统一初始化程序）进行类型推断时，它可能会引起一些麻烦（或者至少是我们不会预期的行为）。让我们看一个例子：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, the type that's being deduced is `initializer_list<T>` and not
    an array of integers, as we could expect.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，被推断的类型是`initializer_list<T>`，而不是我们可能期望的整数数组。
- en: See also
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Scott Meyers的《Effective Modern C++》和Bjarne Stroustrup的《C++程序设计语言》详细介绍了这些主题。
- en: Learning how atomic works
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习原子操作的工作原理
- en: Traditionally, C and C++ have a long tradition of portable code for system programming.
    The `atomic` feature that was introduced in the C++11 standard reinforces this
    by adding, natively, the guarantee that an operation is seen as atomic by other
    threads. Atomic is a template, such as `template <class T> struct atomic;` or `template
    <class T> struct atomic<T*>;`. C++20 has added `shared_ptr` and `weak_ptr` to
    `T` and `T*`. Any operation that's performed on the `atomic` variable is now protected
    from other threads.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，C和C++在系统编程中有着悠久的可移植代码传统。C++11标准引入的`atomic`特性通过本地添加了操作被其他线程视为原子的保证，进一步加强了这一点。原子是一个模板，例如`template
    <class T> struct atomic;`或`template <class T> struct atomic<T*>;`。C++20已经将`shared_ptr`和`weak_ptr`添加到了`T`和`T*`。现在对`atomic`变量执行的任何操作都受到其他线程的保护。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: '`std::atomic` is an important aspect of modern C++ for dealing with concurrency.
    Let''s write some code to master the concept:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic`是现代C++处理并发的重要方面。让我们编写一些代码来掌握这个概念：'
- en: 'The first snippet of code shows the basics of `atomic` operations. Let''s write
    this now:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一段代码片段展示了原子操作的基础知识。现在让我们写下这个：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this second program, we can see that the `is_lock_free()` method returns
    `true` if the implementation is lock-free or if it has been implemented using
    a lock. Let''s write this code:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个程序中，我们可以看到`is_lock_free()`方法在实现是无锁的或者使用锁实现时返回`true`。让我们编写这段代码：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's compile the program. When doing so, you may need to add the `atomic` library
    to g++ (due to a GCC bug) with `g++ atomic.cpp -latomic`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译程序。在这样做时，您可能需要向g++添加`atomic`库（由于GCC的一个错误）：`g++ atomic.cpp -latomic`。
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::atomic<int> speed (0);` defines a `speed` variable as an atomic integer.
    Although the variable will be atomic, this initialization** is not atomic**! Instead,
    the following code: `speed +=10;` atomically increases the speed of `10`. This
    means that there will not be race conditions. By definition, a race condition
    happens when among the threads accessing a variable, at least 1 is a writer.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::atomic<int> speed (0);`将`speed`变量定义为原子整数。尽管变量是原子的，但这种初始化**不是原子的**！相反，以下代码：`speed
    +=10;`原子地增加了`10`的速度。这意味着不会发生竞争条件。根据定义，当访问变量的线程中至少有1个是写入者时，就会发生竞争条件。'
- en: 'The `std::cout << "current speed is: " << speed;` instruction reads the current
    value of the speed automatically. Pay attention to the fact that reading the value
    from speed is atomic but what happens next is not atomic (that is, printing it
    through `cout`). The rule is that read and write are atomic but the surrounding
    operations are not, as we''ve seen.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::cout << "current speed is: " << speed;`指令自动读取当前速度的值。请注意，从速度中读取值是原子的，但接下来发生的事情不是原子的（也就是说，通过`cout`打印它）。规则是读取和写入是原子的，但周围的操作不是，正如我们所见。'
- en: 'The output of the second program is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个程序的输出如下：
- en: '![](img/878ed611-133b-41a3-8388-b49f0f8a688e.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/878ed611-133b-41a3-8388-b49f0f8a688e.png)'
- en: The basic operations for atomic are load, store, swap, and **cas** (short for **compare
    and swap**), which are available on all types of atomics. Others are available,
    depending on the types (for example, `fetch_add`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 原子的基本操作是`load`、`store`、`swap`和`cas`（`compare and swap`的缩写），适用于所有类型的原子。根据类型，还有其他操作可用（例如`fetch_add`）。
- en: 'One question remains open, though. How come `myArray` uses locks and `myStr`
    is lock-free? The reason is simple: C++ provides a lock-free implementation for
    all the primitive types, and the variables inside `MyStr` are primitive types.
    A user will set `myStr.a` and `myStr.b`. `MyArray`, on the other hand, is not
    a fundamental type, so the underlying implementation will use locks.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个问题没有解决。为什么`myArray`使用锁而`myStr`是无锁的？原因很简单：C++为所有原始类型提供了无锁实现，而`MyStr`内部的变量是原始类型。用户将设置`myStr.a`和`myStr.b`。另一方面，`MyArray`不是基本类型，因此底层实现将使用锁。
- en: The standard guarantee is that for each atomic operation, every thread will
    make progress. One important aspect to keep in mind is that the compiler makes
    code optimizations quite often. The use of atomics imposes restrictions on the
    compiler regarding how the code can be reordered. An example of a restriction
    is that no code that preceded the write of an `atomic` variable can be moved *after*
    the atomic write.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 标准保证是对于每个原子操作，每个线程都会取得进展。需要牢记的一个重要方面是，编译器经常进行代码优化。使用原子会对编译器施加关于代码如何重新排序的限制。一个限制的例子是，不能将写入`atomic`变量之前的任何代码移动到*之后*的原子写入。
- en: There's more...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In this recipe, we''ve used the default memory model called `memory_order_seq_cst`.
    Some other memory models that are available are:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了名为`memory_order_seq_cst`的默认内存模型。其他可用的内存模型包括：
- en: '`memory_order_relaxed`: Only the current operation atomicity is guaranteed.
    That is, there are no guarantees on how memory accesses in different threads are
    ordered with respect to the atomic operation.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_order_relaxed`：只保证当前操作的原子性。也就是说，没有保证不同线程中的内存访问与原子操作的顺序有关。'
- en: '`memory_order_consume`: The operation is ordered to happen once all accesses
    to memory in the releasing thread that carry a dependency on the releasing operation
    have happened.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_order_consume`：操作被排序在释放线程上所有对释放操作有依赖的内存访问发生后。'
- en: '`memory_order_acquire`: The operation is ordered to happen once all accesses
    to memory in the releasing thread have happened.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_order_acquire`：操作被排序在释放线程上所有对内存的访问发生后。'
- en: '`memory_order_release`: The operation is ordered to happen before a consume
    or acquire operation.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_order_release`：操作被排序在发生在消费或获取操作之前。'
- en: '`memory_order_seq_cst`: The operation is sequentially consistent ordered.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory_order_seq_cst`：操作是顺序一致的。'
- en: See also
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail. Furthermore, the *Atomic Weapons* talk
    from Herb Sutter, freely available on YouTube ([https://www.youtube.com/watch?v=A8eCGOqgvH4](https://www.youtube.com/watch?v=A8eCGOqgvH4)),
    is a great introduction.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Scott Meyers的《Effective Modern C++》和Bjarne Stroustrup的《C++程序设计语言》详细介绍了这些主题。此外，Herb
    Sutter的*原子武器*演讲在YouTube上免费提供（[https://www.youtube.com/watch?v=A8eCGOqgvH4](https://www.youtube.com/watch?v=A8eCGOqgvH4)），是一个很好的介绍。
- en: Learning how nullptr works
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习`nullptr`的工作原理
- en: Before C++11, the `NULL` identifier was meant to be used for pointers. In this
    recipe, we'll see why this was a problem and how C++11 solved it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前，`NULL`标识符是用于指针的。在这个示例中，我们将看到为什么这是一个问题，以及C++11是如何解决它的。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand why `nullptr` is important, let''s look at the problem with `NULL`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么`nullptr`很重要，让我们看看`NULL`的问题：
- en: 'Let''s write the following code:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们写下以下代码：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s rewrite the preceding code using `nullptr`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用`nullptr`重写前面的代码：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first program might not compile or (if it does) call the wrong method.
    We would expect it to call `bool speedUp (char* speed);` instead. The problem
    with `NULL` was exactly this: `NULL` was defined as `0`, which is an integer type,
    and used by the **pre-processor** (which was replacing all the occurrences of
    `NULL` with `0`). This is a huge difference as `nullptr` is now among the C++
    primitives types and managed by the **compiler**.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个程序可能无法编译，或者（如果可以）调用错误的方法。我们希望它调用`bool speedUp (char* speed);`。`NULL`的问题正是这样：`NULL`被定义为`0`，这是一个整数类型，并且被**预处理器**使用（替换所有`NULL`的出现）。这是一个巨大的区别，因为`nullptr`现在是C++原始类型之一，并由**编译器**管理。
- en: For the second program, the `speedUp` (overloaded) method is called with the
    `char*` pointer to `nullptr`. There is no ambiguity here – we're calling the version
    with the `char*` type.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个程序，使用`char*`指针调用了`speedUp`（重载）方法。这里没有歧义 - 我们调用了`char*`类型的版本。
- en: There's more...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`nullptr` represents *a pointer that does not point to any object*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`nullptr`代表*不指向任何对象的指针*：'
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Due to this, there is no ambiguity, which means that readability improves.
    Another example that improves readability is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个，就没有歧义，这意味着可读性得到了提高。另一个提高可读性的例子如下：
- en: '[PRE15]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This makes the code more readable and clearly indicates that we're comparing
    a pointer.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得代码更易读，并清楚地表明我们正在比较一个指针。
- en: See also
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Scott Meyers的《Effective Modern C++》和Bjarne Stroustrup的《C++程序设计语言》详细介绍了这些主题。
- en: Smart pointers – unique_ptr and shared_ptr
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能指针 - unique_ptr和shared_ptr
- en: This recipe will show the basic usage of `unique_ptr` and `shared_ptr`. These
    smart pointers are the main helpers for programmers who don't want to deal with
    memory deallocation manually. Once you've learned how to use them properly, this
    will save headaches and nights of debugging sessions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将展示`unique_ptr`和`shared_ptr`的基本用法。这些智能指针是程序员的主要帮手，他们不想手动处理内存释放。一旦你学会了如何正确使用它们，这将节省头痛和夜间调试会话。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll look at the basic use of two smart pointers, `std::unique_ptr`
    and `std::shared_ptr`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下两个智能指针`std::unique_ptr`和`std::shared_ptr`的基本用法：
- en: 'Let''s develop a `unique_ptr` example by developing the following class:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过开发以下类来开发一个`unique_ptr`示例：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s develop a `main` class by calling the preceding class:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过调用前面的类来开发一个`main`类：
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's compile `g++ unique_ptr_01.cpp`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译`g++ unique_ptr_01.cpp`。
- en: 'Another example with `unique_ptr` shows its behavior with arrays. Let''s reuse
    the same class (`CruiseControl`):'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个`unique_ptr`的例子展示了它在数组中的行为。让我们重用相同的类（`CruiseControl`）：
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s see `std::shared_ptr` in action with a small program:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看一个小程序中`std::shared_ptr`的实际应用：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`main` looks like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`看起来像这样：'
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The *How it works...* section will describe these three programs in detail.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*它是如何工作的...*部分将详细描述这三个程序。'
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'By running the first `unique_ptr` program, that is, `./a.out`, we get the following
    output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行第一个`unique_ptr`程序，即`./a.out`，我们得到以下输出：
- en: '![](img/a50a8dd3-47ed-411d-bb58-ac9a532dff0c.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a50a8dd3-47ed-411d-bb58-ac9a532dff0c.png)'
- en: '`unique_ptr` is a **smart pointer** that embodies the concept of unique ownership.
    Unique ownership, simply put, means that there is one and only one variable that
    can *own* a pointer. The first consequence of this concept is that the copy operator
    is not allowed on two unique pointer variables. Just `move` is allowed, where
    the ownership is transferred from one variable to another. The executable that
    was run shows that the object is deallocated at the end of the current scope (in
    this case, the `main` function): `CruiseControl object destroyed`. The fact that
    the developer doesn''t need to bother remembering to call `delete` when needed,
    but still keep control over memory, is one of the main advantages of C++ over
    garbage collector-based languages.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr`是一个**智能指针**，体现了独特所有权的概念。独特所有权简单来说意味着只有一个变量可以*拥有*一个指针。这个概念的第一个结果是不允许在两个独特指针变量上使用复制运算符。只允许`move`，其中所有权从一个变量转移到另一个变量。运行的可执行文件显示，对象在当前作用域结束时被释放（在这种情况下是`main`函数）：`CruiseControl
    object destroyed`。开发人员不需要记得在需要时调用`delete`，但仍然可以控制内存，这是C++相对于基于垃圾收集器的语言的主要优势之一。'
- en: 'In the second `unique_ptr` example, with arrays, there are three objects of
    the `CruiseControl` type that have been allocated and then released. For this,
    the output is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个`unique_ptr`示例中，使用数组，有三个`CruiseControl`类型的对象被分配然后释放。因此，输出如下：
- en: '![](img/54984bcf-dcb3-49ff-aeaa-a0c0aac1599c.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54984bcf-dcb3-49ff-aeaa-a0c0aac1599c.png)'
- en: 'The third example shows usage of `shared_ptr`. The output of the program is
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个例子展示了`shared_ptr`的用法。程序的输出如下：
- en: '![](img/9aecd0d1-6647-41a7-9f60-fcc91164b7aa.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9aecd0d1-6647-41a7-9f60-fcc91164b7aa.png)'
- en: 'The `shared_ptr` smart pointer represents the concept that an object is being
    pointed at (that is, by the owner) by more than one variable. In this case, we''re
    talking about shared ownership. It is clear that the rules are different from
    the `unique_ptr` case. An object**cannot be released** until at least one variable
    is using it. In this example, we defined a `cruiseControlMaster` variable pointing
    to `nullptr`. Then, we defined a block and in that block, we defined another variable:
    `cruiseControlSlave`. So far, so good! Then, still inside the block, we assigned
    the `cruiseControlSlave` pointer to `cruiseControlMaster`. At this point, the
    object allocated has two pointers: `cruiseControlMaster` and `cruiseControlSlave`.
    When this block is closed, the `cruiseControlSlave` destructor is called but the
    object is not freed as it is still used by another one: `cruiseControlMaster`!
    When the program finishes, we see the `shared_ptr test finished` log and immediately
    after the `cruiseControlMaster`, as it is the only one pointing to the `CruiseControl`
    object release, the object and then the constructor is called, as reported in
    the `CruiseControl object destroyed` log.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`智能指针代表一个对象被多个变量指向的概念（即，由所有者指向）。在这种情况下，我们谈论的是共享所有权。很明显，规则与`unique_ptr`的情况不同。一个对象**不能被释放**，直到至少有一个变量在使用它。在这个例子中，我们定义了一个指向`nullptr`的`cruiseControlMaster`变量。然后，我们定义了一个块，在该块中，我们定义了另一个变量：`cruiseControlSlave`。到目前为止一切顺利！然后，在块内部，我们将`cruiseControlSlave`指针分配给`cruiseControlMaster`。此时，分配的对象有两个指针：`cruiseControlMaster`和`cruiseControlSlave`。当此块关闭时，`cruiseControlSlave`析构函数被调用，但对象没有被释放，因为它仍然被另一个对象使用：`cruiseControlMaster`！当程序结束时，我们看到`shared_ptr
    test finished`日志，紧接着是`cruiseControlMaster`，因为它是唯一指向`CruiseControl`对象释放的对象，然后调用构造函数，如`CruiseControl
    object destroyed`日志所述。'
- en: Clearly, the `shared_ptr` data type has a concept of **reference counting** to
    keep track of the number of pointers. These references are increased during the
    constructors (not always; the `move` constructor isn't) and the copy assignment
    operator and decreased in the destructors.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`shared_ptr`数据类型具有**引用计数**的概念来跟踪指针的数量。这些引用在构造函数（并非总是；`move`构造函数不是）和复制赋值运算符中增加，并在析构函数中减少。
- en: Can the reference counting variable be safely increased and decreased? The pointers
    to the same object might be in different threads, so manipulating this variable
    might be an issue. This is not an issue as the reference counting variable is
    atomically managed (that is, it is an atomic variable).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数变量是否可以安全地增加和减少？指向同一对象的指针可能在不同的线程中，因此操纵这个变量可能会有问题。这不是问题，因为引用计数变量是原子管理的（即，它是原子变量）。
- en: One last point about the size. `unique_ptr` is as big as a raw pointer, whereas `shared_ptr`
    is typically double the size of `unique_ptr` because of the reference counting
    variable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 关于大小的最后一点。`unique_ptr`的大小与原始指针一样大，而`shared_ptr`的大小通常是`unique_ptr`的两倍，因为有引用计数变量。
- en: There's more...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: I strongly suggest always using `std::make_unique` and `std::make_shared`. Their
    usage removes code duplication and improves exception safety. Want more details?
    `shared_ptr.h` ([https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr.h](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr.h))
    and `shared_ptr_base.h` ([https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h)) contain
    the GCC `shared_ptr` implementation so that we can see how reference counting
    is manipulated.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议始终使用`std::make_unique`和`std::make_shared`。它们的使用消除了代码重复，并提高了异常安全性。想要更多细节吗？`shared_ptr.h`（[https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr.h](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr.h)）和`shared_ptr_base.h`（[https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h)）包含了GCC
    `shared_ptr`的实现，这样我们就可以看到引用计数是如何被操纵的。
- en: See also
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Scott Meyers的《Effective Modern C++》和Bjarne Stroustrup的《C++程序设计语言》详细介绍了这些主题。
- en: Learning how move semantics works
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习移动语义的工作原理
- en: We know copies are expensive, especially heavy objects. The move semantics that
    were introduced in C++11 help us avoid expensive copies. The foundational concept
    behind `std::move` and `std::forward` is the **rvalue reference**. This recipe
    will show you how to use `std::move`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道复制是昂贵的，特别是对于重型对象。C++11引入的移动语义帮助我们避免昂贵的复制。`std::move`和`std::forward`背后的基本概念是**右值引用**。这个示例将向您展示如何使用`std::move`。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s develop three programs to learn about `std::move` and its universal
    reference:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发三个程序来学习`std::move`及其通用引用：
- en: 'Let''s start by developing a simple program:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从开发一个简单的程序开始：
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s develop a second example:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开发第二个例子：
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s look at an example with the universal reference:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看一个通用引用的例子：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The next section will describe these three programs in detail.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将详细描述这三个程序。
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The output of the first program is as follows (`g++ move_01.cpp` and `./a.out`):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个程序的输出如下（`g++ move_01.cpp`和`./a.out`）：
- en: '![](img/863d862f-50f8-46c8-894c-f4b94345d9ae.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/863d862f-50f8-46c8-894c-f4b94345d9ae.png)'
- en: 'In this program, `auto b = std::move(a);` does a couple of things:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，`auto b = std::move(a);`做了一些事情：
- en: It casts the vector, `a`, to the **rvalue reference**.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将向量`a`转换为**右值引用**。
- en: As it is an rvalue reference, the vector move constructor is called, which moves
    the content of the `a` vector to the `b` vector.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于它是右值引用，所以调用了向量的移动构造函数，将`a`向量的内容移动到`b`向量中。
- en: '`a` doesn''t have the original data anymore, `b` has.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a`不再具有原始数据，`b`有。'
- en: 'The output of the second program is as follows (`g++ moveSemantics2.cpp` and `./a.out`):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个程序的输出如下（`g++ moveSemantics2.cpp`和`./a.out`）：
- en: '![](img/0289ab6d-50b2-4b65-9cac-6cf1cddacdbe.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0289ab6d-50b2-4b65-9cac-6cf1cddacdbe.png)'
- en: In this second example, the `str` string we pass to the `print` method is an **lvalue reference** (that
    is, we can take the address of that variable), so it is passed by reference.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们传递给`print`方法的`str`字符串是一个**左值引用**（也就是说，我们可以取该变量的地址），因此它是通过引用传递的。
- en: 'The output of the third program is as follows (`g++ moveSemantics3.cpp` and `./a.out`):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个程序的输出如下（`g++ moveSemantics3.cpp`和`./a.out`）：
- en: '![](img/bd79797d-ed44-45d1-9215-35b82981f9b3.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd79797d-ed44-45d1-9215-35b82981f9b3.png)'
- en: In the third example, the method that's being called is the one with the **universal
    reference** as a parameter: `print (std::string &&s)`. This is because we cannot
    take the address of `this is a string`, which means it is an rvalue reference.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个例子中，被调用的方法是带有**通用引用**作为参数的方法：`print (std::string &&s)`。这是因为我们无法取`this is
    a string`的地址，这意味着它是一个右值引用。
- en: It should be clear now that `std::move` doesn't actually move anything – it
    is a function template that **performs an unconditional cast** to an rvalue, as
    we saw in the first example. This allows us to move (and not copy) the data to
    the destination and invalidate the source. The benefits of `std::move` are huge,
    especially every time we see an rvalue reference parameter to a method (`T&&`) that
    would probably* be a copy in the previous versions of the language (C++98 and
    before).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该清楚了，`std::move`并没有**实际**移动任何东西-它是一个函数模板，**执行无条件转换**为右值，正如我们在第一个例子中看到的那样。这使我们能够将数据移动（而不是复制）到目标并使源无效。`std::move`的好处是巨大的，特别是每当我们看到一个方法（`T&&`）的右值引用参数，在语言的以前版本（C++98及以前）中可能*是一个复制。
- en: '*Probably: it depends on compiler optimizations.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*可能：这取决于编译器的优化。'
- en: There's more...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`std::forward` is somewhat similar (but with a different purpose). It is a
    conditional cast to an rvalue reference. You are invited to learn more about `std::forward`,
    rvalue, and lvalue by reading the books referenced in the next section.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::forward`有些类似（但目的不同）。它是对右值引用的条件转换。您可以通过阅读下一节中引用的书籍来了解更多关于`std::forward`、右值和左值的知识。'
- en: See also
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Scott Meyers的*Effective Modern C++*和Bjarne Stroustrup的*The C++ Programming Language*详细介绍了这些主题。
- en: Understanding concurrency
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解并发
- en: In the past, it was common for a C++ developer to write programs by using threading
    libraries or native threading mechanisms (for example `pthread`, a Windows thread).
    Since C++11, this has changed drastically and concurrency is another big feature
    that was added that goes in the direction of a self-consistent language. The two
    new features we'll look at in this recipe are `std::thread` and `std::async`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，C++开发人员通常使用线程库或本地线程机制（例如`pthread`、Windows线程）编写程序。自C++11以来，这已经发生了巨大的变化，并发是另一个重要的功能，它朝着一个自洽的语言方向发展。我们将在这个配方中看到的两个新特性是`std::thread`和`std::async`。
- en: How to do it...
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll learn how to use `std::thread` with a basic scenario
    (create and join) and how to pass and receive parameters to it:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在基本场景（创建和加入）中使用`std::thread`，以及如何向其传递和接收参数：
- en: '`std::thread`: By using the basic thread methods, `create` and `join`, write
    the following code:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::thread`：通过使用基本的线程方法，`create`和`join`，编写以下代码：'
- en: '[PRE24]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Compile it with `g++ concurrency_01.cpp -lpthread`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`g++ concurrency_01.cpp -lpthread`进行编译。
- en: 'The second example is similar to the previous one but in this case, we pass
    and get parameters:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子与前一个例子类似，但在这种情况下，我们传递和获取参数：
- en: '`std::thread`: Create and join a thread, passing a parameter and getting a
    result. Write the following code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::thread`：创建和加入一个线程，传递一个参数并获取结果。编写以下代码：'
- en: '[PRE25]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Compile it using `g++ concurrency_02.cpp -lpthread`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`g++ concurrency_02.cpp -lpthread`进行编译。
- en: 'The third example uses **async **to create a task, execute it, and get the
    result, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个例子使用**async**来创建一个任务，执行它，并获取结果，如下所示：
- en: '`std::async`: Here, we can see why async is called** task-based threading**.
    Write the following code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::async`：在这里，我们可以看到为什么async被称为**基于任务的线程**。编写以下代码：'
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we need to compile the program. There is a catch here. Since we''re using
    a threading mechanism, the compilers rely on the native implementations, which
    in our case turn out to be `pthread`. In order to compile and link without errors
    (we''d get an undefined reference), we need to include `-lpthread`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要编译程序。这里有一个问题。由于我们使用了线程机制，编译器依赖于本地实现，而在我们的情况下，结果是`pthread`。为了编译和链接而不出现错误（我们会得到一个未定义的引用），我们需要包含`-lpthread`：
- en: '[PRE27]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the fourth example, `std::async` used in conjunction with `std::promise`
    and `std::future` is a good and easy way of making two tasks communicate with
    each other. Let''s take a look:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四个例子中，`std::async`与`std::promise`和`std::future`结合使用是使两个任务相互通信的一种好而简单的方法。让我们来看一下：
- en: '`std::async`: This is another `std::async` example showing a basic communication
    mechanism. Let''s code it:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::async`：这是另一个`std::async`示例，展示了基本的通信机制。让我们编写它：'
- en: '[PRE28]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And finally, compile it: `g++ concurrency_04.cpp -lpthread`
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编译它：`g++ concurrency_04.cpp -lpthread`
- en: How it works...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s analyze the previous four programs:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析前面的四个程序：
- en: '`std::thread`: The following program shows basic thread usage for create and
    join:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::thread`：下面的程序展示了基本的线程使用方法，用于创建和加入：'
- en: '![](img/d24a2f92-5ce9-46f7-ab4f-7c3b1cba03ab.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d24a2f92-5ce9-46f7-ab4f-7c3b1cba03ab.png)'
- en: 'There''s nothing really complex in this first test. `std::thread` was initialized
    with a function through the uniform initialization and joined (waiting for the
    thread to be completed). The thread would accept a function object:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个测试中并没有什么复杂的。`std::thread`通过统一初始化用函数初始化，并加入（等待线程完成）。线程将接受一个函数对象：
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`std::thread`: Create and join a thread, passing a parameter and getting a
    result:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::thread`：创建和加入一个线程，传递一个参数并获取结果：'
- en: '![](img/ae0e61f3-9191-417d-b82f-9b9789c85852.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae0e61f3-9191-417d-b82f-9b9789c85852.png)'
- en: This second test shows how to pass a parameter using `std::vector<int>& speeds`
    to the thread and get the return parameter, `int& ret`. This test shows how to
    pass parameters to a thread, and* is not* multithreaded code (that is, passing
    the same parameters to other threads will result in a race condition if *at least
    one* thread will be writing on them)!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这第二个测试展示了如何通过`std::vector<int>& speeds`将参数传递给线程，并获取返回参数`int& ret`。这个测试展示了如何向线程传递参数，并且*不是*多线程代码（也就是说，如果*至少有一个*线程将对它们进行写入，那么向其他线程传递相同的参数将导致竞争条件）！
- en: '`std::async`: Here, we can see why async is called**task-based ****threading**:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::async`：在这里，我们可以看到为什么`async`被称为**基于任务的**线程：'
- en: '![](img/2c7dfa24-2b7e-420a-a868-5dca78c347a6.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c7dfa24-2b7e-420a-a868-5dca78c347a6.png)'
- en: Note that when we call `std::async(asyncFunction);`, we could use `auto fut =
    std::async(asyncFunction);` to deduce the type of the return from `std::async` at
    compile time.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们调用`std::async(asyncFunction);`时，我们可以使用`auto fut = std::async(asyncFunction);`在编译时推断出`std::async`的返回类型。
- en: '`std::async`: This is another `std::async` example showing a basic communication
    mechanism:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::async`：这是另一个`std::async`示例，展示了一种基本的通信机制：'
- en: '![](img/3659b664-f69d-4cda-a2f7-1a24654284c2.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3659b664-f69d-4cda-a2f7-1a24654284c2.png)'
- en: The consumer, `void asyncConsumer(std::future<int> &fut)`, calls the `get()`
    method on the future to get the value set by the producer through the `set_value()`
    method on the promise. `fut.get()` waits for the value to be computed, if necessary (that
    is, it's a blocking call).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者`void asyncConsumer(std::future<int> &fut)`调用`get()`方法来获取由生产者通过`promise`的`set_value()`方法设置的值。`fut.get()`等待值的计算，如果需要的话（也就是说，这是一个阻塞调用）。
- en: There's more...
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The C++ concurrent library doesn't just include the features shown in this recipe,
    although these are the foundational ones. You are invited to explore the full
    set of concurrency tools that are available by going to *Chapter 5*, paragraph
    three of *The C++ Programming Language* by Bjarne Stroustrup.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: C++并发库不仅包括本示例中显示的功能，尽管这些是基础功能。您可以通过查看Bjarne Stroustrup的《C++程序设计语言》*第5章*第三段来探索可用的完整并发工具集。
- en: See also
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Scott Meyers的《Effective Modern C++》和Bjarne Stroustrup的《C++程序设计语言》详细介绍了这些主题。
- en: Understanding the filesystem
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解文件系统
- en: C++17 marks another huge milestone in terms of new features. The `filesystem`
    library provides a simpler way of interacting with the filesystem. It was inspired
    by `Boost.Filesystem` (available since 2003). This recipe will show its basics
    features.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: C++17标志着另一个新功能方面的重大里程碑。`filesystem`库提供了一种更简单的与文件系统交互的方式。它受到了自2003年以来就可用的`Boost.Filesystem`的启发。本示例将展示其基本功能。
- en: How to do it...
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到的...
- en: 'In this section, we''ll show two examples of the `filesystem` library by using `directory_iterator`
    and `create_directories`. Although there is definitely more under this namespace,
    the goal of these two snippets is to highlight their simplicity:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过使用`directory_iterator`和`create_directories`来展示`filesystem`库的两个示例。尽管在这个命名空间下肯定还有更多内容，但这两个片段的目标是突出它们的简单性：
- en: '`std::filesystem::directory_iterator`: Let''s write the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::filesystem::directory_iterator`：让我们编写以下代码：'
- en: '[PRE30]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, compile it with `g++ filesystem_01.cpp -std=c++17 -lstdc++fs`, where **`-std=c++17`**
    tells the compiler to use the C++17 standard and `-lstdc++fs` tells the compiler
    to use the `filesystem` library.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`g++ filesystem_01.cpp -std=c++17 -lstdc++fs`进行编译，其中**`-std=c++17`**告诉编译器使用C++17标准，`-lstdc++fs`告诉编译器使用`filesystem`库。
- en: 'The second example is about creating a directory and a file:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例是关于创建目录和文件：
- en: '`std::filesystem::create_directories`: Write the following code:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::filesystem::create_directories`：编写以下代码：'
- en: '[PRE31]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The compilation is as the same as the previous example: `g++ filesystem_02.cpp -std=c++17 -lstdc++fs`.'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译与前面的示例相同：`g++ filesystem_02.cpp -std=c++17 -lstdc++fs`。
- en: With just two lines of code, we've created a folder structure, a file, and have
    also written on it! It's as simple (and portable) as that.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 只需两行代码，我们就创建了一个文件夹结构、一个文件，并且还对其进行了写入！就是这么简单（而且可移植）。
- en: How it works...
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `filesystem` library is located in the `<filesystem>` header under the
    `std::filesystem` namespace. These two tests, although pretty simple, were needed
    to show how powerful the `filesystem` library is. The output of the first program
    is as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`filesystem`库位于`std::filesystem`命名空间下的`<filesystem>`头文件中。尽管这两个测试非常简单，但它们需要展示`filesystem`库的强大之处。第一个程序的输出如下：'
- en: '![](img/e3d7f330-c990-493c-aac9-28ea974e1a71.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3d7f330-c990-493c-aac9-28ea974e1a71.png)'
- en: 'A complete list of `std::filesystem` methods can be found here: [https://en.cppreference.com/w/cpp/header/filesystem](https://en.cppreference.com/w/cpp/header/filesystem).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这里找到`std::filesystem`方法的完整列表：[https://en.cppreference.com/w/cpp/header/filesystem](https://en.cppreference.com/w/cpp/header/filesystem)。
- en: '`std::filesystem::create_directories` create a directory (recursively, if `test/src`
    does not exist) in the current folder, in this case. Of course, an absolute path
    is managed too and the current line would be perfectly valid, that is, `std::filesystem::create_directories("/usr/local/test/config");`.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::filesystem::create_directories`在当前文件夹中创建一个目录（如果`test/src`不存在，则递归创建），在这种情况下。当然，绝对路径也是可以的，当前行也是完全有效的，即`std::filesystem::create_directories("/usr/local/test/config");`。'
- en: 'The second line of the source code uses `ofstream` to create an output file
    stream named `test/src/file.txt`and appends `<<` to the string: `This is an example!`*.*'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码的第二行使用`ofstream`来创建一个名为`test/src/file.txt`的输出文件流，并将`<<`附加到字符串：`This is an
    example!`*.*
- en: There's more...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `filesystem` library is heavily inspired by `Boost.Filesystem`, which has
    been available since 2003\. If you want to experiment and debug a little, just
    add the `-g` option (add the debug symbols to the binary) to the compiler: `g++
    **-g** fs.cpp -std=c++17 -lstdc++fs`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`filesystem`库受`Boost.Filesystem`的启发，自2003年以来一直可用。如果你想要尝试和调试一下，只需在编译器中添加`-g`选项（将调试符号添加到二进制文件）：`g++
    **-g** fs.cpp -std=c++17 -lstdc++fs`。'
- en: See also
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Scott Meyers的书*Effective Modern C++*和Bjarne Stroustrup的书*The C++ Programming
    Language*详细介绍了这些主题。
- en: The C++ Core Guidelines
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++核心指南
- en: The C++ Core Guidelines are a collaborative effort led by Bjarne Stroustrup,
    much like the C++ language itself. They are the result of many years of discussion
    and design across a number of organizations. Their design encourages general applicability
    and broad adoption but they can be freely copied and modified to meet your organization's
    needs*.* More precisely, these guidelines are referring to the C++14 standard.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: C++核心指南是由Bjarne Stroustrup领导的协作努力，就像C++语言本身一样。它们是多年来在许多组织中进行讨论和设计的结果。它们的设计鼓励普遍适用性和广泛采用，但可以自由复制和修改以满足您组织的需求。更准确地说，这些指南是指C++14标准。
- en: Getting ready
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Go over to GitHub and go to the C++ Core Guideline document ([http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)),
    as well as to the GitHub project page: [https://github.com/isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 前往GitHub并转到C++核心指南文档（[http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)），以及GitHub项目页面：[https://github.com/isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines)。
- en: How to do it...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The C++ Core Guidelines are divided into sections that are easily browsable.
    The sections include class and class hierarchies, resource management, performance,
    and error handling. The C++ Core Guidelines are a collaborative effort led by Bjarne Stroustrup
    and Herb Sutter but, in total, they involve more than 200 contributors (to find
    out more about this, please visit [https://github.com/isocpp/CppCoreGuidelines/graphs/contributors](https://github.com/isocpp/CppCoreGuidelines/graphs/contributors)).
    The quality, suggestions, and best practices they've put in are incredible.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: C++核心指南分为易于浏览的各个部分。这些部分包括类和类层次结构、资源管理、性能和错误处理。C++核心指南是由Bjarne Stroustrup和Herb
    Sutter领导的协作努力，但总共涉及200多名贡献者（要了解更多信息，请访问[https://github.com/isocpp/CppCoreGuidelines/graphs/contributors](https://github.com/isocpp/CppCoreGuidelines/graphs/contributors)）。他们提出的质量、建议和最佳实践令人难以置信。
- en: How it works...
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The most common way to use the C++ Core Guidelines is to keep a browser tab
    open on the GitHub page and consult it continuously for your daily tasks.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++核心指南的最常见方法是在GitHub页面上保持一个浏览器标签，并持续查阅它以完成日常任务。
- en: There's more...
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you want to contribute to the issues that have already been provided, the
    GitHub page contains a lot of items, ready to be picked up. For more information,
    please visit [https://github.com/isocpp/CppCoreGuidelines/issues](https://github.com/isocpp/CppCoreGuidelines/issues).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想为已提供的问题做出贡献，GitHub页面包含许多可供选择的项目。有关更多信息，请访问[https://github.com/isocpp/CppCoreGuidelines/issues](https://github.com/isocpp/CppCoreGuidelines/issues)。
- en: See also
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Adding GSL in your makefile* recipe of this chapter will be helpful.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的*在makefile中添加GSL*配方将非常有帮助。
- en: Adding GSL in your makefile
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在makefile中添加GSL
- en: '*"The GSL is the small set of types and aliases specified in these guidelines.
    At the time of writing, their specification herein is too sparse; we plan to add
    a WG21-style interface specification to ensure that different implementations
    agree, and to propose as a contribution for possible standardization, subject
    as usual to whatever the committee decides to accept/improve/alter/reject."* –
    FAQ.50 of the C++ Core Guidelines.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*“GSL是这些指南中指定的一小组类型和别名。在撰写本文时，它们的规范还不够详细；我们计划添加一个WG21风格的接口规范，以确保不同的实现达成一致，并提议作为可能标准化的贡献，通常受委员会决定接受/改进/更改/拒绝的影响。”*
    - C++核心指南的FAQ.50。'
- en: Getting ready
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Go to GitHub and go to the C++ Core Guideline document: [http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 前往GitHub并转到C++核心指南文档：[http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)。
- en: How to do it...
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll integrate the **Guideline Supporting Library** (`gsl`)
    to a program by modifying a makefile:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过修改makefile将**指南支持库**（`gsl`）集成到程序中：
- en: Download and copy a `gsl` implementation (for example, [https://github.com/microsoft/GSL](https://github.com/microsoft/GSL)).
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并复制`gsl`实现（例如[https://github.com/microsoft/GSL](https://github.com/microsoft/GSL)）。
- en: Copy the `gsl` folder into your project.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`gsl`文件夹复制到您的项目中。
- en: Add the include to the makefile: `-I$HOME/dev/GSL/include`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在makefile中添加包含：`-I$HOME/dev/GSL/include`。
- en: In your source file, include `#include <gsl/gsl>`.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的源文件中，包含`#include <gsl/gsl>`。
- en: 'The `gsl` currently provides the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`gsl`目前提供以下内容：'
- en: '`GSL.view`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GSL.view`'
- en: '`GSL.owner`'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GSL.owner`'
- en: '`GSL.assert: Assertions`'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GSL.assert: Assertions`'
- en: '`GSL.util: Utilities`'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GSL.util: Utilities`'
- en: '`GSL.concept: Concepts`'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GSL.concept: Concepts`'
- en: How it works...
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You might have noticed that to get the `gsl` working, you just need to specify
    the header file folder path in the makefile, that is, `-I$HOME/dev/GSL/include`.
    Another detail to note is that no library is specified in the makefile.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，要使`gsl`工作，只需在makefile中指定头文件夹路径，即`-I$HOME/dev/GSL/include`。还要注意的一点是，在makefile中没有指定任何库。
- en: This is because the whole implementation is provided *inline* in the header
    files under the `gsl` folder.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为整个实现都是在`gsl`文件夹下的头文件中提供的*内联*。
- en: There's more...
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Microsoft GSL ([http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines))
    is just one implementation maintained by Microsoft. You can find another implementation
    here: [https://github.com/martinmoene/gsl-lite](https://github.com/martinmoene/gsl-lite).
    Both implementations have been released under the MIT license type.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft GSL ([http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines))
    只是由Microsoft维护的一个实现。您可以在这里找到另一个实现：[https://github.com/martinmoene/gsl-lite](https://github.com/martinmoene/gsl-lite)。这两个实现都是以MIT许可类型发布的。
- en: See also
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*The C++ Core Guidelines* recipe of this chapter.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的《C++核心指南》示例。
- en: Understanding concepts
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解概念
- en: A **concept** is a compile-time predicate that's used in conjunction with templates.
    The C++20 standard definitely boosted generic programming by providing more compile-time
    opportunity for the developer to communicate its intention. We can visualize concepts
    such as requirements (or constraints)the user of the template must adhere to.
    Why do we need concepts? Do you have do define concepts by yourself? This recipe
    will answer these and many more questions.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念**是与模板一起使用的编译时谓词。C++20标准通过提供更多的编译时机会，使开发人员能够更多地传达其意图，从而明显提升了通用编程。我们可以将概念视为模板使用者必须遵守的要求（或约束）。我们为什么需要概念？您需要自己定义概念吗？这个示例将回答这些问题以及更多问题。'
- en: How to do it...
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we will develop a concrete template example using `concepts`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`概念`开发一个具体的模板示例：
- en: 'We want to create our own version of the `std::sort` template function from
    the C++ standard library. Let''s start by writing the following code in a `.cpp`
    file:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要创建自己版本的C++标准库中的`std::sort`模板函数。让我们从在`.cpp`文件中编写以下代码开始：
- en: '[PRE32]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s use our new template class with the constraint that the type we
    pass, an `std::vector`, must be sortable; otherwise, the compiler will notify
    us:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用我们的新模板类，并约束我们传递的类型，即`std::vector`必须是可排序的；否则，编译器会通知我们：
- en: '[PRE33]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We'll look at the details in the next section.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中详细讨论。
- en: How it works...
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: I strongly believe `concepts` were the missing feature. Before them, a template
    didn't have a well-defined set of requirements, nor, in the case of a compilation
    error, a simple and brief description of it. These are the two pillars that drove
    the design of the `concepts` feature.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我坚信`概念`是缺失的特性。在它们之前，模板没有明确定义的要求集，也没有在编译错误的情况下对其进行简单和简要的描述。这些是驱动`概念`特性设计的两个支柱。
- en: '*Step 1* includes the algorithms `include` for the `std::sort` method and the
    `concepts` header. To not confuse the compiler and ourselves, we encapsulated
    our new template in a namespace, `sp`. As you can see, there is a very minimal
    difference compared to the classical templates we used to use and the difference
    is with the `requires` keyword.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1*包括`std::sort`方法的`algorithms` `include`和`concepts`头文件。为了不让编译器和我们自己感到困惑，我们将新模板封装在一个命名空间`sp`中。正如您所看到的，与我们过去使用的经典模板相比，几乎没有什么区别，唯一的区别是使用了`requires`关键字。'
- en: '`requires` communicates to the compiler (and to the template user) that this
    template is only valid with a `T Sortable` type (`Sortable<T>`). OK; what is `Sortable`?
    This is a predicate that is only satisfied if it is evaluated to true. There are
    other ways to specify a constraint, as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires`向编译器（以及模板使用者）传达，这个模板只有在`T Sortable`类型（`Sortable<T>`）有效时才有效。好的；`Sortable`是什么？这是一个只有在评估为true时才满足的谓词。还有其他指定约束的方法，如下所示：'
- en: 'With the trailing `requires`:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用尾随`requires`：
- en: '[PRE34]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As a `template` parameter:'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为`模板`参数：
- en: '[PRE35]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'I personally prefer the style in the *How to do it...* section as it is more
    idiomatic and, more importantly, allows us to keep all the `requires` together,
    like so:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人更喜欢*如何做...*部分的风格，因为它更符合惯用法，更重要的是，它允许我们将所有的`requires`放在一起，就像这样：
- en: '[PRE36]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this example, we want to communicate that our `sp::sort` method is valid
    with type `T`, which is `Sortable` and `Integral`, for whatever reason.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们想要传达我们的`sp::sort`方法对类型`T`有效，这个类型是`Sortable`和`Integral`，出于任何原因。
- en: '*Step 2* simply uses our new customized version of sort. To do this, we instantiated
    a vector (which is `Sortable`!) and passed in input to the `sp::sort` method.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2*只是使用我们的新定制版本的sort。为此，我们实例化了一个（`Sortable`！）向`sp::sort`方法传入输入的向量。'
- en: There's more...
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There might be cases where you need to create your own concept. The standard
    library contains plenty of them, so it is a remote probability that you''d need
    one. As we learned in the previous section, a concept is a predicate if and only
    if it is evaluated as true. The definition of a concept as a composite of two
    existing ones might look like this:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有情况需要创建自己的概念。标准库包含了大量的概念，因此您可能不需要自己创建概念。正如我们在前一节中学到的，概念只有在评估为true时才是谓词。将概念定义为两个现有概念的组合可能如下所示：
- en: '[PRE37]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here, we can use the `sort` method:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以使用`sort`方法：
- en: '[PRE38]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Why is this cool? For a couple of reasons:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很酷？有几个原因：
- en: It lets us immediately know what the template expects without getting lost in
    implementation details (that is, the requirements or constraints are explicit).
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它让我们立即知道模板期望什么，而不会迷失在实现细节中（也就是说，要求或约束是明确的）。
- en: At compile time, the compiler will evaluate whether the constraints have been
    met.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时，编译器将评估约束是否已满足。
- en: See also
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*A Tour of C++, Second Edition,* B. Stroustrup: *Chapter 7.2 *and *Chapter* *12.7* for
    a complete list of concepts defined in the standard library.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《C++之旅，第二版》，B. Stroustrup：*第7.2章*和*第12.7章*，列出了标准库中定义的概念的完整列表。
- en: '[https://gcc.gnu.org/projects/cxx-status.html](https://gcc.gnu.org/projects/cxx-status.html)
    for a list of C++20 features mapped with GCC versions and status.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://gcc.gnu.org/projects/cxx-status.html](https://gcc.gnu.org/projects/cxx-status.html)
    以获取与GCC版本和状态映射的C++20功能列表。'
- en: Using span
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用span
- en: We may come across cases where we need to write a method but we'd like to have
    the flexibility to accept a plain array or STL containers as input. `std::span`
    solves this problem. It gives the user a view into a contiguous sequence of elements.
    This recipe will teach you how to use it.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到这样的情况，我们需要编写一个方法，但我们希望能够接受普通数组或STL容器作为输入。`std::span`解决了这个问题。它为用户提供了对连续元素序列的视图。这个食谱将教会你如何使用它。
- en: How to do it...
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll write a method with one parameter (`std::span`) that
    can be used in different contexts. Then, we''ll highlight the flexibility it offers:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将编写一个带有一个参数（`std::span`）的方法，可以在不同的上下文中使用。然后，我们将强调它提供的灵活性：
- en: 'Let''s start by adding the includes we need. Then, we need to define the `print`
    method by passing the `container` variable of the `std::span` type:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先添加我们需要的包含文件。然后，我们需要通过传递`std::span`类型的`container`变量来定义`print`方法：
- en: '[PRE39]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In `main`, we want to print our arrays by calling the `print` method:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`中，我们想通过调用`print`方法打印我们的数组：
- en: '[PRE40]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let's see how this works.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的。
- en: How it works...
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::span` describes an object that refers to a contiguous sequence of elements.
    The C++ standard defines an array as having a contiguous portion of memory. This
    definitely simplifies the `std::span` implementation, since a typical one includes
    a pointer to the first element of the sequence and the size.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::span`描述了一个引用连续元素序列的对象。C++标准将数组定义为具有连续内存部分。这绝对简化了`std::span`的实现，因为典型的实现包括指向序列第一个元素的指针和大小。'
- en: '*Step 1* defines the `print` method of passing the `std::span`, which we can
    read as a sequence of integers. Any array type that has contiguous memory will
    be seen from the method as a sequence.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1*定义了通过`std::span`传递的`print`方法，我们可以将其视为整数序列。任何具有连续内存的数组类型都将从该方法中看到为序列。'
- en: '*Step 2* uses the `print` method with two different arrays, one C-style and
    the second an `std::vector` part of the STL library. Since both arrays are defined
    in a contiguous portion of memory, `std::span` is able to seamlessly manage them.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2*使用`print`方法与两个不同的数组，一个是C风格的，另一个是STL库的`std::vector`。由于这两个数组都在连续的内存部分中定义，`std::span`能够无缝地管理它们。'
- en: There's more...
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Our method considers `std::span` with the `int` type. You might need to make
    the method generic. In this case, you''d need to write something like this:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法考虑了带有`int`类型的`std::span`。您可能需要使该方法通用。在这种情况下，您需要编写类似于以下内容：
- en: '[PRE41]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As we learned in the *Understanding concepts* recipe, it is wise to specify
    some requirements in this template. Therefore, we might write to the following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*理解概念*食谱中所学到的，为这个模板指定一些要求是明智的。因此，我们可能会写成以下内容：
- en: '[PRE42]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `requires Integral<T>` would make explicit the needs of an `Integral` type
    for the template.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`requires Integral<T>`将明确指出模板需要`Integral`类型。'
- en: See also
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Understanding concepts* recipe to review how to write concepts with templates
    and apply them to `std::span`.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解概念*食谱回顾如何使用模板编写概念并将其应用于`std::span`。'
- en: '[https://gcc.gnu.org/projects/cxx-status.html](https://gcc.gnu.org/projects/cxx-status.html) for
    a list of C++20 features mapped with GCC versions and their statuses.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://gcc.gnu.org/projects/cxx-status.html](https://gcc.gnu.org/projects/cxx-status.html)列出了与GCC版本及其状态映射的C++20功能列表。'
- en: Learning how Ranges work
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Ranges的工作原理
- en: The C++20 standard added Ranges, which are an abstraction of containers that
    allow the program to operate uniformly on containers' elements. Furthermore, Ranges
    represent a very modern and concise way of writing expressive code. We'll learn
    that this expressiveness is even greater with pipes and adaptors.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: C++20标准添加了Ranges，它们是对容器的抽象，允许程序统一地操作容器的元素。此外，Ranges代表了一种非常现代和简洁的编写表达性代码的方式。我们将了解到，这种表达性在使用管道和适配器时甚至更加强大。
- en: How to do it...
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll write a program that will help us learn the main use
    case of Ranges in conjunction with pipes and adaptors. Given an array of temperatures,
    we want to filter out the negative ones and convert the positives (warm temperatures)
    into Fahrenheit:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个程序，帮助我们学习Ranges与管道和适配器结合的主要用例。给定一个温度数组，我们想要过滤掉负数，并将正数（温暖的温度）转换为华氏度：
- en: 'On a new source file, type the following code. As you can see, two lambda functions
    and a `for` range loop does the job:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的源文件中，输入以下代码。正如你所看到的，两个lambda函数和一个`for`循环完成了工作：
- en: '[PRE43]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We'll analyze what's behind of Ranges in the next section. We'll also learn
    that Ranges are the first users of `concepts`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节分析Ranges的背后是什么。我们还将了解到Ranges是`concepts`的第一个用户。
- en: How it works...
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::ranges` represents a very modern way of describing a sequence of actions
    on a container in a readable format. This is one of the cases where the language
    improves readability.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::ranges`代表了一种非常现代的方式来以可读的格式描述容器上的一系列操作。这是一种语言提高可读性的情况之一。'
- en: '*Step 1* defines the `temperatures` vector, which contains some data. Then,
    we defined a lambda function that returns true if the input, `i`, is greater or
    equal to zero. The second lambda we defined converts `i` into Fahrenheit. Then,
    we looped over temperatures (`viewable_range`) and piped to the `filter` (called
    `adaptor`, in the scope of Ranges), which removed the negative temperatures based
    on the `minus` lambda function. The output is piped to another adaptor that converts
    every single item of the container so that the final loop can take place and print
    to the standard output.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1*定义了包含一些数据的`temperatures`向量。然后，我们定义了一个lambda函数，如果输入`i`大于或等于零，则返回true。我们定义的第二个lambda将`i`转换为华氏度。然后，我们循环遍历`temperatures`（`viewable_range`），并将其传递给`filter`（在Ranges范围内称为`adaptor`），它根据`minus`
    lambda函数删除了负温度。输出被传递给另一个适配器，它转换容器的每个单个项目，以便最终循环可以进行并打印到标准输出。'
- en: C++20 provides another level on top of the one we used to iterate over the container's
    element, one that's more modern and idiomatic. By combining `viewable_range` with
    adaptors, the code is more concise, compact, and readable.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: C++20提供了另一个层次，用于迭代容器元素的层次更现代和成语化。通过将`viewable_range`与适配器结合使用，代码更加简洁、紧凑和可读。
- en: The C++20 standard library provides many more adaptors following the same logic,
    including `std::views::all`, `std::views::take`, and `std::views::split`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: C++20标准库提供了许多遵循相同逻辑的适配器，包括`std::views::all`、`std::views::take`和`std::views::split`。
- en: There's more...
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'All of the adaptors are templates that use concepts to define the requirements
    that the specific adaptor needs. An example of this is as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些适配器都是使用概念来定义特定适配器需要的要求的模板。一个例子如下：
- en: '[PRE44]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This template is the `std::views::filter` we used in this recipe. This template
    takes two types: the first one is `V`, the input range (that is, the container),
    while the second one is `Pred` (which is the lambda function, in our case). We''ve
    specified two constraints for this template:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板是我们在这个配方中使用的`std::views::filter`。这个模板需要两种类型：第一种是`V`，输入范围（即容器），而第二种是`Pred`（在我们的情况下是lambda函数）。我们为这个模板指定了两个约束：
- en: '`V` must be a view'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V`必须是一个视图'
- en: 'The predicate must be an object type: a function, lambda, and so on'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谓词必须是对象类型：函数、lambda等等
- en: See also
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Understanding concepts* recipe to review concepts.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解概念*配方来审查概念。'
- en: Go to [https://github.com/ericniebler/range-v3](https://github.com/ericniebler/range-v3) to
    see the `range` implementation by the C++20 library proposal author (Eric Niebler).
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问[https://github.com/ericniebler/range-v3](https://github.com/ericniebler/range-v3)以查看C++20库提案作者（Eric
    Niebler）的`range`实现。
- en: '*Learning the Linux fundamentals – shell* recipe in [Chapter 1](c3cda38c-220e-4aae-89c6-c381df46daec.xhtml), *Getting
    Started with System Programming*, to notice that the C++20 Ranges pipe is very
    similar to the concept of pipes we''ve seen on the shell.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](c3cda38c-220e-4aae-89c6-c381df46daec.xhtml)的*学习Linux基础知识-Shell*配方中，注意C++20范围管道与我们在shell上看到的管道概念非常相似。
- en: To read more about `std::is_object`, please visit the following link: [https://en.cppreference.com/w/cpp/types/is_object](https://en.cppreference.com/w/cpp/types/is_object).
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解有关`std::is_object`的更多信息，请访问以下链接：[https://en.cppreference.com/w/cpp/types/is_object](https://en.cppreference.com/w/cpp/types/is_object)。
- en: Learning how modules work
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习模块如何工作
- en: 'Before C++20, there was only one way of structuring a program in parts: through
    the `#include` directive (which is resolved by the precompiler). The latest standard
    added another and more modern way of achieving the same result, called **module**.
    This recipe will show you how to write code using modules and the differences
    between `#include` and module.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20之前，构建程序的唯一方法是通过`#include`指令（由预编译器解析）。最新标准添加了另一种更现代的方法来实现相同的结果，称为**模块**。这个配方将向您展示如何使用模块编写代码以及`#include`和模块之间的区别。
- en: How to do it...
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll write a program composed of two modules. This program
    is an improvement of the one we developed in the *Learning how Range works* recipe.
    We''ll encapsulate the temperature code in a module and use it in a client module.
    Let''s get started:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个由两个模块组成的程序。这个程序是我们在*学习范围如何工作*配方中开发的程序的改进。我们将把温度代码封装在一个模块中，并在客户端模块中使用它。让我们开始吧：
- en: 'Let''s create a new `.cpp` source file called `temperature.cpp` and type in
    the following code:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`temperature.cpp`的新`.cpp`源文件，并键入以下代码：
- en: '[PRE45]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we have to use it. Create a new file (for example, `temperature_client.cpp`)
    and include the following code:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须使用它。创建一个新文件（例如`temperature_client.cpp`）并包含以下代码：
- en: '[PRE46]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The next section explains how modules work, what relationship they have with
    the namespaces, and the advantages they have over the `#include` precompiler directive.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将解释模块如何工作，它们与命名空间的关系以及它们相对于`#include`预编译指令的优势。
- en: How it works...
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A module is the C++20 solution to (possibly) the `#include` directive. Possibly
    is mandatory here as the millions of lines of legacy code cannot be converted
    overnight to use modules.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是C++20对（可能）`#include`指令的解决方案。这里可能是强制性的，因为数百万行的遗留代码不可能一夜之间转换为使用模块。
- en: '*Step 1* has the main goal of defining our `temperature_engine` module. The
    first line, `export module temperature_engine;`, defines the module we want to
    export. Next, we have `import std.core`. This is one of the biggest differences
    brought into C++20: there is no need to use `#include` anymore. Specifically,
    `import std.core` is equivalent to `#include <iostream>`. We also `#include` the
    range. In this case, we did it *the old way* to show you that is possible to have
    code that mixes old and new solutions. This is important as it''ll allow us how
    to manage the transition to module better. Every time we want to export something
    from our module, we just need to prefix it with the `export` keyword, as we did
    with the `toFahrenheitFromCelsius` method. The method''s implementation is not
    affected, so its logic doesn''t change.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤1*的主要目标是定义我们的`temperature_engine`模块。第一行`export module temperature_engine;`定义了我们要导出的模块。接下来，我们有`import
    std.core`。这是C++20引入的最大区别之一：不再需要使用`#include`。具体来说，`import std.core`等同于`#include
    <iostream>`。我们还`#include`了范围。在这种情况下，我们以*旧方式*做到了这一点，以向您展示可以混合旧和新解决方案的代码。这一点很重要，因为它将使我们更好地了解如何管理到模块的过渡。每当我们想要从我们的模块中导出东西时，我们只需要用`export`关键字作为前缀，就像我们对`toFahrenheitFromCelsius`方法所做的那样。方法的实现不受影响，因此它的逻辑不会改变。'
- en: '*Step 2* contains the code for the module client using `temperature_engine`.
    As we did in the previous step, we just need to use `import temperature_engine`
    and use the exported objects. We also used `import std.core` to replace `#include
    <iostream>`. Now, we can use the exported method as we normally would, calling
    `toFahrenheitFromCelsius` and passing the expected input  parameters. The `toFahrenheitFromCelsius` method
    returns a vector of integers representing the converted temperatures in Fahrenheit,
    which means all we need to do is use the `for_each` template method to print the
    values by using** `import std.core` **where we normally would have used `#include
    <algorithm>`.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2*包含使用`temperature_engine`的模块客户端的代码。与上一步一样，我们只需要使用`import temperature_engine`并使用导出的对象。我们还使用`import
    std.core`来替换`#include <iostream>`。现在，我们可以像通常一样使用导出的方法，调用`toFahrenheitFromCelsius`并传递预期的输入参数。`toFahrenheitFromCelsius`方法返回一个整数向量，表示转换后的华氏温度，这意味着我们只需要使用`for_each`模板方法通过**`import
    std.core`**打印值，而我们通常会使用`#include <algorithm>`。'
- en: 'The main question at this point is: why should we use module instead of `#include`?
    `Module` does not just represent a syntactic difference – it''s deeper than that:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 此时的主要问题是：为什么我们应该使用模块而不是`#include`？`模块`不仅代表了一种语法上的差异 - 它比那更深刻：
- en: A module is compiled only once, while `#includes` are not. To make `#include` compile
    only once, we need to use the `#ifdef` `#define`, and `#endif` precompilers.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块只编译一次，而`#include`不会。要使`#include`只编译一次，我们需要使用`#ifdef` `#define`和`#endif`预编译器。
- en: Module can be imported in any order without affecting the meaning. This is not
    the same for `#include`.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块可以以任何顺序导入，而不会影响含义。这对`#include`来说并非如此。
- en: If a symbol is not exported from the module, the client code cannot use it and
    the compiler will notify with an error if the users do.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个符号没有从模块中导出，客户端代码将无法使用它，如果用户这样做，编译器将通知错误。
- en: Modules, unlike includes, are not transitive. Importing module `A` into module
    `B`, when module `C` uses module `B`, doesn't mean it automatically gains access
    to module `A`.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与包含不同，模块不是传递的。将模块`A`导入模块`B`，当模块`C`使用模块`B`时，并不意味着它自动获得对模块`A`的访问权限。
- en: This has a great effect on maintainability, the structure of the code, and compilation
    time.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这对可维护性、代码结构和编译时间有很大影响。
- en: There's more...
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One recurrent question is, aren''t modules in conflict (or overlapping) with
    namespaces? This is a good point, and the answer is no. Namespaces and modules
    solve two different problems. A namespace is yet another mechanism that expresses
    the intention to group some declarations together. Other mechanisms that put group
    declaration together are functions and classes. What if two classes clash? We
    can encapsulate one of them into a namespace. You can see an example of this in
    the *Understanding concepts* recipe, where we created our own version of sort
    called `sp::sort`. A module, on the other hand, is a logical set of functionalities.
    The two concepts are **orthogonal**, which means I can have my namespace spread
    out over more modules. A concrete example is the `std::vector` and `std::list`
    containers, which are in two different modules but on the same `namespace`: `std`.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经常出现的问题是，模块与命名空间是否冲突（或重叠）？这是一个很好的问题，答案是否定的。命名空间和模块解决了两个不同的问题。命名空间是另一种表达意图将一些声明分组在一起的机制。将声明分组在一起的其他机制包括函数和类。如果两个类冲突怎么办？我们可以将其中一个封装到命名空间中。您可以在*理解概念*配方中看到一个例子，我们在那里创建了我们自己的版本的sort，称为`sp::sort`。另一方面，模块是一组逻辑功能。这两个概念是**正交**的，这意味着我可以将我的命名空间分布在更多的模块上。一个具体的例子是`std::vector`和`std::list`容器，它们位于两个不同的模块中，但在相同的`namespace`：`std`。
- en: 'Another thing worth highlighting is that modules allow us to set a portion
    of the module as `private` to make it inaccessible to other **Translation Units** (**TUs**).
    This is useful if you want to export a symbol as an incomplete type, like so:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的另一件事是，模块允许我们将模块的一部分设置为`private`，使其对其他**翻译单元**（**TUs**）不可访问。如果要将符号导出为不完整类型，这将非常有用。
- en: '[PRE47]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: See also
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Go to [https://gcc.gnu.org/projects/cxx-status.html](https://gcc.gnu.org/projects/cxx-status.html)
    to check the module (and other C++20 features) support timeline.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转到[https://gcc.gnu.org/projects/cxx-status.html](https://gcc.gnu.org/projects/cxx-status.html)检查模块（以及其他C++20功能）支持时间表。
- en: The *Lambda expressions* recipe for a refresher on lambdas.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关lambda表达式的刷新，请参阅*Lambda表达式*配方。
