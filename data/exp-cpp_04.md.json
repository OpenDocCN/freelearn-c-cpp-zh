["```cpp\nstruct spaceship {\n  bool is_military;\n  int speed;\n  int seats;\n};\n```", "```cpp\nstruct Product {\n  std::string name;\n  double price;\n  int rating;\n  bool available;\n};\n```", "```cpp\nProduct book;\nProduct tshirt;\nProduct* ptr = &book;\nProduct& ref = tshirt;\n```", "```cpp\n24 (std::string) + 8 (double) + 4 (int) + 1 (bool) = 37 bytes.\n```", "```cpp\nstd::cout << sizeof(Product);\n```", "```cpp\nProduct cpp_book; // declaring the object\n...\n// changing the state of the object cpp_book\ncpp_book.available = true;\ncpp_book.rating = 5;\n```", "```cpp\nProduct book1;\nbook1.rating = 4;\nbook1.name = \"Book\";\nProduct book2;\nbook2.rating = 4;\nbook2.name = \"Book\";\n```", "```cpp\nProduct prod;\nProduct prod; // won't compile, but still \"what if?\"\n```", "```cpp\nstruct Empty {};\n\nint main() {\n Empty e;\n  std::cout << sizeof(e);\n}\n```", "```cpp\ncpp_book.rating = -12;\n```", "```cpp\nvoid set_rating(Product* p, int r) {\n  if (r >= 1 && r <= 5) {\n p->rating = r;\n }\n  // otherwise ignore\n}\n...\nset_rating(&cpp_book, -12); // won't change the state\n```", "```cpp\nstruct Product {\n  std::string name;\n  double price;\n  int rating;\n  bool available;\n};\n\nvoid initialize(Product* p) {\n  p->price = 0.0;\n  p->rating = 0;\n  p->available = false;\n}\n\nvoid set_name(Product* p, const std::string& name) {\n  p->name = name;\n}\n\nstd::string get_name(Product* p) {\n  return p->name;\n}\n\nvoid set_price(Product* p, double price) {\n  if (price < 0 || price > 9999.42) return;\n  p->price = price;\n}\n\ndouble get_price(Product* p) {\n  return p->price;\n}\n\n// code omitted for brevity\n```", "```cpp\nint main() {\n  Product cpp_book;\n initialize(&cpp_book);\n  set_name(&cpp_book, \"Mastering C++ Programming\");\n  std::cout << \"Book title is: \" << get_name(&cpp_book);\n  // ...\n}\n```", "```cpp\nstruct Warehouse {\n  Product* products;\n  int capacity;\n  int size;\n};\n\nvoid initialize_warehouse(Warehouse* w) {\n  w->capacity = 1000;\n  w->size = 0;\n  w->products = new Product[w->capacity];\n  for (int ix = 0; ix < w->capacity; ++ix) {\n    initialize(&w->products[ix]); // initialize each Product object\n  }\n}\n\nvoid set_size(int size) { ... }\n// code omitted for brevity\n```", "```cpp\nclass Product {\npublic:\n  Product() = default; // default constructor\n  Product(const Product&); // copy constructor\n  Product(Product&&); // move constructor\n\n  Product& operator=(const Product&) = default;\n  Product& operator=(Product&&) = default;\n  // destructor is not declared, should be generated by the compiler\npublic:\n  void set_name(const std::string&);\n  std::string name() const;\n  void set_availability(bool);\n  bool available() const;\n  // code omitted for brevity\n\nprivate:\n  std::string name_;\n  double price_;\n  int rating_;\n  bool available_;\n};\n\nstd::ostream& operator<<(std::ostream&, const Product&);\nstd::istream& operator>>(std::istream&, Product&);\n```", "```cpp\nstruct Product {\n  std::string name_;\n  bool available_;\n  double price_;\n  int rating_;\n};\n\n// we forced the compiler to generate the default constructor\nvoid Product_constructor(Product&); \nvoid Product_copy_constructor(Product& this, const Product&);\nvoid Product_move_constructor(Product& this, Product&&);\n// default implementation\nProduct& operator=(Product& this, const Product&); \n// default implementation\nProduct& operator=(Product& this, Product&&); \n\nvoid Product_set_name(const std::string&);\n// takes const because the method was declared as const\nstd::string Product_name(const Product& this); \nvoid Product_set_availability(Product& this, bool b);\nbool Product_availability(const Product& this);\n\nstd::ostream& operator<<(std::ostream&, const Product&);\nstd::istream& operator>>(std::istream&, Product&);\n```", "```cpp\nProduct create_apple() {\n Product apple;\n  apple.set_name(\"Red apple\");\n  apple.set_price(\"0.2\");\n  apple.set_rating(5);\n  apple.set_available(true);\n  return apple;\n}\n\nint main() {\n Product red_apple = create_apple();\n Product book;  Product* ptr = &book;\n  ptr->set_name(\"Alice in Wonderland\");\n  ptr->set_price(6.80);\n  std::cout << \"I'm reading \" << book.name() \n            << \" and I bought an apple for \" << red_apple.price()\n            << std::endl;\n}\n```", "```cpp\nvoid create_apple(Product& apple) {\n  Product_set_name(apple, \"Red apple\");\n  Product_set_price(apple, 0.2);\n  Product_set_rating(apple, 5);\n  Product_set_available(apple, true);\n  return;\n}\n\nint main() {\n  Product red_apple;\n Product_constructor(red_apple);\n create_apple(red_apple);\n  Product book;\n Product* ptr;\n Product_constructor(book);\n Product_set_name(*ptr, \"Alice in Wonderland\");\n Product_set_price(*ptr, 6.80);\n  std::ostream os = operator<<(std::cout, \"I'm reading \");\n  os = operator<<(os, Product_name(book));\n  os = operator<<(os, \" and I bought an apple for \");\n  os = operator<<(os, Product_price(red_apple));\n  operator<<(os, std::endl);\n  // destructor calls are skipped because the compiler \n  // will remove them as empty functions to optimize the code\n  // Product_destructor(book);\n  // Product_destructor(red_apple);\n}\n```", "```cpp\nclass Product {\npublic:\n Product() = default;\n  // ...\n};\n```", "```cpp\nclass Product {\npublic:\n Product() = delete;\n  // ...\n};\n```", "```cpp\nstatic Product global_prod; // #1\n\nProduct* foo() {\n  Product* heap_prod = new Product(); // #4\n  heap_prod->name = \"Sample\";\n  return heap_prod;\n}\n\nint main() {\n Product stack_prod; // #2\n  if (true) {\n    Product tmp; // #3\n    tmp.rating = 3;\n  }\n  stack_prod.price = 4.2;\n  foo();\n}\n```", "```cpp\nProduct p1;\nProduct p2;\np2.set_price(4.2);\np1 = p2; // p1 now has the same price\nProduct p3 = p2; // p3 has the same price\n```", "```cpp\nProduct p1;\nProduct p2;\nProduct_set_price(p2, 4.2);\noperator=(p1, p2);\nProduct p3;\nProduct_copy_constructor(p3, p2);\n```", "```cpp\nclass Warehouse {\npublic:\n  Warehouse() \n    : size_{0}, capacity_{1000}, products_{nullptr}\n  {\n    products_ = new Products[capacity_];\n  }\n\n  ~Warehouse() {\n    delete [] products_;\n  }\n\npublic:\n  void add_product(const Product& p) {\n    if (size_ == capacity_) { /* resize */ }\n    products_[size_++] = p;\n  }\n  // other functions omitted for brevity\n\nprivate:\n  int size_;\n  int capacity_;\n  Product* products_;\n};\n\nint main() {\n  Warehouse w1;\n  Product book;\n  Product apple;\n  // ...assign values to products (omitted for brevity)\n  w1.add_product(book);\n  Warehouse w2 = w1; // copy\n  w2.add_product(apple);\n  // something somewhere went wrong...\n}\n```", "```cpp\nclass Warehouse {\npublic:\n  // ...\n  Warehouse(const Warehouse& rhs) {\n size_ = rhs.size_;\n capacity_ = rhs.capacity_;\n products_ = new Product[capacity_];\n for (int ix = 0; ix < size_; ++ix) {\n products_[ix] = rhs.products_[ix];\n }\n }\n  // code omitted for brevity\n};  \n```", "```cpp\nWarehouse small;\nWarehouse mid;\n// ... some data inserted into the small and mid objects\nWarehouse large{small + mid}; // operator+(small, mid)\n```", "```cpp\n// considering declared as friend in the Warehouse class\nWarehouse operator+(const Warehouse& a, const Warehouse& b) {\n  Warehouse sum; // temporary\n  sum.size_ = a.size_ + b.size_;\n  sum.capacity_ = a.capacity_ + b.capacity_;\n  sum.products_ = new Product[sum.capacity_];\n  for (int ix = 0; ix < a.size_; ++ix) { sum.products_[ix] = a.products_[ix]; }\n  for (int ix = 0; ix < b.size_; ++ix) { sum.products_[a.size_ + ix] = b.products_[ix]; }\n  return sum;\n}\n```", "```cpp\nWarehouse small;\nWarehouse mid;\n// ... some data inserted into the small and mid objects\nWarehouse tmp{operator+(small, mid)};\nWarehouse large;\nWarehouse_copy_constructor(large, tmp);\n__destroy_temporary(tmp);\n```", "```cpp\nclass Warehouse {\npublic:\n  Warehouse(); // default constructor\n  Warehouse(const Warehouse&); // copy constructor\n  Warehouse(Warehouse&&); // move constructor\n  // code omitted for brevity\n};\n```", "```cpp\ndouble pi{3.14}; // lvalue\nint x{42}; // lvalue\nint y{x}; // lvalue\nint& ref{x}; // lvalue-reference\n```", "```cpp\nint * const ref = &x;\n```", "```cpp\nint get_it() {\n  int it{42};\n  return it;\n}\n...\nint& impossible{get_it()}; // compile error\n```", "```cpp\nint&& possible{get_it()};\n```", "```cpp\nvoid do_something(int&& val) {\n  // do something with the val\n}\n// the return value of the get_it is moved to do_something rather than copied\ndo_something(get_it()); \n```", "```cpp\nint val;\nvoid get_it() {\n  val = 42;\n}\nvoid do_something() {\n  // do something with the val\n}\ndo_something();\n```", "```cpp\nint tmp;\nvoid get_it() {\n  tmp = 42;\n}\nvoid do_something(int val) {\n  // do something with the val\n}\ndo_something(tmp);\n```", "```cpp\nclass Warehouse {\npublic:\n  // constructors omitted for brevity\n  Warehouse(Warehouse&& src)\n : size_{src.size_}, \n capacity_{src.capacity_},\n products_{src.products_}\n {\n src.size_ = 0;\n src.capacity_ = 0;\n src.products_ = nullptr;\n }\n};\n```", "```cpp\nWarehouse large = small + mid;\n```", "```cpp\nconstexpr bool operator<(const Money& a, const Money& b) { \n  return a.value_ < b.value_; \n}\nconstexpr bool operator==(const Money& a, const Money& b) { \n  return a.value_ == b.value_; \n}\nconstexpr bool operator<=(const Money& a, const Money& b) { \n  return a.value_ <= b.value_; \n}\nconstexpr bool operator!=(const Money& a, const Money& b) { \n  return !(a == b); \n}\nconstexpr bool operator>(const Money& a, const Money& b) { \n  return !(a <= b); \n}\nconstexpr bool operator>=(const Money& a, const Money& b) { \n  return !(a < b); \n}\nconstexpr Money operator+(const Money& a, const Money& b) { \n  return Money{a.value_ + b.value_}; \n}\nconstexpr Money operator-(const Money& a, const Money& b) { \n  return Money{a.value_ - b.value_}; \n}\n```", "```cpp\nclass Money\n{\npublic:\n  Money() {}\n  explicit Money(double v) : value_{v} {}\n  // construction/destruction functions omitted for brevity\n\npublic:\n  friend constexpr bool operator<(const Money&, const Money&);\n friend constexpr bool operator==(const Money&, const Money&);\n friend constexpr bool operator<=(const Money&, const Money&);\n friend constexpr bool operator!=(const Money&, const Money&);\n friend constexpr bool operator>(const Money&, const Money&);\n friend constexpr bool operator>=(const Money&, const Money&);\n friend constexpr bool operator+(const Money&, const Money&);\n friend constexpr bool operator-(const Money&, const Money&);\n\nprivate:\n  double value_;\n}; \n```", "```cpp\nclass Money\n{\n  // code omitted for brevity\n friend auto operator<=>(const Money&, const Money&) = default;\n};\n```", "```cpp\nclass Warehouse {\npublic:\n  // rather naive implementation\n  void set_size(int sz) {\n if (sz < 1) throw std::invalid_argument(\"Invalid size\");\n size_ = sz;\n }\n  // code omitted for brevity\nprivate:\n  int size_;\n};\n```", "```cpp\nclass QuadraticSolver {\npublic:\n  QuadraticSolver() = default;\n  void set_a(double a);\n void set_b(double b);\n void set_c(double c);\n void find_discriminant();\n double solve(); // solve and return the x\nprivate:\n  double a_;\n  double b_;\n  double c_;\n  double discriminant_;\n};\n```", "```cpp\nQuadraticSolver solver;\nsolver.set_a(2);\nsolver.set_b(5);\nsolver.set_c(-8);\nsolver.find_discriminant();\nstd::cout << \"x is: \" << solver.solve() << std::endl;\n```", "```cpp\nclass QuadtraticSolver {\npublic:\n  QuadraticSolver() = default;\n double solve(double a, double b, double c);\n};\n```", "```cpp\nQuadraticSolver solver;\nstd::cout << solver.solve(2, 5, -8) << std::endl;\n```", "```cpp\nclass QuadraticSolver {\npublic:\n  QuadraticSolver() = delete;\n\n  static double solve_by_discriminant(double a, double b, double c);\n  // other solution methods' implementations can be prefixed by \"solve_by_\"\n};\n```", "```cpp\nstd::cout << QuadraticSolver::solve_by_discriminant(2, 5, -8) << std::endl;\n```", "```cpp\nclass Base\n{\npublic:\n  void foo() {}\n};\n\nclass Derived : Base\n{\n  // can access foo() while clients of Derived can't\n};\n```", "```cpp\nstruct Base\n{\n  // no need to specify the public section\n  void foo() {}\n};\n\nstruct Derived : Base\n{\n  // both Derived and clients of Derived can access foo()\n};\n```", "```cpp\nstruct Base\n{\n  void foo() {}\n};\n\n// Derived inherits Base privately\nclass Derived: Base\n{\n  // clients of Derived can't access foo()\n};\n```", "```cpp\nstruct Person\n{\n  std::string name;\n  int age;\n  std::string profession;\n};\n```", "```cpp\nPerson john{\"John Smith\", 22, \"programmer\"};\n```", "```cpp\nPerson mary{.name = \"Mary Moss\", .age{22}, .profession{\"writer\"}};\n```", "```cpp\nconst auto [p_name, p_age, p_profession] = mary;\nstd::cout << \"Profession is: \" << p_profession << std::endl;\n```", "```cpp\nclass Person; // forward declaration\nclass Engine { /* code omitted for brevity */ };\nclass Car {\npublic:\n  Car();\n  // ...\nprivate:\n  Person* driver_; // aggregation\n  std::vector<Person*> passengers_; // aggregation\n  Engine engine_; // composition\n  // ...\n}; \n```", "```cpp\nclass Vehicle {\npublic:\n  void move();\n};\n\nclass Car : public Vehicle {\npublic:\n  Car();\n  // ...\n};\n```", "```cpp\nclass Rectangle {\npublic:\n  // argument checks omitted for brevity\n  void set_width(int w) { width_ = w; }\n  void set_height(int h) { height_ = h; }\n  int area() const { return width_ * height_; }\nprivate:\n  int width_;\n  int height_;\n};\n```", "```cpp\nclass Square : public Rectangle {\npublic:\n  void set_side(int side) {\n set_width(side);\n set_height(side);\n  }\n\n int area() { \n    area_ = Rectangle::area();\n    return area_; \n  }\nprivate:\n int area_;\n};\n```", "```cpp\nvoid make_big_rectangle(Rectangle& ref) {\n  ref->set_width(870);\n  ref->set_height(940);\n}\n\nint main() {\n  Rectangle rect;\n  make_big_rectangle(rect);\n  Square sq;\n  // Square is a Rectangle\n  make_big_rectangle(sq);\n}\n```", "```cpp\nvoid make_big_rectangle(Rectangle * const ref) {\n  Rectangle_set_width(*ref, 870);\n  Rectangle_set_height(*ref, 940);\n}\n```", "```cpp\nstruct Rectangle {\n int width_;\n int height_;\n};\n\nvoid Rectangle_set_width(Rectangle& this, int w) {\n  this.width_ = w;\n}\n\nvoid Rectangle_set_height(Rectangle& this, int h) {\n  this.height_ = h;\n}\n\nint Rectangle_area(const Rectangle& this) {\n  return this.width_ * this.height_;\n}\n\nstruct Square {\n Rectangle _parent_subobject_;\n int area_; \n};\n\nvoid Square_set_side(Square& this, int side) {\n  // Rectangle_set_width(static_cast<Rectangle&>(this), side);\n Rectangle_set_width(this._parent_subobject_, side);\n  // Rectangle_set_height(static_cast<Rectangle&>(this), side);\n Rectangle_set_height(this._parent_subobject_, side);\n}\n\nint Square_area(Square& this) {\n  // this.area_ = Rectangle_area(static_cast<Rectangle&>(this));\n this.area_ = Rectangle_area(this._parent_subobject_); \n  return this.area_;\n}\n```", "```cpp\nclass Square : public Rectangle {\n  // code omitted for brevity\n};\n```", "```cpp\nclass Square : private Rectangle {\npublic:\n  void set_side(int side) {\n    // Rectangle's public interface is accessible to the Square\n    set_width(side);\n set_height(side);\n  }\n  int area() {\n    area_ = Rectangle::area();\n    return area_;\n  }\nprivate:\n  int area_;\n};\n```", "```cpp\nSquare sq;\nsq.set_width(14); // compile error, the Square has no such public member\nmake_big_rectangle(sq); // compile error, can't cast Square to Rectangle\n```", "```cpp\nclass Square {\npublic: \n  void set_side(int side) {\n rectangle_.set_width(side);\n rectangle_.set_height(side);\n  }\n  int area() {\n area_ = rectangle_.area();\n    return area_;\n  }\nprivate:\n Rectangle rectangle_;\n  int area_;\n};\n```", "```cpp\nclass Vector {\npublic:\n  Vector();\n  Vector(const Vector&);\n  Vector(Vector&&);\n  Vector& operator=(const Vector&);\n  Vector& operator=(Vector&&);\n  ~Vector();\n\npublic:\n  void push_back(int value);\n  void insert(int index, int value);\n  void remove(int index);\n  int operator[](int index);\n  int size() const;\n  int capacity() const;\n\nprivate:\n  int size_;\n  int capacity_;\n  int* array_;\n};\n```", "```cpp\nVector v;\nv.push_back(4);\nv.push_back(5);\nv[1] = 2;\n```", "```cpp\nclass Stack : private Vector {\npublic:\n  // constructors, assignment operators and the destructor are omitted for brevity\n void push(int value) {\n push_back(value);\n }\n int pop() {\n int value{this[size() - 1]};\n remove(size() - 1);\n return value;\n }\n};\n```", "```cpp\nStack s;\ns.push(5);\ns.push(6);\ns.push(3);\nstd::cout << s.pop(); // outputs 3\nstd::cout << s.pop(); // outputs 6\ns[2] = 42; // compile error, the Stack has no publicly available operator[] defined\n```", "```cpp\nclass Stack : protected Vector {\n  // code omitted for brevity\n};\n\nclass AdvancedStack : public Stack {\n  // can use the Vector\n};\n```", "```cpp\nclass Musician {\npublic:\n  void play() { std::cout << \"Play an instrument\"; }\n};\n```", "```cpp\nclass Guitarist {\npublic:\n  void play_guitar() { std::cout << \"Play a guitar\"; }\n};\n```", "```cpp\nclass Musician {\npublic:\n  virtual void play() { std::cout << \"Play an instrument\"; }\n};\n\nclass Guitarist : public Musician {\npublic:\n  void play() override { std::cout << \"Play a guitar\"; }\n};\n```", "```cpp\nMusician armstrong;\nGuitarist steve;\nMusician* m = &armstrong;\nm->play();\nm = &steve;\nm->play();\n```", "```cpp\nclass Musician {\npublic:\n virtual void play() = 0;\n};\n```", "```cpp\nclass Pianist : public Musician {\npublic: \n void play() override { std::cout << \"Play a piano\"; }\n};\n```", "```cpp\nstd::vector<Musician*> get_musicians();\n```", "```cpp\nauto all_musicians = get_musicians();\nfor (const auto& m: all_musicians) {\n m->play();\n}\n```", "```cpp\nclass Account\n{\npublic:\n virtual void cash_out() {\n // the default implementation for cashing out \n }  virtual ~Account() {}\nprivate:\n  double balance_;\n};\n```", "```cpp\nstruct Account\n{\n VTable* __vptr;\n  double balance_;\n};\n\nvoid Account_constructor(Account* this) {\n this->__vptr = &Account_VTable;\n}\n\nvoid Account_cash_out(Account* this) {\n  // the default implementation for cashing out\n}\n\nvoid Account_destructor(Account* this) {}\n```", "```cpp\nVTable Account_VTable[] = {\n &Account_cash_out,\n &Account_destructor\n};\n```", "```cpp\n// consider the get_account() function as already implemented and returning an Account*\nAccount* ptr = get_account();\nptr->cash_out();\n```", "```cpp\nAccount* ptr = get_account();\nptr->__vptr[0]();\n```", "```cpp\nclass SavingsAccount : public Account\n{\npublic:\n void cash_out() override {\n // an implementation specific to SavingsAccount\n }\n  virtual ~SavingsAccount() {}\n};\n```", "```cpp\nAccount* p = get_savings_account();\np->cash_out(); // calls SavingsAccount version of the cash_out\n```", "```cpp\nstruct SavingsAccount\n{\n  Account _parent_subobject_;\n  VTable* __vptr;\n};\n\nVTable* SavingsAccount_VTable[] = {\n  &SavingsAccount_cash_out,\n  &SavingsAccount_destructor,\n};\n\nvoid SavingsAccount_constructor(SavingsAccount* this) {\n  this->__vptr = &SavingsAccount_VTable;\n}\n\nvoid SavingsAccount_cash_out(SavingsAccount* this) {\n  // an implementation specific to SavingsAccount\n}\n\nvoid SavingsAccount_destructor(SavingsAccount* this) {}\n```", "```cpp\np->cash_out();\n```", "```cpp\np->__vptr[0]();\n```", "```cpp\nVTable* SavingsAccount_VTable[] = {\n  // the slot contains the base class version \n  // if the derived class doesn't have an implementation\n &Account_cash_out,\n  &SavingsAccount_destructor\n};\n```", "```cpp\nclass Warehouse {\npublic:\n  static create_instance() {\n if (instance_ == nullptr) {\n instance_ = new Warehouse();\n }\n return instance_;\n }\n\n static remove_instance() {\n delete instance_;\n instance_ = nullptr;\n }\n\nprivate:\n  Warehouse() = default;\n\nprivate:\n  static Warehouse* instance_ = nullptr;\n};\n```", "```cpp\nWarehouse* w = Warehouse::create_instance();\nProduct book;\nw->add_product(book);\nWarehouse::remove_instance();\n```"]