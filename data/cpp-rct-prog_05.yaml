- en: Introduction to Observables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observables的介绍
- en: 'In the last three chapters, we learned about the linguistic features of modern
    C++: multithreading, lock-free programming models, and so on. The topics covered
    there can be considered as sort of prerequisites to start learning about the reactive
    programming model. The reactive programming model warrants skills in functional
    programming, concurrent programming, schedulers, object/functional programming,
    design patterns, and event Stream processing, to name a few. We have already covered
    or touched upon functional programming, object/functional programming, and some
    topics that are related to scheduling in the previous chapter. This time, we will
    cover the wonderful world of design patterns to appreciate the crux of reactive
    programming in general and Observables in particular. In the next chapter, we
    will deal with the topic of event Stream programming before we jump into the RxCpp
    library. The design pattern movement reached critical mass with the publication
    of a book titled *Design Patterns: Elements of Reusable Object Oriented Software*
    by the **Gang of Four** (**GoF**). who cataloged a set of 23 patterns grouped
    into creational, structural, and behavioral families. The GoF catalog defined
    the Observer pattern in the category of behavioral patterns. A key message we
    want to deliver here is that the reactive programming model can be understood
    through knowledge of the venerable GoF patterns. In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后三章中，我们学习了现代C++的语言特性：多线程、无锁编程模型等。那里涵盖的主题可以被视为开始学习响应式编程模型的先决条件。响应式编程模型需要掌握函数式编程、并发编程、调度器、对象/函数式编程、设计模式和事件流处理等技能。我们已经在上一章中涵盖或涉及了函数式编程、对象/函数式编程以及与调度相关的一些主题。这次，我们将涵盖设计模式的精彩世界，以理解响应式编程的要点以及特别是Observables。在下一章中，我们将在跳入RxCpp库之前处理事件流编程的主题。设计模式运动随着一本名为*设计模式：可复用面向对象软件的元素*的书籍的出版而达到了临界质量，这本书由**四人帮**（**GoF**）编写，其中列出了一组分为创建型、结构型和行为型家族的23种模式。GoF目录将观察者模式定义为行为模式的一种。我们想要在这里传达的一个关键信息是，通过了解可敬的GoF模式，可以理解响应式编程模型。在本章中，我们将涵盖：
- en: The GoF Observer pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GoF观察者模式
- en: Limitations of the GoF Observer pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GoF观察者模式的局限性
- en: A holistic look at design patterns and Observables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对设计模式和Observables进行全面审视
- en: Modeling real-world hierarchies using composite design patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复合设计模式对建模现实世界的层次结构
- en: Behavioral processing of composites using visitors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用访问者对复合物进行行为处理
- en: Flattening the composite and navigating through the Iterator pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将复合物扁平化并通过迭代器模式进行导航
- en: Transformation from Iterator to Observable/Observer by reversing the gaze!
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过改变视角，从迭代器转换为Observable/Observer！
- en: The GoF Observer pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GoF观察者模式
- en: 'The GoF Observer pattern is also referred to as a *publish-subscribe pattern*
    in the GoF book. The idea is simple. `EventSource` (classes that emits events)
    will have a one-to-many relationship with event sinks (classes that listen to
    the event notification). Every `EventSource` will have a mechanism for the event
    sinks to subscribe to, in order to get different types of notification. A single
    `EventSource` might emit multiple events. An `EventSource` can send notifications
    to thousands of subscribers (event sinks or listeners) when there is a change
    in state or something significant happens in its realm. The `EventSource` will
    walk through the list of subscribers and notify them one by one. The GoF book
    was written at a time when the world was mostly doing sequential programming.
    Topics such as concurrency were mostly related to platform-specific libraries
    or the `POSIX` thread library. We will write a simple C++ program to demonstrate
    the whole idea of the Observer pattern. The purpose is to quickly understand the
    Observer pattern, and ideas such as robustness have been given secondary priority.
    The listing is self-contained and easily understandable:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: GoF观察者模式在GoF书中也被称为*发布-订阅模式*。这个想法很简单。`EventSource`（发出事件的类）将与事件接收器（监听事件通知的类）建立一对多的关系。每个`EventSource`都将有一个机制，让事件接收器订阅以获取不同类型的通知。单个`EventSource`可能会发出多个事件。当`EventSource`的状态发生变化或其领域发生重大事件时，它可以向成千上万的订阅者（事件接收器或监听器）发送通知。`EventSource`将遍历订阅者列表并逐个通知它们。GoF书是在世界大多数时间都在进行顺序编程的时候编写的。诸如并发性之类的主题大多与特定于平台的库或`POSIX`线程库相关。我们将编写一个简单的C++程序来演示观察者模式的整个思想。目的是快速理解观察者模式，鲁棒性等想法被次要地给予了优先级。这个清单是自包含的并且容易理解的：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The previous code snippet implements a trivial `EventSource`, which can potentially
    store an integral value as the state. In modern C++, we can use type traits to
    detect whether the consumer has instantiated this class with an integral type.
    Since our focus is on elucidation, we have not added assertions pertaining to
    type constraints. In the next C++ standards, there is a notion called **concept**
    (known as Constraints in other languages) that will help in enforcing that directly
    (without type traits). In a real-life scenario, an `EventSource` might store lots
    of variables or Streams of values. Any changes in them will be broadcast to all
    subscribers. In the `SetState` method, when a consumer of the `EventSource` class
    (the event sink itself is the consumer in this class) mutates the state, the `NotifyAll()`
    method will get triggered. The `NotifyAll()` method works through the list of
    sinks and invokes the `Update()` method. Then, event sinks can do the tasks that
    are specific to their context. We have not implemented methods such as unsubscribe
    to focus on the core issues:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段实现了一个微不足道的`EventSource`，它可以潜在地存储一个整数值作为状态。在现代C++中，我们可以使用类型特征来检测消费者是否已经用整数类型实例化了这个类。由于我们的重点是阐明，我们没有添加与类型约束相关的断言。在下一个C++标准中，有一个称为**concept**（在其他语言中称为约束）的概念，将有助于直接强制执行这一点（而不需要类型特征）。在现实生活中，`EventSource`可能存储大量变量或值流。对它们的任何更改都将广播给所有订阅者。在`SetState`方法中，当`EventSource`类的消费者（事件接收器本身是这个类中的消费者）改变状态时，`NotifyAll()`方法将被触发。`NotifyAll()`方法通过接收器列表工作，并调用`Update()`方法。然后，事件接收器可以执行特定于其上下文的任务。我们没有实现取消订阅等方法，以便专注于核心问题：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `EventSourceValueObserver` class has implemented the `Update` method to
    do a task that is relevant for its context. Here, it just prints the values of
    the old state and current state onto the console. In real life, sinks might modify
    a UX element or relay the propagation of state to other objects through notifications.
    Let''s also write another event sink, which will inherit from `EventSourceValueObserver`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventSourceValueObserver`类已经实现了`Update`方法来执行与其上下文相关的任务。在这里，它只是将旧状态和当前状态的值打印到控制台上。在现实生活中，接收器可能会修改UX元素或通过通知将状态的传播传递给其他对象。让我们再写一个事件接收器，它将继承自`EventSourceValueObserver`：'
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have implemented a specialized version of the Observer for demonstration
    purposes. This has been done to show that we can have subscribers that are instances
    of two classes (which can be inherited from `EventSourceObserver<T>`). Here also,
    we do not do much when we get a notification from the `EventSource`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为演示目的实现了观察者的专门版本。这样做是为了表明我们可以有两个类的实例（可以从`EventSourceObserver<T>`继承）作为订阅者。在这里，当我们从`EventSource`收到通知时，我们也不做太多事情：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The previous code snippet instantiates an `EventSource` object and adds two
    subscribers. When we change the state of the `EventSource`, the notification will
    be received by the subscribers. This is the crux of the Observer pattern. In a
    normal OOP program, the consumption of objects is done in the following way:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段实例化了一个`EventSource`对象并添加了两个订阅者。当我们改变`EventSource`的状态时，订阅者将收到通知。这是观察者模式的关键。在普通的面向对象编程程序中，对象的消费是以以下方式进行的：
- en: Instantiate the object
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化对象
- en: Call a method to compute some value or change state
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用方法计算某个值或改变状态
- en: Do something useful based on the return value or a change in the state
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据返回值或状态变化执行有用的操作
- en: 'Here, in the case of the Observer, we have done the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在观察者的情况下，我们已经做了以下工作：
- en: Instantiate the object (`EventSource`)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化对象（`EventSource`）
- en: Subscribe for the notification by implementing Observers (for event listening)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现观察者（用于事件监听）进行通知订阅
- en: When something changes at the `EventSource`, you will be notified
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`EventSource`发生变化时，您将收到通知
- en: Do something with the value received through the notification
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对通过通知接收到的值执行某些操作
- en: The `Method` function outlined here helps in the separation of concerns, and
    modularity has been achieved. This is a good mechanism to implement event-driven
    code. Rather than polling for events, you are asking to be notified. Most GUI
    toolkits today use similar paradigms.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里概述的`Method`函数有助于关注点的分离，并实现了模块化。这是实现事件驱动代码的良好机制。与其轮询事件，不如要求被通知。大多数GUI工具包今天都使用类似的范例。
- en: The limitations of the GoF Observer pattern
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GoF观察者模式的局限性
- en: 'The GoF pattern book was written at a time when the world was really doing
    sequential programming. The architecture of Observer pattern implementation had
    lot of anomalies, judging from the current programming model world view. Here
    are some of them:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: GoF模式书是在世界真正进行顺序编程的时候编写的。从当前的编程模型世界观来看，观察者模式实现的架构有很多异常。以下是其中一些：
- en: The close coupling between Subjects and Observers.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题和观察者之间的紧密耦合。
- en: The lifetime of the `EventSource` is controlled by the Observers.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventSource`的生命周期由观察者控制。'
- en: Observers (sinks) can block the `EventSource`.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者（接收器）可以阻塞`EventSource`。
- en: The implementation is not thread-safe.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现不是线程安全的。
- en: Event filtering is done at the sink level. Ideally speaking, the data should
    be filtered at the place where the data is (at the subject level, before notification).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件过滤是在接收器级别进行的。理想情况下，数据应该在数据所在的地方（在通知之前的主题级别）进行过滤。
- en: Most of the time, Observers do not do much and the CPU cycles will be wasted.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数时候，观察者并不做太多事情，CPU周期将被浪费。
- en: The `EventSource` should ideally publish the value to the environment. The environment
    should notify all the subscribers. This level of indirection can facilitate techniques
    such as event aggregation, event transformation, event filtering, and canonicalizing
    the event data to name a few.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventSource`理想上应该将值发布到环境中。环境应该通知所有订阅者。这种间接层次可以促进诸如事件聚合、事件转换、事件过滤和规范化事件数据等技术。'
- en: With the advent of functional programming techniques such as immutable variables,
    functional composition, functional style transformation, lock-free concurrent
    programming, and so on, we can circumvent the limits of the classic Observer pattern.
    The solution outlined by the industry is the notion of Observables.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着不可变变量、函数式组合、函数式风格转换、无锁并发编程等功能编程技术的出现，我们可以规避经典Observer模式的限制。行业提出的解决方案是Observables的概念。
- en: 'In the classic Observer pattern, a diligent reader might have seen the potential for
    the asynchronous programming model to be incorporated. The `EventSource` can make
    asynchronous calls to the Subscribers method, rather than looping the subscribers
    sequentially. By using a fire and forget mechanism, we can decouple the `EventSource`
    from its sinks. The invocation can be done from a background thread, async task,
    or packaged task, or a suitable mechanism for the context. The asynchronous invocation
    of notification methods has the added advantage that if any of the  client blocks
    (by getting into an infinite loop or a crash), others can still get the notification.
    The asynchronous method works on the following schema:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典Observer模式中，一个勤奋的读者可能已经看到了异步编程模型被整合的潜力。`EventSource`可以对订阅者方法进行异步调用，而不是顺序循环订阅者。通过使用一种“发射并忘记”的机制，我们可以将`EventSource`与其接收器解耦。调用可以从后台线程、异步任务或打包任务，或适合上下文的合适机制进行。通知方法的异步调用具有额外的优势，即如果任何客户端阻塞（进入无限循环或崩溃），其他客户端仍然可以收到通知。异步方法遵循以下模式：
- en: Define methods for handling data, exceptions, and the end of the data (on the
    event sink side)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义处理数据、异常和数据结束的方法（在事件接收器方面）
- en: An Observer (event Sink) interface should have `OnData`, `OnError`, and `OnCompleted`
    methods
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Observer（事件接收器）接口应该有`OnData`、`OnError`和`OnCompleted`方法
- en: Every event sink should implement the Observer interface
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个事件接收器应该实现Observer接口
- en: Every `EventSource` (Observable) should have subscribe and unsubscribe methods
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个`EventSource`（Observable）应该有订阅和取消订阅的方法
- en: The event sink should subscribe to an instance of Observable through Subscribe
    methods
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件接收器应该通过订阅方法订阅Observable的实例
- en: When an event happens, the Observer will be notified by the Observable
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当事件发生时，Observable会通知Observer
- en: Some of these things were already mentioned in [Chapter 1](0352eeb5-f1d9-42d2-b657-92ff3ed53abd.xhtml),
    *Reactive Programming Model – Overview and History*. We did not cover the asynchronous
    part then. In this chapter, we will revisit those ideas. Based on the experience
    which authors had based on the technical presentations and interaction with developers,
    jumping right into the Observable/Observer model of programming does not help
    in comprehension. Most developers are confused regarding Observable/Observer because
    of the fact that they do not know what particular problem this pattern solves.
    The classic GoF Observer implementation given here is to set the context for discussions
    on Observable Streams.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事情有些已经在[第1章](0352eeb5-f1d9-42d2-b657-92ff3ed53abd.xhtml)中提到过，*响应式编程模型-概述和历史*。当时我们没有涉及异步部分。在本章中，我们将重新审视这些想法。根据作者们在技术演示和与开发人员的互动中积累的经验，直接跳入编程的Observable/Observer模型并不能帮助理解。大多数开发人员对Observable/Observer感到困惑，因为他们不知道这种模式解决了什么特定的问题。这里给出的经典GoF
    Observer实现是为了为Observable Streams的讨论设定背景。
- en: A holistic look at GoF patterns
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对GoF模式的整体观察
- en: The design pattern movement started at a time when the World was struggling
    to come to terms with complexities of object-oriented software design methods.
    The GoF book and the associated pattern catalog gave developers a set of techniques
    for designing large-scale systems. Topics such as concurrency and parallelism
    were not in the minds of the people who designed the catalog. (At least, their
    work did not reflect this!)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式运动始于一个时期，当时世界正在努力应对面向对象软件设计方法的复杂性。GoF书籍和相关的模式目录为开发人员提供了一套设计大型系统的技术。诸如并发和并行性之类的主题并不在设计目录的设计者们的考虑之中。（至少，他们的工作没有反映出这一点！）
- en: We have seen that event handling through the classic Observer pattern has some
    limitations, which might be a problem in some cases. What is the way out? We need
    to take a fresh look at the problem of event handling by taking a step back. We
    will digress into the subject of philosophy a bit to have a different outlook
    on the problem that the reactive programming model (programming with Observable
    Streams!) is trying to solve. Our Journey  will help us to transition nicely from
    GOF patterns to the world of Reactive programming using functional programming
    constructs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，通过经典Observer模式进行事件处理存在一些局限性，这在某些情况下可能是个问题。有什么办法？我们需要重新审视事件处理的问题，退一步。我们将稍微涉及一些哲学的主题，以不同的视角看待响应式编程模型（使用Observable
    Streams进行编程！）试图解决的问题。我们的旅程将帮助我们从GOF模式过渡到使用函数式编程构造的响应式编程世界。
- en: The following content in this section is bit abstract and has been given here
    to provide a conceptual background from which authors  of this book have approached
    the subject covered in this chapter. Our approach to explaining Observables starts
    from the GoF Composite/Visitor pattern and iteratively reaches the topic of Observables. 
    The idea of this approach came from a book on Advaita Vedanta, a mystical philosophical
    tradition that originated in India.  The topic has been explained in Western Philosophical
    terms. If a matter seems bit abstract, feel free to gloss over it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的内容有些抽象，并且是为了提供一个概念性背景，从这个背景中，本书的作者们接触了本章涵盖的主题。我们解释Observables的方法是从GoF Composite/Visitor模式开始，逐步达到Observables的主题。这种方法的想法来自一本关于阿德瓦伊塔·维丹塔（Advaita
    Vedanta）的书，这是一种起源于印度的神秘哲学传统。这个主题已经用西方哲学术语解释过。如果某个问题看起来有点抽象，可以随意忽略它。
- en: 'Nataraja Guru (1895-1973) was an Indian philosopher who was a proponent of
    the Advaita Vedanta Philosophy, an Indian philosophical school based on the non-dualism
    of a supreme force that governs all of us. According to this philosophical school,
    whatever we see around , be it humans, animals, or plants, are manifestations
    of the Absolute (called Brahman in Sanskrit) and its only positive affirmation
    is SAT-CHIT-ANAND (Vedanta philosophy uses negation and proof by contradiction
    to depict Brahman). This can be translated into the English language as existence,
    essence, and bliss (the implied meaning of bliss is "good" here). In a book titled
    *The Unitive Philosophy* published by DK Print World, New Delhi, he gives a mapping
    of SAT-CHIT-ANAND to Ontology, Epistemology, and Axiology (the three primary branches
    of philosophy). The Ontology, Epistemology, and Axiology are the theories of existence,
    knowledge, and values respectively. The following table gives possible mappings
    of SAT-CHIT-ANAND to other entities that mean more or less the same:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Nataraja Guru（1895-1973）是一位印度哲学家，他是阿德瓦伊塔维达塔哲学的倡导者，这是一所基于至高力量的非二元论的印度哲学学派。根据这个哲学学派，我们周围所看到的一切，无论是人类、动物还是植物，都是绝对（梵文中称为婆罗门）的表现，它唯一的积极肯定是SAT-CHIT-ANAND（维达塔哲学使用否定和反证来描述婆罗门）。这可以被翻译成英语为存在、本质和幸福（这里幸福的隐含含义是“好”）。在DK
    Print World出版的一本名为《统一哲学》的书中，他将SAT-CHIT-ANAND映射到本体论、认识论和价值论（哲学的三个主要分支）。以下表格给出了SAT-CHIT-ANAND可能与其他意义相近的实体的映射。
- en: '| **SAT** | **CHIT** | **ANAND** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '**SAT** | **CHIT** | **ANAND**'
- en: '| Existence | Essence | Bliss |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: 存在 | 本质 | 幸福
- en: '| Ontology | Epistemology | Axiology |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: 本体论 | 认识论 | 价值论
- en: '| Who am I? | What can I know? | What should I do? |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: 我是谁？ | 我能知道什么？ | 我应该做什么？
- en: '| Structure | Behavior | Function |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: 结构 | 行为 | 功能
- en: In Vedanta (the Advaita school) philosophy, the whole World is viewed as existence,
    essence, and bliss. From the table, we will map the problems in the software design
    world into the problem of structure, behavior, and function. Every system in the
    world can be viewed from the structural, behavioral, and functional perspectives.
    The canonical structure for a OOP programs is hierarchies. We will model the world
    we are interested in as hierarchies and process them in a canonical manner. The
    GOF pattern catalog has got Composite pattern (structural)  for modelling hierarchies
    and Visitor pattern (behavioral)  to process them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vedanta（阿德瓦伊塔学派）哲学中，整个世界被视为存在、本质和幸福。从表中，我们将软件设计世界中的问题映射为结构、行为和功能的问题。世界上的每个系统都可以从结构、行为和功能的角度来看待。面向对象程序的规范结构是层次结构。我们将感兴趣的世界建模为层次结构，并以规范的方式处理它们。GOF模式目录中有组合模式（结构）用于建模层次结构和访问者模式（行为）用于处理它们。
- en: The OOP programming model and hierarchies
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程模型和层次结构
- en: This section is bit conceptual in nature and those of you who have not dabbled
    with GoF design patterns will find it a bit difficult. The best strategy could
    be to skip this section and focus on the running example. Once you have understood
    the running example, this particular section can be revisited.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分在概念上有些复杂，那些没有涉足过GoF设计模式的人可能会觉得有些困难。最好的策略可能是跳过这一部分，专注于运行示例。一旦理解了运行示例，就可以重新访问这一部分。
- en: Object-oriented programming is very good at modeling hierarchies. In fact, the
    hierarchy can be considered the canonical data model for the object-oriented processing
    of data. In the GoF pattern world, we model hierarchies using the Composite pattern.
    The Composite pattern is categorized as a structural pattern. Whenever there is
    a Composite pattern used, the Visitor pattern will also be part of the system.
    The Visitor pattern is good for processing composites to add behavior to the structure.
    The Visitor/Composite patterns come as a pair in real-life contexts. Of course,
    one instance of the Composite can be processed by different visitors. In a Compiler
    project, the **Abstract Syntax Tree** (**AST**) will be modeled as a composite
    and there will be Visitor implementations for type checking, code optimization,
    code generation, and static analysis to name a few.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程非常擅长建模层次结构。事实上，层次结构可以被认为是面向对象数据处理的规范数据模型。在GoF模式世界中，我们使用组合模式来建模层次结构。组合模式被归类为结构模式。每当使用组合模式时，访问者模式也将成为系统的一部分。访问者模式适用于处理组合以向结构添加行为。访问者/组合模式在现实生活中成对出现。当然，组合的一个实例可以由不同的访问者处理。在编译器项目中，**抽象语法树**（**AST**）将被建模为一个组合，并且将有访问者实现用于类型检查、代码优化、代码生成和静态分析等。
- en: 'One of the problems with the Visitor pattern is the fact that it has to have
    some notion of the structure of the Composite to do the processing.  Moreover,
    it  will result in code bloat in the context where it needs to process a filtered
    subset of the available data in the Composite hierarchy. We might require different
    visitors for each filter criterion. The GoF pattern catalog has another pattern
    that falls into the behavioral category, called Iterator, something that every
    C++ programmer is familiar with. The Iterator pattern is good at processing data
    in a structure-agnostic manner. Any kind of hierarchical structure has to be linearized
    or flattened to be in a shape amenable to be processed by an Iterator. An example
    could be a tree, which can be processed using a BFS Iterator or a DFS Iterator.
    For the application programmer, all of a sudden the tree appears as a linear structure.
    We need to flatten the hierarchies to be in a state where the structure is amenable
    to Iterators. The process will be implemented by the person who has implemented
    the API. There are some limitations to the Iterator pattern (which is pull-based)
    and we will reverse the gaze and make the system push-based using a pattern called
    Observerable/Observer, an enhanced version of the Observer pattern. This section
    is a bit abstract, but after going through the entire chapter, you can come back
    and make sense of what is happening. In a nutshell, we can sum up the whole thing
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式的问题之一是它必须对组合的结构有一定的概念才能进行处理。此外，在需要处理组合层次结构中可用数据的筛选子集的上下文中，它将导致代码膨胀。我们可能需要为每个过滤条件使用不同的访问者。GoF模式目录中还有另一个属于行为类别的模式，称为Iterator，这是每个C++程序员都熟悉的东西。Iterator模式擅长以结构无关的方式处理数据。任何层次结构都必须被线性化或扁平化，以便被Iterator处理。例如，树可以使用BFS
    Iterator或DFS Iterator进行处理。对于应用程序员来说，树突然变成了线性结构。我们需要将层次结构扁平化，使其处于适合Iterator处理的状态。这个过程将由实现API的人来实现。Iterator模式也有一些局限性（它是基于拉的），我们将通过一种称为Observable/Observer的模式将系统改为基于推的。这一部分有点抽象，但在阅读整个章节后，你可以回来理解发生了什么。简而言之，我们可以总结整个过程如下：
- en: We can model hierarchical structures using the Composite pattern
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用组合模式来建模层次结构
- en: We can process the Composite using the Visitor pattern
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用Visitor模式处理组合
- en: We can flatten or linearize the Composite to navigate it through Iterators
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过Iterator来展开或线性化组合
- en: Iterators follow a pull method and we need to reverse the gaze for a push-based
    scheme
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Iterators遵循拉取方法，我们需要为基于推的方案逆转视线
- en: Now, we have managed to reach the Observable/Observer way of implementing things
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们已经成功地实现了Observable/Observer的方式来实现事物
- en: Observables and Iterators are binary opposites (one man's push is another man's
    pull!)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Observables和Iterators是二进制对立的（一个人的推是另一个人的拉！）
- en: We will implement all of the preceding points to have a firm grounding on Observables.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现所有前述观点，以对Observables有牢固的基础。
- en: A Composite/Visitor pattern for expression processing
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于表达式处理的组合/访问者模式
- en: 'To demonstrate the journey from the GoF pattern catalog to Observables, we
    will model a four-function calculator as a running example. Since expression trees
    or AST are hierarchical in nature, they will be a good example to model as a Composite
    pattern. We have purposefully omitted writing a parser to keep the code listing
    small:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示从GoF模式目录到Observables的过程，我们将模拟一个四则运算计算器作为一个运行示例。由于表达式树或AST本质上是层次结构的，它们将是一个很好的例子，可以作为组合模式的模型。我们故意省略了编写解析器，以保持代码清单的简洁：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have defined an enum type to represent the four binary operators (`+` ,
    `-` , `*` , `/`) and two unary operators (`+` , `-`). Other than the standard
    C++ headers, we have included a custom header (`FuncCompose.h`), which is available
    at the GitHub repo associated with this book. It contains code for the Compose
    function and pipe operator (`|`) for functional composition. We can use Unix pipeline
    style composition to tie together a collection of transformations:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个枚举类型来表示四个二元运算符（`+`，`-`，`*`，`/`）和两个一元运算符（`+`，`-`）。除了标准的C++头文件，我们还包含了一个自定义头文件（`FuncCompose.h`），它可以在与本书相关的GitHub存储库中找到。它包含了Compose函数和管道运算符（`|`）的代码，用于函数组合。我们可以使用Unix管道风格的组合来将一系列转换联系在一起：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Expr class will act as the base class for all the nodes that are part of
    the Expression Tree. Since our purpose is to demonstrate the Composite/Visitor
    GoF pattern, we support only constants, binary expressions, and unary expressions.
    The accept method in the Expr class accepts a Visitor reference as a parameter
    and the body of the method will be the same for all the nodes. The method will
    redirect the call to the appropriate handler on the Visitor implementation.  To
    gain more insight into the whole subject covered in this section, read about *double
    dispatch* and *Visitor pattern*  by searching the web using your favorite search
    engine.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Expr类将作为表达式树中所有节点的基类。由于我们的目的是演示组合/访问者GoF模式，我们只支持常数、二元表达式和一元表达式。Expr类中的accept方法接受一个Visitor引用作为参数，方法的主体对所有节点都是相同的。该方法将把调用重定向到Visitor实现上的适当处理程序。为了更深入地了解本节涵盖的整个主题，通过使用您喜欢的搜索引擎搜索*双重分派*和*Visitor模式*。
- en: 'The Visitor interface (`IExprVisitor`) contains methods to process all the
    node types supported by the hierarchy. In our case, there are methods for processing
    constant numbers, binary operators, and unary operators. Let''s see the code for
    the Node types. We start with the Number class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Visitor接口（`IExprVisitor`）包含处理层次结构支持的所有节点类型的方法。在我们的情况下，有处理常数、二元运算符和一元运算符的方法。让我们看看节点类型的代码。我们从Number类开始：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Number class wraps an IEEE double precision floating point number. The
    code is obvious and all we need to bother about is the content of the `accept`
    method. The method receives a parameter of type visitor (`IExprVisitor&`). The
    routine just reflects the call back to the appropriate node on the Visitor implementation.
    In this case, it will call `Visit(Number&)` on `IExpressionVisitor`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Number类封装了IEEE双精度浮点数。代码很明显，我们需要关心的只是`accept`方法的内容。该方法接收一个`visitor`类型的参数（`IExprVisitor&`）。该例程只是将调用反映到访问者实现的适当节点上。在这种情况下，它将在`IExpressionVisitor`上调用`Visit(Number&)`：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `BinaryExpr` class models a binary operation with left and right operands.
    The operands can be any of the classes in the hierarchy. The candidate classes
    are `Number`, `BinaryExpr`, and `UnaryExpr`. This can go to an arbitrary depth.
    The terminal node is Number in our case. The previous code has support for four
    binary operators:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinaryExpr`类模拟了具有左右操作数的二元运算。操作数可以是层次结构中的任何类。候选类包括`Number`、`BinaryExpr`和`UnaryExpr`。这可以到任意深度。在我们的情况下，终端节点是Number。先前的代码支持四个二元运算符：'
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `UnaryExpr` method models a unary expression with an operator and a right
    side expression. We support unary plus and unary minus for this implementation.
    The right side expression can in turn be a `UnaryExpr`, `BinaryExpr`, or `Number`.
    Now that we have implementations for all the node types supported, let''s focus
    on the implementation of the Visitor Interface. We will write a Tree Walker and
    Evaluator to compute the value of the expression:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnaryExpr`方法模拟了带有运算符和右侧表达式的一元表达式。我们支持一元加和一元减。右侧表达式可以是`UnaryExpr`、`BinaryExpr`或`Number`。现在我们已经为所有支持的节点类型编写了实现，让我们专注于访问者接口的实现。我们将编写一个树遍历器和评估器来计算表达式的值：'
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This does a depth-first walk of the AST and recursively evaluates the node.
    Let''s write an expression processor (an implementation of `IExprVisitor`) that
    will print the expression tree to the console in **Reverse Polish Notation** (**RPN**) form:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将对AST进行深度优先遍历，并递归评估节点。让我们编写一个表达式处理器（`IExprVisitor`的实现），它将以**逆波兰表示法**（**RPN**）形式将表达式树打印到控制台上：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The RPN notation is also called the postfix notion, where the operator comes
    after the operands. They are suitable for processing using an evaluation stack.
    They form the basis of the stack-based virtual machine architecture leveraged
    by the Java Virtual Machine and the .NET CLR. Now, let''s write a main function
    to put everything together:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: RPN表示法也称为后缀表示法，其中运算符位于操作数之后。它们适合使用评估堆栈进行处理。它们构成了Java虚拟机和.NET CLR所利用的基于堆栈的虚拟机架构的基础。现在，让我们编写一个主函数将所有内容整合在一起：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code snippet creates an instance of a composite (an instance of `BinaryExpr`)
    and also instantiates an instances of `TreeEvaluatorVisitor` and `ReversePolshEvaluator`.
    Then, the `accept` method of Expr is called to start processing. We will see the
    value of the expression and an RPN equivalent of the expression on the console.
    In this section, we learned how to create a Composite and process the Composite
    using a Visitor interface. Other potential examples for Composites/Visitors are
    storing directory contents and their traversal, XML processing, document processing,
    and so on. Popular opinion says that, if you know the Composite/Visitor duo, you
    have understood the GoF pattern catalog well.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段创建了一个组合的实例（`BinaryExpr`的一个实例），并实例化了`TreeEvaluatorVisitor`和`ReversePolshEvaluator`的实例。然后，调用Expr的`accept`方法开始处理。我们将在控制台上看到表达式的值和表达式的RPN等价形式。在本节中，我们学习了如何创建一个组合，并使用访问者接口处理组合。组合/访问者的其他潜在示例包括存储目录内容及其遍历、XML处理、文档处理等。普遍观点认为，如果您了解组合/访问者二者，那么您已经很好地理解了GoF模式目录。
- en: We have seen that the Composite pattern and Visitor pattern act as a pair to
    take care of the structural and behavioral aspects of a system and provide some
    functionality. The Visitor has to be written in a manner that presupposes the
    cognizance of the structure of the Composite. This can be a potential problem
    from an abstraction perspective. An implementer of a hierarchy can provide a mechanism
    to flatten the hierarchy into a list (which is possible in most cases). This will
    enable the API implementer to provide an Iterator-based API. The Iterator-based
    API is good for functional-style processing as well. Let's see how it works.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，组合模式和访问者模式作为一对来处理系统的结构和行为方面，并提供一些功能。访问者必须以一种假定了组合结构的认知方式编写。从抽象的角度来看，这可能是一个潜在的问题。层次结构的实现者可以提供一种将层次结构展平为列表的机制（在大多数情况下是可能的）。这将使API实现者能够提供基于迭代器的API。基于迭代器的API也适用于函数式处理。让我们看看它是如何工作的。
- en: Flattening the composite for iterative processing
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展平组合以进行迭代处理
- en: 'We have already learned that the Visitor pattern has to know the structure
    of the composite for someone to write an instance of the Visitor interface. This
    can create an anomaly called *abstraction leak*. The GoF pattern catalog has a
    pattern that will help us to navigate the contents of a tree in a structure-agnostic
    manner. Yes, you might have guessed it correctly: the Iterator pattern is the
    candidate! For the Iterator to do its job, the composite has to be flattened into
    a list sequence or Stream. Let''s write some code to flatten the expression tree
    that we modeled in the previous section. Before we write the logic to flatten
    a Composite, let''s create a data structure to store the contents of an AST as
    a list. Every node in the list has to store either an operator or value, depending
    upon whether we need to store operators or operands. We describe a data structure
    called `EXPR_ITEM` for this purpose:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，访问者模式必须了解复合体的结构，以便有人编写访问者接口的实例。这可能会产生一个称为*抽象泄漏*的异常。GoF模式目录中有一个模式，将帮助我们以结构不可知的方式导航树的内容。是的，你可能已经猜对了：迭代器模式是候选者！为了使迭代器发挥作用，复合体必须被扁平化为列表序列或流。让我们编写一些代码来扁平化我们在上一节中建模的表达式树。在编写扁平化复合体的逻辑之前，让我们创建一个数据结构，将AST的内容作为列表存储。列表中的每个节点必须存储操作符或值，具体取决于我们是否需要存储操作符或操作数。我们为此描述了一个名为`EXPR_ITEM`的数据结构：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `list<EXPR_ITEM>` data structure will store the contents of the composite
    as a linear structure. Let''s write a class that will flatten the composite:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`list<EXPR_ITEM>`数据结构将以线性结构存储复合的内容。让我们编写一个类来扁平化复合体：'
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `FlattenerVistor` class will flatten the composite `Expr` node to a list
    of `EXPR_ITEM`. Once the composite has been linearized, it is possible to process
    items using the Iterator pattern. Let''s write a small global function to convert
    an `Expr` tree to `list<EXPR_ITEM>`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlattenerVistor`类将复合`Expr`节点扁平化为`EXPR_ITEM`列表。一旦复合体被线性化，就可以使用迭代器模式处理项目。让我们编写一个小的全局函数，将`Expr`树转换为`list<EXPR_ITEM>`：'
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The global subroutine `ExprList` will flatten an arbitrary expression tree
    of a list of `EXPR_ITEM`. Once we have flattened the composite, we can use an
    iterator to process the content. After linearizing the structure as a list, we
    can use a stack data structure to evaluate the expression data to produce the
    output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 全局子例程`ExprList`将扁平化一个任意表达式树的`EXPR_ITEM`列表。一旦我们扁平化了复合体，我们可以使用迭代器来处理内容。在将结构线性化为列表后，我们可以使用堆栈数据结构来评估表达式数据以产生输出：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`DoubleStack` is a wrapper around the STL stack container. This can be considered
    as some kind of helper routine to keep the listing terse. Let''s write an evaluator
    for the flattened expression. We will iterate through list`<EXPR_ITEM>` and push
    the value to the stack, if a value is encountered. If an operator is encountered,
    we will pop the values from the stack and apply the operation. The result is pushed
    into the stack once again. At the end of the iteration, the existing element in
    the stack will be the value associated with the expression:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoubleStack`是STL堆栈容器的包装器。这可以被视为一种帮助程序，以保持清单的简洁。让我们为扁平化表达式编写一个求值器。我们将遍历列表`<EXPR_ITEM>`并将值推送到堆栈中，如果遇到值的话。如果遇到操作符，我们将从堆栈中弹出值并应用操作。结果再次推入堆栈。在迭代结束时，堆栈中现有的元素将是与表达式相关联的值：'
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s write a main program that will call this function to evaluate the expression.
    The code listing in the evaluator is easy to understand because we are reducing
    a list. In the tree-based interpreter, things were not obvious:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个主程序，调用这个函数来评估表达式。求值器中的代码清单易于理解，因为我们正在减少一个列表。在基于树的解释器中，事情并不明显：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Map and filter operations on the list
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表上的Map和Filter操作
- en: 'Map is a functional operator where a function will be applied to a list. Filter
    will apply a predicate to a list and return another list. They are the cornerstone
    of any functional processing pipeline. They are also called higher-order functions.
    We can write a generic Map function, using `std::transform` for `std::list` and
    the `std::vector`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Map是一个功能操作符，其中一个函数将被应用于列表。Filter将对列表应用谓词并返回另一个列表。它们是任何功能处理管道的基石。它们也被称为高阶函数。我们可以编写一个通用的Map函数，使用`std::transform`用于`std::list`和`std::vector`：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s also write a function to filter a `std::list` (we assume only a list
    will be passed). The same can work on `std::vector`. We can compose a higher-order
    function using the pipe operator. The composite function can also be passed as
    a predicate:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还编写一个函数来过滤`std::list`（我们假设只会传递一个列表）。相同的方法也适用于`std::vector`。我们可以使用管道操作符来组合一个高阶函数。复合函数也可以作为谓词传递：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this implementation of Filter, due to limitations in `std::copy_if`, we
    were forced to roll our own iteration logic. It is generally advised to use the
    STL implementation of functions to write wrappers. For this particular scenario,
    we need to detect whether a list is empty or not:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Filter的实现中，由于`std::copy_if`的限制，我们被迫自己编写迭代逻辑。通常建议使用STL函数的实现来编写包装器。对于这种特殊情况，我们需要检测列表是否为空：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s write a main function to put everything together. The code will demonstrate
    how to use `Map` and `Filter` in the application code. The logic for functional
    composition and the pipe operator are available in the `FuncCompose.h`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个主函数将所有内容组合在一起。代码将演示如何在应用程序代码中使用`Map`和`Filter`。功能组合和管道操作符的逻辑在`FuncCompose.h`中可用：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Filter` routine creates a new `list<Expr>`, which contains only the values
    or operands used in the expression. The `Map` routine applies a composite function
    on the list of values to return a new list.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Filter`例程创建一个新的`list<Expr>`，其中只包含表达式中使用的值或操作数。`Map`例程在值列表上应用复合函数以返回一个新列表。'
- en: Reversing the gaze for Observables!
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆转注视可观察性！
- en: We have already learned that we can transform a composite to a list and traverse
    them through an Iterator. The Iterator pattern pulls data from the data source
    and manipulates the result at the consumer level. The most important problem we
    face is that we are coupling our `EventSource` and event sink. The GoF Observer
    pattern also does not help here.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何将复合转换为列表，并通过迭代器遍历它们。迭代器模式从数据源中提取数据，并在消费者级别操纵结果。我们面临的最重要的问题之一是我们正在耦合`EventSource`和事件接收器。GoF观察者模式在这里也没有帮助。
- en: 'Let''s write a class that can act as an event hub, which the sinks will subscribe
    to. By having an event hub, we will now have an object that will act as an intermediary
    between the `EventSource` and event sink. One advantage of this indirection is
    readily obvious from the fact that our class can aggregate, transform, and filter
    out events before they reach the consumer. The consumer can even set transformation
    and filtering criteria at the event hub level:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个可以充当事件中心的类，事件接收器将订阅该类。通过拥有事件中心，我们现在将有一个对象，它将充当`EventSource`和事件接收器之间的中介。这种间接的一个优点很容易明显，即我们的类可以在到达消费者之前聚合、转换和过滤事件。消费者甚至可以在事件中心级别设置转换和过滤条件：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have already covered the `OBSERVABLE` and `OBSERVER` in [Chapter 1](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=53&action=edit#post_26), *Reactive
    Programming Model – Overview and History* and [Chapter 2](e1c95513-a3a7-40f2-ac25-9f95cbd9a2e6.xhtml),
    *A Tour of Modern C++ and its Key Idioms*. The `EventSource` implements `OBSERVABLE`
    and the event sinks implement the `OBSERVER` interface. A class derived from `OBSERVER`
    will implement the following methods:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第1章](https://cdp.packtpub.com/c___reactive_programming/wp-admin/post.php?post=53&action=edit#post_26)中介绍了`OBSERVABLE`和`OBSERVER`，*响应式编程模型-概述和历史*和[第2章](e1c95513-a3a7-40f2-ac25-9f95cbd9a2e6.xhtml)，*现代C++及其关键习惯的概览*。`EventSource`实现了`OBSERVABLE`，事件接收器实现了`OBSERVER`接口。从`OBSERVER`派生的类将实现以下方法：
- en: '`ondata` (for receiving data)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ondata`（用于接收数据）'
- en: '`onexception` (exception processing)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onexception`（异常处理）'
- en: '`oncompleted` (end of the data)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oncompleted`（数据结束）'
- en: 'The `EventSource` class will be derived from `OBSERVABLE` and has to implement:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventSource`类将从`OBSERVABLE`派生，并且必须实现：'
- en: Subscribe (subscribe to notification)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subscribe（订阅通知）
- en: Unsubscribe (not implemented in our case)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unsubscribe（在我们的情况下未实现）
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`map_func` and `filter_func` are functions that can help us to transform and
    filter the values before they are dispatched to the subscribers in an asynchronous
    manner. We give these values as parameters when we instantiate the `EventSource`
    class. Currently, we have written the code under the assumption that only the
    `Expr` object will be stored in the `EventSource`. We can have a list or vector
    of expressions and Stream the value to the subscribers. For this, implementation
    a scalar value can be pushed to the listeners:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`map_func`和`filter_func`是可以帮助我们在将值异步分派给订阅者之前转换和过滤值的函数。在实例化`EventSource`类时，我们将这些值作为参数给出。目前，我们已经根据假设编写了代码，即只有`Expr`对象将存储在`EventSource`中。我们可以有一个表达式的列表或向量，并将值流式传输给订阅者。为此，实现可以将标量值推送到监听器：'
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We have made some assumptions that the `Expr` objects will be owned by the
    caller. We have also omitted the implementation of the unsubscribe method. The
    constructor takes an `Expr` object, a `Filter` predicate (it can be a composite
    function using the | operator), and a `Mapping` function (it can be a composite
    function using the `|` operator):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做出了一些假设，即`Expr`对象将由调用者拥有。我们还省略了取消订阅方法的实现。构造函数接受一个`Expr`对象，一个`Filter`谓词（可以是使用|运算符的复合函数），以及一个`Mapping`函数（可以是使用`|`运算符的复合函数）：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After evaluating the expression, the scalar value will be put into an STL list.
    Then, the Map function will be applied on the list to transform the value. In
    future, we will handle a list of values. Once we have mapped or transformed the
    values, we will apply a filter to the list. If there is no value in the list,
    the method returns without notifying the subscribers:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估表达式后，标量值将放入STL列表中。然后，将在列表上应用Map函数以转换值。将来，我们将处理一系列值。一旦我们映射或转换了值，我们将对列表应用过滤器。如果列表中没有值，则方法将返回而不通知订阅者：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this code, we will call `packaged_task` to dispatch the data to the event
    sinks. Industrial-strength libraries use a piece of code called Scheduler to do
    this part of the task. Since we are using fire and forget, the sinks will not
    be able to block the `EventSource`. This is one of the most important use cases
    of Observables:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们将调用`packaged_task`将数据分派到事件接收器。工业级库使用称为调度器的代码片段来执行此任务的一部分。由于我们使用的是fire
    and forget，接收器将无法阻止`EventSource`。这是Observables的最重要用例之一：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s write a method to emit random expressions based on the modern C++
    random number generator with a uniform probability distribution. The choice of
    this distribution is rather arbitrary. We can try other distributions as well
    to see different results:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个方法，根据现代C++随机数生成器发出随机表达式，具有均匀概率分布。选择这种分布是相当任意的。我们也可以尝试其他分布，以查看不同的结果：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s write a main function to put everything together. We will instantiate
    the `EventSourceValueSubject` class with an `Expr`, a `Filter`, and a `Mapper`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个主函数将所有内容组合在一起。我们将使用`Expr`、`Filter`和`Mapper`实例化`EventSourceValueSubject`类：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'While instantiating the object, we have used the pipe operator to compose two
    Lambdas. This is to demonstrate that we can compose an arbitrary list of functions
    to form a composite function. When we write RxCpp programs, we will exploit this
    technique a lot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化对象时，我们使用管道运算符来组合两个Lambda。这是为了演示我们可以组合任意数量的函数以形成复合函数。当我们编写RxCpp程序时，我们将大量利用这种技术。
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this code, we have instantiated two `OBSERVER` objects and assigned them
    to the ondata member using Lambda functions . We have not implemented other methods.
    This is for demonstration purposes only:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们实例化了两个“OBSERVER”对象，并使用Lambda函数将它们分配给ondata成员。我们没有实现其他方法。这仅用于演示目的：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We subscribed to event notification using the `OBSERVER` instances. We have
    only implemented the ondata method. Implementing `onexception` and `oncompleted`
    are trivial tasks:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们订阅了使用“OBSERVER”实例的事件通知。我们只实现了ondata方法。实现“onexception”和“oncompleted”是微不足道的任务：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We evaluated a series of random expressions by setting the expression to the
    `EventSource` object. After transformation and filtering, if there is a value
    left, the value will be notified to the `OBSERVER` and it will printed to the
    console. With this, we have managed to write a non-blocking `EventSource` using
    `packaged_taks`. We have demonstrated the following in this chapter:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将表达式设置为“EventSource”对象来评估一系列随机表达式。经过转换和过滤，如果还有值剩下，该值将通知给“OBSERVER”，并打印到控制台。通过这种方式，我们成功地使用“packaged_taks”编写了一个非阻塞的“EventSource”。在本章中，我们演示了以下内容：
- en: Modeling an expression tree using a Composite
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复合对表达树进行建模
- en: Processing a Composite through the Visitor interface
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Visitor接口处理复合
- en: Flattening the expression tree into a list and processing it through Iterators
    (pull)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将表达树展平为列表，并通过迭代器进行处理（拉）
- en: Reversing the gaze from `EventSource` to the event sink (push)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从“EventSource”到事件接收端（推送）的凝视反转
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have covered a lot of ground in this chapter, inching towards the reactive
    programming model. We learned about the GoF Observer pattern and understood its
    shortcomings. Then, we digressed into philosophy to understand the method of looking
    at the world from a structural, behavioral, and functional perspective. We learned
    about the GoF Composite/Visitor pattern in the context of modeling an expression
    tree. We learned how to flatten the hierarchy into a list and navigate them through
    the Iterator. Finally, we transformed the scheme of things a bit to reach Observables.
    Normally, Observables work with Streams, but in our case it was a scalar value.
    In the next chapter, we will learn about event Stream processing to complete our
    prerequisites for learning reactive programming.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容，朝着响应式编程模型迈进。我们了解了GoF Observer模式并理解了它的缺点。然后，我们偏离了哲学，以了解从结构、行为和功能的角度看世界的方法。我们在表达树建模的背景下学习了GoF
    Composite/Visitor模式。我们学会了如何将层次结构展平为列表，并通过迭代器对其进行导航。最后，我们稍微改变了事物的方案，以达到Observables。通常，Observables与Streams一起工作，但在我们的情况下，它是一个标量值。在下一章中，我们将学习有关事件流处理，以完成学习响应式编程的先决条件。
