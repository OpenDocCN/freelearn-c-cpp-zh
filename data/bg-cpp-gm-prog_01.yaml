- en: Chapter 1. C++, SFML, Visual Studio, and Starting the First Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。C++，SFML，Visual Studio和开始第一个游戏
- en: Welcome to Beginning C++ Game Programming. I will waste no time in getting you
    started on your journey to writing great games for the PC, using C++ and **OpenGL**-**powered
    SFML**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到《开始C++游戏编程》。我将立即让你开始你的写作之旅，使用C++和**OpenGL**-**powered SFML**为PC编写出色的游戏。
- en: 'This is quite a hefty first chapter, but we will learn absolutely everything
    we need to, in order to have the first part of our first game up-and-running.
    Here is what we will cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当庞大的第一章，但我们将学到我们需要的一切，以便让我们第一个游戏的第一部分运行起来。在本章中，我们将涵盖以下内容：
- en: Find out about the games we will build
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解我们将构建的游戏
- en: Learn a bit about C++
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一些关于C++的知识
- en: Explore SFML and its relationship with C++
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索SFML及其与C++的关系
- en: Look at the Visual Studio software, which we will use throughout the book
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看我们将在整本书中使用的Visual Studio软件
- en: Set up a game development environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置游戏开发环境
- en: Create a reusable project template, which will save a lot of time
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可重用的项目模板，这将节省大量时间
- en: Plan and prepare for the first game project, Timber!!!
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划并准备第一个游戏项目，伐木者！！！
- en: Write the first C++ code of the book and make a runnable game that draws a background
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写本书的第一个C++代码，并制作一个可运行的游戏来绘制背景
- en: The games
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏
- en: We will learn the fundamentals of the super-fast C++ language, a step at a time,
    and then put the new knowledge to use, so it should be fairly easy to add cool
    features to the three games we are building.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步学习超快的C++语言的基础知识，然后将新知识应用到实践中，因此应该相当容易地为我们正在构建的三款游戏添加酷炫的功能。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you get stuck with any of the content in this chapter, take a look at the
    sections near the end Handling errors and FAQs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在本章的任何内容上遇到困难，请查看最后的处理错误和常见问题解答部分。
- en: 'These are our three projects for the book:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们书中的三个项目：
- en: Timber!!!
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伐木者！！！
- en: The first game is an addictive, fast-paced clone of the hugely successful Timberman,
    which can be found at [http://store.steampowered.com/app/398710/](http://store.steampowered.com/app/398710/).
    Our game, Timber!!!, will introduce us to all the C++ basics at the same time
    as building a genuinely playable game. Here is what our version of the game will
    look like when we are done and we have added a few last-minute enhancements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个游戏是一款令人上瘾、节奏快速的《伐木工》的克隆版本，该游戏可以在[http://store.steampowered.com/app/398710/](http://store.steampowered.com/app/398710/)找到。我们的游戏《伐木者！！！》将在构建一个真正可玩的游戏的同时，向我们介绍所有C++的基础知识。当我们完成并添加了一些最后一刻的增强功能时，我们的游戏版本将是这个样子。
- en: '![Timber!!!](img/image_01_001.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![伐木者！！！](img/image_01_001.jpg)'
- en: Zombie Arena
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 僵尸竞技场
- en: Next, we will build a frantic, zombie survival shooter, not unlike the Steam
    hit, Over 9000 Zombies, which can be found at [http://store.steampowered.com/app/273500/](http://store.steampowered.com/app/273500/).
    The player will have a machine gun, and must fight off ever-growing waves of zombies.
    All this will take place in a randomly generated, scrolling world. To achieve
    this we will learn about object-oriented programming and how it enables us to
    have a large code base (lots of code) that is easy to write and maintain. Expect
    exciting features such as hundreds of enemies, rapid-fire weaponry, pick-ups,
    and a character that can be "leveled-up" after each wave.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一个疯狂的僵尸生存射击游戏，类似于Steam的热门游戏《超过9000只僵尸》，该游戏可以在[http://store.steampowered.com/app/273500/](http://store.steampowered.com/app/273500/)找到。玩家将拥有一把机关枪，并必须抵御不断增长的僵尸浪潮。所有这些将发生在一个随机生成的滚动世界中。为了实现这一点，我们将学习面向对象编程以及它如何使我们能够拥有一个庞大的代码库（大量代码），易于编写和维护。期待令人兴奋的功能，如数百个敌人、快速射击武器、拾取物品以及每一波后都可以“升级”的角色。
- en: '![Zombie Arena](img/image_01_002.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![僵尸竞技场](img/image_01_002.jpg)'
- en: Thomas was Late
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 托马斯迟到了
- en: The third game will be a stylish and challenging puzzle platformer, which can
    be played as a single player and coop. It is based on the very popular game, Thomas
    was Alone, which can be found at [http://store.steampowered.com/app/220780/](http://store.steampowered.com/app/220780/).
    Expect to learn about cool topics such as particle effects, OpenGL Shaders, and
    split-screen cooperative multiplayer features.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第三款游戏将是一款时尚而具有挑战性的益智平台游戏，可以作为单人和合作游玩。它基于非常受欢迎的游戏《托马斯是孤独的》，该游戏可以在[http://store.steampowered.com/app/220780/](http://store.steampowered.com/app/220780/)找到。期待学习有关粒子效果、OpenGL着色器和分屏合作多人游戏等酷炫主题。
- en: '![Thomas was Late](img/image_01_003.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![托马斯迟到了](img/image_01_003.jpg)'
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want to play any of the games now, you can do so from the download bundle
    in the `Runnable Games` folder. Just double-click on the appropriate `.exe` file.
    Notice that in this folder you can either run the completed games or any game
    in its partially completed state from any chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在想玩任何游戏，可以在`Runnable Games`文件夹中的下载包中进行。只需双击相应的`.exe`文件。请注意，在这个文件夹中，你可以运行已完成的游戏，也可以从任何章节的部分完成状态中运行任何游戏。
- en: Let's get started by introducing C++, Visual Studio, and SFML!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始介绍C++、Visual Studio和SFML！
- en: Meet C++
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解C++
- en: One question you might have is, why use C++ at all? C++ is fast, very fast.
    What makes this the case is the fact that the code that we write is directly translated
    into machine executable instructions. These instructions make the game. The executable
    game is contained within an `.exe` file that the player can simply double-click
    to run.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会有一个问题，为什么要使用C++？C++很快，非常快。使其成为这种情况的原因是我们编写的代码直接转换为机器可执行指令。这些指令构成了游戏。可执行游戏包含在一个`.exe`文件中，玩家只需双击即可运行。
- en: There are a few steps in the process. First, the **pre-processor** looks to
    see if any other code needs to be included within our own code and adds it when
    necessary. Next, all the code is compiled into **object files** by the compiler
    program. Finally, a third program, called the **linker**, joins all the object
    files into the executable file, which is our game.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程中有几个步骤。首先，**预处理器**查看我们的代码中是否需要包含其他代码，并在必要时添加它。接下来，编译器程序将所有代码编译成**目标文件**。最后，一个名为**链接器**的第三个程序将所有目标文件连接成可执行文件，这就是我们的游戏。
- en: In addition, C++ is well established at the same time as being extremely up-to-date.
    C++ is an **object oriented programming **( ****OOP**** ) language, which means
    we can write and organize our code in a proven way that makes our games efficient
    and manageable. The benefits, as well as the necessity for this, will reveal themselves
    as we progress through the book.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，C++既是一个成熟的语言，同时又非常现代化。C++是一种面向对象的编程语言，这意味着我们可以以一种经过验证的方式编写和组织我们的代码，使我们的游戏高效且易于管理。这些好处以及这种必要性将随着我们在书中的进展而显现。
- en: Most of the other code to which I referred is SFML, and we will find out more
    about SFML in just a minute. The pre-processor, compiler, and linker programs
    I have just mentioned, are all part of the Visual Studio **Integrated Development
    Environment**(**IDE**).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到的大部分其他代码都是SFML，我们将在接下来的一分钟内了解更多关于SFML的信息。我刚刚提到的预处理器、编译器和链接器程序都是Visual Studio集成开发环境（IDE）的一部分。
- en: Microsoft Visual Studio
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Microsoft Visual Studio
- en: Visual Studio hides away the complexity of the pre-processing, compiling, and
    linking. It wraps it all up into one press of a button. In addition to this, it
    provides a slick user interface for us to type our code and manage what will become
    a large selection of code files, and other project assets as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio隐藏了预处理、编译和链接的复杂性。它将所有这些封装成一个按钮。此外，它为我们提供了一个流畅的用户界面，让我们输入我们的代码并管理将成为大量代码文件和其他项目资产的选择。
- en: While there are advanced versions of Visual Studio that cost hundreds of dollars,
    we will be able to build all three of our games in the free **Express 2015 for
    Desktop** version.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有高级版本的Visual Studio需要花费数百美元，但我们可以在免费的**Express 2015 for Desktop**版本中构建我们的三个游戏。
- en: SFML
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFML
- en: '**Simple Fast Media Library **(**SFML**) is not the only C++ library for games
    and multimedia. It is possible to make an argument for using other libraries,
    but SFML seems to be the best for me, every time. First it is written using object
    oriented C++. The benefits of this are numerous. Most of these benefits you will
    experience as you progress through the book.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**Simple Fast Media Library（SFML）**不是唯一的C++游戏和多媒体库。可能有人会主张使用其他库，但对我来说，SFML似乎是最好的选择。首先，它是使用面向对象的C++编写的。这样做的好处是多方面的。随着你在书中的进展，你将体验到大部分这些好处。'
- en: SFML is so easy to get started and is therefore a good choice if you are a beginner.
    At the same time, it also has the potential to build the highest-quality 2D games
    if you are a professional. So a beginner can get started using SFML and not worry
    about having to start again with a new language/library as their experience grows.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: SFML非常容易上手，因此对于初学者来说是一个很好的选择。同时，如果你是专业人士，它也有潜力构建最高质量的2D游戏。因此，初学者可以开始使用SFML，而不必担心随着经验的增长需要重新开始学习新的语言/库。
- en: Perhaps the biggest benefit is that most modern C++ programming uses OOP. Every
    C++ beginners guide I have ever read uses and teaches OOP. OOP is, in fact, the
    future (and the now) of coding in almost all languages. So why, if you're learning
    C++ from the beginning, would you want to do it any other way?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最大的好处是大多数现代C++编程都使用面向对象编程。我读过的每一本C++初学者指南都使用并教授面向对象编程。事实上，面向对象编程几乎是所有语言中编码的未来（和现在）。因此，如果你从头开始学习C++，为什么要以其他方式学习呢？
- en: SFML has a module (code) for just about anything you would ever want to do in
    a 2D game. SFML works using OpenGL, which can also make 3D games. OpenGL is the
    de-facto free-to-use graphics library for games when you want them to run on more
    than one platform. When you use SFML, you are automatically using OpenGL.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SFML几乎为2D游戏中你可能想做的任何事情提供了模块（代码）。SFML使用OpenGL工作，它也可以制作3D游戏。OpenGL是游戏的事实上免费使用的图形库，当你希望它们在多个平台上运行时。当你使用SFML时，你自动使用OpenGL。
- en: 'SFML drastically simplifies:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: SFML大大简化了：
- en: 2D graphics and animation including scrolling game worlds.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D图形和动画，包括滚动游戏世界。
- en: Sound effects and music playback, including high-quality directional sound.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括高质量的定向声音在内的音效和音乐播放。
- en: Online multiplayer features
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线多人游戏功能
- en: The same code can be compiled and linked on all major desktop operating systems,
    and soon mobile, as well!
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的代码可以在所有主要桌面操作系统上进行编译和链接，很快也可以在移动设备上进行。
- en: Extensive research has not uncovered any more suitable way to build 2D games
    for PC, even for expert developers, and especially if you are a beginner and want
    to learn C++ in a fun gaming environment.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛的研究并没有发现任何更适合的方式来为PC构建2D游戏，即使对于专业开发人员来说也是如此，尤其是如果你是初学者，并且想在有趣的游戏环境中学习C++。
- en: Setting up the development environment
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: Now you know a bit more about how we will be making these games, it is time
    to set up a development environment so we can get coding.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对我们将如何制作这些游戏有了一些了解，是时候设置开发环境，让我们开始编码了。
- en: What about Mac and Linux?
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么Mac和Linux呢？
- en: The games that we make can be built to run on Windows, Mac and Linux! The code
    we use will be identical for each. However, each version does need to be compiled
    and linked on the platform for which it is intended and Visual Studio will not
    be able to help us with Mac and Linux.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制作的游戏可以在Windows、Mac和Linux上运行！我们使用的代码对于每个平台都是相同的。然而，每个版本都需要在其预期的平台上进行编译和链接，而Visual
    Studio将无法帮助我们处理Mac和Linux。
- en: It would be unfair to say that this book is entirely suited for Mac and Linux
    users, especially complete beginners. Although, I guess, if you are an enthusiastic
    Mac or Linux user, and you are comfortable with your operating system, the vast
    majority of the extra challenges you will encounter will be in the initial setup
    of the development environment, SFML, and the first project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 说这本书完全适合Mac和Linux用户，尤其是完全的初学者，可能有些不公平。尽管，我猜，如果你是一个热衷于Mac或Linux的用户，并且对你的操作系统感到舒适，你将遇到的大部分额外挑战将在开发环境、SFML和第一个项目的初始设置中。
- en: To this end, I can highly recommend the following tutorials which will hopefully
    replace the next 10 pages (approximately), up to the section *Planning Timber!!!*,
    when this book should again become relevant to all operating systems.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我强烈推荐以下教程，希望能替代接下来的大约10页（大约），直到*Planning Timber!!!*部分，当这本书应该再次适用于所有操作系统。
- en: 'For Linux, read this for an overview: [http://www.sfml-dev.org/tutorials/2.0/start-linux.php](http://www.sfml-dev.org/tutorials/2.0/start-linux.php)
    [.](http://www.sfml-dev.org/tutorials/2.0/start-linux.php)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux，阅读这篇概述：[http://www.sfml-dev.org/tutorials/2.0/start-linux.php](http://www.sfml-dev.org/tutorials/2.0/start-linux.php)。
- en: 'For Linux, read this for step-by-step guidance: [http://en.sfml-dev.org/forums/index.php?topic=9808.0](http://en.sfml-dev.org/forums/index.php?topic=9808.0)
    [.](http://en.sfml-dev.org/forums/index.php?topic=9808.0)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux，阅读这篇逐步指导：[http://en.sfml-dev.org/forums/index.php?topic=9808.0](http://en.sfml-dev.org/forums/index.php?topic=9808.0)。
- en: 'On Mac, read this tutorial as well as the linked out articles: [http://www.edparrish.net/common/sfml-.osx.html](http://www.edparrish.net/common/sfml-osx.html)
    [.](http://www.edparrish.net/common/sfml-osx.html)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，阅读这篇教程以及链接的文章：[http://www.edparrish.net/common/sfml-.osx.html](http://www.edparrish.net/common/sfml-osx.html)。
- en: Installing Visual Studio Express 2015 on your desktop
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你的桌面上安装Visual Studio Express 2015
- en: Installing Visual Studio can be almost as simple as downloading a file and clicking
    a few buttons. It will help us, however, if we carefully run through exactly how
    we do this. For this reason, I will walk through the installation process a step
    at a time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Visual Studio几乎和下载一个文件并点击几下按钮一样简单。然而，如果我们仔细地按照我们的步骤来做，这将对我们有所帮助。因此，我将一步一步地走过安装过程。
- en: The Microsoft Visual Studio site says that you need 5 GB of hard disk space.
    From experience, however, I would suggest you need at least 10 GB of free space.
    In addition, these figures are slightly ambiguous. If you are planning to install
    it on a secondary hard drive, you will still need at least 5 GB on the primary
    hard drive because no matter where you choose to install Visual Studio, it will
    need this space too.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 微软Visual Studio网站表示你需要5GB的硬盘空间。然而，根据经验，我建议你至少需要10GB的可用空间。此外，这些数字有些模糊。如果你计划将其安装在辅助硬盘上，你仍然需要主硬盘上至少5GB的空间，因为无论你选择在哪里安装Visual
    Studio，它也需要这个空间。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To summarize this ambiguous situation: It is essential to have a full 10 GB
    space on the primary hard disk, if you intend to install Visual Studio to that
    primary hard disk. On the other hand, make sure you have 5 GB on the primary hard
    disk as well as 10 GB on the secondary, if you intend to install to a secondary
    hard disk. Yep, stupid, I know!'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这种模糊的情况：如果你打算将Visual Studio安装到主硬盘上，那么在主硬盘上必须有完整的10GB空间是必不可少的。另一方面，如果你打算安装到辅助硬盘上，确保你的主硬盘上有5GB的空间，辅助硬盘上有10GB的空间。是的，愚蠢，我知道！
- en: 'The first thing you need is a Microsoft account and the login details. If you
    have a Hotmail or MSN email address then you already have one. If not, you can
    sign up for a free one here: [https://login.live.com/](https://login.live.com/).'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要的第一件事是一个微软账户和登录详情。如果你有Hotmail或MSN邮箱地址，那么你已经有了一个。如果没有，你可以在这里免费注册一个：[https://login.live.com/](https://login.live.com/)。
- en: 'Visit this link: [https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx](https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx).
    Click on **Visual Studio 2015**, then **Express 2015 for desktop** then the **Downloads**
    button. The next screenshot shows the three places to click:![Installing Visual
    Studio Express 2015 on your desktop](img/image_01_004.jpg)'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问这个链接：[https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx](https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx)。点击**Visual
    Studio 2015**，然后点击**Express 2015 for desktop**，然后点击**Downloads**按钮。下一个截图显示了三个点击的位置：![Installing
    Visual Studio Express 2015 on your desktop](img/image_01_004.jpg)
- en: Wait for the short download to complete and then run the downloaded file. Now
    you just need to follow the on-screen instructions. However, make a note of the
    folder where you choose to install Visual Studio. If you want to do things exactly
    the same as me, then create a new folder called `Visual Studio 2015` on your preferred
    hard disk and install to this folder. This whole process could take a while depending
    on the speed of your Internet connection.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待短暂的下载完成，然后运行下载的文件。现在你只需要按照屏幕上的指示进行操作。但是，请记下你选择安装Visual Studio的文件夹。如果你想和我做的一样，就在你喜欢的硬盘上创建一个名为“Visual
    Studio 2015”的新文件夹，并安装到这个文件夹中。整个过程可能需要一段时间，取决于你的互联网连接速度。
- en: When you see the next screen, click on **Launch** and enter your Microsoft account
    login details.![Installing Visual Studio Express 2015 on your desktop](img/image_01_005.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你看到下一个屏幕时，点击**Launch**并输入你的微软账户登录详情。![Installing Visual Studio Express 2015
    on your desktop](img/image_01_005.jpg)
- en: Now we can turn to SFML.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以转向SFML。
- en: Setting up SFML
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置SFML
- en: 'This short tutorial will take you through downloading the SFML files that allow
    us to include the functionality contained in the library. In addition, we will
    see how to use the SFML DLL files that will enable our compiled object code to
    run alongside SFML:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的教程将带你下载SFML文件，使我们能够包含库中包含的功能。此外，我们将看到如何使用SFML DLL文件，这将使我们编译的目标代码能够与SFML一起运行。
- en: 'Visit this link on the SFML website: [http://www.sfml-dev.org/download.php](http://www.sfml-dev.org/download.php).
    Click on the button that says **Latest stable version** as shown next.![Setting
    up SFML](img/image_01_006.jpg)'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问SFML网站上的这个链接：[http://www.sfml-dev.org/download.php](http://www.sfml-dev.org/download.php)。点击下一个显示的**Latest
    stable version**按钮。![Setting up SFML](img/image_01_006.jpg)
- en: By the time you read this guide, the latest version will almost certainly have
    changed. That doesn't matter as long as you do the next step correctly. We want
    to download the 32-bit version for **Visual C++ 2014**. This might sound counter-intuitive
    because we have just installed Visual Studio 2015 and you probably (most commonly)
    have a 64-bit PC. The reason we choose this download is because Visual C++ 2014
    is part of Visual Studio 2015 (Visual Studio offers more than just C++) and we
    will be building games in 32-bit so that they run on both 32- and 64- bit machines.
    To be clear, click the following download:![Setting up SFML](img/image_01_007.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您阅读本指南时，最新版本几乎肯定已经更改。只要您正确执行下一步，这并不重要。我们要下载**Visual C++ 2014**的32位版本。这可能听起来有些违反直觉，因为我们刚刚安装了Visual
    Studio 2015，您可能（最常见）有一台64位PC。我们选择此下载的原因是因为Visual C++ 2014是Visual Studio 2015的一部分（Visual
    Studio提供的不仅仅是C++），我们将以32位构建游戏，以便它们在32位和64位机器上运行。为了明确起见，单击以下下载：![设置SFML](img/image_01_007.jpg)
- en: When the download completes, create a folder at the root of the same drive where
    you installed Visual Studio and name it `SFML`. Also create another folder at
    the root of the drive where you installed Visual Studio and call it `Visual Studio
    Stuff`. We will store all kinds of Visual Studio-related things here so `Visual
    Studio Stuff` seems like a good name. Just to be clear, here is what my hard drive
    looks like after this step:![Setting up SFML](img/image_01_008.jpg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，在安装Visual Studio的相同驱动器的根目录创建一个名为`SFML`的文件夹。还在安装Visual Studio的相同驱动器的根目录创建另一个文件夹，并将其命名为`Visual
    Studio Stuff`。我们将在这里存储各种与Visual Studio相关的东西，因此`Visual Studio Stuff`似乎是一个不错的名字。为了明确起见，这是在完成此步骤后我的硬盘的样子：![设置SFML](img/image_01_008.jpg)
- en: Obviously, the folders you have in between the highlighted three folders in
    the screenshot will probably be totally different to mine. Now we are ready for
    all the projects we will soon be making, create a new folder inside `Visual Studio
    Stuff`. Name the new folder `Projects`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显然，您在截图中突出显示的三个文件夹之间的文件夹可能与我的完全不同。现在我们准备好了即将创建的所有项目，创建一个新文件夹在`Visual Studio
    Stuff`内。将新文件夹命名为`Projects`。
- en: Finally, unzip the SFML download. Do this on your desktop. When unzipping is
    complete you can delete the `zip` folder. You will be left with a single folder
    on your desktop. Its name will reflect the version of SFML that you downloaded.
    Mine is called `SFML-2.3.2-windows-vc14-32-bit`. Your file name will likely reflect
    a more recent version. Double-click this folder to see the contents, then double-click
    again into the next folder (mine is called `SFML-2.3.2`). The following screenshot
    shows what my `SFML-2.3.2` folder's contents looks like, when the entire contents
    have been selected. Yours should look the same.![Setting up SFML](img/image_01_009.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，解压SFML下载。在桌面上进行此操作。解压完成后，可以删除`zip`文件夹。您将在桌面上留下一个单独的文件夹。其名称将反映您下载的SFML版本。我的称为`SFML-2.3.2-windows-vc14-32-bit`。您的文件名可能反映了一个更新的版本。双击此文件夹以查看内容，然后再次双击进入下一个文件夹（我的称为`SFML-2.3.2`）。以下截图显示了当选择了整个内容时，我的`SFML-2.3.2`文件夹的内容是什么样子的。您的应该看起来一样。![设置SFML](img/image_01_009.jpg)
- en: Copy the entire contents of this folder, as seen in the previous screenshot,
    and paste/drag all the contents into the `SFML` folder you created in Step 3\.
    For the rest of the book I will refer to this folder simply as your SFML folder.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制前面截图中所见的整个文件夹的内容，并将所有内容粘贴/拖放到第3步中创建的`SFML`文件夹中。在本书的其余部分，我将简称此文件夹为您的SFML文件夹。
- en: Now we are ready to start using C++ and SFML in Visual Studio.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备在Visual Studio中开始使用C++和SFML。
- en: Creating a reusable project template
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建可重用的项目模板
- en: 'As setting up a project is a fairly fiddly process, we will create a project
    and then save it as a Visual Studio template. This will save us quite a significant
    amount of work each time we start a new game. So, if you find the next tutorial
    a little tedious, rest assured that you will never need to do this again:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设置项目是一个相当繁琐的过程，我们将创建一个项目，然后将其保存为Visual Studio模板。这将节省我们每次开始新游戏时相当大量的工作。因此，如果您发现下一个教程有点乏味，请放心，您将永远不需要再次这样做：
- en: Start Visual Studio and, in the **New Project** window, click the little drop-down
    arrow next to **Visual C++** to reveal more options, then click **Win32,** and
    click **Win32 Console Application**. You can see all these selections in the next
    screenshot.![Creating a reusable project template](img/image_01_010.jpg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio，在**新项目**窗口中，单击**Visual C++**旁边的小下拉箭头以显示更多选项，然后单击**Win32**，再单击**Win32控制台应用程序**。您可以在下一个截图中看到所有这些选择。![创建可重用的项目模板](img/image_01_010.jpg)
- en: Now, at the bottom of the **New Project** window, type `HelloSFML` in the **Name:**
    field.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**新项目**窗口的底部，在**名称：**字段中键入`HelloSFML`。
- en: Next, browse to the `Visual Studio Stuff\Projects\` folder that we created in
    the previous tutorial. This will be the location where all our project files will
    be kept. All templates are based on an actual project. So, we will have a project
    called `HelloSFML` but the only thing we will do with it is make a template from
    it.![Creating a reusable project template](img/image_01_011.jpg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，浏览到我们在上一篇教程中创建的`Visual Studio Stuff\Projects\`文件夹。这将是我们保存所有项目文件的位置。所有模板都是基于实际项目的。因此，我们将有一个名为`HelloSFML`的项目，但我们将做的唯一事情就是从中制作一个模板。![创建可重用的项目模板](img/image_01_011.jpg)
- en: When you have completed the steps above, click **OK**. The next screenshot shows
    the **Application Settings** window. Check the box for **Console application**,
    and leave the other options as shown below.![Creating a reusable project template](img/image_01_012.jpg)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成上述步骤后，单击**确定**。下一个截图显示了**应用程序设置**窗口。选中**控制台应用程序**的复选框，并将其他选项保持如下所示。![创建可重用的项目模板](img/image_01_012.jpg)
- en: Click **Finish** and Visual Studio will create the new project.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**完成**，Visual Studio将创建新项目。
- en: Next, we will add some fairly intricate and important project settings. This
    is the laborious part but, as we will create a template, we will only need to
    do this once. What we need to do is tell Visual Studio, or more specifically the
    code compiler that is part of Visual Studio, where to find a special type of code
    file from SFML. The special type of file I am referring to is a header file. Header
    files are the files that define the format of the SFML code. So when we use the
    SFML code, the compiler knows how to handle it. Note that the header files are
    distinct from the main source code files and they are contained in files with
    the `.hpp` file extension. (All this will become clearer when we eventually start
    adding our own header files in the second project). In addition, we need to tell
    Visual Studio where it can find the SFML library files. From the Visual Studio
    main menu select **Project | HelloSFML properties**.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些相当复杂和重要的项目设置。这是费力的部分，但由于我们将创建一个模板，我们只需要做一次。我们需要告诉Visual Studio，或者更具体地说，Visual
    Studio的代码编译器，从哪里找到SFML的特殊类型的代码文件。我所指的特殊类型的文件是头文件。头文件定义了SFML代码的格式。因此，当我们使用SFML代码时，编译器知道如何处理它。请注意，头文件与主源代码文件不同，并且它们包含在扩展名为`.hpp`的文件中。（当我们最终开始在第二个项目中添加自己的头文件时，所有这些将变得更清晰）。此外，我们需要告诉Visual
    Studio它在哪里可以找到SFML库文件。从Visual Studio的主菜单中选择**项目 | HelloSFML属性**。
- en: In the resulting **HelloSFML Property Pages** window, perform the following
    steps, flagged in the next screenshot.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生成的**HelloSFML属性页**窗口中，执行下一截图中标记的步骤。
- en: Select **All Configurations** from the **Configuration:** drop-down.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**配置：**下拉菜单中选择**所有配置**。
- en: Select **C/C++** then **General** from the left-hand menu.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左侧菜单中选择**C/C++**，然后选择**常规**。
- en: 'Locate the **Additional Include Directories** edit box and type the drive letter
    where your SFML folder is located, followed by `\SFML\include`. The full path
    to type, if you located your `SFML` folder on your D drive, is as shown in the
    screenshot: `D:\SFML\include`. Vary your path if you installed SFML to a different
    drive.![Creating a reusable project template](img/image_01_013.jpg)'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位**附加包含目录**编辑框，并输入您的SFML文件夹所在的驱动器号，然后加上`\SFML\include`。如果您的`SFML`文件夹位于D驱动器上，则要输入的完整路径如截图所示：`D:\SFML\include`。如果您将SFML安装到其他驱动器上，则需要更改路径。![创建可重用的项目模板](img/image_01_013.jpg)
- en: Click **Apply** to save your configurations so far.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**以保存到目前为止的配置。
- en: Now, still in the same window, perform these next steps, again flagged in the
    next screenshot. Select **Linker** then **General**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在同一窗口中，执行下一截图中标记的步骤。选择**链接器**，然后选择**常规**。
- en: Find the **Additional Library Directories** edit box and type the drive letter
    where your `SFML` folder is, followed by `\SFML\lib`. So the full path to type
    if you located your `SFML` folder on your D drive is, as shown in the screenshot,
    `D:\SFML\lib`. Vary your path if you installed SFML to a different drive.![Creating
    a reusable project template](img/image_01_014.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到**附加库目录**编辑框，并输入您的`SFML`文件夹所在的驱动器号，然后加上`\SFML\lib`。因此，如果您的`SFML`文件夹位于D驱动器上，则要输入的完整路径如截图所示：`D:\SFML\lib`。如果您将SFML安装到其他驱动器上，则需要更改路径。![创建可重用的项目模板](img/image_01_014.jpg)
- en: Click **Apply** to save your configurations so far.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**以保存到目前为止的配置。
- en: Finally for this stage, still in the same window, perform these steps, which
    again refer to the next screenshot. Switch the **Configuration:** drop-down(1)
    to **Debug** as we will be running and testing our games in Debug mode.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在同一窗口中，执行下一截图中标记的步骤。将**配置：**下拉菜单（1）切换到**调试**，因为我们将在调试模式下运行和测试游戏。
- en: Select **Linker** then **Input** (2).
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**链接器**，然后选择**输入**（2）。
- en: 'Find the **Additional Dependencies** edit box (3) and click into it on the
    far left-hand side. Now copy and paste/type the following: `sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;`
    at the indicated place. Again, be really careful to place the cursor precisely,
    and dont overwrite any of the text that is already there.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到**附加依赖项**编辑框（3），并在最左侧点击进入。现在复制并粘贴/输入以下内容：`sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;`。再次要非常小心地将光标放置在正确的位置，并且不要覆盖已经存在的任何文本。
- en: Click **OK**.![Creating a reusable project template](img/image_01_015.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**。![创建可重用的项目模板](img/image_01_015.jpg)
- en: Let's make a template from our `HelloSFML` project so we never have to do this
    slightly mind-numbing task again. Creating a reusable project template is really
    easy. In Visual Studio select **File | Export Template...**. Then, in the **Export
    Template Wizard** window, make sure the **Project template** option is selected,
    and then select **HelloSFML** project for the **From which project do you want
    to create a template** option.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`HelloSFML`项目中创建一个模板，这样我们就永远不必再做这个略显乏味的任务了。创建可重用的项目模板非常简单。在Visual Studio中选择**文件
    | 导出模板...**。然后，在**导出模板向导**窗口中，确保选择了**项目模板**选项，然后选择**HelloSFML**项目作为**要创建模板的项目**选项。
- en: Click **Next** and then **Finish**.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**，然后点击**完成**。
- en: Phew, that's it! Next time we create a project, I'll show you how to do it from
    this template. Now let's build Timber!!!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，就是这样！下次我们创建项目时，我会告诉您如何从这个模板中创建。现在让我们构建Timber！！！
- en: Planning Timber!!!
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划Timber！！！
- en: Whenever you make a game it is always best to start with a pencil and paper.
    If you don't know exactly how your game is going to work on the screen, how can
    you possibly make it work in code?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每当制作游戏时，最好都要先用铅笔和纸开始。如果您不确定游戏在屏幕上的工作方式，又怎么可能在代码中使其正常工作呢？
- en: Tip
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: At this point, if you haven't already, I suggest you go and watch a video of
    Timberman in action, so you can see what we are aiming for. If you feel your budget
    can stretch to it, then grab a copy and give it a play. It is often on sale for
    under a dollar on Steam. [http://store.steampowered.com/app/398710/](http://store.steampowered.com/app/398710/)
    [.](http://store.steampowered.com/app/398710/)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果你还没有这样做，我建议你去观看一段Timberman的游戏视频，这样你就可以看到我们的目标是什么。如果你的预算允许，那就买一份来玩玩。在Steam上通常会以不到一美元的价格出售。[http://store.steampowered.com/app/398710/](http://store.steampowered.com/app/398710/)
    [.](http://store.steampowered.com/app/398710/)
- en: 'The features and objects of a game, which define the gameplay, are known as
    the **mechanics**. The basic mechanics of the game are:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的特性和物体，定义了游戏玩法，被称为**机制**。游戏的基本机制是：
- en: Time is always running out.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间总是在流逝。
- en: Get more time by chopping the tree.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过砍树来获得更多时间。
- en: Chopping the tree causes the branches to fall.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 砍树会导致树枝掉落。
- en: The player must avoid the falling branches.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家必须避开掉落的树枝。
- en: Repeat until the time runs out or the player is squished.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复直到时间用完或玩家被压扁。
- en: Expecting you to plan the C++ code at this stage is obviously a bit silly. This
    is, of course, the first chapter of a C++ beginner's guide. We can, however, take
    a look at all the assets we will use and an overview of what we will need to make
    our C++ do what we want it to.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段期望你计划C++代码显然有点傻。当然，这是C++初学者指南的第一章。然而，我们可以看一下我们将使用的所有资源以及我们需要让我们的C++做我们想要的事情的概述。
- en: 'Take a look at a annotated screenshot of the game:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下游戏的注释截图：
- en: '![Planning Timber!!!](img/image_01_016.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![规划Timber!!!](img/image_01_016.jpg)'
- en: 'You can see that we have the following features:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们有以下特性：
- en: '**Player''s current score:** Each time the player chops a log he will get one
    point. He can chop a log with either the left or the right arrow.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家当前得分：**每次玩家砍一根木头，他就会得到一个点。他可以用左箭头或右箭头砍木头。'
- en: '**Player Character:** Each time the player chops, he will move/stay on the
    same side of the tree. Therefore the player must be careful which side he chooses
    to chop on. When the player chops, a simple ax graphic will appear in the player
    character''s hands.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家角色：**每次玩家砍的时候，他会移动/停留在树的同一侧。因此，玩家必须小心选择砍树的哪一侧。当玩家砍的时候，一个简单的斧头图形会出现在玩家角色的手中。'
- en: '**Shrinking time-bar:** Each time the player chops, a small amount of time
    will be added to the ever-shrinking time bar.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩小的时间条：**每次玩家砍的时候，一小段时间将被添加到不断缩小的时间条上。'
- en: '**Lethal branches:** The faster the player chops, the more time he will get,
    but also the faster the branches will move down the tree, and therefore the more
    likely he is to get squished. The branches spawn randomly at the top of the tree
    and move down with each chop.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**致命的树枝：**玩家砍得越快，他得到的时间就越多，但树枝也会更快地从树上掉下来，因此他被压扁的可能性就越大。树枝在树顶随机生成，并且每次砍树都会向下移动。'
- en: When the player gets squished, which he will quite regularly, a gravestone graphic
    will appear.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家被压扁时，他会经常被压扁，一个墓碑图形会出现。
- en: '****Chopped log**:** When the player chops, a chopped log graphic will whiz
    off away from the player.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**被砍的木头：**当玩家砍的时候，一个被砍的木头图形会从玩家身边飞走。'
- en: There are three floating clouds that will drift at random heights and speeds
    as well as a bee that does nothing but fly around.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有三朵漂浮的云，它们会以随机的高度和速度飘动，还有一只蜜蜂，除了四处飞来飞去什么也不做。
- en: All this takes place on a pretty background.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有这些都发生在一个漂亮的背景上。
- en: So, in nutshell the player must frantically chop to gain points and avoid running
    out of time. As a slightly perverse but fun consequence, the faster he chops,
    the more likely his squishy demise.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简而言之，玩家必须疯狂地砍树来获得积分，并避免时间用尽。作为一个略微扭曲但有趣的结果，他砍得越快，他被压扁的可能性就越大。
- en: We now know what the game looks like, how it is played, and the motivation behind
    the game mechanics. We can go ahead and start to build it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道游戏的外观，玩法以及游戏机制背后的动机。我们可以继续开始构建它。
- en: Creating a project from the template
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从模板创建项目
- en: 'Creating a new project is now extremely easy. Just follow these straightforward
    steps in Visual Studio:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个新项目非常容易。只需在Visual Studio中按照这些简单的步骤操作：
- en: Select **File** | **New Project** from the main menu.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单中选择**文件** | **新项目**。
- en: Make sure that **Visual C++** is selected in the left-hand menu and then select
    **HelloSFML** from the list of presented options. This next screenshot should
    make this clear.![Creating a project from the template](img/image_01_017.jpg)
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在左侧菜单中选择**Visual C++**，然后从所呈现的选项列表中选择**HelloSFML**。下一个截图应该能清楚地说明这一点。![从模板创建项目](img/image_01_017.jpg)
- en: In the **Name:** field, type `Timber` and also make sure that the **Create directory
    for solution** option is checked. Now click **OK**.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**名称：**字段中键入`Timber`，并确保选中**为解决方案创建目录**选项。现在点击**确定**。
- en: Now we need to copy the SFML `.dll` files into the main project directory. My
    main project directory is `D:\Visual Studio Stuff\Projects\Timber\Timber`. It
    was created by Visual Studio in the previous step. If you put your `Projects`
    folder somewhere else, then perform this step there instead. The files we need
    to copy into the project folder are located in your `SFML\bin` folder. Open a
    window for each of the two locations and highlight the required files as shown
    in the next screenshot on the left.![Creating a project from the template](img/image_01_018.jpg)
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将SFML的`.dll`文件复制到主项目目录中。我的主项目目录是`D:\Visual Studio Stuff\Projects\Timber\Timber`。它是在上一步中由Visual
    Studio创建的。如果你把你的`Projects`文件夹放在其他地方，那么就在那里执行这一步。我们需要复制到项目文件夹中的文件位于你的`SFML\bin`文件夹中。打开两个位置的窗口，并按照左侧下一个截图中显示的要求文件进行突出显示。![从模板创建项目](img/image_01_018.jpg)
- en: Now copy and paste the highlighted files into the project folder on the right
    of the previous screenshot.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将突出显示的文件复制并粘贴到上一张截图右侧的项目文件夹中。
- en: The project is now set up and ready to go. You will be able to see the screen
    shown in this next screenshot. I have annotated the screenshot so you can start
    to familiarize yourself with Visual Studio. We will revisit all these areas, and
    others, soon.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 项目现在已经设置好，准备就绪。您将能够在下一个截图中看到屏幕。我已经对截图进行了注释，这样您就可以开始熟悉Visual Studio了。我们很快会重新访问所有这些区域以及其他区域。
- en: '![Creating a project from the template](img/image_01_019.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![从模板创建项目](img/image_01_019.jpg)'
- en: Your layout might look slightly different from the screenshot because the windows
    of Visual Studio, like most applications, are customizable. Take the time to locate
    the **Solution Explorer** window on the right and adjust it to make its contents
    nice and clear, such as they are in the previous screenshot.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您的布局可能与截图略有不同，因为Visual Studio的窗口，像大多数应用程序一样，是可定制的。花些时间找到右侧的**Solution Explorer**窗口，并调整它使其内容清晰明了，就像前面的截图一样。
- en: We will be back here really soon to start coding.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会回到这里开始编码。
- en: Project assets
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目资产
- en: 'Assets are anything you need to make your game. In our case the assets include:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 资产是制作游戏所需的任何东西。在我们的情况下，资产包括：
- en: A font for the writing on the screen
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕上的书写字体
- en: Sound effects for different actions such as chopping, dying, and running out
    of time
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同动作的音效，如砍伐、死亡和时间耗尽
- en: Graphics for the character, background, branches, and other game objects
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色、背景、树枝和其他游戏对象的图形
- en: All the graphics and sound required for the game are included in the download
    bundle. They can be found in the `Chapter 1/graphics` and `Chapter 1/sound` folders
    as appropriate.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏所需的所有图形和声音都包含在下载包中。它们可以在相应的`Chapter 1/graphics`和`Chapter 1/sound`文件夹中找到。
- en: The font that is required has not been supplied. This is because I wanted to
    avoid any possible ambiguity regarding licensing. This will not cause a problem
    though, as I will show you exactly where and how to choose and download fonts
    for yourself.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的字体尚未提供。这是因为我想避免任何可能的许可歧义。不过这不会造成问题，因为我将向您展示确切的位置和方式来选择和下载字体。
- en: Although I will provide either the assets themselves or information on where
    to get them, you might like to create and acquire them for yourself.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我将提供资产本身或获取它们的信息，但您可能希望自己创建和获取它们。
- en: Outsourcing assets
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外包资产
- en: There are a number of websites that allow you to contract artists, sound engineers,
    and even programmers. One of the biggest is the [www.upwork.com](http://www.upwork.com).
    You can join this site for free and post your jobs. You need to write a clear
    explanation of your requirements as well as state how much you are prepared to
    pay. Then you will probably get a good selection of contractors bidding to do
    the work. Be aware, there is a lot of unqualified contractors whose work might
    be disappointing, but if you choose carefully you will likely find a competent,
    enthusiastic, and great value person or company to do the job.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多网站可以让您与艺术家、声音工程师甚至程序员签约。其中最大的之一是[www.upwork.com](http://www.upwork.com)。您可以免费加入该网站并发布您的工作。您需要清晰地解释您的要求，以及说明您愿意支付多少。然后您可能会得到许多承包商竞标做这项工作。请注意，有很多不合格的承包商，他们的工作可能令人失望，但如果您选择得当，您可能会找到一个称职、热情和物有所值的人或公司来完成工作。
- en: Making your own sound FX
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制作自己的音效
- en: Sound effects can be downloaded for free from sites like [www.freesound.org](http://www.freesound.org)
    but often the license won't allow you to use them if you are selling your game.
    Another option is to use an open source software called BFXR from [www.bfxr.net](http://www.bfxr.net),
    which can help you generate lots of different sound effects that are yours to
    keep and do as you like with.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从网站（如[www.freesound.org](http://www.freesound.org)）免费下载音效，但通常许可证不允许您在出售游戏时使用它们。另一个选择是使用名为BFXR的开源软件，该软件可以帮助您生成许多不同的音效，这些音效是您自己保留并随意使用的。
- en: Adding assets to the project
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将资产添加到项目
- en: Once you have decided which assets you will use, it is time to add them to the
    project. These next instructions will assume you are using all the assets supplied
    in the book's download bundle. Where you are using your own, simply replace the
    appropriate sound or graphic file with your own, using exactly the same file name.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定要使用哪些资产，就该是将它们添加到项目的时候了。下面的说明将假定您正在使用书籍下载包中提供的所有资产。如果您使用自己的资产，只需用您自己的相应音效或图形文件替换，文件名完全相同即可。
- en: Browse to the Visual `D:\Visual Studio Stuff\Projects\Timber\Timber`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到Visual `D:\Visual Studio Stuff\Projects\Timber\Timber`。
- en: Create three new folders within this folder and name them as `graphics`, `sound`,
    and `fonts`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中创建三个新文件夹，并将它们命名为`graphics`、`sound`和`fonts`。
- en: From the download bundle, copy the entire contents of `Chapter 1/graphics` into
    the `D:\Visual Studio Stuff\Projects\Timber\Timber\graphics` folder.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将`Chapter 1/graphics`的整个内容复制到`D:\Visual Studio Stuff\Projects\Timber\Timber\graphics`文件夹中。
- en: From the download bundle, copy the entire contents of `Chapter 1/sound` into
    the `D:\Visual Studio Stuff\Projects\Timber\Timber\sound` folder.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将`Chapter 1/sound`的整个内容复制到`D:\Visual Studio Stuff\Projects\Timber\Timber\sound`文件夹中。
- en: 'Now visit: [http://www.1001freefonts.com/komika_poster.font](http://www.1001freefonts.com/komika_poster.font)
    in your web browser and download the **Komika Poster** font.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在访问：[http://www.1001freefonts.com/komika_poster.font](http://www.1001freefonts.com/komika_poster.font)
    在您的网络浏览器中下载**Komika Poster**字体。
- en: Extract the contents of the zipped download and add the `KOMIKAP_.ttf` file
    to the `D:\Visual Studio Stuff\Projects\Timber\Timber\fonts` folder.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压缩下载的内容，并将`KOMIKAP_.ttf`文件添加到`D:\Visual Studio Stuff\Projects\Timber\Timber\fonts`文件夹中。
- en: Let's take a look at these assets, especially the graphics, so we can better
    visualize what is happening when we use them in our C++ code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些资产，特别是图形，这样我们在使用它们在我们的C++代码中时可以更好地可视化发生了什么。
- en: Exploring assets
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索资产
- en: Graphical assets form the individual parts of the screen in our Timber!!! game.
    Take a look at the graphical assets and it should be clear where, in our game,
    they will be used.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图形资产构成了我们的《伐木者！！！》游戏屏幕的各个部分。看一看这些图形资产，就能清楚地知道它们在我们的游戏中将被使用在哪里。
- en: '![Exploring assets](img/image_01_020.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![探索资产](img/image_01_020.jpg)'
- en: 'The sound files are all `.wav` format. These are files containing the sound
    effects that we will play at certain events throughout the game. They were all
    generated using BFXR. They are:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 声音文件都是`.wav`格式。这些文件包含了我们在游戏中特定事件播放的音效。它们都是用BFXR生成的。它们包括：
- en: '`chop.wav`: A sound that is a bit like an ax (a retro ax) chopping a tree'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chop.wav`：一种像斧头（复古斧头）砍树的声音'
- en: '`death.wav`: A sound a bit like a retro "losing" sound.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`death.wav`：一种有点像复古“失败”声音的声音。'
- en: '`out_of_time.wav`: Plays when the player loses by running out of time, as opposed
    to being squashed'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`out_of_time.wav`：当玩家因时间耗尽而失败时播放，而不是被压扁'
- en: Understanding screen and internal coordinates
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解屏幕和内部坐标
- en: Before we move on to the actual C++ coding, let's talk a little about coordinates.
    All the images that we see on our monitors are made out of pixels. Pixels are
    little tiny dots of light that combine to make the images we see.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行实际的C++编码之前，让我们谈谈坐标。我们在监视器上看到的所有图像都是由像素组成的。像素是一小点光，它们组合在一起形成我们看到的图像。
- en: There are many different monitor resolutions but, as an example, a fairly typical
    gamer's monitor might have 1920 pixels horizontally and 1080 pixels vertically.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的监视器分辨率，但是举个例子，一个相当典型的游戏玩家的监视器可能在水平上有1920个像素，在垂直上有1080个像素。
- en: The pixels are numbered starting at the top left of the screen. As you can see
    from the next diagram, our 1920 x 1080 example is numbered from 0 through to 1919
    on the horizontal (x) axis and 0 through 1079 on the vertical (y) axis.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 像素从屏幕的左上角开始编号。正如你从下一个图表中看到的，我们的1920 x 1080的示例在水平（x）轴上从0到1919，垂直（y）轴上从0到1079编号。
- en: '![Understanding screen and internal coordinates](img/image_01_021.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![理解屏幕和内部坐标](img/image_01_021.jpg)'
- en: A specific and exact screen location can therefore be identified by x and y
    coordinate. We create our games by drawing game objects such as background, characters,
    bullets and, text, to specific locations on the screen. These locations are identified
    by the coordinates of the pixels. Take a look at this next hypothetical example
    of how we might draw at, approximately, the central coordinates of the screen.
    In the case of a 1920 x 1080 screen this would be at position 960, 540.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，特定而准确的屏幕位置可以通过x和y坐标来确定。我们通过在屏幕的特定位置绘制游戏对象，比如背景、角色、子弹和文本，来创建我们的游戏。这些位置由像素的坐标来确定。看一看下面这个假设性的例子，我们可能在屏幕的中心坐标，大约在960,
    540的位置绘制。
- en: '![Understanding screen and internal coordinates](img/image_01_022.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![理解屏幕和内部坐标](img/image_01_022.jpg)'
- en: In addition to the screen coordinates, our game objects will each have their
    own similar coordinate system as well. As with the screen coordinate system, their
    **internal** or **local** coordinates start at 0,0 in the top left-hand corner.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了屏幕坐标，我们的游戏对象也将有自己类似的坐标系统。与屏幕坐标系统一样，它们的**内部**或**本地**坐标从左上角的0,0开始。
- en: We can see in the previous screenshot that 0,0 of the character is drawn at
    960, 540 of the screen.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个屏幕截图中，我们可以看到角色的0,0点被绘制在屏幕的960, 540位置。
- en: A visual, 2D game object, such as a character or perhaps a zombie, is called
    a **sprite**. A sprite is typically made from an image file. All sprites have
    what is known as an **origin**.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉上，2D游戏对象，比如角色或者僵尸，被称为**精灵**。精灵通常由图像文件制作而成。所有精灵都有所谓的**原点**。
- en: If we draw a sprite at a specific location on the screen, the origin will be
    located at this specific location. The 0,0 coordinates of the sprite are the origin.
    The next screenshot demonstrates this.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在屏幕的特定位置绘制一个精灵，原点将位于这个特定位置。精灵的0,0坐标就是原点。下一个屏幕截图演示了这一点。
- en: '![Understanding screen and internal coordinates](img/image_01_023.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![理解屏幕和内部坐标](img/image_01_023.jpg)'
- en: This is why, in the screenshot showing the character drawn to the screen, although
    we drew the image at the central position (960, 540) it appears off to the right
    and down a bit.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在显示角色绘制到屏幕的截图中，尽管我们在中心位置（960, 540）绘制了图像，它看起来有点偏右和向下的原因。
- en: We just need to bear in mind how this works as we progress through the first
    project.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行第一个项目时，我们只需要牢记这是如何工作的。
- en: Note that, in the real world, gamers have a huge variety of screen resolutions
    and our games will need to work with as many of them as possible. In the second
    project we will see how we can make our games dynamically adapt to almost any
    resolution. In this first project we will need to assume that the screen resolution
    is 1920 x 1080\. Don't worry if your screen is different to this, as I have provided
    a separate set of code for each chapter, for the Timber!!! game. The code files
    are nearly identical, apart from adding and swapping a few lines of code near
    the beginning. If you have a lower-resolution screen, then simply follow the code
    in the book that assumes a 1920 x 1080 resolution and when it comes to trying
    out the game you can copy and paste the code files from the `low res` folder in
    each of Chapters 1 to 5, as appropriate. In fact, once the extra lines have been
    added in this first chapter, all the rest of the code will be identical regardless
    of your screen resolution. I have supplied the low-res code for each chapter,
    just as a convenience. We will discuss how the few lines of code work their magic
    (scale the screen) in the second project. The alternative code will work on resolutions
    as low as 960 x 540 so should be good on almost any PC or laptop.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在现实世界中，玩家有各种各样的屏幕分辨率，我们的游戏需要尽可能适应其中的许多。在第二个项目中，我们将看到如何使我们的游戏动态适应几乎任何分辨率。在这个第一个项目中，我们需要假设屏幕分辨率是1920
    x 1080。如果你的屏幕分辨率与此不同，不要担心，因为我为Timber!!!游戏的每一章提供了单独的代码。这些代码文件几乎是相同的，只是在开头添加和交换了一些代码行。如果你有较低分辨率的屏幕，那么只需按照假设1920
    x 1080分辨率的书中的代码进行操作，当试玩游戏时，你可以从每一章的`低分辨率`文件夹中复制和粘贴代码文件。实际上，一旦在本章中添加了额外的代码行，无论你的屏幕分辨率如何，其余的代码都将是相同的。我为每一章提供了低分辨率的代码，只是为了方便起见。我们将在第二个项目中讨论这几行代码是如何发挥作用的（缩放屏幕）。备用代码将适用于分辨率低至960
    x 540，因此几乎可以在任何PC或笔记本电脑上使用。
- en: Now we can write our first C++ code, and very soon we will see it in action.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写我们的第一个C++代码，很快我们就会看到它在运行中。
- en: Starting to code the game
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始编写游戏
- en: Open up Visual Studio if it isn't already, open up the Timber project (if it
    isn't already open) by left-clicking it from the **Recent** list on the main Visual
    Studio window.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未打开Visual Studio，请打开它，从主Visual Studio窗口的**最近**列表中左键单击打开Timber项目（如果尚未打开）。
- en: The first thing we will do is to rename our main code file. It is currently
    called `HelloSFML.cpp` and we will rename it to the more appropriate `Timber.cpp`. The
    `.cpp` stands for C plus plus.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的第一件事是重命名我们的主代码文件。它目前被称为`HelloSFML.cpp`，我们将把它重命名为更合适的`Timber.cpp`。`.cpp`代表C++。
- en: Find the **Solution Explorer** window on the right-hand side.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧找到**解决方案资源管理器**窗口。
- en: Locate the `HelloSFML.cpp` file under the **Source Files** folder.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**源文件**文件夹下找到`HelloSFML.cpp`文件。
- en: Right-click `HelloSFML.cpp` and choose **Rename**.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`HelloSFML.cpp`，选择**重命名**。
- en: Edit the filename to `Timber.cpp` and press *Enter*.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑文件名为`Timber.cpp`，然后按*Enter*。
- en: 'Make some minor edits in the code window so that you have exactly the same
    code as shown next. You can do so in exactly the same way that you would with
    any text editor or word processor; you could even copy and paste it if you prefer.
    After you have made the slight edits, we can talk about them:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码窗口中进行一些微小的编辑，以便你的代码与下面显示的完全相同。你可以像使用任何文本编辑器或文字处理软件一样进行编辑；如果你愿意，甚至可以复制粘贴。在进行了轻微的编辑之后，我们可以讨论它们：
- en: '[PRE0]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This simple C++ program is a good place to start. Let's go through it line by
    line
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的C++程序是一个很好的起点。让我们逐行来看一下
- en: Making code clearer with comments
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用注释使代码更清晰
- en: 'As you can see, the only code that needed to change was a little bit at the
    very top. The first line of code is this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，唯一需要更改的代码是顶部的一点点。第一行代码是这样的：
- en: '[PRE1]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Any line of code that starts with `//` is a comment and is ignored by the compiler.
    As such, this line of code does nothing. It is used to leave any information that
    we might find useful when we come back to the code at a later date. The comment
    ends at the end of the line, so anything on the next line is not part of the comment.
    There is another type of comment called a **multi-line** or **c-style** comment,
    which can be used to leave comments that take up more than a single line. We will
    see some of them later in this chapter. Throughout this book I will leave hundreds
    of comments to help add context and further explain the code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以`//`开头的代码行都是注释，编译器会忽略它们。因此，这行代码什么也不做。它用于在以后回到代码时留下我们可能会发现有用的任何信息。注释在行尾结束，因此下一行的任何内容都不是注释的一部分。还有另一种类型的注释叫做**多行**或**c风格**注释，它可以用来留下占据多于一行的注释。我们将在本章后面看到一些这样的注释。在本书中，我将留下数百条注释，以帮助添加上下文并进一步解释代码。
- en: '#including Windows essentials'
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '#include Windows基本组件'
- en: 'Now that you know what comments are for, you can probably take a decent guess
    at what the next line of code does. Here it is again:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道注释是用来干什么的，你可能可以猜到下一行代码是做什么的。这里再次给出：
- en: '[PRE2]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `#include` directive tells Visual Studio to include, or add the contents
    of another file before compiling. The effect of this is that some other code,
    that we have not written ourselves, will be a part of our program when we run
    it. The process of adding code from other files into our code is called **pre-processing**
    and, perhaps unsurprisingly, is performed by something called a **pre-processor**.
    The file extension `.h` stands for header file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include`指令告诉Visual Studio在编译之前包含或添加另一个文件的内容。这样做的效果是，当我们运行程序时，一些我们没有自己编写的其他代码将成为我们程序的一部分。将其他文件中的代码添加到我们的代码中的过程称为**预处理**，或许不足为奇的是，这是由一个叫做**预处理器**的东西执行的。文件扩展名`.h`代表头文件。'
- en: You might be wondering what this code will do? The `stdafx.h` file actually
    contains more `#include` directives itself. It adds into our program, all the
    necessary code that is required to run our program on Windows. We will never need
    to see this file and definitely don't need to concern ourselves with what is in
    it. We just need to add the line of code at the top of every game that we make.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这段代码会做什么？`stdafx.h`文件实际上包含了更多的`#include`指令。它将我们程序所需的所有必要代码添加到我们的程序中，以便在Windows上运行我们的程序。我们永远不需要看到这个文件，绝对不需要关心它里面有什么。我们只需要在我们制作的每个游戏的顶部添加一行代码。
- en: What is more significant and relevant to us, and the reason it is worth discussing
    the `#include` directive, is that we will add many more `#include` directives
    at the top of our code files. This is to include code that we will use and take
    the trouble to understand.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说更重要和相关的是，值得讨论`#include`指令的原因是，我们将在代码文件的顶部添加许多`#include`指令。这是为了包含我们将使用和费力理解的代码。
- en: The main files that we will be including are the SFML header files, which give
    us access to all the cool game coding features. We will also use `#include` to
    access the **C++ Standard Library** header files. These header files give us access
    to core features of the C++ language itself.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将包含的主要文件是SFML头文件，它为我们提供了所有酷炫的游戏编码功能。我们还将使用`#include`来访问**C++标准库**头文件。这些头文件为我们提供了访问C++语言核心功能的权限。
- en: That's two lines squared away, so let's move on.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两行解决了，让我们继续。
- en: The main function
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主函数
- en: 'The next line we see in our code is this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中看到的下一行是这样的：
- en: '[PRE3]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code `int` is what is known as a **type**. C++ has many types and they represent
    different types of data. An `int` is an **integer** or whole number. Hold that
    thought and we will come back to it in a minute.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 代码`int`被称为**类型**。C++有许多类型，它们代表不同类型的数据。`int`是**整数**或整数。记住这一点，我们一会儿会回来讨论它。
- en: The `main()` code part is the name of the section of code that follows. This
    section of code is marked out between the opening curly brace `{` and the next
    closing curly brace `}`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`代码部分是随后的代码部分的名称。这段代码在开放的花括号`{`和下一个闭合的花括号`}`之间标出。'
- en: So, everything in between these curly braces `{...}` is a part of `main`. We
    call a section of code like this, a **function**.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些花括号`{...}`之间的所有内容都是`main`的一部分。我们把这样的一段代码称为**函数**。
- en: Every C++ program has a `main` function and it is the place where the execution
    (running) of the entire program will start. As we progress through the book, eventually
    our games will have many code files. However, there will only ever be one `main`
    function, and no matter what code we write, our game will always begin execution
    from the first line of code inside the opening curly brace of the `main` function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 每个C++程序都有一个`main`函数，它是整个程序执行（运行）的起点。随着我们在书中的进展，最终我们的游戏将有许多代码文件。然而，只会有一个`main`函数，无论我们写什么代码，我们的游戏总是从`main`函数的开放花括号内的第一行代码开始执行。
- en: 'For now, don''t worry about the strange brackets that follow the function name
    `()`. We will discuss them further in [Chapter 4](ch04.html "Chapter 4.  Loops,
    Arrays, Switch, Enumerations, and Functions – Implementing Game Mechanics"): *Loops,
    Arrays, Switch, Enumerations, and Functions*-*Implementing Game Mechanics*, where
    we will get to see functions in a whole new and more interesting light.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不要担心跟在函数名`()`后面的奇怪括号。我们将在[第4章](ch04.html "第4章。循环、数组、开关、枚举和函数-实现游戏机制")中进一步讨论它们：*循环、数组、开关、枚举和函数-实现游戏机制*，在那里我们将以全新和更有趣的方式看到函数。
- en: Let's look closely at the one single line of code within our `Main` function.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看`Main`函数中的一行代码。
- en: Presentation and syntax
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示和语法
- en: 'Take a look at the entirety of our `Main` function again:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看看我们的`Main`函数的全部内容：
- en: '[PRE4]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can see that inside `Main` there is just one single line of code, `return
    0;`. Before we move on to find out what this line of code does, let's look at
    how it is presented. This is useful because it can help us prepare to write code
    that is easy to read, and distinguish, from other parts of our code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在`Main`中只有一行代码，`return 0;`。在我们继续了解这行代码的作用之前，让我们看看它是如何呈现的。这很有用，因为它可以帮助我们准备编写易于阅读和区分的代码，与我们代码的其他部分。
- en: First notice that `return 0;` is indented to the right by one tab. This clearly
    marks it out as being internal to the `main` function. As our code grows in length
    we will see that indenting our code and leaving white space will be essential
    to maintaining readability.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先注意到`return 0;`向右缩进了一个制表符。这清楚地标志着它是`main`函数内部的一部分。随着我们的代码长度增加，我们将看到缩进我们的代码和留下空白将是保持可读性的关键。
- en: Next, notice the punctuation on the end of the line. A semicolon `;` tells the
    compiler that it is the end of the instruction and whatever follows it is a new
    instruction. We call an instruction terminated by a semicolon, a `statement`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意一下行末的标点符号。分号`;`告诉编译器这是指令的结束，其后的任何内容都是新的指令。我们称以分号终止的指令为`语句`。
- en: Note that the compiler doesn't care whether you leave a new line or even a space
    between the semicolon and the next statement. However, not starting a new line
    for each statement will lead to desperately hard-to-read code, and missing the
    semicolon altogether will result in a syntax error so that the game will not compile
    or run.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，编译器不在乎你在分号和下一条语句之间留下一个新行甚至一个空格。然而，不为每个语句开启新行将导致代码难以阅读，而完全忽略分号将导致语法错误，使得游戏无法编译或运行。
- en: A section of code together, often denoted by its indentation with the rest of
    the section, is called a **block**.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一起的一段代码，通常由其与部分的缩进表示，称为**块**。
- en: Now that you are comfortable with the idea of the `main` function, indenting
    your code to keep it tidy and putting a semicolon on the end of each statement,
    we can move on to find out exactly what the `return 0;` statement actually does.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对`main`函数的概念感到舒适，缩进你的代码以保持整洁，并在每个语句的末尾加上一个分号，我们可以继续找出`return 0;`语句实际上是做什么的。
- en: Returning values from a function
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从函数返回值
- en: Actually, `return 0;` does almost nothing in the context of our game. The concept,
    however, is an important one. When we use the `return` keyword, either on its
    own or followed by a value, it is an instruction for the program execution to
    jump/move back to the code that got the function started in the first place.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在我们的游戏中，`return 0;`几乎没有做任何事情。然而，这个概念是重要的。当我们使用`return`关键字时，无论是单独使用还是后面跟着一个值，它都是一个指示程序执行跳转/返回到最初启动函数的代码的指令。
- en: Often this code that got the function started will be yet another function somewhere
    else in our code. In this case, however, it is the operating system that started
    the `main` function. So, when the line `return 0;` is executed, the `main` function
    exits and the entire program ends.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通常启动函数的代码将是我们代码中其他地方的另一个函数。然而，在这种情况下，是操作系统启动了`main`函数。因此，当执行`return 0;`时，`main`函数退出，整个程序结束。
- en: As we have a 0 after the `return` keyword, that value is also sent to the operating
    system. We could change the value of zero to something else and that value would
    be sent back instead.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在`return`关键字后面有一个0，这个值也被发送到操作系统。我们可以将零的值更改为其他值，那个值将被发送回去。
- en: We say that the code that starts a function, **calls** the function, and that
    the function **returns** the value.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说启动函数的代码**调用**函数，并且函数**返回**值。
- en: You don't need to fully grasp all this function information just yet. It is
    just useful to introduce it here. There's one last thing on functions before we
    move on. Remember the `int` from `int Main()`? That tells the compiler that the
    type of value returned from `Main` must be an `int` (integer/whole number). We
    can return any value that qualifies as an `int`. Perhaps 0, 1, 999, 6358, and
    so on. If we try and return something that isn't an int, perhaps 12.76, then the
    code won't compile and the game won't run.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在不需要完全掌握所有这些函数信息。这里只是介绍它是有用的。在我们继续之前，还有一个关于函数的最后一件事。还记得`int Main()`中的`int`吗？那告诉编译器`Main`返回的值的类型必须是`int`（整数/整数）。我们可以返回任何符合`int`的值。也许是0、1、999、6358等等。如果我们尝试返回一个不是int的值，比如12.76，那么代码将无法编译，游戏也无法运行。
- en: Functions can return a big selection of different types, including types that
    we invent for ourselves! That kind of type, however, must be made known to the
    compiler in the way we have just seen.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以返回各种不同类型的值，包括我们自己发明的类型！然而，这种类型必须以我们刚刚看到的方式告知编译器。
- en: This little bit of background information on functions will make things smoother
    as we progress.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关于函数的背景信息将使我们在进展中更加顺利。
- en: Running the game
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行游戏
- en: You can actually run the game at this point. Do so by clicking **the Local Windows
    Debugger** button in the quick-launch bar of Visual Studio, or you can use the
    **F5** shortcut key.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行游戏。通过点击Visual Studio快速启动栏中的**本地Windows调试器**按钮，或者使用**F5**快捷键来运行。
- en: '![Running the game](img/image_01_024.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![运行游戏](img/image_01_024.jpg)'
- en: You will just get a flash of a black screen. This flash is the C++ console,
    which we can use for debugging our game. We don't need to do this for now. What
    is happening is that our program is starting, executing from the first line of
    `Main`, which of course is `return 0;` and then immediately exiting back to the
    operating system.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你将只看到一个黑屏的闪烁。这个闪烁是C++控制台，我们可以用它来调试我们的游戏。现在我们不需要这样做。正在发生的是我们的程序启动，从`Main`的第一行开始执行，当然是`return
    0;`，然后立即退出返回到操作系统。
- en: Opening a window using SFML
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SFML打开一个窗口
- en: Now let's add some more code. The code that follows will open a window that
    Timber!!! will eventually run in. The window will be 1920 pixels wide by 1080
    pixels high and will be full-screen (no border or title).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一些更多的代码。接下来的代码将打开一个窗口，Timber!!!最终将在其中运行。窗口将是1920像素宽，1080像素高，并且将是全屏的（没有边框或标题）。
- en: 'Enter the new code that is highlighted below amongst the existing code and
    then we will examine it. As you type (or copy and paste) try and work out what
    is going on:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 输入下面突出显示的新代码到现有代码中，然后我们将对其进行检查。在输入（或复制和粘贴）时，尝试弄清楚发生了什么：
- en: '[PRE5]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '#including SFML features'
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包括SFML功能
- en: The first thing we notice in our new code is another, albeit slightly different,
    `#include` directive. `#include <SFML/Graphics.hpp>` tells the pre-processor to
    include the contents of the file `Graphics.hpp` contained within the folder named
    `SFML` which we created while setting up the project.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新代码中，我们注意到的第一件事是另一个略有不同的`#include`指令。`#include <SFML/Graphics.hpp>`告诉预处理器包含文件夹中名为`SFML`的文件夹中包含的`Graphics.hpp`文件的内容。
- en: So what this line achieves is that it adds code from the aforementioned file,
    which gives us access to some of the features of SFML. Exactly how it achieves
    this will become clearer when we start writing our own separate code files and
    using `#include` to use them.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这行代码的作用是添加来自上述文件的代码，这使我们可以访问SFML的一些功能。当我们开始编写自己的独立代码文件并使用`#include`来使用它们时，它的实现方式将变得更加清晰。
- en: Note
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering about the difference between pre-processor directives where
    the file name is contained like this `<filename.hpp>` and `"filename.h"`, `<...>`
    is for files contained within our folder structure, such as the SFML files or
    anything we code ourselves. The `"..."` is for files included with Visual Studio.
    Also the `.hpp` file extension is just a more C++-oriented version of a `.h` file,
    which is more of a C-style extension. Both styles and both file extensions end
    up doing exactly the same thing and will work fine in our games.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道预处理器指令中包含文件名的`<filename.hpp>`和`"filename.h"`之间的区别，`<...>`是用于我们文件夹结构中包含的文件，比如SFML文件或我们自己编写的任何文件。`"..."`是用于包含在Visual
    Studio中的文件。此外，`.hpp`文件扩展名只是`.h`文件的更加面向C++的版本，而`.h`文件更像是C风格的扩展名。这两种风格和文件扩展名最终都会做同样的事情，并且在我们的游戏中都能正常工作。
- en: What matters, for now, is that we have a whole bunch of new functionality provided
    by SFML, available for use.The next new line is `using namespace sf;`. We will
    come back to what this line does in a few paragraphs-time.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 目前重要的是，我们有一大堆新的功能由SFML提供，可供使用。下一行是`using namespace sf;`。我们将在几段时间内回到这行代码的作用。
- en: OOP, classes, objects
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程，类，对象
- en: We will more fully discuss OOP, classes, and objects as we proceed through the
    book. What follows is the briefest introduction, so we can understand what is
    happening.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续阅读本书，我们将更全面地讨论面向对象编程、类和对象。接下来是最简短的介绍，以便我们能够理解发生了什么。
- en: We already know that OOP stands for object-oriented programming. OOP is a programming
    paradigm, a way of coding. OOP is generally accepted throughout the world of programming,
    in almost every language, as the best, if not the only, professional way to write
    code.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道OOP代表面向对象编程。OOP是一种编程范式，一种编码方式。OOP通常被全球范围内的编程界所接受，在几乎每种语言中，作为编写代码的最佳、如果不是唯一的专业方式。
- en: 'OOP introduces a lot of coding concepts, but fundamental to them all are **classes** and
    **objects**. When we write code, whenever possible we want to write code that
    is reusable. The way we do this is to structure our code as a class. We will learn
    how to do this in [Chapter 6](ch06.html "Chapter 6.  Object-Oriented Programming,
    Classes, and SFML Views"): *Object-Oriented Programming, Classes and SFML Views*.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程引入了许多编码概念，但它们所有的基础都是**类**和**对象**。当我们编写代码时，我们希望尽可能地编写可重用的代码。我们这样做的方式是将我们的代码结构化为一个类。我们将在[第6章](ch06.html
    "第6章。面向对象编程，类和SFML视图")中学习如何做到这一点：*面向对象编程，类和SFML视图*。
- en: All we need to know about classes, for now, is that once we have coded our class,
    we don't just execute that code as part of our game instead we create usable objects
    from the class.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只需要知道关于类的一切，一旦我们编写了我们的类，我们不仅仅执行该代码作为游戏的一部分，而是创建可用的对象从类中。
- en: For example, if we wanted a hundred zombie **Non-Player Characters** (**NPCs**)
    we could carefully design and code a class called `Zombie` and then, from that
    single class, create as many zombie objects as we like. Each and every zombie
    object would have the same functionality and internal data types, but each and
    every zombie object would be a separate and distinct entity.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要一百个僵尸**非玩家角色**（**NPCs**），我们可以仔细设计和编写一个名为`Zombie`的类，然后从这个单个类中创建任意数量的僵尸对象。每个僵尸对象都具有相同的功能和内部数据类型，但每个僵尸对象都是一个独立的实体。
- en: 'To take the hypothetical zombie example further, but without showing any code
    for the `Zombie` class, we might create a new object based on the `Zombie` class
    like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步以假设的僵尸示例为例，但不显示任何`Zombie`类的代码，我们可以像这样创建一个基于`Zombie`类的新对象：
- en: '[PRE6]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The object, `z1`, is now a fully coded and functioning `Zombie` object. We
    could then do this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对象`z1`是一个完全编码和功能的`Zombie`对象。然后我们可以这样做：
- en: '[PRE7]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We now have five separate zombies, but they are all based on one carefully
    coded class. Let''s take things one step further before we get back to the code
    we have just written. Our zombies can contain both behaviors (defined by functions),
    as well as data that might represent things such as the zombie''s health, speed,
    location, or direction of travel. As an example, we could code our `Zombie` class
    to enable us to use our zombie objects, perhaps like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有五个独立的僵尸，但它们都是基于一个精心编写的类。在我们回到刚刚编写的代码之前，让我们再进一步。我们的僵尸可以包含行为（由函数定义）以及可能代表僵尸健康、速度、位置或行进方向等事物的数据。例如，我们可以编写我们的`Zombie`类，使我们能够像这样使用我们的僵尸对象：
- en: '[PRE8]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note again that all this zombie-code is hypothetical for the moment. Don't type
    this code in to Visual Studio; it will just produce a bunch of errors.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，所有这些僵尸代码目前都是假设的。不要将这些代码输入Visual Studio；它只会产生一堆错误。
- en: We will design our class to enable us to use the data and behaviors in the most
    appropriate manner to suit our game's objectives. For example, we could design
    our class so that we can assign values for the data for each zombie object at
    the time we create it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计我们的类，以便我们可以以最合适的方式使用数据和行为来满足我们游戏的目标。例如，我们可以设计我们的类，以便我们可以在创建每个僵尸对象时为数据分配值。
- en: 'Perhaps we need to assign a unique name and speed in meters per second, at
    the time we create each zombie. Careful coding of the `Zombie` class could enable
    us to write code like this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们需要在创建每个僵尸时分配一个唯一的名称和以米每秒为单位的速度。`Zombie`类的仔细编码可以使我们编写这样的代码：
- en: '[PRE9]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The point is that classes are almost infinitely flexible, and once we have coded
    the class, we can go about using them by creating an object from them. It is through
    classes and the objects that we create from them that we will harness the power
    of SFML. And yes, we will also write our own classes, including a `Zombie` class.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是类几乎是无限灵活的，一旦我们编写了类，我们就可以通过创建对象来使用它们。正是通过类和我们从中创建的对象，我们将利用SFML的强大功能。是的，我们还将编写我们自己的类，包括一个`Zombie`类。
- en: Let's get back to the real code we just wrote.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们刚刚编写的真正代码。
- en: Using namespace sf
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用sf命名空间
- en: Before we move on to look more closely at `VideoMode` and `RenderWindow`, which,
    as you've probably guessed, are classes provided by SFML, we will learn what the
    `using namespace sf;` line of code does.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续更仔细地查看`VideoMode`和`RenderWindow`之前，您可能已经猜到，这些都是SFML提供的类，我们将学习`using namespace
    sf;`这行代码的作用。
- en: When we create a class, we do so in a **namespace**. We do this to distinguish
    our classes from those that others have written. Consider the `VideoMode` class.
    It is entirely possible that, in an environment like Windows, somebody has already
    written a class called `VideoMode`. By using a namespace, we, and the SFML programmers,
    can make sure that the names of classes never clash.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个类时，我们是在一个**命名空间**中创建的。我们这样做是为了区分我们编写的类和其他人编写的类。考虑一下`VideoMode`类。在Windows等环境中，完全有可能有人已经编写了一个名为`VideoMode`的类。通过使用命名空间，我们和SFML程序员可以确保类的名称永远不会冲突。
- en: 'The full way of using the `VideoMode` class is like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`VideoMode`类的完整方式如下：
- en: '[PRE10]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code `using namespace sf;` enables us to omit the prefix `sf::` from everywhere
    in our code. Without it, there would be over 100 instances of `sf::` in this simple
    game alone. It also makes our code more readable as well as shorter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 代码`using namespace sf;`使我们可以在代码中的任何地方省略前缀`sf::`。如果没有它，在这个简单的游戏中将会有超过100个`sf::`的实例。它还使我们的代码更易读，同时也更短。
- en: SFML VideoMode and RenderWindow
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SFML VideoMode和RenderWindow
- en: 'Inside the `Main` function we now have two new comments and two new lines of
    actual code. The first line of actual code is this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Main`函数中，我们现在有两个新的注释和两行新的实际代码。第一行实际代码是这样的：
- en: '[PRE11]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code creates an object called `vm` from the class called `VideoMode` and
    sets up two internal values of `1920` and `1080`. These values represent the resolution
    of the player's screen.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为`vm`的对象，从名为`VideoMode`的类中创建，并设置了内部值`1920`和`1080`。这些值代表玩家屏幕的分辨率。
- en: 'The next new line of code is this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行新的代码是这样的：
- en: '[PRE12]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the previous line of code, we were creating a new object called `window`
    from the SFML provided class called `RenderWindow`. Furthermore, we were setting
    up some values inside our window object.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一行代码中，我们正在从SFML提供的名为`RenderWindow`的类中创建一个名为`window`的新对象。此外，我们正在设置窗口对象内部的一些值。
- en: Firstly, the `vm` object is used in order to initialize part of the `window`.
    At first this might seem confusing. Remember, however, that a class can be as
    varied and flexible as its creator wants to make it. And yes, some classes can
    contain other classes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`vm`对象用于初始化`window`的一部分。起初这可能看起来令人困惑。然而，请记住，类可以像其创建者想要的那样多样化和灵活。是的，有些类可以包含其他类。
- en: Tip
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is not necessary to fully understand how this works at this point, just as
    long as you appreciate the concept. We code a class and then make usable objects
    from that class. A bit like an architect might draw a blueprint. You certainly
    can't move all your furniture, kids, and dog into the blueprint; but you could
    build a house (or many houses) from the blueprint. In this analogy, a class is
    like the blueprint and an object is like a house.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此时不必完全理解这是如何工作的，只要您能理解这个概念就可以了。我们编写一个类，然后从该类中创建可用的对象。有点像建筑师可能会绘制蓝图。您当然不能把所有家具、孩子和狗都搬进蓝图中；但您可以根据蓝图建造一座房子（或者多座房子）。在这个类比中，类就像蓝图，对象就像房子。
- en: Next we use the value Timber!!! to give the window a name. And we use the predefined
    value `Style::FullScreen` to make our `window` object full screen.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用值Timber!!!来给窗口命名。我们使用预定义的值`Style::FullScreen`来使我们的`window`对象全屏显示。
- en: Tip
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '`Style::FullScreen` is a value defined in SFML. It is useful so that we don''t
    need to remember the integer number that the internal code uses to represent a
    full screen. The coding term for this type of value is a `constant`. Constants
    and their close C++ relatives, **variables**, are covered in the next chapter.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`Style::FullScreen`是SFML中定义的一个值。这样做是为了我们不需要记住内部代码用来表示全屏的整数。这种类型的值的编码术语是`常量`。常量及其近亲C++中的**变量**将在下一章中介绍。'
- en: Let's see our window object in action.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的窗口对象在运行中的样子。
- en: Running the game
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行游戏
- en: You can run the game again at this point. You will see a bigger black screen
    flash on then disappear. This is the 1920 x 1080 full-screen window that we just
    coded. Unfortunately, what is still happening is that our program is starting,
    executing from the first line of `Main`, creating the cool new game window, then
    coming to `return 0;`, and immediately exiting back to the operating system.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可以再次运行游戏。您会看到一个更大的黑屏一闪而过。这就是我们刚刚编写的1920 x 1080全屏窗口。不幸的是，我们的程序仍然是从`Main`的第一行开始执行，创建了一个很酷的新游戏窗口，然后到达`return
    0;`，立即退出到操作系统。
- en: The main game loop
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主游戏循环
- en: We need a way to stay in the program until the player wants to quit. At the
    same time, we should clearly mark out where the different parts of our code will
    go as we progress with Timber!!!. Furthermore, if we are going to stop our game
    from exiting, we had better provide a way for the player to exit when they are
    ready. Otherwise the game will go on forever!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来保持程序运行，直到玩家想要退出。同时，随着我们在Timber!!!中的进展，我们应该清楚地标出代码的不同部分将放在哪里。此外，如果我们要阻止游戏退出，我们最好提供一种让玩家在准备好退出时退出的方法。否则游戏将永远进行下去！
- en: 'Add the highlighted code, inside the existing code, and then we will go through
    and discuss it all:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 添加高亮代码，放入现有代码中，然后我们将一起讨论它们：
- en: '[PRE13]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While loops
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: While循环
- en: 'The very first thing we see in the new code is this:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在新代码中，我们看到的第一件事是：
- en: '[PRE14]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The very last thing we see in the new code is a closing `}`. We have created
    a `while` loop. Everything between the opening `{` and closing `}` of the `while`
    loop will continue to execute, over and over, potentially forever.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在新代码中，我们看到的最后一件事是一个闭合的`}`。我们创建了一个`while`循环。在`while`循环的开头`{`和结尾`}`之间的所有内容将会一遍又一遍地执行，可能会永远执行下去。
- en: 'Look closely between the parentheses `(...)` of the `while` loop as shown highlighted
    in the next code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看一下下一个代码中突出显示的`while`循环的括号`(...)`之间的部分：
- en: '[PRE15]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The full explanation of this code will have to wait until we discuss loops
    and conditions in [Chapter 4](ch04.html "Chapter 4.  Loops, Arrays, Switch, Enumerations,
    and Functions – Implementing Game Mechanics"): *Loops, Arrays, Switch, Enumerations,
    and Functions*-*Implementing Game Mechanics*. What is important for now is that,
    when the `window` object is set to closed, the execution of the code will break
    out of the `while` loop and onto the next statement. Exactly how a window is closed
    will be covered soon.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的完整解释将等到我们在[第4章](ch04.html "第4章。循环、数组、开关、枚举和函数-实现游戏机制")讨论循环和条件时再说：*循环、数组、开关、枚举和函数-实现游戏机制*。现在重要的是，当`window`对象被设置为关闭时，代码的执行将跳出`while`循环并进入下一个语句。窗口如何关闭将很快涵盖。
- en: The next statement is of course `return 0;`, which ends our game.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个声明当然是`return 0;`，这结束了我们的游戏。
- en: We now know that our `while` loop will whiz round and round, repeatedly executing
    the code within it, until our window object is set to closed.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的`while`循环会快速循环执行其中的代码，直到我们的窗口对象被设置为关闭。
- en: C-style code comments
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C风格的代码注释
- en: 'Just inside the while loop we see what, at first glance, might look a bit like
    ASCII art:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在while循环内部，我们看到了乍一看可能有点像ASCII艺术的东西：
- en: '[PRE16]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'ASCII art is a niche but fun way of creating images with computer text. You
    can read more about it here: [https://en.wikipedia.org/wiki/ASCII_art](https://en.wikipedia.org/wiki/ASCII_art)
    [.](https://en.wikipedia.org/wiki/ASCII_art)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII艺术是一种利用计算机文本创建图像的小众但有趣的方式。您可以在这里阅读更多信息：[https://en.wikipedia.org/wiki/ASCII_art](https://en.wikipedia.org/wiki/ASCII_art)
    [.](https://en.wikipedia.org/wiki/ASCII_art)
- en: This previous code is simply another type of comment. This type of comment is
    known as a C-style comment. The comment begins with `/*` and ends with `*/`. Anything
    in between is just for information and is not compiled. I have used this slightly
    elaborate text to make it absolutely clear what we will be doing in this part
    of the code file. And of course you can now work out that any code that follows
    will be related to handling the player's input.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码只是另一种类型的注释。这种注释被称为C风格注释。注释以`/*`开头，以`*/`结尾。中间的任何内容只是用于信息，不会被编译。我使用了这种略微复杂的文本，以确保清楚地表明我们将在代码文件的这部分做什么。当然，您现在可以推断出接下来的任何代码都将与处理玩家的输入有关。
- en: Skip over a few lines of code and you will see that we have another C-style
    comment announcing that, in that part of the code, we will be updating the scene.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过几行代码，您会看到我们有另一个C风格的注释，宣布在代码的这部分，我们将更新场景。
- en: Jump to the next C-style comment and it is plain where we will be drawing all
    the graphics.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 跳到下一个C风格的注释，很明显我们将在那里绘制所有的图形。
- en: Input, update, draw, repeat
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入、更新、绘制、重复
- en: 'Although this first project uses the simplest possible version of a **game
    loop**, every game will need these phases in the code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个第一个项目使用了最简单的**游戏循环**版本，但每个游戏都需要在代码中经历这些阶段：
- en: Get the player's input (if any).
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取玩家的输入（如果有）。
- en: Update the scene based on things such as artificial intelligence, physics, or
    the player's input.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据人工智能、物理或玩家的输入更新场景。
- en: Draw the current scene.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制当前场景。
- en: Repeat the above at a fast enough rate to create a smooth and animated game
    world.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以足够快的速度重复以上步骤，以创建一个平滑和动画的游戏世界。
- en: Now let's look at the code that actually does something within the game loop.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看实际在游戏循环中执行的代码。
- en: Detecting a key press
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测按键
- en: 'Firstly, within the section labeled `Handle the player''s input` we have the
    following code:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在标记为`处理玩家输入`的部分中，我们有以下代码：
- en: '[PRE17]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code checks whether the **Escape** key is currently pressed. If it is,
    the highlighted code uses the `window` object to close itself. Now, the next time
    the `while` loop begins, it will see that the `window` object is closed and jump
    to the code immediately after the closing curly brace `}` of the `while` loop
    and the game will exit. We will discuss `if` statements more fully in [Chapter
    2](ch02.html "Chapter 2. Variables, Operators, and Decisions – Animating Sprites"):
    *Variables, Operators, and Decisions-Animating Sprites*.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查当前是否按下了**Escape**键。如果是，突出显示的代码使用`window`对象关闭自身。现在，下一次`while`循环开始时，它将看到`window`对象已关闭，并跳到`while`循环的结束大括号`}`后面的代码，游戏将退出。我们将在[第2章](ch02.html
    "第2章。变量、运算符和决策-动画精灵")更全面地讨论`if`语句：*变量、运算符和决策-动画精灵*。
- en: Clearing and drawing the scene
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除和绘制场景
- en: At the moment there is no code in the `Update the scene` section, so let's move
    on to the `Draw the scene section`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在`更新场景`部分没有代码，所以让我们继续到`绘制场景`部分。
- en: 'The first thing we do is to rub out the previous frame of animation using the
    code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是使用以下代码擦除先前的动画帧：
- en: '[PRE18]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What we do now is draw each and every object from the game. At the moment, however,
    we don't have any game objects.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的是绘制游戏中的每一个对象。然而，目前我们没有任何游戏对象。
- en: 'The next line of code is this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码是：
- en: '[PRE19]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When we draw all the game objects, we are drawing them to a hidden surface ready
    to be displayed. The code `window.display()` flips from the previously displayed
    surface to the newly updated (previously hidden) one. This way, the player will
    never see the drawing process as the surface has all the sprites added to it.
    It also guarantees that the scene will be complete before it is flipped. This
    prevents a graphical glitch known as **tearing**. The process is called **double
    buffering**.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们绘制所有游戏对象时，我们将它们绘制到一个隐藏的表面上，准备好显示。代码`window.display()`从先前显示的表面翻转到新更新的（先前隐藏的）表面。这样，玩家永远不会看到绘图过程，因为表面上添加了所有精灵。它还保证了在翻转之前场景将会完整。这可以防止图形故障，称为**撕裂**。这个过程称为**双缓冲**。
- en: Also, notice that all this drawing and clearing functionality is performed using
    our `window` object, which was created from the SFML `RenderWindow` class.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，所有这些绘制和清除功能都是使用我们的`window`对象执行的，该对象是从SFML的`RenderWindow`类创建的。
- en: Running the game
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行游戏
- en: Run the game and you will get a blank, full-screen window that remains until
    you press the ***Esc*** keyboard key.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，您将得到一个空白的全屏窗口，直到您按下***Esc***键。
- en: Drawing the game background
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制游戏背景
- en: At last we will get to see some real graphics in our game. What we need to do
    is create a sprite. The first one we will create will be the game background.
    We can then draw it in between clearing the window and displaying/flipping it.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在游戏中看到一些真正的图形。我们需要做的是创建一个精灵。我们将创建的第一个精灵将是游戏背景。然后我们可以在清除窗口和显示/翻转窗口之间绘制它。
- en: Preparing the sprite using a texture
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用纹理准备精灵
- en: The SFML `RenderWindow` class allowed us to create our `window` object to take
    care of all the functionality that our game's window needs.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: SFML的`RenderWindow`类允许我们创建`window`对象来处理游戏窗口所需的所有功能。
- en: We will now explore two more SFML classes, which will take care of drawing sprites
    to the screen. One of these classes, perhaps unsurprisingly, is called `Sprite`.
    The other class is called `Texture`. A texture is a graphic stored in memory on
    the **Graphics Processing Unit** (**GPU**).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将探索另外两个SFML类，它们将负责在屏幕上绘制精灵。其中一个类，也许不足为奇的是，被称为`Sprite`。另一个类被称为`Texture`。纹理是存储在**图形处理单元**（**GPU**）上的图形。
- en: 'An object made from the `Sprite` class needs an object made from the `Texture`
    class in order to display itself as an image. Add the following highlighted code.
    Try and work out what is going on as well. Then we will go through it one line
    at a time:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Sprite`类创建的对象需要从`Texture`类创建的对象才能将自己显示为图像。添加以下突出显示的代码。尝试弄清楚发生了什么。然后我们将逐行解释：
- en: '[PRE20]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: First, we create an object called `textureBackground` from the SFML `Texture`
    class.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从SFML的`Texture`类创建一个名为`textureBackground`的对象。
- en: '[PRE21]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once this is done, we can use the `textureBackground` object to load a graphic
    from our `graphics` folder, into the `textureBackground`, like this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以使用`textureBackground`对象从我们的`graphics`文件夹加载图形到`textureBackground`中，就像这样：
- en: '[PRE22]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We only need to specify `graphics/background` as the path is relative to the
    Visual Studio working directory where we created the folder and added the image.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要指定`graphics/background`作为路径，因为路径是相对于我们创建文件夹并添加图像的Visual Studio工作目录的。
- en: 'Next, we create an object called `spriteBackground` from the SFML `Sprite`
    class with this code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下代码从SFML的`Sprite`类创建一个名为`spriteBackground`的对象：
- en: '[PRE23]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we can associate the texture object `textureBackground` with the Sprite
    object `spriteBackground`, like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将纹理对象`textureBackground`与精灵对象`spriteBackground`关联起来，就像这样：
- en: '[PRE24]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we can position the `spriteBackground` object in the `window` object
    at coordinates `0,0`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将`spriteBackground`对象定位在`window`对象的坐标`0,0`处：
- en: '[PRE25]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As the `background.png` graphic in the `graphics` folder is 1920 pixels wide
    by 1080 pixels high, it will neatly fill the entire screen. Just note that this
    previous line of code doesn't actually show the sprite. It just sets its position
    ready for when it is shown.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`background.png`图形在`graphics`文件夹中的尺寸为1920像素宽，1080像素高，它将完全填满整个屏幕。只是请注意，这行代码并不实际显示精灵，它只是设置好位置，以便在显示时使用。'
- en: The object, `backgroundSprite`, can now be used to display the background graphic.
    Of course you are almost certainly wondering why we had to do things in such a
    convoluted way. The reason is because of the way that graphics cards and OpenGL
    work.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`backgroundSprite`对象可以用来显示背景图形。当然，您几乎肯定想知道为什么我们不得不以这种复杂的方式做事。原因是因为显卡和OpenGL的工作方式。
- en: Textures take up graphics memory and this memory is a finite resource. Furthermore,
    the process of loading a graphic into the GPU's memory is very slow. Not so slow
    that you can watch it happen, or that you will see your PC noticeably slow down
    while it is happening, but slow enough that you can't do it every frame of the
    game loop. So it is useful to dissociate the actual texture `textureBackground` from
    any code that we will manipulate during the game loop.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理占用图形内存，而这种内存是有限的资源。此外，将图形加载到GPU内存中的过程非常缓慢。并不是缓慢到可以看到它发生，或者在发生时会明显减慢您的PC，但足够缓慢，以至于您无法在游戏循环的每一帧中都这样做。因此，将实际纹理`textureBackground`与在游戏循环期间我们将操纵的任何代码分离开来是有用的。
- en: As you will see when we start to move our graphics, we will do so using the
    sprite. Any objects made from the `Texture` class will sit happily on the GPU,
    just waiting for an associated `Sprite` object to tell them where to show themselves.
    In later projects we will also reuse the same `Texture` object with multiple different
    `Sprite` objects, which makes efficient use of GPU memory.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始移动我们的图形时，您将会看到我们将使用精灵。任何从`Texture`类创建的对象都将愉快地停留在GPU上，只等待一个关联的`Sprite`对象告诉它们在哪里显示自己。在以后的项目中，我们还将重复使用相同的`Texture`对象与多个不同的`Sprite`对象，这样可以有效地利用GPU内存。
- en: 'In summary:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 总之：
- en: Textures are very slow to load onto the GPU
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理加载到GPU上非常缓慢
- en: Textures are very fast to access once they are on the GPU
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦纹理存储在GPU上，访问速度非常快
- en: We associate a sprite object with a texture
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将精灵对象与纹理关联起来
- en: We manipulate the position and orientation of sprite objects (usually in the
    `Update the scene` section)
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通常在“更新场景”部分操纵精灵对象的位置和方向。
- en: We draw the `Sprite` object, which in turn displays the texture that is associated
    with it (usually in the `Draw the scene` section).
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们绘制`Sprite`对象，然后显示与其关联的纹理（通常在“绘制场景”部分）。
- en: So all we need to do now is use our double-buffering system, provided by our
    `window` object, to draw our new `Sprite` object (`spriteBackground`), and we
    should actually get to see our game in action.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们需要做的就是使用我们的`window`对象提供的双缓冲系统来绘制我们的新`Sprite`对象（`spriteBackground`），然后我们实际上应该能够看到我们的游戏在运行。
- en: Double-buffering the background sprite
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双缓冲背景精灵
- en: Finally we need to draw that sprite, and its associated texture, in the appropriate
    place in the game loop.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在游戏循环中的适当位置绘制该精灵及其相关纹理。
- en: Tip
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that, when I present code that is all from the same block, I don't add
    the indenting because it lessens the instances of line wraps in the text of the
    book. The indenting is implied. Check out the code file in the download bundle
    to see the full use of indenting.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我展示的代码都来自同一个块时，我不添加缩进，因为这会减少书中文本的换行次数。缩进是暗示的。请查看下载包中的代码文件，以查看缩进的完整用法。
- en: 'Add the highlighted code:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 添加突出显示的代码：
- en: '[PRE26]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The new line of code simply uses the `window` object to draw the `spriteBackground`
    object, in between clearing the display and showing the newly drawn scene.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 新的代码行只是使用`window`对象来绘制`spriteBackground`对象，在清除显示并显示新绘制的场景之间。
- en: Running the game
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行游戏
- en: Run the program now and you will see the first signs that we have a real game
    in progress.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行程序，您将看到我们正在进行真正的游戏的第一个迹象。
- en: '![Running the game](img/image_01_025.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![运行游戏](img/image_01_025.jpg)'
- en: It's not going to get **Greenlit** on Steam in its current state, but we are
    on our way at least!
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 它目前还不能在Steam上获得**绿光**，但至少我们已经在路上了！
- en: Let's take a look at some of the things that might go wrong in this chapter,
    and as we proceed through the book.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看本章可能出现的一些问题，以及随着书的进行我们将继续进行的工作。
- en: Handling errors
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: There will always be problems and errors in every project you make, that is
    guaranteed! The tougher a problem is, the more satisfying it is when you solve
    it. When, after hours of struggling, a new game feature finally bursts into life,
    it can cause a genuine high. Without the struggle, it would somehow be less worthwhile.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 每个项目都会出现问题和错误，这是肯定的！问题越棘手，解决它时就会越令人满意。经过数小时的挣扎后，一个新的游戏功能终于实现，会让人真正兴奋。如果没有挣扎，它可能会变得不那么值得。
- en: At some point in this book there will probably be some struggle. Remain calm,
    be confident that you will overcome it, and then set to work.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的某个时候，可能会遇到一些困难。保持冷静，相信自己能够克服它，然后开始工作。
- en: Remember that, whatever your problem, it is very unlikely you are the first
    person in the world to have ever had this same problem. Think of a concise sentence
    that describes your problem or error and then type it in to Google. You will be
    surprised how quickly, precisely, and often, someone else will already have solved
    your problem for you.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，无论您遇到什么问题，您都极不可能是世界上第一个遇到同样问题的人。想出一个简洁的句子来描述您的问题或错误，然后在Google中输入。您会惊讶地发现，有人很快、准确地解决了您的问题，而且经常会有人已经为您解决了问题。
- en: 'Having said that, here are a few pointers (pun intended; see [Chapter 8](ch08.html
    "Chapter 8. Pointers, the Standard Template Library, and Texture Management"):
    *Pointers, Standard Template Library, and Texture Management*) to get you started,
    in the event you are struggling with making this first chapter work.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在这里有一些提示（双关语；请参阅[第8章](ch08.html "第8章。指针、标准模板库和纹理管理")：*指针、标准模板库和纹理管理*），以便在您努力使本章工作时帮助您入门。
- en: Configuration errors
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置错误
- en: The most likely cause of problems in this chapter will be configuration errors.
    As you probably noticed during the process of setting up Visual Studio, SFML,
    the project template, and the project itself, there are an awful lot of filenames,
    folders, and settings that need to be just right. Just one wrong setting could
    cause one of a number of errors in which the text doesn't make it clear exactly
    what is wrong.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中问题最有可能的原因是配置错误。您可能已经在设置Visual Studio、SFML、项目模板和项目本身的过程中注意到，有很多文件名、文件夹和设置需要完全正确。只要有一个错误的设置，就可能导致多种错误，其中文本并没有清楚地说明出了什么问题。
- en: If you can't get the empty project with the black screen working in the **Creating
    a reusable template** section, it might be easier to start that section again.
    Make sure all the filenames and folders are appropriate for your specific setup
    and then get the simplest part of the code running (the part where the screen
    flashes black and then closes). If you can get to this stage, then configuration
    is probably not the issue.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法使**从模板创建可重用模板**部分中的黑屏空项目运行起来，可能更容易重新开始该部分。确保所有的文件名和文件夹适合于您特定的设置，然后让代码的最简单部分运行起来（屏幕闪烁黑色然后关闭的部分）。如果您能够达到这个阶段，那么配置可能不是问题所在。
- en: Compile errors
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译错误
- en: Compile errors are probably the most common error we will experience going forward.
    Check that your code is identical to mine, especially semicolons on the ends of
    lines and subtle changes in upper and lower case for class and object names. If
    all else fails, open the code files in the download bundle and copy and paste
    it. While it is always possible that a code typo made it into the book, the code
    files were made from actual working projects - they definitely work!
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 编译错误可能是我们未来经历的最常见的错误。检查您的代码是否与我的相同，特别是行尾的分号和类和对象名称的大小写的微妙变化。如果一切都失败了，打开下载包中的代码文件并复制粘贴。虽然书中可能存在代码拼写错误，但代码文件是从实际工作的项目中制作的
    - 它们绝对有效！
- en: Link errors
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接错误
- en: Link errors are most likely caused by missing SFML `.dll` files. Did you copy
    all of them into the project folder in the section Creating a project from the
    template?
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 链接错误很可能是由于缺少SFML的`.dll`文件造成的。您是否将它们全部复制到了从模板创建项目的项目文件夹中？
- en: Bugs
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误
- en: Bugs are what happen when your code works, but not as you expect it to. Debugging
    can actually be fun. The more bugs you squash the better your game and the more
    satisfying your day's work will be. The trick to solving bugs is to find them
    early! To do this I recommend running and playing your game every time you implement
    something new. The sooner you find the bug, the more likely the cause will be
    fresh in your mind. In this book we will run the code to see the results at every
    possible stage.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的代码工作时发生错误时，这就是错误。调试实际上可以很有趣。您消灭的错误越多，您的游戏就会越好，您一天的工作就会越令人满意。解决错误的诀窍是尽早找到它们！为此，我建议每次实现新功能时都运行和玩游戏。您越早发现错误，原因就越可能新鲜在您的脑海中。在本书中，我们将在每个可能的阶段运行代码以查看结果。
- en: FAQ
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: 'Here are some questions that might be on your mind:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可能会让你困惑的问题：
- en: Q) I am struggling with the content presented so far. Am I cut out for programming?
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Q）我对目前呈现的内容感到困难。我适合编程吗？
- en: A) Setting up a development environment and getting your head round OOP as a
    concept is probably the toughest thing you will do in this book. As long as your
    game is functioning (drawing the background), you are ready to proceed with the
    next chapter.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: A）设置开发环境并理解OOP作为一个概念可能是你在这本书中做的最艰难的事情。只要你的游戏正常运行（绘制背景），你就可以继续进行下一章。
- en: Q) All this talk of OOP, classes, and objects is too much and kind of spoiling
    the whole learning experience.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Q）所有关于面向对象编程（OOP）、类和对象的讨论都太多了，有点破坏了整个学习体验。
- en: 'A) Don''t worry. We will keep returning to OOP, classes, and objects constantly.
    In [Chapter 6](ch06.html "Chapter 6.  Object-Oriented Programming, Classes, and
    SFML Views"): *Object-Oriented Programming, Classes, and SFML Views*, we will
    really begin to get grip with the whole OOP thing. All you need to understand
    for now is that SFML has written a whole load of useful classes and we get to
    use this code by creating usable objects from those classes.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: A）别担心。我们会不断地回到面向对象编程、类和对象。在[第6章](ch06.html "第6章。面向对象编程、类和SFML视图")：*面向对象编程、类和SFML视图*中，我们将真正开始掌握整个面向对象编程的东西。你现在需要理解的是，SFML已经编写了大量有用的类，我们可以通过从这些类创建可用对象来使用这些代码。
- en: Q) I really don't get this function stuff.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Q）我真的不懂这个函数的东西。
- en: A) It doesn't matter, we will return to it again and will learn about functions
    more thoroughly. You just need to know that, when a function is called, its code
    is executed, and when it is done (reaches a `return` statement), then the program
    jumps back to the code that called it.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: A）没关系，我们会再次回到这个问题，并且会更彻底地学习函数。你只需要知道，当一个函数被调用时，它的代码被执行，当它完成时（达到`return`语句），程序会跳回调用它的代码。
- en: Summary
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: That was quite a challenging chapter and perhaps I was a little bit mean to
    make it so demanding. It is true that configuring an IDE to use a C++ library
    can be a bit awkward and time consuming. Also it is well known that the concept
    of classes and objects is slightly awkward for people who are new to coding.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个相当具有挑战性的章节，也许我让它变得如此苛刻了一点。配置IDE以使用C++库可能有点棘手和耗时。同时，众所周知，对于编程新手来说，类和对象的概念可能有点棘手。
- en: Now that we are at this stage, however, we can totally focus on C++, SFML, and
    games. As the chapters progress, we will learn more and more C++, as well as how
    to implement increasingly interesting game features. As we do so, we will take
    a further look at things such as functions, classes, and objects, to help demystify
    them a little more. Next up we will learn all the C++ we need to draw some more
    sprites and animate them as well.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到了这个阶段，我们可以完全专注于C++、SFML和游戏。随着章节的进展，我们将学习更多的C++，以及如何实现越来越有趣的游戏功能。在这个过程中，我们将进一步研究诸如函数、类和对象之类的东西，以帮助更好地揭开它们的神秘面纱。接下来，我们将学习所有绘制更多精灵并对它们进行动画处理所需的C++知识。
