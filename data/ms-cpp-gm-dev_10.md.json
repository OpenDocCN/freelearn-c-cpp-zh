["```cpp\n\u2026\n#include <stdio.h>\n#include <windows.h>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n\n#define PORT \"44000\" /* Port to listen on */\n\n\u2026\n```", "```cpp\n\u2026\n if ((iResult = WSAStartup(wVersion, &wsaData)) != 0) {\n     printf(\"WSAStartup failed: %d\\n\", iResult);\n     return 1;\n }\n```", "```cpp\n\n ZeroMemory(&hints, sizeof hints);\n hints.ai_family = AF_INET;\n hints.ai_socktype = SOCK_STREAM;\n if (getaddrinfo(NULL, PORT, &hints, &res) != 0) {\n     perror(\"getaddrinfo\");\n     return 1;\n }\n```", "```cpp\n sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n if (sock == INVALID_SOCKET) {\n     perror(\"socket\");\n     WSACleanup();\n     return 1;\n }\n```", "```cpp\n    /* Enable the socket to reuse the address */\n    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (const char *)&reuseaddr,\n        sizeof(int)) == SOCKET_ERROR) {\n        perror(\"setsockopt\");\n        WSACleanup();\n        return 1;\n    }\n```", "```cpp\n    if (bind(sock, res->ai_addr, res->ai_addrlen) == SOCKET_ERROR) {\n        perror(\"bind\");\n        WSACleanup();\n        return 1;\n    }\n    if (listen(sock, 1) == SOCKET_ERROR) {\n        perror(\"listen\");\n        WSACleanup();\n        return 1;\n    }\n```", "```cpp\n\u2026\n    while(1) {\n        size_t size = sizeof(struct sockaddr);\n        struct sockaddr_in their_addr;\n        SOCKET newsock;\n        ZeroMemory(&their_addr, sizeof (struct sockaddr));\n        newsock = accept(sock, (struct sockaddr*)&their_addr, &size);\n        if (newsock == INVALID_SOCKET) {\n            perror(\"accept\\n\");\n        }\n        else {\n            printf(\"Got a connection from %s on port %d\\n\",\n                inet_ntoa(their_addr.sin_addr), ntohs(their_addr.sin_port));\n \u2026\n        }\n    }\n```", "```cpp\n    /* Clean up */\n    closesocket(sock);\n    WSACleanup();\n    return 0;\n}\n```", "```cpp\n#include <stdio.h>\n#include <string.h> /* memset() */\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <netdb.h>\n#define PORT    \"44000\"\n\u2026\n```", "```cpp\nint main(void)\n{\n    int sock;\n    struct addrinfo hints, *res;\n    int reuseaddr = 1; /* True */\n    /* Get the address info */\n    memset(&hints, 0, sizeof hints);\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    if (getaddrinfo(NULL, PORT, &hints, &res) != 0) {\n        perror(\"getaddrinfo\");\n        return 1;\n    }\n```", "```cpp\n    /* Create the socket */\n    sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n    if (sock == -1) {\n        perror(\"socket\");\n        return 1;\n    }\n```", "```cpp\n    /* Enable the socket to reuse the address */\n    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &reuseaddr, sizeof(int)) == -1) {\n        perror(\"setsockopt\");\n        return 1;\n    }\n```", "```cpp\n    if (bind(sock, res->ai_addr, res->ai_addrlen) == -1) {\n        perror(\"bind\");\n        return 1;\n    }\n\n    if (listen(sock, 1) == -1) {\n        perror(\"listen\");\n        return 1;\n    }\n```", "```cpp\n    while (1) {\n        socklen_t size = sizeof(struct sockaddr_in);\n        struct sockaddr_in their_addr;\n        int newsock = accept(sock, (struct sockaddr*)&their_addr, &size);\n        if (newsock == -1) {\n            perror(\"accept\");\n        }\n        else {\n            printf(\"Got a connection from %s on port %d\\n\",\n                    inet_ntoa(their_addr.sin_addr), htons(their_addr.sin_port));\n            handle(newsock);\n        }\n    }\n```", "```cpp\n    close(sock);\n    return 0;\n}\n```"]