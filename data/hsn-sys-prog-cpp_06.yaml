- en: Learning to Program Console Input/Output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习编程控制台输入/输出
- en: Console IO is essential for any program. It can be used to get user input, provide
    an output, and support debugging and diagnostics. A common cause of program instability
    also generally originates from poorly written IO, which is only exacerbated by
    the overuse of standard C `printf()`/`scanf()` IO functions. In this chapter,
    we will discuss the pros and cons of using C++ IO, commonly referred to as stream-based
    IO, compared to the standard C-style alternatives. In addition, we will provide
    a high-level introduction to C++ manipulators and how they can be used in place
    of standard C-style format strings. We will conclude this chapter with a set of
    examples designed to guide the reader through the use of both `std::cout` and
    `std::cin`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台IO对于任何程序都是必不可少的。它可以用于获取用户输入，提供输出，并支持调试和诊断。程序不稳定的常见原因通常源于IO编写不佳，这只会加剧标准C `printf()`/`scanf()`
    IO函数的滥用。在本章中，我们将讨论使用C++ IO的利弊，通常称为基于流的IO，与标准C风格的替代方法相比。此外，我们将提供一个关于C++操作器的高级介绍，以及它们如何可以用来替代标准C风格的格式字符串。我们将以一组示例结束本章，旨在引导读者如何使用`std::cout`和`std::cin`。
- en: 'The chapter has the following objectives:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有以下目标：
- en: Learning about stream-based IO
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习基于流的IO
- en: User-defined type-manipulators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的类型操作器
- en: An example of echoes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回声的例子
- en: The Serial Echo server example
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行回声服务器示例
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to compile and execute the examples in this chapter, the reader must
    have:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译和执行本章中的示例，读者必须具备：
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够编译和执行C++17的基于Linux的系统（例如，Ubuntu 17.10+）
- en: GCC 7+
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 7+
- en: CMake 3.6+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.6+
- en: An internet connection
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: To download all of the code in this chapter, including the examples and code
    snippets, please see the following GitHub link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter06).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载本章中的所有代码，包括示例和代码片段，请参阅以下GitHub链接：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter06)。
- en: Learning about stream-based IO
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习基于流的IO
- en: In this section, we are going to learn about the basics and some advantages
    and disadvantages of stream-based IO.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习基于流的IO的基础知识以及一些优缺点。
- en: The basics of stream
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流的基础知识
- en: 'Unlike the C-style `printf()` and `scanf()` functions, C++ IO uses streams
    (`std::ostream` for output and `std::istream` for input) that leverage the `<<`
    and `>>` operators. For example, the following code outputs `Hello World` to `stdout`
    using a non-member `<<` overload of `basic_ostream` for `const char *` strings:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与C风格的`printf()`和`scanf()`函数不同，C++ IO使用流（`std::ostream`用于输出，`std::istream`用于输入），利用`<<`和`>>`操作符。例如，以下代码使用`basic_ostream`的非成员`<<`重载将`Hello
    World`输出到`stdout`：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By default, the `std::cout` and `std::wcout` objects, which are instantiations
    of `std::ostream`, output data to the standard C `stdout`, with the only difference
    being that `std::wcout` provides support for Unicode, while `std::cout` provides
    support for ASCII. In addition to several non-member overloads, C++ provides the
    following arithmetic-style member overloads:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`std::cout`和`std::wcout`对象是`std::ostream`的实例，将数据输出到标准C `stdout`，唯一的区别是`std::wcout`支持Unicode，而`std::cout`支持ASCII。除了几个非成员重载外，C++还提供了以下算术风格的成员重载：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These overloads can be used to stream numbers of various types to `stdout`
    or `stderr`. Consider the following example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些重载可以用于将各种类型的数字流到`stdout`或`stderr`。考虑以下例子：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Using `stdin` by default, input is performed via `std::cin` and `std::wcin`.
    Unlike `std::cout`, `std::cin` uses the `>>` stream operator, instead of the `<<`
    stream operator. The following accepts input from `stdin` and outputs the result
    to `stdout`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用`stdin`进行输入，通过`std::cin`和`std::wcin`执行输入。与`std::cout`不同，`std::cin`使用`>>`流操作符，而不是`<<`流操作符。以下接受来自`stdin`的输入并将结果输出到`stdout`：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Advantages and disadvantages of C++ stream-based IO
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++基于流的IO的优缺点
- en: There are many pros and cons to using C++ for IO instead of standard C functions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++进行IO而不是标准C函数有许多优缺点。
- en: Advantages of  C++ stream-based IO
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++基于流的IO的优点
- en: 'C++ streams are generally preferred over the standard C functions that leverage
    format specifiers, because C++ streams are:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，C++流优于使用格式说明符的标准C函数，因为C++流具有以下特点：
- en: Capable of handling user-defined types providing cleaner, type-safe IO
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够处理用户定义的类型，提供更清晰、类型安全的IO
- en: Safer, preventing a larger number of accidental-buffer overflow vulnerabilities
    as not all format-specifier bugs can be detected by the compiler or prevented
    using the `_s` C function variants added to C11
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更安全，可以防止更多的意外缓冲区溢出漏洞，因为并非所有格式说明符错误都可以被编译器检测到或使用C11添加的`_s` C函数变体来预防
- en: Capable of providing implicit memory management, and do not require variadic
    functions
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够提供隐式内存管理，不需要可变参数函数
- en: For these reasons, format specifiers are discouraged by the C++ Core Guidelines
    including functions such as `printf()`, `scanf()`, and others. Although there
    are many advantages to using C++ streams, there are some disadvantages.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，C++核心指南不鼓励使用格式说明符，包括`printf()`、`scanf()`等函数。尽管使用C++流有许多优点，但也有一些缺点。
- en: Disadvantages of C++ stream-based IO
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++基于流的IO的缺点
- en: 'The two most common complaints about C++ streams are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C++流的两个最常见的抱怨如下：
- en: Standard C functions (specifically `printf()`) often outperform C++ streams
    (an issue that largely depends on your operating system and C++ implementation)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准C函数（特别是`printf()`）通常优于C++流（这在很大程度上取决于您的操作系统和C++实现）
- en: Format specifiers are often more flexible than `#include <iomanip>`
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式说明符通常比`#include <iomanip>`更灵活
- en: Although these are typically valid complaints, there are ways to address these
    issues without having to sacrifice the advantages of C++ streams, which we will
    explain in the following sections.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些通常是有效的抱怨，但有方法可以解决这些问题，而不必牺牲C++流的优势，我们将在接下来的部分中解释。
- en: Beginning with user-defined types
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从用户定义的类型开始
- en: 'C++ streams provide the ability to overload the `<<` and `>>` operators for
    user-defined types. This provides the ability to create custom, type-safe IO for
    any data type, including system-level data types, structures, and even more complicated
    types such as classes. For example, the following provides an overload for the
    `<<` stream operator to print an error code provided by a POSIX-style function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: C++流提供了为用户定义的类型重载`<<`和`>>`运算符的能力。这提供了为任何数据类型创建自定义、类型安全的IO的能力，包括系统级数据类型、结构，甚至更复杂的类型，如类。例如，以下提供了对`<<`流运算符的重载，以打印由POSIX风格函数提供的错误代码：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we create an empty class that provides us with a custom type
    and overload the `<<` operator for this custom type. We then use `strerror()`
    to output the error string for `errno` to the provided output stream. Although
    this could be achieved by directly outputting the result of `strerror()` to the
    stream, it demonstrates how user-defined types can be created and used with streams.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个空类，为我们提供了一个自定义类型，并重载了这个自定义类型的`<<`运算符。然后我们使用`strerror()`来输出`errno`的错误字符串到提供的输出流。虽然可以通过直接将`strerror()`的结果输出到流中来实现这一点，但它演示了如何创建并使用流的用户定义类型。
- en: 'In addition to more complicated types, user-defined types can also be leveraged
    by input streams. Consider the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更复杂的类型，用户定义的类型也可以通过输入流进行利用。考虑以下例子：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we create a structure that stores two integers. We then overload
    both the `<<` and `>>` operators for this user-defined type, exercise these overloads
    by reading data into an instance of our type, and then output the results. With
    our overloads, we have instructed both `std::cin` and `std::cout` on how to handle
    the input and output of our user-defined type.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个存储两个整数的结构。然后我们为这个用户定义的类型重载了`<<`和`>>`运算符，通过读取数据到我们类型的实例来练习这些重载，然后输出结果。通过我们的重载，我们已经指示了`std::cin`和`std::cout`如何处理我们用户定义的类型的输入和输出。
- en: Safety and implicit memory management
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全和隐式内存管理
- en: 'Although vulnerabilities are still possible with C++ streams, they are less
    likely compared to their standard C counterparts. The classic example of a buffer
    overflow using the standard C `scanf()` function is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C++流仍然可能存在漏洞，但与它们的标准C对应物相比，这种可能性较小。使用标准C的`scanf()`函数进行缓冲区溢出的经典示例如下：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The buffer being input by the user is larger than the space allocated for this
    buffer, resulting in a buffer overflow situation. Increasing the size of `buf`
    will not solve the problem in this example as the user can always input a string
    larger than the provided buffer. This issue can be addressed by specifying a length
    limit on `scanf()`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入的缓冲区大于为该缓冲区分配的空间，导致缓冲区溢出的情况。在这个例子中增加`buf`的大小不会解决问题，因为用户总是可以输入一个比提供的缓冲区更大的字符串。这个问题可以通过在`scanf()`上指定长度限制来解决：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we provide the size of `buf` to the `scanf()` function, preventing the
    buffer overflow. The problem with this approach is the size of `buf` is declared
    twice. If only one of these is changed, a buffer overflow could be reintroduced.
    C-style macros could be used to address this issue, but the decoupling of the
    buffer and its size is still present.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向`scanf()`函数提供了`buf`的大小，防止了缓冲区溢出。这种方法的问题是`buf`的大小声明了两次。如果这两者中的一个改变了，就可能重新引入缓冲区溢出。可以使用C风格的宏来解决这个问题，但缓冲区和其大小的解耦仍然存在。
- en: 'Although there are other ways to solve this using C, one way to address the
    preceding issues with C++ is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然还有其他方法可以用C来解决这个问题，但解决C++中前面提到的问题的一种方法如下：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Instead of using a `*` char, we create a user-defined type that encapsulates
    a `*` char and its length. The total size of the buffer is coupled with the buffer
    itself, preventing accidental buffer overflows. Still, if memory-allocation is
    allowed (which is not always the case when programming systems, we can do better:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用`*` char，而是创建一个封装`*` char及其长度的用户定义类型。缓冲区的总大小与缓冲区本身耦合在一起，防止意外的缓冲区溢出。然而，如果允许内存分配（在编程系统中并非总是如此），我们可以做得更好：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we use `std::string` to store the input from `std::cin`. The
    difference here is that `std::string` dynamically allocates memory as needed to
    store the input, preventing a possible buffer overflow. If more memory is needed,
    more memory is allocated or `std::bad_alloc` is thrown and the program aborts.
    User-defined types with C++ streams provide safer mechanisms for handling IO.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`std::string`来存储从`std::cin`输入的内容。这里的区别在于`std::string`根据需要动态分配内存来存储输入，防止可能的缓冲区溢出。如果需要更多的内存，就分配更多的内存，或者抛出`std::bad_alloc`并中止程序。C++流的用户定义类型提供了更安全的处理IO的机制。
- en: Common debugging patterns
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的调试模式
- en: 'In programming systems, one of the main uses of console output is debugging.
    C++ streams provide two different global objects—`std::cout` and `std::cerr`.
    The first option, `std::cout`, is typically buffered, sent to `stdout`, and only
    flushed when either `std::flush` or `std::endl` is sent to the stream. The second
    option, `std::cerr`, provides the same functionality as `std::cout`, but is sent
    to `stderr` instead of `stdout`, and is flushed on every call to the global object.
    Take a look at the following example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程系统中，控制台输出的主要用途之一是调试。C++流提供了两个不同的全局对象——`std::cout`和`std::cerr`。第一个选项`std::cout`通常是缓冲的，发送到`stdout`，并且只有在发送到流的`std::flush`或`std::endl`时才会刷新。第二个选项`std::cerr`提供了与`std::cout`相同的功能，但是发送到`stderr`而不是`stdout`，并且在每次调用全局对象时都会刷新。看一下以下的例子：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For this reason, error logic is usually sent to `stderr` using `std::cerr` to
    ensure all error console output is received in the event of a catastrophic issue.
    Likewise, general output, including debug logic is sent to `stdout` using `std::cout`
    to take advantage of buffering to speed up console output, and `'\n'` is used
    to send a newline instead of `std::endl` unless an explicit flush is required.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，错误逻辑通常使用`std::cerr`发送到`stderr`，以确保在发生灾难性问题时接收所有错误控制台输出。同样，一般输出，包括调试逻辑，使用`std::cout`发送到`stdout`，以利用缓冲加快控制台输出速度，并且使用`'\n'`发送换行而不是`std::endl`，除非需要显式刷新。
- en: 'The following shows a typical pattern in C for debugging:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是C语言中调试的典型模式：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If debugging is enabled, which usually means that `NDEBUG` is defined, the
    `DEBUG` macro can be used to send debug statements to the console. `NDEBUG` is
    used because this is the macro that is defined when most compilers are set to
    Release mode, disabling `assert()` in standard C. Another common debugging pattern
    is to provide the debug macro with a debug level that allows the developer to
    dial in how verbose the program is while debugging:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了调试，通常意味着定义了`NDEBUG`，则可以使用`DEBUG`宏将调试语句发送到控制台。使用`NDEBUG`是因为这是大多数编译器设置为发布模式时定义的宏，禁用了标准C中的`assert()`。另一个常见的调试模式是为调试宏提供调试级别，允许开发人员在调试时调整程序的详细程度：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The problem with this logic is the overuse of macros to achieve debugging,
    a pattern that is discouraged by the C++ Core Guidelines ([https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-macros2](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-macros2)).
    A simple approach to debugging with C++17 is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种逻辑的问题在于过度使用宏来实现调试，这是C++核心指南不赞成的模式。使用C++17进行调试的简单方法如下：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Even with C++17, some macro logic is needed to handle the `NDEBUG` macro that
    is provided by the compiler when debugging is enabled. In this example, the `NDEBUG`
    macro is converted into `constexpr`, which is then used in the source code to
    handle debugging. A debug level can also be implemented using the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用了C++17，仍然需要一些宏逻辑来处理启用调试时编译器提供的`NDEBUG`宏。在这个例子中，`NDEBUG`宏被转换为`constexpr`，然后在源代码中用于处理调试。调试级别也可以使用以下方式实现：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since changing the debug level is a compile-time feature in this example, it
    would be passed to the compiler using `-DDEBUG_LEVEL=xxx`, and as such, still
    requires macro logic to convert the C macro into a C++ `constexpr`. As can be
    seen in this example, the C++ implementation is far more complicated than a simple
    `DEBUG` macro that leverages `fprintf()` and friends. To overcome this complexity,
    we will leverage encapsulation, without sacrificing compile-time optimizations:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这个例子中调试级别是一个编译时特性，它将使用`-DDEBUG_LEVEL=xxx`传递给编译器，因此仍然需要宏逻辑将C宏转换为C++的`constexpr`。正如在这个例子中所看到的，C++实现比利用`fprintf()`和其他函数的简单`DEBUG`宏要复杂得多。为了克服这种复杂性，我们将利用封装，而不会牺牲编译时优化：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example, the debug logic is encapsulated into a `constexpr` function
    that takes a Lambda. The debug level is defined using a template parameter to
    maintain constancy. Unlike the typical standard C debugging pattern, this implementation
    will accept any debug logic that can fit into a `void(*func)()` function or lambda
    and, like the standard C version, will be compiled out and removed when the compiler
    is set to Release mode (that is, when `NDEBUG` is defined, and typically optimizations
    are enabled). To show this, GCC 7.3 outputs the following when Release mode is
    enabled:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，调试逻辑被封装为一个接受Lambda的`constexpr`函数。调试级别使用模板参数来保持常数。与典型的标准C调试模式不同，这个实现将接受任何适合于`void(*func)()`函数或lambda的调试逻辑，并且与标准C版本一样，在编译器设置为发布模式时将被编译和移除（即定义了`NDEBUG`并且通常启用了优化）。为了证明这一点，当启用发布模式时，GCC
    7.3输出如下内容：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'GCC 7.3 outputs the following when `#undef NDEBUG` is added to the source code
    (ensuring the only difference is the debug logic is disabled, but the compile
    flags remain the same):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当在源代码中添加`#undef NDEBUG`时，GCC 7.3输出如下内容（确保唯一的区别是调试逻辑被禁用，但编译标志保持不变）：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The extra 288 bytes come from the debug logic that is completely removed by
    the compiler thanks to the constancy observed by the additions of `constexpr`
    to C++17, providing a cleaner approach to debugging, without the need for the
    extensive use of macros.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的288字节来自于调试逻辑，这些逻辑完全被编译器移除，这要归功于C++17中`constexpr`的常数性，提供了一种更清晰的调试方法，而无需大量使用宏。
- en: 'Another common debugging pattern is to include both the current line number
    and the filename into debugging statements for additional context. The `__LINE__` and
    `__FILE__` macros are used to provide this information. Sadly, without the Source
    Location TS ([http://en.cppreference.com/w/cpp/experimental/source_location](http://en.cppreference.com/w/cpp/experimental/source_location)),
    which was not included in C++17, there is no way to provide this information without
    these macros and the inclusion of something like the following pattern:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的调试模式是在调试语句中包含当前行号和文件名，以提供额外的上下文。`__LINE__`和`__FILE__`宏用于提供这些信息。遗憾的是，在C++17中没有包含源位置TS，因此没有办法在没有这些宏的情况下提供这些信息，也没有类似以下模式的包含：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this example, the `DEBUG` macro automatically inserts the file name and
    line number into the standard C-style `fprintf()` function. This works because
    wherever the compiler sees the `DEBUG` macro, it inserts `fprintf(stdout, "%s
    [%d]: " fmt, __FILE__, __LINE__, args);`, and then must evaluate the line and
    file macros, resulting in the expected output. One example of how to convert this
    same pattern to our existing C++ example is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，`DEBUG`宏会自动将文件名和行号插入标准C风格的`fprintf()`函数中。这是因为无论编译器在哪里看到`DEBUG`宏，它都会插入`fprintf(stdout,
    "%s [%d]: " fmt, __FILE__, __LINE__, args);`，然后必须评估行和文件宏，从而产生预期的输出。将这种模式转换为我们现有的C++示例的一个例子如下：'
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Instead of using `std::cout` in our debug lambdas, we add a console macro that
    uses `std::cout`, but also adds the file name and line number to the debug statement
    to provide the same functionality as the standard C version. Unlike the standard
    C version, an additional C macro function is not needed as the console macro will
    properly provide the file name and line number where used.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的调试lambda中，我们不再使用`std::cout`，而是添加一个使用`std::cout`的控制台宏，但也将文件名和行号添加到调试语句中，以提供与标准C版本相同的功能。与标准C版本不同的是，不需要额外的C宏函数，因为控制台宏将正确提供使用的文件名和行号。
- en: Finally, to complete our C++17 debugging patterns, we add a debug, warning,
    and fatal version of the preceding example with color, and an overload for the
    `fatal` function that defaults to exiting with `-1` on error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了完成我们的C++17调试模式，我们添加了一个带颜色的调试、警告和致命错误版本的前面示例，并为`fatal`函数添加了一个默认退出错误码为`-1`的重载版本。
- en: 'To start, we leverage the same standard C macros as used in the preceding code
    snippets:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们利用与前面代码片段中相同的标准C宏：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'These macros convert standard C-style macros, which are needed for command-line
    compatibility, to C++-style constant expressions. Next, we create a template function
    called `debug`, capable of accepting a lambda function. This `debug` function
    first outputs a green colored `debug` to `stdout`, and then executes the lambda
    function, if (and only if) debugging is enabled and the debugging level matches
    that which was provided to the `debug` function itself. If debugging is not enabled,
    the `debug` function is compiled without impacting the size of the program, or
    its performance:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏将标准C风格的宏转换为C++风格的常量表达式，这些宏在命令行兼容性中是必需的。接下来，我们创建一个名为`debug`的模板函数，能够接受一个lambda函数。这个`debug`函数首先将绿色的`debug`输出到`stdout`，然后执行lambda函数，只有在调试被启用并且调试级别与提供给`debug`函数本身的级别匹配时才执行。如果调试未启用，`debug`函数将在不影响程序大小或性能的情况下编译。
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This same `debug` function is repeated to provide a warning, and a fatal version
    of this function, with the only difference being color (which is platform-specific,
    and in this case is intended for UNIX operating systems), and the `fatal` function
    exits the program after the lambda function is executed with either a user-defined
    error code or `-1`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相同的`debug`函数被重复使用来提供警告和致命错误版本的函数，唯一的区别是颜色（这是特定于平台的，在这种情况下是为UNIX操作系统设计的），而`fatal`函数在执行lambda函数后退出程序，退出时使用用户定义的错误码或`-1`。
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, these debugging patterns are exercised in a `main()` function to demonstrate
    how they can be used:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这些调试模式在`main()`函数中得到了应用，以演示它们的使用方法。
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Performance of C++ streams
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++流的性能
- en: 'A common complaint about C++ streams is performance, a problem that has largely
    been mitigated over the years. To ensure C++ streams perform at their best, there
    are some optimizations that can be applied:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C++流的一个常见抱怨是性能问题，这个问题在多年来已经得到了很大的缓解。为了确保C++流的最佳性能，可以应用一些优化：
- en: '**Disable std::ios::sync_with_stdio:** C++ streams by default synchronize themselves
    with standard C functions, such as `printf()` and others. If these functions are
    not being used, this synchronization feature should be disabled as it will result
    in a noticeable improvement in performance.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁用 std::ios::sync_with_stdio**：C++流默认会与标准C函数（如`printf()`等）同步。如果不使用这些函数，应该禁用这个同步功能，因为这将显著提高性能。'
- en: '**Avoid flushing**: Where possible, avoid flushing C++ streams and let `libc++`
    and the OS handle flushing for you. This includes not using `std::flush`, and
    using `''\n''` instead of `std::endl`, which flushes after it outputs a newline.
    When flushing is avoided, all output is buffered for you, reducing the number
    of calls to the OS to deliver the output.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免刷新**：在可能的情况下，避免刷新C++流，让`libc++`和操作系统来处理刷新。这包括不使用`std::flush`，而是使用`''\n''`代替`std::endl`，后者在输出换行后会刷新。避免刷新时，所有输出都会被缓冲，减少了向操作系统传递输出的次数。'
- en: '**Use std::cout and std::clog instead of std::cerr**: For the same reason,
    `std::cerr` will flush on destruction, increasing the number of times the OS is
    delivered output. When possible, `std::cout` should be used, with `std::cerr`
    only being used for fatal errors followed by control-flow changes, such as exits,
    exceptions, assertions, and possible crashes.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用std::cout 和std::clog而不是std::cerr**：出于同样的原因，`std::cerr`在销毁时会刷新，增加了操作系统传递输出的次数。在可能的情况下，应该使用`std::cout`，只有在出现致命错误后才使用`std::cerr`，例如退出、异常、断言和可能的崩溃。'
- en: It's impossible to provide a general answer to the question, *Which is faster,*
    `printf()` *or* `std::cout`*?*But in practice, if the preceding optimizations
    are used, `std::cout` can often outperform standard C `printf()`, but this is
    highly dependent on your environment and use case.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于问题“*哪个更快*，`printf()` *还是* `std::cout`*？*”，不可能提供一个一般性的答案。但实际上，如果使用了前面的优化，`std::cout`通常可以优于标准C的`printf()`，但这高度依赖于您的环境和用例。
- en: 'In addition to the preceding example, one way to avoid unwanted flushing to
    increase performance is to use `std::stringstream` instead of `std::cout`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的例子，避免不必要的刷新以提高性能的一种方法是使用`std::stringstream`而不是`std::cout`。
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'By using `std::stringstream`, all output is directed to your controlled buffer
    until you are ready to send the output to the OS via `std::cout` and manual flushing.
    This can also be used to buffer output to `std::cerr`, reducing the total number
    of flushes. Another way to avoid flushing is to use `std::clog`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`std::stringstream`，所有输出都被定向到您控制的缓冲区，直到您准备通过`std::cout`和手动刷新将输出发送到操作系统。这也可以用于缓冲输出到`std::cerr`，减少总刷新次数。避免刷新的另一种方法是使用`std::clog`：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`std::clog` operates like `std::cout`, but instead of sending output to `stdout`,
    `std::clog` sends output to `stderr`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::clog`的操作方式类似于`std::cout`，但是不是将输出发送到`stdout`，而是将输出发送到`stderr`。'
- en: Learning about manipulators
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习操纵器
- en: 'C++ streams have several different manipulators that may be used to control
    both input and output, some of which have already been discussed. The most common
    manipulator is `std::endl`, which outputs a newline and then flushes the output
    stream:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: C++流有几种不同的操纵器，可以用来控制输入和输出，其中一些已经讨论过。最常见的操纵器是`std::endl`，它输出一个换行符，然后刷新输出流：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Another way to write this same logic is to use the `std::flush` manipulator:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 编写相同逻辑的另一种方法是使用`std::flush`操纵器：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Both are the same, although `''\n''` should always be used unless a flush is
    explicitly needed. For example, if multiple lines are needed, the following is
    preferred:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 两者是相同的，尽管除非明确需要刷新，否则应始终使用`'\n'`。例如，如果需要多行，应首选以下方式：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Compared to the preceding code, the following is not preferred:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的代码相比，以下代码不是首选：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It should be noted that the trailing flush is not needed, as `::exit()` flushes
    `stdout` on exit for you, which is called when main completes.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，不需要尾随刷新，因为`::exit()`在`main`完成时会为您刷新`stdout`。
- en: 'A common manipulator that is set at the beginning of any program is `std::boolalpha`,
    which causes Booleans to be outputted as `true` or `false` instead of `1` or `0`
    (with `std::noboolalpha` providing the inverse, which is also the default):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何程序开始时设置的常见操纵器是`std::boolalpha`，它导致布尔值输出为`true`或`false`，而不是`1`或`0`（`std::noboolalpha`提供相反的效果，这也是默认值）：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Another common set of manipulators is numeric base manipulators—`std::hex`,
    `std::dec`, and `std::oct`. These manipulators are similar to `%d`, `%x`, and
    `%o` used by standard C-format specifiers (for example, those used by `printf()`).
    Unlike the standard C versions, these manipulators are global, and thus should
    be used with caution, especially in libraries. To use these manipulators, simply
    add them to the stream prior to adding a number for the desired base:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组常见的操纵器是数字基操纵器——`std::hex`、`std::dec`和`std::oct`。这些操纵器类似于标准C格式说明符（例如`printf()`使用的`%d`、`%x`和`%o`）。与标准C版本不同，这些操纵器是全局的，因此在库中使用时应谨慎使用。要使用这些操纵器，只需在添加所需基数的数字之前将它们添加到流中：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first number, `42`, is printed as `42` as no numeric base-manipulators have
    been used yet. The second number is printed as `2a` as the `std::hex` manipulator
    was used resulting in `2a` as that is the hex value for `42`. The third number
    that is printed is also `2a` as numeric base manipulators are global and thus,
    even though `std::cout` is called a second time, the stream is still told to use
    hex values instead of decimal. This pattern continues for both `std::dec` (for
    example, decimal numbers) and `std::oct` (for example, octal numbers), resulting
    in `42`, `2a`, `2a`, `42`, `42`, and finally `52`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数字`42`打印为`42`，因为尚未使用任何数字基操纵器。第二个数字打印为`2a`，因为使用了`std::hex`操纵器，导致`2a`是`42`的十六进制值。打印的第三个数字也是`2a`，因为数字基操纵器是全局的，因此，即使第二次调用`std::cout`，流仍然被告知使用十六进制值而不是十进制值。这种模式对于`std::dec`（例如，十进制数）和`std::oct`（例如，八进制数）都是一样的，结果是`42`、`2a`、`2a`、`42`、`42`，最后是`52`。
- en: 'It is also possible to use the uppercase version of `std::hex` instead of the
    default, lowercase version seen in the previous example. To accomplish this, use `std::uppercase` and `std::nouppercase` (`std::uppercase` shows
    alphanumeric characters in uppercase while `std::nouppercase` does not, which
    is the default):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`std::hex`的大写版本，而不是前面示例中看到的默认小写版本。要实现这一点，使用`std::uppercase`和`std::nouppercase`（`std::uppercase`显示大写字母数字字符，而`std::nouppercase`不显示，这是默认值）：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, instead of `42` being outputted as `2a`, it was outputted as
    `2A`, with the alphanumeric characters being uppercase.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`42`不再输出为`2a`，而是输出为`2A`，其中字母数字字符是大写的。
- en: 'Typically, especially with respect to programming systems, hexadecimal and
    octal numbers are printed with their base identifiers (for example, `0x` and `0`).
    To accomplish this, use the `std::showbase` and `std::noshowbase` manipulators
    (`std::showbase` shows the base while `std::noshowbase` does not, which is the
    default):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，特别是在编程系统方面，十六进制和八进制数以它们的基数标识符（例如`0x`和`0`）打印。要实现这一点，使用`std::showbase`和`std::noshowbase`操纵器（`std::showbase`显示基数，`std::noshowbase`不显示，这是默认值）：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As seen from this example, `std::hex` now outputs `0x2a` instead of `2a`, and
    `std::oct` outputs `052` instead of `52`, while `std::dec` continues to output
    `42` as expected (since decimal numbers do not have base identifiers). Unlike
    numbers, pointers always output in hexadecimal, lowercase, and with their base
    being shown, and `std::uppercase`, `std::noshowbase`, `std::dec`, and `std::oct`
    do not affect the output. One solution to this problem is to cast the pointer
    to a number, and then the preceding manipulators may be used as shown in the following
    example, but this type of logic is discouraged by the C++ Core Guidelines since `reinterpret_cast`
    is required, which is frowned upon:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以看出，`std::hex`现在输出`0x2a`，而不是`2a`，`std::oct`输出`052`，而不是`52`，而`std::dec`继续按预期输出`42`（因为十进制数没有基数标识符）。与数字不同，指针始终以十六进制、小写形式输出，并显示它们的基数，`std::uppercase`、`std::noshowbase`、`std::dec`和`std::oct`不会影响输出。解决这个问题的一个方法是将指针转换为数字，然后可以使用前面的操纵器，如下例所示，但是C++核心指南不鼓励这种逻辑，因为需要使用`reinterpret_cast`：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'One issue with outputting pointers is that their total length (that is, the
    total number of characters) changes from pointer to pointer. This can often be
    distracting when outputting several pointers at the same time, as their base modifiers
    are likely not to match up. To overcome this, `std::setw` and `std::setfill` may
    be used. `std::setw` sets the total width (that is, the total number of characters)
    in the next output. If the next output is not at least the size of the value passed
    to `std::setw`, the stream will automatically add spaces to the stream:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出指针的一个问题是它们的总长度（即字符的总数）会从一个指针变化到另一个指针。当同时输出多个指针时，这通常会分散注意力，因为它们的基本修改器可能不匹配。为了克服这一点，可以使用`std::setw`和`std::setfill`。`std::setw`设置下一个输出的总宽度（即字符的总数）。如果下一个输出的大小不至少是传递给`std::setw`的值的大小，流将自动向流中添加空格：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this example, the width is set to `18`. Since the next addition to the stream
    is two characters (from the number `42`), `16` total spaces are added prior to
    adding `42` to the stream. To change the characters that are added to the stream
    by `std::setw`, use `std::setfill`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，宽度设置为`18`。由于流的下一个添加是两个字符（来自数字`42`），在将`42`添加到流之前添加了`16`个空格。要更改由`std::setw`添加到流中的字符，请使用`std::setfill`：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As can be seen, instead of spaces being added to the stream (which is the default),
    `''0''` characters are added to the stream. The direction of the characters being
    added to the stream can be controlled using `std::left`, `std::right`, and `std::internal`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，流中添加的不是空格（默认情况下），而是添加到流中的'0'字符。可以使用`std::left`，`std::right`和`std::internal`来控制添加到流中的字符的方向：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`std::left` first outputs to the stream, and then fills in the stream with
    the remaining characters, while `std::right` fills in the stream with unused characters,
    and then outputs to the stream. `std::internal` is specific to text that uses
    base identifiers such as `std::hex` and `std::oct` with `std::showbase` or pointers
    that automatically show the base identifier, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::left`首先输出到流中，然后用剩余的字符填充流，而`std::right`用未使用的字符填充流，然后输出到流中。`std::internal`特定于使用基本标识符（如`std::hex`和`std::oct`）的文本以及使用`std::showbase`或自动显示基本标识符的指针。'
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Often, especially in libraries, it can be useful to set some manipulators,
    and then restore the stream to its original state. For example, if you''re writing
    a library and you want to output a number in `hex`, you would need to use the
    `std::hex` manipulator, but doing so would cause all of the numbers your user
    outputs from that point on to also be outputted in `hex`. The problem is, you
    cannot simply use `std::dec` to set the stream back to decimal because the user
    might actually be using `std::hex` in the first place. One way to deal with this
    issue is to use the `std::cout.flags()` function, which allows you to both get
    and set the stream''s internal flags:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，特别是在库中，设置一些操纵器然后将流恢复到其原始状态是有用的。例如，如果您正在编写一个库，并且想要以`hex`输出一个数字，您需要使用`std::hex`操纵器，但这样做会导致从那时起用户输出的所有数字也以`hex`输出。问题是，您不能简单地使用`std::dec`将流设置回十进制，因为用户可能实际上是首先使用`std::hex`。解决这个问题的一种方法是使用`std::cout.flags()`函数，它允许您获取和设置流的内部标志：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In general, all of the manipulators that have been discussed, as well as some
    others, can be enabled/disabled using the `std::cout.flags()` function, and the
    manipulators discussed are simply wrappers around this function to reduce verbosity.
    Although this function can be used to configure the manipulators (which should
    be avoided), the `std::cout.flags()` function is a convenient way to restore the
    manipulators after the stream has been changed. It should also be noted that the
    preceding methods work for all of the streams, not just `std::cout`. One way to
    simplify restoring the manipulators is to use a little functional programming,
    and wrap a user function with the save/restore logic, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，所有已经讨论过的操纵器以及其他一些操纵器都可以使用`std::cout.flags()`函数启用/禁用，所讨论的操纵器只是这个函数的包装器，以减少冗长。虽然这个函数可以用来配置操纵器（应该避免），`std::cout.flags()`函数是在流被更改后恢复操纵器的便捷方法。还应该注意，前面的方法适用于所有流，而不仅仅是`std::cout`。简化恢复操纵器的一种方法是使用一些函数式编程，并用保存/恢复逻辑包装用户函数，如下所示：
- en: '[PRE40]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this example, we wrap the use of `std::cout` in `cout_transation`. This wrapper
    stores the current state of the manipulators, calls the user-provided function
    (which changes the manipulators), and then restores the manipulators prior to
    completing. As a result, the manipulators are unaffected after the completion
    of the transaction, which means the second `std::cout` in this example outputs
    `42` instead of `0x2a`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`std::cout`的使用包装在`cout_transation`中。这个包装器存储操纵器的当前状态，调用用户提供的函数（改变操纵器），然后在完成之前恢复操纵器。结果是，事务完成后操纵器不受影响，这意味着这个例子中的第二个`std::cout`输出`42`而不是`0x2a`。
- en: 'Finally, to simplify the use of manipulators, it can sometimes be useful to
    create your own user-defined manipulators that can encapsulate your custom logic:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了简化操纵器的使用，有时创建自定义的用户定义操纵器可以封装自定义逻辑是很有用的：
- en: '[PRE41]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As can be seen from this example, by simply using `usr::hex` instead of `std::hex`,
    `42` is outputted using `std::hex`, `std::showbase`, `std::internal`, `std::setfill('0')`,
    and `std::setw(18)`, reducing verbosity and simplifying multiple uses of this
    same logic.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子可以看出，只需使用`usr::hex`而不是`std::hex`，就可以使用`std::hex`，`std::showbase`，`std::internal`，`std::setfill('0')`和`std::setw(18)`输出`42`，减少冗长并简化对相同逻辑的多次使用。
- en: Recreating the echo program
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新创建echo程序
- en: 'In this hands-on example, we will be recreating the popular echo program found
    on almost all `POSIX` systems. The echo program takes all of the input provided
    to the program and echoes it back to `stdout`. This program is very simple, with
    the following program options:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实际例子中，我们将重新创建几乎所有`POSIX`系统上都可以找到的流行的echo程序。echo程序接受程序提供的所有输入并将其回显到`stdout`。这个程序非常简单，具有以下程序选项：
- en: '`-n`: Prevents echo from outputting a newline on exit'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -n：防止echo在退出时输出换行符
- en: '`--help`: Prints the Help menu'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--help`：打印帮助菜单'
- en: '`--version`: Prints some version information'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--version`：打印一些版本信息'
- en: There are two other options, `-e` and `-E`; we have omitted them here to keep
    things simple, but, if desired, would serve as a unique exercise for the reader.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个选项，`-e`和`-E`；我们在这里省略了它们，以保持简单，但如果需要，可以作为读者的一个独特练习。
- en: To see the full sources for this example, please see the following: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter06/example1.cpp](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter06/example1.cpp).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此示例的完整源代码，请参见以下链接：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter06/example1.cpp](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter06/example1.cpp)。
- en: 'The `main` function presented here is a useful pattern to add to all programs
    and deviates slightly from the original echo program as exceptions (which are
    highly unlikely in this example) could generate error messages not seen in the
    original echo program; however, it is still useful:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此处呈现的`main`函数是一个有用的模式，与原始的echo程序略有不同，因为异常（在本例中极不可能）可能会生成原始echo程序中看不到的错误消息；但是，它仍然很有用：
- en: '[PRE42]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The goal of this logic is to catch any exceptions prior to the program exiting
    and outputting the exception description to `stderr` before exiting with a failure
    status.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此逻辑的目标是在程序退出之前捕获任何异常，并在退出之前将异常描述输出到`stderr`。
- en: 'Consider the following example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding code catches all `std::exceptions` and outputs a catch exception's
    description (that is, `e.what()`) to `stderr`. Note that `std::cerr` is used here (instead
    of `std::clog`) just in case the use of exceptions generates instability, ensuring
    a flush occurs. When using error-handling logic, it's always better to be on the
    safe side and ensure all debugging output is delivered with performance being
    a secondary concern.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码捕获所有`std::exceptions`并将捕获的异常描述（即`e.what()`）输出到`stderr`。请注意，这里使用的是`std::cerr`（而不是`std::clog`），以防异常的使用会导致不稳定性，确保发生刷新。在使用错误处理逻辑时，最好始终保持谨慎，并确保所有调试输出都以性能为次要考虑因素进行。
- en: 'Consider the following example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding code catches all unknown exceptions, which in this program should
    almost certainly never happen, and was added purely for completeness:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码捕获所有未知异常，在本程序中几乎肯定永远不会发生，并且纯粹是为了完整性而添加：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `try` block attempts to execute the `protected_main()` function, and if
    it fails with an exception, executes the `catch` blocks as described previously;
    otherwise, it returns from the `main` function, ultimately exiting the program.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`块尝试执行`protected_main()`函数，如果出现异常，则执行先前描述的`catch`块；否则，从`main`函数返回，最终退出程序。'
- en: 'The goal of the `protected_main()` function is to parse the arguments provided
    to the program, and handle each argument as expected:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected_main()`函数的目标是解析程序提供的参数，并按预期处理每个参数：'
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here is the first line:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第一行：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It is used to control whether a newline is added to `stdout` on exit, just
    like the original echo program, and is controlled by the `-n` program argument.
    Here is the next line:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于控制是否在退出时向`stdout`添加换行符，就像原始的echo程序一样，并由`-n`程序参数控制。以下是下一行：
- en: '[PRE48]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding code converts the standard C `argv` and `argc` arguments into
    a C++ GSL span, allowing us to safely process the program arguments in a C++-Core-Guideline-compliant
    fashion. The span is nothing more than a list (specifically, it is very similar
    to `std::array`), with the bounds of this list being checked each time we access
    the list (unlike `std::array`). If our code attempts to access an argument that
    doesn't exist, an exception will be thrown, and the program will safely exit with
    an error code, telling us via `stderr` that we attempted to access an element
    in the list that does not exist (via the `try`/`catch` logic in the `main` function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将标准C `argv`和`argc`参数转换为C++ GSL span，使我们能够以符合C++核心指南的方式安全地处理程序参数。该span只不过是一个列表（具体来说，它与`std::array`非常相似），每次访问列表时都会检查此列表的边界（不像`std::array`）。如果我们的代码尝试访问不存在的参数，将抛出异常，并且程序将以错误代码安全退出，通过`stderr`告诉我们尝试访问不存在的列表元素（通过`main`函数中的`try`/`catch`逻辑）。
- en: 'Here is the next part:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是下一部分：
- en: '[PRE49]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It loops through each argument in the list. Normally, we would loop through
    each element in a list using the ranged `for` syntax:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它循环遍历列表中的每个参数。通常，我们会使用范围`for`语法循环遍历列表中的每个元素：
- en: '[PRE50]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: But this syntax cannot be used because the first argument in the argument list
    is always the program name, and in our case should be ignored. For this reason,
    we start from `1` (instead of `0`) as can be seen previously, and then we loop
    through the remaining elements in the list. The second line in this snippet creates
    `cstring_span{}` from each program argument in the list. `cstring_span{}` is nothing
    more than a standard C-style string wrapped in a GSL span to protect any accesses
    to the string to make C-style string access C++-Core-Guideline-compliant. This
    wrapper will later be used to compare the string to look for our program options,
    such as `-n`, `--help`, and `--version`, in a safe and compliant way. The `ensure_z()`
    function ensures that the string is complete, preventing possible unwanted corruption.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，不能使用此语法，因为参数列表中的第一个参数始终是程序名称，在我们的情况下应该被忽略。因此，我们从`1`开始（而不是`0`），如前所述，然后循环遍历列表中的其余元素。此片段中的第二行从列表中的每个程序参数创建`cstring_span{}`。`cstring_span{}`只不过是一个标准的C风格字符串，包装在GSL
    span中，以保护对字符串的任何访问，使C风格字符串访问符合C++核心指南。稍后将使用此包装器来比较字符串，以安全和符合规范的方式查找我们的程序选项，例如`-n`，`--help`和`--version`。`ensure_z()`函数确保字符串完整，防止可能的意外损坏。
- en: 'The next step is to compare each argument to the list of arguments we plan
    to support:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将每个参数与我们计划支持的参数列表进行比较：
- en: '[PRE51]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since we are using `cstring_span{}` instead of a standard C-style string, we
    can directly compare the argument to the `"-n"` literal string safely without
    having to use an unsafe function such as `strcmp()`, or direct character comparisons,
    which is what the original echo implementation does (and since we only support
    one single character option, performance is the same). If the argument is `-n`,
    we instruct our implementation that no newline should be added to `stdout` when
    the program exits by setting `endl` to `false`, and then we continue looping through
    the arguments until they are all processed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`cstring_span{}`而不是标准的C风格字符串，我们可以安全地直接将参数与`"-n"`字面字符串进行比较，而无需使用不安全的函数（如`strcmp()`）或直接字符比较，这是原始echo实现所做的（由于我们只支持一个单个字符选项，性能是相同的）。如果参数是`-n`，我们指示我们的实现在程序退出时不应向`stdout`添加换行符，通过将`endl`设置为`false`，然后我们继续循环处理参数，直到它们全部被处理。
- en: 'Here are the next two blocks of code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是接下来的两个代码块：
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: They check whether the arguments are `--help` or `--version`. If either of these
    is provided by the user, a special `handle_help()` or `handle_version()` function
    is executed. It should be noted that `handle_xxx()` functions exit the program
    when they are done, so no further logic is needed and it should be assumed that
    these functions never return (as the program exits).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 它们检查参数是否为`--help`或`--version`。如果用户提供了其中任何一个，将执行特殊的`handle_help()`或`handle_version()`函数。需要注意的是，`handle_xxx()`函数在完成时退出程序，因此不需要进一步的逻辑，并且应该假定这些函数永远不会返回（因为程序退出）。
- en: 'At this point, all of the optional arguments have been processed. All other
    arguments should be outputted to `stdout`, just like the original echo program.
    The problem is that the user could provide more than one argument that they wish
    to be outputted to `stdout`. Consider the following example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，所有可选参数都已处理。所有其他参数应该像原始的echo程序一样输出到`stdout`。问题在于用户可能提供多个希望输出到`stdout`的参数。考虑以下例子：
- en: '[PRE53]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this example, the user has provided two arguments—`Hello` and `World`. The
    expected output is `Hello World` (with a space), not `HelloWorld` (without a space),
    and some additional logic is needed to ensure that a space is outputted to `stdout`
    as needed.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，用户提供了两个参数——`Hello`和`World`。预期输出是`Hello World`（有一个空格），而不是`HelloWorld`（没有空格），需要一些额外的逻辑来确保根据需要将空格输出到`stdout`。
- en: 'Here is the next block:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是下一个代码块：
- en: '[PRE54]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This outputs a space to `stdout` after the first argument has already been outputted,
    but right before the next argument is about to be outputted (and all remaining
    arguments). It does this because `num` starts as `0` (and `0` is equal to `0`,
    not greater than `0`, and thus the space is not outputted on the first argument),
    and then `num` is incremented. When the next argument is processed, `num` is `1`
    (or larger) which is greater than `0`, and thus the space is added to `stdout`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这在第一个参数已经输出后向`stdout`输出一个空格，但在下一个参数即将输出之前（以及所有剩余的参数）。这是因为`num`开始为`0`（`0`等于`0`，而不是大于`0`，因此在第一个参数上不会输出空格），然后`num`被递增。当处理下一个参数时，`num`为`1`（或更大），大于`0`，因此空格被添加到`stdout`。
- en: 'Finally, the argument is added to `stdout` by providing `std::cout` with the
    argument''s data, which is nothing more than the unsafe, standard C version of
    the argument that `std::cout` can safely handle for us:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过向`std::cout`提供参数的数据，将参数添加到`stdout`，这只是`std::cout`可以安全处理的参数的不安全的标准C版本：
- en: '[PRE55]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The last block in the `protected_main()` function is:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected_main()`函数中的最后一个代码块是：'
- en: '[PRE56]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'By default, `endl` is `true`, and thus a newline is added to `stdout` before
    the program exits. If, however, the user had provided `-n`, then `endl` would
    have been set to `false` by  the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`endl`是`true`，因此在程序退出之前会向`stdout`添加一个换行符。然而，如果用户提供了`-n`，那么`endl`将被设置为`false`。
- en: '[PRE57]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding code, the program would exit without adding the newline to
    `stdout`. If `--help` was provided by the user, the `handle_help()` function would
    be executed as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，如果用户提供了`--help`，则会执行`handle_help()`函数如下：
- en: '[PRE58]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This function outputs the Help menu to `stdout` using `std::cout`, and then
    exits the program successfully. The `handle_version()` function does the same
    thing if `--version` is provided by the user:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用`std::cout`将帮助菜单输出到`stdout`，然后成功退出程序。如果用户提供了`--version`，`handle_version()`函数也会执行相同的操作：
- en: '[PRE59]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To compile this example, we use CMake:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译这个例子，我们使用CMake：
- en: '[PRE60]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here is the header portion of this `CMakeLists.txt` file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`CMakeLists.txt`文件的头部分：
- en: '[PRE62]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This sets up CMake to require version 3.6 (since we use `GIT_SHALLOW`), gives
    the project a name, includes the `ExternalProject` module (which provided `ExternalProject_Add`),
    and sets the C++ standard to C++17.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了CMake要求版本为3.6（因为我们使用`GIT_SHALLOW`），为项目命名，包括`ExternalProject`模块（提供了`ExternalProject_Add`），并将C++标准设置为C++17。
- en: 'Here is the next section:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是下一部分：
- en: '[PRE63]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: It uses CMake's `ExternalProject_Add` to download and install the GSL from its
    Git repository at GitHub using a depth of 1 (that is, `GIT_SHALLOW 1`) to speed
    up the download process. The arguments provided to `ExternalProject_Add` (that
    is, `GSL_CMAKE_ARGS`) tell the GSL's build system to turn off unit testing (which
    our project does not need) and to install the resulting headers into our build
    directory (which places them in an `include` folder in our `build` directory).
    The remaining arguments provided to `ExternalProject_Add` are optional, simply
    serve to clean up the output of `ExternalProject_Add`, and can be ignored, or
    even removed if desired.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用CMake的`ExternalProject_Add`从GitHub上的Git存储库下载并安装GSL，使用深度为1（即`GIT_SHALLOW 1`）来加快下载过程。提供给`ExternalProject_Add`的参数（即`GSL_CMAKE_ARGS`）告诉GSL的构建系统关闭单元测试（我们的项目不需要）并将生成的头文件安装到我们的构建目录中（将它们放在我们的`build`目录中的`include`文件夹中）。提供给`ExternalProject_Add`的其余参数是可选的，只是用来清理`ExternalProject_Add`的输出，并且可以被忽略，甚至在需要时删除。
- en: 'Finally, here is the last block:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是最后一个代码块：
- en: '[PRE64]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'It tells the build system where to find our newly-installed GSL headers, and
    then creates an executable called `example1` from the `example1.cpp` source code.
    To compile and run this example, simply execute:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉构建系统在哪里找到我们新安装的GSL头文件，然后从`example1.cpp`源代码创建一个名为`example1`的可执行文件。要编译和运行此示例，只需执行：
- en: '[PRE65]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Understanding the Serial Echo server example
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解串行回显服务器示例
- en: In this hands-on example, we will be creating a serial-based echo server. An
    echo server (regardless of the type) takes an input and echoes the input to the
    program's output (similar to the first example, but in this case using a server-style
    application over a serial port).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实际示例中，我们将创建一个基于串行的回显服务器。回显服务器（无论类型如何）都会接收输入并将输入回显到程序的输出（类似于第一个示例，但在这种情况下使用串行端口上的服务器式应用程序）。
- en: To see the full sources for this example, please see the following: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter06/example2.cpp](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter06/example2.cpp).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此示例的完整源代码，请参阅以下内容：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter06/example2.cpp](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter06/example2.cpp)。
- en: '[PRE66]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `main` function is the same as the first example. Its sole purpose is to
    catch any exceptions that might fire, output the exception''s description to `stderr`,
    and safely exit the program with a failure status. For more information on how
    this works, please see the first example. The `protected_main()` function''s purpose
    is to open the serial port, read in an input, and echo the input to the output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数与第一个示例相同。它的唯一目的是捕获可能触发的任何异常，将异常的描述输出到`stderr`，并以失败状态安全地退出程序。有关其工作原理的更多信息，请参见第一个示例。`protected_main()`函数的目的是打开串行端口，读取输入，并将输入回显到输出：'
- en: '[PRE67]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here is the first line:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一行：
- en: '[PRE68]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It does the same thing the first example does, which wraps the `argc` and `argv`
    argument parameters in a GSL span, providing a safe mechanism for parsing the
    arguments provided by the user.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 它做的事情和第一个示例一样，将`argc`和`argv`参数参数包装在GSL span中，为解析用户提供的参数提供了安全机制。
- en: 'Here is the second block:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个块：
- en: '[PRE69]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It checks to make sure that one, and only one, argument was provided by the
    user. The reason the total number of arguments (`argc`) is `2` and not `1` is
    because the first argument is always the name of the program and in this case
    should be ignored, and thus `1` argument provided by the user is actually equal
    to an `argc` of `2`. Furthermore, we use `std::clog` instead of `std::cerr` as
    instability is unlikely in this case, and a flush will be performed for us by
    `libc` when `::exit()` is called.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 它检查确保用户提供了一个且仅一个参数。`argc`的总数为`2`而不是`1`的原因是因为第一个参数总是程序的名称，在这种情况下应该被忽略，因此用户提供的`1`个参数实际上等于`argc`的`2`。此外，我们使用`std::clog`而不是`std::cerr`，因为在这种情况下不太可能不稳定，并且当调用`::exit()`时，`libc`将为我们执行刷新。
- en: 'Here is the second block:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个块：
- en: '[PRE70]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'It opens the serial port and returns input and output streams that can be used
    by `std::cout` and `std::cin` to use the serial port instead of `stdout` and `stdin`.
    To do this, the `open_streams()` function is used:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 它打开串行端口并返回输入和输出流，`std::cout`和`std::cin`可以使用串行端口而不是`stdout`和`stdin`。为此，使用了`open_streams()`函数：
- en: '[PRE71]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This function takes in a `cstring_span{}` that stores the serial port to open
    (for example, `/dev/ttyS0`).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个`cstring_span{}`，用于存储要打开的串行端口（例如`/dev/ttyS0`）。
- en: 'Next we move on the following streams:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们转到以下流：
- en: '[PRE72]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The preceding code opens an input and output stream tied to this serial port.
    Both `ifstream{}` and `ofstream{}` are file streams, which are outside the scope
    of this chapter (they will be explained in later chapters), but in short, these
    open the serial device and provide a stream object that `std::cout` and `std::cin`
    can use as if they were using `stdout` and `stdin` (which are also technically
    file streams on a `POSIX` system).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码打开了一个输入和输出流，绑定到这个串行端口。`ifstream{}`和`ofstream{}`都是文件流，超出了本章的范围（它们将在以后的章节中解释），但简而言之，这些打开了串行设备并提供了一个流对象，`std::cout`和`std::cin`可以使用它们，就好像它们在使用`stdout`和`stdin`（这在`POSIX`系统上也是技术上的文件流）。
- en: 'Here is the next block:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是下一个块：
- en: '[PRE73]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It verifies that both the input stream and the output steam were successfully
    opened, which is important because this type of error could happen (for example,
    an invalid serial port is provided, or the user doesn't have access to the serial
    port). If an error occurs, the user is informed via a message outputted to `std::clog`,
    and the program exits with a failure status.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 它验证了输入流和输出流是否成功打开，这很重要，因为这种类型的错误可能发生（例如，提供了无效的串行端口，或者用户无法访问串行端口）。如果发生错误，用户将通过输出到`std::clog`的消息得到通知，并且程序以失败状态退出。
- en: Finally, if the input stream and output stream are successfully opened, they
    are returned in a pair, which is read by the `protected_main()` function using
    a structured binding syntax (a feature added in C++17).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果输入流和输出流成功打开，它们将作为一对返回，`protected_main()`函数将使用结构化绑定语法（C++17中添加的功能）读取它们。
- en: 'Here is the next block in the `protected_main()` function:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`protected_main()`函数中的下一个块：
- en: '[PRE74]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'It redirects `std::cout` and `std::cin` to the serial port, and then echos
    input into the program to the program''s output, in effect echoing the serial
    port provided by the user. To perform the redirection, the `redirect_output()`
    function is used:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 它将`std::cout`和`std::cin`重定向到串行端口，然后将输入回显到程序的输出，实际上回显了用户提供的串行端口。为了执行重定向，使用了`redirect_output()`函数：
- en: '[PRE75]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `redirect_output()` function takes an input and output stream as a parameter,
    as well as a function to execute and the final parameter. The first thing `redirect_function()`
    does is save the current buffers for `std::cin` and `std::cout`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`redirect_output()`函数将输入和输出流作为参数，以及要执行的函数和最终参数。`redirect_function()`的第一件事是保存`std::cin`和`std::cout`的当前缓冲区：'
- en: '[PRE76]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next we see:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们看到：
- en: '[PRE77]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Both `std::cin` and `std::cout` are redirected to the provided input and output
    streams. Once this is done, the function that was provided is executed. Any use
    of `std::cin` and `std::cout` will be redirected to the provided serial port instead
    of the standard `stdout` and `stdin`. When the `f()` function is finished, `std::cin`
    and `std::cout` are restored to their original buffers, redirecting them back
    to `stdout` and `stdin`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::cin`和`std::cout`都重定向到提供的输入和输出流。完成此操作后，将执行提供的函数。任何对`std::cin`和`std::cout`的使用都将重定向到提供的串行端口，而不是标准的`stdout`和`stdin`。当`f()`函数完成时，`std::cin`和`std::cout`将恢复到它们的原始缓冲区，将它们重定向回`stdout`和`stdin`：'
- en: '[PRE78]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Finally, the program exits with success. To compile this example, we use CMake:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，程序成功退出。要编译此示例，我们使用CMake：
- en: '[PRE79]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This `CMakeLists.txt` is identical to the `CMakeLists.txt` in the first example
    (minus the user of `example2` instead of `example1`). For a complete explanation
    of how this works, please see the first example in this chapter.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`CMakeLists.txt`与第一个例子中的`CMakeLists.txt`相同（减去了使用`example1`而不是`example2`）。有关此操作原理的完整解释，请参阅本章中的第一个例子。
- en: 'To compile and use this example, two computers are needed, one that acts as
    the echo server and a second one that acts as the client, with both computers''
    serial ports connected to each other. On the echo server computer, use the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和使用此示例，需要两台计算机，一台用作echo服务器，另一台用作客户端，两台计算机的串行端口连接在一起。在echo服务器计算机上，使用以下命令：
- en: '[PRE80]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Note that your serial port device might be different. On the client computer,
    open two terminals. In the first terminal, run the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您的串行端口设备可能不同。在客户计算机上，打开两个终端。在第一个终端中，运行以下命令：
- en: '[PRE81]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This code waits for the serial device to output data. In the second terminal,
    run:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码等待串行设备输出数据。在第二个终端中运行：
- en: '[PRE82]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This sends data through the serial port to the echo server. When you press
    *Enter*, you will see the `example2` program that we wrote on the echo server
    close successfully, and the first terminal on the client will show `Hello World`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过串行端口将数据发送到echo服务器。当您按下*Enter*时，您将看到我们在echo服务器上成功关闭的`example2`程序，并且客户端的第一个终端将显示`Hello
    World`：
- en: '[PRE83]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to perform console-based IO, a common system-programming
    requirement, using C++17\. Unlike standard C-style IO functions, such as `printf()`
    and `scanf()`, C++ uses stream-based IO functions, such as `std::cout` and `std::cin`.
    There are many advantages and some disadvantages to using stream-based IO. For
    example, stream-based IO provides a type-safe mechanism for performing IO, while
    raw, POSIX-style `write()` functions can often outperform stream-based IO due
    to a lack of calls to `malloc()` and `free()`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用C++17执行基于控制台的IO，这是一种常见的系统编程需求。与`printf()`和`scanf()`等标准C风格的IO函数不同，C++使用基于流的IO函数，如`std::cout`和`std::cin`。使用基于流的IO有许多优点和一些缺点。例如，基于流的IO提供了一种类型安全的机制来执行IO，而原始的POSIX风格的`write()`函数通常由于不调用`malloc()`和`free()`而能够优于基于流的IO。
- en: In addition, we looked at stream-based manipulators, which provide stream-based
    IO with a similar feature set to standard C-style format strings, but without
    the common instability issues found with the C equivalents. In addition to manipulating
    the format of numbers and Boolean values, we explored field properties, including
    width and justification.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还研究了基于流的操作符，它们为基于流的IO提供了与标准C风格格式字符串类似的功能集，但没有C等效项中常见的不稳定性问题。除了操纵数字和布尔值的格式之外，我们还探讨了字段属性，包括宽度和对齐。
- en: Finally, we finished this chapter with two different examples. The first example
    showed how to implement the popular POSIX *echo* program in C++ rather than in
    C. The second created an *echo* server for the serial port that takes input from
    the serial port using `std::cin` and sends that input back over the serial port
    as an output using `std::cout`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用两个不同的例子结束了本章。第一个例子展示了如何在C++中实现流行的POSIX *echo*程序，而不是在C中。第二个例子创建了一个*echo*服务器，用于串行端口，它使用`std::cin`从串行端口接收输入，并使用`std::cout`将该输入作为输出发送回串行端口。
- en: In the next chapter we will provide a comprehensive overview of the memory management
    facilities provided by C, C++, and POSIX including aligned memory and C++ smart
    pointers.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将全面介绍C、C++和POSIX提供的内存管理设施，包括对齐内存和C++智能指针。
- en: Questions
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does `std::cin` help to prevent buffer overflows compared to the standard
    C `scanf`?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相比标准C的`scanf`，`std::cin`如何帮助防止缓冲区溢出？
- en: Name at least one advantage from using C++ streams compared to the standard
    C-style `printf`/`scanf`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少列举一个使用C++流相对于标准C风格的`printf`/`scanf`的优点。
- en: Name at least on disadvantage to using C++ streams compared to the standard
    C-style `printf`/`scanf`.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少列举一个使用C++流相对于标准C风格的`printf`/`scanf`的缺点。
- en: When should `std::endl` be used instead of `\n`?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用`std::endl`而不是`\n`？
- en: What is the difference between `std::cerr` and `std::clog`, and when should
    `std::cerr` be used?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::cerr`和`std::clog`之间有什么区别，何时应该使用`std::cerr`？'
- en: How does one output extra characters between a base identifier and a hex value?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在基数标识符和十六进制值之间输出额外字符？
- en: How does one output a number in octal and upper case?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何输出八进制和大写字母？
- en: How can standard C-style program arguments be safely parsed using C++ and the
    GSL?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用C++和GSL安全地解析标准C风格的程序参数？
- en: How does one save/restore the read buffer for `std::cin`?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何保存/恢复`std::cin`的读取缓冲区？
- en: Further reading
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
