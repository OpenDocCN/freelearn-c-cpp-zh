- en: Domain-Specific Language
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: In the previous chapters, we developed the games Othello and Noughts and Crosses
    with the Qt library. In this chapter, we will start to develop a **Domain-Specific
    Language** (**DSL**), which is a language intended for a specific domain. More
    specifically, we will develop a language for writing graphical objects in a Qt
    widget. The language allows us to draw lines, rectangles, ellipses, and to write
    text. Moreover, it does allow us to choose color as well as pen and brush style
    for the graphical objects. It also allows us to choose font and alignment for
    the text.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用Qt库开发了Othello和井字棋游戏。在本章中，我们将开始开发一个**领域特定语言（DSL**），这是一种针对特定领域的语言。更具体地说，我们将开发一种用于在Qt小部件中编写图形对象的语言。该语言允许我们绘制线条、矩形、椭圆，并写入文本。此外，它还允许我们为图形对象选择颜色以及笔和画笔样式。它还允许我们为文本选择字体和对齐方式。
- en: 'Topics we will cover in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题包括：
- en: First, we will informally look into the source code of our DSL by looking at
    an example. We will draw graphical objects and set their color, style, and font.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将通过查看一个示例来非正式地研究我们的领域特定语言（DSL）的源代码。我们将绘制图形对象并设置它们的颜色、样式和字体。
- en: We will formally define our language with grammar.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用语法正式定义我们的语言。
- en: When we have defined the grammar, we write the scanner. The scanner reads the
    source code and recognizes meaningful sequences of characters, called **tokens**.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们定义了语法后，我们编写扫描器。扫描器读取源代码并识别有意义的字符序列，称为**标记**。
- en: When we have written the scanner, we write the parser. The parser can be considered
    the heart of our DSL. It requests new tokens from the scanner, when needed. It
    checks that the source code complies with the grammar, and it generates a sequence
    of actions. Each action holds an instruction, such as setting the color or drawing
    a line.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们编写了扫描器后，我们编写解析器。解析器可以被认为是我们的领域特定语言（DSL）的核心。当需要时，它会从扫描器请求新的标记。它检查源代码是否符合语法，并生成一系列动作。每个动作都包含一个指令，例如设置颜色或绘制线条。
- en: Finally, we write a viewer that reads the action sequence generated by the parser
    and displays the graphical objects in a Qt widget.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们编写一个查看器，该查看器读取解析器生成的动作序列，并在Qt小部件中显示图形对象。
- en: Introducing the source language – a simple example
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍源语言——一个简单的例子
- en: The source language of our DSL is made up by a sequence of instructions. There
    are instructions for drawing graphical objects such as lines, rectangles, ellipses,
    and text. We also have instructions for setting the color and style of the objects
    as well as font and alignment of the text. Finally, there is instruction for assigning
    values to a name.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的领域特定语言（DSL）的源语言由一系列指令组成。有用于绘制图形对象的指令，如线条、矩形、椭圆和文本。我们还有设置对象颜色和样式以及文本字体和对齐方式的指令。最后，还有为名称分配值的指令。
- en: 'Let us look at an example. The following code draws a rectangle and writes
    text. Note that the language is not case-sensitive, that is, it does not matter
    whether we use small or capital letters in our code. We start by defining the
    top-left corner of a rectangle:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。以下代码绘制了一个矩形并写入了文本。请注意，该语言不区分大小写，也就是说，我们代码中使用小写或大写字母无关紧要。我们首先定义矩形的左上角：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We use the coordinate operators to extract the *x* and *y* coordinates of the
    top-left point and define the bottom-right corner:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用坐标运算符来提取左上点的*x*和*y*坐标，并定义右下角：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We use the predefined values `DashLine` and `CrossPatterns` to set the style
    of the pen and brush:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用预定义的值`DashLine`和`CrossPatterns`来设置笔和画笔的样式：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We use the predefined color `Black` for the pen and create our own color `Purple`
    for the brush. We can create a new color with three values corresponding to their
    red, green, and blue components. Each component can hold a value between 0 and
    255, inclusive:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用预定义的颜色`Black`作为笔的颜色，并为画笔创建自己的颜色`Purple`。我们可以使用三个值来创建一个新颜色，这三个值分别对应它们的红色、绿色和蓝色分量。每个分量可以持有介于0到255之间的值，包括：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We continue to add a text, with font and alignment. We choose `12` point `Times
    New Roman` with left horizontal alignment and top vertical alignment:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续添加文本，包括字体和对齐方式。我们选择`12`点的`Times New Roman`字体，左对齐水平方向和顶对齐垂直方向：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The instructions of this example will be divided into meaningful parts by the
    scanner; the parser will check that the instructions comply with the grammar and
    generate a sequence of actions read by the viewer and display the following Qt
    widget:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的指令将由扫描器分成有意义的部分；解析器将检查指令是否符合语法，并生成一系列由观众读取的动作，并显示以下 Qt 小部件：
- en: '![](img/30203c62-df0f-49a5-9e2a-e676d1dafdbf.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30203c62-df0f-49a5-9e2a-e676d1dafdbf.png)'
- en: The grammar of the source language
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源语言的语法
- en: The source language of our DSL needs to be exactly defined. We do that by defining grammarfor
    the language. Grammar is made up by rules (in *italic* style), keywords (in **bold**
    style), separations, and punctuations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要精确地定义我们的领域特定语言（DSL）的源语言。我们通过定义语言的语法来实现这一点。语法由规则（以 *斜体* 风格呈现）、关键字（以 **粗体*
    风格呈现）、分隔符和标点符号组成。
- en: 'The `program` rule is the start rule. The arrow (`->`) means that a program
    is made up by an instructions list. The arrow can be read as:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`program` 规则是起始规则。箭头 (`->`) 表示程序由指令列表组成。箭头可以读作：'
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the grammar, an asterisk (`*`) means **zero** or **more**. Hence, an instruction
    list is made up by zero or more instructions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法中，星号 (`*`) 表示 **零个或多个**。因此，指令列表由零个或多个指令组成：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The assignment instruction takes a name followed by the assignment operator
    (`=`), an expression, and a semicolon. The instructions for setting the pen and
    brush color and style take one expression, so do the settings of the font and
    alignment. The instructions for drawing lines, rectangles, and text take two expressions.
    Note that every instruction is terminated by a semicolon (`;`).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值指令包含一个名称后跟赋值运算符 (`=`)，一个表达式和一个分号。设置笔和画笔颜色和样式的指令以及字体和对齐的设置都只需要一个表达式。绘制线条、矩形和文本的指令需要两个表达式。请注意，每个指令都以分号
    (`;`) 结尾。
- en: 'The vertical bar (`|`) can be read as **or**. An instruction is an assignment
    orthe setting of the pen color orthe setting of the brush color, and so on:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 竖线 (`|`) 可以读作 **或**。指令是一个赋值或设置笔色、设置画笔色等：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The next part of the parser to define is the expressions. First, we look at
    the operators of the expressions. We also have to look into the priority of the
    operators. For instance, multiplication and division have higher priority than
    addition and subtraction. The operators of the grammar have the following priorities:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步要定义的是表达式。首先，我们查看表达式的运算符。我们还需要考虑运算符的优先级。例如，乘法和除法的优先级高于加法和减法。语法中的运算符具有以下优先级：
- en: '| **Expression** | **Operator** | **Priority** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **运算符** | **优先级** |'
- en: '| Addition Subtraction | `+ -` | Lowest |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 加减 | `+ -` | 最低 |'
- en: '| Multiplication Division | `* /` |  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 乘除 | `* /` |  |'
- en: '| Primary | `point``xCoordinate``yCoordinate``color``font``(expression)``name``value`
    | Highest |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 基本表达式 | `point` `xCoordinate` `yCoordinate` `color` `font` `(expression)`
    `name` `value` | 最高 |'
- en: 'We define two rules each for addition and subtraction, as well as for multiplication
    and division. We start with the lowest priority level, which is addition and subtraction.
    In the `expression` rule we call the `mulDivExpression` rule, which handles multiplication
    and division expressions, and we call the `expressionRest` rule to examine the
    rest of the expression:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为加法和减法、乘法和除法各自定义了两条规则。我们首先从优先级最低的开始，即加法和减法。在 `expression` 规则中，我们调用 `mulDivExpression`
    规则来处理乘除表达式，并调用 `expressionRest` 规则来检查表达式的其余部分：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `expressionRest` rule we look into the next token. If it is a plus or
    a minus, we have an addition or subtraction expression. We call `mulDivExpression`
    to handle expressions of higher priority. Finally, we call the `expressionRest`
    rule again in case of another plus or minus. However, if the first token is neither
    a plus nor a minus,  we do nothing:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `expressionRest` 规则中，我们查看下一个标记。如果它是加号或减号，我们有一个加法或减法表达式。我们调用 `mulDivExpression`
    来处理优先级更高的表达式。最后，如果还有另一个加号或减号，我们再次调用 `expressionRest` 规则。然而，如果第一个标记既不是加号也不是减号，我们就不做任何事情：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`mulDivExpression` and `mulDivExpressionRest` work in the same way as `expression`
    and `expressionRest` shown previously:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`mulDivExpression` 和 `mulDivExpressionRest` 的工作方式与之前展示的 `expression` 和 `expressionRest`
    相同：'
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The primary expression is a point, an *x* or *y* coordinate, a color, a font,
    a name, or a value. A point is made up by two expressions holding the *x* and
    *y* coordinate of the point. A coordinate takes an expression holding a point
    and gives it an *x* or *y* coordinate:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 基本表达式是一个点，一个 *x* 或 *y* 坐标，一个颜色，一个字体，一个名字或一个值。一个点由两个表达式组成，分别持有点的 *x* 和 *y* 坐标。一个坐标接受一个包含点的表达式，并给它一个
    *x* 或 *y* 坐标：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A color expression is made up by its red, green, and blue components, while
    a font expression is made up by the name and size of the font:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色表达式由其红色、绿色和蓝色分量组成，而字体表达式由字体名称和大小组成：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An expression can be enclosed in parentheses in order to change the priority
    of the expression. For instance, in the expression 2 + 3 x 4, multiplication takes
    precedence over addition, but in the expression (2 + 3) x 4, addition takes precedence
    over multiplication:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式可以用括号括起来以改变表达式的优先级。例如，在表达式 2 + 3 x 4 中，乘法比加法有更高的优先级，但在表达式 (2 + 3) x 4 中，加法比乘法有更高的优先级：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, an expression can be a name earlier associated with a value, or simply
    a value:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个表达式可以是一个之前与值关联的名字，或者简单地是一个值：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The target language
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标语言
- en: The target language is defined by a sequence of actions. Informally, the actions
    correspond to the instructions of the grammar. We have actions for setting the
    color or style of a pen or a brush, and for setting the horizontal or vertical
    alignment of the text, as well as actually drawing the lines, rectangles, ellipses,
    and text of the drawing. Later in this chapter, we will write a parser that generates
    a sequence of actions, and a viewer that reads the actions and displays graphical
    objects in a Qt widget.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 目标语言由一系列动作定义。非正式地说，动作对应于语法的指令。我们有设置画笔或刷子的颜色或样式的动作，以及设置文本的水平或垂直对齐，以及实际绘制线条、矩形、椭圆和绘图文本的动作。在本章的后面，我们将编写一个生成一系列动作的解析器，以及一个读取动作并在
    Qt 小部件中显示图形对象的查看器。
- en: An `Action` object holds the identity of the action (which is defined by the
    `TokenId` enumeration in the `Token` class, as follows) together with, at most,
    two values.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Action` 对象持有动作的标识符（由 `Token` 类中的 `TokenId` 枚举定义，如下所示）以及最多两个值。
- en: '**Action.h:**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Action.h:** '
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Action.cpp` file holds the definitions of the methods of the `Action` class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Action.cpp` 文件包含了 `Action` 类的方法定义。'
- en: '**Action.cpp:**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**Action.cpp:** '
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The constructor takes the action identity and at most two values:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受动作标识符和最多两个值：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The colors
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色
- en: 'When setting the color of the pen or brush, we need to submit the color with
    the instruction. We can use the color rule in the preceding grammar to create
    our own color. However, there is a set of predefined colors of the Qt class `QColor`.
    The following scanner defines a set of predefined `QColor` objects (`Aqua`, `Black`,
    ...) and maps them to their names. For instance, the user can write the following
    instruction in the source code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置画笔或刷子的颜色时，我们需要提交带有指令的颜色。我们可以使用前面语法中的颜色规则来创建自己的颜色。然而，Qt 类 `QColor` 有一个预定义的颜色集。以下扫描器定义了一个预定义的
    `QColor` 对象集（`Aqua`、`Black`、...）并将它们映射到它们的名称。例如，用户可以在源代码中编写以下指令：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In that case, since the name `Aqua` is associated with the `QColor` object `Aqua`,
    the pen color is set to `Aqua`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在那种情况下，由于名字 `Aqua` 与 `QColor` 对象 `Aqua` 相关联，画笔颜色被设置为 `Aqua`。
- en: '**Colors.h:**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**Colors.h:** '
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Colors.cpp` file holds the definitions of the colors in the `Colors.h`
    file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Colors.cpp` 文件包含了 `Colors.h` 文件中颜色的定义。'
- en: '**Colors.cpp:**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**Colors.cpp:** '
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Each color is defined by its red, green, and blue component. Each component
    holds a value from 0 to 255, inclusive. For instance, the `Blue` color holds the
    full value of the blue component and zero of the other components, while `Yellow`
    is a blend of red and green:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个颜色由其红色、绿色和蓝色分量定义。每个分量持有从 0 到 255 的值，包括 255。例如，`Blue` 颜色持有蓝色分量的最大值和其它分量的零值，而
    `Yellow` 是红色和绿色的混合：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Error handling
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'There are some functions for error handling: `check` checks whether a condition
    is true and reports an error if it is not. The `syntaxError` and `semanticError`
    functions report a syntactic and semantic error, while `error` throws an exception
    that is caught and reported by the `main` function.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些用于错误处理的函数：`check` 检查一个条件是否为真，如果不为真则报告错误。`syntaxError` 和 `semanticError`
    函数报告语法和语义错误，而 `error` 抛出一个异常，该异常被 `main` 函数捕获并报告。
- en: '**Error.h:**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Error.h:** '
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Error.cpp` file holds the definitions of the `Error.h` file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error.cpp` 文件包含了 `Error.h` 文件的定义。'
- en: '**Error.cpp:**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**Error.cpp:** '
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We use the C++ `stringstream` standard class to compound the error message:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用C++的`stringstream`标准类来组合错误信息：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `str` method returns an object of the C++ `string` standard class, and
    `c_str` returns a character pointer that is converted to a `QString` object in
    the `error` call:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`str`方法返回C++ `string`标准类的一个对象，而`c_str`返回一个字符指针，在`error`调用中转换为`QString`对象：'
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A syntax error occurs when the scanner finds a character sequence that does
    not constitute a token, or when the parser detects that the token sequence does
    not comply with the grammar. We will cover the topic soon; for now, just remember
    that a scanner can report errors too:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当扫描器发现不构成标记的字符序列，或者当解析器检测到标记序列不符合语法时，会发生语法错误。我们将在不久的将来介绍这个主题；现在，只需记住扫描器也可以报告错误：
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A semantic error occurs when an unknown name is found, or when the types of
    an expression do not comply:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当发现未知名称，或者当表达式的类型不匹配时，会发生语义错误：
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `check` method has a similar effect to the `assert` macro. It checks whether
    the condition is true. If it is not true, `semanticError` is called, which eventually
    throws an error exception:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`check`方法与`assert`宏有类似的效果。它检查条件是否为真。如果不为真，则调用`semanticError`，最终抛出错误异常：'
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The value
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值
- en: 'There are several kinds of values in the language, which are used to set the
    color or style of the pen or brush, or to set the end-points of a line, or to
    set the name of the font, or the alignment of the text: numerical (`double`),
    string (`QString`), color (`QColor`), font (`QFont`), point (`QPoint`), pen style
    (`Qt::PenStyle`), brush style (`Qt`::`BrushStyle`), and horizontal or vertical
    alignment (`Qt`::`AlignmentFlag`).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 语言中有几种类型的值，用于设置画笔或画刷的颜色或样式，或设置线的端点，或设置字体名称，或文本的对齐方式：数值（`double`）、字符串（`QString`）、颜色（`QColor`）、字体（`QFont`）、点（`QPoint`）、画笔样式（`Qt::PenStyle`）、画刷样式（`Qt`::`BrushStyle`）以及水平或垂直对齐（`Qt`::`AlignmentFlag`）。
- en: '**Value.h:**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**Value.h**：'
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `Value.cpp` file holds the definitions of the methods of the `Value` class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Value.cpp`文件包含了`Value`类的定义方法。'
- en: '**Value.cpp:**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**Value.cpp**：'
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The non-default constructors initialize the `Value` object with appropriate
    values:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 非默认构造函数使用适当的值初始化`Value`对象：
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The scanner
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描器
- en: The **scanner** is a part of the application that accepts the source code and
    generates a sequence of tokens. A **token** is the smallest meaningful part of
    the source code. For instance, the characters **f**, **o**, **n**, and **t** make
    up the keyword **font**, and the characters **1**, **2**, and **3** constitute
    the numerical value **123**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**扫描器**是应用程序的一部分，它接受源代码并生成一系列标记。**标记**是源代码中最小的有意义的部分。例如，字符**f**、**o**、**n**和**t**组成了关键字**font**，而字符**1**、**2**和**3**构成了数值**123**。'
- en: However, first we need the `Token` class to keep track of the tokens. The `m_tokenId`
    field is set to a value of the enumeration `TokenId`. In the case of a name, the
    `m_name` field holds the name, and in the case of a value, the `m_value` field
    holds the value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，首先我们需要`Token`类来跟踪标记。`m_tokenId`字段被设置为枚举`TokenId`的值。在名称的情况下，`m_name`字段包含名称，而在值的情况下，`m_value`字段包含值。
- en: '**Token.h:**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**Token.h**：'
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `TokenId` enumeration holds all the tokens of the scanner. They are divided
    into keywords, operators, punctuation, and separators, as well as names and values.
    In order to avoid converting between different enumerations, the `TokenId` enumeration
    is used by the scanner, parser, and viewer. The `TokenId` enumeration is used
    by the scanner to distinguish between the different tokens by the parser when
    type checking and evaluating expressions, and by the `Action` class to distinguish
    between different actions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`TokenId`枚举包含了扫描器的所有标记。它们被分为关键字、运算符、标点符号和分隔符，以及名称和值。为了避免在不同枚举之间进行转换，扫描器、解析器和查看器都使用`TokenId`枚举。`TokenId`枚举由扫描器在类型检查和评估表达式时区分不同的标记，由`Action`类区分不同的操作。'
- en: 'The first part (`ColorId` to `YCoordinateId`) is keywords of the language:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分（从`ColorId`到`YCoordinateId`）是语言的关键字：
- en: '[PRE33]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The second part (`AddId` to `DivideId`) is operators:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分（从`AddId`到`DivideId`）是运算符：
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next part is parentheses, assignment (`=`), comma, and semicolon:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是括号、赋值（`=`）、逗号和分号：
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, the last part is the name, value, and end-of-file marking:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一部分是名称、值和文件结束标记：
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Each token can be annotated with a name or a value:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个标记都可以用名称或值进行标注：
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `Token.cpp` file holds the definitions of the methods of the `Token` class.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Token.cpp` 文件包含 `Token` 类的方法定义。'
- en: '**Token.cpp:**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**Token.cpp:**'
- en: '[PRE38]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The default token is initialized with an end-of-file token:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 默认标记使用文件结束标记初始化：
- en: '[PRE39]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Most tokens hold only a value of the `TokenId` enumeration:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数标记只包含 `TokenId` 枚举的值：
- en: '[PRE40]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Tokens can also hold a name or a value:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 标记也可以包含名称或值：
- en: '[PRE41]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Scanner` class takes the source code and divides it into tokens. A token
    can also be associated by a name or a value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner` 类接收源代码并将其划分为标记。标记也可以通过名称或值关联。'
- en: '**Scanner.h:**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scanner.h:**'
- en: '[PRE42]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `init` method initializes the names of the keywords and operators:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`init` 方法初始化关键字和操作符的名称：'
- en: '[PRE43]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `nextToken` method scans the buffer and returns the next token. If there
    is no recognizable token, an error exception is thrown that is later caught by
    the `main` function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextToken` 方法扫描缓冲区并返回下一个标记。如果没有可识别的标记，则会抛出一个错误异常，该异常随后被 `main` 函数捕获：'
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `m_buffer` field holds the source code; `m_bufferIndex` holds the index
    of the next character in the buffer to be examined (the index is initialized to
    zero); `m_keywordMap` holds the names of the keywords; `m_valueMap` holds a map
    of color, alignment, and pen and brush style values, and `m_operatorList` hold
    a list of operators:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_buffer` 字段包含源代码；`m_bufferIndex` 包含要检查的缓冲区中下一个字符的索引（索引初始化为零）；`m_keywordMap`
    包含关键字的名称；`m_valueMap` 包含颜色、对齐、笔和画笔样式值的映射，`m_operatorList` 包含操作符列表：'
- en: '[PRE45]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In previous chapters, we have used the C++ standard classes `map`, `set`, `list`,
    `vector`, and `stack`. In this chapter, we will use the Qt classes `QMap`, `QSet`,
    `QList`, `QVector`, and `QStack` instead. They work approximately in the same
    way:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了 C++ 标准类 `map`、`set`、`list`、`vector` 和 `stack`。在本章中，我们将使用 Qt 类
    `QMap`、`QSet`、`QList`、`QVector` 和 `QStack` 代替。它们的工作方式大致相同：
- en: '[PRE46]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `Scanner.cpp` file holds the definitions of the methods of the `Scanner`
    class.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner.cpp` 文件包含 `Scanner` 类的方法定义。'
- en: '**Scanner.cpp:**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scanner.cpp:**'
- en: '[PRE47]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `g_lineNo` global field keeps track of the current line in the source code,
    in order for the error messages to state the line number:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`g_lineNo` 全局字段跟踪源代码中的当前行，以便错误消息可以显示行号：'
- en: '[PRE48]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `ADD_TO_OPERATOR_LIST` macro adds a token to the operator list. For instance,
    `ADD_TO_OPERATOR_LIST("+", AddId)` adds the pair of `"+"` and `AddId` to the list:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD_TO_OPERATOR_LIST` 宏将标记添加到操作符列表中。例如，`ADD_TO_OPERATOR_LIST("+", AddId)`
    将 `"+"` 和 `AddId` 对添加到列表中：'
- en: '[PRE49]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `ADD_TO_KEYWORD_MAP` macro adds a keyword to the keyword map. For instance,
    `ADD_TO_KEYWORD_MAP(ColorId)` adds the pair of `Color` and `ColorId` to the map.
    Note that the `Id` part of the keyword (the last two characters) text is removed:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD_TO_KEYWORD_MAP` 宏将关键字添加到关键字映射中。例如，`ADD_TO_KEYWORD_MAP(ColorId)` 将 `Color`
    和 `ColorId` 对添加到映射中。请注意，关键字的部分（最后两个字符）的文本被移除：'
- en: '[PRE50]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `ADD_TO_VALUE_MAP` macro adds a value to the value map. For instance, `ADD_TO_VALUE_MAP(Aqua)`
    adds the pair of aqua and the `QColor` object Aqua to the map. Note that the text
    is converted to lower case. Also note that only the last part after the last potential
    pair of colons (`::`) is included:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD_TO_VALUE_MAP` 宏将值添加到值映射中。例如，`ADD_TO_VALUE_MAP(Aqua)` 将 aqua 和 `QColor`
    对象 Aqua 对添加到映射中。请注意，文本被转换为小写。另外请注意，只包括最后一个可能的对冒号 (`::`) 的最后一个部分：'
- en: '[PRE51]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`ADD_TO_VALUE_MAP(Qt::AlignLeft)` adds the pair of align left and the `Qt::PenStyle`
    value to the map. Again, note that only the last segment of the value''s name
    is stored as text:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD_TO_VALUE_MAP(Qt::AlignLeft)` 将对齐左和 `Qt::PenStyle` 值对添加到映射中。再次注意，只有值名称的最后一个部分被存储为文本：'
- en: '[PRE52]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the constructor, we load the buffer into the `m_buffer` field. We also add
    the null-character (`''''`) in order to find the end of the buffer in an easier
    way:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们将缓冲区加载到 `m_buffer` 字段中。我们还添加了空字符 (`''`)，以便更容易地找到缓冲区的末尾：
- en: '[PRE53]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `nextToken` method scans the buffer and returns the token found. First,
    we iterate as long as we find new-line, white-space, or line comment. In case
    of a new line, we increase the line count:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextToken` 方法扫描缓冲区并返回找到的标记。首先，我们迭代，直到找到新行、空白或行注释。如果遇到新行，则增加行数：'
- en: '[PRE54]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'A white-space is regular space, a horizontal or vertical tabulator, a return
    character, or new line. We use the `isSpace` method to check whether the character
    is a white-space:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 空白是常规空格、水平或垂直制表符、回车符或新行。我们使用 `isSpace` 方法检查字符是否为空白：
- en: '[PRE55]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we encounter the beginning of a line comment (`//`), we continue until we
    find the end of the line (`''n''`) or the end of the buffer (`''''`):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到行注释的开始（`//`），我们继续直到找到行尾（`'n'`）或缓冲区结束（`''`）：
- en: '[PRE56]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If we do not find a new line, white-space, or line comment, we break the iteration
    and continue looking for the next token:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有找到新行、空白或行注释，我们中断迭代并继续寻找下一个标记：
- en: '[PRE57]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When we have scanned through the potential white-spaces and comments, we start
    looking for the real tokens. We start by checking if the next character in the
    buffer is a null character (`''''`). If it is a null character, we have found
    the end of the source code and return end-of-file. Remember that we added a null
    character at the end of the buffer in the constructor, just to be able to recognize
    the end of the file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扫描过潜在的空白和注释后，我们开始寻找真正的标记。我们首先检查缓冲区中的下一个字符是否是空字符（`''`）。如果是空字符，我们就找到了源代码的结尾并返回文件结束。记住，我们在构造函数中添加了一个空字符到缓冲区末尾，只是为了能够识别文件结束：
- en: '[PRE58]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If the next token is not end-of-file, we check if it is an operator. We iterate
    through the operator list and check if the buffer begins with any of the operator''s
    text. For instance, the add operator holds the text `+`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下一个标记不是文件结束，我们检查它是否是一个运算符。我们遍历运算符列表，并检查缓冲区是否以任何运算符的文本开头。例如，加法运算符包含文本 `+`：
- en: '[PRE59]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When we have found the operator, we increment the buffer index, and return
    the token:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们找到运算符时，我们增加缓冲区索引，并返回标记：
- en: '[PRE60]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If the buffer does not begin with an operator, we look after a name representing
    a keyword, a value, or simply a name. We start by checking if the buffer begins
    with a letter or the underscore character (`''_''`), since a name is allowed to
    start with a letter or an underscore. However, the remaining characters can be
    digits besides the letters and underscores:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缓冲区不以运算符开头，我们寻找代表关键字、值或简单名称的名称。我们首先检查缓冲区是否以字母或下划线字符（`'_'`）开头，因为名称可以以字母或下划线开头。然而，除了字母和下划线之外，剩余的字符可以是数字：
- en: '[PRE61]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We iterate until we find a character that is not a letter, digit, or underscore:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历直到找到一个不是字母、数字或下划线的字符：
- en: '[PRE62]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We extract the text and increase the buffer index:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取文本并增加缓冲区索引：
- en: '[PRE63]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The text can hold a keyword, a value, or a name. First, we check whether the
    text is present in the keyword map. If it is present, we just return the token
    associated with the keyword text:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 文本可以包含一个关键字、一个值或一个名称。首先，我们检查文本是否存在于关键字映射中。如果存在，我们只需返回与关键字文本关联的标记：
- en: '[PRE64]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We then check whether the text is present in the value map. If it is present,
    we return a value token with the value annotated to the token. The value can later
    be obtained by the parser:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查文本是否存在于值映射中。如果存在，我们返回一个带有值注释的值标记。值可以在稍后由解析器获取：
- en: '[PRE65]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If the text is neither a keyword nor a value, we assume that it is a name and
    return a name token with the name annotated to the token. The name can later be
    obtained by the parser:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文本既不是关键字也不是值，我们假设它是一个名称，并返回一个带有名称注释的名称标记。名称可以在稍后由解析器获取：
- en: '[PRE66]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When we have looked for a name without finding it, we start looking for a string
    instead. A string is a text enclosed by double quotes (`''"''`). If the next character
    in the buffer is a double quote, it is the beginning of a text. We remove the
    double quote from the buffer and iterate until we find the end quote of the text:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们没有找到名称时，我们开始寻找字符串。字符串是由双引号（`'"'`）包围的文本。如果缓冲区中的下一个字符是双引号，那么它是文本的开始。我们从缓冲区中移除双引号，并遍历直到找到文本的结束引号：
- en: '[PRE67]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we find a null character before the end of the text, a syntax error is reported
    since we have found the end of the file inside the text:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在文本结束之前找到空字符，由于我们在文本中找到了文件结束，所以报告语法错误：
- en: '[PRE68]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When we have found the end quote, we increase the buffer index and return a
    value token with the text as its annotated value. The text can later be obtained
    by the parser:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们找到结束引号时，我们增加缓冲区索引，并返回一个带有文本作为其注释值的值标记。文本可以在稍后由解析器获取：
- en: '[PRE69]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If the next character in the buffer is a digit, we have found a numerical value,
    with or without decimals. First, we iterate as long as we find digits in the buffer:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缓冲区中的下一个字符是数字，我们就找到了一个数值，可能带有小数点。首先，我们遍历缓冲区，直到找到数字：
- en: '[PRE70]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When we no longer find any digits, we check whether the next character in the
    buffer is a dot (`''.''`). If it is a dot, we continue to iterate as long as we
    find digits:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不再找到任何数字时，我们检查缓冲区中的下一个字符是否是点（`'.'`）。如果是点，只要我们找到数字，我们就继续迭代：
- en: '[PRE71]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'When we no longer find any digits, we increase the buffer index and return
    a value token with the annotated value. The value can later be obtained by the
    parser:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不再找到任何数字时，我们增加缓冲区索引，并返回一个带有注释值的值标记。该值可以稍后被解析器获取：
- en: '[PRE72]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Finally, if none of the preceding cases apply, the source code is syntactically
    incorrect, and we report a syntax error:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果前面的任何情况都不适用，源代码在语法上是错误的，我们报告一个语法错误：
- en: '[PRE73]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We return an end-of-file token, simply because we have to return a value. However,
    we will never reach this point of the code since the `syntaxError` call caused
    an exception to be thrown:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回一个文件结束标记，仅仅是因为我们必须返回一个值。然而，我们永远不会到达代码的这个点，因为`syntaxError`调用抛出了一个异常：
- en: '[PRE74]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now that we have looked at the scanner, we will continue to look at the parser
    in the next section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了扫描器，我们将在下一节继续了解解析器。
- en: Building the parser
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建解析器
- en: Now that we have looked into the scanner, it is time to move on to the parser.
    The parser checks that the source code complies with the grammar. It also performs
    type checking and generates the action list, which is later displayed by the viewer,
    as follows. The `Parser` class mirrors the grammar in that way the it holds one
    method for each grammar rule.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了扫描器，是时候转向解析器了。解析器检查源代码是否符合语法。它还执行类型检查并生成动作列表，该列表稍后由查看器显示，如下所示。`Parser`
    类以这种方式反映了语法，即它为每个语法规则持有一个方法。
- en: '**Parser.h:**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**Parser.h:** '
- en: '[PRE75]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The constructor takes a grammar object and the action list, which is empty
    at the beginning. The parser calls the scanner each time it needs a new token:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受一个语法对象和动作列表，动作列表最初为空。解析器每次需要新标记时都会调用扫描器：
- en: '[PRE76]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `match` method checks whether the given token equals the next token obtained
    by the scanner. If it does not, a syntax error is reported:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 方法检查给定的标记是否等于扫描器获取的下一个标记。如果不相等，则报告语法错误：'
- en: '[PRE77]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The remaining methods of the `Parser` class are divided into methods for instructions
    and expressions in the grammar, as well as methods for type checking and evaluation
    of expressions:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parser`类的其余方法分为语法中的指令和表达式的方法，以及类型检查和表达式评估的方法：'
- en: '[PRE78]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We also add a method to the parser for each expression rule in the grammar:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为语法中的每个表达式规则添加了一个解析器方法：
- en: '[PRE79]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'When evaluating the values of expressions, we need to check the types of the
    values. For instance, when adding two values, both of the operands shall have
    numerical values:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估表达式的值时，我们需要检查值的类型。例如，当添加两个值时，两个操作数都应该是数值：
- en: '[PRE80]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `m_lookAhead` field holds the next token obtained by the scanner, and `m_scanner`
    holds the scanner itself. The `m_actionList` field holds a reference to the action
    list given in the constructor. Finally, `m_assignMap` holds a map for the names
    assigned to values by the assignment rule:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_lookAhead`字段持有扫描器获取的下一个标记，`m_scanner`持有扫描器本身。`m_actionList`字段持有构造函数中给出的动作列表的引用。最后，`m_assignMap`持有由赋值规则分配给值的映射：'
- en: '[PRE81]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `Parser.cpp` file holds the definitions of the methods of the `Parser` class.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parser.cpp`文件包含`Parser`类的定义方法。'
- en: '**Parser.cpp:**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**Parser.cpp:** '
- en: '[PRE82]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The constructor initializes the references to the scanner and the action list,
    and sets the `m_lookAHead` field to the first token obtained by the scanner. Then
    the parsing process begins by calling `instructionList`. When the instruction
    list has been parsed, the only remaining token shall be the end-of-file token:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数初始化对扫描器和动作列表的引用，并将`m_lookAHead`字段设置为扫描器获取的第一个标记。然后通过调用`instructionList`开始解析过程。当指令列表被解析后，唯一剩下的标记应该是文件结束标记：
- en: '[PRE83]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The `g_lineNo` field keeps track of the current line of the source code so
    that a syntax error can be reported with the correct line number:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`g_lineNo`字段跟踪源代码的当前行，以便可以报告带有正确行号的语法错误：'
- en: '[PRE84]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `instructionList` method keeps iterating until it encounters the end-of-file
    token:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`instructionList`方法会一直迭代，直到遇到文件结束标记：'
- en: '[PRE85]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `match` method compares the next token obtained by the scanner with the
    given token. If they do not comply, a syntax error is reported. If they do comply,
    the next token is obtained by the scanner:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`match`方法比较扫描器获取的下一个标记与给定的标记。如果不一致，则报告语法错误。如果一致，则通过扫描器获取下一个标记：'
- en: '[PRE86]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Parsing the instructions of the language
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析语言的指令
- en: 'The `instruction` method holds a sequence of switch cases, one case for each
    category of instructions. We will look into the next token obtained by the scanner:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`instruction` 方法包含一系列的 switch 案例序列，每个案例对应于指令的一个类别。我们将查看扫描器获得的下一个标记：'
- en: '[PRE87]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In the case of a name, we parse the name, assignment (`=`), the following expression,
    and a semicolon:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在名称的情况下，我们解析名称、赋值运算符（`=`）、后面的表达式和分号：
- en: '[PRE88]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'If the name is already associated with a value, a semantic error is reported:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果名称已经与一个值相关联，则会报告语义错误：
- en: '[PRE89]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The settings of pen and brush colors and styles, as well as fonts and alignments,
    are a little bit more complicated. We call `expression` to parse and evaluate
    the value of an expression. The type of the expression is checked, and an `Action`
    object is added to the action list:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 笔和刷的颜色和样式设置，以及字体和对齐方式，稍微复杂一些。我们调用 `expression` 来解析和评估表达式的值。检查表达式的类型，并将 `Action`
    对象添加到动作列表中：
- en: '[PRE90]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The drawing of lines, rectangles, ellipses, and text takes two expressions,
    whose values are evaluated and type checked:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制线条、矩形、椭圆和文本需要两种表达式，其值将被评估和类型检查：
- en: '[PRE91]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'If none of the preceding tokens apply, a syntax error is reported:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的任何标记都不适用，则报告语法错误：
- en: '[PRE92]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Parsing the expressions of the language
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析语言的表达式
- en: 'An expression, at its lowest priority level, is made up by two multiplication
    or division expressions. First, we call `mulDivExpression`, which is the next
    expression in increasing priority order, to obtain the left value of a possible
    addition or subtraction expression, and then `expressionRest`, which checks if
    there actually is such an expression:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低优先级上，一个表达式由两个乘法或除法表达式组成。首先，我们调用 `mulDivExpression`，这是按优先级顺序的下一个表达式，以获得可能的加法或减法表达式的左值，然后调用
    `expressionRest`，以检查实际上是否存在这样的表达式：
- en: '[PRE93]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `expressionRest` method checks whether the next token is a plus or a minus.
    In that case, we have an addition or subtraction expression, the token is matched,
    the left and right values are type checked, and the resulting expression is evaluated
    and returned:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`expressionRest` 方法检查下一个标记是否为加号或减号。在这种情况下，我们有一个加法或减法表达式，匹配标记，检查左右值的类型，然后评估并返回结果表达式：'
- en: '[PRE94]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `mulDivExpression` method works in a way similar to `expression` shown
    previously. It calls `primaryExpression` and `mulDivExpressionRest`, which look
    for multiplication and division. Multiplication and division have higher priority
    than addition and subtraction. As stated in *The grammar of source language* section
    previously, we need a new pair of rules in the grammar, with two pairs of methods
    in the parser for the addition/subtraction and multiplication/division expressions:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`mulDivExpression` 方法的工作方式与之前展示的 `expression` 类似。它调用 `primaryExpression` 和
    `mulDivExpressionRest`，寻找乘法和除法。乘法和除法的优先级高于加法和减法。正如之前在 *源语言语法* 部分所述，我们需要在语法中添加一对新规则，在解析器中有两对方法用于加法/减法和乘法/除法表达式：'
- en: '[PRE95]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Finally, the primary expression is made up by a point, coordinate, color, or
    font expression. It can also be made up by an expression enclosed in parentheses,
    a name (in which case we look up its value), or a value:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，主表达式由一个点、坐标、颜色或字体表达式组成。它也可以由括号内的表达式、一个名称（在这种情况下我们查找其值）或一个值组成：
- en: '[PRE96]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The coordinate expression takes a point and returns its x or y coordinate.
    We match the keyword and the parentheses and call expressions in between. We then
    check that the value of the expression is a point, and finally call `evaluate`
    to extract the *x* or *y* coordinate:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标表达式接受一个点并返回其 x 或 y 坐标。我们匹配关键字和括号，并调用括号之间的表达式。然后我们检查表达式的值是否为点，最后调用 `evaluate`
    以提取 *x* 或 *y* 坐标：
- en: '[PRE97]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'A point expression is made up by the keyword `point` and two numerical expressions:
    the *x* and *y* coordinate:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 点表达式由关键字 `point` 和两个数值表达式组成：*x* 和 *y* 坐标：
- en: '[PRE98]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'A color expression is made up by the keyword `color` and three numerical expressions:
    the red, green, and blue components:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色表达式由关键字 `color` 和三个数值表达式组成：红色、绿色和蓝色成分：
- en: '[PRE99]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'A font expression is made up by the keyword `font` and two expressions: the
    name of the font (string) and its size (numerical):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 字体表达式由关键字 `font` 和两个表达式组成：字体的名称（字符串）和其大小（数值）：
- en: '[PRE100]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'An expression can be enclosed by parentheses. In that case, we match the parentheses
    and call `expression` in between to obtain the value of the expression:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式可以被括号包围。在这种情况下，我们匹配括号，并在其中调用 `expression` 以获得表达式的值：
- en: '[PRE101]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In case of a name, we look up its value in the assignment map and return the
    value. If there is no value, a semantic error is reported:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在名称的情况下，我们在赋值映射中查找其值并返回该值。如果没有值，则报告语义错误：
- en: '[PRE102]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In the case of a value, we simply return the value:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在值的情况下，我们直接返回该值：
- en: '[PRE103]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In any other case, a syntax error is reported:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何其他情况下，都会报告语法错误：
- en: '[PRE104]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Type checking the expression
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式类型检查
- en: 'The first `checkType` method checks the type of an expression with one value.
    When setting a pen or brush style, the type must be a pen or brush style, respectively:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `checkType` 方法检查具有一个值的表达式的类型。当设置笔或画刷样式时，类型必须是笔或画刷样式：
- en: '[PRE105]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'When setting a color or a font, the value must be a color or a font, respectively:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置颜色或字体时，值必须是颜色或字体：
- en: '[PRE106]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'When setting an alignment, the value must be an alignment:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置对齐方式时，值必须是对齐方式：
- en: '[PRE107]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'When extracting the *x* or *y* coordinate from a point, the value must be a
    point:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当从一个点中提取 *x* 或 *y* 坐标时，值必须是一个点：
- en: '[PRE108]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The second `checkType` method takes two values. The drawing instructions must
    take two points:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `checkType` 方法接受两个值。绘图指令必须接受两个点：
- en: '[PRE109]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The drawing of text instructions must take a point and a string:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 文本绘图指令必须接受一个点和字符串：
- en: '[PRE110]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Evaluating the values of the expressions
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估表达式的值
- en: 'The first `evaluate` method returns the value of an expression with one value.
    The *x* and *y* coordinate operators return the *x* or *y* coordinate of the point:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `evaluate` 方法返回具有一个值的表达式的值。*x* 和 *y* 坐标运算符返回点的 *x* 或 *y* 坐标：
- en: '[PRE111]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The assertion is for debugging purposes only, and we return false simply because
    the method has to return a value:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 断言仅用于调试目的，我们返回 false 仅因为该方法必须返回一个值：
- en: '[PRE112]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Finally, the second `evaluate` method evaluates the value of expressions with
    two values. First, we extract numerical values and evaluate the arithmetic expressions:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第二个 `evaluate` 方法评估具有两个值的表达式的值。首先，我们提取数值并评估算术表达式：
- en: '[PRE113]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'In case of division by zero, a semantic error is reported:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在除以零的情况下，报告语义错误：
- en: '[PRE114]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Finally, in the point expression, we return a point value holding the two numerical
    values holding its *x* and *y* coordinates:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在点表达式中，我们返回一个包含其 *x* 和 *y* 坐标两个数值的点值：
- en: '[PRE115]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'As in the first evaluate case previously, the assertion is for debugging purposes
    only, and we return false simply because the method has to return a value:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的第一个评估情况，断言仅用于调试目的，我们返回 false 仅因为该方法必须返回一个值：
- en: '[PRE116]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The viewer
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看器
- en: Finally, it is time to write the viewer, the last part of our DSL. The viewer
    iterates through the actions and displays the graphical objects. The `ViewerWidget`
    class inherits the Qt class `QWidget`, which displays a widget on the screen.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候编写查看器，我们 DSL 的最后一部分。查看器遍历动作并显示图形对象。`ViewerWidget` 类继承自 Qt 类 `QWidget`，它在屏幕上显示小部件。
- en: '**ViewerWidget.h:**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**ViewerWidget.h:** '
- en: '[PRE117]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The constructor calls the constructor of the base class `QWidget` and stores
    a reference to the action list:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数调用基类 `QWidget` 的构造函数，并存储动作列表的引用：
- en: '[PRE118]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The main part of the class is the `paintEvent` method. It gets called every
    time the widget needs to be repainted and iterates through the actions list:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 类的主要部分是 `paintEvent` 方法。每当窗口需要重绘时，它都会被调用，并遍历动作列表：
- en: '[PRE119]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The default constructor of `QFont` is called, which initializes the font to
    an appropriate system font. Both the horizontal and vertical alignment is centered.
    Finally, `m_actionList` holds a reference to the action list generated by the
    parser:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `QFont` 的默认构造函数，将字体初始化为合适的系统字体。水平和垂直对齐都是居中的。最后，`m_actionList` 持有由解析器生成的动作列表的引用：
- en: '[PRE120]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The `ViewerWidget.cpp` file holds the definitions of the methods of the `ViewerWidget`
    class.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewerWidget.cpp` 文件包含 `ViewerWidget` 类的方法定义。'
- en: '**ViewerWidget.cpp:**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**ViewerWidget.cpp:** '
- en: '[PRE121]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The constructor calls the constructor of the base class `QWidget` with the
    parent widget, initializes the `m_actionList` reference, sets the title of the
    widget, and sets an appropriate size:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数调用基类 `QWidget` 的构造函数，并传入父窗口小部件，初始化 `m_actionList` 引用，设置窗口标题，并设置一个合适的尺寸：
- en: '[PRE122]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The `paintEvent` method is called every time the widget needs to be repainted.
    First, the `QPainter` object `painter` is defined, we then iterate through the
    action list:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 每次小部件需要重新绘制时，都会调用 `paintEvent` 方法。首先定义 `QPainter` 对象 `painter`，然后遍历动作列表：
- en: '[PRE123]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The `SetPenColor` action creates a new pen with the new color and current style,
    which is added to `painter`. In the same way, the `SetPenStyle` action creates
    a pen with the new style and the current color:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetPenColor` 动作创建了一个带有新颜色和当前样式的笔，并将其添加到 `painter` 中。同样，`SetPenStyle` 动作创建了一个带有新样式和当前颜色的笔：'
- en: '[PRE124]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We set the color and style of the brush in the same way as we set the pen previously.
    The only difference is that we create a brush instead of a pen:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与之前设置笔颜色和样式相同的方式设置画刷的颜色和样式。唯一的区别是我们创建了一个画刷而不是笔：
- en: '[PRE125]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'In the case of the font, we call `setFont` on `painter`. Thereafter, the font
    is associated to `painter`, and will be used when writing text:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在字体的情况下，我们在 `painter` 上调用 `setFont`。之后，字体与 `painter` 关联，并在写入文本时使用：
- en: '[PRE126]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The horizontal and vertical alignment are stored in `m_horizontalAlignment`
    and `m_verticalAlignment`, which are values that are later used when writing text:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 水平和垂直对齐方式存储在 `m_horizontalAlignment` 和 `m_verticalAlignment` 中，这些值在写入文本时会被使用：
- en: '[PRE127]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Now, it is time to actually draw some graphical objects. A line is simply drawn
    between two points, while a rectangle or ellipse has top-left and bottom-right
    corners, which are placed in a rectangle that is used as a parameter to the calls
    to `drawRect` and `drawEllipse`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候实际绘制一些图形对象了。一条线简单地画在两个点之间，而矩形或椭圆有上左和下右角，这些角被放置在一个矩形中，该矩形用作 `drawRect`
    和 `drawEllipse` 调用的参数：
- en: '[PRE128]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Finally, we write text. We start by extracting the point to center the text
    around and the text to draw. We then obtain the size of the text (in pixels) with
    the Qt `QFontMetrics` class:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们写入文本。我们首先提取点以围绕文本中心进行绘制，然后使用 Qt 的 `QFontMetrics` 类获取文本的大小（以像素为单位）：
- en: '[PRE129]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'In the case of left horizontal alignment, the left side of the text is the
    *x* coordinate of the point. In the case of center alignment, the left side of
    the text is moved to the left with half the text width, and in the case of right
    alignment, the left side is moved to the left with the whole text width:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在左对齐的情况下，文本的左侧是点的 *x* 坐标。在居中对齐的情况下，文本的左侧会向左移动半个文本宽度，而在右对齐的情况下，文本的左侧会向左移动整个文本宽度：
- en: '[PRE130]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'In the same way: in the case of top vertical alignment, the top side of the
    text is the *y* coordinate of the point. In the case of center alignment, the
    top side of the text is moved upwards with half of the text height, and in the
    case of bottom alignment, the top side is moved upwards with the whole text height:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 同样：在顶部垂直对齐的情况下，文本的顶部是点的 *y* 坐标。在居中对齐的情况下，文本的顶部向上移动半个文本高度，而在底部对齐的情况下，文本的顶部向上移动整个文本高度：
- en: '[PRE131]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The main function
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: Finally, the main function calls the `init` static method on the scanner in
    order to initialize its tokens, keywords, and values. A `QApplication` object
    is created, the source code is read and parsed, and the viewer widget is created.
    It executes the action list and displays the graphical objects. The application
    executes until the user presses the close button in the top-right corner.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，主函数调用扫描器的 `init` 静态方法以初始化其标记、关键字和值。创建了一个 `QApplication` 对象，读取并解析源代码，并创建了查看器小部件。它执行动作列表并显示图形对象。应用程序会一直执行，直到用户按下右上角的关闭按钮。
- en: '**Main.cpp:**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp:**'
- en: '[PRE132]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'In the case of a syntactic or semantic error, its message is displayed in a
    message box:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现语法或语义错误的情况下，其消息会在消息框中显示：
- en: '[PRE133]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started to develop a DSL that generates a sequence of actions
    creating graphical objects, which are viewed in a widget. Our DSL supports instructions
    for drawing graphical objects such as lines, rectangles, ellipses, and text, and
    for setting the color, style, and alignment of the objects. It also supports expressions
    with arithmetic operators.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始开发一个 DSL，该 DSL 生成一系列创建图形对象的动作，这些对象在窗口小部件中查看。我们的 DSL 支持绘制图形对象（如线条、矩形、椭圆和文本）的指令，以及设置对象的颜色、样式和对齐方式。它还支持带有算术运算符的表达式。
- en: The language of our DSL is defined by grammar and is made up by a scanner that
    scans the text for meaningful parts, the parser checks that the source code complies
    with the grammar and generates a sequence of actions, which is read and executed
    by the viewer.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们领域特定语言（DSL）的语法由语法规则定义，并由一个扫描器组成，该扫描器扫描文本以查找有意义的部分，解析器检查源代码是否符合语法，并生成一系列动作，这些动作由查看器读取并执行。
- en: In the next chapter, we will continue to develop our DSL. The DSL of this chapter
    only supports code executed in straight sequence. However, in the next chapter,
    we will add function calls as well as selection and iteration (the `if` and `while`
    instructions).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续开发我们的DSL。本章的DSL仅支持按顺序执行的代码。然而，在下一章中，我们将添加函数调用以及选择和迭代（`if`和`while`指令）。
