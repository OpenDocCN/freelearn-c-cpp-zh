- en: Building an Object-Following Robot with OpenCV
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenCV构建一个目标跟随机器人
- en: 'After installing OpenCV in the previous chapter, it is now time to perform
    image-processing operations using the OpenCV library. In this chapter, we will
    cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中安装了OpenCV之后，现在是时候使用OpenCV库执行图像处理操作了。在本章中，我们将涵盖以下主题：
- en: Image processing with OpenCV
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenCV进行图像处理
- en: Viewing a video feed from the Pi camera
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看来自Pi摄像头的视频源
- en: Building an object-following robot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个目标跟随机器人
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'There are no new technical requirements as such for this chapter, but you will
    require the following things to perform the examples:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章没有新的技术要求，但是您需要以下内容来执行示例：
- en: A red, green, or blue colored ball for detection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于检测红色、绿色或蓝色的球
- en: A Pi camera and an ultrasonic sensor mounted on the robot
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装在机器人上的Pi摄像头和超声波传感器
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter07).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以从[https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Robotics-Programming-with-Cpp/tree/master/Chapter07)下载。
- en: Image processing with OpenCV
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenCV进行图像处理
- en: In this section, we will look at the important functions of the OpenCV library.
    After that, we will write a simple C++ program using the OpenCV libraries and
    perform different image-processing operations on an image.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看OpenCV库的重要函数。之后，我们将使用OpenCV库编写一个简单的C++程序，并对图像执行不同的图像处理操作。
- en: Important functions in OpenCV
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCV中的重要函数
- en: 'Before writing any OpenCV program, it is important to understand some of the
    main functions in OpenCV and the output that these functions can give us. Let''s
    start by looking at the functions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何OpenCV程序之前，了解OpenCV中的一些主要函数以及这些函数可以给我们的输出是很重要的。让我们从查看这些函数开始：
- en: '**`imread()`**: The `imread()` function is used to read an image or a video
    feed from the Pi camera or webcam. Inside the `imread()` function, we have to
    provide the location of the image. If the image and program files are in the same
    folder, we only need to provide the name of the image. However, if the image is
    stored in a different folder, then we need to provide the complete path of the
    image inside the `imread` function. We store the image value from the `imread()`
    function inside a matrix (`Mat`) variable.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`imread()`**: `imread()`函数用于从Pi摄像头或网络摄像头读取图像或视频。在`imread()`函数内部，我们必须提供图像的位置。如果图像和程序文件在同一个文件夹中，我们只需要提供图像的名称。但是，如果图像存储在不同的文件夹中，那么我们需要在`imread`函数内提供图像的完整路径。我们将从`imread()`函数中存储的图像值存储在一个矩阵（`Mat`）变量中。'
- en: 'If the image and `.cpp` files are in the same folder, the code will look as
    follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像和`.cpp`文件在同一个文件夹中，代码如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If the image and `.cpp` file are in different folders, the code will look as
    follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像和`.cpp`文件在不同的文件夹中，代码如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`imshow()`: The `imshow()` function is used to show or view the image:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imshow()`: `imshow()`函数用于显示或查看图像：'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `imshow()` function consists of two parameters, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`imshow()`函数包括两个参数，如下：'
- en: The first parameter is the window text
  id: totrans-22
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是窗口文本
- en: The second parameter is the variable name of the image that is to be displayed
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是要显示的图像的变量名
- en: 'The output of the `imshow()` function is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`imshow()`函数的输出如下：'
- en: '![](img/9cb8e918-e21b-4484-994c-a53e49eaf1f6.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9cb8e918-e21b-4484-994c-a53e49eaf1f6.png)'
- en: '`resize()`: The `resize()` function is used to resize the dimensions of the
    image. This function is generally used when users are working with multiple windows
    at the same time:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resize()`: `resize()`函数用于调整图像的尺寸。当用户同时使用多个窗口时，通常会使用此函数：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function consist of three parameters:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数包括三个参数：
- en: The first parameter is the variable name of the original image (`img`) that
    is to be resized.
  id: totrans-29
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是要调整大小的原始图像（`img`）的变量名。
- en: The second parameter is the variable name of the new image (`rzimg`) that will
    be resized.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是将调整大小的新图像（`rzimg`）的变量名。
- en: The third parameter is `cvSize`, and in this we enter the **new width** andthe
    **height value**.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是`cvSize`，在其中输入**新宽度**和**高度值**。
- en: 'The output of the `resize()` function is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`resize()`函数的输出如下：'
- en: '![](img/2fcade67-80dc-476e-b1d2-1a7ad3138fa3.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2fcade67-80dc-476e-b1d2-1a7ad3138fa3.png)'
- en: '`flip()`: This function is used to flip the image either horizontally, or vertically,
    or both at the same time:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flip()`: 此函数用于水平翻转、垂直翻转或同时进行两者：'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function consists of three parameters:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数包括三个参数：
- en: The first parameter (`img`) is the variable name of the original image.
  id: totrans-37
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数（`img`）是原始图像的变量名。
- en: The second parameter (`flipimage`) is the variable name of the flipped image.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数（`flipimage`）是翻转后的图像的变量名。
- en: The third parameter is the flipping type; `0` denotes a vertical flip, `1` represents
    a horizontal flip, and `-1` means that the image should flip both horizontally
    and vertically.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是翻转类型；`0`表示垂直翻转，`1`表示水平翻转，`-1`表示图像应同时水平和垂直翻转。
- en: 'The output of the `flip()` function is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`flip()`函数的输出如下：'
- en: '![](img/2e0a5b4a-3110-465f-af3f-f2e5d0309fe8.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e0a5b4a-3110-465f-af3f-f2e5d0309fe8.png)'
- en: '`cvtColor()`: This function is used to convert a normal RGB-colored image into
    a gray-scale image:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cvtColor()`: 此函数用于将普通的RGB彩色图像转换为灰度图像：'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This function consists of three parameters:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数包括三个参数：
- en: The first parameter (`img`) is the variable name of the original image
  id: totrans-45
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数（`img`）是原始图像的变量名
- en: The second parameter (`grayimage`) is the variable of the new image that will
    be converted to gray-scale
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数（`grayimage`）是将转换为灰度的新图像的变量
- en: The third parameter, `COLOR_BGR2GRAY`,is the conversion type; BGR is RGB written
    in reverse
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数，`COLOR_BGR2GRAY`，是转换类型；BGR是RGB倒过来写的
- en: 'The output of the `cvtColor()` function is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`cvtColor()`函数的输出如下：'
- en: '![](img/6bb5991a-bb09-4079-b1e7-36fb272f016d.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bb5991a-bb09-4079-b1e7-36fb272f016d.png)'
- en: '`threshold()`: The thresholding method is used to separate out regions of an
    image that represent an object. In simple terms, thresholding is used to recognize
    a particular object in an image. The thresholding method takes a source image
    (`src`), the thresholding value, and the maximum threshold value (`255`) as an
    input. It produces an output image (`thresimg`) by comparing the pixel values
    of the source image to the threshold value:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threshold()`: 阈值化方法用于分离代表对象的图像区域。简单来说，阈值化用于识别图像中的特定对象。阈值化方法接受源图像（`src`）、阈值和最大阈值（`255`）作为输入。它通过比较源图像的像素值与阈值来生成输出图像（`thresimg`）：'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The threshold function consists of five parameters:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值函数由五个参数组成：
- en: The first parameter (`src`) is the variable name of the image that is to be
    thresholded.
  id: totrans-53
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数（`src`）是要进行阈值化的图像的变量名。
- en: The second parameter (`thresimg`) is the variable name of the thresholded image.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数（`thresimg`）是阈值化图像的变量名。
- en: The third parameter (`threshold value`) is the threshold value (from 0 to 255).
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数（`阈值`）是阈值（从0到255）。
- en: The fourth parameter (`max threshold value`) is the maximum threshold value
    (`255`).
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数（`最大阈值`）是最大阈值（`255`）。
- en: The fifth parameter (`threshold type`) is the thresholding type.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个参数（`阈值类型`）是阈值化类型。
- en: 'Generally, there are five types of thresholding, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，有五种类型的阈值化，如下所示：
- en: '**0-binary**: Binary thresholding is the simplest form of thresholding. In
    this thresholding, if any pixel on the source image (`src`) has a value greater than
    the threshold value, then in the output image (`thresimg`), this pixel is set
    to the maximum threshold value (`255`), and it will turn white. On the other hand,
    if any pixel on the source image has a value less than the threshold value, then
    in the output image the pixel value is set to `0`, and it will appear black.'
  id: totrans-59
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0-二进制**：二进制阈值化是阈值化的最简单形式。在这种阈值化中，如果源图像（`src`）上的任何像素值大于阈值，则在输出图像（`thresimg`）中，该像素将被设置为最大阈值（`255`），并且将变为白色。另一方面，如果源图像上的任何像素值小于阈值，则在输出图像中，该像素值将被设置为`0`，并且将变为黑色。'
- en: 'For example, in the following code, the thresholded value is set to `85`, the
    maximum threshold value is `255`, and the thresholding type is a binary represented
    by the number `0`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下代码中，阈值设置为`85`，最大阈值为`255`，阈值类型为用数字`0`表示的二进制：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, if any pixels on the Apple Image source image have a value greater than
    the threshold value (that is, greater than `85`), then those pixels will turn
    white in the output image. Similarly, the pixels on the source image whose values
    are less than the threshold value will turn black in the output image:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果苹果图像源图像上的任何像素值大于阈值（即大于`85`），那么这些像素将在输出图像中变为白色。同样，源图像上值小于阈值的像素将在输出图像中变为黑色。
- en: '![](img/dcdf5b7c-3085-4601-a90f-fbb742150def.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcdf5b7c-3085-4601-a90f-fbb742150def.png)'
- en: Binary thresholding
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制阈值化
- en: '**1-binary inverted**: Binary inverted thresholding is exactly the opposite
    of binary thresholding. In this type of thresholding, the pixel of the output
    image will turn black (`0`) if the source image''s pixel value is greater than
    the threshold value, and will turn white (`255`) if the pixel value of the source
    image is less than the threshold value:'
  id: totrans-65
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1-二进制反转**：二进制反转阈值化正好与二进制阈值化相反。在这种类型的阈值化中，如果源图像的像素值大于阈值，则输出图像的像素将变为黑色（`0`），如果源图像的像素值小于阈值，则输出图像的像素将变为白色（`255`）：'
- en: '![](img/64064bd2-0ac0-4793-a79a-c5600f8f2d18.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64064bd2-0ac0-4793-a79a-c5600f8f2d18.png)'
- en: Binary inverted thresholding
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制反转阈值化
- en: '**2-truncated** **thresholding**: In truncated thresholding, if any pixel value
    on the `src` source image is greater than the threshold value, then in the output
    image, this pixel will be set to the threshold value. On the other hand, if any
    pixel value on the `src` source image is less than the threshold value, then in
    the output image, the pixel will retain its original color value:'
  id: totrans-68
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2-截断** **阈值化**：在截断阈值化中，如果`src`源图像上的任何像素值大于阈值，则在输出图像中，该像素将被设置为阈值。另一方面，如果`src`源图像上的任何像素值小于阈值，则在输出图像中，该像素将保留其原始颜色值：'
- en: '![](img/fcf7b239-5bf5-4a6f-a6d7-d76f05083cb9.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcf7b239-5bf5-4a6f-a6d7-d76f05083cb9.png)'
- en: Truncated thresholding
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 截断阈值化
- en: '**3-threshold to zero**: In this thresholding, if any pixel value on the `src` source
    imageis greater than the threshold value, then in the output image, the pixel
    will retain its original color value. On the other hand, if any pixel value on
    the `src`source image is less than the threshold value, then in the output image
    the pixel will be set to `0` (that is, black):'
  id: totrans-71
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3-阈值为零**：在这种阈值化中，如果`src`源图像上的任何像素值大于阈值，则在输出图像中，该像素将保留其原始颜色值。另一方面，如果`src`源图像上的任何像素值小于阈值，则在输出图像中，该像素将被设置为`0`（即黑色）：'
- en: '![](img/6f3a8fc1-a1b9-4010-9f76-43c7598b936f.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f3a8fc1-a1b9-4010-9f76-43c7598b936f.png)'
- en: Threshold to zero
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值为零
- en: '**4-threshold to zero inverted**: In this thresholding, if any pixel value
    on the `src` is greater than the threshold value, then in the output image, the pixel
    will be set to `0`. If any pixel value on the `src`is less than the threshold
    value, then in the output image, the pixel will retain its original color value:'
  id: totrans-74
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4-阈值为零反转**：在这种阈值化中，如果`src`上的任何像素值大于阈值，则在输出图像中，该像素将被设置为`0`。如果`src`上的任何像素值小于阈值，则在输出图像中，该像素将保留其原始颜色值：'
- en: '![](img/2c0e2d36-c417-4ab2-9ca8-6369d7808e9d.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c0e2d36-c417-4ab2-9ca8-6369d7808e9d.png)'
- en: Threshold to zero inverted
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值为零反转
- en: '`inRange()`: The `inRange()` function is an advanced form of the thresholding
    function. Inside this function, we have to enter the minimum and maximum RGB color
    values of the object that we want to recognize. The `inRange()` function consists
    of four parameters:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inRange()`: `inRange()`函数是阈值函数的高级形式。在这个函数内部，我们必须输入我们想要识别的对象的最小和最大RGB颜色值。`inRange()`函数由四个参数组成：'
- en: The first parameter (`img`) is the variable name of the image that is to be
    thresholded.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数（`img`）是要进行阈值处理的图像的变量名。
- en: There are two `Scalar` functions. In the second parameter, which is the first
    `Scalar` function, we have to enter the minimum RGB color of the object.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两个`Scalar`函数。在第一个`Scalar`函数中的第二个参数中，我们必须输入对象的最小RGB颜色。
- en: In the third parameter, which is the second `Scalar` function, we will enter
    the maximum RGB color value of the object.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三个参数中，也就是第二个`Scalar`函数中，我们将输入对象的最大RGB颜色值。
- en: 'The fourth parameter (`thresImage`) represents the output of the threshold
    image:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数（`thresImage`）代表阈值图像的输出：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Image moments**—the concept of image moments is borrowed from **moments**,
    which is used in both mechanics and statistics to describe the spatial distribution
    of a set of points. In image processing or computer vision, an image moment is
    used to find the **centroid** of a shape, which is the average mean of all the
    points in a shape. In simple terms, image moments are used to find the center
    of any object once we have segmented it from the entire image. For example, in
    our case, we might want to find the center of the apple. The **image moments formula**
    for calculating the center of an object from an image is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像矩**——图像矩的概念源自**矩**，它在力学和统计学中用于描述一组点的空间分布。在图像处理或计算机视觉中，图像矩用于找到形状的**质心**，即形状中所有点的平均值。简单来说，图像矩用于在我们从整个图像中分割出对象后找到任何对象的中心。例如，在我们的情况下，我们可能想要找到苹果的中心。从图像计算对象的中心的**图像矩公式**如下：'
- en: '![](img/03fefae2-083d-4dc8-a8ac-d5a21dc4d18c.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03fefae2-083d-4dc8-a8ac-d5a21dc4d18c.png)'
- en: '*x* represents the width of image'
  id: totrans-85
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x*代表图像的宽度'
- en: '*y* represents the height of image'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*y*代表图像的高度'
- en: '*M10* represents the sum of all the *x* values in the image'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*M10*代表图像中所有*x*值的总和'
- en: '*M01* represents the sum of all the *y* values in the image'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*M01*代表图像中所有*y*值的总和'
- en: '*M00* represents the entire area of the image'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*M00*代表图像的整个区域'
- en: '`circle`: As the name suggests, this function is used to draw a circle. It
    takes five parameters as the input:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`circle`: 正如其名，这个函数用于画圆。它有五个参数作为输入：'
- en: The first parameter (`img`) is the variable name of the image on which you have
    to draw the circle.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数（`img`）是你要在其上画圆的图像的变量名。
- en: The second parameter (`point`) is the center (the *x*, *y* position) point for
    the circle.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数（`point`）是圆的中心（*x*，*y*位置）点。
- en: The third parameter (`radius`) is the radius of the circle.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数（`radius`）是圆的半径。
- en: The fourth parameter (`Scalar(B,G,R)`) is for coloring the circle; we do this
    using the `Scalar()` function.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个参数（`Scalar(B,G,R)`）是为圆着色的；我们使用`Scalar()`函数来做到这一点。
- en: 'The fifth parameter (`thickness`) is the thickness of the circle:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个参数（`thickness`）是圆的厚度：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Object recognition using OpenCV
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenCV进行对象识别
- en: 'Now that we''ve understood the important functions of OpenCV, let''s write
    a program to detect a colored ball from an image. Before we start, the first thing
    we have to do is to take a proper photo of the ball. You can use any ball for
    this project, but just make sure that the ball has a single color (red, green,
    or blue color ball is highly recommended) and that it is not multicolored. I''m
    using a green ball for this project:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了OpenCV的重要功能，让我们编写一个程序来从图像中检测一个有颜色的球。在我们开始之前，我们必须做的第一件事是拍摄球的合适照片。你可以用任何球来做这个项目，但要确保球是单色的（红色、绿色或蓝色的球是强烈推荐的），并且不是多色的。我在这个项目中使用了一个绿色的球：
- en: '![](img/b106b7e4-d5e1-4315-9a5f-780605e86b64.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b106b7e4-d5e1-4315-9a5f-780605e86b64.png)'
- en: Capturing the image
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拍摄图像
- en: 'To capture the image of your ball, place it on some dark surface. I have placed
    my green ball on a mobile phone case, which is black:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕捉你的球的图像，把它放在一些黑色的表面上。我把我的绿色球放在一个黑色的手机壳上：
- en: '![](img/6682ea0b-0d22-4d37-9f4c-f97c19c5f083.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6682ea0b-0d22-4d37-9f4c-f97c19c5f083.png)'
- en: If your ball is black, or of a dark color, you can place the ball on a surface
    that has a light color. This is to make sure there is a very high contrast between
    the color of the ball and the color of the background, which will help us in thresholding
    later on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的球是黑色，或者颜色较暗，你可以把球放在一个颜色较浅的表面上。这是为了确保球的颜色和背景的颜色之间有很高的对比度，这将有助于我们后面的阈值处理。
- en: 'While capturing the image, make sure that there are no white colored patches
    on the ball, as this may cause problems later on while thresholding:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在拍摄图像时，确保球上没有白色斑块，因为这可能会在后面的阈值处理中造成问题：
- en: '![](img/a50b303b-299f-4688-a872-7b1113acd8c0.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a50b303b-299f-4688-a872-7b1113acd8c0.png)'
- en: The photo on the left has a big white region because of too much lighting. On
    the right, the ball is lit up properly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的照片有一个大的白色区域，因为光线太亮。右边，球被适当照亮。
- en: Once you are satisfied with the captured image, transfer it to your laptop.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对拍摄的图像满意，将其传输到你的笔记本电脑上。
- en: Finding the RGB pixel values
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 找到RGB像素值
- en: 'We will now find the RGB pixel values of the ball by examining different points
    on it using the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过以下步骤检查球上不同点的RGB像素值来找到球的RGB像素值：
- en: 'Open Paint and open the saved image of the ball, as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开画图并打开保存的球的图像，如下：
- en: '![](img/ed5a0ead-7fce-4d7a-b840-4bac834a0314.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed5a0ead-7fce-4d7a-b840-4bac834a0314.png)'
- en: 'Next, using the color picker tool, take samples of the color by clicking anywhere
    on the ball:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用取色器工具，在球的任何位置单击取样颜色：
- en: '![](img/5a72281c-cd2c-488c-9a25-862740b7f79e.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a72281c-cd2c-488c-9a25-862740b7f79e.png)'
- en: 'The Color 1 box will show the sample of the color that was clicked on. In my
    case, this is green:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色1框将显示被点击的颜色的样本。在我的情况下，这是绿色：
- en: '![](img/55d4a8ea-436c-44b7-809a-ced4e08fef9e.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55d4a8ea-436c-44b7-809a-ced4e08fef9e.png)'
- en: 'If you click on the Edit Colors option, you will see the RGB color value of
    that particular pixel. In my case, the RGB color value for the green pixel is
    Red: `61`, Green: `177`, and Blue: `66`. Make a note of these values and save
    them for later:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您点击“编辑颜色”选项，您将看到该像素的RGB颜色值。在我的情况下，绿色像素的RGB颜色值为红色：`61`，绿色：`177`，蓝色：`66`。记下这些值，以备后用：
- en: '![](img/79be885f-8be2-4410-9213-6f295f4e68af.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79be885f-8be2-4410-9213-6f295f4e68af.png)'
- en: 'Now, select the color picker option again and click on another colored area
    of the ball to find out the RGB color value of that particular pixel. Again, note
    down this value. Do the same thing 13 to 14 times, making sure you include the
    lightest and the darkest colors on the ball:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次选择取色器选项，点击球的另一个彩色区域，找出该像素的RGB颜色值。再次记录这个值。重复13到14次，确保包括球上最浅和最暗的颜色：
- en: '![](img/73e809be-ab83-4576-8502-61e1f9202d22.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73e809be-ab83-4576-8502-61e1f9202d22.png)'
- en: I have noted down the RGB values for six points on the edges of the ball, four
    points at random places around the ball, and six points on places where the color
    is either light green or dark green. After finding out the RGB values, highlight
    the lowest red, green, and blue color values and the highest red, green, and blue
    color values. We will use these values in our program later on to threshold the
    image.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经记录了球边缘六个点的RGB值，球周围随机位置的四个点的RGB值，以及颜色为浅绿色或深绿色的六个点的RGB值。找到RGB值后，突出显示最低的红色、绿色和蓝色值，以及最高的红色、绿色和蓝色值。我们将在程序中稍后使用这些值来对图像进行阈值处理。
- en: You now need to transfer this image to your RPi. I transferred my image via Google
    Drive**. **I did this by uploading the image to Google Drive, next, opening the
    default Chromium web browser inside my RPi, signing into my Gmail account, opening
    Google Drive, and downloading the image.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要将这个图像传输到您的RPi。我通过**Google Drive**传输了我的图像。我通过将图像上传到Google Drive，然后在我的RPi内打开默认的Chromium网络浏览器，登录我的Gmail账户，打开Google
    Drive，并下载图像来完成这一步。
- en: The object detection program
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物体检测程序
- en: 'The program for detecting the green ball is named `ObjectDetection.cpp` and
    I have saved it inside the `OpenCV_codes` folder. I have also copied the `greenball.png`
    image to this folder. You can download the `ObjectDetection.cpp` program from
    the `Chapter07` folder of the GitHub repository. So, the program for detecting
    the green ball is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检测绿色球的程序名为`ObjectDetection.cpp`，我将其保存在`OpenCV_codes`文件夹中。我还将`greenball.png`图像复制到了这个文件夹中。您可以从GitHub存储库的`Chapter07`文件夹中下载`ObjectDetection.cpp`程序。因此，用于检测绿色球的程序如下：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding program, we are importing four OpenCV libraries, which are `opencv.hpp`,
    `core.hpp`, `highgui.hpp`, and `imgproc.hpp`. We then declared the `cv` namespace
    that is a part of the OpenCV library.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们导入了四个OpenCV库，它们是`opencv.hpp`、`core.hpp`、`highgui.hpp`和`imgproc.hpp`。然后我们声明了OpenCV库的`cv`命名空间。
- en: 'The following is the explanation of the preceding program:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面程序的解释：
- en: Inside the `main` function, we declared three matrix variables called `img`,
    `resizeimg`, and `thresimage`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数内，我们声明了三个矩阵变量，分别为`img`、`resizeimg`和`thresimage`。
- en: Next, the `greenball.png` file is read by the `imread()` function and stored
    in the `img` variable.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`imread()`函数读取`greenball.png`文件，并将其存储在`img`变量中。
- en: 'The `imshow("Green Ball Image", img)` line will display the image in a new
    window, as shown in the following screenshot:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`imshow("Green Ball Image", img)`行将在新窗口中显示图像，如下面的屏幕截图所示：'
- en: '![](img/78b0c58b-4365-4476-8a93-ae7f0cff4575.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78b0c58b-4365-4476-8a93-ae7f0cff4575.png)'
- en: After this, the `waitKey(0)` function will wait for the keyboard input. It will
    then execute the next set of code. Once you press any key, the next two lines
    of code for resizing the image will execute.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，`waitKey(0)`函数将等待键盘输入。然后执行下一组代码。一旦按下任意键，将执行调整图像大小的下两行代码。
- en: 'The `resize` function will resize the width and height of the image so that
    the new width of the image is `640` and the height is `480`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`resize`函数将调整图像的宽度和高度，使得图像的新宽度为`640`，高度为`480`：'
- en: '![](img/cd1136d0-cd91-4c74-ad86-b7b2c19c79d3.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd1136d0-cd91-4c74-ad86-b7b2c19c79d3.png)'
- en: The thresholding operation is then performed using the `inRange` function. Inside
    the first `Scalar` function, I have entered the minimum RGB values for the green
    color of my ball, and in the second `Scalar` function, I have entered the maximum
    RGB values thereof. The thresholded image is stored in the `thresimage` variable.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用`inRange`函数执行阈值处理操作。在第一个`Scalar`函数内，我输入了我的球的绿色的最小RGB值，在第二个`Scalar`函数内，我输入了最大RGB值。阈化后的图像存储在`thresimage`变量中。
- en: Inside the `Scalar` function, we have to enter the blue value first, followed
    by green, and then red.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Scalar`函数内，我们首先输入蓝色值，然后是绿色，最后是红色。
- en: 'After thresholding, the color of the ball will become white and the remaining
    portion of the image will become black. Some portions in the middle of the ball
    will appear black, which is fine. If large areas appear as black inside the white
    color, this means that the thresholding has not happened properly. In this case,
    you can try modifying the RGB values inside the `Scalar` function:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阈值处理后，球的颜色将变为白色，图像的其余部分将变为黑色。球中间的一些部分将呈现为黑色，这是正常的。如果白色内部出现大面积黑色，这意味着阈值处理没有正确进行。在这种情况下，您可以尝试修改`Scalar`函数内的RGB值：
- en: '![](img/7dbbcb36-3994-479a-baff-e29aae6ba464.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7dbbcb36-3994-479a-baff-e29aae6ba464.png)'
- en: Next, using moments, we find the center of the object.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`moments`函数，我们找到对象的中心。
- en: In the `moments(thresimage,true)` line, we have provided the `thresimage` variable
    as an input.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`moments(thresimage,true)`行，我们将`thresimage`变量作为输入。
- en: In the next three lines of code, we find the center of the white area and store
    that value in the point variable, `p`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的三行代码中，我们找到白色区域的中心并将该值存储在点变量`p`中。
- en: 'After that, to display the center of the ball, we use the `circle` function.
    Inside the circle function, we use the `img` variable as we will display the circular
    dot on the original image. Next, the point variable, `p`, tells the function where
    we have to display the dot. The width of the circular dot is set to `5`, and the
    color of the circular dot will be red, as we have only filled the last parameter
    of the `Scalar` function, which denotes the color red. If you want to set another
    color, you can change the color values inside the `Scalar` function:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，为了显示球的中心，我们使用`circle`函数。在圆函数内部，我们使用`img`变量，因为我们将在原始图像上显示圆点。接下来，点变量`p`告诉函数我们在哪里显示点。圆形点的宽度设置为`5`，圆形点的颜色将是红色，因为我们只填充了`Scalar`函数的最后一个参数，表示颜色为红色。如果要设置其他颜色，可以更改`Scalar`函数内的颜色值：
- en: '![](img/59d0c10b-6ec9-4fb7-800c-c3ef54c1006d.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59d0c10b-6ec9-4fb7-800c-c3ef54c1006d.png)'
- en: Press any key one more time and the final `waitKey(0)` function will close all
    of the windows apart from the Terminal window. To close the Terminal window, press
    *Enter*.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按任意键再次按下`waitKey(0)`函数，将关闭除终端窗口之外的所有窗口。要关闭终端窗口，请按*Enter*。
- en: With the preceding program, we have learned how to resize, threshold, and generate
    a point (the red dot) on top of the image of the green ball. In the next section,
    we will perform some image recognition operations on a live video feed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述程序，我们已经学会了如何调整大小、阈值处理，并在绿色球的图像上生成一个点（红点）。在下一节中，我们将对实时视频反馈执行一些图像识别操作。
- en: The OpenCV camera feed program
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCV相机反馈程序
- en: 'We will now write a simple C++ program to view the camera feed from the Pi
    camera. The program for viewing the video is as follows. The program is named
    `Camerafeed.cpp` and you can download it from the `Chaper07` folder of the GitHub
    repository:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个简单的C++程序来查看来自Pi相机的视频反馈。视频查看程序如下。该程序名为`Camerafeed.cpp`，您可以从GitHub存储库的`Chaper07`文件夹中下载：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The OpenCV libraries and namespace declaration is similar to that of the previous
    program:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV库和命名空间声明与先前程序类似：
- en: First, inside the `main` function, we are declaring a matrix variable called
    `videoframe`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`main`函数内部，我们声明了一个名为`videoframe`的矩阵变量。
- en: Next, the `VideoCapture` datatype is used to capture a video feed from the Pi
    camera. It has a variable called `vid(0)`. The `0` number inside the `vid(0)`
    variable represents the index number of the camera. Currently, since we have only
    one camera attached to the RPi, the Pi camera will have an index of `0`. If you
    attach a USB camera to the Raspberry Pi, then the USB camera will have an index
    of `1`. By changing the index number, you can switch between the Pi camera and
    the USB camera.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`VideoCapture`数据类型从Pi相机捕获视频反馈。它有一个名为`vid(0)`的变量。`vid(0)`变量内的`0`数字表示相机的索引号。目前，由于我们只连接了一个相机到RPi，Pi相机的索引将为`0`。如果您将USB相机连接到树莓派，那么USB相机的索引将为`1`。通过更改索引号，您可以在Pi相机和USB相机之间切换。
- en: Next, we specify that the `!vid.isOpened()` condition should be called if the
    camera is not able to capture any video feed. In this case, an `"Error opening
    camera"` message will be printed in the Terminal.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们指定如果相机无法捕获任何视频反馈，则应调用`!vid.isOpened()`条件。在这种情况下，终端将打印出`"Error opening
    camera"`消息。
- en: After that, the `vid.read(videoframe)` command will read the camera feed.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，`vid.read(videoframe)`命令将读取相机反馈。
- en: Using the `imshow("Video output", videoframe)` line, we can now view the camera
    feed.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`imshow("Video output", videoframe)`行，我们现在可以查看相机反馈。
- en: The `waitKey` command will wait for keyboard input. Once you press any key,
    it will exit the code.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`waitKey`命令将等待键盘输入。一旦按下任意键，它将退出代码。'
- en: This is how you can view a video feed using the Pi camera.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您可以使用Pi相机查看视频反馈的方法。
- en: Building an object-following robot
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个目标跟踪机器人
- en: After thresholding an image and viewing the video feed from the Pi camera, we
    will combine both of these programs to create our object-following robot program.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在对图像进行阈值处理并从Pi相机查看视频反馈之后，我们将结合这两个程序来创建我们的目标跟踪机器人程序。
- en: In this section, we will write two programs. In the first program, we place
    the ball in front of the camera and trace it by creating a dot (using moments)
    in the center of the ball. Next, we will move the ball **up**, **down**, **left**, and **right**
    and note the point values at different positions on the camera.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写两个程序。在第一个程序中，我们将球放在相机前面，并通过在球的中心创建一个点（使用矩形）来追踪它。接下来，我们将移动球**上**、**下**、**左**和**右**，并记录相机上不同位置的点值。
- en: In the second program, we will use these point values as an input and make the
    robot follow the ball object.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个程序中，我们将使用这些点值作为输入，并使机器人跟随球对象。
- en: Ball tracing using moments
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用矩形进行球追踪
- en: Before following the ball, the robot should first be able to trace it using
    the Pi camera. Before writing the program, let's see how we are going to track
    the ball.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在跟踪球之前，机器人应首先能够使用Pi相机追踪它。在编写程序之前，让我们看看我们将如何追踪球。
- en: Programming logic
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程逻辑
- en: 'First, we will resize the camera resolution to 640 x 480, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将相机分辨率调整为640 x 480，如下所示：
- en: '![](img/573110e3-d48d-4160-a850-58337f40e3d3.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/573110e3-d48d-4160-a850-58337f40e3d3.png)'
- en: 'After resizing the width and height, we divide the camera screen horizontally
    into three equal sections:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 调整宽度和高度后，我们将相机屏幕水平分为三个相等的部分：
- en: '![](img/58b91348-dc48-4cff-a1e8-39b77c1dd6f4.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58b91348-dc48-4cff-a1e8-39b77c1dd6f4.png)'
- en: The **x coordinate values** from 0 to 214 represent the left section. The **x
    coordinate values** from 214 to 428 represent the forward section, while the **x
    coordinate values** from 428 to 640 represent the right section. We do not need
    to write any specific program to divide the camera screen into these three different
    sections, we just need to remember the minimum and maximum** x point values** for
    each of these sections.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从0到214的**x坐标值**代表左侧部分。从214到428的**x坐标值**代表前进部分，而从428到640的**x坐标值**代表右侧部分。我们不需要编写任何特定的程序来将摄像头屏幕划分为这三个不同的部分，我们只需要记住每个部分的最小和最大**x点值**。
- en: 'Next, we will perform thresholding on the ball object. After this, we will
    use moments and generate a dot on the center of the ball. We will print the point
    value in the console and check the *x* and *y* point values at a particular segment
    of the screen:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对球对象进行阈值处理。之后，我们将使用矩和在球的中心生成一个点。我们将在控制台中打印点值，并检查屏幕特定部分的*x*和*y*点值：
- en: '![](img/f14fbb93-e742-4108-b319-a23790fa82b9.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f14fbb93-e742-4108-b319-a23790fa82b9.png)'
- en: If the ball is in the **FORWARD** section, the **x coordinate value** must be
    between **214** and **428**. Since we are not dividing the screen vertically,
    we don't need to consider the *y* values. Let's now start with the ball tracing
    program.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果球在**前进**部分，**x坐标值**必须在**214**和**428**之间。由于我们不是垂直地划分屏幕，所以不需要考虑*y*值。现在让我们开始球追踪程序。
- en: The ball tracing program
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 球追踪程序
- en: 'The `BallTracing.cpp` program is as follows. You can download this program
    from the `Chapter07` folder of the GitHub repository:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`BallTracing.cpp`程序如下。您可以从GitHub存储库的`Chapter07`文件夹中下载此程序：'
- en: '[PRE12]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Inside the `main` function, we have three matrix variables by the name of `videofeed`,
    `resizevideo`, and `thresholdvideo`. We have also declared a `VideoCapture` variable
    called `vid(0)` for capturing the video.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数内，我们有三个矩阵变量，名为`videofeed`、`resizevideo`和`thresholdvideo`。我们还声明了一个名为`vid(0)`的`VideoCapture`变量来捕获视频。
- en: 'The following steps explain the `BallTracing.cpp` program in detail:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤详细说明了`BallTracing.cpp`程序：
- en: Inside the `for` loop, the `vid.read(videofeed)` code will read the camera feed.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`for`循环中，`vid.read(videofeed)`代码将读取摄像头视频。
- en: Using the `resize` function, we resize the camera resolution to 640 x 480\.
    The resized video feed is stored in the `resizevideo` variable.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`resize`函数，我们将摄像头分辨率调整为640 x 480。调整大小后的视频存储在`resizevideo`变量中。
- en: Then, using the `flip` function, we flip the resized image horizontally. The
    output of the flipped video is again stored in the `resizevideo` variable. If
    we don't flip the video horizontally, the ball will appear as though it is moving
    on the right side when you move to the left and vice versa. If you have mounted
    the Pi camera upside down then you will need to flip the resized image vertically.
    To flip it vertically, set the third parameter to `0`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`flip`函数，我们水平翻转调整大小后的图像。翻转后的视频输出再次存储在`resizevideo`变量中。如果我们不水平翻转视频，当你向左移动时，球会看起来好像在右侧移动，反之亦然。如果您将树莓派相机倒置安装，则需要垂直翻转调整大小后的图像。要垂直翻转，将第三个参数设置为`0`。
- en: Next, with the `inRange` function, we threshold the video feed to make the colored
    ball stand out from the rest of the image. The thresholded video output is stored
    in the `thresholdvideo` variable.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`inRange`函数，我们对视频进行阈值处理，使彩色球从图像的其余部分中脱颖而出。阈值化后的视频输出存储在`thresholdvideo`变量中。
- en: Using `moments`, we find the center of the ball that is stored in the point
    variable, `p`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`moments`，我们找到了存储在点变量`p`中的球的中心。
- en: Using the `circle` function, we display a red dot on the ball inside the `resizevideo`
    feed.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`circle`函数，在`resizevideo`视频中显示一个红点在球上。
- en: 'The first `imshow` function will display the resized (`resizedvideo`) video
    feed, while the second `imshow` function will display the thresholded (`thresholdvideo`)
    video feed:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个`imshow`函数将显示调整大小后的(`resizedvideo`)视频，而第二个`imshow`函数将显示阈值化后的(`thresholdvideo`)视频：
- en: '![](img/f05e7531-1c94-4573-ba08-46c39265d628.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f05e7531-1c94-4573-ba08-46c39265d628.png)'
- en: In the preceding screenshot, the left window shows the `resizevideo` feed and
    we see the red dot on the green ball. The right window shows the threshold video
    feed, in which only the region of the ball is appearing white.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的屏幕截图中，左窗口显示了`resizevideo`的视频，我们看到绿色球上的红点。右窗口显示了阈值视频，其中只有球的区域是白色的。
- en: Finally, the `cout<<Mat(p)<<endl;` code will display the *x* and *y* point values
    of the red dot inside the console. When you move the ball, the red dot will also
    move with it and the *x* and *y* position of the red dot will be displayed inside
    the console.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`cout<<Mat(p)<<endl;`代码将在控制台内显示红点的*x*和*y*点值。当您移动球时，红点也会随之移动，并且红点的*x*和*y*位置将显示在控制台内。
- en: From the preceding screenshot, the values inside the square brackets, `[298
    ; 213]`, are the point values. So the *x* value of the red dot in my case is in
    the range of 298 to 306 and the *y* value is in the range of 216 to 218.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的屏幕截图中，方括号内的值`[298 ; 213]`是点值。因此，我的情况下红点的*x*值在298到306的范围内，*y*值在216到218的范围内。
- en: Setting up the object-following robot
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置物体跟随机器人
- en: After tracing the position of the ball, what remains is to make our robot follow
    the ball. We are going to use the *x* and *y* coordinate values as an input. While
    following the ball, however, we also have to make sure that the robot is at a
    suitable distance from the ball, so that it does not collide with the ball or
    the person who is holding it. To do this, we will also attach the ultrasonic sensor
    to our robot. For this project, I have attached the ultrasonic sensor **trigger**
    pin to the **wiringPi pin no 12**, and the **echo** pin to the **wiringPi pin
    no 13** via a** voltage divider circuit**.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪球的位置后，剩下的就是让我们的机器人跟随球。我们将使用`x`和`y`坐标值作为输入。然而，在跟随球的同时，我们还必须确保机器人与球的距离适当，以免与球或拿着球的人发生碰撞。为此，我们还将把超声波传感器连接到我们的机器人上。对于这个项目，我已经通过电压分压电路将超声波传感器的`trigger`引脚连接到`wiringPi
    pin no 12`，将`echo`引脚连接到`wiringPi pin no 13`。
- en: Object-following robot program
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物体跟随机器人程序
- en: 'The object-following robot program is basically a combination of the obstacle-avoiding
    program from [Chapter 4](a6ef702a-1576-4aa5-8e2a-b2b431b313bb.xhtml), *Building
    an Obstacle-Avoiding Robot,* and the preceding ball-tracing program. The program
    is called `ObjectFollowingRobot.cpp` and you can download it from the `Chapter07`
    folder of the GitHub repository:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 物体跟随机器人程序基本上是[第4章](a6ef702a-1576-4aa5-8e2a-b2b431b313bb.xhtml)中的避障程序和前面的球追踪程序的组合。该程序名为`ObjectFollowingRobot.cpp`，您可以从GitHub存储库的`Chapter07`文件夹中下载：
- en: '[PRE13]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `main` function, after calculating the distance, thresholding the video,
    and placing the dot at the center of ball, let''s take a look at the rest of the
    program:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，计算距离、对视频进行阈值处理并将点放在球的中心后，让我们来看看程序的其余部分：
- en: The first `if` condition (`if(distance < 15)`), will check whether the robot
    is 15 cm away from the object. If the distance is less than 15 cm, the robot will
    stop. The forward, left, right, and stop functions are declared above the `main`
    function.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个`if`条件（`if(distance < 15)`）将检查机器人距离物体是否为15厘米。如果距离小于15厘米，机器人将停止。前进、左转、右转和停止功能在`main`函数上方声明。
- en: Underneath the `stop()` function, the `cout` statement will first print the
    message, `"Object close to Robot"`**.** After that, it will print the point(x,y)
    value (`Mat(p)`) and then the `distance` value. Inside every `if` condition, the
    `cout` statement will print the region (such as `LEFT`, `FORWARD`, or `RIGHT`),
    the point value, and the `distance` value.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`stop()`函数下，`cout`语句将首先打印消息`"Object close to Robot"`。之后，它将打印点（x，y）值（`Mat(p)`），然后是`distance`值。在每个`if`条件内，`cout`语句将打印区域（如`LEFT`，`FORWARD`或`RIGHT`），点值和`distance`值。
- en: If the distance is greater than 15 cm, the `else` condition will execute. Inside
    the `else` condition, there are three `if` conditions to find the position of
    the ball (by using the red dot on it as a reference).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果距离大于15厘米，将执行`else`条件。在`else`条件内，有三个`if`条件来找到球的位置（使用上面的红点作为参考）。
- en: Now, as soon as the camera is activated, or when the ball moves out of the camera's
    view, the red dot (the point) will reset to a position of **x:0**, **y:0**, which
    is at the extreme top-left of the screen**.** The first `if` condition(`if(x<20
    && y< 20)`) inside the `else` block will check whether the position of the red
    dot is less than 20 on both the *x* and *y* axis. If it is, the robot will stop.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，一旦摄像头被激活，或者当球移出摄像头的视野时，红点（点）将重置到屏幕的极左上角的位置`x:0`，`y:0`。`else`块内的第一个`if`条件（`if(x<20
    && y< 20)`）将检查红点的位置在`x`和`y`轴上是否都小于20。如果是，机器人将停止。
- en: If the *x* position is between 20 and 170 and the *y* position is greater than
    20, the red dot will be in the **LEFT** region and the robot will turn **LEFT**.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`x`位置在20和170之间，`y`位置大于20，红点将在`LEFT`区域，机器人将向`LEFT`转动。
- en: 'In this program, I have reduced the width of the **LEFT** and **RIGHT** regions
    and increased the width of the **FORWARD** region, as shown in the following photo.
    You can modify the width of each region according to your requirements:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个程序中，我已经减小了`LEFT`和`RIGHT`区域的宽度，并增加了`FORWARD`区域的宽度，如下图所示。您可以根据需要修改每个区域的宽度：
- en: '![](img/a53a8bd1-4f76-4ab6-aaf4-bc0c0a18646b.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a53a8bd1-4f76-4ab6-aaf4-bc0c0a18646b.png)'
- en: If the **x position** is between **170** and **470, **thered dot is in the **FORWARD**
    region and the robot will move **FORWARD**.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`x`位置在170和470之间，红点在`FORWARD`区域，机器人将向`FORWARD`移动。
- en: If the** x position** is between **470** and **640****, **thered dot is in the
    **RIGHT** region and the robot will turn** RIGHT**.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`x`位置在470和640之间，红点在`RIGHT`区域，机器人将向`RIGHT`转动。
- en: Power up your robot using a power bank so that it can move freely. Next, compile
    the program and build it on your RPi robot. As long as the ball is not in front
    of the robot, the red dot will remain in the extreme top-left corner of the screen
    and the robot will not move. If you move the ball in front of the camera and if
    you are 15 cm away from the robot, the robot will start following the ball.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用移动电源为您的机器人供电，以便它可以自由移动。接下来，编译程序并在您的RPi机器人上构建它。只要球不在机器人面前，红点将保持在屏幕的极左上角，机器人将不会移动。如果您将球移动到摄像头前，并且距离机器人15厘米，机器人将开始跟随球。
- en: As the robot follows the ball, the color of the ball will vary because of external
    factors, such as sunlight or the light in the room. If the light in the room is
    low, the ball will appear a little darker to the robot. Similarly, if there is
    too much light in the room, some parts of the ball may also appear white. This
    may cause the thresholding to not work properly, which might mean the robot does
    not follow the ball smoothly. In this case, you will need to adjust the RGB values.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 随着机器人跟随球，球的颜色会因外部因素（如阳光或房间内的光线）而变化。如果房间里的光线较暗，球对机器人来说会显得稍暗。同样，如果房间里的光线太亮，球的某些部分也可能显得白色。这可能导致阈值处理无法正常工作，这可能意味着机器人无法顺利跟随球。在这种情况下，您需要调整RGB值。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at some of the important functions inside OpenCV
    libraries. After that, we put these functions to the test and recognized an object
    from an image. Next, we learned how to read a video feed from the Pi camera, how
    to threshold a colored ball, and how to place a red dot on top of it. Finally,
    we used the Pi camera and the ultrasonic sensor to detect the ball and follow
    it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了OpenCV库中的一些重要函数。之后，我们对这些函数进行了测试，并从图像中识别出了一个物体。接下来，我们学习了如何从树莓派摄像头读取视频，如何对彩色球进行阈值处理，以及如何在球的顶部放置一个红点。最后，我们使用了树莓派摄像头和超声波传感器来检测球并跟随它。
- en: In the next chapter, we are going to expand our OpenCV knowledge by detecting
    human faces using the Haar Cascade. After that, we will recognize a smile and
    make the robot follow the face.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使用Haar级联来扩展我们的OpenCV知识，检测人脸。之后，我们将识别微笑并让机器人跟随人脸。
- en: Questions
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the process of separating an object from an image called?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从图像中分离出一个物体的过程叫什么？
- en: What is the command to flip the image vertically?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垂直翻转图像的命令是什么？
- en: If x>428 and y>320, what block will the red dot be in?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果x>428且y>320，红点会在哪个区块？
- en: What is the command used for resizing the camera resolution?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于调整摄像头分辨率的命令是什么？
- en: If the object is not in front of the camera then where will the red dot be placed?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果物体不在摄像头前方，红点会放在哪里？
