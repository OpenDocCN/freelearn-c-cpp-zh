- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Inter-Integrated Circuit (I2C)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互集成电路 (I2C)
- en: In this chapter, we will learn about the **Inter-Integrated Circuit** (**I2C**)
    communication protocol. We will begin by exploring the fundamental principles
    of the I2C protocol, covering its modes of operation, addressing methods, and
    the communication process. Then, we will examine the key registers of the I2C
    peripheral in STM32 microcontrollers and apply this knowledge to develop a bare-metal
    I2C driver.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 **互集成电路**（**I2C**）通信协议。我们将从探索 I2C 协议的基本原理开始，包括其操作模式、寻址方法和通信过程。然后，我们将检查
    STM32 微控制器中 I2C 外设的关键寄存器，并将这些知识应用于开发裸机 I2C 驱动程序。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: An overview of the I2C protocol
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I2C 协议概述
- en: The STM32 I2C peripheral
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32 I2C 外设
- en: Developing the I2C Driver
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 I2C 驱动程序
- en: By the end of this chapter, you will have a solid grasp of the I2C protocol
    and be equipped with the skills to develop bare-metal drivers for I2C.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将牢固掌握 I2C 协议，并具备开发 I2C 硬件驱动程序所需的技能。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在 GitHub 上找到：[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: An overview of the I2C protocol
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I2C 协议概述
- en: I2C is another commonly used protocol. Let’s explore what it is, its key features,
    how it works, and its data format.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: I2C 是另一种常用协议。让我们探索它是什么，它的关键特性，它是如何工作的，以及它的数据格式。
- en: What is I2C?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 I2C？
- en: I2C is a *multi-master*, multi-slave, packet-switched, single-ended, serial
    communication bus invented by Philips Semiconductor (now NXP Semiconductors).
    It’s designed for short-distance communication within a single device or between
    multiple devices on the same board. I2C is known for its simplicity and ease of
    use, making it a popular choice for communication between microcontrollers and
    other ICs. Let’s see its key features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: I2C 是由飞利浦半导体（现为恩智浦半导体）发明的 *多主多从*、分组交换、单端、串行通信总线。它旨在实现单个设备内部或同一板上的多个设备之间的短距离通信。I2C
    以其简单易用而闻名，使其成为微控制器和其他集成电路之间通信的流行选择。让我们看看它的关键特性。
- en: The key features of I2C
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I2C 的关键特性
- en: 'I2C has a number of unique features, which makes it ideal for various applications
    in embedded systems:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: I2C 具有许多独特特性，使其成为嵌入式系统各种应用的理想选择：
- en: '**A two-wire interface**: I2C uses only two wires, **Serial Data** (**SDA**)
    and **Serial Clock** (**SCL**), which simplifies the wiring and reduces the number
    of pins required on the microcontroller.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双线接口**：I2C 只使用两条线，**串行数据**（**SDA**）和**串行时钟**（**SCL**），这简化了布线并减少了微控制器上所需的引脚数量。'
- en: '**Multi-master and multi-slave**: Multiple master devices can initiate communication
    on the bus, and multiple slave devices can respond. This flexibility allows for
    complex communication setups. The I2C protocol supports up to 128 devices with
    7-bit addressing, although the practical limit is 119 due to reserved addresses.
    With 10-bit addressing, the protocol theoretically allows for 1,024 devices, but
    again, reserved addresses reduce the practical maximum slightly. The 10-bit mode,
    while less common, enables a higher number of devices on the same bus.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多主多从**：多个主设备可以在总线上发起通信，多个从设备可以响应。这种灵活性允许复杂的通信设置。I2C 协议支持最多 128 个设备，使用 7 位寻址，但由于保留地址，实际限制为
    119。使用 10 位寻址，该协议理论上允许 1,024 个设备，但同样，保留地址略微减少了实际最大值。10 位模式虽然不太常见，但允许同一总线上有更多的设备。'
- en: '**Addressable devices**: Each device on the I2C bus has a unique address, enabling
    the master to communicate with specific slaves.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可寻址设备**：I2C 总线上的每个设备都有一个唯一的地址，使主设备能够与特定的从设备通信。'
- en: '**Synchronous communication**: The SCL line provides the clock signal, ensuring
    that data is transferred synchronously between devices.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步通信**：SCL 线提供时钟信号，确保设备间数据同步传输。'
- en: '**Speed variants**: I2C supports various speed modes, including standard mode
    (100 kHz), fast mode (400 kHz), fast mode plus (1 MHz), and high-speed mode (3.4
    MHz), catering to different speed requirements.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度变体**：I2C 支持各种速度模式，包括标准模式（100 kHz）、快速模式（400 kHz）、快速模式+（1 MHz）和高速模式（3.4 MHz），以满足不同的速度要求。'
- en: '**Simple and low-cost**: The protocol’s simplicity and minimal hardware requirements
    make it cost-effective and easy to implement.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单且低成本**：该协议的简单性和最小硬件要求使其具有成本效益且易于实现。'
- en: Let’s look at the I2C interface.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 I2C 接口。
- en: The I2C interface
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I2C 接口
- en: 'The I2C interface consists of two main lines:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: I2C 接口由两条主要线路组成：
- en: '**Serial Data (SDA)**: This line carries the data being transferred between
    devices. It’s a bidirectional line, meaning that both the master and slave can
    send and receive data.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行数据（SDA）**：这条线携带设备之间传输的数据。它是一个双向线，意味着主设备和从设备都可以发送和接收数据。'
- en: '**Serial Clock (SCL)**: This line carries the clock signal generated by the
    master device. It synchronizes the data transfer between the master and the slave.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行时钟（SCL）**：这条线携带由主设备生成的时钟信号。它同步主设备和从设备之间的数据传输。'
- en: '![Figure 13.1: The I2C interface – multiple slaves](img/B21914_13_1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1：I2C 接口 – 多个从设备](img/B21914_13_1.jpg)'
- en: 'Figure 13.1: The I2C interface – multiple slaves'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：I2C 接口 – 多个从设备
- en: These two lines are connected to all devices on the bus, with pull-up resistors
    to ensure that the lines are pulled to a high state when idle. Let’s see how it
    works.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条线连接到总线上所有的设备，通过上拉电阻确保在空闲状态下这些线被拉到高电平。让我们看看它是如何工作的。
- en: How I2C works
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I2C 的工作原理
- en: Understanding how I2C works involves looking at the **roles** of master and
    slave devices, the **addressing scheme**, and the **communication process**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 I2C 的工作原理涉及查看主设备和从设备的**角色**、**寻址方案**和**通信过程**。
- en: 'The following are the roles and addressing scheme:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其角色和寻址方案：
- en: '**Master device**: The master device initiates communication and generates
    a clock signal. It controls the flow of data and can address multiple slaves.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主设备**：主设备启动通信并生成时钟信号。它控制数据流，并能寻址多个从设备。'
- en: '**Slave device**: The slave device responds to the master’s commands and performs
    the requested operations. Each slave has a unique **7-bit** or **10-bit address**
    that the master uses to identify it.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从设备**：从设备响应主设备的命令并执行请求的操作。每个从设备都有一个唯一的**7 位**或**10 位**地址，主设备使用该地址来识别它。'
- en: 'The communication process is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通信过程如下：
- en: '**A start condition**: Communication begins with the master generating a start
    condition. This involves pulling the SDA line low while the SCL line is high.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**起始条件**：通信从主设备生成起始条件开始。这涉及到在 SCL 线为高电平时将 SDA 线拉低。'
- en: '**Address frame**: The master sends the address of the target slave device,
    followed by a read/write bit indicating the operation type (0 for write and 1
    for read).'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**地址帧**：主设备发送目标从设备的地址，后面跟着一个读写位，表示操作类型（0 为写，1 为读）。'
- en: '**Acknowledge (ACK) bit**: The addressed slave responds with an ACK bit by
    pulling the SDA line low during the next clock pulse.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**确认（ACK）位**：被寻址的从设备在下一个时钟脉冲期间通过将 SDA 线拉低来响应 ACK 位。'
- en: '**Data Frames**: Data is transferred in 8-bit frames. Each byte is followed
    by an ACK bit from the receiver.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据帧**：数据以 8 位帧的形式传输。每个字节后面跟随接收方的 ACK 位。'
- en: '**A stop condition**: The master ends the communication by generating a stop
    condition, which involves pulling the SDA line high while the SCL line is high.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**停止条件**：主设备通过生成停止条件来结束通信，这涉及到在 SCL 线为高电平时将 SDA 线拉高。'
- en: '![Figure 13.2: The I2C packet](img/B21914_13_2.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2：I2C 数据包](img/B21914_13_2.jpg)'
- en: 'Figure 13.2: The I2C packet'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2：I2C 数据包
- en: Before we proceed to the next section, let’s take a moment to touch on the I2C
    data transfer, using an example.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，让我们花一点时间来谈谈 I2C 数据传输，用一个例子来说明。
- en: 'Let’s begin by revisiting the role of the data frame and the start condition:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先回顾一下数据帧和起始条件的作用：
- en: '**Data frames**: Data is transferred in **8-bit bytes**. After each byte, the
    receiver sends an ACK bit to confirm successful reception.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据帧**：数据以**8 位字节**的形式传输。在每个字节之后，接收方发送一个 ACK 位以确认成功接收。'
- en: '**Repeated start condition**: If the master needs to communicate with another
    slave or continue communication without releasing the bus, it can generate a **repeated
    start condition** instead of a stop condition.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重复起始条件**：如果主设备需要与另一个从设备通信或在不释放总线的情况下继续通信，它可以生成**重复起始条件**而不是停止条件。'
- en: 'Let’s see the data transfer:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看数据传输：
- en: '**Write operation**: The master sends a **start condition**, the **address
    frame** with the **write bit**, and the **data frames**. Each data byte is followed
    by an ACK bit from the slave.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写操作**：主设备发送一个**起始条件**，带有**写位**的**地址帧**和**数据帧**。每个数据字节后面跟随从设备的ACK位。'
- en: '**Read operation**: The master sends a start condition, the address frame with
    the **read bit**, and then reads the data frames from the slave. Each data byte
    is acknowledged by the master with an ACK bit, except for the last byte, which
    is followed by a **NACK** to indicate the end of the read operation.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读操作**：主设备发送一个起始条件，带有**读位**的地址帧，然后从从设备读取数据帧。每个数据字节由主设备通过ACK位确认，除了最后一个字节，它后面跟着一个**NACK**，表示读操作结束。'
- en: For a better understanding, let’s analyze *Figures 13.3* to *13.6*, starting
    with the start and stop conditions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，让我们分析*图13.3*到*13.6*，从起始和停止条件开始。
- en: '![Figure 13.3: The start condition](img/B21914_13_3.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3：起始条件](img/B21914_13_3.jpg)'
- en: 'Figure 13.3: The start condition'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：起始条件
- en: 'The following is the stop condition:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为停止条件：
- en: '![Figure 13.4: The stop condition](img/B21914_13_4.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4：停止条件](img/B21914_13_4.jpg)'
- en: 'Figure 13.4: The stop condition'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：停止条件
- en: The start condition occurs when the master device pulls the SDA line low while
    the SCL line remains high. This sequence signals all devices on the I2C bus that
    a communication session is about to begin, allowing the master to claim the bus
    for its intended operations. Without a valid start condition, the I²C communication
    cannot commence.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 起始条件发生在主设备将SDA线拉低，而SCL线保持高电平时。这个序列向I2C总线上的所有设备发出信号，表明即将开始一个通信会话，允许主设备为其预期操作占用总线。如果没有有效的起始条件，I²C通信无法开始。
- en: Conversely, the stop condition signals the end of communication. The master
    device releases the SDA line to a high state while the SCL line is high, indicating
    that the communication session is complete and the bus is now free for other devices.
    The proper use of stop conditions is essential for ensuring that no devices remain
    active on the bus, which could lead to conflicts or communication errors.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，停止条件标志着通信的结束。主设备将SDA线释放到高电平状态，同时SCL线保持高电平，这表明通信会话已完成，总线现在可供其他设备使用。正确使用停止条件对于确保没有设备在总线上保持活跃至关重要，这可能导致冲突或通信错误。
- en: Next, let’s see how the I2C protocol distinguishes between zeros and ones.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看I2C协议如何区分0和1。
- en: '![Figure 13.5: The data transmission process](img/B21914_13_5.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5：数据传输过程](img/B21914_13_5.jpg)'
- en: 'Figure 13.5: The data transmission process'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5：数据传输过程
- en: '*Figure 13**.5* illustrates the data transmission process. Data is sent bit
    by bit, synchronized with the clock pulses on the SCL line. As shown, each bit
    of data is placed on the SDA line while the SCL line is low. When the SCL line
    transitions to high, the state of the SDA line is read by the receiving device.
    This particular figure shows the transmission of **1**, followed by a **0**.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13*.*5*说明了数据传输过程。数据是逐位发送的，与SCL线上的时钟脉冲同步。如图所示，每个数据位在SCL线低电平时放置在SDA线上。当SCL线切换到高电平时，接收设备读取SDA线的状态。这个特定的图显示了**1**的传输，随后是**0**。'
- en: Finally, let’s examine the complete packet and how it interacts with the SDA
    and SCL lines.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们检查完整的包以及它与SDA和SCL线的交互。
- en: '![Figure 13.6: The complete packet](img/B21914_13_6.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图13.6：完整的包](img/B21914_13_6.jpg)'
- en: 'Figure 13.6: The complete packet'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：完整的包
- en: '*Figure 13**.6* provides a comprehensive view of a complete I²C communication
    packet, showcasing the relationship between the SDA and SCL lines throughout the
    transaction. The communication begins with a start condition, where the SDA line
    is pulled low while the SCL line remains high, signaling the initiation of a new
    communication sequence.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13*.*6*提供了一个完整的I²C通信包的全面视图，展示了在整个事务过程中SDA和SCL线之间的关系。通信从起始条件开始，此时SDA线被拉低，而SCL线保持高电平，标志着新通信序列的启动。'
- en: Following the start condition, the address frame is transmitted. This frame
    contains the 7-bit address of the target device, followed by the **read/write**
    (**R/W**) bit that indicates whether the master intends to read from or write
    to the slave device. The address frame is then acknowledged by the slave device
    with an ACK bit, confirming that it is ready to proceed with the communication.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动条件之后，传输地址帧。该帧包含目标设备的7位地址，后面跟着**读/写**（**R/W**）位，表示主设备是否打算从从设备读取或写入。然后从设备通过ACK位确认地址帧，确认它已准备好进行通信。
- en: After the address frame, the data frame is transmitted. The data is sent in
    8-bit bytes, with each bit being placed on the SDA line while the SCL line clocks
    each bit in sync. After each byte of data, the receiving device responds with
    another ACK bit, ensuring that the data was received correctly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在地址帧之后，传输数据帧。数据以8位字节的形式发送，每个位被放置在SDA线上，而SCL线同步地时钟每个位。在每个数据字节之后，接收设备会响应另一个ACK位，确保数据被正确接收。
- en: The communication concludes with a stop condition, where the SDA line is released
    to go high while the SCL line is also high. This signals the end of the communication
    session, freeing the bus for other potential communications. This complete cycle,
    from start to stop, forms the backbone of data exchange in the I²C protocol, ensuring
    structured and reliable communication between devices.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通信以停止条件结束，此时SDA线被释放以变高，而SCL线也处于高电平。这表示通信会话结束，为其他潜在的通信释放总线。从开始到停止的整个周期构成了I²C协议中数据交换的骨架，确保设备之间结构化和可靠的通信。
- en: This concludes our overview of the I2C protocol. In the next section, we shall
    analyze the I2C peripheral in the STM32F4 microcontroller.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对I2C协议的概述。在下一节中，我们将分析STM32F4微控制器中的I2C外设。
- en: The STM32F4 I2C peripherals
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STM32F4 I2C外设
- en: Depending on the specific model of STM32F4 you are working with, you can typically
    find up to three I2C peripherals labeled I2C1, I2C2, and I2C3\. These peripherals
    enable the microcontroller to communicate with I2C-compatible devices using the
    standard two-wire interface.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您正在使用的STM32F4的具体型号，通常可以找到最多三个标记为I2C1、I2C2和I2C3的I2C外设。这些外设使微控制器能够通过标准双线接口与I2C兼容的设备进行通信。
- en: 'The I2C peripherals in STM32F4 microcontrollers come packed with features that
    enhance their versatility and performance:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F4微控制器中的I2C外设集成了许多功能，增强了它们的通用性和性能：
- en: '**Multi-master and multi-slave capabilities**: Each I2C peripheral can operate
    as both master and slave, supporting multiple master configurations where more
    than one master device can control the bus'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多主和多从功能**：每个I2C外设都可以作为主设备和从设备运行，支持多个主配置，其中多个主设备可以控制总线'
- en: '**Standard, fast, and fast mode plus**: The peripherals support multiple speed
    modes, including **standard mode** (100 kHz), **fast mode** (400 kHz), and **fast
    mode plus** (1 MHz), allowing for flexibility in communication speed'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准、快速和快速模式+**：外设支持多种速度模式，包括**标准模式**（100 kHz）、**快速模式**（400 kHz）和**快速模式+**（1
    MHz），这为通信速度提供了灵活性'
- en: '**10-bit addressing**: In addition to standard **7-bit addressing**, the I2C
    peripherals also support **10-bit addressing**, enabling communication with a
    broader range of devices'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**10位寻址**：除了标准的**7位寻址**外，I2C外设还支持**10位寻址**，这使得与更广泛的设备进行通信成为可能'
- en: '**Dual addressing mode**: Each I2C peripheral can be configured to respond
    to two different addresses, useful for complex multi-device setups'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双寻址模式**：每个I2C外设都可以配置为响应两个不同的地址，这对于复杂的多个设备设置非常有用'
- en: '**DMA support**: **Direct Memory Access** (**DMA**) support is available, enabling
    efficient data transfer without CPU intervention'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DMA支持**：**直接内存访问**（**DMA**）支持可用，允许在没有CPU干预的情况下进行高效的数据传输'
- en: Let’s examine the key registers of this peripheral.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个外设的关键寄存器。
- en: The key I2C registers
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键的I2C寄存器
- en: Configuring the I2C peripheral on an STM32 microcontroller involves several
    key registers that control various aspects of its operation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在STM32微控制器上配置I2C外设涉及几个关键寄存器，这些寄存器控制其操作的各个方面。
- en: Each register has specific bits that need to be set correctly to ensure proper
    functionality. Let’s break down the main registers we’ll be working with, starting
    with **Control** **Register 1**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个寄存器都有需要正确设置的特定位，以确保正常功能。让我们分解我们将要使用的主要寄存器，从**控制寄存器1**开始。
- en: I2C Control Register 1 (I2C_CR1)
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I2C控制寄存器1 (I2C_CR1)
- en: '`I2C_CR1` is one of the primary control registers used to configure the I2C
    peripheral’s basic operational settings. It provides options to **enable the peripheral**,
    manage the start and stop conditions, and control the acknowledge feature.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`I2C_CR1` 是用于配置 I2C 外设基本操作设置的几个主要控制寄存器之一。它提供了启用外设、管理起始和停止条件以及控制应答功能的选择。'
- en: 'The key bits in this register include the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此寄存器中的关键位包括以下内容：
- en: '**Peripheral enable (PE)**: This bit enables or disables the I2C peripheral.
    Setting this bit to 1 turns on the I2C peripheral, while clearing it turns it
    off.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外设使能（PE）**：此位启用或禁用 I2C 外设。将此位设置为 1 打开 I2C 外设，而清除它则关闭。'
- en: '`START` condition, initiating communication.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START` 条件，启动通信。'
- en: '`STOP` condition, terminating communication.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STOP` 条件，终止通信。'
- en: '**Acknowledge enable (ACK)**: When set, this bit enables the ACK after each
    byte received.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应答使能（ACK）**：当设置时，此位在每个字节接收后启用ACK。'
- en: '**Acknowledge/PEC position (POS)**: This bit controls the position of the ACK
    bit.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应答/PEC 位置（POS）**：此位控制 ACK 位的位位置。'
- en: '**Software reset (SWRST)**: Setting this bit resets the I2C peripheral.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件复位（SWRST）**：设置此位将重置 I2C 外设。'
- en: You can find detailed information about this register on *page 492* of the STM32F4
    reference manual (RM0383). Next, let’s look at I2C **Control** **Register 2**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 STM32F4 参考手册（RM0383）的第 *492* 页找到有关此寄存器的详细信息。接下来，让我们看看 I2C **控制** **寄存器
    2**。
- en: I2C Control Register 2 (I2C_CR2)
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I2C 控制寄存器 2（I2C_CR2）
- en: '`I2C_CR2` is another crucial control register that handles different aspects
    of I2C operation, including **clock frequency**, **interrupt** enable, and **DMA**
    control. Key bits in this register include the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`I2C_CR2` 是另一个关键控制寄存器，用于处理 I2C 操作的不同方面，包括**时钟频率**、**中断**使能和**DMA**控制。此寄存器中的关键位包括以下内容：'
- en: '**FREQ[5:0] (peripheral clock frequency)**: These bits set the I2C peripheral
    clock frequency in MHz'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FREQ[5:0]（外设时钟频率）**：这些位设置 I2C 外设时钟频率，以 MHz 为单位'
- en: '**DMAEN (DMA requests enable)**: When set, this bit enables the DMA requests
    for the I2C peripheral'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DMAEN（DMA 请求使能）**：当设置时，此位启用 I2C 外设的 DMA 请求'
- en: You can find detailed information about this register on *page 494* of the STM32F4
    reference manual (RM0383). Next, let’s look at the I2C **Clock** **Control Register**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 STM32F4 参考手册（RM0383）的第 *494* 页找到有关此寄存器的详细信息。接下来，让我们看看 I2C **时钟** **控制寄存器**。
- en: I2C Clock Control Register (I2C_CCR)
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I2C 时钟控制寄存器（I2C_CCR）
- en: '`I2C_CCR` configures the clock control settings for standard, fast, and fast
    mode plus operations. Key bits in this register include the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`I2C_CCR` 配置标准、快速和快速模式加操作的时钟控制设置。此寄存器中的关键位包括以下内容：'
- en: '**CCR[11:0] (clock control)**: These bits set the clock control value, determining
    the I2C clock speed'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CCR[11:0]（时钟控制）**：这些位设置时钟控制值，确定 I2C 时钟速度'
- en: '**DUTY (fast mode duty cycle)**: This bit selects the duty cycle for fast mode'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DUTY（快速模式占空比）**：此位选择快速模式的占空比'
- en: '**F/S (I2C master mode selection)**: This bit selects between standard mode
    (0) and fast mode (1)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F/S（I2C 主模式选择）**：此位在标准模式（0）和快速模式（1）之间进行选择'
- en: You can find detailed information about this register on *page 502* of the STM32F4
    reference manual (RM0383). The next register is the I2C Rise Time Register.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 STM32F4 参考手册（RM0383）的第 *502* 页找到有关此寄存器的详细信息。下一个寄存器是 I2C 上升时间寄存器。
- en: I2C TRISE register (I2C_TRISE)
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I2C **TRISE** 寄存器（I2C_TRISE）
- en: '`I2C_TRISE` configures the maximum rise time for the I2C signals, ensuring
    compliance with I2C specifications. This register has only one field – **TRISE[5:0]
    (maximum rise time)**. These bits set the maximum rise time for the SDA and SCL
    signals in nanoseconds.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`I2C_TRISE` 配置 I2C 信号的上升时间最大值，确保符合 I2C 规范。此寄存器只有一个字段 – **TRISE[5:0]（最大上升时间）**。这些位设置
    SDA 和 SCL 信号的上升时间最大值，以纳秒为单位。'
- en: The final register is the I2C **Data Register**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最终寄存器是 I2C **数据寄存器**。
- en: I2C Data Register (I2C_DR)
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I2C 数据寄存器（I2C_DR）
- en: '`I2C_DR` is the data register used for both **transmitting** and **receiving**
    data. Data written to this register is transmitted, and data received from the
    bus is stored in this register. This register has only one field – **DR[7:0] (8-bit
    data register)**: This register holds the 8-bit data to be transmitted or the
    data received from the bus.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`I2C_DR` 是用于**发送**和**接收**数据的寄存器。写入此寄存器的数据将被发送，而从总线接收到的数据将存储在此寄存器中。此寄存器只有一个字段
    – **DR[7:0]（8位数据寄存器）**：此寄存器保存要发送的8位数据或从总线接收到的数据。'
- en: With these registers in mind, we’re now ready to develop the I2C driver. Let’s
    do that in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些寄存器，我们现在可以开始开发 I2C 驱动程序。让我们在下一节中这样做。
- en: Developing the I2C driver
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发 I2C 驱动程序
- en: Let’s develop the I2C driver. Create a copy of your previous project in your
    IDE and rename this copied project `I2C`. Next, create a new file named `i2c.c`
    in the `Src` folder and another file named `i2c.h` in the `Inc` folder.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发 I2C 驱动程序。在您的 IDE 中复制您之前的项目，并将复制的项目重命名为 `I2C`。接下来，在 `Src` 文件夹中创建一个名为 `i2c.c`
    的新文件，并在 `Inc` 文件夹中创建一个名为 `i2c.h` 的新文件。
- en: The initialization function
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化函数
- en: 'Let’s populate the `i2c.c` file, starting with the macros and initialization
    function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们填充 `i2c.c` 文件，从宏和初始化函数开始：
- en: '[PRE0]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break down what we have so far:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解到目前为止的内容：
- en: '[PRE1]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This line enables the clock for GPIOB by setting the corresponding bit.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过设置相应的位启用了 GPIOB 的时钟。
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These lines configure `PB8` and `PB9` pins to an alternate function mode for
    I2C.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行将 `PB8` 和 `PB9` 引脚配置为 I2C 的备用功能模式。
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These lines configure the pins as **open-drain**, which is required for I2C
    communication.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行将引脚配置为**开漏**，这是 I2C 通信所必需的。
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These lines enable **pull-up resistors** for the I2C pins.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行启用了 I2C 引脚的**上拉电阻**。
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These lines configure the `I2C1`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行配置了 `I2C1`。
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This line enables the clock for the I2C1 peripheral.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码启用了 I2C1 外设的时钟。
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These lines **reset** the I2C1 peripheral.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行**重置**了 I2C1 外设。
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This configures the I2C1 clock.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这配置了 I2C1 时钟。
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This line sets the clock control register for 100 kHz standard mode, using the
    macro we defined.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使用我们定义的宏设置时钟控制寄存器，以 100 kHz 标准模式设置时钟。
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This line sets the rise time for the I2C signals using the macro we defined.
    The TRISE register specifies the maximum time the signal is allowed to take to
    transition from a low to a high state on the I2C bus. Setting this value correctly
    is important to ensure that the I2C communication adheres to the timing requirements
    of the I2C standard, which helps maintain reliable and stable communication.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使用我们定义的宏设置 I2C 信号的上升时间。TRISE 寄存器指定信号在 I2C 总线上从低电平到高电平状态的最大转换时间。正确设置此值对于确保
    I2C 通信符合 I2C 标准的时序要求非常重要，这有助于保持可靠和稳定的通信。
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This line enables the I2C1 peripheral by setting the PE bit. Next, we will add
    and analyze the function to read a byte from an I2C slave device.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码通过设置 PE 位启用了 I2C1 外设。接下来，我们将添加并分析从 I2C 从设备读取字节的函数。
- en: The read function
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取函数
- en: 'Let’s analyze the `read` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析 `read` 函数：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s break down what we have so far:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解到目前为止的内容：
- en: '`while (I2C1->SR2 & (SR2_BUSY)){}`: This line waits for the I2C bus to be free
    by checking the state of the `BUSY` bit in I2C Status Register 2.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while (I2C1->SR2 & (SR2_BUSY)){}`: 这行代码通过检查 I2C 状态寄存器 2 中的 `BUSY` 位状态，等待 I2C
    总线空闲。'
- en: '`I2C1->CR1 |= CR1_START;`: This line initiates a start condition on the I2C
    bus.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I2C1->CR1 |= CR1_START;`: 这行代码在 I2C 总线上启动一个起始条件。'
- en: '`while (!(I2C1->SR1 & (SR1_SB))){}`: This line waits until the start condition
    is acknowledged by checking the `SB` bit in I2C Status Register 1.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while (!(I2C1->SR1 & (SR1_SB))){}`: 这行代码通过检查 I2C 状态寄存器 1 中的 `SB` 位，等待起始条件被确认。'
- en: '`I2C1->DR = saddr << 1;`: This line sends the slave address with the write
    bit. The 7-bit address of the device is left-shifted by 1 bit to make room for
    the R/W bit in the `saddr` left by 1, we prepare the address for a subsequent
    write operation to the slave device.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I2C1->DR = saddr << 1;`: 这行代码发送带有写位的从设备地址。设备的 7 位地址向左移动 1 位，为 `saddr` 中保留的
    R/W 位腾出空间，我们为从设备后续的写操作准备地址。'
- en: '`while (!(I2C1->SR1 & (SR1_ADDR))){}`: This line waits until the address is
    acknowledged by checking the `ADDR` bit in I2C Status Register 1.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while (!(I2C1->SR1 & (SR1_ADDR))){}`: 这行代码通过检查 I2C 状态寄存器 1 中的 `ADDR` 位，等待地址被确认。'
- en: '`tmp = I2C1->SR2;`: This line clears the address flag by simply reading I2C
    Status Register 2.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tmp = I2C1->SR2;`: 这行代码通过简单地读取 I2C 状态寄存器 2 来清除地址标志。'
- en: '`2C1->DR = maddr;`: Here, we send the memory address to read from the slave
    device.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I2C1->DR = maddr;`: 这里，我们向从设备发送要读取的内存地址。'
- en: '`while (!(I2C1->SR1 & SR1_TXE)){}`: This line waits until the data register
    is empty by reading the transmit buffer empty (`TXE`) bit in I2C Status Register
    1.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while (!(I2C1->SR1 & SR1_TXE)){}`: 这行代码通过读取 I2C 状态寄存器 1 中的传输缓冲区空 (`TXE`) 位，等待数据寄存器为空。'
- en: '`I2C1->CR1 |= CR1_START;`: This line initiates a **restart condition** on the
    I2C bus.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I2C1->CR1 |= CR1_START;`: 这行代码在 I2C 总线上启动一个**重启动条件**。'
- en: '`while (!(I2C1->SR1 & SR1_SB)){}`: Here, we wait until the restart condition
    is acknowledged by checking the `SB` bit in I2C Status Register 1.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while (!(I2C1->SR1 & SR1_SB)){}`：在这里，我们等待直到重启动条件被I2C状态寄存器1中的`SB`位确认。'
- en: '`I2C1->DR = saddr << 1 | 1;`: This line prepares the I2C data register for
    a read operation by setting up the 7-bit I2C address of the slave device and appending
    the R/W bit. Specifically, `saddr << 1` shifts the 7-bit address left by one bit
    to make room for the LSB, which is then set to 1 using the bitwise `OR` operator
    (| 1). This final value, with the LSB set to 1, indicates a read operation when
    loaded into the I2C1 **data register** (**DR**). Hence, this line configures the
    I2C peripheral to initiate communication with the slave device, requesting to
    read data from it.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I2C1->DR = saddr << 1 | 1;`：这一行通过设置从设备的7位I2C地址和附加R/W位来准备I2C数据寄存器以进行读取操作。具体来说，`saddr
    << 1`将7位地址左移一位以留出LSB的空间，然后使用位或运算符（| 1）将其设置为1。这个最终值，LSB设置为1，当加载到I2C1 **数据寄存器**（**DR**）时，表示读取操作。因此，这一行配置I2C外设与从设备通信，请求从它读取数据。'
- en: '`while (!(I2C1->SR1 & (SR1_ADDR))){}`: This line waits until the address is
    acknowledged.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while (!(I2C1->SR1 & (SR1_ADDR))){}`：这一行等待直到地址被确认。'
- en: '`I2C1->CR1 &= ~CR1_ACK;`: This line disables the acknowledge bit to prepare
    for a stop condition.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I2C1->CR1 &= ~CR1_ACK;`：这一行禁用应答位以准备停止条件。'
- en: '`tmp = I2C1->SR2;`: This line clears the address flag by reading I2C Status
    Register 2.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tmp = I2C1->SR2;`：这一行通过读取I2C状态寄存器2来清除地址标志。'
- en: '`I2C1->CR1 |= CR1_STOP;`: This initiates a stop condition on the I2C bus.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I2C1->CR1 |= CR1_STOP;`：这一行在I2C总线上启动停止条件。'
- en: '`while (!(I2C1->SR1 & SR1_RXNE)){}`: This line waits until the receive buffer
    is not empty by reading the `RXNE`) flag in I2C Status Register 1\. This flag
    indicates that new data has been received and is available in the data register.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while (!(I2C1->SR1 & SR1_RXNE)){}`：这一行等待直到接收缓冲区不为空，通过读取I2C状态寄存器1中的`RXNE`标志。此标志表示已接收到新数据，并且数据已准备好在数据寄存器中。'
- en: '`*data++ = I2C1->DR;`: This line is responsible for storing the received byte
    of data from the I2C DR in the memory location pointed to by the `data` pointer.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*data++ = I2C1->DR;`：这一行负责将接收到的数据字节从I2C数据寄存器（DR）存储到由`data`指针指向的内存位置。'
- en: 'Next, we have a function to read multiple bytes from the slave device:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个从从设备读取多个字节的函数：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This function reads multiple bytes of data from a specified memory address
    in the I2C slave device. Here’s a breakdown of what it does:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从I2C从设备指定的内存地址读取多个字节数据。以下是它的操作分解：
- en: '**Waits for bus availability**: The function starts by ensuring that the I2C
    bus is not busy, waiting until it is free to initiate communication.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等待总线可用**：该函数首先确保I2C总线不忙，等待直到它空闲以启动通信。'
- en: '**Generates a start condition**: It generates a start condition to begin communication
    with the slave device.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成启动条件**：它生成启动条件以开始与从设备的通信。'
- en: '**Transmits a slave address for write**: The function sends the slave device
    address with a write bit, indicating that it will initially write data to specify
    the memory address.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发送从设备地址用于写入**：该函数发送带有写入位的从设备地址，表示它将首先写入数据以指定内存地址。'
- en: '**Waits for the address flag and clears it**: It waits for the address flag
    to be set and then clears it by reading the SR2 register.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等待地址标志并清除它**：它等待地址标志被设置，然后通过读取SR2寄存器来清除它。'
- en: '**Transmits the memory address**: The memory address from which to start reading
    is sent to the slave device.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发送内存地址**：将要从其中开始读取的内存地址发送到从设备。'
- en: '**Generates a restart condition**: A repeated start condition is generated
    to switch the communication mode from write to read.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成重启动条件**：生成重复启动条件以将通信模式从写入切换到读取。'
- en: '**Transmits a slave address for read**: The function sends the slave address
    with a read bit, indicating that it will read data from the slave device.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**发送从设备地址用于读取**：该函数发送带有读取位的从设备地址，表示它将从从设备读取数据。'
- en: '**Waits for the address flag and clears it**: Again, it waits for the address
    flag to be set and clears it by reading the SR2 register.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等待地址标志并清除它**：再次，它等待地址标志被设置，并通过读取SR2寄存器来清除它。'
- en: '**Enables acknowledge**: The acknowledge bit is set.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启用应答**：设置应答位。'
- en: '`RXNE` flag to indicate that data is ready, reads the data into the buffer,
    and decrements the byte counter'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RXNE`标志表示数据已准备好，将数据读入缓冲区，并递减字节数计数器'
- en: Finally, we add the function to write data to the slave device.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将函数添加到向从设备写入数据。
- en: The write function
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入函数
- en: 'Let’s break down the function to write multiple bytes to the slave device:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解写入从设备多个字节的函数：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function writes **multiple bytes** of data to a specific memory address
    in the I2C slave device. The function begins by waiting for the I2C bus to be
    free, ensuring that there is no ongoing communication. It then generates a start
    condition to initiate communication with the slave device. The slave address is
    transmitted with a write bit, and then the function waits for the address flag
    to be set and cleared by reading the SR2 register. After ensuring the data register
    is empty, it sends the memory address where the data writing should begin. The
    function enters a loop to transmit each byte of data, waiting for the data register
    to empty before each byte is sent. Once all bytes have been transmitted, it waits
    for the byte transfer to finish and then generates a stop condition to end the
    communication.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将 **多个字节** 的数据写入 I2C 从设备中的特定内存地址。函数首先等待 I2C 总线空闲，确保没有正在进行的通信。然后生成一个起始条件以与从设备开始通信。通过写入位传输从设备地址，然后函数等待通过读取
    SR2 寄存器设置和清除地址标志。在确保数据寄存器为空后，它发送数据写入应开始的数据地址。函数进入一个循环以传输每个字节数据，在每个字节发送之前等待数据寄存器为空。一旦所有字节都已传输，它等待字节传输完成，然后生成一个停止条件以结束通信。
- en: Our next task is to populate the `i2c.h` file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个任务是填充 `i2c.h` 文件。
- en: The header file
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头文件
- en: 'Here is the code for the header file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是头文件中的代码：
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s update our driver for the adxl345 device to use the I2C driver we developed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 adxl345 设备的驱动程序，以使用我们开发的 I2C 驱动程序。
- en: The ADXL345 I2C driver
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ADXL345 I2C 驱动程序
- en: 'Update the current `adxl345.c` in the `Src` folder:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `Src` 文件夹中的当前 `adxl345.c`：
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is a breakdown of the code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码的分解：
- en: The `adxl_read_address` function reads a single byte of data from a specified
    register in the ADXL345 accelerometer. It uses the `i2c1_byte_read` function to
    communicate over the I2C bus, fetching the data from the register identified by
    the `reg` parameter and storing it in the `data` variable.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adxl_read_address` 函数从 ADXL345 加速度计的指定寄存器读取单个字节数据。它使用 `i2c1_byte_read` 函数通过
    I2C 总线通信，从由 `reg` 参数指定的寄存器获取数据并将其存储在 `data` 变量中。'
- en: The `adxl_write` function writes a single byte of data to a specific register
    in the ADXL345\. It prepares a single-element array, containing the value to be
    written, and then uses `i2c1_burst_write` to send this data to the register specified
    by the `reg` parameter, over the I2C interface.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adxl_write` 函数将单个字节数据写入 ADXL345 的特定寄存器。它准备一个包含要写入值的单元素数组，然后使用 `i2c1_burst_write`
    将这些数据发送到由 `reg` 参数指定的寄存器，通过 I2C 接口。'
- en: The `adxl_read_values` function reads a block of data from the ADXL345 – specifically,
    `i2c1_burst_read` to pull this data, starting from the register specified by the
    `reg` parameter, and stores it in `data_buffer` for further processing.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adxl_read_values` 函数从 ADXL345 读取数据块 - 特别是使用 `i2c1_burst_read` 读取这些数据，从由 `reg`
    参数指定的寄存器开始，并将其存储在 `data_buffer` 中以供进一步处理。'
- en: The `adxl_init` function initializes the ADXL345 accelerometer. It first enables
    I2C communication by calling `i2c1_init`, and then it checks the device’s identity
    by reading the `DEVID` register. Following this, it configures the data format
    to a range of `±4g`, resets the power control register, and finally, sets the
    power control register to start measuring acceleration.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adxl_init` 函数初始化 ADXL345 加速度计。它首先通过调用 `i2c1_init` 启用 I2C 通信，然后通过读取 `DEVID`
    寄存器检查设备的身份。在此之后，它将数据格式配置为 ±4g 范围，重置电源控制寄存器，并最终将电源控制寄存器设置为开始测量加速度。'
- en: 'Next, we update the current `adxl345.h` in the `Inc` folder:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新 `Inc` 文件夹中的当前 `adxl345.h`：
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#include <stdio.h>'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <stdio.h>'
- en: '#include <stdint.h>'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '#include <stdint.h>'
- en: '#include "stm32f4xx.h"'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "stm32f4xx.h"'
- en: '#include "uart.h"'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "uart.h"'
- en: '#include "adxl345.h"'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '#include "adxl345.h"'
- en: //Variables for storing accelerometer data
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: // 用于存储加速度计数据的变量
- en: int16_t accel_x, accel_y, accel_z;
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: int16_t accel_x, accel_y, accel_z;
- en: double accel_x_g, accel_y_g, accel_z_g;
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: double accel_x_g, accel_y_g, accel_z_g;
- en: extern uint8_t data_buffer[6];
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: extern uint8_t data_buffer[6];
- en: int main(void)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: int main(void)
- en: '{'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: uart_init();
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: uart_init();
- en: // Initialize the ADXL345 accelerometer
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: // 初始化 ADXL345 加速度计
- en: adxl_init();
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: adxl_init();
- en: while (1)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: while (1)
- en: '{'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: // Read accelerometer data starting from the data start
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: // 从数据起始地址读取加速度计数据
- en: // register
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: // 寄存器
- en: adxl_read_values(ADXL345_REG_DATA_START);
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: adxl_read_values(ADXL345_REG_DATA_START);
- en: // Combine high and low bytes to form the accelerometer data
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: // 将高字节和低字节合并形成加速度计数据
- en: accel_x = (int16_t)((data_buffer[1] << 8) | data_buffer[0]);
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: accel_x = (int16_t)((data_buffer[1] << 8) | data_buffer[0]);
- en: accel_y = (int16_t)((data_buffer[3] << 8) | data_buffer[2]);
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: accel_y = (int16_t)((data_buffer[3] << 8) | data_buffer[2]);
- en: accel_z = (int16_t)((data_buffer[5] << 8) | data_buffer[4]);
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: accel_z = (int16_t)((data_buffer[5] << 8) | data_buffer[4]);
- en: // Convert raw data to g values
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: // 将原始数据转换为g值
- en: accel_x_g = accel_x * 0.0078;
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: accel_x_g = accel_x * 0.0078;
- en: accel_y_g = accel_y * 0.0078;
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: accel_y_g = accel_y * 0.0078;
- en: accel_z_g = accel_z * 0.0078;
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: accel_z_g = accel_z * 0.0078;
- en: 'printf("accel_x : %d accel_y : %d  accel_z : %d\n\'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'printf("accel_x : %d accel_y : %d  accel_z : %d\n\'
- en: r",accel_x,accel_y,accel_z);
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: r",accel_x,accel_y,accel_z);
- en: '}'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return 0;
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: return 0;
- en: '}'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
