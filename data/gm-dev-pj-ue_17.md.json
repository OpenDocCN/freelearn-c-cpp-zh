["```cpp\nUFUNCTION(Server, Reliable, WithValidation)\nvoid ServerRPCFunction(int32 IntegerParameter, float FloatParameter,   AActor* ActorParameter); \n```", "```cpp\nvoid ARPCTest::CallMyOwnServerRPC(int32 IntegerParameter)\n{\n\u00a0\u00a0ServerMyOwnRPC(IntegerParameter);\n}\nvoid ARPCTest::CallServerRPCOfAnotherActor(AAnotherActor* OtherActor)\n{\n\u00a0\u00a0if(OtherActor != nullptr)\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0OtherActor->ServerAnotherActorRPC();\n\u00a0\u00a0}\n}\n```", "```cpp\nUFUNCTION(NetMulticast)\nvoid MulticastRPCFunction(int32 IntegerParameter, float   FloatParameter, AActor* ActorParameter); \n```", "```cpp\nvoid ARPCTest::CallMyOwnMulticastRPC(int32 IntegerParameter)\n{\n\u00a0\u00a0MulticastMyOwnRPC(IntegerParameter);\n}\nvoid ARPCTest::CallMulticastRPCOfAnotherActor(AAnotherActor*   OtherActor)\n{\n\u00a0\u00a0if(OtherActor != nullptr)\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0OtherActor->MulticastAnotherActorRPC();\n\u00a0\u00a0}\n}\n```", "```cpp\nUFUNCTION(Client)\nvoid ClientRPCFunction(int32 IntegerParameter, float FloatParameter,   AActor* ActorParameter); \n```", "```cpp\nvoid ARPCTest::CallMyOwnClientRPC(int32 IntegerParameter)\n{\n\u00a0\u00a0ClientMyOwnRPC(IntegerParameter);\n}\nvoid ARPCTest::CallClientRPCOfAnotherActor(AAnotherActor* OtherActor)\n{\n\u00a0\u00a0if(OtherActor != nullptr)\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0OtherActor->ClientAnotherActorRPC();\n\u00a0\u00a0}\n}\n```", "```cpp\nvoid ARPCTest::ServerRPCTest_Implementation(int32 IntegerParameter,   float FloatParameter, AActor* ActorParameter)\n{\n}\n```", "```cpp\nvoid ARPCTest::MulticastRPCTest_Implementation(int32 IntegerParameter,   float FloatParameter, AActor* ActorParameter)\n{\n}\n```", "```cpp\nvoid ARPCTest::ClientRPCTest_Implementation(int32 IntegerParameter,   float FloatParameter, AActor* ActorParameter)\n{\n}\n```", "```cpp\nvoid ARPCTest::ServerRPCFunction(int32 IntegerParameter, float   FloatParameter, AActor* ActorParameter)\n{\n}\n```", "```cpp\nUFUNCTION(Server)\nvoid ServerRPCTest(int32 IntegerParameter); \n```", "```cpp\nvirtual void ServerRPCTest_Implementation(int32 IntegerParameter)   override;\n```", "```cpp\nvoid ARPCTest::CallServerRPC(int32 IntegerParameter)\n{\n\u00a0\u00a0if(HasAuthority())\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0ServerRPCFunction_Implementation(IntegerParameter);\n\u00a0\u00a0}\n\u00a0\u00a0else ServerRPCFunction(IntegerParameter);\n}\n```", "```cpp\nUFUNCTION(Server, WithValidation)\nvoid ServerSetHealth(float NewHealth);\n```", "```cpp\nbool ARPCTest::ServerSetHealth_Validate(float NewHealth)\n{\n\u00a0\u00a0return NewHealth <= MaxHealth;\n}\nvoid ARPCTest::ServerSetHealth_Implementation(float NewHealth)\n{\n\u00a0\u00a0Health = NewHealth;\n}\n```", "```cpp\n    UFUNCTION(Server, Reliable)\n    void ServerReliableRPCFunction(int32 IntegerParameter); \n    ```", "```cpp\n    UFUNCTION(Server, Unreliable)\n    void ServerUnreliableRPCFunction(int32 IntegerParameter);\n    ```", "```cpp\n    #include \"Net/UnrealNetwork.h\"\n    ```", "```cpp\n    FTimerHandle FireTimer;\n    ```", "```cpp\n    UPROPERTY(Replicated)\n    int32 Ammo = 5;\n    ```", "```cpp\n    UPROPERTY(EditDefaultsOnly, Category = \"RPC Character\")\n    UAnimMontage* FireAnimMontage;\n    ```", "```cpp\n    UPROPERTY(EditDefaultsOnly, Category = \"RPC Character\")\n    USoundBase* NoAmmoSound;\n    ```", "```cpp\n    virtual void Tick(float DeltaSeconds) override;\n    ```", "```cpp\n    void OnPressedFire();\n    ```", "```cpp\n    UFUNCTION(Server, Reliable, WithValidation, Category = \"RPC   Character\")\n    void ServerFire();\n    ```", "```cpp\n    UFUNCTION(NetMulticast, Unreliable, Category = \"RPC Character\")\n    void MulticastFire();\n    ```", "```cpp\n    UFUNCTION(Client, Unreliable, Category = \"RPC Character\")\n    void ClientPlaySound2D(USoundBase* Sound);\n    ```", "```cpp\n    #include \"DrawDebugHelpers.h\"\n    #include \"Kismet/GameplayStatics.h\"\n    #include \"TimerManager.h\"\n    #include \"Engine/World.h\"\n    ```", "```cpp\n    PrimaryActorTick.bCanEverTick = true;\n    ```", "```cpp\n    void ARPCCharacter::GetLifetimeReplicatedProps(TArray<   FLifetimeProperty >& OutLifetimeProps) const\n    {\n    \u00a0\u00a0Super::GetLifetimeReplicatedProps(OutLifetimeProps);\n    \u00a0\u00a0DOREPLIFETIME(ARPCCharacter, Ammo);\n    }\n    ```", "```cpp\n    void ARPCCharacter::Tick(float DeltaSeconds)\n    {\n    \u00a0\u00a0Super::Tick(DeltaSeconds);\n    \u00a0\u00a0const FString AmmoString = FString::Printf(TEXT(\"Ammo = %d\"),     Ammo);\n    \u00a0\u00a0DrawDebugString(GetWorld(), GetActorLocation(), AmmoString,     nullptr, FColor::White, 0.0f, true);\n    }\n    ```", "```cpp\n    PlayerInputComponent->BindAction(\"Fire\", IE_Pressed, this,   &ARPCCharacter::OnPressedFire);\n    ```", "```cpp\n    void ARPCCharacter::OnPressedFire()\n    {\n    \u00a0\u00a0ServerFire();\n    }\n    ```", "```cpp\n    bool ARPCCharacter::ServerFire_Validate()\n    {\n    \u00a0\u00a0return true;\n    }\n    ```", "```cpp\n    void ARPCCharacter::ServerFire_Implementation()\n    {\n\n    }\n    ```", "```cpp\n    if (GetWorldTimerManager().IsTimerActive(FireTimer))\n    {\n    \u00a0\u00a0return;\n    }\n    ```", "```cpp\n    if (Ammo == 0)\n    {\n    \u00a0\u00a0ClientPlaySound2D(NoAmmoSound);\n    \u00a0\u00a0return;\n    }\n    ```", "```cpp\n    Ammo--;\n    GetWorldTimerManager().SetTimer(FireTimer, 1.5f, false);\n    ```", "```cpp\n    MulticastFire();\n    ```", "```cpp\n    void ARPCCharacter::MulticastFire_Implementation()\n    {\n    \u00a0\u00a0if (FireAnimMontage != nullptr)\n    \u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0PlayAnimMontage(FireAnimMontage);\n    \u00a0\u00a0}\n    }\n    ```", "```cpp\n    void ARPCCharacter::ClientPlaySound2D_Implementation(USoundBase*   Sound)\n    {\n    \u00a0\u00a0UGameplayStatics::PlaySound2D(GetWorld(), Sound);\n    }\n    ```", "```cpp\nenum class ETestEnum : uint8\n{\n\u00a0\u00a0EnumValue1,\n\u00a0\u00a0EnumValue2,\n\u00a0\u00a0EnumValue3\n};\n```", "```cpp\nUPROPERTY()\nETestEnum TestEnum;\nUFUNCTION()\nvoid SetTestEnum(ETestEnum NewTestEnum) { TestEnum = NewTestEnum; }\n```", "```cpp\nerror : Unrecognized type 'ETestEnum' - type must be a UCLASS, USTRUCT   or UENUM\n```", "```cpp\nUENUM()\nenum class ETestEnum : uint8\n{\n\u00a0\u00a0EnumValue1,\n\u00a0\u00a0EnumValue2,\n\u00a0\u00a0EnumValue3\n};\n```", "```cpp\nUENUM()\nenum ETestRawEnum\n{\n\u00a0\u00a0EnumValue1,\n\u00a0\u00a0EnumValue2,\n\u00a0\u00a0EnumValue3\n};\n```", "```cpp\nUPROPERTY()\nETestRawEnum TestRawEnum;\n```", "```cpp\nerror : You cannot use the raw enum name as a type for member   variables, instead use TEnumAsByte or a C++11 enum class with an   explicit underlying type.\n```", "```cpp\nUPROPERTY()\nTEnumAsByte<ETestRawEnum> TestRawEnum;\n```", "```cpp\nUENUM()\nenum class ETestEnum : uint8\n{\n\u00a0\u00a0EnumValue1 UMETA(DisplayName = \"My First Option\",\n\u00a0\u00a0EnumValue2 UMETA(DisplayName = \"My Second Option\",\n\u00a0\u00a0EnumValue3 UMETA(DisplayName = \"My Third Option\"\n};\n```", "```cpp\nUPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = \"Test\")\nETestEnum TestEnum;\n```", "```cpp\nUENUM()\nenum class ETestEnum : uint8\n{\n\u00a0\u00a0EnumValue1 UMETA(DisplayName = \"My First Option\"),\n\u00a0\u00a0EnumValue2 UMETA(Hidden),\n\u00a0\u00a0EnumValue3 UMETA(DisplayName = \"My Third Option\")\n};\n```", "```cpp\nUPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = \"Test\")\nETestEnum TestEnum;\n```", "```cpp\nUENUM()\nenum class ETestEnum : uint8\n{\n\u00a0\u00a0EnumValue1,\n\u00a0\u00a0EnumValue2,\n\u00a0\u00a0EnumValue3,\n\u00a0\u00a0MAX\n};\n```", "```cpp\nconst int32 MaxCount = (int32)ETestEnum::MAX;\n```", "```cpp\nUENUM()\nenum class ETestEnum : uint8\n{\n\u00a0\u00a0EnumValue1 = 4,\n\u00a0\u00a0EnumValue2 = 78,\n\u00a0\u00a0EnumValue3 = 100,\n\u00a0\u00a0MAX\n};\n```", "```cpp\n    #define ENUM_TO_INT32(Value) (int32)Value\n    ```", "```cpp\n    #define ENUM_TO_FSTRING(Enum, Value) FindObject<UEnum>(ANY_PACKAGE, TEXT(Enum), true)-  >GetDisplayNameTextByIndex((int32)Value).ToString()\n    ```", "```cpp\n    UENUM(BlueprintType)\n    enum class EWeaponType : uint8\n    {\n    \u00a0\u00a0Pistol UMETA(Display Name = \u00abGlock 19\u00bb),\n    \u00a0\u00a0Shotgun UMETA(Display Name = \u00abWinchester M1897\u00bb),\n    \u00a0\u00a0RocketLauncher UMETA(Display Name = \u00abRPG\u00bb),\u00a0\u00a0\u00a0\u00a0\n    \u00a0\u00a0MAX\n    };\n    UENUM(BlueprintType)\n    enum class EAmmoType : uint8\n    {\n    \u00a0\u00a0Bullets UMETA(DisplayName = \u00ab9mm Bullets\u00bb),\n    \u00a0\u00a0Shells UMETA(Display Name = \u00ab12 Gauge Shotgun Shells\u00bb),\n    \u00a0\u00a0Rockets UMETA(Display Name = \u00abRPG Rockets\u00bb),\n    \u00a0\u00a0MAX\n    };\n    ```", "```cpp\n    #include \"Enumerations.h\"\n    ```", "```cpp\n    UPROPERTY(BlueprintReadOnly, Category = \"Enumerations Character\")\n    EWeaponType Weapon;\n    ```", "```cpp\n    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category =   \"Enumerations Character\")\n    TArray<int32> Ammo;\n    ```", "```cpp\n    virtual void BeginPlay() override;\n    virtual void Tick(float DeltaSeconds) override;\n    ```", "```cpp\n    void OnPressedPistol();\n    void OnPressedShotgun();\n    void OnPressedRocketLauncher();\n    void OnPressedFire();\n    ```", "```cpp\n    #include \"DrawDebugHelpers.h\"\n    ```", "```cpp\n    PlayerInputComponent->BindAction(\"Pistol\", IE_Pressed, this,   &AEnumerationsCharacter::OnPressedPistol);\n    PlayerInputComponent->BindAction(\"Shotgun\", IE_Pressed, this,   &AEnumerationsCharacter::OnPressedShotgun);\n    PlayerInputComponent->BindAction(\"Rocket Launcher\", IE_Pressed,   this, &AEnumerationsCharacter::OnPressedRocketLauncher);\n    PlayerInputComponent->BindAction(\"Fire\", IE_Pressed, this,   &AEnumerationsCharacter::OnPressedFire);\n    ```", "```cpp\n    void AEnumerationsCharacter::BeginPlay()\n    {\n    \u00a0\u00a0Super::BeginPlay();\n    \u00a0\u00a0const int32 AmmoCount = ENUM_TO_INT32(EAmmoType::MAX);\n    \u00a0\u00a0Ammo.Init(10, AmmoCount);\n    }\n    ```", "```cpp\n    void AEnumerationsCharacter::Tick(float DeltaSeconds)\n    {\n    \u00a0\u00a0Super::Tick(DeltaSeconds);\n    }\n    ```", "```cpp\n    const int32 WeaponIndex = ENUM_TO_INT32(Weapon);\n    const FString WeaponString = ENUM_TO_FSTRING(\"EWeaponType\",   Weapon);\n    ```", "```cpp\n    const FString AmmoTypeString = ENUM_TO_FSTRING(\"EAmmoType\",   Weapon);\n    const int32 AmmoCount = Ammo[WeaponIndex];\n    ```", "```cpp\n    const FString String = FString::Printf(TEXT(\"Weapon = %s\\nAmmo   Type = %s\\nAmmo Count = %d\"), *WeaponString, *AmmoTypeString,   AmmoCount);\n    DrawDebugString(GetWorld(), GetActorLocation(), String, nullptr,   FColor::White, 0.0f, true);\n    ```", "```cpp\n    void AEnumerationsCharacter::OnPressedPistol()\n    {\n    \u00a0\u00a0Weapon = EWeaponType::Pistol;\n    }\n    void AEnumerationsCharacter::OnPressedShotgun()\n    {\n    \u00a0\u00a0Weapon = EWeaponType::Shotgun;\n    }\n    void AEnumerationsCharacter::OnPressedRocketLauncher()\n    {\n    \u00a0\u00a0Weapon = EWeaponType::RocketLauncher;\n    }\n    ```", "```cpp\n    void AEnumerationsCharacter::OnPressedFire()\n    {\n    \u00a0\u00a0const int32 WeaponIndex = ENUM_TO_INT32(Weapon);\n    \u00a0\u00a0const int32 NewRawAmmoCount = Ammo[WeaponIndex] - 1;\n    \u00a0\u00a0const int32 NewAmmoCount = FMath::Max(NewRawAmmoCount, 0);\n    \u00a0\u00a0Ammo[WeaponIndex] = NewAmmoCount;\n    }\n    ```", "```cpp\nAWeapon * APlayer::GetPreviousWeapon()\n{\n\u00a0\u00a0if(WeaponIndex - 1 < 0)\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0WeaponIndex = Weapons.Num() - 1;\n\u00a0\u00a0}\n\u00a0\u00a0else WeaponIndex--;\n\u00a0\u00a0return Weapons[WeaponIndex];\n}\nAWeapon * APlayer::GetNextWeapon()\n{\n\u00a0\u00a0if(WeaponIndex + 1 > Weapons.Num() - 1)\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0WeaponIndex = 0;\n\u00a0\u00a0}\n\u00a0\u00a0else WeaponIndex++;\n\u00a0\u00a0return Weapons[WeaponIndex];\n}\n```", "```cpp\nAWeapon * APlayer::GetNewWeapon(int32 Direction)\n{\n\u00a0\u00a0const int32 WeaponCount = Weapons.Num();\n\u00a0\u00a0const int32 NewIndex = WeaponIndex + Direction;\n\u00a0\u00a0const in32 ClampedNewIndex = NewIndex % WeaponCount;\n\u00a0\u00a0WeaponIndex = (ClampedNewIndex + WeaponCount) % WeaponCount;\n\u00a0\u00a0return Weapons[WeaponIndex];\n}\n```", "```cpp\n    #define GET_CIRCULAR_ARRAY_INDEX(Index, Count) (Index % Count +   Count) % Count\n    ```", "```cpp\n    void OnPressedPreviousWeapon();\n    void OnPressedNextWeapon();\n    ```", "```cpp\n    void CycleWeapons(int32 Direction);\n    ```", "```cpp\n    PlayerInputComponent->BindAction(\"Previous Weapon\", IE_Pressed,   this, &AEnumerationsCharacter::OnPressedPreviousWeapon);\n    PlayerInputComponent->BindAction(\"Next Weapon\", IE_Pressed, this,   &AEnumerationsCharacter::OnPressedNextWeapon);\n    ```", "```cpp\n    void AEnumerationsCharacter::OnPressedPreviousWeapon()\n    {\n    \u00a0\u00a0CycleWeapons(-1);\n    }\n    void AEnumerationsCharacter::OnPressedNextWeapon()\n    {\n    \u00a0\u00a0CycleWeapons(1);\n    }\n    ```", "```cpp\n    void AEnumerationsCharacter::CycleWeapons(int32 Direction)\n    {\n    \u00a0\u00a0const int32 WeaponIndex = ENUM_TO_INT32(Weapon);\n    \u00a0\u00a0const int32 AmmoCount = Ammo.Num();\n    \u00a0\u00a0const int32 NextRawWeaponIndex = WeaponIndex + Direction;\n    \u00a0\u00a0const int32 NextWeaponIndex = GET_CIRCULAR_ARRAY_INDEX(NextRawWeaponIndex , AmmoCount);\n    \u00a0\u00a0Weapon = (EWeaponType)NextWeaponIndex;\n    }\n    ```"]