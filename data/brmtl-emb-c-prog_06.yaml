- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: The Common Microcontroller Software Interface Standard (CMSIS)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用微控制器软件接口标准（CMSIS）
- en: In this chapter, we will delve into the **Common Microcontroller Software Interface
    Standard** (**CMSIS**), a critical framework for Cortex-M and some Cortex-A processors.
    We will begin by learning how to define hardware registers using C structures.
    This foundational knowledge will enable us to read and understand CMSIS-compliant
    header files provided by microcontroller manufacturers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入研究**通用微控制器软件接口标准**（**CMSIS**），这是Cortex-M和某些Cortex-A处理器的关键框架。我们将从学习如何使用C结构定义硬件寄存器开始。这种基础知识将使我们能够阅读和理解微控制器制造商提供的CMSIS兼容的头文件。
- en: Next, we will explore CMSIS itself, discussing its components and how it facilitates
    efficient software development. Finally, we will set up the necessary header files
    from our silicon manufacturer, demonstrating how CMSIS compliance can streamline
    production and improve code portability.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨CMSIS本身，讨论其组件以及它是如何促进高效软件开发的。最后，我们将设置从我们的硅制造商处获取的必要头文件，展示CMSIS合规性如何简化生产和提高代码可移植性。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Defining peripheral registers with C structures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C结构定义外设寄存器
- en: Understanding CMSIS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解CMSIS
- en: Setting up the required CMSIS files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置所需的CMSIS文件
- en: By the end of this chapter, you will be equipped with a solid understanding
    of CMSIS and how to use it to enhance code portability in your Arm Cortex-M projects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将具备对CMSIS的扎实理解，以及如何使用它来增强你的Arm Cortex-M项目的代码可移植性。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，链接为[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: Defining peripheral registers with C structures
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C结构定义外设寄存器
- en: In embedded systems development, defining hardware registers using C structures
    is a fundamental technique that enhances code readability and maintainability.
    In this section, we will explore how to use C structures to represent peripherals
    and their registers, drawing on practical examples and analogies to simplify the
    concept.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统开发中，使用C结构定义硬件寄存器是一种基本技术，它可以提高代码的可读性和可维护性。在本节中，我们将探讨如何使用C结构来表示外设及其寄存器，通过实际示例和类比来简化概念。
- en: In previous chapters, we configured a **General Purpose Input/Output** (**GPIO**)
    pin (PA5) to turn on an LED by manually defining the address of each required
    register. We learned how to find the correct addresses from documentation, define
    registers, and define register bits. This method, while effective, can become
    cumbersome as projects grow in complexity.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们配置了一个**通用输入/输出**（**GPIO**）引脚（PA5），通过手动定义每个所需寄存器的地址来点亮一个LED。我们学习了如何从文档中找到正确的地址，定义寄存器和定义寄存器位。虽然这种方法有效，但随着项目的复杂性增加，可能会变得繁琐。
- en: To streamline this process, we can use C structures to represent peripherals
    and their registers. This approach groups related registers into a cohesive unit
    to match the hardware architecture and memory map of our microcontroller, making
    the code more intuitive.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个过程，我们可以使用C结构来表示外设及其寄存器。这种方法将相关的寄存器组合成一个统一的单元，以匹配我们的微控制器的硬件架构和内存映射，使代码更加直观。
- en: Let’s create a structure to represent the GPIO peripherals and their associated
    registers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个结构体来表示GPIO外设及其相关的寄存器。
- en: To achieve this, we need to get the base address of each GPIO port and the offset
    of each register within these ports. Here, offset refers to the register’s address
    relative to the peripheral’s base address.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要获取每个GPIO端口的基址以及这些端口内每个寄存器的偏移量。在这里，偏移量指的是寄存器地址相对于外设基址的相对位置。
- en: Before diving into the details of creating the structure, it’s important to
    understand how to obtain the necessary base addresses and offsets.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入创建结构体的细节之前，了解如何获取必要的基址和偏移量是很重要的。
- en: Getting the base address and offsets of registers
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取寄存器的基址和偏移量
- en: 'In [*Chapter 2*](B21914_02.xhtml#_idTextAnchor039), we learned how to locate
    the base addresses of peripherals in our datasheet. Specifically, we examined
    pages 54 to 56 of the STM32F411 datasheet, which lists the base addresses for
    the microcontroller’s peripherals. Here are the extracted base addresses for the
    GPIO and **Reset and Clock Control** (**RCC**) peripherals:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B21914_02.xhtml#_idTextAnchor039)中，我们学习了如何在数据手册中定位外设的基址。具体来说，我们查看了
    STM32F411 数据手册的第 54 至 56 页，列出了微控制器外设的基址。以下是 GPIO 和 **复位和时钟控制**（**RCC**）外设的提取基址：
- en: '| **Peripheral** | **Base Address** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **外设** | **基址** |'
- en: '| --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **GPIOA** | 0x4002 0000 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOA** | 0x4002 0000 |'
- en: '| **GPIOB** | 0x4002 0400 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOB** | 0x4002 0400 |'
- en: '| **GPIOC** | 0x4002 0800 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOC** | 0x4002 0800 |'
- en: '| **GPIOD** | 0x4002 0C00 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOD** | 0x4002 0C00 |'
- en: '| **GPIOE** | 0x4002 1000 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOE** | 0x4002 1000 |'
- en: '| **GPIOH** | 0x4002 1C00 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOH** | 0x4002 1C00 |'
- en: '| **RCC** | 0x4002 3800 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **RCC** | 0x4002 3800 |'
- en: 'Table 6.1: Base addresses of GPIO and RCC'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.1：GPIO 和 RCC 的基址
- en: 'Also, in [*Chapter 2*](B21914_02.xhtml#_idTextAnchor039), we covered how to
    extract the register offsets from the reference manual (**RM383**). Here are the
    extracted offsets for all the GPIO registers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在[*第 2 章*](B21914_02.xhtml#_idTextAnchor039)中，我们介绍了如何从参考手册（**RM383**）中提取寄存器偏移量。以下是所有
    GPIO 寄存器的提取偏移量：
- en: '| **Register** | **Offset** |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **寄存器** | **偏移量** |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **GPIOx_MODER** | 0x00 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOx_MODER** | 0x00 |'
- en: '| **GPIOx_OTYPE****R** | 0x04 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOx_OTYPER** | 0x04 |'
- en: '| **GPIOx_OSPEED****R** | 0x08 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOx_OSPEEDR** | 0x08 |'
- en: '| **GPIOx_PUPD****R** | 0x0C |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOx_PUPDR** | 0x0C |'
- en: '| **GPIOx_IDR** | 0x10 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOx_IDR** | 0x10 |'
- en: '| **GPIOx_ODR** | 0x14 |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOx_ODR** | 0x14 |'
- en: '| **GPIOx_BSRR** | 0x18 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOx_BSRR** | 0x18 |'
- en: '| **GPIOx_LCKR** | 0x1C |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOx_LCKR** | 0x1C |'
- en: '| **GPIOx_AFRL** | 0x20 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOx_AFRL** | 0x20 |'
- en: '| **GPIOx_AFRH** | 0x24 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **GPIOx_AFRH** | 0x24 |'
- en: 'Table 6.2: Offsets of GPIO register'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6.2：GPIO 寄存器偏移量
- en: '*Table 6.1* shows all the GPIO registers of our STM32F411 microcontroller along
    with their offsets, arranged in the same order they appear in memory. Almost all
    registers in our microcontroller are 32 bits (4 bytes) in size. As illustrated
    in *Table 6.1*, each register is offset by 4 bytes from the previous one. For
    instance, the `GPIOx_OTYPER` register at `0x04` is 4 bytes from the `GPIOx_MODER`
    register at `0x00` (0x04 - 0x00 = 4). Similarly, the `GPIOx_PUPDR` register at
    `0x0C` is 4 bytes from the `GPIOx_OSPEEDR` register at `0x08`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 6.1* 显示了我们 STM32F411 微控制器的所有 GPIO 寄存器及其偏移量，按照它们在内存中出现的顺序排列。我们微控制器中的几乎所有寄存器都是
    32 位（4 字节）大小。如 *表 6.1* 所示，每个寄存器相对于前一个寄存器偏移 4 字节。例如，`GPIOx_OTYPER` 寄存器位于 `0x04`，距离
    `GPIOx_MODER` 寄存器位于 `0x00`（0x04 - 0x00 = 4）有 4 字节。同样，`GPIOx_PUPDR` 寄存器位于 `0x0C`，距离
    `GPIOx_OSPEEDR` 寄存器位于 `0x08` 有 4 字节。'
- en: This tells us that the registers are contiguously arranged in that memory region,
    since we know that each register is 4 bytes in size.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，寄存器在该内存区域中是连续排列的，因为我们知道每个寄存器的大小为 4 字节。
- en: However, this contiguous arrangement is not always the case. There are instances
    where gaps of a few bytes are left between registers within a peripheral.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种连续排列的情况并不总是如此。在某些情况下，外设内部的寄存器之间会留下几个字节的间隙。
- en: '*Now, what’s the relationship between the offset and the* *base address?*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在，偏移量和基址之间有什么关系呢？*'
- en: Imagine your microcontroller as a large apartment complex. Each apartment represents
    a peripheral, such as GPIO or RCC, and the entrance to each apartment is the peripheral’s
    base address. Inside each apartment, there are several rooms, which represent
    the registers. Each room has a specific purpose and is located at a certain distance
    from the entrance, known as the **offset**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你的微控制器就像一个大型公寓楼。每个公寓代表一个外设，例如 GPIO 或 RCC，每个公寓的入口就是外设的基址。在每间公寓内部，有几个房间，这些房间代表寄存器。每个房间都有特定的用途，并且位于入口的一定距离处，称为**偏移量**。
- en: For example, when you enter the GPIO apartment (peripheral), the living room
    might be the `GPIOx_MODER` register located right at the entrance (offset 0x00).
    The kitchen could be the `GPIOx_OTYPER` register, located a bit further down the
    hallway (offset 0x04). The bedroom might be the `GPIOx_OSPEEDR` register, located
    even further down the hallway (offset 0x08), and so on.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你进入 GPIO 公寓（外设）时，客厅可能是位于入口处（偏移量 0x00）的 `GPIOx_MODER` 寄存器。厨房可能是位于走廊稍远处的 `GPIOx_OTYPER`
    寄存器（偏移量 0x04）。卧室可能是位于走廊更远处的 `GPIOx_OSPEEDR` 寄存器（偏移量 0x08），等等。
- en: This arrangement shows that each room (register) is placed at a fixed distance
    (offset) from the entrance (base address). In our case, since each room is 4 bytes
    in size, every subsequent room is 4 bytes away from the previous one. However,
    in some apartments (peripherals), there might be extra space between rooms, indicating
    non-contiguous placement of registers. This is similar to having a small hallway
    between rooms, which you’ll notice when you examine peripherals such as the RCC
    peripheral in the reference manual.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种排列表明每个房间（寄存器）都放置在入口（基址）的固定距离（偏移量）处。在我们的情况下，由于每个房间的大小是4字节，所以每个后续房间都距离前一个房间4字节。然而，在某些公寓（外设）中，房间之间可能会有额外的空间，表明寄存器的非连续放置。这类似于房间之间有一个小走廊，当你检查参考手册中的RCC外设等外设时，你会注意到这一点。
- en: Now, let’s go ahead with implementing the peripheral structures using what we
    have learned so far.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续使用我们迄今为止所学的内容来实现外设结构体。
- en: Implementing the peripheral structures
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现外设结构体
- en: 'The following is our `GPIO_TypeDef` structure, representing the GPIO peripherals:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们`GPIO_TypeDef`结构体，代表GPIO外设：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break down the syntax:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下语法：
- en: The line `typedef struct` begins the definition of a new structure type. `typedef`
    is used to create an alias for the structure, allowing us to use `GPIO_TypeDef`
    as a type name later in the code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 行 `typedef struct` 开始了一个新结构类型的定义。`typedef` 用于为结构体创建一个别名，允许我们在代码的后续部分使用 `GPIO_TypeDef`
    作为类型名。
- en: 'Each member of the structure is declared as `volatile uint32_t`. Here’s the
    breakdown:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体中的每个成员都被声明为`volatile uint32_t`。以下是分解：
- en: '`volatile`: This keyword indicates that the value of the variable can change
    at any time, often due to hardware changes. The compiler should not optimize accesses
    to this variable.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volatile`：这个关键字表示变量的值可以在任何时候改变，通常是由于硬件变化引起的。编译器不应优化对这个变量的访问。'
- en: '`uint32_t`: This indicates that each member of the structure is a 32-bit (4-byte)
    unsigned integer. This is important because the registers we are working with
    are also 32 bits in size. To ensure that the structure members accurately represent
    these registers, they must match this size. This alignment guarantees that each
    member corresponds correctly to its respective register in the memory map.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uint32_t`: 这表示结构体中的每个成员都是一个32位（4字节）的无符号整数。这很重要，因为我们正在处理的寄存器大小也是32位。为了确保结构体成员能够准确代表这些寄存器，它们必须匹配这个大小。这种对齐保证了每个成员在内存映射中正确对应其各自的寄存器。'
- en: Also note that the structure members are arranged in the same order and have
    the same size as the registers, as specified in the reference manual.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，结构体成员的排列顺序和大小与参考手册中指定的寄存器相同。
- en: Now, as we discussed in [*Chapter 2*](B21914_02.xhtml#_idTextAnchor039), to
    use any peripheral in the microcontroller, we first need to enable clock access
    to that peripheral. This is done through the RCC peripheral. Let’s create the
    structure for the RCC peripheral.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们在[*第2章*](B21914_02.xhtml#_idTextAnchor039)中讨论的那样，要使用微控制器中的任何外设，我们首先需要启用对该外设的时钟访问。这是通过RCC外设完成的。让我们为RCC外设创建一个结构体。
- en: 'This is our RCC structure:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的RCC结构体：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The RCC peripheral of the STM32F411 microcontroller has about 24 registers,
    which are not contiguous, leaving gaps in the memory region. The register we are
    interested in for the purposes of GPIO peripherals is the `AHB1ENR` register,
    which has an offset of 0x30.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F411微控制器的RCC外设大约有24个寄存器，这些寄存器不是连续的，在内存区域中留下空隙。我们感兴趣的寄存器是为了GPIO外设的`AHB1ENR`寄存器，其偏移量为0x30。
- en: In our `RCC_TypeDef`, we have added padding to the structure with the number
    of `uint32_t` (4 bytes) items required to reach the offset 0x30\. In this case,
    it is 12 items. This is *because 4 bytes multiplied by 12 equals 48 bytes*, which
    corresponds to *0x30 in* *hexadecimal notation*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`RCC_TypeDef`中，我们添加了足够的`uint32_t`（4字节）项目填充到结构体中，以达到偏移量0x30。在这种情况下，是12个项目。这是因为在4字节乘以12等于48字节，这对应于*十六进制表示法中的*0x30。
- en: 'At this point, we have defined two important structures (`GPIO_TypeDef` and
    `RCC_TypeDef`) required to configure and control our GPIO pins. The next step
    involves creating pointers to the base addresses of the GPIO and RCC peripherals
    using these structures. This allows us to access and manipulate the peripheral
    registers in a structured and readable manner. Here is the code snippet that accomplishes
    this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经定义了两个重要的结构（`GPIO_TypeDef` 和 `RCC_TypeDef`），这些结构是配置和控制我们的 GPIO 引脚所必需的。下一步涉及到使用这些结构创建
    GPIO 和 RCC 外设的基地址指针。这使我们能够以结构化和可读的方式访问和操作外设寄存器。以下是完成此任务的代码片段：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s break it down:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: '`#define` `RCC_BASE 0x40023800`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#define` `RCC_BASE 0x40023800`'
- en: This line defines the base address of the RCC peripheral. The address value
    is taken from *Table 6.1*.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一行定义了 RCC 外设的基地址。地址值取自 *表 6.1*。
- en: '`#define` `GPIOA_BASE 0x40020000`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#define` `GPIOA_BASE 0x40020000`'
- en: This line defines the base address of the GPIOA peripheral.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一行定义了 GPIOA 外设的基地址。
- en: '`#define RCC ((``RCC_TypeDef*) RCC_BASE)`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#define RCC ((RCC_TypeDef*) RCC_BASE)`'
- en: This line defines a macro, `RCC`, that casts the `RCC_BASE` base address to
    a pointer of type `RCC_TypeDef*`.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一行定义了一个宏，`RCC`，它将 `RCC_BASE` 基地址转换为 `RCC_TypeDef*` 类型的指针。
- en: By doing this, `RCC` becomes a pointer to the RCC peripheral, allowing us to
    access its registers through the `RCC_TypeDef` structure.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这样做，`RCC` 成为一个指向 RCC 外设的指针，允许我们通过 `RCC_TypeDef` 结构访问其寄存器。
- en: '`#define GPIOA ((``GPIO_TypeDef*) GPIOA_BASE)`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#define GPIOA ((GPIO_TypeDef*) GPIOA_BASE)`'
- en: Similarly, this line defines a macro, `GPIOA`, that casts the `GPIOA_BASE` base
    address to a pointer of type `GPIO_TypeDef*`.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，这一行定义了一个宏，`GPIOA`，它将 `GPIOA_BASE` 基地址转换为 `GPIO_TypeDef*` 类型的指针。
- en: This makes `GPIOA` a pointer to the GPIOA peripheral, enabling access to its
    registers via the `GPIO_TypeDef` structure.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这使得 `GPIOA` 成为一个指向 GPIOA 外设的指针，使我们能够通过 `GPIO_TypeDef` 结构访问其寄存器。
- en: With this accomplished, we are now ready to test out our implementation. Let’s
    do that in the next section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们现在可以测试我们的实现了。让我们在下一节中这样做。
- en: Evaluating the structure-based register access method
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估基于结构的寄存器访问方法
- en: 'Let’s update our previous project to use the structure-based register access
    approach:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们之前的工程以使用基于结构的寄存器访问方法：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this new implementation, we access the required registers using the C structure
    pointer operator (`->`). Here’s a breakdown of `RCC->AHB1ENR`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的实现中，我们使用 C 结构指针运算符（`->`）来访问所需的寄存器。以下是 `RCC->AHB1ENR` 的分解：
- en: '`RCC`: This is the pointer to a structure of type `RCC_TypeDef`. This pointer
    allows us to access the RCC registers using the structure’s members.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RCC`: 这是一个指向类型为 `RCC_TypeDef` 的结构的指针。这个指针允许我们通过结构成员访问 RCC 寄存器。'
- en: '`->`: This is the structure pointer operator in C. It is used to access a member
    of a structure through a pointer.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->`: 这是 C 中的结构指针运算符。它用于通过指针访问结构的一个成员。'
- en: '`AHB1ENR`: This is a member of the `RCC_TypeDef` structure.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AHB1ENR`: 这是 `RCC_TypeDef` 结构的一个成员。'
- en: Similarly, we use the same approach to access GPIOA registers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用相同的方法来访问 GPIOA 寄存器。
- en: 'Here’s a breakdown of `GPIOA->MODER` and `GPIOA->ODR`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `GPIOA->MODER` 和 `GPIOA->ODR` 的分解：
- en: '`GPIOA`: This is a pointer to the structure of type `GPIO_TypeDef`, allowing
    access to GPIOA registers'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIOA`: 这是一个指向类型为 `GPIO_TypeDef` 的结构的指针，允许访问 GPIOA 寄存器'
- en: '`MODER`: A member of the `GPIO_TypeDef` structure, representing the GPIO port
    mode register'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MODER`: `GPIO_TypeDef` 结构的一个成员，代表 GPIO 端口模式寄存器'
- en: '`ODR`: Another member of the `GPIO_TypeDef` structure, representing the GPIO
    port output data register'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ODR`: `GPIO_TypeDef` 结构的另一个成员，代表 GPIO 端口输出数据寄存器'
- en: Build the project and run it on your development board. It should work the same
    way as the previous project.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 构建项目并在您的开发板上运行它。它应该与上一个项目以相同的方式工作。
- en: In this section, we learned how to define hardware registers using C structures.
    This technique is an important step toward understanding CMSIS-compliant code,
    which will be covered in the next sections.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用 C 结构定义硬件寄存器。这项技术是理解 CMSIS 兼容代码的重要步骤，将在下一节中介绍。
- en: Understanding CMSIS
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 CMSIS
- en: In this section, we will explore CMSIS, an important framework designed for
    Arm Cortex-M and some Cortex-A processors. **CMSIS** is a vendor-independent hardware
    abstraction layer that standardizes software interfaces across various Arm Cortex-based
    microcontroller platforms, promoting software portability and reusability. Let’s
    start by understanding CMSIS and its key benefits.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨CMSIS，这是一个为Arm Cortex-M和某些Cortex-A处理器设计的框架。**CMSIS**是一个供应商无关的硬件抽象层，它标准化了各种基于Arm
    Cortex的微控制器平台之间的软件接口，促进了软件的可移植性和可重用性。让我们首先了解CMSIS及其关键优势。
- en: What is CMSIS?
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是CMSIS？
- en: CMSIS, pronounced *See-M-Sys*, is a standard developed by Arm to provide a consistent
    and efficient way to interface with Cortex-based microcontrollers. It includes
    a comprehensive set of APIs, software components, tools, and workflows designed
    to simplify and streamline the development process for embedded systems.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CMSIS，发音为*See-M-Sys*，是由Arm开发的标准，旨在提供一种一致且高效的方式与基于Cortex的微控制器进行接口。它包括一套全面的API、软件组件、工具和工作流程，旨在简化并优化嵌入式系统的开发过程。
- en: 'Its key benefits include the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它的关键优势包括以下内容：
- en: '**Standardization**: CMSIS standardizes the interface for all Cortex-based
    microcontrollers, making it easier for you to switch between different microcontrollers
    and tools without having to relearn or reconfigure your code base'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准化**：CMSIS对所有基于Cortex的微控制器接口进行标准化，这使得您可以在不重新学习或重新配置代码库的情况下轻松地在不同微控制器和工具之间切换'
- en: '**Portability**: By providing a consistent API, CMSIS allows software developed
    for one microcontroller to be easily ported to another, enhancing code reuse and
    reducing development time'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**便携性**：通过提供一致的API，CMSIS允许为某一微控制器开发的软件轻松移植到另一个微控制器，增强代码重用并减少开发时间'
- en: '**Efficiency**: CMSIS includes optimized libraries and functions, such as **Digital
    Signal Processing** (**DSP**) and neural network kernels, which improve performance
    and reduce the memory footprint'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：CMSIS包括优化的库和函数，如**数字信号处理**（**DSP**）和神经网络内核，这些可以提升性能并减少内存占用'
- en: CMSIS has several components. Let’s explore some of the commonly used ones.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: CMSIS有几个组件。让我们探索一些常用的组件。
- en: Key components of CMSIS
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMSIS的关键组件
- en: 'CMSIS comprises several components, each serving a unique purpose:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: CMSIS由几个组件组成，每个组件都服务于独特的目的：
- en: '**CMSIS-Core (M)**: This component is designed for all Cortex-M and SecurCore
    processors. It provides standardized APIs for configuring the Cortex-M processor
    core and peripherals. It also standardizes the naming of device peripheral registers,
    which helps reduce the learning curve when switching between different microcontrollers.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMSIS-Core (M)**：此组件是为所有Cortex-M和SecurCore处理器设计的。它提供了配置Cortex-M处理器核心和外设的标准API。它还标准化了设备外设寄存器的命名，有助于在切换不同微控制器时减少学习曲线。'
- en: '**CMSIS-Driver**: This provides generic peripheral driver interfaces for middleware,
    facilitating the connection between microcontroller peripherals and middleware
    such as communication stacks, filesystems, or graphical user interfaces.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMSIS-Driver**：这为中间件提供了通用的外设驱动接口，促进了微控制器外设与中间件（如通信堆栈、文件系统或图形用户界面）之间的连接。'
- en: '**CMSIS-DSP**: This component offers a library of over 60 functions for various
    data types, optimized for the **Single Instruction Multiple Data** (**SIMD**)
    instruction sets available on Cortex-M4, M7, M33, and M35P processors.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMSIS-DSP**：此组件提供了一套超过60个针对各种数据类型的函数库，针对Cortex-M4、M7、M33和M35P处理器上可用的**单指令多数据**（**SIMD**）指令集进行了优化。'
- en: '**CMSIS-NN**: This stands for **neural network**. It includes a collection
    of efficient neural network kernels optimized to maximize the performance and
    minimize the memory footprint on Cortex-M processor cores.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMSIS-NN**：这代表**神经网络**。它包括一系列针对Cortex-M处理器核心进行优化的高效神经网络内核，旨在最大化性能并最小化内存占用。'
- en: '**CMSIS-RTOS**: There are two versions, RTOS v1 and RTOS v2\. RTOS v1 supports
    Cortex-M0, M0+, M3, M4, and M7 processors, providing a common API for real-time
    operating systems. RTOS v2 extends support to Cortex-A5, A7, and A9 processors,
    including features such as dynamic object creation and multi-core system support.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMSIS-RTOS**：有两个版本，RTOS v1和RTOS v2。RTOS v1支持Cortex-M0、M0+、M3、M4和M7处理器，为实时操作系统提供公共API。RTOS
    v2扩展了对Cortex-A5、A7和A9处理器的支持，包括动态对象创建和多核系统支持等功能。'
- en: '**CMSIS-Pack**: Pack outlines a delivery system for software components, device
    parameters, and evaluation board support. It streamlines software reuse and facilitates
    effective product life cycle management.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMSIS-Pack**: Pack 描述了一个软件组件、设备参数和评估板支持的交付系统。它简化了软件重用并促进了有效的产品生命周期管理。'
- en: '**CMSIS-SVD**: **SVD** stands for **System Viewer Description**. It defines
    device description files maintained by the silicon vendor, containing comprehensive
    descriptions of the microcontroller peripherals and registers in XML format. Development
    tools import these files to automatically construct peripheral debug windows.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMSIS-SVD**: **SVD** 代表 **System Viewer Description**。它定义了由硅供应商维护的设备描述文件，包含对微控制器外设和寄存器的全面描述，格式为XML。开发工具导入这些文件以自动构建外设调试窗口。'
- en: Another crucial aspect of CMSIS is its coding standard. Let’s take a closer
    look to familiarize ourselves with these guidelines.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: CMSIS 的另一个关键方面是其编码标准。让我们更详细地了解一下这些指南。
- en: The CMSIS coding rules
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMSIS 编码规则
- en: 'Here are the essential coding rules and conventions used in CMSIS:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 CMSIS 中使用的必要编码规则和约定：
- en: '**Compliance with ANSI C (C99) and C++ (C++03)**: This ensures compatibility
    with widely accepted programming standards.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**符合 ANSI C (C99) 和 C++ (C++03)**: 这确保了与广泛接受的编程标准的兼容性。'
- en: '`<stdint.h>`, ensuring consistency in data representation.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<stdint.h>`，确保数据表示的一致性。'
- en: '**Complete data types**: Variables and parameters are defined with complete
    data types, avoiding ambiguity.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整数据类型**: 变量和参数使用完整数据类型定义，避免了歧义。'
- en: '**MISRA 2012 conformance**: While CMSIS conforms to the MISRA 2012 guidelines,
    it does not claim full MISRA compliance. Any rule violations are documented for
    transparency.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MISRA 2012 符合性**: 虽然 CMSIS 符合 MISRA 2012 指南，但它并不声称完全符合 MISRA。任何违规规则都会被记录下来以确保透明度。'
- en: 'Additionally, CMSIS uses specific qualifiers:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CMSIS 还使用特定的限定符：
- en: '`__I` for read-only variables (equivalent to **volatile const** in ANSI C)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__I` 用于只读变量（相当于 ANSI C 中的 **volatile const**）'
- en: '`__O` for write-only variables'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__O` 用于只写变量'
- en: '`__IO` for read and write variables (equivalent to **volatile** in ANSI C)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__IO` 用于读写变量（相当于 ANSI C 中的 **volatile**）'
- en: These qualifiers in CMSIS provide a convenient way to specify the intended access
    mode for variables, particularly for memory-mapped peripheral registers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限定符在 CMSIS 中提供了一种方便的方式来指定变量的预期访问模式，特别是对于内存映射外设寄存器。
- en: With this background knowledge, let’s go ahead and learn how to use CMSIS in
    our embedded projects.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在具备这些背景知识的基础上，让我们继续学习如何在嵌入式项目中使用 CMSIS。
- en: The CMSIS-Core files
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CMSIS-Core 文件
- en: The CMSIS-Core files are categorized into two primary groups, each serving a
    specific purpose in the development process. These groups are the CMSIS-Core standard
    files and the CMSIS-Core device files. *Figure 6**.1* provides a comprehensive
    overview of the CMSIS-Core file structure, illustrating the different types of
    files and their roles in a project.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: CMSIS-Core 文件分为两个主要组，每个组在开发过程中都发挥着特定的作用。这些组是 CMSIS-Core 标准文件和 CMSIS-Core 设备文件。*图
    6**.1* 提供了 CMSIS-Core 文件结构的全面概述，说明了不同类型文件及其在项目中的作用。
- en: '![Figure 6.1: The CMSIS-Core files](img/B21914_06_1.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1：CMSIS-Core 文件](img/B21914_06_1.jpg)'
- en: 'Figure 6.1: The CMSIS-Core files'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：CMSIS-Core 文件
- en: Let’s analyze the diagram.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这个图。
- en: 'The files are divided into three categories: **CMSIS-Core Standard Files**,
    **CMSIS-Core Device Files**, and **User** **Program Files**.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 文件分为三个类别：**CMSIS-Core 标准文件**、**CMSIS-Core 设备文件**和**用户** **程序文件**。
- en: 'The **CMSIS-Core Standard Files** category of files is provided by Arm and
    typically does not require modifications. They include the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**CMSIS-Core 标准文件**类别由 Arm 提供，通常不需要修改。它们包括以下内容：'
- en: '`core_<cpu>.h`: This provides access to the CPU and core-specific functionalities'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`core_<cpu>.h`: 该文件提供了对 CPU 和核心特定功能的访问'
- en: '`cmsis_compiler.h`: This contains core peripheral functions, CPU instruction
    access, and SIMD instruction access'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmsis_compiler.h`: 该文件包含核心外设函数、CPU指令访问和SIMD指令访问'
- en: '`<arch>_<feature>.h`: This defines architecture-specific attributes and features'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<arch>_<feature>.h`: 该文件定义了特定于架构的属性和功能'
- en: '`cmsis_<compiler>_m.h`: This is a toolchain-specific file that aids in compiler
    compatibility and optimization'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmsis_<compiler>_m.h`: 这是一个针对工具链的特定文件，有助于提高编译器的兼容性和优化'
- en: 'The next category is **CMSIS-Core Device Files**. These files are provided
    by silicon vendors (such as STMicroelectronics) and may require application-specific
    modifications. They include the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下一类是**CMSIS-Core设备文件**。这些文件由硅供应商（如STMicroelectronics）提供，可能需要针对特定应用进行修改。它们包括以下内容：
- en: '`system_<Device>.c`: This file handles system and clock configuration'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system_<Device>.c`：此文件处理系统和时钟配置'
- en: '`partition_<Device>.h`: This manages secure attributes and interrupt assignments'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partition_<Device>.h`：此文件管理安全属性和中断分配'
- en: '`startup_<Device>.c`: This contains the device startup interrupt vectors'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startup_<Device>.c`：此文件包含设备启动中断向量'
- en: '`<Device>.h`: This provides access to the CMSIS device peripheral functionalities'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Device>.h`：此文件提供对CMSIS设备外设功能的访问'
- en: '`system_<Device>.h`: This assists in system and clock configuration'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system_<Device>.h`：此文件协助进行系统和时钟配置'
- en: The third category is **User Program Files**. These are created by us, the developers,
    and include the main application code along with other user-defined functionalities
    essential for the project’s operation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第三类是**用户程序文件**。这些是我们开发者创建的，包括主应用程序代码以及其他对于项目运行至关重要的用户定义功能。
- en: Understanding CMSIS is fundamental for efficient and standardized development
    across various Arm Cortex-based microcontroller platforms. In this section, we
    have explored its key components, the CMSIS coding standards, and the CMSIS-Core
    files crucial to the development of embedded projects. In the next section, we
    will learn how to include the required CMSIS files in our project, enabling us
    to leverage the full potential of this robust framework for developing embedded
    systems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 理解CMSIS对于在各个基于Arm Cortex的微控制器平台上进行高效和标准化的开发是基本的。在本节中，我们探讨了其关键组件、CMSIS编码标准和对于嵌入式项目开发至关重要的CMSIS-Core文件。在下一节中，我们将学习如何将所需的CMSIS文件包含到我们的项目中，使我们能够充分利用这个强大的框架来开发嵌入式系统。
- en: Setting up the required CMSIS files
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置所需的CMSIS文件
- en: In this section, we will work through the process of integrating CMSIS files
    into our project. These files also contain the definitions of all the registers
    and their respective bits, making it easier to manage and configure peripherals
    without manually defining each register.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过将CMSIS文件集成到我们的项目中的过程。这些文件还包含了所有寄存器和它们各自的位定义，这使得在没有手动定义每个寄存器的情况下管理和配置外设变得更加容易。
- en: Getting the right header files
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取正确的头文件
- en: 'Let’s start by downloading the package for our microcontroller from the STMicroelectronics
    website:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从STMicroelectronics网站下载我们微控制器的软件包：
- en: Open your browser and go to [https://www.st.com/content/st_com/en.html](https://www.st.com/content/st_com/en.html).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的浏览器并访问[https://www.st.com/content/st_com/en.html](https://www.st.com/content/st_com/en.html)。
- en: Search for `STM32CubeF4` to locate the package for the STM32F4 microcontroller
    series.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索`STM32CubeF4`以定位STM32F4微控制器系列的软件包。
- en: 'Next, download the STM32CubeF4 package:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，下载STM32CubeF4软件包：
- en: Locate the STM32CubeF4 package and download the latest version. Make sure not
    to download the patch version.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位STM32CubeF4软件包并下载最新版本。请确保不要下载补丁版本。
- en: Once the download is complete, unzip the package. You will find several subfolders
    inside, including the `Drivers` folder.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，解压软件包。你将找到几个子文件夹，包括`Drivers`文件夹。
- en: 'Our next steps involve organizing the files:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的步骤是组织文件：
- en: Inside your project workspace, create a new folder named `chip_headers`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目工作区中，创建一个名为`chip_headers`的新文件夹。
- en: Within the `chip_headers` folder, create another folder named `CMSIS`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chip_headers`文件夹内，创建另一个名为`CMSIS`的文件夹。
- en: Navigate to `Drivers/CMSIS` in the extracted package.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解压的软件包中导航到`Drivers/CMSIS`。
- en: Copy the entire `Include` folder from `Drivers/CMSIS` into `chip_headers/CMSIS`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Drivers/CMSIS`中的整个`Include`文件夹复制到`chip_headers/CMSIS`。
- en: Next, copy the `Device` folder from `Drivers/CMSIS` into `chip_headers/CMSIS`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`Drivers/CMSIS`中的`Device`文件夹复制到`chip_headers/CMSIS`。
- en: 'Finally, we clean up the `Device` folder:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们清理`Device`文件夹：
- en: Navigate to `chip_headers/CMSIS/Device/ST/STM32F4xx`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`chip_headers/CMSIS/Device/ST/STM32F4xx`。
- en: Delete all files and folders, *except the Include folder*. This ensures you
    keep only the necessary header files for your specific microcontroller.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有文件和文件夹，*除了Include文件夹*。这确保你只保留特定微控制器的必要头文件。
- en: Moving forward, we will consistently include the `chip_headers` folder in our
    project directories. This practice ensures that anyone running our projects on
    a different computer won’t encounter errors due to missing header files.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 今后，我们将持续在项目目录中包含`chip_headers`文件夹。这种做法确保了在另一台计算机上运行我们的项目的人不会因为缺少头文件而遇到错误。
- en: In the next section, we’ll create a new project in STM32CubeIDE. After setting
    up the project, we’ll copy the `chip_headers` folder and paste it into the project
    directory. Subsequently, we’ll add the subfolders within `chip_headers` to our
    project’s `include` paths, ensuring seamless integration of the necessary CMSIS
    files.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将在STM32CubeIDE中创建一个新的项目。设置项目后，我们将复制`chip_headers`文件夹并将其粘贴到项目目录中。随后，我们将添加`chip_headers`内的子文件夹到项目的`include`路径中，确保必要CMSIS文件的顺利集成。
- en: Working with CMSIS files
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与CMSIS文件一起工作
- en: In this section, we will integrate the CMSIS files into our project by adding
    the relevant folders to our project’s `include` paths. We will then test our setup
    by updating our `main.c` file to use these CMSIS files instead of our manually
    defined peripheral structures.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过将相关文件夹添加到项目的`include`路径中来将CMSIS文件集成到我们的项目中。然后，我们将通过更新我们的`main.c`文件以使用这些CMSIS文件而不是我们手动定义的外设结构来测试我们的设置。
- en: Let’s begin by creating a new project following the steps outlined in [*Chapter
    1*](B21914_01.xhtml#_idTextAnchor015). I will name my project `header_files`.
    Once the project is created, I’ll copy and paste the `chip_headers` folder into
    the project folder.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照[*第一章*](B21914_01.xhtml#_idTextAnchor015)中概述的步骤创建一个新的项目。我将把我的项目命名为`header_files`。一旦项目创建完成，我将复制并粘贴`chip_headers`文件夹到项目文件夹中。
- en: 'Our next task involves adding the paths of the subfolders within the `chip_headers`
    folder to our project’s `include` paths:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是将`chip_headers`文件夹内子文件夹的路径添加到项目的`include`路径中：
- en: Open STM32CubeIDE, right-click on your project, and select **Properties**.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开STM32CubeIDE，右键单击您的项目，并选择**属性**。
- en: Once the **Properties** window opens, expand the **C/C++** **General** options.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦**属性**窗口打开，展开**C/C++** **通用**选项。
- en: Select **Paths** **and Symbols**.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**路径**和**符号**。
- en: Under the **Includes** tab, click **Add** to add a new directory.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**包含**选项卡下，点击**添加**以添加新的目录。
- en: Enter `${ProjDirPath}\chip_headers\CMSIS\Include` to add the `Include` folder
    located in our `CMSIS` folder, and then click **OK** to save.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`${ProjDirPath}\chip_headers\CMSIS\Include`以添加位于我们`CMSIS`文件夹中的`Include`文件夹，然后点击**确定**保存。
- en: Click **Add** again to add another directory.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**添加**以添加另一个目录。
- en: Enter `${ProjDirPath}\chip_headers\CMSIS\Device\ST\STM32F4xx\Include` to add
    the `Include` folder located in the `STM32F4xx` subdirectory and click **OK**
    to save.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`${ProjDirPath}\chip_headers\CMSIS\Device\ST\STM32F4xx\Include`以添加位于`STM32F4xx`子目录中的`Include`文件夹，然后点击**确定**保存。
- en: '*Figure 6**.2* illustrates the Project Properties window after adding these
    directories to the project’s `include` paths.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6**.2*展示了在将这两个目录添加到项目的`include`路径后，项目属性窗口的示意图。'
- en: '![Figure 6.2: The Includes tab in the project properties window](img/B21914_06_2.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：项目属性窗口中的包含选项卡](img/B21914_06_2.jpg)'
- en: 'Figure 6.2: The Includes tab in the project properties window'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：项目属性窗口中的包含选项卡
- en: 'Let’s break down the two lines we have just added:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析我们刚刚添加的两行：
- en: '`${``ProjDirPath}\chip_headers\CMSIS\Include`:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ProjDirPath}\chip_headers\CMSIS\Include`：'
- en: '`${ProjDirPath}`: This is a macro in STM32CubeIDE that represents the root
    directory of your current project. It’s a placeholder that dynamically points
    to the directory where your project is located.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ProjDirPath}`：这是STM32CubeIDE中的一个宏，代表您当前项目的根目录。它是一个占位符，动态指向您的项目所在目录。'
- en: '`\chip_headers\CMSIS\Include`: This specifies the path relative to the project’s
    root directory. It points to the `Include` folder within the `CMSIS` directory
    inside the `chip_headers` folder. This folder contains general CMSIS include files,
    which provide core functionalities and definitions for the Cortex-M processor.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\chip_headers\CMSIS\Include`：这指定了相对于项目根目录的路径。它指向`chip_headers`文件夹内`CMSIS`目录中的`Include`文件夹。此文件夹包含通用的CMSIS包含文件，为Cortex-M处理器提供核心功能和定义。'
- en: '`${``ProjDirPath}\chip_headers\CMSIS\Device\ST\STM32F4xx\Include`:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ProjDirPath}\chip_headers\CMSIS\Device\ST\STM32F4xx\Include`：'
- en: '`${ProjDirPath}`: As mentioned earlier, this macro represents the root directory
    of your current project.'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`${ProjDirPath}`：如前所述，此宏代表您当前项目的根目录。'
- en: '`\chip_headers\CMSIS\Device\ST\STM32F4xx\Include`: This specifies another path
    relative to the project’s root directory. It points to the `Include` folder within
    the `STM32F4xx` subdirectory inside the `Device` directory, which is located in
    the `CMSIS` directory in the `chip_headers` folder. This folder contains device-specific
    include files for the STM32F4xx series microcontrollers, providing definitions
    and configurations specific to this family of microcontrollers.'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\chip_headers\CMSIS\Device\ST\STM32F4xx\Include`：这指定了相对于项目根目录的另一个路径。它指向位于`CMSIS`文件夹中的`chip_headers`文件夹内的`Device`目录下的`STM32F4xx`子目录中的`Include`文件夹。这个文件夹包含STM32F4xx系列微控制器的设备特定包含文件，提供针对这个微控制器系列的特定定义和配置。'
- en: Before closing the project properties dialog box, we need to specify the exact
    version of the STM32F4 microcontroller we are using. This ensures that the appropriate
    header file for our specific microcontroller is enabled in our project. As we
    can see, the `STM32F4xx\Include` subfolder contains header files for various microcontrollers
    within the STM32F4 family. The NUCLEO-F411 development board has the STM32F411
    microcontroller.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭项目属性对话框之前，我们需要指定我们正在使用的STM32F4微控制器的确切版本。这确保了在我们的项目中启用了针对我们特定微控制器的适当头文件。正如我们所见，`STM32F4xx\Include`子文件夹包含STM32F4系列中各种微控制器的头文件。NUCLEO-F411开发板配备了STM32F411微控制器。
- en: 'To configure our project for the STM32F411 microcontroller:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要为STM32F411微控制器配置我们的项目：
- en: Click on the **#** **Symbols** tab.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**#** **符号**选项卡。
- en: Click **Add…** to add a new symbol.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加…**以添加一个新的符号。
- en: In the `STM32F411xE` in the **Name** field and then click **OK**.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**名称**字段中输入`STM32F411xE`，然后点击**确定**。
- en: Click **Apply and Close** to save all changes and close the Project Properties
    window.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用并关闭**以保存所有更改并关闭项目属性窗口。
- en: '*Figure 6**.3* illustrates the `STM32F411xE` symbol.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6**.3*展示了`STM32F411xE`符号。'
- en: '![Figure 6.3: The Symbols tab in the project properties window](img/B21914_06_3.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：项目属性窗口中的符号选项卡](img/B21914_06_3.jpg)'
- en: 'Figure 6.3: The Symbols tab in the project properties window'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：项目属性窗口中的符号选项卡
- en: 'To test our setup, let’s follow these steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的设置，请按照以下步骤操作：
- en: Copy the entire content of the `main.c` file from our previous project that
    used the structure-based access approach.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从我们之前使用基于结构访问方法的项目中复制`main.c`文件的整个内容。
- en: Open the `main.c` file in the current project.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开当前项目中`main.c`文件。
- en: Delete all the existing content in the `main.c` file.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`main.c`文件中的所有现有内容。
- en: Paste the copied content into the `main.c` file.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将复制的内
- en: In the `main.c` file, delete all the code related to manually defined addresses
    and structures, as we will now use the register definitions provided in our header
    files.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.c`文件中，删除所有与手动定义的地址和结构相关的代码，因为我们现在将使用在头文件中提供的寄存器定义。
- en: Include the `stm32f4xx.h` header file in your project to access these definitions.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目中包含`stm32f4xx.h`头文件以访问这些定义。
- en: Build the project in the IDE and run it on the development board.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IDE中构建项目并在开发板上运行它。
- en: 'The following snippet shows the updated `main.c` file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了更新的`main.c`文件：
- en: '[PRE4]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You’ll observe that this project builds without any errors and works in the
    same way as our previous one. This implementation accesses the microcontroller
    registers defined in `chip_headers/CMSIS/Device/ST/STM32F4xx/Include/stm32f411xe.h`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你会观察到这个项目在构建时没有任何错误，并且与我们的上一个项目以相同的方式工作。这个实现访问了在`chip_headers/CMSIS/Device/ST/STM32F4xx/Include/stm32f411xe.h`中定义的微控制器寄存器。
- en: Upon inspecting this file, you will find that it contains a `typedef` structure
    for each peripheral of our microcontroller, similar to the one we manually created
    a few sections ago. This means that moving forward, we don’t need to manually
    extract the base addresses and register offsets from the documentation. Instead,
    we can simply include the `stm32f4xx.h` header file in our project. This header
    file will in turn include the `stm32f411xe.h` file because we specified in the
    **Symbols** tab of the project properties window that we are using the *STM32F411xE*
    microcontroller.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 检查此文件后，你会发现它包含一个针对我们微控制器每个外设的`typedef`结构，类似于我们之前手动创建的那个。这意味着从现在开始，我们不需要从文档中手动提取基址和寄存器偏移量。相反，我们只需在我们的项目中包含`stm32f4xx.h`头文件。这个头文件反过来会包含`stm32f411xe.h`文件，因为我们已经在项目属性窗口的**符号**选项卡中指定了我们正在使用*STM32F411xE*微控制器。
- en: Setting up the required header files significantly simplifies configuring and
    using peripherals on our STM32 microcontroller. This approach allows us to leverage
    pre-defined register addresses and bit definitions, making our code more readable
    and maintainable while also reducing development time.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 设置所需的头文件显著简化了在STM32微控制器上配置和使用外设的过程。这种方法使我们能够利用预定义的寄存器地址和位定义，使我们的代码更易于阅读和维护，同时也能减少开发时间。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored CMSIS, a critical framework for Cortex-M and some
    Cortex-A processors. This chapter gave us the foundational knowledge to enhance
    code portability and efficiency in our Arm Cortex-M projects.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了CMSIS，这是Cortex-M和某些Cortex-A处理器的关键框架。本章为我们提供了增强Arm Cortex-M项目代码可移植性和效率的基础知识。
- en: We began by learning how to define hardware registers using C structures, a
    fundamental technique for improving code readability and maintainability. This
    knowledge allowed us to understand how the CMSIS-compliant header files provided
    by microcontroller manufacturers give us access to the register definitions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先学习了如何使用C结构定义硬件寄存器，这是一种提高代码可读性和可维护性的基本技术。这种知识使我们能够理解微控制器制造商提供的CMSIS兼容头文件是如何让我们访问寄存器定义的。
- en: Next, we explored CMSIS itself, discussing its components and how it facilitates
    efficient software development. We examined the key benefits of CMSIS, such as
    standardization, portability, and efficiency, and introduced its main components,
    including CMSIS-Core, CMSIS-Driver, CMSIS-DSP, CMSIS-NN, CMSIS-RTOS, CMSIS-Pack,
    and CMSIS-SVD.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们探讨了CMSIS本身，讨论了其组件以及它是如何促进高效软件开发的。我们考察了CMSIS的关键优势，如标准化、可移植性和效率，并介绍了其主要组件，包括CMSIS-Core、CMSIS-Driver、CMSIS-DSP、CMSIS-NN、CMSIS-RTOS、CMSIS-Pack和CMSIS-SVD。
- en: We then moved on to setting up the necessary CMSIS files from our silicon manufacturer.
    This process involved downloading the relevant packages, organizing the files,
    and integrating them into our project.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向设置来自我们的硅制造商的必要CMSIS文件。这个过程涉及下载相关包、组织文件并将它们集成到我们的项目中。
- en: Finally, we tested our setup by updating our previous project to use CMSIS files
    instead of our manually defined peripheral structures. This practical application
    showcased how CMSIS simplifies accessing microcontroller registers, making the
    code more readable, maintainable, and efficient.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将我们的先前项目更新为使用CMSIS文件而不是我们手动定义的外设结构来测试我们的设置。这个实际应用展示了CMSIS如何简化访问微控制器寄存器，使代码更易于阅读、维护和高效。
- en: In the next chapter, we will learn about the GPIO peripheral. This chapter will
    provide a comprehensive understanding of how to configure and use GPIO for input/output
    applications in embedded systems.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习GPIO外设。本章将全面介绍如何在嵌入式系统中配置和使用GPIO进行输入/输出应用。
