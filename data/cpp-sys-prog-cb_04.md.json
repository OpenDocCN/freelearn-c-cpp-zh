["```cpp\nclass User\n{\npublic:\n    User(){\n        std::cout << \"User constructor\" << std::endl;\n    };\n    ~User(){\n        std::cout << \"User Destructor\" << std::endl;\n    };\n\n    void cheers() \n    {\n        std::cout << \" hello!\" << std::endl;};\n    };\n};\n```", "```cpp\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Start ... \" << std::endl;\n    {\n        User developer;\n        developer.cheers();\n    }\n    std::cout << \"End ... \" << std::endl;\n}\n```", "```cpp\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Start ... \" << std::endl;\n    {\n        User* developer = new User();\n        developer->cheers();\n        delete developer;\n    }\n    std::cout << \"End ... \" << std::endl;\n}\n```", "```cpp\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Start ... \" << std::endl;\n    {\n        auto developer = std::make_unique<User>();\n        developer->cheers();\n    }\n    std::cout << \"End ... \" << std::endl;\n}\n```", "```cpp\nauto developer = std::make_unique<User>();\ndeveloper->cheers();\n\nUser* developer2 = new User();\nstd::cout << \"developer size = \" << sizeof (developer) << std::endl;\nstd::cout << \"developer2 size = \" << sizeof (developer2) << std::endl;\ndelete developer2;\n```", "```cpp\nint main()\n{\n    std::cout << \"Start ... \" << std::endl;\n    auto shared1 = std::make_shared<User>();\n    {\n        auto shared2 = shared1;\n        shared2->cheers(); std::cout << \" from shared2\"\n            << std::endl;\n        shared1->cheers(); std::cout << \" from shared1\"\n            << std::endl;\n    }\n    std::cout << \"End ... \" << std::endl;\n}\n```", "```cpp\nint main()\n{\n    std::cout << \"Start ... \" << std::endl;\n    auto shared1 = std::make_shared<User>();\n   {\n        auto shared2 = shared1;\n        User* newAllocation = new User();\n        auto uniqueAllocation = std::make_unique<User>();\n\n        std::cout << \"shared2 size = \" << sizeof (shared2)\n            << std::endl;\n        std::cout << \"newAllocation size = \" <<\n            sizeof (newAllocation) << std::endl;\n        std::cout << \"uniqueAllocation size = \" <<\n            sizeof (uniqueAllocation) << std::endl;\n\n        delete newAllocation;\n    }\n    std::cout << \"End ... \" << std::endl;\n}\n```", "```cpp\n#include <type_traits>\n#include <iostream>\nint main()\n{\n    std::cout << \"int alignment = \" << std::alignment_of<int>\n        ::value << std::endl;\n    std::cout << \"double alignment = \" << \n        std::alignment_of<double>::value << std::endl;\n    return (0);\n}\n```", "```cpp\n#include <type_traits>\n#include <iostream>\ntypedef std::aligned_storage<sizeof(int), 8>::type intAligned;\nint main()\n{\n    intAligned i, j;\n    new (&i) int();\n    new (&j) int();\n\n    int* iu = &reinterpret_cast<int&>(i);\n    *iu = 12;\n    int* ju = &reinterpret_cast<int&>(j);\n    *ju = 13;\n\n    std::cout << \"alignment = \" << std::alignment\n        _of<intAligned>::value << std::endl;\n    std::cout << \"value = \" << *iu << std::endl;\n    std::cout << \"value2 = \" << reinterpret_cast<int&>(i)\n        << std::endl;\n    return (0);\n}\n```", "```cpp\n#include <type_traits>\n#include <iostream>\n\nusing intAligned8 = std::aligned_storage<sizeof(int), 8>::type;\nusing intAligned4 = std::aligned_storage<sizeof(int), 4>::type;\n\nint main()\n{\n    intAligned8 i; new(&i) int();\n    intAligned4 j; new (&j) int();\n\n    int* iu = &reinterpret_cast<int&>(i);\n    *iu = 12;\n    int* ju = &reinterpret_cast<int&>(j);\n    *ju = 13;\n\n    if (reinterpret_cast<unsigned long>(iu) % 8 == 0)\n        std::cout << \"memory pointed by the <iu> variable \n        aligned to 8 byte\" << std::endl;\n    else\n        std::cout << \"memory pointed by the <iu> variable NOT \n        aligned to 8 bytes\" << std::endl;\n    if (reinterpret_cast<unsigned long>(ju) % 8 == 0)\n        std::cout << \"memory pointed by the <ju> variable aligned to \n        8 bytes\" << std::endl;\n    else\n        std::cout << \"memory pointed by the <ju> variable NOT \n        aligned to 8 bytes\" << std::endl;\n\n    return (0);\n}\n```", "```cpp\nvoid myFunc (int* p)\n{\n    int* pAligned = std::assume_aligned<64>(p);\n    // using pAligned from now on.\n}\n\n```", "```cpp\n int fd = open(FILEPATH, O_RDWR | O_CREAT | O_TRUNC, (mode_t)0600);\n if (fd == -1)\n {\n    std::cout << \"Error opening file \" << FILEPATH << std::endl;\n    return 1;\n }\n```", "```cpp\nint result = lseek(fd, FILESIZE-1, SEEK_SET);\nif (result == -1)\n{\n    close(fd);\n    std::cout << \"Error calling lseek \" << std::endl;\n    return 2;\n}\n\nresult = write(fd, \"\", 1);\nif (result != 1)\n{\n    close(fd);\n    std::cout << \"Error writing into the file \" << std::endl;\n    return 3;\n}\n```", "```cpp\n int* map = (int*) mmap(0, FILESIZE, PROT_READ | PROT_WRITE, \n     MAP_SHARED, fd, 0);\n if (map == MAP_FAILED)\n {\n     close(fd);\n     std::cout << \"Error mapping the file \" << std::endl;\n     return 4;\n }\n```", "```cpp\nfor (int i = 1; i <=NUM_OF_ITEMS_IN_FILE; ++i)\n    map[i] = 2 * i;\n```", "```cpp\nif (munmap(map, FILESIZE) == -1)\n    std::cout << \"Error un-mapping\" << std::endl;\n\nclose(fd);\n```", "```cpp\nint* map = (int*) mmap(0, FILESIZE, PROT_READ, MAP_SHARED, fd, 0);\nif (map == MAP_FAILED)\n{\n    close(fd);\n    std::cout << \"Error mapping the file \" << std::endl;\n    return 4;\n}\n\nfor (int i = 1; i <= NUM_OF_ITEMS_IN_FILE; ++i)\n    std::cout << \"i = \" << map[i] << std::endl;\n```", "```cpp\n#include <sys/mman.h>\n#include <iostream>\n#include <cstring>\n\nconstexpr auto SIZE = 1024;\n\nint main(int argc, char *argv[])\n{\n    auto* mapPtr = (char*) mmap(0, SIZE, \n                                PROT_READ | PROT_WRITE, \n                                MAP_PRIVATE | MAP_ANONYMOUS, \n                                -1, 0);\n if (mapPtr == MAP_FAILED)\n {\n     std::cout << \"Error mapping memory \" << std::endl;\n     return 1;\n }\n std::cout << \"memory allocated available from: \" << mapPtr\n   << std::endl;\n\n strcpy (mapPtr, \"this is a string!\");\n std::cout << \"mapPtr val = \" << mapPtr << std::endl;\n\n if (munmap(mapPtr, SIZE) == -1)\n     std::cout << \"Error un-mapping\" << std::endl;\n\n return 0;\n}\n```", "```cpp\ntemplate<typename T>\nclass mmap_allocator\n{\npublic:\n    using value_type = T;\n\n    template<typename U> struct rebind {\n        using alloc = mmap_allocator<U>;\n    };\n\n    mmap_allocator(){};\n    template <typename U>\n    mmap_allocator(const mmap_allocator<U> &alloc) noexcept {};\n\n    T* allocate(std::size_t n){};\n\n    void deallocate(T* p, std::size_t n) {}\n};\n```", "```cpp\n    mmap_allocator(const mmap_allocator<U> &alloc) noexcept {\n      (void) alloc;};\n```", "```cpp\n    std::cout << \"allocating ... n = \" << n << std::endl;\n    auto* mapPtr = static_cast<T*> (mmap(0, sizeof(T) * n, \n                                    PROT_READ | PROT_WRITE, \n                                    MAP_PRIVATE | MAP_ANONYMOUS, \n                                    -1, 0));\n    if (mapPtr != MAP_FAILED)\n        return static_cast<T*>(mapPtr);\n    throw std::bad_alloc();\n```", "```cpp\n    std::cout << \"deallocating ... n = \" << n << std::endl;\n    (void) n;\n    munmap(p, sizeof(T) * n);\n```", "```cpp\nint main ()\n{\n    std::vector<int, mmap_allocator<int>> mmap_vector = {1, 2,\n        3, 4, 5};\n\n    for (auto i : mmap_vector)\n        std::cout << i << std::endl;\n\n    return 0;\n}\n```"]