- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: How to Call C++ from Lua
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何从 Lua 调用 C++
- en: In the previous three chapters, we focused on learning how to call Lua from
    C++. In this chapter, we will start to learn how to call C++ from Lua. This is
    important for your applications because although Lua scripts can extend your C++
    applications, they can also benefit from the functions provided by your native
    C++ code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三个章节中，我们专注于学习如何从 C++ 调用 Lua。在本章中，我们将开始学习如何从 Lua 调用 C++。这对于你的应用程序来说很重要，因为虽然
    Lua 脚本可以扩展你的 C++ 应用程序，但它们也可以从你提供的原生 C++ 代码中的函数中受益。
- en: This also means we will learn more concepts and piece different things together
    to make it work. Although the chapters are laid out in a way that they extend
    the previous chapter in a seamless flow, you may need a different pace to absorb
    the new concepts. Do read the sections more times if you need practice with coding.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们将学习更多概念，并将不同的事物拼接在一起以使其工作。尽管章节以无缝流动的方式展开，使它们延续前一章，但你可能需要不同的节奏来吸收新概念。如果你需要练习编码，请多次阅读这些部分。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: How to register C++ functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何注册 C++ 函数
- en: How to override Lua library functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何覆盖 Lua 库函数
- en: How to register C++ modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何注册 C++ 模块
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the technical requirements for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章的技术要求：
- en: You can access the source code for this chapter at [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter06](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter06)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter06](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter06)
    找到本章的源代码。
- en: Based on the learnings from the last chapter, you should now be confident in
    adding code to our Lua executor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于上一章的学习，你现在应该对我们的 Lua 执行器添加代码感到自信
- en: 'This chapter will introduce many new concepts and Lua library APIs. You can
    cross-check the Lua reference manual online to reinforce the learning: [https://www.lua.org/manual/5.4/](https://www.lua.org/manual/5.4/).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍许多新概念和 Lua 库 API。你可以通过在线查阅 Lua 参考手册来加强学习：[https://www.lua.org/manual/5.4/](https://www.lua.org/manual/5.4/)。
- en: How to register C++ functions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何注册 C++ 函数
- en: Lua is written in C, so it cannot access your C++ classes directly. The only
    way to call C++ code from Lua is to make it call C++ functions – that is, plain
    C functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 是用 C 编写的，因此它不能直接访问你的 C++ 类。从 Lua 调用 C++ 代码的唯一方法是通过使其调用 C++ 函数——即纯 C 函数。
- en: How to declare C++ functions for Lua
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何为 Lua 声明 C++ 函数
- en: 'To register a function to Lua, it must conform to the following prototype:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要将函数注册到 Lua 中，它必须符合以下原型：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The function receives only one argument, which is a Lua state. It needs to return
    an integer value indicating how many return values it produces. The Lua state
    is private to the function call, and its stack holds the arguments passed from
    the Lua code when calling the C++ function. The C++ function needs to push its
    return values onto the stack.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 函数只接收一个参数，即 Lua 状态。它需要返回一个整数值，表示它产生多少返回值。Lua 状态是函数调用的私有，其栈包含从 Lua 代码调用 C++ 函数时传递的参数。C++
    函数需要将其返回值推送到栈上。
- en: We will first implement a simple function and export it to Lua. Then, we’ll
    see more complex examples to understand more.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现一个简单的函数并将其导出到 Lua。然后，我们将看到更复杂的示例以了解更多。
- en: Implementing your first C++ function for Lua
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现你的第一个 Lua C++ 函数
- en: 'Let us add a simple but useful capability to our Lua executor. It will provide
    a function to check its version code so that the Lua code it executes can query
    it. In `LuaExecutor.cc`, right below the `#include` directives, add the following
    function implementation that conforms to `lua_CFunction`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给我们的 Lua 执行器添加一个简单但有用的功能。它将提供一个函数来检查其版本代码，以便 Lua 代码可以查询它。在 `LuaExecutor.cc`
    中，在 `#include` 指令下方，添加以下符合 `lua_CFunction` 的函数实现：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The function pushes a `LuaExecutor::versionCode` integer constant to its private
    stack and returns `1` to indicate that it returns one value. We can define this
    constant in `LuaExecutor.h` as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将 `LuaExecutor::versionCode` 整数常量推送到其私有栈中，并返回 `1` 以指示它返回一个值。我们可以在 `LuaExecutor.h`
    中如下定义此常量：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will use the value `6` for *Chapter 6*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用值 `6` 表示 *第 6 章*。
- en: You may have noticed that the function is inside an anonymous namespace. This
    is to make sure that it cannot be accessed outside the file of `LuaExecutor.cc`.
    This also helps with logical code grouping.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到函数位于匿名命名空间内。这是为了确保它不能被访问 `LuaExecutor.cc` 文件之外。这也帮助于逻辑代码分组。
- en: Next, let us make this function available to Lua.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们让这个函数对 Lua 可用。
- en: How to register C++ functions to Lua
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何将 C++ 函数注册到 Lua
- en: 'There are a few ways to register C++ functions to Lua. We will look at the
    simplest way here to register a C++ function in the Lua global table. Later in
    this chapter when learning C++ modules, we will learn a more proper way to register
    C++ functions in their own table. You already know how to do this from *Chapter
    3*. I only need to point it out with the following code, which you should add
    to the same anonymous namespace you have just written:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以将 C++ 函数注册到 Lua 中。在这里，我们将查看注册 C++ 函数到 Lua 全局表中的最简单方法。在本章后面学习 C++ 模块时，我们将学习一种更合适的方法来注册
    C++ 函数到它们自己的表中。您已经从 *第 3 章* 中知道了如何做这件事。我只需要用以下代码指出，您应该将其添加到您刚刚编写的相同匿名命名空间中：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Yes—we simply need to set it as a Lua global variable! We use `lua_pushcfunction`
    to push the `lua_CFunction` type onto the stack. Then, we assign it to a global
    variable named `host_version`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 是的——我们只需要将其设置为 Lua 全局变量！我们使用 `lua_pushcfunction` 将 `lua_CFunction` 类型推送到栈上。然后，我们将其分配给名为
    `host_version` 的全局变量。
- en: Using a global variable for the host executor version sounds very reasonable.
    But you should not abuse Lua global variables by using them too much. Now, let
    us try it out.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用全局变量来表示宿主执行器版本听起来非常合理。但您不应该过度使用 Lua 全局变量。现在，让我们试试看。
- en: Testing it out
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试它
- en: We need to modify three places to test our progress so far. You can start your
    work with the `begin` folder from the source code of this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改三个地方来测试我们到目前为止的进度。您可以从本章源代码的 `begin` 文件夹开始工作。
- en: 'Call `registerHostFunctions` from the constructor of our Lua executor, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的 Lua 执行器的构造函数中调用 `registerHostFunctions`，如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This registers our function to Lua.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们的函数注册到 Lua。
- en: 'Replace the content of `script.lua` as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `script.lua` 的内容替换如下：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This calls our C++ function from Lua and prints out the result.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从 Lua 调用我们的 C++ 函数并打印出结果。
- en: 'Replace the content of `main.cpp` with the following test code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `main.cpp` 的内容替换为以下测试代码：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This resets the test code to simply create a Lua executor and runs `scripts.lua`.
    Run the project, and if you have done everything correctly, you should see the
    following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将测试代码重置为仅创建 Lua 执行器并运行 `scripts.lua`。运行项目，如果您一切操作正确，您应该看到以下输出：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Congratulations! You have called your first C++ function from Lua code. Based
    on this learning, let us find out how to override Lua library functions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经从 Lua 代码中调用了第一个 C++ 函数。基于这次学习，让我们来看看如何覆盖 Lua 库函数。
- en: How to override Lua library functions
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何覆盖 Lua 库函数
- en: Why would you want to override Lua library functions? First, it helps to learn
    more about calling C++ functions from Lua in a progressive way, before moving
    on to C++ modules. Second, but more importantly, it is a frequent requirement
    for real-life projects.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么您想要覆盖 Lua 库函数？首先，这有助于以渐进的方式学习在 Lua 中调用 C++ 函数，然后再学习 C++ 模块。其次，但更重要的是，这是实际项目中的常见需求。
- en: Suppose you are working on a game where assets are packed inside a private archive
    and your Lua scripts need to access them. Overriding the Lua `io` and `file` libraries
    can provide a seamless experience for your fellow Lua developers and enforce security
    at the same time. You can make sure Lua scripts can only access assets you want
    them to, but nothing else on the host filesystem. This is even more important
    when your users can change the Lua scripts.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在制作一个游戏，其中资源打包在一个私有存档中，而您的 Lua 脚本需要访问它们。覆盖 Lua 的 `io` 和 `file` 库可以为您的 Lua
    开发者提供无缝的体验，并在同时加强安全性。您可以确保 Lua 脚本只能访问您希望它们访问的资源，而不会访问宿主文件系统上的其他内容。当您的用户可以更改 Lua
    脚本时，这一点尤为重要。
- en: Let us implement a more trivial case. We use the Lua `print` function to output
    debug information. We want to merge the Lua debug output with C++ output so that
    we get all our logs in the same place ordered by the time they are printed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个更简单的情况。我们使用 Lua 的 `print` 函数来输出调试信息。我们希望将 Lua 调试输出与 C++ 输出合并，以便我们可以在同一位置按打印时间顺序获取所有日志。
- en: Reimplementing the Lua print function
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新实现 Lua 的 print 函数
- en: 'Because the Lua `print` function takes a variable number of arguments, we need
    to take this into consideration in our implementation. In `LuaExecutor.cc`, below
    the namespace from the previous section, add *another* namespace as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Lua 的 `print` 函数可以接受可变数量的参数，所以我们需要在我们的实现中考虑这一点。在 `LuaExecutor.cc` 中，在上一节中的命名空间下方，添加
    *另一个* 命名空间，如下所示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `luaPrintOverride` C++ function would eventually get called when you invoke
    the `print` function in Lua. It takes `lua_State` as a single argument, whose
    associated Lua stack is used to pass the real arguments from the Lua call site.
    To understand what is happening, see the following diagram:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Lua 中调用 `print` 函数时，`luaPrintOverride` C++ 函数最终会被调用。它接受 `lua_State` 作为单个参数，其关联的
    Lua 堆栈用于传递来自 Lua 调用站点的实际参数。为了理解发生了什么，请参阅以下图表：
- en: '![Figure 6.1 – Overriding the Lua print function](img/B20927_06_01.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 覆盖 Lua 打印函数](img/B20927_06_01.jpg)'
- en: Figure 6.1 – Overriding the Lua print function
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 覆盖 Lua 打印函数
- en: The Lua `print` function will push its arguments onto the private Lua stack
    for the call. The C++ function first checks the number of arguments the Lua call
    site has passed with `lua_gettop`. Then, it prints out `"[Lua]"`to indicate that
    the print comes from Lua instead of C++. Next, it loops through each argument
    and prints them out, separated by a space. Finally, it returns `0` to tell the
    Lua library that it has no value to return to the call site.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 的 `print` 函数将它的参数推入调用私有的 Lua 堆栈。C++ 函数首先使用 `lua_gettop` 检查 Lua 调用站点传递的参数数量。然后，它打印出
    `"[Lua]"` 以指示打印来自 Lua 而不是 C++。接下来，它遍历每个参数并打印它们，用空格分隔。最后，它返回 `0` 以告诉 Lua 库它没有要返回给调用站点的值。
- en: To reinforce
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强
- en: The Lua state and the Lua stack for each `lua_CFunction` call are private to
    the call. So, everything in the stack is made up of the arguments passed from
    the Lua call site. You do not need to remove them from the stack before pushing
    your return values because you are already telling the Lua library how many values
    are pushed onto the stack as the C++ function return value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个 `lua_CFunction` 调用，Lua 状态和 Lua 堆栈都是私有的。因此，堆栈中的所有内容都是由 Lua 调用站点传递的参数组成的。在推送返回值之前，您不需要从堆栈中移除它们，因为您已经告诉
    Lua 库有多少个值被推入堆栈作为 C++ 函数的返回值。
- en: Next, let us see how we can override the Lua `print` function with the C++ version
    we just implemented.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何可以用我们刚刚实现的 C++ 版本覆盖 Lua 的 `print` 函数。
- en: Overriding the Lua print function
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖 Lua 打印函数
- en: 'Here, we will first look at the code and then delve into our explanation of
    it. In the same anonymous namespace, add the following function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的匿名命名空间中，添加以下函数：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The process of overriding library functions includes the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖库函数的过程包括以下步骤：
- en: Getting the library table
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取库表
- en: Reassigning the functions of interest to your new implementations
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将感兴趣的功能重新分配到你的新实现中
- en: 'Each line of the code is doing the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每行代码执行以下操作：
- en: It defines an array of `luaL_Reg`, which is a structure representing a name
    and `lua_CFunction` pair. We set the name as `"print"`, the same as the function
    name we want to override. We set the function as our new implementation. The last
    entry in the array must be `{NULL, NULL}` to mark the end of the definition.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个 `luaL_Reg` 数组，这是一个表示名称和 `lua_CFunction` 对的结构。我们将名称设置为 `"print"`，与我们要覆盖的函数名称相同。我们将函数设置为我们的新实现。数组的最后一个条目必须是
    `{NULL, NULL}` 以标记定义的结束。
- en: It gets the `_G` Lua table onto the stack, because the `print` function is a
    global variable and the `_G` table holds all global variables.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将 `_G` Lua 表推入堆栈，因为 `print` 函数是一个全局变量，而 `_G` 表包含所有全局变量。
- en: It sets our list of functions from *step 1* to the `_G` table with `luaL_setfuncs`.
    You can ignore the last parameter for now; we will learn about it in the next
    section.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用 `luaL_setfuncs` 将我们的函数列表从 *步骤 1* 设置到 `_G` 表中。现在您可以忽略最后一个参数；我们将在下一节中学习它。
- en: It pops the `_G` table from the stack to maintain a balanced stack.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从堆栈中弹出 `_G` 表以保持堆栈平衡。
- en: 'Additionally, `luaL_Reg` is defined in the Lua library as follows:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，`luaL_Reg` 在 Lua 库中定义如下：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Overriding the Lua library functions is really as simple as reassigning some
    table keys to different values! Now, let us see if it works.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖 Lua 库函数实际上就像重新分配一些表键到不同的值一样简单！现在，让我们看看它是否有效。
- en: Testing it out
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试它
- en: 'Similar to the previous section, call `overrideLuaFunctions` from the constructor
    of our Lua executor, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节类似，从我们 Lua 执行器的构造函数中调用 `overrideLuaFunctions`，如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You do not need to change anything else. With the same `main.cpp` and `script.lua`
    files, run the project. If you have followed everything correctly, you should
    see the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要更改其他任何内容。使用相同的 `main.cpp` 和 `script.lua` 文件，运行项目。如果您一切都做得正确，您应该看到以下输出：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There is now a `[Lua]` prefix in the output, proving it is printed from our
    C++ override, not the Lua library function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中现在有一个 `[Lua]` 前缀，证明它是从我们的 C++ 覆盖中打印出来的，而不是 Lua 库函数。
- en: Next, let us learn about C++ modules, which is the preferred way to add your
    C++ functionalities to Lua.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解 C++ 模块，这是将你的 C++ 功能添加到 Lua 的首选方式。
- en: How to register C++ modules
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何注册 C++ 模块
- en: In this section, we will export a C++ class instance to Lua. You probably have
    used or even implemented Lua modules before, the ones that the Lua interpreter
    can find and load automatically and return via Lua’s `require` function. Here,
    the focus is integrating Lua into C++, and in such use cases, things are initiated
    from a C++ executor to benefit from the rest of your C++ application. So, there
    is a difference if you have used standalone Lua modules before.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将导出 C++ 类实例到 Lua。你可能之前使用过或甚至实现过 Lua 模块，这些模块可以被 Lua 解释器自动找到和加载，并通过 Lua
    的 `require` 函数返回。在这里，重点是集成 Lua 到 C++ 中，在这种情况下，从 C++ 执行器开始，以利用你的 C++ 应用程序的其他部分。因此，如果你之前使用过独立的
    Lua 模块，这里会有所不同。
- en: In the previous chapter, we implemented a Lua class called `Destinations` to
    keep track of places we want to go. Let us reimplement it in C++ so that we can
    export it to Lua.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了一个名为 `Destinations` 的 Lua 类来跟踪我们想要去的地点。现在让我们用 C++ 重新实现它，以便我们可以将其导出到
    Lua。
- en: Implementing a C++ class
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 C++ 类
- en: 'Create two source files, `Destinations.h` and `Destinations.cc`. Remember to
    add `Destinations.cc` to the `Makefile`. Write the header file as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个源文件，`Destinations.h` 和 `Destinations.cc`。请记住将 `Destinations.cc` 添加到 `Makefile`
    中。编写头文件如下：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We use a `map` variable to keep a list of places and whether we have visited
    them and have a `name` member variable to identify the instance. The member functions
    are named and work the same as the Lua version, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个 `map` 变量来保存地点列表以及我们是否访问过它们，并且有一个 `name` 成员变量来识别实例。成员函数的命名和 Lua 版本相同，如下所示：
- en: '`wish` adds a list of places to the wish list as `unvisited`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wish` 将地点列表添加到愿望列表中，作为 `未访问`。'
- en: '`went` marks a list of places as `visited`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`went` 将地点列表标记为 `已访问`。'
- en: '`listVisited` returns visited places'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listVisited` 返回已访问的地点'
- en: '`listUnvisited` returns unvisited places'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listUnvisited` 返回未访问的地点'
- en: 'Now, let us implement the member functions in `Destinations.cc`. They are plain
    C++ functions without using any Lua features. So, we will just list the code without
    much explanation. First, let us implement the constructor:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `Destinations.cc` 中实现成员函数。它们是普通的 C++ 函数，不使用任何 Lua 功能。因此，我们将只列出代码，不做过多解释。首先，让我们实现构造函数：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This initializes the `wishlist` as an empty map.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将初始化 `wishlist` 为一个空映射。
- en: 'Then, write the `wish` function as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式编写 `wish` 函数：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, implement the `went` function as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式实现 `went` 函数：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `wish` function and the `went` function are quite similar and mark places
    as visited or unvisited.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`wish` 函数和 `went` 函数非常相似，用于标记地点为已访问或未访问。'
- en: 'Finally, implement the query functions. Write the `listVisited` function as
    follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实现查询函数。按照以下方式编写 `listVisited` 函数：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, write the `listUnvisited` function as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式编写 `listUnvisited` 函数：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With a C++ class ready, our next task is to export it to Lua.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备好 C++ 类之后，我们的下一个任务是将其导出到 Lua。
- en: What to export to Lua
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 要导出到 Lua 的内容
- en: Exporting a C++ class to Lua is really exporting its instances to Lua. Sometimes,
    only one instance is exported and the C++ class works as a utility library, similar
    to the Lua `string` library. Sometimes, many instances are exported and Lua extends
    C++’s **object-oriented** **programming** (**OOP**).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将 C++ 类导出到 Lua 实际上是将其实例导出到 Lua。有时，只导出一个实例，C++ 类作为工具库工作，类似于 Lua 的 `string` 库。有时，导出多个实例，Lua
    扩展了 C++ 的 **面向对象** **编程**（**OOP**）。
- en: 'It is important to note that no matter how many instances you want to export,
    the process is the same. When overriding Lua library functions, we retrieve an
    existing table and set some of its functions to our implementation. To export
    a C++ class instance, similarly, we need to do the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，无论你想要导出多少个实例，过程都是相同的。当覆盖 Lua 库函数时，我们检索一个现有的表，并将其中的一些函数设置为我们的实现。要导出 C++
    类实例，类似地，我们需要做以下操作：
- en: Create a new table
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的表
- en: Add the functions we want to export to the table
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们想要导出的函数添加到表中
- en: 'If you recall that we can only export functions of the `lua_CFunction` prototype
    to Lua, you will clearly see that we cannot export our public member functions
    to Lua directly. We need some wrapper functions. Let us first write some stubs.
    Below the `#include` directives in `Destinations.cc`, add the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得我们只能导出 `lua_CFunction` 原型的函数到 Lua，你将清楚地看到我们无法直接导出我们的公共成员函数到 Lua。我们需要一些包装函数。让我们首先编写一些存根。在
    `Destinations.cc` 中的 `#include` 指令下方，添加以下代码：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We defined four wrapper functions of the `lua_CFunction` prototype and a list
    of `luaL_Reg` instances. We are using `vector` instead of `array` because in C++
    we prefer vectors unless we have to use an array.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了四个 `lua_CFunction` 原型的包装函数和一个 `luaL_Reg` 实例的列表。我们使用 `vector` 而不是 `array`，因为在
    C++ 中我们更喜欢 `vector`，除非我们不得不使用数组。
- en: Next, let us design a reusable mechanism to export our wrappers to Lua.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们设计一个可重用的机制来导出我们的包装器到 Lua。
- en: Designing a reusable exporting mechanism
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计一个可重用的导出机制
- en: 'There are many ways to do this. We choose a way to work with our Lua executor
    and let it register our C++ modules. First, let us define an abstract class to
    represent C++ modules. Create a new file named `LuaModule.h` and write its content
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种方法可以做到这一点。我们选择一种与我们的 Lua 执行器一起工作并让它注册我们的 C++ 模块的方法。首先，让我们定义一个抽象类来表示 C++
    模块。创建一个名为 `LuaModule.h` 的新文件，并按照以下内容编写其内容：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `LuaModule` abstract class defines two abstract methods to provide data
    needed to register a C++ module to Lua. `luaName` returns a name for the module
    instance; we will use it as the Lua table name. `luaRegs` returns a list of functions
    to be exported along with their names in Lua.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`LuaModule` 抽象类定义了两个抽象方法，以提供将 C++ 模块注册到 Lua 所需的数据。`luaName` 返回模块实例的名称；我们将用它作为
    Lua 表的名称。`luaRegs` 返回要随其 Lua 名称一起导出的函数列表。'
- en: 'Let us extend our `Destinations` C++ class to conform to this protocol. Change
    its declaration as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的 `Destinations` C++ 类以符合此协议。更改其声明如下：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After this, add the following implementation to `Destinations.cc`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下实现添加到 `Destinations.cc`：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The code simply returns the instance name as `luaName` and the `REGS` we just
    defined for our stubs as `luaRegs`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 代码简单地返回实例名称作为 `luaName` 以及我们为存根定义的 `REGS` 作为 `luaRegs`。
- en: 'Now comes the time to finally register our C++ class to Lua. In `LuaExecutor.h`,
    add a function declaration as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候最终将我们的 C++ 类注册到 Lua 中了。在 `LuaExecutor.h` 中，添加如下函数声明：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `registerModule` function registers an instance of `LuaModule` to the Lua
    state that the executor holds.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`registerModule` 函数将 `LuaModule` 的一个实例注册到执行器持有的 Lua 状态。'
- en: 'Next, implement it in `LuaExecutor.cc`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `LuaExecutor.cc` 中实现它：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This needs some explanation. Let us explore what each line of the code here
    is doing in sequence:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一些解释。让我们按顺序探索这里每一行代码所做的事情：
- en: It creates a table with `lua_createtable`. This library function will push the
    table onto the stack. The second parameter hints at how many elements in the table
    will be used as a sequence. We have none, so we pass `0`. The third parameter
    hints at how many elements in the table will be used as a map. All our functions
    are used this way, so we pass the count of our vector minus the ending marker.
    The hints help with memory allocation in Lua, as Lua will be responsible for creating
    a properly sized table to avoid unnecessary reallocations to increase the capacity
    of the table later.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 `lua_createtable` 创建一个表。这个库函数将表推入堆栈。第二个参数暗示表中将使用多少元素作为序列。我们没有，所以我们传递 `0`。第三个参数暗示表中将使用多少元素作为映射。我们所有的函数都是这样使用的，所以我们传递我们的向量计数减去结束标记。这些提示有助于
    Lua 中的内存分配，因为 Lua 将负责创建一个适当大小的表，以避免在以后增加表容量的不必要重新分配。
- en: It sets our functions to the table with `luaL_setfuncs`. This works exactly
    the same as when we overrode Lua library functions. Ignore the third parameter
    for now as well. `module.luaRegs().data()` returns our function list as an array
    instead of a vector. `std::vector::data` is a C++ feature.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 `luaL_setfuncs` 将我们的函数设置到表中。这与当我们覆盖 Lua 库函数时的工作方式完全相同。现在也忽略第三个参数。`module.luaRegs().data()`
    返回我们的函数列表作为数组而不是向量。`std::vector::data` 是 C++ 的一个特性。
- en: It assigns the table just created to a global variable using the name returned
    from `module.luaName()`. From now on, our C++ module can be accessed from this
    table.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 `module.luaName()` 返回的名称将刚刚创建的表分配给一个全局变量。从现在起，我们的 C++ 模块可以通过这个表访问。
- en: Exporting a C++ module to Lua may sound heavy and glorious. But there is actually
    not much gluing code involved. Compare what we have just done with overriding
    Lua library functions. Take a moment, then we will test our mechanism to see if
    it works.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将 C++ 模块导出到 Lua 可能听起来很复杂且令人印象深刻。但实际上，涉及的粘合代码并不多。将我们刚刚所做的工作与覆盖 Lua 库函数进行比较。稍作停顿，然后我们将测试我们的机制以查看它是否正常工作。
- en: Testing our mechanism
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的机制
- en: 'Add a few lines of code to `main.cpp` so that it looks like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.cpp` 中添加几行代码，使其看起来像这样：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We create an instance of the `Destinations` class and give it the name `"destinations"`.
    Then, we register it with our Lua executor.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `Destinations` 类的实例，并将其命名为 `"destinations"`。然后，我们将它注册到我们的 Lua 执行器中。
- en: 'Now, add the following code to `script.lua`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到 `script.lua` 中：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is doing the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在做以下操作：
- en: It adds London, Paris, and Amsterdam to the wish list.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将伦敦、巴黎和阿姆斯特丹添加到愿望清单中。
- en: It marks Paris as visited.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将巴黎标记为已访问。
- en: It prints the visited cities.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它打印出已访问的城市。
- en: It prints the unvisited cities.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它打印出未访问的城市。
- en: 'Run the project, and if you have followed all the steps correctly, you should
    see the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目，如果您正确地遵循了所有步骤，您应该看到以下输出：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There should be no errors, and since our wrapper functions are only stubs, it
    will not return anything useful. Hence, this is how we laid out the architectural
    foundation. Next, we will focus our efforts on making it work at the ground level.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 应该没有错误，并且由于我们的包装函数只是占位符，它不会返回任何有用的内容。因此，这就是我们构建架构基础的方式。接下来，我们将专注于使其在底层工作。
- en: Accessing the C++ class instance
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问 C++ 类实例
- en: Our wrapper functions are of type `lua_CFunction`. They are essentially C++
    static methods not associated with any class. How can we access the correct class
    instance? We must do some bookkeeping.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的包装函数是 `lua_CFunction` 类型。它们本质上是与任何类无关的 C++ 静态方法。我们如何访问正确的类实例？我们必须做一些记账。
- en: Luckily, Lua provides a mechanism to keep data for the registered C++ functions.
    It is called an **upvalue**. Upvalues can only be accessed by the associated function
    in C/C++ code and are shared across different function calls. We can save the
    pointer to the class instance in an upvalue.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Lua 提供了一种机制来保存注册的 C++ 函数的数据。它被称为 **upvalue**。Upvalue 只能通过 C/C++ 代码中关联的函数访问，并且在不同函数调用之间共享。我们可以在
    upvalue 中保存类实例的指针。
- en: Why is it called an upvalue? At this stage, it is easier to understand when
    not explained, in the same spirit as why a variable is called a variable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它被称为 upvalue？在这个阶段，如果不解释，它更容易理解，就像变量被称为变量一样。
- en: Have you noticed?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了吗？
- en: From the previous description, an upvalue behaves like a C++ static variable
    in the function scope. Then, why do we use an upvalue instead of a static variable?
    Because an upvalue is associated with a C++ function in the Lua library. This
    way, we can use the same C++ function with different upvalues.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的描述中，upvalue 在函数作用域中表现得像 C++ 静态变量。那么，为什么我们使用 upvalue 而不是静态变量？因为 upvalue 与
    Lua 库中的 C++ 函数相关联。这样，我们可以使用相同的 C++ 函数，但具有不同的 upvalue。
- en: Which Lua data type can be used to save a C++ pointer? We can use **userdata**.
    This type is used to store arbitrary C/C++ data. Especially, for our case, we
    need to use **light userdata**, whose purpose is to store a C/C++ pointer. It
    is a perfect match for us.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种 Lua 数据类型可以用来保存 C++ 指针？我们可以使用 **userdata**。这种类型用于存储任意 C/C++ 数据。特别是，在我们的情况下，我们需要使用
    **light userdata**，其目的是存储 C/C++ 指针。这对我们来说是一个完美的匹配。
- en: In conclusion, we need to save the class instance’s `this` pointer as *light
    userdata* in an *upvalue* for the `lua_CFunction` implementation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们需要将类实例的 `this` 指针作为 *light userdata* 保存在 `lua_CFunction` 实现的 *upvalue*
    中。
- en: Here, we have involved two new Lua concepts. They are exclusively used to work
    with C/C++ code, so chances are that you are not very familiar with them from
    Lua programming. Let us see the code in action to help with the understanding.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们涉及了两个新的 Lua 概念。它们专门用于与 C/C++ 代码一起工作，因此您可能不太熟悉 Lua 编程中的它们。让我们看看代码的实际运行情况，以帮助理解。
- en: How to provide upvalues
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何提供 upvalue
- en: We will only look at the case for registering C++ modules. So far, we have ignored
    the third parameter to `luaL_setfuncs` and always passed `0`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只关注注册 C++ 模块的情况。到目前为止，我们已经忽略了 `luaL_setfuncs` 的第三个参数，并且始终传递 `0`。
- en: What does this third parameter mean? It is the count for the upvalues that will
    be available to all functions in the list provided in the second parameter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第三个参数是什么意思？它是第二个参数中提供的列表中所有函数可用的 upvalue 的计数。
- en: How do you provide upvalues? Of course—you push them onto the stack!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何提供upvalues？当然——你将它们推送到栈上！
- en: 'Let us rewrite the function to register C++ modules as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写函数，如下注册C++模块：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are only two changes. First, we want another function yet to be implemented
    in `LuaModule` to push upvalues onto the stack and return to us how many upvalues
    have been pushed. Then, we pass the upvalue count as the third parameter to `luaL_setfuncs`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两处改动。首先，我们希望在`LuaModule`中实现另一个函数，用于将upvalues推送到栈上，并返回推送了多少个upvalues。然后，我们将upvalue计数作为`luaL_setfuncs`的第三个参数传递。
- en: 'Remember to add `pushLuaUpvalues` to `LuaModule.h`, like so:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将`pushLuaUpvalues`添加到`LuaModule.h`中，如下所示：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have provided a default implementation that pushes `this` as an upvalue.
    In derived classes, they can override this function and push more upvalues.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个默认实现，将`this`作为upvalue推送。在派生类中，它们可以重写这个函数并推送更多的upvalues。
- en: Next, let us see how we can access this upvalue.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何访问这个upvalue。
- en: How to access upvalues
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何访问upvalues
- en: Lua upvalues are accessed as if they were in the stack, while they are not really
    in the stack. So, a magic stack index, `LUA_REGISTRYINDEX`, is used to mark the
    start of the upvalue pseudo-region. Lua provides a `lua_upvalueindex` macro to
    locate the indices of your upvalues, so you do not really need to deal with this
    magic number.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Lua upvalues的访问就像它们在栈上一样，尽管它们实际上并不在栈上。所以，一个魔法栈索引`LUA_REGISTRYINDEX`被用来标记upvalue伪区域的开始。Lua提供了一个`lua_upvalueindex`宏来定位你的upvalues的索引，所以你实际上不需要处理这个魔法数字。
- en: 'This is how we can access our C++ class instance stored as an upvalue. In `Destinations.cc`,
    add the following function to the anonymous namespace:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以访问存储为upvalue的C++类实例了。在`Destinations.cc`中，向匿名命名空间添加以下函数：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can use this helper function to get a pointer to the instance. It uses `lua_touserdata`
    to get our light userdata from the stack with the pseudo-index. This helper will
    be called from the stubs we registered.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个辅助函数来获取实例的指针。它使用`lua_touserdata`通过伪索引从栈中获取我们的light userdata。这个辅助函数将从我们注册的存根中调用。
- en: To reinforce
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强
- en: The Lua state and stack passed to a `lua_CFunction` function are private to
    each call to that function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`lua_CFunction`函数的Lua状态和栈对该函数的每次调用都是私有的。
- en: Now that we have figured out how to access the class instance, we can complete
    our stubs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经弄清楚如何访问类实例，我们可以完成我们的存根。
- en: Completing our stubs
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成我们的存根
- en: 'Write `luaWish` as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将`luaWish`编写如下：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It first gets the class instance with the `getObj` helper function we just implemented.
    Then, it puts all arguments from the Lua call site into a vector. Finally, it
    calls the real object method, `obj->wish`. This is what a wrapper does – it routes
    the call to the real object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先使用我们刚刚实现的`getObj`辅助函数获取类实例。然后，它将Lua调用站点的所有参数放入一个vector中。最后，它调用真实对象的方法`obj->wish`。这就是包装器的作用——它将调用路由到真实对象。
- en: 'The code for `luaWent` is similar, as we can see here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`luaWent`的代码与此类似，如下所示：'
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The only difference is that it calls `obj->went` instead.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是它调用`obj->went`而不是其他。
- en: 'Finally, implement the query functions as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照以下方式实现查询函数：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These functions use the object functions to get a list of places and then push
    the list onto the stack to return the results to the Lua call site.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数使用对象函数获取一个位置列表，然后将列表推送到栈上以返回到Lua调用站点。
- en: Now, we have implemented everything, and we can test it.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经实现了所有功能，我们可以进行测试了。
- en: Testing it out
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行测试
- en: We do not need to modify any test code because we have already used the functions
    to test our stubs. Now, recompile and run the project.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要修改任何测试代码，因为我们已经使用这些函数测试了我们的存根。现在，重新编译并运行项目。
- en: 'Recall that the Lua test code looks like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Lua测试代码看起来是这样的：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you have done everything correctly, you should see the following output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切操作正确，你应该看到以下输出：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Congratulations on making it work!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你让它工作起来！
- en: This chapter is quite a change of mindset from the previous chapters. Take a
    moment to reflect if you need to.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这章与前面的章节相比，思维模式有很大的改变。如果你需要，请花点时间反思。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how to call C++ code from Lua. We first learned
    how to register a simple C++ function to Lua. All registered functions must conform
    to `lua_CFunction`. Then, we found out how to override Lua library functions.
    Finally, we implemented a C++ class and exported it to Lua. We also came across
    the concepts of *upvalue* and *light userdata* along the way.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在 Lua 中调用 C++ 代码。我们首先学习了如何将一个简单的 C++ 函数注册到 Lua 中。所有注册的函数都必须符合 `lua_CFunction`。然后，我们发现了如何覆盖
    Lua 库函数。最后，我们实现了一个 C++ 类并将其导出到 Lua。在过程中，我们还遇到了 *upvalue* 和 *light userdata* 的概念。
- en: In the next chapter, we will continue our journey with more details on user-defined
    data in C++ and more data-exchanging mechanisms.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续我们的旅程，更详细地介绍 C++ 中的用户定义数据以及更多的数据交换机制。
- en: Exercises
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In the `Destinations` class, we only used one upvalue. Add another upvalue and
    play around with it. Which upvalue is at which pseudo-index?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Destinations` 类中，我们只使用了其中一个 upvalue。添加另一个 upvalue 并对其进行实验。哪个 upvalue 对应哪个伪索引？
- en: Try to modify the second upvalue in a function and see if the value is persisted
    the next time the function is called. How about when it is accessed in another
    function?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试修改函数中的第二个 upvalue，看看下次函数被调用时值是否被保留。当它在另一个函数中被访问时又会怎样呢？
- en: In `LuaType.hpp`, add `LuaType::lightuserdata` and implement a structure for
    it, named `LuaLightUserData`. Support this case in the executor and helper functions.
    You do not need to support this type when popping values from the Lua stack.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LuaType.hpp` 中，添加 `LuaType::lightuserdata` 并为其实现一个结构体，命名为 `LuaLightUserData`。在执行器和辅助函数中支持这个情况。当从
    Lua 栈中弹出值时，你不需要支持这个类型。
