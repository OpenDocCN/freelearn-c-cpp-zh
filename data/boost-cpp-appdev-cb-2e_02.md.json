["```cpp\nbool foo1() { \n    foo_class* p = new foo_class(\"Some data\"); \n\n    const bool something_else_happened = some_function1(*p);  \n    if (something_else_happened) { \n        delete p; \n        return false; \n    } \n\n    some_function2(p); \n\n    delete p; \n    return true; \n}\n```", "```cpp\nbool foo2() { \n    foo_class* p = new foo_class(\"Some data\"); \n    try { \n        const bool something_else_happened = some_function1(*p); \n        if (something_else_happened) { \n            delete p; \n            return false; \n        } \n       some_function2(p); \n    } catch (...) { \n        delete p; \n        throw; \n    } \n    delete p; \n    return true; \n}\n```", "```cpp\n#include <boost/scoped_ptr.hpp> \n\nbool foo3() { \n    const boost::scoped_ptr<foo_class> p(new foo_class(\"Some data\")); \n\n    const bool something_else_happened = some_function1(*p); \n    if (something_else_happened) { \n       return false; \n    } \n    some_function2(p.get()); \n    return true; \n}\n```", "```cpp\n#include <boost/move/make_unique.hpp> \n\nbool foo3_1() { \n    const boost::movelib::unique_ptr<foo_class> p\n        = boost::movelib::make_unique<foo_class>(\"Some data\"); \n\n    const bool something_else_happened = some_function1(*p); \n    if (something_else_happened) { \n       return false; \n    } \n    some_function2(p.get()); \n    return true; \n}\n```", "```cpp\n#include <iostream>\n#include <string>\n\nstruct base {\n    virtual ~base(){}\n};\n\nclass derived: public base {\n    std::string str_;\n\npublic:\n    explicit derived(const char* str)\n        : str_(str)\n    {}\n\n    ~derived() /*override*/ {\n        std::cout << \"str == \" << str_ << '\\n';\n    }\n};\n\nvoid base_and_derived() {\n    const boost::movelib::unique_ptr<base> p1(\n        boost::movelib::make_unique<derived>(\"unique_ptr\")\n    );\n\n    const boost::scoped_ptr<base> p2(\n        new derived(\"scoped_ptr\")\n    );\n}\n```", "```cpp\nstr == scoped_ptr\nstr == unique_ptr\n```", "```cpp\n// In header file:\nstruct public_interface {\n    // ...\nprivate:\n    struct impl; // Forward declaration.\n    boost::movelib::unique_ptr<impl> impl_;\n};\n```", "```cpp\n#include <boost/thread.hpp> \n#include <boost/bind.hpp> \n\nvoid process1(const foo_class* p); \nvoid process2(const foo_class* p); \nvoid process3(const foo_class* p); \n\nvoid foo1() { \n    while (foo_class* p = get_data()) // C way \n    { \n        // There will be too many threads soon, see \n        // recipe 'Parallel execution of different tasks' \n        // for a good way to avoid uncontrolled growth of threads \n        boost::thread(boost::bind(&process1, p)) \n            .detach(); \n        boost::thread(boost::bind(&process2, p)) \n            .detach(); \n        boost::thread(boost::bind(&process3, p)) \n            .detach(); \n\n        // delete p; Oops!!!! \n    } \n}\n```", "```cpp\n#include <boost/shared_ptr.hpp> \n\nvoid process_sp1(const boost::shared_ptr<foo_class>& p); \nvoid process_sp2(const boost::shared_ptr<foo_class>& p); \nvoid process_sp3(const boost::shared_ptr<foo_class>& p); \n\nvoid foo2() { \n    typedef boost::shared_ptr<foo_class> ptr_t; \n    ptr_t p; \n    while (p = ptr_t(get_data())) // C way \n    { \n        boost::thread(boost::bind(&process_sp1, p)) \n            .detach(); \n        boost::thread(boost::bind(&process_sp2, p)) \n            .detach(); \n        boost::thread(boost::bind(&process_sp3, p)) \n            .detach(); \n\n        // no need to anything \n    } \n}\n```", "```cpp\n#include <string> \n#include <boost/smart_ptr/make_shared.hpp> \n\nvoid process_str1(boost::shared_ptr<std::string> p); \nvoid process_str2(const boost::shared_ptr<std::string>& p); \n\nvoid foo3() { \n    boost::shared_ptr<std::string> ps = boost::make_shared<std::string>( \n        \"Guess why make_shared<std::string> \" \n        \"is faster than shared_ptr<std::string> \" \n        \"ps(new std::string('this string'))\" \n    ); \n\n    boost::thread(boost::bind(&process_str1, ps)) \n            .detach(); \n    boost::thread(boost::bind(&process_str2, ps)) \n            .detach(); \n}\n```", "```cpp\nvoid process_cstr1(boost::shared_ptr<const std::string> p);\nvoid process_cstr2(const boost::shared_ptr<const std::string>& p);\n\nvoid foo3_const() {\n    boost::shared_ptr<const std::string> ps\n        = boost::make_shared<const std::string>(\n            \"Some immutable string\"\n        );\n\n    boost::thread(boost::bind(&process_cstr1, ps))\n            .detach();\n    boost::thread(boost::bind(&process_cstr2, ps))\n            .detach();\n\n    // *ps = \"qwe\"; // Compile time error, string is const!\n}\n```", "```cpp\nvoid may_throw1(char ch); \nvoid may_throw2(const char* buffer); \n\nvoid foo() { \n    // we cannot allocate 10MB of memory on stack, \n    // so we allocate it on heap \n    char* buffer = new char[1024 * 1024 * 10]; \n\n    // Oops. Here comes some code, that may throw.\n    // It was a bad idea to use raw pointer as the memory may leak!!\n    may_throw1(buffer[0]); \n    may_throw2(buffer); \n\n    delete[] buffer; \n}\n```", "```cpp\n#include <boost/scoped_array.hpp> \n\nvoid foo_fixed() { \n    // We allocate array on heap \n    boost::scoped_array<char> buffer(new char[1024 * 1024 * 10]); \n\n    // Here comes some code, that may throw, \n    // but now exception won't cause a memory leak \n    may_throw1(buffer[0]); \n    may_throw2(buffer.get()); \n\n    // destructor of 'buffer' variable will call delete[] \n}\n```", "```cpp\n#include <boost/move/make_unique.hpp> \n\nvoid foo_fixed2() { \n    // We allocate array on heap \n    const boost::movelib::unique_ptr<char[]> buffer \n        = boost::movelib::make_unique<char[]>(1024 * 1024 * 10); \n\n    // Here comes some code, that may throw, \n    // but now exception won't cause a memory leak \n    may_throw1(buffer[0]); \n    may_throw2(buffer.get()); \n\n    // destructor of 'buffer' variable will call delete[] \n}\n```", "```cpp\n#include <cstring> \n#include <boost/thread.hpp> \n#include <boost/bind.hpp> \n\nvoid do_process(const char* data, std::size_t size); \n\nvoid do_process_in_background(const char* data, std::size_t size) { \n    // We need to copy data, because we do not know, \n    // when it will be deallocated by the caller.\n    char* data_cpy = new char[size]; \n    std::memcpy(data_cpy, data, size); \n\n    // Starting thread of execution to process data.\n    boost::thread(boost::bind(&do_process, data_cpy, size)) \n            .detach(); \n    boost::thread(boost::bind(&do_process, data_cpy, size)) \n            .detach();\n\n    // Oops!!! We cannot delete[] data_cpy, because \n    // do_process() function may still work with it.\n}\n```", "```cpp\n#include <boost/shared_ptr.hpp>\n#include <boost/make_shared.hpp>\n\ntemplate <std::size_t Size>\nvoid do_process_shared(const boost::shared_ptr<char[Size]>& data);\n\ntemplate <std::size_t Size>\nvoid do_process_in_background_v1(const char* data) {\n    // Same speed as in 'First solution'.\n    boost::shared_ptr<char[Size]> data_cpy\n        = boost::make_shared<char[Size]>();\n    std::memcpy(data_cpy.get(), data, Size);\n\n    // Starting threads of execution to process data.\n    boost::thread(boost::bind(&do_process_shared<Size>, data_cpy))\n            .detach();\n    boost::thread(boost::bind(&do_process_shared<Size>, data_cpy))\n            .detach();\n\n    // data_cpy destructor will deallocate data when\n    // reference count is zero.\n}\n```", "```cpp\n#include <boost/shared_ptr.hpp>\n#include <boost/make_shared.hpp>\n\nvoid do_process_shared_ptr(\n        const boost::shared_ptr<char[]>& data,\n        std::size_t size);\n\nvoid do_process_in_background_v2(const char* data, std::size_t size) {\n    // Faster than 'First solution'.\n    boost::shared_ptr<char[]> data_cpy = boost::make_shared<char[]>(size);\n    std::memcpy(data_cpy.get(), data, size);\n\n    // Starting threads of execution to process data.\n    boost::thread(boost::bind(&do_process_shared_ptr, data_cpy, size))\n            .detach();\n    boost::thread(boost::bind(&do_process_shared_ptr, data_cpy, size))\n            .detach();\n\n    // data_cpy destructor will deallocate data when\n    // reference count is zero.\n}\n```", "```cpp\n#include <boost/shared_ptr.hpp>\n\nvoid do_process_shared_ptr2(\n        const boost::shared_ptr<char>& data,\n        std::size_t size);\n\nvoid do_process_in_background_v3(const char* data, std::size_t size) {\n    // Same speed as in 'First solution'.\n    boost::shared_ptr<char> data_cpy(\n                new char[size],\n                boost::checked_array_deleter<char>()\n    );\n    std::memcpy(data_cpy.get(), data, size);\n\n    // Starting threads of execution to process data.\n    boost::thread(boost::bind(&do_process_shared_ptr2, data_cpy, size))\n            .detach();\n    boost::thread(boost::bind(&do_process_shared_ptr2, data_cpy, size))\n            .detach();\n\n    // data_cpy destructor will deallocate data when\n    // reference count is zero.\n}\n```", "```cpp\n#include <boost/shared_array.hpp>\n\nvoid do_process_shared_array(\n        const boost::shared_array<char>& data,\n        std::size_t size);\n\nvoid do_process_in_background_v4(const char* data, std::size_t size) {\n    // We need to copy data, because we do not know, when it will be\n    // deallocated by the caller.\n    boost::shared_array<char> data_cpy(new char[size]);\n    std::memcpy(data_cpy.get(), data, size);\n\n    // Starting threads of execution to process data.\n    boost::thread(\n        boost::bind(&do_process_shared_array, data_cpy, size)\n    ).detach();\n    boost::thread(\n        boost::bind(&do_process_shared_array, data_cpy, size)\n    ).detach();\n\n    // No need to call delete[] for data_cpy, because\n    // data_cpy destructor will deallocate data when\n    // reference count is zero.\n}\n```", "```cpp\n// making a typedef for function pointer accepting int \n// and returning nothing \ntypedef void (*func_t)(int); \n\n// Function that accepts pointer to function and \n// calls accepted function for each integer that it has.\n// It cannot work with functional objects :( \nvoid process_integers(func_t f); \n\n// Functional object \nclass int_processor { \n   const int min_; \n   const int max_; \n   bool& triggered_; \n\npublic: \n    int_processor(int min, int max, bool& triggered) \n        : min_(min) \n        , max_(max) \n        , triggered_(triggered) \n    {} \n\n    void operator()(int i) const { \n        if (i < min_ || i > max_) { \n            triggered_ = true; \n        } \n    } \n};\n```", "```cpp\n#include <boost/function.hpp> \n\ntypedef boost::function<void(int)> fobject_t; \n\n// Now this function may accept functional objects \nvoid process_integers(const fobject_t& f); \n\nint main() { \n    bool is_triggered = false; \n    int_processor fo(0, 200, is_triggered); \n    process_integers(fo); \n    assert(is_triggered); \n}\n```", "```cpp\nbool g_is_triggered = false; \nvoid set_functional_object(fobject_t& f) {\n    // Local variable\n    int_processor fo( 100, 200, g_is_triggered); \n\n    f = fo;\n    // now 'f' holds a copy of 'fo'\n\n    // 'fo' leavs scope and will be destroyed,\n    // but it's OK to use 'f' in outer scope.\n}\n```", "```cpp\nvoid foo(const fobject_t& f) { \n    // boost::function is convertible to bool \n    if (f) { \n        // we have value in 'f' \n        // ... \n    } else { \n        // 'f' is empty \n        // ... \n    } \n}\n```", "```cpp\nvoid my_ints_function(int i); \n\nint main() { \n    process_integers(&my_ints_function); \n}\n```", "```cpp\nboost::function<int(std::string&&)> f = &something;\nf(std::string(\"Hello\")); // Works\n```", "```cpp\n#include <deque>\n//#include \"your_project/process_integers.h\"\n\nvoid sample() {\n    // lambda function with no parameters that does nothing \n    process_integers([](int /*i*/){}); \n\n    // lambda function that stores a reference \n    std::deque<int> ints; \n    process_integers([&ints](int i){ \n        ints.push_back(i); \n    }); \n\n    // lambda function that modifies its content \n    std::size_t match_count = 0; \n    process_integers([ints, &match_count](int i) mutable { \n        if (ints.front() == i) { \n           ++ match_count; \n        } \n        ints.pop_front(); \n    });\n}\n```", "```cpp\n    std::for_each(v.begin(), v.end(), [](int& v) { v += 10; });\n```", "```cpp\n    const boost::function<void(int&)> f0(\n        [](int& v) { v += 10; }\n    ); \n    std::for_each(v.begin(), v.end(), f0);\n```", "```cpp\n    const auto f1 = [](int& v) { v += 10; }; \n    std::for_each(v.begin(), v.end(), f1);\n```", "```cpp\n#include <set>\n#include <algorithm>\n#include <cassert>\n\ntemplate <class T>\nstruct ptr_cmp {\n    template <class T1>\n    bool operator()(const T1& v1, const T1& v2) const {\n        return operator ()(*v1, *v2);\n    }\n\n    bool operator()(const T& v1, const T& v2) const {\n        return std::less<T>()(v1, v2);\n    }\n};\n\nvoid example1() {\n    std::set<int*, ptr_cmp<int> > s;\n    s.insert(new int(1));\n    s.insert(new int(0));\n\n    // ...\n    assert(**s.begin() == 0);\n    // ...\n\n    // Oops! Any exception in the above code leads to\n    // memory leak.\n\n    // Deallocating resources.\n    std::for_each(s.begin(), s.end(), [](int* p) { delete p; });\n}\n```", "```cpp\n#include <memory>\n#include <set>\n\nvoid example2_cpp11() {\n    typedef std::unique_ptr<int> int_uptr_t;\n    std::set<int_uptr_t, ptr_cmp<int> > s;\n    s.insert(int_uptr_t(new int(1)));\n    s.insert(int_uptr_t(new int(0)));\n\n    // ...\n    assert(**s.begin() == 0);\n    // ...\n\n    // Resources will be deallocated by unique_ptr<>.\n}\n```", "```cpp\n#include <boost/shared_ptr.hpp>\n#include <boost/make_shared.hpp>\n\nvoid example3() {\n    typedef boost::shared_ptr<int> int_sptr_t;\n    std::set<int_sptr_t, ptr_cmp<int> > s;\n    s.insert(boost::make_shared<int>(1));\n    s.insert(boost::make_shared<int>(0));\n\n    // ...\n    assert(**s.begin() == 0);\n    // ...\n\n    // Resources will be deallocated by shared_ptr<>.\n}\n```", "```cpp\n#include <boost/ptr_container/ptr_set.hpp> \n\nvoid correct_impl() { \n    boost::ptr_set<int> s; \n    s.insert(new int(1)); \n    s.insert(new int(0)); \n\n    // ... \n    assert(*s.begin() == 0); \n    // ... \n\n    // Resources will be deallocated by container itself.\n}\n```", "```cpp\n#include <boost/ptr_container/clone_allocator.hpp>\n#include <boost/ptr_container/ptr_vector.hpp>\n#include <cassert>\n\nvoid theres_more_example() {\n    // Creating vector of 10 elements with values 100\n    boost::ptr_vector<int> v;\n    int value = 100;\n    v.resize(10, &value); // Beware! No ownership of pointer!\n\n    assert(v.size() == 10);\n    assert(v.back() == 100);\n}\n```", "```cpp\n#include <boost/container/set.hpp>\n#include <boost/move/make_unique.hpp>\n#include <cassert>\n\nvoid example2_cpp03() { \n    typedef boost::movelib::unique_ptr<int> int_uptr_t; \n    boost::container::set<int_uptr_t, ptr_cmp<int> > s; \n    s.insert(boost::movelib::make_unique<int>(1)); \n    s.insert(boost::movelib::make_unique<int>(0)); \n    // ... \n    assert(**s.begin() == 0); \n}\n```", "```cpp\n// Some pseudo code (suspiciously similar to Java code) \ntry { \n    FileWriter f = new FileWriter(\"example_file.txt\"); \n    // Some code that may throw or return \n    // ... \n} finally { \n    // Whatever happened in scope, this code will be executed \n    // and file will be correctly closed \n    if (f != null) { \n        f.close() \n    } \n}\n```", "```cpp\n#include <boost/scope_exit.hpp> \n#include <cstdlib> \n#include <cstdio> \n#include <cassert> \n\nint main() { \n    std::FILE* f = std::fopen(\"example_file.txt\", \"w\"); \n    assert(f); \n\n    BOOST_SCOPE_EXIT(f) { \n    // Whatever happened in outer scope, this code will be executed \n    // and file will be correctly closed. \n        std::fclose(f); \n    } BOOST_SCOPE_EXIT_END \n\n    // Some code that may throw or return. \n    // ... \n}\n```", "```cpp\nclass theres_more_example { \npublic: \n    void close(std::FILE*); \n\n    void theres_more_example_func() { \n        std::FILE* f = 0; \n        BOOST_SCOPE_EXIT(f, this_) { // Capturing `this` as 'this_' \n            this_->close(f); \n        } BOOST_SCOPE_EXIT_END \n    } \n};\n```", "```cpp\n#include <boost/move/unique_ptr.hpp>\n#include <cstdio>\n\nvoid unique_ptr_example() {\n    boost::movelib::unique_ptr<std::FILE, int(*)(std::FILE*)> f(\n        std::fopen(\"example_file.txt\", \"w\"), // open file\n        &std::fclose  // specific deleter\n    );\n    // ...\n}\n```", "```cpp\n#include <boost/noncopyable.hpp> \n#include <sstream> \n\nclass tasks_processor: boost::noncopyable { \n    std::ostream& log_; \n\nprotected: \n    virtual void do_process() = 0; \n\npublic: \n    explicit tasks_processor(std::ostream& log) \n        : log_(log) \n    {} \n\n    void process() { \n        log_ << \"Starting data processing\"; \n        do_process(); \n    } \n};\n```", "```cpp\nclass fake_tasks_processor: public tasks_processor { \n    std::ostringstream logger_; \n\n    virtual void do_process() { \n        logger_ << \"Fake processor processed!\"; \n    } \n\npublic: \n    fake_tasks_processor() \n        : tasks_processor(logger_) // Oops! logger_ does not exist here \n        , logger_() \n    {} \n};\n```", "```cpp\n    fake_tasks_processor() \n        : logger_() // Oops! It is still constructed AFTER tasks_processor. \n        , tasks_processor(logger_) \n    {}\n```", "```cpp\n#include <boost/utility/base_from_member.hpp>\n```", "```cpp\nclass fake_tasks_processor_fixed\n    : boost::base_from_member<std::ostringstream>\n    , public tasks_processor\n```", "```cpp\n{\n    typedef boost::base_from_member<std::ostringstream> logger_t;\n\n    virtual void do_process() {\n        logger_t::member << \"Fake processor processed!\";\n    }\n\npublic:\n    fake_tasks_processor_fixed()\n        : logger_t()\n        , tasks_processor(logger_t::member)\n    {}\n};\n```", "```cpp\ntemplate < typename MemberType, int UniqueID = 0 >\nclass base_from_member {\nprotected:\n    MemberType  member;\n    //      Constructors go there...\n};\n```", "```cpp\nclass fake_tasks_processor2 \n    : boost::base_from_member<std::ostringstream, 0> \n    , boost::base_from_member<std::ostringstream, 1> \n    , public tasks_processor \n{ \n    typedef boost::base_from_member<std::ostringstream, 0> logger0_t;\n    typedef boost::base_from_member<std::ostringstream, 1> logger1_t;\n\n    virtual void do_process() { \n        logger0_t::member << \"0: Fake processor2 processed!\"; \n        logger1_t::member << \"1: Fake processor2 processed!\"; \n    } \n\npublic: \n    fake_tasks_processor2() \n        : logger0_t() \n        , logger1_t() \n        , tasks_processor(logger0_t::member) \n    {} \n};\n```"]