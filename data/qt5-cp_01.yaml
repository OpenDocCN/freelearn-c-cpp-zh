- en: Chapter 1. Creating Your First Qt Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 创建您的第一个 Qt 应用程序
- en: GUI programming is not as difficult as you think. At least it's not when you
    come to the world of Qt. This book will take you through this world and give you
    an insight into this incredibly amazing toolkit. It doesn't matter whether you've
    heard of it or not, as long as you have essential knowledge of C++ programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: GUI 编程并不像您想象的那么困难。至少，当您进入 Qt 的世界时，它不是那么困难。这本书将带您穿越这个世界，并让您深入了解这个令人难以置信的神奇工具包。无论您是否听说过它，只要您具备
    C++ 编程的基本知识即可。
- en: 'In this chapter, we will get you comfortable with the development of Qt applications.
    Simple applications are used as a demonstration for you to cover the following
    topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将让您熟悉 Qt 应用程序的开发。简单的应用程序被用作演示，以便您涵盖以下主题：
- en: Creating a new project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: Changing the layout of widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改小部件布局
- en: Understanding the mechanism of signals and slots
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解信号和槽的机制
- en: Connecting two signals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接两个信号
- en: Creating a Qt Quick application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 Qt Quick 应用程序
- en: Connecting C++ slots to QML signals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 C++ 槽连接到 QML 信号
- en: Creating a new project
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: 'If you haven''t installed Qt 5, refer to [http://www.qt.io/download](http://www.qt.io/download)
    to install the latest version of it. It''s recommended that you install the Community
    version, which is totally free and compliant with GPL/LGPL. Typically, the installer
    will install both **Qt Library** and **Qt Creator** for you. In this book, we
    will use Qt 5.4.0 and Qt Creator 3.3.0\. Later versions may have slight differences
    but the concept remains the same. It''s highly recommended that you install Qt
    Creator if you don''t have it on your computer, because all the tutorials in this
    book are based on it. It is also the official IDE for the development of Qt applications.
    Although you may be able to develop Qt applications with other IDEs, it tends
    to be much more complex. So if you''re ready, let''s go for it by performing the
    following steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装 Qt 5，请参考[http://www.qt.io/download](http://www.qt.io/download)安装最新版本。建议您安装社区版，它是完全免费的，并且符合
    GPL/LGPL。通常，安装程序会为您安装**Qt 库**和**Qt Creator**。在这本书中，我们将使用 Qt 5.4.0 和 Qt Creator
    3.3.0。较新版本可能会有细微差异，但概念保持不变。如果您电脑上没有 Qt Creator，强烈建议您安装它，因为本书中的所有教程都是基于它的。它也是 Qt
    应用程序开发的官方 IDE。尽管您可能能够使用其他 IDE 开发 Qt 应用程序，但这通常会更加复杂。所以，如果您准备好了，让我们通过以下步骤开始吧：
- en: Open Qt Creator.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Qt Creator。
- en: Navigate to **File** | **New File** or **Project**.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**文件** | **新建文件**或**项目**。
- en: Select **Qt Widgets Application**.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Qt Widgets 应用程序**。
- en: Enter the project's name and location. In this case, the project's name is `layout_demo`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入项目的名称和位置。在这种情况下，项目的名称是 `layout_demo`。
- en: You may wish to follow the wizard and keep the default values. After this process,
    Qt Creator will generate the skeleton of the project based on your choices. The
    UI files are under the `Forms` directory. When you double-click on a UI file,
    Qt Creator will redirect you to the integrated designer. The mode selector should
    have **Design** highlighted, and the main window should contain several sub-windows
    to let you design the user interface. This is exactly what we are going to do.
    For more details about Qt Creator UI, refer to [http://doc.qt.io/qtcreator/creator-quick-tour.html](http://doc.qt.io/qtcreator/creator-quick-tour.html).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择跟随向导并保留默认值。在此过程之后，Qt Creator 将根据您的选择生成项目的骨架。UI 文件位于 `Forms` 目录下。当您双击一个
    UI 文件时，Qt Creator 将将您重定向到集成设计器。模式选择器应该突出显示**设计**，主窗口应包含几个子窗口，以便您设计用户界面。这正是我们要做的。有关
    Qt Creator UI 的更多详细信息，请参阅[http://doc.qt.io/qtcreator/creator-quick-tour.html](http://doc.qt.io/qtcreator/creator-quick-tour.html)。
- en: Drag three push buttons from the widget box (widget palette) into the frame
    of **MainWindow** in the center. The default text displayed on these buttons is
    **PushButton**, but you can change the text if you want by double-clicking on
    the button. In this case, I changed the buttons to `Hello`, `Hola`, and `Bonjour`,
    accordingly. Note that this operation won't affect the `objectName` property.
    In order to keep it neat and easy to find, we need to change the `objectName`
    property. The right-hand side of the UI contains two windows. The upper-right
    section includes **Object Inspector** and the lower-right side includes **Property
    Editor**. Just select a push button; you can easily change `objectName` in **Property
    Editor**. For the sake of convenience, I changed these buttons' `objectName` properties
    to `helloButton`, `holaButton`, and `bonjourButton` respectively.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从小部件框（小部件调色板）中拖动三个按钮到中心**MainWindow**的框架中。这些按钮上显示的默认文本是**PushButton**，但你可以通过双击按钮来更改文本。在这种情况下，我将按钮改为`Hello`、`Hola`和`Bonjour`。请注意，此操作不会影响`objectName`属性。为了保持整洁且易于查找，我们需要更改`objectName`属性。UI的右侧包含两个窗口。右上部分包括**对象检查器**，而右下部分包括**属性编辑器**。只需选择一个按钮；你可以在**属性编辑器**中轻松更改`objectName`。为了方便起见，我将这些按钮的`objectName`属性分别更改为`helloButton`、`holaButton`和`bonjourButton`。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's a good habit to use lowercase for the first letter of `objectName` and
    an uppercase letter for **Class name**. This helps your code to be more readable
    by people who are familiar with this convention.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小写字母作为`objectName`的第一个字母，大写字母作为**类名**是一个好习惯。这有助于使你的代码对熟悉此约定的人更易读。
- en: 'Okay, it''s time to see what you have done to the user interface of your first
    Qt application. Click on **Run** on the left-hand side panel. It will build the
    project automatically and then run it. It''s amazing to see that the application
    has the exact same interface as the design, isn''t it? If everything is alright,
    the application should appear similar to what is shown in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，是时候看看你对你的第一个Qt应用程序的用户界面做了什么。在左侧面板上点击**运行**。它将自动构建项目然后运行。看到应用程序与设计完全相同的界面，是不是很神奇？如果一切正常，应用程序应该看起来与以下截图所示相似：
- en: '![Creating a new project](img/4615OS_01_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![创建新项目](img/4615OS_01_01.jpg)'
- en: 'You may want to look at the source code and see what happened there. So, let''s
    go back to the source code by returning to the **Edit** mode. Click on the **Edit**
    button in the mode selector. Then, double-click on `main.cpp` in the `Sources`
    folder of the **Projects** tree view. The code for `main.cpp` is shown as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想查看源代码看看那里发生了什么。所以，让我们通过返回到**编辑**模式来回到源代码。在模式选择器中点击**编辑**按钮。然后，在**项目**树视图的**源**文件夹中双击`main.cpp`。`main.cpp`的代码如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `QApplication` class manages the GUI application's control flow and the
    main settings.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`QApplication`类管理GUI应用程序的控制流和主要设置。'
- en: Actually, you don't need to and you probably won't change too much in this file.
    The first line of the main scope just initializes the applications on a user's
    desktop and handles some events. Then there is also an object, `w`, which belongs
    to the `MainWindow` class. As for the last line, it ensures that the application
    won't terminate after execution but will keep in an event loop, so that it is
    able to respond to external events such as mouse clicks and window state changes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你不需要也不太可能在这个文件中做太多改动。主作用域的第一行只是初始化用户桌面上的应用程序并处理一些事件。然后还有一个对象`w`，它属于`MainWindow`类。至于最后一行，它确保应用程序在执行后不会终止，而是保持在一个事件循环中，以便能够响应外部事件，如鼠标点击和窗口状态变化。
- en: 'Last but not least, let''s see what happens during the initialization of the
    `MainWindow` object, `w`. It is the content of `mainwindow.h`, shown as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，让我们看看在`MainWindow`对象初始化过程中会发生什么，`w`是这个内容，如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You may feel a bit surprised seeing a `Q_OBJECT` macro if this is your first
    time writing a Qt application. In the QObject documentation, it says:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次编写Qt应用程序，看到`Q_OBJECT`宏可能会让你感到有些惊讶。在QObject文档中，它说：
- en: '*The `Q_OBJECT` macro must appear in the private section of a class definition
    that declares its own signals and slots or that uses other services provided by
    Qt''s meta-object system.*'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*`Q_OBJECT`宏必须出现在声明其自己的信号和槽或使用Qt元对象系统提供的其他服务的类定义的私有部分中。*'
- en: Well, this means that `QObject` has to be declared if you're going to use Qt's
    meta-object system and (or) its signals and slots mechanism. The signals and slots,
    which are almost the core of Qt, will be included later in this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这意味着如果你打算使用 Qt 的元对象系统以及（或）其信号和槽机制，就必须声明 `QObject`。信号和槽，几乎是 Qt 的核心，将在本章后面进行介绍。
- en: 'There is a private member named `ui`, which is a pointer of the `MainWindow`
    class of the `Ui` namespace. Do you remember the UI file we edited before? What
    the magic of Qt does is that it links the UI file and the parental source code.
    We can manipulate the UI through code lines as well as design it in Qt Creator''s
    integrated designer. Finally, let''s look into the construction function of `MainWindow`
    in `mainwindow.cpp`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `ui` 的私有成员，它是 `Ui` 命名空间中 `MainWindow` 类的指针。你还记得我们之前编辑的 UI 文件吗？Qt 的魔法在于它将
    UI 文件和父源代码链接起来。我们可以通过代码行来操作 UI，也可以在 Qt Creator 的集成设计器中设计它。最后，让我们看看 `mainwindow.cpp`
    中 `MainWindow` 的构造函数：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Did you see where the user interface comes from? It''s the member `setupUi`
    function of `Ui::MainWindow` that initializes it and sets it up for us. You may
    want to check what happens if we change the member function to something like
    this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到用户界面是从哪里来的了吗？它是 `Ui::MainWindow` 的成员函数 `setupUi`，它初始化并为我们设置它。你可能想检查如果我们把成员函数改为类似这样会发生什么：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What happened here? The `Hola` button can't be clicked on because we disabled
    it! It has the same effect if the **enabled** box is unchecked in the designer
    instead of writing a statement here. Please apply this change before heading to
    the next topic, because we don't need a disabled push button to do any demonstrations
    in this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？由于我们禁用了它，所以无法点击 `Hola` 按钮！如果在设计器中取消勾选 **启用** 复选框而不是在这里编写语句，也会有相同的效果。请在进入下一个主题之前应用此更改，因为我们不需要禁用的按钮在本章中进行任何演示。
- en: Changing the layout of widgets
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改小部件的布局
- en: You already know how to add and move widgets in the **Design** mode. Now, we
    need to make the UI neat and tidy. I'll show you how to do this step by step.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何在 **设计** 模式下添加和移动小部件。现在，我们需要使 UI 整洁有序。我会一步步地教你如何做。
- en: A quick way to delete a widget is to select it and press the **Delete** button.
    Meanwhile, some widgets, such as the menu bar, status bar, and toolbar can't be
    selected, so we have to right-click on them in **Object Inspector** and delete
    them. Since they are useless in this example, it's safe to remove them and we
    can do this for good.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 删除小部件的一个快捷方法是选择它并按 **Delete** 按钮。同时，一些小部件，如菜单栏、状态栏和工具栏，不能被选择，因此我们必须在 **对象检查器**
    中右键点击它们并删除它们。由于它们在这个例子中无用，所以安全地移除它们，我们可以永久地这样做。
- en: 'Okay, let''s understand what needs to be done after the removal. You may want
    to keep all these push buttons on the same horizontal axis. To do this, perform
    the following steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们了解在移除之后需要做什么。你可能希望将这些按钮都保持在同一水平轴上。为此，执行以下步骤：
- en: Select all the push buttons either by clicking on them one by one while keeping
    the *Ctrl* key pressed or just drawing an enclosing rectangle containing all the
    buttons.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过逐个点击按钮同时按住 *Ctrl* 键或绘制一个包含所有按钮的包围矩形来选择所有按钮。
- en: Right-click and select **Layout** | **LayOut Horizontally**, The keyboard shortcut
    for this is *Ctrl* + *H*.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击并选择 **布局** | **水平布局**，此操作的快捷键是 *Ctrl* + *H*。
- en: Resize the horizontal layout and adjust its `layoutSpacing` by selecting it
    and dragging any of the points around the selection box until it fits best.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择并拖动选择框周围的任何一点来调整水平布局的大小，直到它最适合。
- en: Hmm…! You may have noticed that the text of the **Bonjour** button is longer
    than the other two buttons, and it should be wider than the others. How do you
    do this? You can change the property of the horizontal layout object's `layoutStretch`
    property in **Property Editor**. This value indicates the stretch factors of the
    widgets inside the horizontal layout. They would be laid out in proportion. Change
    it to `3,3,4`, and there you are. The stretched size definitely won't be smaller
    than the minimum size hint. This is how the zero factor works when there is a
    nonzero natural number, which means that you need to keep the minimum size instead
    of getting an error with a zero divisor.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯…！你可能已经注意到**Bonjour**按钮的文本比其他两个按钮长，它应该比其他按钮更宽。你该如何做到这一点？你可以在**属性编辑器**中更改水平布局对象的`layoutStretch`属性。此值表示水平布局内小部件的拉伸因子。它们将按比例排列。将其更改为`3,3,4`，就是这样。拉伸的大小肯定不会小于最小尺寸提示。这就是当存在非零自然数时零因子的作用，这意味着你需要保持最小尺寸，而不是因为零除数而出现错误。
- en: Now, drag **Plain Text Edit** just below, and not inside, the horizontal layout.
    Obviously, it would be neater if we could extend the plain text edit's width.
    However, we don't have to do this manually. In fact, we could change the layout
    of the parent, **MainWindow**. That's it! Right-click on **MainWindow**, and then
    navigate to **Lay out** | **Lay Out Vertically**. Wow! All the children widgets
    are automatically extended to the inner boundary of **MainWindow**; they are kept
    in a vertical order. You'll also find **Layout** settings in the `centralWidget`
    property, which is exactly the same thing as the previous horizontal layout.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将**纯文本编辑**拖动到水平布局的下方，而不是内部。显然，如果我们能扩展纯文本编辑的宽度，会看起来更整洁。然而，我们不必手动这样做。实际上，我们可以更改父窗口的布局，即**MainWindow**。就是这样！右键点击**MainWindow**，然后导航到**布局**
    | **垂直布局**。哇！所有子小部件都会自动扩展到**MainWindow**的内边界；它们保持垂直顺序。你也会在`centralWidget`属性中找到**布局**设置，这与之前的水平布局完全相同。
- en: 'The last thing to make this application halfway decent is to change the title
    of the window. `MainWindow` is not the title you want, right? Click on **MainWindow**
    in the object tree. Then, scroll down its properties to find **windowTitle**.
    Name it whatever you want. In this example, I changed it to `Greeting`. Now, run
    the application again and you will see it looks like what is shown in the following
    screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个应用程序变得半 decent 的最后一件事是更改窗口的标题。"MainWindow"不是你想要的标题，对吧？在对象树中点击**MainWindow**。然后，滚动其属性以找到**windowTitle**。给它起个你想的名字。在这个例子中，我将其更改为`Greeting`。现在，再次运行应用程序，你将看到它看起来就像以下截图所示：
- en: '![Changing the layout of widgets](img/4615OS_01_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![更改小部件布局](img/4615OS_01_02.jpg)'
- en: Understanding the mechanism of signals and slots
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解信号和槽的机制
- en: It is really important to keep your curiosity and to explore what on earth these
    properties do. However, please remember to revert the changes you made to the
    app, as we are about to enter the core part of Qt, that is, signals and slots.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 保持好奇心并探索这些属性究竟有什么作用，这一点非常重要。然而，请记住恢复你对应用程序所做的更改，因为我们即将进入Qt的核心部分，即信号和槽。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Signals and slots are used for communication between objects. The signals and
    slots mechanism is a central feature of Qt and probably the part that differs
    the most from the features provided by other frameworks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 信号和槽用于对象之间的通信。信号和槽机制是Qt的核心特性，可能是与其他框架提供的特性差异最大的部分。
- en: 'Have you ever wondered why a window closes after the **Close** button is clicked
    on? Developers who are familiar with other toolkits would say that the **Close**
    button being clicked on is an event, and this event is bound with a callback function
    that is responsible for closing the window. Well, it''s not quite the same in
    the world of Qt. Since Qt uses a mechanism called signals and slots, it makes
    the callback function weakly coupled to the event. Also, we usually use the terms
    signal and slot in Qt. A signal is emitted when a particular event occurs. A slot
    is a function that is called in response to a particular signal. The following
    simple and schematic diagram helps you understand the relation between signals,
    events, and slots:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经想过为什么在点击**关闭**按钮后窗口会关闭？熟悉其他工具包的开发者会说，点击**关闭**按钮是一个事件，这个事件绑定了一个回调函数，该函数负责关闭窗口。然而，在
    Qt 的世界中，情况并不完全相同。由于 Qt 使用名为信号和槽的机制，它使得回调函数与事件之间的耦合变得较弱。此外，我们通常在 Qt 中使用信号和槽这两个术语。当特定事件发生时发出信号。槽是响应特定信号而被调用的函数。以下简单且示意图有助于您理解信号、事件和槽之间的关系：
- en: '![Understanding the mechanism of signals and slots](img/4615OS_01_03.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![理解信号和槽的机制](img/4615OS_01_03.jpg)'
- en: Qt has tons of predefined signals and slots, which cover its general purposes.
    However, it's indeed commonplace to add your own slots to handle the target signals.
    You may also be interested in subclassing widgets and writing your own signals,
    which will be covered later. The mechanism of signals and slots was designed to
    be type-safe because of its requirement of the list of the same arguments. In
    fact, the slot may have a shorter arguments list than the signal since it can
    ignore the extras. You can have as many arguments as you want. This enables you
    to forget about the wildcard `void*` type in C and other toolkits.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 有大量的预定义信号和槽，涵盖了其通用目的。然而，添加自己的槽来处理目标信号确实是常见的做法。您可能还对子类化小部件并编写自己的信号感兴趣，这将在稍后介绍。由于信号和槽机制要求具有相同参数的列表，因此它被设计为类型安全的。实际上，槽可以比信号具有更短的参数列表，因为它可以忽略额外的参数。您可以拥有尽可能多的参数。这使得您可以在
    C 和其他工具包中忘记通配符 `void*` 类型。
- en: 'Since Qt 5, this mechanism is even safer because we can use a new syntax of
    signals and slots to deal with the connections. A conversion of a piece of code
    is demonstrated here. Let''s see what a typical connect statement in old style
    is:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Qt 5 以来，这种机制变得更加安全，因为我们可以使用新的信号和槽语法来处理连接。这里演示了一段代码的转换。让我们看看旧式风格中典型的连接语句：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This can be rewritten in a new syntax style:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用新的语法风格重写：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the traditional way of writing code, the verification of signals and slots
    only happens at runtime. In the new style, the compiler can detect the mismatches
    in the types of arguments and the existence of signals and slots at compile time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的代码编写方式中，信号和槽的验证仅在运行时发生。在新风格中，编译器可以在编译时检测参数类型的不匹配以及信号和槽的存在。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As long as it is possible, all `connect` statements are written in the new syntax
    style in this book.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 只要可能，本书中的所有 `connect` 语句都使用新的语法风格编写。
- en: 'Now, let''s get back to our application. I''ll show you how to display some
    words in a plain text edit when the **Hello** button is clicked on. First of all,
    we need to create a slot since Qt has already predefined the clicked signal for
    the `QPushButton` class. Edit `mainwindow.h` and add a slot declaration:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的应用程序。我将向您展示如何在点击**Hello**按钮时在纯文本编辑器中显示一些文字。首先，我们需要创建一个槽，因为 Qt 已经为
    `QPushButton` 类预定义了点击信号。编辑 `mainwindow.h` 并添加槽声明：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, it''s the `slots` keyword that distinguishes slots from ordinary
    functions. I declared it private to restrict access permission. You have to declare
    it a `public` slot if you need to invoke it in an object from other classes. After
    this declaration, we have to implement it in the `mainwindow.cpp` file. The implementation
    of the `displayHello` slot is written as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，是 `slots` 关键字将槽与普通函数区分开来。我将其声明为私有以限制访问权限。如果您需要在其他类的对象中调用它，必须将其声明为 `public`
    槽。在此声明之后，我们必须在 `mainwindow.cpp` 文件中实现它。`displayHello` 槽的实现如下：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It simply calls a member function of the plain text edit in order to add a
    `Hello` QString to it. `QString` is a core class that Qt has introduced. It provides
    a Unicode character string, which efficiently solves the internationalization
    issue. It''s also convenient to convert a `QString` class to `std::string` and
    vice versa. Besides, just like the other `QObject` classes, `QString` uses an
    implicit sharing mechanism to reduce memory usage and avoid needless copying.
    If you don''t want to get concerned about the scenes shown in the following code,
    just take `QString` as an improved version of `std::string`. Now, we need to connect
    this slot to the signal that the **Hello** push button will emit:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是调用纯文本编辑的一个成员函数，以便向其中添加一个`Hello` QString。`QString`是Qt引入的一个核心类。它提供了一个Unicode字符字符串，有效地解决了国际化问题。它也方便地将`QString`类转换为`std::string`，反之亦然。此外，就像其他`QObject`类一样，`QString`使用隐式共享机制来减少内存使用并避免不必要的复制。如果你不想关心以下代码中显示的场景，只需将`QString`视为`std::string`的改进版本。现在，我们需要将这个槽连接到**Hello**按钮将发出的信号：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What I did is add a `connect` statement to the constructor of `MainWindow`.
    In fact, we can connect signals and slots anywhere and at any time. However, the
    connection only exists after this line gets executed. So, it''s a common practice
    to have lots of `connect` statements in the construction functions instead of
    spreading them out. For a better understanding, run your application and see what
    happens when you click on the **Hello** button. Every time you click, a **Hello**
    text will be appended to the plain text edit. The following screenshot is what
    happened after we clicked on the **Hello** button three times:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我所做的是在`MainWindow`的构造函数中添加了一个`connect`语句。实际上，我们可以在任何地方和任何时候连接信号和槽。然而，连接只有在执行这一行之后才会存在。因此，在构造函数中放置大量的`connect`语句是一种常见的做法。为了更好地理解，运行你的应用程序并看看点击**Hello**按钮时会发生什么。每次点击，都会在纯文本编辑中追加一个**Hello**文本。以下是在我们点击了**Hello**按钮三次之后的截图：
- en: '![Understanding the mechanism of signals and slots](img/4615OS_01_04.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![理解信号和槽的机制](img/4615OS_01_04.jpg)'
- en: Getting confused? Let me walk you through this. When you clicked on the **Hello**
    button, it emitted a clicked signal. Then, the code inside the `displayHello`
    slot got executed, because we connected the clicked signal of the **Hello** button
    to the `displayHello` slot of `MainWindow`. What the `displayHello` slot did is
    that it simply appended `Hello` to the plain text edit.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 感到困惑？让我带你一步步走过这个过程。当你点击**Hello**按钮时，它发出了一个点击信号。然后，`displayHello`槽中的代码被执行，因为我们把**Hello**按钮的点击信号连接到了`MainWindow`的`displayHello`槽。`displayHello`槽所做的是简单地将`Hello`追加到纯文本编辑中。
- en: 'It may take you some time to fully understand the mechanism of signals and
    slots. Just take your time. I''ll show you another example of how to disconnect
    such a connection after we clicked on the **Hola** button. Similarly, add a declaration
    of the slot to the header file and define it in the source file. I pasted the
    content of the `mainwindow.h` header file, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完全理解信号和槽的机制可能需要一些时间。请慢慢来。在我们点击了**Hola**按钮之后，我会给你展示一个如何断开这种连接的例子。同样，将槽的声明添加到头文件中，并在源文件中定义它。我已经粘贴了`mainwindow.h`头文件的内容，如下所示：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It''s only declaring a `onHolaClicked` slot that differed from the original.
    Here''s the content of the source file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是声明了一个与原始版本不同的`onHolaClicked`槽。以下是源文件的内容：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You''ll find that the **Hello** button no longer works after you clicked on
    the **Hola** button. This is because in the `onHolaClicked` slot, we just disconnected
    the binding between the clicked signal of `helloButton` and the `displayHello`
    slot of `MainWindow`. Actually, `disconnect` has some overloaded functions and
    can be used in a more destructive way. For example, you may want to disconnect
    all connections between a specific signal sender and a specific receiver:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现点击了**Hola**按钮之后，**Hello**按钮不再工作。这是因为在我们点击了`onHolaClicked`槽之后，我们只是断开了`helloButton`的点击信号和`MainWindow`的`displayHello`槽之间的绑定。实际上，`disconnect`有一些重载函数，可以用更破坏性的方式使用。例如，你可能想要断开特定信号发送者和特定接收者之间的所有连接：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you want to disconnect all the slots associated with a signal, since a signal
    can be connected to as many slots as you wish, the code can be written like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要断开与一个信号相关联的所有槽，因为一个信号可以连接到任意多个槽，代码可以写成这样：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also disconnect all the signals in an object, whatever slots they might
    be connected to. The following code will disconnect all the signals in `helloButton`,
    which of course includes the clicked signal:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以断开一个对象中的所有信号，无论它们连接到哪个槽。以下代码将断开`helloButton`中的所有信号，当然包括点击信号：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Just like a signal, a slot can be connected to as many signals as you want.
    However, there's no such function to disconnect a specific slot from all the signals.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就像信号一样，槽可以连接到任意多的信号。然而，没有这样的函数可以从所有信号中断开特定槽的连接。
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always remember the signals and slots that you have connected.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 总是记住你连接的信号和槽。
- en: 'Apart from the new syntax for traditional connections of signals and slots,
    Qt 5 has offered a new way to simplify such a binding process with C++11 lambda
    expressions. As you may have noticed, it''s kind of tedious to declare a slot
    in the header file, define it in the source code file, and then connect it to
    a signal. It''s worthwhile if the slot has a lot of statements, otherwise it becomes
    time consuming and increases the complexity. Before we go any further, we need
    to turn on C++11 support on Qt. Edit the pro file (`layout_demo.pro` in my example)
    and add the following line to it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传统的信号和槽连接的新语法之外，Qt 5还提供了一种使用C++11 lambda表达式简化这种绑定过程的新方法。正如你可能已经注意到的，在头文件中声明槽、在源代码文件中定义它，然后将其连接到信号，这有点繁琐。如果槽有很多语句，这很值得，否则它会变得耗时并增加复杂性。在我们继续之前，我们需要在Qt上打开C++11支持。编辑pro文件（我的例子中的`layout_demo.pro`），并向其中添加以下行：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that some old compilers don't support C++11\. If this happens, upgrade
    your compiler.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一些旧的编译器不支持C++11。如果发生这种情况，请升级您的编译器。
- en: 'Now, you need to navigate to **Build** | **Run qmake** to reconfigure the project
    properly. If everything is okay, we can go back to editing the `mainwindow.cpp`
    file. This way, there is no need to declare a slot and define and connect it.
    Just add a `connect` statement to the construction function of `MainWindow`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要导航到**构建** | **运行qmake**来正确地重新配置项目。如果一切正常，我们可以回到编辑`mainwindow.cpp`文件。这样，就没有必要声明槽并定义和连接它。只需向`MainWindow`的构造函数中添加一个`connect`语句即可：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It's very straightforward, isn't it? The third argument is a lambda expression,
    which was added to C++ since C++11.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常直接，不是吗？第三个参数是一个lambda表达式，它自C++11以来被添加到C++中。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more details about lambda expression, visit [http://en.cppreference.com/w/cpp/language/lambda](http://en.cppreference.com/w/cpp/language/lambda).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 关于lambda表达式的更多详细信息，请访问[http://en.cppreference.com/w/cpp/language/lambda](http://en.cppreference.com/w/cpp/language/lambda)。
- en: 'This pair of signal and slot connection is done if you don''t do need to to
    disconnect such a connection. However, if you need, you have to save this connection,
    which is a `QMetaObject::Connection` type. In order to disconnect this connection
    elsewhere, it would be better to declare it as a variable of `MainWindow`. So
    the header file becomes as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要断开这样的连接，则会执行这对信号和槽的连接。但是，如果你需要，你必须保存这个连接，它是一个`QMetaObject::Connection`类型的对象。为了在别处断开这个连接，最好将其声明为`MainWindow`变量的一个变量。因此，头文件变为以下内容：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, I declared `bonjourConnection` as an object of `QMetaObject::Connection`
    so that we can save the connection dealing with an unnamed slot. Similarly, the
    disconnection happens in `onHolaClicked`, so there won''t be any new `Bonjour`
    text on screen after we click on the **Hola** button. Here is the content of `mainwindow.cpp`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将`bonjourConnection`声明为`QMetaObject::Connection`对象，这样我们就可以保存处理未命名槽的连接。同样，断开连接发生在`onHolaClicked`中，因此在我们点击**Hola**按钮后，屏幕上不会出现任何新的“Bonjour”文本。以下是`mainwindow.cpp`的内容：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载示例代码文件，以获取您购买的所有Packt
    Publishing书籍。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: This is indeed another new usage of `disconnect`. It takes in a `QMetaObject::Connection`
    object as the only argument. You'll thank this new overloaded function if you're
    going to use the lambda expression as a slot.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是`disconnect`的另一种新用法。它只接受一个`QMetaObject::Connection`对象作为参数。如果你打算将lambda表达式用作槽，你会感谢这个新重载函数。
- en: Connecting two signals
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接两个信号
- en: 'Due to the weak couplings of the Qt signals and slot mechanisms, it is viable
    to bind signals to each other. It may sound confusing, so let me draw a diagram
    to make it clear:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Qt 信号和槽机制的弱耦合，将信号绑定到彼此是可行的。这听起来可能有些令人困惑，所以让我画一个图表来使其更清晰：
- en: '![Connecting two signals](img/4615OS_01_05.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![连接两个信号](img/4615OS_01_05.jpg)'
- en: 'When an event triggers a specific signal, this emitted signal could be another
    event, which will emit another specific signal. It is not a very common practice,
    but it tends to be useful when you deal with some complex signals and slot connection
    networks, especially when tons of events lead to the emission of only a few signals.
    Although it definitely increases the complexity of the project, binding these
    signals could simplify the code a lot. Append the following statement to the construction
    function of `MainWindow`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个事件触发一个特定信号时，这个发出的信号可能是一个事件，它将发出另一个特定信号。这并不是一个非常常见的做法，但当您处理一些复杂的信号和槽连接网络时，它往往很有用，尤其是当大量事件导致仅发出几个信号时。尽管这肯定会增加项目的复杂性，但绑定这些信号可以大大简化代码。将以下语句添加到
    `MainWindow` 的构造函数中：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You''ll get two lines in a plain text edit after you click on the **Bonjour**
    button. The first line is **Bonjour** and the second one is **Hello**. Apparently,
    this is because we coupled the clicked signal of the **Bonjour** button with the
    clicked signal of the **Hello** button. The clicked signal of the latter has already
    been coupled with a slot, which results in the new text line, **Hello**. In fact,
    it has the same effect as the following statement:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在您点击 **Bonjour** 按钮后，您将在纯文本编辑器中看到两行。第一行是 **Bonjour**，第二行是 **Hello**。显然，这是因为我们将
    **Bonjour** 按钮的点击信号与 **Hello** 按钮的点击信号耦合起来。后者的点击信号已经与一个槽耦合，这导致了新的文本行 **Hello**。实际上，它具有与以下语句相同的效果：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Basically, connecting two signals is a simplified version of connecting a signal
    and a slot, while the slot is meant to emit another signal. As for priority, the
    slot(s) of the latter signal will be handled when the event loop is returned to
    the object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，连接两个信号是连接信号和槽的简化版本，而槽的目的是发出另一个信号。至于优先级，后一个信号的槽将在事件循环返回到对象时被处理。
- en: However, it is impossible to connect two slots because the mechanism requires
    a signal while a slot is considered a receiver instead of a sender. Therefore,
    if you want to simplify the connection, just wrap these slots as one slot, which
    can be used for connections.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于机制要求一个信号，而槽被看作是接收者而不是发送者，因此无法连接两个槽。因此，如果您想简化连接，只需将这些槽封装为一个槽，它可以用于连接。
- en: Creating a Qt Quick application
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 Qt Quick 应用程序
- en: We already covered how to create a Qt (C++) application. How about giving the
    newly introduced Qt Quick application development a try? Qt Quick was introduced
    in Qt 4.8 and it is now becoming mature in Qt 5\. Because the QML file is usually
    platform-independent, it enables you to develop an application for multiple targets,
    including mobile operating systems with the same code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何创建一个 Qt (C++) 应用程序。那么，尝试一下新引入的 Qt Quick 应用程序开发如何？Qt Quick 自 Qt 4.8
    以来被引入，现在在 Qt 5 中已经变得成熟。由于 QML 文件通常是平台无关的，它使您能够使用相同的代码为多个目标开发应用程序，包括移动操作系统。
- en: 'In this chapter, I''ll show you how to create a simple Qt Quick application
    based on Qt Quick Controls 1.2, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您展示如何创建一个基于 Qt Quick Controls 1.2 的简单 Qt Quick 应用程序，具体如下：
- en: Create a new project named `HelloQML`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `HelloQML` 的新项目。
- en: Select **Qt Quick Application** instead of **Qt Widgets Application**, which
    we chose previously.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Qt Quick Application** 而不是我们之前选择的 **Qt Widgets Application**。
- en: Select **Qt Quick Controls 1.2** when the wizard navigates you to **Select Qt
    Quick Components Set**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当向导引导您到 **选择 Qt Quick 组件集** 时，选择 **Qt Quick Controls 1.2**。
- en: Qt Quick Controls has been introduced since Qt 5.1 and is highly recommended
    because it enables you to build a complete and native user interface. You can
    also control the top-level window properties from QML. Getting confused by QML
    and Qt Quick?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick Controls 自 Qt 5.1 以来已被引入，并且强烈推荐使用，因为它使您能够构建一个完整且本地的用户界面。您还可以从 QML 控制顶级窗口属性。对
    QML 和 Qt Quick 感到困惑？
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: QML is a user interface specification and programming language. It allows developers
    and designers alike to create highly performant, fluidly animated, and visually
    appealing applications. QML offers a highly readable, declarative, JSON-like syntax
    with support for imperative JavaScript expressions combined with dynamic property
    bindings.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: QML 是一种用户界面规范和编程语言。它允许开发者和设计师创建高性能、流畅动画和视觉吸引力的应用程序。QML 提供了一种高度可读的、声明性的、类似 JSON
    的语法，并支持命令式 JavaScript 表达式与动态属性绑定的结合。
- en: While Qt Quick is the standard library for QML, it sounds like the relation
    between STL and C++. The difference is that QML is dedicated to user interface
    design and Qt Quick includes a lot of visual types, animations, and so on. Before
    we go any further, I want to inform you that QML is different from C++ but similar
    to JavaScript and JSON.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Qt Quick 是 QML 的标准库，但它听起来与 STL 和 C++ 之间的关系相似。不同之处在于 QML 专注于用户界面设计，Qt Quick
    包含了许多视觉类型、动画等功能。在我们继续之前，我想通知您，QML 与 C++ 不同，但与 JavaScript 和 JSON 相似。
- en: 'Edit the `main.qml` file under the root of the `Resources` file, `qml.qrc`,
    which Qt Creator has generated for our new Qt Quick project. Let''s see how the
    code should be:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑位于 `Resources` 文件根目录下的 `main.qml` 文件，`qml.qrc`，这是 Qt Creator 为我们新的 Qt Quick
    项目生成的。让我们看看代码应该如何编写：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you have ever touched Java or Python, the first two lines won't be too unfamiliar
    to you. It simply imports Qt Quick and Qt Quick Controls, and the number following
    is the version of the library. You may need to change the version if there is
    a newer library. Importing other libraries is a common practice when developing
    Qt Quick applications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经接触过 Java 或 Python，前两行对您来说不会太陌生。它只是简单地导入 Qt Quick 和 Qt Quick Controls，后面的数字是库的版本号。如果您有更新的库，可能需要更改版本。在开发
    Qt Quick 应用程序时，导入其他库是一种常见做法。
- en: The body of this QML source file is actually in the JSON style, which enables
    you to understand the hierarchy of the user interface through the code. Here,
    the root item is `ApplicationWindow`, which is basically the same thing as `MainWindow`
    in the previous topics, and we use braces to enclose the statements just like
    in a JSON file. Although you could use a semicolon to mark an ending of a statement
    just like we do in C++, there is no need to do this. As you can see, the property
    definition needs a colon if it's a single-line statement and enclosing braces
    if it contains more than one subproperty.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 QML 源文件的主体实际上采用了 JSON 风格，这使得您可以通过代码理解用户界面的层次结构。在这里，根项是 `ApplicationWindow`，这基本上与前面主题中的
    `MainWindow` 相同，我们使用大括号来包围语句，就像在 JSON 文件中一样。虽然您可以使用分号来标记语句的结束，就像我们在 C++ 中做的那样，但这样做是没有必要的。正如您所看到的，如果属性定义是单行语句，则需要冒号；如果包含多个子属性，则需要大括号。
- en: The statements are kind of self explanatory and they are similar to the properties
    that we saw in the Qt Widgets application. A `qsTr` function is used for internationalization
    and localization. Strings marked by `qsTr` could be translated by Qt Linguist.
    In addition to this, you don't need to care about QString and `std::string` any
    more. All the strings in QML are encoded in the same coding as the QML file and
    the QML file is created in UTF-8 by default.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语句相当自解释，并且与我们在 Qt Widgets 应用程序中看到的属性相似。`qsTr` 函数用于国际化本地化。被 `qsTr` 标记的字符串可以被
    Qt Linguist 翻译。除此之外，您再也不需要关心 `QString` 和 `std::string` 了。QML 中的所有字符串都使用与 QML 文件相同的编码，并且
    QML 文件默认以 UTF-8 编码创建。
- en: As for the signals and slots mechanism in Qt Quick, it's easy if you only use
    QML to write the callback function to the corresponding slot. Here, we execute
    `Qt.quit()` inside the `onTriggered` slot of `MenuItem`. It's viable to connect
    the signal of a QML item to a C++ object's slot, which I'll introduce later.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 Qt Quick 中的信号和槽机制，如果您只使用 QML 编写回调函数到相应的槽，那么它很容易。在这里，我们在 `MenuItem` 的 `onTriggered`
    槽中执行 `Qt.quit()`。将 QML 项的信号连接到 C++ 对象的槽是可行的，我将在后面介绍。
- en: 'When you run this application in Windows, you can barely find the difference
    between the `Text` item and the `Label` item. However, on some platforms, or when
    you change the system font and/or its color, you''ll find that `Label` follows
    the font and the color scheme of the system, while `Text` doesn''t. Although you
    can use the properties of `Text` to customize the appearance of `Label`, it would
    be better to use the system settings to keep the looks of the application native.
    Well, if you run this application right now, it will appear similar to what is
    shown in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Windows 上运行此应用程序时，你几乎找不到 `Text` 项和 `Label` 项之间的区别。然而，在某些平台或更改系统字体及其颜色时，你会发现
    `Label` 会遵循系统的字体和颜色方案，而 `Text` 则不会。虽然你可以使用 `Text` 的属性来自定义 `Label` 的外观，但使用系统设置以保持应用程序的本地外观会更好。好吧，如果你现在运行这个应用程序，它将看起来与以下截图所示相似：
- en: '![Creating a Qt Quick application](img/4615OS_01_06.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Qt Quick 应用程序](img/4615OS_01_06.jpg)'
- en: Because there is no separate UI file for the Qt Quick applications, only a QML
    file, we use the `anchors` property to position the items, and `anchors.centerIn`
    will position the item in the center of the parent. There is an integrated Qt
    Quick Designer in Qt Creator, which could help you design the user interface of
    a Qt Quick application. If you need it, just navigate to **Design** mode when
    you're editing a QML file. However, I suggest you stay in **Edit** mode to understand
    the meaning of each statement.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Qt Quick 应用程序没有单独的 UI 文件，只有一个 QML 文件，我们使用 `anchors` 属性来定位项目，`anchors.centerIn`
    将项目定位在父级的中心。Qt Creator 中有一个集成的 Qt Quick 设计器，可以帮助你设计 Qt Quick 应用的用户界面。如果你需要它，只需在编辑
    QML 文件时导航到 **设计** 模式。然而，我建议你保持在 **编辑** 模式下，以便理解每个语句的含义。
- en: Connecting C++ slots to QML signals
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接 C++ 插槽到 QML 信号
- en: The separation of the user interface and backend allows us to connect C++ slots
    to the QML signals. Although it's possible to write processing functions in QML
    and manipulate interface items in C++, it violates the principle of the separation.
    Therefore, you may want to know how to connect a C++ slot to a QML signal at first.
    As for connecting a QML slot to a C++ signal, I'll introduce that later in this
    book.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面和后端的分离使我们能够将 C++ 插槽连接到 QML 信号。虽然可以在 QML 中编写处理函数并在 C++ 中操作界面元素，但这违反了分离原则。因此，你可能首先想知道如何将
    C++ 插槽连接到 QML 信号。至于将 QML 插槽连接到 C++ 信号，我将在本书的后面介绍。
- en: 'In order to demonstrate this, we need to create a C++ class in the first place
    by right-clicking on the project in the **Projects** panel and selecting **Add
    New…**. Then, click on **C++ Class** in the pop-up window. The newly created class
    should at least inherit from `QObject` by choosing `QObject` as its base class.
    This is because a plain C++ class can''t include Qt''s slots or signals. The header
    file''s content is displayed as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们首先需要在 **项目** 面板中右键单击项目，并选择 **添加新…**。然后在弹出的窗口中点击 **C++ 类**。新创建的类至少应该通过选择
    `QObject` 作为其基类来继承 `QObject`。这是因为一个普通的 C++ 类不能包含 Qt 的插槽或信号。头文件的内容如下所示：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here''s the content of the source file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是源文件的内容：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The C++ file is the same as the one we dealt with in the previous topics. The
    `onMenuClicked` slot I defined is simply to output the string that passes through
    the signal. Note that you have to include `QDebug` if you want to use the built-in
    functions of `qDebug`, `qWarning`, `qCritical`, and so on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 文件与我们在前几节中处理的是同一个。我定义的 `onMenuClicked` 插槽仅仅是为了输出通过信号的字符串。请注意，如果你想使用 `qDebug`、`qWarning`、`qCritical`
    等内置函数，你必须包含 `QDebug`。
- en: 'The slot is prepared, so we need to add a signal to the QML file. The QML file
    is changed to the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽已经准备好了，因此我们需要在 QML 文件中添加一个信号。QML 文件修改为以下代码：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, I specified the ID of the root `ApplicationWindow` item to window
    and declared a signal named `menuClicked`. In addition to this, there is another
    `MenuItem` in the menu file. It emits the `menuClicked` signal of window, using
    its text as the parameter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我指定了根 `ApplicationWindow` 项的 ID 为窗口，并声明了一个名为 `menuClicked` 的信号。除此之外，菜单文件中还有一个
    `MenuItem`。它使用其文本作为参数，发出窗口的 `menuClicked` 信号。
- en: Now, let's connect the slot in the C++ file to this newly created QML signal.
    Edit the `main.cpp` file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将 C++ 文件中的插槽连接到这个新创建的 QML 信号。编辑 `main.cpp` 文件。
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The item in the QML file is accessed as `QObject` in C++ and it could be cast
    to `QQuickItem`. For now, we only need to connect its signal, so `QObject` will
    do.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 QML 文件中的项以 `QObject` 的形式在 C++ 中访问，并且它可以被转换为 `QQuickItem`。目前，我们只需要连接其信号，所以
    `QObject` 就足够了。
- en: You may notice that I used the old-style syntax of the `connect` statement.
    This is because QML is dynamic and the C++ compiler can't detect the existence
    of the signal in the QML file. Since things in QML are checked at runtime, it
    doesn't make sense to use the old syntax here.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我使用了 `connect` 语句的老式语法。这是因为 QML 是动态的，C++ 编译器无法检测 QML 文件中信号的存在。由于 QML
    中的事物是在运行时检查的，所以在这里使用老式语法是没有意义的。
- en: 'When you run this application and navigate to **File** | **Click Me** in the
    menu bar, you''ll see **Application Output** in Qt Creator:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行此应用程序并导航到菜单栏中的 **文件** | **点击我** 时，你将在 Qt Creator 中看到 **应用程序输出**：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's review this process again. Triggering the `Click Me` menu item resulted
    in the emission of the window's signal `menuClicked`. This signal passed the text
    of `MenuItem`, which is `Click Me`, to the slot in C++ class `Processor`, and
    the processor `myProcessor` slot `onMenuClicked` printed the string to the **Application
    Output** panel.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回顾这个过程。触发 **点击我** 菜单项导致窗口的信号 `menuClicked` 被发射。这个信号将 `MenuItem` 的文本（`点击我`）传递给
    C++ 类 `Processor` 中的槽，处理器 `myProcessor` 的槽 `onMenuClicked` 将字符串打印到 **应用程序输出**
    面板。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the fundamentals of Qt, which included steps for
    how to create a Qt application. Then, we had a walk-through of both Qt Widgets
    and Qt Quick, and how to change the layout. Finally, we rounded off by covering
    an important concept about the mechanism of signals and slots.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Qt 的基础知识，包括创建 Qt 应用程序的步骤。然后，我们了解了 Qt Widgets 和 Qt Quick 的使用，以及如何更改布局。最后，我们通过介绍关于信号和槽机制的重要概念来结束本章。
- en: In the next chapter, we will have a chance to put this knowledge into practice
    and get started on building a real-world, and of course cross-platform, Qt application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将有机会将所学知识付诸实践，并开始构建一个真实世界、当然也是跨平台的 Qt 应用程序。
