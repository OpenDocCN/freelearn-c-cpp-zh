- en: Chapter 9. Using LLVM for Various Useful Projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章：使用 LLVM 进行各种有用的项目
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Exception handling in LLVM
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 中的异常处理
- en: Using sanitizers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 sanitizers
- en: Writing the garbage collector with LLVM
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LLVM 编写垃圾收集器
- en: Converting LLVM IR to JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 LLVM IR 转换为 JavaScript
- en: Using the Clang Static Analyzer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Clang 静态分析器
- en: Using bugpoint
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 bugpoint
- en: Using LLDB
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LLDB
- en: Using LLVM utility passes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LLVM 工具传递
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Until now, you have learned how to write the frontend of a compiler, write optimizations
    and create a backend. In this chapter, the last of this book, we will look into
    some other features that the LLVM infrastructure provides and how we can use them
    in our projects. We won't be diving very deep into the details of the topics in
    this chapter. The main point is to let you know about these important tools and
    techniques, which are hot points in LLVM.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了如何编写编译器的前端，编写优化并创建后端。在本章，本书的最后一章，我们将探讨 LLVM 基础设施提供的一些其他功能以及我们如何在项目中使用它们。我们不会深入探讨本章主题的细节。主要目的是让你了解这些重要的工具和技术，它们是
    LLVM 中的热点。
- en: Exception handling in LLVM
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLVM 中的异常处理
- en: In this recipe, we will look into the exception handling infrastructure of LLVM.
    We will discuss how the exception handling information looks in the IR and the
    intrinsic functions provided by LLVM for exception handling.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将探讨 LLVM 的异常处理基础设施。我们将讨论异常处理信息在 IR 中的外观以及 LLVM 为异常处理提供的内建函数。
- en: Getting ready...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: You must understand how exception handling works normally and the concepts of
    `try`, `catch` and `throw` and so on. You must also have Clang and LLVM installed
    in your path.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须理解异常处理是如何正常工作的，以及 `try`、`catch` 和 `throw` 等概念。你还需要在路径中安装 Clang 和 LLVM。
- en: How to do it…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We will take an example to describe how exception handling works in LLVM:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个例子来描述在 LLVM 中异常处理是如何工作的：
- en: 'Open a file to write down the source code, and enter the source code to test
    exception handling:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个文件来写下源代码，并输入源代码以测试异常处理：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Generate the bitcode file using the following command:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令生成位码文件：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To view the IR on the screen, run the following command, which will give you
    the output as shown:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在屏幕上查看 IR，请运行以下命令，它将给出如下所示的输出：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In LLVM, if an exception is thrown, the runtime tries its best to find a handler.
    It tries to find an exception frame corresponding to the function where the exception
    was thrown. This exception frame contains a reference to the exception table,
    which contains the implementation—how to handle the exception when a programming
    language supports exception handling. When the language does not support exception
    handling, the information on how to unwind the current activation and restore
    the state of the prior activation is found in this exception frame.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LLVM 中，如果抛出异常，运行时会尽力找到一个处理程序。它会尝试找到与抛出异常的函数相对应的异常帧。这个异常帧包含对异常表的引用，该表包含实现——当编程语言支持异常处理时如何处理异常。当语言不支持异常处理时，如何展开当前激活并恢复先前激活的状态的信息就包含在这个异常帧中。
- en: Let's look at the preceding example to see how to generate exception handling
    code with LLVM.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前面的例子，看看如何使用 LLVM 生成异常处理代码。
- en: 'The `try` block is translated to invoke instruction in LLVM:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 块被翻译为调用 LLVM 的指令：'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding line tells the compiler how it should handle an exception if
    the `throw_exception` function throws it. If no exception is thrown, then normal
    execution will take place through the `%5` label. But if an exception is thrown,
    it will branch into the `%6` label, which is the landing pad. This corresponds
    roughly to the `catch` portion of a `try`/`catch` sequence. When execution resumes
    at a landing pad, it receives an exception structure and a selector value corresponding
    to the type of exception thrown. The selector is then used to determine which
    `catch` function should actually process the exception. In this case, it looks
    something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行告诉编译器如果 `throw_exception` 函数抛出异常时应该如何处理异常。如果没有抛出异常，则正常执行将通过 `%5` 标签进行。但如果抛出异常，它将分支到
    `%6` 标签，即着陆地。这大致对应于 `try`/`catch` 序列中的 `catch` 部分。当执行在着陆地恢复时，它接收一个异常结构和与抛出异常类型相对应的选择器值。然后选择器被用来确定哪个
    `catch` 函数应该实际处理异常。在这种情况下，它看起来像这样：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `%7` in the preceding code snippet represents the information describing
    the exception. The `{ i8*, i32 }` part of the code describes the type of information.
    The `i8*` part of the code represents the exception pointer part, and `i32` is
    the selector value. In this case, we have only one selector value, as the `catch`
    function accepts all types of exception objects thrown. The `@__gxx_personality_v0`
    function is the `personality` function. It receives the context of the exception,
    an exception structure containing the exception object type and value, and a reference
    to the exception table for the current function. The personality function for
    the current compile unit is specified in a common exception frame. In our case,
    the `@__gxx_personality_v0` function represents the fact that we are dealing with
    C++ exceptions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的 `%7` 表示异常描述信息。代码中的 `{ i8*, i32 }` 部分描述了信息的类型。代码中的 `i8*` 部分表示异常指针部分，而
    `i32` 是选择器值。在这种情况下，我们只有一个选择器值，因为 `catch` 函数接受所有类型的异常对象。`@__gxx_personality_v0`
    函数是 `personality` 函数。它接收异常的上下文，一个包含异常对象类型和值的异常结构，以及当前函数的异常表引用。当前编译单元的 `personality`
    函数在公共异常帧中指定。在我们的例子中，`@__gxx_personality_v0` 函数表示我们正在处理 C++ 异常。
- en: So, the `%8 = extractvalue { i8*, i32 } %7, 0` will represent the exception
    object, and `%9 = extractvalue { i8*, i32 } %7, 1` represents the selector value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`%8 = extractvalue { i8*, i32 } %7, 0` 将表示异常对象，而 `%9 = extractvalue { i8*,
    i32 } %7, 1` 表示选择器值。
- en: 'The following are some noteworthy IR functions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些值得注意的 IR 函数：
- en: '`__cxa_throw`: This is a function used to throw an exception'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__cxa_throw`：这是一个用于抛出异常的函数'
- en: '`__cxa_begin_catch`: This takes an exception structure reference as an argument
    and returns the value of the exception object'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__cxa_begin_catch`：这个函数接受一个异常结构引用作为参数，并返回异常对象的值'
- en: '`__cxa_end_catch`: This locates the most recently caught exception and decrements
    its handler count, removing the exception from the caught state if this counter
    goes down to zero'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__cxa_end_catch`：这个函数定位最近捕获的异常，并减少其处理程序计数，如果这个计数器降到零，则从捕获状态中移除异常'
- en: See also
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: To understand the exception format used by LLVM, go to [http://llvm.org/docs/ExceptionHandling.html#llvm-code-generation](http://llvm.org/docs/ExceptionHandling.html#llvm-code-generation).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解 LLVM 使用的异常格式，请访问 [http://llvm.org/docs/ExceptionHandling.html#llvm-code-generation](http://llvm.org/docs/ExceptionHandling.html#llvm-code-generation)。
- en: Using sanitizers
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用清理器
- en: You might have used tools such as **Valgrind** for memory debugging. LLVM also
    provides us with tools for memory debugging, such as the address sanitizer, memory
    sanitizer, and so on. These tools are very fast compared to Valgrind, even though
    they are not as mature as Valgrind. Most of these tools are in their experimental
    stage, so if you want, you can contribute to the open source development of these
    tools.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经使用过 **Valgrind** 等工具进行内存调试。LLVM 也为我们提供了内存调试的工具，如地址清理器、内存清理器等。与 Valgrind
    相比，这些工具非常快速，尽管它们不如 Valgrind 成熟。大多数这些工具都处于实验阶段，所以如果你愿意，你可以为这些工具的开源开发做出贡献。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To make use of these sanitizers, we need to check out the code for `compiler-rt`
    from the LLVM SVN:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些清理器，我们需要从 LLVM SVN 检出 `compiler-rt` 代码：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Build LLVM as we did in [Chapter 1](part0015.xhtml#aid-E9OE1 "Chapter 1. LLVM
    Design and Use"), *LLVM Design and Use*. By doing so, we get the runtime libraries
    required.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们在 [第 1 章](part0015.xhtml#aid-E9OE1 "第 1 章。LLVM 设计和使用") 中所做的那样构建 LLVM，*LLVM
    设计和使用*。通过这样做，我们得到所需的运行时库。
- en: How to do it…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Now, we will test the address sanitizer on a test code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对测试代码进行地址清理器的测试。
- en: 'Write a test case to check the address sanitizer:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试用例来检查地址清理器：
- en: '[PRE6]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Compile the test code using the `fsanitize=address` `command-line argument`
    for using the address sanitizer:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `fsanitize=address` 命令行参数编译测试代码以使用地址清理器：
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Generate the output of running the address sanitizer using the following command:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令生成地址清理器的输出：
- en: '[PRE8]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s the output:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '![How to do it…](img/image00268.jpeg)'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/image00268.jpeg)'
- en: How it works…
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The LLVM address sanitizer works on the principle of code instrumentation.
    The tool consists of a compiler instrumentation module and a runtime library.
    The code instrumentation part is done by the pass of LLVM, which runs on passing
    the `fsanitize=address` command-line argument, as is done in the preceding example.
    The runtime library replaces the `malloc` and `free` functions in the code with
    custom-made code. Before we go ahead and discuss the details of how code instrumentation
    is done, here we must know that the virtual address space is divided into two
    disjointed classes: the main application memory, which is used by the regular
    application code; and the shadow memory, which contains the shadow values (or
    metadata).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM地址清理器基于代码插桩的原则。该工具由一个编译器插桩模块和一个运行时库组成。代码插桩部分是通过LLVM的pass完成的，它通过传递`fsanitize=address`命令行参数来运行，就像前面的例子中那样。运行时库用自定义代码替换代码中的`malloc`和`free`函数。在我们继续讨论代码插桩的细节之前，我们必须知道虚拟地址空间被分为两个不相交的类别：主应用程序内存，它被常规应用程序代码使用；以及影子内存，它包含影子值（或元数据）。
- en: The shadow memory and the main application memory are linked to each other.
    Poisoning a byte in the main memory means writing a special value into the corresponding
    shadow memory.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 影子内存和主应用程序内存相互链接。在主内存中污染一个字节意味着将特殊值写入相应的影子内存。
- en: Let's come back to the address sanitizer; the memory around the regions allocated
    by the `malloc` function is poisoned. The memory freed by the `free` function
    is placed in quarantine and is also poisoned. Every memory access in the program
    is transformed by the compiler in the following way.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到地址清理器的主题；由`malloc`函数分配的区域周围的内存被污染。由`free`函数释放的内存被置于隔离区，并且也被污染。程序中的每次内存访问都会被编译器以以下方式转换。
- en: 'At first, it is like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，它看起来是这样的：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After transformation, it becomes the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换后，它变成了以下内容：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This means that if it finds any invalid access to this memory, it reports an
    error.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果它发现对这块内存的任何无效访问，它会报告一个错误。
- en: In the preceding example, we wrote a piece of code for a buffer overrun, accessing
    an array that is out of bounds. Here, the instrumentation of code is done on the
    address just before and after the array. So, when we access the array beyond its
    upper bound, we try accessing the red zone. Hence, the address sanitizer gives
    us a stack buffer overflow report.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们为缓冲区溢出编写了一段代码，访问了一个越界的数组。在这里，代码的仪器是在数组的正前负后地址上进行的。因此，当我们访问数组超出其上界时，我们尝试访问红色区域。因此，地址清理器给我们提供了堆栈缓冲区溢出报告。
- en: See also…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见以下内容…
- en: You can check out the documentation page at [http://clang.llvm.org/docs/AddressSanitizer.html](http://clang.llvm.org/docs/AddressSanitizer.html)
    for more information.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以查看[http://clang.llvm.org/docs/AddressSanitizer.html](http://clang.llvm.org/docs/AddressSanitizer.html)上的文档页面以获取更多信息。
- en: 'You can also check out the other sanitizers in LLVM using the following links:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以通过以下链接查看LLVM中的其他清理器：
- en: '[http://clang.llvm.org/docs/MemorySanitizer.html](http://clang.llvm.org/docs/MemorySanitizer.html)'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://clang.llvm.org/docs/MemorySanitizer.html](http://clang.llvm.org/docs/MemorySanitizer.html)'
- en: '[http://clang.llvm.org/docs/ThreadSanitizer.html](http://clang.llvm.org/docs/ThreadSanitizer.html)'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://clang.llvm.org/docs/ThreadSanitizer.html](http://clang.llvm.org/docs/ThreadSanitizer.html)'
- en: '[https://code.google.com/p/address-sanitizer/wiki/LeakSanitizer](https://code.google.com/p/address-sanitizer/wiki/LeakSanitizer)'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://code.google.com/p/address-sanitizer/wiki/LeakSanitizer](https://code.google.com/p/address-sanitizer/wiki/LeakSanitizer)'
- en: Writing the garbage collector with LLVM
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LLVM编写垃圾回收器
- en: Garbage collection is a technique of memory management where the collector tries
    to reclaim the memory occupied by objects that are no longer in use. This frees
    the programmer from of being required to keep track of the lifetimes of heap objects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收是一种内存管理技术，其中回收器试图回收不再使用的对象占用的内存。这使程序员免于跟踪堆对象的生存期。
- en: In this recipe, we will see how to integrate LLVM into a compiler for a language
    that supports garbage collection. LLVM does not itself provide a garbage collector,
    but provides a framework for describing the garbage collector's requirements to
    the compiler.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解如何将LLVM集成到支持垃圾回收的语言的编译器中。LLVM本身不提供垃圾回收器，但提供了一个框架来描述垃圾回收器对编译器的要求。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: LLVM must be built and installed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 必须构建和安装LLVM。
- en: How to do it…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will see in the following recipe how the LLVM IR code, with garbage collection
    intrinsic functions, is converted to the corresponding machine assembly code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的配方中，我们将看到带有垃圾回收内置函数的 LLVM IR 代码是如何转换为相应的机器汇编代码的：
- en: 'Write the test code:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写测试代码：
- en: '[PRE11]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Use the `llc` tool to generate the assembly code and view the assembly code
    using the `cat` command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `llc` 工具生成汇编代码，并使用 `cat` 命令查看汇编代码：
- en: '[PRE12]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In the preceding code, in the main function, we are using the built-in GC collector
    strategy called `shadow-stack`, which maintains a linked list of stack `roots()`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码的主函数中，我们正在使用名为 `shadow-stack` 的内置 GC 收集器策略，该策略维护一个堆栈 `roots()` 的链表：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It mirrors the machine stack. We can provide any other technique, if we want
    to, by specifying its name after the function name in this format, `gc "strategy
    name"`. This strategy name can either be the built-in strategy or our own custom
    strategy for garbage collection.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它反映了机器堆栈。如果我们想的话，可以通过在此格式中指定函数名称后的名称来提供任何其他技术，即 `gc "策略名称"`。这个策略名称可以是内置策略，也可以是我们自己的自定义垃圾回收策略。
- en: 'To identify the roots, that is, the references to the heap object, LLVM makes
    use of the intrinsic function `@llvm.gcroot` or `the .statepoint` relocation sequence.
    The `llvm.gcroot` intrinsic function informs LLVM that a stack variable references
    an object on the heap and it needs to be tracked by the collector. In the preceding
    code, the following line is the call to the `llvm.gcroot` function to mark the
    `%tmp.1` stack variable:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别根，即对堆对象的引用，LLVM 使用内置函数 `@llvm.gcroot` 或 `.statepoint` 重定位序列。`llvm.gcroot`
    内置函数通知 LLVM，一个栈变量引用了堆上的对象，并且它需要被收集器跟踪。在前面代码中，以下行是调用 `llvm.gcroot` 函数以标记 `%tmp.1`
    栈变量的调用：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `llvm.gcwrite` function is a write barrier. This means that whenever a
    program on which garbage collection is being done, it writes a pointer to a field
    of a heap object, the collector is informed about that. The `llvm.gcread` intrinsic
    function is also present, which informs the garbage collector when the program
    reads a pointer to a field of a heap object. The following line of code writes
    the `%A.1` value to the `%B.upgrd` heap object:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm.gcwrite` 函数是一个写屏障。这意味着每当对正在执行垃圾回收的程序进行写操作时，它都会将指向堆对象字段的指针写入，收集器会被告知这一点。`llvm.gcread`
    内置函数也存在，它在程序读取指向堆对象字段的指针时通知垃圾回收器。以下代码行将 `%A.1` 的值写入 `%B.upgrd` 堆对象：'
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that LLVM does not provide a garbage collector. It should be a part of
    the runtime library of the language. The preceding explanation deals with the
    infrastructure that LLVM provides for describing garbage collector requirements
    to the compiler.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，LLVM 不提供垃圾回收器。它应该是语言运行时库的一部分。前面的解释处理了 LLVM 为描述垃圾回收器要求向编译器提供的基础设施。
- en: See also
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See [http://llvm.org/docs/GarbageCollection.html](http://llvm.org/docs/GarbageCollection.html)
    for the documentation on garbage collection.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 [http://llvm.org/docs/GarbageCollection.html](http://llvm.org/docs/GarbageCollection.html)
    了解垃圾回收的文档。
- en: Also, check out [http://llvm.org/docs/Statepoints.html](http://llvm.org/docs/Statepoints.html)
    for an alternative method of garbage collection.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还可以查看 [http://llvm.org/docs/Statepoints.html](http://llvm.org/docs/Statepoints.html)
    了解垃圾回收的另一种方法。
- en: Converting LLVM IR to JavaScript
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 LLVM IR 转换为 JavaScript
- en: In this recipe, we will briefly discuss how we can convert LLVM IR to JavaScript.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将简要讨论如何将 LLVM IR 转换为 JavaScript。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To convert IR to JavaScript, perform the following steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 IR 转换为 JavaScript，执行以下步骤：
- en: We will make use of the `emscripten` LLVM to JavaScript compiler. You need to
    download the SDK provided at [https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html)
    . You can also build it from the source code, but just for experimenting, you
    can use the SDK that comes with the toolchain.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `emscripten` LLVM 到 JavaScript 编译器。您需要下载在 [https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html](https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html)
    提供的 SDK。您也可以从源代码构建它，但仅用于实验，您可以使用工具链中包含的 SDK。
- en: After downloading the SDK, extract it to a location and go to the root folder
    of the download.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 SDK 后，将其解压缩到指定位置，并转到下载的根目录。
- en: Install the `default-jre`, `nodejs`, `cmake`, `build-essential`, and `git` dependencies.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `default-jre`、`nodejs`、`cmake`、`build-essential` 和 `git` 依赖项。
- en: 'Execute the following commands to install the SDK:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令以安装 SDK：
- en: '[PRE16]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: See the `~/emscripten` script to check whether it has the correct values, and
    if not, update it accordingly.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看位于 `~/emscripten` 的脚本，以检查其是否具有正确的值，如果不是，则相应地更新它。
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Write the test code for the conversion:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写转换的测试代码：
- en: '[PRE17]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Convert the code to the LLVM IR:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码转换为 LLVM IR：
- en: '[PRE18]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now use the `emcc` executable located in the `emsdk_portable/emscripten/master`
    directory to take this `.ll` file as the input and convert it into JavaScript:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在请使用位于 `emsdk_portable/emscripten/master` 目录中的 `emcc` 可执行文件，将此 `.ll` 文件作为输入并转换为
    JavaScript：
- en: '[PRE19]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output file generated is the `a.out.js` file. We can execute this file
    using the following command:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的输出文件是 `a.out.js` 文件。我们可以使用以下命令执行此文件：
- en: '[PRE20]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See more
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看更多
- en: To know more details, visit [https://github.com/kripken/emscripten](https://github.com/kripken/emscripten)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多细节，请访问 [https://github.com/kripken/emscripten](https://github.com/kripken/emscripten)
- en: Using the Clang Static Analyzer
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Clang 静态分析器
- en: In this recipe, you will learn about the static analysis of code, which is carried
    out by the **Clang Static Analyzer**. It is built on top of Clang and LLVM. The
    static analysis engine used by the Clang Static Analyzer is a Clang library, and
    it has the capability to be reused in different contexts by different clients.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解由 **Clang 静态分析器** 执行的代码静态分析。它是建立在 Clang 和 LLVM 之上的。Clang 静态分析器使用的静态分析引擎是一个
    Clang 库，并且它具有在不同上下文中被不同客户端重用的能力。
- en: We will take the example of the divide-by-zero defect and show you how the Clang
    Static Analyzer handles this defect.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以除以零缺陷为例，向你展示 Clang 静态分析器如何处理这个缺陷。
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to build and install LLVM along with Clang.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要构建和安装 LLVM 以及 Clang。
- en: How to do it…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create a test file and write the test code in it:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试文件并在其中编写测试代码：
- en: '[PRE21]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the Clang Static Analyzer by passing the command-line options shown in
    the following command, and get the output on the screen:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递以下命令中显示的命令行选项运行 Clang 静态分析器，并在屏幕上获取输出：
- en: '[PRE22]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The static analyzer core performs the symbolic execution of the program. The
    input values are represented by symbolic values. The values of the expressions
    are calculated by the analyzer using the input symbol and the path. The execution
    of the code is path-sensitive, and hence every possible path is analyzed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析器核心执行程序的符号执行。输入值由符号值表示。表达式的值由分析器使用输入符号和路径计算得出。代码的执行是路径敏感的，因此分析每个可能的路径。
- en: While executing, the execution traces are represented by an exploded graph.
    Each node of this `ExplodedGraph` is called `ExplodedNode`. It consists of a `ProgramState`
    object, which represents the abstract state of the program; and a `ProgramPoint`
    object, which represents the corresponding location in the program.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行过程中，执行跟踪由一个展开图表示。这个 `ExplodedGraph` 的每个节点都称为 `ExplodedNode`。它由一个 `ProgramState`
    对象组成，该对象表示程序的抽象状态；以及一个 `ProgramPoint` 对象，该对象表示程序中的相应位置。
- en: For each type of bug, there is an associated checker. Each of these checkers
    is linked to the core in a way by which they contribute to the `ProgramState`
    construction. Each time the analyzer engine explores a new statement, it notifies
    each checker registered to listen for that statement, giving it an opportunity
    to either report a bug or modify the state.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种类型的错误，都有一个相关的检查器。这些检查器中的每一个都以一种方式链接到核心，从而为 `ProgramState` 构造做出贡献。每次分析器引擎探索一个新的语句时，它会通知已注册以监听该语句的每个检查器，给它一个报告错误或修改状态的机会。
- en: Each checker registers for some events and callbacks such as `PreCall` (prior
    to the call of the function), `DeadSymbols` (when a symbol goes dead), and so
    on. They are notified in the case of the requested events, and they implement
    the action to be taken for such events.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每个检查器都会注册一些事件和回调，例如 `PreCall`（在函数调用之前）、`DeadSymbols`（当符号死亡时），等等。在请求的事件发生时，它们会收到通知，并实现针对此类事件采取的操作。
- en: In this recipe, we looked at a divide-by-zero checker, which reports when a
    divide-by-zero condition occurs. The checker, in this case, registers for the
    `PreStmt` callback, before a statement gets executed. It then checks the operator
    of the next statement to be executed, and if it finds a division operator, it
    looks for a zero value. If it finds such a possible value, it reports a bug.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们查看了一个除以零检查器，该检查器在发生除以零条件时报告。在这种情况下，检查器在执行语句之前注册了`PreStmt`回调。然后它检查将要执行的下一个语句的运算符，如果找到除法运算符，它就寻找零值。如果找到这样的可能值，它就报告一个错误。
- en: See also
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For more detailed information about the static analyzer and checkers, visit
    [http://clang-analyzer.llvm.org/checker_dev_manual.html](http://clang-analyzer.llvm.org/checker_dev_manual.html)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关静态分析器和检查器的更详细信息，请访问[http://clang-analyzer.llvm.org/checker_dev_manual.html](http://clang-analyzer.llvm.org/checker_dev_manual.html)
- en: Using bugpoint
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用bugpoint
- en: In this recipe, you will learn about a useful tool provided by LLVM infrastructure,
    known as bugpoint. Bugpoint allows us to narrow down the source of problems in
    the LLVM's tools and passes. It is helpful in debugging optimizer crashes, miscompilations
    by optimizers, or bad native code generation. Using this, we can get a small test
    case for our problem and work on that.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将了解由LLVM基础设施提供的一个有用工具，称为bugpoint。bugpoint允许我们缩小LLVM工具和传递中问题来源的范围。它在调试优化器崩溃、优化器误编译或生成不良本地代码时非常有用。使用它，我们可以为我们的问题获取一个小测试用例并在此上工作。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to build and install LLVM.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要构建和安装LLVM。
- en: How to do it…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Perform the following steps:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Write the test cases using the bugpoint tool:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用bugpoint工具编写测试用例：
- en: '[PRE23]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Use bugpoint in this test case to view the results :'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个测试用例中使用bugpoint查看结果：
- en: '[PRE24]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, to see the reduced test case, use the `llvm-dis` command to convert the
    `crash-narrowfunctiontest.ll.tmp-reduced-simplified.bc` file to the `.ll` form.
    Then, view the reduced test case:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要查看缩减的测试用例，请使用`llvm-dis`命令将`crash-narrowfunctiontest.ll.tmp-reduced-simplified.bc`文件转换为`.ll`形式。然后查看缩减的测试用例：
- en: '[PRE25]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The bugpoint tool runs all the passes specified in the command line on the test
    program. If any of these passes crash, bugpoint starts the crash debugger. The
    crash debugger tries to reduce the list of passes that cause this crash. Then
    it tries to removes unnecessary functions. Once able to reduce the test program
    to a single function, it tries to deletes the edges of the control flow graph
    to reduce the size of the function. After this, it proceeds to remove the individual
    LLVM instructions whose absence does not impact the failure. In the end, bugpoint
    gives the output showing which pass is causing the crash and a simplified reduced
    test case.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: bugpoint工具在测试程序上运行命令行中指定的所有传递。如果这些传递中的任何一个崩溃，bugpoint将启动崩溃调试器。崩溃调试器试图减少导致此崩溃的传递列表。然后它尝试删除不必要的函数。一旦能够将测试程序缩减到单个函数，它就尝试删除控制流图的边以减小函数的大小。之后，它继续删除对失败没有影响的单个LLVM指令。最后，bugpoint给出输出，显示哪个传递导致崩溃，以及一个简化的缩减测试用例。
- en: If the `–output` option wasn't specified, then bugpoint runs the program on
    a `"safe"` backend and generated reference output. It then compares the output
    generated by the selected code generator. If there is a crash, it runs the crash
    debugger as explained in the previous paragraph. Other than this, if the output
    generated by the code generator differs from the reference output, it starts the
    code generator debugger, which reduces the test case through techniques similar
    to those of the crash debugger.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定`–output`选项，那么bugpoint将在一个`"safe"`后端上运行程序并生成参考输出。然后它比较由所选代码生成器生成的输出。如果有崩溃，它将运行崩溃调试器，如前一段所述。除此之外，如果代码生成器生成的输出与参考输出不同，它将启动代码生成器调试器，通过类似于崩溃调试器的技术缩减测试用例。
- en: Finally, if the output generated by the code generator and the reference output
    are the same, then bugpoint runs all the LLVM passes and checks the output against
    the reference output. If there is any mismatch, then it runs the miscompilation
    debugger. The miscompilation debugger works by splitting the test program into
    two pieces. It runs the optimizations as specified on one piece, then links the
    two pieces back together, and finally executes the result. It tries to narrow
    down to the pass that is causing miscompilation from the list of passes, and then
    pinpoints the portion of the test program that is being miscompiled. It outputs
    the reduced case that is causing the miscompilation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果代码生成器生成的输出和参考输出相同，那么bugpoint将运行所有的LLVM遍历，并将输出与参考输出进行比较。如果有任何不匹配，它将运行误编译调试器。误编译调试器通过将测试程序分成两部分来工作。它在一个部分上运行指定的优化，然后将两部分重新链接在一起，并最终执行结果。它试图从遍历列表中缩小到导致误编译的遍历，然后确定正在被误编译的测试程序的部分。它输出导致误编译的简化案例。
- en: In the preceding test case, bugpoint checks for the crash in all functions,
    and ends up knowing that the problem lies in the test function. It also tries
    to reduce the instructions within the function. The output for every stage is
    displayed on the terminal, which is self-explanatory. In the end, it produces
    a simplified reduced test case in the bitcode format, which we can convert to
    the LLVM IR and get the reduced test case.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试用例中，bugpoint检查所有函数中的崩溃，并最终确定问题出在测试函数中。它还尝试减少函数内的指令。每个阶段的输出都会在终端上显示，这是不言自明的。最后，它以位码格式生成简化的简化测试用例，我们可以将其转换为LLVM
    IR并获取简化后的测试用例。
- en: See also
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To read more on bugpoint, go to [http://llvm.org/docs/Bugpoint.html](http://llvm.org/docs/Bugpoint.html)
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于bugpoint的信息，请访问[http://llvm.org/docs/Bugpoint.html](http://llvm.org/docs/Bugpoint.html)
- en: Using LLDB
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LLDB
- en: In this recipe, you will learn how to use the debugger known as `LLDB`, provided
    by LLVM. LLDB is a next-generation, high-performance debugger. It is essentially
    built as a set of reusable components that have advantages over the existing libraries
    in the larger LLVM project. You might find it quite similar to the `gdb` debugging
    tool.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用LLVM提供的名为`LLDB`的调试器。LLDB是一个下一代、高性能的调试器。它本质上是一个可重用组件的集合，在更大的LLVM项目中优于现有的库。你可能会觉得它和`gdb`调试工具非常相似。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will need the following before working with LLDB:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用LLDB之前，我们需要以下内容：
- en: 'To use LLDB, we need to check out the LLDB source code in the `llvm/tools`
    folder:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用LLDB，我们需要在`llvm/tools`文件夹中检出LLDB源代码：
- en: '[PRE26]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Build and install LLVM, which will also build LLDB simultaneously.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并安装LLVM，这将同时构建LLDB。
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Write a test case for a simple example using LLDB:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用LLDB编写一个简单示例的测试用例：
- en: '[PRE27]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Compile the code using Clang with the `–g` flag to generate the debug information:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有`-g`标志的Clang编译代码以生成调试信息：
- en: '[PRE28]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Debug the output file generated in the previous file with LLDB. To load the
    output file, we need to pass its name to LLDB:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用LLDB调试前一个文件生成的输出文件。要加载输出文件，我们需要将其名称传递给LLDB：
- en: '[PRE29]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Set a breakpoint in the main function:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中设置断点：
- en: '[PRE30]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To look at the list of breakpoints set, use the following command:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看设置的断点列表，请使用以下命令：
- en: '[PRE31]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add a command to be executed when a breakpoint is hit. Here, let''s add the
    back trace `bt` command when the breakpoint on the main function is hit:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在遇到断点时添加要执行的命令。在这里，让我们在主函数上的断点被触发时添加回溯`bt`命令：
- en: '[PRE32]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the executable using the following command. This will hit the breakpoint
    on the `main` function and execute the back trace(`bt`) command, as set in the
    earlier step:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行可执行文件。这将触发`main`函数上的断点并执行之前步骤中设置的回溯(`bt`)命令：
- en: '[PRE33]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To set `watchpoint` on the global variable, use the following command:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在全局变量上设置`watchpoint`，请使用以下命令：
- en: '[PRE34]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To stop the execution when the value of `globalvar` becomes `3`, use the `watch`
    command:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`globalvar`的值变为`3`时停止执行，请使用`watch`命令：
- en: '[PRE35]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To continue execution after the main function, use the following command. The
    executable will stop when the value of `globalvar` becomes `3`, inside the `func2`
    function:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数之后继续执行，请使用以下命令。可执行文件将在`func2`函数内部`globalvar`的值变为`3`时停止：
- en: '[PRE36]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To continue the execution of the executable use the `thread continue` command,
    which will execute till the end as no other breakpoints are met:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要继续执行可执行文件，使用 `thread continue` 命令，它将执行到结束，因为没有遇到其他断点：
- en: '[PRE37]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To exit LLDB, use the following command:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出 LLDB，使用以下命令：
- en: '[PRE38]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See also
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Check out [http://lldb.llvm.org/tutorial.html](http://lldb.llvm.org/tutorial.html)
    for an exhaustive list of LLDB commands.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查阅 [http://lldb.llvm.org/tutorial.html](http://lldb.llvm.org/tutorial.html)
    获取 LLDB 命令的详尽列表。
- en: Using LLVM utility passes
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LLVM 实用传递函数
- en: In this recipe, you will learn about LLVM's utility passes. As the name signifies,
    they are of much utility to users who want to understand certain things about
    LLVM that are not easy to understand by going through code. We will look into
    two utility passes that represent the CFG of a program.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将了解 LLVM 的实用传递函数。正如其名所示，它们对希望了解关于 LLVM 的某些不易通过代码理解的事情的用户非常有用。我们将探讨两个代表程序
    CFG 的实用传递函数。
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to build and install LLVM, and install the `graphviz` tool. You can
    download `graphviz` from [http://www.graphviz.org/Download.php](http://www.graphviz.org/Download.php),
    or install it from your machine's package manager, if it is in the list of available
    packages.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要构建和安装 LLVM，并安装 `graphviz` 工具。你可以从 [http://www.graphviz.org/Download.php](http://www.graphviz.org/Download.php)
    下载 `graphviz`，或者如果它在可用软件包列表中，可以从你的机器的包管理器中安装它。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Write the test code required for running the utility passes. This test code
    consists of `if` blocks, it will create a new edge in the CFG:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写运行实用传递函数所需的测试代码。此测试代码包含 `if` 块，它将在 CFG 中创建一个新的边：
- en: '[PRE39]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run the `view-cfg-only` pass to view the CFG of a function without the function
    body:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `view-cfg-only` 传递函数以查看函数的 CFG，而不包括函数体：
- en: '[PRE40]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, view the `dot` file formed using the `graphviz` tool:![How to do it...](img/image00269.jpeg)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，查看使用 `graphviz` 工具生成的 `dot` 文件：![如何操作...](img/image00269.jpeg)
- en: 'Run the `view-dom` pass to view the **Dominator tree** of a function:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `view-dom` 传递函数以查看函数的 **支配树**：
- en: '[PRE41]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: View the `dot` file formed using the `graphviz` tool:![How to do it...](img/image00270.jpeg)
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看使用 `graphviz` 工具生成的 `dot` 文件：![如何操作...](img/image00270.jpeg)
- en: See also
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: A list of the other utility passes is available at [http://llvm.org/docs/Passes.html#utility-passes](http://llvm.org/docs/Passes.html#utility-passes)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他实用传递函数的列表可在 [http://llvm.org/docs/Passes.html#utility-passes](http://llvm.org/docs/Passes.html#utility-passes)
    获取
