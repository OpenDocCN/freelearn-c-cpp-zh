- en: FreeRTOS Memory Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FreeRTOS内存管理
- en: So far, we've worked through many examples of creating FreeRTOS primitives;
    however, when these primitives were initially created, there wasn't much of an
    explanation as to where the memory was coming from. In this chapter, we'll learn
    exactly where the memory comes from, along with when and how it is allocated.
    Choosing when and how memory is allocated allows us to make trade-offs between
    coding convenience, timing determinism, potential regulatory requirements, and
    code standards. We'll conclude by looking at different measures that can be taken
    to ensure application robustness.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过许多创建FreeRTOS原语的示例；然而，当这些原语最初创建时，并没有太多关于内存来源的解释。在本章中，我们将了解内存的确切来源，以及何时以及如何分配。选择何时以及如何分配内存允许我们在编码便利性、时序确定性、潜在法规要求以及代码标准之间进行权衡。我们将通过查看可以采取的不同措施来确保应用程序的健壮性来结束本章。
- en: 'In a nutshell, this chapter covers the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，本章涵盖了以下内容：
- en: Understanding memory allocation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解内存分配
- en: Static and dynamic allocation of FreeRTOS primitives
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeRTOS原语的静态和动态分配
- en: Comparing FreeRTOS heap implementations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较FreeRTOS堆实现
- en: Replacing `malloc` and `free`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换`malloc`和`free`
- en: Implementing FreeRTOS memory hooks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现FreeRTOS内存钩子
- en: Using a **memory protection unit** (**MPU**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**内存保护单元**（**MPU**）
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the hands-on exercises in this chapter, you will require the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的动手练习，你需要以下内容：
- en: A Nucleo F767 development board
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nucleo F767开发板
- en: A Micro-USB cable
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条Micro-USB线
- en: STM32CubeIDE and source code (see the instructions in [Chapter 5](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml),
    *Selecting an IDE,* under the section *Setting up our IDE*)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32CubeIDE和源代码（参见[第5章](84a945dc-ff6c-4ec8-8b9c-84842db68a85.xhtml)，*选择IDE*部分下的*设置我们的IDE*说明）
- en: SEGGER JLink, Ozone, and SystemView (see the instructions in [Chapter 6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml),
    *Debugging Tools for Real-Time Systems)*
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SEGGER JLink、Ozone和SystemView（参见[第6章](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml)，*实时系统调试工具*中的说明）
- en: All source code for this chapter is available from [https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_15](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_8).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有源代码均可在[https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_15](https://github.com/PacktPublishing/Hands-On-RTOS-with-Microcontrollers/tree/master/Chapter_8)获取。
- en: Understanding memory allocation
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解内存分配
- en: Memory allocation isn't necessarily at the top of a developer's list of favorite
    topics to consider when developing an application—it just isn't all that glamorous.
    Dynamic allocation of memory—that is, allocating memory as it is needed rather
    than at the beginning of the program—is the norm. With desktop-oriented development,
    memory is generally available whenever it is needed, so it isn't given a second
    thought; it is simply a `malloc` call away. When it is finished, it will be unallocated
    with `free`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配并不一定是开发者考虑应用开发中最喜欢的主题之一——它并不那么吸引人。动态分配内存——即在需要时分配内存，而不是在程序开始时——是常态。在面向桌面的开发中，内存通常在需要时可用，因此不会过多考虑；它只是一个`malloc`调用而已。当它完成时，它将通过`free`进行释放。
- en: Unlike the carefree dynamic memory allocation schemes in a desktop environment,
    programmers of deeply embedded systems that use MCUs will often need to be more
    careful about how (and if) memory is dynamically allocated. In an embedded system,
    regulatory, RAM, and timing constraints can all play a role in whether/how memory
    can be dynamically allocated.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与桌面环境中无忧无虑的动态内存分配方案不同，使用MCU的深度嵌入式系统程序员通常需要更加小心地考虑如何（以及是否）动态分配内存。在嵌入式系统中，法规、RAM和时序约束都可能影响内存是否以及如何进行动态分配。
- en: Many high-reliability and safety-critical coding standards, such as MISRA-C,
    will not allow the use of dynamic allocation. In this case, it is still perfectly
    acceptable to use static allocation. Some coding standards disallow dynamic allocation
    after all tasks are created (*Ten Rules for Safety Critical Coding* by *JPL*,
    for example). In this case, static allocation or FreeRTOS's `heap_1.c` implementation
    would be reasonable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 许多高可靠性和安全关键性的编码标准，如MISRA-C，不允许使用动态分配。在这种情况下，使用静态分配仍然是完全可接受的。一些编码标准禁止在所有任务创建后进行动态分配（例如，*JPL的*《*安全关键编码十规则*》）。在这种情况下，静态分配或FreeRTOS的`heap_1.c`实现是合理的。
- en: RAM may be severely limited on a given platform. On the surface, this seems
    like the perfect use case for dynamic memory allocation; after all, if there is
    limited memory, it can be given back when it's not in use! In practice, however,
    things don't always go this smoothly when there is limited heap space available.
    When small heaps are used to allocate space for arbitrarily sized objects with
    different lifetimes, fragmentation will often occur eventually (this will be covered
    in more depth with an example later).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些平台上，RAM 可能会受到严重限制。表面上，这似乎是动态内存分配的完美用例；毕竟，如果内存有限，当它不再使用时可以将其归还！然而，在实践中，当有限的堆空间可用时，事情并不总是这么顺利。当使用小堆为具有不同生命周期的任意大小对象分配空间时，最终往往会发生碎片化（这将在稍后的示例中更深入地讨论）。
- en: Finally, a need for highly deterministic timing can also limit the options for
    dynamic allocation. If a portion of code has tight timing constraints, it is sometimes
    easier to avoid using dynamic allocation, rather than contriving tests that attempt
    to mimic worst-case timing for a call to `malloc`. It is also worth noting (again)
    that `malloc` isn't guaranteed to succeed, *especially* on an embedded system
    with limited memory. Having a large amount of dynamic allocation in a memory-constrained,
    multithreaded system can create some very complex use cases that have the potential
    to fail at runtime. Thoroughly testing such a system is a very serious challenge.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对高度确定性的定时需求也可能限制动态分配的选项。如果代码的一部分有严格的定时约束，有时避免使用动态分配比尝试模拟 `malloc` 调用的最坏情况定时测试要容易。还值得再次注意的是，`malloc`
    并不保证成功，尤其是在内存有限的嵌入式系统中。在内存受限的多线程系统中，大量动态分配可能会创建一些非常复杂的使用案例，这些案例在运行时可能会失败。彻底测试这样的系统是一个非常大的挑战。
- en: With this background information on why memory allocation is so important in
    constrained embedded systems, let's take a closer look at *where* memory comes
    from in a few different use cases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了为什么内存分配在受限嵌入式系统中如此重要之后，让我们更仔细地看看在几个不同的用例中内存是从哪里来的。
- en: Static memory
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态内存
- en: Static memory's lifespan is the entire duration of a program. Global variables,
    as well as any variables declared inside functions using the `static` specifier,
    will be placed into static memory and they will have a lifetime equal to that
    of the program.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 静态内存的生命周期是整个程序运行期间。全局变量，以及使用 `static` 说明符在函数内部声明的任何变量，都将放置到静态内存中，并且它们的生命周期与程序相同。
- en: 'For example, both `globalVar` and `staticVar` are located in static memory
    and will persist for the entire lifetime of the program. The initialization of
    `staticVar` only occurs once during the initial program load:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`globalVar` 和 `staticVar` 都位于静态内存中，并且在整个程序生命周期内保持不变。`staticVar` 的初始化仅在程序初始加载时发生一次：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When variables are declared as static, memory is guaranteed to be available.
    All of the global and static variables defined by the program are placed into
    their locations during the linking phase. As long as the amount of memory has
    been properly configured, the linker guarantees that space is available for these
    variables.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量被声明为静态时，内存的可用性得到保证。程序定义的所有全局和静态变量都在链接阶段放置到它们的位置。只要内存量已正确配置，链接器保证这些变量有足够的空间。
- en: The downside is that because static variables have such a long lifespan, static
    variables will *always* be consuming space, even when they are not being used.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，缺点是静态变量具有如此长的生命周期，静态变量将始终占用空间，即使它们没有被使用。
- en: Stack memory
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈内存
- en: A stack is used for function-scoped storage. Each time a function is called,
    information for that function (like its parameters and local variables) are placed
    onto a stack. When the function exits, all of the information that was placed
    onto the stack is removed (this is why passing pointers to local variables is
    a problem). In FreeRTOS, each task has its own private stack whose size is determined
    when the task is created.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 栈用于函数作用域的存储。每次调用函数时，该函数的信息（如参数和局部变量）都会放置到栈上。当函数退出时，放置到栈上的所有信息都会被移除（这就是为什么将局部变量的指针传递出去是一个问题）。在
    FreeRTOS 中，每个任务都有自己的私有栈，其大小在任务创建时确定。
- en: Since stacks have such an orderly way of being accessed, it isn't possible for
    them to become fragmented, like a heap. It is possible, however, to overflow the
    stack by placing more information onto it than its size allows.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于堆栈有如此有序的访问方式，它们不可能像堆那样变得碎片化。然而，通过在堆栈上放置比其大小允许更多的信息，是有可能溢出堆栈的。
- en: On the Cortex-M, there is also one additional stack—the main stack. The main
    stack is used by ISRs and the FreeRTOS kernel. The kernel and ISRs execute in
    a privileged mode that modifies the **main stack pointer** (**MSP**). Tasks execute
    on the process stack and use the **process stack pointer** (**PSP**). All of the
    stack pointer operations are taken care of by hardware and the kernel depending
    on whether the kernel, interrupt, or task (process) is currently being executed.
    It is not something that users of the RTOS API will normally need to worry about.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cortex-M中，还有一个额外的堆栈——主堆栈。主堆栈由中断服务例程（ISRs）和FreeRTOS内核使用。内核和ISRs在特权模式下执行，该模式会修改**主堆栈指针**（**MSP**）。任务在进程堆栈上执行并使用**进程堆栈指针**（**PSP**）。所有堆栈指针操作都由硬件和内核根据当前正在执行的是内核、中断还是任务（进程）来处理。这不是RTOS
    API用户通常需要担心的事情。
- en: 'Initialization of the stack and heap takes place in `Chapter_*\startup\startup_stm32f767xx.s`.
    The exact size of the main stack is defined in the linker script `STM32F767ZI_FLASH.ld`.
    If necessary, the size of the stack and heap available to the system before the
    FreeRTOS scheduler is started can be adjusted by modifying `_Min_Heap_Size` or
    `_Min_Stack_Size`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈和堆的初始化发生在 `Chapter_*\startup\startup_stm32f767xx.s`。主堆栈的确切大小在链接脚本 `STM32F767ZI_FLASH.ld`
    中定义。如果需要，可以通过修改 `_Min_Heap_Size` 或 `_Min_Stack_Size` 来调整在FreeRTOS调度器启动之前系统可用的堆栈和堆的大小：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is best to try and keep these both to minimal sizes since any RAM used here
    will be unavailable to the tasks. These stacks/heaps are only for code that is
    run before the scheduler is started, as well as the ISRs. This is *not* the same
    stack that is used by any of the tasks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最好尽量保持这两个堆栈的大小最小，因为在这里使用的任何RAM都将无法用于任务。这些堆栈/堆只用于在调度器启动之前运行的代码，以及中断服务例程（ISRs）。这**不是**任何任务使用的相同堆栈。
- en: Occasionally, you may run into a problem where you'll need to run some memory-intensive
    initialization code (the USB stack is a good example of this). If the initialization
    functions are called outside of a task (before the scheduler starts), then they
    will use the main stack. In order to keep this stack as small as possible and
    allow more memory to be used for tasks, move memory-intensive initialization inside
    a task This will allow the RTOS heap to have the additional RAM that would have
    gone unused after initialization had the main stack size been increased.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会遇到需要运行一些内存密集型初始化代码的问题（USB堆栈是这种情况的一个好例子）。如果初始化函数在任务之外（在调度器启动之前）被调用，那么它们将使用主堆栈。为了使这个堆栈尽可能小，并允许为任务使用更多的内存，将内存密集型初始化代码移入任务中。这将允许RTOS堆拥有在初始化后本将未使用的额外RAM，因为如果增加了主堆栈的大小。
- en: The FreeRTOS kernel manipulates the **process stack pointer** (**PSP**) to point
    to the task stack that has context (is in the running state).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS内核操作**进程堆栈指针**（**PSP**）以指向具有上下文（处于运行状态）的任务堆栈。
- en: For the most part, you won't need to be immediately concerned with the various
    stack pointers—they are taken care of by the kernel and C runtime. If you happen
    to be developing code that will transition between an RTOS and *bare metal* (that
    is, a bootloader), then you will need to understand how/when to properly switch
    the current stack pointer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你不需要立即关注各种堆栈指针——它们由内核和C运行时处理。如果你正在开发将在RTOS和 *bare metal*（即，引导加载程序）之间转换的代码，那么你需要了解如何/何时正确切换当前堆栈指针。
- en: The most important thing to keep in mind with stacks is that they must be adequately
    sized to hold all of the local variables that a task will execute for the deepest
    call level. We'll discuss ways of getting a handle on this in the *Keeping an
    eye on stack space* section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆栈方面需要记住的最重要的事情是，它们必须足够大，以容纳任务将执行的 deepest call level 的所有局部变量。我们将在 *Keeping
    an eye on stack space* 部分讨论获取这个信息的方法。
- en: Heap memory
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆内存
- en: The heap is the portion of memory that is used when a dynamic allocation using `malloc`
    is called. It is also where a FreeRTOS task stack and **task control block** (**TCB**)
    are stored when they are created by calling `xTaskCreate()`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是当调用 `malloc` 进行动态分配时使用的内存部分。它也是当通过调用 `xTaskCreate()` 创建时，FreeRTOS 任务堆栈和 **任务控制块**
    (**TCB**) 存储的地方。
- en: 'In an MCU FreeRTOS system, there will typically be two heaps created:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 MCU FreeRTOS 系统中，通常会创建两个堆：
- en: '**System heap**: Defined in the startup and linker scripts described previously.
    This will *not *be available for use by the final application code when allocating
    space for RTOS primitives.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统堆**：在前面描述的启动和链接脚本中定义。这在使用为 RTOS 原语分配空间时将 *不* 可用于最终应用程序代码。'
- en: '**FreeRTOS heap**: Used when creating tasks and other primitives and defined
    in ***Inc\****FreeRTOSConfig.h***. It can be resized by adjusting the following
    line:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FreeRTOS 堆**：在创建任务和其他原语时使用，并在 ***Inc\****FreeRTOSConfig.h*** 中定义。可以通过调整以下行来调整大小：'
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Currently, this line is defining a 15 KB heap. This heap must be adequately
    sized to accommodate the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这一行定义了一个 15 KB 的堆。这个堆必须足够大，以容纳以下内容：
- en: Stacks (and **TCBs**) for all tasks that are created using `xTaskCreate`
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `xTaskCreate` 创建的所有任务的堆栈（和 **TCBs**）
- en: Queues, semaphores, mutexes, event groups, and software timers created using
    `x*Create`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `x*Create` 创建的队列、信号量、互斥锁、事件组和软件定时器
- en: 'Here''s a visual representation of where all of the different variables will
    come from:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是所有不同变量来源的视觉表示：
- en: '![](img/5ac3322f-699f-4f2e-b212-06791ecef725.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ac3322f-699f-4f2e-b212-06791ecef725.png)'
- en: 'There are two possible locations for FreeRTOS primitives and stacks:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS 原语和堆栈有两个可能的存储位置：
- en: Statically allocated space for a stack and a **TCB**, passed to a task when
    calling `xTaskCreateStatic()`
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用 `xTaskCreateStatic()` 时传递给任务的堆栈和 **TCB** 的静态分配空间
- en: Dynamically allocated space for a stack/TCB, created when calling `xTaskCreate()`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用 `xTaskCreate()` 时创建的堆栈/TCB 的动态分配空间
- en: The C heap is only used for any items that are created without the use of the
    FreeRTOS heap implementation, while the C stack is only used before the scheduler
    is started, as well as by ISRs. When using an RTOS, it is best to minimize the
    size of the C heap as much as possible, or entirely. This will leave more available
    RAM to allocate to the RTOS heap or static variables.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: C 堆仅用于创建时未使用 FreeRTOS 堆实现的项目，而 C 堆栈仅在调度器启动之前以及由 ISRs 使用。在使用 RTOS 时，最好尽可能最小化
    C 堆的大小，或者完全不要。这将留下更多的可用 RAM 来分配给 RTOS 堆或静态变量。
- en: Heap fragmentation
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆碎片化
- en: 'In an embedded system with limited RAM, heap fragmentation can be a very serious
    issue. A heap becomes fragmented when items are loaded into the heap and then
    removed at different points in time. The problem is that if many items that are
    being removed aren''t adjacent to one another, a larger contiguous region of space
    won''t necessarily be available:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在有限 RAM 的嵌入式系统中，堆碎片化可能是一个非常严重的问题。当项目被加载到堆中并在不同的时间点移除时，堆就会变得碎片化。问题是，如果许多被移除的项目不是相邻的，就不一定会有一个更大的连续空间区域可用：
- en: '![](img/94bc05c1-17f7-40b2-97a6-1f9d3d1de749.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94bc05c1-17f7-40b2-97a6-1f9d3d1de749.png)'
- en: In the preceding example, space won't be successfully allocated for item 8\.
    Even though there is sufficient free space, there isn't enough *contiguous* free
    space to accommodate the size of item 8\. This is especially problematic because
    it will only occur at runtime, and under certain circumstances that are dependent
    on the size and timing of when items in the heap are allocated and freed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，项目 8 的空间无法成功分配。尽管有足够的空闲空间，但并没有足够的 *连续* 空间来容纳项目 8 的大小。这尤其成问题，因为它只会在运行时发生，并且在某些情况下，这些情况取决于堆中项目分配和释放的大小和时机。
- en: Now that we've covered the basics of memory allocation, let's look at some different
    ways that FreeRTOS primitives can be created to be placed in static or heap memory.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了内存分配的基础知识，让我们看看 FreeRTOS 原语可以以不同的方式创建并放置在静态或堆内存中的几种方法。
- en: Static and dynamic allocation of FreeRTOS primitives
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FreeRTOS 原语的静态和动态分配
- en: Details on the mechanics of creating tasks were covered in [Chapter 7](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml),
    *The FreeRTOS Scheduler.* Here, we will only focus on the differences in *where*
    the memory is coming from and what its *lifetime* is. This will help illuminate
    the implications of choosing different allocation schemes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建任务的机制在[第7章](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml)，*FreeRTOS调度器*中有所介绍。在这里，我们只关注内存来源及其*生命周期*的差异。这将有助于阐明选择不同分配方案的含义。
- en: Memory for tasks can either be allocated dynamically or statically. Dynamic
    allocation allows the memory used by the task to be returned by calling `vTaskDelete()`
    if the task no longer needs to run (see [Chapter 7](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml),
    *The FreeRTOS Scheduler*, for details). Dynamic allocation can occur at any point
    in the program, whereas static allocation occurs before the program starts. The
    static variants of FreeRTOS API calls follow the same initialization scheme—the
    standard calls use dynamic allocation (pulling memory from the FreeRTOS heap).
    All FreeRTOS API functions with `CreateStatic` in their names (such as `xTaskCreateStatic`)
    take additional arguments for referencing preallocated memory. As opposed to the
    dynamic allocation approach, the memory passed to `*CreateStatic` variants will
    typically be statically allocated buffers, which are present for the entire program's
    lifetime.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 任务内存可以是动态分配或静态分配。动态分配允许通过调用`vTaskDelete()`来返回任务使用的内存，如果任务不再需要运行（有关详细信息，请参阅[第7章](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml)，*FreeRTOS调度器*）。动态分配可以在程序的任何点发生，而静态分配则在程序开始之前发生。FreeRTOS
    API调用的静态变体遵循相同的初始化方案——标准调用使用动态分配（从FreeRTOS堆中拉取内存）。所有名称中包含`CreateStatic`的FreeRTOS
    API函数（如`xTaskCreateStatic`）都接受额外的参数来引用预分配的内存。与动态分配方法相反，传递给`*CreateStatic`变体的内存通常是静态分配的缓冲区，这些缓冲区在整个程序的生命周期中都是存在的。
- en: While the naming of the `*CreateStatic` API variants suggests that the memory
    is static, this isn't actually a requirement. For example, you could allocate
    a buffer memory on the stack and pass the pointer to a `*CreateStatic` API function
    call; however, you'll need to be sure that the lifetime of the primitive created
    is limited to that function! You may also find it useful to allocate memory using
    an allocation scheme outside of the FreeRTOS heap, in which case you could also
    use the `*CreateStatic` API variants. If you choose to utilize either of these
    methods, then to avoid memory corruption, you'll need to have detailed knowledge
    of the lifetime of both the FreeRTOS primitive being created and the allocated
    memory!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`*CreateStatic` API变体的命名暗示内存是静态的，但这实际上并不是一个要求。例如，你可以在栈上分配缓冲区内存，并将指针传递给`*CreateStatic`
    API函数调用；然而，你需要确保所创建的基本类型的生命周期仅限于该函数！你还可以发现，使用FreeRTOS堆以外的分配方案分配内存可能很有用，在这种情况下，你也可以使用`*CreateStatic`
    API变体。如果你选择使用这两种方法中的任何一种，为了避免内存损坏，你需要详细了解正在创建的FreeRTOS基本类型和分配的内存的生命周期！
- en: Dynamic allocation examples
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态分配示例
- en: Nearly all of the code presented has used dynamic allocation to create FreeRTOS
    primitives (tasks, queues, mutexes, and so on). Here are two examples to serve
    as a quick refresher before we look at the differences between creating primitives
    using static allocation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '几乎所有展示的代码都使用了动态分配来创建FreeRTOS基本类型（任务、队列、互斥锁等）。在我们查看使用静态分配创建基本类型的差异之前，这里有两个例子作为快速复习。 '
- en: Creating a task
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建任务
- en: 'When a task is created using dynamically allocated memory, the call will look
    something like this (see [Chapter 7](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml),
    *The FreeRTOS Scheduler*, for more details on the parameters that are not related
    to memory allocation):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用动态分配的内存创建任务时，调用将类似于以下内容（有关与内存分配无关的参数的更多详细信息，请参阅[第7章](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml)，*FreeRTOS调度器*）：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are a few relevant pieces of information, relevant to memory allocation,
    to note about this call:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此调用，有一些与内存分配相关的相关信息需要注意：
- en: The call to `xTaskCreate` may fail. This is because there is no guarantee that
    enough space will be available for storing the task's stack and TCB on the FreeRTOS
    heap. The only way to ensure that it was created successfully is to check the
    return value, `retVal`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xTaskCreate`的调用可能会失败。这是因为无法保证在FreeRTOS堆上有足够的空间来存储任务的堆栈和TCB。唯一确保其成功创建的方法是检查返回值，`retVal`。'
- en: The only parameter to do with a stack is the requested size of the stack.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与堆栈有关的唯一参数是请求的堆栈大小。
- en: When created in this manner, if it is appropriate for a task to terminate itself,
    it may call `xTaskDelete(NULL)` and the memory associated with the task's stack
    and TCB will be available to be reused.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建时，如果任务适当地终止自己，它可以调用 `xTaskDelete(NULL)`，与任务堆栈和 TCB 相关的内存将可用于重用。
- en: 'The following are a few points to note regarding dynamic allocation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 关于动态分配的以下是一些需要注意的点：
- en: Primitive creation may fail at runtime if no heap space is available.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有堆空间可用，原语创建可能在运行时失败。
- en: All memory that FreeRTOS allocates for the primitive will be automatically freed
    when the task is deleted (as long as `Heap_1` is not used and `INCLUDE_vTaskDelete`
    is set to `1` in `FreeRTOSConfig.h`). This doesn't include memory that was dynamically
    allocated by *user*-supplied code in the actual task; the RTOS is unaware of any
    dynamic allocation initiated by user-supplied code. It is up to you to free this
    code when appropriate.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeRTOS 为原语分配的所有内存将在任务删除时自动释放（只要不使用 `Heap_1`，并且在 `FreeRTOSConfig.h` 中将 `INCLUDE_vTaskDelete`
    设置为 `1`）。这不包括实际任务中由 *用户* 代码动态分配的内存；RTOS 对用户代码启动的任何动态分配一无所知。释放此代码的责任在于您，您需要在适当的时候释放此代码。
- en: '`configSUPPORT_DYNAMIC_ALLOCATION` must be set to 1 in `FreeRTOSConfig.h` for
    dynamic allocation to be available:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `FreeRTOSConfig.h` 中，必须将 `configSUPPORT_DYNAMIC_ALLOCATION` 设置为 1，以便动态分配可用：
- en: '![](img/f9fad1c7-0e46-4cf6-92ee-b12a7bbdae96.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9fad1c7-0e46-4cf6-92ee-b12a7bbdae96.png)'
- en: When creating a task using dynamic allocation, all of the memory used for the
    task, the task's stack, and **TCB** is allocated from the FreeRTOS heap, as shown
    in the preceding diagram.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用动态分配创建任务时，任务使用的所有内存、任务的堆栈和 **TCB** 都是从 FreeRTOS 堆中分配的，如前图所示。
- en: Next, let's take a look at the different ways of creating queues.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看创建队列的不同方法。
- en: Creating a queue
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建队列
- en: 'For a detailed explanation and working examples regarding how to create queues
    using dynamically allocated memory, see [Chapter 9](495bdcc0-2a86-4b22-9628-4c347e67e49e.xhtml),
    *Intertask *Communication, in the section on *Passing data through queues by value*.
    As a quick review, to create a queue of length `LED_CMD_QUEUE_LEN` that holds
    elements of the `uint8_t` type, we''d go through the following steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用动态分配的内存创建队列的详细解释和工作示例，请参阅第 9 章，*通过队列按值传递数据* 中的 *任务间通信* 部分，[第 9 章](495bdcc0-2a86-4b22-9628-4c347e67e49e.xhtml)。作为一个快速回顾，要创建一个长度为
    `LED_CMD_QUEUE_LEN`、包含 `uint8_t` 类型元素的队列，我们需要执行以下步骤：
- en: 'Create the queue:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建队列：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Verify that the queue was created successfully by checking the handle, `ledCmdQueue`,
    is not `NULL`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过检查句柄 `ledCmdQueue` 不是 `NULL` 来验证队列是否成功创建：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we've reviewed a few examples of dynamic allocation (which will pull
    memory during runtime from the FreeRTOS heap), let's move on to static allocation
    (which reserves memory during compilation/linking, before the application is ever
    run).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了一些动态分配的示例（这些示例将在运行时从 FreeRTOS 堆中拉取内存），让我们继续讨论静态分配（这将在编译/链接期间预留内存，在应用程序运行之前）。
- en: Static allocation examples
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态分配示例
- en: FreeRTOS also has a method for creating primitives that don't require us to
    dynamically allocate memory. This is an example of creating primitives with statically
    allocated memory.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: FreeRTOS 还有一种创建不需要我们动态分配内存的原语的方法。这是一个使用静态分配内存创建原语的示例。
- en: Creating a task
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建任务
- en: 'To create a task using a preallocated stack and TCB (requiring no dynamic allocation),
    use a call similar to the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用预分配的堆栈和 TCB（不需要动态分配）创建任务，可以使用以下类似的调用：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There are several notable differences between this static allocation and the
    previous method of dynamic allocation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的动态分配方法相比，这种静态分配有几个显著的不同点：
- en: Instead of a return value of `pdPASS`, the `xTaskCreateStatic` function returns
    a task handle.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与返回值 `pdPASS` 不同，`xTaskCreateStatic` 函数返回一个任务句柄。
- en: Task creation using `xTaskCreateStatic` will always succeed, provided that the
    stack pointer and TCB pointers are non-null.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `xTaskCreateStatic` 创建任务总是会成功，前提是堆栈指针和 TCB 指针非空。
- en: As an alternative to checking the `TaskHandle_t`, `StackType_t` and `StaticTask_t`
    could be checked instead; as long as they are not `NULL`, the task will always
    be successfully created.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为检查 `TaskHandle_t`、`StackType_t` 和 `StaticTask_t` 的替代方案，可以检查 `StackType_t`；只要它们不是
    `NULL`，任务总是会成功创建。
- en: Tasks can also be *deleted*, even if they were created with `xTaskCreateStatic`.
    FreeRTOS will only take the steps necessary to remove the task from the scheduler;
    freeing associated memory is the responsibility of the caller.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使任务是用 `xTaskCreateStatic` 创建的，任务也可以被*删除*。FreeRTOS 只会采取必要的步骤将任务从调度器中移除；释放相关内存是调用者的责任。
- en: 'Here''s where the task''s stack and TCB are located when we use the previous
    call:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用之前的调用时，这是任务堆栈和 TCB 所在的位置：
- en: '![](img/615b2e6c-0f53-4b53-a793-463d43079c13.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/615b2e6c-0f53-4b53-a793-463d43079c13.png)'
- en: Static creation allows more flexibility in memory allocation than the name implies.
    Strictly speaking, a call to `vTaskDelete` will only remove a statically created
    task from the schedule. Since FreeRTOS will no longer access memory from that
    task's stack or TCB, it is safe to repurpose this memory for other purposes. It
    is conceivably possible to allocate the stack and TCB from the stack memory rather
    than static memory. An example of deleting a task created using `xTaskCreateStatic`
    can be found in `main_staticTask_Delete.c`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 静态创建在内存分配方面比其名称所暗示的提供了更多的灵活性。严格来说，对 `vTaskDelete` 的调用只会将静态创建的任务从调度器中移除。由于 FreeRTOS
    将不再访问该任务的堆栈或 TCB 中的内存，因此可以安全地将此内存用于其他目的。从堆栈内存而不是静态内存分配堆栈和 TCB 是可能的。使用 `xTaskCreateStatic`
    创建的任务删除的示例可以在 `main_staticTask_Delete.c` 中找到。
- en: Creating a queue
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建队列
- en: 'Now let''s take a look at the steps for creating a queue using static memory
    for both the buffer and queue structure. This code is an excerpt from `mainStaticQueueCreation.c`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用静态内存为缓冲区和队列结构创建队列的步骤。此代码摘自 `mainStaticQueueCreation.c`：
- en: 'Define a variable for holding the queue structure used by FreeRTOS:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个变量来保存 FreeRTOS 使用的队列结构：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a raw array, appropriately sized to hold the queue contents:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个适当大小的原始数组，用于保存队列内容：
- en: A simple C array of the target datatype can be used; in this case, our queue
    will hold a datatype of `uint8_t`.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用目标数据类型的一个简单的 C 数组；在这种情况下，我们的队列将持有 `uint8_t` 数据类型。
- en: 'Use `#define` to define the array length:'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `#define` 来定义数组长度：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create the queue within the same length as the array that was previously defined:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前定义的数组相同长度内创建队列：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here''s a breakdown of the parameters:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是参数的分解：
- en: '`LED_CMD_QUEUE_LEN`: Number of elements in the queue'
  id: totrans-111
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LED_CMD_QUEUE_LEN`: 队列中的元素数量'
- en: '`sizeof(uint8_t)`: Size of each element (in bytes)'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sizeof(uint8_t)`: 每个元素的大小（以字节为单位）'
- en: '`queueStorage`: Raw array used for storing elements in the queue (used only
    by FreeRTOS)'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queueStorage`: 用于在队列中存储元素的原始数组（仅由 FreeRTOS 使用）'
- en: '`queueStructure`: Pointer to `StatisQueue_t`, the queue structure used internally
    by FreeRTOS'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queueStructure`: 指向 `StatisQueue_t` 的指针，这是 FreeRTOS 内部使用的队列结构'
- en: 'Check the queue handle `ledCmdQueue`, to ensure that the queue was correctly
    created by verifying that it is not `NULL`. Unlike dynamically allocated queues,
    it is unlikely that this call will fail, but leaving the check ensures that if
    the queue is ever changed to be dynamically allocated, errors will still be caught:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查队列句柄 `ledCmdQueue`，以确保队列被正确创建，通过验证它不是 `NULL`。与动态分配的队列不同，这个调用不太可能失败，但进行这个检查可以确保如果队列被更改为动态分配，错误仍然会被捕获：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Put it all together:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有内容组合在一起：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The only difference between creating queues with static allocation and creating
    them with dynamic allocation is how the memory is supplied—both calls return queue
    handles. Now that we've seen examples of creating queues and tasks without using
    dynamically allocated memory, what happens if we have a requirement for *no* dynamic
    allocation to take place?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态分配创建队列和使用动态分配创建队列之间的唯一区别是内存的提供方式——两个调用都返回队列句柄。现在我们已经看到了创建队列和任务而不使用动态分配内存的示例，如果我们有*不*进行动态分配的要求会发生什么？
- en: Eliminating all dynamic allocation
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消除所有动态分配
- en: In most of the examples that we've seen, we've focused on working with the dynamic
    allocation scheme variants when creating FreeRTOS primitives. This has been primarily
    for ease of use and brevity, enabling us to focus on the core RTOS concepts rather
    than worrying about exactly where memory was coming from and how we were accessing
    it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到的多数示例中，我们专注于在创建 FreeRTOS 原语时使用动态分配方案变体。这主要是为了使用方便和简洁，使我们能够专注于核心 RTOS 概念，而不是担心内存的确切来源以及我们如何访问它。
- en: All FreeRTOS primitives can be created with either dynamically allocated memory
    or preallocated memory. To avoid all dynamic allocation, simply use the `CreateStatic`
    version of a `create` function, as we've done in the preceding example when we
    created a task. Some `CreateStatic` versions exist for queues, mutexes, semaphores,
    stream buffers, message buffers, event groups, and timers. They share the same
    arguments as their dynamic counterparts, but also require a pointer to preallocated
    memory to be passed to them. The `CreateStatic` equivalents don't require any
    memory allocation to take place during runtime.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有FreeRTOS原语都可以使用动态分配的内存或预分配的内存来创建。为了避免所有动态分配，只需使用`CreateStatic`版本的`create`函数，就像我们在前面的例子中创建任务时做的那样。对于队列、互斥锁、信号量、流缓冲区、消息缓冲区、事件组和定时器，都存在`CreateStatic`版本。它们与它们的动态对应物具有相同的参数，但还需要传递一个指向预分配内存的指针。`CreateStatic`等效版本在运行时不需要进行任何内存分配。
- en: 'You would consider using the static equivalents for the following reasons:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你会考虑使用静态等效物，以下是一些原因：
- en: They are guaranteed to never fail because of a lack of memory.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们保证永远不会因为内存不足而失败。
- en: All of the checks that are needed to ensure memory is available happen during
    linking (before the application binary is created). If memory is not available,
    it will fail at link time, rather than runtime.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需要的所有检查以确保内存可用都发生在链接阶段（在创建应用程序二进制文件之前）。如果内存不可用，它将在链接时失败，而不是在运行时。
- en: Many standards targeting safety-critical applications prohibit the use of dynamically
    allocated memory.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多针对安全关键应用的标准禁止使用动态分配的内存。
- en: Internal embedded C coding standards will occasionally prohibit the use of dynamic
    allocation.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部嵌入式C编码标准偶尔也会禁止使用动态分配。
- en: Memory fragmentation could be added to this list as well, but this isn't an
    issue unless memory is freed (for example, `heap_1` could be used to eliminate
    heap fragmentation concerns).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 内存碎片化也可以添加到这个列表中，但这并不是一个问题，除非内存被释放（例如，可以使用`heap_1`来消除堆碎片化问题）。
- en: Now that we have an understanding of the differences between dynamic and static
    allocation, let's dive into the differences of FreeRTOS's dynamic allocation schemes—the
    five heap implementations. Moving ahead, we will see what these different definitions
    look like in a file (globals, static allocation, and so on). We will also understand
    the difference between the main stack and task-based stacks where they live in
    a FreeRTOS heap.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了动态分配和静态分配之间的区别，让我们深入了解FreeRTOS的动态分配方案——五种堆实现。接下来，我们将看到这些不同的定义在文件中是什么样的（全局变量、静态分配等）。我们还将理解主栈和基于任务的栈之间的区别，以及它们在FreeRTOS堆中的位置。
- en: Comparing FreeRTOS heap implementations
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较FreeRTOS堆实现
- en: Because FreeRTOS targets such a wide range of MCUs and applications, it ships
    with five different dynamic allocation schemes, all of which are implemented with
    a heap. The different heap implementations allow different levels of heap functionality.
    They are included in the `portable/MemMang` directory as `heap_1.c`, `heap_2.c`,
    `heap_3.c`, `heap_4.c`, and `heap_5.c`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于FreeRTOS针对如此广泛的MCU和应用程序，它提供了五种不同的动态分配方案，所有这些方案都是通过堆实现的。不同的堆实现允许不同的堆功能级别。它们包含在`portable/MemMang`目录中，作为`heap_1.c`、`heap_2.c`、`heap_3.c`、`heap_4.c`和`heap_5.c`。
- en: '**A note on memory pools:**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于内存池的说明：**'
- en: Many other RTOSes include memory pools as an implementation for dynamic memory
    allocation. A memory pool achieves dynamic allocation by only allocating and freeing
    fixed-size blocks. By fixing the block size, the problem of fragmentation is avoided
    in memory-constrained environments.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他实时操作系统（RTOS）将内存池作为动态内存分配的实现方式。内存池通过仅分配和释放固定大小的块来实现动态分配。通过固定块大小，在内存受限的环境中可以避免碎片化问题。
- en: The downside to memory pools is that the blocks need to be sized for each specific
    application. If they are too large, they will waste precious RAM; too small, and
    they'll be unable to hold large items. In order to make things easier on users
    and avoid wasting RAM, Richard Barry elected to exclusively use heaps for dynamic
    allocation in FreeRTOS.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 内存池的缺点是，块的大小需要针对每个特定应用程序进行调整。如果太大，它们会浪费宝贵的RAM；太小，它们将无法容纳大项。为了使用户更容易操作并避免浪费RAM，理查德·巴里选择在FreeRTOS中仅使用堆进行动态分配。
- en: 'In order for projects to properly link after compilation, it is important to
    only have one of the heap implementations visible to the linker. This can either
    be accomplished by removing the unused files or not including the unused heap
    files in the list of files available to the linker. For this book, the extra files
    in `Middleware\Third_Party\FreeRTOS\Source\portable\MemMang` have been removed.
    For this chapter, however, all of the original implementations are included in
    `Chapter_15\Src\MemMang`: it is the only place where examples use a heap other
    than `heap_4.c`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保项目在编译后正确链接，重要的是只让链接器看到一种堆实现。这可以通过删除未使用的文件或不在链接器可用的文件列表中包含未使用的堆文件来实现。对于本书，`Middleware\Third_Party\FreeRTOS\Source\portable\MemMang`
    中的额外文件已被删除。然而，对于本章，所有原始实现都包含在 `Chapter_15\Src\MemMang` 中：这是唯一一个使用除 `heap_4.c`
    之外堆的示例的地方。
- en: 'All of the various heap options exist to enable a project to get exactly the
    functionality it needs without requiring anything more (in terms of program space
    or configuration). They also allow for trade-offs between flexibility and deterministic
    timing. The following is a list of the various heap options:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所有各种堆选项都存在，以便项目能够获得所需的确切功能，而无需更多（在程序空间或配置方面）。它们还允许在灵活性和确定性定时之间进行权衡。以下是一系列各种堆选项：
- en: '`heap_1`: Allocation only—no freeing is allowed. This is best suited for simple
    applications that don''t free anything after initial creation. This implementation,
    along with `heap_2`, provides the most deterministic timing since neither heap
    ever performs a search for adjacent free blocks to combine.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heap_1`: 只允许分配——不允许释放。这最适合那些在初始创建后不释放任何内容的简单应用程序。此实现，连同 `heap_2`，提供了最确定的定时，因为这两个堆永远不会执行搜索相邻空闲块以组合的操作。'
- en: '`heap_2`: Allocation and freeing are both allowed, but adjacent free blocks
    are not combined. This limits appropriate use cases to those applications that
    can know/guarantee they are reusing a number of items that are the same size each
    time. This heap implementation is not a great fit for applications that make use
    of `vPortMalloc` and `vPortFree` explicitly (for example, applications that allocate
    memory dynamically themselves), unless there is a very large degree of discipline
    in ensuring that only a small subset of possible sizes are used.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heap_2`: 允许分配和释放，但不会组合相邻的空闲块。这限制了适当的使用场景，仅适用于那些可以知道/保证每次重新使用相同数量的相同大小的项的应用程序。此堆实现对于明确使用
    `vPortMalloc` 和 `vPortFree` 的应用程序（例如，自行动态分配内存的应用程序）来说并不是一个好的选择，除非在确保只使用可能大小的一小部分方面有非常高的纪律性。'
- en: '`heap_3`: Wraps standard `malloc`/`free` implementations to provide thread
    safety.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heap_3`: 包装标准的 `malloc`/`free` 实现以提供线程安全。'
- en: '`heap_4`: The same as `heap_2` but combines adjacent free space. Allows locating
    the entire heap by giving an absolute address. Well suited for applications to
    use dynamic allocation.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heap_4`: 与 `heap_2` 相同，但组合相邻的空闲空间。通过提供一个绝对地址，允许定位整个堆。非常适合需要使用动态分配的应用程序。'
- en: '`heap_5`: The same as `heap_4` but allows for creating a heap that is distributed
    across different noncontiguous memory regions—for example, a heap could be scattered
    across internal and external RAM.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heap_5`: 与 `heap_4` 相同，但允许创建一个分布在不同非连续内存区域上的堆——例如，堆可以分散在内部和外部RAM上。'
- en: 'Here''s a quick comparison between all of the heap implementations:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是所有堆实现之间的快速比较：
- en: '| **Heap name** | **Thread safe** | **Allocation** | **Free** | **Combine adjacent
    free space** | **Multiple memory regions** | **Determinism** |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **堆名称** | **线程安全** | **分配** | **释放** | **组合相邻空闲空间** | **多个内存区域** | **确定性**
    |'
- en: '| `heap_1.c` | ✓ | ✓ |  |  |  | ↑ |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `heap_1.c` | ✓ | ✓ |  |  |  | ↑ |'
- en: '| `heap_2.c` | ✓ | ✓ | ✓ |  |  | ↑ |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `heap_2.c` | ✓ | ✓ | ✓ |  |  | ↑ |'
- en: '| `heap_3.c` | ✓ | ✓ | ✓ | ✓* |  | ? |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `heap_3.c` | ✓ | ✓ | ✓ | ✓* |  | ? |'
- en: '| `heap_4.c` | ✓ | ✓ | ✓ | ✓ |  | → |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `heap_4.c` | ✓ | ✓ | ✓ | ✓ |  | → |'
- en: '| `heap_5.c` | ✓ | ✓ | ✓ | ✓ | ✓ | → |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `heap_5.c` | ✓ | ✓ | ✓ | ✓ | ✓ | → |'
- en: '| `std C lib` | ? | ✓ | ✓ | ✓* |  | ? |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `std C lib` | ? | ✓ | ✓ | ✓* |  | ? |'
- en: (*) Most, if not all, included heap implementations will combine free space.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: (*) 大多数（如果不是全部）包含的堆实现将组合空闲空间。
- en: Since determinism is dependent on the C library implementation that we happen
    to be using, it isn't possible to provide general guidance here. Typically, general-purpose
    heap implementations are created to minimize fragmentation, which requires additional
    CPU resources (time) and decreases the determinism of the timing, depending on
    how much memory is moved around.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于确定性取决于我们恰好使用的C库实现，因此在这里提供一般性指导是不可能的。通常，通用堆实现是为了最小化碎片化而创建的，这需要额外的CPU资源（时间），并且会降低时间确定的确定性，这取决于移动了多少内存。
- en: Each C implementation may approach dynamic allocation differently. Some will
    make adding thread safety as easy as defining implementations for `__mallock_lock`
    and `__malloc_unlock`, in which case a single mutex is all that is required. In
    other cases, they will require a few implementations for implementing mutex functionality.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每个C语言的实现可能对动态分配的处理方式不同。有些实现会让添加线程安全变得和定义`__mallock_lock`和`__malloc_unlock`的实现一样简单，在这种情况下，只需要一个互斥锁即可。在其他情况下，它们可能需要几个实现来实施互斥锁功能。
- en: Choosing your RTOS heap implementation
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择你的RTOS堆实现
- en: So, how do you go about choosing which heap implementation to use? First, you
    need to ensure that you're able to use dynamic allocation (many standards for
    safety-critical applications disallow it). If you don't need to free allocated
    memory, then `heap_1.c` is a potential option (as is avoiding a heap entirely).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何选择使用哪种堆实现呢？首先，你需要确保你能够使用动态分配（许多针对安全关键型应用的标准禁止使用它）。如果你不需要释放分配的内存，那么`heap_1.c`可能是一个潜在的选择（同样，完全避免使用堆也是一个选择）。
- en: From a coding perspective, the main difference between using `heap_1` and static
    allocation is when the checks for memory availability are performed. When using
    the `*CreateStatic` variants, you'll be notified at link time that you don't have
    enough memory to support the newly created primitive. This requires a few extra
    lines of code each time a primitive is created (to allocate buffers used by the
    primitive). When using `heap_1`, as long as checks are performed (see [Chapter
    7](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml), *The FreeRTOS Scheduler*) to determine
    task creation success, then the checking will be performed at runtime. Many applications
    that are appropriate for the `heap_1` implementation will also create all required
    tasks before starting the scheduler. Using dynamic memory allocation in this way
    isn't much different from static allocation; it simply moves the checking from
    link time to runtime, while reducing the amount of code required to create each
    RTOS primitive.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从编码的角度来看，使用`heap_1`和静态分配之间的主要区别在于内存可用性检查的执行时机。当使用`*CreateStatic`变体时，你将在链接时被告知没有足够的内存来支持新创建的原语。这需要在每次创建原语时添加几行额外的代码（以分配原语使用的缓冲区）。当使用`heap_1`时，只要执行检查（见[第7章](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml)，*FreeRTOS
    调度器*）以确定任务创建成功，那么检查将在运行时执行。许多适合`heap_1`实现的程序也会在启动调度器之前创建所有必需的任务。以这种方式使用动态内存分配与静态分配并没有太大的区别；它只是将检查从链接时间移动到运行时，同时减少了创建每个RTOS原语所需的代码量。
- en: If you're working on an application that only requires *one* datatype to be
    freed, `heap_2` might be an option. If you choose to go down this route, you'll
    need to be very careful to document this limitation for future maintainers of
    the code. Failure to understand the limited use case of `heap_2` can easily result
    in memory fragmentation. In the worst-case scenario, fragmentation might potentially
    occur after the application has been running for an extended period of time and
    might not occur until the final code has been released and the hardware is fielded.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发一个只需要释放*一种*数据类型的程序，`heap_2`可能是一个选择。如果你选择走这条路，你需要非常小心地记录下这个限制，以便未来的代码维护者了解。未能理解`heap_2`的有限用途可能会导致内存碎片化。在最坏的情况下，碎片化可能发生在应用程序运行了一段时间之后，并且可能直到最终代码发布和硬件部署时才会发生。
- en: When dynamic memory is used, then `heap_3`, `heap_4`, or `heap_5` can be used.
    As mentioned earlier, `heap_3` simply wraps whatever C runtime implementation
    of `malloc` and `free` is available, to make it thread safe so it can be used
    by multiple tasks. This means that its behavior is going to be dependent on the
    underlying runtime implementation. If your system has RAM in several different,
    noncontiguous memory locations (for example, internal and external RAM) then `heap_5`
    can be used to combine all of these locations into one heap; otherwise, `heap_4`
    provides the same allocation, freeing, and adjacent block collation capabilities
    as `heap_5`. These are the two general-purpose heap implementations. Since they
    include code that will collate free blocks, it is possible that they will run
    for different periods of time when freeing memory. In general, it is best to avoid
    calls to `vPortMalloc` and `vPortFree` in code that requires a high degree of
    determinism. In `heap_4` and `heap_5`, calls to `vPortFree` will have the most
    amount of timing variability, since this is when adjacent block collation occurs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用动态内存时，可以使用 `heap_3`、`heap_4` 或 `heap_5`。如前所述，`heap_3` 简单地包装可用的任何C运行时 `malloc`
    和 `free` 实现，使其线程安全，以便可以被多个任务使用。这意味着其行为将取决于底层运行时实现。如果您的系统有多个不同、非连续的内存位置（例如，内部和外部RAM），则可以使用
    `heap_5` 将所有这些位置组合成一个堆；否则，`heap_4` 提供与 `heap_5` 相同的分配、释放和相邻块整理能力。这些都是两种通用堆实现。由于它们包括整理空闲块的代码，它们在释放内存时可能会运行不同时间段。一般来说，最好避免在需要高度确定性的代码中调用
    `vPortMalloc` 和 `vPortFree`。在 `heap_4` 和 `heap_5` 中，调用 `vPortFree` 将具有最大的时间变化性，因为这是相邻块整理发生的时候。
- en: In general, avoiding dynamic allocation will help to provide more robust code
    with less effort—memory leaks and fragmentation are impossible if memory is never
    freed. On the other end of the spectrum, if your application makes use of standard
    library functions, such as `printf` and string manipulation, you'll likely need
    to replace the versions of `malloc` and `free` that were included with thread-safe
    implementations. Let's take a quick look at what's involved in making sure other
    parts of the application don't end up using a heap implementation that isn't thread
    safe.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，避免动态分配可以帮助以更少的努力提供更健壮的代码——如果内存从未被释放，内存泄漏和碎片化是不可能的。在另一端，如果您的应用程序使用了标准库函数，例如
    `printf` 和字符串操作，您可能需要替换随 `malloc` 和 `free` 一起提供的版本，以使用线程安全的实现。让我们快速看一下确保应用程序的其他部分不会最终使用非线程安全的堆实现所涉及的内容。
- en: Replacing malloc and free
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换 `malloc` 和 `free`
- en: 'Many C runtimes will ship with an implementation of `malloc`, but the embedded,
    oriented versions won''t necessarily be thread safe by default. Because each C
    runtime is different, the steps needed to make `malloc` thread safe will vary.
    The included STM toolchain used in this book includes `newlib-nano` as the C runtime
    library. The following are a few notes regarding `newlib-nano`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 许多C运行时都会附带 `malloc` 的实现，但嵌入式、面向特定版本的运行时不一定默认是线程安全的。由于每个C运行时都不同，使 `malloc` 具有线程安全性的步骤也会有所不同。本书中使用的包含的STM工具链将
    `newlib-nano` 作为C运行时库。以下是一些关于 `newlib-nano` 的注意事项：
- en: '`newlib-nano` uses `malloc` and `realloc` for `stdio.h` functionality (that
    is, `printf`).'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newlib-nano` 使用 `malloc` 和 `realloc` 来实现 `stdio.h` 的功能（即 `printf`）。'
- en: '`realloc` is not directly supported by FreeRTOS heap implementations.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeRTOS堆实现不支持 `realloc`。
- en: '`FreeRTOSConfig.h` includes the `configUSE_NEWLIB_REENTRANT` setting to make
    `newlib` thread safe, but it needs to be used in conjunction with the appropriate
    implementations of all stubs. This will allow you to use newlib-based `printf`,
    `strtok`, and so on in a thread-safe manner. This option also makes general use
    case calls to `malloc` and `free` safe to use from anywhere, without you needing
    to explicitly use `pvPortMalloc` and `vPortFree`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FreeRTOSConfig.h` 包含了 `configUSE_NEWLIB_REENTRANT` 设置，以使 `newlib` 具有线程安全性，但它需要与所有存根的适当实现一起使用。这将允许您以线程安全的方式使用基于newlib的
    `printf`、`strtok` 等功能。此选项还使对 `malloc` 和 `free` 的一般用例调用在任何地方都是安全的，无需您显式使用 `pvPortMalloc`
    和 `vPortFree`。'
- en: See the Dave Nadler link in the *Further reading* section for more information
    and detailed instructions on how to use `newlib` safely in a FreeRTOS project
    with the GNU toolchain.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅“进一步阅读”部分中的Dave Nadler链接，以获取更多信息以及如何在FreeRTOS项目中使用GNU工具链安全地使用`newlib`的详细说明。
- en: Luckily, there aren't any calls to raw `malloc` in the example code included
    in this book. Normally, the STM HAL USB CDC implementation would include a call
    to `malloc`, but this was converted to a statically defined variable instead,
    which enables us to simply use the heap implementations included with FreeRTOS.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这本书中包含的示例代码中没有对原始`malloc`的调用。通常，STM HAL USB CDC实现会包含对`malloc`的调用，但这个调用被转换为一个静态定义的变量，这使得我们可以简单地使用FreeRTOS附带提供的堆实现。
- en: The `malloc` call in the STM-supplied USB stack was especially sinister because
    it occurred inside the USB interrupt, which makes it especially difficult to guarantee
    thread safety during `malloc`. This is because, for every call to `malloc`, interrupts
    would need to be disabled from within the tasks and also within interrupts that
    made calls to `malloc` (USB in this case). Rather than go through this trouble,
    the dynamic allocation was removed altogether.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: STM提供的USB堆栈中的`malloc`调用特别危险，因为它发生在USB中断中，这使得在`malloc`期间保证线程安全特别困难。这是因为，对于每次对`malloc`的调用，都需要在任务内部以及调用`malloc`的中断（在这种情况下是USB）内部禁用中断。为了避免这种麻烦，动态分配被完全移除。
- en: Now that we've come to terms with different safety options using dynamic allocation,
    let's take a look at some additional tools that FreeRTOS has for reporting the
    health of our stacks and heaps.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了使用动态分配的不同安全选项，让我们来看看FreeRTOS为我们提供的其他一些工具，用于报告我们的栈和堆的健康状况。
- en: Implementing FreeRTOS memory hooks
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现FreeRTOS内存钩子
- en: When many people first start programming in an RTOS, one of the immediate challenges
    is figuring out how to properly size the stack for each task. This can lead to
    some frustration during development because when a stack is overrun, the symptoms
    can range from odd behavior to a full system crash.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当许多人第一次开始使用实时操作系统（RTOS）编程时，一个直接的挑战是找出如何为每个任务正确地设置栈的大小。这可能导致开发过程中的某些挫折，因为当栈溢出时，症状可能从异常行为到整个系统崩溃不等。
- en: Keeping an eye on stack space
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关注栈空间
- en: '`vApplicationStackOverflowHook` provides a very simple way of eliminating most
    of the oddball behavior and halting the application. When enabling `configCHECK_FOR_STACK_OVERFLOW
    #define` in `FreeRTOSConfig.h`, any time a stack overflow is detected by FreeRTOS,
    `vApplicationStackOverflowHook` will be called.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`vApplicationStackOverflowHook`提供了一种非常简单的方法来消除大多数异常行为并停止应用程序。当在`FreeRTOSConfig.h`中启用`configCHECK_FOR_STACK_OVERFLOW
    #define`时，每当FreeRTOS检测到栈溢出时，`vApplicationStackOverflowHook`将被调用。'
- en: 'There are two potential values for `configCHECK_FOR_STACK_OVERFLOW`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`configCHECK_FOR_STACK_OVERFLOW`有两个可能的值：'
- en: '`#define configCHECK_FOR_STACK_OVERFLOW 1`: Checks the stack pointer location
    upon task exit.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#define configCHECK_FOR_STACK_OVERFLOW 1`：在任务退出时检查栈指针的位置。'
- en: '`#define configCHECK_FOR_STACK_OVERFLOW 2`: Fills the stack with a known pattern
    and checks for the pattern upon exit.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#define configCHECK_FOR_STACK_OVERFLOW 2`：在栈中填充一个已知的模式，并在退出时检查该模式。'
- en: 'The first method checks the task stack pointer as the task exits the running
    state. If the stack pointer is pointing to an invalid location (where the stack
    shouldn''t be), then an overflow has occurred:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法在任务退出运行状态时检查任务栈指针。如果栈指针指向一个无效位置（栈不应该在那里），则发生了溢出：
- en: '![](img/1207b1ce-d347-4cc1-96bb-7285577c892a.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1207b1ce-d347-4cc1-96bb-7285577c892a.png)'
- en: This method is very fast, but it has the potential to miss some stack overflows—for
    example, if the stack has grown beyond its originally allocated space, but the
    stack pointer happens to be pointing to a valid spot when checked, then the overflow
    will be missed. To combat this, a second method is also available.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常快，但它有可能错过一些栈溢出——例如，如果栈已经超出了最初分配的空间，但在检查时栈指针恰好指向一个有效位置，那么溢出就会被错过。为了解决这个问题，还有一个第二种方法可用。
- en: 'When setting `configCHECK_FOR_STACK_OVERFLOW` to 2, method 1 will be used,
    but a second method will also be employed. Instead of simply checking where the
    stack pointer is located after the task has exited the running state, the top
    16 bytes of the stack can be watermarked and analyzed upon exit. This way, if
    at any point during the task run the stack has overflowed and the data in the
    top 16 bytes has been modified, an overflow will be detected:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`configCHECK_FOR_STACK_OVERFLOW`设置为2时，将使用方法1，但还会采用第二种方法。不是简单地检查任务退出运行状态后栈指针的位置，而是在退出时对栈的顶部16个字节进行水印和分析。这样，如果在任务运行期间栈溢出并且顶部16个字节中的数据被修改，就可以检测到溢出：
- en: '![](img/ec24bea1-bff4-4004-9cc1-ab96e11ad5f5.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec24bea1-bff4-4004-9cc1-ab96e11ad5f5.png)'
- en: This method helps to ensure that, even if a stack overflow has occurred (or
    nearly occurred) at any point during the task execution, it will be detected,
    as long as the overflow passed through the upper 16 words of the stack.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法有助于确保，即使在任务执行期间的任何时刻发生了堆栈溢出（或几乎发生了），只要溢出通过了堆栈的上16个字，它就会被检测到。
- en: While these methods are good for catching stack overflows, they are not perfect—for
    example, if an array is declared on a task stack and extends past the end of the
    stack with only the end of the array being modified, then a stack overflow won't
    be detected.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些方法对于捕获堆栈溢出很有用，但它们并不完美——例如，如果一个数组在任务堆栈上声明并扩展到堆栈的末尾，只有数组的末尾被修改，那么堆栈溢出将不会被检测到。
- en: 'So, to implement a very simple hook that will stop execution when a stack overflow
    occurs, we''ll take the following simple steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了实现一个简单的钩子，在堆栈溢出发生时停止执行，我们将采取以下简单步骤：
- en: 'In `FreeRTOSConfig.h`, define the configuration flag:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FreeRTOSConfig.h` 中定义配置标志：
- en: '[PRE12]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In a `*.c` file, add the stack overflow hook:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个 `*.c` 文件中，添加堆栈溢出钩子：
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This very simple method disables all interrupts and executes an infinite loop,
    leaving no question that something has gone wrong. At this point, a debugger can
    be used to analyze which stack has overflowed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这种非常简单的方法禁用所有中断并执行一个无限循环，毫无疑问地表明出了问题。此时，可以使用调试器来分析哪个堆栈发生了溢出。
- en: Keeping an eye on heap space
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关注堆空间
- en: If your application makes regular use of the FreeRTOS heap, then you should
    strongly consider using the `configUSE_MALLOC_FAILED_HOOK` configuration and associated
    hook, `vApplicationMallocFailedHook`. This hook is called anytime a call to `pvMalloc()`
    fails.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序经常使用 FreeRTOS 堆，那么你应该强烈考虑使用 `configUSE_MALLOC_FAILED_HOOK` 配置和相关的钩子
    `vApplicationMallocFailedHook`。此钩子会在调用 `pvMalloc()` 失败时被调用。
- en: Of course, while you're doing this, you're being a responsible programmer and
    checking the return value of `malloc` and handling these error cases anyway...
    so this hook may be redundant.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当你这样做的时候，你正在做一个负责任的程序员，检查 `malloc` 的返回值并处理这些错误情况……所以这个钩子可能是多余的。
- en: 'The steps for setting this up are the same as in the previous hook:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 设置此钩子的步骤与上一个钩子相同：
- en: 'Add the following in `FreeRTOSConfig.h`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FreeRTOSConfig.h` 中添加以下内容：
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In a `*.c` file, add the failed `malloc` hook:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个 `*.c` 文件中，添加失败的 `malloc` 钩子：
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are also two helpful API functions that can be called on a regular basis
    to help get a general sense of the available space:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有两个有用的 API 函数可以定期调用，以帮助获得可用空间的一般感觉：
- en: '`xPortGetFreeHeapSize()`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xPortGetFreeHeapSize()`'
- en: '`xPortGetMinimumEverFreeHeapSize()`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xPortGetMinimumEverFreeHeapSize()`'
- en: These functions return the available heap space and the least amount of free
    heap space ever recorded. They don't, however, give any clue as to whether or
    not the free space is fragmented into small blocks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数返回可用堆空间和记录过的最少空闲堆空间。然而，它们并不提供任何关于空闲空间是否被分割成小块的线索。
- en: So, what happens if none of these safeguards provide enough peace of mind that
    each of your tasks is playing nicely with the rest of the system? Read on!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果这些安全措施中没有一项能给你足够的信心，确保你的每个任务都能与其他系统部分良好地协作，会发生什么？继续阅读！
- en: Using a memory protection unit (MPU)
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内存保护单元（MPU）
- en: A **memory protection unit** (**MPU**) continuously monitors memory access at
    a hardware level to make absolutely certain that only legal memory accesses are
    occurring; otherwise, an interrupt is raised and immediate action can be taken.
    This allows many common errors (which might otherwise go unnoticed for a period
    of time) to be immediately detected.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存保护单元**（**MPU**）在硬件级别持续监控内存访问，以确保只有合法的内存访问发生；否则，会引发中断并立即采取行动。这允许许多常见的错误（否则可能一段时间内不会被注意到）立即被检测到。'
- en: Problems like stack overflows that make a stack flow into the memory space reserved
    for another task are immediately caught when using an MPU, even if they can't
    be detected by `vApplicationStackOverflowHook`. Buffer overflows and pointer errors
    are also stopped dead in their tracks when an MPU is utilized, which makes for
    a more robust application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MPU 时，即使 `vApplicationStackOverflowHook` 无法检测到，像堆栈溢出这样使堆流向为另一个任务保留的内存空间的问题也会立即被捕获。当使用
    MPU 时，缓冲区溢出和指针错误也会被立即阻止，这使得应用程序更加健壮。
- en: 'The STM32F767 MCU includes an MPU. In order to make use of it, the MPU-enabled
    port must be used: `GCC\ARM_CM4_MPU`. This way, restricted tasks can be created
    by using `xTaskCreateRestricted`, which contains the following additional parameters:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F767 MCU 包含一个 MPU。为了使用它，必须使用启用 MPU 的端口：`GCC\ARM_CM4_MPU`。这样，可以通过使用 `xTaskCreateRestricted`
    创建受限制的任务，它包含以下附加参数：
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Restricted tasks have limited execution and memory access rights.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 受限制的任务具有有限的执行和内存访问权限。
- en: '`xTaskCreate` can be used to create tasks that either operate as standard user
    mode tasks or privileged mode tasks. In privileged mode, a task has access to
    the entire memory map, whereas in user mode, it only has access to its own flash
    and RAM that isn''t configured for privileged access only.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`xTaskCreate` 可以用来创建标准用户模式任务或特权模式任务。在特权模式下，任务可以访问整个内存映射，而在用户模式下，它只能访问自己的闪存和未配置为仅特权访问的
    RAM。'
- en: 'In order for all of this to come together, the MPU ports of FreeRTOS also require
    variables to be defined in the linker file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使所有这些内容结合在一起，FreeRTOS 的 MPU 端口还需要在链接器文件中定义变量：
- en: '| **Variable name** | **Description** |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| **变量名** | **描述** |'
- en: '| `__FLASH_segment_start__` | The start address of the flash memory |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `__FLASH_segment_start__` | 闪存的起始地址 |'
- en: '| `__FLASH_segment_end__` | The end address of the flash memory |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `__FLASH_segment_end__` | 闪存的结束地址 |'
- en: '| `__privileged_functions_end__` | The end address of the `privileged_functions`
    named section |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `__privileged_functions_end__` | `privileged_functions` 命名部分的结束地址 |'
- en: '| `__SRAM_segment_start__` | The start address of the SRAM memory |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `__SRAM_segment_start__` | SRAM 存储器的起始地址 |'
- en: '| `__SRAM_segment_end__` | The end address of the SRAM memory |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `__SRAM_segment_end__` | SRAM 存储器的结束地址 |'
- en: '| `__privileged_data_start__` | The start address of the `privileged_data` section
    |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `__privileged_data_start__` | `privileged_data` 部分的起始地址 |'
- en: '| `__privileged_data_end__` | The end address of the `privileged_data` section
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `__privileged_data_end__` | `privileged_data` 部分的结束地址 |'
- en: These variables will be placed into the `*.LD` file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量将被放置在 `*.LD` 文件中。
- en: Congratulations! You're now ready to develop your application using the MPU
    to protect against invalid data access.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在可以使用 MPU 来保护无效数据访问，准备开发你的应用程序了。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've covered static and dynamic memory allocation, all of
    the available heap implementations in FreeRTOS, and how to implement memory hooks
    that let us keep an eye on our stacks and heaps. By understanding the trade-offs
    to be made when using the different allocation schemes, you'll be in a good position
    to choose the most appropriate method for each of your future projects.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了静态和动态内存分配，FreeRTOS 中所有可用的堆实现，以及如何实现内存钩子，以便我们可以监视我们的堆栈和堆。通过了解使用不同分配方案时需要做出的权衡，你将能够为你的每个未来项目选择最合适的方法。
- en: In the next chapter, we'll discuss some of the details of using FreeRTOS in
    a multicore environment.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论在多核环境中使用 FreeRTOS 的细节。
- en: Questions
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the Appendix:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结之际，这里有一份问题列表，供你测试对本章内容的了解。你将在附录的 *评估* 部分找到答案：
- en: 'With FreeRTOS, using dynamically allocated memory is extremely safe because
    it guards against heap fragmentation:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 FreeRTOS，动态分配内存非常安全，因为它可以防止堆碎片化：
- en: 'True'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'False'
- en: 'FreeRTOS requires dynamically allocated memory to function:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FreeRTOS 需要动态分配的内存来运行：
- en: 'True'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'True'
- en: 'False'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'False'
- en: How many different heap implementations ship with FreeRTOS?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FreeRTOS 中有多少种不同的堆实现？
- en: Name two hook functions that can be used to notify you about problems with the
    heap or stack.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出两个可以用来通知你堆栈或堆问题的钩子函数。
- en: What is an MPU used for?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MPU 用于什么？
- en: Further reading
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*The Power of 10: Rules for Developing Safety-Critical Code* by *Gerard J.
    Holzmann*: [http://web.eecs.umich.edu/~imarkov/10rules.pdf](http://web.eecs.umich.edu/~imarkov/10rules.pdf)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《10条规则：开发安全关键代码的法则》* 由 *Gerard J. Holzmann* 撰写：[http://web.eecs.umich.edu/~imarkov/10rules.pdf](http://web.eecs.umich.edu/~imarkov/10rules.pdf)'
- en: 'Dave Nadler – newlib and FreeRTOS re-entry: [http://www.nadler.com/embedded/newlibAndFreeRTOS.html](http://www.nadler.com/embedded/newlibAndFreeRTOS.html)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dave Nadler – newlib 和 FreeRTOS 重入：[http://www.nadler.com/embedded/newlibAndFreeRTOS.html](http://www.nadler.com/embedded/newlibAndFreeRTOS.html)
- en: 'FreeRTOS stack overflow checking: [https://www.freertos.org/Stacks-and-stack-overflow-checking.html](https://www.freertos.org/Stacks-and-stack-overflow-checking.html)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeRTOS 栈溢出检查：[https://www.freertos.org/Stacks-and-stack-overflow-checking.html](https://www.freertos.org/Stacks-and-stack-overflow-checking.html)
