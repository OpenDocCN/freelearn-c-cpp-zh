- en: Strings, Stream Classes, and Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串、流类和正则表达式
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下内容：
- en: Creating, concatenating, and transforming strings
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、连接和转换字符串
- en: Trimming whitespace from the beginning and end of strings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符串的开头和结尾修剪空白
- en: Getting the comfort of `std::string` without the cost of constructing `std::string`
    objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不构造`std::string`对象的情况下获得`std::string`的舒适性
- en: Reading values from user input
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从用户输入中读取值
- en: Counting all words in a file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算文件中的所有单词
- en: Formatting your output with I/O stream manipulators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用I/O流操纵器格式化输出
- en: Initializing complex objects from file input
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件输入初始化复杂对象
- en: Filling containers from `std::istream` iterators
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`std::istream`迭代器填充容器
- en: Generic printing with `std::ostream` iterators
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::ostream`迭代器进行通用打印
- en: Redirect output to files for specific code sections
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输出重定向到特定代码段的文件
- en: Creating custom string classes by inheriting from `std::char_traits`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过继承`std::char_traits`创建自定义字符串类
- en: Tokenizing input with the regular expression library
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式库对输入进行标记化
- en: Comfortably pretty printing numbers differently per context on the fly
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同上下文中舒适地漂亮地打印数字
- en: Catching readable exceptions from `std::iostream` errors
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`std::iostream`错误中捕获可读的异常
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'This chapter is devoted to string handling, parsing, and printing of arbitrary
    data. For such jobs, STL provides its *I/O stream library*. The library basically
    consists of the following classes, which are each depicted in gray boxes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门讨论任意数据的字符串处理、解析和打印。对于这样的工作，STL提供了其*I/O流库*。该库基本上由以下类组成，每个类都用灰色框表示：
- en: '![](img/11e3bdf6-16ba-4b13-a4f1-07d22b52f7b8.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11e3bdf6-16ba-4b13-a4f1-07d22b52f7b8.png)'
- en: The arrows show the inheritance scheme of the classes. This might look very
    overwhelming at first, but we will get to use most of these classes in this chapter
    and get familiar with them class by class. When looking at those classes in the
    C++ STL documentation, we will not find them directly with these *exact* names.
    That is because the names in the diagram are what we see as application programmers,
    but they are really mostly just typedefs of classes with a `basic_` class name
    prefix (for example, we will have an easier job searching the STL documentation
    for `basic_istream` rather than `istream`). The `basic_*` I/O stream classes are
    templates that can be specialized for different character types. The classes in
    the diagram are specialized on `char` values. We will use these specializations
    throughout the book. If we prefix those class names with the `w` character, we
    get `wistream`, `wostream`, and so on--these are the specialization typedefs for
    `wchar_t` instead of `char`, for example.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头显示了类的继承结构。这一开始可能看起来很压抑，但在本章中我们将使用大多数这些类，并逐个熟悉它们。当查看C++ STL文档中的这些类时，我们将无法直接找到它们的*确切*名称。这是因为图表中的名称是我们作为应用程序员看到的，但它们实际上大多只是带有`basic_`类名前缀的类的typedef（例如，我们将更容易地在STL文档中搜索`basic_istream`而不是`istream`）。`basic_*`
    I/O流类是可以为不同字符类型进行特化的模板。图表中的类是针对`char`值进行特化的。我们将在整本书中使用这些特化。如果我们在这些类名前加上`w`字符，我们会得到`wistream`，`wostream`等等--这些是`wchar_t`的特化typedef，而不是`char`，例如。
- en: At the top of the diagram, we see `std::ios_base`. We will basically never use
    it directly, but it is listed for completeness because all other classes inherit
    from it. The next specialization is `std::ios` which embodies the idea of an object
    which maintains a stream of data, that can be in *good* state, run *empty* of
    data state (EOF), or some kind of *fail* state.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表的顶部，我们看到`std::ios_base`。我们基本上永远不会直接使用它，但它被列出是为了完整性，因为所有其他类都继承自它。下一个特化是`std::ios`，它体现了维护数据流的对象的概念，可以处于*良好*状态、运行*空*数据状态（EOF）或某种*失败*状态。
- en: The first specializations we are going to actually use are `std::istream` and
    `std::ostream`. The `"i"` and the `"o"` prefix stand for input and output. We
    have seen them in our earliest days of C++ programming in the simplest examples
    in form of the objects `std::cout` and `std::cin` (but also `std::cerr`). These
    are instances of those classes, which are always globally available. We do data
    output via `ostream` and input via `istream`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实际使用的第一个特化是`std::istream`和`std::ostream`。`"i"`和`"o"`前缀代表输入和输出。我们在C++编程的最早期就已经见过它们，以最简单的形式出现在`std::cout`和`std::cin`（但也有`std::cerr`）的对象中。这些是这些类的实例，它们始终全局可用。我们通过`ostream`进行数据输出，通过`istream`进行输入。
- en: 'A class which inherits from both `istream` and `ostream` is `iostream`. It
    combines both input and output capabilities. When we understand how all classes
    from the trio consisting of `istream`, `ostream` and `iostream` can be used, we
    basically are ready to immediately put all following ones to use, too:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 同时继承自`istream`和`ostream`的类是`iostream`。它结合了输入和输出功能。当我们了解到来自`istream`，`ostream`和`iostream`三者组成的所有类可以如何使用时，我们基本上已经准备好立即使用所有接下来的类了：
- en: '`ifstream`, `ofstream` and `fstream` inherit from `istream`, `ostream` and
    `iostream` respectively, but lift their capabilities to redirect the I/O from
    and to files from the computer''s *filesystem*.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifstream`，`ofstream`和`fstream`分别继承自`istream`，`ostream`和`iostream`，但它们提升了它们的能力，以重定向I/O从计算机的*文件系统*到文件。'
- en: The `istringstream`, `ostringstream` and `iostringstream` work pretty analogously.
    They help build strings in memory, and/or consuming data from them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`istringstream`，`ostringstream`和`iostringstream`的工作方式非常类似。它们帮助在内存中构建字符串，并/或从中消耗数据。'
- en: Creating, concatenating, and transforming strings
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、连接和转换字符串
- en: Even C++ programmers from the very old days will know about `std::string`. While
    string handling is tedious and painful in C, especially when parsing, concatenating,
    copying them, and so on, `std::string` is a real step forward regarding simplicity
    and safety.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是非常古老的C++程序员也会知道`std::string`。在C中，特别是在解析、连接、复制字符串等方面，字符串处理是繁琐且痛苦的，而`std::string`在简单性和安全性方面确实是一大进步。
- en: Thanks to C++11, we don't even need to copy strings when we want to transfer
    ownership to some other function or data structure anymore because we can *move*
    them. This way, there's not much overhead involved in most cases.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C++11，当我们想要将所有权转移到其他函数或数据结构时，我们甚至不需要再复制字符串，因为我们可以*移动*它们。这样，在大多数情况下，几乎没有太多的开销。
- en: The `std::string` got a few new features here and there over the last few standard
    increments. What is completely new in C++17 is `std::string_view`. We will play
    with both a bit (but there is another recipe, which concentrates more on `std::string_view`-only
    features) to get a feeling of them and how they work in the C++17 era.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`在过去几个标准增量中有一些新功能。C++17中完全新的是`std::string_view`。我们将稍微玩弄一下两者（但还有另一个配方，更集中于`std::string_view`的特性），以便对它们有所了解，并了解它们在C++17时代的工作方式。'
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We will create strings and string views and do basic concatenation and transformation
    with them in this section:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建字符串和字符串视图，并对它们进行基本的连接和转换：
- en: 'As always, we first include header files and declare that we use the `std`
    namespace:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，我们首先包括头文件并声明我们使用`std`命名空间：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s first create string objects. The most obvious way is instantiating an
    object `a` of class `string`. We control its content by giving the constructor
    a C-style string (which will be embedded in the binary as a static array containing
    characters after compiling). The constructor will copy it and make it the content
    of string object `a`. Alternatively, instead of initializing it from a C-style
    string, we can use the string literal operator `""s`. It creates a string object
    on the fly. Using that to construct object `b`, we can even use automatic type
    deduction:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先让我们创建字符串对象。最明显的方法是实例化一个`string`类的对象`a`。我们通过给构造函数传递一个C风格的字符串来控制它的内容（在编译后作为包含字符的静态数组嵌入到二进制文件中）。构造函数将复制它并将其作为字符串对象`a`的内容。或者，我们可以使用字符串字面量操作符`""s`来初始化它，而不是从C风格字符串初始化它。它可以即时创建一个字符串对象。使用它来构造对象`b`，我们甚至可以使用自动类型推断：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The strings we just created are *copying* their input from the constructor
    argument into their own buffer. In order to not copy, but *reference* the underlying
    string, we can use `string_view` instances. This class does also have a literal
    operator, and it is called `""sv`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚创建的字符串是将它们的输入从构造函数参数复制到它们自己的缓冲区中。为了不复制，而是*引用*底层字符串，我们可以使用`string_view`实例。这个类也有一个字面操作符，称为`""sv`：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Okay, now let''s play with our strings and string views. For both types, there
    are `operator<<` overloads for the `std::ostream` class, so they can be printed
    comfortably:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在让我们玩一下我们的字符串和字符串视图。对于这两种类型，`std::ostream`类都有`operator<<`的重载，因此它们可以轻松地打印出来：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The string class overloads `operator+`, so we can *add* two strings and get
    their concatenation as a result. This way, `"a" + "b"` results in `"ab"`. Concatenating
    `a` and `b` this way is easy. With `a` and `c`, it is not that easy, because c
    is not a `string`, but a `string_view`. We have to get the string out of `c` first,
    and this can be done by constructing a new string from `c`, and then adding it
    to `a`. At this point one could ask, "Wait, why are you copying `c` into an intermediate
    string object just in order to add it to `a`? Can''t you avoid that copy by using
    `c.data()`?" That is a nice idea, but it has a flaw--`string_view` instances do
    not have to carry zero-terminated strings. And this is a problem that can lead
    to buffer overflows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串类重载了`operator+`，所以我们可以*添加*两个字符串并得到它们的连接作为结果。这样，`"a" + "b"`的结果是`"ab"`。以这种方式连接`a`和`b`很容易。对于`a`和`c`，情况就不那么容易了，因为c不是一个`string`，而是一个`string_view`。我们首先必须从`c`中获取字符串，然后将其添加到`a`中。此时，有人可能会问，“等等，为什么你要将`c`复制到一个中间字符串对象中，然后再将其添加到`a`中？你不能通过使用`c.data()`来避免那个复制吗？”这是一个好主意，但它有一个缺陷--`string_view`实例不一定要携带零终止的字符串。这是一个可能导致缓冲区溢出的问题：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s create a new string, which contains all of the strings and string views
    we just created. By using `std::ostringstream`, we can *print* any variable into
    a stream object that behaves exactly like `std::cout`, but it doesn''t print to
    the shell. Instead, it prints into a *string buffer*. After we streamed all the
    variables with some separating space between them using `operator<<`, we can construct
    and print a new string object from that with `o.str()`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的字符串，其中包含我们刚刚创建的所有字符串和字符串视图。通过使用`std::ostringstream`，我们可以将任何变量*打印*到一个行为完全像`std::cout`的流对象中，但它不会打印到shell。相反，它会打印到*字符串缓冲区*中。在我们使用`operator<<`将所有变量流到一起并在它们之间使用一些分隔空间后，我们可以从中构造并打印一个新的字符串对象`o.str()`：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can now also transform that new string by converting all its letters to
    upper case, for example. The C library function `toupper`, which maps lower-case
    characters to upper-case characters and leaves other characters unchanged, is
    already available and can be combined with `std::transform` because a string is
    basically also an iterable container object with `char` items:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们还可以通过将所有字母转换为大写来转换这个新字符串，例如。C库函数`toupper`，它将小写字符映射为大写字符并保持其他字符不变，已经可用，并且可以与`std::transform`结合使用，因为字符串基本上也是一个具有`char`项的可迭代容器对象：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Compiling and running the program leads to the following output, which is just
    what we expected:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会产生以下输出，这正是我们所期望的：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Obviously, strings can be added with the `+` operator like numbers, but that
    has nothing to do with math but results in *concatenated* strings. In order to
    mix this with `string_view`, we need to convert to `std::string` first.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，字符串可以像数字一样使用`+`运算符进行相加，但这与数学无关，而是产生*连接*的字符串。为了将其与`string_view`混合使用，我们需要首先转换为`std::string`。
- en: However, it is really important to note that when mixing strings and string
    views in code, we must never assume that the underlying string behind a `string_view`
    is *zero terminated*! This is why we would rather write `"abc"s + string{some_string_view}`
    than `"abc"s + some_string_view.data()`. Aside from that, `std::string` provides
    a member function, `append`, which can handle `string_view` instances, but it
    alters the string instead of returning a new one with the string view content
    appended.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，非常重要的一点是，当在代码中混合字符串和字符串视图时，我们绝不能假设`string_view`背后的基础字符串是*零终止*的！这就是为什么我们宁愿写`"abc"s
    + string{some_string_view}`而不是`"abc"s + some_string_view.data()`。除此之外，`std::string`提供了一个成员函数`append`，可以处理`string_view`实例，但它会改变字符串，而不是返回一个新的带有字符串视图内容的字符串。
- en: '`std::string_view` is useful, but be cautious when mixing it with strings and
    string functions. We cannot assume that they are zero-terminated, which breaks
    things quickly in a standard string environment. Fortunately, there are often
    proper function overloads, which can deal with them the right way.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string_view`很有用，但在与字符串和字符串函数混合使用时要小心。我们不能假设它们是以零结尾的，这在标准字符串环境中会很快出问题。幸运的是，通常有适当的函数重载，可以正确处理它们。'
- en: If we want to do complex string concatenation with formatting and so on, we
    should however not do that piece by piece on string instances. The `std::stringstream`,
    `std::ostringstream`, and `std::istringstream` classes are much better suited
    for this, as they enhance the memory management while appending, and provide all
    the formatting features we know from streams in general. The `std::ostringstream`
    class is what we chose in this section because we were going to create a string
    instead of parsing it. An `std::istringstream` instance could have been instantiated
    from an existing string, which we could have then comfortably parsed into variables
    of other types. If we want to combine both, `std::stringstream` is the perfect
    all-rounder.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要进行复杂的字符串连接和格式化等操作，我们不应该逐个在字符串实例上执行。`std::stringstream`、`std::ostringstream`和`std::istringstream`类更适合这样做，因为它们在附加时增强了内存管理，并提供了我们从一般流中了解的所有格式化功能。在本节中，我们选择了`std::ostringstream`类，因为我们要创建一个字符串而不是解析它。`std::istringstream`实例可以从现有字符串实例中实例化，然后我们可以轻松地将其解析为其他类型的变量。如果我们想要结合两者，`std::stringstream`是完美的全能选手。
- en: Trimming whitespace from the beginning and end of strings
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修剪字符串开头和结尾的空格。
- en: Especially when obtaining strings from user input, they are often polluted with
    unneeded white space. In another recipe, we removed excess whitespace that occurred
    between words.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在从用户输入中获取字符串时，它们经常被不需要的空格污染。在另一个示例中，我们去除了单词之间出现的多余空格。
- en: Let's now have a look at strings that are surrounded by whitespace and remove
    that. The `std::string` has some nice helper functions for getting this job done.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看被空格包围的字符串并去除它。`std::string`有一些很好的辅助函数可以完成这项工作。
- en: After reading this recipe that shows how to do this with plain string objects,
    make sure to also read the following recipe. There we will see how to avoid unnecessary
    copies or data modifications with the new `std::string_view` class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读了这个使用普通字符串对象执行此操作的示例后，确保还阅读以下示例。在那里，我们将看到如何避免不必要的副本或数据修改，使用新的`std::string_view`类。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will write a helper function that identifies surrounding
    white space in a string and returns a copy without that, and then we are going
    to test it briefly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个辅助函数，用于识别字符串中的周围空格并返回一个不包含它的副本，然后我们将对其进行简要测试。
- en: 'As always, the header includes and using directive come first:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，首先是头文件包含和使用指令：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our function to trim whitespace surrounding a string takes a const reference
    to an existing string. It will return a new string without any surrounding whitespace:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的修剪字符串周围空格的函数接受一个现有字符串的常量引用。它将返回一个没有任何周围空格的新字符串：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `std::string` provides two handy functions, which help us a lot. The first
    is `string::find_first_not_of`, which accepts a string containing all the characters
    we want to skip over. This is, of course, whitespace, meaning the characters space
    `'' ''`, tab `''t''`, and new line, `''n''`. It returns us the first non-whitespace
    character position. If there is only whitespace in the string, it returns `string::npos`.
    This means that there is only an empty string left if we trim whitespace from
    it. So, in such a case, let''s just return an empty string:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::string`提供了两个很有用的函数，这些函数对我们非常有帮助。第一个是`string::find_first_not_of`，它接受一个包含我们要跳过的所有字符的字符串。这当然是空格，意味着空格字符
    `'' ''`, 制表符 `''t''` 和换行符 `''n''`。它会返回第一个非空格字符的位置。如果字符串中只有空格，它会返回`string::npos`。这意味着如果我们从中修剪空格，只剩下一个空字符串。因此，在这种情况下，让我们返回一个空字符串：'
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We know now where the new string has to begin, but we don''t yet know where
    it has to end. Therefore, we use the other handy string function `string::find_last_not_of`.
    It will return us the last character position in the string which is no whitespace:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在知道新字符串应该从哪里开始，但我们还不知道它应该在哪里结束。因此，我们使用另一个方便的字符串函数`string::find_last_not_of`。它将返回字符串中最后一个非空白字符的位置：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using `string::substr`, we can now return the part of the string, which is
    surrounded by whitespace but without the white space. This function takes two
    parameters--a *position* in the string to begin with and the *number of characters*
    after this position:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`string::substr`，我们现在可以返回由空格包围但不包含空格的字符串部分。这个函数接受两个参数--一个*位置*，表示从字符串的哪个位置开始，以及在这个位置之后的*字符数*：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'That''s it. Let''s write a main function in which we create a string that surrounds
    a text sentence with all kinds of whitespace, in order to trim it:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样。让我们编写一个主函数，在其中创建一个字符串，用各种空格包围文本句子，以便对其进行修剪：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We print the untrimmed and trimmed versions of the string. By surrounding the
    string with brackets, it''s more obvious which whitespace belonged to it prior
    to trimming:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打印字符串的未修剪和修剪版本。通过用括号括起字符串，更容易看出修剪前它包含的空格：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Compiling and running the program yields us the output we expected:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会产生我们预期的输出：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this section, we used `string::find_first_not_of` and `string::find_last_not_of`.
    Both functions accept a C-style string, which acts as a list of characters that
    should be skipped while searching a different character. If we have a string instance
    that carries the string, `"foo bar"`, and we call `find_first_not_of("bfo ")`
    on it, it will return us the value `5`, because the `'a'` character is the first
    one that is not in the `"bfo "` string. The order of the characters in the argument
    string is not important.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们使用了`string::find_first_not_of`和`string::find_last_not_of`。这两个函数都接受一个C风格的字符串，它作为一个应该在搜索不同字符时跳过的字符列表。如果我们有一个携带字符串`"foo
    bar"`的字符串实例，并且在它上调用`find_first_not_of("bfo ")`，它将返回值`5`，因为`'a'`字符是第一个不在`"bfo "`字符串中的字符。参数字符串中字符的顺序并不重要。
- en: 'The same functions exist with inverted logic, although we did not use them
    in this recipe: `string::find_first_of` and `string::find_last_of`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的函数也存在相反的逻辑，尽管我们在这个示例中没有使用它们：`string::find_first_of`和`string::find_last_of`。
- en: Similar to iterator based functions, we need to check if these functions return
    an actual position in the string or a value that denotes that they did *not* find
    a character position fulfilling the constraints. If they did not find one, they
    return `string::npos`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于迭代器的函数类似，我们需要检查这些函数是否返回字符串中的实际位置，还是表示它们*没有*找到满足约束条件的字符位置的值。如果它们没有找到，它们会返回`string::npos`。
- en: From the character positions we retrieved from these functions in our helper
    function, we built us a substring without surrounding whitespace, using `string::substring`.
    This function accepts a relative offset and a string length and then returns a
    new string instance with its own memory, which contains only that substring. For
    example, `string{"abcdef"}.substr(2, 2)` will return us a new string `"cd"`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的辅助函数中检索到的字符位置，我们建立了一个不包含周围空白的子字符串，使用`string::substring`。这个函数接受一个相对偏移和一个字符串长度，然后返回一个新的字符串实例，其中包含了那个子字符串。例如，`string{"abcdef"}.substr(2,
    2)`将返回一个新的字符串`"cd"`。
- en: Getting the comfort of std::string without the cost of constructing std::string
    objects
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获得std::string的便利性，而不需要构造std::string对象的成本
- en: The `std::string` class is a really useful class because it simplifies dealing
    with strings so much. A flaw is that if we want to pass around a substring of
    it, we need to pass a pointer and a length variable, two iterators, or a copy
    of the substring. We did that in the previous recipe, where we removed the surrounding
    whitespace from a string by taking a copy of the substring range that does not
    contain the surrounding whitespace.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`类是一个非常有用的类，因为它极大地简化了处理字符串的过程。一个缺点是，如果我们想传递它的子字符串，我们需要传递一个指针和一个长度变量，两个迭代器，或者子字符串的副本。我们在上一个示例中做到了这一点，我们通过获取不包含周围空白的子字符串范围的副本来实现了这一点。'
- en: If we want to pass a string or a substring to a library that does not even support
    `std::string`, we can only provide a raw string pointer, which is a bit disappointing,
    because it sets us back to the old C days. Just as with the substring problem,
    a raw pointer does not carry information about the string length with it. This
    way, one would have to implement a bundle of a pointer and a string length.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将字符串或子字符串传递给甚至不支持`std::string`的库，我们只能提供一个原始字符串指针，这有点令人失望，因为它让我们回到了旧的C语言时代。就像子字符串问题一样，原始指针并不携带有关字符串长度的信息。这样，一个人将不得不实现一个指针和字符串长度的捆绑。
- en: In a simplified way, this is exactly what `std::string_view` is. It is available
    since C++17 and provides a way to pair a pointer to some string together with
    that string's size. It embodies the idea of having a reference type for arrays
    of data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以简化的方式来说，这正是`std::string_view`。它自C++17起可用，并提供了一种将指向某个字符串的指针与该字符串的大小配对的方法。它体现了为数据数组提供引用类型的想法。
- en: If we design functions which formerly accepted `std::string` instances as parameters,
    but did not change them in a way that would require the string instances to reallocate
    the memory that holds the actual string payload, we could now use `std::string_view`
    and be more compatible with libraries that are STL-agnostic. We could let other
    libraries provide a `string_view` view on the payload strings behind their complex
    string implementations and then use that in our STL code. This way, the `string_view`
    class acts as a minimal and useful interface, which can be shared among different
    libraries.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设计的函数以前接受`std::string`实例作为参数，但没有改变它们以需要字符串实例重新分配保存实际字符串负载的内存的方式，我们现在可以使用`std::string_view`，并且更兼容于STL-agnostic的库。我们可以让其他库提供对其复杂字符串实现背后的负载字符串的`string_view`视图，然后在我们的STL代码中使用它。这样，`string_view`类就充当了一个最小且有用的接口，可以在不同的库之间共享。
- en: Another cool thing is that `string_view` can be used as a non-copy reference
    to substrings of larger string objects. There are a lot of possibilities to use
    it profitably. In this section, we will play around with `string_view` in order
    to get a feeling for its ups and downs. We will also see how we can hide the surrounding
    whitespace from strings by adapting string views instead of modifying or copying
    the actual string. This method avoids unnecessary copying or data modification.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很酷的事情是，`string_view`可以被用作对更大的字符串对象的子字符串的非复制引用。有很多可以利用它的可能性。在这一部分，我们将使用`string_view`来玩耍，以便对其优势和劣势有所了解。我们还将看到如何通过调整字符串视图而不是修改或复制实际字符串来隐藏字符串的周围空白。这种方法避免了不必要的复制或数据修改。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to implement a function that relies on some `string_view` features,
    and then, we see how many different types we can feed into it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个依赖于一些`string_view`特性的函数，然后，我们将看到我们可以将多少不同类型的数据输入到其中：
- en: 'The header includes and using directive come first:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先是头文件包含和使用指令：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We implement a function that accepts a `string_view` as its only argument:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了一个函数，它只接受一个`string_view`作为参数：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Before doing anything with the input string, we remove any leading and trailing
    whitespace. We are not going to change the string, but the *view* on the string
    by narrowing it down to the actual non-whitespace part of the string. The `find_first_not_of`
    function will find the first character in the string, which is not space (`''
    ''`), not a tab character (`''t''`), and not a newline character (`''n''`). With
    `remove_prefix`, we advance the internal `string_view` pointer to the first non-whitespace
    character. In case the string contains only whitespace, the `find_first_not_of`
    function returns the value `npos`, which is `size_type(-1)`. As `size_type` is
    an unsigned variable, this boils down to a very large number. So, we take the
    smaller one of both: `words_begin` or the string view''s size:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对输入字符串进行任何操作之前，我们去除任何前导和尾随空白。我们不会改变字符串，但是通过将其缩小到实际的非空白部分，*视图*会改变。`find_first_not_of`函数将找到字符串中第一个不是空格（`'
    '`）、制表符（`'t'`）和换行符（`'n'`）的字符。通过`remove_prefix`，我们将内部的`string_view`指针移动到第一个非空白字符。如果字符串只包含空白，`find_first_not_of`函数将返回值`npos`，即`size_type(-1)`。由于`size_type`是无符号变量，这将变成一个非常大的数字。因此，我们取两者中较小的一个：`words_begin`或字符串视图的大小：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We do the same with trailing whitespace. The `remove_suffix` shrinks down the
    view''s size variable:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对尾随空白做同样的处理。`remove_suffix`会缩小视图的大小变量：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we can print the string view and its length:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以打印字符串视图及其长度：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In our main function, we play around with the new `print` function by feeding
    it with completely different argument types. First, we give it a runtime `char*`
    string from the `argv` pointer. At runtime, it contains the file name of our executable.
    Then, we give it an empty `string_view` instance. We then feed it with a C-style
    static character string, and with a `""sv` literal, which constructs us a `string_view`
    on the fly. And finally, we give it an `std::string`. The nice thing is that none
    of these arguments are modified or copied in order to call the `print` function.
    No heap allocations happen. For many and/or large strings, this is very efficient:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们通过使用完全不同的参数类型来玩弄新的`print`函数。首先，我们给它一个运行时的`char*`字符串，来自`argv`指针。在运行时，它包含了我们可执行文件的文件名。然后，我们给它一个空的`string_view`实例。然后，我们用C风格的静态字符字符串和`""sv`字面量来给它提供参数，这会在我们的程序中构造一个`string_view`。最后，我们给它一个`std::string`。好处是，为了调用`print`函数，这些参数都没有被修改或复制。没有堆分配发生。对于许多和/或大字符串，这是非常高效的。
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We did not test the whitespace removal feature. So, let''s give it a string
    that has a lot of leading and trailing whitespace:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们没有测试去除空白的功能。所以，让我们给它一个有很多前导和尾随空白的字符串：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Another cool feature is that the strings `string_view` gives us access to do
    not have to be *zero-terminated*. If we construct a string, such as `"abc"`, without
    a trailing zero, the `print` function can still safely handle it because `string_view`
    also carries the size of the string it points to:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个很酷的功能是，`string_view`给我们访问的字符串不必是*零终止*的。如果我们构造一个字符串，比如`"abc"`，没有尾随零，`print`函数仍然可以安全地处理它，因为`string_view`也携带了它指向的字符串的大小：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Compiling and running the program yields the following output. All the strings
    are correctly handled. The string we filled with lots of leading and trailing
    whitespace is correctly filtered, and the `abc` string without zero termination
    is also correctly printed without any buffer overflows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会产生以下输出。所有字符串都被正确处理。我们填充了大量前导和尾随空白的字符串被正确过滤，没有零终止的`abc`字符串也被正确打印，没有任何缓冲区溢出：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have just seen that we can call a function that accepts a `string_view` argument
    with basically anything that is string like in the sense that it stores characters
    in a contiguous way. *No copy* of the underlying string was made in any of our
    `print` calls.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '我们刚刚看到，我们可以调用接受`string_view`参数的函数，基本上可以使用任何类似字符串的东西，它以连续方式存储字符。在我们的`print`调用中，没有对基础字符串进行任何*复制*。 '
- en: It is interesting to note that in our `print(argv[0])` call, the string view
    automatically determined the string length because this is a zero-terminated string
    by convention. The other way around, one cannot assume that it is possible to
    determine a `string_view` instances's data length by counting the number of items
    until a zero terminator is reached. Because of this, we must always be careful
    about where we reach around a pointer to the string view data using `string_view::data()`.
    Usual string functions mostly assume zero termination and, thus, can buffer overflow
    very badly with raw pointers to the payload of a string view. It is always better
    to use interfaces that already expect a string view.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在我们的`print(argv[0])`调用中，字符串视图自动确定了字符串长度，因为这是一个约定的零结尾字符串。反过来，不能假设可以通过计算直到达到零终止符为止的项目数来确定`string_view`实例的数据长度。因此，我们必须始终小心地处理`string_view::data()`指向的字符串视图数据的指针。通常的字符串函数大多假定零终止，因此，使用指向字符串视图有效载荷的原始指针可能会非常严重地缓冲区溢出。最好使用已经期望字符串视图的接口。
- en: Apart from that, we get a lot of the luxury interface we know from `std::string`
    already.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们已经从`std::string`中知道了很多豪华的接口。
- en: Use `std::string_view` for passing strings or substrings where you want to avoid
    copies or heap allocations, without losing the comfort of string classes. But
    be aware of the fact that `std::string_view` drops the assumption that strings
    are zero terminated.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::string_view`来传递字符串或子字符串，可以避免复制或堆分配，同时不失去字符串类的便利性。但要注意`std::string_view`放弃了字符串以零结尾的假设。
- en: Reading values from user input
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从用户输入读取值
- en: A lot of recipes in this book read values from an input source, such as standard
    input or a file, and do something with it. This time we concentrate only on the
    reading and learn more about error handling, which becomes important if reading
    something from a stream did *not* go well and we need to handle it other than
    terminating the whole program.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中的许多食谱都从输入源（如标准输入或文件）中读取数值，并对其进行处理。这次我们只关注读取，并学习更多关于错误处理的知识，如果从流中读取的内容出现问题，我们需要处理它，而不是终止整个程序。
- en: We will only read from user input in this recipe, but as soon as we know how
    to do that, we also know how to read from any other stream. User input is read
    via `std::cin`, and that is essentially an input stream object, such as instances
    of `ifstream` and `istringstream` are.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们只会从用户输入中读取，但一旦我们知道如何做到这一点，我们也知道如何从任何其他流中读取。用户输入是通过`std::cin`读取的，这本质上是一个输入流对象，就像`ifstream`和`istringstream`的实例一样。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we are going to read user input into different variables,
    and see how to handle errors, as well as how to do a little bit more complex tokenizing
    of input into useful chunks:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将读取用户输入到不同的变量中，并看看如何处理错误，以及如何将输入复杂化为有用的块：
- en: 'We only need `iostream` this time. So, let''s include this single header and
    declare that we use the `std` namespace by default:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次我们只需要`iostream`。因此，让我们包含这个单一的头文件，并声明我们默认使用`std`命名空间：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s first prompt the user to enter two numbers. We will parse them into
    an `int` and a `double` variable. The user can separate them with white space.
    `1 2.3`, for example, is a valid input:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先提示用户输入两个数字。我们将把它们解析成一个`int`和一个`double`变量。用户可以用空格分隔它们。例如，`1 2.3`是一个有效的输入：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Parsing and error checking is done at the same time in the condition part of
    our `if` branch. Only if both the numbers could be parsed are they meaningful
    to us and we print them:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析和错误检查同时在`if`分支的条件部分完成。只有在两个数字都能解析出来时，它们对我们才有意义，我们才会打印它们：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the parsing did not succeed for any reason, we tell the user that the parsing
    did not go well. The `cin` stream object is now in a *fail state* and will not
    give us other input until we clear the fail state again. In order to be able to
    parse a new input afterward, we call `cin.clear()` and drop all input we received
    until now. The dropping is done with `cin.ignore`, where we specify that we are
    dropping the maximum number of characters until we finally see a newline character,
    which is also dropped. Everything after that is interesting input again:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果由于任何原因解析失败，我们会告诉用户解析没有成功。`cin`流对象现在处于*失败状态*，直到我们再次清除失败状态之前，它不会给我们其他输入。为了能够解析新的输入，我们调用`cin.clear()`并丢弃到目前为止收到的所有输入。丢弃是用`cin.ignore`完成的，我们指定丢弃最大数量的字符，直到最终看到换行符，然后将其丢弃。之后的所有内容又变得有趣起来：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s now ask for some other input. We let the user enter names. As names
    can consist multiple words separated by spaces, the space character is not a good
    separator any longer. Therefore, we use `std::getline`, which accepts a stream
    object, such as `cin`, a string reference where it will copy the input into, and
    a separating character. Let''s choose comma (`,`) as the separating character.
    By not just using `cin` alone and by using `cin >> ws` as a stream parameter for
    `getline` instead, we can make `cin` drop any leading whitespace before any name.
    In every loop step, we print the current name, but if a name is empty, we drop
    out of the loop:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们要求输入其他内容。我们让用户输入名字。由于名字可以由多个用空格分隔的单词组成，空格字符不再是一个好的分隔符。因此，我们使用`std::getline`，它接受一个流对象，比如`cin`，一个字符串引用，它将把输入复制到其中，以及一个分隔字符。让我们选择逗号（`,`）作为分隔字符。通过不仅仅使用`cin`，而是使用`cin
    >> ws`作为`getline`的流参数，我们可以使`cin`在任何名字之前丢弃任何前导空格。在每个循环步骤中，我们打印当前的名字，但如果一个名字是空的，我们就退出循环：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Compiling and running the program leads to the following output, in which we
    assumingly entered only valid inputs. The numbers are `"1 2"`, which are parsed
    correctly, and then we enter some names which are then also listed correctly.
    An empty name input in the form of two consecutive commas quits the loop:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会产生以下输出，假设我们只输入了有效的输入。数字是`"1 2"`，被正确解析，然后我们输入一些名字，它们也被正确列出。以两个连续逗号的形式输入空名字会退出循环：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When running the program again, while entering bad numbers in the beginning,
    we see that the program correctly takes the other branch, drops the bad input
    and correctly continues with the name listening. Play around with the `cin.clear()`
    and `cin.ignore(...)` lines to see how that tampers with the name reading code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当再次运行程序时，在开始输入错误的数字时，我们看到程序正确地选择了另一个分支，丢弃了错误的输入，并正确地继续了名字的输入。尝试使用`cin.clear()`和`cin.ignore(...)`行，看看它们如何影响名字读取代码：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We did some complex input retrieval in this section. The first noticeable thing
    is that we always did the retrieval and error checking at the same time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们进行了一些复杂的输入检索。首先要注意的是，我们总是同时进行检索和错误检查。
- en: The result of the expression `cin >> x` is again a reference to `cin`. This
    way, we can write `cin >> x >> y >> z >> ...`. At the same time, it is possible
    to convert it into a Boolean value by using it in a Boolean context such as `if`
    conditions. The Boolean value tells us if the last read was successful. That is
    why we were able to write `if (cin >> x >> y) {...}`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`cin >> x`的结果再次是对`cin`的引用。这样，我们可以写`cin >> x >> y >> z >> ...`。同时，它也可以在布尔上下文中转换为布尔值，比如`if`条件中。布尔值告诉我们最后一次读取是否成功。这就是为什么我们能够写`if
    (cin >> x >> y) {...}`。
- en: If we, for example, try to read an integer, but the input contains `"foobar"`
    as the next token, then parsing this into the integer is not possible and the
    stream object enters a *fail state*. This is only critical for the parsing attempt
    but not for the whole program. It is okay to reset it and then to try anything
    else. In our recipe program, we tried to read a list of names after a potentially
    failing attempt to read two numbers. In the case of a failing attempt to read
    those numbers in, we used `cin.clear()` to put `cin` back into a working state.
    But then, its internal cursor was still on what we typed instead of numbers. In
    order to drop this old input and clear the pipe for the names input, we used the
    very long expression, `cin.ignore(std::numeric_limits<std::streamsize>::max(),
    'n');`. This is necessary to clear whatever is in the buffer at this point, because
    we want to start with a really fresh buffer when we ask the user for a list of
    names.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们尝试读取一个整数，但输入包含`"foobar"`作为下一个标记，那么将其解析为整数是不可能的，流对象进入*失败状态*。这只对解析尝试很重要，但对整个程序并不重要。重置它然后尝试其他任何事情都是可以的。在我们的配方程序中，我们尝试在尝试读取两个数字失败后读取一系列名称。在尝试读取这些数字失败的情况下，我们使用`cin.clear()`将`cin`恢复到工作状态。但是，它的内部光标仍然停留在我们键入的内容而不是数字上。为了丢弃这个旧输入并清除名称输入的管道，我们使用了非常长的表达式`cin.ignore(std::numeric_limits<std::streamsize>::max(),
    'n');`。这是必要的，因为我们想要从一个真正新鲜的缓冲区开始，当我们要求用户提供一系列名称时。
- en: 'The following loop might look strange at first, too:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的循环一开始可能看起来很奇怪：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the conditional part of the `for` loop, we use `getline`. The `getline` function
    accepts an input stream object, a string reference as an output parameter, and
    a delimiter character. By default, the delimiter character is the newline symbol.
    Here, we defined it to be the comma (`,`) character, so all the names in a list,
    such as `"john, carl, frank"`, are read individually.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环的条件部分中，我们使用`getline`。`getline`函数接受一个输入流对象，一个字符串引用作为输出参数，以及一个分隔符字符。默认情况下，分隔符字符是换行符。在这里，我们将其定义为逗号（`,`）字符，因此列表中的所有名称，例如`"john,
    carl, frank"`，都将被单独读取。
- en: So far, so good. But what does it mean to provide the `cin >> ws` function as
    a stream object? This makes `cin` first flush all the whitespace, which lead before
    the next non-whitespace character and after the last comma. Looking back at the
    `"john, carl, frank"` example, we would get the substrings `"john"`, `" carl"`,
    and `" frank"` without using `ws`. Notice the unnecessary leading space characters
    for `carl` and `frank`? These effectively vanish because of our `ws` pretreatment
    of the input stream.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好。但是将`cin >> ws`函数作为流对象提供是什么意思呢？这使得`cin`首先刷新所有空白字符，这些空白字符位于下一个非空白字符之前和最后一个逗号之后。回顾一下`"john,
    carl, frank"`的例子，我们将得到子字符串`"john"`，`" carl"`和`" frank"`，而不使用`ws`。注意`carl`和`frank`的不必要的前导空格字符？由于我们对输入流的`ws`预处理，这些实际上消失了。
- en: Counting all words in a file
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文件中计算所有单词
- en: Let's say we read a text file and we want to count the number of words in the
    text. We define that one word is a range of characters between whitespace characters.
    How do we do it?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们读取一个文本文件，并且想要计算文本中的单词数。我们定义一个单词是两个空格字符之间的字符范围。我们该如何做呢？
- en: We could count the number of spaces, for example, because there must be spaces
    between words. In the sentence, `"John has a funny little dog."`, we have five
    space characters, so we could say there are six words.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以计算空格的数量，例如，因为单词之间必须有空格。在句子`"John has a funny little dog."`中，我们有五个空格字符，所以我们可以说有六个单词。
- en: What if we have a sentence with whitespace noise, such as `" John has t anfunny
    little dog ."`? There are way too many unnecessary spaces in this string, and
    it's not even only spaces. From the other recipes in this book, we already learned
    how we can remove such excess whitespace. So, we could first preprocess the string
    into a normal sentence form and then apply the strategy of counting space characters.
    Yes, that is doable, but there is a *much* easier way. Why shouldn't we use what
    the STL already provides us?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个带有空格噪音的句子，例如`" John has t anfunny little dog ."`？这个字符串中有太多不必要的空格，甚至不仅仅是空格。从本书的其他配方中，我们已经学会了如何去除这种多余的空格。因此，我们可以首先将字符串预处理为正常的句子形式，然后应用计算空格字符的策略。是的，这是可行的，但有一个*更*简单的方法。为什么我们不使用STL已经提供给我们的东西呢？
- en: In addition to finding an elegant solution for this problem, we will let the
    user choose if we shall count the words from the standard input or a text file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为这个问题找到一个优雅的解决方案之外，我们还将让用户选择是否从标准输入或文本文件中计算单词。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we will write a one-liner function that counts the words from
    an input buffer, and let the user choose where the input buffer reads from:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个一行函数，用于计算输入缓冲区中的单词，并让用户选择输入缓冲区的读取位置：
- en: 'Let''s include all the necessary headers first and declare that we use the
    `std` namespace:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先让我们包括所有必要的头文件，并声明我们使用`std`命名空间：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Our `wordcount` function accepts an input stream, for example, `cin`. It creates
    an `std::input_iterator` iterator, which tokenizes the strings out of the stream
    and then feeds them to `std::distance`. The `distance` parameter accepts two iterators
    as arguments and tries to determine how many incrementing steps are needed in
    order to get from one iterator position to the other. For *random access* iterators,
    this is simple because they implement the mathematical difference operation (`operator-`).
    Such iterators can be subtracted from each other like pointers. An `istream_iterator`
    however, is a *forward* iterator and must be advanced until it equals the end
    iterator. Eventually, the number of steps needed is the number of words:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`wordcount`函数接受一个输入流，例如`cin`。它创建一个`std::input_iterator`迭代器，该迭代器从流中标记字符串，然后将它们传递给`std::distance`。`distance`参数接受两个迭代器作为参数，并尝试确定从一个迭代器位置到另一个迭代器位置需要多少递增步骤。对于*随机访问*迭代器来说，这很简单，因为它们实现了数学差异操作（`operator-`）。这样的迭代器可以像指针一样相互减去。然而，`istream_iterator`是*前向*迭代器，必须一直前进直到等于结束迭代器。最终，所需的步骤数就是单词数：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In our main function, we let the user choose if the input stream will be `std::cin`
    or an input file:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们让用户选择输入流是`std::cin`还是输入文件：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If the user launches the program in the shell together with a file name (such
    as `$ ./count_all_words some_textfile.txt`), then we obtain that filename from
    the `argv` command-line parameter array and open it, in order to feed the new
    input file stream into `wordcount`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户在shell中与文件名一起启动程序（例如`$ ./count_all_words some_textfile.txt`），那么我们将从`argv`命令行参数数组中获取该文件名，并打开它，以便将新的输入文件流输入到`wordcount`中：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If the user launched the program without any parameter, we assume that the
    input comes from standard input:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户在没有任何参数的情况下启动程序，我们假设输入来自标准输入：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'That''s already it, so we just print the number of words we saved in the variable
    `wc`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样，所以我们只需打印我们保存在变量`wc`中的单词数：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s compile and run the program. First, we feed the program from standard
    input without any file parameter. We can either pipe an echo call with some words
    into it or launch the program and enter some words from the keyboard. In the latter
    case, we can stop the input by pressing *Ctrl*+*D*. This is how echoing some words
    into the program looks:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译并运行程序。首先，我们从标准输入中输入程序，没有任何文件参数。我们可以通过管道将echo调用与一些单词一起输入，或者启动程序并从键盘输入一些单词。在后一种情况下，我们可以通过按*Ctrl*+*D*来停止输入。这是将一些单词回显到程序中的方式：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When launching the program with its source code file as input, it will count
    how many words it consists of:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当以源代码文件作为输入启动程序时，它将计算它由多少个单词组成：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There is not much left to say; most of it has been explained while implementing
    it as this program is very short. One thing we could elaborate on a bit is the
    fact that we used `std::cin` and an `std::ifstream` instance in a completely interchangeable
    way. The `cin` is of the `std::istream` type, and `std::ifstream` inherits from
    `std::istream`. Have a look at the class inheritance diagram at the beginning
    of this chapter. This way, they are completely interchangeable, even at runtime.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 没有太多要说的了；大部分内容在实现时已经解释过了，因为这个程序非常简短。我们可以详细介绍一点的是，我们完全可以以相互替换的方式使用`std::cin`和`std::ifstream`实例。`cin`是`std::istream`类型，而`std::ifstream`继承自`std::istream`。看一下本章开头的类继承图表。这样，它们在运行时是完全可以互换的。
- en: Keep your code modular by using stream abstractions. This helps decouple source
    code parts and makes your code easy to test because you can just inject any other
    matching type of stream.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用流抽象来保持代码模块化。这有助于解耦源代码部分，并使您的代码易于测试，因为您可以注入任何其他匹配类型的流。
- en: Formatting your output with I/O stream manipulators
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用I/O流操纵器格式化输出
- en: In many cases, just printing out strings and numbers is not enough. Sometimes,
    numbers need to be printed as decimal numbers, sometimes as hexadecimal, and sometimes
    even as octal. Sometimes we want to see a `"0x"` prefix in front of hexadecimal
    numbers, sometimes not.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，仅仅打印字符串和数字是不够的。有时，数字需要以十进制数打印，有时以十六进制数打印，有时甚至以八进制数打印。有时我们希望在十六进制数前面看到`"0x"`前缀，有时不希望。
- en: When printing floating-point numbers, there are also a lot of things we may
    want to have an influence on. Should the decimal values always be printed with
    the same precision? Should they be printed at all? Or perhaps, we want a scientific
    notation?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印浮点数时，我们可能也有很多事情想要影响。小数值是否总是以相同的精度打印？它们是否应该被打印？或者，也许我们想要科学计数法？
- en: Apart from scientific presentation and hexadecimal, octal, and so on, we also
    want to present the user output in a tidy form. Some output can be arranged in
    tables, for example, in order to make it as readable as possible.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了科学表示法和十六进制、八进制等，我们还希望以整洁的形式呈现用户输出。有些输出可以以表格的形式排列，以使其尽可能可读。
- en: All these things are, of course, possible with output streams. Some of these
    settings are also important when *parsing* values from input streams. In this
    recipe, we will get a feeling of such so-called **I/O manipulators** by playing
    around with them. Sometimes, they appear tricky, so we will also get into some
    details.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，所有这些都可以通过输出流实现。当从输入流中*解析*值时，其中一些设置也很重要。在本教程中，我们将通过玩弄这些所谓的**I/O操纵器**来感受一下。有时，它们看起来很棘手，所以我们也会深入一些细节。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we will print numbers with wildly varying format settings,
    in order to get familiar with I/O manipulators:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用各种格式设置打印数字，以便熟悉I/O操纵器：
- en: 'First, we include all the necessary headers and declare that we use the `std`
    namespace by default:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包括所有必要的标头，并声明我们默认使用`std`命名空间：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we define a helper function that prints a single integer value with different
    styles. It accepts a padding width and a filling character for padding, which
    is set to space `'' ''` by default:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个辅助函数，它以不同的样式打印单个整数值。它接受填充宽度和填充字符，默认为空格`' '`：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With `setw`, we can set the minimum number of characters output for printing
    a number. If we print `123` with a width of `6`, for example, we get `" 123"`,
    or `"123 "`. We can control on which side the padding occurs with `std::left`,
    `std::right`, and `std::internal`. When printing numbers in the decimal form,
    `internal` looks identical to `right`. But if we print the value `0x1`, for example,
    with a width of `6` and with `internal`, we get `"0x 6"`. The `setfill` manipulator
    defines the character that will be used for padding. We will try different styles:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`setw`，我们可以设置打印数字时的最小字符数。例如，如果我们以宽度为`6`打印`123`，我们会得到`" 123"`或`"123 "`。我们可以使用`std::left`、`std::right`和`std::internal`控制填充发生在哪一侧。在以十进制形式打印数字时，`internal`看起来与`right`相同。但是，例如，如果我们以宽度为`6`和`internal`打印值`0x1`，我们会得到`"0x
    6"`。`setfill`操纵器定义了用于填充的字符。我们将尝试不同的样式：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the main function, we start using the function we just implemented. At first,
    we print the value `12345`, with a width of `15`. We do this twice, but the second
    time, we use the `''_''` character for padding:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们开始使用刚刚实现的函数。首先，我们打印值`12345`，宽度为`15`。我们这样做两次，但第二次，我们使用`'_'`字符进行填充：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Afterward, we print the value `0x123abc` with the same width as before. However,
    before doing this, we apply `std::hex` and `std::showbase` to tell the output
    stream object `cout` that it should print numbers in the hexadecimal format and
    that it should prepend `"0x"` to them so that it is obvious that they are to be
    interpreted as hex:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们以与之前相同的宽度打印值`0x123abc`。但在这之前，我们应用了`std::hex`和`std::showbase`，告诉输出流对象`cout`应该以十六进制格式打印数字，并且应该在它们前面添加`"0x"`，以便明确表示它们应该被解释为十六进制：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can do the same with `oct`, which tells `cout` to use the octal system for
    printing numbers. The `showbase` is still active, so `0` will be prepended to
    every printed number:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以使用`oct`做同样的事情，告诉`cout`使用八进制系统来打印数字。`showbase`仍然有效，因此`0`将被添加到每个打印的数字前面：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'With `hex` and `uppercase`, we get the `''x''` in `"0x"` printed upper case.
    The `''abc''` in `''0x123abc''` is also upper cased:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`hex`和`uppercase`，我们得到了`"0x"`中的`'x'`大写打印。`'0x123abc'`中的`'abc'`也是大写的：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we want to print `100` in the decimal format again, we have to remember
    that we switched the stream to `hex` before. By using `dec`, we can put it back
    to normal:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想再次以十进制格式打印`100`，我们必须记住之前已经将流切换为`hex`。通过使用`dec`，我们可以将其恢复为正常状态：
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can also configure how Boolean values are printed. By default, `true` is
    printed as `1` and `false` as `0`. With `boolalpha`, we can set it to a text representation:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以配置布尔值的打印方式。默认情况下，`true`打印为`1`，`false`打印为`0`。使用`boolalpha`，我们可以将其设置为文本表示：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s have a look at floating-point variables of the `float` and `double`
    types. If we print a number such as `12.3`, it is printed as `12.3`, of course.
    If we have a number such as `12.0`, the output stream will just drop the decimal
    point, which we can change with `showpoint`. Using this, the decimal point is
    always displayed:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看看`float`和`double`类型的浮点变量。如果我们打印一个数字，比如`12.3`，它当然会打印为`12.3`。如果我们有一个数字，比如`12.0`，输出流将会去掉小数点，我们可以使用`showpoint`来改变这一点。使用这个，小数点总是会显示：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The representation of a floating-point number can be scientific or fixed. `scientific`
    means that the number is *normalized* to such a form that the first digit is the
    only digit before the decimal point, and then the exponent is printed, which is
    needed to multiply the number back to its actual size. For example, the value
    `300.0` would be printed as `"3.0E2"`, because `300` equals `3.0 * 10^2`. `fixed`
    reverts back to the normal decimal point notation:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浮点数的表示可以是科学或固定的。`scientific`表示数字被*标准化*为这样一种形式，即小数点前只有一个数字，然后打印出指数，这是将数字乘回其实际大小所需的。例如，值`300.0`将被打印为`"3.0E2"`，因为`300`等于`3.0
    * 10^2`。`fixed`则恢复为正常的十进制表示法：
- en: '[PRE51]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Apart from the notation, we can also decide with what precision a floating-point
    number is printed. Let''s create a very small value and print it with 10 digits
    after the decimal point, and once with just one digit after the decimal point:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了表示法，我们还可以决定浮点数打印的精度。让我们创建一个非常小的值，并以小数点后10位的精度打印它，然后再以小数点后只有一位的精度打印它：
- en: '[PRE52]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Compiling and running the program yields us the following lengthy output. Those
    four first blocks of output are from the print helper function that tampered around
    with the `setw` and `left`/`right`/`internal` modifiers. Afterward, we played
    with the casing of base representations, Boolean representation, and floating-point
    formatting. It is a good idea to play with each of these to get familiar with
    them:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行程序会产生以下冗长的输出。前四个输出块是打印助手函数的输出，该函数对`setw`和`left`/`right`/`internal`修饰符进行了调整。之后，我们对基本表示、布尔表示和浮点数格式进行了调整。熟悉每种格式是个好主意：
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'All these, sometimes pretty long, `<< foo << bar` stream expressions are really
    confusing if it is not clear to the reader what each of them does. Therefore,
    let''s have a look at a table of existing formatting modifiers. They are all to
    be placed in a `input_stream >> modifier` or `output_stream << modifier` expression
    and then affect the following input or output:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些有时相当长的`<< foo << bar`流表达式如果读者不清楚每个表达式的含义，会让人感到困惑。因此，让我们来看一下现有格式修饰符的表格。它们都应该放在`input_stream
    >> modifier`或`output_stream << modifier`表达式中，然后影响接下来的输入或输出：
- en: '| **Symbol** | **Meaning** |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **含义** |'
- en: '| `setprecision(int n)` | Sets the precision parameter when printing or parsing
    floating-point values. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `setprecision(int n)` | 设置打印或解析浮点值时的精度参数。 |'
- en: '| `showpoint` / `noshowpoint` | Enables or disables the printing of the decimal
    point of floating-point numbers even if they do not have any decimal places. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `showpoint` / `noshowpoint` | 启用或禁用打印浮点数的小数点，即使它们没有任何小数位 |'
- en: '| `fixed` / `scientific` / `hexfloat` / `defaultfloat` | Numbers can be printed
    in a fixed style (which is the most intuitive one) or scientific style. `fixed`
    and `scientific` stand for these modes. `hexfloat` activates both modes, which
    formats floating-point numbers in hexadecimal floating-point notation. `defaultfloat`
    deactivates both modes. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `fixed` / `scientific` / `hexfloat` / `defaultfloat` | 数字可以以固定样式（这是最直观的样式）或科学样式打印。`fixed`和`scientific`代表这些模式。`hexfloat`激活这两种模式，它以十六进制浮点表示法格式化浮点数。`defaultfloat`取消这两种模式。'
- en: '| `showpos` / `noshowpos` | Enable or disable printing a `''+''` prefix for
    positive floating-point values. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `showpos` / `noshowpos` | 启用或禁用打印正浮点值的`''+''`前缀 |'
- en: '| `setw(int n)` | Read or write exactly `n` characters. When reading, this
    truncates the input. When printing, padding is applied if the output would be
    shorter than `n` characters. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `setw(int n)` | 读取或写入确切的`n`个字符。在读取时，这会截断输入。在打印时，如果输出长度小于`n`个字符，则会应用填充。'
- en: '| `setfill(char c)` | When applying padding (see `setw`), fill the output with
    character values, `c`. The default is space (`'' ''`). |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `setfill(char c)` | 在应用填充（参见`setw`）时，用字符值`c`填充输出。默认值是空格（`'' ''`）。 |'
- en: '| `internal` / `left` / `right` | `left` and `right` control where the padding
    for fixed-width prints (see `setw`) occurs. `internal` puts padding characters
    in the middle between integers and their negative sign, the hex prefix and a hexadecimally
    printed value, or monetary units and values. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `internal` / `left` / `right` | `left`和`right`控制固定宽度打印（参见`setw`）的填充位置。`internal`将填充字符放在整数及其负号、十六进制前缀和十六进制打印值，或货币单位和值之间的中间位置。'
- en: '| `dec` / `hex` / `oct` | Integral values can be printed and parsed in the
    decimal, hexadecimal, and octal base systems. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `dec` / `hex` / `oct` | 可以在十进制、十六进制和八进制基数系统中打印和解析整数值 |'
- en: '| `setbase(int n)` | This is the numeric synonymous function to `dec`/`hex`/`oct`,
    which are equivalent if used with the values `10`/`16`/`8`. Other values reset
    the base choice to `0`, which leads to decimal printing again, or parsing based
    on the prefix of the input. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `setbase(int n)` | 这是`dec`/`hex`/`oct`的数值同义函数，如果与值`10`/`16`/`8`一起使用，则它们是等效的。其他值会将基础选择重置为`0`，这将再次导致十进制打印，或者根据输入的前缀进行解析。
    |'
- en: '| `quoted(string)` | Prints string in quotes or parse from quoted input, and
    then drops the quotes. `string` can be a String class instance or a C-style character
    array. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `quoted(string)` | 以引号打印字符串或从带引号的输入中解析字符串，然后删除引号。`string`可以是String类实例或C风格的字符数组。
    |'
- en: '| `boolalpha` / `noboolalpha` | Prints or parses Boolean values as/from alphabetical
    representation rather than `1`/`0` strings. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `boolalpha` / `noboolalpha` | 以字母表示形式而不是`1`/`0`字符串打印或解析布尔值 |'
- en: '| `showbase` / `noshowbase` | Enables or disables base-prefixes when printing
    or parsing numbers. For `hex`, this is `0x`; for `octal` it is `0`. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `showbase` / `noshowbase` | 在打印或解析数字时启用或禁用基数前缀。对于`hex`，这是`0x`；对于`octal`，这是`0`。
    |'
- en: '| `uppercase` / `nouppercase` | Enables or disables upper casing or alphabetical
    characters when printing floating-point and hexadecimal values. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `uppercase` / `nouppercase` | 在打印浮点和十六进制值时启用或禁用大写或字母字符 |'
- en: The best way to get familiar with those is studying their variety a bit and
    playing with them.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉它们的最佳方法是稍微研究它们的多样性并与它们玩耍。
- en: When playing with them, however, we might have noticed already that most of
    these modifiers appear to be *sticky* and a few of them, not so. Sticky means
    that once applied, they appear to influence the input/output *forever* until they
    are reset again. The only non-sticky ones from this table are `setw` and `quoted`.
    They only affect the next item in the input/output. This is important to know
    because if we print some output with certain formatting, we should tidy up our
    stream object formatting settings afterward, because the next output from unrelated
    code may otherwise look crazy. Same applies to input parsing, where things can
    break with the wrong I/O manipulator options.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在与它们玩耍时，我们可能已经注意到这些修改器中的大多数似乎是*粘性的*，而其中一些则不是。粘性意味着一旦应用，它们似乎会永久地影响输入/输出，直到它们再次被重置。此表中唯一不粘性的是`setw`和`quoted`。它们只影响输入/输出中的下一项。这是很重要的，因为如果我们以某种格式打印一些输出，我们应该在之后整理我们的流对象格式设置，因为来自不相关代码的下一个输出可能看起来很疯狂。同样适用于输入解析，其中错误的I/O操作器选项可能会导致问题。
- en: 'We did not really use any of those because they do not have to do anything
    with formatting, but for the reason of completeness, we should also have a look
    at some other stream state manipulators:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有真正使用它们中的任何一个，因为它们与格式无关，但出于完整性的原因，我们也应该看一下其他一些流状态操作器：
- en: '| **Symbol** | **Meaning** |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **含义** |'
- en: '| `skipws` / `noskipws` | Enables or disables the feature of input streams
    skipping whitespace |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `skipws` / `noskipws` | 启用或禁用输入流跳过空白的功能 |'
- en: '| `unitbuf` / `nounitbuf` | Enables or disables immediate output buffer flushing
    after any output operation |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `unitbuf` / `nounitbuf` | 启用或禁用任何输出操作后立即刷新输出缓冲区 |'
- en: '| `ws` | Can be used on input streams to skip any whitespace at the head of
    the stream |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `ws` | 可以在输入流上使用，以跳过流头部的任何空白 |'
- en: '| `ends` | Writes a string-terminating `''''` character into a stream |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `ends` | 在流中写入一个字符串终止`''''`字符 |'
- en: '| `flush` | Immediately flushes out whatever is in the output buffer |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `flush` | 立即刷新输出缓冲区中的内容 |'
- en: '| `endl` | Inserts a `''n''` character into an output stream and flushes the
    output |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `endl` | 在输出流中插入一个 `''n''` 字符并刷新输出 |'
- en: From these, only `skipws`/`noskipws` and `unitbuf`/`nounitbuf` appear sticky.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从中，只有`skipws`/`noskipws`和`unitbuf`/`nounitbuf`是粘性的。
- en: Initializing complex objects from file input
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件输入初始化复杂对象
- en: Reading in individual integers, floats, and word strings is really easy, because
    the `>>` operator of input stream objects is overloaded for all these types, and
    input streams conveniently drop all in-between whitespace for us.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 读取单独的整数、浮点数和单词字符串非常容易，因为输入流对象的 `>>` 操作符已经为所有这些类型重载了，并且输入流方便地为我们删除了所有中间的空白。
- en: But what if we have a more complex structure that we want to read from an input
    stream, and if we need to read strings that contain more than one word (as they
    would normally be chunked into single words because of the whitespace skipping)?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们有一个更复杂的结构，我们想要从输入流中读取，如果我们需要读取包含多个单词的字符串（因为它们通常会被分成单个单词，因为空白会被跳过），那该怎么办呢？
- en: For any type, it is possible to provide another input stream `operator>>` overload,
    and we are going to see how to do it.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何类型，都可以提供另一个输入流 `operator>>` 重载，我们将看到如何做到这一点。
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we''ll define a custom data structure and provide facilities
    to read such items from input streams as standard input:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将定义一个自定义数据结构，并提供从标准输入流中读取这些项目的功能：
- en: 'We need to include some headers first and for comfort, we declare that we use
    the `std` namespace by default:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要包含一些头文件，并且为了方便起见，我们声明默认使用 `std` 命名空间：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As a complex object example, we define a `city` structure. A city shall have
    a name, a population count, and geographic coordinates:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为一个复杂对象的例子，我们定义了一个 `city` 结构。一个城市应该有一个名称、一个人口数量和地理坐标：
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In order to be able to read such a city from a serial input stream, we need
    to overload the stream function `operator>>`. In this operator, we first skip
    all the leading whitespace with `ws`, because we do not want whitespace to pollute
    the city name. Then, we read a whole line of text input. This implies that in
    the input file, there is a whole text line only carrying the name of a city object.
    Then, after a newline character, a whitespace-separated list of numbers follows,
    indicating the population, the geographic latitude, and the longitude:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够从串行输入流中读取这样一个城市，我们需要重载流函数 `operator>>`。在这个操作符中，我们首先使用 `ws` 跳过所有前导空白，因为我们不希望空白污染城市名称。然后，我们读取一整行文本输入。这意味着在输入文件中，只有一整行文本只携带城市对象的名称。然后，在换行符之后，跟着一个以空格分隔的数字列表，表示人口数量、地理纬度和经度：
- en: '[PRE56]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In our main function, we create a vector that can hold a range of city items.
    We fill it using `std::copy`. The input of the copy call is an `istream_iterator`
    range. By giving it the `city` struct type as a template parameter, it will use
    the `operator>>` function overload, which we just implemented:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们创建了一个可以容纳一系列城市项目的向量。我们使用 `std::copy` 来填充它。复制调用的输入是一个 `istream_iterator`
    范围。通过将 `city` 结构类型作为模板参数传递给它，它将使用我们刚刚实现的 `operator>>` 函数重载：
- en: '[PRE57]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In order to see whether our city parsing went right, we print what we got in
    the list. The I/O formatting, `left << setw(15) <<`, leads to the city name being
    filled with whitespace, so we get our output in a nicely readable form:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查看我们的城市解析是否正确，我们打印了列表中的内容。I/O 格式化，`left << setw(15) <<`，导致城市名称被填充了空白，所以我们得到了一个很好的可读形式的输出：
- en: '[PRE58]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The text file from which we will feed our program looks like this. There are
    four example cities with their population count and geographical coordinates:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将喂给我们的程序的文本文件看起来像这样。有四个示例城市及其人口数量和地理坐标：
- en: '[PRE59]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Compiling and running the program yields the following output, which is what
    we expected. Try to tamper around with the input file by adding some unnecessary
    whitespace before the city names in order to see how it gets filtered out:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生了以下输出，这正是我们所期望的。尝试通过在城市名称之前添加一些不必要的空白来篡改输入文件，以查看它是如何被过滤掉的：
- en: '[PRE60]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This was another short recipe again. The only thing we did was creating a new
    struct `city`, then we overloaded `std::istream` iterator's `operator>>` for this
    type and that's it. This already enabled us to deserialize city items from standard
    input using `istream_iterator<city>`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个简短的示例。我们所做的唯一的事情就是创建一个新的结构 `city`，然后为这种类型重载 `std::istream` 迭代器的 `operator>>`，就是这样。这已经使我们能够从标准输入中反序列化城市项目使用
    `istream_iterator<city>`。
- en: 'There might be an open question left regarding error checking. For that, let''s
    have a look at the `operator>>` implementation again:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 关于错误检查可能还有一个未解决的问题。让我们再次看看 `operator>>` 的实现：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We are reading a lot of different things. What happens if one of them fails
    and the next one doesn't? Does that mean that we are potentially reading all following
    items with a bad "offset" in the token stream? No, this cannot happen. As soon
    as one of these items cannot be parsed from the input stream, the input stream
    object enters an error state and refuses to parse anything further. This means
    that if for example `c.population` or `c.latitude` cannot be parsed, the remaining
    `>>` operands just "drop through", and we leave this operator function scope with
    a half-deserialized city object.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在读取很多不同的东西。如果其中一个失败了，下一个又怎么样？这是否意味着我们可能会用错误的“偏移量”读取所有后续的项目？不，这是不可能的。一旦这些项目中的一个无法从输入流中解析出来，输入流对象就会进入错误状态，并拒绝进一步解析任何内容。这意味着，例如
    `c.population` 或 `c.latitude` 无法解析，剩余的 `>>` 操作数就会“跳过”，我们将以一个半反序列化的城市对象离开这个操作符函数范围。
- en: On the caller side, we are notified by this when we write `if (input_stream
    >> city_object)`. Such a streaming expression is implicitly converted to a bool
    value when used as a conditional expression. It returns `false` if the input stream
    object is in an error state. Knowing that we can reset the stream and do whatever
    is appropriate.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用方面，当我们写 `if (input_stream >> city_object)` 时，我们会得到通知。当作为条件表达式使用时，这样的流表达式会被隐式转换为一个布尔值。如果输入流对象处于错误状态，则返回
    `false`。知道这一点后，我们可以重置流并执行适当的操作。
- en: In this recipe, we did not write such `if` conditionals ourselves because we
    let `std::istream_iterator<city>` do the deserialization. The `operator++` implementation
    of this iterator class also checks for errors while parsing. If any errors occur,
    it will refuse iterating further. In this state, it returns `true` when it is
    compared to the end iterator, which makes the `copy` algorithm terminate. This
    way, we are safe.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们没有自己编写这样的`if`条件，因为我们让`std::istream_iterator<city>`进行反序列化。这个迭代器类的`operator++`实现在解析时也会检查错误。如果发生任何错误，它将拒绝进一步迭代。在这种状态下，当它与结束迭代器进行比较时，它将返回`true`，这使得`copy`算法终止。这样，我们就安全了。
- en: Filling containers from std::istream iterators
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从std::istream迭代器填充容器
- en: In the last recipe, we learned how we can assemble compound data structures
    from an input stream and then fill lists or vectors with those.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们学会了如何从输入流中组装复合数据结构，然后用它们填充列表或向量。
- en: This time, we make it a little bit harder by filling an `std::map` from standard
    input. The problem here is that we cannot just fill a single structure with values
    and push it back into a linear container like a list or a vector is because `map`
    divides its payload into key and value parts. It is, however, not completely different,
    as we will see.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们通过标准输入填充一个`std::map`，使问题变得有点困难。这里的问题是，我们不能只是用值填充单个结构，然后将其推回线性容器，比如列表或向量，因为`map`将其有效负载分为键和值部分。然而，它并不完全不同，正如我们将看到的那样。
- en: After studying this recipe, we will feel comfortable with serializing and deserializing
    complex data structures from and to character streams.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 学习了这个示例之后，我们将会对从字符流中序列化和反序列化复杂的数据结构感到满意。
- en: How to do it...
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to define another structure like in the last recipe, but this
    time we are going to fill it into a map, which makes it more complicated because
    this container maps from keys to values instead of just holding all values in
    a list:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义另一个类似上一个示例的结构，但这次我们将把它填充到一个地图中，这使得它变得更加复杂，因为这个容器从键到值的映射，而不仅仅是在列表中保存所有值：
- en: 'First, we include all the needed headers and declare that we use the `std`
    namespace by default:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包括所有需要的头文件，并声明我们默认使用`std`命名空间：
- en: '[PRE62]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We want to maintain a little Internet meme database. Let''s say a meme has
    a name, a description, and the year when it was born or invented. We will save
    them in an `std::map`, where the name is the key, and the other information is
    bunched up in a struct as the value associated with the key:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要维护一个小的互联网迷因数据库。假设一个迷因有一个名称、一个描述以及它诞生或发明的年份。我们将把它们保存在一个`std::map`中，其中名称是键，而其他信息则作为与键关联的值打包在一个结构中：
- en: '[PRE63]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s first ignore the key and just implement a stream `operator>>` function
    overload for `struct meme`. We assume that the description is surrounded by quotation
    marks, followed by the year. This would look like `"some description" 2017` in
    a text file. As the description is surrounded by quotation marks, it can contain
    whitespace because we know that everything between the quotation marks belongs
    to it. By reading with `is >> quoted(m.description)`, the quotation marks are
    automatically used as delimiters and dropped afterward. This is very convenient.
    Just after that, we read the year number:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先忽略键，只为`struct meme`实现一个流`operator>>`函数重载。我们假设描述被引号包围，后面跟着年份。这在文本文件中看起来像`"一些描述"
    2017`。由于描述被引号包围，它可以包含空格，因为我们知道引号之间的所有内容都属于它。通过使用`is >> quoted(m.description)`读取，引号会自动用作分隔符，并在之后被丢弃。这非常方便。就在那之后，我们读取年份数字：
- en: '[PRE64]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'OK, now we take the meme''s name as the key for the map into account. In order
    to insert a meme into the map, we need an `std::pair<key_type, value_type>` instance.
    `key_type` is `string`, of course, and `value_type` is `meme`. The name is allowed
    to contain spaces too, so we use the same `quoted` wrapper as for the description.
    `p.first` is the name and `p.second` is the whole `meme` structure associated
    with it. It will be fed into the other `operator>>` implementation that we just
    implemented:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在我们考虑将迷因的名称作为地图的键。为了将迷因插入地图，我们需要一个`std::pair<key_type, value_type>`实例。`key_type`当然是`string`，而`value_type`是`meme`。名称也允许包含空格，所以我们使用与描述相同的`quoted`包装。`p.first`是名称，`p.second`是与之关联的整个`meme`结构。它将被馈送到我们刚刚实现的另一个`operator>>`实现中：
- en: '[PRE65]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Okay, that''s it. Let''s write a main function, which instantiates a map, and
    fill that map. Because we overloaded the stream function `operator>>`, `istream_iterator`
    can deal with this type directly. We let it deserialize our meme items from standard
    input and use an `inserter` iterator in order to pump them into the map:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，就是这样。让我们编写一个主函数，实例化一个地图，并填充该地图。因为我们重载了流函数`operator>>`，`istream_iterator`可以直接处理这种类型。我们让它从标准输入反序列化我们的迷因项目，并使用`inserter`迭代器将它们泵入地图中：
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Before we print what we have, let''s first find out what''s the *longest* meme
    name in the map. We use `std::accumulate` for this. It gets an initial value `0u`
    (`u` for unsigned) and will visit the map element-wise in order to *merge* them
    together. In terms of `accumulate`, merging usually means *adding*. In our case,
    we want no numeric *sum* of anything, but the largest string length. In order
    to get that, we provide `accumulate` a helper function, `max_func`, which takes
    the current maximum size variable (which must be `unsigned` because string lengths
    are unsigned) and compares it to the length of the current item''s meme name string,
    in order to take the maximum of both values. This will happen for each element.
    The `accumulate` function''s final return value is the maximum meme name length:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打印我们拥有的内容之前，让我们首先找出地图中*最长*的迷因名称是什么。我们使用`std::accumulate`来实现这一点。它得到一个初始值`0u`（`u`表示无符号），并将按元素访问地图，以便将它们*合并*在一起。在`accumulate`中，合并通常意味着*添加*。在我们的情况下，我们不想得到任何数值的*总和*，而是最大的字符串长度。为了实现这一点，我们提供了一个辅助函数`max_func`给`accumulate`，它接受当前最大尺寸变量（必须是`unsigned`，因为字符串长度是无符号的）并将其与当前项目的迷因名称字符串长度进行比较，以便取两个值中的最大值。这将对每个元素发生。`accumulate`函数的最终返回值是最大的迷因名称长度：
- en: '[PRE67]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, let''s quickly loop through the map and print each item. We use `<< left
    << setw(width)` to get a nice table-like printing:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们快速地循环遍历map并打印每个项。我们使用`<< left << setw(width)`来获得一个漂亮的类似表格的打印：
- en: '[PRE68]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'That''s it. We need a small Internet meme database file, so let''s fill a text
    file with some examples:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样。我们需要一个小的互联网迷因数据库文件，所以让我们用一些示例填充一个文本文件：
- en: '[PRE69]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Compiling and running the program with the example meme database yields the
    following output:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用示例meme数据库编译和运行程序产生以下输出：
- en: '[PRE70]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works...
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There were three specialties in this recipe. One was that we did not fill a
    normal vector or a list from a serial character stream, but a more complex container
    like `std::map`. The other was that we used those magic `quoted` stream manipulators.
    And the last was the `accumulate` call, which finds out the largest key string
    size.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中有三个特殊之处。一个是我们没有从串行字符流中填充普通向量或列表，而是从`std::map`这样的更复杂的容器中填充。另一个是我们使用了那些神奇的`quoted`流操作器。最后一个是`accumulate`调用，它找出了最大的键字符串大小。
- en: Let's start with the `map` part. Our `struct meme` only contains a `description`
    field and `year`. The name of the Internet meme is not part of this structure
    because it is used as the key for the map. When we insert something into a map,
    we can provide an `std::pair` with a key type and a value type. This is what we
    did. We first implemented stream `operator>>` for `struct meme`, and then we did
    the same for `pair<string, meme>`. Then we used `istream_iterator<**pair<string,
    meme>**>{cin}` to get such items out of the standard input, and fed them into
    the map using `inserter(m, end(m))`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`map`部分开始。我们的`struct meme`只包含一个`description`字段和`year`。互联网迷因的名称不是这个结构的一部分，因为它被用作map的键。当我们向map中插入东西时，我们可以提供一个具有键类型和值类型的`std::pair`。这就是我们所做的。我们首先为`struct
    meme`实现了流`operator>>`，然后我们为`pair<string, meme>`做了同样的事情。然后我们使用`istream_iterator<**pair<string,
    meme>**>{cin}`从标准输入中获取这些项，并使用`inserter(m, end(m))`将它们插入map中。
- en: 'When we deserialized meme items from the stream, we allowed the names and descriptions
    to contain whitespace. This was easily possible, although we only used one line
    per meme because we *quoted* those fields. An example of the line format is as
    follows: `"Name with spaces" "Description with spaces" 123`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从流中反序列化meme项时，我们允许名称和描述包含空格。这是很容易实现的，尽管我们每个meme只使用一行，因为我们对这些字段进行了引用。一行格式的示例如下：`"Name
    with spaces" "Description with spaces" 123`
- en: When dealing with quoted strings both in input and output, `std::quoted` is
    a great help. If we have a string, `s`, printing it using `cout << quoted(s)`
    will put it in quotes. If we deserialize a string from a stream, for example,
    via `cin >> quoted(s)`, it will read the next quotation mark, fill the string
    with what is following, and continue until it sees the next quotation mark, no
    matter how many whitespace are involved.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 处理输入和输出中的带引号字符串时，`std::quoted`是一个很好的帮助。如果我们有一个字符串`s`，使用`cout << quoted(s)`来打印它会加上引号。如果我们通过流反序列化一个字符串，例如，通过`cin
    >> quoted(s)`，它将读取下一个引号，用后面的内容填充字符串，并继续直到看到下一个引号，无论涉及多少空格。
- en: 'The last strange looking thing was `max_func` in our accumulate call:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的累积调用中，最后一个看起来奇怪的是`max_func`：
- en: '[PRE71]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Apparently, `max_func` accepts a `size_t` argument and another `auto-`typed
    argument which turns out to be a `pair` item from the map. This looks really weird
    at first as most binary reduction functions accept arguments of identical types
    and then merge them together with some operation, just as `std::plus` does. In
    this case, it is really different because we are not merging actual `pair` items.
    We only pick the key string length from every pair, *drop* the rest, and then
    reduce the resulting `size_t` values with the `max` function.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`max_func`接受一个`size_t`参数和另一个`auto-`类型的参数，结果是来自map的`pair`项。这一开始看起来很奇怪，因为大多数二进制缩减函数接受相同类型的参数，然后使用某种操作将它们合并在一起，就像`std::plus`一样。在这种情况下，情况确实很不同，因为我们不是合并实际的`pair`项。我们只从每对中选择键字符串长度，*丢弃*其余部分，然后使用`max`函数减少结果的`size_t`值。
- en: In the accumulate call, the first call of `max_func` gets the `0u` value we
    initially provided as the left argument and a reference to the first pair item
    on the right side. This results in a `max(0u, string_length)` return value, which
    is the left argument in the *next* call with the next pair item as the right parameter,
    and so on.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在累积调用中，`max_func`的第一个调用得到我们最初提供的`0u`值作为左参数，并得到右侧的第一个pair项的引用。这导致`max(0u, string_length)`的返回值，这是*下一个*调用的左参数，下一个pair项作为右参数，依此类推。
- en: Generic printing with std::ostream iterators
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::ostream迭代器进行通用打印
- en: It is pretty easy to print anything with output streams, as the STL is already
    shipped with many useful `operator<<` overloads for the most basic types. This
    way, data structures containing items of such types can easily be printed using
    the `std::ostream_iterator` class, which we've already done quite often in this
    book.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用输出流打印任何东西都很容易，因为STL已经为大多数基本类型提供了许多有用的`operator<<`重载。这样，包含这些类型项的数据结构可以很容易地使用`std::ostream_iterator`类进行打印，这在本书中我们已经经常做过。
- en: In this recipe, we will concentrate on how to do this with a custom type, and
    what else we can do to manipulate printing via template type choices without much
    code at the caller side.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将集中讨论如何使用自定义类型以及在调用方面不需要太多代码的情况下，我们可以通过模板类型选择来操纵打印。
- en: How to do it...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will play with `std::ostream_iterator` by enabling for combination with
    a new custom class and have a look into its implicit conversion capabilities,
    which can help us with printing:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过启用与新自定义类的组合来玩`std::ostream_iterator`，并查看其隐式转换能力，这可以帮助我们进行打印：
- en: 'The include files come first and then we declare that we use the `std` namespace
    by default:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先是包含文件，然后我们声明默认使用`std`命名空间：
- en: '[PRE72]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s implement a transformation function, which maps numbers to strings.
    It shall return `"one"` for the value `1`, `"two"` for the value `2`, and so on:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现一个转换函数，将数字映射到字符串。它应该为值`1`返回`"one"`，为值`2`返回`"two"`，依此类推：
- en: '[PRE73]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We fill a hash map with the mappings we need in order to access them later:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用我们需要的映射填充哈希映射，以便以后访问它们：
- en: '[PRE74]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, we can feed the hash map''s `find` function with the argument, `i`, and
    return what it finds. If it doesn''t find anything, because there is no translation
    for a given number, we return the string, `"unknown"`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用哈希映射的 `find` 函数来查找参数 `i`，并返回它找到的内容。如果找不到任何内容，因为给定数字没有翻译，我们将返回字符串 `"unknown"`：
- en: '[PRE75]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Another thing with which we will play later with is `struct bork`. It only
    contains an integer and is also implicitly constructible from an integer. It has
    a `print` function, which accepts an output stream reference and prints the `"bork"`
    string repeatedly, depending on the value of its member integer `borks`:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们稍后将使用的另一件事是 `struct bork`。它只包含一个整数，并且也可以从整数*隐式*构造出来。它有一个 `print` 函数，接受一个输出流引用，并根据其成员整数
    `borks` 的值重复打印 `"bork"` 字符串：
- en: '[PRE76]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'In order to gain convenience with `bork::print` we overload `operator<<` for
    stream objects, so they automatically call `bork::print` whenever `bork` objects
    are streamed into an output stream:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便使用 `bork::print`，我们为流对象重载了 `operator<<`，因此每当 `bork` 对象被流到输出流中时，它们会自动调用 `bork::print`。
- en: '[PRE77]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now we can finally begin implementing the actual main function. We initially
    just create a vector with some example values:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们终于可以开始实现实际的主函数了。我们最初只是创建了一个带有一些示例值的向量：
- en: '[PRE78]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Objects of type `ostream_iterator` need a template parameter, which denotes
    which type of variables they can print. If we write `ostream_iterator<**T**>`,
    it will later use `ostream& operator(ostream&, const **T**&)` for printing. This
    is exactly what we implemented before for the `bork` type, for example. This time,
    we are just printing integers, so it is `ostream_iterator<**int**>`. It shall
    use `cout` for printing, so we provide it as the constructor parameter. We go
    through our vector in a loop and assign each item `i` to the dereferenced output
    iterator. This is how stream iterators are used by STL algorithms too:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ostream_iterator` 类型的对象需要一个模板参数，该参数表示它们可以打印哪种类型的变量。如果我们写 `ostream_iterator<**T**>`，它将在打印时使用
    `ostream& operator(ostream&, const **T**&)`。这正是我们之前为 `bork` 类型实现的。这一次，我们只是打印整数，所以是
    `ostream_iterator<**int**>`。它将使用 `cout` 进行打印，因此我们将其作为构造函数参数提供。我们在循环中遍历我们的向量，并将每个项目
    `i` 分配给解引用的输出迭代器。这也是STL算法使用流迭代器的方式：'
- en: '[PRE79]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The output of the iterator we just produced is fine, but it prints the number
    without any separator. If we want a bit of separating whitespace between all printed
    items, we can provide a custom spacing string as a second parameter of the output
    stream iterator''s constructor. This way, it prints `"1, 2, 3, 4, 5, "` instead
    of `"12345"`. Unfortunately, we cannot easily tell it to drop the comma-space
    string after the last number, because the iterator does not know of its end before
    it reaches it:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚生成的迭代器的输出是正常的，但它打印数字时没有任何分隔符。如果我们希望在所有打印的项目之间有一些分隔空格，我们可以将自定义的间隔字符串作为输出流迭代器构造函数的第二个参数提供。这样，它将打印
    `"1, 2, 3, 4, 5, "` 而不是 `"12345"`。不幸的是，我们无法轻松地告诉它在最后一个数字之后删除逗号空格字符串，因为迭代器在到达最后一个数字之前不知道它的结束：
- en: '[PRE80]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Assigning items to an output stream iterator in order to print them is not
    a wrong way to use it, but this is not what they were invented for. The idea is
    to use them in combination with algorithms. The simplest one is `std::copy`. We
    can provide the begin and end iterators of the vector as an input range and the
    output stream iterator as the output iterator. It will print all the numbers of
    the vector. Let''s do that with both the output iterators and later compare the
    output with the loops we wrote before:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目分配给输出流迭代器以便打印它们并不是使用它的错误方式，但这不是它们被发明的目的。想法是将它们与算法结合使用。最简单的算法是 `std::copy`。我们可以将向量的开始和结束迭代器作为输入范围，将输出流迭代器作为输出迭代器。它将打印向量的所有数字。让我们用输出迭代器和之前编写的循环来比较一下：
- en: '[PRE81]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Remember the function, `word_num`, which maps numbers to strings, as `1` to
    `"one"`, `2` to `"two"`, and so on? Yes, we can use those for printing too. We
    just need to use an output stream operator, which is template specialized on `string`
    because we are not printing integers any longer. And instead of `std::copy`, we
    use `std::transform` because it allows us to apply a transformation function to
    each item in the input range before copying it to the output range:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还记得函数 `word_num` 吗，它将数字映射到字符串，比如 `1` 对应 `"one"`，`2` 对应 `"two"`，依此类推？是的，我们也可以用它们来打印。我们只需要使用一个输出流操作符，它是针对
    `string` 进行模板专门化的，因为我们不再打印整数。而且我们使用 `std::transform` 而不是 `std::copy`，因为它允许我们在将每个项目复制到输出范围之前对输入范围中的每个项目应用转换函数：
- en: '[PRE82]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The last output line in this program finally puts `struct bork` to use. We
    could, but do not provide a transformation function to `std::transform`. Instead,
    we can just create an output stream iterator, which is specialized on the `bork`
    type in an `std::copy` call. This leads to the `bork` instances being *implicitly*
    created from the input range integers. That will give us some interesting output:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序中的最后一行最终使用了 `struct bork`。我们可以为 `std::transform` 提供一个转换函数，但我们没有这样做。相反，我们可以在
    `std::copy` 调用中创建一个专门针对 `bork` 类型的输出流迭代器。这将导致从输入范围整数*隐式*创建 `bork` 实例。这将给我们一些有趣的输出：
- en: '[PRE83]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Compiling and running the program yields us the following output. The first
    two lines are completely identical to the next two lines, which is what we suspected.
    Then, we get nice, written-out number strings in a line, followed by a lot of
    `bork!` strings. These occur in multiple lines because we used a `"n"` separator
    string instead of spaces for those:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会产生以下输出。前两行与接下来的两行完全相同，这是我们预料到的。然后，我们得到了漂亮的、写出来的数字字符串，然后是大量的 `bork!`
    字符串。这些出现在多行中，因为我们使用了 `"n"` 分隔字符串而不是空格：
- en: '[PRE84]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: How it works...
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have seen that `std::ostream_iterator` is really just a *syntax hack,* which
    kind of squeezes the act of printing into the form and syntax of an iterator.
    Incrementing such an iterator does *nothing*. Dereferencing it only returns us
    a proxy object whose assignment operator forwards its argument to an output stream.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到`std::ostream_iterator`实际上只是一个*语法技巧*，它将打印的行为压缩成迭代器的形式和语法。递增这样的迭代器*没有任何作用*。对其进行解引用只会返回一个代理对象，其赋值运算符将其参数转发到输出流。
- en: Output stream iterators that are specialized on a type `T` (as in `ostream_iterator<T>`)
    work with all types for which an `ostream& operator<<(ostream&, const T&)` implementation
    is provided.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类型`T`（如`ostream_iterator<T>`）进行特化的输出流迭代器可以使用提供了`ostream& operator<<(ostream&,
    const T&)`实现的所有类型。
- en: '`ostream_iterator` always tries to call `operator<<` for the type it was specialized
    for, via its template parameter. It will try to implicitly convert types if the
    same is allowed. When we iterate over a range of `A`-typed items but we copy those
    items over to `output_iterator<B>` instances, this will work if `A` is implicitly
    convertible to `B`. We did exactly the same thing with `struct bork`: a `bork`
    instance is implicitly convertible from an integer value. That is why it was so
    easy to throw a lot of `"bork!"` strings onto the user shell.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`ostream_iterator`总是尝试调用其模板参数指定的类型的`operator<<`，它将尝试隐式转换类型（如果允许）。当我们迭代`A`类型的项目范围，但将这些项目复制到`output_iterator<B>`实例时，如果`A`可以隐式转换为`B`，这将起作用。我们对`struct
    bork`也是完全相同的操作：`bork`实例可以从整数值隐式转换。这就是为什么很容易将大量`"bork!"`字符串抛到用户shell上。'
- en: If implicit conversion is not possible, we can do that ourselves, using `std::transform`,
    which is what we did in combination with the `word_num` function.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果隐式转换不可能，我们可以自己做，使用`std::transform`，这就是我们与`word_num`函数结合使用的方法。
- en: Note that it is, in general, *bad style* to allow implicit conversions for custom
    types because this is a common *source of bugs* that are really hard to find later.
    In our example use case, the implicit constructor is more useful than dangerous
    because the class is used for nothing else but printing.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通常*允许自定义类型进行隐式转换*是*不好的风格*，因为这是一个常见的*bug来源*，后期很难找到。在我们的示例用例中，隐式构造函数比危险更有用，因为该类除了打印之外没有其他用途。
- en: Redirecting output to files for specific code sections
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将输出重定向到特定代码段的文件
- en: The `std::cout` provides a really nice way to print whatever we want, whenever
    we want because it is simple to use, easily extensible, and globally accessible.
    Even if we want to print special messages, such as error messages, which we want
    to isolate from normal messages, we can just use `std::cerr`, which is the same
    as `cout` but prints to the standard error channel instead of the standard output
    channel.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::cout`提供了一个非常好的方法，可以在任何时候打印我们想要的内容，因为它简单易用，易于扩展，并且全局可访问。即使我们想要打印特殊消息，比如错误消息，我们想要将其与普通消息隔离开来，我们可以使用`std::cerr`，它与`cout`相同，但是将内容打印到标准错误通道而不是标准输出通道。'
- en: We might have some more complicated desires for logging sometimes. Let's say,
    for example, we want to *redirect* the output of a function to a file, or we want
    to *mute* the output of a function, without changing the function at all. Perhaps,
    it is a library function we cannot access the source code of. Maybe, it was never
    designed to write to a file but we want its output in a file.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能对日志记录有更复杂的需求。例如，我们想要将函数的输出*重定向*到文件，或者我们想要*静音*函数的输出，而不改变函数本身。也许它是一个我们无法访问源代码的库函数。也许它从未被设计为写入文件，但我们希望将其输出到文件中。
- en: It is indeed possible to redirect the output of stream objects. In this recipe,
    we are going to see how to do that in a very simple and elegant way.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 确实可以重定向流对象的输出。在本教程中，我们将看到如何以非常简单和优雅的方式做到这一点。
- en: How to do it...
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We are going to implement a helper class that solves the problem of redirecting
    a stream and reverting that redirection again with constructor/destructor magic.
    And then we see how we can put it to use:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个辅助类，解决重定向流和再次恢复重定向的问题，使用构造函数/析构函数的魔法。然后我们看看如何使用它：
- en: 'We only need the headers for input, output, and file streams this time. And
    we declare the `std` namespace as a default namespace for lookup:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次我们只需要输入、输出和文件流的头文件。并将`std`命名空间声明为查找的默认命名空间：
- en: '[PRE85]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We implement a class, which holds a file stream object and a pointer to a stream
    buffer. The `cout` as a stream object has an internal stream buffer, which we
    can simply exchange. And while we exchange it, we can save what it was before,
    so we can *undo* any change later. We could look its type up in the C++ reference,
    but we can also use `decltype` to find out what type `cout.rdbuf()` returns. This
    is not generally good practice in all situations, but in this case, it''s just
    a pointer type:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了一个类，它包含一个文件流对象和一个指向流缓冲区的指针。作为流对象的`cout`有一个内部流缓冲区，我们可以简单地交换。在交换的同时，我们可以保存之前的内容，以便稍后可以*撤消*任何更改。我们可以在C++参考中查找其类型，但我们也可以使用`decltype`来找出`cout.rdbuf()`返回的类型。这通常不是所有情况下的良好做法，但在这种情况下，它只是一个指针类型：
- en: '[PRE86]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The constructor of our class accepts a filename string as its only parameter.
    The filename is used to initialize the file stream member, `ofs`. After initializing
    it, we can feed it into `cout` as a new stream buffer. The same function that
    accepts the new buffer also returns a pointer to the old one, so we can save it
    in order to restore it later:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的类的构造函数接受一个文件名字符串作为其唯一参数。文件名用于初始化文件流成员`ofs`。初始化后，我们可以将其输入`cout`作为新的流缓冲区。接受新缓冲区的相同函数也返回旧缓冲区的指针，因此我们可以保存它以便稍后恢复它：
- en: '[PRE87]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The default constructor does the same as the other constructor. The difference
    is, that it does not open any file. Feeding a default-constructed file stream
    buffer into the `cout` stream buffer leads to `cout` being kind of *deactivated*.
    It will just *drop* its input we give it for printing. This can also be useful
    in some situations:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认构造函数与其他构造函数的作用相同。不同之处在于它不会打开任何文件。将默认构造的文件流缓冲区输入到`cout`流缓冲区会导致`cout`被*停用*。它只会*丢弃*我们给它的输入进行打印。在某些情况下，这也是有用的：
- en: '[PRE88]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The destructor just restores our change. When an object of this class runs
    out of scope, the stream buffer of `cout` is the old one again:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 析构函数只是恢复了我们的更改。当这个类的对象超出范围时，“cout”的流缓冲区再次变为旧的：
- en: '[PRE89]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Let''s mock an *output-heavy* function, so we can play with it later:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们模拟一个*输出密集*的函数，这样我们以后可以玩耍：
- en: '[PRE90]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In the main function, we first produce some completely normal output:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们首先产生一些完全正常的输出：
- en: '[PRE91]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now we''re opening another scope, and the first thing we do in this scope is
    instantiating our new class with a text file parameter. File streams open files
    in read and write mode by default, so it creates this file for us. Any following
    output will now be redirected to this file, although we use `cout` for printing:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们正在打开另一个作用域，这个作用域中的第一件事就是用文本文件参数实例化我们的新类。文件流默认以读写模式打开文件，因此它为我们创建了这个文件。任何后续的输出现在都将重定向到这个文件，尽管我们使用`cout`进行打印：
- en: '[PRE92]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'After leaving the scope, the file is closed and the output is redirected to
    the normal standard output again. Let''s now open another scope in which we instantiate
    the same class, but via its default constructor. This way the following printed
    line of text will not be visible anywhere. It will just be dropped:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 离开作用域后，文件被关闭，输出重新重定向到正常的标准输出。现在让我们在另一个作用域中实例化相同的类，但是通过它的默认构造函数。这样，下面打印的文本行将不会在任何地方可见。它只会被丢弃：
- en: '[PRE93]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'After leaving that scope also, our standard output is resurrected and the last
    line of text output will be readable in the shell again:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 离开那个作用域后，我们的标准输出被恢复，最后一行文本输出将再次在shell中可读：
- en: '[PRE94]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Compiling and running the program yields the output as we expected it. Only
    the very first and the very last lines of output are visible in the shell:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生了我们预期的输出。在shell中只有第一行和最后一行输出可见：
- en: '[PRE95]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We can see that a new file, `output.txt`, has been created and contains the
    output of the first scope. The output of the second scope vanishes completely:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到，创建了一个名为`output.txt`的新文件，并包含了第一个作用域的输出。第二个作用域的输出完全消失了。
- en: '[PRE96]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: How it works...
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Every stream object has an internal buffer for which it acts as a front end.
    Such buffers are exchangeable. If we have a stream object, `s`, and want to save
    its buffer into a variable, `a`, and install a new buffer, `b`, this looks like
    the following: `a = s.rdbuf(b)`. Restoring it can be simply done with `s.rdbuf(a)`.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 每个流对象都有一个内部缓冲区，它充当前端。这些缓冲区是可交换的。如果我们有一个流对象`s`，想要将其缓冲区保存到变量`a`中，并安装一个新的缓冲区`b`，则如下所示：`a
    = s.rdbuf(b)`。恢复它可以简单地使用`s.rdbuf(a)`来完成。
- en: 'This is exactly what we did in this recipe. Another cool thing is that we can
    *stack* those `redirect_cout_region` helpers:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在这个示例中所做的。另一个很酷的事情是我们可以*堆叠*这些`redirect_cout_region`助手：
- en: '[PRE97]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This works because objects are destructed in the opposite order of their construction.
    The concept behind this pattern that uses the tight coupling between construction
    and destruction of objects is called **Resource Acquisition Is Initialization**
    (**RAII**).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为对象的销毁顺序与它们的构造顺序相反。使用对象的构造和销毁之间的紧密耦合的模式的概念被称为**资源获取即初始化**（**RAII**）。
- en: 'There is one really important thing that should be mentioned--the *initialization
    order* of the member variables of the `redirect_cout_region` class:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件非常重要的事情应该提到--`redirect_cout_region`类的成员变量的*初始化顺序*：
- en: '[PRE98]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: As we can see, the member, `buf_backup`, is constructed from an expression that
    depends on `ofs`. This obviously means that `ofs` needs to be initialized before
    `buf_backup`. Interestingly, the order in which these members are initialized
    does *not* depend on the order of the initializer list items. The initialization
    order only depends on the order of the *member declarations*!
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，成员`buf_backup`是从取决于`ofs`的表达式构造的。这显然意味着`ofs`需要在`buf_backup`之前初始化。有趣的是，这些成员初始化的顺序*并不*取决于初始化列表项的顺序。初始化顺序只取决于*成员声明*的顺序！
- en: If one class member variable needs to be initialized after another member variable,
    they *must* also appear in that order in the class member declaration. The order
    of their appearance in the initializer list of the constructor is not critical.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类成员变量需要在另一个成员变量之后初始化，它们在类成员声明中也*必须*按照这个顺序出现。它们在构造函数的初始化列表中出现的顺序并不重要。
- en: Creating custom string classes by inheriting from std::char_traits
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过继承自std::char_traits创建自定义字符串类
- en: The `std::string` is extremely useful. However, as soon as people need a string
    class with slightly different semantics for string handling, some tend to write
    their *own* string class.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`非常有用。然而，一旦人们需要一个具有略有不同语义的字符串处理的字符串类，一些人就倾向于编写自己的字符串类。'
- en: Writing your own string class is rarely a good idea because safe string handling
    is hard. Fortunately, `std::string` is only a specializing typedef of the template
    class, `std::basic_string`. This class contains all the complicated memory handling
    stuff, but it does not impose any policy on how strings are copied, compared,
    and so on. This is something that is imported into `basic_string` by accepting
    a template parameter that contains a traits class.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 编写自己的字符串类很少是一个好主意，因为安全的字符串处理很困难。幸运的是，`std::string`只是模板类`std::basic_string`的专门类型定义。这个类包含了所有复杂的内存处理内容，但它不会对字符串的复制、比较等施加任何策略。这是通过接受一个包含特性类的模板参数导入到`basic_string`中的。
- en: In this recipe, we will see how to build our own trait classes and, this way,
    how to create custom strings without reimplementing anything.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将看到如何构建我们自己的特性类，以此方式创建自定义字符串而无需重新实现任何内容。
- en: How to do it...
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to implement two different custom string classes: `lc_string`
    and `ci_string`. The first class constructs lower case strings from any string
    input. The other class does not transform any string, but it can do case-insensitive
    string comparison:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现两种不同的自定义字符串类：`lc_string`和`ci_string`。第一个类从任何字符串输入构造小写字符串。另一个类不转换任何字符串，但可以进行不区分大小写的字符串比较：
- en: 'Let''s include the few necessary headers first and then declare that we use
    the `std` namespace by default:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先包含一些必要的头文件，然后声明我们默认使用`std`命名空间：
- en: '[PRE99]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Then we reimplement the `std::tolower` function, which is already defined in
    `<cctype>`. The already existing function is fine, but it is not `constexpr`.
    Some `string` functions are `constexpr` since C++17, however, and we want to be
    able to make use of that with our own custom string trait class. The function
    maps upper-case characters to lower case and leaves other characters unchanged:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们重新实现了`std::tolower`函数，它已经在`<cctype>`中定义。已经存在的函数很好，但它不是`constexpr`。自C++17以来，一些`string`函数是`constexpr`，我们希望能够利用我们自己的自定义字符串特性类。该函数将大写字符映射到小写字符，并保持其他字符不变：
- en: '[PRE100]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The `std::basic_string` class accepts three template parameters: the underlying
    character type, a character traits class, and an allocator type. We are only changing
    the character traits class in this section because it defines the behavior of
    strings. In order to reimplement only what should differ from the ordinary strings,
    we are publicly inheriting from the standard traits class:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::basic_string`类接受三个模板参数：基础字符类型、字符特性类和分配器类型。在本节中，我们只更改字符特性类，因为它定义了字符串的行为。为了仅重新实现与普通字符串不同的部分，我们公开继承标准特性类：'
- en: '[PRE101]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Our class accepts input strings but transforms them to lower case. There is
    one function, which does this character-wise, so we can put our own `tolow` function
    here. This function is `constexpr`, which is why we reimplemented ourselves a
    `constexpr` `tolow` function:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的类接受输入字符串但将它们转换为小写。有一个函数，它逐个字符地执行此操作，因此我们可以在这里放置我们自己的`tolow`函数。这个函数是`constexpr`的，这就是为什么我们重新实现了一个`constexpr`的`tolow`函数：
- en: '[PRE102]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The other function handles the copying of an entire string into its own memory.
    We use an `std::transform` call to copy all the characters from the source string
    to the internal destination string and, at the same time, map every character
    to its lower-case version:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个函数处理整个字符串复制到自己的内存中。我们使用`std::transform`调用将所有字符从源字符串复制到内部目标字符串，并同时将每个字符映射到其小写版本：
- en: '[PRE103]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The other trait helps build a string class that effectively transforms strings
    to lower case. We are going to write another trait that leaves the actual string
    payload untouched but which is case insensitive when it comes to comparing strings.
    We inherit from the existing standard character traits class again, and this time,
    we redefine some other member functions:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个特性有助于构建一个有效地将字符串转换为小写的字符串类。我们将编写另一个特性，它保持实际的字符串有效负载不变，但在比较字符串时不区分大小写。我们再次从现有的标准字符特性类继承，并且这次，我们重新定义了一些其他成员函数：
- en: '[PRE104]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `eq` function tells whether two characters are equal. We do this too, but
    we compare their lower-case versions. This way `''A''` equals `''a''`:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`eq`函数告诉我们两个字符是否相等。我们也这样做，但是我们比较它们的小写版本。这样`''A''`等于`''a''`：'
- en: '[PRE105]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The `lt` function tells whether the value of `a` is less than the value of
    `b`. We apply the correct logical operator for that, just after lower-casing both
    the characters again:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lt`函数告诉我们`a`的值是否小于`b`的值。我们在将两个字符再次转换为小写后，应用正确的逻辑运算符：'
- en: '[PRE106]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The last two functions worked on character-wise input and the next two functions
    work on string-wise input. The `compare` function works similar to the old-school
    `strncmp` function. It returns `0` if both the strings are equal within the length
    that `count` defines. If they differ, it returns a negative or positive number,
    which tells which input string is lexicographically smaller. Calculating the difference
    between both the characters at every position must, of course, be done on their
    lower-case versions. The nice thing is that this whole loop code has been part
    of a `constexpr` function since C++14:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后两个函数处理逐个字符的输入，接下来的两个函数处理逐个字符串的输入。`compare`函数类似于老式的`strncmp`函数。如果两个字符串在`count`定义的长度内相等，则返回`0`。如果它们不同，则返回一个负数或正数，告诉哪个输入字符串在词典顺序上更小。当然，必须在它们的小写版本上计算每个位置的字符之间的差异。好处是自C++14以来，这整个循环代码一直是`constexpr`函数的一部分：
- en: '[PRE107]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The last function we need to implement for our case-insensitive string class
    is `find`. For a given input string, `p`, and length, `count`, it finds the position
    of a character, `ch`. Then, it returns a pointer to the first occurrence of that
    character, or it returns `nullptr` if there is none. The comparison in this function
    has to be done using the `tolow` "glasses" in order to make the search case-insensitive.
    Unfortunately, we cannot use `std::find_if`, because it is not `constexpr`, and
    must write a loop ourselves:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为我们的不区分大小写的字符串类实现的最后一个函数是`find`。对于给定的输入字符串`p`和长度`count`，它找到字符`ch`的位置。然后，它返回指向该字符的第一个出现的指针，如果没有，则返回`nullptr`。该函数中的比较必须使用`tolow`“眼镜”来进行，以使搜索不区分大小写。不幸的是，我们不能使用`std::find_if`，因为它不是`constexpr`，必须自己编写一个循环：
- en: '[PRE108]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Okay, that''s it for the traits. Since we have them in place now, we can define
    two new string class types. `lc_string` means *lower-case string*. `ci_string`
    means *case-insensitive string*. Both the classes only differ from `std::string`
    by their character traits class:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，特性就是这些。既然我们现在已经有了它们，我们可以定义两种新的字符串类类型。`lc_string`表示*小写字符串*。`ci_string`表示*不区分大小写的字符串*。这两个类与`std::string`唯一的区别在于它们的字符特性类：
- en: '[PRE109]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In order to make the output streams accept these new classes for printing,
    we quickly need to overload the stream `operator<<`:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使输出流接受这些新的类进行打印，我们需要快速重载流`operator<<`：
- en: '[PRE110]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now we can finally begin implementing the actual program. Let''s instantiate
    a normal string, a lower-case string, and a case-insensitive string, and print
    them immediately. They should all look normal on the terminal, but the lower case
    strings should be all lower-cased:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们终于可以开始实现实际的程序了。让我们实例化一个普通字符串、一个小写字符串和一个不区分大小写的字符串，并立即打印它们。它们在终端上应该都看起来正常，但小写字符串应该都是小写的：
- en: '[PRE111]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'In order to test the case-insensitive string, we can instantiate two strings
    that are basically equal but differ in the casing of some characters. When doing
    a really case-insensitive comparison, they should appear equal nevertheless:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试不区分大小写的字符串，我们可以实例化两个基本相等但在某些字符的大小写上有所不同的字符串。当进行真正的不区分大小写比较时，它们应该看起来是相等的：
- en: '[PRE112]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'So, let''s compare them and print that they match if they do:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们比较它们，并打印出它们是否匹配：
- en: '[PRE113]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Compiling and running the program yields us the expected results. When we first
    printed the same string three times in different types, we got unchanged results,
    but the `lc_string` instance is all lower case. The comparison of the two strings
    that only differ in their character casing was indeed successful and yields us
    the right output:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会产生我们预期的结果。当我们首先以不同类型三次打印相同的字符串时，我们得到了不变的结果，但`lc_string`实例全部是小写的。只有在字符大小写不同的两个字符串的比较确实成功，并产生了正确的输出：
- en: '[PRE114]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: How it works...
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All the subclassing, and function reimplementing we did will surely look a bit
    crazy for beginners. Where did all the function signatures come from, of which
    we *magically* knew that we need to reimplement?
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的所有子类化和函数重新实现对于初学者来说肯定看起来有点疯狂。我们从哪里得到所有这些函数签名，我们*神奇地*知道我们需要重新实现？
- en: 'Let''s first have a look where `std::string` really comes from:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看`std::string`真正来自哪里：
- en: '[PRE115]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The `std::string` is really an `std::basic_string<char>` and that expands to
    `std::basic_string<char, std::char_traits<char>, std::allocator<char>>`. Okay,
    that is a long type description, but what does it mean? The point of all of this
    is that it is possible to base a string not only on single-byte `char` items but
    also on other, larger, types. This enables for string types, which can handle
    more than the typical American ASCII character set. This is not something we will
    have a look into now.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`实际上是一个`std::basic_string<char>`，它扩展为`std::basic_string<char, std::char_traits<char>,
    std::allocator<char>>`。好吧，这是一个很长的类型描述，但是它是什么意思呢？所有这一切的重点是，可以基于单字节`char`项以及其他更大的类型来构建字符串。这使得可以处理更多的字符集，而不仅仅是典型的美国ASCII字符集。这不是我们现在要研究的东西。'
- en: The `char_traits<char>` class, however, contains algorithms that `basic_string`
    needs for its operation. The knows how to compare, find, and copy characters and
    strings.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`char_traits<char>`类包含了`basic_string`在其操作中需要的算法。它知道如何比较、查找和复制字符和字符串。
- en: The `allocator<char>` class is also a traits class, but its special job is handling
    string allocation and deallocation. This is not important for us at this time
    as the default behavior satisfies our needs.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`allocator<char>`类也是一个特性类，但它的特殊工作是处理字符串的分配和释放。这对我们来说现在并不重要，因为默认行为满足我们的需求。'
- en: If we want a string class to behave differently, we can try to reuse as much
    as possible from what `basic_string` and `char_traits` already provide. And this
    is what we did. We implemented two `char_traits` subclasses called `case_insentitive`
    and `lower_caser` and configured two completely new string types with them by
    using them as substitutes for the standard `char_traits` type.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望字符串类的行为有所不同，我们可以尝试尽可能多地重用`basic_string`和`char_traits`已经提供的内容。这就是我们所做的。我们实现了两个`char_traits`子类，分别称为`case_insentitive`和`lower_caser`，并通过将它们用作标准`char_traits`类型的替代品，配置了两种全新的字符串类型。
- en: In order to explore what other possibilities there are to adapt `basic_string`
    to your own needs, look up the C++ STL documentation for `std::char_traits` and
    see what other functions it has that can be reimplemented.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索其他可能性，以适应`basic_string`到您自己的需求，查阅C++ STL文档中的`std::char_traits`，看看它还有哪些其他函数可以重新实现。
- en: Tokenizing input with the regular expression library
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式库对输入进行标记化
- en: When parsing or transforming strings in complex ways or breaking them into chunks,
    *regular expressions* are a great help. In many programming languages, they are
    already built in because they are so useful and handy.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的字符串解析或转换以及将其分成块时，*正则表达式*是一个很好的帮助。在许多编程语言中，它们已经内置，因为它们非常有用和方便。
- en: If you do not know regular expressions yet, have a look at the *Wikipedia* article
    about them, for example. They will surely extend your horizon, as it is easy to
    see how useful they are when parsing any kind of text. Regular expressions can,
    for example, test whether an e-mail address string or an IP address string is
    valid, find and extract substrings out of large strings, which follow a complex
    pattern, and so on.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还不了解正则表达式，请查看关于它们的*维基百科*文章，例如。当解析任何类型的文本时，它们肯定会扩展您的视野，因为很容易看到它们的有用性。例如，正则表达式可以测试电子邮件地址字符串或IP地址字符串是否有效，找到并提取符合复杂模式的大字符串中的子字符串等等。
- en: In this recipe, we will extract all the links out of an HTML file and list them
    for the user. The code will be amazingly short because we have regular expression
    support built in the C++ STL since C++11.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将从HTML文件中提取所有链接并列出给用户。代码将非常简短，因为自C++11以来，我们在C++ STL中内置了正则表达式支持。
- en: How to do it...
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to define a regular expression that detects links, and we apply
    it to an HTML file in order to pretty print all the links that occur in that file:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个检测链接的正则表达式，并将其应用于HTML文件，以便漂亮地打印出该文件中出现的所有链接：
- en: 'Let''s first include all the necessary headers, and declare that we use the
    `std` namespace by default:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先包括所有必要的头文件，并声明我们默认使用`std`命名空间：
- en: '[PRE116]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We will later generate an iterable range, which consists of strings. These
    strings always occur in pairs of a link and a link description. Therefore, let''s
    write a little helper function, which pretty prints these:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稍后我们将生成一个可迭代范围，其中包含字符串。这些字符串总是成对出现，一个是链接，一个是链接描述。因此，让我们编写一个小帮助函数，漂亮地打印这些：
- en: '[PRE117]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'In each loop step, we increment the iterator twice and take copies of the link
    and the link description they contain. Between the two iterator dereferences,
    we add another guarding `if` branch that checks whether we prematurely reached
    the end of the iterable range, just for safety:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个循环步骤中，我们将迭代器递增两次，并复制链接和链接描述。在两个迭代器解引用之间，我们添加了另一个保护`if`分支，检查我们是否过早地到达了可迭代范围的末尾，只是为了安全起见：
- en: '[PRE118]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Now, let''s print the link with its description in a nicely prettified form
    and that''s it:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们以一个漂亮的格式打印链接及其描述，就这样：
- en: '[PRE119]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'In the main function, we are reading in everything that comes from standard
    input. To do this, we are constructing a string from the whole standard input
    via an input stream iterator. In order to prevent tokenizing, because we want
    the whole user input as-is, we use `noskipws`. This modifier deactivates whitespace
    skipping and tokenizing:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们正在读取来自标准输入的所有内容。为了做到这一点，我们通过输入流迭代器从整个标准输入构造一个字符串。为了防止标记化，因为我们希望整个用户输入保持原样，我们使用`noskipws`。这个修饰符取消了空格跳过和标记化：
- en: '[PRE120]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Now we need to define a regular expression that describes how we assume an
    HTML link to look. The parentheses, `()`, within the regular expression define
    groups. These are the parts of the link we want to access--the URL it links to,
    and its description:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要定义一个正则表达式，描述我们如何假设HTML链接的外观。正则表达式中的括号`()`定义了组。这些是我们想要访问的链接的部分--它链接到的URL及其描述：
- en: '[PRE121]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The `sregex_token_iterator` class has the same look and feel as of `istream_iterator`.
    We give it the whole string as iterable input range and the regular expression
    we just defined. There is also a third parameter, `{1, 2}`, which is an initializer
    list of integer values. It defines that we want to iterate over the groups 1 and
    2 from the expressions it captures:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sregex_token_iterator`类与`istream_iterator`具有相同的外观和感觉。我们将整个字符串作为可迭代输入范围，并使用刚刚定义的正则表达式。还有第三个参数`{1,
    2}`，它是一个整数值的初始化列表。它定义了我们要迭代表达式捕获的组1和2：'
- en: '[PRE122]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Now we have an iterator that will emit the links and link descriptions if it
    finds any. We provide it together with a default constructed iterator of the same
    type to the `print` function we implemented before:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个迭代器，如果找到任何内容，它将发出链接和链接描述。我们将它与相同类型的默认构造的迭代器一起提供给我们之前实现的`print`函数：
- en: '[PRE123]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Compiling and running the program gives us the following output. I ran the
    `curl` program on the ISO C++ homepage, which simply downloads an HTML page from
    the Internet. Of course, it would also be possible to write `cat some_html_file.html
    | ./link_extraction`. The regular expression we used is pretty much hardcoded
    to a fixed assumption of how links look in the HTML document. It may be exercised
    by you to make it more general:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序后，我们得到以下输出。我在ISO C++主页上运行了`curl`程序，它只是从互联网上下载了一个HTML页面。当然，也可以写`cat some_html_file.html
    | ./link_extraction`。我们使用的正则表达式基本上是固定的，假设了HTML文档中链接的外观。你可以尝试使它更通用：
- en: '[PRE124]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: How it works...
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: Regular expressions (or *regex* in short) are extremely useful. They can look
    really cryptic, but it is worth learning how they work. A short regex can spare
    us writing many lines of code if we did the matching manually.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式（或简称*regex*）非常有用。它们可能看起来很神秘，但值得学习它们的工作原理。如果我们手动进行匹配，一个简短的正则表达式就可以节省我们编写许多行代码。
- en: In this recipe, we first instantiated an object of type regex. We fed its constructor
    with a string that describes a regular expression. A very simple regular expression
    is `"."`, which matches *every* character because a dot is the regex wildcard.
    If we write `"a"`, then this matches only on the `'a'` characters. If we write
    `"ab*"`, then this means "one `a`, and zero or arbitrarily many `b` characters".
    And so on. Regular expressions are another large topic, and there are great explanations
    on Wikipedia and other websites or literature.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先实例化了一个regex类型的对象。我们将其构造函数与描述正则表达式的字符串一起使用。一个非常简单的正则表达式是`"."`，它匹配*每个*字符，因为点是正则表达式通配符。如果我们写`"a"`，那么这只匹配`'a'`字符。如果我们写`"ab*"`，那么这意味着"一个`a`，以及零个或任意多个`b`字符"。等等。正则表达式是另一个大的主题，在维基百科和其他网站或文献上有很好的解释。
- en: 'Let''s have another look at our regular expression that matches what we assume
    to be HTML links. A simple HTML link can look like `<a href="some_url.com/foo">A
    great link</a>`. We want the `some_url.com/foo` part, as well as `A great link`.
    So we came up with the following regular expression, which contains *groups* for
    matching substrings:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看我们假设是HTML链接的正则表达式。一个简单的HTML链接可能看起来像`<a href="some_url.com/foo">A great
    link</a>`。我们想要`some_url.com/foo`部分，以及`A great link`。因此，我们想出了以下正则表达式，其中包含用于匹配子字符串的*组*：
- en: '![](img/f6d75901-b27a-455d-bbb6-118f376bef15.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6d75901-b27a-455d-bbb6-118f376bef15.png)'
- en: The whole match itself is always **Group 0**. In this case, this is the full
    `<a href ..... </a>` string. The quoted `href`-part that contains the URL being
    linked to is **Group 1**. The `( )` parentheses in the regular expression define
    such a . The other one is the part between the `<a ...>` and `</a>`, which contains
    the link description.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 整个匹配本身始终是**Group 0**。在这种情况下，这是完整的`<a href ..... </a>`字符串。包含链接到的URL的引用`href`部分是**Group
    1**。正则表达式中的`( )`括号定义了这样一个。另一个是在`<a ...>`和`</a>`之间的部分，其中包含链接描述。
- en: 'There are various STL functions that accept regex objects, but we directly
    used a regex token iterator adapter, which is a high-level abstraction that uses
    `std::regex_search` under the hood in order to automate recurring matching work.
    We instantiated it like this:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种STL函数接受正则表达式对象，但我们直接使用了正则表达式令牌迭代器适配器，这是一个高级抽象，它在底层使用`std::regex_search`来自动化重复匹配工作。我们像这样实例化它：
- en: '[PRE125]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The begin and end part denote our input string over which the regex token iterator
    shall iterate and match all links. The is, of course, the complex regular expression
    we implemented to match links. The `{1, 2}` part is the next complicated looking
    thing. It instructs the token iterator to stop on each full match and first yield
    Group 1, then after incrementing the iterator to yield Group 2, and after incrementing
    it again, it would finally search for the next match in the string. This somewhat
    intelligent behavior really spares us some code lines.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 开始和结束部分表示我们的输入字符串，正则表达式令牌迭代器将在其上迭代并匹配所有链接。当然，这是我们实现的复杂正则表达式，用于匹配链接。`{1, 2}`部分是下一个看起来复杂的东西。它指示令牌迭代器在每次完全匹配时停止，并首先产生第1组，然后在递增迭代器后产生第2组，再次递增后，最终在字符串中搜索下一个匹配项。这种智能行为确实为我们节省了一些代码行。
- en: 'Let''s have a look at another example to make sure we got the idea. Let''s
    imagine the regular expression, `"a(b*)(c*)"`. It will match strings that contain
    an `a` character, then none or arbitrarily many `b` characters, and then none
    or arbitrarily many `c` characters:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子，确保我们理解了这个概念。假设正则表达式是`"a(b*)(c*)"`。它将匹配包含`a`字符的字符串，然后是零个或任意多个`b`字符，然后是零个或任意多个`c`字符：
- en: '[PRE126]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: There is also the `std::regex_iterator` class, which emits the substrings that
    are *between* regex matches.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`std::regex_iterator`类，它发出*在*正则表达式匹配之间的子字符串。
- en: Comfortably pretty printing numbers differently per context on the fly
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 舒适地根据上下文动态地以不同方式打印数字
- en: 'In the last recipe, we learned how to format the output with output streams.
    And while doing the same, we realized two facts:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们学会了如何使用输出流格式化输出。在做同样的事情时，我们意识到了两个事实：
- en: Most I/O manipulators are *sticky*, so we have to revert their effect after
    use in order to not tamper with other unrelated code, which also prints
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数I/O操纵器是*粘性*的，因此我们必须在使用后恢复它们的效果，以免干扰其他不相关的代码，也会打印
- en: It can be very tedious and does not look very readable if we have to set up
    long chains of I/O manipulators in order to get only a few variables printed with
    specific formatting
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们不得不设置长链的I/O操纵器才能以特定格式打印出少量变量，这将非常乏味，看起来也不太可读。
- en: A lot of people do not like I/O streams for such reasons, and even in C++, they
    still use `printf` for formatting their strings.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人不喜欢I/O流，甚至在C++中，他们仍然使用`printf`来格式化他们的字符串。
- en: In this recipe, we will see how to format types on the fly without too much
    I/O manipulator noise in our code.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何在代码中减少I/O操纵器的噪音，动态地格式化类型。
- en: How to do it...
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to implement a class, `format_guard`, which can automatically
    revert any format setting. Additionally, we add a wrapper type, which can contain
    any value, but when it is printed, it gets special formatting without burdening
    us with I/O manipulator noise:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个名为`format_guard`的类，它可以自动恢复任何格式设置。此外，我们添加了一个包装类型，它可以包含任何值，但在打印时，它以特殊格式显示，而不会给我们带来I/O操纵器的噪音：
- en: 'First, we include some headers and declare that we use the `std` namespace:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包含一些头文件，并声明我们使用`std`命名空间：
- en: '[PRE127]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The helper class that tidies up our stream formatting states for us is called
    `format_guard`. Its constructor saves the formatting flags, which `std::cout`
    has set at the moment. Its destructor restores them to the state it had when the
    constructor was called. This effectively revokes any formatting settings that
    were applied in between:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 帮助类`format_guard`会为我们整理流格式设置。它的构造函数保存了`std::cout`在那一刻设置的格式标志。它的析构函数将它们恢复到构造函数调用时的状态。这实际上撤销了在之间应用的任何格式设置：
- en: '[PRE128]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Another little helper class is `scientific_type`. Because it''s a class template,
    it can wrap any payload type as a member variable. It basically does nothing:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个小帮助类是`scientific_type`。因为它是一个类模板，它可以将任何有效载荷类型包装为成员变量。它基本上什么也不做：
- en: '[PRE129]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'We can define completely custom formatting settings for any type that was wrapped
    into `scientific_type` before because if we overload the stream `operator>>` for
    it, the stream library executes completely different code when printing such types.
    This way, we can print scientific values in scientific floating-point notation,
    with uppercase formatting and explicit `+` prefix if they have positive values.
    We do also use our `format_guard` class in order to tidy up all our settings when
    leaving this function again:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以为任何类型定义完全自定义的格式设置，这些类型在之前被包装成`scientific_type`，因为如果我们为其重载流`operator>>`，那么当打印这些类型时，流库会执行完全不同的代码。这样，我们可以以科学浮点表示法打印科学值，使用大写格式和显式的`+`前缀（如果它们具有正值）。我们还使用我们的`format_guard`类来在离开此函数时整理所有设置：
- en: '[PRE130]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'In the main function, we will first play around with the `format_guard` class.
    We open a new scope, first get an instance of the class, and then we apply some
    wild formatting flags to `std::cout`:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们首先尝试使用`format_guard`类。我们打开一个新的作用域，首先获得该类的一个实例，然后我们对`std::cout`应用一些疯狂的格式标志：
- en: '[PRE131]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'After we printed some numbers with many formatting flags enabled, we left the
    scope again. While this happened, the destructor of `format_guard` tidied the
    formatting up. In order to test this, we are printing exactly the same numbers
    *again*. They should appear different:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启用了许多格式标志的情况下打印了一些数字后，我们再次离开了作用域。在此期间，`format_guard`的析构函数整理了格式。为了测试这一点，我们*再次*打印完全相同的数字。它们应该看起来不同：
- en: '[PRE132]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Now we put `scientific_type` to use. Let''s print three floating-point numbers
    in a row. We wrap the second number in `scientific_type`. This way, it is printed
    in our special scientific style, but the numbers before and after it get default
    formatting. At the same time, we avoid ugly formatting line *noise*:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们要使用`scientific_type`。让我们依次打印三个浮点数。我们将第二个数字包装在`scientific_type`中。这样，它将以我们特殊的科学样式打印，但它之前和之后的数字将采用默认格式。同时，我们避免了丑陋的格式化行*噪音*：
- en: '[PRE133]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Compiling and running the program yields us the following result. The first
    two numbers are printed with specific formatting. The next two numbers appear
    with default formatting, which shows us that our `format_guard` works just nicely.
    The three numbers in the last lines also look just as expected. Only the one in
    the middle has the formatting of `scientific_type`, the rest has default formatting:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会产生以下结果。前两个数字以特定格式打印。接下来的两个数字以默认格式显示，这表明我们的`format_guard`工作得很好。最后一行的三个数字看起来也正如预期的那样。只有中间的数字具有`scientific_type`的格式，其余的都是默认格式：
- en: '[PRE134]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Catching readable exceptions from std::iostream errors
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获std::iostream错误的可读异常
- en: In *none* of the recipes in this chapter, we used *exceptions* to catch errors.
    While this is certainly possible, working on stream objects without exceptions
    is already very convenient. If we try to parse in 10 values, but this fails somewhere
    in the middle, the whole stream object sets itself into a fail state and stops
    further parsing. This way, we do not run into the danger of parsing variables
    from the wrong offset in the stream. We can just do the parsing in a conditional,
    such as `if (cin >> foo >> bar >> ...)`. If this fails, we handle it. It does
    not appear very advantageous to embrace parsing in a `try { ... } catch ...` block.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的*任何*食谱中，我们都没有使用*异常*来捕获错误。虽然这是可能的，但在没有异常的情况下使用流对象已经非常方便。如果我们尝试解析10个值，但在中间某个地方失败了，整个流对象就会将自己设置为失败状态并停止进一步解析。这样，我们就不会遇到从流中错误的偏移解析变量的危险。我们可以在条件语句中进行解析，比如`if
    (cin >> foo >> bar >> ...)`。如果失败了，我们就处理它。在`try { ... } catch ...`块中进行解析似乎并不是很有利。
- en: In fact, the C++ I/O stream library already existed before there were exceptions
    in C++. Exception support was added later, which might be an explanation why they
    are not a first-class supported feature in the stream library.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在C++中引入异常之前，C++ I/O流库已经存在。异常支持是后来添加的，这可能解释了为什么它们不是流库中的一流支持特性。
- en: In order to use exceptions in the stream library, we must configure each stream
    object individually to throw an exception, whenever it sets itself into a fail
    state. Unfortunately, the error explanations in the exception objects, which we
    can then catch later, are not thoroughly standardized. This leads to not really
    helpful error messages, as we will see in this section. If we really want to use
    exceptions with stream objects, we can *additionally* poll the C library for filesystem
    error states to get some additional information.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在流库中使用异常，我们必须单独配置每个流对象，以便在将自身设置为失败状态时抛出异常。不幸的是，异常对象中的错误解释并没有得到彻底的标准化。正如我们将在本节中看到的那样，这导致了不太有用的错误消息。如果我们真的想要在流对象中使用异常，我们可以*另外*轮询C库以获取文件系统错误状态以获得一些额外信息。
- en: In this section, we are going to write a program that can fail in different
    ways, handle those with exceptions, and see how to squeeze more information out
    of those afterward.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个可以以不同方式失败的程序，使用异常处理这些失败，并看看如何在之后从中挤取更多信息。
- en: How to do it...
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will implement a program that opens a file (which might fail), and then
    we''ll read an integer out of it (which might fail, too). We do this with activated
    exceptions and then we see how we can handle those:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个程序，打开一个文件（可能失败），然后我们将从中读取一个整数（这也可能失败）。我们在激活异常的情况下进行这些操作，然后看看我们如何处理这些异常：
- en: 'First, we include some headers and declare that we use the `std` namespace:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包含一些头文件，并声明我们使用`std`命名空间：
- en: '[PRE135]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'If we want to use stream objects with exceptions, we have to enable them first.
    In order to get a file stream object to throw an exception if the file we are
    letting it access does not exist, or if there are parsing errors, we need to set
    some fail bits in an exception mask. If we do something afterward that fails,
    it will trigger an exception. By activating `failbit` and `badbit`, we enable
    exceptions for filesystem errors and parsing errors:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要在流对象中使用异常，我们必须首先启用它们。为了使文件流对象在访问的文件不存在或存在解析错误时抛出异常，我们需要在异常掩码中设置一些失败位。如果我们之后做了一些失败的事情，它将触发异常。通过激活`failbit`和`badbit`，我们为文件系统错误和解析错误启用了异常：
- en: '[PRE136]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Now we can open a `try` block and access a file. If opening the file is successful,
    we try to read an integer from it. Only if both steps succeed, we print the integer:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以打开一个`try`块并访问一个文件。如果打开文件成功，我们尝试从中读取一个整数。只有在两个步骤都成功的情况下，我们才打印整数：
- en: '[PRE137]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'In both the expected possibilities of an error, an instance of `std::ios_base::failure`
    is thrown. This object has a `what()` member function, which ought to explain
    what triggered the exception. Unfortunately, the standardization of this message
    was left out, and it does not give too much information. However, we can at least
    distinguish if there is a *filesystem* problem (because the file does not exist,
    for example) or a format *parsing* problem. The global variable, `errno`, has
    been there even before C++ was invented, and it is set to an error value, which
    we can check now. The `strerror` function translates from an error number to a
    human readable string. If `errno` is `0`, there is, at least, no filesystem error:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两种预期的错误可能性中，都会抛出`std::ios_base::failure`的实例。这个对象有一个`what()`成员函数，应该解释触发异常的原因。不幸的是，这条消息的标准化被省略了，它并没有提供太多信息。然而，我们至少可以区分是否存在*文件系统*问题（例如文件不存在）或格式*解析*问题。全局变量`errno`甚至在C++发明之前就存在了，并且被设置为一个错误值，我们现在可以检查。`strerror`函数将错误号转换为可读的字符串。如果`errno`为`0`，那么至少没有文件系统错误：
- en: '[PRE138]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Compiling the program and running it in two different scenarios yields the
    following output. If the file to be opened does exist but parsing an integer from
    it was not possible, we get an `iostream_category` error message:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序并在两种不同的情况下运行它会产生以下输出。如果要打开的文件存在，但无法从中解析出整数，则会得到一个`iostream_category`错误消息：
- en: '[PRE139]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'If the file does *not* exist, we will be notified about this with a different
    message from `strerror(errno)`:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件*不存在*，我们将收到一个不同于`strerror(errno)`的消息通知我们：
- en: '[PRE140]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: How it works...
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have seen that we can enable exceptions per stream object, `s`, with `s.exceptions(s.failbit
    | s.badbit)`. This means, that there is no way to use, for example, the `std::ifstream`
    instance''s constructor for opening a file if we want to get an exception when
    opening that file is not possible:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以通过`s.exceptions(s.failbit | s.badbit)`为流对象`s`启用异常。这意味着，例如，如果我们想在打开文件时无法打开文件时得到异常，就无法使用`std::ifstream`实例的构造函数：
- en: '[PRE141]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: This is a pity because exceptions actually promise that they make error handling
    less clumsy compared to old-school C-style code, which is riddled with loads of
    `if` branches, which handle errors after every step.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个遗憾，因为异常实际上承诺它们使错误处理变得不那么笨拙，与老式的C风格代码相比，后者充斥着大量的`if`分支，处理每一步之后的错误。
- en: If we played around trying to provoke various reasons for streams to fail, we
    would realize that there are no different exceptions being thrown. This way, we
    can only find out *when* we get an error, but not *what* specific error (This
    is, of course, *not* true for exception handling in *general*, but for the STL
    stream library). That is why we additionally consulted the value of `errno`. This
    global variable is an ancient construct, which has already been used in the old
    days when there were no C++ or exceptions in general.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试引发流失败的各种原因，我们会意识到没有抛出不同的异常。这样，我们只能找出*何时*发生错误，而不是*什么*具体的错误（当然，这对于*一般*的异常处理来说是*不*正确的，但对于STL流库来说是正确的）。这就是为什么我们另外查看了`errno`的值。这个全局变量是一个古老的构造，在旧日当没有C++或一般的异常时就已经被使用。
- en: If any system-related function has seen an error condition, it is able to set
    the `errno` variable to something other than `0` (`0` describes the absence of
    errors), and then the caller is able to read that error number and look up what
    its value means. The only problem with this is that when we have a multithreaded
    application, and all the threads use functions that can set this error variable,
    *whose* error value is it? If we read it even though there is no error, it could
    carry an error value because some *other* system function running in a *different
    thread* may have experienced an error. Luckily, this flaw has been gone since
    C++11, where every thread in a process sees its own `errno` variable.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何与系统相关的函数遇到错误条件，它可以将`errno`变量设置为非`0`的值（`0`表示没有错误），然后调用者可以读取该错误号并查找其值的含义。唯一的问题是，当我们有一个多线程应用程序，并且所有线程都使用可以设置此错误变量的函数时，*它是谁*的错误值？如果我们即使没有错误也读取它，它可能携带一个错误值，因为在*不同线程*中运行的*其他*系统函数可能已经遇到了错误。幸运的是，自C++11以来，这个缺陷已经消失，进程中的每个线程都可以看到自己的`errno`变量。
- en: Without elaborating the ups and downs of an ancient error indication method,
    it can give us useful extra information when an exception is triggered on system-based
    things such as file streams. Exceptions tell us *when* it happened, and `errno`
    can tell us *what* happened if it happened at the system level.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 不详细阐述古老的错误指示方法的利弊，当异常在基于系统的事物上触发时，它可以给我们提供有用的额外信息。异常告诉我们*何时*发生了，而`errno`可以告诉我们*发生了什么*，如果它是在系统级别发生的。
