["```cpp\n    QT += core gui opengl\n    ```", "```cpp\n    LIBS += -lopengl32 -lglu32\n    ```", "```cpp\n    #ifndef MAINWINDOW_H\n    #define MAINWINDOW_H\n    #include <QMainWindow>\n\n    namespace Ui {\n      class MainWindow;\n    }\n    class MainWindow : public QMainWindow\n    {\n      Q_OBJECT\n      public:\n        explicit MainWindow(QWidget *parent = 0);\n        ~MainWindow();\n      private:\n        Ui::MainWindow *ui;\n    };\n    #endif // MAINWINDOW_H\n    ```", "```cpp\n    #ifndef MAINWINDOW_H\n    #define MAINWINDOW_H\n    #include <QOpenGLWindow>\n\n    class MainWindow : public QOpenGLWindow\n    {\n      Q_OBJECT\n      public:\n        explicit MainWindow(QWidget *parent = 0);\n        ~MainWindow();\n\n      protected:\n        virtual void initializeGL();\n        virtual void resizeGL(int w, int h);\n        virtual void paintGL();\n        void paintEvent(QPaintEvent *event);\n        void resizeEvent(QResizeEvent *event);\n    };\n\n    #endif // MAINWINDOW_H\n    ```", "```cpp\n    #include \"mainwindow.h\"\n    #include \"ui_mainwindow.h\"\n\n    MainWindow::MainWindow(QWidget *parent):\n      QMainWindow(parent),\n      ui(new Ui::MainWindow)\n    MainWindow::MainWindow(QWidget *parent)\n    {\n      ui->setupUi(this);\n      setSurfaceType(QWindow::OpenGLSurface);\n    }\n\n    MainWindow::~MainWindow()\n    {\n      delete ui;\n    }\n    void MainWindow::initializeGL()\n    {\n      void MainWindow::resizeGL(int w, int h)\n    {\n    }\n    void MainWindow::paintGL()\n    {\n    }\n    void MainWindow::paintEvent(QPaintEvent *event)\n    {\n    }\n    void MainWindow::resizeEvent(QResizeEvent *event)\n    {\n    }\n    ```", "```cpp\n    #include \"mainwindow.h\"\n    #include <QApplication>\n\n    int main(int argc, char *argv[])\n    {\n      QApplication a(argc, argv);\n      MainWindow w;\n      w.setTitle(\"OpenGL Hello World!\");\n      w.resize(640, 480);\n      w.show();\n      return a.exec();\n    }\n    ```", "```cpp\n    #include <QSurfaceFormat>\n    #include <QOpenGLFunctions>\n    #include <QtOpenGL>\n    #include <GL/glu.h>\n    ```", "```cpp\n    private:\n      QOpenGLContext* context;\n      QOpenGLFunctions* openGLFunctions;\n    ```", "```cpp\n    MainWindow::MainWindow(QWidget *parent)\n    {\n     setSurfaceType(QWindow::OpenGLSurface);\n     QSurfaceFormat format;\n     format.setProfile(QSurfaceFormat::CompatibilityProfile);\n     format.setVersion(2, 1); // OpenGL 2.1\n     setFormat(format);\n\n     context = new QOpenGLContext;\n     context->setFormat(format);\n     context->create();\n     context->makeCurrent(this);\n\n     openGLFunctions = context->functions();\n    }\n    ```", "```cpp\n    void MainWindow::paintGL()\n    {\n     // Initialize clear color (cornflower blue)\n     glClearColor(0.39f, 0.58f, 0.93f, 1.f);\n\n     // Clear color buffer\n     glClear(GL_COLOR_BUFFER_BIT);\n\n     // Render quad\n     glBegin(GL_QUADS);\n     glVertex2f(-0.5f, -0.5f);\n     glVertex2f(0.5f, -0.5f);\n     glVertex2f(0.5f, 0.5f);\n     glVertex2f(-0.5f, 0.5f);\n     glEnd();\n\n     glFlush();\n    }\n    ```", "```cpp\n    void MainWindow::paintEvent(QPaintEvent *event)\n    {\n     paintGL();\n    }\n    ```", "```cpp\n    void MainWindow::paintGL()\n    {\n      // Initialize clear color (cornflower blue)\n      glClearColor(0.39f, 0.58f, 0.93f, 1.f);\n\n      // Clear color buffer\n      glClear(GL_COLOR_BUFFER_BIT);\n\n     glBegin(GL_QUADS);\n     glVertex2f(-0.5f, -0.5f);\n     glVertex2f(0.5f, -0.5f);\n     glVertex2f(0.5f, 0.5f);\n     glVertex2f(-0.5f, 0.5f);\n     glEnd();\n\n     glBegin(GL_QUADS);\n     glColor3f(1.f, 0.f, 0.f); glVertex2f(-0.8f, -0.8f);\n     glColor3f(1.f, 1.f, 0.f); glVertex2f(0.3f, -0.8f);\n     glColor3f(0.f, 1.f, 0.f); glVertex2f(0.3f, 0.3f);\n     glColor3f(0.f, 0.f, 1.f); glVertex2f(-0.8f, 0.3f);\n     glEnd();\n\n     glBegin(GL_TRIANGLES);\n     glColor3f(1.f, 0.f, 0.f); glVertex2f(-0.4f, -0.4f);\n     glColor3f(0.f, 1.f, 0.f); glVertex2f(0.8f, -0.1f);\n     glColor3f(0.f, 0.f, 1.f); glVertex2f(-0.1f, 0.8f);\n     glEnd();\n\n      glFlush();\n    }\n    ```", "```cpp\n    void MainWindow::resizeGL(int w, int h)\n    {\n      // Initialize Projection Matrix\n      glMatrixMode(GL_PROJECTION);\n      glLoadIdentity();\n\n      glViewport(0, 0, w, h);\n\n      qreal aspectRatio = qreal(w) / qreal(h);\n      glOrtho(-1 * aspectRatio, 1 * aspectRatio, -1, 1, 1, -1);\n    }\n    ```", "```cpp\n    void MainWindow::resizeEvent(QResizeEvent *event)\n    {\n     resizeGL(this->width(), this->height());\n     this->update();\n    }\n    ```", "```cpp\n    void MainWindow::initializeGL()\n    {\n     resizeGL(this->width(), this->height());\n    }\n    ```", "```cpp\n    #include <QTimer>\n    ```", "```cpp\n    private:\n      QOpenGLContext* context;\n      QOpenGLFunctions* openGLFunctions;\n     float rotation;\n\n    ```", "```cpp\n    public slots:\n      void updateAnimation();\n    ```", "```cpp\n    void MainWindow::initializeGL()\n    {\n     //  Enable Z-buffer depth test\n     glEnable(GL_DEPTH_TEST);\n      resizeGL(this->width(), this->height());\n    }\n    ```", "```cpp\n    void MainWindow::resizeGL(int w, int h)\n    {\n      // Set the viewport\n      glViewport(0, 0, w, h);\n      qreal aspectRatio = qreal(w) / qreal(h);\n\n      // Initialize Projection Matrix\n      glMatrixMode(GL_PROJECTION);\n      glLoadIdentity();\n\n     glOrtho(-1 * aspectRatio, 1 * aspectRatio, -1, 1, 1, -1);\n     gluPerspective(75, aspectRatio, 0.1, 400000000);\n\n     // Initialize Modelview Matrix\n     glMatrixMode(GL_MODELVIEW);\n     glLoadIdentity();\n    }\n    ```", "```cpp\n    void MainWindow::paintGL()\n    {\n      // Initialize clear color (cornflower blue)\n      glClearColor(0.39f, 0.58f, 0.93f, 1.f);\n\n     // Clear color buffer\n     glClear(GL_COLOR_BUFFER_BIT);\n     glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n     glBegin(GL_QUADS);\n     glColor3f(1.f, 0.f, 0.f); glVertex2f(-0.8f, -0.8f);\n     glColor3f(1.f, 1.f, 0.f); glVertex2f(0.3f, -0.8f);\n     glColor3f(0.f, 1.f, 0.f); glVertex2f(0.3f, 0.3f);\n     glColor3f(0.f, 0.f, 1.f); glVertex2f(-0.8f, 0.3f);\n     glEnd();\n\n     glBegin(GL_TRIANGLES);\n     glColor3f(1.f, 0.f, 0.f); glVertex2f(-0.4f, -0.4f);\n     glColor3f(0.f, 1.f, 0.f); glVertex2f(0.8f, -0.1f);\n     glColor3f(0.f, 0.f, 1.f); glVertex2f(-0.1f, 0.8f);\n     glEnd();\n\n      glFlush();\n    }\n    ```", "```cpp\n    // Reset modelview matrix\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n\n    // Transformations\n    glTranslatef(0.0, 0.0, -3.0);\n    glRotatef(rotation, 1.0, 1.0, 1.0);\n\n    // FRONT\n    glBegin(GL_POLYGON);\n      glColor3f(0.0, 0.0, 0.0);\n      glVertex3f(0.5, -0.5, -0.5); glVertex3f(0.5, 0.5, -0.5);\n      glVertex3f(-0.5, 0.5, -0.5); glVertex3f(-0.5, -0.5, -0.5);\n    glEnd();\n\n    // BACK\n    glBegin(GL_POLYGON);\n      glColor3f(0.0, 1.0, 0.0);\n      glVertex3f(0.5, -0.5, 0.5); glVertex3f(0.5, 0.5, 0.5);\n      glVertex3f(-0.5, 0.5, 0.5); glVertex3f(-0.5, -0.5, 0.5);\n    glEnd();\n\n    // RIGHT\n    glBegin(GL_POLYGON);\n      glColor3f(1.0, 0.0, 1.0);\n      glVertex3f(0.5, -0.5, -0.5); glVertex3f(0.5, 0.5, -0.5);\n      glVertex3f(0.5, 0.5, 0.5); glVertex3f(0.5, -0.5, 0.5);\n    glEnd();\n\n    // LEFT\n    glBegin(GL_POLYGON);\n      glColor3f(1.0, 1.0, 0.0);\n      glVertex3f(-0.5, -0.5, 0.5); glVertex3f(-0.5, 0.5, 0.5);\n      glVertex3f(-0.5, 0.5, -0.5); glVertex3f(-0.5, -0.5, -0.5);\n    glEnd();\n\n    // TOP\n    glBegin(GL_POLYGON);\n      glColor3f(0.0, 0.0, 1.0);\n      glVertex3f(0.5, 0.5, 0.5); glVertex3f(0.5, 0.5, -0.5);\n      glVertex3f(-0.5, 0.5, -0.5); glVertex3f(-0.5, 0.5, 0.5);\n    glEnd();\n\n    // BOTTOM\n    glBegin(GL_POLYGON);\n      glColor3f(1.0, 0.0, 0.0);\n      glVertex3f(0.5, -0.5, -0.5); glVertex3f(0.5, -0.5, 0.5);\n      glVertex3f(-0.5, -0.5, 0.5); glVertex3f(-0.5, -0.5, -0.5);\n    glEnd();\n    ```", "```cpp\n    MainWindow::MainWindow(QWidget *parent)\n    {\n      setSurfaceType(QWindow::OpenGLSurface);\n      QSurfaceFormat format;\n      format.setProfile(QSurfaceFormat::CompatibilityProfile);\n      format.setVersion(2, 1); // OpenGL 2.1\n      setFormat(format);\n\n      context = new QOpenGLContext;\n      context->setFormat(format);\n      context->create();\n      context->makeCurrent(this);\n\n      openGLFunctions = context->functions();\n\n     QTimer *timer = new QTimer(this);\n     connect(timer, SIGNAL(timeout()), this, SLOT(updateAnimation()));\n     timer->start(100);\n\n     rotation = 0;\n    }\n    ```", "```cpp\n    void MainWindow::updateAnimation()\n    {\n      rotation += 10;\n      this->update();\n    }\n    ```", "```cpp\n    #include <QGLWidget>\n    ```", "```cpp\n    private:\n      QOpenGLContext* context;\n      QOpenGLFunctions* openGLFunctions;\n\n      float rotation;\n     GLuint texID[1];\n\n    ```", "```cpp\n    void MainWindow::initializeGL()\n    {\n      // Enable Z-buffer depth test\n      glEnable(GL_DEPTH_TEST);\n\n     // Enable texturing\n     glEnable(GL_TEXTURE_2D);\n\n     QImage image(\"bricks\");\n     QImage texture = QGLWidget::convertToGLFormat(image);\n\n     glGenTextures(1, &texID[0]);\n     glBindTexture(GL_TEXTURE_2D, texID[0]);\n\n     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\n     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texture.width(), texture.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, texture.bits());\n\n      // Make sure render at the correct aspect ratio\n      resizeGL(this->width(), this->height());\n    }\n    ```", "```cpp\n    glEnable(GL_TEXTURE_2D);\n    glBindTexture(GL_TEXTURE_2D, texID[0]);\n\n    // FRONT\n    glBegin(GL_POLYGON);\n      glColor3f(0.0, 0.0, 0.0);\n      glTexCoord2f(0.0f, 0.0f); glVertex3f(0.5, -0.5, -0.5);\n      glTexCoord2f(1.0f, 0.0f); glVertex3f(0.5, 0.5, -0.5);\n      glTexCoord2f(1.0f, 1.0f); glVertex3f(-0.5, 0.5, -0.5);\n      glTexCoord2f(0.0f, 1.0f); glVertex3f(-0.5, -0.5, -0.5);\n    glEnd();\n\n    // BACK\n    glBegin(GL_POLYGON);\n      glColor3f(0.0, 1.0, 0.0);\n      glTexCoord2f(1.0f, 0.0f); glVertex3f(0.5, -0.5, 0.5);\n      glTexCoord2f(1.0f, 1.0f); glVertex3f(0.5, 0.5, 0.5);\n      glTexCoord2f(0.0f, 1.0f); glVertex3f(-0.5, 0.5, 0.5);\n      glTexCoord2f(0.0f, 0.0f); glVertex3f(-0.5, -0.5, 0.5);\n    glEnd();\n\n    // RIGHT\n    glBegin(GL_POLYGON);\n      glColor3f(1.0, 0.0, 1.0);\n      glTexCoord2f(0.0f, 1.0f); glVertex3f(0.5, -0.5, -0.5);\n      glTexCoord2f(0.0f, 0.0f); glVertex3f(0.5, 0.5, -0.5);\n      glTexCoord2f(1.0f, 0.0f); glVertex3f(0.5, 0.5, 0.5);\n      glTexCoord2f(1.0f, 1.0f); glVertex3f(0.5, -0.5, 0.5);\n    glEnd();\n\n    // LEFT\n    glBegin(GL_POLYGON);\n      glColor3f(1.0, 1.0, 0.0);\n      glTexCoord2f(1.0f, 1.0f); glVertex3f(-0.5, -0.5, 0.5);\n      glTexCoord2f(0.0f, 1.0f); glVertex3f(-0.5, 0.5, 0.5);\n      glTexCoord2f(0.0f, 0.0f); glVertex3f(-0.5, 0.5, -0.5);\n      glTexCoord2f(1.0f, 0.0f); glVertex3f(-0.5, -0.5, -0.5);\n    glEnd();\n\n    // TOP\n    glBegin(GL_POLYGON);\n      glColor3f(0.0, 0.0, 1.0);\n      glTexCoord2f(1.0f, 0.0f); glVertex3f(0.5, 0.5, 0.5);\n      glTexCoord2f(1.0f, 1.0f); glVertex3f(0.5, 0.5, -0.5);\n      glTexCoord2f(0.0f, 1.0f); glVertex3f(-0.5, 0.5, -0.5);\n      glTexCoord2f(0.0f, 0.0f); glVertex3f(-0.5, 0.5, 0.5);\n    glEnd();\n\n    // Red side - BOTTOM\n    glBegin(GL_POLYGON);\n      glColor3f(1.0, 0.0, 0.0);\n      glTexCoord2f(0.0f, 0.0f); glVertex3f( 0.5, -0.5, -0.5);\n      glTexCoord2f(1.0f, 0.0f); glVertex3f( 0.5, -0.5, 0.5);\n      glTexCoord2f(1.0f, 1.0f); glVertex3f(-0.5, -0.5, 0.5);\n      glTexCoord2f(0.0f, 1.0f); glVertex3f(-0.5, -0.5, -0.5);\n    glEnd();\n\n    glDisable(GL_TEXTURE_2D);\n    ```", "```cpp\n    // Trilinear interpolation\n    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n    glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE);\n\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texture.width(), texture.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, texture.bits());\n\n    // Enable smooth shading\n    glShadeModel(GL_SMOOTH);\n\n    // Lighting\n    glEnable(GL_LIGHT1);\n    GLfloat lightAmbient[]= { 0.5f, 0.5f, 0.5f, 1.0f };\n    GLfloat lightDiffuse[]= { 1.0f, 1.0f, 1.0f, 1.0f };\n    GLfloat lightPosition[]= { 3.0f, 3.0f, -5.0f, 1.0f };\n    glLightfv(GL_LIGHT1, GL_AMBIENT, lightAmbient);\n    glLightfv(GL_LIGHT1, GL_DIFFUSE, lightDiffuse);\n    glLightfv(GL_LIGHT1, GL_POSITION, lightPosition);\n\n    // Make sure render at the correct aspect ratio\n    resizeGL(this->width(), this->height());\n    ```", "```cpp\n    glEnable(GL_LIGHTING);\n\n    // FRONT\n    glBegin(GL_POLYGON);\n      glNormal3f(0.0f, 0.0f, 1.0f);\n      glTexCoord2f(0.0f, 0.0f); glVertex3f(0.5, -0.5, -0.5);\n      glTexCoord2f(1.0f, 0.0f); glVertex3f(0.5, 0.5, -0.5);\n      glTexCoord2f(1.0f, 1.0f); glVertex3f(-0.5, 0.5, -0.5);\n      glTexCoord2f(0.0f, 1.0f); glVertex3f(-0.5, -0.5, -0.5);\n    glEnd();\n\n    // BACK\n    glBegin(GL_POLYGON);\n      glNormal3f(0.0f, 0.0f,-1.0f);\n      glTexCoord2f(1.0f, 0.0f); glVertex3f(0.5, -0.5, 0.5);\n      glTexCoord2f(1.0f, 1.0f); glVertex3f(0.5, 0.5, 0.5);\n      glTexCoord2f(0.0f, 1.0f); glVertex3f(-0.5, 0.5, 0.5);\n      glTexCoord2f(0.0f, 0.0f); glVertex3f(-0.5, -0.5, 0.5);\n    glEnd();\n\n    // RIGHT\n    glBegin(GL_POLYGON);\n      glNormal3f(0.0f, 1.0f, 0.0f);\n      glTexCoord2f(0.0f, 1.0f); glVertex3f(0.5, -0.5, -0.5);\n      glTexCoord2f(0.0f, 0.0f); glVertex3f(0.5, 0.5, -0.5);\n      glTexCoord2f(1.0f, 0.0f); glVertex3f(0.5, 0.5, 0.5);\n      glTexCoord2f(1.0f, 1.0f); glVertex3f(0.5, -0.5, 0.5);\n    glEnd();\n\n    // LEFT\n    glBegin(GL_POLYGON);\n      glNormal3f(0.0f,-1.0f, 0.0f);\n      glTexCoord2f(1.0f, 1.0f); glVertex3f(-0.5, -0.5, 0.5);\n      glTexCoord2f(0.0f, 1.0f); glVertex3f(-0.5, 0.5, 0.5);\n      glTexCoord2f(0.0f, 0.0f); glVertex3f(-0.5, 0.5, -0.5);\n      glTexCoord2f(1.0f, 0.0f); glVertex3f(-0.5, -0.5, -0.5);\n    glEnd();\n\n    // TOP\n    glBegin(GL_POLYGON);\n      glNormal3f(1.0f, 0.0f, 0.0f);\n      glTexCoord2f(1.0f, 0.0f); glVertex3f(0.5, 0.5, 0.5);\n      glTexCoord2f(1.0f, 1.0f); glVertex3f(0.5, 0.5, -0.5);\n      glTexCoord2f(0.0f, 1.0f); glVertex3f(-0.5, 0.5, -0.5);\n      glTexCoord2f(0.0f, 0.0f);glVertex3f(-0.5, 0.5, 0.5);\n    glEnd();\n\n    // Red side - BOTTOM\n    glBegin(GL_POLYGON);\n      glNormal3f(-1.0f, 0.0f, 0.0f);\n      glTexCoord2f(0.0f, 0.0f); glVertex3f(0.5, -0.5, -0.5);\n      glTexCoord2f(1.0f, 0.0f); glVertex3f(0.5, -0.5, 0.5);\n      glTexCoord2f(1.0f, 1.0f); glVertex3f(-0.5, -0.5, 0.5);\n      glTexCoord2f(0.0f, 1.0f); glVertex3f(-0.5, -0.5, -0.5);\n    glEnd();\n\n    glDisable(GL_LIGHTING);\n    ```", "```cpp\n    private:\n      QOpenGLContext* context;\n      QOpenGLFunctions* openGLFunctions;\n\n      float rotation;\n      GLuint texID[1];\n\n     float moveX;\n     float moveZ;\n\n    ```", "```cpp\n    public:\n      explicit MainWindow(QWidget *parent = 0);\n      ~MainWindow();\n\n      void keyPressEvent(QKeyEvent *event);\n\n    ```", "```cpp\n    MainWindow::MainWindow(QWidget *parent)\n    {\n      setSurfaceType(QWindow::OpenGLSurface);\n\n      QSurfaceFormat format;\n      format.setProfile(QSurfaceFormat::CompatibilityProfile);\n      format.setVersion(2, 1); // OpenGL 2.1\n      setFormat(format);\n\n      context = new QOpenGLContext;\n      context->setFormat(format);\n      context->create();\n      context->makeCurrent(this);\n\n      openGLFunctions = context->functions();\n\n      QTimer *timer = new QTimer(this);\n      connect(timer, SIGNAL(timeout()), this, SLOT(updateAnimation()));\n      timer->start(100);\n\n      rotation = 0;\n\n     moveX = 0;\n     moveZ = 0;\n    }\n    ```", "```cpp\n    void MainWindow::keyPressEvent(QKeyEvent *event)\n    {\n      if (event->key() == Qt::Key_W)\n      {\n        moveZ -= 0.2;\n      }\n\n      if (event->key() == Qt::Key_S)\n      {\n        moveZ += 0.2;\n      }\n\n      if (event->key() == Qt::Key_A)\n      {\n        moveX -= 0.2;\n      }\n\n      if (event->key() == Qt::Key_D)\n      {\n        moveX += 0.2;\n      }\n    }\n    ```", "```cpp\n    // Transformations\n    glTranslatef(0.0, 0.0, -3.0);\n    glRotatef(rotation, 1.0, 1.0, 1.0);\n    glTranslatef(moveX, 0.0, moveZ);\n\n    // Texture mapping\n    glEnable(GL_TEXTURE_2D);\n    glBindTexture(GL_TEXTURE_2D, texID[0]);\n\n    glEnable(GL_LIGHTING);\n    ```", "```cpp\n    function initializeGL(canvas) {\n      scene = new THREE.Scene();\n      camera = new THREE.PerspectiveCamera(75, canvas.width / canvas.height, 0.1, 1000);\n      camera.position.z = 5;\n\n     var directionalLight = new THREE.DirectionalLight(0xffffff);\n     directionalLight.position.set(1, 1, 1).normalize();\n     scene.add(directionalLight);\n\n     var texture = THREE.ImageUtils.loadTexture('bricks.jpg');\n\n     var material = new THREE.MeshBasicMaterial({ map: texture });\n     var cubeGeometry = new THREE.BoxGeometry(3, 3, 3);\n      cube = new THREE.Mesh(cubeGeometry, material);\n      cube.rotation.set(0.785, 0.785, 0.0);\n      scene.add(cube);\n\n      renderer = new THREE.Canvas3DRenderer(\n        { canvas: canvas, antialias: true, devicePixelRatio: canvas.devicePixelRatio });\n      renderer.setSize(canvas.width, canvas.height);\n    }\n    ```", "```cpp\n    function paintGL(canvas) {\n      cube.rotation.y -= 0.005;\n      renderer.render(scene, camera);\n    }\n    ```", "```cpp\n    import QtQuick 2.4\n    import QtCanvas3D 1.0\n    import QtQuick.Window 2.2\n    import \"glcode.js\" as GLCode\n\n    Window {\n      title: qsTr(\"Qt_Canvas_3D\")\n     width: 480\n     height: 320\n      visible: true\n\n      Canvas3D {\n        id: canvas3d\n        anchors.fill: parent\n        focus: true\n\n        onInitializeGL: {\n          GLCode.initializeGL(canvas3d);\n        }\n\n        onPaintGL: {\n          GLCode.paintGL(canvas3d);\n        }\n\n        onResizeGL: {\n          GLCode.resizeGL(canvas3d);\n        }\n      }\n    }\n    ```"]