["```cpp\n//--------- Streams_First.cpp \n#include \"Stream.h\" \nusing namespace std; \nusing namespace Stream; \nusing namespace Stream::op; \nint main(){ \n  //-------- counter(n) - Generate a series of value \n  //-------- Map (Apply a Lambda) \n  //-------- limit(n) -- Take first ten items \n  //-------- Sum -- aggregate \n  int total = MakeStream::counter(1) \n    | map_([] (int x) { return x * x; } // Apply square on each elements \n    | limit(10) //take first ten elements\n   | sum();  // sum the Stream contents Streams::op::sum \n   //----------- print the result \n   cout << total << endl; \n} \n```", "```cpp\n//--------------- Streams_Second.cpp \n// g++ -I./Streams-master/sources Streams_Second.cpp \n// \n#include \"Stream.h\" \n#include <ioStream> \n#include <vector> \n#include <algorithm> \n#include <functional> \nusing namespace std; \nusing namespace Stream; \nusing namespace Stream::op; \nint main() { \n  std::vector<double> a = { 10,20,30,40,50 }; \n  //------------ Make a Stream and reduce  \n  auto val =  MakeStream::from(a)  | reduce(std::plus<void>()); \n  //------ Compute the arithematic average \n  cout << val/a.size() << endl; \n} \n```", "```cpp\n//--------------- Streams_Third.cpp \n// g++ -I./Streams-master/sources Streams_Third.cpp \n// \n#include \"Stream.h\" \n#include <ioStream> \n#include <vector> \n#include <algorithm> \n#include <functional> \n#include <cmath> \nusing namespace std; \nusing namespace Stream; \nusing namespace Stream::op; \ndouble square( double a ) { return a*a; } \nint main() { \n  std::vector<double> values = { 1,2,3,4,5 }; \n  std::vector<double> outputs = MakeStream::from(values) \n               | map_([] (double a ) { return a*a;})  \n               | to_vector(); \n  for(auto pn : outputs ) \n  { cout << pn << endl; } \n} \n```", "```cpp\n#include \"Streamulus.h\" \n#include <ioStream> \nusing namespace std; \nusing namespace Streamulus; \nstruct print {     \n    static double temp; \n    print() { } \n    template<typename T> \n    T operator()(const T& value) const {  \n        print::temp += value; \n        std::cout << print::temp << std::endl;  return value; \n     } \n}; \ndouble print::temp = 0; \n```", "```cpp\nvoid hello_Stream() { \n    using namespace Streamulus; \n    // Define an input Stream of strings, whose name is \"Input Stream\" \n    InputStream<double> s = \n             NewInputStream<double>(\"Input Stream\", true /* verbose */); \n    // Construct a Streamulus instance \n    Streamulus Streamulus_engine;   \n\n```", "```cpp\n    // For each element of the Stream:  \n    //     aggregate the received value into a running sum\n    //     print it  \n    Streamulus_engine.Subscribe(Streamify<print>( s));    \n```", "```cpp\n    // Insert data to the input Stream \n    InputStreamPut<double>(s, 10); \n    InputStreamPut<double>(s, 20); \n    InputStreamPut<double>(s, 30);     \n} \nint main() {  hello_Stream();  return 0; } \n```", "```cpp\n/////////////////////////// \n//  g++ -I\"./Streamulus-master/src\"  -I<PathToBoost>s Streamulus_second.cpp \n#include \"Streamulus.h\" \n#include <ioStream> \nusing namespace std; \nusing namespace Streamulus; \n//-------  Functors for doubling/negating and halfving values \nstruct twice {     \n    template<typename T> \n    T operator()(const T& value) const {return value*2;} \n}; \nstruct neg {     \n    template<typename T> \n    T operator()(const T& value) const{ return -value; } \n}; \nstruct half{     \n    template<typename T> \n    T operator()(const T& value) const { return 0.5*value;} \n};\n```", "```cpp\nstruct print{     \n    template<typename T> \n    T operator()(const T& value) const{  \n        std::cout << value << std::endl; \n        return value; \n    } \n}; \nstruct as_string  { \n    template<typename T> \n    std::string operator()(const T& value) const {  \n        std::stringStream ss; \n        ss << value; \n        return ss.str(); \n    } \n};\n```", "```cpp\nvoid DataFlowGraph(){ \n    // Define an input Stream of strings, whose name is \"Input Stream\" \n    InputStream<double> s = \n          NewInputStream<double>(\"Input Stream\", false /* verbose */); \n    // Construct a Streamulus instance \n    Streamulus Streamulus_engine;             \n    // Define a Data Flow Graph for Stream based computation  \n    Subscription<double>::type val2 =  Streamulus_engine.Subscribe(Streamify<neg> \n                         (Streamify<neg>(Streamify<half>(2*s)))); \n    Subscription<double>::type val3 = Streamulus_engine.Subscribe( \n                                      Streamify<twice>(val2*0.5)); \n    Streamulus_engine.Subscribe(Streamify<print>(Streamify<as_string>(val3*2))); \n    //------------------ Ingest data into the Stream \n    for (int i=0; i<5; i++) \n        InputStreamPut(s, (double)i); \n}\n```", "```cpp\nint main(){ \n    DataFlowGraph(); //Trigger all action \n    return 0; \n} \n```", "```cpp\nInputStream<int>::type x = NewInputStream<int>(\"X\"); \nEngine.Subscribe( -(x+1)); \n```", "```cpp\n#include \"spreadsheet.hpp\" \n#include <ioStream> \nint main (int argc, const char * argv[]) {  \n    using namespace spreadsheet; \n    Spreadsheet sheet; \n    Cell<double> a = sheet.NewCell<double>(); \n    Cell<double> b = sheet.NewCell<double>(); \n    Cell<double> c = sheet.NewCell<double>(); \n    Cell<double> d = sheet.NewCell<double>(); \n    Cell<double> e = sheet.NewCell<double>(); \n    Cell<double> f = sheet.NewCell<double>();\n```", "```cpp\n    c.Set(SQRT(a()*a() + b()*b())); \n    a.Set(3.0); \n    b.Set(4.0); \n    d.Set(c()+b()); \n    e.Set(d()+c()); \n```", "```cpp\n    std::cout << \" a=\" << a.Value()  \n              << \" b=\" << b.Value()  \n              << \" c=\" << c.Value()  \n              << \" d=\" << d.Value()  \n              << \" e=\" << e.Value()  \n              << std::endl;\n```", "```cpp\n    c.Set(2*(a()+b())); \n    c.Set(4*(a()+b())); \n    c.Set(5*(a()+b())); \n    c.Set(6*(a()+b())); \n    c.Set(7*(a()+b())); \n    c.Set(8*(a()+b())); \n    c.Set(a()); \n    std::cout << \" a=\" << a.Value()  \n              << \" b=\" << b.Value()  \n              << \" c=\" << c.Value()  \n              << \" d=\" << d.Value()  \n              << \" e=\" << e.Value()  \n              << std::endl;     \n    std::cout << \"Goodbye!n\"; \n    return 0; \n} \n```", "```cpp\n#include <raft> \n#include <raftio> \n#include <cstdlib> \n#include <string> \n\nclass hi : public raft::kernel \n{ \npublic: \n    hi() : raft::kernel(){ output.addPort< std::string >( \"0\" ); } \n    virtual raft::kstatus run(){ \n        output[ \"0\" ].push( std::string( \"Hello Worldn\" ) ); \n        return( raft::stop );  \n    } \n}; \n\nint main( int argc, char **argv ) { \n    /** instantiate print kernel **/ \n    raft::print< std::string > p; \n    /** instantiate hello world kernel **/ \n    hi hello; \n    /** make a map object **/ \n    raft::map m; \n    /** add kernels to map, both hello and p are executed concurrently **/ \n    m += hello >> p; \n    /** execute the map **/ \n    m.exe(); \n    return( EXIT_SUCCESS ); \n} \n```"]