- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Asynchronous Programming Using Coroutines
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协程进行异步编程
- en: In previous chapters, we saw different methods of writing asynchronous code
    in C++. We used threads, the basic units of execution, and some higher-level asynchronous
    code mechanisms, such as futures and promises and **std::async** . We will look
    at the Boost.Asio library in the next chapter. All these methods often use several
    system threads, created and managed by the kernel.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了在C++中编写异步代码的不同方法。我们使用了线程，这是执行的基本单元，以及一些高级异步代码机制，如futures、promises和**std::async**。我们将在下一章中查看Boost.Asio库。所有这些方法通常使用多个系统线程，由内核创建和管理。
- en: For example, the main thread of our program may need to access a database. This
    access may be slow, so we read the data in a different thread so our main thread
    can go on doing some other tasks. Another example is the producer-consumer model,
    where one or more threads generate data items to be processed, and one or more
    threads process those items in a fully asynchronous way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们程序的主线程可能需要访问数据库。这种访问可能很慢，所以我们将在不同的线程中读取数据，以便主线程可以继续执行其他任务。另一个例子是生产者-消费者模型，其中一个或多个线程生成要处理的数据项，一个或多个线程以完全异步的方式处理这些项。
- en: Both of the preceding examples use threads, also called system (kernel) threads,
    and require different units of execution, one per thread.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两个示例都使用了线程，也称为系统（内核）线程，并需要不同的执行单元，每个线程一个。
- en: In this chapter, we are going to study a different way to write asynchronous
    code – coroutines. Coroutines are an old concept from the late 1950s that was
    added to C++ only recently, since C++20. They don’t need a separate thread (of
    course, we can have different threads running coroutines). Coroutines are a mechanism
    that allows us, among other things, to perform multiple tasks in a single thread.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究一种不同的异步代码编写方式——协程。协程是一个来自20世纪50年代末的老概念，直到C++20才被添加到C++中。它们不需要单独的线程（当然，我们可以在不同的线程中运行协程）。协程是一种机制，它使我们能够在单线程中执行多个任务。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What are coroutines and how are they implemented and supported by C++?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程是什么？它们是如何被C++实现和支持的？
- en: Implementing basic coroutines to see what the requirements of a C++ coroutine
    are
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基本协程以了解C++协程的要求
- en: Generator coroutines and the new C++23 **std::generator**
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器协程和新的C++23 **std::generator**
- en: A string parser to parse integers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于解析整数的字符串解析器
- en: Exceptions in coroutines
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程中的异常
- en: This chapter is about C++ coroutines implemented without using any third-party
    libraries. This way of writing coroutines is quite low level and we need to write
    code to support the compiler.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的是不使用任何第三方库实现的C++协程。这种方式编写协程相当底层，我们需要编写代码来支持编译器。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need a C++20 compiler. For the generator examples,
    you will need a C++23 compiler. We have tested the examples with GCC **14.1**
    . The code is platform-independent, so even though we have a Linux focus in this
    book, all the examples should work on macOS and Windows. Please note that Visual
    Studio **17.11** doesn’t support the C++23 **std::generator** yet.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要一个C++20编译器。对于生成器示例，你需要一个C++23编译器。我们已经测试了这些示例与GCC **14.1** 兼容。代码是平台无关的，因此尽管本书关注Linux，但所有示例都应在macOS和Windows上运行。请注意，Visual
    Studio **17.11** 还不支持C++23 **std::generator**。
- en: 'The code for this chapter can be found in the book’s GitHub repository: [https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)
    .'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)。
- en: Coroutines
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: Before we start implementing coroutines in C++, we will introduce coroutines
    conceptually and see how they can be useful in our programs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始用C++实现协程之前，我们将从概念上介绍协程，并看看它们在我们的程序中如何有用。
- en: Let’s start with a definition. A **coroutine** is a function that can suspend
    itself. Coroutines suspend themselves while waiting for an input value (while
    they are suspended, they don’t execute) or after yielding a value such as the
    result of a computation. Once the input value is available or the caller requests
    another value, the coroutine resumes execution. We will come back to coroutines
    in C++ soon, but let’s see with a real-life example how a coroutine works.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义开始。**协程**是一个可以暂停自己的函数。协程在等待输入值（在它们暂停时，它们不执行）或产生一个值，如计算的输出后暂停自己。一旦输入值可用或调用者请求另一个值，协程将恢复执行。我们很快将回到C++中的协程，但让我们通过一个现实生活中的例子来看看协程是如何工作的。
- en: Imagine someone working as an assistant. They start the day reading emails.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下有人在当助手。他们开始一天的工作是阅读电子邮件。
- en: One of the emails is a request for a report. After reading the email, they start
    writing the requested document. Once they have written the introductory paragraphs,
    they notice that they need another report from a colleague to get some accounting
    results from the previous quarter. They stop writing the report, write an email
    to their colleague requesting the needed information, and read the next email,
    which is a request to book a room for an important meeting in the afternoon. They
    open a special application the company has developed for booking meeting rooms
    automatically to optimize their use and book the room.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一封电子邮件是要求一份报告。在阅读电子邮件后，他们开始撰写所需的文档。一旦他们写完了引言段落，他们注意到他们需要从同事那里获取一份报告，以获取上一季度的会计结果。他们停止撰写报告，给同事写了一封电子邮件，请求所需的信息，然后阅读下一封电子邮件，这是一封要求预订下午重要会议的会议室的请求。他们打开公司开发的一个专门用于自动预订会议室以优化其使用的应用程序来预订会议室。
- en: After a while, they receive the required accounting data from their colleague
    and resume writing the report.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 过了一段时间，他们从同事那里收到了所需的会计数据，然后继续撰写报告。
- en: 'The assistant is always busy working on their tasks. Writing the report is
    a good example of a coroutine: they start writing the report, then suspend the
    writing while they wait for the required information, and once the information
    arrives, they resume their writing. Of course, the assistant doesn’t want to waste
    their time, and while they wait, they go on doing other tasks. Their colleague
    can be seen as another coroutine if they wait for requests and then send the appropriate
    response.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 助手总是忙于处理他们的任务。撰写报告是协程的一个好例子：他们开始撰写报告，然后在等待所需信息时暂停写作，一旦信息到达，他们继续写作。当然，助手不想浪费时间，在等待时，他们会继续做其他任务。如果他们等待请求并发出适当的响应，他们的同事可以被视为另一个协程。
- en: Now let’s go back to software. Let’s assume that we need to write a function
    that stores data in a database after processing some input information.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到软件。假设我们需要编写一个函数，在处理一些输入信息后，将数据存储到数据库中。
- en: If the data comes all at once, we can implement just a function. The function
    will read the input, perform the required processing on it, and finally, write
    the result to a database. But what if the data to be processed arrives in blocks
    and processing each block requires the result from the previous block processing
    (we can assume for the sake of this example that the first block processing needs
    only some default value)?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据一次性到达，我们只需实现一个函数。该函数将读取输入，对数据进行必要的处理，最后将结果写入数据库。但如果要处理的数据以块的形式到达，并且处理每个块都需要前一个块处理的结果（为了这个例子，我们可以假设第一个块的处理只需要一些默认值）呢？
- en: A possible solution to our problem would be to make the function wait for each
    data block, process it, store the result in the database, and then wait for the
    next one, and so on. But if we do that, we could potentially waste a lot of time
    while waiting for each block of data to arrive.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 解决我们问题的可能方法是在每个数据块到达时让函数等待，处理它，将结果存储在数据库中，然后等待下一个，依此类推。但如果我们这样做，我们可能会在等待每个数据块到达时浪费很多时间。
- en: 'After reading the previous chapters, you may be thinking about different potential
    solutions: we could create a thread to read the data, copy the blocks to a queue,
    and a second thread (maybe the main thread) will process the data. This is an
    acceptable solution but using multiple threads may be overkill.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了前面的章节后，你可能正在考虑不同的潜在解决方案：我们可以创建一个线程来读取数据，将块复制到队列中，然后第二个线程（可能是主线程）将处理数据。这是一个可接受的解决方案，但使用多个线程可能有些过度。
- en: Another solution could be implementing a function to process only one block.
    The caller will wait for the input to be passed to the function and will keep
    the result of the previous block processing required to process each data block.
    In this solution, we must keep the state required by the data processing function
    in another function. It may be acceptable for a simple example, but once the processing
    gets more complicated (for example, requiring several steps with different intermediate
    results to be kept), the code might be difficult to understand and maintain.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案可能是实现一个只处理一个数据块的函数。调用者将等待输入传递给函数，并保留处理每个数据块所需的上一块处理的结果。在这个解决方案中，我们必须在另一个函数中保留数据处理函数所需的状态。对于简单的示例可能是可接受的，但一旦处理变得更为复杂（例如，需要保留不同中间结果的多步处理），代码可能难以理解和维护。
- en: 'We can solve the problem with a coroutine. Let’s see some possible pseudocode
    for a coroutine that processes data in blocks and keeps intermediate results:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用协程解决这个问题。让我们看看处理数据块并保留中间结果的协程的一些可能的伪代码：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding coroutine receives a data block from the caller, performs all
    the processing, updates a database, and keeps the result required to process the
    next block. After yielding the result to the caller (more on yielding later),
    it suspends itself. Its execution will resume when the coroutine is called again
    by the caller requesting the processing of a new data block.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的协程从调用者那里接收一个数据块，执行所有处理，更新数据库，并保留处理下一个数据块所需的结果。在将结果传回调用者（关于传回的更多内容稍后讨论）之后，它将自己暂停。当调用者再次调用协程请求处理新的数据块时，其执行将恢复。
- en: A coroutine such as this simplifies state management because it can keep the
    state between calls.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的协程简化了状态管理，因为它可以在调用之间保持状态。
- en: After this conceptual introduction to coroutines, we are going to start implementing
    them in C++20.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在对协程进行概念介绍之后，我们将开始使用C++20实现它们。
- en: C++ coroutines
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++协程
- en: As we have seen, coroutines are just functions, but they are not like the functions
    we are used to. They have special properties that we will study in this chapter.
    In this section, we will focus on coroutines in C++.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，协程只是函数，但它们并不像我们习惯的函数。它们具有我们将在本章中学习的特殊属性。在本节中，我们将专注于C++中的协程。
- en: A function starts executing when it’s called and normally terminates with a
    return sentence or just when the function’s end is reached.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数在调用时开始执行，并通常通过返回语句或当函数的末尾到达时正常终止。
- en: A function runs from beginning to end. It may call another function (or even
    itself if it is recursive), and it may throw exceptions or have different return
    points. But it always runs from beginning to end.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数从开始到结束运行。它可能调用另一个函数（或者如果是递归的，甚至可以调用自己），它可能抛出异常或具有不同的返回点。但它总是从开始到结束运行。
- en: 'A coroutine is different. A coroutine is a function that can suspend itself.
    The flow for a coroutine may be like the following pseudocode:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是不同的。协程是一个可以暂停自己的函数。协程的流程可能如下伪代码所示：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will see what those terms with the **co_** prefix mean soon.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到那些带有**co_**前缀的术语的含义。
- en: For a coroutine, we need a mechanism to keep the execution state to be able
    to suspend/resume the coroutine. This is done for us by the compiler, but we must
    write some *helping* code to let the compiler help us back.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于协程，我们需要一个机制来保持执行状态，以便能够暂停/恢复协程。这是由编译器为我们完成的，但我们必须编写一些**辅助**代码，以便让编译器帮助我们。
- en: Coroutines in C++ are stackless. This means that the state we need to store
    to be able to suspend/resume the coroutine is stored in the heap calling **new**
    / **delete** to allocate/free dynamic memory. These calls are created by the compiler.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的协程是无堆栈的。这意味着我们需要存储以能够暂停/恢复协程的状态存储在堆中，通过调用**new**/**delete**来分配/释放动态内存。这些调用是由编译器创建的。
- en: New keywords
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新关键字
- en: 'Because a coroutine is essentially a function (with some special properties,
    but a function nonetheless), the compiler needs some way to know whether a given
    function is a coroutine. C++20 introduced three new keywords: **co_yield** , **co_await**
    , and **co_return** . If a function uses at least one of those three keywords,
    then the compiler knows it is a coroutine.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因为协程本质上是一个函数（具有一些特殊属性，但仍然是一个函数），编译器需要某种方式来确定给定的函数是否是协程。C++20引入了三个新的关键字：**co_yield**、**co_await**和**co_return**。如果一个函数使用了这三个关键字中的至少一个，那么编译器就知道它是一个协程。
- en: 'The following table summarizes the functionality of the new keywords:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了新关键字的函数：
- en: '| **Keyword** | **Input/Output** | **Coroutine State** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **关键字** | **输入/输出** | **协程状态** |'
- en: '| --- | --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **co_yield** | Output | Suspended |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **co_yield** | 输出 | 暂停 |'
- en: '| **co_await** | Input | Suspended |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **co_await** | 输入 | 暂停 |'
- en: '| **co_return** | Output | Terminated |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **co_return** | 输出 | 终止 |'
- en: 'Table 8.1: New coroutine keywords'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1：新的协程关键字
- en: In the preceding table, we see that after **co_yield** and **co_await** , the
    coroutine suspends itself, and after **co_return** , it is terminated ( **co_return**
    is the equivalent of the **return** statement in a C++ function). A coroutine
    cannot have a **return** statement; it must always use **co_return** . If the
    coroutine doesn’t return any value and any of the other two coroutine keywords
    are used, the **co_return** statement can be omitted.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，我们看到在 **co_yield** 和 **co_await** 之后，协程会暂停，而在 **co_return** 之后，它会终止（**co_return**
    在C++函数中相当于 **return** 语句）。协程不能有 **return** 语句；它必须始终使用 **co_return**。如果协程不返回任何值，并且使用了其他两个协程关键字之一，则可以省略
    **co_return** 语句。
- en: Coroutines restrictions
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协程限制
- en: 'We have said that coroutines are functions using the new coroutines keywords.
    But coroutines have the following restrictions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，协程是使用新协程关键字的函数。但协程有以下限制：
- en: Functions with a variable number of arguments using **varargs** can’t be coroutines
    (a variadic function template can be a coroutine)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **varargs** 的具有可变数量参数的函数不能是协程（一个变长函数模板可以是协程）
- en: A class constructor or destructor cannot be a coroutine
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类构造函数或析构函数不能是协程
- en: The **constexpr** and **consteval** functions cannot be coroutines
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**constexpr** 和 **consteval** 函数不能是协程'
- en: A function returning **auto** cannot be a coroutine but **auto** with a trailing
    return type can be
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 **auto** 的函数不能是协程，但带有尾随返回类型的 **auto** 可以是
- en: The **main()** function cannot be a coroutine
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**main()** 函数不能是协程'
- en: Lambdas can be coroutines
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda可以是协程
- en: After studying the restrictions of coroutines (basically what kind of C++ functions
    cannot be coroutines), we are going to start implementing coroutines in the next
    section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了协程的限制（基本上是哪些C++函数不能是协程）之后，我们将在下一节开始实现协程。
- en: Implementing basic coroutines
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基本协程
- en: In the previous section, we studied the basics of coroutines, what they are,
    and some use cases.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了协程的基本知识，包括它们是什么以及一些用例。
- en: 'In this section, we will implement three simple coroutines to illustrate the
    basics of implementing and working with them:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现三个简单的协程来展示实现和使用它们的基本方法：
- en: The simplest coroutine that just returns
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只返回的最简单协程
- en: A coroutine sending values back to the caller
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程向调用者发送值
- en: A coroutine getting values from the caller
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从调用者获取值的协程
- en: The simplest coroutine
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最简单的协程
- en: We know that a coroutine is a function that can suspend itself and can be resumed
    by the caller. We also know that the compiler identifies a function as a coroutine
    if it uses at least one **co_yield** , **co_await** , or **co_return** expression.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道协程是一个可以暂停自己的函数，并且可以被调用者恢复。我们还知道，如果函数至少使用了一个 **co_yield**、**co_await** 或
    **co_return** 表达式，编译器会将该函数识别为协程。
- en: The compiler will transform the coroutine source code and create some data structures
    and functions to make the coroutine functional and capable of being suspended
    and resumed. This is required to keep the coroutine state and be able to communicate
    with the coroutine.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将转换协程源代码，并创建一些数据结构和函数，使协程能够正常工作，并能够暂停和恢复。这是为了保持协程状态并能够与协程进行通信。
- en: The compiler will take care of all those details but bear in mind that C++ support
    for coroutines is quite low level. There are some libraries to make our lives
    easier when working with coroutines in C++. Some of them are **Lewis Baker’s cppcoro**
    and **Boost.Cobalt** . The **Boost.Asio** library has support for coroutines too.
    These libraries are the subject of the next two chapters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将处理所有这些细节，但请注意，C++对协程的支持相当底层。有一些库可以帮助我们在C++中更轻松地处理协程。其中一些是 **Lewis Baker的cppcoro**
    和 **Boost.Cobalt**。**Boost.Asio** 库也支持协程。这些库是下一章的主题。
- en: Let’s start from scratch. And we mean by absolute scratch. We will write some
    code and be guided by both compiler errors and the C++ reference to write a basic
    but fully functional coroutine.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从零开始。这里的“从零开始”是指绝对的零起点。我们将编写一些代码，并通过编译器错误和C++参考来编写一个基本但功能齐全的协程。
- en: 'The following code is the simplest implementation of a coroutine:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是协程的最简单实现：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Simple, isn’t it? Our first coroutine will just return nothing. It will not
    do anything else. Sadly, the preceding code is too simple for a functional coroutine
    and will not compile. When compiling with GCC **14.1** , we get the following
    error:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，不是吗？我们的第一个协程将只返回空值。它不会做任何其他事情。遗憾的是，前面的代码对于功能协程来说太简单了，无法编译。当使用GCC **14.1**
    编译时，我们得到以下错误：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also get the following note:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还得到了以下提示：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The compiler is giving us a hint: we may have missed including a required file.
    Let’s include the **<coroutine>** header file. We’ll deal with the error about
    the traits template in a minute:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器给我们一个提示：我们可能遗漏了包含一个必需的文件。让我们包含**<coroutine>**头文件。我们将在一会儿处理关于traits模板的错误：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When compiling the preceding code, we get the following error:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译前面的代码时，我们遇到了以下错误：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first version of our coroutine gave us a compiler error saying that the
    type **std::coroutine_traits** template couldn’t be found. Now we get an error
    related to something called the *promise type* .
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们协程的第一个版本给我们带来了一个编译错误，说找不到类型**std::coroutine_traits**模板。现在我们得到了一个与所谓的*promise类型*有关的错误。
- en: 'Looking at the C++ reference, we see that the **std::coroutine_traits** template
    determines the return type and parameter types of a coroutine. The reference also
    states that the return type of a coroutine must define a type named **promise_type**
    . Following the reference advice, we can write a new version of our coroutine:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 查看C++参考，我们看到**std::coroutine_traits**模板决定了协程的返回类型和参数类型。参考还指出，协程的返回类型必须定义一个名为**promise_type**的类型。遵循参考建议，我们可以编写我们协程的新版本：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Please note that the return type of a coroutine can have any name (we have called
    it **return_type** here because is convenient for this simple example).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，协程的返回类型可以有任何名称（我们在这里将其称为**return_type**，因为这在这个简单示例中很方便）。
- en: 'Compiling the preceding code again gives us some errors (they are edited for
    clarity). All the errors are about missing functions in the **promise_type** structure:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 再次编译前面的代码时，我们遇到了一些错误（为了清晰起见，错误已被编辑）。所有错误都与**promise_type**结构中缺少的函数有关：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All the compiler errors we have seen until now are related to missing features
    in our code. Writing coroutines in C++ requires following some rules and helping
    the compiler to make its generated code functional.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止看到的所有编译错误都与我们的代码中缺少的功能有关。在C++中编写协程需要遵循一些规则，并帮助编译器生成有效的代码。
- en: 'The following is the final version of the simplest coroutine:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最简单的协程的最终版本：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You may have noticed that we have removed the **std::coroutine_traits** template.
    Implementing the return and promise types is enough.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们已经移除了**std::coroutine_traits**模板。实现返回和promise类型就足够了。
- en: The preceding code compiles without any errors and you can run it. It does…
    nothing! But it’s our first coroutine and we have learned that we need to supply
    some code required by the compiler to create the coroutine.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码编译没有任何错误，你可以运行它。它确实...什么也不做！但这是我们第一个协程，我们已经了解到我们需要提供一些编译器所需的代码来创建协程。
- en: The promise type
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: promise类型
- en: The **promise type** is required by the compiler. We need to always have this
    type defined (it can be either a class or a struct), it must be named **promise_type**
    , and it must implement some functions specified in the C++ reference. We have
    seen that if we don’t do that, the compiler will complain and give us errors.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**promise类型**是编译器所要求的。我们需要始终定义此类型（它可以是类或结构体），它必须命名为**promise_type**，并且必须实现C++参考中指定的某些函数。我们已经看到，如果我们不这样做，编译器会抱怨并给出错误。'
- en: The promise type must be defined inside the type returned by the coroutine,
    otherwise the code will not compile. The returned type (sometimes also called
    the **wrapper type** because it wraps **promise_type** ) can be named arbitrarily.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: promise类型必须在协程返回的类型内部定义，否则代码将无法编译。返回的类型（有时也称为**wrapper类型**，因为它封装了**promise_type**）可以任意命名。
- en: A yielding coroutine
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个产生结果的协程
- en: A do-nothing coroutine is good for illustrating some basic concepts. We will
    now implement another coroutine that can send data back to the caller.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个什么也不做的协程对于说明一些基本概念很有用。我们现在将实现另一个可以将数据发送回调用者的协程。
- en: In this second example, we will implement a coroutine that produces a message.
    It will be the “hello world” of coroutines. The coroutine will say hello and the
    caller function will print the message received from the coroutine.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个例子中，我们将实现一个产生消息的协程。它将是协程的“hello world”。协程将说你好，调用函数将打印从协程接收到的消息。
- en: To implement that functionality, we need to establish a communication channel
    from the coroutine to the caller. This channel is the mechanism that allows the
    coroutine to pass values to the caller and receive information from it. This channel
    is established through the coroutine’s **promise type** and **handle** , which
    manages the state of the coroutine.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现该功能，我们需要从协程到调用者建立一个通信通道。这个通道是允许协程向调用者传递值并从它那里接收信息的机制。这个通道是通过协程的 **承诺类型**
    和 **句柄** 建立的，它们管理协程的状态。
- en: 'The communication channel works in the following way:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通信通道按以下方式工作：
- en: '**Coroutine frame** : When a coroutine is called, it creates a **coroutine
    frame** , which contains all the state information needed to suspend and resume
    its execution. This includes local variables, the promise type, and any internal
    state.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程帧** : 当协程被调用时，它创建一个 **协程帧** ，其中包含暂停和恢复其执行所需的所有状态信息。这包括局部变量、承诺类型以及任何内部状态。'
- en: '**Promise type** : Each coroutine has an associated **promise type** , which
    is responsible for managing the coroutine’s interaction with the caller functions.
    The promise is where the coroutine’s return value is stored, and it provides functions
    to control the coroutine’s behavior. We are going to see these functions in this
    chapter’s examples. The promise is the interface through which the caller interacts
    with the coroutine.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**承诺类型** : 每个协程都有一个相关的 **承诺类型** ，它负责管理协程与调用函数之间的交互。承诺是存储协程返回值的地方，它提供了控制协程行为的函数。我们将在本章的示例中看到这些函数。承诺是调用者与协程交互的接口。'
- en: '**Coroutine handle** : The **coroutine handle** is a type that gives access
    to the coroutine frame (the coroutine’s internal state) and allows the caller
    to resume or destroy the coroutine. The handle is what the caller can use to resume
    the coroutine after it has been suspended (for example, after **co_await** or
    **co_yield** ). The handle can also be used to check whether the coroutine is
    done or to clean up its resources.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程句柄** : 协程句柄是一种类型，它提供了对协程帧（协程的内部状态）的访问权限，并允许调用者恢复或销毁协程。句柄是调用者可以在协程被挂起后（例如，在
    **co_await** 或 **co_yield** 之后）恢复协程的东西。句柄还可以用来检查协程是否完成或清理其资源。'
- en: '**Suspend and resume mechanism** : When a coroutine yields a value ( **co_yield**
    ) or awaits an asynchronous operation ( **co_await** ), it suspends its execution,
    saving its state in the coroutine frame. The caller can then resume the coroutine
    at a later point, retrieving the yielded or awaited value through the coroutine
    handle and continuing the execution.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起和恢复机制** : 当协程yield一个值（ **co_yield** ）或等待异步操作（ **co_await** ）时，它挂起其执行，将其状态保存在协程帧中。然后调用者可以在稍后恢复协程，通过协程句柄检索yielded或awaited的值并继续执行。'
- en: We are going to see, in the following examples, that this communication channel
    requires a considerable amount of code on our side to help the compiler generate
    all the code required for a coroutine to be functional.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下示例中看到，这个通信通道需要我们在自己的这一侧编写相当数量的代码，以帮助编译器生成协程功能所需的全部代码。
- en: 'The following code is the new version of both the caller function and the coroutine:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是调用函数和协程的新版本：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The changes are as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 变更如下：
- en: '**[1]** : The coroutine *yields* and sends some data (in this case, a **std::string**
    object) to the caller'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[1]** : 协程 *yield* 并向调用者发送一些数据（在这种情况下，一个 **std::string** 对象）'
- en: '**[2]** : The caller reads that data and prints it'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[2]** : 调用者读取那些数据并将其打印出来'
- en: The required communication mechanism is implemented in the promise type and
    in the return type (which is a promise type wrapper).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的通信机制在承诺类型和返回类型（这是一个承诺类型包装器）中实现。
- en: When the compiler reads the **co_yield** expression, it will generate a call
    to the **yield_value** function defined in the promise type.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器读取 **co_yield** 表达式时，它将生成对在承诺类型中定义的 **yield_value** 函数的调用。
- en: 'The following code is the implementation for our version of that function that
    generates (or yields) a **std::string** object:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是我们版本的该函数的实现，该函数生成（或yield）一个 **std::string** 对象：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The function gets a **std::string** object and moves it to the **output_data**
    member variable of the promise type. But this just keeps the data inside the promise
    type. We need a mechanism to get that string out of the coroutine.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 函数获取一个 **std::string** 对象并将其移动到承诺类型的 **output_data** 成员变量中。但这只是将数据保留在承诺类型内部。我们需要一种机制来将那个字符串从协程中取出。
- en: The handle type
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 句柄类型
- en: Once we require a communication channel to and from a coroutine, we need a way
    to refer to a suspended or executing coroutine. The C++ standard library implements
    such a mechanism in what is called a **coroutine handle** . Its type is **std::coroutine_handle**
    and it’s a member variable of the return type. This structure is also responsible
    for the full life cycle of the handle, creating and destroying it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们需要一个协程的通信通道，我们需要一种方式来引用一个挂起或正在执行的协程。C++标准库在所谓的**协程句柄**中实现了这样的机制。它的类型是**std::coroutine_handle**，它是返回类型的成员变量。这个结构也负责句柄的完整生命周期，包括创建和销毁它。
- en: 'The following code snippet is the functionality we added to our return type
    to manage a coroutine handle:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是我们添加到返回类型中以管理协程句柄的功能：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code declares a coroutine handle of type **std::coroutine_handle<promise_type>**
    and creates the handle in the return type constructor. The handle is destroyed
    in the return type destructor.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码声明了一个类型为**std::coroutine_handle<promise_type>**的协程句柄，并在返回类型构造函数中创建句柄。句柄在返回类型析构函数中被销毁。
- en: 'Now, back to our yielding coroutine. The only missing bit is the **get()**
    function for the caller function to be able to access the string generated by
    the coroutine:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的产生值的协程。唯一缺少的部分是调用函数的**get()**函数，以便能够访问协程生成的字符串：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The **get()** function resumes the coroutine if it is not terminated and then
    returns the string object.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**get()**函数在协程未终止的情况下恢复协程，然后返回字符串对象。'
- en: 'The following is the full code for our second coroutine:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们第二个协程的完整代码：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running the preceding code prints the following messages:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会打印以下消息：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This output shows us what is happening during the coroutine execution:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示了协程执行期间发生的情况：
- en: The **return_type** object is created after a call to **get_return_object**
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**return_type**对象在调用**get_return_object**之后创建'
- en: The coroutine is initially suspended
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协程最初是挂起的
- en: The caller wants to get the message from the coroutine, so **get()** is called
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用者想要从协程中获取消息，因此调用**get()**
- en: '**yield_value** is called and the coroutine is resumed and the message is copied
    to a member variable in the promise'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**yield_value**被调用，协程被恢复，并且消息被复制到承诺的成员变量中'
- en: Finally, the message is printed by the caller function, and the coroutine returns
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用函数打印消息，协程返回
- en: Note that the promise (and promise type) have nothing to do with the C++ Standard
    Library **std::promise** type explained in *Chapter 6* .
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，承诺（以及承诺类型）与在*第6章*中解释的C++标准库**std::promise**类型无关。
- en: A waiting coroutine
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待中的协程
- en: In the previous example, we saw how to implement a coroutine that can communicate
    back to the caller by sending it a **std::string** object. Now, we are going to
    implement a coroutine that can wait for input data sent by the caller. In our
    example, the coroutine will wait until it gets a **std::string** object and then
    print it. When we say that the coroutine “waits,” we mean it is suspended (that
    is, not executing) until the data is received.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了如何实现一个可以通过发送**std::string**对象来回调者通信的协程。现在，我们将实现一个可以等待调用者发送的输入数据的协程。在我们的例子中，协程将等待直到它接收到一个**std::string**对象，然后打印它。当我们说协程“等待”时，我们的意思是它是挂起的（即，没有执行）直到数据接收。
- en: 'Let’s start with changes to both the coroutine and the caller function:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从协程和调用函数的更改开始：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, the caller function calls the **put()** function (a method
    in the return type structure) and the coroutine calls **co_await** to wait for
    a **std::string** object from the caller.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，调用函数调用**put()**函数（返回类型结构中的方法）和协程调用**co_await**等待从调用者那里来的**std::string**对象。
- en: 'The changes to the return type are simple, that is, just adding the **put()**
    function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型的更改很简单，即只是添加**put()**函数：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We need to add the **input_data** variable to the promise structure. But just
    with those changes to our first example (we take it as the starting point for
    the rest of the examples in this chapter because it’s the minimum code to implement
    a coroutine) and the coroutine handle from the previous example, the code cannot
    be compiled. The compiler gives us the following error:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将**input_data**变量添加到承诺结构中。但是，仅仅通过对我们第一个示例所做的更改（我们将它作为本章其余示例的起点，因为它是最少的代码来实现协程）以及上一个示例中的协程句柄，代码无法编译。编译器给我们以下错误：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Going back to the C++ reference, we see that when the coroutine calls **co_await**
    , the compiler will generate code to call a function in the promise object called
    **await_transform** , which has a parameter of the same type as the data the coroutine
    is waiting for. As its name implies, **await_transform** is a function that transforms
    any object (in our example, **std::string** ) into an awaitable object. **std::string**
    is not awaitable, hence the previous compiler error.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回到C++参考，我们看到当协程调用**co_await**时，编译器将生成代码来调用承诺对象中的函数**await_transform**，该函数的参数类型与协程等待的数据类型相同。正如其名所示，**await_transform**是一个将任何对象（在我们的例子中，**std::string**）转换为可等待对象的函数。**std::string**是不可等待的，因此之前的编译器错误。
- en: '**await_transform** must return an **awaiter** object. This is just a simple
    struct implementing a required interface for the awaiter to be usable by the compiler.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**await_transform**必须返回一个**awaiter**对象。这只是一个简单的结构，实现了使编译器能够使用awaiter所需的基本接口。'
- en: 'The following code shows our implementation of the **await_transform** function
    and the **awaiter** struct:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们实现的**await_transform**函数和**awaiter**结构：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The **promise_type** function **await_transform** is required by the compiler.
    We cannot use a different identifier for this function. The parameter type must
    be the same as the object the coroutine is waiting for. The **awaiter** struct
    can be named with any name. We used **awaiter** here because is descriptive. The
    **awaiter** struct must implement three functions:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器需要**promise_type**函数**await_transform**。我们不能为这个函数使用不同的标识符。参数类型必须与协程等待的对象类型相同。**awaiter**结构可以命名为任何名称。我们在这里使用**awaiter**是因为它具有描述性。**awaiter**结构必须实现三个函数：
- en: '**await_ready** : This is called to check whether the coroutine is suspended.
    If that is the case, it returns **false** . In our example, it always returns
    **true** to indicate the coroutine is not suspended.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**await_ready**：这个函数用于检查协程是否被挂起。如果是这种情况，它返回**false**。在我们的例子中，它总是返回**true**，表示协程没有被挂起。'
- en: '**await_resume** : This resumes the coroutine and generates the result of the
    **co_await** expression.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**await_resume**：这个函数恢复协程并生成**co_await**表达式的结果。'
- en: '**await_suspend** : In our simple awaiter, this returns **void** , meaning
    the control is passed to the caller and the coroutine is suspended. It’s also
    possible for **await_suspend** to return a Boolean. Returning **true** in this
    case is like returning **void** . Returning **false** means the coroutine is resumed.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**await_suspend**：在我们的简单awaiter中，这个函数返回**void**，意味着控制权传递给调用者，协程被挂起。**await_suspend**也可以返回一个布尔值。在这种情况下返回**true**就像返回**void**一样。返回**false**意味着协程被恢复。'
- en: 'This is the code for the full example of the waiting coroutine:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是等待协程完整示例的代码：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this section, we have seen three basic examples of coroutines. We have implemented
    the simplest coroutine and then coroutines with communication channels to both
    generate data for the caller ( **co_yield** ) and wait for data from the caller
    ( **co_await** ).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了协程的三个基本示例。我们实现了最简单的协程，然后是具有通信通道的协程，这些协程既为调用者生成数据（**co_yield**），又从调用者那里等待数据（**co_await**）。
- en: In the next section, we will implement a type of coroutine called a generator
    and generate sequences of numbers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现一种称为生成器的协程类型，并生成数字序列。
- en: Coroutine generators
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程生成器
- en: A **generator** is a coroutine that generates a sequence of elements by repeatedly
    resuming itself from the point that it was suspended.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成器**是一个协程，通过反复从它被挂起的位置恢复自身来生成一系列元素。'
- en: A generator can be seen as an *infinite* sequence because it can generate an
    arbitrary number of elements. The caller function can get as many new elements
    from the generator as it needs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器可以被视为一个**无限**序列，因为它可以生成任意数量的元素。调用函数可以从生成器获取它所需的所有新元素。
- en: When we say infinite, we mean in theory. A generator coroutine will yield elements
    without a definite last element (it is possible to implement generators with a
    limited range) but, in practice, we must deal with issues such as overflow in
    the case of numerical sequences.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说无限时，我们指的是理论上。生成器协程将产生元素，没有明确的最后一个元素（可以实现具有有限范围的生成器），但在实践中，我们必须处理诸如数值序列中的溢出等问题。
- en: Let’s implement a generator from scratch, applying the knowledge we have gained
    in the previous sections of this chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从零开始实现一个生成器，应用我们在本章前几节学到的知识。
- en: Fibonacci sequence generator
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 斐波那契序列生成器
- en: Imagine we are implementing an application and we need to use the Fibonacci
    sequence. As you probably already know, the **Fibonacci sequence** is a sequence
    in which each number is the sum of the two preceding ones. The first element is
    0, the second element is 1, and then we apply the definition and generate element
    after element.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们正在实现一个应用程序，并且需要使用斐波那契序列。您可能已经知道，**斐波那契序列**是一个序列，其中每个数字都是前两个数字的和。第一个元素是0，第二个元素是1，然后我们应用定义并逐个生成元素。
- en: '![<math  display="block"><mrow><mrow><mi>F</mi><mi>i</mi><mi>b</mi><mi>o</mi><mi>n</mi><mi>a</mi><mi>c</mi><mi>c</mi><mi>i</mi><mi>s</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>:</mo><mi>F</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>F</mi><mfenced open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></mfenced><mo>+</mo><mi>F</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfenced><mo>;</mo><mi>F</mi><mfenced
    open="(" close=")"><mn>0</mn></mfenced><mo>=</mo><mn>0</mn><mo>,</mo><mi>F</mi><mfenced
    open="(" close=")"><mn>1</mn></mfenced><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/12.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![<math display="block"><mrow><mrow><mi>F</mi><mi>i</mi><mi>b</mi><mi>o</mi><mi>n</mi><mi>a</mi><mi>c</mi><mi>c</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>:</mo><mi>F</mi><mfenced
    open="(" close=")"><mi>n</mi></mfenced><mo>=</mo><mi>F</mi><mfenced open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></mfenced><mo>+</mo><mi>F</mi><mfenced
    open="(" close=")"><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></mfenced><mo>;</mo><mi>F</mi><mfenced
    open="(" close=")"><mn>0</mn></mfenced><mo>=</mo><mn>0</mn><mo>,</mo><mi>F</mi><mfenced
    open="(" close=")"><mn>1</mn></mfenced><mo>=</mo><mn>1</mn></mrow></mrow></math>](img/12.png)'
- en: We can always generate these numbers with a **for** loop. But if we need to
    generate them at different points in our program, we need to implement a way to
    store the state of the sequence. We need to keep somewhere in our program what
    the last element we generated was. Was it the fifth or maybe the tenth element?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是可以用一个 **for** 循环生成这些数字。但如果我们需要在程序的不同点生成它们，我们需要实现一种存储序列状态的方法。我们需要在我们的程序中某个地方保留我们生成的最后一个元素是什么。是第五个还是可能是第十个？
- en: A coroutine is a very good solution for this problem; it will keep the required
    state itself and it will suspend until we request the next number in the sequence.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是解决这个问题的非常好的解决方案；它会自己保持所需的状态，并且它会在我们请求序列中的下一个数字时暂停。
- en: 'Here’s the code using a generator coroutine:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用生成器协程的代码：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see in the preceding code, we generate the numbers we need without
    worrying about what the last element was. The sequence is generated by the coroutine.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中看到的，我们生成所需的数字时无需担心最后一个元素是什么。序列是由协程生成的。
- en: Note that even though in theory the sequence is infinite, our program must be
    aware of potential overflow for very big Fibonacci numbers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管在理论上序列是无限的，但我们的程序必须意识到非常大的斐波那契数可能存在溢出的潜在风险。
- en: To implement the generator coroutine, we follow the principles explained previously
    in this chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现生成器协程，我们遵循本章之前解释的原则。
- en: 'First, we implement the coroutine function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实现协程函数：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The coroutine just generates the next element in the Fibonacci sequence by applying
    the formula. The elements are generated in an infinite loop, but the coroutine
    suspends itself after **co_yield** .
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 协程通过应用公式生成斐波那契序列的下一个元素。元素在无限循环中生成，但协程在 **co_yield** 后会暂停自己。
- en: The return type is the **sequence_generator** struct (we use a template to be
    able to use either 32- or 64-bit integers). It contains a promise type, pretty
    much like the one in the yielding coroutine we saw in a previous section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型是 **sequence_generator** 结构体（我们使用模板以便能够使用32位或64位整数）。它包含一个承诺类型，与我们在前一个部分中看到的产生式协程中的承诺类型非常相似。
- en: In the **sequence_generator** struct, we added two functions that are useful
    when implementing a sequence generator.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **sequence_generator** 结构体中，我们添加了两个在实现序列生成器时有用的函数。
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The **next()** function resumes the coroutine for a new Fibonacci number in
    the sequence to be generated.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**next()** 函数用于恢复协程以生成序列中要生成的下一个斐波那契数。'
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The **value()** function returns the last generated Fibonacci number.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**value()** 函数返回最后一个生成的斐波那契数。'
- en: This way, we decouple element generation and its retrieval Qvalue.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就解耦了元素生成和其检索Q值。
- en: Please find the full code for this example in the book’s accompanying GitHub
    repository.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请在本书的配套GitHub仓库中找到此示例的完整代码。
- en: C++23 std::generator
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++23 std::generator
- en: We have seen that implementing even the most basic coroutine in C++ requires
    a certain amount of code. This may change in C++26 with more support for coroutines
    in the C++ Standard Library, which will allow us to write coroutines much more
    easily.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，即使在 C++ 中实现最基础的协程也需要一定量的代码。这可能在 C++26 中改变，因为 C++ 标准库对协程的支持将更多，这将使我们能够更容易地编写协程。
- en: C++23 introduced the **std::generator** template class. By using it, we can
    write coroutine-based generators without writing any of the required code, such
    as the promise type, the return type, and all their functions. To run this example,
    you will need a C++23 compiler. We have used GCC 14.1. **std::generator** is not
    available in Clang.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: C++23 引入了 **std::generator** 模板类。通过使用它，我们可以编写基于协程的生成器，而无需编写任何所需的代码，例如承诺类型、返回类型及其所有函数。要运行此示例，您需要一个
    C++23 编译器。我们使用了 GCC 14.1。**std::generator** 在 Clang 中不可用。
- en: 'Let’s see the Fibonacci sequence generator using the new C++23 Standard Library
    features:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用新的 C++23 标准库特性的斐波那契数列生成器：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first step is to include the **<generator>** header file. Then, we just
    write the coroutine because all the rest of the required code has been written
    for us. In the preceding code, we access the generated elements with an iterator
    (which is provided by the C++ Standard Library). This allows us to use a range-for
    loop, algorithms, and ranges.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是包含 **<generator>** 头文件。然后，我们只需编写协程，因为所有其他所需的代码都已经为我们编写好了。在前面的代码中，我们使用迭代器（由
    C++ 标准库提供）访问生成的元素。这允许我们使用范围-for 循环、算法和范围。
- en: 'It is also possible to write a version of the Fibonacci generator to generate
    a certain number of elements instead of an infinite series:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以编写一个斐波那契生成器的版本，生成一定数量的元素而不是无限序列：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The code changes are very simple: just pass the number of elements we want
    the generator to generate and use it as the termination condition in the **while**
    loop.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 代码更改非常简单：只需传递我们希望生成器生成的元素数量，并在 **while** 循环中将其用作终止条件。
- en: In this section, we have implemented one of the most common coroutine types
    – a generator. We have implemented generators both from scratch and using the
    C++23 **std::generator** class template.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们实现了最常见的协程类型之一——生成器。我们从头开始实现了生成器，也使用了 C++23 的 **std::generator** 类模板。
- en: We will implement a simple string parser coroutine in the next section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将实现一个简单的字符串解析器协程。
- en: Simple coroutine string parser
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的协程字符串解析器
- en: 'In this section, we will implement our last example: a simple string parser.
    The coroutine will wait for the input, a **std::string** object, and will yield
    the output, a number, after parsing the input string. To simplify the example,
    we will assume that the string representation of the number doesn’t have any errors
    and that the end of a number is represented by the hash character, **#** . We
    will also assume that the number type is **int64_t** and that the string won’t
    contain any values out of that integer type range.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现我们的最后一个示例：一个简单的字符串解析器。协程将等待输入，一个 **std::string** 对象，并在解析输入字符串后产生输出，即一个数字。为了简化示例，我们将假设数字的字符串表示没有错误，并且数字的结尾由哈希字符，**#**
    表示。我们还将假设数字类型是 **int64_t**，并且字符串不会包含该整数类型范围之外的任何值。
- en: The parsing algorithm
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析算法
- en: 'Let’s see how to convert a string representing an integer into a number. For
    example, the string **"-12321#"** represents the number -12321. To convert the
    string into a number, we can write a function like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将表示整数的字符串转换为数字。例如，字符串 **"-12321#"** 表示数字 -12321。要将字符串转换为数字，我们可以编写一个像这样的函数：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The code is quite simple because of the assumption that the string is well formed.
    If we read the minus sign, **-** , then we change the sign to -1 (by default,
    we assume positive numbers, and if there is a **+** sign, it is simply ignored).
    Then, the digits are read one by one, and the number value is calculated as follows.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于假设字符串是良好形成的，代码相当简单。如果我们读取负号，**-**，则将符号更改为 -1（默认情况下，我们假设正数，如果有 **+** 符号，则简单地忽略它）。然后，逐个读取数字，并按以下方式计算数字值。
- en: 'The initial value of **num** is **0** . We read the first digit and add its
    numeric value to the current **num** value multiplied by 10. This is the way we
    read numbers: the leftmost digit will be multiplied by 10 as many times as the
    number of digits to its right.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**num** 的初始值是 **0**。我们读取第一个数字，并将其数值加到当前 **num** 值乘以 10 上。这就是我们读取数字的方式：最左边的数字将乘以
    10，次数等于其右侧数字的数量。'
- en: When we use characters to represent digits, they have some value according to
    the ASCII representation (we assume no wide characters or any other character
    type is used). The characters *0* to *9* have consecutive ASCII codes, so we can
    easily convert them to numbers by just subtracting *0* .
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用字符来表示数字时，它们根据ASCII表示法有一定的值（我们假设没有使用宽字符或其他任何字符类型）。字符*0*到*9*具有连续的ASCII码，因此我们可以通过简单地减去*0*来轻松地将它们转换为数字。
- en: Even if for the preceding code the last character check is not necessary, we
    have included it here. When the parser routine finds the **#** character, it terminates
    the parsing loop and returns the final number value.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于前面的代码，最后的字符检查可能不是必要的，但我们还是在这里包含了它。当解析器例程找到**#**字符时，它将终止解析循环并返回最终的数值。
- en: We can use this function to parse any string and get the number value, but we
    need the full string to convert it into a number.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个函数解析任何字符串并获取数值，但我们需要完整的字符串来将其转换为数字。
- en: 'Let’s think about this scenario: the string is being received from a network
    connection and we need to parse it and convert it into a number. We may save the
    characters to a temporary string and then call the preceding function.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑这个场景：字符串正在从网络连接接收，我们需要解析它并将其转换为数字。我们可能将字符保存到一个临时字符串中，然后调用前面的函数。
- en: 'But there is another issue: what if the characters arrive slowly, such as once
    every few seconds, because that’s the way they are transmitted? We want to keep
    our CPU busy and, if possible, do some other task (or tasks) while waiting for
    each character to arrive.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有一个问题：如果字符以每几秒一次的速度缓慢到达，那会怎样？因为这就是它们传输的方式？我们希望保持CPU忙碌，并在可能的情况下，在等待每个字符到达时执行其他任务（或多个任务）。
- en: There are different approaches to solving this problem. We can create a thread
    and process the string concurrently, but this can be costly in computer time for
    such a simple task. We can use **std::async** too.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有不同的方法。我们可以创建一个线程并发处理字符串，但这对于这样一个简单的任务来说可能会在计算机时间上代价高昂。我们也可以使用**std::async**。
- en: The parsing coroutine
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析协程
- en: We are working with coroutines in this chapter, so we will implement the string
    parser using C++ coroutines. We don’t need an extra thread, and because of the
    asynchronous nature of coroutines, it will be quite easy to perform any other
    processing while the characters arrive.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们正在使用协程，因此我们将使用C++协程实现字符串解析。我们不需要额外的线程，并且由于协程的异步性质，在字符到达时执行任何其他处理将非常容易。
- en: 'The boilerplate code we will need for the parsing coroutine is pretty much
    the same as the code we have already seen in the previous examples. The parser
    itself is quite different. See the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的解析协程的样板代码与我们在前面的示例中已经看到的代码几乎相同。解析器本身则相当不同。请看以下代码：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I think that you can now easily recognize the return type ( **async_parse<int64_t,
    char>** ) and that the parser coroutine suspends itself waiting for an input character.
    The coroutine will suspend itself after yielding the number once the parsing has
    been done.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为你现在可以轻松地识别返回类型（**async_parse<int64_t, char>**），并且知道解析协程会在等待输入字符时挂起。一旦解析完成，协程会在返回数字后挂起自己。
- en: But you can see too that the preceding code is not as simple as our first attempt
    at parsing a string into a number.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也会看到，前面的代码并不像我们第一次尝试将字符串解析为数字那样简单。
- en: First, the parser coroutine parses one character after another. It doesn’t get
    the full string to parse, hence the infinite **while (true)** loops. We don’t
    know how many characters there are in the full string, so we need to keep on receiving
    and parsing them.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，解析协程逐个解析字符。它不获取完整的字符串来解析，因此有无限循环**while (true)**。我们不知道完整字符串中有多少个字符，因此我们需要继续接收和解析它们。
- en: The outer loop means that the coroutine will parse numbers, one after another,
    as the characters arrive – forever. But remember that it suspends itself to wait
    for the characters, so we don’t waste CPU time.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 外层循环意味着协程将解析数字，一个接一个，随着字符的到达——永远。但请记住，它会挂起自己以等待字符，所以我们不会浪费CPU时间。
- en: Now, one character arrives. The first check is to see whether it is a valid
    character for our number. If the character is not either the minus sign, **-**
    , the plus sign, **+** , or a digit, then the parser waits for the next character.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个字符到达。首先检查这个字符是否是我们数字的有效字符。如果字符既不是负号**-**，也不是正号**+**，也不是一个数字，那么解析器将等待下一个字符。
- en: 'If the next character is a valid one, then the following apply:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下一个字符是有效的，那么以下适用：
- en: If it is the minus sign, we change the sign value to -1
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是减号，我们将符号值更改为-1
- en: If it is the plus sign, we ignore it
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是加号，我们忽略它
- en: If it is a digit, we parse it into the number, updating the current number value
    using the same method as we saw in the first version of the parser
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是数字，我们将其解析到数字中，使用与我们在解析器的第一个版本中看到的方法更新当前数字值。
- en: After the first valid character, we enter a new loop to receive the rest of
    the characters, either digits or the separator character ( **#** ). Note here
    that when we say valid character, we mean good for numerical conversion. We are
    still assuming that the input characters form a valid number that is correctly
    terminated.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个有效字符之后，我们进入一个新的循环来接收其余的字符，无论是数字还是分隔符字符（**#**）。注意，当我们说有效字符时，我们是指对数值转换好的。我们仍然假设输入字符形成一个有效的数字，并且正确终止。
- en: Once the number has been converted, it is yielded by the coroutine and the outer
    loop executes again. The terminating character is needed here because the input
    character stream is, in theory, endless, and it can contain many numbers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数字被转换，它就会被协程产生，外层循环再次执行。这里需要一个终止字符，因为输入字符流在理论上是无尽的，它可以包含许多数字。
- en: 'The code for the rest of the coroutine can be found in the GitHub repo. It
    follows the same convention as any other coroutine. First, we define the return
    type:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 协程其余部分的代码可以在GitHub仓库中找到。它遵循任何其他协程相同的约定。首先，我们定义返回类型：
- en: '[PRE29]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We use a template for flexibility because it allows us to parameterize both
    the input and output data types. In this case, these types are **int64_t** and
    **char** , respectively.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用模板以提高灵活性，因为它允许我们参数化输入和输出数据类型。在这种情况下，这些类型分别是**int64_t**和**char**。
- en: 'The input and output data items are the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 输入和输出数据项如下：
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For input, we are using **std::optional<In>** because we need a way to know
    whether we have received a character. We use the **put()** function to send a
    character to the parser:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入，我们使用**std::optional<In>**，因为我们需要一种方式来知道我们是否收到了一个字符。我们使用**put()**函数将字符发送到解析器：
- en: '[PRE31]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This function just assigns a value to the **std::optional** **input_data**
    variable. To manage the waiting for the characters, we implement the following
    awaiter type:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数只是将值赋给**std::optional** **input_data**变量。为了管理等待字符，我们实现以下awaiter类型：
- en: '[PRE32]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The **awaiter** struct implements two functions to handle the input data:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**awaiter**结构体实现了两个函数来处理输入数据：'
- en: '**await_ready()** : Returns **true** if the optional **input_data** variable
    contains a valid value. It returns **false** otherwise.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**await_ready()**：如果可选的**input_data**变量包含有效值，则返回**true**。否则返回**false**。'
- en: '**await_resume()** : Returns the value stored in the optional **input_data**
    variable and *empties* it, assigning it to **std::nullopt** .'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**await_resume()**：返回存储在可选**input_data**变量中的值，并将其清空，赋值为**std::nullopt**。'
- en: In this section, we have seen how to implement a simple parser using C++ coroutines.
    This is our last example, illustrating a very basic stream processing function
    using coroutines. In the next section, we will see exceptions in coroutines.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何使用C++协程实现一个简单的解析器。这是我们最后的示例，展示了使用协程的一个非常基本的流处理函数。在下一节中，我们将看到协程中的异常。
- en: Coroutines and exceptions
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程和异常
- en: 'In the previous sections, we implemented a few basic examples to learn the
    main C++ coroutines concepts. We implemented a very basic coroutine first to understand
    what the compiler required from us: the return type (sometimes called the wrapper
    type because it wraps the promise type) and the promise type.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们实现了一些基本示例来学习主要的C++协程概念。我们首先实现了一个非常基本的协程，以了解编译器对我们有什么要求：返回类型（有时称为包装类型，因为它包装了承诺类型）和承诺类型。
- en: 'Even for such a simple coroutine, we had to implement some functions we explained
    while we wrote the examples. But one function has not been explained yet:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于这样一个简单的协程，我们也必须实现我们在编写示例时解释的一些函数。但有一个函数尚未解释：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We assumed then that coroutines couldn’t throw exceptions, but the truth is
    they can. We can add the functionality to handle exceptions in the body of the
    **unhandled_exception()** function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当时假设协程不能抛出异常，但事实是它们可以。我们可以在**unhandled_exception()**函数体中添加处理异常的功能。
- en: Exceptions in coroutines can happen while the return type or the promise type
    object is created and while the coroutine is executed (as in a normal function,
    coroutines can throw exceptions).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 协程中的异常可能在创建返回类型或承诺类型对象时发生，也可能在协程执行时发生（就像正常函数一样，协程可以抛出异常）。
- en: The difference is that if the exception is thrown before the coroutine is executed,
    the code creating the coroutine must handle the exception, while if the exception
    is thrown when the coroutine is executed, then **unhandled_exception()** is called.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于，如果在协程执行之前抛出异常，创建协程的代码必须处理该异常，而如果在协程执行时抛出异常，则调用**unhandled_exception()**。
- en: The first case is just the usual exception handling with no special functions
    called. We can put the coroutine creation inside a **try-catch** block and handle
    the possible exceptions as we normally do in our code.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况只是通常的异常处理，没有调用特殊函数。我们可以在**try-catch**块中放置协程创建，并像我们通常在代码中那样处理可能的异常。
- en: If, on the other hand, **unhandled_exception()** is called (inside the promise
    type), we must implement the exception-handling functionality inside that function.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一方面，调用了**unhandled_exception()**（在promise类型内部），我们必须在该函数内部实现异常处理功能。
- en: 'There are different strategies to handle such exceptions. Among them are the
    following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 处理此类异常有不同的策略。其中之一如下：
- en: Rethrow the exception so we can handle it outside the promise type (that is,
    in our code).
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新抛出异常，这样我们就可以在promise类型之外（即在我们的代码中）处理它。
- en: Terminate the program (for example, calling **std::terminate** ).
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止程序（例如，调用**std::terminate**）。
- en: Leave the function empty. In this case, the coroutine will crash and it will
    very likely crash the program too.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 留下函数为空。在这种情况下，协程将崩溃，并且它很可能导致程序崩溃。
- en: Because we have implemented very simple coroutines, we have left the function
    empty.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们实现了非常简单的协程，所以我们留下了函数为空。
- en: In this last section, we have introduced the exception-handling mechanism for
    coroutines. It is very important to handle exceptions properly. For example, if
    you know that after an exception occurs inside a coroutine, it won’t be able to
    recover; then, it may be better to let the coroutine crash and handle the exception
    from another part of the program (usually from the caller function).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们介绍了协程的异常处理机制。正确处理异常非常重要。例如，如果你知道协程内部发生异常后无法恢复；那么，可能更好的做法是让协程崩溃，并在程序的另一部分（通常是从调用函数）处理异常。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have seen coroutines, a recently introduced feature in C++
    that allows us to write asynchronous code without creating new threads. We have
    implemented a few simple coroutines to explain the basic requirements of a C++
    coroutine. Additionally, we have learned how to implement generators and a string
    parser. Finally, we have seen exceptions in coroutines.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了协程，这是C++中最近引入的一个特性，允许我们编写不需要创建新线程的异步代码。我们实现了一些简单的协程来解释C++协程的基本要求。此外，我们还学习了如何实现生成器和字符串解析器。最后，我们看到了协程中的异常。
- en: Coroutines are important in asynchronous programming because they let the program
    suspend execution at specific points and resume later, allowing other tasks to
    run in the meantime, all running in the same thread. They allow better resource
    utilization, reduce waiting time, and improve the scalability of applications.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 协程在异步编程中很重要，因为它们允许程序在特定点挂起执行并在稍后恢复，同时允许在此期间运行其他任务，所有这些都在同一个线程中运行。它们允许更好的资源利用，减少等待时间，并提高应用程序的可扩展性。
- en: In the next chapter, we will introduce Boost.Asio – a very powerful library
    for writing asynchronous code in C++.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Boost.Asio – 一个用于在C++中编写异步代码的非常强大的库。
- en: Further reading
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*C++ Coroutines for Beginners* , Andreas Fertig, Meeting C++ Online, 2024'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++协程入门* ，Andreas Fertig，Meeting C++在线，2024'
- en: '*Deciphering Coroutines* , Andreas Weiss, CppCon 2022'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解码协程* ，Andreas Weiss，CppCon 2022'
- en: 'Part 4: Advanced Asynchronous Programming with Boost Libraries'
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：使用Boost库的高级异步编程
- en: In this part, we will learn about advanced asynchronous programming techniques
    using powerful Boost libraries, enabling us to efficiently manage tasks that interact
    with external resources and system-level services. We will explore the **Boost.Asio**
    and **Boost.Cobalt** libraries, learning how they simplify the development of
    asynchronous applications while offering fine-grained control over complex processes
    such as task management and coroutine execution. Through hands-on examples, we
    will see how Boost.Asio handles asynchronous I/O operations in both single-threaded
    and multithreaded environments, and how Boost.Cobalt abstracts away the complexities
    of C++20 coroutines, allowing us to focus on functionality instead of low-level
    coroutine management.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将学习使用强大的Boost库进行高级异步编程技术，使我们能够高效地管理与外部资源和系统级服务交互的任务。我们将探索**Boost.Asio**和**Boost.Cobalt**库，了解它们如何简化异步应用程序的开发，同时提供对复杂过程（如任务管理和协程执行）的精细控制。通过实际示例，我们将看到Boost.Asio如何在单线程和多线程环境中处理异步I/O操作，以及Boost.Cobalt如何抽象出C++20协程的复杂性，使我们能够专注于功能而不是低级协程管理。
- en: 'This part has the following chapters:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 9*](B22219_09.xhtml#_idTextAnchor184) , *Asynchronous Programming
    Using Boost.Asio*'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B22219_09.xhtml#_idTextAnchor184) ，*使用Boost.Asio进行异步编程*'
- en: '[*Chapter 10*](B22219_10.xhtml#_idTextAnchor212) , *Coroutines with Boost.Cobalt*'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B22219_10.xhtml#_idTextAnchor212) ，*使用Boost.Cobalt的协程*'
