- en: Chapter 2. COM and C++ for Windows 8 Store Apps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '第2章。Windows 8商店应用的COM和C++ '
- en: C++ was first released to the public in 1985 by Bjarne Stroustrup, its creator
    and original implementer. It was first named "C with Classes", extending the C
    language to include true object-oriented features. It was published in 1998 in
    an "official" form and started to gain real traction. In 1998, the ISO standard
    for the language appeared, later to be revised slightly in 2003.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: C++最初由其创造者和最初的实施者Bjarne Stroustrup于1985年首次向公众发布。它最初被命名为“C with Classes”，扩展了C语言以包括真正的面向对象的特性。它在1998年以“官方”形式出版，并开始获得真正的发展。1998年，该语言的ISO标准出现，稍后在2003年进行了轻微修订。
- en: Years went by without a new standard until 2011, in which finally a new C++
    standard was finalized (this process was going on for several years) by the standards
    committee. Going from 1998 to 2011 with nothing official in between made C++ less
    popular than it used to be, mostly because of new languages and platforms that
    appeared, mainly Java (over the various Java platforms) and C# (over the .NET
    platform). Data-driven applications, which traditionally were written in C++,
    were (and still are) written in Java (in the non-Microsoft world) and C# (and,
    to a small extent, other .NET-based languages such as Visual Basic, in the Microsoft
    world). C++ remained a language with many followers, but the lack of advancement
    has shown cracks in the C++ ecosystem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直到2011年，没有新的标准，最终在2011年，标准委员会最终确定了新的C++标准（这个过程进行了几年）。从1998年到2011年之间没有官方标准，使得C++不像以前那样受欢迎，主要是因为出现了新的语言和平台，主要是Java（在各种Java平台上）和C#（在.NET平台上）。传统上用C++编写的数据驱动应用程序在非微软世界中是用Java（现在仍然是）和C#（在微软世界中，以及在一定程度上，其他基于.NET的语言，如Visual
    Basic）编写的。C++仍然是一种有很多追随者的语言，但缺乏进展显示了C++生态系统的裂痕。
- en: This 13-year gap was not without progress in C++, but it was in the library
    domain, rather than the language domain. The most notable contribution was the
    boost library ([http://www.boost.org](http://www.boost.org)) that contributed
    a lot of high-quality libraries that extended the standard C++ libraries; and
    although boost was not an official standard, it has become a de-facto standard
    among the C++ community. In fact, parts of boost have made it to the new C++11
    standard.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这13年的间隔并不是C++中没有进展，而是在库领域，而不是语言领域。最显著的贡献是boost库（[http://www.boost.org](http://www.boost.org)），它贡献了许多高质量的库，扩展了标准C++库；尽管boost不是官方标准，但它已成为C++社区中的事实标准。事实上，boost的部分内容已经成为新的C++11标准。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The C++ committee has decided to expedite matters for future standards and is
    planning a new standard in 2014 (and later in 2017); time will tell.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: C++委员会已决定加快未来标准的进程，并计划在2014年（以及2017年后）制定新的标准；时间会告诉我们。
- en: Welcome to C++11
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎使用C++11
- en: The C++11 standard was developed for several years, first called "C++0x", where
    "x" was hoped to be a single digit, making the standard final in 2009 at the latest,
    but things didn't turn out that way and the standard was finalized in September
    2011\.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准经过数年的开发，最初被称为“C++0x”，希望“x”是一个个位数，使得标准最迟在2009年完成，但事情并没有按照计划进行，标准最终在2011年9月才最终确定。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's possible to replace "x" with "b", the hexadecimal equivalent of 11 and
    still maintain a single digit if so desired.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用十六进制的11的十进制等价物“b”替换“x”，如果需要的话，仍然保持一个个位数。
- en: C++11 has many new features, some part of the core language and some part of
    the new standard libraries. 13 years is practically an eternity in computer years,
    and that's why there are so many additions to the language; in fact, at the time
    of writing, no compiler (Microsoft and non-Microsoft alike) exists that implements
    the entire C++11 standard. Visual Studio 2010 has implemented several features
    and Visual Studio 2012 implements some more features (and enhances existing features);
    it will probably take a while until all C++11 features are implemented by compilers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: C++11有许多新特性，部分是核心语言的一部分，部分是新的标准库的一部分。13年在计算机年代几乎是一个永恒，这就是为什么语言中有这么多的添加；事实上，在撰写本文时，没有一个编译器（包括微软和非微软）实现了整个C++11标准。Visual
    Studio 2010已经实现了一些功能，Visual Studio 2012实现了一些更多的功能（并增强了现有功能）；可能要过一段时间，直到所有C++11功能都被编译器实现。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a comprehensive list of supported C++11 features in VS 2012 and VS 2010,
    refer to this blog post by the Visual C++ team: [http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx](http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx).
    More features are expected to be available in relatively frequent updates.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有关VS 2012和VS 2010中支持的C++11功能的全面列表，请参阅Visual C++团队的博客文章：[http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx](http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx)。预计将在相对频繁的更新中提供更多功能。
- en: New features in C++11
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++11中的新特性
- en: We'll take a look at some of the new C++11 language and library features, that
    make it easier to develop using C++, not necessarily related to Windows 8 Store
    apps.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一些新的C++11语言和库特性，使得使用C++更容易开发，不一定与Windows 8商店应用相关。
- en: nullptr
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: nullptr
- en: '`nullptr` is a new keyword that replaces the famous value `NULL` as a pointer
    that points nowhere. It doesn''t seem to be a major feature, but this makes any
    `#define` for `NULL` unnecessary and also resolves some inconsistencies. Consider
    the following overloaded functions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`nullptr`是一个新的关键字，取代了著名的值`NULL`，作为一个指向无处的指针。这似乎不是一个主要的特性，但这使得任何`#define`为`NULL`的定义都是不必要的，也解决了一些不一致的地方。考虑以下重载函数：'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Which function would be invoked by calling `f1(NULL)`? The (maybe surprising)
    answer is `f1(int)`. The reason is that `NULL` is defined as a simple zero by
    the Microsoft compiler, which is interpreted as an integer by the compiler and
    not a pointer; this means the compiler's overload resolution selects `f1(int)`,
    rather than `f1(const char*)`. `nullptr` solves that; calling `f1(nullptr)` invokes
    the correct function (that accepts an actual pointer). From a purist standpoint,
    it's hard to imagine a language where pointers are of prime importance, not having
    a dedicated keyword to indicate a pointer to nothing. This was mainly for compatibility
    reasons with the C language; now it's finally resolved.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`f1(NULL)`会调用哪个函数？（也许令人惊讶的）答案是`f1(int)`。原因是Microsoft编译器将`NULL`定义为简单的零，编译器将其解释为整数而不是指针；这意味着编译器的重载解析选择了`f1(int)`，而不是`f1(const
    char*)`。`nullptr`解决了这个问题；调用`f1(nullptr)`会调用正确的函数（接受实际指针）。从纯粹主义的角度来看，很难想象一个指针至关重要的语言没有一个专门的关键字来指示指向空的指针。这主要是为了与C语言兼容的原因；现在它终于解决了。
- en: In C++/CX (which we'll discuss later in this chapter), `nullptr` is used to
    indicate a reference to nothing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++/CX（我们将在本章后面讨论），`nullptr`用于指示对空的引用。
- en: auto
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: auto
- en: 'The `auto` keyword existed since the C language, being a redundant keyword
    that meant "automatic variable", meaning a stack-based variable. The following
    C declaration is legal, but adds nothing of real value:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`关键字自C语言以来就存在，它是一个多余的关键字，意思是“自动变量”，意思是基于栈的变量。以下C声明是合法的，但没有真正的价值：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In C++11, `auto` is used to tell the compiler to automatically infer a variable''s
    type based on its initialization expression. Here are a few declarations:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，`auto`用于告诉编译器根据初始化表达式自动推断变量的类型。以下是一些声明：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This looks ordinary enough. Let''s replace this with the `auto` keyword:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很普通。让我们用`auto`关键字替换它：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running these pieces of code produces the same result (displaying `10` and `20`
    when iterating through the `vector`).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些代码片段会产生相同的结果（在迭代`vector`时显示`10`和`20`）。
- en: Initializing `x` to `5` using `auto` isn't much better than specifying the actual
    type (`int`); in fact, it's less clear (by the way, `5` is an `int`, whereas `5.0`
    is `double`, and so on). The real power of `auto` is with complex types, such
    as the preceding iterator example. The compiler infers the correct type based
    on the initialization expression. There is no runtime benefit here, it's just
    compile time inference. But, it makes the code (usually) more readable and less
    error prone. The variable type is not some kind of void pointer, it's exactly
    as if the type was specified explicitly. If `x` is an `int`, it will continue
    to be an `int` forever. The programmer does not have to think too hard about the
    correct type, we know it's an iterator (in the preceding example), why should
    we care about the exact type? Even if we do care, why should we write the complete
    type (which may contain template arguments which further enlarge the type expression),
    as the compiler knows the exact type already? `auto` can simplify things, as we'll
    see later on, when dealing with nontrivial WinRT types.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将`x`初始化为`5`使用`auto`并不比指定实际类型(`int`)好多少；事实上，它更不清晰（顺便说一句，`5`是`int`，而`5.0`是`double`，依此类推）。`auto`的真正威力在于复杂类型，比如前面的迭代器示例。编译器根据初始化表达式推断出正确的类型。这里没有运行时的好处，只是编译时的推断。但是，它使代码（通常）更易读，更不容易出错。变量类型不是某种空指针，它就像类型被明确指定一样。如果`x`是`int`，它将永远是`int`。程序员不必过多考虑正确的类型，我们知道它是一个迭代器（在前面的示例中），为什么我们要关心确切的类型呢？即使我们关心，为什么我们要写完整的类型（可能包含进一步扩大类型表达式的模板参数），因为编译器已经知道确切的类型了？`auto`可以简化事情，正如我们稍后将看到的，当处理非平凡的WinRT类型时。
- en: What about the string initialization? In the non-`auto` case, we used `std::string`
    explicitly. What about the `auto` case? It turns out the type of `name` is `const
    char*` and not `std::string`. The point here is that sometimes we need to be careful,
    we may have to specify the exact type to prevent unwanted compiler inference.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那么字符串初始化呢？在非`auto`情况下，我们明确使用了`std::string`。那么`auto`情况呢？结果是`name`的类型是`const char*`而不是`std::string`。这里的重点是有时我们需要小心，我们可能需要指定确切的类型以防止不必要的编译器推断。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Naturally, specifying something like `auto x;` does not compile, as `x` can
    be of any type—there must be an initialization expression. Similarly, specifying
    something like `auto x = nullptr;` fails to compile as well; again, because `x`
    can be any pointer type (and even non-pointer type with appropriate converting
    constructor).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，像`auto x;`这样指定的东西是无法编译的，因为`x`可以是任何类型——必须有一个初始化表达式。同样，指定像`auto x = nullptr;`这样的东西也无法编译；同样，因为`x`可以是任何指针类型（甚至是具有适当转换构造函数的非指针类型）。
- en: Lambdas
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Lambda
- en: 'Lambda functions, or simply lambdas, are a way to create anonymous functions,
    specified inline where needed. Let''s look at an example. Suppose we want to use
    the `transform` algorithm to take some items in a container and generate new items
    based on some transformation function. Here''s one prototype of `transform`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数，或简称lambda，是一种在需要的地方内联指定的匿名函数的方法。让我们看一个例子。假设我们想使用`transform`算法从容器中取一些项目，并根据一些转换函数生成新项目。这是`transform`的一个原型：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `transform` template function accepts, as its last argument, a transformation
    function to be invoked on each and every item specified with the start and end
    iterators.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`transform`模板函数接受作为最后一个参数的转换函数，该函数将在指定的起始和结束迭代器上调用每个项目。'
- en: 'One way to specify that function is by setting up a global (or a class static)
    function, as shown in the following code snippet:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 指定该函数的一种方法是设置一个全局（或类静态）函数，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`f1` is passed as the last argument to transform, making `v2` contain the square
    roots of the corresponding numbers in `v`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`f1`作为最后一个参数传递给`transform`，使`v2`包含`v`中相应数字的平方根。'
- en: 'This is the "C way" of providing functions—through function pointers. One of
    its drawbacks is that a function cannot maintain state. In C++, we can use a function
    object, known as "functor"—an object masquerading as a function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是提供函数的“C方式”—通过函数指针。它的一个缺点是函数无法维护状态。在C++中，我们可以使用函数对象，称为“函数对象”—一个伪装成函数的对象：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And the code to use it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以及使用它的代码：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: No state is maintained in this simple case, but it works because of the overloading
    of the function call operator; `transform` doesn't care, as long as it's something
    it can invoke.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种简单情况下没有维护状态，但它能工作是因为函数调用运算符的重载；`transform`不在乎，只要它是可以调用的东西。
- en: 'This still isn''t ideal—in both cases we lose code locality—as the invoked
    function is somewhere else. Lambdas solve this by embedding the code exactly where
    it''s needed:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不是理想的情况——在这两种情况下，我们都失去了代码局部性——因为调用的函数在其他地方。lambda通过将代码嵌入到需要的地方来解决这个问题：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Lambda function syntax may seem strange at first. The syntax has the following
    ingredients:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数的语法一开始可能看起来很奇怪。语法包括以下几个要素：
- en: A variable capture list in square brackets (empty in the example)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方括号中的变量捕获列表（在示例中为空）
- en: The arguments to the function (as expected by its usage), in the previous example
    is an `int` as that's what `transform` expects, given input iterators that point
    to a collection of `int` types
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的参数（根据其使用预期），在前面的例子中是一个`int`，因为`transform`期望的是这样的输入迭代器，指向一个`int`类型的集合
- en: The actual function body
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际的函数体
- en: 'An optional (and sometimes not so much) return type specifier using some new
    C++11 syntax:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一些新的C++11语法，可选（有时不太）返回类型说明符：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `std::begin` and `std::end` functions are new to C++11, providing a somewhat
    more convenient equivalent to the `begin` and `end` member functions of containers.
    These also work with WinRT collections, as we'll see later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::begin`和`std::end`函数是C++11中的新功能，提供了与容器的`begin`和`end`成员函数相对应的更方便的等价物。这些也适用于WinRT集合，正如我们将在后面看到的那样。'
- en: 'There are two things to gain when using lambdas:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lambda有两个好处：
- en: Code locality is maintained.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码局部性得到保持。
- en: Possibility to use outer scope variables by "capturing" them inside the lambda.
    If it were a separate function, it would be difficult to "transfer" the values
    for the outer scope variables.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在lambda内部“捕获”外部作用域变量，可以使用外部作用域变量。如果它是一个单独的函数，将很难为外部作用域变量“传递”值。
- en: 'Capturing variables can be done by value or by reference. Here are a few examples:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过值或引用来捕获变量。以下是一些例子：
- en: '`[=]` captures all outer scoped variables by value'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[=]`通过值捕获所有外部作用域的变量'
- en: '`[x, y]` captures `x` and `y` by value'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[x, y]`通过值捕获`x`和`y`'
- en: '`[&]` captures all outer scope variables by reference'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[&]`通过引用捕获所有外部作用域变量'
- en: '`[x, &y]` captures `x` by value, `y` by reference'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[x, &y]`通过值捕获`x`，通过引用捕获`y`'
- en: Without capturing, the lambda function body can only use the arguments provided
    and its own declared variables
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有捕获，lambda函数体只能使用提供的参数和自己声明的变量
- en: We'll use lambdas extensively, especially when dealing with asynchronous operations,
    as we'll see later in this chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将广泛使用lambda，特别是在处理异步操作时，正如我们将在本章后面看到的那样。
- en: Smart pointers
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 智能指针
- en: 'Smart pointers are not a language feature, but rather part of the new standard
    library. First introduced by boost, they provide automatic management of dynamically
    allocated objects. Consider this simple object allocation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针不是一种语言特性，而是新标准库的一部分。它们最初由boost引入，提供动态分配对象的自动管理。考虑这种简单的对象分配：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is a very typical dynamic allocation. The problem with that is, well,
    it must be de-allocated at some point. This may seem easy enough, given the following
    statements:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常典型的动态分配。问题在于，它必须在某个时刻被释放。这似乎很容易，给出以下语句：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Even this seemingly simple code is problematic; what if the call to `Car::Drive`
    throws an exception? In that case, the call to delete is skipped and we have ourselves
    a memory leak.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这个看似简单的代码也有问题；如果对`Car::Drive`的调用抛出异常怎么办？在这种情况下，删除的调用将被跳过，我们就会有一个内存泄漏。
- en: 'The solution? Wrapping the pointer by an automatically allocated object, for
    which the constructor and destructor do the right thing:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案？通过自动分配的对象包装指针，其中构造函数和析构函数做正确的事情：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is known as **Resource Acquisition Is Initialization** (**RAII**). The
    `operator->` ensures accessing the `Car` instance is transparent, making the smart
    pointer smart enough not to interfere with the normal operations of the car:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**资源获取即初始化**（**RAII**）。`operator->`确保访问`Car`实例是透明的，使智能指针足够智能，不会干扰汽车的正常操作：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The destructor takes care of destroying the object. If an exception is thrown,
    the destructor is called no matter what (except catastrophic power failures and
    the like), ensuring the `Car` instance is destroyed before a `catch` handler is
    searched.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数负责销毁对象。如果抛出异常，无论如何都会调用析构函数（除了灾难性的电源故障等），确保在搜索`catch`处理程序之前销毁`Car`实例。
- en: 'The `CarPtr` class is a very simple smart pointer, but it still may be useful
    at times. C++11 has a generic implementation of this idea in the form of the `std::unique_ptr<T>`
    class, where `T` is the type whose pointer is to be managed. In our case, we could
    have written the `Car` client code like so (we need to `#include <memory>` for
    this):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`CarPtr`类是一个非常简单的智能指针，但有时仍然可能有用。C++11以`std::unique_ptr<T>`类的形式提供了这个想法的通用实现，其中`T`是要管理其指针的类型。在我们的情况下，我们可以这样编写`Car`客户端代码（我们需要为此`#include
    <memory>`）：'
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The actual definition of `unique_ptr<>` is more complex than the simple `CarPtr`
    shown here. For example, what about the assignment operator with a different `Car`
    object pointer? What about assignment to `nullptr`? Why should the destructor
    call `delete`—maybe the object was allocated in some other way? These and other
    details are handled by `unique_ptr<>` correctly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr<>`的实际定义比这里显示的简单`CarPtr`更复杂。例如，对于具有不同`Car`对象指针的赋值运算符怎么办？对于赋值给`nullptr`怎么办？为什么析构函数要调用`delete`——也许对象是以其他方式分配的？这些和其他细节都由`unique_ptr<>`正确处理。'
- en: '`unique_ptr<>` is simple enough, but what about objects that need to be passed
    around? Destroying the object in the destructor of the `unique_ptr` would be premature.
    For that, we need reference counting, so that when an object is passed to some
    function (or more interestingly, another thread), a counter should increment.
    When the smart pointer''s destructor is called, it should decrement the counter,
    and only if it reaches zero, should it actually destroy the object. That''s exactly
    the role of another new smart pointer class, `shared_ptr<T>`. Here''s an example
    with a `Car` object:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_ptr<>`足够简单，但是对于需要传递的对象呢？在`unique_ptr`的析构函数中销毁对象会过早。为此，我们需要引用计数，这样当对象传递给某个函数（或者更有趣的是，另一个线程）时，计数器应该递增。当智能指针的析构函数被调用时，它应该递减计数器，只有当计数器达到零时，它才应该实际销毁对象。这正是另一个新的智能指针类`shared_ptr<T>`的作用。以下是一个`Car`对象的示例：'
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The nice thing about `shared_ptr<>` is that it works on any type, the type does
    not need to have any special properties. `shared_ptr<>` allocates an extra reference
    count that is associated with the provided object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr<>`的好处在于它适用于任何类型，类型不需要具有任何特殊属性。`shared_ptr<>`分配了一个与提供的对象相关联的额外引用计数。'
- en: 'The preferred way to initialize `shared_ptr<>` is by using the `std::make_shared<>`
    template function, that accepts parameters passed to the actual type''s constructor.
    It creates the object instance (for example `Car`) along with a reference counter,
    all in one block, hence the extra efficiency. In the `Car` example, this looks
    as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化`shared_ptr<>`的首选方法是使用`std::make_shared<>`模板函数，该函数接受传递给实际类型构造函数的参数。它在一个块中创建对象实例（例如`Car`）以及引用计数，因此额外高效。在`Car`示例中，如下所示：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's important not to mix smart pointers (like `shared_ptr<>`) with ordinary
    pointers, else the object may be destroyed while regular pointers to it are still
    used by other code fragments.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要混合智能指针（如`shared_ptr<>`）和普通指针，否则对象可能在其他代码片段仍在使用它的常规指针时被销毁。
- en: 'One of the caveats of reference counting is the problem of cyclic references.
    For example, if some code creates object A, that creates an object B in its constructor
    and passes itself to B, where B holds a smart pointer back to A, and at some point
    the client lets go of its A smart pointer, the cycle will leave A and B alive
    forever:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数的一个警告是循环引用的问题。例如，如果某些代码创建对象A，该对象在其构造函数中创建对象B并将自身传递给B，B持有对A的智能指针，然后在某个时刻客户端释放了其A智能指针，这个循环将使A和B永远存在：
- en: '![Smart pointers](img/5022_02_01.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![智能指针](img/5022_02_01.jpg)'
- en: The original client doesn't even know that a memory leak has occurred. This
    is something to be aware of, and as we'll see later, the same problem exists with
    WinRT objects, which are reference counted as well.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 原始客户甚至不知道发生了内存泄漏。这是需要注意的问题，正如我们将在后面看到的，WinRT对象也存在相同的问题，它们也是引用计数的。
- en: 'One way to avoid the issue is to use another smart pointer class from C++11,
    `std::weak_ptr<>`. As the name suggests, it holds a weak reference to the object,
    meaning it won''t prevent the object from self-destruction. This would be the
    way B would hold a reference to A in the previous diagram. If that''s the case,
    how can we access the actual object in case we need it? Or, more precisely, how
    do we know it actually still exists? Here''s the way to do it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这个问题的一种方法是使用C++11中的另一个智能指针类`std::weak_ptr<>`。顾名思义，它持有对象的弱引用，这意味着它不会阻止对象自毁。这将是B在前面图表中持有对A的引用的方式。如果是这样，我们如何访问实际对象以便在需要时使用？或者更确切地说，我们如何知道它实际上仍然存在？这是做法：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `weak_ptr<>::lock` function returns a `shared_ptr<>` to the object in question.
    If there is no object, the internal pointer would be null. If there is an object,
    then its ref count is incremented, protecting it from premature destruction even
    if the original `shared_ptr<>` is released. Adding the following line after the
    initialization of `spCar4` would show **Car gone** on the display:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`weak_ptr<>::lock`函数返回对问题对象的`shared_ptr<>`。如果没有对象，内部指针将为null。如果有对象，则其引用计数会增加，即使原始的`shared_ptr<>`被释放，也会保护它免受过早销毁。在初始化`spCar4`之后添加以下行将在显示器上显示**Car
    gone**：'
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is another way to break the cycle. A can implement a specific method (for
    example `Dispose`), that must be called explicitly by the client. In that method,
    A will release its pointer to B, thus breaking the cycle. The problem here is
    somewhat similar to manually using `new`/`delete`—the function needs to be called
    at the correct time. If called too early it will make the object unusable; `weak_ptr<>`
    is usually preferred.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种打破循环的方法。A可以实现一个特定的方法（例如`Dispose`），客户端必须显式调用该方法。在该方法中，A将释放其对B的指针，从而打破循环。这里的问题与手动使用`new`/`delete`有些类似——函数需要在正确的时间调用。如果调用得太早，它将使对象无法使用；通常更喜欢使用`weak_ptr<>`。
- en: In today's C++, the recommended approach is to always use smart pointers and
    never use raw pointers. Using the `new` and `delete` operators is considered a
    maintenance headache, that could lead to memory leaks or corruptions because of
    premature object destruction. Smart pointers are cheap to pass around and guarantee
    correct behavior even in the face of exceptions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的C++中，推荐的方法是始终使用智能指针，而不是使用原始指针。使用`new`和`delete`运算符被认为是维护的头痛，可能会导致内存泄漏或因为过早对象销毁而导致损坏。智能指针在传递时很便宜，并且即使在出现异常时也能保证正确的行为。
- en: Conclusion
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: C++11 has a lot of new features, both in the language and in the standard libraries.
    We've seen some of the useful ones, but there are certainly others, such as `rvalue`
    references that provide a way to avoid costly copying operations (and, in fact,
    are used in the container classes such as `std::vector<>`), a new `enum class`
    declaration that solves the outer scope problem of classic enums, and many others.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: C++11有许多新特性，无论是在语言中还是在标准库中。我们已经看到了一些有用的特性，但肯定还有其他的，比如`rvalue`引用，它提供了一种避免昂贵的复制操作的方式（实际上，在容器类中使用，比如`std::vector<>`），还有一个新的`enum
    class`声明，解决了经典枚举的外部范围问题，以及其他许多特性。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a complete treatment of the new C++11 features, use web resources such as
    Microsoft's Channel 9 ([http://channel9.msdn.com](http://channel9.msdn.com)),
    the Visual C++ team's blog ([http://blogs.msdn.com/b/vcblog/](http://blogs.msdn.com/b/vcblog/)),
    and Wikipedia ([http://en.wikipedia.org/wiki/C%2B%2B11](http://en.wikipedia.org/wiki/C%2B%2B11)).
    Also, the almost-final draft of the C++11 standard can be found at [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要全面了解新的C++11特性，请使用诸如微软的Channel 9（[http://channel9.msdn.com](http://channel9.msdn.com)）、Visual
    C++团队的博客（[http://blogs.msdn.com/b/vcblog/](http://blogs.msdn.com/b/vcblog/)）和维基百科（[http://en.wikipedia.org/wiki/C%2B%2B11](http://en.wikipedia.org/wiki/C%2B%2B11)）等网络资源。此外，几乎最终的C++11标准草案可以在[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf)找到。
- en: COM and WinRT
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: COM和WinRT
- en: The COM technology was created by Microsoft at around 1993\. It was first named
    OLE 2.0, because it was used to implement the **Object Linking and Embedding**
    (**OLE**) feature in the Microsoft Office suite. This feature allowed, for example,
    embedding (or linking) an Excel table inside a Word document. The first version
    of OLE (known as OLE 1.0) was implemented by something called **Dynamic Data Exchange**
    (**DDE**), which is a long time Windows feature that is based on messaging. Microsoft
    realized that OLE is just one possible use of a more general technology, and so
    renamed OLE 2.0 to COM.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: COM技术是由微软在1993年左右创建的。它最初被命名为OLE 2.0，因为它被用来实现Microsoft Office套件中的**对象链接和嵌入**（**OLE**）功能。例如，这个功能允许在Word文档中嵌入（或链接）一个Excel表格。OLE的第一个版本（称为OLE
    1.0）是由称为**动态数据交换**（**DDE**）的东西实现的，它是基于消息的长期Windows功能。微软意识到OLE只是更一般技术的一种可能用途，因此将OLE
    2.0重命名为COM。
- en: 'COM contains many details, but is based on very few principles:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: COM包含许多细节，但基于很少的原则：
- en: Client programs against interfaces, never against concrete objects
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端程序针对接口，而不是具体对象
- en: Components are loaded dynamically rather than statically
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件是动态加载的，而不是静态加载的
- en: What is an interface? In object-oriented parlance, an interface is an abstraction
    that groups a set of related operations. This abstraction has no implementation,
    but various types may implement the interface in some appropriate way. A client
    can use different implementations because it relies on the interface (being a
    contract) alone and not on any particular implementation that may be provided
    indirectly, for example, by some factory component.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是接口？在面向对象的术语中，接口是一种抽象，它将一组相关的操作分组在一起。这种抽象没有实现，但各种类型可以以适当的方式实现接口。客户端可以使用不同的实现，因为它仅依赖于接口（作为合同），而不依赖于可能间接提供的任何特定实现，例如某个工厂组件。
- en: A COM interface is something more precise. It specifies a particular binary
    layout that is provided by the implementer of the interface and consumed by the
    client. Since the layout is known in advance, the contract presented is not just
    logical, but also a binary one. This leads to the possibility of mixing languages
    or technologies when using COM. A COM class can be authored in (say) C++, but
    consumed by Visual Basic or C#, assuming those languages (in this case the .NET
    platform) know the binary layout of the interfaces in question.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: COM接口是更加精确的东西。它指定了由接口的实现者提供并由客户端使用的特定二进制布局。由于布局是预先知道的，所以提出的合同不仅仅是逻辑的，还是二进制的。这导致在使用COM时可以混合语言或技术的可能性。COM类可以由（比如）C++编写，但可以被Visual
    Basic或C#（在这种情况下是.NET平台）消耗，假设这些语言知道所讨论的接口的二进制布局。
- en: 'The layout of a COM interface is a virtual table (also known as V-table), which
    is the most common mechanism of implementing virtual functions in C++, making
    C++ a natural choice for developing COM components and COM clients. Here''s a
    definition of a simple interface in C++, as a pure abstract class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: COM接口的布局是虚拟表（也称为V表），这是在C++中实现虚拟函数的最常见机制，使C++成为开发COM组件和COM客户端的自然选择。以下是C++中一个简单接口的定义，作为纯抽象类：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By convention, interface names in COM start with a capital "I" and then a name
    in Pascal casing (for example `IAnimal`, `ILibrary`, `IObjectBuilder`).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，COM中的接口名称以大写的“I”开头，然后是帕斯卡命名法的名称（例如`IAnimal`，`ILibrary`，`IObjectBuilder`）。
- en: 'Here''s a simple (inline) implementation of this interface:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个接口的一个简单（内联）实现：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can use any `ICar` interface pointer without knowing anything about the
    actual implementation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何`ICar`接口指针，而不知道实际实现的任何信息：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Looking at an instance of the `Porche` class in memory, using the Visual Studio
    debugger, this is what we find:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Visual Studio调试器查看`Porche`类的实例在内存中，我们发现：
- en: '![COM and WinRT](img/5022_02_02.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![COM和WinRT](img/5022_02_02.jpg)'
- en: The first field in the instance is a pointer to a v-table (`vptr`). That v-table
    holds pointers to the actual implemented functions on that particular `ICar` implementation,
    `Porche`. Following the v-table pointer, we see the member variables declared
    by the implementation. But using an interface pointer, there's no way of knowing
    what member variables exist (if any); it's an implementation detail that should
    not concern clients.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 实例中的第一个字段是指向v表（`vptr`）的指针。该v表保存了在特定`ICar`实现`Porche`上实际实现的函数的指针。在v表指针之后，我们看到了实现声明的成员变量。但是使用接口指针，无法知道存在哪些成员变量（如果有的话）；这是一个不应该关心客户端的实现细节。
- en: 'Let''s define another interface:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义另一个接口：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Porche` class wants to implement `ICarrier` as well as `ICar`. Here''s
    the revised definition:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Porche`类希望实现`ICarrier`以及`ICar`。这是修订后的定义：'
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ll add some fields to manage objects mounted on the car:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一些字段来管理安装在汽车上的对象：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And implement the two methods (functions) from `ICarrier`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 并实现`ICarrier`中的两个方法（函数）：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The exact implementation is not important in itself at this time, just the
    layout of the object in memory:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此时确切的实现本身并不重要，只是内存中对象的布局：
- en: '![COM and WinRT](img/5022_02_03.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![COM and WinRT](img/5022_02_03.jpg)'
- en: 'The first two members of the `Porche` instance are the v-table pointers to
    `ICar` and `ICarrier` (in that order), each of which points to a virtual table
    of function pointers. Only then the instance member variables are placed. Here''s
    a diagram to show this perhaps more clearly:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Porche`实例的前两个成员是指向`ICar`和`ICarrier`的v-table指针（按顺序），每个指向一个函数指针的虚拟表。然后才放置实例成员变量。这里有一个图表可能更清晰地显示这一点：'
- en: '![COM and WinRT](img/5022_02_04.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![COM and WinRT](img/5022_02_04.jpg)'
- en: Now, suppose a client holds an `ICar*` interface and wants to see if `ICarrier`
    is implemented by the object. Doing a C-style case (or `reinterpret_cast<>`) is
    going to simply make the same pointer value think it's pointing to another v-table,
    but it's not. In this case invoking `ICarrier::PlaceObject` would actually invoke
    `ICar::Start` because that's the first function in that v-table; and functions
    are invoked by offset.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设客户端持有一个`ICar*`接口，并希望查看对象是否实现了`ICarrier`。进行C风格的转换（或`reinterpret_cast<>`）只会简单地使相同的指针值认为它指向另一个v-table，但实际上并不是。在这种情况下，调用`ICarrier::PlaceObject`实际上会调用`ICar::Start`，因为那是该v-table中的第一个函数；并且函数是通过偏移量调用的。
- en: 'What we need is to query dynamically whether another interface is supported
    using the `dynamic_cast<>` operator:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要动态查询另一个接口是否支持，使用`dynamic_cast<>`运算符：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If successful, `dynamic_cast` adjusts the pointer to the correct v-table. In
    the `Porche` case, the value of `pCarrier` should be greater than `pCar` by pointer
    size (4 bytes in a 32-bit process, 8 bytes in a 64-bit process). We can verify
    that by printing their values:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，`dynamic_cast`会调整指针到正确的v-table。在`Porche`的情况下，`pCarrier`的值应该比`pCar`大一个指针大小（在32位进程中为4个字节，在64位进程中为8个字节）。我们可以通过打印它们的值来验证：
- en: '![COM and WinRT](img/5022_02_05.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![COM and WinRT](img/5022_02_05.jpg)'
- en: The offset is 4, since this code was compiled as 32 bit.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量为4，因为这段代码是以32位编译的。
- en: The problem with `dynamic_cast<>` is that it's C++ specific. What would other
    languages do to get another interface on an object? The solution is to factor
    that functionality into every interface. Coupled with reference counting, this
    leads to the most fundamental interface in the world of COM, `IUnknown`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamic_cast<>`的问题在于它是特定于C++的。其他语言会如何获取对象上的另一个接口？解决方案是将该功能因子化到每个接口中。结合引用计数，这导致了COM世界中最基本的接口，`IUnknown`。'
- en: The IUnknown interface
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IUnknown接口
- en: 'The `IUnknown` interface is the base interface of every COM interface. It encapsulates
    two pieces of functionality: querying for other interfaces that may be supported
    and managing the object''s reference count. Here''s its definition:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`IUnknown`接口是每个COM接口的基本接口。它封装了两个功能：查询可能支持的其他接口和管理对象的引用计数。这是它的定义：'
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`QueryInterface` allows getting another supported interface, based on the interface
    ID, which is a **Global Unique Identifier** (**GUID**)—a 128-bit number that''s
    generated by an algorithm that statistically guarantees uniqueness. The returned
    value, an `HRESULT` is the standard return type in COM (and WinRT). For `QueryInterface`,
    `S_OK (0)` means all is well and the requested interface exists (and is returned
    indirectly via the `ppvObject` argument) or `E_NOINTERFACE`, meaning no such interface
    is supported.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryInterface`允许根据接口ID获取另一个支持的接口，这是一个**全局唯一标识符**（**GUID**）—一个由算法生成的128位数字，可以统计保证唯一性。返回的值，一个`HRESULT`是COM（和WinRT）中的标准返回类型。对于`QueryInterface`，`S_OK
    (0)`表示一切正常，请求的接口存在（并间接通过`ppvObject`参数返回），或者`E_NOINTERFACE`，表示不支持这样的接口。'
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All COM/WinRT interface methods are using the standard calling convention (`__stdcall`),
    which says the callee is responsible for cleaning the parameters on the call stack
    (rather than the caller). This matters in the 32-bit world, which has several
    calling conventions. Since COM is intended for cross technology access, this is
    part of the contract (in x64 only one calling convention exists, so this is not
    that important).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所有COM/WinRT接口方法都使用标准调用约定（`__stdcall`），这意味着被调用方负责清理调用堆栈上的参数（而不是调用方）。这在32位世界中很重要，因为有几种调用约定。由于COM旨在实现跨技术访问，这是合同的一部分（在x64中只存在一种调用约定，因此这并不那么重要）。
- en: '`AddRef` increments the internal reference count of the object and `Release`
    decrements it, destroying the object if the count reaches zero.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddRef`增加对象的内部引用计数，`Release`减少它，如果计数达到零则销毁对象。'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that this is just an interface, and other implementations are possible.
    For example, `AddRef` and `Release` may do nothing for an object that always wants
    to remain in memory, such as a singleton. Most objects, however, are implemented
    as described.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这只是一个接口，还有其他的实现可能。例如，对于一个始终希望保留在内存中的对象（如单例），`AddRef`和`Release`可能什么也不做。然而，大多数对象都是按照描述的方式实现的。
- en: Any COM interface must derive from `IUnknown`; this means that every v-table
    has at least three entries corresponding to `QueryInterface`, `AddRef`, and `Release`
    (in that order).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 任何COM接口都必须派生自`IUnknown`；这意味着每个v-table至少有三个条目对应于`QueryInterface`、`AddRef`和`Release`（按顺序）。
- en: IInspectable interface
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IInspectable接口
- en: 'WinRT can be viewed as a better COM. One of the shortcomings of the `IUnknown`
    interface is that there is no standard way to ask the object to give back a list
    of interfaces it supports. WinRT defines a new standard interface, `IInspectable`
    (that of course derives from `IUnknown`) that provides this capability:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT可以被视为更好的COM。`IUnknown`接口的一个缺点是没有标准的方法来询问对象返回它支持的接口列表。WinRT定义了一个新的标准接口`IInspectable`（当然是从`IUnknown`派生的），提供了这种能力：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The most interesting method is `GetIids` , returning all interfaces supported
    by the object. This is used by the JavaScript engine running on top of WinRT because
    of the lack of static typing in JavaScript, but it's not generally useful for
    C++ clients.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的方法是`GetIids`，返回对象支持的所有接口。这是由运行在WinRT之上的JavaScript引擎使用的，因为JavaScript中缺乏静态类型，但对于C++客户端来说通常不太有用。
- en: 'The net result of all this is the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切的最终结果如下：
- en: Every WinRT interface must inherit from `IInspectable`. This means every v-table
    always has at least six entries corresponding to the methods `QueryInterface`,
    `AddRef`, `Release`, `GetIids`, `GetRuntimeClassName`, and `GetTrustLevel` (in
    that order).
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个WinRT接口必须继承自`IInspectable`。这意味着每个v表总是至少有六个条目，对应于方法`QueryInterface`、`AddRef`、`Release`、`GetIids`、`GetRuntimeClassName`和`GetTrustLevel`（按照这个顺序）。
- en: A WinRT type implements at least `IInspectable`, but will almost always implement
    at least another interface; otherwise, this object would be very dull.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinRT类型至少实现了`IInspectable`，但几乎总是至少实现了另一个接口；否则，这个对象将会非常乏味。
- en: 'The following classic diagram depicts a WinRT object:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的经典图表描述了一个WinRT对象：
- en: '![IInspectable interface](img/5022_02_06.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![IInspectable接口](img/5022_02_06.jpg)'
- en: Creating a WinRT object
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建WinRT对象
- en: As we've seen, COM/WinRT clients use interfaces to call operations on objects.
    However, one thing was eluded thus far, how did that object come to be? The process
    of creation must be generic enough (and not C++ specific), so that other technologies/languages
    would be able to utilize it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，COM/WinRT客户端使用接口来调用对象上的操作。然而，到目前为止有一件事被忽略了，那个对象是如何产生的？创建过程必须足够通用（而不是特定于C++），以便其他技术/语言能够利用它。
- en: We'll build a simple example that creates an instance of the WinRT `Calendar`
    class residing in the `Windows::Globalization` namespace, and call some of its
    methods. To remove all possible noise, we'll do that in a simple Win32 console
    application (not a Windows 8 Store app), so that we can focus on the details.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个简单的示例，创建一个位于`Windows::Globalization`命名空间中的WinRT `Calendar`类的实例，并调用一些其方法。为了消除所有可能的噪音，我们将在一个简单的Win32控制台应用程序中进行操作（而不是Windows
    8商店应用程序），这样我们就可以专注于细节。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The last sentence also means that WinRT types (most of them, anyway) are accessible
    and usable from a desktop app, as well as a Store app. This opens up interesting
    possibilities.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一句也意味着WinRT类型（大部分情况下）可以从桌面应用程序和商店应用程序中访问和使用。这开启了有趣的可能性。
- en: 'We need to use some new APIs that are part of the Windows Runtime infrastructure.
    These APIs start with the letters "Ro" (short for Runtime Object). To that end,
    we''ll need a specific `#include` and to link with the appropriate library:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用一些属于Windows Runtime基础设施的新API。这些API以"Ro"开头（代表Runtime Object）。为此，我们需要一个特定的`#include`和链接到适当的库：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can start implementing our main function. The first thing to do is
    to initialize WinRT on the current thread. This is accomplished using the `RoInitialize`
    function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始实现我们的主函数。首先要做的事情是在当前线程上初始化WinRT。这是通过使用`RoInitialize`函数来实现的：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`RoInitialize` requires specifying the apartment model for the thread. This
    can be a **Single Threaded Apartment** (**STA**) denoted by `RO_INIT_SINGLETHREADED`
    or the **Multithreaded Apartment** (**MTA**) denoted by `RO_INIT_MULTITHREADED`.
    The concept of apartments will be discussed a bit later, and is unimportant for
    the current discussion.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoInitialize`需要为线程指定公寓模型。这可以是**单线程公寓**（**STA**）表示为`RO_INIT_SINGLETHREADED`，也可以是**多线程公寓**（**MTA**）表示为`RO_INIT_MULTITHREADED`。公寓的概念将在稍后讨论，对于当前的讨论来说并不重要。'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`RoInitialize` is similar in concept to the classic COM `CoInitialize` (`Ex`)
    functions. WinRT apartments are pretty much the same as the classic COM apartments.
    In fact, since WinRT is built upon COM foundations, most things work very similarly.
    The object creation mechanism is very similar, with some changes to the details
    as we''ll soon see.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoInitialize`在概念上类似于经典的COM `CoInitialize`(`Ex`)函数。WinRT公寓与经典的COM公寓几乎是一样的。事实上，由于WinRT是建立在COM基础之上的，大部分事情都工作得非常相似。对象创建机制非常相似，只是细节上有一些变化，我们很快就会看到。'
- en: 'To create an actual object and get back an interface pointer, a call must be
    made to the `RoActivateInstance` API function. This function is prototyped as
    follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个实际的对象并获得一个接口指针，必须调用`RoActivateInstance`API函数。这个函数的原型如下：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first argument that's needed is the full name of the class, represented
    as an `HSTRING`. `HSTRING` is the standard WinRT string type, and represents an
    immutable array of Unicode (UTF-16) characters. Several WinRT APIs exist for creating
    and manipulating `HSTRING`. As we'll see a bit later, C++/CX provides the `Platform::String`
    class to wrap an `HSTRING` for ease of use.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的第一个参数是类的全名，表示为`HSTRING`。`HSTRING`是标准的WinRT字符串类型，表示一个不可变的Unicode（UTF-16）字符数组。存在多个WinRT
    API用于创建和操作`HSTRING`。正如我们稍后将看到的，C++/CX提供了`Platform::String`类来包装`HSTRING`以便于使用。
- en: The second argument to `RoActivateInstance` is the resulting instance represented
    through an `IInspectable` interface pointer (recall that all WinRT objects must
    support this interface).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoActivateInstance`的第二个参数是通过`IInspectable`接口指针表示的结果实例（请记住，所有WinRT对象必须支持这个接口）。'
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Interested readers may be wondering why create a new string type. Surely, there
    are already plenty of those in the Microsoft space: `std::string`/`wstring` (C++),
    `CString` (ATL/MFC), and `BSTR` (COM). `BSTR` seems the most likely candidate
    as it''s not C++ specific. The new `HSTRING` is immutable, meaning it cannot change
    once created. Any apparent modification creates a new `HSTRING`. This attribute
    makes the `HSTRING` thread safe and more easily projectable to other platforms,
    such as .NET, where the `System.String` class is immutable as well, so there is
    no mismatch.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 感兴趣的读者可能会想知道为什么要创建一个新的字符串类型。毫无疑问，在Microsoft空间中已经有了很多这样的类型：`std::string`/`wstring`（C++），`CString`（ATL/MFC）和`BSTR`（COM）。`BSTR`似乎是最有可能的候选者，因为它不是特定于C++的。新的`HSTRING`是不可变的，这意味着一旦创建就无法更改。任何明显的修改都会创建一个新的`HSTRING`。这个属性使`HSTRING`线程安全，并且更容易投射到其他平台，比如.NET，其中`System.String`类也是不可变的，所以没有不匹配。
- en: 'To use the `HSTRING`-related APIs, we''ll add `#include` to `<winstring.h>`.
    Now we can go ahead and create an `HSTRING` for the `Calendar` class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用与`HSTRING`相关的API，我们将添加`#include`到`<winstring.h>`。现在我们可以继续为`Calendar`类创建一个`HSTRING`：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`HSTRING` is created with the `WindowsCreateString` WinRT API, passing the
    string literal and its length (here acquired with the help of `std::wstring`).
    Note, that the class name includes its full namespace where a dot (`.`) is the
    separator (and not the C++ scope resolution operator `::`).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`HSTRING`是使用`WindowsCreateString` WinRT API创建的，传递字符串文字和它的长度（这里是通过`std::wstring`的帮助获得的）。请注意，类名包括其完整的命名空间，其中点（`.`）是分隔符（而不是C++的作用域解析运算符`::`）。'
- en: Now, we can call `RoActivateInstance` (I've omitted any error checking in these
    code fragments so we can concentrate on the essentials) and get back an interface
    for the Calendar. Since this is `IInspectable`, it's not very interesting. We
    need a more specific interface for the Calendar, that is, we need to call `QueryInterface`
    to get a more interesting interface to work with.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以调用`RoActivateInstance`（我在这些代码片段中省略了任何错误检查，以便我们可以集中精力在基本要点上），并获得一个日历的接口。由于这是`IInspectable`，所以并不是很有趣。我们需要一个更具体的日历接口，也就是说，我们需要调用`QueryInterface`来获得一个更有趣的接口来使用。
- en: What does `RoActivateInstance` do? How is that instance actually created? Where
    is it implemented?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`RoActivateInstance`是做什么的？该实例是如何创建的？它是在哪里实现的？'
- en: 'The procedure is very similar to the classic COM creation mechanism. `RoActivateInstance`
    consults the Registry at `HKEY_LOCAL_MACHINE\Software\Microsoft\WindowsRuntime\ActiavatableClassId`
    and looks for a key with the name **Windows.Globalization.Calendar**. Here''s
    a screenshot from **RegEdit.exe**:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程与经典的COM创建机制非常相似。`RoActivateInstance`在`HKEY_LOCAL_MACHINE\Software\Microsoft\WindowsRuntime\ActiavatableClassId`处查阅注册表，并查找名为**Windows.Globalization.Calendar**的键。这是来自**RegEdit.exe**的屏幕截图：
- en: '![Creating a WinRT object](img/5022_02_07.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Creating a WinRT object](img/5022_02_07.jpg)'
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The screenshot shows the 64-bit key. For 32-bit processes, the key is under
    `HKLM\Software\Wow6432Node\Windows\WindowsRuntime\ActivatableClassId`. This is
    transparent to the process, as the Registry APIs, by default, go to the correct
    location based on the process "bitness".
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕截图显示了64位键。对于32位进程，该键位于`HKLM\Software\Wow6432Node\Windows\WindowsRuntime\ActivatableClassId`下。这对于进程来说是透明的，因为注册表API默认根据进程的“位数”去正确的位置。
- en: 'Several values exist in the class **Name** key. The most interesting are:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 类**Name**键中存在几个值。最有趣的是：
- en: '**DllPath** – indicates where the implementing DLL resides. This DLL is loaded
    into the calling process address space, as we''ll see in a moment.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DllPath** - 指示实现DLL所在的位置。这个DLL被加载到调用进程的地址空间中，我们马上就会看到。'
- en: '**CLSID** – the corresponding GUID of the class name. It''s not as important
    as in classic COM, because WinRT implementations are identified by the full class
    name and not the CLSID, as is evident by the first argument to `RoActivateInstance`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CLSID** - 类名的相应GUID。这并不像在经典的COM中那么重要，因为WinRT实现是通过完整的类名而不是CLSID来识别的，这一点可以从`RoActivateInstance`的第一个参数中看出。'
- en: '**ActivationType** – indicates whether this class is activated in-process (DLL,
    value of 0) or out-of-process (EXE, value of 1).'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ActivationType** - 指示此类是在进程内（DLL，值为0）还是在进程外（EXE，值为1）激活。'
- en: 'For the rest of this discussion, we''ll assume an in-process class. `RoActivateInstance`
    calls another function, `RoGetActivationFactory`, that does the actual work of
    locating the Registry key and loading the DLL into the process address space.
    Then, it calls an exported global function from the DLL named `DllGetActivationFactory`
    (the DLL must export such a function, otherwise the creation process fails), passing
    in the full class name, the requested factory interface ID, and an output interface
    pointer as the result:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本讨论的其余部分，我们将假设是一个进程内类。`RoActivateInstance`调用另一个函数`RoGetActivationFactory`，它实际上是定位注册表键并将DLL加载到进程地址空间的实际工作。然后，它调用DLL中导出的名为`DllGetActivationFactory`的全局函数（DLL必须导出这样一个函数，否则创建过程将失败），传入完整的类名，请求的工厂接口ID和输出接口指针作为结果：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That global function inside the DLL is responsible for returning a class factory,
    capable of creating actual instances. The class factory typically implements the
    `IActivationFactory` interface, with a single method (beyond `IInspectable`):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: DLL中的全局函数负责返回一个能够创建实际实例的类工厂。类工厂通常实现`IActivationFactory`接口，具有一个方法（除了`IInspectable`）：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Returning the class factory is the job of `RoGetActivationFactory`. Then `RoActivateInstance`
    takes over, and calls `IActivationFactory::ActivateInstance` to create the actual
    instance, which is the result of `RoActivateInstance`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类工厂是`RoGetActivationFactory`的工作。然后`RoActivateInstance`接管，并调用`IActivationFactory::ActivateInstance`来创建实际的实例，这就是`RoActivateInstance`的结果。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Readers familiar with classic COM may recognize the similarities: `RoActivateInstance`
    replaces the classic `CoCreateInstance`; `RoGetActivationFactory` replaces `CoGetClassObject`;
    `DllGetActivationFactory` replaces `DllGetClassObject`; and finally, `IActivationFactory`
    replaces `IClassFactory`. Overall, though, the steps are practically the same.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉经典COM的读者可能会注意到相似之处：`RoActivateInstance`替换了经典的`CoCreateInstance`；`RoGetActivationFactory`替换了`CoGetClassObject`；`DllGetActivationFactory`替换了`DllGetClassObject`；最后，`IActivationFactory`替换了`IClassFactory`。总的来说，步骤几乎是一样的。
- en: 'The following diagram sums up the creation process of a WinRT type:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了创建WinRT类型的过程：
- en: '![Creating a WinRT object](img/5022_02_08.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![创建WinRT对象](img/5022_02_08.jpg)'
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Registry keys used in this sequence are relevant to desktop apps creating
    WinRT objects. The keys that a Store app activation uses are different, but the
    general sequence is the same.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在此序列中使用的注册表键与桌面应用程序创建WinRT对象相关。商店应用程序激活使用的键是不同的，但一般序列是相同的。
- en: If all goes well, we have an `IInspectable` interface pointer to a Calendar
    instance. But we're interested in a more specific interface that would provide
    the true capabilities of the Calendar.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将得到一个指向Calendar实例的`IInspectable`接口指针。但我们对能够提供Calendar真正功能的更具体接口感兴趣。
- en: 'As it turns out, the definition of the relevant interface is in a header file,
    named after the namespace where Calendar is placed:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，相关接口的定义在一个名为Calendar的命名空间的头文件中：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The interface in question is named `ICalendar` in the `ABI::Windows::Globalization`
    namespace. We''ll add a `using` namespace for easier access:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 所讨论的接口在`ABI::Windows::Globalization`命名空间中被命名为`ICalendar`。我们将添加一个`using`命名空间以便更容易访问：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Application Binary Interface** (**ABI**) is a root namespace that we''ll
    discuss in a later section.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序二进制接口**（**ABI**）是我们将在后面的部分中讨论的根命名空间。'
- en: 'Since we need an `ICalendar`, we have to `QueryInterface` for it:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要一个`ICalendar`，我们必须为其进行`QueryInterface`：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`pInst` is assumed to be some interface on an object (such as `IInspectable`).
    If that interface is indeed supported, we''ll get back a successful `HRESULT`
    (`S_OK`) and an interface pointer we can use. The `__uuidof` operator returns
    the **interface ID** (**IID**) of the interface in question; this is possible
    because of a `__declspec(uuid)` attribute attached to the declared interface.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`pInst`被假定为对象上的某个接口（如`IInspectable`）。如果确实支持该接口，我们将得到一个成功的`HRESULT`（`S_OK`）和一个可以使用的接口指针。`__uuidof`操作符返回了接口的**接口ID**（**IID**）；这是可能的，因为在声明的接口上附加了一个`__declspec(uuid)`属性。'
- en: 'Now, we can use the interface in any way we see fit. Here are some lines that
    get the current time and display it to the console:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以任何我们认为合适的方式使用接口。以下是一些获取当前时间并将其显示到控制台的代码行：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At this time, the reference count on the `Calendar` instance should be `2`.
    To clean up properly, we need to call `IUnknown::Release` on any obtained interface
    pointer (when created the ref count was `1`, and after `QueryInterface` it became
    `2`); also, since we created an `HSTRING`, it''s a good idea to destroy it; finally
    we''ll uninitialize WinRT on the current thread for good measure:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`Calendar`实例上的引用计数应该是`2`。为了正确清理，我们需要在任何获得的接口指针上调用`IUnknown::Release`（创建时引用计数为`1`，`QueryInterface`后变为`2`）；此外，由于我们创建了一个`HSTRING`，最好将其销毁；最后，我们将在当前线程上取消初始化WinRT以确保万无一失：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The complete code can be found in the `WinRTAccess1` project, part of the downloadable
    code for this chapter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`WinRTAccess1`项目中找到，这是本章可下载代码的一部分。
- en: WinRT metadata
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WinRT元数据
- en: The preceding example used the `<windows.globalization.h>` header file to discover
    the declaration of the `ICalendar` interface, including its IID. However, since
    COM/WinRT is supposed to provide interoperability between languages/platforms,
    how would a non-C++ language be able to use that header file?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用了`<windows.globalization.h>`头文件来发现`ICalendar`接口的声明，包括其IID。然而，由于COM/WinRT应该提供语言/平台之间的互操作性，非C++语言如何能够使用该头文件呢？
- en: The answer is that other languages can't use that header file; it's specific
    to C/C++. What we need is a kind of "universal header file", based on a well-defined
    structure and, thus, usable by any platform. This is the role of metadata files.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是其他语言无法使用该头文件；它是特定于C/C++的。我们需要的是一种基于明确定义的结构的“通用头文件”，因此可以被任何平台使用。这就是元数据文件的作用。
- en: The format of metadata files (with extension `.winmd`) is based on the metadata
    format created for .NET. This was simply convenient, as that format is rich, providing
    all the necessary ingredients for WinRT metadata as well.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据文件（扩展名为`.winmd`）的格式基于为.NET创建的元数据格式。这只是方便，因为该格式是丰富的，提供了WinRT元数据所需的所有必要组成部分。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In classic COM this metadata was stored in a type library. Type library format
    is not as rich as the .NET metadata format, and so wasn't used for WinRT.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典COM中，这些元数据存储在类型库中。类型库格式不如.NET元数据格式丰富，因此不适用于WinRT。
- en: 'The WinRT metadata files reside in the `%System32%\WinMetadata` folder, and
    they are conveniently arranged based on namespaces (in fact, that''s a requirement).
    Here are the files on my machine:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT元数据文件位于`%System32%\WinMetadata`文件夹中，并且它们根据命名空间方便地排列（实际上，这是一个要求）。这是我机器上的文件：
- en: '![WinRT metadata](img/5022_02_09.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![WinRT元数据](img/5022_02_09.jpg)'
- en: 'To view a metadata file, we can use any (relatively new) tool that is capable
    of showing .NET metadata, such as IL Disassembler (`ILDasm.exe`) from the Visual
    Studio 2012 tools, or Reflector ([http://www.reflector.net/](http://www.reflector.net/)).
    Opening `Windows.Globalization.winmd` in `ILDasm.exe` shows this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看元数据文件，我们可以使用任何（相对较新的）能够显示.NET元数据的工具，例如来自Visual Studio 2012工具的IL Disassembler（`ILDasm.exe`）或Reflector（[http://www.reflector.net/](http://www.reflector.net/)）。在`ILDasm.exe`中打开`Windows.Globalization.winmd`显示如下：
- en: '![WinRT metadata](img/5022_02_10.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![WinRT元数据](img/5022_02_10.jpg)'
- en: 'We can see all the classes and interfaces defined in the metadata file. Expanding
    the `ICalendar` interface node shows its members:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到元数据文件中定义的所有类和接口。展开`ICalendar`接口节点显示其成员：
- en: '![WinRT metadata](img/5022_02_11.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![WinRT metadata](img/5022_02_11.jpg)'
- en: Double-clicking a method does not show its implementation, as it's not really
    .NET; there's no code there, it's just its metadata format.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 双击一个方法并不会显示它的实现，因为它并不是真正的.NET；那里没有代码，只有它的元数据格式。
- en: 'What about the `Calendar` class? Expanding its node shows that it implements
    `ICalendar`. This gives anyone using the metadata (humans, as well as tools) the
    confidence to `QueryInterface` for this interface with a successful result:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calendar`类呢？展开它的节点会显示它实现了`ICalendar`。这使得任何使用元数据的人（包括工具）都可以自信地使用`QueryInterface`来查询这个接口并获得成功的结果：'
- en: '![WinRT metadata](img/5022_02_12.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![WinRT metadata](img/5022_02_12.jpg)'
- en: These metadata files are the result of building WinRT components. This way,
    any platform that understands the metadata format, can consume the classes/interfaces
    exposed by that component. We'll see an example later in this chapter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元数据文件是构建WinRT组件的结果。这样，任何了解元数据格式的平台都可以消费该组件公开的类/接口。我们将在本章后面看到一个示例。
- en: The Windows Runtime Library
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows Runtime Library
- en: The Calendar usage example worked, but the code required was pretty verbose.
    The **Windows Runtime Library** (**WRL**) is a set of helper classes and functions
    that make it easier to work with WinRT types, both as a client and as a server
    (creator of components). WRL uses standard C++ (no non-standard extensions), keeping
    things pretty close to the metal. Let's see how we can simplify the Calendar example
    by using WRL.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Calendar的使用示例有效，但所需的代码相当冗长。**Windows Runtime Library**（**WRL**）是一组帮助类和函数，使得在客户端和服务器端（组件的创建者）中更容易使用WinRT类型。WRL使用标准C++（没有非标准扩展），使得它与底层非常接近。让我们看看如何通过使用WRL来简化Calendar示例。
- en: 'First, we need to include the WRL headers; there is a main header and a helper
    with some convenient wrappers:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要包含WRL头文件；有一个主头文件和一个带有一些便利包装器的辅助文件：
- en: '[PRE40]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we''ll add some `using` statements to shorten the code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一些`using`语句来缩短代码：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In `main()`, we first need to initialize WinRT. A simple wrapper calls `RoInitialize`
    in its constructor and `RoUninitialize` in its destructor:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`中，我们首先需要初始化WinRT。一个简单的包装器在它的构造函数中调用`RoInitialize`，在它的析构函数中调用`RoUninitialize`：
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To create and manage an `HSTRING`, we can use a helper class, `HString`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和管理`HSTRING`，我们可以使用一个辅助类`HString`：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The long identifier is the full Calendar class name defined in `<windows.globalization.h>`,
    so we don't have to provide the actual string. `HString` has a `Get()` member
    function that returns the underlying `HSTRING`; its destructor destroys the `HSTRING`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 长标识符是在`<windows.globalization.h>`中定义的完整的Calendar类名，因此我们不必提供实际的字符串。`HString`有一个`Get()`成员函数，返回底层的`HSTRING`；它的析构函数销毁`HSTRING`。
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding code could actually be simplified (and sped up) by using an `HSTRING`
    that references an existing string, thus preventing actual string allocation and
    copying. This is done with the `HString::MakeReference` static function that internally
    calls `WindowsCreateStringReference`. It effectively removes the need to destroy
    the `HSTRING`, because there was nothing allocated in the first place. This string
    reference is also known as "fast pass".
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码实际上可以通过使用引用现有字符串的`HSTRING`来简化（并加快速度），从而避免实际的字符串分配和复制。这是通过`HString::MakeReference`静态函数完成的，该函数在内部调用`WindowsCreateStringReference`。它有效地消除了销毁`HSTRING`的需要，因为一开始根本没有分配任何东西。这个字符串引用也被称为“快速传递”。
- en: 'Creating the `Calendar` instance can be simplified by calling the `Windows::Foundation::ActivateInstance`
    template function that internally calls `RoActivateInstance` and queries for the
    requested interface:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`Windows::Foundation::ActivateInstance`模板函数，可以简化创建`Calendar`实例，该函数在内部调用`RoActivateInstance`并查询所请求的接口：
- en: '[PRE44]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`ComPtr<T>` is WRL''s smart pointer for WinRT interfaces. It calls `Release`
    correctly in its destructor, and provides the necessary operators (such as `->`)
    so that it''s invisible enough when accessing the underlying interface pointer.
    The rest of the code is pretty much the same, although no cleanup is necessary,
    as destructors do the right thing:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComPtr<T>`是WRL用于WinRT接口的智能指针。它在析构函数中正确调用`Release`，并提供必要的操作符（如`->`），因此在访问底层接口指针时几乎是不可见的。代码的其余部分基本相同，尽管不需要清理，因为析构函数会做正确的事情：'
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: WRL also provides classes that help implement WinRT components by implementing
    boilerplate code, such as `IInspectable`, activation factories, and so on. We
    will generally use C++/CX to create components, but WRL can be used if low-level
    control is required or language extensions are undesirable.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: WRL还提供了帮助实现WinRT组件的类，包括实现样板代码的`IInspectable`、激活工厂等。我们通常会使用C++/CX来创建组件，但如果需要低级控制或者不希望使用语言扩展，可以使用WRL。
- en: Note
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is no project template that is installed by default with Visual Studio
    2012 to create WinRT components with WRL; however, such a template was created
    by Microsoft, and is available by searching online when invoking the **Tools**
    | **Extensions and Updates** menu item. This gives a decent starting point for
    creating a WinRT DLL component. The steps involved are somewhat similar to the
    steps used to create classic COM components with ATL defining interfaces and members
    in an **Interface Definition Language** (**IDL**) file, and implementing the required
    functionality.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Visual Studio 2012没有安装用于使用WRL创建WinRT组件的项目模板；但是，微软创建了这样一个模板，并且在调用**工具**
    | **扩展和更新**菜单项时可以在线搜索到。这为创建WinRT DLL组件提供了一个不错的起点。所涉及的步骤与使用ATL定义接口和成员的经典COM组件的步骤相似，在**接口定义语言**（**IDL**）文件中实现所需的功能。
- en: C++/CX
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++/CX
- en: WRL simplifies using and accessing WinRT objects, but it's still a way to go
    from the normal C++ experience when creating and using objects. Calling the `new`
    operator is far easier than using `Windows::Foundation::ActivateInstance` and
    working with a `ComPtr<T>` smart pointer.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: WRL简化了使用和访问WinRT对象，但在创建和使用对象时，它仍然比普通C++体验要复杂。调用`new`运算符比使用`Windows::Foundation::ActivateInstance`和使用`ComPtr<T>`智能指针要容易得多。
- en: To this end, Microsoft has created a set of extensions to the C++ language,
    called C++/CX that help to bridge the gap, so that working with WinRT objects
    is almost as simple as working with non-WinRT objects.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，微软创建了一组名为C++/CX的C++语言扩展，帮助弥合差距，使得使用WinRT对象几乎与使用非WinRT对象一样简单。
- en: The following sections discuss some of the more common extensions. We'll discuss
    more extensions throughout the book. First, we'll look at creating objects, then
    we'll examine various members and how to access them, and finally, we'll consider
    the basics of creating new WinRT types with C++/CX.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分讨论了一些常见的扩展。我们将在整本书中讨论更多的扩展。首先，我们将看看如何创建对象，然后我们将研究各种成员以及如何访问它们，最后，我们将考虑使用C++/CX创建新的WinRT类型的基础知识。
- en: Creating and managing objects
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和管理对象
- en: 'WinRT objects are instantiated in C++/CX by the keyword `ref new`. This creates
    a reference counted object (a WinRT object) and returns a handle to the object
    using the `^` (hat) notation. Here''s an example of creating a `Calendar` object:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++/CX中，WinRT对象是通过关键字`ref new`实例化的。这将创建一个引用计数对象（WinRT对象），并使用`^`（帽子）符号返回对象的句柄。以下是创建`Calendar`对象的示例：
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The returned value in `cal` is a WinRT object. One thing that may be puzzling
    is that we're getting back a `Calendar` object and not an interface; but COM/WinRT
    clients can work with interfaces only; and where is `ICalendar` we were using
    before?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`cal`中返回的值是一个WinRT对象。可能令人困惑的一点是，我们得到的是一个`Calendar`对象而不是一个接口；但是COM/WinRT客户端只能使用接口；我们之前使用的`ICalendar`在哪里？'
- en: 'C++/CX provides a layer of convenience that allows using an object reference
    rather than an interface reference. However, the interface `ICalendar` is still
    there, and in fact that''s defined as the default interface for the `Calendar`
    class (the compiler is aware of that), but using the class directly seems more
    natural. We can verify that by adding a method call and looking at the generated
    code after adding a specific cast to `ICalendar` and comparing it to the original
    call:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: C++/CX提供了一层便利，允许使用对象引用而不是接口引用。但是，接口`ICalendar`仍然存在，并且实际上被定义为`Calendar`类的默认接口（编译器知道这一点），但直接使用类似更自然。我们可以通过添加一个方法调用来验证这一点，并在添加特定转换为`ICalendar`后查看生成的代码并将其与原始调用进行比较：
- en: '[PRE47]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here is the generated code for these calls:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些调用的生成代码：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The highlighted portions are the same, proving that the actual call goes through
    an interface.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮部分相同，证明实际调用是通过接口进行的。
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Readers familiar with C++/CLI, the C++ extensions for .NET, may recognize the
    "hat" (^) and some other similar keywords. This is simply syntax borrowed from
    C++/CLI, but it has nothing to do with .NET. All WinRT stuff is pure native code,
    whether it's accessed using C++/CX or not.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉C++/CLI，即.NET的C++扩展的读者可能会认出“帽子”(^)和一些其他类似的关键字。这只是从C++/CLI借来的语法，但与.NET无关。所有的WinRT都是纯本地代码，无论是使用C++/CX还是其他方式访问。
- en: 'When the hat variable goes out of scope, `IUnknown::Release` is called automatically
    as expected. It''s also possible to use stack semantics with WinRT types, like
    so:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当帽子变量超出范围时，`IUnknown::Release`会按预期自动调用。还可以使用WinRT类型的堆栈语义，如下所示：
- en: '[PRE49]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The object is still allocated dynamically in the usual way. But it's guaranteed
    to be cleaned up when the variable goes out of scope. This means that it cannot
    be passed to other methods.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对象仍然以通常的方式动态分配。但是保证在变量超出范围时进行清理。这意味着它不能传递给其他方法。
- en: Accessing members
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问成员
- en: After obtaining a reference to a WinRT object (or interface), members can be
    accessed with the arrow (`->`) operator, just like a regular pointer. Note, however,
    that the hat is not a pointer in the normal sense; for example, no pointer arithmetic
    is ever possible. The hat variable should be thought of as an opaque reference
    to a WinRT object.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得对WinRT对象（或接口）的引用后，可以使用箭头（`->`）运算符访问成员，就像常规指针一样。但是，帽子不是正常意义上的指针；例如，永远不可能进行指针算术运算。应该将帽子变量视为对WinRT对象的不透明引用。
- en: Accessing members through the reference is not exactly the same as accessing
    the object through a direct (or WRL-like) interface pointer. The main difference
    is error handling. All interface members must return an `HRESULT`; calling through
    a hat reference hides the `HRESULT` and instead throws an exception (something
    deriving from `Platform::Exception`) in case of failure. This is usually what
    we want, so that we can use the standard language facilities `try`/`catch` to
    handle errors and not have to check `HRESULT` for every call.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用访问成员并不完全与通过直接（或类似WRL的）接口指针访问对象相同。主要区别在于错误处理。所有接口成员必须返回`HRESULT`；通过帽子引用调用会隐藏`HRESULT`，而是在失败的情况下抛出异常（派生自`Platform::Exception`）。这通常是我们想要的，这样我们可以使用标准语言设施`try`/`catch`来处理错误，而不必为每次调用检查`HRESULT`。
- en: 'Another difference appears in case a method has a return value. The actual
    interface method must return an `HRESULT`, and as such adds an output argument
    (which must be a pointer) where the result would be stored on success. Since hat
    references hide the `HRESULT`, they make the return type the actual return value
    of the method call, which is very convenient. Here''s an example that uses the
    `ICalendar::Compare` method to compare this calendar''s date/time to another''s.
    Using WRL to create a second calendar and compare looks as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别出现在方法有返回值的情况下。实际接口方法必须返回`HRESULT`，因此添加一个输出参数（必须是指针），在成功时将结果存储在其中。由于帽子引用隐藏了`HRESULT`，它们使返回类型成为方法调用的实际返回值，这非常方便。以下是使用`ICalendar::Compare`方法比较此日历的日期/时间与另一个日历的示例。使用WRL创建第二个日历并进行比较如下：
- en: '[PRE50]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The result is obtained by passing the target variable as the last argument
    to the `Compare` call. Here''s the equivalent C++/CX version:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将目标变量作为`Compare`调用的最后一个参数来获得结果。以下是等效的C++/CX版本：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `HRESULT` is nowhere to be found, and the actual result is returned directly
    from the method call. If an error had occurred, a `Platform::Exception` (or a
    derivative) would have been thrown.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: HRESULT`无处可寻，实际结果直接从方法调用中返回。如果发生错误，将抛出`Platform::Exception`（或其派生类）。
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What about static methods or properties? These exist, and can be accessed by
    the familiar `ClassName::MemberName` syntax. Curious readers may wonder how these
    are implemented, as COM does not have a notion of static members, everything must
    be accessed through an interface pointer, implying an instance must exist. The
    solution selected is to implement the static members on the activation factory
    (class factory), as it's typically a singleton, effectively giving out the same
    net result.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法或属性呢？这些是存在的，并且可以通过熟悉的`ClassName::MemberName`语法进行访问。好奇的读者可能想知道这些是如何实现的，因为COM没有静态成员的概念，一切都必须通过接口指针访问，这意味着必须存在一个实例。所选的解决方案是在激活工厂（类工厂）上实现静态成员，因为它通常是单例，有效地给出了相同的净结果。
- en: Methods and properties
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法和属性
- en: WinRT is striving for object orientation, at least where members are concerned.
    Methods are member functions, invoked as expected in C++. This was the case with
    `ICalendar::SetToNow()`, `ICalendar::AddMinutes()` , and `ICalendar::Compare()`,
    shown previously.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT正在努力实现对象导向，至少在成员方面是这样。方法是成员函数，在C++中按预期调用。这在之前显示的`ICalendar::SetToNow()`、`ICalendar::AddMinutes()`和`ICalendar::Compare()`中是这样的。
- en: WinRT also defines the notion of properties, which are really methods in disguise.
    A property can have a getter and/or a setter. Since C++ doesn't have the concept
    of properties, these are modeled as methods starting with `get_` or `put_`, while
    C++/CX provides field-like access to the properties for convenience.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT还定义了属性的概念，实际上它们是伪装成方法的方法。属性可以有getter和/或setter。由于C++没有属性的概念，这些属性被建模为以`get_`或`put_`开头的方法，而C++/CX为了方便提供了类似字段的属性访问。
- en: 'Here''s an example that uses the `Hour` property defined on `ICalendar`. First,
    the WRL version:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`ICalendar`上定义的`Hour`属性的示例。首先是WRL版本：
- en: '[PRE52]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, the C++/CX version:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是C++/CX版本：
- en: '[PRE53]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The existence of properties can be seen in the metadata file, in this case
    `Windows.Globalization.winmd`. Looking at the `Calendar` class (or the `ICalendar`
    interface), the red triangles indicate properties. Double-clicking any of them
    shows the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的存在可以在元数据文件中看到，例如`Windows.Globalization.winmd`。查看`Calendar`类（或`ICalendar`接口），红色三角形表示属性。双击其中任何一个会显示以下内容：
- en: '![Methods and properties](img/5022_02_13.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![方法和属性](img/5022_02_13.jpg)'
- en: 'It is possible (with C++/CX) to access the actual method or property without
    the abstraction layer of mapping failed `HRESULT` to exception, if the need arises
    (this is faster, and is equivalent to WRL generated code). This is done by calling
    the member prefixed by `__abi_`, as the following code snippet demonstrates:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++/CX可以访问实际的方法或属性，而无需将失败的`HRESULT`映射到异常的抽象层，如果需要（这更快，等效于WRL生成的代码）。这是通过调用以`__abi_`为前缀的成员来实现的，如下面的代码片段所示：
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: All these members return `HRESULT` as these are the actual calls through the
    interface pointer. Curiously enough, property setters must be prefixed by `set_`
    and not `put_`. This scheme also provides a way to call `IInspectable` methods,
    such as `GetIids`, which are otherwise inaccessible through a hat reference.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些成员都返回`HRESULT`，因为这些都是通过接口指针的实际调用。有趣的是，属性的设置器必须以`set_`而不是`put_`为前缀。这种方案还提供了一种调用`IInspectable`方法的方式，例如`GetIids`，否则无法通过帽子引用进行访问。
- en: Note
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Currently, there is no `Intellisense` for these calls, so red squigglies will
    show in the editor. The code compiles and runs as expected, though.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这些调用没有`Intellisense`，因此编辑器中会显示红色波浪线。但是代码编译和运行都如预期那样。
- en: Delegates
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 委托
- en: Delegates are the WinRT equivalent of function pointers. A delegate is a kind
    of field that can point to a method. Contrary to function pointers, a delegate
    can point to a static method or an instance method, as required. Delegates have
    built-in constructors that accept a method or a lambda function.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 委托是WinRT中函数指针的等价物。委托是一种可以指向方法的字段。与函数指针相反，委托可以指向静态方法或实例方法，根据需要。委托具有内置的构造函数，接受方法或lambda函数。
- en: Note
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The term "delegate" is used because of its similarity to the same concept from
    the .NET world, where delegates serve much the same purpose as they do in WinRT.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“委托”之所以被使用，是因为它与.NET世界中的相同概念相似，在那里委托的作用与WinRT中的作用基本相同。
- en: 'Here''s an example with the `IAsyncOperation<T>` interface, which we''ll discuss
    shortly when we look at asynchronous operations. Given an `IAsyncOperation<T>`
    (`T` is the return type expected from the operation), its `Completed` property
    is of type `AsyncOperationCompletedHandler<T>`, which is a delegate type. We can
    hook up the `Completed` property to a member function of the current instance
    like so:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`IAsyncOperation<T>`接口的示例，我们将在讨论异步操作时进行详细讨论。给定一个`IAsyncOperation<T>`（`T`是操作预期的返回类型），其`Completed`属性的类型为`AsyncOperationCompletedHandler<T>`，这是一种委托类型。我们可以将`Completed`属性连接到当前实例的成员函数，如下所示：
- en: '[PRE55]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Where `App::MyHandler` is prototyped like so:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`App::MyHandler`的原型如下：
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Why this prototype? This is exactly the thing that a delegate defines: a certain
    prototype that must be followed, else the compiler complains.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是这个原型？这正是委托定义的东西：必须遵循的特定原型，否则编译器会抱怨。
- en: 'As an alternative to a named method, we can bind the delegate to a lambda function,
    which is more convenient in many cases. Here''s the equivalent lambda to the previous
    code:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 作为命名方法的替代，我们可以将委托绑定到lambda函数，这在许多情况下更方便。以下是与之前代码等效的lambda：
- en: '[PRE57]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The example captures no variables. The key point here is that the arguments
    to the lambda are exactly the same as the case with a named method.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中未捕获任何变量。关键点在于lambda的参数与命名方法的情况完全相同。
- en: 'What is a delegate really? It''s a WinRT class like any other, with a special
    constructor that allows binding to a method (named or lambda) and an `Invoke`
    method that actually executes the delegate. In C++/CX, the invocation can be performed
    by a function call operator `()`, just like any function. Assuming the previous
    declarations, we can invoke the `Completed` delegate in one of the following ways:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 委托到底是什么？它是一个像任何其他WinRT类一样的类，具有一个特殊的构造函数，允许绑定到一个方法（命名或lambda），以及一个实际执行委托的`Invoke`方法。在C++/CX中，调用可以通过函数调用运算符`()`执行，就像任何函数一样。假设前面的声明，我们可以以以下方式之一调用`Completed`委托：
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The two lines are equivalent.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行是等价的。
- en: Note
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, the preceding code is syntactically correct, but we would never
    invoke an asynchronous operation completion ourselves. The owner of the operation
    will do the invocation (we'll look at asynchronous operations later in this chapter).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，前面的代码在语法上是正确的，但我们永远不会自己调用异步操作完成。操作的所有者将进行调用（我们将在本章后面讨论异步操作）。
- en: Events
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: 'Delegates are not usually declared as properties as in the `IAsyncOperation<T>::Completed`
    property. There are two reasons for that:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 委托通常不会声明为属性，如`IAsyncOperation<T>::Completed`属性。原因有两个：
- en: Anyone can place `nullptr` in that property (or some other delegate), throwing
    away any previous delegate instance that might have been set up
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何人都可以在该属性中放置`nullptr`（或其他委托），丢弃可能已设置的任何先前的委托实例
- en: Anyone can invoke the delegate, which is weird, as only the declaring class
    knows when the delegate should be invoked
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何人都可以调用委托，这很奇怪，因为只有声明类知道何时应该调用委托。
- en: What we want is a way to use delegates to connect to interested methods, but
    do so in a safe way that does not allow arbitrary code to change the delegate
    directly or to invoke it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的是一种使用委托连接到感兴趣的方法的方式，但以一种安全的方式，不允许任意代码直接更改委托或调用它。
- en: This is where events come in. An event looks like a delegate, but in fact, it
    has two methods, one for registering a handler for the event and one for revoking
    the handler. In C++/CX, the `+=` and `-=` operators work on events, so that clients
    can register for notifications, but can never use the assignment operator to nullify
    or replace the delegate's value, because it's not exposed in that way.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是事件的作用。事件看起来像委托，但实际上有两种方法，一种用于注册事件处理程序，一种用于撤销处理程序。在C++/CX中，`+=`和`-=`运算符用于事件，因此客户端可以注册通知，但永远不能使用赋值运算符来使委托的值为空或替换委托的值，因为它没有以这种方式公开。
- en: 'Here''s an example using the `Application::Suspending` event that indicates
    to the interested parties that the application is about to be suspended, a good
    time to save a state (we''ll discuss the application lifecycle in [Chapter 7](ch07.html
    "Chapter 7. Applications, Tiles, Tasks, and Notifications"), *Applications, Tiles,
    Tasks and Notifications*):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用`Application::Suspending`事件的示例，该事件指示感兴趣的方当应用程序即将被暂停时，可以保存状态的良好时机（我们将在[第7章](ch07.html
    "Chapter 7. Applications, Tiles, Tasks, and Notifications")中讨论应用程序生命周期，*应用程序、磁贴、任务和通知*）：
- en: '[PRE59]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Notice that `SuspendingEventHandler` is a delegate type, meaning the method
    `OnSuspending` must be prototyped in a certain way, as defined by that delegate.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`SuspendingEventHandler`是委托类型，这意味着方法`OnSuspending`必须按照该委托定义的方式进行原型设计。
- en: 'Behind the scenes, an event is just a pair of methods, implemented appropriately
    (Visual Studio intellisense shows events with a lightning-like icon). Here''s
    a look at the `Application::Suspending` event (other events are shown as well)
    as described via metadata, shown in `ILDasm.exe`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，事件只是一对适当实现的方法（Visual Studio智能感知显示带有闪电图标的事件）。以下是通过元数据描述的`Application::Suspending`事件（还显示了其他事件），在`ILDasm.exe`中显示：
- en: '![Events](img/5022_02_14.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![事件](img/5022_02_14.jpg)'
- en: The inverted green triangle indicates the event member itself, while the `add_Suspending`
    and `remove_Suspending` are the actual methods called when the `+=` and `-=` C++/CX
    operators are used.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 倒置的绿色三角形表示事件成员本身，而`add_Suspending`和`remove_Suspending`是在使用`+=`和`-=` C++/CX运算符时调用的实际方法。
- en: Defining types and members
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义类型和成员
- en: Defining WinRT types can be done with WRL (by defining interfaces in an IDL
    file, implementing all boilerplate code, such as `IUnknown` and `IInspectable`
    implementations, activation factories, DLL global functions, and so on). This
    provides a very fine-grained way to create components, and is similar in spirit
    to the way COM components were authored with the **Active Template Library** (**ATL**).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用WRL（通过在IDL文件中定义接口，实现所有样板代码，如`IUnknown`和`IInspectable`实现，激活工厂，DLL全局函数等）来定义WinRT类型。这提供了一种非常精细的方式来创建组件，并且在精神上类似于使用**Active
    Template Library**（**ATL**）编写COM组件的方式。
- en: With C++/CX, authoring reusable WinRT components is much easier than with WRL.
    In this section we'll build a simple component, and use it with C++ and C# clients
    (a JavaScript client would work just as well and is left as an exercise for the
    interested reader).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++/CX，编写可重用的WinRT组件比使用WRL要容易得多。在本节中，我们将构建一个简单的组件，并将其与C++和C#客户端一起使用（JavaScript客户端同样有效，留给感兴趣的读者作为练习）。
- en: A WinRT component project
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WinRT组件项目
- en: 'Visual Studio 2012 includes a project template for creating a WinRT component
    that can then be used by any WinRT-compliant platform (or another WinRT component).
    We''ll create a new project of type **Windows Runtime Component**, named `Calculations`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2012包括一个项目模板，用于创建一个WinRT组件，然后可以被任何符合WinRT标准的平台（或另一个WinRT组件）使用。我们将创建一个名为`Calculations`的**Windows
    Runtime Component**类型的新项目：
- en: '![A WinRT component project](img/5022_02_15.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![WinRT组件项目](img/5022_02_15.jpg)'
- en: 'The wizard adds a `Class1` class. We can delete that and add a new C++ class
    or do the renaming of files and class name. We''ll create a WinRT class named
    `Calculator`, defined with the following code in the header file:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 向导添加了一个`Class1`类。我们可以删除它并添加一个新的C++类，或者重命名文件和类名。我们将创建一个名为`Calculator`的WinRT类，在头文件中使用以下代码定义：
- en: '[PRE60]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: A WinRT class must be defined inside a namespace by the `ref class` keyword.
    It must also be declared `public` so that it would be usable outside the component
    DLL. The class must also be marked `sealed`, meaning it cannot be inherited from;
    or, it can inherit from non-sealed classes, which currently are classes provided
    by the WinRT library residing in the `Windows::UI::Xaml` namespace. A detailed
    discussion of WinRT inheritance is outside the scope of this section.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT类必须由`ref class`关键字定义在命名空间内。它还必须声明为`public`，以便在组件DLL外部可用。该类还必须标记为`sealed`，表示它不能被继承；或者，它可以继承自非密封类，这些类目前是WinRT库中位于`Windows::UI::Xaml`命名空间中的类。WinRT继承的详细讨论超出了本节的范围。
- en: Now, it's time to give the class some useful content.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候给这个类一些有用的内容了。
- en: Adding properties and methods
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加属性和方法
- en: The idea for the `Calculator` class is to be an accumulating calculator. It
    should hold a current result (starting at zero, by default), and modify the result
    when new mathematical operations are performed. At any time, its current result
    can be obtained.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`Calculator`类的想法是成为一个累积计算器。它应该保存当前结果（默认为零），并在执行新的数学运算时修改结果。随时可以获取其当前结果。'
- en: 'Methods are added as regular member functions, including constructors. Let''s
    add a constructor and a few operations (within the `public` section of the class):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 方法被添加为常规成员函数，包括构造函数。让我们在类的`public`部分添加一个构造函数和一些操作：
- en: '[PRE61]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We need a read-only property to convey the current result. Here''s how to define
    it:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个只读属性来传达当前结果。下面是如何定义它的方法：
- en: '[PRE62]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `property` keyword is a C++/CX extension that defines a property, followed
    by its type and its name. Inside the curly braces, `get()` and `set()` methods
    can be declared (`set` must accept the value with the correct type). The missing
    `set()` method indicates this is a read-only property—a `get_Result` method would
    be created, but a `put_Result` method would not.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`property`关键字是C++/CX的扩展，定义了一个属性，后面跟着它的类型和名称。在大括号内，可以声明`get()`和`set()`方法（`set`必须接受正确类型的值）。缺少的`set()`方法表示这是一个只读属性——将创建一个`get_Result`方法，但不会创建`put_Result`方法。'
- en: Note
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's possible to add a simple read/write property backed by a private field
    by placing a semicolon after the property name (with no curly braces at all).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在属性名称后面加上分号（完全没有大括号）来添加一个简单的由私有字段支持的读/写属性。
- en: 'Next, we add whatever `private` members we need to maintain a proper state;
    in this simple case, it''s just the current result:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加需要维护正确状态的任何`private`成员；在这种简单情况下，只是当前结果：
- en: '[PRE63]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the CPP file, we need to implement all these members, to get away from **unresolved
    external linker** errors:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在CPP文件中，我们需要实现所有这些成员，以摆脱**未解析的外部链接器**错误：
- en: '[PRE64]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: There is nothing special in that code, except perhaps the syntax used to implement
    the `Result` property.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在那段代码中没有什么特别的，除了用于实现`Result`属性的语法。
- en: 'Since this is a WinRT component, a metadata (`.winmd`) file is created as part
    of the build process; this is the file that will be used to consume the component.
    Opening it with `ILDasm.exe` shows the result of the code just written:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个WinRT组件，元数据（`.winmd`）文件将作为构建过程的一部分创建；这是将用于消耗组件的文件。使用`ILDasm.exe`打开它会显示刚刚编写的代码的结果：
- en: '![Adding properties and methods](img/5022_02_16.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![添加属性和方法](img/5022_02_16.jpg)'
- en: There are a few interesting points here. Since we've written a WinRT class,
    it must implement an interface, as WinRT/COM clients can only work with interfaces.
    In the `Calendar` case, the interface was named `ICalendar` (which was its default
    interface), but here we haven't specified any such interface. The compiler created
    such an interface automatically, and it's named `__ICalculatorPublicNonVirtuals`.
    This is the actual interface that defines all the methods and properties. The
    peculiar name hints that these methods are normally only callable from a reference
    to a `Calculator` object; in any case, the interface name is unimportant.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的地方。由于我们编写了一个WinRT类，它必须实现一个接口，因为WinRT/COM客户端只能使用接口。在`Calendar`的情况下，接口被命名为`ICalendar`（这是它的默认接口），但在这里我们没有指定任何这样的接口。编译器自动创建了这样一个接口，它的名称是`__ICalculatorPublicNonVirtuals`。这是实际定义所有方法和属性的接口。奇怪的名称暗示这些方法通常只能从对`Calculator`对象的引用调用；无论如何，接口名称都不重要。
- en: Note
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Clearly, the `Calendar` class was not created with C++/CX, as its default interface
    is named `ICalendar`. In fact, it was created with WRL, which allows complete
    control of every aspect of component authoring, including interface names; WRL
    was used to build all Microsoft-provided WinRT types.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`Calendar`类不是用C++/CX创建的，因为它的默认接口名为`ICalendar`。事实上，它是用WRL创建的，WRL允许完全控制组件作者的每个方面，包括接口名称；WRL用于构建所有Microsoft提供的WinRT类型。
- en: Another interesting point concerns the overloaded constructors. Since a non-default
    constructor was provided, the default creation interface, `IActivationFactory`
    is insufficient, and so the compiler created a second interface, `ICalculatorFactory`,
    with a `CreateInstance` method accepting a double value. This is another feature
    that makes C++/CX easy to use—as the burden is on the compiler.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的地方涉及重载的构造函数。由于提供了非默认构造函数，因此默认的创建接口`IActivationFactory`是不够的，因此编译器创建了第二个接口`ICalculatorFactory`，其中包含一个接受双精度值的`CreateInstance`方法。这是使C++/CX易于使用的另一个特性——因为负担在编译器上。
- en: Adding an event
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个事件
- en: To make it more interesting, let's add an event that fires in case an attempt
    is made to divide by zero. First, we need to declare a delegate that is appropriate
    for the event, or use one of the already defined delegates in WinRT.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更有趣，让我们添加一个事件，以防尝试除以零。首先，我们需要声明一个适用于事件的委托，或者使用WinRT中已定义的委托之一。
- en: 'For demonstration purposes, we''ll define a delegate of our own to show how
    it''s done with C++/CX. We add the following declarations just above the `Calculator`
    definition inside the `Calculations` namespace declaration:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将定义一个自己的委托，以展示如何在C++/CX中完成。我们在`Calculations`命名空间声明内的`Calculator`定义上方添加以下声明：
- en: '[PRE65]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The forward declaration is necessary, as the compiler has not yet stumbled upon
    the `Calculator` class.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 前向声明是必要的，因为编译器尚未遇到`Calculator`类。
- en: 'The delegate indicates it can bind to any method that accepts a `Calculator`
    instance. What should we do with this delegate declaration? We''ll add an event
    that clients can register for. The following declaration is added inside the `public`
    section of the class:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 委托表示它可以绑定到接受`Calculator`实例的任何方法。我们应该如何处理这个委托声明呢？我们将在类的`public`部分添加一个客户端可以注册的事件。
- en: '[PRE66]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This declares the event in the simplest possible way—the compiler implements
    the `add_DivideByZero` and `remove_DivideByZero` methods appropriately.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这以最简单的方式声明了事件——编译器适当地实现了`add_DivideByZero`和`remove_DivideByZero`方法。
- en: 'Now, we need to update the implementation of the `Divide` method, so that the
    event fires in case the passed in value is zero:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新`Divide`方法的实现，以便在传入值为零的情况下触发事件：
- en: '[PRE67]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Invoking the event invokes all registered observers (clients) for this event,
    passing itself as an argument (that may or may not be useful for clients).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 调用事件会调用所有注册的观察者（客户端）来处理此事件，并将自身作为参数传递（这可能对客户端有用，也可能没有）。
- en: Consuming a WinRT component
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用WinRT组件
- en: It's time to consume the `Calculator` class we just created. We'll build two
    clients, a C++ and a C# client, just to show the differences.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候使用我们刚刚创建的`Calculator`类了。我们将构建两个客户端，一个是C++客户端，一个是C#客户端，以展示它们之间的区别。
- en: Building a C++ client
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建一个C++客户端
- en: 'We''ll create a blank C++ Store application project in the same solution and
    build a simple user interface in XAML to test the functionality of the calculator.
    The user interface details are unimportant for this discussion; the complete code
    can be found in the `CalcClient1` project, available in the downloadable code
    for this chapter. The UI looks like this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在同一个解决方案中创建一个空白的C++商店应用项目，并在XAML中构建一个简单的用户界面来测试计算器的功能。对于这次讨论来说，用户界面的细节并不重要；完整的代码可以在本章的可下载代码中的`CalcClient1`项目中找到。UI看起来像这样：
- en: '![Building a C++ client](img/5022_02_17.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![构建一个C++客户端](img/5022_02_17.jpg)'
- en: 'To get the definition of our `Calculator`, we need to add a reference to the
    metadata file. This is available by right-clicking on the project node and selecting
    **References…**. In the shown dialog box, we select the **Calculations** project:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取我们的`Calculator`的定义，我们需要添加对元数据文件的引用。通过右键单击项目节点并选择**References…**来实现。在显示的对话框中，我们选择**Calculations**项目：
- en: '![Building a C++ client](img/5022_02_18.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![构建一个C++客户端](img/5022_02_18.jpg)'
- en: 'Now that the definitions are available, we can use them. In `MainPage.xaml.h`,
    we add a reference to a `Calculator` object, so that it exists for the lifetime
    of the page:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义都已经可用，我们可以使用它们了。在`MainPage.xaml.h`中，我们添加了对`Calculator`对象的引用，以便它在页面的生命周期内存在：
- en: '[PRE68]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the `MainPage` constructor, we need to actually create the instance and
    optionally connect to the `DivideByZero` event (which we do):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainPage`构造函数中，我们需要实际创建实例，并可选择连接到`DivideByZero`事件（我们这样做）：
- en: '[PRE69]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`_error` is a `TextBlock` element within the UI that shows the last error (if
    any). A `using namespace` for `Calculations` was also added so that the preceding
    code can compile.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`_error`是UI中显示最后一个错误（如果有的话）的`TextBlock`元素。还添加了一个`using namespace`来引用`Calculations`，以便前面的代码可以编译。'
- en: 'When the **Calculate** button is clicked we need to perform the actual operation
    based on the currently selected index in the listbox that hosts the available
    operations:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当单击**Calculate**按钮时，我们需要根据列表框中当前选择的索引执行实际操作：
- en: '[PRE70]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: For this code to compile, a `using` `namespace` statement was added for `std`
    and an `#include` was added for `<sstream>`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这段代码编译通过，需要添加一个`using` `namespace`语句来引用`std`，并添加一个`#include`来引用`<sstream>`。
- en: That's it. We have consumed a WinRT component. Technically, there is no easy
    way to know in what language that was written. The only thing that matters is
    that it's a WinRT component.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们已经使用了一个WinRT组件。从技术上讲，没有简单的方法可以知道它是用什么语言编写的。唯一重要的是它是一个WinRT组件。
- en: Building a C# client
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建一个C#客户端
- en: Let's see how this works with another client—a Store app written with C#. First,
    we'll create a blank C# Store application (named `CalcClient2`) and copy the XAML
    as is to the C# project from the C++ client project.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这如何与另一个客户端一起工作——使用C#编写的商店应用。首先，我们将创建一个空白的C#商店应用（名为`CalcClient2`），并将XAML原样复制到C#项目中，从C++客户端项目中。
- en: Next, we need to add a reference to the `winmd` file. Right-click on the project
    node and select **Add Reference…** or right-click on the **References** node and
    select **Add Reference…**. A similar dialog appears, allowing the selection of
    the `Calculations` project (or browsing the filesystem for the file if it's a
    different solution).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加对`winmd`文件的引用。右键单击项目节点，选择**Add Reference…**，或右键单击**References**节点，选择**Add
    Reference…**。类似的对话框会出现，允许选择`Calculations`项目（或者如果它是不同的解决方案，则浏览文件系统中的文件）。
- en: 'The actual code needed to use `Calculator` is similar to the C++ case, with
    the syntax and semantics of C# (and .NET). In `MainPage.xaml.cs`, we create a
    `Calculator` object and register for the `DivideByZero` event (using a C# lambda
    expression):'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Calculator`所需的实际代码与C++情况类似，使用了C#（和.NET）的语法和语义。在`MainPage.xaml.cs`中，我们创建了一个`Calculator`对象，并注册了`DivideByZero`事件（使用C#
    lambda表达式）：
- en: '[PRE71]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In C#, a lambda expression can be written without specifying the exact types
    (as shown in the preceding code snippet); the compiler infers the types on its
    own (because the delegate type is known). It's possible (and legal) to write the
    type explicitly like `_calculator.DivideByZero += (Calculator calc) => { … };`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，可以编写lambda表达式而不指定确切的类型（如前面的代码片段所示）；编译器会自行推断类型（因为委托类型是已知的）。也可以明确写出类型，如`_calculator.DivideByZero
    += (Calculator calc) => { … };`是可能的（也是合法的）。
- en: 'A `using` `Calculations` statement was added at the top of the file. The button''s
    click event handler is pretty self-explanatory:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 文件顶部添加了一个`using` `Calculations`语句。按钮的点击事件处理程序非常容易理解：
- en: '[PRE72]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Notice how similar the C# code that accesses the calculator is to the C++ version.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 注意C#代码访问计算器的方式与C++版本非常相似。
- en: The Application Binary Interface
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序二进制接口
- en: 'The `Calculator` WinRT class created in the previous section leaves some questions.
    Suppose the following method was added to the public section of the class:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中创建的`Calculator` WinRT类留下了一些问题。假设以下方法被添加到类的公共部分：
- en: '[PRE73]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The compiler would refuse to compile this method. The reason has to do with
    the use of `std::wstring`. It''s a C++ type—how would that project into C# or
    JavaScript? It can''t. Public members must use WinRT types only. There is a boundary
    between the internal C++ implementation and the public-facing types. The correct
    way to define the method in question is this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将拒绝编译此方法。原因与使用`std::wstring`有关。这是一种C++类型——它如何映射到C#或JavaScript？它不能。公共成员必须仅使用WinRT类型。内部C++实现和面向公众的类型之间存在边界。定义相关方法的正确方式是这样的：
- en: '[PRE74]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`Platform::String` is the C++/CX wrapper over a `HSTRING` WinRT, which is projected
    as `System.String` to C# and to a JavaScript `string` in that world.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`Platform::String`是C++/CX对`HSTRING` WinRT的包装器，它在C#中被映射为`System.String`，在JavaScript中被映射为`string`。'
- en: Private members in a WinRT class can be anything, and more often than not these
    are native C++ types (such as `wstring`, `vector<>`, and anything else that may
    have been migrated from older code).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT类中的私有成员可以是任何东西，往往是本机C++类型（如`wstring`，`vector<>`，以及可能从旧代码迁移过来的其他任何东西）。
- en: Simple types, such as `int` and `double` are automatically mapped between C++
    and WinRT. The **Application Binary Interface** (**ABI**) is the boundary between
    WinRT types (that are consumable outside the component) and the native types that
    are specific to the language/technology (true not just for C++, but for C# as
    well).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 简单类型，如`int`和`double`在C++和WinRT之间自动映射。**应用程序二进制接口**（**ABI**）是WinRT类型（可在组件外部使用）和特定于语言/技术的本机类型之间的边界（不仅适用于C++，也适用于C#）。
- en: Asynchronous operations
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步操作
- en: Windows 8 Store applications promise to be "fast and fluid". This expression
    has several meanings, some of which are related to user experience and user interface
    design (which won't concern us here), and some related to application responsiveness.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 8商店应用承诺“快速流畅”。这个表达有几个意思，其中一些与用户体验和用户界面设计有关（这里不涉及），一些与应用程序响应性有关。
- en: 'Ever since the first version of the Windows OS, user interface was handled
    by a single thread in an application. Technically, a thread may create any number
    of windows, and that thread becomes the owner of those windows, and is the only
    thread that can handle messages targeting those windows (through a message queue).
    If that thread becomes very busy and does not handle messages quickly enough,
    the UI becomes less responsive; in extreme cases, if the thread is stuck for several
    seconds or longer (for whatever reason), the UI becomes completely unresponsive.
    This situation is pretty familiar and highly undesirable. The following diagram
    illustrates the entities involved in UI processing:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Windows操作系统的第一个版本以来，用户界面由应用程序中的单个线程处理。从技术上讲，一个线程可以创建任意数量的窗口，并且该线程成为这些窗口的所有者，并且是唯一可以处理针对这些窗口的消息的线程（通过消息队列）。如果该线程变得非常忙碌，并且不能及时处理消息，UI将变得不够响应；在极端情况下，如果线程由于某种原因被卡住了几秒钟或更长时间，UI将变得完全无响应。这种情况非常熟悉且极不理想。以下图表说明了UI处理中涉及的实体：
- en: '![Asynchronous operations](img/5022_02_19.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![异步操作](img/5022_02_19.jpg)'
- en: The key to responsiveness is to free the UI thread as soon as possible and never
    block it for more than a few milliseconds. In the world of desktop apps, there's
    nothing stopping the developer from calling some long running operation (or some
    long I/O operation), thus preventing the thread from returning to its pumping
    messages activity, freezing the user interface.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 响应性的关键是尽快释放UI线程，并且永远不要阻塞它超过几毫秒。在桌面应用程序的世界中，开发人员可以随意调用一些长时间运行的操作（或一些长时间的I/O操作），从而阻止线程返回到消息处理活动，冻结用户界面。
- en: 'In WinRT, Microsoft has made a conscious decision that if an operation may
    take longer than 50 milliseconds, then it should be made asynchronous rather than
    synchronous. The net result is that many methods are executed asynchronously,
    something that can potentially complicate code. Asynchronous means that the operation
    starts, but the call returns almost immediately. When the operation is complete,
    some callback is invoked, so that the application can take further steps. In between,
    though, the UI thread is doing nothing special and, thus, can pump messages as
    usual, keeping the UI responsive. The difference between synchronous and asynchronous
    calls can be illustrated with the following diagram:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在WinRT中，微软已经做出了一个有意识的决定，即如果一个操作可能需要超过50毫秒的时间，那么它应该是异步的而不是同步的。最终结果是许多方法都是异步执行的，这可能会使代码变得更加复杂。异步意味着操作开始，但调用几乎立即返回。当操作完成时，会调用某些回调，以便应用程序可以采取进一步的步骤。在此期间，UI线程没有做任何特殊的事情，因此可以像往常一样处理消息，保持UI的响应性。同步和异步调用之间的区别可以用以下图表说明：
- en: '![Asynchronous operations](img/5022_02_20.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![异步操作](img/5022_02_20.jpg)'
- en: Asynchronous operations, although desirable, are more complicated by definition.
    The code is not sequential anymore. WinRT defines some interfaces that represent
    on-going operations. These interfaces are returned from various asynchronous methods
    that start an operation and allow the client to register for the time the operation
    completes.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 异步操作，虽然可取，但从定义上来说更加复杂。代码不再是顺序的。WinRT定义了一些表示正在进行的操作的接口。这些接口是从各种异步方法返回的，这些方法启动一个操作，并允许客户端注册操作完成的时间。
- en: Let's see an example of asynchronous operations and how we can handle them.
    We'll create a simple image viewer application that allows a user to browse for
    an image and show it (the complete source is in the `SimpleImageView` project
    available with this chapter's downloads). The user interface is not important
    at the moment, consisting of a button that initiates the user's selection process
    and an `Image` element that can show images. When the button is clicked we want
    to provide the user with a way to select image files and then convert the file
    to something an `Image` element can show.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个异步操作的例子以及我们如何处理它们。我们将创建一个简单的图像查看器应用程序，允许用户浏览图像并显示它（完整的源代码在本章的下载中提供的`SimpleImageView`项目中）。用户界面目前并不重要，由一个按钮组成，该按钮启动用户的选择过程，以及一个`Image`元素，可以显示图像。当点击按钮时，我们希望为用户提供一种选择图像文件的方法，然后将文件转换为`Image`元素可以显示的内容。
- en: 'The WinRT class to use for selecting files is `Windows::Storage::Pickers::FileOpenPicker`.
    We''ll create an instance and set some properties:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 用于选择文件的WinRT类是`Windows::Storage::Pickers::FileOpenPicker`。我们将创建一个实例并设置一些属性：
- en: '[PRE75]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Readers familiar with the desktop app world may wonder where the common open
    file dialog is, which is available through the Win32 API or other wrappers. That
    dialog cannot be used in a Store app for several reasons. The first is aesthetic;
    the dialog is ugly, compared to the modern UI that Windows 8 Store apps try to
    convey. Second, the dialog has a title bar and other such chrome, and as such
    is not suitable for the new world. And third (most importantly), `FileOpenPicker`
    is not just about selecting files from the filesystem. It actually works with
    the File Open Picker contract, implemented (for example) by the camera (if one
    is attached), so we can actually take a picture and then select it; the same is
    true for other sources, such as SkyDrive, Facebook, and so on. The common open
    file dialog has no such functionality.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉桌面应用程序世界的读者可能会想知道通用的打开文件对话框在哪里，该对话框可以通过Win32 API或其他包装器使用。由于几个原因，该对话框不能在商店应用程序中使用。首先是美学原因；与Windows
    8商店应用程序试图传达的现代UI相比，该对话框很丑陋。其次，该对话框有标题栏和其他类似的界面，因此不适合新世界。最重要的是，`FileOpenPicker`不仅仅是从文件系统中选择文件。它实际上是使用文件打开选择器合同，由相机（如果连接了相机）实现（例如），因此我们实际上可以拍照然后选择它；对于其他来源，如SkyDrive、Facebook等也是如此。通用的打开文件对话框没有这样的功能。
- en: Now, it's time to show that picker and allow the user to select something. Looking
    at the `FileOpenPicker` API, we find the `PickSingleFileAsync` method. The `Async`
    suffix is the convention used in the WinRT API to indicate a method that starts
    an asynchronous operation. The result of picking a file should be an instance
    of `Windows::Storage::StorageFile`, but instead it returns an `IAsyncOperation<StorageFile^>`,
    which is an object representing the long running operation.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候显示选择器并允许用户选择一些东西了。查看`FileOpenPicker`API，我们找到了`PickSingleFileAsync`方法。`Async`后缀是WinRT
    API中用于指示启动异步操作的方法的约定。选择文件的结果应该是`Windows::Storage::StorageFile`的一个实例，但实际上它返回的是`IAsyncOperation<StorageFile^>`，这是表示长时间运行操作的对象。
- en: 'One way to work with this is to set the `Completed` property (a delegate) to
    a handler method that will be invoked when the operation completes (this can be
    a lambda function). When that function is called, we can call `IAsyncOperation<T>::GetResults()`
    to get the actual `StorageFile` object:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的一种方法是将`Completed`属性（一个委托）设置为一个处理程序方法，当操作完成时将调用该方法（这可以是一个lambda函数）。当调用该函数时，我们可以调用`IAsyncOperation<T>::GetResults()`来获取实际的`StorageFile`对象：
- en: '[PRE76]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Unfortunately, that's not the end of it. Once the file is available, we need
    to open it, convert its data into a WinRT stream interface and then feed it to
    a `BitmapImage` object that can be rendered into an `Image` element.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，这还没结束。一旦文件可用，我们需要打开它，将其数据转换为WinRT流接口，然后将其提供给一个`BitmapImage`对象，该对象可以呈现为`Image`元素。
- en: 'It turns out that opening a `StorageFile` is an asynchronous operation, too
    (remember, that file can be from anywhere, such as SkyDrive or a network share).
    We repeat the same sequence after the file is obtained:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 原来打开`StorageFile`也是一个异步操作（记住，该文件可以来自任何地方，比如SkyDrive或网络共享）。在获得文件之后，我们重复相同的顺序：
- en: '[PRE77]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`_image` is the `Image` element that should display the resulting image using
    its `Source` property.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`_image`是应该使用其`Source`属性显示结果图像的`Image`元素。'
- en: This almost works. The "almost" part is a bit subtle. The previous lambda is
    called by a different thread than the thread that initiated the call. The UI thread
    started it, but it returned on a background thread. Accessing UI elements (such
    as the `Image` element) from a background thread causes an exception to be thrown.
    How can we fix that?
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎可以工作。"几乎"部分有点微妙。前面的lambda是由不同的线程调用的，而不是启动调用的线程。UI线程启动了它，但它在后台线程上返回。从后台线程访问UI元素（如`Image`元素）会导致抛出异常。我们该如何解决这个问题呢？
- en: 'We can use the `Dispatcher` object that is bound to a particular thread in
    the case of the UI and ask it to execute some piece of code (specified typically
    as a lambda) on the UI thread:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与UI线程绑定的`Dispatcher`对象，并要求它在UI线程上执行一些代码（通常指定为lambda）：
- en: '[PRE78]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`Dispatcher` is a property of `this` (or any UI element for that matter), that
    posts an operation to be executed by the UI thread when possible (typically almost
    immediately, assuming the UI thread is not blocked, which we work very hard to
    avoid).'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispatcher`是`this`（或任何UI元素）的属性，它在可能时将操作发布到UI线程上执行（通常几乎立即，假设UI线程没有被阻塞，我们非常努力地避免这种情况）。'
- en: This whole sequence was not easy, and adding the `Dispatcher` to the mix complicates
    things further. Fortunately, there is an easier way to work with asynchronous
    operations—using the `task<T>` class.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 整个序列并不容易，并且将`Dispatcher`添加到混合物中会进一步复杂化事情。幸运的是，有一种更简单的方法来处理异步操作——使用`task<T>`类。
- en: Using tasks for asynchronous operations
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用任务进行异步操作
- en: The `task<T>` class resides in the concurrency namespace and requires `#include`
    to `<ppltasks.h>`. This class is new to C++11, and is generally related to parallel
    programming, but here it serves a special purpose for invoking asynchronous operations.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`task<T>`类位于concurrency命名空间中，并需要`#include`到`<ppltasks.h>`。这个类是C++11中的新类，通常与并行编程有关，但在这里它为调用异步操作提供了特殊的目的。'
- en: 'The `task<T>` class represents an operation whose result is of type `T`. It
    handles the gory details of the `Completed` property registration, calling `GetResults`,
    and using the `Dispatcher` automatically to maintain thread affinity in case the
    operation was invoked from the UI thread (technically, a call from a Single Threaded
    Apartment). And all this with nice composition in case we need to invoke several
    asynchronous operations in sequence (which is true for the case in hand). Here''s
    the complete code:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`task<T>`类表示其结果为`T`类型的操作。它处理`Completed`属性注册的繁琐细节，调用`GetResults`，并自动使用`Dispatcher`来保持线程关联，以防操作是从UI线程（技术上是从单线程公寓）调用的。并且所有这些都可以很好地组合，以便我们需要按顺序调用几个异步操作（对于手头的情况是真实的）。以下是完整的代码：'
- en: '[PRE79]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `create_task<T>` function is a convenience that creates a `task<T>` with
    the correct `T`; `create_task<T>` allows using the `auto` keyword. An equivalent
    alternative would be this:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_task<T>`函数是一个方便的函数，它使用正确的`T`创建一个`task<T>`；`create_task<T>`允许使用`auto`关键字。一个等效的替代方法是：'
- en: '[PRE80]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The then instance method expects a function (sometimes called continuation,
    typically a lambda) that should execute upon completion of the asynchronous operation.
    It provides the result without any need to call `IAsyncOperation<T>::GetResults()`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 然后实例方法期望一个函数（有时称为continuation，通常是lambda），该函数应在异步操作完成时执行。它提供结果，无需调用`IAsyncOperation<T>::GetResults()`。
- en: Notice the composition. After the `StorageFile` is available, another task is
    created and returned from the lambda. This initiates yet another asynchronous
    operation, to be resolved by the next `then` call.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 注意组合。在`StorageFile`可用之后，另一个任务被创建并从lambda返回。这启动了另一个异步操作，将由下一个`then`调用解决。
- en: Finally, the continuations run on the same thread as the operation initiator,
    if that initiator is running in an STA (which is the case for the UI thread).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，continuations在与操作发起者相同的线程上运行，如果该发起者在STA（这是UI线程的情况）中运行。
- en: Note
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This apartment awareness only works for operations returning `IAsyncAction<T>`
    or `IAsyncOperation<T>` (and their derivatives).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 该公寓意识仅适用于返回`IAsyncAction<T>`或`IAsyncOperation<T>`（及其派生类）的操作。
- en: Cancelling asynchronous operations
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消异步操作
- en: An asynchronous operation, by definition, may be long running, so it's a good
    idea to expose an ability to cancel the operation (if possible). The `IAsync*`
    family of interfaces have a `Cancel` method that we can call (for example, from
    some **Cancel** button's click event handler), but it's difficult to expose the
    `IAsync*` object to outside code.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 按定义，异步操作可能会长时间运行，因此最好提供取消操作的能力（如果可能）。`IAsync*`接口族有一个`Cancel`方法，我们可以调用它（例如，从某个**Cancel**按钮的单击事件处理程序），但很难将`IAsync*`对象暴露给外部代码。
- en: 'Fortunately, the `task<>` class provides an elegant solution. A second parameter
    to the task constructor (or the `create_task` auxiliary function) is a `cancellation_token`
    object. This token is obtained from a `cancellation_token_source` object using
    its `get_token()` instance method. `cancellation_token_source` represents an operation
    that is cancellable. An outside caller can use its `cancel()` method to "signal"
    all `cancellation_token` objects (typically just one) that were handed out by
    the `cancellation_token_source`, causing the task(s) to call the `IAsync*::Cancel`
    method. The following diagram illustrates the process:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`task<>`类提供了一个优雅的解决方案。任务构造函数（或`create_task`辅助函数）的第二个参数是一个`cancellation_token`对象。这个令牌是从`cancellation_token_source`对象使用其`get_token()`实例方法获得的。`cancellation_token_source`表示一个可取消的操作。外部调用者可以使用它的`cancel()`方法来“信号”所有由`cancellation_token_source`分发的`cancellation_token`对象（通常只有一个），从而导致任务调用`IAsync*::Cancel`方法。以下图表说明了这个过程：
- en: '![Cancelling asynchronous operations](img/5022_02_21.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: 取消异步操作
- en: 'The net result is that if an operation is cancelled, a `task_canceled` exception
    is thrown. It''s propagated (if unhandled) down the `then` chain, so that it can
    be caught conveniently on the last `then`—in fact, it''s better to add a last
    `then` that does cancellation (and error) handling only:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的结果是，如果操作被取消，将抛出一个`task_canceled`异常。它会（如果未处理）在`then`链中传播，以便可以方便地在最后一个`then`上捕获它——实际上，最好添加一个最后的`then`，只处理取消（和错误）：
- en: '[PRE81]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `task<>::get()` method is the one throwing the exceptions. Note that `task_canceled`
    does not derive from `Platform::Exception`, so it needs a separate `catch` clause
    to be caught.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`task<>::get()`方法会抛出异常。请注意，`task_canceled`不是从`Platform::Exception`派生的，因此需要一个单独的`catch`子句来捕获它。'
- en: Note
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some operations simply return a `nullptr` object to indicate cancellation. This
    is the case with the `FileOpenPicker` example. If the `StorageFile` object returned
    is `nullptr`, this means the user selected the **Cancel** button when selecting
    a file.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 有些操作只是返回一个`nullptr`对象来表示取消。这是`FileOpenPicker`示例的情况。如果返回的`StorageFile`对象是`nullptr`，这意味着用户在选择文件时选择了**Cancel**按钮。
- en: Error handling
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: In asynchronous operations, exceptions may be thrown. One way to handle those
    is by adding `try`/`catch` blocks to the appropriate continuations. A more convenient
    approach is to handle all errors in the last `then` continuation, in much the
    same way as cancellation.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步操作中，可能会抛出异常。处理这些异常的一种方法是在适当的延续中添加`try`/`catch`块。一个更方便的方法是在最后的`then`延续中处理所有错误，就像取消一样。
- en: Using existing libraries
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现有库
- en: WinRT is a new library we want to use to get access to Windows 8 features in
    this new Store apps model. What about existing C++ libraries, such as the **Standard
    Template Library** (**STL**), **Active Template Library** (**ATL**), **Microsoft
    Foundation Classes** (**MFC**), or some other custom libraries? What about the
    raw Win32 API? In the following sections, we'll address the common Microsoft libraries
    and their use in Windows 8 Store apps.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT是一个新的库，我们希望在这个新的商店应用模型中使用它来访问Windows 8的功能。那么现有的C++库，比如标准模板库（STL），活动模板库（ATL），Microsoft基础类（MFC），或者其他一些自定义库呢？原始的Win32
    API呢？在接下来的章节中，我们将讨论常见的Microsoft库及它们在Windows 8商店应用中的使用。
- en: STL
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STL
- en: STL is part of the standard C++ libraries (and sometimes considered a synonym
    for it), and is fully supported in Windows 8 Store apps. In fact, some of the
    WinRT type wrappers know about STL, making it easier to interoperate.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: STL是标准C++库的一部分（有时被认为是它的同义词），并且在Windows 8商店应用中得到完全支持。事实上，一些WinRT类型包装器了解STL，使其更容易进行互操作。
- en: MFC
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MFC
- en: MFC library was created more than 20 years ago, to provide a C++ layer over
    the Windows API (Win16 at the time of creation), mostly for easier creation of
    user interface.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: MFC库是在20多年前创建的，用于在Windows API（在创建时是Win16）上提供一个C++层，主要是为了更容易地创建用户界面。
- en: Windows 8 Store apps provide their own user interface that is very far from
    the Windows `User32.dll` APIs (which MFC wraps), making MFC obsolete and unusable
    in the new world. Existing code must be migrated to using XAML, user controls,
    control templates, or whatever is appropriate for the application in question.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 8商店应用提供了自己的用户界面，与MFC包装的Windows `User32.dll` API相去甚远，使得MFC在新世界中已经过时且无法使用。现有代码必须迁移到使用XAML、用户控件、控件模板或适用于特定应用程序的其他内容。
- en: ATL
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ATL
- en: ATL was created to assist in building COM servers and clients, easing the burden
    of implementing common functionality such as `IUnknown`, class factories, component
    registration, and the like. It can technically be used in Windows Store apps,
    but there's really no point. Anything on that level is covered by the WRL that
    was discussed earlier in this chapter.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: ATL是为了帮助构建COM服务器和客户端而创建的，简化了实现常见功能（如`IUnknown`，类工厂，组件注册等）的负担。它在理论上可以在Windows商店应用中使用，但实际上没有什么意义。这个层次的任何东西都已经被本章前面讨论过的WRL所覆盖。
- en: Win32 API
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Win32 API
- en: Win32 API (or the Windows API) is a huge set of mostly C-style functions and
    some COM component that has been, and still is, the low-level API to the Windows
    OS in user mode.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 API（或Windows API）是一个庞大的主要是C风格函数和一些COM组件的集合，它一直是用户模式下Windows操作系统的低级API。
- en: 'Every documented function now includes an "applied to" clause, stating whether
    that API is usable in desktop apps, Store apps, or both. Why would some functions
    be unavailable in a Windows Store app? A few reasons:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个文档化的函数都包括一个“应用于”条款，说明该API是否可在桌面应用、商店应用或两者中使用。为什么一些函数在Windows商店应用中不可用？有几个原因：
- en: Some functions are related to a user interface that is inappropriate for Windows
    Store. For example, `MessageBox` and `CreateWindowEx`.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些函数与不适合Windows商店的用户界面相关。例如，`MessageBox`和`CreateWindowEx`。
- en: Some functions have equivalents in the WinRT API (which is usually superior).
    For example `CreateFile` (although a new `CreateFile2` API exists that works with
    Store apps as well), `CreateThread`, and `QueueUserWorkItem`.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些函数在WinRT API中有等价物（通常更好）。例如`CreateFile`（虽然有一个新的`CreateFile2` API也适用于商店应用），`CreateThread`和`QueueUserWorkItem`。
- en: Some functions are inappropriate in some other way, such as violating security
    constraints. For example `CreateProcess` and `EnumWindows`.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些函数以其他方式不适用，比如违反安全约束。例如`CreateProcess`和`EnumWindows`。
- en: Using a forbidden API fails to compile; that's because the Windows API headers
    have been changed to conditionally compile based on two constants, `WINAPI_PARTITION_APP`
    (for Store apps) and `WINAPI_PARTITION_DESKTOP` (for desktop apps).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 使用被禁止的API会导致编译失败；这是因为Windows API头文件已经根据两个常量`WINAPI_PARTITION_APP`（用于商店应用）和`WINAPI_PARTITION_DESKTOP`（用于桌面应用）进行了条件编译的更改。
- en: 'Theoretically, it''s possible to redefine a forbidden function and call it.
    Here''s an example that would work for the `MessageBox` function:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，可以重新定义一个被禁止的函数并调用它。以下是一个对`MessageBox`函数有效的示例：
- en: '[PRE82]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Linking to the appropriate library is required in this case, as `user32.dll`
    is not linked in, by default.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，需要链接到适当的库，因为默认情况下没有链接到`user32.dll`。
- en: 'Although this works, and a message box would appear if this function is called,
    don''t do it. The reason is simple: the Windows 8 Store certification process
    will fail any application that uses a forbidden API.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这样可以工作，如果调用这个函数，消息框会出现，但不要这样做。原因很简单：Windows 8商店认证流程将拒绝使用任何使用被禁止API的应用程序。
- en: Note
  id: totrans-461
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on the allowed Windows API functions can be found at [http://msdn.microsoft.com/en-us/library/windows/apps/br205757](http://msdn.microsoft.com/en-us/library/windows/apps/br205757).
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 有关允许的Windows API函数的更多信息可以在[http://msdn.microsoft.com/en-us/library/windows/apps/br205757](http://msdn.microsoft.com/en-us/library/windows/apps/br205757)找到。
- en: CRT
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRT
- en: The **C Runtime** (**CRT**) library contains a slew of functions, originally
    created as the support library for the C language. Many of those functions are
    unavailable in Store apps; usually there is a Win32 or WinRT equivalent. For a
    comprehensive list of unsupported functions, refer to [http://msdn.microsoft.com/EN-US/library/jj606124.aspx](http://msdn.microsoft.com/EN-US/library/jj606124.aspx).
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**C Runtime** (**CRT**)库包含大量函数，最初是作为C语言的支持库创建的。其中许多函数在商店应用中不可用；通常有Win32或WinRT的等效函数。有关不受支持函数的全面列表，请参阅[http://msdn.microsoft.com/EN-US/library/jj606124.aspx](http://msdn.microsoft.com/EN-US/library/jj606124.aspx)。'
- en: DirectX
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DirectX
- en: DirectX is a set of low-level, COM-based APIs, originally created more than
    20 years ago, for the purpose of accessing the multimedia capabilities of the
    PC (graphics, audio, input, and so on) while leveraging the hardware capabilities
    (such as the graphic card). DirectX has been used for years mostly in the gaming
    industry.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: DirectX是一组基于低级COM的API，最初是在20多年前创建的，用于访问PC的多媒体功能（图形、音频、输入等），同时利用硬件能力（如图形卡）。DirectX多年来主要在游戏行业中使用。
- en: Windows 8 comes with DirectX 11.1 installed, providing a base for creating high
    performance games and applications. It's fully supported with Store apps, and
    can even coexist with XAML-based UI.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 8预装了DirectX 11.1，为创建高性能游戏和应用程序提供了基础。它完全支持商店应用，甚至可以与基于XAML的UI共存。
- en: C++ AMP
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ AMP
- en: 'The C++ **Accelerated Massive Parallelism** (**AMP**)is a relatively new library
    that has a lofty goal: the ability to use a mainstream programming language (C++)
    to execute code on CPU and non-CPU devices. Currently, the only other supported
    device is the **Graphics Processing Unit** (**GPU**).'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: C++ **加速大规模并行性** (**AMP**)是一个相对较新的库，其目标是使用主流编程语言（C++）在CPU和非CPU设备上执行代码。目前，唯一支持的其他设备是**图形处理单元**
    (**GPU**)。
- en: Modern GPUs are capable of much parallelism, but originally they have their
    own languages for programming arbitrary algorithms that may be unrelated to graphics
    per se. C++ AMP is an attempt to work with C++, but still be able to run the GPU
    (and other devices in the future).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 现代GPU具有很强的并行性，但最初它们有自己的编程语言，用于编写可能与图形本身无关的任意算法。C++ AMP是一种尝试使用C++来运行GPU（以及将来的其他设备）的方法。
- en: C++ AMP is fully supported with Windows 8 Store apps (and requires a DirectX
    11 capable card).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: C++ AMP完全支持Windows 8商店应用（需要DirectX 11兼容的显卡）。
- en: The Windows Runtime class library
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows Runtime类库
- en: WinRT provides a comprehensive class library, arranged in hierarchical namespaces;
    from strings and collections, to controls, to devices, to networking, to graphics;
    the API covers a lot of ground. Part of the journey into Windows Store apps is
    learning the various APIs and capabilities that are supported. This kind of knowledge
    evolves with time. During the course of this book, we'll discuss a fair amount
    of WinRT APIs, but certainly not all of it.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT提供了一个全面的类库，按照层次命名空间排列；从字符串和集合，到控件，到设备，到网络，到图形；API涵盖了很多领域。进入Windows商店应用的旅程之一就是学习各种受支持的API和功能。这种知识会随着时间的推移而不断发展。在本书的过程中，我们将讨论相当多的WinRT
    API，但肯定不是全部。
- en: In the following sections, we'll discuss some of the core types that are used
    frequently with Store apps and how they are mapped specifically (if at all) to
    C++.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论一些在商店应用中经常使用的核心类型，以及它们如何（如果有的话）特定地映射到C++。
- en: Strings
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: WinRT defines its own string type, `HSTRING`. We have already met it a few times.
    Since `HSTRING` is just an opaque handle to an immutable string, Windows provides
    some functions for managing `HSTRING`, such as `WindowsCreateString` , `WindowsConcatString`
    , `WindowsSubString` , `WIndowsGetStringLen` , `WindowsReplaceString` , and others.
    Working with these APIs is not difficult, but very tedious.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT定义了自己的字符串类型`HSTRING`。我们已经多次遇到它。由于`HSTRING`只是不可变字符串的不透明句柄，Windows提供了一些用于管理`HSTRING`的函数，如`WindowsCreateString`、`WindowsConcatString`、`WindowsSubString`、`WIndowsGetStringLen`、`WindowsReplaceString`等。使用这些API并不困难，但非常繁琐。
- en: 'Fortunately, an `HSTRING` is wrapped by a reference counted class, `Platform::String`,
    which provides the necessary calls behind the scenes to the appropriate APIs.
    It can be constructed given a raw Unicode character pointer (`wchar_t*`) and has
    a `Data()` method that returns a raw pointer back. This means that interoperating
    `Platform::String` with `std::wstring` is fairly easy. Here are a few example
    of using strings:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一个`HSTRING`被一个引用计数类`Platform::String`包装，它在幕后提供了对适当API的必要调用。它可以根据原始Unicode字符指针（`wchar_t*`）构造，并且具有返回原始指针的`Data()`方法。这意味着在`Platform::String`与`std::wstring`之间进行互操作相当容易。以下是使用字符串的一些示例：
- en: '[PRE83]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Notice the iterator-like behavior achieved with `Platform::begin` and `Platform::end`.
    As a general guideline, when authoring components, it's better to work with a
    `std::wstring` for all string operations, as `wstring` has a rich function set.
    Use `Platform::String` only at the ABI boundary; `Platform::String` has very little
    functionality built in.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`Platform::begin`和`Platform::end`实现的迭代器行为。一般指导原则是，在编写组件时，最好使用`std::wstring`进行所有字符串操作，因为`wstring`具有丰富的函数集。只在ABI边界处使用`Platform::String`；`Platform::String`内置的功能非常有限。
- en: Collections
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: Standard C++ defines several container types, such as `std::vector<T>`, `std::list<T>`,
    `std::map<K, V>`, and others. These types, however, cannot cross the ABI boundary—they
    are C++ specific.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C++定义了几种容器类型，如`std::vector<T>`、`std::list<T>`、`std::map<K, V>`等。然而，这些类型不能跨ABI边界——它们是特定于C++的。
- en: 'WinRT defines its own collection interfaces that must be used across the ABI
    boundary. Here''s a class diagram with those interfaces:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT定义了自己的集合接口，必须跨ABI边界使用。以下是带有这些接口的类图：
- en: '![Collections](img/5022_02_22.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_IMG
  zh: '![集合](img/5022_02_22.jpg)'
- en: '`IIterable<T>` has just one method: `First`, which returns an `IIterator<T>`,
    which is the WinRT iterator interface. It defines the methods `MoveNext` and `GetMany`
    and two properties: `Current` returns the current object the iterator points to
    and `HasCurrent` indicates whether there are any more items to iterate over.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`IIterable<T>`只有一个方法：`First`，它返回一个`IIterator<T>`，这是WinRT迭代器接口。它定义了`MoveNext`和`GetMany`方法以及两个属性：`Current`返回迭代器指向的当前对象，`HasCurrent`指示是否还有更多的项目可以迭代。'
- en: '`IVector<T>` represents a sequence of items that are accessible by index. It''s
    a common type to use across the ABI. The C++ support library provides a stock
    implementation for `IVector<T>` named `Platform::Collections::Vector<T>`. This
    could be used as the underlying private type within a WinRT class, because it''s
    convertible to `IVector<T>` when needed. Note, however, that for heavy duty operations
    the STL `std::vector<T>` is more efficient. If `Vector<T>` is needed at some point,
    it has many constructors, some of which accept `std::vector<T>`.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`IVector<T>`表示可以通过索引访问的项目序列。这是ABI中常用的类型。C++支持库为`IVector<T>`提供了一个名为`Platform::Collections::Vector<T>`的标准实现。这可以作为WinRT类中的基础私有类型，因为在需要时它可以转换为`IVector<T>`。但是，请注意，对于重型操作，STL
    `std::vector<T>`更有效率。如果在某个时候需要`Vector<T>`，它有许多构造函数，其中一些接受`std::vector<T>`。'
- en: '`IVectorView<T>` represents a read only view into a vector. It can be obtained
    from an `IVector<T>` by calling the `GetView` method. `VectorView<T>` is a C++
    private implementation that may be used if needed by custom implementations of
    `IVector<T>`.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`IVectorView<T>`表示对向量的只读视图。可以通过调用`GetView`方法从`IVector<T>`中获取。`VectorView<T>`是一个C++私有实现，如果需要，可以用于`IVector<T>`的自定义实现。'
- en: '`IObservableVector<T>` inherits from `IVector<T>` and adds a single event,
    `VectorChanged`. This may be useful for clients that want notifications when items
    are added, removed, or replaced in the `IObservableVector<T>`.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '`IObservableVector<T>`继承自`IVector<T>`并添加了一个事件`VectorChanged`。这对于希望在`IObservableVector<T>`中添加、移除或替换项目时收到通知的客户端可能很有用。'
- en: The `IMap*` series of interfaces manage key/value pairs, and are transferrable
    across the ABI boundary. `Platform::Collections::Map<K,V>` provides an implementation
    convertible to this interface, as a balanced binary tree, similar to `std::map<K,V>`
    (including the ability to change the ordering algorithm via a third template argument).
    `IMapView<K,V>` is a read-only view of a `IMap<K,V>`.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMap*`系列接口管理键/值对，并且可以在ABI边界上进行传输。`Platform::Collections::Map<K,V>`提供了一个可转换为此接口的实现，作为一个平衡的二叉树，类似于`std::map<K,V>`（包括通过第三个模板参数改变排序算法的能力）。`IMapView<K,V>`是`IMap<K,V>`的只读视图。'
- en: Note
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The most useful collection type for the ABI is `IVector<T>`. If you can live
    with `Vector<T>` as the underlying implementation, do so. Otherwise, maintain
    a `std::vector<T>` and convert to `IVector<T>` only when crossing the ABI boundary.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: ABI中最有用的集合类型是`IVector<T>`。如果可以接受`Vector<T>`作为基础实现，请这样做。否则，保持`std::vector<T>`，并且只在跨越ABI边界时转换为`IVector<T>`。
- en: Exceptions
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: COM/WinRT does not work with exceptions. The reason may be obvious, exceptions
    are language or platform specific. They cannot be part of a binary standard that
    various platforms adhere to. Instead, COM uses `HRESULT`, which are just 32-bit
    numbers to indicate the success or failure of method calls.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: COM/WinRT不使用异常。原因可能很明显，异常是特定于语言或平台的。它们不能成为各种平台遵循的二进制标准的一部分。相反，COM使用`HRESULT`，它们只是32位数字，用于指示方法调用的成功或失败。
- en: C++, however (and most other modern languages, such as C#) support the notion
    of exceptions. Handling errors by catching exceptions is far easier and maintainable
    than checking `HRESULT` after each call (C-style of programming). That's why the
    calls made through C++/CX reference counted object (hat) translates a failed `HRESULT`
    into an exception object, derived from `Platform::Exception` that can be caught
    in the usual way.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C++（以及大多数其他现代语言，如C#）支持异常的概念。通过捕获异常来处理错误比在每次调用后检查`HRESULT`要容易得多，并且更易于维护（C风格的编程）。这就是为什么通过C++/CX引用计数对象（帽子）进行的调用将失败的`HRESULT`转换为异常对象，该对象派生自`Platform::Exception`，可以以通常的方式捕获。
- en: This is also true the other way around; when implementing a component in C++/CX,
    the code can throw an exception derived from `Platform::Exception`; this exception
    cannot cross the ABI; instead, it's translated to an equivalent `HRESULT`, which
    is the thing that can cross the ABI. On the other side, it may be turned into
    an exception object again for that client platform, such as a C++ exception or
    a .NET exception.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于另一种情况；在C++/CX中实现组件时，代码可能会抛出一个派生自`Platform::Exception`的异常；这种异常不能跨越ABI；相反，它被转换为等效的`HRESULT`，这是可以跨越ABI的东西。另一方面，它可能会再次转换为异常对象，例如C++异常或.NET异常，以供客户端平台使用。
- en: 'The list of exception types deriving from `Platform::Exception` is predefined
    and cannot be extended, because each type maps directly to an `HRESULT`. This
    means it''s not possible to add new exception types, because C++/CX can''t know
    to which `HRESULT` to translate the exception when crossing the ABI. For custom
    exceptions, `Platform::COMException` can be used with some custom `HRESULT`. The
    complete table of exception types and their `HRESULT` equivalent is shown, as
    follows:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Platform::Exception`派生的异常类型列表是预定义的，不能扩展，因为每种类型直接映射到一个`HRESULT`。这意味着不可能添加新的异常类型，因为C++/CX无法知道将异常转换为哪个`HRESULT`，当跨越ABI时。对于自定义异常，可以使用带有自定义`HRESULT`的`Platform::COMException`。异常类型及其`HRESULT`等效的完整表格如下所示：
- en: '![Exceptions](img/5022_02_23.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![异常](img/5022_02_23.jpg)'
- en: Most of the exception types in the table are self-explanatory. We'll discuss
    some of these exceptions later in the book.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 表中大多数异常类型都是不言自明的。我们将在本书的后面讨论其中一些异常。
- en: Note
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Throwing something that does not inherit from `Platform::Exception` will be
    translated to an `E_FAIL` `HRESULT`.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出一个不继承自`Platform::Exception`的对象将被转换为`E_FAIL` `HRESULT`。
- en: All exception types have an `HResult` property with the underlying `HRESULT`
    value and a `Message` property, which is a textual description of the exception
    (supplied by WinRT and cannot be changed).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 所有异常类型都有一个`HResult`属性，其中包含基础的`HRESULT`值，还有一个`Message`属性，这是异常的文本描述（由WinRT提供，无法更改）。
- en: Summary
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter started with some of the new C++11 features that may be useful
    for WinRT development. We discussed COM, its concepts and ideas and how they are
    translated into WinRT. WRL provides helpers for accessing WinRT objects without
    language extensions. C++/CX provides language extensions that make it far easier
    to work with WinRT and to author WinRT components.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从一些可能对WinRT开发有用的新C++11特性开始。我们讨论了COM，它的概念和思想，以及它们如何转化为WinRT。WRL提供了访问WinRT对象的帮助程序，而无需语言扩展。C++/CX提供了语言扩展，使得与WinRT的工作和编写WinRT组件变得更加容易。
- en: WinRT has some patterns and idioms we need to learn and get used to, such as
    ways to work with asynchronous operations, strings, collections, and error handling.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT有一些模式和习惯用法，我们需要学习和适应，比如处理异步操作、字符串、集合和错误处理的方法。
- en: The coverage in this chapter was not exhaustive, but it should give us enough
    power and understanding to start writing real applications. We'll take a look
    at some other C++/CX capabilities and other WinRT-related features in later parts
    of the book.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的覆盖范围并不全面，但应该足够让我们有能力和理解开始编写真实的应用程序。我们将在本书的后面部分看一些其他C++/CX的能力和其他与WinRT相关的特性。
- en: In the next chapter, we'll dive into building applications, starting with XAML
    and the way user interfaces are commonly built in WinRT.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入构建应用程序，从XAML开始，以及在WinRT中通常构建用户界面的方式。
