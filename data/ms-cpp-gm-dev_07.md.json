["```cpp\nGLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);\n```", "```cpp\nGLchar* shaderCode = LoadShader(\"shaders/simple.vert\");\nglShaderSource(vertexShader, 1, shaderCode, NULL);\n```", "```cpp\nglCompileShader(vertexShader);\n```", "```cpp\nGLuint shaderProgram = glCreateProgram();\n```", "```cpp\nglAttachShader(shaderProgram, vertexShader);\nglAttachShader(shaderProgram, fragmentShader);\n```", "```cpp\nglLinkProgram(programHandle);\n```", "```cpp\nvoid ShaderManager::CompileShaders(const std::string&                        \n                        vertexShaderFilePath, const std::string&      \n                        fragmentShaderFilepath)\n{\n   m_programID = glCreateProgram();\n   m_vertexShaderID = glCreateShader(GL_VERTEX_SHADER);\n   if (m_vertexShaderID == 0){\n      Exception(\"Vertex shader failed to be created!\");\n   }\n   m_fragmentShaderID = glCreateShader(GL_FRAGMENT_SHADER);\n   if (m_fragmentShaderID == 0){\n    Exception(\"Fragment shader failed to be created!\");\n   }\n   CompileShader(vertexShaderFilePath, m_vertexShaderID);\n   CompileShader(fragmentShaderFilepath, m_fragmentShaderID);\n}\n```", "```cpp\nvoid ShaderManager::CompileShader(const std::string& filePath, GLuint id) \n{\n  std::ifstream shaderFile(filePath);\n  if (shaderFile.fail()){\n     perror(filePath.c_str());\n     Exception(\"Failed to open \" + filePath);\n  }\n    //File contents stores all the text in the file\n     std::string fileContents = \"\";\n    //line is used to grab each line of the file\n    std::string line;\n   //Get all the lines in the file and add it to the contents\n    while (std::getline(shaderFile, line)){\n    fileContents += line + \"n\";\n }\n   shaderFile.close();\n   //get a pointer to our file contents c string\n   const char* contentsPtr = fileContents.c_str();   //tell opengl that        \n   we want to use fileContents as the contents of the shader file \n  glShaderSource(id, 1, &contentsPtr, nullptr);\n  //compile the shader\n  glCompileShader(id);\n  //check for errors\n  GLint success = 0;\n  glGetShaderiv(id, GL_COMPILE_STATUS, &success);\n  if (success == GL_FALSE){\n    GLint maxLength = 0;\n    glGetShaderiv(id, GL_INFO_LOG_LENGTH, &maxLength);\n    //The maxLength includes the NULL character\n    std::vector<char> errorLog(maxLength);\n    glGetShaderInfoLog(id, maxLength, &maxLength, &errorLog[0]);\n    //Provide the infolog in whatever manor you deem best.\n    //Exit with failure.\n    glDeleteShader(id); //Don't leak the shader.\n    //Print error log and quit\n    std::printf(\"%sn\", &(errorLog[0]));\n        Exception(\"Shader \" + filePath + \" failed to compile\");\n  }\n}\n```", "```cpp\nstd::ifstream shaderFile(filePath);\nif (shaderFile.fail()) {\n  perror(filePath.c_str());\n  Exception(\"Failed to open \" + filePath);\n}\n```", "```cpp\nstd::string fileContents = \"\";\nstd::string line;\nwhile (std::getline(shaderFile, line)) {\n  fileContents += line + \"n\";\n}\nshaderFile.close();\n```", "```cpp\nconst char* contentsPtr = fileContents.c_str();\n```", "```cpp\nglShaderSource(id, 1, &contentsPtr, nullptr);\nglCompileShader(id);\n```", "```cpp\nGLint success = 0;\nglGetShaderiv(id, GL_COMPILE_STATUS, &success);\n```", "```cpp\nif (success == GL_FALSE){\n  GLint maxLength = 0;\n  glGetShaderiv(id, GL_INFO_LOG_LENGTH, &maxLength);\n  std::vector<char> errorLog(maxLength); \n  glGetShaderInfoLog(id, maxLength, &maxLength, &errorLog[0]);\n```", "```cpp\nglDeleteShader(id);\n```", "```cpp\nstd::printf(\"%sn\", &(errorLog[0]));\nException(\"Shader \" + filePath + \" failed to compile\");\n}\n...\n```", "```cpp\nshaderManager.CompileShaders(\"Shaders/SimpleShader.vert\",\n\"Shaders/SimpleShader.frag\");\n```", "```cpp\nvoid ShaderManager::LinkShaders() {\n//Attach our shaders to our program\nglAttachShader(m_programID, m_vertexShaderID);\nglAttachShader(m_programID, m_fragmentShaderID);\n//Link our program\nglLinkProgram(m_programID);\n//Note the different functions here: glGetProgram* instead of glGetShader*.\nGLint isLinked = 0;\nglGetProgramiv(m_programID, GL_LINK_STATUS, (int *)&isLinked);\nif (isLinked == GL_FALSE){\n  GLint maxLength = 0;\n  glGetProgramiv(m_programID, GL_INFO_LOG_LENGTH, &maxLength);\n  //The maxLength includes the NULL character\n  std::vector<char> errorLog(maxLength);\n  glGetProgramInfoLog(m_programID, maxLength, &maxLength,   \n  &errorLog[0]);\n  //We don't need the program anymore.\n  glDeleteProgram(m_programID);\n  //Don't leak shaders either.\n  glDeleteShader(m_vertexShaderID);\n  glDeleteShader(m_fragmentShaderID);\n  //print the error log and quit\n  std::printf(\"%sn\", &(errorLog[0]));\n  Exception(\"Shaders failed to link!\");\n}\n  //Always detach shaders after a successful link.\n  glDetachShader(m_programID, m_vertexShaderID);\n  glDetachShader(m_programID, m_fragmentShaderID);\n  glDeleteShader(m_vertexShaderID);\n  glDeleteShader(m_fragmentShaderID);\n}\n```", "```cpp\nglAttachShader(m_programID, m_vertexShaderID);\nglAttachShader(m_programID, m_fragmentShaderID);\n```", "```cpp\nglLinkProgram(m_programID);\n```", "```cpp\nGLint isLinked = 0;\nglGetProgramiv(m_programID, GL_LINK_STATUS, (int *)&isLinked);\nif (isLinked == GL_FALSE){\n  GLint maxLength = 0;\n  glGetProgramiv(m_programID, GL_INFO_LOG_LENGTH, &maxLength);\n  //The maxLength includes the NULL character\n  std::vector<char> errorLog(maxLength);  \n  glGetProgramInfoLog(m_programID, maxLength, &maxLength,   \n  &errorLog[0]);\n  //We don't need the program anymore.\n  glDeleteProgram(m_programID);\n  //Don't leak shaders either.\n  glDeleteShader(m_vertexShaderID);\n  glDeleteShader(m_fragmentShaderID);\n  //print the error log and quit\n  std::printf(\"%sn\", &(errorLog[0]));\n  Exception(\"Shaders failed to link!\");\n}\n```", "```cpp\n  glDetachShader(m_programID, m_vertexShaderID);\n  glDetachShader(m_programID, m_fragmentShaderID);\n  glDeleteShader(m_vertexShaderID);\n  glDeleteShader(m_fragmentShaderID);\n}\n```", "```cpp\n  shaderManager.LinkShaders();\n```", "```cpp\nin vec3 VertexColour;\n```", "```cpp\n#version 410\nin vec3 VertexPosition;\nin vec3 VertexColour;\nout vec3 Colour;\nvoid main(){\n  Colour = VertexColour;\n  gl_Position = vec4(VertexPosition, 1.0);\n}\n```", "```cpp\n#version 410\nin vec3 Colour;\nout vec4 FragColour;\nvoid main(){\n  FragColour = vec4(Colour, 1.0);\n}\n```", "```cpp\nGLunit vao;\n```", "```cpp\nGLuint vbo[2];\nglGenBuffers(2, vbo);\nGLuint positionBufferHandle = vbo[0];\nGLuint colorBufferHandle = vbo[1];\nglBindBuffer(GL_ARRAY_BUFFER,positionBufferHandle);\nglBufferData(GL_ARRAY_BUFFER,\n             9 * sizeof(float),\n             positionData,\n             GL_STATIC_DRAW);\nglBindBuffer(GL_ARRAY_BUFFER,\n             colorBufferHandle);\nglBufferData(GL_ARRAY_BUFFER,\n             9 * sizeof(float),\n             colorData,\n             GL_STATIC_DRAW);\n```", "```cpp\nglGenVertexArrays( 1, &vao );\nglBindVertexArray(vao);\nglEnableVertexAttribArray(0);\nglEnableVertexAttribArray(1);\nglBindBuffer(GL_ARRAY_BUFFER, positionBufferHandle);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, NULL);\nglBindBuffer(GL_ARRAY_BUFFER, colorBufferHandle);\nglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, NULL);\n```", "```cpp\nglBindVertexArray(vaoHandle);glDrawArrays(GL_TRIANGLES, 0, 3 );\n```", "```cpp\nlayout (location=0) in vec3 VertexPosition;\n```", "```cpp\nuniform mat4 ViewMatrix;\n```", "```cpp\nGLuint location = glGetUniformLocation(programHandle,\" ViewMatrix \");\nif( location >= 0 )\n{\nglUniformMatrix4fv(location, 1, GL_FALSE, &viewMatrix [0][0])\n}\n```", "```cpp\nvoid ShaderManager::AddAttribute(const std::string& attributeName)\n{\nglBindAttribLocation(m_programID,\n                     m_numAttributes++,\n                     attributeName.c_str());\n }\n```", "```cpp\nGLint ShaderManager::GetUniformLocation(const std::string& uniformName)\n{\n    GLint location = glGetUniformLocation(m_programID,\n    uniformName.c_str());\n    if (location == GL_INVALID_INDEX) \n    {\n     Exception(\"Uniform \" + uniformName + \" not found in shader!\");\n    }\n  return location;\n}\n```", "```cpp\nvoid ShaderManager::Use(){\n  glUseProgram(m_programID);\n  for (int i = 0; i < m_numAttributes; i++) { \n    glEnableVertexAttribArray(i);\n  }\n}\n```", "```cpp\nvoid ShaderManager::UnUse() {\n  glUseProgram(0);\n  for (int i = 0; i < m_numAttributes; i++) {\n    glDisableVertexAttribArray(i);\n }\n}\n```", "```cpp\nshaderManager.CompileShaders(\"Shaders/SimpleShader.vert\",\n                             \"Shaders/SimpleShader.frag\");\nshaderManager.AddAttribute(\"vertexPosition_modelspace\");\nshaderManager.AddAttribute(\"vertexColor\");\nshaderManager.LinkShaders();\nMatrixID = shaderManager.GetUniformLocation(\"ModelViewProjection\");\nm_model.Init(\"Meshes/Dwarf_2_Low.obj\", \"Textures/dwarf_2_1K_color.png\");\n```", "```cpp\n  shaderManager.Use();\n  m_model.Draw();\n  shaderManager.UnUse();\n```", "```cpp\n#version 410\nin vec3 vertexPosition_modelspace;\nin vec2 vertexUV;\nin vec3 vertexNormal;\nout vec2 UV;\nout vec3 LightIntensity;\nuniform vec4 LightPosition;\nuniform vec3 DiffuseCoefficient ;\nuniform vec3 LightSourceIntensity;\nuniform mat4 ModelViewProjection;\nuniform mat3 NormalMatrix;\nuniform mat4 ModelViewMatrix;\nuniform mat4 ProjectionMatrix;\nvoid main(){\n    vec3 tnorm = normalize(NormalMatrix * vertexNormal);\n    vec4 CameraCoords = ModelViewMatrix *\n    vec4(vertexPosition_modelspace,1.0);\n    vec3 IncomingLightDirection = normalize(vec3(LightPosition -\n    CameraCoords));\n    LightIntensity = LightSourceIntensity * DiffuseCoefficient *\n                     max( dot( IncomingLightDirection, tnorm ), 0.0 );\n    gl_Position = ModelViewProjection *                   \n                  vec4(vertexPosition_modelspace,1);\n                  UV = vertexUV;\n }\n```", "```cpp\nGLint DiffuseCoefficient =    \n        shaderManager.GetUniformLocation(\"DiffuseCoefficient \");\nglUniform3f(DiffuseCoefficient, 0.9f, 0.5f, 0.3f);\nGLint LightSourceIntensity =    \n       shaderManager.GetUniformLocation(\"LightSourceIntensity \");\nglUniform3f(LightSourceIntensity, 1.0f, 1.0f, 1.0f);\nglm::vec4 lightPos = m_camera.GetView() * glm::vec4(5.0f, 5.0f, 2.0f,              \n                     1.0f);\nGLint lightPosUniform =      \n                shaderManager.GetUniformLocation(\"LightPosition\");\nglUniform4f(lightPosUniform, lightPos[0], lightPos[1], lightPos[2],    \n             lightPos[3]);\nglm::mat4 modelView = m_camera.GetView() * glm::mat4(1.0f);\nGLint modelViewUniform =           \n               shaderManager.GetUniformLocation(\"ModelViewMatrix\");\nglUniformMatrix4fv(modelViewUniform, 1, GL_FALSE, &modelView[0][0]);\nglm::mat3 normalMatrix = glm::mat3(glm::vec3(modelView[0]),     \n                         glm::vec3(modelView[1]),  \n                         glm::vec3(modelView[2]));\nGLint normalMatrixUniform =     \n                   shaderManager.GetUniformLocation(\"NormalMatrix\");\nglUniformMatrix3fv(normalMatrixUniform, 1, GL_FALSE, &normalMatrix[0][0]);\nglUniformMatrix4fv(MatrixID, 1, GL_FALSE, &m_camera.GetMVPMatrix()[0][0]);\n```", "```cpp\nshaderManager.AddAttribute(\"vertexPosition_modelspace\");\nshaderManager.AddAttribute(\"vertexColor\");\nshaderManager.AddAttribute(\"vertexNormal\");\n```", "```cpp\n#version 410\nin vec2 UV;\nin vec3 LightIntensity;\n// Ouput data\nout vec3 color;\n// Values that stay constant for the whole mesh.\nuniform sampler2D TextureSampler;\nvoid main(){\n  color = vec3(LightIntensity);\n}\n```", "```cpp\n#version 410\n// Input vertex data, different for all executions of this shader.\nin vec3 vertexPosition_modelspace;\nin vec2 vertexUV;\nin vec3 vertexNormal;\n// Output data ; will be interpolated for each fragment.\nout vec2 UV;\nout vec3 LightIntensity;\nstruct LightInfo {\n  vec4 Position; // Light position in eye coords.\n  vec3 La; // Ambient light intensity\n  vec3 Ld; // Diffuse light intensity\n  vec3 Ls; // Specular light intensity\n};\nuniform LightInfo Light;\nstruct MaterialInfo {\n  vec3 Ka; // Ambient reflectivity\n  vec3 Kd; // Diffuse reflectivity\n  vec3 Ks; // Specular reflectivity\n  float Shininess; // Specular shininess factor\n};\n  uniform MaterialInfo Material;\n  uniform mat4 ModelViewMatrix;\n  uniform mat3 NormalMatrix;\n  uniform mat4 ProjectionMatrix;\n  uniform mat4 ModelViewProjection;\n  void main(){\n     vec3 tnorm = normalize( NormalMatrix * vertexNormal);\n     vec4 CameraCoords = ModelViewMatrix *                \n                     vec4(vertexPosition_modelspace,1.0);\n     vec3 s = normalize(vec3(Light.Position - CameraCoords));\n     vec3 v = normalize(-CameraCoords.xyz);\n     vec3 r = reflect( -s, tnorm );\n     float sDotN = max( dot(s,tnorm), 0.0 );\n     vec3 ambient = Light.La * Material.Ka;\n     vec3 diffuse = Light.Ld * Material.Kd * sDotN;\n     vec3 spec = vec3(0.0);\n     if( sDotN > 0.0 )\n      spec = Light.Ls * Material.Ks *\n      pow( max( dot(r,v), 0.0 ), Material.Shininess );\n      LightIntensity = ambient + diffuse + spec;\n      gl_Position = ModelViewProjection *\n                vec4(vertexPosition_modelspace,1.0);\n}\n```", "```cpp\nGLint Kd = shaderManager.GetUniformLocation(\"Material.Kd\");\nglUniform3f(Kd, 0.9f, 0.5f, 0.3f);\n```", "```cpp\n#version 410\nin vec3 vertexPosition_modelspace;\nin vec2 vertexUV;\nin vec3 vertexNormal;\nout vec2 UV;\nout vec3 Position;\nout vec3 Normal;\nuniform mat4 ModelViewMatrix;\nuniform mat3 NormalMatrix;\nuniform mat4 ProjectionMatrix;\nuniform mat4 ModelViewProjection;\nvoid main(){\n    UV = vertexUV;\n    Normal = normalize( NormalMatrix * vertexNormal);\n    Position = vec3( ModelViewMatrix *        \n               vec4(vertexPosition_modelspace,1.0));\n    gl_Position = ModelViewProjection *\n                 vec4(vertexPosition_modelspace,1.0);\n}\n```", "```cpp\n#version 410\nin vec3 Position;\nin vec3 Normal;\nin vec2 UV;\nuniform sampler2D TextureSampler;\nstruct LightInfo {\n  vec4 Position; // Light position in eye coords.\n  vec3 Intensity; // A,D,S intensity\n};\nuniform LightInfo Light;\nstruct MaterialInfo {\n  vec3 Ka; // Ambient reflectivity\n  vec3 Kd; // Diffuse reflectivity\n  vec3 Ks; // Specular reflectivity\n  float Shininess; // Specular shininess factor\n};\nuniform MaterialInfo Material;\nout vec3 color;\nvoid phongModel( vec3 pos, vec3 norm, out vec3 ambAndDiff, out vec3\nspec ) {\n  vec3 s = normalize(vec3(Light.Position) - pos);\n  vec3 v = normalize(-pos.xyz);\n  vec3 r = reflect( -s, norm );\n  vec3 ambient = Light.Intensity * Material.Ka;\n  float sDotN = max( dot(s,norm), 0.0 );\n  vec3 diffuse = Light.Intensity * Material.Kd * sDotN;\n  spec = vec3(0.0);\n  if( sDotN > 0.0 )\n   spec = Light.Intensity * Material.Ks *\n        pow( max( dot(r,v), 0.0 ), Material.Shininess );\n        ambAndDiff = ambient + diffuse;\n}\nvoid main() {\n   vec3 ambAndDiff, spec;\n   vec3 texColor = texture( TextureSampler, UV ).rbg;\n   phongModel( Position, Normal, ambAndDiff, spec );\n   color = (vec3(ambAndDiff * texColor) + vec3(spec));\n }\n```", "```cpp\n#version 410\n// Input vertex data, different for all executions of this shader.\nin vec3 vertexPosition_modelspace;\nin vec2 vertexUV;\nin vec3 vertexNormal;\nout vec3 FrontColor;\nout vec3 BackColor;\nout vec2 UV;\nstruct LightInfo {\nvec4 Position; // Light position in eye coords.\nvec3 La; // Ambient light intensity\nvec3 Ld; // Diffuse light intensity\nvec3 Ls; // Specular light intensity\n};\nuniform LightInfo Light;\nstruct MaterialInfo {vec3 Ka; // Ambient reflectivity\nvec3 Kd; // Diffuse reflectivity\nvec3 Ks; // Specular reflectivity\nfloat Shininess; // Specular shininess factor\n};\nuniform MaterialInfo Material;\nuniform mat4 ModelViewMatrix;\nuniform mat3 NormalMatrix;\nuniform mat4 ProjectionMatrix;\nuniform mat4 ModelViewProjection;\nvoid getCameraSpace( out vec3 norm, out vec4 position )\n{\nnorm = normalize( NormalMatrix * vertexNormal);\nposition = ModelViewMatrix * vec4(vertexPosition_modelspace,1.0);\n}\nvec3 phongModel( vec4 position, vec3 norm )\n{\n...\n//Same as previous examples\n...}\nvoid main()\n{\nvec3 cameraNorm;\nvec4 cameraPosition;\nUV = vertexUV;\n// Get the position and normal in eye space\ngetCameraSpace(cameraNorm, cameraPosition);\nFrontColor = phongModel( cameraPosition, cameraNorm );\nBackColor = phongModel( cameraPosition, -cameraNorm );\ngl_Position = ModelViewProjection *\nvec4(vertexPosition_modelspace,1.0);\n}\n```", "```cpp\n#version 410\nin vec3 FrontColor;\nin vec3 BackColor;\nin vec2 UV;\nout vec4 FragColor;\nvoid main() {\nconst float scale = 105.0;\nbvec2 toDiscard = greaterThan( fract(UV * scale), vec2(0.2,0.2) );\nif( all(toDiscard) )\ndiscard;\nelse {\nif( gl_FrontFacing )\nFragColor = vec4(FrontColor, 1.0);\nelse\nFragColor = vec4(BackColor, 1.0);\n}\n}\n```", "```cpp\n#version 410\nin vec3 VertexInitVel; // Particle initial velocity\nin float StartTime; // Particle \"birth\" time\nout float Transp; // Transparency of the particle\nuniform float Time; // Animation time\nuniform vec3 Gravity = vec3(0.0,-0.05,0.0); // world coords\nuniform float ParticleLifetime; // Max particle lifetime\nuniform mat4 ModelViewProjection;\nvoid main()\n{\n// Assume the initial position is (0,0,0).\nvec3 pos = vec3(0.0);\nTransp = 0.0;\n// Particle dosen't exist until the start time\nif( Time > StartTime ) {\nfloat t = Time - StartTime;\nif( t < ParticleLifetime ) {\npos = VertexInitVel * t + Gravity * t * t;\nTransp = 1.0 - t / ParticleLifetime;\n}\n}\n// Draw at the current position\ngl_Position = ModelViewProjection * vec4(pos, 1.0);\n}\n```", "```cpp\n#version 410\nin float Transp;\nuniform sampler2D ParticleTex;\nout vec4 FragColor;\nvoid main()\n{\nFragColor = texture(ParticleTex, gl_PointCoord);\nFragColor.a *= Transp;\n}\n```", "```cpp\nglDisable(GL_DEPTH_TEST);\nglEnable(GL_BLEND);\nglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n```", "```cpp\nglPointSize(10.0f);\n```"]