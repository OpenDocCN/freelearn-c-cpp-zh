- en: Chapter 1. Instant MinGW Starter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 立即开始使用 MinGW
- en: Welcome to *Instant MinGW Starter*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎使用 *立即开始使用 MinGW*。
- en: This book has been especially created to provide you with all the information
    that you need to start developing applications with MinGW software. You will get
    to know the basic skills to work with MinGW software and discover some tips and
    tricks for using it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书特别创建，旨在为您提供所有开始使用 MinGW 软件开发应用程序所需的信息。您将了解与 MinGW 软件一起工作的基本技能，并发现一些使用它的技巧和窍门。
- en: 'This book contains the following sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含以下章节：
- en: '*So, what is MinGW?* – This section describes what MinGW actually is, its common
    components, and what you can do with it.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，MinGW 是什么？* – 本节描述了 MinGW 实际上是什么，其常见组件以及您可以用它做什么。'
- en: '*Installation* – In this section you will learn how to download and install
    MinGW software with minimum fuss and then set it up so that you can use it as
    soon as possible.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*安装* – 在本节中，您将学习如何以最少的麻烦下载和安装 MinGW 软件，然后设置它，以便您可以尽快使用。'
- en: '*Quick start – Creating your first MinGW project* – This section will show
    you how to create a new application with MinGW software step by step. It will
    be the basis of most your work with MinGW.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*快速入门 – 创建您的第一个 MinGW 项目* – 本节将逐步向您展示如何使用 MinGW 软件创建新的应用程序。这将是您大部分 MinGW 工作的基础。'
- en: '*Top features you''ll want to know about* – Here, you will learn how to perform
    some tasks with the most important features of MinGW. By the end of this section
    you will be able to use the GNU Make utility for effectively building your projects,
    importing existing Visual C++ projects to MinGW software, developing applications
    based on cross-platform GUI libraries, and configuring several Open Source IDEs
    with MinGW.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*您需要了解的顶级功能* – 在这里，您将学习如何使用 MinGW 的最重要功能执行一些任务。在本节结束时，您将能够使用 GNU Make 工具有效地构建项目，将现有的
    Visual C++ 项目导入 MinGW 软件，基于跨平台 GUI 库开发应用程序，以及使用 MinGW 配置几个开源 IDE。'
- en: '*People and places you should get to know* – Every Open Source project is centered
    around a community. This section provides you with many useful links to the project
    page and forums, as well as a number of helpful articles and tutorials on MinGW
    software.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*您应该了解的人和地点* – 每个开源项目都围绕一个社区展开。本节为您提供许多有用的项目页面和论坛链接，以及一些关于 MinGW 软件的有用文章和教程。'
- en: So, what is MinGW?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，MinGW 是什么？
- en: 'Minimalist GNU for Windows (MinGW) is a native software port of the GNU tool
    chain for the Microsoft Windows operating system. The base components of MinGW
    software are compiler, linker, and assembler. This minimal tool set is enough
    to start developing applications. But MinGW contains some service utilities to
    make the developing process more effective:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化 GNU for Windows (MinGW) 是 GNU 工具链的本地软件移植，用于 Microsoft Windows 操作系统。MinGW
    软件的基本组件是编译器、链接器和汇编器。这个最小工具集足以开始开发应用程序。但 MinGW 包含一些服务实用程序，以使开发过程更加高效：
- en: GNU Make
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU Make
- en: GNU Debugger (GDB)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU 调试器 (GDB)
- en: GNU profiler
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU 性能分析器
- en: Compiler for Windows resource files
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 资源文件的编译器
- en: Header files and libraries for Windows API
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows API 的头文件和库
- en: Collection of archives and packers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归档和打包工具的集合
- en: These components allow you to develop native 32-bit Windows applications without
    any proprietary third-party software. All components of MinGW software are produced
    under GNU General Public License and therefore this is a free software that you
    can download, use, and change as you want.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件允许您在不使用任何专有第三方软件的情况下开发本机 32 位 Windows 应用程序。MinGW 软件的所有组件都是在 GNU 通用公共许可证下生产的，因此这是一个您可以下载、使用和随意更改的自由软件。
- en: You can develop applications in C, C++, Java, Objective C, Fortran, and Ada
    programming languages with MinGW software. C++ application development will be
    described in this book, which is more typical for MinGW usage.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 MinGW 软件在 C、C++、Java、Objective C、Fortran 和 Ada 编程语言中开发应用程序。本书将描述 C++ 应用程序开发，这对于
    MinGW 的使用更为典型。
- en: Besides developing new applications, you can import existing Visual C++ projects
    to MinGW software. It is easy to integrate MinGW with well-known third-party libraries
    such as DirectX, Boost, Qt, GTK, OpenGL, and SDL. If you are using any of these
    libraries, you can compile your application with MinGW.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了开发新的应用程序外，您还可以将现有的 Visual C++ 项目导入 MinGW 软件。将 MinGW 与 DirectX、Boost、Qt、GTK、OpenGL
    和 SDL 等知名第三方库集成起来非常容易。如果您使用这些库中的任何一个，您都可以使用 MinGW 编译您的应用程序。
- en: MinGW software is very useful for importing Unix and Mac applications to Windows
    native code. It provides the same instruments that Unix and Mac developers have
    used in most cases. Also, you can import your MinGW-based applications to any
    computing platform supported by the GNU toolchain. Therefore, MinGW software is
    a great instruments' set for developing cross-platform applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MinGW 软件对于将 Unix 和 Mac 应用程序导入 Windows 本地代码非常有用。它提供了 Unix 和 Mac 开发者在大多数情况下使用的相同工具。此外，您还可以将基于
    MinGW 的应用程序导入任何由 GNU 工具链支持的计算机平台。因此，MinGW 软件是开发跨平台应用程序的优秀工具集。
- en: Another benefit of MinGW software is modular organization. You can replace most
    components of the GNU toolchain with your favorite instruments (for example, debugger,
    profiler, or build automation system). These instruments will be integrated with
    existing components without any problems. Usage of the MinGW software is the first
    step to collecting your own developer's instruments' set for comfortable work.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: MinGW 软件的好处之一是模块化组织。您可以用您喜欢的工具（例如，调试器、性能分析器或构建自动化系统）替换 GNU 工具链的大多数组件。这些工具将与现有组件无缝集成。使用
    MinGW 软件是收集您自己的开发者工具集以舒适工作的第一步。
- en: The compiler efficiency is one of most important parameters for software developers.
    There are a lot of C++ compilers' benchmarks that are available on the Internet.
    Unfortunately for us, developers of proprietary compilers are not interested in
    objective researches of this kind. Fair comparison of available compilers is impossible
    because of this.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的效率是软件开发者最重要的参数之一。互联网上有许多 C++ 编译器的基准测试。不幸的是，专有编译器的开发者对此类客观研究不感兴趣。由于这个原因，比较可用的编译器是不公平的。
- en: 'The MinGW compiler efficiency is abreast to proprietary compiler efficiency
    today according to benchmarks of independent software developers. You can find
    one of them at the following website:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据独立软件开发者的基准测试，MinGW 编译器的效率与专有编译器的效率相当。您可以在以下网站上找到其中之一：
- en: '[http://www.willus.com/ccomp_benchmark.shtml?p9+s6](http://www.willus.com/ccomp_benchmark.shtml?p9+s6)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.willus.com/ccomp_benchmark.shtml?p9+s6](http://www.willus.com/ccomp_benchmark.shtml?p9+s6)'
- en: 'The MinGW software releases are more frequent than the proprietary compilers''
    releases. This means that MinGW is developed and improved more dynamically. For
    example, the standard features of C++11 have been supported by the GCC compiler
    earlier than the Visual Studio one. You can find these features at the following
    website:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: MinGW 软件发布比专有编译器的发布更频繁。这意味着 MinGW 的开发和改进更加动态。例如，C++11 的标准功能比 Visual Studio 中的
    GCC 编译器更早得到支持。您可以在以下网站上找到这些功能：
- en: '[http://wiki.apache.org/stdcxx/C++0xCompilerSupport](http://wiki.apache.org/stdcxx/C++0xCompilerSupport)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://wiki.apache.org/stdcxx/C++0xCompilerSupport](http://wiki.apache.org/stdcxx/C++0xCompilerSupport)'
- en: Notice that the GNU toolchain is a product of Unix culture. This culture is
    earlier than GUI applications with access to any function through menus, dialogs,
    and icons. Unix software has been developed as a suite of little stand alone utilities.
    Each of these performs only one task, but this execution is optimized very well.
    Therefore, all these utilities have a text-based interface. This provides the
    simplest intercommunication mechanism with a command line shell and saves the
    system resources.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，GNU 工具链是 Unix 文化的产物。这种文化早于通过菜单、对话框和图标访问任何功能的 GUI 应用程序。Unix 软件已经开发成一套小型的独立实用工具。每个都只执行一个任务，但这个执行被优化得非常好。因此，所有这些实用工具都有基于文本的界面。这为命令行
    shell 提供了最简单的交互机制，并节省了系统资源。
- en: If the idea of a text-based interface scares you, be relieved because there
    are a lot of **Integrated Development Environments** (**IDE**) that support MinGW.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基于文本界面的想法让您感到害怕，请放心，有很多 **集成开发环境**（**IDE**）支持 MinGW。
- en: Installation
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: There are several ways to install MinGW software on your computer. For example,
    you can compile whole MinGW software by yourself, or you can just install MinGW
    software distribution with a few clicks. The following steps are the simplest
    and quickest guide to install MinGW software.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以在您的计算机上安装 MinGW 软件。例如，您可以自己编译整个 MinGW 软件，或者只需通过几次点击安装 MinGW 软件发行版。以下步骤是安装
    MinGW 软件最简单、最快的方法指南。
- en: Step 1 – What do I need?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 1 步 – 我需要什么？
- en: 'You need the following configurations on your computer to install MinGW software
    according to this guide:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本指南安装 MinGW 软件时，您需要在您的计算机上具备以下配置：
- en: Disk space of 500 MB
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 500 MB 的磁盘空间
- en: An operating system of any version of Microsoft Windows since Windows XP or
    newer
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何版本的 Microsoft Windows 操作系统，从 Windows XP 或更新的版本
- en: Internet connection
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: Step 2 – Downloading MinGW
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 步 – 下载 MinGW
- en: 'Download a self-extracting archive with the latest version of the MinGW software
    distribution from the following web page:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下网页下载包含 MinGW 软件最新版本的自解压存档：
- en: '[http://nuwen.net/mingw.html](http://nuwen.net/mingw.html)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://nuwen.net/mingw.html](http://nuwen.net/mingw.html)'
- en: 'You will find two types of distribution here: one with Git and one without
    Git. **Git** is an open source distributed revision control system. I suggest
    you install the version with Git because it contains Bash command shell. This
    is a comfortable alternative for the standard Windows Command Prompt. For example,
    the Bash shell provides the autocomplete function that will complete the typed
    commands and pathnames by pressing the *Tab* key. Also the command history is
    available by pressing up and down arrows.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里会找到两种类型的分发：一种包含 Git，另一种不包含 Git。**Git** 是一个开源的分布式版本控制系统。我建议你安装包含 Git 的版本，因为它包含
    Bash 命令 shell。这是标准 Windows 命令提示符的一个舒适替代品。例如，Bash shell 提供了自动完成功能，通过按 *Tab* 键可以完成输入的命令和路径名。此外，通过按上下箭头可以访问命令历史记录。
- en: Step 3 – Extracting and configuring
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 步 – 提取和配置
- en: Run the self-extracting archive. Specify the target directory and click on the
    **Extract** button.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 运行自解压存档。指定目标目录并点击 **提取** 按钮。
- en: Suppose that you choose `C:\` as the target directory. The archive will be extracted
    to `C:\MinGW`. I strongly recommend you not to install MinGW software in `C:\Program
    Files`. There are problems with paths containing spaces.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你选择 `C:\` 作为目标目录。存档将被提取到 `C:\MinGW`。我强烈建议你不要在 `C:\Program Files` 中安装 MinGW
    软件。包含空格的路径存在问题。
- en: Run the `set_distro_paths.bat` script in `C:\MinGW` after the archieve extraction.
    It will add the MinGW software directory to the `PATH` system variable for integration
    with the Windows Command Prompt and Bash shell. This script does not work properly
    on Windows Vista and Windows 7\. Check the MinGW directory existence in the `PATH`
    variable after executing it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在存档提取后，在 `C:\MinGW` 中运行 `set_distro_paths.bat` 脚本。它将 MinGW 软件目录添加到 `PATH` 系统变量中，以便与
    Windows 命令提示符和 Bash shell 集成。此脚本在 Windows Vista 和 Windows 7 上可能无法正常工作。在执行后检查 `PATH`
    变量中 MinGW 目录的存在性。
- en: What do you have to get?
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你需要得到什么？
- en: Congratulations! You have got the linker, C, and C++ compilers on your computer
    with header files and libraries for Windows API. Boost, GLEW, SDL, PCRE, Free
    Type, Vorbis, and many more libraries have been installed too. Moreover, there
    is profiler, Bash shell, Git, and other utilities.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经在你的计算机上安装了链接器、C 和 C++ 编译器，以及 Windows API 的头文件和库。Boost、GLEW、SDL、PCRE、Free
    Type、Vorbis 以及许多其他库也已安装。此外，还有性能分析器、Bash shell、Git 以及其他实用工具。
- en: There are several other ways to install MinGW software. One of them may be more
    suitable for your goals.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 MinGW 软件有几种其他方法。其中一种可能更适合你的目标。
- en: Alternative ways to install MinGW
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 MinGW 的替代方法
- en: The installation process described earlier refers to the unofficial distribution
    of the MinGW software with additional libraries and utilities. It may seem doubtful
    for users accustomed to proprietary software, but this is common practice for
    open source users. The third-party distributions are more usable and complete
    than official ones in some cases. This is achieved by integrating several relative
    open source products into one distribution. GNU Linux distribution is a typical
    sample of this practice.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的安装过程是指包含额外库和实用工具的非官方 MinGW 软件分发版。对于习惯于专有软件的用户来说，这可能会显得可疑，但对于开源用户来说，这是一种常见的做法。第三方分发在某些情况下比官方分发更易于使用和更完整。这是通过将几个相关的开源产品集成到一个分发中实现的。GNU
    Linux 分发是这种做法的典型例子。
- en: 'You can download and install the official distribution of MinGW software from
    the following developers'' website:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从以下开发者的网站下载和安装 MinGW 软件的官方分发版：
- en: '[http://www.mingw.org](http://www.mingw.org)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.mingw.org](http://www.mingw.org)'
- en: 'I recommend you use the `mingw-get` installer application with a text-based
    interface. You can get a list of all the available packages by executing the following
    command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你使用具有文本界面的 `mingw-get` 安装程序。你可以通过执行以下命令来获取所有可用包的列表：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Execute the following command to install the necessary packages (for example,
    GCC, G++, GDB):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令来安装必要的包（例如，GCC、G++、GDB）：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A more detailed instruction manual is available at the official MinGW website.
    You can simply install extensions for MinGW software using the `mingw-get` application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细的说明手册可在官方MinGW网站上找到。你可以使用`mingw-get`应用程序简单地安装MinGW软件的扩展。
- en: 'The 64-bit MinGW software version is available from the `MinGW-w64` fork. Fork
    is an alternative branch of mainstream software development. The goal of any fork
    is to achieve specific software features. MinGW-w64 is a completely different
    software package than MinGW with its own staff of developers. However, the basic
    principles of MinGW and MinGW-w64 are the same. All knowledge gained in this book
    you can apply to MinGW-w64 software. The following website is for the MinGW-w64
    project:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 64位MinGW软件版本可以从`MinGW-w64`分支获取。分支是主流软件开发的一个替代分支。任何分支的目标都是实现特定的软件功能。MinGW-w64是一个与MinGW完全不同的软件包，拥有自己的开发团队。然而，MinGW和MinGW-w64的基本原则是相同的。你在这本书中学到的所有知识都可以应用于MinGW-w64软件。以下网站是MinGW-w64项目的网站：
- en: '[http://mingw-w64.sourceforge.net](http://mingw-w64.sourceforge.net)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://mingw-w64.sourceforge.net](http://mingw-w64.sourceforge.net)'
- en: You can download the archive with MinGW software from here and unpack them.
    After unpacking you will get a ready-to-use MinGW software.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这里下载MinGW软件的存档并解压它们。解压后，你将得到一个可立即使用的MinGW软件。
- en: 'The following is the website of a MinGW-w64 software''s unofficial distribution:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个MinGW-w64软件非官方分发的网站：
- en: '[http://tdm-gcc.tdragon.net](http://tdm-gcc.tdragon.net)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://tdm-gcc.tdragon.net](http://tdm-gcc.tdragon.net)'
- en: This distribution provides a more flexible configuration of the installable
    components than the official one. The installation will be performed through the
    standard Windows Installation Wizard application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分发提供的安装组件配置比官方版本更灵活。安装将通过标准的Windows安装向导应用程序执行。
- en: MinGW software is supplied with some open source IDE. For example, such integrated
    product is available on Code::Blocks, official website [http://www.codeblocks.org](http://www.codeblocks.org).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: MinGW软件附带了一些开源IDE。例如，这样的集成产品在Code::Blocks官方网站上可用。[http://www.codeblocks.org](http://www.codeblocks.org).
- en: Quick start – Creating your first MinGW project
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速入门 – 创建你的第一个MinGW项目
- en: Let's create a simple typical C++ Windows application from scratch. Its interface
    will consist of a dialog window with two buttons. A click on the first button
    leads to a display of a message while a click on the second button leads to the
    application termination. The application contains a resource file with Windows
    Controls captions, sizes, styles, and fonts.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从零开始创建一个简单的典型C++ Windows应用程序。其界面将包括一个带有两个按钮的对话框窗口。点击第一个按钮将显示一条消息，而点击第二个按钮将导致应用程序终止。应用程序包含一个资源文件，其中包含Windows控件标题、大小、样式和字体。
- en: Step 1 – Adding source files
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一步 – 添加源文件
- en: 'First of all, you must create a source C++ file and name it `main.cpp`. This
    file will contain the main function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须创建一个源C++文件，并将其命名为`main.cpp`。这个文件将包含主函数：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[http://www.PacktPub.com](http://www.PacktPub.com)的账户下载你购买的所有Packt书籍的示例代码文件。如果你在其他地方购买了这本书，你可以访问[http://www.PacktPub.com/support](http://www.PacktPub.com/support)并注册，以便将文件直接通过电子邮件发送给你。
- en: The first line is the definition of the `WIN32_LEAN_AND_MEAN` macro, which disables
    the inclusion of rarely-used Windows header files. The next two lines include
    the header file with the Windows API functions' declaration and the header file
    with application resources identifiers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是`WIN32_LEAN_AND_MEAN`宏的定义，它禁用了不常用Windows头文件的包含。接下来的两行包含了包含Windows API函数声明的头文件和包含应用程序资源标识符的头文件。
- en: The `DialogProc` function processes messages sent to our modal dialog. These
    messages contain information about events that occurred. The message identifier
    is passed to the function in the `uMsg` parameter. The `wParam` and `lParam` parameters
    are used for additional message-specific information. The `hwndDlg` parameter
    defines the dialog window that has received the message.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`DialogProc`函数处理发送到我们的模态对话框的消息。这些消息包含有关发生的事件的信息。消息标识符通过`uMsg`参数传递给函数。`wParam`和`lParam`参数用于提供额外的消息特定信息。`hwndDlg`参数定义了接收消息的对话框窗口。'
- en: 'The `DialogProc` function processes the following messages:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`DialogProc` 函数处理以下消息：'
- en: '`WM_CLOSE`: This message is caused by a click on the standard close window
    button.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WM_CLOSE`：此消息是由点击标准关闭窗口按钮引起的。'
- en: '`WM_COMMAND` with the `IDC_BTN_QUIT` parameter: This message is caused by a
    click on the Quit button.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WM_COMMAND` 与 `IDC_BTN_QUIT` 参数：此消息是由点击退出按钮引起的。'
- en: '`WM_COMMAND` with the `IDC_BTN_TEST` parameter: This message is caused by a
    click on the Test button.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`WM_COMMAND` 与 `IDC_BTN_TEST` 参数：此消息是由点击测试按钮引起的。'
- en: The `WM_CLOSE` and `WM_COMMAND` with `IDC_BTN_QUIT` parameter messages causes
    the application to terminate. The `WM_COMMAND` with the `IDC_BTN_TEST` parameter
    message causes the standard message box displaying.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`WM_CLOSE` 和 `WM_COMMAND` 与 `IDC_BTN_QUIT` 参数的消息会导致应用程序终止。`WM_COMMAND` 与 `IDC_BTN_TEST`
    参数的消息会导致显示标准消息框。'
- en: The function which is defined next is `WinMain`. This function will be called
    when the application launches. The `DialogBox` Windows API function is called
    here to create a modal dialog window. We pass the `hInstance` variable to this
    function with a handle to the module whose executable file contains the resources
    of the created dialog. These resources are read-only embedded data in a binary
    file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个定义的函数是 `WinMain`。当应用程序启动时，将调用此函数。在这里调用 `DialogBox` Windows API 函数以创建模态对话框窗口。我们将
    `hInstance` 变量的句柄传递给此函数，该句柄包含创建的对话框资源所在的模块的可执行文件。这些资源是二进制文件中的只读嵌入数据。
- en: Next, the `DialogBox` function parameter is a pointer to the null-terminated
    string that specifies the dialog template in the resource data. The `MAKEINTRESOURCE`
    macro is used here to convert the `DLG_MAIN` identifier of the integer type to
    the null-terminated string. This identifier is defined in the `resource.h` header
    file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`DialogBox` 函数参数是指向以空字符终止的字符串的指针，该字符串指定资源数据中的对话框模板。这里使用 `MAKEINTRESOURCE`
    宏将整数类型的 `DLG_MAIN` 标识符转换为以空字符终止的字符串。此标识符在 `resource.h` 头文件中定义。
- en: The third parameter of the `DialogBox` function is the handle of the parent
    window that owns the dialog window. This is equal to the `NULL` value in our case
    that means the absence of a parent window.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`DialogBox` 函数的第三个参数是拥有对话框窗口的父窗口句柄。在我们的情况下，这等于 `NULL` 值，表示没有父窗口。'
- en: The last parameter of the function is a pointer to the dialog window procedure
    to process messages. We pass the pointer to the `DialogProc` function for this
    parameter.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最后一个参数是指向处理消息的对话框窗口过程的指针。我们传递 `DialogProc` 函数的指针给此参数。
- en: User interface elements and their parameters can be described in the resource
    file. All data from this file will be embedded into executable files and these
    will be available when the application runs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面元素及其参数可以在资源文件中描述。此文件中的所有数据都将嵌入到可执行文件中，并在应用程序运行时可用。
- en: 'Let''s add this resource file to our project (`resource.rc`):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此资源文件添加到我们的项目中（`resource.rc`）：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see the inclusion of the `resource.h` header in the first line of the
    resource file. The user interface element identifiers are defined in this header
    file. These identifiers are used to provide access from C++ code to resource data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在资源文件的第一行看到 `resource.h` 头文件的包含。用户界面元素标识符在此头文件中定义。这些标识符用于从 C++ 代码访问资源数据。
- en: The `DLG_MAIN` element of the `DIALOGEX` type is defined in the next line. This
    element represents the dialog template with the position and size dialog window
    parameters. All statements in the next lines define the appearance of the dialog
    box and its elements.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个行定义了 `DIALOGEX` 类型的 `DLG_MAIN` 元素。此元素表示具有位置和大小对话框窗口参数的对话框模板。下一行中的所有语句定义了对话框及其元素的外观。
- en: The next line of the resource file contains the `CAPTION` statement. This statement
    defines the title of the dialog box. The `FONT` statement defines the font size
    and typeface for the dialog text font. The `STYLE` statement defines the window
    style of the dialog box.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 资源文件的下一条包含 `CAPTION` 语句。此语句定义了对话框的标题。`FONT` 语句定义了对话框文本字体的大小和字体类型。`STYLE` 语句定义了对话框窗口的样式。
- en: 'The dialog box buttons are defined between the `BEGIN` and `END` statements.
    These parameters are defined for each button as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框按钮在 `BEGIN` 和 `END` 语句之间定义。每个按钮的参数如下定义：
- en: Type of the user interface element (this is equal to `CONTROL`)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面元素的类型（这等于 `CONTROL`）
- en: Caption of the element
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素的标题
- en: Element identifier
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素标识符
- en: Class of the element (this is equal to `Button`)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素的类别（这等于 `Button`）
- en: Window style of the element
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素的窗口样式
- en: Position (x, y) and size (width, height)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素的位置（x, y）和大小（宽度，高度）
- en: 'The third file is a header for the binding resource identifiers and C++ code
    (`resource.h`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个文件是绑定资源标识符和 C++ 代码的头文件（`resource.h`）：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The dialog box and buttons' identifiers are specified here.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里指定对话框和按钮的标识符。
- en: Step 2 – Adding a Makefile
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 2 步 – 添加 Makefile
- en: The compilation rules are required to build our application. The rules describe
    algorithms to compile sources and link object files together to assembly executable
    files and libraries. This kind of algorithm is present in common IDEs, such as
    Visual Studio. However, it is often hidden inside the graphical user interface
    and is not available for change. You have the ability to control each step of
    the building application algorithm with the GNU Make utility.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 编译规则是构建我们的应用程序所必需的。规则描述了编译源文件并将目标文件链接到汇编可执行文件和库的算法。这种算法在常见的 IDE 中存在，如 Visual
    Studio。然而，它通常隐藏在图形用户界面中，不可更改。你可以使用 GNU Make 工具控制构建应用程序算法的每个步骤。
- en: You can perform each compilation step manually by calling the compiler and linker
    from the command line interface. However, the rules in the GNU Make utility file
    can automate these operations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从命令行界面调用编译器和链接器来手动执行每个编译步骤。然而，GNU Make 工具文件中的规则可以自动化这些操作。
- en: 'This is the simplest variant of the rules of the GNU Make utility file to build
    our application (`Makefile`):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 GNU Make 工具文件构建我们的应用程序（`Makefile`）的规则的最简单变体：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that there is a tabulation under each command. Tabulation and spaces
    are not the same for the GNU Make utility and this is often subjected to criticism.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每个命令下面都有一个制表符。对于 GNU Make 工具来说，制表符和空格是不一样的，这常常受到批评。
- en: The Makefile syntax will be described in detail in the later part of this book.
    It consists of targets (specified under the colon), and commands for producing
    these targets at the next line. The file list after the colon consists of files
    on which the target depends. These files are called prerequisites. The target
    will be rebuilt by the `make` command if one of its prerequisite files has been
    changed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 语法将在本书的后续部分详细描述。它由目标（在冒号下指定）和用于生成这些目标的命令组成。冒号后面的文件列表是目标所依赖的文件。这些文件被称为先决条件。如果其先决条件文件之一已更改，则
    `make` 命令将重建目标。
- en: 'The following targets are specified in this `Makefile`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `Makefile` 中指定了以下目标：
- en: The final executable file, that is, `win32-app.exe`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终的可执行文件，即 `win32-app.exe`
- en: The object file with application resources, that is, `resource.rc.res.o`
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含应用程序资源的目标文件，即 `resource.rc.res.o`
- en: The utility target to remove temporary files, that is, `clean`
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于删除临时文件的实用目标，即 `clean`
- en: The MinGW C++ compiler application name is g++. The compiler for the Windows
    resource files is `windres`. Each GNU utility has detailed information about command
    line options and developers' feedback. Running the GNU utility from the Windows
    command prompt or Bash shell with the `--help` option will lead to displaying
    this information. This is the example of the same GNU utility run.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: MinGW C++ 编译器的应用程序名称是 g++。Windows 资源文件的编译器是 `windres`。每个 GNU 工具都有关于命令行选项和开发者反馈的详细信息。在
    Windows 命令提示符或 Bash shell 中使用 `--help` 选项运行 GNU 工具将显示此信息。这是运行相同 GNU 工具的示例。
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `clean` utility target is required to remove all files generated by the
    compiler and linker. The `rm` command is called to perform this task. You can
    use the `clean` target to rebuild the application after changing source files.
    Just perform this target and then build your application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 需要 `clean` 实用目标来删除编译器和链接器生成的所有文件。使用 `rm` 命令执行此任务。你可以使用 `clean` 目标在更改源文件后重新构建应用程序。只需执行此目标，然后构建你的应用程序。
- en: Step 3 – Compiling and linking
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 步 – 编译和链接
- en: Now we are ready to compile our first application with MinGW software. First
    of all, you must run the command shell. There are several ways to do this. The
    simplest one is by launching the command shell from the Windows **Start** menu.
    Just type the `cmd` or `bash` command in the menu's **Search** field. Furthermore,
    there are a lot of file managers with integrated command shells which you will
    be comfortable to work with. Far Manager is one of these.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好使用 MinGW 软件编译我们的第一个应用程序。首先，你必须运行命令行界面。有几种方法可以做到这一点。最简单的方法是从 Windows
    **开始** 菜单启动命令行界面。只需在菜单的 **搜索** 字段中输入 `cmd` 或 `bash` 命令。此外，还有很多集成了命令行界面的文件管理器，你将能够舒适地使用它们。Far
    Manager 就是其中之一。
- en: 'You will see a window with the command line shell. Several useful commands
    for directory navigation have been installed with MinGW software:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个带有命令行壳的窗口。MinGW 软件已安装了几个用于目录导航的有用命令：
- en: '`cd <dir>`: This command changes the current directory to the specified one.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cd <dir>`：此命令将当前目录更改为指定的目录。'
- en: 'For example, to change the directory to `C:\Projects`, type the following command
    line:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，要将目录更改为 `C:\Projects`，请输入以下命令行：
- en: '[PRE7]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`pwd`: This command writes the absolute pathname of the current directory'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pwd`：此命令写入当前目录的绝对路径名'
- en: '`ls`: This command lists the current directory contents'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls`：此命令列出当前目录的内容'
- en: Change the current directory to the project one. The `C:/` path equals to the
    `/c` path in the Bash shell. This is due to the specific Unix environment's integration
    with Windows filesystems. Type the `make` command after changing the current directory.
    This is all that you need to do for compiling and linking applications. You get
    the executable binary after the GNU Make utility is executed successfully. Retype
    the `make` command to rebuild the application after changing any of the source
    files. It may be helpful to remove all the files, which were already generated
    by the compiler and linker, by using the `make` `clean` command before rebuilding
    the application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将当前目录更改为项目目录。`C:/` 路径等于 Bash shell 中的 `/c` 路径。这是由于特定 Unix 环境与 Windows 文件系统的集成。更改当前目录后，请输入
    `make` 命令。这就是编译和链接应用程序所需做的全部工作。在 GNU Make 工具成功执行后，您将获得可执行二进制文件。在更改任何源文件后，重新输入
    `make` 命令以重新构建应用程序。在重新构建应用程序之前，使用 `make clean` 命令删除所有已由编译器和链接器生成的文件可能会有所帮助。
- en: Top features you'll want to know about
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您需要了解的顶级功能
- en: Several useful features of MinGW software will be described in detail in this
    section. You will get detailed knowledge about the most commonly used GNU toolchain
    utilities, such as C++ compiler, GNU Make, GNU Debugger, and the GNU `gprof` profiler.
    Also the integration of MinGW software with several well-known GUI libraries and
    IDE systems will be described.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将详细描述 MinGW 软件的一些有用功能。您将详细了解最常用的 GNU 工具链实用程序，如 C++ 编译器、GNU Make、GNU 调试器和 GNU
    `gprof` 分析器。还将描述 MinGW 软件与几个知名 GUI 库和 IDE 系统的集成。
- en: 1 – Make utility usage
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1 – Make 工具使用
- en: We created a simple `Makefile` in the previous section. Let's explore the GNU
    Make utility's behavior and the syntax of Makefile in more detail.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了一个简单的 `Makefile`。现在让我们更详细地探讨 GNU Make 工具的行为和 `Makefile` 的语法。
- en: 'You can run the GNU Make utility from the command shell with the `make` command.
    It will search one of the `Makefile`, `GNUmakefile`, or `makefile` named files
    and start to build the first line target. For changing this behavior, type the
    following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用命令行中的 `make` 命令从命令壳中运行 GNU Make 工具。它将搜索名为 `Makefile`、`GNUmakefile` 或 `makefile`
    的文件之一，并开始构建第一行目标。要更改此行为，请输入以下命令：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This leads to reading `OtherMakefile` as input file of rules and executing commands
    to build `other_target`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致将 `OtherMakefile` 作为规则输入文件读取并执行构建 `other_target` 的命令。
- en: 'In the previous section we created the following `Makefile`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们创建了以下 `Makefile`：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This works, but it has some problems. First of all the `main.cpp` and `resource.rc.res.o`
    files are specified several times. You must rename these in several places if
    one of these has been changed. This violates one of the most important principles
    of software development, **Don''t repeat yourself** (**DRY**). Variables can help
    you to avoid this problem. The GNU Make variables are often used to save constant
    values and change behavior during the build process. Our `Makefile` with variables
    will be as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这可行，但有一些问题。首先，`main.cpp` 和 `resource.rc.res.o` 文件被指定了多次。如果其中一个文件已更改，您必须在多个地方重命名这些文件。这违反了软件开发最重要的原则之一，**不要重复自己**（**DRY**）。变量可以帮助您避免这个问题。GNU
    Make 变量通常用于在构建过程中保存常量值和更改行为。我们的带有变量的 `Makefile` 将如下所示：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The variable definition contains the name and variable value after the equals
    sign. You must use the dollar sign before the variable name within parentheses
    to access its value after the variable definition.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 变量定义包含等于号后的名称和变量值。您必须在括号内的变量名前使用美元符号来访问变量定义后的值。
- en: The source, resource, and executable files are defined as variables in our example.
    Now you should change the variable value in one place only to rename any of these
    files.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，源文件、资源文件和可执行文件被定义为变量。现在您只需在一个地方更改变量值，就可以重命名这些文件中的任何一个。
- en: 'GNU Make allows the user to define variables, but there are several special
    automatic variables. These variables are computed for each rule that is executed.
    You can use the `$@` variable to specify the previously defined target and the
    `$^` variable to specify all the prerequisites of this target. After doing all
    this `Makefile` will look as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: GNU Make 允许用户定义变量，但也有一些特殊的自动变量。这些变量是在每个执行的规则中计算的。你可以使用 `$@` 变量来指定之前定义的目标，使用
    `$^` 变量来指定这个目标的所有依赖项。完成所有这些后，`Makefile` 将如下所示：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The automatic variables can be used just like the user-defined ones. Now output
    files of g++ and the `windres` command are declared with the `$@` variable and
    source files with the `$^` one.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像使用用户定义的变量一样使用自动变量。现在，g++ 和 `windres` 命令的输出文件使用 `$@` 变量声明，源文件使用 `$^` 变量声明。
- en: Suppose you want to link your application with a third-party library. The library
    is supplied with the header file and a dynamic-link or static-link library. You
    must inform the compiler about these files' paths and the library to link with.
    The simplest way to do it is using the GNU Make environment variables.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要将你的应用程序与第三方库链接。库包含头文件和一个动态链接库或静态链接库。你必须通知编译器这些文件的路径以及要链接的库。最简单的方法是使用 GNU
    Make 环境变量。
- en: An environment variable is a variable that comes from the command shell in which
    GNU Make runs. There are several predefined environment variables with standard
    names. You can add custom environment variables from your command shell, but the
    most common practice is to operate with the standard one in `Makefile`. Environment
    variables affect target producing commands in `Makefile` (for example, additional
    compiler options are usually passed through environment variables).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量是从 GNU Make 运行的命令壳中来的变量。有几个具有标准名称的预定义环境变量。你可以从你的命令壳中添加自定义环境变量，但最常见的方法是在
    `Makefile` 中操作标准变量。环境变量会影响 `Makefile` 中的目标生成命令（例如，额外的编译器选项通常通过环境变量传递）。
- en: 'The following Makefile is a linking example with the static-link boost program
    options library (the file path of the library is `C:\MinGW\lib\libboost_program_options.a`):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用静态链接的 boost 程序选项库的链接示例（库的文件路径为 `C:\MinGW\lib\libboost_program_options.a`）：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`CXXFLAGS` is a predefined environment variable that contains command line
    options for the C++ compiler. This variable can be used to specify the paths of
    additional header files required for source compilation. Paths to headers are
    specified there with the `-I` prefix. You can specify several paths separated
    by a space as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`CXXFLAGS` 是一个预定义的环境变量，它包含了 C++ 编译器的命令行选项。这个变量可以用来指定源编译所需的额外头文件路径。头文件的路径使用
    `-I` 前缀来指定。你可以指定多个路径，用空格分隔，如下所示：'
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`LIBS` is a simple variable with a list of static-link libraries to link with.
    This variable is passed to the C++ compiler explicitly in the `win32-app.exe`
    target producing rule. Libraries to link are specified with the `-l` prefix, and
    without the first three letters (`lib`), as well as the suffix (`.a`). The full
    path to linked libraries must be specified too with the `-L` prefix.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIBS` 是一个简单的变量，包含要链接的静态链接库列表。这个变量在 `win32-app.exe` 目标生成规则中明确传递给 C++ 编译器。要链接的库使用
    `-l` 前缀指定，不包含前三个字母（`lib`），以及后缀（`.a`）。必须使用 `-L` 前缀指定链接库的完整路径。'
- en: 'The following command is used to print all the predefined GNU Make environment
    variables:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令用于打印所有预定义的 GNU Make 环境变量：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that the additional `options.cpp` source file has been added to the project
    in this example. Also the `CPP` variable has been renamed to `OBJ` and contains
    object files list now. GNU Make will compile object files from source files automatically
    if they have same names (for example, `main.o` and `main.cpp`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个示例中已经向项目中添加了额外的 `options.cpp` 源文件。此外，`CPP` 变量已被重命名为 `OBJ`，现在包含对象文件列表。如果源文件和对象文件具有相同的名称（例如，`main.o`
    和 `main.cpp`），GNU Make 将自动从源文件编译对象文件。
- en: 'The following Makefile is a linking example with a dynamic-link `zlib` library
    (the file path of the library is `C:\MinGW\git\bin\libz.dll`):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用动态链接的 `zlib` 库的链接示例（库的文件路径为 `C:\MinGW\git\bin\libz.dll`）：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Dynamic-link libraries are described in the `LIBS` variable by the same rules
    as for static-link libraries.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 动态链接库与静态链接库使用相同的规则在 `LIBS` 变量中描述。
- en: '`CXX` is an environment variable with the C++ compiler''s application name.
    This is equal to `g++` by default.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`CXX` 是一个包含 C++ 编译器应用程序名称的环境变量。默认情况下等于 `g++`。'
- en: 'You can call the GNU Make utility for the `Makefile` subdirectory''s processing.
    This is an example of the root project directory, `Makefile`, that performs the
    GNU Make utility for subdirectories (`foo` and `bar`):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以调用 GNU Make 工具来处理 `Makefile` 子目录。以下是一个根项目目录的 `Makefile` 示例，它为子目录（`foo` 和
    `bar`）执行 GNU Make 工具：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `.PHONY` rule is a special rule. It is used to specify the fact that the
    target is not a file. This is required in our case because subdirectories always
    exist and the GNU Make will not rebuild targets whose files already exist. `MAKE`
    is an environment variable with GNU Make application name. This is equal to `C:\MinGW\bin\make`
    by default if the installation path of MinGW software is equal to `C:\MinGW`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`.PHONY` 规则是一个特殊规则。它用于指定目标不是一个文件的事实。在我们的情况下，这是必需的，因为子目录总是存在的，GNU Make 不会重建那些文件已经存在的目标。`MAKE`
    是一个环境变量，代表 GNU Make 应用程序名称。如果 MinGW 软件的安装路径等于 `C:\MinGW`，则默认情况下等于 `C:\MinGW\bin\make`。'
- en: Makefiles can include comments. All lines starting with the `#` symbol will
    be considered by GNU Make as comments.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 可以包含注释。所有以 `#` 符号开头的行都将被 GNU Make 视为注释。
- en: 'Makefiles can be complex and consists of several separated files. To include
    external file content in `Makefile` use `include` directive, for example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile 可能很复杂，由多个分离的文件组成。要在 `Makefile` 中包含外部文件内容，请使用 `include` 指令，例如：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: GNU Make is a great instrument for compiling small projects with a couple of
    source files and headers. There are more powerful instruments for building complex
    applications that consist of several libraries and executables. Some of them are
    based on the GNU Make utility and produce Makefiles as the output (for example,
    GNU Autotools and CMake). I strongly recommend you to study and use one of these
    for your daily projects.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: GNU Make 是一个用于编译带有少量源文件和头文件的中小型项目的优秀工具。对于由多个库和可执行文件组成的复杂应用程序，有更强大的工具可供选择。其中一些基于
    GNU Make 工具，并生成 Makefile 作为输出（例如，GNU Autotools 和 CMake）。我强烈建议您学习和使用这些工具之一来处理您的日常项目。
- en: 2 – Compiler options
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 – 编译器选项
- en: 'The MinGW compiler behavior is highly dependent on command line options. These
    options are usually set through GNU Make environment variables. The following
    is a list of commonly used predefined environment variables:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: MinGW 编译器的行为高度依赖于命令行选项。这些选项通常通过 GNU Make 环境变量设置。以下是一个常用预定义环境变量的列表：
- en: '`CC`: This variable sets the C compiler in use'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CC`：此变量设置正在使用的 C 编译器'
- en: '`CFLAGS`: This variable sets the C compiler command line options'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CFLAGS`：此变量设置 C 编译器的命令行选项'
- en: '`CPPFLAGS`: This variable sets the C PreProcessor flags, which are used by
    C and C++ compilers'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPPFLAGS`：此变量设置 C 预处理器标志，这些标志由 C 和 C++ 编译器使用'
- en: '`CXX`: This variable sets the C++ compiler in use'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CXX`：此变量设置正在使用的 C++ 编译器'
- en: '`CXXFLAGS`: This variable sets the C++ compiler command line options'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CXXFLAGS`：此变量设置 C++ 编译器的命令行选项'
- en: '`LD`: This variable sets the linker in use'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LD`：此变量设置正在使用的链接器'
- en: '`LDFLAGS`: This variable sets the linker command line options'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LDFLAGS`：此变量设置链接器的命令行选项'
- en: '`LDLIBS`: This variable sets libraries to link'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LDLIBS`：此变量设置要链接的库'
- en: 'The following is a list of commonly used MinGW C and C++ compilers'' command
    line options:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个常用 MinGW C 和 C++ 编译器命令行选项的列表：
- en: '`-o file-name`: This gives the name of the compiler output file.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o file-name`：这给出了编译器输出文件的名称。'
- en: '`-c`: This is used for compilation only. The object files will be created without
    further linking.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c`：此选项仅用于编译。将创建对象文件，而不会进行进一步链接。'
- en: '`-Dname=value`: This defines the C preprocessor macro with a specified name
    and value. The `=value` part can be skipped. The default value (equal to 1) will
    be used instead. The result of this option will be the same as the following declaration
    in the source file:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Dname=value`：此选项使用指定的名称和值定义 C 预处理器宏。`=value` 部分可以省略。默认值（等于 1）将被使用。此选项的结果将与以下源文件中的声明相同：'
- en: '[PRE18]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`-llibrary-name`: This uses the specified dynamic-link or static-link library
    for linking.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-llibrary-name`：此选项使用指定的动态链接库或静态链接库进行链接。'
- en: '`-Idirectory`: This uses the directory to search headers by compiler.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Idirectory`：此选项使用目录来搜索编译器使用的头文件。'
- en: '`-Ldirectory`: This uses the directory to search dynamic-link libraries for
    linking.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Ldirectory`：此选项使用目录来搜索链接动态链接库。'
- en: '`-g`: This produces debugging information to be used by GDB debugger.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-g`：此选项生成调试信息，供 GDB 调试器使用。'
- en: '`-pg`: This generates extra code to write profiling information for the `gprof`
    performance analyzer.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-pg`：此选项生成额外的代码，用于为 `gprof` 性能分析器写入分析信息。'
- en: '`-Wall`: This shows all the compiler''s warning messages.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Wall`：这显示了编译器的所有警告消息。'
- en: '`-On`: This sets the compiler''s optimization level to an `n` value. The available
    levels are `-O0`, `-O1`, `-O2`, `-O3`, `-Os`, and `-Ofast`. The `-O0` option disables
    all optimizations. The `-O3` option provides the maximum optimization of code
    size and execution time. The `-Os` option optimizes for code size. The `-Ofast`
    option is the `-O3` option with non-accurate math calculation.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-On`：这设置编译器的优化级别为`n`值。可用的级别有`-O0`、`-O1`、`-O2`、`-O3`、`-Os`和`-Ofast`。`-O0`选项禁用所有优化。`-O3`选项提供代码大小和执行时间的最大优化。`-Os`选项优化代码大小。`-Ofast`选项是带有非精确数学计算的`-O3`选项。'
- en: '`-std=standard`: This uses the specified language standard (example for C++
    standard: `-std=C++11`).'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-std=standard`：这使用指定的语言标准（例如C++标准的示例：`-std=C++11`）。'
- en: 3 – Importing the existing Visual C++ project
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3 – 导入现有的Visual C++项目
- en: You can use MinGW software even if you already have your project developed with
    Visual C++. The importing process from Visual C++ to MinGW is quite simple. All
    you need is to remove unusable headers and create Makefiles to compile and link
    existing C++ sources.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你已经使用Visual C++开发了你的项目，你也可以使用MinGW软件。从Visual C++到MinGW的导入过程相当简单。你所需要做的就是移除不可用的头文件并创建Makefiles来编译和链接现有的C++源代码。
- en: This process will be described in detail in this section by an example application.
    The application is a simple command-line archiving utility based on the zlib compression
    library. The boost library is also used for command-line option parsing. The application
    consists of the `core` static-link library and the `z_pack` executable. This separation
    by library and executable is required for complex project linking example with
    several modules.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程将通过一个示例应用来详细描述。该应用是一个基于zlib压缩库的简单命令行归档工具。同时，也使用了boost库来进行命令行选项解析。该应用由`core`静态链接库和`z_pack`可执行文件组成。这种通过库和可执行文件进行分离的做法对于具有多个模块的复杂项目链接示例是必需的。
- en: 'You can see the Visual C++ project structure in the **Solution Explorer** window
    in the following screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下屏幕截图的**解决方案资源管理器**窗口中，你可以看到Visual C++项目结构：
- en: '![3 – Importing the existing Visual C++ project](img/5626_01_01.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![3 – 导入现有的Visual C++项目](img/5626_01_01.jpg)'
- en: First of all, let's look at the source code of the `core` library. This library
    contains the implementation of most of the application's functionality. The command-line
    parsing and compressing mechanisms are implemented here. Each of these mechanisms
    are encapsulated in a separate class. The `Options` class implements the command-line
    options' parsing. The `Packer` class implements the compressing and decompressing
    algorithms.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`core`库的源代码。这个库包含了应用程序的大部分功能实现。命令行解析和压缩机制都在这里实现。每个机制都被封装在一个单独的类中。`Options`类实现了命令行选项的解析。`Packer`类实现了压缩和解压缩算法。
- en: 'Let''s look at the `Options` class. The following code shows the class declaration
    in the `options.h` file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Options`类。以下代码展示了`options.h`文件中的类声明：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following code shows the constructor definition of the `Options` class
    in the `options.cpp` file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`options.cpp`文件中`Options`类的构造函数定义：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The constructor's input parameters are the count of command-line arguments and
    the vector with arguments' values. First of all the object from the boost library
    of the `options_description` class with the `description_` name is configured
    here with the available command-line arguments. This object is a field of the
    `Options` class.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的输入参数是命令行参数的数量和参数值的向量。首先，在这里配置了boost库中的`options_description`类对象，名为`description_`，并带有可用的命令行参数。这个对象是`Options`类的一个字段。
- en: 'All available command-line arguments are defined as global constants of the
    `string` type in the `options.h` file:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可用的命令行参数都在`options.h`文件中定义为全局常量类型`string`：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These arguments with descriptions are passed to the `add_options` method of
    the `description_` object to configure it. Now this object stores information
    about available command-line arguments. After that, arguments passed to the constructor
    input parameters are parsed and saved to the variables map. This map is an object
    from the boost library of the `variables_map` class with the `options_` name.
    This object is a field of the `Options` class.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些带有描述的参数传递给`description_`对象的`add_options`方法以配置它。现在这个对象存储了有关可用命令行参数的信息。之后，传递给构造函数的输入参数被解析并保存到变量映射中。这个映射是boost库中的`variables_map`类的一个对象，名为`options_`。这个对象是`Options`类的一个字段。
- en: The available command-line arguments are printed if any exception occurs in
    the arguments' parsing operation. The application's termination will be caused
    with the `exit` function in this case.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在解析参数的操作中发生任何异常，将打印出可用的命令行参数。在这种情况下，应用程序将通过`exit`函数终止。
- en: 'The following code is the `GetString` method''s definition of the `Options`
    class in the `options.cpp` file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是`options.cpp`文件中`Options`类`GetString`方法的定义：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The method returns the specified program option value of the `string` type or
    an empty string if the option has not been passed as a command-line argument.
    I suggest you name command-line arguments as program options after parsing them
    in the constructor of the `Options` class.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回指定程序选项的`string`类型值，如果没有将选项作为命令行参数传递，则返回空字符串。我建议你在`Options`类的构造函数中解析命令行参数后将其命名为程序选项。
- en: 'The following three methods of the `Options` class are quite simple. These
    perform a check on the existence of specific program options or return them:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Options`类的以下三个方法相当简单。这些方法对特定的程序选项的存在性进行检查或返回它们：'
- en: The `IsComplete` method checks if input and output filenames have been passed
    as command-line arguments to the application. This method returns the `true` value
    if the filenames exist.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsComplete`方法检查输入和输出文件名是否作为命令行参数传递给了应用程序。如果文件名存在，该方法返回`true`值。'
- en: The `IsUnzip` method checks if the `--unzip` command-line argument exists.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsUnzip`方法检查`--unzip`命令行参数是否存在。'
- en: The `GetDescription` method returns the reference to the `description_` field
    of the `Options` class. You can print available command-line arguments if this
    object is passed to the `cout` standard output stream.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetDescription`方法返回`Options`类中`description_`字段的引用。如果将此对象传递给`cout`标准输出流，你可以打印出可用的命令行参数。'
- en: The second class of the core library is `Packer`. The compressing and decompressing
    algorithms are implemented here. This class contains the `Compress` and `Decompress`
    static methods. The static class methods may be very helpful to implement algorithms
    without state and mutable data. You don't need the object of the class to call
    static methods.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 核心库的第二类是`Packer`。这里实现了压缩和解压缩算法。此类包含`Compress`和`Decompress`静态方法。静态类方法对于实现无状态和可变数据的算法非常有帮助。调用静态方法不需要类的对象。
- en: 'The following code shows the declaration of the class in the `packer.h` file:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`packer.h`文件中类的声明：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following code shows the `Compress` method''s definition in the `packer.cpp`
    file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了`packer.cpp`文件中`Compress`方法的定义：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The input parameters of this method are strings with filenames of source and
    target files.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的输入参数是包含源文件和目标文件名的字符串。
- en: The compression is performed with the `copy` function from the boost library
    that copies one stream content to another. The stream of the `file_source` class
    from the boost library is used in this function as input parameter. The copy function
    produces the object of the `filtering_ostreambuf` class with the `out` name as
    the result. The stream of the `file_source` class is anonymous and is created
    from the source filename and stream type. This is the `binary` type in our case.
    The `out` object has been configured by the compression filter of the `zlib_compressor`
    type and anonymous stream of the `file_sink` boost library class. This anonymous
    stream represents the target file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩是通过boost库中的`copy`函数进行的，该函数将一个流的内容复制到另一个流。在这个函数中，使用了boost库中`file_source`类的流作为输入参数。`copy`函数生成了名为`out`的`filtering_ostreambuf`类对象。`file_source`类的流是匿名的，它由源文件名和流类型创建。在我们的例子中，这是`binary`类型。`out`对象已经通过`zlib_compressor`类型的压缩过滤器和boost库类`file_sink`的匿名流进行了配置。这个匿名流代表了目标文件。
- en: After performing the `Compress` method, the compressed file with the specified
    target filename will be created.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `Compress` 方法后，将创建具有指定目标文件名的压缩文件。
- en: 'The following code shows the `Decompress` method''s definition of the `Packer`
    class in the `packer.cpp` file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了 `packer.cpp` 文件中 `Packer` 类的 `Decompress` 方法定义：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This method is similar to the `Compress` method, but the filter of the `zlib_decompressor`
    type has been used here. The decompressed file with a specified target filename
    will be created after this method is performed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法与 `Compress` 方法类似，但在此处使用了 `zlib_decompressor` 类型的过滤器。执行此方法后，将创建具有指定目标文件名的解压缩文件。
- en: The rest of the `core` library source files have been automatically generated
    by Visual C++.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`core` 库的其余源文件已由 Visual C++ 自动生成。'
- en: Another solution's project is `z_pack`. This project binds the `core` library
    classes' functionality in to use them in the complete application. The `z_pack`
    project consist of one source file with the `main` function implementation and
    several autogenerated files by Visual C++.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案的项目是 `z_pack`。此项目将 `core` 库类的功能绑定在一起，以便在完整应用程序中使用。`z_pack` 项目包含一个具有 `main`
    函数实现的源文件和由 Visual C++ 自动生成的几个文件。
- en: 'The following code shows the `main` function''s definition in the `z_pack.cpp`
    file:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了 `z_pack.cpp` 文件中 `main` 函数的定义：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The input parameters of this function are the same as the `Options` class constructor.
    These are count of command-line arguments and vectors with argument values. First
    of all the object of the `Options` class with the `options` name is created here.
    The next operation is checking the source and target filenames for correctness
    using the `IsComplete` method of the `options` object. The available command-line
    arguments will be printed and the application will be terminated if this checking
    fails. The specified compression or decompression operation is performed if command-line
    arguments are correct. The `IsUnzip` method of the `options` object defines what
    kind of operation must be performed. The `Compression` and `Decompression` operations
    perform as per the `Packer` class static methods.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的输入参数与 `Options` 类构造函数相同。这些是命令行参数的数量和参数值的向量。首先在这里创建一个名为 `options` 的 `Options`
    类对象。接下来的操作是使用 `options` 对象的 `IsComplete` 方法检查源文件和目标文件名的正确性。如果检查失败，将打印可用的命令行参数，并且应用程序将被终止。如果命令行参数正确，将执行指定的压缩或解压缩操作。`options`
    对象的 `IsUnzip` 方法定义了必须执行的操作类型。`Compression` 和 `Decompression` 操作按照 `Packer` 类的静态方法执行。
- en: The input parameters for these methods are available from the `GetString` method
    of the `Options` class execution result.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的输入参数可以从 `Options` 类执行结果的 `GetString` 方法中获取。
- en: Full Visual C++ project sources are available in the code bundle uploaded on
    the Packt website.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Packt 网站上上传的代码包中提供了完整的 Visual C++ 项目源代码。
- en: 'You can build this project and check its functionality. The Visual C++ versions
    of the boost and zlib libraries are required to compile the project. The comfortable
    distribution of both libraries is available at the following website:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以构建此项目并检查其功能。编译项目需要 Visual C++ 版本的 boost 和 zlib 库。这两个库的舒适版本可在以下网站找到：
- en: '[http://www.boostpro.com/download](http://www.boostpro.com/download)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.boostpro.com/download](http://www.boostpro.com/download)'
- en: 'You can test the functionality of our example application after building one.
    Type the following command to compress the existing file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建一个示例应用之后，您可以测试其功能。输入以下命令以压缩现有文件：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following command is used to decompress the existing archive:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令用于解压缩现有存档：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now you have the necessary information about our example Visual C++ project
    to import it to the MinGW software. The following are step-by-step instructions
    to do this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经拥有了将我们的示例 Visual C++ 项目导入 MinGW 软件的必要信息。以下是将项目导入的逐步说明：
- en: Create a new directory for the MinGW project version with the `core` and `z_pack`
    subdirectories.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 MinGW 项目版本创建一个新目录，包含 `core` 和 `z_pack` 子目录。
- en: Copy the `options.h`, `options.cpp`, `packer.h`, and `packer.cpp` files to the
    `core` subdirectory.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `options.h`、`options.cpp`、`packer.h` 和 `packer.cpp` 文件复制到 `core` 子目录。
- en: Copy the `z_pack.cpp` file to the `z_pack` subdirectory.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `z_pack.cpp` 文件复制到 `z_pack` 子目录。
- en: 'Remove the following line from all the files in the project that have the cpp
    extension:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从具有 cpp 扩展名的所有项目中删除以下行：
- en: '[PRE29]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following `Makefile` to the root project directory:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `Makefile` 添加到根项目目录：
- en: '[PRE30]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This `Makefile` allows you to perform the `make clean` and `make` commands for
    the `core` and `z_pack` subdirectories. The `make` command will build your application
    and the `make` `clean` command will remove output files generated by the compiler
    and linker.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 `Makefile` 允许你为 `core` 和 `z_pack` 子目录执行 `make clean` 和 `make` 命令。`make` 命令将构建你的应用，而
    `make clean` 命令将删除编译器和链接器生成的输出文件。
- en: 'Add the following `Makefile` to the `core` subdirectory:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `Makefile` 添加到 `core` 子目录：
- en: '[PRE31]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `ar` archive utility is used to maintain the `options.o` and `packer.o`
    object files into the `libcore.a` archive here. This archive will be used for
    static linking with the `z_pack` executable. The `libcore.a` archive is conceptually
    the same as the Visual C++ static-link library. You can get additional information
    about the `ar` archive utility by the executing following command:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ar` 归档工具用于将 `options.o` 和 `packer.o` 对象文件维护到 `libcore.a` 归档中。这个归档将被用于与 `z_pack`
    可执行文件的静态链接。`libcore.a` 归档在概念上与 Visual C++ 静态链接库相同。你可以通过执行以下命令来获取关于 `ar` 归档工具的更多信息：'
- en: '[PRE32]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following Makefile to the `z_pack` subdirectory:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `Makefile` 添加到 `z_pack` 子目录：
- en: '[PRE33]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Linking with all necessary external libraries (boost and zlib) occurs here because
    the `ar` archive utility does not perform any linking.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里进行所有必要的外部库（boost 和 zlib）的链接，因为 `ar` 归档工具不执行任何链接。
- en: Type the `make` command in the root project directory to build our application.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根项目目录中输入 `make` 命令来构建我们的应用。
- en: This is all you need to import our example Visual C++ project to the MinGW software.
    You will get the `z_pack.exe` executable file after building it.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要将我们的示例 Visual C++ 项目导入 MinGW 软件的全部内容。构建后，你将得到 `z_pack.exe` 可执行文件。
- en: It is quite simple to change the `libcore.a` static-link library to the dynamic-link
    variant one. All you need is to change the `Makefile` files for the `z_pack` executable
    and the `core` library.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `libcore.a` 静态链接库更改为动态链接版本相当简单。你只需要更改 `z_pack` 可执行文件和 `core` 库的 `Makefile`
    文件。
- en: 'The following `Makefile` will create the dynamic-link `core` library variant:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `Makefile` 将创建动态链接的 `core` 库版本：
- en: '[PRE34]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The C++ compiler and linker will be called here unlike the static-link `core`
    library variant. Furthermore, the `-shared` compiler option must be specified
    to create the dynamic-link library.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态链接的 `core` 库版本不同，这里将调用 C++ 编译器和链接器。此外，必须指定 `-shared` 编译器选项来创建动态链接库。
- en: 'The following `Makefile` is for the `z_pack` executable to link with the `core`
    library dynamically:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `Makefile` 是为 `z_pack` 可执行文件动态链接 `core` 库而准备的：
- en: '[PRE35]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Linking with external libraries (boost and zlib) is not required here because
    it has occurred in the `core` library building.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在 `core` 库构建中已经发生，这里不需要与外部库（boost 和 zlib）进行链接。
- en: You must copy the `libcore.dll` library and the `z_pack.exe` executable files
    into one directory to run the application.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须将 `libcore.dll` 库和 `z_pack.exe` 可执行文件复制到同一个目录中才能运行应用。
- en: It is important to note that libraries, objects, and executable files compiled
    with Visual C++ and MinGW software are incompatible. This means that you need
    the MinGW version of all static-link and dynamic-link libraries that you want
    to link with your application compiled with MinGW software. You must check the
    existing MinGW version of all third-party libraries that have been used in your
    project before importing this to MinGW software.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，使用 Visual C++ 和 MinGW 软件编译的库、对象和可执行文件是不兼容的。这意味着你需要 MinGW 版本的静态链接和动态链接库，这些库是你想要与使用
    MinGW 软件编译的应用程序链接的。在将项目导入 MinGW 软件之前，你必须检查项目中使用的所有第三方库的现有 MinGW 版本。
- en: 4 – Debugging application
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4 – 应用程序调试
- en: MinGW software contains **GNU Debugger** (**GDB**). This is a standard tool
    to debug applications developed with MinGW software. You can't use GDB to debug
    projects compiled with the Visual C++ compiler.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: MinGW 软件包含 **GNU 调试器**（**GDB**）。这是一个用于调试使用 MinGW 软件开发的应用的标准化工具。你不能使用 GDB 来调试使用
    Visual C++ 编译器编译的项目。
- en: 'You can install GDB manually if it doesn''t exist in your MinGW software distribution.
    Perform the following instructions to do the same:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 MinGW 软件发行版中没有 GDB，你可以手动安装它。按照以下说明进行操作：
- en: 'Download the GDB application archive from the official download page:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从官方下载页面下载 GDB 应用程序归档：
- en: '[http://sourceforge.net/projects/mingw/files/MinGW/Extension/gdb](http://sourceforge.net/projects/mingw/files/MinGW/Extension/gdb)'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://sourceforge.net/projects/mingw/files/MinGW/Extension/gdb](http://sourceforge.net/projects/mingw/files/MinGW/Extension/gdb)'
- en: Some problems might occur with the latest GDB version's launching. Try to install
    the previous debugger version if you get errors.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能会与最新 GDB 版本的启动出现一些问题。如果你遇到错误，请尝试安装之前的调试器版本。
- en: Extract the downloaded archive to the MinGW software installation directory.
    I recommend you to extract the archive to `C:\MinGW\git` if you have installed
    MinGW software with Git as described in this book.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的存档提取到 MinGW 软件安装目录中。如果你按照本书中的描述安装了带有 Git 的 MinGW 软件，我建议你将存档提取到 `C:\MinGW\git`。
- en: 'After installing GDB you can test its functionality by typing the following
    command:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装 GDB 后，你可以通过输入以下命令来测试其功能：
- en: '[PRE36]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: GDB has been installed correctly if you see the application using information.
    Now you have the necessary debugger utility to start debugging your MinGW-based
    application.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到应用程序使用信息，则表示 GDB 已正确安装。现在你有了必要的调试工具来开始调试基于 MinGW 的应用程序。
- en: Let's debug the example application with GDB. The application is a simple program
    with anull-pointer assignment.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GDB 调试示例应用程序。该应用程序是一个包含空指针赋值的简单程序。
- en: 'The following code shows the content of the source file named `segfault.cpp`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了名为 `segfault.cpp` 的源文件内容：
- en: '[PRE37]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The null-pointer assignment operation occurs in the `bar` function. The `bar`
    function is called from `foo` and the `foo` function is called from the `main`
    function.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 空指针赋值操作发生在 `bar` 函数中。`bar` 函数由 `foo` 函数调用，而 `foo` 函数由 `main` 函数调用。
- en: 'The following `Makefile` is to compile the example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `Makefile` 用于编译示例：
- en: '[PRE38]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The MinGW C++ compiler doesn't include debug information in output binary files
    by default. We need to add the `-g` compiler option to do it in this `Makefile`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: MinGW C++ 编译器默认不将调试信息包含在输出二进制文件中。我们需要在 `Makefile` 中添加 `-g` 编译器选项来实现这一点。
- en: You will get the `segfault.exe` executable file with debugging symbols after
    compilation. It means that GDB can inform you not only about memory addresses
    but also the names of routines and variables.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，你会得到带有调试符号的 `segfault.exe` 可执行文件。这意味着 GDB 不仅会告诉你内存地址，还会告诉你例程和变量的名称。
- en: 'Type the following command to start debugging our example application:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令以开始调试我们的示例应用程序：
- en: '[PRE39]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To start the application with command-line arguments use the `--args` GDB option.
    For example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用命令行参数启动应用程序，请使用 `--args` GDB 选项。例如：
- en: '[PRE40]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The input and output filenames will be passed to the `z_pack.exe` application
    in this case.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输入和输出文件名将被传递到 `z_pack.exe` 应用程序。
- en: 'You will see the GDB command prompt after launching the debugger. Type the
    `r` command to run the loaded application:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 启动调试器后，你会看到 GDB 命令提示符。输入 `r` 命令来运行已加载的应用程序：
- en: '[PRE41]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is the short variant of the `run` command. Most of the GDB commands have
    common and short variants. All future commands will be described with short variants
    because they are easy to remember and type.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `run` 命令的简短变体。大多数 GDB 命令都有常用和简短的变体。所有未来的命令都将使用简短变体来描述，因为它们容易记忆和输入。
- en: 'You will see this program crash message after the application starts running,
    as shown in the following screenshot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动运行后，你会看到此程序崩溃信息，如下截图所示：
- en: '![4 – Debugging application](img/5626_01_02.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![4 – 调试应用程序](img/5626_01_02.jpg)'
- en: 'You can see that the program abortion is receiving the `SIGSEGV` signal by
    application. The POSIX system sends this signal to process when it makes an invalid
    virtual memory reference or segmentation fault. Furthermore the source file''s
    line, where the error has occurred, is displayed here. The following is the sixth
    line of the `segfault.cpp` file:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到程序终止时正在接收 `SIGSEGV` 信号。当 POSIX 系统检测到无效的虚拟内存引用或段错误时，它会向进程发送此信号。此外，发生错误的源文件行也会在这里显示。以下为
    `segfault.cpp` 文件的第六行：
- en: '[PRE42]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Our example program execution has stopped after the crash. You can interact
    with the debugger through the command line when the program is stopped. For example,
    you can get the **stack backtrace** to explore the nested functions'' calls. Type
    the `bt` command as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例程序在崩溃后停止执行。当程序停止时，你可以通过命令行与调试器交互。例如，你可以获取 **堆栈跟踪** 来探索嵌套函数的调用。如下输入 `bt`
    命令：
- en: '[PRE43]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You will see something like the following screenshot:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似以下截图的内容：
- en: '![4 – Debugging application](img/5626_01_03.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![4 – 调试应用程序](img/5626_01_03.jpg)'
- en: You will see called functions' names and source file lines, where these have
    been called by the program just before it crashed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到程序在崩溃前调用的函数名称和源文件行。
- en: 'Moreover, you can get a list of source file lines in the error place by the
    `l` command:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以通过`l`命令获取错误位置处的源文件行列表：
- en: '[PRE44]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You will see the `bar` function source code. Now you have enough information
    to fix the segmentation fault error.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到`bar`函数的源代码。现在您有足够的信息来修复段错误错误。
- en: 'To quit from GDB type the `q` command:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出GDB，请输入`q`命令：
- en: '[PRE45]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And type `y` to confirm.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 并输入`y`以确认。
- en: 'GDB allows you to set breakpoints to stop program execution in a predefined
    place. There are several breakpoint types. The simplest types are a breakpoint
    at entry to the function and a breakpoint at a line in a source file. You need
    to specify the application source files directory to provide access to these for
    GDB. The command to start the application debugging in this case will look like
    the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: GDB允许您在预定义的位置设置断点以停止程序执行。有几种断点类型。最简单的类型是在函数入口处设置断点和在源文件中的行设置断点。您需要指定应用程序源文件目录以提供对GDB的访问。在这种情况下启动应用程序调试的命令将如下所示：
- en: '[PRE46]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `--directory` command-line option defines the source files directory. The
    current directory has been added in this example (the current directory equals
    to point symbol).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`--directory`命令行选项定义源文件目录。在此示例中已添加当前目录（当前目录等于点符号）。'
- en: 'All the loaded directories are available by typing the following command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入以下命令可以获取所有已加载的目录：
- en: '[PRE47]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following command is used to set a breakpoint at the `foo` function from
    the `segfault.cpp` source file:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令用于在`segfault.cpp`源文件的`foo`函数处设置断点：
- en: '[PRE48]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To set a breakpoint at the fifth line of the `segfault.cpp` source file type
    the following command:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`segfault.cpp`源文件的第五行设置断点，请输入以下命令：
- en: '[PRE49]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A list with information about all the current defined breakpoints is available
    by using the following command:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令可以获取所有当前定义的断点信息列表：
- en: '[PRE50]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can run our example program after setting breakpoints:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 设置断点后，您可以运行我们的示例程序：
- en: '[PRE51]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Program execution will be stopped at the first breakpoint in the `foo` function
    after that. You can continue execution by using the `c` command:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置断点后，程序执行将在`foo`函数的第一个断点处停止。您可以使用`c`命令继续执行：
- en: '[PRE52]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Type this and the next breakpoint at the fifth line of the `segfault.cpp` source
    file will be achieved. The backtrace information and source file lines are available
    at each breakpoint.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 输入此命令，然后在`segfault.cpp`源文件的第五行设置下一个断点。在每一个断点，都可以查看回溯信息和源文件行。
- en: 'Watchpoint is a special breakpoint type to detect read and write variable operations.
    This command is used to set a watchpoint for the `pointer` variable:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 观察点是一种特殊的断点类型，用于检测读取和写入变量操作。此命令用于为`pointer`变量设置观察点：
- en: '[PRE53]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: GDB can set such watchpoints if variables have been defined in the current context.
    This means that you must stop program execution at the `bar` function and then
    set a watchpoint for its local `pointer` variable. The program can be stopped
    in the `main` function to set a watchpoint for any global variable.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在当前上下文中已定义了变量，GDB可以设置此类观察点。这意味着您必须在`bar`函数处停止程序执行，然后为其局部`pointer`变量设置观察点。您可以在`main`函数中停止程序以设置任何全局变量的观察点。
- en: 'Moreover, you can configure GDB to display a list of variables with the current
    values at each breakpoint hit. To add the `pointer` variable in this list type
    the following command:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以配置GDB，在每次断点命中时显示具有当前值的变量列表。要将`pointer`变量添加到此列表中，请输入以下命令：
- en: '[PRE54]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The value of the `pointer` variable will be displayed at the next breakpoint
    program stop.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个断点程序停止时，将显示`pointer`变量的值。
- en: 'You can disable a breakpoint of any type to prevent the program from stopping
    at it. The following is the command to do it:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以禁用任何类型的断点以防止程序在它处停止。执行此操作的命令如下：
- en: '[PRE55]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The specified number is a breakpoint identifier. This identifier is declared
    in the breakpoints information list.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 指定的数字是断点标识符。此标识符在断点信息列表中声明。
- en: 'To enable the breakpoint type the following command:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用断点，请输入以下命令：
- en: '[PRE56]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The breakpoint can be removed if it is no longer needed:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不再需要，可以删除断点：
- en: '[PRE57]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'There are several useful commands for tracing a program:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个有用的命令用于跟踪程序：
- en: 'Continue to run a program until the control reaches a different source line
    (analogous of trace into):'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续运行程序，直到控制到达不同的源行（类似于进入跟踪）：
- en: '[PRE58]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Continue to the next source line in the current stack frame (analogous of step
    over):'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续到当前堆栈帧中的下一个源行（类似于步进）：
- en: '[PRE59]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Continue execution until the function in the selected stack frame returns:'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继续执行，直到所选堆栈帧中的函数返回：
- en: '[PRE60]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: These commands can be used after the program has run and been stopped by breakpoint.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令可以在程序运行后，通过断点停止后使用。
- en: 'You can rebuild your application without debug information to produce release
    variants of executable files and libraries. But there is a possibility to remove
    debug information from existing binary files. Use the `strip` command as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不包含调试信息的情况下重新构建你的应用程序，以生成可执行文件和库的发布版本。但有可能从现有的二进制文件中移除调试信息。使用以下`strip`命令：
- en: '[PRE61]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: GDB is quite useful to debug abnormal program behavior (segmentation faults,
    for example). But using the same approaches as the test suite and event logging
    can complete the GDB capabilities for the algorithms' correctness checking.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: GDB对于调试异常程序行为（例如段错误）非常有用。但使用与测试套件和事件日志相同的方法可以完成GDB对算法正确性检查的功能。
- en: 5 – Profiling application
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5 – 分析应用程序
- en: MinGW software contains the gprof performance analyzing tool. This instrument
    can be useful for tracking down an application's bottlenecks. The gprof tool is
    a part of the GNU Binutils collection and therefore it is present in all MinGW
    distributions. You can't use gprof to analyze the performance of applications
    compiled with Visual C++ compiler.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: MinGW软件包含gprof性能分析工具。这个工具对于追踪应用程序的瓶颈非常有用。gprof工具是GNU Binutils集合的一部分，因此它存在于所有MinGW发行版中。你不能使用gprof来分析用Visual
    C++编译器编译的应用程序的性能。
- en: Let's profile an example application with gprof. This application reads bytes
    from a file to an STL `vector` type container, sorts them, and writes the result
    to an output file. The application source code is present in the file named `sorting.cpp`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用gprof来分析一个示例应用程序。该应用程序从文件中读取字节到STL `vector`类型容器，对它们进行排序，并将结果写入输出文件。应用程序的源代码位于名为`sorting.cpp`的文件中。
- en: 'The following is the `main` function definition:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`main`函数的定义：
- en: '[PRE62]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You can see the basic application algorithm in this function. First of all,
    the data is reading from the input text file. Then the data is sorted and written
    to the output file. Each of these steps are implemented in the separate function.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在该函数中看到基本的应用算法。首先，数据是从输入文本文件中读取的。然后，数据被排序并写入输出文件。这些步骤中的每一个都在单独的函数中实现。
- en: 'The following code shows the `ReadData` function''s definition:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`ReadData`函数的定义：
- en: '[PRE63]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The stream of the `ifstream` class with the `in_file` name is used here to read
    the `source.txt` input file content. Then the STL `copy` algorithm is used to
    copy the `in_file` stream content to the global `gData` container of the `vector<char>`
    class. We use the iterator of the `istream_iterator` class to access elements
    of the `in_file` stream in the `copy` algorithm.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用具有`in_file`名称的`ifstream`类的流来读取`source.txt`输入文件的内容。然后使用STL `copy`算法将`in_file`流的内容复制到全局`gData`容器中，该容器是`vector<char>`类的。我们在`copy`算法中使用`istream_iterator`类的迭代器来访问`in_file`流中的元素。
- en: 'The `SortData` function implements the simplest bubble sort algorithm:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortData`函数实现了最简单的冒泡排序算法：'
- en: '[PRE64]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This sort algorithm processes the elements of the `gData` container.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此排序算法处理`gData`容器中的元素。
- en: 'The following is the `WriteResult` function definition:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`WriteResult`函数的定义：
- en: '[PRE65]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The stream of the `ofstream` class with the `out_file` name is used here to
    write the `gData` container content to the output `result.txt` file. The `write`
    method of the `out_file` stream is called here to perform the file writing operation.
    An empty file with the `result.txt` name will be created to write if this file
    already exists. The `sorting.cpp` file is available in the code bundle uploaded
    on the Packt website.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用具有`out_file`名称的`ofstream`类的流来将`gData`容器的内容写入输出`result.txt`文件。这里调用`out_file`流的`write`方法来执行文件写入操作。如果该文件已存在，将创建一个空文件`result.txt`来写入。`sorting.cpp`文件可在Packt网站上上传的代码包中找到。
- en: 'The following is `Makefile` for the example application:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为示例应用程序的`Makefile`：
- en: '[PRE66]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Profiling information is needed for performance analyzing. This information
    can be generated by an executable file's extra code. The same kind of extra code
    creation is an optional feature of the compiler and this feature can be specified
    by the compiler `-pg` option. This option must be specified for each object file
    compilation and final linking. The `CXXFLAGS` environment variable is used to
    do this in our `Makefile`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析需要配置信息。这些信息可以通过可执行文件的额外代码生成。这种类型的额外代码创建是编译器的可选功能，并且可以通过编译器的 `-pg` 选项指定。此选项必须为每个对象文件编译和最终链接指定。在我们的
    `Makefile` 中使用 `CXXFLAGS` 环境变量来完成此操作。
- en: 'You can test our example application after compilation. Just copy any plain
    text file to project directory with, name it `source.txt`, and run the `sorting.exe`
    executable file. You will get the `result.txt` file with the sorted source file
    content after the application finishes its work. Perform the following steps to
    profile our example application:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在编译后测试我们的示例应用程序。只需将任何纯文本文件复制到项目目录中，命名为 `source.txt`，然后运行 `sorting.exe` 可执行文件。应用程序完成工作后，您将获得包含排序源文件内容的
    `result.txt` 文件。执行以下步骤来分析我们的示例应用程序：
- en: Launch the application's executable file. After that you will get the `gmon.out`
    file with the profiling data in the current working directory.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序的可执行文件。之后，您将在当前工作目录中获得包含分析数据的 `gmon.out` 文件。
- en: 'Run the gprof utility to interpret the `gmon.out` file information and write
    the result to the `profile.txt` output file:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 gprof 工具来解释 `gmon.out` 文件信息，并将结果写入 `profile.txt` 输出文件：
- en: '[PRE67]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'These gprof utility options have been used in the preceding:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中使用了以下 gprof 工具选项：
- en: The `-z` option is required to include all used functions in the output file
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-z` 选项是必需的，以便在输出文件中包含所有使用的函数'
- en: The `-q` option causes a call-graph of the program for a more detailed report
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-q` 选项会导致程序调用图，以生成更详细的报告'
- en: You have got a text report with the profiling data in the `profile.txt` file.
    It can be opened in any text editor. But this text representation of the profiling
    information is not comfortable to discovery. There are handy tools for visualizing
    a gprof report.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您在 `profile.txt` 文件中得到了包含分析数据的文本报告。它可以在任何文本编辑器中打开。但是，这种分析信息的文本表示不太方便进行发现。有方便的工具可以可视化
    gprof 报告。
- en: 'For visualization we need the following tools:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可视化，我们需要以下工具：
- en: Python 2.7 interpreter
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 2.7 解释器
- en: Python script to convert the gprof report to dot file format
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 gprof 报告转换为 dot 文件格式的 Python 脚本
- en: Graphviz package with visualization utilities for dot format
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含 dot 格式可视化工具的 Graphviz 软件包
- en: 'You can download Python version 2.7 from the following official website:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下官方网站下载 Python 2.7 版本：
- en: '[http://python.org/download](http://python.org/download)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://python.org/download](http://python.org/download)'
- en: Python can be installed with the standard Windows Installer. To do this just
    run the downloaded MSI file.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Python 可以使用标准的 Windows 安装程序进行安装。为此，只需运行下载的 MSI 文件。
- en: 'The script to convert a gprof report text file to dot format is available on
    the following developer page:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 将 gprof 报告文本文件转换为 dot 格式的脚本可在以下开发者页面上找到：
- en: '[http://code.google.com/p/jrfonseca/wiki/Gprof2Dot](http://code.google.com/p/jrfonseca/wiki/Gprof2Dot)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://code.google.com/p/jrfonseca/wiki/Gprof2Dot](http://code.google.com/p/jrfonseca/wiki/Gprof2Dot)'
- en: This script is a free software and you can use, distribute, and modify it as
    you want. To install this script copy it to `C:\MinGW\bin` or `C:\MinGW\git\bin`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本是免费软件，您可以根据自己的意愿使用、分发和修改它。要安装此脚本，请将其复制到 `C:\MinGW\bin` 或 `C:\MinGW\git\bin`。
- en: 'The Graphviz package is available at the following official website:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Graphviz 软件包可在以下官方网站获取：
- en: '[http://www.graphviz.org/Download_windows.php](http://www.graphviz.org/Download_windows.php)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.graphviz.org/Download_windows.php](http://www.graphviz.org/Download_windows.php)'
- en: Graphviz can be installed with Windows Installer in the same way as Python interpreter.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Graphviz 可以像 Python 解释器一样使用 Windows 安装程序进行安装。
- en: 'Now you have the necessary scripts and the visualization utility to visualize
    our profiling results. Perform the following steps to do this:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了必要的脚本和可视化工具来可视化我们的分析结果。执行以下步骤来完成此操作：
- en: 'Run the `gprof2dot.py` script to get the dot file:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `gprof2dot.py` 脚本以获取 dot 文件：
- en: '[PRE68]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This `gprof2dot.py` utility option has been used here.
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里使用了 `gprof2dot.py` 工具选项。
- en: The `-s` option removes functions and templates argument information.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`-s` 选项删除了函数和模板参数信息。'
- en: After that you will get the `profile.dot` file with call-graph of the program.
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后，您将获得包含程序调用图的 `profile.dot` 文件。
- en: Run the `gvedit.exe` application. It is available from the **Start** menu of
    Windows. Go to **File** | **Open** from the main menu. Specify the `profile.dot`
    file.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `gvedit.exe` 应用程序。它可以从 Windows 的 **开始** 菜单中获取。从主菜单中选择 **文件** | **打开**。指定
    `profile.dot` 文件。
- en: 'You will see a call-graph of the program as shown in the following screenshot:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到程序如下截图所示的调用图：
- en: '![5 – Profiling application](img/5626_01_04.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![5 – 应用程序分析](img/5626_01_04.jpg)'
- en: 'You can see a call-graph in the preceding screenshot. Nodes of this graph are
    represented as colored edges. These nodes represent called functions of the analyzing
    program. Each edge contains the following information:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在前面的截图中看到一个调用图。此图的节点用彩色边表示。这些节点代表分析程序中调用的函数。每条边包含以下信息：
- en: '**Total time %** is the percentage of the running time spent in this function
    and all its children'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总时间百分比**是指在此函数及其所有子函数中花费的运行时间百分比'
- en: '**Self time %** (in brackets) is the percentage of the running time spent in
    this function alone'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自身时间百分比**（括号内）是指仅在此函数中花费的运行时间百分比'
- en: '**Total calls** is the total number of times this function was called (including
    recursive calls)'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总调用次数**是指此函数被调用的总次数（包括递归调用）'
- en: Moreover, nodes have temperature-like colors according to the total time percent
    value. Most time expensive functions display as red (hot-spot) edges and the most
    cheap ones as dark blue.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，节点根据总时间百分比值具有类似温度的彩色。耗时最多的函数显示为红色（热点）边，耗时最少的函数显示为深蓝色。
- en: 'The most execution time of our example application has been spent in the red
    colored `SortData` function. Statistic information about the `SortData` function
    at graph confirms it:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序的大部分执行时间都花在了红色的 `SortData` 函数上。图中的统计信息证实了这一点：
- en: Total time is equal to 99.35 percent
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总时间是 99.35 百分比
- en: Self time is equal to 55.81 percent
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自身时间是 55.81 百分比
- en: Total calls is equal to 1
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总调用次数等于 1
- en: 'We can use the STL `sort` algorithm instead of the bubble one to optimize our
    example application. Let''s change the code of the `SortData` function as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 STL 的 `sort` 算法代替冒泡算法来优化我们的示例应用程序。让我们将 `SortData` 函数的代码修改如下：
- en: '[PRE69]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now you need to rebuild the application, run the application, and run gprof
    and the `gprof2dot.py` script. Open the resulting dot file in the Graphviz application.
    You will see the call-graph as shown in the following screenshot:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要重新构建应用程序，运行应用程序，然后运行 gprof 和 `gprof2dot.py` 脚本。在 Graphviz 应用程序中打开生成的 dot
    文件。您将看到如下截图所示的调用图：
- en: '![5 – Profiling application](img/5626_01_05.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![5 – 应用程序分析](img/5626_01_05.jpg)'
- en: The red edges disappear from the graph. This means that we don't have any explicit
    bottleneck. All program execution time has been evenly distributed between several
    functions.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 红色边从图中消失。这意味着我们没有任何明显的瓶颈。所有程序执行时间在几个函数之间均匀分布。
- en: 'You can remove the profiling extra code from executable files and libraries
    after profiling with the `strip` command:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `strip` 命令从可执行文件和库中删除分析后的额外代码：
- en: '[PRE70]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Profiling is a significant technique that allows you to find and remove bottlenecks
    in your applications. This may be very helpful for performance analyzing of the
    complex systems with many components and libraries. MinGW software allows you
    to include this technique in your software development process in a simple and
    fast manner.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 分析是一种重要的技术，可以帮助您找到并移除应用程序中的瓶颈。这对于分析具有许多组件和库的复杂系统非常有帮助。MinGW 软件允许您以简单快捷的方式将这项技术纳入您的软件开发流程。
- en: 6 – Developing with cross-platform libraries
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6 – 使用跨平台库进行开发
- en: 'MinGW software allows you to develop applications based on any library compiled
    with the MinGW C++ compiler. Open source libraries are often supplied in Visual
    C++ and MinGW compilation variants. Moreover, you can always get the source code
    of these libraries and build them with your MinGW software. Several well-known
    open source cross-platform frameworks and toolkits are described as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: MinGW 软件允许您使用 MinGW C++ 编译器编译的任何库开发应用程序。开源库通常提供 Visual C++ 和 MinGW 编译变体。此外，您始终可以获取这些库的源代码，并使用您的
    MinGW 软件构建它们。以下是一些著名的开源跨平台框架和工具包的描述：
- en: Qt framework
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 框架
- en: Gtk+ widget toolkit
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gtk+ 小部件工具包
- en: wxWidgets framework
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: wxWidgets 框架
- en: The same functionality example application will be developed with each of these
    libraries. The goal of these examples is to show the first steps to deploy and
    to start working with these libraries.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用这些库中的每一个开发相同的功能示例应用程序。这些示例的目标是展示部署和开始使用这些库的第一步。
- en: Our example application consists of a window with two buttons. A click on the
    first button leads to the display of a message and a click on the second button
    leads to the application termination. This functionality is the same as the one
    described in the *Quick start* section.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序由一个包含两个按钮的窗口组成。点击第一个按钮会显示一条消息，点击第二个按钮会导致应用程序终止。这种功能与*快速入门*部分中描述的功能相同。
- en: The Qt framework
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Qt框架
- en: 'The Qt framework provides not only a cross-platform widget toolkit for GUI
    development but also contains features for SQL database access, XML parsing, thread
    management, interaction over a network, and internalization support. The Qt framework
    has its own container classes such as `Qstring` or `QVector` and a set of well-known
    algorithms such as sorting, searching, and copying to process data in these containers
    that allow you to substitute the capabilities of STL and Boost libraries by the
    Qt ones. This kind of Qt framework self-sufficiency is of great advantage to develop
    cross-platform applications. All you need to do to import your Qt application
    to a new platform is building a Qt framework for this one. There are a lot of
    platforms that are supported by Qt framework developers:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Qt框架不仅提供用于GUI开发的跨平台小部件工具包，还包含用于SQL数据库访问、XML解析、线程管理、网络交互和本地化支持的特性。Qt框架拥有自己的容器类，如`Qstring`或`QVector`，以及一系列知名算法，如排序、搜索和复制，这些算法可以处理这些容器中的数据，允许你用Qt的能力替代STL和Boost库的功能。这种Qt框架的自给自足特性对于开发跨平台应用非常有优势。你只需为这个平台构建一个Qt框架，就可以将你的Qt应用程序导入到新的平台。Qt框架的开发者支持许多平台：
- en: Windows
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows
- en: Mac OS X
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mac OS X
- en: Linux
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux
- en: Solaris
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solaris
- en: Symbian
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Symbian
- en: Android (unofficial framework port with the name Ministro)
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android（名为Ministro的非官方框架端口）
- en: 'Let''s begin our work with the Qt framework. It is important to note that Qt
    libraries have been compiled with the specific MinGW software version. Your application
    must be compiled with the same MinGW version and therefore you must install it.
    The alternative way is the compilation of Qt libraries sources with your already
    installed MinGW software, but this variant will not be described in this book.
    You can find some helpful instructions to do this at the following website:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Qt框架开始我们的工作。重要的是要注意，Qt库是用特定的MinGW软件版本编译的。你的应用程序必须用相同的MinGW版本编译，因此你必须安装它。另一种方式是用你已安装的MinGW软件编译Qt库的源代码，但这个变体将不会在本书中描述。你可以在以下网站上找到一些有用的说明来完成这项工作：
- en: '[http://www.formortals.com/build-qt-static-small-microsoft-intel-gcc-compiler](http://www.formortals.com/build-qt-static-small-microsoft-intel-gcc-compiler)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.formortals.com/build-qt-static-small-microsoft-intel-gcc-compiler](http://www.formortals.com/build-qt-static-small-microsoft-intel-gcc-compiler)'
- en: 'All other toolkits described here don''t need a specific MinGW software version.
    The following are instructions to install Qt libraries version 4.6.4 and some
    necessary software to start developing with it:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的所有其他工具包都不需要特定的MinGW软件版本。以下是将Qt库版本4.6.4及其一些必要软件安装以开始开发的说明：
- en: 'Download the MinGW version of the Qt libraries for Windows from the following
    official website:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下官方网站下载Windows版本的Qt库的MinGW版本：
- en: '[http://qt-project.org/downloads](http://qt-project.org/downloads)'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://qt-project.org/downloads](http://qt-project.org/downloads)'
- en: Note that this library has been compiled with a specific (equal in our case
    to 4.4) MinGW software version.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这个库是用特定的（在我们的案例中等于4.4）MinGW软件版本编译的。
- en: Install the downloaded Qt libraries with the setup wizard. Run the downloaded
    exe file to do it.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用设置向导安装下载的Qt库。运行下载的exe文件即可完成。
- en: 'Download the MinGW software of version 4.4 from the following official download
    page:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下官方下载页面下载版本4.4的MinGW软件：
- en: '[http://sourceforge.net/projects/mingw/files/MinGW/Base/gcc/Version4/Previous%20Release%20gcc-4.4.0/](http://sourceforge.net/projects/mingw/files/MinGW/Base/gcc/Version4/Previous%20Release%20gcc-4.4.0/)'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://sourceforge.net/projects/mingw/files/MinGW/Base/gcc/Version4/Previous%20Release%20gcc-4.4.0/](http://sourceforge.net/projects/mingw/files/MinGW/Base/gcc/Version4/Previous%20Release%20gcc-4.4.0/)'
- en: You need the file to be named `gcc-full-4.4.0-mingw32-bin-2.tar.lzma`. This
    is an archive with the MinGW compilers' executable files and necessary core libraries.
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要的文件名为 `gcc-full-4.4.0-mingw32-bin-2.tar.lzma`。这是一个包含 MinGW 编译器的可执行文件和必要核心库的归档文件。
- en: Extract the downloaded MinGW software archive to the directory without spaces
    in the path (for example, `C:\MinGW4.4`).
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的 MinGW 软件归档文件解压到路径中不含空格的目录中（例如，`C:\MinGW4.4`）。
- en: 'You can use the 7-Zip application to extract the LZMA archive type. This application
    is available at the following official website:'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用 7-Zip 应用程序提取 LZMA 归档类型。此应用程序可在以下官方网站上找到：
- en: '[http://www.7-zip.org/download.html](http://www.7-zip.org/download.html)'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.7-zip.org/download.html](http://www.7-zip.org/download.html)'
- en: 'Download the GNU Binutils for MinGW software from the following official download
    page:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下官方下载页面下载 MinGW 的 GNU Binutils 软件：
- en: '[http://sourceforge.net/projects/mingw/files/MinGW/Base/binutils/binutils-2.19](http://sourceforge.net/projects/mingw/files/MinGW/Base/binutils/binutils-2.19)'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://sourceforge.net/projects/mingw/files/MinGW/Base/binutils/binutils-2.19](http://sourceforge.net/projects/mingw/files/MinGW/Base/binutils/binutils-2.19)'
- en: You need the archive to be named `binutils-2.19-2-mingw32-bin.tar.gz`.
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 需要的归档文件名为 `binutils-2.19-2-mingw32-bin.tar.gz`。
- en: Extract the downloaded GNU Binutils archive to the same directory as the MinGW
    software. This is `C:\MinGW4.4` in our case.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的 GNU Binutils 归档文件解压到与 MinGW 软件相同的目录中。在我们的例子中是 `C:\MinGW4.4`。
- en: 'Download the GNU Make utility from the following web page:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下网页下载 GNU Make 工具：
- en: '[http://sourceforge.net/projects/mingw/files/MinGW/Extension/make/mingw32-make-3.80-3](http://sourceforge.net/projects/mingw/files/MinGW/Extension/make/mingw32-make-3.80-3)'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://sourceforge.net/projects/mingw/files/MinGW/Extension/make/mingw32-make-3.80-3](http://sourceforge.net/projects/mingw/files/MinGW/Extension/make/mingw32-make-3.80-3)'
- en: You need to download the `mingw32-make-3.80.0-3.exe` file.
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您需要下载的文件是 `mingw32-make-3.80.0-3.exe`。
- en: Install GNU Make utility to the MinGW software directory (`C:\MinGW4.4`). Run
    the downloaded exe file and use the setup wizard to do it.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 GNU Make 工具安装到 MinGW 软件目录中（`C:\MinGW4.4`）。运行下载的 exe 文件，并使用安装向导来完成安装。
- en: Add the installation MinGW software path to the `PATH` Windows environment variable.
    Remove the existing paths of other MinGW software installations from there. The
    `C:\MinGW4.4\bin` path must be added in our example.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将安装的 MinGW 软件路径添加到 `PATH` Windows 环境变量中。从那里删除其他 MinGW 软件安装的现有路径。在我们的例子中，必须添加
    `C:\MinGW4.4\bin` 路径。
- en: Now you have the necessary libraries and specific MinGW software version to
    start developing an application based on the Qt framework.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了必要的库和特定的 MinGW 软件版本，可以开始基于 Qt 框架开发应用程序了。
- en: 'Our example application is implemented in the `main.cpp` source file. The following
    is the `main` function definition:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序是在 `main.cpp` 源文件中实现的。以下是对 `main` 函数的定义：
- en: '[PRE71]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: First of all, the object of the `QApplication` class named `application` is
    created here. This object is used to manage the application's control flow and
    main settings. After that, the window of the `QMainWindow` class named `window`
    is created by the `CreateWindow` function. Two window buttons are created by the
    `CreateMsgButton` and `CreateQuitButton` functions. The `exec` method of the `application`
    object is called to enter the main event loop when all user interface objects
    have been created. Now the application starts processing events such as button
    pressing.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建了一个名为 `application` 的 `QApplication` 类对象。这个对象用于管理应用程序的控制流和主要设置。之后，通过 `CreateWindow`
    函数创建了名为 `window` 的 `QMainWindow` 类窗口。通过 `CreateMsgButton` 和 `CreateQuitButton`
    函数创建了两个窗口按钮。当所有用户界面对象都创建完成后，调用 `application` 对象的 `exec` 方法进入主事件循环。现在应用程序开始处理按钮按下等事件。
- en: 'The following is the `CreateWindow` function that encapsulate''s the main application
    window creation:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对封装主应用程序窗口创建的 `CreateWindow` 函数：
- en: '[PRE72]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The main application window is an object of the `QMainWindow` class named `window`
    . It is created by a constructor that has two input parameters. The first parameter
    is of the `QWidget*` type. This is a pointer to the window's parent widget. It
    equals to zero in our case which means that there is no parent widget. The second
    parameter is of the `Qt::WindowFlags` type and defines the window style. It equals
    to `Qt::Window` that matches the standard window appearance with the system frame
    and title bar.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 主应用程序窗口是 `QMainWindow` 类的一个对象，名为 `window`。它通过一个具有两个输入参数的构造函数创建。第一个参数是 `QWidget*`
    类型，这是一个指向窗口父窗口的指针。在我们的例子中，它等于零，这意味着没有父窗口。第二个参数是 `Qt::WindowFlags` 类型，它定义了窗口样式。它等于
    `Qt::Window`，这与具有系统框架和标题栏的标准窗口外观相匹配。
- en: After the main window creation its size is set with the `resize` method of the
    `window` object. Then the window title is set with the `setWindowTitle` method
    of the `window` object. The next action is to make the main window visible by
    using the `show` method of the `window` object. The function returns the pointer
    to the created `window` object.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建主窗口后，使用 `window` 对象的 `resize` 方法设置其大小。然后，使用 `window` 对象的 `setWindowTitle`
    方法设置窗口标题。接下来的操作是使用 `window` 对象的 `show` 方法使主窗口可见。函数返回创建的 `window` 对象的指针。
- en: 'The following code shows the `CreateMsgButton` function that encapsulates the
    creation of button with message showing action:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了封装创建带有显示消息动作的按钮的 `CreateMsgButton` 函数：
- en: '[PRE73]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: At first, we need to create a message window to display it when we click on
    the button. This message window is an object of the `QMessageBox` class named
    `message`. It is created by a constructor with one input parameter of the `QWidget*`
    type. This is a pointer to the parent widget. The text displayed in the message
    window is set by the `setText` method of the `message` object.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个消息窗口，以便在点击按钮时显示它。这个消息窗口是 `QMessageBox` 类的一个对象，名为 `message`。它通过一个带有
    `QWidget*` 类型输入参数的构造函数创建。这是一个指向父窗口的指针。消息窗口中显示的文本通过 `message` 对象的 `setText` 方法设置。
- en: Now we need a button that will be placed at the main window. This button is
    the object of the `QPushButton` class named `button`. The constructor with two
    input parameters is used here to create this object. The first parameter is a
    string with the button text of the `QString` class. The second parameter is the
    parent widget pointer. The position and size of the `button` object are set by
    the `move` and `resize` methods. After configuring the button we make it visible
    by using the `show` method.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个按钮，它将被放置在主窗口中。这个按钮是 `QPushButton` 类的一个对象，名为 `button`。这里使用带有两个输入参数的构造函数来创建这个对象。第一个参数是一个
    `QString` 类的字符串，包含按钮文本。第二个参数是父窗口指针。`button` 对象的位置和大小通过 `move` 和 `resize` 方法设置。配置完按钮后，我们通过使用
    `show` 方法使其可见。
- en: Now we need to bind the button press event and message window displaying. The
    `connect` static method of the `QObject` class is used here for this goal. It
    allows to create a connection between the `button` object's release signal and
    the `exec` method of the `message` object. The `exec` method causes the displaying
    of window with message.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要绑定按钮按下事件和消息窗口显示。这里使用 `QObject` 类的 `connect` 静态方法来实现这个目标。它允许在 `button`
    对象的释放信号和 `message` 对象的 `exec` 方法之间创建连接。`exec` 方法会导致显示带有消息的窗口。
- en: 'The following code shows the `CreateQuitButton` function that encapsulates
    the creation of the close application button:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了封装创建关闭应用程序按钮的 `CreateQuitButton` 函数：
- en: '[PRE74]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This function is similar the `CreateMsgButton` function. But the message window
    isn't created here. The close application button is an object of the `QPushButton`
    class named `quit_button`. The `release` signal of the `quit_button` button is
    connected to the `quit` method of the `application` object. This method leads
    to the application closing with successful code.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与 `CreateMsgButton` 函数类似。但在这里没有创建消息窗口。关闭应用程序按钮是 `QPushButton` 类的一个对象，名为
    `quit_button`。`quit_button` 按钮的 `release` 信号连接到 `application` 对象的 `quit` 方法。这个方法会导致应用程序以成功代码关闭。
- en: The full `main.cpp` file is available in the code bundle uploaded on the Packt
    website.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `main.cpp` 文件可以在 Packt 网站上上传的代码包中找到。
- en: 'Now you are ready to build an example application. You need to perform the
    following instructions:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好构建一个示例应用程序。你需要执行以下指令：
- en: 'Create a Qt project file with the following command:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个 Qt 项目文件：
- en: '[PRE75]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You will get a file with the `pro` extension and name of the current directory.
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将得到一个扩展名为`pro`且与当前目录同名的文件。
- en: 'Create `Makefile`, service files, and subdirectories with the following command:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建`Makefile`、服务文件和子目录：
- en: '[PRE76]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Compile the project with the GNU Make utility:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 GNU Make 工具编译项目：
- en: '[PRE77]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The GNU Make utility executable name is `mingw32-make` in the official distribution.
    This one has been installed with the MinGW software of version 4.4.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: GNU Make 工具的可执行文件名在官方发行版中是`mingw32-make`。这个版本是与 4.4 版本的 MinGW 软件一起安装的。
- en: You will get the `qt.exe` executable file in the `debug` subdirectory after
    compilation.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后，你将在`debug`子目录中找到`qt.exe`可执行文件。
- en: 'This is the debugging version of our example application. Type the following
    command to build the `release` version:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们示例应用的调试版本。输入以下命令以构建`release`版本：
- en: '[PRE78]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The `qt.exe` executable file will be created in the `release` subdirectory after
    this compilation.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后，`qt.exe`可执行文件将在`release`子目录中创建。
- en: The Gtk+ widget toolkit
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gtk+ 小部件工具包
- en: 'Gtk+ is a cross-platform toolkit with many widgets to construct user interfaces.
    It is important to note that Gtk+ has been written in C language. This toolkit
    has an object model, but there are no C++ classes and objects. You can use the
    toolkit in your C++ applications, but it may be helpful to use the gtkmm. The
    gtkmm is an official C++ interface for Gtk+. The gtkmm interface is not described
    in this book, but you can get more information about it at the following official
    website:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: Gtk+ 是一个跨平台工具包，具有许多小部件来构建用户界面。重要的是要注意，Gtk+ 是用 C 语言编写的。这个工具包有一个对象模型，但没有 C++ 类和对象。你可以在你的
    C++ 应用程序中使用这个工具包，但使用 gtkmm 可能会有所帮助。gtkmm 是 Gtk+ 的官方 C++ 接口。关于 gtkmm 接口，本书没有描述，但你可以在以下官方网站上获取更多信息：
- en: '[http://www.gtkmm.org](http://www.gtkmm.org)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.gtkmm.org](http://www.gtkmm.org)'
- en: Gtk+ is a good choice if you are looking for a widget toolkit for user interface
    creation and you don't need any additional features provided by the Qt framework.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找用于创建用户界面的小部件工具包且不需要 Qt 框架提供的任何附加功能，Gtk+ 是一个好的选择。
- en: 'The following are the instructions to install the Gtk+ widget toolkit:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何安装 Gtk+ 小部件工具包的说明：
- en: 'Download the all-in-one bundle archive with the Gtk+ widget toolkit from the
    following official website:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下官方网站下载包含 Gtk+ 小部件工具包的完整捆绑包存档：
- en: '[http://www.gtk.org/download/win32.php](http://www.gtk.org/download/win32.php)'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.gtk.org/download/win32.php](http://www.gtk.org/download/win32.php)'
- en: Extract the archive to the directory without spaces in the path (for example,
    `C:\Gtk+`).
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存档提取到路径中不含空格的目录中（例如，`C:\Gtk+`）。
- en: Add the installation path of the Gtk+ toolkit to the `PATH` Windows environment
    variable. The path, `C:\Gtk+\bin`, must be added in our case.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Gtk+ 工具包的安装路径添加到`PATH` Windows环境变量中。在我们的例子中，路径`C:\Gtk+\bin`必须被添加。
- en: Create a new Windows environment variable named `PKG_CONFIG_PATH`. Specify the
    path to the `pkg-config` utility files as a value of this variable. This is `C:\Gtk+\lib\pkgconfig`
    in our case.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`PKG_CONFIG_PATH`的新 Windows 环境变量。将`pkg-config`实用程序文件的路径指定为该变量的值。在我们的例子中，这是`C:\Gtk+\lib\pkgconfig`。
- en: Now you have the necessary libraries to start developing applications with the
    Gtk+ widget toolkit. Unlike the Qt framework you don't need the same MinGW software
    version as Gtk+ libraries have been compiled with. Any already installed MinGW
    software can be used to compile your applications.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了使用 Gtk+ 小部件工具包开发应用程序所需的库。与 Qt 框架不同，你不需要与 Gtk+ 库相同的 MinGW 软件版本，因为 Gtk+ 库是用
    MinGW 软件编译的。任何已安装的 MinGW 软件都可以用来编译你的应用程序。
- en: 'Our example application is implemented in the `main.cpp` source file. The following
    is the `main` function definition:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序是在`main.cpp`源文件中实现的。以下是`main`函数的定义：
- en: '[PRE79]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: First of all the `gtk_init` function is called. It initializes everything that
    we need to operate with Gtk+ toolkit. Four widgets are created in the `main` function
    after that. There are the main window, vertical box container, and two buttons.
    The main window is a pointer to the `GtkWidget` Gtk+ structure that is created
    by the `CreateWindow` function.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，调用`gtk_init`函数，它初始化我们使用 Gtk+ 工具包所需的一切。之后在`main`函数中创建了四个小部件。它们是主窗口、垂直框容器和两个按钮。主窗口是`CreateWindow`函数创建的`GtkWidget`
    Gtk+ 结构的指针。
- en: The box container is needed to place several widgets in the main window (two
    buttons in our case). This box container is a pointer to the `GtkWidget` structure
    that is created by the `gtk_vbox_new` Gtk+ function. This function has two input
    parameters. The first parameter is of the `gboolean` type that defines whether
    all children widgets are to be given equal space allotments. The second parameter
    is of the `gint` type that defines the number of pixels to place between child
    widgets. The `gtk_widget_show` function is called to make the box container visible.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用盒式容器在主窗口中放置几个小部件（在我们的例子中是两个按钮）。这个盒式容器是指由 `gtk_vbox_new` Gtk+ 函数创建的 `GtkWidget`
    结构的指针。此函数有两个输入参数。第一个参数是 `gboolean` 类型，用于定义是否所有子小部件都应获得相等的空间分配。第二个参数是 `gint` 类型，用于定义在子小部件之间放置的像素数。使用
    `gtk_widget_show` 函数调用使盒式容器可见。
- en: Buttons to show messages and close applications are created in the `CreateMsgButton`
    and `CreateQuitButton` functions.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `CreateMsgButton` 和 `CreateQuitButton` 函数中创建了显示消息和关闭应用程序的按钮。
- en: The `gtk_container_add` function is used to put one widget into another. The
    box container has been put into the main window in our case. After that the `window`
    widget is made visible with the `gtk_widget_show` function.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`gtk_container_add` 函数用于将一个小部件放入另一个小部件中。在我们的例子中，盒式容器已经被放入主窗口中。之后，使用 `gtk_widget_show`
    函数使 `window` 小部件可见。'
- en: The `gtk_main` function leads to run main application loop to process events.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`gtk_main` 函数导致运行主应用程序循环以处理事件。'
- en: 'The following is the `CreateWindow` function that creates the main window:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为创建主窗口的 `CreateWindow` 函数：
- en: '[PRE80]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The main window of the `GTK_WINDOW_TOPLEVEL` type is created here with the `gtk_window_new`
    function. This window type equals to a regular application window. Then the window
    title is set with the `gtk_window_set_title` function.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `gtk_window_new` 函数在这里创建了 `GTK_WINDOW_TOPLEVEL` 类型的主窗口。此窗口类型等于一个常规应用程序窗口。然后使用
    `gtk_window_set_title` 函数设置窗口标题。
- en: Now we must bind the application closing and main window destroy events. This
    is needed to close the application after the main window closes. The events are
    named signals in Gtk+ terminology. The `g_signal_connect` macro is used here for
    signal binding. This macro has four arguments. The first argument is the pointer
    to the widget that you need to connect to. The second argument is a string with
    the signal name. The third argument is a callback function that will process this
    signal. The fourth argument is the pointer to additional signal data.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须绑定应用程序关闭和主窗口销毁事件。这是在主窗口关闭后关闭应用程序所需的。在 Gtk+ 术语中，事件被命名为信号。在这里使用 `g_signal_connect`
    宏进行信号绑定。此宏有四个参数。第一个参数是需要连接到的窗口的指针。第二个参数是包含信号名称的字符串。第三个参数是处理此信号的回调函数。第四个参数是指向附加信号数据的指针。
- en: There are two signals named `delete-event` and `destroy` that match the window
    closing event. The `gtk_main_quit` function will be called when these signals
    occur in our case. This function will stop the application event loop and will
    lead to the application termination.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个名为 `delete-event` 和 `destroy` 的信号与窗口关闭事件相匹配。在我们的情况下，当这些信号发生时，将调用 `gtk_main_quit`
    函数。此函数将停止应用程序事件循环，并导致应用程序终止。
- en: 'The following is the `CreateMsgButton` function that creates the message showing
    button:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为创建显示消息按钮的 `CreateMsgButton` 函数：
- en: '[PRE81]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This function has one input parameter of the pointer to the `GtkWidget` structure
    type. This is used to pass the pointer of the button container widget.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有一个输入参数，即指向 `GtkWidget` 结构的指针。这用于传递按钮容器小部件的指针。
- en: The button widget is a pointer to the `GtkWidget` structure named `button`.
    It is created by the `gtk_button_new_with_label` function. This function has only
    one input parameter with the button label string. After that the button widget
    is made visible with the `gtk_window_show` function. The `clicked` signal of the
    button widget is connected to the `ShowMessage` function. The button widget is
    added to the box container when it has been configured.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮小部件是指向名为 `button` 的 `GtkWidget` 结构的指针。它是由 `gtk_button_new_with_label` 函数创建的。此函数只有一个输入参数，即按钮标签字符串。之后，使用
    `gtk_window_show` 函数使按钮小部件可见。按钮小部件的 `clicked` 信号连接到 `ShowMessage` 函数。当配置完成后，按钮小部件被添加到盒式容器中。
- en: 'The following is the `ShowMessage` function to create and display the message
    window:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为创建和显示消息窗口的 `ShowMessage` 函数：
- en: '[PRE82]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The message window is the Gtk+ dialog widget that has been created with the
    `gtk_message_dialog_new` function. Parent window pointers, dialog flags, message
    types, dialog buttons, and message text are passed to this function. The `gtk_dialog_run`
    function is called to display the created dialog. This function will return control
    when the dialog button has been clicked. The `gtk_widget_destroy` function at
    the next line will destroy our message window.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 消息窗口是使用 `gtk_message_dialog_new` 函数创建的 Gtk+ 对话框小部件。父窗口指针、对话框标志、消息类型、对话框按钮和消息文本被传递给此函数。调用
    `gtk_dialog_run` 函数以显示创建的对话框。当对话框按钮被点击时，此函数将返回控制权。下一行的 `gtk_widget_destroy` 函数将销毁我们的消息窗口。
- en: 'The following is the `CreateQuitButton` function that creates the quit button:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为创建退出按钮的 `CreateQuitButton` 函数：
- en: '[PRE83]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This is the same as the `CreateMsgButton` function, but the button labels differ.
    Moreover, the `clicked` signal of this button is bound with the `gtk_main_quit`
    function. This function will lead to the application termination.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 `CreateMsgButton` 函数相同，但按钮标签不同。此外，此按钮的 `clicked` 信号绑定到 `gtk_main_quit` 函数。此函数将导致应用程序终止。
- en: The full `main.cpp` file is available in the code bundle uploaded on the Packt
    website.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `main.cpp` 文件可在 Packt 网站上上传的代码包中找到。
- en: 'The following is `Makefile` to compile our example application:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为编译我们的示例应用程序的 `Makefile`：
- en: '[PRE84]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `pkg-config` utility from the Gtk+ toolkit is used here to get the compiler
    and linker Gtk+ specific flags. The grave accent mark means that the wrapped string
    will be performed as a command and the result of the execution will be returned
    as a string value.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用来自 Gtk+ 工具包的 `pkg-config` 工具来获取编译器和链接器 Gtk+ 特定标志。重音符号意味着包裹的字符串将被执行为一个命令，并且执行的结果将作为字符串值返回。
- en: 'The following `pkg-config` options have been used here:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在这里使用的 `pkg-config` 选项：
- en: '`--cflags`: This prints the preprocessor and compiler flags to compile the
    application with a specified library'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cflags`：这将打印预处理器和编译器标志，以便使用指定的库编译应用程序'
- en: '`--libs`: This prints the linker flags to link the application with a specified
    library'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--libs`：这将打印链接器标志，以便将应用程序与指定的库链接'
- en: '`gtk+-win32-2.0` is the name of the package with the Gtk+ libraries that we
    want to link with.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`gtk+-win32-2.0` 是我们想要链接的包含 Gtk+ 库的包的名称。'
- en: The results of the `pkg-config` utility execution are assigned to the `CXXFLAGS`
    and `LIBS` variables.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg-config` 工具的执行结果被分配给 `CXXFLAGS` 和 `LIBS` 变量。'
- en: Now you have all the source files that are needed to compile our example application.
    Type the `make` command to do this. You will get the `gtk.exe` executable file
    in the current directory.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经有了编译我们的示例应用程序所需的所有源文件。输入 `make` 命令来完成此操作。您将在当前目录中获得 `gtk.exe` 可执行文件。
- en: wxWidgets framework
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: wxWidgets 框架
- en: The wxWidgets framework contains the widget toolkit for user interface development
    and features for network programming, threading support, image processing, database
    support, and HTML and XML processing. The wxWidgets have a set of their own containers
    and algorithms that can be enough to develop applications with this framework
    resources only.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: wxWidgets 框架包含用于用户界面开发的工具包和用于网络编程、线程支持、图像处理、数据库支持和 HTML 以及 XML 处理的功能。wxWidgets
    有自己的一套容器和算法，这些足以仅使用此框架资源来开发应用程序。
- en: Implementing own user interface elements is common practice for many widget
    toolkits and frameworks. This is what makes the Qt framework and Gtk+ widget toolkit.
    wxWidgets unlike these, uses the native platform's user interface elements through
    the platform's API. Thanks to this, wxWidgets-based applications look and feel
    like a native one.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 实现自己的用户界面元素是许多小部件工具包和框架的常见做法。这就是 Qt 框架和 Gtk+ 小部件工具包的特点。与这些不同，wxWidgets 通过平台的
    API 使用原生平台的用户界面元素。正因为如此，基于 wxWidgets 的应用程序看起来和感觉就像原生应用程序一样。
- en: wxWidgets is a good base to develop cross-platform high-quality, native-looking
    applications for Mac OS X, Windows, Linux, and other Unix family operating systems.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: wxWidgets 是开发适用于 Mac OS X、Windows、Linux 和其他 Unix 家族操作系统的跨平台高质量、原生外观应用程序的好基础。
- en: Several wxWidgets framework versions are available from the official website
    as source code archives. You can download one of these and build it with your
    currently installed MinGW software.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从官方网站下载几个 wxWidgets 框架版本作为源代码存档。您可以下载其中一个，并使用当前安装的 MinGW 软件构建它。
- en: 'The following are the instructions to install the wxWidgets widget toolkit:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为安装 wxWidgets 小部件工具包的说明：
- en: 'Download the wxMSV version of wxWidgets from the following official website:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下官方网站下载wxWidgets的wxMSV版本：
- en: '[http://www.wxwidgets.org/downloads](http://www.wxwidgets.org/downloads)'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[wxWidgets下载](http://www.wxwidgets.org/downloads)'
- en: Install the downloaded wxWidgets toolkit with the setup wizard. Run the downloaded
    exe file to do it. We will assume that the `C:\wxWidgets` target directory has
    been specified for example.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用设置向导安装下载的wxWidgets工具包。运行下载的exe文件来完成此操作。例如，我们将假设已经指定了`C:\wxWidgets`目标目录。
- en: 'Build the wxWidgets toolkit with your already installed MinGW software. Type
    the following commands to do it:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您已经安装的MinGW软件构建wxWidgets工具包。输入以下命令来完成此操作：
- en: '[PRE85]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Download the `wx-config` utility from the developer''s page:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从开发者的页面下载`wx-config`实用程序：
- en: '[http://code.google.com/p/wx-config-win](http://code.google.com/p/wx-config-win)'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[wxWidgets配置下载](http://code.google.com/p/wx-config-win)'
- en: This utility is used to search the wxWidgets toolkit libraries and header files
    by GNU Make.
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此实用程序用于通过GNU Make搜索wxWidgets工具包库和头文件。
- en: Copy the `wx-config` utility to the wxWidgets installation directory (in our
    case `C:\wxWidgets`).
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`wx-config`实用程序复制到wxWidgets安装目录（在我们的例子中为`C:\wxWidgets`）。
- en: Add the path to the wxWidgets installation directory and the path to the dynamic-linked
    libraries in the `PATH` Windows environment variable. The `C:\wxWidgets` and `C:\wxWidgets\lib\gcc_dll`
    values must be added in our example.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将wxWidgets安装目录的路径和动态链接库的路径添加到`PATH` Windows环境变量中。在我们的例子中，必须添加`C:\wxWidgets`和`C:\wxWidgets\lib\gcc_dll`值。
- en: Now you have the necessary libraries to start developing applications with the
    wxWidgets widget toolkit.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经拥有了使用wxWidgets小部件工具包开发应用程序所需的库。
- en: The example wxWidgets application is implemented in the `main.cpp` source file.
    User classes must be created here unlike the Gtk+ and Qt example application variants.
    The `MyApp` class is the base application class that is derived from the `wxApp`
    wxWidgets library standard class.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 示例wxWidgets应用程序在`main.cpp`源文件中实现。与Gtk+和Qt示例应用程序变体不同，必须在这里创建用户类。`MyApp`类是从wxWidgets库标准类`wxApp`派生的基本应用程序类。
- en: 'The following is the `MyApp` class definition:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`MyApp`类的定义：
- en: '[PRE86]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The virtual destructor and the `OnInit` virtual method are defined here. The
    virtual destructor is needed here for correct parent class data deleting. All
    application functionality is implemented in the `OnInit` method of the `MyApp`
    class.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里定义了虚拟析构函数和`OnInit`虚拟方法。虚拟析构函数在这里是必要的，用于正确删除父类数据。所有应用程序功能都在`MyApp`类的`OnInit`方法中实现。
- en: 'The following is the `OnInit` method of the `MyApp` class:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`MyApp`类的`OnInit`方法：
- en: '[PRE87]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The main application window is created here. This window is the object of the
    `MyDialog` class with the `dialog` name. The `MyDialog` class is a user defined
    class derived from the `wxDialog` widget class. The constructor of the `MyDialog`
    class has three input parameters. These are parent widget pointer, widget identifier,
    and title bar caption string.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里创建了主应用程序窗口。此窗口是具有`dialog`名称的`MyDialog`类的对象。`MyDialog`类是一个用户定义的类，它从`wxDialog`小部件类派生。`MyDialog`类的构造函数有三个输入参数。这些是父小部件指针、小部件标识符和标题栏字符串。
- en: Then two buttons with `OK` and `Cancel` captions are created for the `dialog`
    object by the `CreateButtonSizer` method. This method has one parameter that defines
    the standard buttons list to creation. Each of these buttons is represented by
    the bit flag. The `CreateButtonSizer` method returns the pointer to the object
    of the `wxSizer` class with the `sizer` name. This object represents the sub-window
    that contains the buttons. Thanks to the `sizer` object the button's position
    can be changed with the `SetDimensions` method. This method has four input parameters.
    The first two parameters are x and y coordinates and the second two parameters
    are the width and height of the `sizer` subwindow.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过`CreateButtonSizer`方法为`dialog`对象创建了两个带有`OK`和`Cancel`标题的按钮。此方法有一个参数，用于定义创建标准按钮列表。这些按钮中的每一个都由位标志表示。`CreateButtonSizer`方法返回指向具有`sizer`名称的`wxSizer`类对象的指针。此对象代表包含按钮的子窗口。多亏了`sizer`对象，可以使用`SetDimensions`方法更改按钮的位置。此方法有四个输入参数。前两个参数是x和y坐标，后两个参数是`sizer`子窗口的宽度和高度。
- en: The `ShowModal` method of the `dialog` object method will be called in a loop
    after the widget's initialization. This is the main application loop. It will
    be interrupted when the main application window has been destroyed.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在小部件初始化后，`dialog`对象的`ShowModal`方法将在循环中调用。这是主应用程序循环。当主应用程序窗口被销毁时，它将被中断。
- en: The information message will be displayed when the button with the `wxID_OK`
    identifier is clicked on. The `wxMessageBox` function is used to show an informational
    message. This function has six input parameters. The four of these are used here
    and the other two have values by default. The first parameter is a string with
    the message text. The second parameter is a string with message window caption
    bar text. The third parameter defines the message window style by bit flags. The
    fourth parameter is a pointer to the parent widget. The last two parameters are
    the coordinates of the message window.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击带有`wxID_OK`标识符的按钮时，将显示信息消息。使用`wxMessageBox`函数显示信息消息。此函数有六个输入参数。其中四个在这里使用，另外两个具有默认值。第一个参数是包含消息文本的字符串。第二个参数是包含消息窗口标题栏文本的字符串。第三个参数通过位标志定义消息窗口样式。第四个参数是指向父小部件的指针。最后两个参数是消息窗口的坐标。
- en: The main application window will be hidden when the button with the `Cancel`
    caption will be clicked. The `Destroy` method of the `dialog` object is called
    here to destroy the main application window.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击带有`Cancel`标题的按钮时，主应用程序窗口将被隐藏。在这里调用`dialog`对象的`Destroy`方法来销毁主应用程序窗口。
- en: 'The following is the `MyDialog` class definition:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`MyDialog`类的定义：
- en: '[PRE88]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The `MyDialog` class is derived from the `wxDialog` widget. The class constructor
    and destructor are defined here. The `MyDialog` class constructor just passes
    input parameters to the parent class constructor.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyDialog`类是从`wxDialog`小部件派生出来的。类的构造函数和析构函数在这里定义。`MyDialog`类的构造函数只是将输入参数传递给父类构造函数。'
- en: 'You must specify this macro in the `main.cpp` source file to create the application
    instance and start the program:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须在`main.cpp`源文件中指定此宏来创建应用程序实例并启动程序：
- en: '[PRE89]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The full `main.cpp` file is available in the code bundle uploaded on the Packt
    site.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在Packt网站上上传的代码包中可以找到完整的`main.cpp`文件。
- en: 'The following is `Makefile` to compile our example application:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们示例应用的`Makefile`：
- en: '[PRE90]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `wx-config` utility is used here. This is the `wxWidgets` framework's alternative
    of the `pkg-config` utility of Gtk+ toolkit. The `wx-config` utility is used here
    to get the compiler and linker wxWidgets specific flags.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用了`wx-config`实用工具。这是`wxWidgets`框架对Gtk+工具包的`pkg-config`实用工具的替代品。在这里使用`wx-config`实用工具来获取编译器和链接器wxWidgets特定标志。
- en: 'The next `wx-config` utility options have been used here:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用了以下`wx-config`实用工具选项：
- en: '`--cxxflags`: This prints the preprocessor and compiler flags to compile the
    application with the wxWidget library'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cxxflags`：这会打印出预处理器和编译器标志，以便使用wxWidget库编译应用程序'
- en: '`--libs`: This prints linker flags to link the application with the wxWidget
    library'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--libs`：这会打印出链接器标志，以便将应用程序与wxWidget库链接'
- en: '`--wxcfg`: This specifies a relative path to the `build.cfg` configuration
    file'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--wxcfg`：这指定了到`build.cfg`配置文件的相对路径'
- en: Now you are ready to compile our example application. Type the `make` command
    to do it. You will get the `wxwidgets.exe` executable file in the current directory
    after compilation.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好编译我们的示例应用了。输入`make`命令来执行它。编译后，您将在当前目录中获得`wxwidgets.exe`可执行文件。
- en: It is important to note that you can debug and profile your applications based
    on any of the described toolkit and frameworks with the MinGW software tools (GDB
    debugger and gprof profiler).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，您可以使用MinGW软件工具（GDB调试器和gprof分析器）基于任何描述的工具包和框架对您的应用程序进行调试和性能分析。
- en: 7 – Integrating with IDE
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7 – 集成到IDE
- en: 'MinGW software can be integrated with a lot of well-known free IDE systems.
    Integration with the following systems will be described here:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: MinGW软件可以与许多知名的免费IDE系统集成。以下将描述与以下系统的集成：
- en: Code::Blocks
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Code::Blocks
- en: Qt Creator
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Creator
- en: Eclipse
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse
- en: Integration in this case means the ability to edit MinGW-based project source
    code, building this project, and debugging it from the IDE. This integration provides
    a comfortable interface to interact with the most commonly used MinGW instruments.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，集成意味着能够编辑基于MinGW的项目源代码，构建此项目，并从IDE中进行调试。这种集成提供了一个舒适的用户界面，用于与最常用的MinGW工具进行交互。
- en: Code::Blocks
  id: totrans-559
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Code::Blocks
- en: Code::Blocks is an open source cross-platform IDE for developing C and C++ applications.
    Code::Blocks has an open architecture. Thanks to this, IDE capabilities can be
    expanded with plugins with significant facilitates software development process.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: Code::Blocks 是一个开源的跨平台 IDE，用于开发 C 和 C++ 应用程序。Code::Blocks 具有开放架构。因此，IDE 功能可以通过插件进行扩展，从而显著简化软件开发过程。
- en: Code::Blocks supports a lot of C and C++ compilers and several debuggers. This
    IDE is a good alternative for the Visual C++ one to develop C++ applications.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: Code::Blocks 支持许多 C 和 C++ 编译器和几个调试器。这个 IDE 是 Visual C++ 的良好替代品，用于开发 C++ 应用程序。
- en: 'The following are instructions to install and configure the Code::Blocks IDE:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何安装和配置 Code::Blocks IDE 的说明：
- en: 'Download the Code::Blocks IDE distribution with the already integrated MinGW
    software from the official website:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从官方网站下载已集成 MinGW 软件的 Code::Blocks IDE 发行版：
- en: '[http://www.codeblocks.org/downloads/binaries](http://www.codeblocks.org/downloads/binaries)'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.codeblocks.org/downloads/binaries](http://www.codeblocks.org/downloads/binaries)'
- en: Install the downloaded Code::Blocks distribution. Run the downloaded exe file
    to do it.
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装下载的 Code::Blocks 发行版。运行下载的 exe 文件来完成此操作。
- en: Select additional IDE components in **Choose Components** dialog during installation
    process.
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装过程中的 **选择组件** 对话框中，选择额外的 IDE 组件。
- en: The default installable components will be enough to start developing the C++
    application. But you can choose additional languages supporting GNU utilities
    and IDE plugins.
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认的安装组件足以开始开发 C++ 应用程序。但您可以选择支持 GNU 工具和 IDE 插件的其他语言。
- en: Start installed Code::Blocks system and select **GNU GCC Compiler** to use in
    the compilers auto-detection dialog.
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动已安装的 Code::Blocks 系统，并在编译器自动检测对话框中选择 **GNU GCC 编译器**。
- en: Now you are ready to use the Code::Blocks IDE system with integrated MinGW software.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好使用集成 MinGW 软件的 Code::Blocks IDE 系统。
- en: 'You can install the Code::Blocks IDE without integrated MinGW software if you
    have already installed it. The following are instructions to set up Code::Blocks
    working with your already installed MinGW software:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经安装了 MinGW 软件，可以不集成 MinGW 软件安装 Code::Blocks IDE。以下是将 Code::Blocks 与已安装的
    MinGW 软件一起设置的说明：
- en: Run Code::Blocks IDE.
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Code::Blocks IDE。
- en: Select **Settings** | **Compiler and Debugger...** in the main menu. You will
    see the compiler setting dialog:![Code::Blocks](img/5626_01_06.jpg)
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主菜单中选择 **设置** | **编译器和调试器...**，您将看到编译器设置对话框：![Code::Blocks](img/5626_01_06.jpg)
- en: Switch to the Toolchain executables tab. Specify the MinGW software installation
    directory and its utility executables file names.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 **工具链可执行文件** 选项卡。指定 MinGW 软件安装目录及其实用程序可执行文件名。
- en: 'Perform the following actions to create a new MinGW based project in Code::Blocks
    IDE:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作以在 Code::Blocks IDE 中创建一个新的基于 MinGW 的项目：
- en: Run Code::Blocks IDE. You will see the main system window:![Code::Blocks](img/5626_01_07.jpg)
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Code::Blocks IDE。您将看到主系统窗口：![Code::Blocks](img/5626_01_07.jpg)
- en: You can see the **Start here** tab content in the middle of the window. The
    main IDE menu is placed at the top of the window. The messages panel is placed
    at the bottom of the window. The build error messages, build log, debugger messages,
    and search results will be displayed here.
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在窗口中间看到 **开始这里** 选项卡的内容。主要的 IDE 菜单位于窗口顶部。消息面板位于窗口底部。构建错误消息、构建日志、调试器消息和搜索结果将在此显示。
- en: Click on the **create a new** project icon on the **Start here** tab or choose
    **File** | **New** | **Project...**in the main menu.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **开始这里** 选项卡上单击 **创建新项目** 图标，或在主菜单中选择 **文件** | **新建** | **项目...**。
- en: We will create a template Windows application in this example. Choose the **Win32GUI
    project** icon in the **new from template** dialog to do it.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本例中，我们将创建一个模板 Windows 应用程序。在 **新建模板** 对话框中选择 **Win32GUI 项目** 图标来完成此操作。
- en: Choose a frame-based type of project in the next dialog.
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个对话框中选择基于框架的项目类型。
- en: Specify the project name and path to store its sources.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定项目名称和存储源代码的路径。
- en: Select the compiler to build the application in the last dialog. It will be
    equal to the GNU GCC compiler by default. Leave it unchanged.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一个对话框中，选择构建应用程序的编译器。默认情况下，它将等于 GNU GCC 编译器。保持不变。
- en: You will get template source files of the MinGW-based Windows API application.
    This application just shows an empty window at launch.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得基于 MinGW 的 Windows API 应用程序的模板源代码。此应用程序在启动时仅显示一个空窗口。
- en: You can build our example application from the **Code::Blocks IDE** interface.
    Choose **Build** | **Build** in the main menu or press *Ctrl* + *F9* to do it.
    The build log and build messages will be displayed in the messages panel after
    that. Note what debug variant of build has been performed. You can change it to
    a release variant by switching the **Build target** combobox in the main menu.
    The application executable files will be created at the `bin` subdirectory of
    the our project directory.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 **Code::Blocks IDE** 界面构建我们的示例应用程序。在主菜单中选择 **构建** | **构建**，或者按 *Ctrl* +
    *F9* 来执行。构建日志和构建消息将在之后的消息面板中显示。注意已执行哪个调试版本的构建。您可以通过切换主菜单中的 **构建目标** 组合框将其更改为发布版本。应用程序的可执行文件将创建在我们的项目目录的
    `bin` 子目录中。
- en: Now the application is ready to be run. Choose **Build** | **Run** in the main
    menu or press *Ctrl* + *F10* to run the application. You will see the application
    window and console window , where the standard output stream messages will be
    displyed.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序已准备好运行。在主菜单中选择 **构建** | **运行**，或者按 *Ctrl* + *F10* 来运行应用程序。您将看到应用程序窗口和控制台窗口，其中将显示标准输出流消息。
- en: Code::Blocks IDE allows you to debug applications with the GDB debugger. First
    of all you must set breakpoints to stop program execution in specified places.
    Press the *F5* key to set a breakpoint at the current line in the source file.
    Press *F8* or choose **Debug** | **Start** from the main menu to start debugging.
    After that program execution stops at the specified line. Now you can get information
    about variables, call stack, CPU registers, and threads, or continue execution.
    All this functionality is available from the **Debug** submenu. You can continue
    the application debugging with the next line (*F7*) and step into (*Shift* + *F7*)
    commands.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: Code::Blocks IDE 允许您使用 GDB 调试器调试应用程序。首先，您必须设置断点以在指定的位置停止程序执行。按 *F5* 键在源文件当前行设置断点。按
    *F8* 或从主菜单中选择 **调试** | **开始** 来开始调试。之后，程序执行将在指定的行停止。现在，您可以获取有关变量、调用堆栈、CPU 寄存器和线程的信息，或者继续执行。所有这些功能都可通过
    **调试** 子菜单访问。您可以使用下一个行 (*F7*) 和进入 (*Shift* + *F7*) 命令继续应用程序的调试。
- en: Qt Creator
  id: totrans-586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Qt Creator
- en: Qt Creator is a cross-platform open source IDE, which is part of the Qt software
    development kit. It includes a source code editor, visual debugger, and forms
    designer. It supports both MinGW and Visual C++ software.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator 是一个跨平台的开源 IDE，它是 Qt 软件开发套件的一部分。它包括源代码编辑器、可视化调试器和表单设计器。它支持 MinGW 和
    Visual C++ 软件。
- en: Qt Creator is the best choice to develop Qt framework-based C++ applications.
    But other frameworks, toolkits, and programming languages are supported poorly.
    This obstacle must be considered when you choose this IDE for your application's
    development.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator 是开发基于 Qt 框架的 C++ 应用程序的最佳选择。但其他框架、工具包和编程语言的支持不佳。在选择此 IDE 进行应用程序开发时，必须考虑这个障碍。
- en: MinGW software and Qt libraries are not present in the Qt Creator IDE distribution
    and therefore you must install these separately.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: MinGW 软件和 Qt 库不包含在 Qt Creator IDE 的发行版中，因此您必须单独安装这些软件。
- en: 'The following are instructions to install and configure Qt Creator IDE:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是指示安装和配置 Qt Creator IDE 的说明：
- en: 'Download Qt Creator IDE distribution from the official website:'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从官方网站下载 Qt Creator IDE 发行版：
- en: '[http://qt-project.org/downloads](http://qt-project.org/downloads)'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://qt-project.org/downloads](http://qt-project.org/downloads)'
- en: Install Qt Creator with the help of the setup wizard. Just run the downloaded
    exe file to do it. Run the installed Qt Creator IDE. You will see the main system
    window:![Qt Creator](img/5626_01_08.jpg)
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置向导的帮助下安装 Qt Creator。只需运行下载的 exe 文件即可完成安装。运行已安装的 Qt Creator IDE。您将看到主系统窗口：![Qt
    Creator](img/5626_01_08.jpg)
- en: The **Welcome** tab content is placed in the middle of the window. You can see
    the main system menu at the top of the window. The control panel is placed at
    the left-hand side of the window. The most commonly used commands are available
    in this panel. Moreover the icons of different Qt Creator IDE modes (Editor, Designer
    and so on) are placed here. The messages' output panels are available at the bottom
    of window.
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**欢迎** 选项卡的内容放置在窗口的中间。您可以在窗口顶部看到主系统菜单。控制面板放置在窗口的左侧。最常用的命令都可用在此面板上。此外，不同 Qt
    Creator IDE 模式（编辑器、设计器等）的图标也放置在此处。消息输出面板位于窗口底部。'
- en: Select **Tools** | **Options...** in the main menu. You will see the **Options**
    dialog.
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主菜单中选择 **工具** | **选项...**，您将看到 **选项** 对话框。
- en: Switch to the **Build & Run** icon in the left-hand side of the dialog panel.
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到对话框面板左侧的**构建和运行**图标。
- en: Switch to the **Qt Versions** tab at the top of the dialog window. Now you see
    the following screenshot:![Qt Creator](img/5626_01_09.jpg)
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到对话框窗口顶部的**Qt版本**选项卡。现在你将看到以下截图：![Qt Creator](img/5626_01_09.jpg)
- en: Click on the **Add** button and specify the path to the `qmake.exe` file. This
    is `C:\Qt\4.6.4\bin\qmake.exe` for the default Qt libraries installation path.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**按钮并指定`qmake.exe`文件的路径。对于默认的Qt库安装路径，此路径为`C:\Qt\4.6.4\bin\qmake.exe`。
- en: Switch to the **Tool Chains** tab at the top of the dialog window. You will
    see the following screenshot:![Qt Creator](img/5626_01_10.jpg)
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到对话框窗口顶部的**工具链**选项卡。你将看到以下截图：![Qt Creator](img/5626_01_10.jpg)
- en: Qt Creator can find already installed MinGW software automatically, but I recommend
    you manually add it for detailed configuration.
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Qt Creator可以自动找到已安装的MinGW软件，但我建议你手动添加它以进行详细配置。
- en: Click on the **Add** button and choose the MinGW variant in the pop-up list.
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**按钮，并在弹出的列表中选择MinGW变体。
- en: Click on the **Browse...** button near the **Compiler path** field and specify
    the path to the `g++.exe` file. This is equal to `C:\MinGW4.4\bin\g++.exe` if
    the MinGW software has been installed to the `C:\MinGW4.4` directory.
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**浏览...**按钮，该按钮位于**编译器路径**字段附近，并指定`g++.exe`文件的路径。如果MinGW软件已安装到`C:\MinGW4.4`目录，则此路径等于`C:\MinGW4.4\bin\g++.exe`。
- en: Click on the **Browse...** button near the **Debugger** input field and specify
    the path to the `gdb.exe` file. You can install the GDB debugger separately if
    your MinGW software distribution doesn't already contain it. The debugger path
    equals to `C:\MinGW4.4\bin\gdb.exe` for our example.
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**浏览...**按钮，该按钮位于**调试器**输入字段附近，并指定`gdb.exe`文件的路径。如果你的MinGW软件发行版中尚未包含它，你可以单独安装GDB调试器。调试器路径等于`C:\MinGW4.4\bin\gdb.exe`，以我们的示例为例。
- en: Click on the **Apply** and then **OK** button to complete the configuration.
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**应用**然后**确定**按钮以完成配置。
- en: Now you are ready to use the Qt Creator IDE system integrated with MinGW software
    and Qt libraries. Note that your MinGW software version must be the same as the
    MinGW software that has been used to build your installed Qt libraries.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已准备好使用集成MinGW软件和Qt库的Qt Creator IDE系统。请注意，你的MinGW软件版本必须与用于构建已安装Qt库的MinGW软件版本相同。
- en: 'The following are the instructions to create example Qt-based application with
    Qt Creator IDE:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Qt Creator IDE中创建示例Qt应用程序的说明：
- en: Select **File** | **New File** or **Project** from the main menu. You will see
    the template application choosing dialog.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单中选择**文件** | **新建文件**或**项目**。你将看到模板应用程序选择对话框。
- en: Select **Applications** and **Qt Gui Application** variant in the project type
    selecting fields:![Qt Creator](img/5626_01_11.jpg)
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目类型选择字段中选择**应用程序**和**Qt Gui应用程序**变体：![Qt Creator](img/5626_01_11.jpg)
- en: Click on the **Choose...** button.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**选择...**按钮。
- en: Specify the project name (for example, `qt`) and location to store the source
    files in the **Location** tab of the **Qt Gui Application** dialog. Click on the
    **Next** button.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Qt Gui应用程序**对话框的**位置**选项卡中指定项目名称（例如，`qt`）和存储源文件的路径。点击**下一步**按钮。
- en: Choose **Desktop** target in the **Targets** tab of the dialog and click on
    **Next**.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框的**目标**选项卡中选择**桌面**目标，然后点击**下一步**。
- en: You can change the default source files and class names in the **Details** tab.
    I suggest you leave these unchanged for our example application. Just click on
    the **Next** button.
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在**详细信息**选项卡中更改默认的源文件和类名。我建议你保持这些设置不变，以适应我们的示例应用程序。只需点击**下一步**按钮。
- en: The subproject and version control can be added in the **Summary** dialog tab.
    Switch version control to **None** and click on the **Finish** button.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在**摘要**对话框选项卡中添加子项目和版本控制。将版本控制切换到**无**并点击**完成**按钮。
- en: You will get a template of the Qt-based application with the source files located
    in a specified location.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得一个Qt应用程序模板，源文件位于指定的位置。
- en: Click on the **Build Project** icon at the left-hand side of the control panel
    or press *Ctrl* + *B* to build our example application. The `qt.exe` executable
    file will be created in the `debug` subdirectory of the project directory. You
    can select the debug or release build variant in the control panel's project configuration
    submenu (this is placed under the **Run** icon).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制面板的左侧点击**构建项目**图标或按*Ctrl* + *B*来构建我们的示例应用程序。`qt.exe`可执行文件将被创建在项目目录的`debug`子目录中。您可以在控制面板的项目配置子菜单中选择调试或发布构建版本（这位于**运行**图标之下）。
- en: Click on the **Run** icon to launch our example application. You will see the
    empty application window with the status bar and toolbar.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**运行**图标以启动我们的示例应用程序。您将看到一个带有状态栏和工具栏的空应用程序窗口。
- en: Qt Creator IDE allows you to debug your applications with the GDB debugger.
    This is standard procedure to do it; you must specify breakpoints at source file
    lines and then start debugging. Use the *F9* key to set a breakpoint and the *F5*
    key to start debugging.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator IDE允许您使用GDB调试器调试您的应用程序。这是执行此操作的标准程序；您必须在源文件行上设置断点然后开始调试。使用*F9*键设置断点，使用*F5*键开始调试。
- en: The variables' current values, call-stack, and watchpoints configuration are
    available in debugging mode. You can find all this information in the additional
    panels of Qt Creator main window. Use **Step Over** (*F10*) and **Step Into**
    (*F11*) **Debug** submenu items to continue application execution.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的当前值、调用栈和观察点配置在调试模式下可用。您可以在Qt Creator主窗口的附加面板中找到所有这些信息。使用**步过**（*F10*）和**步入**（*F11*）**调试**子菜单项继续应用程序执行。
- en: Eclipse
  id: totrans-619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Eclipse
- en: Eclipse is a cross-platform open source IDE with multi-language support. There
    are a huge amount of plugins that have been developed for this IDE. Eclipse supports
    many compilers, interpreters, debuggers, version control systems, unit testing
    frameworks, and so on. You can use Eclipse for developing applications in any
    popular programming language and framework.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse是一个跨平台的开源IDE，支持多语言。为这个IDE开发了大量的插件。Eclipse支持许多编译器、解释器、调试器、版本控制系统、单元测试框架等等。您可以使用Eclipse开发任何流行编程语言和框架的应用程序。
- en: Eclipse is an excellent IDE for comfortable application developing, but it has
    been developed in Java and has a massive architecture. Therefore there are high
    demands on the performance of your computer.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse是一个优秀的IDE，适用于舒适的应用程序开发，但它是用Java开发的，具有庞大的架构。因此，对您计算机的性能有很高的要求。
- en: This is not the Eclipse IDE system distribution that contains the MinGW software.
    You must install it separately to integrate with Eclipse.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是包含MinGW软件的Eclipse IDE系统分发版。您必须单独安装它以与Eclipse集成。
- en: 'The following are instructions to install and configure the Eclipse IDE system:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Eclipse IDE系统中安装和配置的说明：
- en: 'Download **Java Runtime Environment** (**JRE**) from the official website:'
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从官方网站下载**Java运行时环境**（**JRE**）：
- en: '[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)'
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)'
- en: Install it with the setup wizard. Just run the downloaded exe file to do it.
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用设置向导安装它。只需运行下载的exe文件即可。
- en: Add the path of the JRE executable files to the `PATH` Windows environment variable
    (for example, `C:\Program Files\Java\jre7\bin`).
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将JRE可执行文件路径添加到`PATH` Windows环境变量中（例如，`C:\Program Files\Java\jre7\bin`）。
- en: 'Download the Eclipse IDE for C/C++ Developers version archive from the official
    website:'
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从官方网站下载Eclipse IDE for C/C++ Developers版本存档：
- en: '[http://www.eclipse.org/downloads](http://www.eclipse.org/downloads)'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.eclipse.org/downloads](http://www.eclipse.org/downloads)'
- en: Note what you need the 32-bit Eclipse IDE system version for 32-bit JRE and
    64-bit one for 64-bit JRE.
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意您需要32位Eclipse IDE系统版本用于32位JRE，64位版本用于64位JRE。
- en: Unpack the Eclipse archive to any directory (for example, `C:\Program Files`)
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Eclipse存档解压到任何目录（例如，`C:\Program Files`）。
- en: Now you are ready to use the Eclipse IDE system. The MinGW software utilities
    will be integrated automatically thanks to Windows environment variables. Therefore
    the MinGW `bin` subdirectory with executable files must be specified there.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好使用Eclipse IDE系统。由于Windows环境变量的原因，MinGW软件工具将自动集成。因此，必须指定包含可执行文件的MinGW
    `bin`子目录。
- en: 'The following are instructions to create an example application in Eclipse
    IDE:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Eclipse IDE中创建示例应用程序的说明：
- en: Run Eclipse IDE. You will see the **Welcome** screen.
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 Eclipse IDE。你会看到 **欢迎** 屏幕。
- en: Select **File** | **New** | **C++ Project** from the main menu. You will see
    the project configuration dialog as shown in the following screenshot:![Eclipse](img/5626_01_12.jpg)
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单中选择 **文件** | **新建** | **C++ 项目**。你将看到以下截图所示的 项目配置对话框：![Eclipse](img/5626_01_12.jpg)
- en: Select the **Hello world C++ Project** item in the **Project type** selection
    field. Select the **MinGW GCC** item in the **Toolchains** selection field. Click
    on the **Next** button. You will see the **Basic Settings** dialog. The author,
    copyright notice, and source files directory can be specified here.
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **项目类型** 选择字段中选择 **Hello world C++ 项目** 项。在 **工具链** 选择字段中选择 **MinGW GCC**
    项。点击 **下一步** 按钮。你将看到 **基本设置** 对话框。可以在这里指定作者、版权声明和源文件目录。
- en: Click on the **Next** button. This is the **Select Configurations** dialog.
    Debug, release, or both build configurations availability can be selected here.
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步** 按钮。这是 **选择配置** 对话框。可以在这里选择调试、发布或两者都构建的配置。
- en: Click on the **Finish** button.
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **完成** 按钮。
- en: 'After that you get a template C++ console project with the source files placed
    at the `src` subdirectory of the project directory. Now you see the Eclipse IDE
    window as shown in the following screenshot:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将获得一个模板 C++ 控制台项目，源文件放置在项目目录的 `src` 子目录中。现在你看到的是以下截图所示的 Eclipse IDE 窗口：
- en: '![Eclipse](img/5626_01_13.jpg)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
  zh: '![Eclipse](img/5626_01_13.jpg)'
- en: The **Project Explorer** panel is placed at the left-hand side of the window.
    You can find all the project source files here. The source file editor is placed
    in the middle part of the window. You can find the messages' output panel at the
    bottom of the window.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目资源管理器** 面板位于窗口的左侧。你可以在这里找到所有的项目源文件。源文件编辑器位于窗口的中间部分。你可以在窗口底部找到消息输出面板。'
- en: Select **Project** | **Build Project** from the main menu to build our example
    application. After that the executable file will be created in the `Debug` subdirectory
    of the project directory. You can switch to the release configuration to build
    the project. Click on the build icon (hammer icon) at the main menu and select
    **Release** configuration to build. The `Release` subdirectory will be created
    with the compiled executable file.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 从主菜单中选择 **项目** | **构建项目** 来构建我们的示例应用程序。之后，可执行文件将创建在项目目录的 `Debug` 子目录中。你可以切换到发布配置来构建项目。点击主菜单中的构建图标（锤子图标），选择
    **发布** 配置来构建。将创建一个 `Release` 子目录，其中包含编译后的可执行文件。
- en: Select **Run** | **Run** from the main menu or press *Ctrl* + *F11* to launch
    our example application. You will see the result of the application execution
    in the console output panel at the bottom of the Eclipse window.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 从主菜单中选择 **运行** | **运行** 或按 *Ctrl* + *F11* 键来启动我们的示例应用程序。你将在 Eclipse 窗口底部的控制台输出面板中看到应用程序执行的输出结果。
- en: You can debug applications with the Eclipse IDE system. Press *Ctrl* + *Shift*
    + *B* key to set the breakpoint at the current line of a source file. After setting
    the breakpoints select **Run** | **Debug** from the main menu or press the *F11*
    key to start debugging. You will see panels with call-stack, variable values,
    CPU registers values, breakpoints, and loaded modules in the debugging mode. Use
    the **Step Over** (*F6*) and **Step Into** (*F5*) **Run** submenu items to continue
    application execution.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Eclipse IDE 系统进行调试。按 *Ctrl* + *Shift* + *B* 键在源文件的当前行设置断点。设置断点后，从主菜单选择
    **运行** | **调试** 或按 *F11* 键开始调试。在调试模式下，你会看到包含调用栈、变量值、CPU 寄存器值、断点和加载的模块的面板。使用 **步过**
    (*F6*) 和 **步入** (*F5*) **运行** 子菜单项来继续应用程序执行。
- en: People and places you should get to know
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你应该了解的人和地方
- en: There is a lot of information about MinGW software available on the Internet.
    You will get to know some helpful sources from this section.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上可以找到大量关于 MinGW 软件的信息。你将从这个部分了解一些有用的资源。
- en: MinGW official sites
  id: totrans-647
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MinGW 官方网站
- en: '**Homepage**: [http://www.mingw.org](http://www.mingw.org)'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**：[http://www.mingw.org](http://www.mingw.org)'
- en: '**Manuals**: [http://www.mingw.org/wiki/HOWTO](http://www.mingw.org/wiki/HOWTO)'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手册**：[http://www.mingw.org/wiki/HOWTO](http://www.mingw.org/wiki/HOWTO)'
- en: '**Wiki**: [http://www.mingw.org/wiki](http://www.mingw.org/wiki)'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wiki**：[http://www.mingw.org/wiki](http://www.mingw.org/wiki)'
- en: '**Source code and binary files**: [http://sourceforge.net/projects/mingw/files/MinGW](http://sourceforge.net/projects/mingw/%E2%80%A8files/MinGW)'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码和二进制文件**：[http://sourceforge.net/projects/mingw/files/MinGW](http://sourceforge.net/projects/mingw/%E2%80%A8files/MinGW)'
- en: '**Available mailing lists**: [http://www.mingw.org/lists.shtml](http://www.mingw.org/lists.shtml)'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用的邮件列表**: [http://www.mingw.org/lists.shtml](http://www.mingw.org/lists.shtml)'
- en: MinGW-w64 official sites
  id: totrans-653
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MinGW-w64 官方网站
- en: '**Homepage**: [http://mingw-w64.sourceforge.net](http://mingw-w64.sourceforge.net)'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**: [http://mingw-w64.sourceforge.net](http://mingw-w64.sourceforge.net)'
- en: '**Wiki**: [http://sourceforge.net/apps/trac/mingw-w64](http://sourceforge.net/apps/trac/mingw-w64)'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wiki**: [http://sourceforge.net/apps/trac/mingw-w64](http://sourceforge.net/apps/trac/mingw-w64)'
- en: '**Source code and binary files**: [http://sourceforge.net/projects/mingw-w64/files](http://sourceforge.net/projects/mingw-w64/files)'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码和二进制文件**: [http://sourceforge.net/projects/mingw-w64/files](http://sourceforge.net/projects/mingw-w64/files)'
- en: '**Discussion forum**: [http://sourceforge.net/projects/mingw-w64/forums/forum/723797](http://sourceforge.net/projects/mingw-w64/forums/forum/723797)'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**讨论论坛**: [http://sourceforge.net/projects/mingw-w64/forums/forum/723797](http://sourceforge.net/projects/mingw-w64/forums/forum/723797)'
- en: '**Public support mailing list**: [https://lists.sourceforge.net/lists/listinfo/mingw-w64-public](https://lists.sourceforge.net/lists/listinfo/mingw-w64-public)'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共支持邮件列表**: [https://lists.sourceforge.net/lists/listinfo/mingw-w64-public](https://lists.sourceforge.net/lists/listinfo/mingw-w64-public)'
- en: '**Support IRC channel**: [irc://irc.oftc.net/#mingw-w64](http://irc://irc.oftc.net/#mingw-w64)'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持 IRC 频道**: [irc://irc.oftc.net/#mingw-w64](http://irc://irc.oftc.net/#mingw-w64)'
- en: GNU Compiler Collection official sites
  id: totrans-660
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GNU 编译器集合官方网站
- en: 'You can find a lot of useful information about MinGW utilities on the GCC official
    site:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GCC 官方网站上找到关于 MinGW 工具的大量有用信息：
- en: '**Homepage**: [http://gcc.gnu.org](http://gcc.gnu.org)'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**: [http://gcc.gnu.org](http://gcc.gnu.org)'
- en: '**Manual and documentation**: [http://gcc.gnu.org/onlinedocs](http://gcc.gnu.org/onlinedocs)'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手册和文档**: [http://gcc.gnu.org/onlinedocs](http://gcc.gnu.org/onlinedocs)'
- en: '**Wiki**: [http://gcc.gnu.org/wiki](http://gcc.gnu.org/wiki)'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wiki**: [http://gcc.gnu.org/wiki](http://gcc.gnu.org/wiki)'
- en: '**Available mailing lists**: [http://gcc.gnu.org/lists.html](http://gcc.gnu.org/lists.html)'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用的邮件列表**: [http://gcc.gnu.org/lists.html](http://gcc.gnu.org/lists.html)'
- en: GNU Debugger official sites
  id: totrans-666
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GNU 调试器官方网站
- en: 'All the information that you need to debug an application with GNU Debugger
    can be found at the official site:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 所有关于使用 GNU 调试器调试应用程序的信息都可以在官方网站找到：
- en: '**Homepage**: [http://www.gnu.org/software/gdb](http://www.gnu.org/software/gdb)'
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**: [http://www.gnu.org/software/gdb](http://www.gnu.org/software/gdb)'
- en: '**Manual and documentation**: [http://www.gnu.org/software/gdb/documentation](http://www.gnu.org/software/gdb/documentation)'
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手册和文档**: [http://www.gnu.org/software/gdb/documentation](http://www.gnu.org/software/gdb/documentation)'
- en: '**Wiki**: [http://sourceware.org/gdb/wiki](http://sourceware.org/gdb/wiki)'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wiki**: [http://sourceware.org/gdb/wiki](http://sourceware.org/gdb/wiki)'
- en: '**Available mailing lists**: [http://www.gnu.org/software/gdb/mailing-lists](http://www.gnu.org/software/gdb/mailing-lists)'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用的邮件列表**: [http://www.gnu.org/software/gdb/mailing-lists](http://www.gnu.org/software/gdb/mailing-lists)'
- en: GNU Make official sites
  id: totrans-672
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GNU Make 官方网站
- en: '**Homepage**: [http://www.gnu.org/software/make](http://www.gnu.org/software/make)'
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主页**: [http://www.gnu.org/software/make](http://www.gnu.org/software/make)'
- en: '**Manual and documentation**: [http://www.gnu.org/software/make/manual/html_node/index.html](http://www.gnu.org/software/make/manual/%E2%80%A8html_node/index.html)'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手册和文档**: [http://www.gnu.org/software/make/manual/html_node/index.html](http://www.gnu.org/software/make/manual/%E2%80%A8html_node/index.html)'
- en: '**Mailing lists**: `<[bug-make@gnu.org](mailto:bug-make@gnu.org)>`; `<[help-make@gnu.org](mailto:help-make@gnu.org)>`'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邮件列表**: `<[bug-make@gnu.org](mailto:bug-make@gnu.org)>`; `<[help-make@gnu.org](mailto:help-make@gnu.org)>`'
- en: Articles and tutorials
  id: totrans-676
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文章和教程
- en: 'Here you can find several useful articles and tutorials for MinGW software
    usage:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 这里您可以找到关于 MinGW 软件使用的几个有用的文章和教程：
- en: '[http://www.cs.utah.edu/dept/old/texinfo/as/gprof.html](http://www.cs.utah.edu/dept/old/texinfo/as/gprof.html):
    This is a detailed article about gprof profiler usage'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.cs.utah.edu/dept/old/texinfo/as/gprof.html](http://www.cs.utah.edu/dept/old/texinfo/as/gprof.html):
    这是一篇关于 gprof 分析器使用的详细文章'
- en: '[http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor):
    This is quite simple and demonstrative tutorial on GNU Make utility'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor):
    这是一个关于 GNU Make 工具的简单且具有示范性的教程'
- en: '[http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html](http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html):
    You will find detailed information about MinGW C++ compiler optimization capabilities'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html](http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html):
    您将找到关于 MinGW C++ 编译器优化能力的详细信息'
- en: '[http://gcc.gnu.org/onlinedocs/gcc/Standards.html](http://gcc.gnu.org/onlinedocs/gcc/Standards.html):
    You can find information about compiler''s supporting standards'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://gcc.gnu.org/onlinedocs/gcc/Standards.html](http://gcc.gnu.org/onlinedocs/gcc/Standards.html):
    您可以找到有关编译器支持的标准的详细信息'
- en: Community
  id: totrans-682
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社区
- en: '**Largest free and open source-focused IRC network**: [http://freenode.net](http://freenode.net)'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大的免费和开源-focused IRC 网络**: [http://freenode.net](http://freenode.net)'
- en: '**Unofficial distributions**: [http://nuwen.net/mingw.html](http://nuwen.net/mingw.html);
    [http://tdm-gcc.tdragon.net](http://tdm-gcc.tdragon.net)'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非官方发行版**: [http://nuwen.net/mingw.html](http://nuwen.net/mingw.html); [http://tdm-gcc.tdragon.net](http://tdm-gcc.tdragon.net)'
- en: '**Several MinGW developers sites**: [http://www.willus.com/mingw/colinp](http://www.willus.com/mingw/colinp);
    [http://www.megacz.com](http://www.megacz.com); [http://rmathew.com](http://rmathew.com)'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**几个 MinGW 开发者网站**: [http://www.willus.com/mingw/colinp](http://www.willus.com/mingw/colinp);
    [http://www.megacz.com](http://www.megacz.com); [http://rmathew.com](http://rmathew.com)'
- en: Twitter
  id: totrans-686
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Twitter
- en: '**Packt Publishing**: [https://twitter.com/packtopensource](https://twitter.com/packtopensource)'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Packt 出版公司**: [https://twitter.com/packtopensource](https://twitter.com/packtopensource)'
