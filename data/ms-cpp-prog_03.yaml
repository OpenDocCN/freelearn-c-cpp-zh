- en: Template Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板编程
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Generic programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型编程
- en: Function templates
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数模板
- en: Class templates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类模板
- en: Overloading function templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数模板重载
- en: Generic classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类
- en: Explicit class specializations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式类特化
- en: Partial specializations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分特化
- en: Let's now start learning generic programming.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始学习泛型编程。
- en: Generic programming
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型编程
- en: Generic programming is a style of programming that helps you develop reusable
    code or generic algorithms that can be applied to a wide variety of data types.
    Whenever a generic algorithm is invoked, the data types will be supplied as parameters
    with a special syntax.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型编程是一种编程风格，可以帮助您开发可重用的代码或通用算法，可应用于各种数据类型。每当调用通用算法时，数据类型将以特殊语法作为参数提供。
- en: 'Let''s say we would like to write a `sort()` function, which takes an array
    of inputs that needs to be sorted in an ascending order. Secondly, we need the
    `sort()` function to sort `int`, `double`, `char`, and `string` data types. There
    are a couple of ways this can be solved:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写一个`sort()`函数，它接受一个需要按升序排序的输入数组。其次，我们需要`sort()`函数来对`int`、`double`、`char`和`string`数据类型进行排序。有几种方法可以解决这个问题：
- en: We could write four different `sort()` functions for each data type
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为每种数据类型编写四个不同的`sort()`函数
- en: We could also write a single macro function
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以编写一个单一的宏函数
- en: Well, both approaches have their own merits and demerits. The advantage of the
    first approach is that, since there are dedicated functions for the `int`, `double`,
    `char`, and `string` data types, the compiler will be able to perform type checking
    if an incorrect data type is supplied. The disadvantage of the first approach
    is that we have to write four different functions even though the logic remains
    the same across all the functions. If a bug is identified in the algorithm, it
    must be fixed separately in all four functions; hence, heavy maintenance efforts
    are required. If we need to support another data type, we will end up writing
    one more function, and this will keep growing as we need to support more data
    types.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这两种方法都有各自的优点和缺点。第一种方法的优点是，由于为`int`、`double`、`char`和`string`数据类型专门有函数，如果提供了不正确的数据类型，编译器将能够执行类型检查。第一种方法的缺点是，尽管所有函数的逻辑保持不变，但我们必须编写四个不同的函数。如果在算法中发现了错误，必须分别在所有四个函数中进行修复；因此，需要进行大量的维护工作。如果我们需要支持另一种数据类型，我们将不得不编写另一个函数，并且随着需要支持更多数据类型，这种情况将不断增加。
- en: The advantage of the second approach is that we could just write one macro for
    all the data types. However, one very discouraging disadvantage is that the compiler
    will not be able to perform type checking, and this approach is more prone to
    errors and may invite many unexpected troubles. This approach is dead against
    object-oriented coding principles.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法的优点是我们可以为所有数据类型编写一个宏。然而，一个非常令人沮丧的缺点是编译器将无法执行类型检查，这种方法更容易出现错误，并可能引发许多意外的麻烦。这种方法与面向对象编码原则背道而驰。
- en: 'C++ supports generic programming with templates, which has the following benefits:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: C++支持使用模板进行泛型编程，具有以下好处：
- en: We just need to write one function using templates
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只需要使用模板编写一个函数
- en: Templates support static polymorphism
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板支持静态多态
- en: Templates offer all the advantages of the two aforementioned approaches, without
    any disadvantages
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板提供了前述两种方法的所有优点，没有任何缺点
- en: Generic programming enables code reuse
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型编程实现了代码重用
- en: The resultant code is object-oriented
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果代码是面向对象的
- en: The C++ compiler can perform type checking during compile time
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++编译器可以在编译时执行类型检查
- en: Easy to maintain
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于维护
- en: Supports a wide variety of built-in and user-defined data types
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持各种内置和用户定义的数据类型
- en: 'However, the disadvantages are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，缺点如下：
- en: Not all C++ programmers feel comfortable writing template-based coding, but
    this is only an initial hiccup
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有C++程序员都感到舒适编写基于模板的编码，但这只是最初的阻碍
- en: In certain scenarios, templates could bloat your code and increase the binary
    footprint, leading to performance issues
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，模板可能会使您的代码膨胀并增加二进制占用空间，导致性能问题
- en: Function templates
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数模板
- en: A function template lets you parameterize a data type. The reason this is referred
    to as generic programming is that a single template function will support many
    built-in and user-defined data types. A templatized function works like a **C-style
    macro**, except for the fact that the C++ compiler will type check the function
    when we supply an incompatible data type at the time of invoking the template
    function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板允许您将数据类型参数化。之所以称之为泛型编程，是因为单个模板函数将支持许多内置和用户定义的数据类型。模板化函数的工作方式类似于**C风格宏**，只是C++编译器在我们在调用模板函数时提供不兼容的数据类型时会对函数进行类型检查。
- en: 'It will be easier to understand the template concept with a simple example,
    as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个简单的示例来理解模板概念会更容易，如下所示：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the following commands:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序的输出如下：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Isn't it really interesting to see just one template function doing all the
    magic? Yes, that's how cool C++ templates are!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 看到一个模板函数就能完成所有魔术，是不是很有趣？是的，这就是C++模板的酷之处！
- en: Are you curious to see the assembly output of a template instantiation? Use
    the command, **`g++ -S main.cpp`**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否好奇看到模板实例化的汇编输出？使用命令**`g++ -S main.cpp`**。
- en: Code walkthrough
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码演示
- en: 'The following code defines a function template. The keyword, `template <typename
    T, int size>`, tells the compiler that what follows is a function template:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了一个函数模板。关键字`template <typename T, int size>`告诉编译器接下来是一个函数模板：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The line, `void sort ( T input[] )`, defines a function named `sort`, which
    returns `void` and receives an input array of type `T`. The `T` type doesn't indicate
    any specific data type. `T` will be deduced at the time of instantiating the function
    template during compile time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`void sort ( T input[] )`这一行定义了一个名为`sort`的函数，它返回`void`并接收类型为`T`的输入数组。`T`类型并不表示任何特定的数据类型。`T`将在编译时实例化函数模板的时候推断出来。'
- en: 'The following code populates an integer array with some unsorted values and
    prints the same to the terminal:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用一些未排序的值填充一个整数数组，并将其打印到终端上：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following line will instantiate an instance of a function template for
    the `int` data type. At this point, `typename T` is substituted and a specialized
    function is created for the `int` data type. The scope-resolution operator in
    front of `sort`, that is, `::sort()`, ensures that it invokes our custom function, `sort()`,
    defined in the global namespace; otherwise, the C++ compiler will attempt to invoke
    the `sort()` algorithm defined in the `std namespace`, or from any other namespace
    if such a function exists. The `<int, 10>` variable tells the compiler to create
    an instance of a function, substituting `typename T` with `int`, and `10` indicates
    the size of the array used in the template function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一行将为`int`数据类型实例化一个函数模板的实例。在这一点上，`typename T`被替换，为`int`数据类型创建了一个专门的函数。在`sort`前面的作用域解析运算符，即`::sort()`，确保它调用我们自定义的`sort()`函数，该函数定义在全局命名空间中；否则，C++编译器将尝试调用`std
    namespace`中定义的`sort()`算法，或者如果存在这样的函数，则来自任何其他命名空间。`<int, 10>`变量告诉编译器创建一个函数的实例，用`int`替换`typename
    T`，`10`表示模板函数中使用的数组的大小：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following lines will instantiate two additional instances that support
    a `double` array of `5` elements and a `string` array of `6` elements respectively:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行将实例化另外两个支持`5`个元素的`double`数组和`6`个元素的`string`数组的实例：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you are curious to know some more details about how the C++ compiler instantiates
    the function templates to support `int`, `double`, and `string`, you could try
    the Unix utilities, `nm` and `c++filt`. The `nm` Unix utility will list the symbols
    in the symbol table, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关C++编译器如何实例化函数模板以支持`int`、`double`和`string`的更多细节，可以尝试Unix实用程序`nm`和`c++filt`。`nm`
    Unix实用程序将列出符号表中的符号，如下所示：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, there are three different overloaded `sort` functions in the
    binary; however, we have defined only one template function. As the C++ compiler
    has mangled names to deal with function overloading, it is difficult for us to
    interpret which function among the three functions is meant for the `int`, `double`,
    and `string` data types.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在二进制文件中有三个不同的重载`sort`函数；然而，我们只定义了一个模板函数。由于C++编译器对函数重载进行了名称混编，我们很难解释这三个函数中的哪一个是为`int`、`double`和`string`数据类型准备的。
- en: 'However, there is a clue: the first function is meant for `double`, the second
    is meant for `int`, and the third is meant for `string`. The name-mangled function
    has `_Z4sortIdLi5EEvPT_` for `double`, `_Z4sortIiLi10EEvPT_` for `int`, and `_Z4sortINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELi6EEvPT_`
    for `string`. There is another cool Unix utility to help you interpret the function
    signatures without much struggle. Check the following output of the `c++filt`
    utility:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个线索：第一个函数是为`double`准备的，第二个是为`int`准备的，第三个是为`string`准备的。名称混编函数对于`double`是`_Z4sortIdLi5EEvPT_`，对于`int`是`_Z4sortIiLi10EEvPT_`，对于`string`是`_Z4sortINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELi6EEvPT_`。还有另一个很酷的Unix实用程序，可以帮助您轻松解释函数签名。检查`c++filt`实用程序的以下输出：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Hopefully, you will find these utilities useful while working with C++ templates.
    I'm sure these tools and techniques will help you to debug any C++ application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您在使用C++模板时会发现这些实用程序有用。我相信这些工具和技术将帮助您调试任何C++应用程序。
- en: Overloading function templates
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重载函数模板
- en: Overloading function templates works exactly like regular function overloading
    in C++. However, I'll help you recollect the C++ function overloading basics.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 重载函数模板的工作方式与C++中的常规函数重载完全相同。不过，我将帮助您回顾一下C++函数重载的基础知识。
- en: 'The function overloading rules and expectations from the C++ compiler are as
    follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: C++编译器对重载函数的规则和期望如下：
- en: The overloaded function names will be the same.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载函数的名称将是相同的。
- en: The C++ compiler will not be able to differentiate between overloaded functions
    that differ only by a return value.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++编译器将无法区分仅通过返回值不同的重载函数。
- en: The number of overloaded function arguments, the data types of those arguments,
    or their sequence should be different. Apart from the other rules, at least one
    of these rules described in the current bullet point should be satisfied, but
    more compliance wouldn't hurt, though.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载函数参数的数量、这些参数的数据类型或它们的顺序应该是不同的。除了其他规则之外，当前项目符号表中描述的这些规则中至少应满足一个，但更多的符合也不会有害。
- en: The overloaded functions must be in the same namespace or within the same class
    scope.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载函数必须在相同的命名空间或相同的类作用域内。
- en: If any of these aforementioned rules aren't met, the C++ compiler will not treat
    them as overloaded functions. If there is any ambiguity in differentiating between
    the overloaded functions, the C++ compiler will report it promptly as a compilation
    error.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些前述规则中的任何一个没有得到满足，C++编译器将不会将它们视为重载函数。如果在区分重载函数方面存在任何歧义，C++编译器将立即报告为编译错误。
- en: 'It is time to explore this with an example, as shown in the following program:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过下面的示例来探索一下了：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the following commands:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前述程序的输出如下：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Code walkthrough
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码演示
- en: 'The following code is a non-template version of our custom `sort()`  function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是我们自定义的`sort()`函数的非模板版本：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Non-template functions and template functions can coexist and participate in
    function overloading. One weird behavior of the preceding function is that the
    size of the array is hardcoded.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 非模板函数和模板函数可以共存并参与函数重载。前面函数的一个奇怪行为是数组的大小是硬编码的。
- en: 'The second version of our `sort()` function is a template function, as shown
    in the following code snippet. Interestingly, the weird issue that we noticed
    in the first non-template `sort()` version is addressed here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`sort()`函数的第二个版本是一个模板函数，如下面的代码片段所示。有趣的是，我们在第一个非模板`sort()`版本中注意到的奇怪问题在这里得到了解决：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, both the data type and the size of the array are passed
    as template arguments, which are then passed to the function call arguments. This
    approach makes the function generic, as this function can be instantiated for
    any data type.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，数组的数据类型和大小都作为模板参数传递，然后传递给函数调用参数。这种方法使函数通用，因为这个函数可以为任何数据类型实例化。
- en: 'The third version of our custom `sort()` function is also a template function,
    as shown in the following code snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自定义的`sort()`函数的第三个版本也是一个模板函数，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding template function takes a C-style array; hence, it also expects
    the user to indicate its size. However, the size of the array could be computed
    within the function, but for demonstration purposes, I need a function that takes
    two arguments. The previous function isn't recommended, as it uses a C-style array;
    ideally, we would use one of the STL containers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模板函数接受C风格的数组；因此，它也期望用户指示其大小。然而，数组的大小可以在函数内计算，但出于演示目的，我需要一个接受两个参数的函数。不建议使用前面的函数，因为它使用了C风格的数组；理想情况下，我们应该使用STL容器之一。
- en: 'Now, let''s understand the main function code. The following code declares
    and initializes the STL array container with six values, which is then passed
    to our `sort()` function defined in the default namespace:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们理解主函数代码。以下代码声明并初始化了包含六个值的STL数组容器，然后将其传递给我们在默认命名空间中定义的`sort()`函数：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code will invoke the non-template `sort()` function. An important
    point to note is that, whenever C++ encounters a function call, it first looks
    for a non-template version; if C++ finds a matching non-template function version,
    its search for the correct function definition ends there. If the C++ compiler
    isn't able to identify a non-template function definition that matches the function
    call signature, then it starts looking for any template function that could support
    the function call and instantiates a specialized function for the data type required.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将调用非模板`sort()`函数。需要注意的一个重要点是，每当C++遇到函数调用时，它首先寻找非模板版本；如果C++找到匹配的非模板函数版本，它的搜索正确函数定义的过程就结束了。如果C++编译器无法识别与函数调用签名匹配的非模板函数定义，那么它开始寻找任何可以支持函数调用的模板函数，并为所需的数据类型实例化一个专门的函数。
- en: 'Let''s understand the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解以下代码：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will invoke the template function that receives a single argument. As there
    is no non-template `sort()` function that receives an `array<float,6>` data type,
    the C++ compiler will instantiate such a function out of our user-defined `sort()`
    template function with a single argument that takes `array<float, 6>`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用接收单个参数的模板函数。由于没有接收`array<float,6>`数据类型的非模板`sort()`函数，C++编译器将从我们定义的接收单个参数的`sort()`模板函数中实例化这样一个函数，该函数接收`array<float,
    6>`。
- en: 'In the same way, the following code triggers the compiler to instantiate a
    `double` version of the template `sort()` function that receives `array<double,
    6>`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，以下代码触发编译器实例化模板`sort()`函数的`double`版本，该函数接收`array<double, 6>`：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, the following code will instantiate an instance of the template `sort()`
    that receives two arguments and invokes the function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下代码将实例化模板`sort()`的一个实例，该实例接收两个参数并调用函数：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you have come this far, I'm sure you like the C++ template topics discussed
    so far.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经走到这一步，我相信您会喜欢迄今为止讨论的C++模板主题。
- en: Class template
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类模板
- en: C++ templates extend the function template concepts to classes too, and enable
    us to write object-oriented generic code. In the previous sections, you learned
    the use of function templates and overloading. In this section, you will learn
    writing template classes that open up more interesting generic programming concepts.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: C++模板将函数模板概念扩展到类，使我们能够编写面向对象的通用代码。在前面的部分，您学习了函数模板和重载的用法。在本节中，您将学习编写模板类，从而开启更有趣的通用编程概念。
- en: A `class` template lets you parameterize the data type on the class level via
    a template type expression.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`模板允许您通过模板类型表达式在类级别上对数据类型进行参数化。'
- en: 'Let''s understand a `class` template with the following example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例理解一个`class`模板：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: C++ template function overloading is a form of static or compile-time polymorphism.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: C++模板函数重载是静态或编译时多态的一种形式。
- en: 'Let''s use `myalgorithm.h` in the following `main.cpp` program as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下`main.cpp`程序中使用`myalgorithm.h`如下所示：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s quickly compile the program using the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速使用以下命令编译程序：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Code walkthrough
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码演示
- en: 'The following code declares a class template. The keyword, `template <typename
    T, int size>`, can be replaced with `<class T, int size>`. Both keywords can be
    interchanged in function and class templates; however, as an industry best practice, `template<class
    T>` can be used only with class templates to avoid confusion:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码声明了一个类模板。关键字`template <typename T, int size>`可以替换为`<class T, int size>`。这两个关键字可以在函数和类模板中互换使用；然而，作为行业最佳实践，`template<class
    T>`只能用于类模板，以避免混淆。
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'One of the overloaded `sort()` methods is defined inline as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个重载的`sort()`方法内联定义如下：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second overloaded `sort()` function is just declared within the class scope,
    without any definition, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重载的`sort()`函数只是在类范围内声明，没有任何定义，如下所示：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding `sort()` function is defined outside the class scope, as shown
    in the following code snippet. The weird part is that we need to repeat the template
    parameters for every member function that is defined outside the class template:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`sort()`函数是在类范围之外定义的，如下面的代码片段所示。奇怪的是，我们需要为每个在类模板之外定义的成员函数重复模板参数：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Otherwise, the class template concepts remain the same as that of function templates.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，类模板的概念与函数模板的概念相同。
- en: Would you like to see the compiler-instantiated code for templates?  Use the
    **`g++ -fdump-tree-original main.cpp -std=c++17`** command.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你想看看模板的编译器实例化代码吗？使用**`g++ -fdump-tree-original main.cpp -std=c++17`**命令。
- en: Explicit class specializations
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式类特化
- en: So far in this chapter, you have learned how to do generic programming with
    function templates and class templates. As you understand the class template,
    a single template class can support any built-in and user-defined data types.
    However, there are times when we need to treat certain data types with some special
    treatment with respect to the other data types. In such cases, C++ offers us explicit
    class specialization support to handle selective data types with differential
    treatment.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，你已经学会了如何使用函数模板和类模板进行泛型编程。当你理解了类模板时，一个模板类可以支持任何内置和用户定义的数据类型。然而，有时我们需要对某些数据类型进行特殊处理。在这种情况下，C++为我们提供了显式类特化支持，以处理具有不同处理方式的选择性数据类型。
- en: Consider the STL `deque` container; though `deque` looks fine for storing, let's
    say, `string`, `int`, `double`, and `long`, if we decide to use `deque` to store
    a bunch of `boolean` types, the `bool` data type takes at least one byte, while
    it may vary as per compiler vendor implementation. While a single bit can efficiently
    represent true or false, a boolean at least takes one byte, that is, 8 bits, and
    the remaining 7 bits are not used. This may appear as though it's okay; however,
    if you have to store a very large `deque` of booleans, it definitely doesn't appear
    to be an efficient idea, right? You may think, what's the big deal? We could write
    another specialized class or template class for `bool`. But this approach requires
    end users to use different classes for different data types explicitly, and this
    doesn't sound like a good design either, right? This is exactly where C++'s explicit
    class specialization comes in handy.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑STL `deque`容器；虽然`deque`看起来适合存储，比如说，`string`、`int`、`double`和`long`，但如果我们决定使用`deque`来存储一堆`boolean`类型，`bool`数据类型至少占用一个字节，而根据编译器供应商的实现可能会有所不同。虽然一个位可以有效地表示真或假，但布尔值至少占用一个字节，即8位，剩下的7位没有被使用。这可能看起来没问题；然而，如果你必须存储一个非常大的布尔值`deque`，这显然不是一个高效的想法，对吧？你可能会想，有什么大不了的？我们可以为`bool`编写另一个专门的类或模板类。但这种方法要求最终用户明确为不同的数据类型使用不同的类，这也不是一个好的设计，对吧？这正是C++的显式类特化派上用场的地方。
- en: The explicit template specialization is also referred to as full-template specialization.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 显式模板特化也被称为完全模板特化。
- en: Never mind if you aren't convinced yet; the following example will help you
    understand the need for explicit class specialization and how explicit class specialization
    works.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不相信，没关系；下面的例子将帮助你理解显式类特化的需求以及显式类特化的工作原理。
- en: 'Let us develop a `DynamicArray` class to support a dynamic array of any data
    type. Let''s start with a class template, as shown in the following program:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开发一个`DynamicArray`类来支持任何数据类型的动态数组。让我们从一个类模板开始，如下面的程序所示：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding `DynamicArray` template class internally makes use of the STL
    `deque` class. Hence, you could consider the `DynamicArray` template class a custom
    adapter container. Let''s explore how the `DynamicArray` template class can be
    used in `main.cpp` with the following code snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`DynamicArray`模板类内部使用了STL `deque`类。因此，你可以将`DynamicArray`模板类视为自定义适配器容器。让我们看看`DynamicArray`模板类如何在`main.cpp`中使用，如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s quickly compile the program using the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速使用以下命令编译程序：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Great! Our custom adapter container seems to work fine.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们的自定义适配器容器似乎工作正常。
- en: Code walkthrough
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码演示
- en: 'Let''s zoom in and try to understand how the previous program works. The following
    code tells the C++ compiler that what follows is a class template:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们放大并尝试理解前面的程序是如何工作的。下面的代码告诉C++编译器接下来是一个类模板：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, the `DynamicArray` class makes use of STL `deque` internally,
    and an iterator for `deque` is declared with the name, `pos`.  This iterator, `pos`,
    is utilized by the `Dynamic` template class to provide high-level methods such
    as the `initialize()`, `appendValue()`, `hasNextValue()`, and `getValue()` methods.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`DynamicArray`类内部使用了STL `deque`，并且为`deque`声明了名为`pos`的迭代器。这个迭代器`pos`被`Dynamic`模板类用于提供高级方法，比如`initialize()`、`appendValue()`、`hasNextValue()`和`getValue()`方法。
- en: The `initialize()` method initializes the `deque` iterator `pos` to the first
    data element stored within `deque`. The `appendValue( T element )` method lets
    you add a data element at the end of `deque`.  The `hasNextValue()` method tells
    whether the `DynamicArray` class has further data values stored--`true` indicates
    it has further values and `false` indicates that the `DynamicArray` navigation
    has reached the end of `deque`. The `initialize()` method can be used to reset
    the `pos` iterator to the starting point when required. The `getValue()` method
    returns the data element pointed by the `pos` iterator at that moment. The `getValue()`
    method doesn't perform any validation; hence, it must be combined with `hasNextValue()`
    before invoking `getValue()`  to safely access the values stored in `DynamicArray`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialize()`方法将`deque`迭代器`pos`初始化为存储在`deque`中的第一个数据元素。`appendValue( T element
    )`方法允许您在`deque`的末尾添加数据元素。`hasNextValue()`方法告诉`DynamicArray`类是否有进一步存储的数据值--`true`表示有更多的值，`false`表示`DynamicArray`导航已经到达`deque`的末尾。当需要时，`initialize()`方法可以用来重置`pos`迭代器到起始点。`getValue()`方法返回`pos`迭代器指向的数据元素。`getValue()`方法不执行任何验证；因此，在调用`getValue()`之前，必须与`hasNextValue()`结合使用，以安全地访问存储在`DynamicArray`中的值。'
- en: 'Now, let''s understand the `main()` function. The following code declares a
    `DynamicArray` class that stores the `int` data type; `DynamicArray<int> intArray`
    will trigger the C++ compiler to instantiate a `DynamicArray` class that is specialized
    for the `int` data type:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解`main()`函数。以下代码声明了一个存储`int`数据类型的`DynamicArray`类；`DynamicArray<int> intArray`将触发C++编译器实例化一个专门用于`int`数据类型的`DynamicArray`类。
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The values `100`, `200`, `300`, and `400` are stored back to back within the
    `DynamicArray` class. The following code ensures that the `intArray` iterator
    points to the first element. Once the iterator is initialized, the values stored
    in the `DynamicArray` class are printed with the `getValue()` method, while `hasNextValue()`
    ensures that the navigation hasn''t reached the end of the `DynamicArray` class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 值`100`、`200`、`300`和`400`被依次存储在`DynamicArray`类中。以下代码确保`intArray`迭代器指向第一个元素。一旦迭代器初始化，存储在`DynamicArray`类中的值将通过`getValue()`方法打印出来，而`hasNextValue()`确保导航没有到达`DynamicArray`类的末尾。
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Along the same lines, in the main function, a `char DynamicArray` class is created,
    populated with some data, and printed. Let's skip `char` `DynamicArray` and directly
    move on to the `DynamicArray` class that stores `bool`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在同样的情况下，在主函数中，创建了一个`char DynamicArray`类，填充了一些数据，并打印出来。让我们跳过`char` `DynamicArray`，直接转到存储`bool`的`DynamicArray`类。
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: From the preceding code snippet, we can see everything looks okay, right? Yes,
    the preceding code works perfectly fine; however, there is a performance issue
    with the `DynamicArray` design approach. While `true` can be represented by `1`
    and `false` can be represented by `0`, which requires just 1 bit, the preceding `DynamicArray` class
    makes use of 8 bits to represent `1` and 8 bits to represent `0`, which we must
    fix without forcing end users to choose a different `DynamicArray` class that
    works efficiently for `bool`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们可以看到一切看起来都很好，对吗？是的，前面的代码运行得很好；然而，`DynamicArray`的设计方法存在性能问题。虽然`true`可以用`1`表示，`false`可以用`0`表示，只需要1位，但前面的`DynamicArray`类使用8位来表示`1`，另外8位来表示`0`，我们必须修复，而不强迫最终用户选择一个对`bool`有效率的`DynamicArray`类。
- en: 'Let''s fix the issue by using explicit class template specialization with the
    following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下代码使用显式类模板特化来解决这个问题：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Did you notice the template class declaration? The syntax for template class
    specialization is `template <> class DynamicArray<bool> { };`.  The `class` template
    expression is empty `<>` and the name of the `class` template that works for all
    data types and the name of the class that works the for the `bool` data type are
    kept the same with the template expression, `<bool>`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到模板类声明了吗？模板类特化的语法是`template <> class DynamicArray<bool> { };`。`class`模板表达式是空的`<>`，对于所有数据类型都适用的`class`模板的名称和适用于`bool`数据类型的类的名称与模板表达式`<bool>`保持一致。
- en: If you observe closely, the specialized `DynamicArray` class for `bool` internally
    makes use of `deque< bitset<8> >`, that is, `deque` of `bitsets` of 8 bits, and,
    when required, `deque` will automatically allocate more `bitset<8>` bits. The
    `bitset` variable is a memory-efficient STL container that consumes just 1 bit
    to represent `true` or `false`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，专门为`bool`的`DynamicArray`类在内部使用了`deque< bitset<8> >`，即8位的`bitset`的`deque`，在需要时，`deque`将自动分配更多的`bitset<8>`位。`bitset`变量是一个内存高效的STL容器，只消耗1位来表示`true`或`false`。
- en: 'Let''s take a look at the `main` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`main`函数：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With the class template specialization in place, we can observe from the following that the
    main code seems the same for `bool`, `char`, and `double`, although the primary
    template class, `DynamicArray`, and the specialized `DynamicArray<bool>` class
    are different:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有了类模板特化，我们可以观察到以下的主要代码对于`bool`、`char`和`double`似乎是相同的，尽管主模板类`DynamicArray`和专门化的`DynamicArray<bool>`类是不同的。
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I'm sure you will find this C++ template specialization feature quite useful.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你会发现这个C++模板特化特性非常有用。
- en: Partial template specialization
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分模板特化
- en: Unlike explicit template specialization, which replaces the primary template
    class with its own complete definitions for a specific data type, partial template
    specialization allows us to specialize a certain subset of template parameters supported
    by the primary template class, while the other generic types can be the same as
    the primary template class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与显式模板特化不同，显式模板特化用自己的完整定义替换特定数据类型的主模板类，部分模板特化允许我们专门化主模板类支持的某个子集的模板参数，而其他通用类型可以与主模板类相同。
- en: 'When partial template specialization is combined with inheritance, it can do
    more wonders, as shown in the following example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当部分模板特化与继承结合时，可以做更多的奇迹，如下例所示。
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `main.cpp` file will have the following content:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp`文件将包含以下内容：'
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'From the preceding code, you may have noticed that the primary template class
    name and the partially specialized class name are the same as in the case of full
    or explicit template class specialization. However, there are some syntactic changes
    in the template parameter expression. In the case of a complete template class
    specialization, the template parameter expression will be empty, whereas, in the
    case of a partially specialized template class, listed appears, as shown in the
    following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，你可能已经注意到主模板类的名称和部分特化类的名称与完全或显式模板类特化的情况相同。然而，在模板参数表达式中有一些语法上的变化。在完全模板类特化的情况下，模板参数表达式将为空，而在部分特化的模板类的情况下，列出的表达式会出现，如下所示：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The expression, `template<typename T1, typename T2, typename T3>`, is the template
    parameter expression used in the primary class template class, and `MyTemplateClass<
    T1, T2*, T3*>` is the partial specialization done by the second class. As you
    can see, the second class has done some specialization on `typename T2` and `typename
    T3`, as they are used as pointers in the second class; however, `typename T1`
    is used as is in the second class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`template<typename T1, typename T2, typename T3>`是主类模板中使用的模板参数表达式，`MyTemplateClass<
    T1, T2*, T3*>`是第二类进行的部分特化。你可以看到，第二类对`typename T2`和`typename T3`进行了一些特化，因为它们在第二类中被用作指针；然而，`typename
    T1`在第二类中被原样使用。
- en: Apart from the facts discussed so far, the second class also inherits the primary
    template class, which helps the second class reuse the public and protected methods
    of the primary template class. However, a partial template specialization doesn't
    stop the specialized class from supporting other functions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了迄今为止讨论的事实之外，第二类还继承了主模板类，这有助于第二类重用主模板类的公共和受保护方法。然而，部分模板特化并不会阻止特定类支持其他函数。
- en: While the `F1` function from the primary template class is replaced by the partially
    specialized template class, it reuses the `F2` function from the primary template
    class via inheritance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当主模板类的`F1`函数被部分特化的模板类替换时，它通过继承重用了主模板类的`F2`函数。
- en: 'Let''s quickly compile the program using the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令快速编译程序：
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output of the program is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: I hope that you find the partially specialized template class useful.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你会发现部分特化的模板类有用。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了以下内容：
- en: You are now aware of the motivation for using generic programming
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你现在知道使用泛型编程的动机
- en: You are now familiar with function templates
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你现在熟悉了函数模板
- en: You know how to overload function templates
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你知道如何重载函数模板
- en: You are aware of class templates
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你知道类模板
- en: You are aware of when to use explicit template specialization and when to use
    partially specialized template specialization
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你知道何时使用显式模板特化以及何时使用部分特化的模板特化
- en: Congrats! Overall, you have a good understanding of C++'s template programming.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！总的来说，你对C++的模板编程有很好的理解。
- en: In the next chapter, you will learn smart pointers.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习智能指针。
