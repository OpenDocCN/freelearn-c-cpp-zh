- en: Chapter 3. Building UI with XAML
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用XAML构建UI
- en: User interface and user experience play an important role with Windows 8 Store
    apps. A new design has been created for Store apps, now called modern design style
    (formerly known as Metro), with keywords such as "fast and fluid", "content first",
    and "touch centric". The app UI takes up the entire screen (except when in snap
    view), which makes the UI all the more important. In this chapter (and the next
    one), we'll discuss the way in which UI for Store apps is built, more on the technical
    level than on the actual design. Microsoft makes a lot of resources available
    online for the design part of the UI.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面和用户体验在Windows 8 Store应用程序中扮演着重要的角色。为Store应用程序创建了一种新的设计，现在称为现代设计风格（以前称为Metro），其中关键词包括“快速流畅”、“内容优先”和“触摸为中心”。应用程序UI占据整个屏幕（除了在快照视图中），这使得UI变得更加重要。在本章（和下一章）中，我们将讨论为Store应用程序构建UI的方式，更多地是在技术层面上而不是在实际设计上。微软在线提供了大量设计UI的资源。
- en: XAML
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XAML
- en: C++ Store applications typically use **eXtensible Application Markup Language**
    (**XAML**) as the main language for creating the user interface. The first question
    that comes to mind when XAML is first mentioned, is why? What's wrong with C++,
    or any other existing programming language?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C++ Store应用程序通常使用**可扩展应用程序标记语言**（**XAML**）作为创建用户界面的主要语言。当首次提到XAML时，首先想到的问题是为什么？C++或任何其他现有的编程语言有什么问题吗？
- en: 'XAML is an XML-based language that describes the what, not the how; it''s declarative
    and neutral. Technically, a complete app can be written without any XAML; there''s
    nothing XAML can do that C++ can''t. Here are some reasons why XAML makes sense
    (or at least may make sense in a little bit):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: XAML是一种基于XML的语言，描述了“什么”，而不是“如何”；它是声明性的和中立的。从技术上讲，完整的应用程序可以在没有任何XAML的情况下编写；没有XAML可以做的事情是C++做不到的。以下是XAML有意义的一些原因（或者至少可能有意义的一点）：
- en: C++ is very verbose as opposed to XAML. XAML is usually shorter than the equivalent
    C++ code.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与XAML相比，C++非常冗长。XAML通常比等效的C++代码更短。
- en: Since XAML is neutral, design-oriented tools can read and manipulate it. Microsoft
    provides the Expression Blend tool just for this purpose.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于XAML是中立的，面向设计的工具可以读取和操作它。微软专门提供了Expression Blend工具用于此目的。
- en: The declarative nature of XAML makes it easier (most of the time, after users
    get used to it) to build user interfaces, as these have a tree-like structure,
    just like XML.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAML的声明性使得构建用户界面更容易（大多数情况下，用户习惯后），因为这些界面具有类似XML的树状结构。
- en: 'XAML itself has nothing to do with the user interface in itself. XAML is a
    way to create objects (usually an object tree) and set their properties. This
    works for any type that is "XAML friendly", meaning it should have the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: XAML本身与用户界面本身无关。XAML是一种创建对象（通常是对象树）并设置其属性的方法。这适用于任何“XAML友好”的类型，这意味着它应该具有以下特点：
- en: A default public constructor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认的公共构造函数
- en: Settable public properties
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可设置的公共属性
- en: The second point is not a strict requirement, but without properties the object
    is pretty dull.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点不是严格要求，但是没有属性，对象就相当无聊。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: XAML was originally created for **Windows Presentation Foundation** (**WPF**),
    the main rich client technology in .NET. It's now leveraged in other technologies,
    mostly in the .NET space, such as Silverlight and **Windows Workflow Foundation**
    (**WF**).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: XAML最初是为**Windows Presentation Foundation**（**WPF**）创建的，这是.NET中的主要丰富客户端技术。现在它被其他技术所利用，主要是在.NET空间中，比如Silverlight和**Windows
    Workflow Foundation**（**WF**）。
- en: The XAML level currently implemented in WinRT is roughly equivalent to Silverlight
    3 XAML. In particular, it's not as powerful as WPF's XAML.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT中当前实现的XAML级别大致相当于Silverlight 3 XAML。特别是，它不像WPF的XAML那样强大。
- en: XAML basics
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XAML基础知识
- en: 'XAML has a few rules. Once we understand those rules, we can read and write
    any XAML. The most fundamental XAML rules are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: XAML有一些规则。一旦我们理解了这些规则，就可以阅读和编写任何XAML。最基本的XAML规则如下：
- en: An XML element means object creation
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML元素意味着对象创建
- en: An XML attribute means setting a property (or an event handler)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML属性意味着设置属性（或事件处理程序）
- en: 'With these two rules, the following markup means creating a `Button` object
    and setting its `Content` property to the string `Click me`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两条规则，下面的标记意味着创建一个`Button`对象，并将其`Content`属性设置为字符串`Click me`：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The equivalent C++ code would be as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的C++代码如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When creating a new Blank App project, a `MainPage.xaml` file is created along
    with the header and implementation files. Here''s how that XAML file looks:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的空白应用程序项目时，会创建一个`MainPage.xaml`文件以及头文件和实现文件。以下是该XAML文件的外观：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It's worth going over these lines in detail. In this example, the project name
    is `BasicXaml` . The root element is `Page` and an `x:Class` attribute is set,
    indicating the class that inherits from `Page`, here named `BasicXaml::MainPage`.
    Note that the class name is the full name including namespace, where the separator
    must be a period (not the C++ scope resolution operator `::`). `x:Class` can only
    be placed on the root element.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 详细了解这些行是值得的。在这个例子中，项目名称是`BasicXaml`。根元素是`Page`，并设置了一个`x:Class`属性，指示从`Page`继承的类，这里命名为`BasicXaml::MainPage`。请注意，类名是包括命名空间的完整名称，其中分隔符必须是句点（而不是C++的作用域解析运算符`::`）。`x:Class`只能放在根元素上。
- en: What follows that root element is a bunch of XML namespace declarations. These
    give context to the elements used in the entire XAML of this page. The default
    XML namespace (without a name) indicates to the XAML parser that types such as
    `Page`, `Button`, and `Grid` can be written as they are, without any special prefix.
    This is the most common scenario, because most of the XAML in a page constitutes
    user interface elements.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 跟在根元素后面的是一堆XML命名空间声明。这些为页面整个XAML中使用的元素提供了上下文。默认的XML命名空间（没有名称）告诉XAML解析器，诸如`Page`、`Button`和`Grid`这样的类型可以直接写成它们自己，不需要任何特殊前缀。这是最常见的情况，因为页面中的大部分XAML都是用户界面元素。
- en: The next XML namespace prefix is `x` and it points to special instructions for
    the XAML parser. We have just seen `x:Class` in action. We'll meet other such
    attributes later in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个XML命名空间前缀是`x`，它指向XAML解析器的特殊指令。我们刚刚看到`x:Class`的作用。我们将在本章的后面遇到其他类似的属性。
- en: 'Next up is a prefix named `local`, which points to the types declared in the
    `BasicXaml` namespace. This allows creating our own objects in XAML; the prefix
    of such types must be `local` so that the XAML parser understands where to look
    for such a type (of course, we can change that to anything we like). For example,
    suppose we create a user control derived type named `MyControl`. To create a `MyControl`
    instance in XAML, we could use the following markup:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个名为`local`的前缀，它指向在`BasicXaml`命名空间中声明的类型。这允许在XAML中创建我们自己的对象；这些类型的前缀必须是`local`，以便XAML解析器知道在哪里查找这样的类型（当然，我们可以将其更改为任何我们喜欢的东西）。例如，假设我们创建了一个名为`MyControl`的用户控件派生类型。要在XAML中创建一个`MyControl`实例，我们可以使用以下标记：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `d` prefix is used for designer-related attributes, mostly useful with Expression
    Blend. The `mc:ignorable` attribute states that the `d` prefix should be ignored
    by the XAML parser (because it's related to the way Blend works with the XAML).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`d`前缀用于与设计相关的属性，主要与Expression Blend一起使用。`mc:ignorable`属性说明`d`前缀应该被XAML解析器忽略（因为它与Blend与XAML的工作方式有关）。'
- en: The `Grid` element is hosted inside the `Page`, where "hosted" will become clear
    in a moment. Its `Background` property is set to `{StaticResource ApplicationPageBackgroundThemeBrush}`.
    This is a markup extension, discussed in a later section in this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid`元素托管在`Page`内，"托管"将在下文中变得清晰。其`Background`属性设置为`{StaticResource ApplicationPageBackgroundThemeBrush}`。这是一个标记扩展，在本章的后面部分讨论。'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: XAML is unable to invoke methods directly; it can just set properties. This
    is understandable, as XAML needs to remain declarative in nature; it's not meant
    as a replacement for C++ or any other programming language.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: XAML无法直接调用方法；它只能设置属性。这是可以理解的，因为XAML需要保持声明性的特性；它并不是作为C++或任何其他编程语言的替代品。
- en: Type converters
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换器
- en: 'XML deals with strings. However, it''s clear that many properties are not strings.
    Many can still be specified as strings, and still work correctly thanks to the
    type converters employed by the XAML parser. Here''s an example of a `Rectangle`
    element:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: XML处理字符串。然而，很明显许多属性不是字符串。许多属性仍然可以指定为字符串，并且由于XAML解析器使用的类型转换器，仍然可以正确工作。以下是`Rectangle`元素的一个例子：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Presumably, the `Fill` property is not of a string type. In fact, it's a `Brush`.
    `Red` here really means `ref new SolidColorBrush(Colors::Red)`. The XAML parser
    knows how to translate a string, such as `Red` (and many others) to a `Brush`
    type (in this case the more specific `SolidColorBrush`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可以推测，`Fill`属性不是字符串类型。实际上，它是一个`Brush`。这里的`Red`实际上意味着`ref new SolidColorBrush(Colors::Red)`。XAML解析器知道如何将字符串（例如`Red`和许多其他字符串）转换为`Brush`类型（在这种情况下是更具体的`SolidColorBrush`）。
- en: Type converters are just one aspect of XAML that make it more succinct than
    the equivalent C++ code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换器只是XAML的一个方面，使其比等效的C++代码更简洁。
- en: Complex properties
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂属性
- en: 'As we''ve seen, setting properties is done via XML attributes. What about complex
    properties that cannot be expressed as a string and don''t have type converters?
    In this case, an extended syntax (property element syntax) is used to set the
    property. Here''s an example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，设置属性是通过XML属性完成的。那么，对于无法表示为字符串并且没有类型转换器的复杂属性呢？在这种情况下，使用扩展语法（属性元素语法）来设置属性。这里有一个例子：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Setting the `RenderTransform` property cannot be done with a simple string;
    it must be an object that is derived from the `Transform` class (`RotateTransform`
    in this case).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`RenderTransform`属性不能使用简单的字符串；它必须是从`Transform`类派生的对象（在这种情况下是`RotateTransform`）。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The exact meaning of the various example properties (`Fill`, `RenderTransform`,
    and others) will be discussed in [Chapter 4](ch04.html "Chapter 4. Layout, Elements,
    and Controls"), *Layout, Elements, and Controls*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 各种示例属性（`Fill`，`RenderTransform`等）的确切含义将在[第4章](ch04.html "第4章 布局、元素和控件")中讨论，*布局、元素和控件*。
- en: 'The preceding markup is equivalent to the following C++ code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的标记等同于以下C++代码：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Dependency properties and attached properties
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖属性和附加属性
- en: Most properties on various elements and controls are not normal, in the sense
    that they are not simple wrappers around private fields. The significance of dependency
    properties will be discussed in [Chapter 5](ch05.html "Chapter 5. Data Binding"),
    *Data Binding*. For now, it's important to realize that there is no difference
    in XAML between a dependency property and a regular property; the syntax is the
    same. In fact, there is no way to tell if a certain property is a dependency property
    or not, just by looking at its use in XAML.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 各种元素和控件上的大多数属性都不是正常的，它们不是简单的私有字段的包装器。依赖属性的重要性将在[第5章](ch05.html "第5章 数据绑定")中讨论，*数据绑定*。现在，重要的是要意识到在XAML中，依赖属性和常规属性之间没有区别；语法是相同的。实际上，仅仅通过在XAML中使用某个属性，无法判断某个属性是依赖属性还是普通属性。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Dependency properties provide the following features (a detailed explanation
    is provided in [Chapter 6](ch06.html "Chapter 6. Components, Templates, and Custom
    Elements"), *Components, Templates, and Custom Elements*):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖属性提供以下功能（详细解释在[第6章](ch06.html "第6章 组件、模板和自定义元素")中提供，*组件、模板和自定义元素*）：
- en: Change notifications when the property value changes
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当属性值改变时进行更改通知
- en: Visual inheritance for certain properties (mostly the font-related properties)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些属性的视觉继承（主要是与字体相关的属性）
- en: Multiple providers that may affect the final value (one wins out)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能影响最终值的多个提供者（一个获胜）
- en: Memory conservation (value not allocated unless changed)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存保护（值在改变时不分配）
- en: Some WinRT features, such as data binding, styles, and animations are dependent
    on that support.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 某些WinRT功能，如数据绑定、样式和动画，依赖于该支持。
- en: 'Another kind of dependency properties is attached properties. Again, a detailed
    discussion is deferred until [Chapter 5](ch05.html "Chapter 5. Data Binding"),
    *Data Binding*, but essentially an attached property is contextual—it''s defined
    by one type (with a registration mechanism that will be discussed in [Chapter
    6](ch06.html "Chapter 6. Components, Templates, and Custom Elements"), *Components,
    Templates, and Custom Controls*), but can be used by any type that inherits from
    `DependencyObject` (as all elements and controls do). Since this kind of property
    is not defined by the object it''s used on, it merits a special syntax in XAML.
    The following is an example of a `Canvas` panel that holds two elements:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种依赖属性是附加属性。再次，详细讨论将推迟到[第5章](ch05.html "第5章。数据绑定")*数据绑定*，但基本上附加属性是上下文相关的——它由一个类型定义（具有将在[第6章](ch06.html
    "第6章。组件、模板和自定义元素")*组件、模板和自定义控件*中讨论的注册机制），但可以被任何继承自`DependencyObject`的类型使用（因为所有元素和控件都这样做）。由于这种属性不是由其使用的对象定义的，因此它在XAML中具有特殊的语法。以下是一个包含两个元素的`Canvas`面板的示例：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `Canvas.Left` and `Canvas.Top` are attached properties. They were defined
    by the `Canvas` class, but they are attached to the `Rectangle` and `Ellipse`
    elements. Attached properties only have meaning in certain scenarios. In this
    case, they indicate the exact position of the elements within the canvas .The
    canvas is the one that looks for these properties in the layout phase (discussed
    in detail in the next chapter). This means that if those same elements were placed
    in, say a `Grid`, those properties would have no effect, because there is no interested
    entity in those properties (there is no harm in having them, however). Attached
    properties can be thought of as dynamic properties that may or may not be set
    on objects.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas.Left`和`Canvas.Top`是附加属性。它们由`Canvas`类定义，但附加到`Rectangle`和`Ellipse`元素上。附加属性只在某些情况下有意义。在这种情况下，它们指示画布内元素的确切位置。画布在布局阶段查找这些属性（在下一章中详细讨论）。这意味着，如果这些相同的元素放置在，比如一个`Grid`中，这些属性将没有效果，因为没有感兴趣的实体在这些属性中（但是没有伤害）。附加属性可以被视为动态属性，可以在对象上设置或不设置。'
- en: 'This is the resulting UI:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成的UI：
- en: '![Dependency properties and attached properties](img/5022_03_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![依赖属性和附加属性](img/5022_03_04.jpg)'
- en: 'Setting an attached property in code is a little verbose. Here''s the equivalent
    C++ code for setting the `Canvas.Left` and `Canvas.Top` properties on an element
    named `_myrect`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中设置附加属性有点冗长。以下是在名为`_myrect`的元素上设置`Canvas.Left`和`Canvas.Top`属性的等效C++代码：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The reason why the preceding calls will become apparent will be discussed when
    we will learn how to create attached properties in [Chapter 6](ch06.html "Chapter 6. Components,
    Templates, and Custom Elements"), *Components, Templates, and Custom Elements*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的调用将变得明显的原因将在我们学习如何在[第6章](ch06.html "第6章。组件、模板和自定义元素")*组件、模板和自定义元素*中创建附加属性时讨论。
- en: Content properties
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容属性
- en: 'The relationship between a `Page` object and a `Grid` object is not obvious.
    `Grid` seems to be inside the `Page`. But how would that translate to code? The
    `Page`/`Grid` markup can be summed up as follows (ignoring the detailed markup):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Page`对象和`Grid`对象之间的关系并不明显。`Grid`似乎在`Page`内部。但是这如何转换为代码呢？`Page`/`Grid`标记可以总结如下（忽略详细标记）：'
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is actually a shortcut for the following markup:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是以下标记的快捷方式：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This means the `Grid` object is set as the `Content` property of the `Page`
    object; now the relationship is clear. The XAML parser considers certain properties
    (no more than one per type hierarchy) as the default or content properties. It
    doesn''t have to be named `Content`, but it is in the `Page` case. This attribute
    is specified in the control''s metadata using the `Windows::UI::Xaml::Markup::ContentAttribute`
    class attribute. Looking at the Visual Studio object browser for the `Page` class
    shows no such attribute. But `Page` inherits from `UserControl`; navigating to
    `UserControl`, we can see the attribute set:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`Grid`对象被设置为`Page`对象的`Content`属性；现在关系清晰了。XAML解析器将某些属性（每个类型层次结构最多一个）视为默认或内容属性。它不一定要被命名为`Content`，但在`Page`的情况下是这样。这个属性在控件的元数据中使用`Windows::UI::Xaml::Markup::ContentAttribute`类属性来指定。在Visual
    Studio对象浏览器中查看`Page`类，没有这样的属性。但`Page`继承自`UserControl`；导航到`UserControl`，我们可以看到设置了该属性：
- en: '![Content properties](img/5022_03_01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![内容属性](img/5022_03_01.jpg)'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Attributes are a way to extend the metadata for a type declaratively. They can
    be inserted in C++/CX by an attribute type name in square brackets before the
    item that attribute is applied to (can be a class, interface, method, property,
    and other code element). An attribute class must derive from `Platform::Metadata::Attribute`
    to be considered as such by the compiler.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是一种以声明方式扩展类型元数据的方法。它们可以通过在应用该属性的项目之前的方括号中插入C++/CX中的属性类型名称来插入（可以是类、接口、方法、属性和其他代码元素）。属性类必须从`Platform::Metadata::Attribute`派生，才能被编译器视为这样的属性。
- en: 'Some of the common `ContentProperty` properties in WinRT types are as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT类型中一些常见的`ContentProperty`属性如下：
- en: '`Content` of `ContentControl` (and all derived types)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContentControl`的`Content`（以及所有派生类型）'
- en: '`Content` of `UserControl`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserControl`的`Content`'
- en: '`Children` of `Panel` (base class for all layout containers)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Panel`的`Children`（所有布局容器的基类）'
- en: '`Items` of `ItemsControl` (base class for collection-based controls)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ItemsControl`的`Items`（集合型控件的基类）'
- en: '`GradientStops` of `GradientBrush` (base class of `LinearGradientBrush`)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GradientBrush`的`GradientStops`（`LinearGradientBrush`的基类）'
- en: Collection properties
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合属性
- en: 'Some properties are collections (of type `IVector<T>` or `IMap<K,V>`, for instance).
    Such properties can be filled with objects, and the XAML parser will call the
    `IVector<T>::Append` or `IMap<K,V>::Insert` methods. Here''s an example for a
    `LinearGradientBrush`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性是集合（例如`IVector<T>`或`IMap<K,V>`类型）。这些属性可以填充对象，XAML解析器将调用`IVector<T>::Append`或`IMap<K,V>::Insert`方法。这是`LinearGradientBrush`的一个示例：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Two rules are at work here. The first is the `ContentProperty` of `LinearGradientBrush`
    (`GradientStops`), which need not be specified. It''s of the type `GradientStopCollection`,
    which implements `IVector<GradientStop>`, and thus is eligible for automatic appending.
    This is equivalent to the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两条规则。第一条是`LinearGradientBrush`的`ContentProperty`（`GradientStops`），不需要指定。它是`GradientStopCollection`类型，实现了`IVector<GradientStop>`，因此有资格进行自动追加。这相当于以下代码：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is perhaps the first clear sign of XAML syntax advantage over C++. Here''s
    the rectangle in all its glory:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是XAML语法优势在C++上的第一个明显迹象。以下是矩形的全部荣耀：
- en: '![Collection properties](img/5022_03_02.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![集合属性](img/5022_03_02.jpg)'
- en: In the case of `IMap<K,V>`, an attribute named `x:Key` must be set on each item
    to indicate the key sent to the `IMap<K,V>::Insert` method. We'll see an example
    of such a map later in this chapter, when we will discuss resources.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`IMap<K,V>`，必须在每个项目上设置名为`x:Key`的属性，以指示发送到`IMap<K,V>::Insert`方法的键。在本章后面，我们将讨论资源时，将看到这样一个地图的例子。
- en: Markup extensions
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标记扩展
- en: '**Markup extensions** are special instructions to the XAML parser that provide
    ways of expressing things that are beyond object creation or setting some property.
    These instructions are still declarative in nature, but their code equivalent
    usually entails calling methods, which is not directly possible in XAML.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**标记扩展**是对XAML解析器的特殊指令，提供了表达超出对象创建或设置某些属性的方式。这些指令仍然是声明性的，但它们的代码等效通常涉及调用方法，在XAML中直接不可能。'
- en: Markup extensions are placed inside curly braces as property values. They may
    contain arguments and properties, as we'll see in later chapters. The only markup
    extension used by default in a blank page is `{StaticResource}`, which will be
    discussed later in this chapter.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 标记扩展放置在花括号内作为属性值。它们可以包含参数和属性，我们将在后面的章节中看到。在空白页面中默认使用的唯一标记扩展是`{StaticResource}`，将在本章后面讨论。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WPF and Silverlight 5 allow developers to create custom markup extensions by
    deriving classes from `MarkupExtension`. This capability is unavailable in the
    current WinRT implementation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: WPF和Silverlight 5允许开发人员通过从`MarkupExtension`派生类来创建自定义标记扩展。当前WinRT实现中不支持此功能。
- en: 'One simple example of a markup extension is `{x:Null}`. This is used in XAML
    whenever the value `nullptr` needs to be specified, as there''s no better way
    to use a string for this. The following example makes a hole in the `Rectangle`
    element:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的标记扩展的例子是`{x:Null}`。每当需要指定值`nullptr`时，在XAML中使用它，因为没有更好的方法来使用字符串。以下示例在`Rectangle`元素中创建了一个空白：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Naming elements
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名元素
- en: 'Objects created through XAML can be named using the `x:Name` XAML attribute.
    Here''s an example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过XAML创建的对象可以使用`x:Name` XAML属性进行命名。以下是一个例子：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The net result is a private member variable (field) that is created by the
    XAML compiler inside `MainPage.g.h` (if working on `MainPage.xaml`):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是一个私有成员变量（字段），由XAML编译器在`MainPage.g.h`中创建（如果在`MainPage.xaml`上工作）：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The reference in itself must be set in the implementation of `MainPage::InitializeComponent`
    with the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 引用本身必须在`MainPage::InitializeComponent`的实现中设置，使用以下代码：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The mentioned file and method are discussed further in the section *XAML compilation
    and execution*. Regardless of how it works, `r1` is now a reference to that particular
    rectangle.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的文件和方法在* XAML编译和执行*部分进一步讨论。无论它是如何工作的，`r1`现在是对该特定矩形的引用。
- en: Connecting events to handlers
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接事件到处理程序
- en: Events can be connected to handlers by using the same syntax as setting properties,
    but in this case the value of the property must be a method in the code behind
    class with the correct delegate signature.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 事件可以通过与设置属性相同的语法连接到处理程序，但在这种情况下，属性的值必须是代码后台类中具有正确委托签名的方法。
- en: Visual Studio helps out by adding a method automatically if *Tab* is pressed
    twice after entering the event name (in the header and implementation files).
    The default name that Visual Studio uses includes the element's name (`x:Name`)
    if it has one, or its type if it doesn't, followed by an underscore and the event
    name, and optionally followed by an underscore and an index if duplication is
    detected. The default name is usually not desirable; a better approach that still
    has Visual Studio creating the correct prototype is to write the handler name
    as we want it, and then right-click on the handler name and select **Navigate
    to Event Handler**. This has the effect of creating the handler (if it does not
    exist) and switching to the method implementation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在输入事件名称后两次按下* Tab*，Visual Studio会自动添加一个方法。Visual Studio使用的默认名称包括元素的名称（`x:Name`）（如果有）或其类型（如果没有），后跟下划线和事件名称，如果检测到重复，则后跟下划线和索引。默认名称通常不理想；一个更好的方法，仍然让Visual
    Studio创建正确的原型，是按照我们想要的方式编写处理程序名称，然后右键单击处理程序名称并选择**导航到事件处理程序**。这将创建处理程序（如果不存在）并切换到方法实现。
- en: 'Here''s an example of an XAML event connection:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是XAML事件连接的示例：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And the handler would be as follows (assuming the XAML is in `MainPage.xaml`):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序如下（假设XAML在`MainPage.xaml`中）：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Visual Studio also writes the namespace name in front of the class name (deleted
    in the preceding code example); this can be deleted safely, since an in-use namespace
    statement exists at the top of the file for the correct namespace. Also, the usage
    of `Platform::Object` instead of just `Object` (and similarly for `RoutedEventArgs`)
    is less readable; the namespace prefixes can be removed, as they are set up at
    the top of the file by default.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio还在类名前面写入命名空间名称（在前面的代码示例中删除了）；这可以安全地删除，因为文件顶部存在正确命名空间的使用命名空间语句。此外，使用`Platform::Object`而不仅仅是`Object`（以及类似于`RoutedEventArgs`）不够可读；命名空间前缀可以被移除，因为它们默认在文件顶部设置。
- en: All events (by convention) use delegates that are similar. The first argument
    is always the sender of the event (in this case a `Button`) and the second parameter
    is the extra information regarding the event. `RoutedEventArgs` is the minimum
    type for events, known as routed events. A detailed discussion of routed events
    is covered in the next chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有事件（按照惯例）使用类似的委托。第一个参数始终是事件的发送者（在本例中是`Button`），第二个参数是有关事件的额外信息。`RoutedEventArgs`是事件的最小类型，称为路由事件。路由事件的详细讨论将在下一章中进行。
- en: XAML rules summary
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XAML规则摘要
- en: 'This is a summary of all XAML rules:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有XAML规则的摘要：
- en: An XAML element means creating an instance.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAML元素意味着创建一个实例。
- en: An XAML attribute sets a property or an event handler. For properties, a type
    converter may execute depending on the property's type.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XAML属性设置属性或事件处理程序。对于属性，根据属性的类型，可能会执行类型转换器。
- en: Complex properties are set with the `Type.Property` element syntax.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Type.Property`元素语法设置复杂属性。
- en: Attached properties are set with the `Type.Property` syntax, where `Type` is
    the declaring type of the attached property.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Type.Property`语法设置附加属性，其中`Type`是附加属性的声明类型。
- en: '`ContentPropertyAttribute` sets a `Content` property that need not be specified.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContentPropertyAttribute`设置一个不需要指定的`Content`属性。'
- en: Properties that are collections cause the XAML parser to call `Append` or `Insert`,
    as appropriate, automatically.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为集合的属性会自动调用`Append`或`Insert`的XAML解析器。
- en: Markup extensions allow for special (predefined) instructions.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记扩展允许特殊（预定义）指令。
- en: Introducing the Blend for Visual Studio 2012 tool
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Blend for Visual Studio 2012工具
- en: Visual Studio 2012 is installed with the Blend for Visual Studio 2012 tool.
    This tool is typically used by UI designers to create or manipulate the user interface
    for XAML-based applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2012安装了Blend for Visual Studio 2012工具。UI设计师通常使用此工具来创建或操作基于XAML的应用程序的用户界面。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The initial release of Blend for Visual Studio 2012 only supported Windows 8
    Store Apps and Windows Phone 8 projects. The support for WPF 4.5 and Silverlight
    was added in Update 2 for Visual Studio 2012.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Blend for Visual Studio 2012的初始版本仅支持Windows 8商店应用程序和Windows Phone 8项目。对于Visual
    Studio 2012的更新2中添加了对WPF 4.5和Silverlight的支持。
- en: 'Blend can be used alongside Visual Studio 2012, as both understand the same
    file types (such as solution `.sln` files). It''s not atypical to switch back
    and forth between the two tools—using each tool for its strengths. Here''s a screenshot
    of Blend with the `CH03.sln` solution file open (the solution that holds all the
    samples for this chapter):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Blend可以与Visual Studio 2012一起使用，因为两者都能理解相同的文件类型（例如解决方案`.sln`文件）。在这两种工具之间来回切换并不罕见，每个工具都发挥其优势。这是Blend打开`CH03.sln`解决方案文件的屏幕截图（该解决方案包含本章节所有示例）：
- en: '![Introducing the Blend for Visual Studio 2012 tool](img/5022_03_10.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![介绍Blend for Visual Studio 2012工具](img/5022_03_10.jpg)'
- en: 'The preceding screenshot shows a particular XAML file open, with one button
    selected. Several windows comprise Blend, some of which are similar to their Visual
    Studio counterparts, namely **Projects** and **Properties**. Some of the new windows
    include:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述屏幕截图显示了一个特定的XAML文件打开，其中选择了一个按钮。Blend由几个窗口组成，其中一些与其Visual Studio对应部分相似，即**项目**和**属性**。一些新窗口包括：
- en: '**Assets**: Holds the elements and controls available in WinRT (along with
    some other useful shortcuts)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：包含WinRT中可用的元素和控件（以及其他一些有用的快捷方式）'
- en: '**Objects** and **Timeline**: Include all objects in the visual tree and also
    animations'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**和**时间轴**：包括可视树中的所有对象以及动画'
- en: '**Resources**: Holds all resources (refer to the next section) within the application'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：包含应用程序中的所有资源（参见下一节）'
- en: Blend's design surface allows manipulating elements and controls, which is also
    possible to do in Visual Studio. Blend's layout and some special editing features
    make it easier for UI/graphic designers to work with as it mimics other popular
    applications, such as Adobe Photoshop and Illustrator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Blend的设计界面允许操作元素和控件，这在Visual Studio中也是可能的。Blend的布局和一些特殊的编辑功能使得UI/图形设计师更容易使用，因为它模仿了其他流行的应用程序，如Adobe
    Photoshop和Illustrator。
- en: Any changes made using the designer are immediately reflected by the changed
    XAML. Switching back to Visual Studio and accepting the reload option synchronizes
    the files; naturally, this can be done both ways.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设计师进行的任何更改都会立即反映在更改的XAML中。切换回Visual Studio并接受重新加载选项会同步文件；当然，这两种方式都可以做到。
- en: It's possible to work from within Blend entirely. Pressing *F5* builds and launches
    the app in the usual way. Blend, however, is not Visual Studio, and breakpoints
    and other debugging tasks are not supported.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以在Blend内部工作。按下*F5*以通常方式构建和启动应用程序。但是，Blend不是Visual Studio，不支持断点和其他调试任务。
- en: Blend is a non-trivial tool, and is well beyond the scope of this book. Experimentation
    can go a long way, however.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Blend是一个非常复杂的工具，远远超出了本书的范围。然而，通过实验可以走得更远。
- en: XAML compilation and execution
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XAML编译和执行
- en: 'The XAML compiler that runs as part of the normal compilation process, places
    the XAML as an internal resource within the EXE or DLL. In the constructor of
    a XAML root element type (such as `MainPage`), a call is made to `InitializeComponent`
    . This method uses a static helper method `Application::LoadComponent` to load
    the XAML and parse it—creating objects, setting properties, and so on. Here''s
    the implementation created by the compiler for `InitializeComponent` (in `MainPage.g.hpp`,
    with some code cleaning):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为正常编译过程的一部分运行的XAML编译器，将XAML作为内部资源放置在EXE或DLL中。在XAML根元素类型（例如`MainPage`）的构造函数中，调用`InitializeComponent`。该方法使用静态辅助方法`Application::LoadComponent`来加载XAML并解析它，创建对象，设置属性等。这是编译器为`InitializeComponent`创建的实现（在`MainPage.g.hpp`中，进行了一些代码清理）：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Connecting XAML, H, and CPP files to the build process
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将XAML、H和CPP文件连接到构建过程
- en: 'From a developer''s perspective, working with a XAML file carries with it two
    other files, the H and CPP. Let''s examine them in a little more detail. Here''s
    the default `MainPage.xaml.h` (comments and namespaces removed):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发人员的角度来看，使用 XAML 文件还需要另外两个文件，即 H 和 CPP。让我们更详细地检查一下它们。这是默认的 `MainPage.xaml.h`（已删除注释和命名空间）：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The code shows a constructor and a virtual method override named `OnNavigatedTo`
    (unimportant for this discussion). One thing that seems to be missing is the `InitializeComponent`
    method declaration mentioned in the previous section. Also the inheritance from
    `Page` that was hinted at earlier is missing. It turns out that the XAML compiler
    generates another header file named `MainPage.g.h` (`g` stands for generated)
    based on the XAML itself (this is evident with the top `#include` declaration).
    This file contains the following (it can be opened easily by selecting the **Project**
    | **Show All Files**, or the equivalent toolbar button, or right clicking on `#include`
    and selecting **Open Document…**):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 代码显示了一个构造函数和一个名为 `OnNavigatedTo` 的虚方法重写（对于本讨论不重要）。似乎缺少的一件事是在前一节中提到的 `InitializeComponent`
    方法声明。还有之前提到的从 `Page` 继承也缺失了。原来 XAML 编译器生成了另一个名为 `MainPage.g.h`（`g` 代表生成）的头文件，基于
    XAML 本身（这可以通过顶部的 `#include` 声明来证明）。这个文件包含以下内容（可以通过选择 **项目** | **显示所有文件**，或等效的工具栏按钮，或右键单击
    `#include` 并选择 **打开文档…** 来轻松打开）：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we find the missing pieces. Here we find `InitializeComponent`, as well
    as the derivation from `Page`. How can there be more than one header file per
    class? A new C++/CX feature called partial classes allows this. The `MainPage`
    class is marked as `partial`, meaning there are more parts to it. The last part
    should not be marked as `partial`, and should include at least one header so that
    a chain forms, eventually including all the partial headers; all these headers
    must be part of the same compilation unit (a CPP file). This `MainPage.g.h` file
    is generated before any compilation happens; it's generated on the fly while editing
    the XAML file. This is important because named elements are declared in that file,
    providing instance intellisense.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们找到了缺失的部分。在这里我们找到了 `InitializeComponent`，以及从 `Page` 派生。一个类怎么会有多个头文件？一个名为部分类的新
    C++/CX 功能允许这样做。`MainPage` 类被标记为 `partial`，意味着它有更多的部分。最后一个部分不应该被标记为 `partial`，并且应该包含至少一个头文件，以便形成一个链，最终包括所有部分头文件；所有这些头文件必须是同一个编译单元（一个
    CPP 文件）的一部分。`MainPage.g.h` 文件是在任何编译发生之前生成的；它是在编辑 XAML 文件时动态生成的。这很重要，因为命名元素是在那个文件中声明的，提供实例智能感知。
- en: During the compilation process, `MainPage.cpp` is finally compiled, producing
    an object file, `MainPage.obj`. It still has some unresolved functions, such as
    `InitializeComponent`. At this time, `MainPage.obj` (along with other XAML object
    files, if exist) is used to generate the metadata (`.winmd`) file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译过程中，`MainPage.cpp` 最终被编译，生成一个对象文件 `MainPage.obj`。它仍然有一些未解决的函数，比如 `InitializeComponent`。此时，`MainPage.obj`（以及其他
    XAML 对象文件，如果存在）被用来生成元数据（`.winmd`）文件。
- en: To complete the build process, the compiler generates `MainPage.g.hpp`, which
    is actually an implementation file, created based on the information extracted
    from the metadata file (the `InitializeComponent` implementation is generated
    in this file). This generated file is included just once in a file called `XamlTypeInfo.g.cpp`,
    which is also generated automatically based on the metadata file (its job is related
    to data binding, as discussed in [Chapter 5](ch05.html "Chapter 5. Data Binding"),
    *Data Binding*), but that's good enough so that `MainPage.g.hpp` is finally compiled,
    allowing linking to occur correctly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成构建过程，编译器生成了 `MainPage.g.hpp`，实际上是一个实现文件，根据从元数据文件中提取的信息创建的（`InitializeComponent`
    实现是在这个文件中生成的）。这个生成的文件只包含在一个名为 `XamlTypeInfo.g.cpp` 的文件中，这个文件也是根据元数据文件自动生成的（它的工作与数据绑定有关，如
    [第 5 章](ch05.html "第 5 章. 数据绑定") 中讨论的 *数据绑定*），但这已经足够让 `MainPage.g.hpp` 最终被编译，允许链接正确进行。
- en: 'The entire process can be summarized with the following diagram:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程可以用以下图表总结：
- en: '![Connecting XAML, H, and CPP files to the build process](img/5022_03_03.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![将 XAML、H 和 CPP 文件连接到构建过程](img/5022_03_03.jpg)'
- en: Resources
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: The term "resources" is highly overloaded. In classic Win32 programming, resources
    refer to read-only chunks of data, used by an application. Typical Win32 resources
    are strings, bitmaps, menus, toolbars, and dialogs, but custom resources can be
    created as well, making Win32 treat those as unknown chunks of binary data.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“资源”有很多含义。在经典的 Win32 编程中，资源指的是应用程序使用的只读数据块。典型的 Win32 资源包括字符串、位图、菜单、工具栏和对话框，但也可以创建自定义资源，使
    Win32 将其视为未知的二进制数据块。
- en: WinRT defines binary, string, and logical resources. The following sections
    discuss binary and logical resources (string resources are useful for localization
    scenarios and will not be discussed in this section).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT 定义了二进制、字符串和逻辑资源。以下部分讨论二进制和逻辑资源（字符串资源对于本节的本地化场景很有用，不在本节讨论范围内）。
- en: Binary resources
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制资源
- en: Binary resources refer to chunks of data, provided as part of the application's
    package. These typically include images, fonts, and any other static data needed
    for the application to function correctly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制资源是指作为应用程序包的一部分提供的数据块。这些通常包括图像、字体和应用程序正常运行所需的任何其他静态数据。
- en: Binary resources can be added to a project by right-clicking on the project
    in Solution Explorer, and selecting **Add Existing Item**. Then, select a file
    that must be in the project's directory or in a subdirectory.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在解决方案资源管理器中右键单击项目，然后选择 **添加现有项** 来将二进制资源添加到项目中。然后，选择必须位于项目目录或子目录中的文件。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Contrary to C# or VB projects, adding an existing item from a location does
    not copy the file to the project's directory. This inconsistency is a bit annoying
    for those familiar with C#/VB projects, and hopefully will be reconciled in a
    future Visual Studio version or service pack.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与C#或VB项目相反，从位置添加现有项目不会将文件复制到项目的目录中。对于熟悉C#/VB项目的人来说，这种不一致性有点恼人，希望在将来的Visual Studio版本或服务包中能得到调和。
- en: 'A typical Store app project already has some binary resources stored in the
    `Assets` project folder, namely images used by the application:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的商店应用程序项目已经在`Assets`项目文件夹中存储了一些二进制资源，即应用程序使用的图像：
- en: '![Binary resources](img/5022_03_05.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![二进制资源](img/5022_03_05.jpg)'
- en: Using folders is a good way to organize resources by type or usage. Right-clicking
    on the project node and selecting **Add New Filter** creates a logical folder,
    to which items may be dragged.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件夹是按类型或用途组织资源的好方法。右键单击项目节点并选择**添加新过滤器**会创建一个逻辑文件夹，可以将项目拖放到其中。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Again, contrary to C#/VB projects, project folders are not created in the filesystem.
    It's recommended that these are actually created in the filesystem for better
    organization.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与C#/VB项目相反，项目文件夹不会在文件系统中创建。建议实际上在文件系统中创建这些文件夹以便更好地组织。
- en: 'The added binary resource is packaged as part of the application''s package
    and is available in the executable folder or subfolder, keeping its relative location.
    Right-clicking on such a resource and selecting **Properties** yields the following
    dialog:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的二进制资源作为应用程序包的一部分打包，并在可执行文件夹或子文件夹中可用，保持其相对位置。右键单击此类资源并选择**属性**会出现以下对话框：
- en: '![Binary resources](img/5022_03_06.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![二进制资源](img/5022_03_06.jpg)'
- en: The **Content** attribute must be set to **Yes** for the resource to be actually
    available (the default). **Item Type** is typically recognized by Visual Studio
    automatically. In case, it doesn't, we can always set it to **Text** and do whatever
    we want with it in code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容**属性必须设置为**是**才能实际可用（默认值）。**项目类型**通常会被Visual Studio自动识别。如果没有，我们可以始终将其设置为**文本**并在代码中进行任何操作。'
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't set **Item Type** to **Resource**. This is unsupported in WinRT and will
    cause compile errors (this setting is really for WPF/Silverlight).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将**项目类型**设置为**资源**。这在WinRT中不受支持，会导致编译错误（此设置实际上是为WPF/Silverlight准备的）。
- en: 'Binary resources can be accessed in XAML or in code, depending on the need.
    Here''s an example of using an image named `apple.png` stored in a subfolder in
    the application named `Images` under the `Assets` folder by an `Image` element:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要，可以在XAML或代码中访问二进制资源。以下是一个示例，使用存储在应用程序的`Assets`文件夹下`Images`文件夹中的子文件夹中名为`apple.png`的图像的`Image`元素：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note the relative URI. The preceding markup works because of a type converter
    that''s used or the `Image::Source` property (which is of the type `ImageSource`).
    That path is really a shortcut for the following, equivalent, URI:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意相对URI。前面的标记之所以有效是因为使用了类型转换器或`Image::Source`属性（类型为`ImageSource`）。该路径实际上是以下等效URI的快捷方式：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Other properties may require a slightly different syntax, but all originate
    through the `ms-appx` scheme, indicating the root of the application's package.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 其他属性可能需要稍有不同的语法，但都是通过`ms-appx`方案生成，表示应用程序包的根。
- en: 'Binary resources that are stored in another component referenced by the application
    can be accessed with the following syntax:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序引用的另一个组件中存储的二进制资源可以使用以下语法访问：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The markup assumes that a component DLL named `ResourceLibrary.Dll` is referenced
    by the application and that a binary resource named `jellyfish.jpg` is present
    in its root folder.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 标记假定应用程序引用了名为`ResourceLibrary.Dll`的组件DLL，并且其根文件夹中存在名为`jellyfish.jpg`的二进制资源。
- en: Logical resources
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑资源
- en: Binary resources are not new or unique to Store apps. They've been around practically
    forever. Logical resources, on the other hand, is a more recent addition. First
    created and used by WPF, followed by the various versions of Silverlight, they
    are used in WinRT as well. So, what are they?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制资源对于商店应用程序并不新鲜或独特。它们几乎永远存在。另一方面，逻辑资源是一个较新的添加。首先由WPF创建和使用，然后是各个版本的Silverlight，它们也在WinRT中使用。那么，它们是什么？
- en: Logical resources can be almost anything. These are objects, not binary chunks
    of data. They are stored in the `ResourceDictionary` objects, and can be easily
    accessed in XAML by using the `StaticResource` markup extension.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑资源几乎可以是任何东西。这些是对象，而不是二进制数据块。它们存储在`ResourceDictionary`对象中，并可以通过使用`StaticResource`标记扩展在XAML中轻松访问。
- en: 'Here''s an example of two elements that use an identical brush:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用相同画笔的两个元素的示例：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The problem should be self-evident. We''re using the same brush twice. This
    is bad for two reasons:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 问题应该是不言自明的。我们两次使用了同一画笔。这有两个原因不好：
- en: If we want to change the brush, we need to do it twice (because of the duplication).
    Naturally, this is more severe if that brush is used by more than two elements.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要更改画笔，我们需要做两次（因为重复）。如果该画笔被两个以上的元素使用，这自然会更严重。
- en: Two different objects are created, although just one shared object is needed.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管只需要一个共享对象，但创建了两个不同的对象。
- en: '`LinearGradientBrush` can be turned into a logical resource (or simply a resource)
    and referenced by any element that requires it. To do that, the brush must be
    placed in a `ResourceDictionary` object. Fortunately, every element has a `Resources`
    property (of type `ResourceDictionary`) that we can use. This is typically done
    on the root XAML element (typically a `Page`), or (as we''ll see in a moment)
    in the application''s XAML (`App.Xaml`):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearGradientBrush`可以转换为逻辑资源（或简单资源），并被任何需要它的元素引用。为此，画笔必须放置在`ResourceDictionary`对象中。幸运的是，每个元素都有一个`Resources`属性（类型为`ResourceDictionary`）可以使用。这通常在根XAML元素（通常是`Page`）上完成，或者（我们马上会看到的）在应用程序的XAML（`App.Xaml`）中完成：'
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Any logical resource must have a key, because it''s in a dictionary. That key
    is specified by the `x:Key` XAML directive. Once placed, a resource can be accessed
    from any element within that `Page` with the `StaticResource` markup extension
    as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 任何逻辑资源必须有一个键，因为它在字典中。该键由“x:Key”XAML指令指定。一旦放置，资源可以通过以下方式使用“StaticResource”标记扩展从“Page”中的任何元素中访问：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `StaticResource` markup extension searches for a resource with the specified
    key starting from the current element. If not found, the search continues on the
    resources with its parent element (say a Grid). If found, the resource is selected
    (it is created the first time it''s requested), and `StaticResource` is done.
    If not found, the parent''s parent is searched and so on. If the resource is not
    found at the top level element (typically a `Page`, but can be a `UserControl`
    or something else), the search continues in the application resources (`App.xaml`).
    If not found, an exception is thrown. The search process can be summarized by
    the following diagram:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: “StaticResource”标记扩展从当前元素开始搜索具有指定键的资源。如果找不到，则在其父元素（例如Grid）的资源上继续搜索。如果找到，则选择资源（在第一次请求时创建），并且“StaticResource”完成。如果找不到，则搜索父级的父级，依此类推。如果在顶级元素（通常是“Page”，但可以是“UserControl”或其他内容）中找不到资源，则在应用程序资源（“App.xaml”）中继续搜索。如果找不到，则抛出异常。搜索过程可以通过以下图表总结：
- en: '![Logical resources](img/5022_03_07.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![逻辑资源](img/5022_03_07.jpg)'
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Why is the markup extension called `StaticResource`? Is there a `DynamicResource`?
    `DynamicResource` exists in WPF only, which allows a resource to be replaced dynamically,
    with all those bound to it noticing the change. This is currently unsupported
    by WinRT.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么标记扩展被称为“StaticResource”？是否有“DynamicResource”？“DynamicResource”仅存在于WPF中，它允许资源动态替换，并且所有绑定到它的对象都能注意到这种变化。这在WinRT中目前不受支持。
- en: There is no single call that is equivalent to `StaticResource`, although it's
    not difficult to create one if needed. The `FrameworkElement::Resources` property
    can be consulted on any required level, navigating to the parent element using
    the `Parent` property. The `Application::Resources` property has special significance,
    since any resources defined within it can be referenced by any page or element
    across the entire application. This is typically used to set various defaults
    for a consistent look and feel.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 没有与“StaticResource”等效的单个调用，尽管如果需要，创建一个并不困难。可以在任何所需的级别上使用“FrameworkElement::Resources”属性进行查询，使用“Parent”属性导航到父元素。
    “Application::Resources”属性具有特殊意义，因为在其中定义的任何资源都可以被整个应用程序中的任何页面或元素引用。这通常用于设置一致外观和感觉的各种默认值。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It may be tempting to store actual elements as resources (such as buttons).
    This should be avoided because resources are singletons within their usage container;
    this means referencing that button more than once within the same page will cause
    an exception to be thrown on the second reference, because an element can be in
    the visual tree just once.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将实际元素存储为资源可能很诱人（例如按钮）。应该避免这样做，因为资源在其使用容器中是单例；这意味着在同一页面中多次引用该按钮将导致在第二次引用时抛出异常，因为元素只能在可视树中出现一次。
- en: Resources are really intended for sharable objects, such as brushes, animations,
    styles, and templates.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 资源实际上是用于可共享的对象，例如画笔、动画、样式和模板。
- en: Resources can be added dynamically by using the `ResourceDictionary::Insert`
    method (on the relevant `ResourceDictionary`) and removed by calling `ResourceDictionary::Remove`.
    This only has an effect on subsequent `{StaticResource}` invocations; already
    bound resources are unaffected.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用“ResourceDictionary::Insert”方法（在相关的“ResourceDictionary”上）动态添加资源，并通过调用“ResourceDictionary::Remove”来删除资源。这只对后续的{StaticResource}调用产生影响；已绑定的资源不受影响。
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A `StaticResource` markup extension can be used by a resource as well. For this
    to work, any `StaticResource` must reference a resource that was defined earlier
    in the XAML; this is due to the way the XAML parser works. It cannot find resources
    that it has not yet encountered.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 资源也可以使用“StaticResource”标记扩展。为了使其工作，任何“StaticResource”必须引用在XAML中先前定义的资源；这是由于XAML解析器的工作方式。它无法找到尚未遇到的资源。
- en: Managing logical resources
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理逻辑资源
- en: Logical resources may be of various types, such as brushes, geometries, styles,
    templates, and more. Placing all those resources in a single file, such as `App.xaml`,
    hinders maintainability. A better approach would be to separate resources of different
    types (or based on some other criteria) from their own files. Still, they must
    be referenced somehow from within a common file such as `App.xaml` so that they
    are recognized.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑资源可以是各种类型，例如画笔、几何图形、样式、模板等。将所有这些资源放在一个文件中，例如“App.xaml”，会阻碍可维护性。更好的方法是将不同类型的资源（或基于其他标准）从它们自己的文件中分离出来。但是，它们必须以某种方式从一个共同的文件（如“App.xaml”）中引用，以便它们被识别。
- en: '`ResourceDictionary` can incorporate other resource dictionaries using its
    `MergedDictionaries` property (a collection). This means a `ResourceDictionary`
    can reference as many resource dictionaries as desired and can have its own resources
    as well. The `Source` property must point to the location of `ResourceDictionary`.
    The default `App.xaml` created by Visual Studio contains the following (comments
    removed):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: “ResourceDictionary”可以使用其“MergedDictionaries”属性（一个集合）合并其他资源字典。这意味着“ResourceDictionary”可以引用尽可能多的资源字典，并且可以拥有自己的资源。
    “Source”属性必须指向“ResourceDictionary”的位置。由Visual Studio创建的默认“App.xaml”包含以下内容（已删除注释）：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Indeed, we find a file called `StandardStyles.xaml` in the `Common` folder,
    which hosts a bunch of logical resources, with `ResourceDictionary` as its root
    element. For this file to be considered when `StaticResource` is invoked, it must
    be referenced by another `ResourceDictionary`, from a `Page` or the application
    (the application is more common). The `ResourceDictionary::MergedDictionaries`
    property contains other `ResourceDictionary` objects, whose `Source` property
    must point to the required XAML to be included (that XAML must have `ResourceDictionary`
    as its root element).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，在`Common`文件夹中我们找到了一个名为`StandardStyles.xaml`的文件，其中包含一堆逻辑资源，其根元素为`ResourceDictionary`。当调用`StaticResource`时，要考虑到这个文件，它必须被另一个`ResourceDictionary`引用，可以是从`Page`或应用程序引用（应用程序更常见）。`ResourceDictionary::MergedDictionaries`属性包含其他`ResourceDictionary`对象，其`Source`属性必须指向要包含的所需XAML文件（该XAML文件必须以`ResourceDictionary`作为其根元素）。
- en: 'We can create our own `ResourceDictionary` XAML by using Visual Studio''s **Add
    New Item** menu option and selecting **Resource Dictionary**:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Visual Studio的**添加新项**菜单选项并选择**资源字典**来创建自己的`ResourceDictionary` XAML：
- en: '![Managing logical resources](img/5022_03_08.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![管理逻辑资源](img/5022_03_08.jpg)'
- en: Duplicate keys
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复的键
- en: No two objects can have the same key in the same `ResourceDictionary` instance.
    `StaticResource` takes the first resource it finds with the specified key, even
    if that key already exists in a `ResourceDictionary`. What about merged dictionaries?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个`ResourceDictionary`实例中，两个对象不能具有相同的键。`StaticResource`会获取它在指定键中找到的第一个资源，即使该键已经存在于`ResourceDictionary`中。那么合并字典呢？
- en: 'Merging different resource dictionaries may cause an issue—two or more resources
    with the same key that originate from different merged dictionaries. This is not
    an error and does not throw an exception. Instead, the selected object is the
    one from the last resource dictionary added (which has a resource with that key).
    Furthermore, if a resource in the current resource dictionary has the same key
    as any of the resources in its merged dictionaries, it always wins out. Here''s
    an example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 合并不同的资源字典可能会导致问题——来自不同合并字典的两个或更多具有相同键的资源。这不是错误，也不会引发异常。相反，所选对象是来自最后一个添加的资源字典（具有该键的资源）。此外，如果当前资源字典中的资源与其合并字典中的任何资源具有相同的键，它总是胜出。以下是一个例子：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Given this markup, the resource named `brush1` is a blue `SolidColorBrush` because
    it appears in the `ResourceDictionary` itself. This overrides any resources named
    `brush1` in the merged dictionaries. If this blue brush did not exist, `brush1`
    would be looked up in `Brushes1.xaml` first, as this is the last entry in the
    merged dictionaries collection.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个标记，名为`brush1`的资源是蓝色的`SolidColorBrush`，因为它出现在`ResourceDictionary`本身中。这会覆盖合并字典中命名为`brush1`的任何资源。如果这个蓝色的画笔不存在，`brush1`将首先在`Brushes1.xaml`中查找，因为这是合并字典集合中的最后一个条目。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: XAML containing a `ResourceDictionary` as its root can be loaded dynamically
    from a string using the static `XamlReader::Load` method and then added as a merged
    dictionary, where appropriate.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`ResourceDictionary`作为其根的XAML可以使用静态`XamlReader::Load`方法从字符串动态加载，然后根据需要添加为合并字典。
- en: Styles
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式
- en: Consistency in user interface is an important trait; there are many facets of
    consistency, one of which is the consistent look and feel of controls. For example,
    all buttons should look roughly the same—similar colors, fonts, sizes, and so
    on. Styles provide a convenient way of grouping a set of properties under a single
    object, and then selectively (or automatically, as we'll see later) apply it to
    elements.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面的一致性是一个重要特征；一致性有许多方面，其中之一是控件的一致外观和感觉。例如，所有按钮应该大致相同——类似的颜色、字体、大小等。样式提供了一种方便的方式，将一组属性分组到一个单一对象下，然后有选择地（或自动地，我们稍后会看到）将其应用到元素上。
- en: Styles are always defined as resources (usually at the application level, but
    can also be at the `Page` or `UserControl` level). Once defined, they can be applied
    to elements by setting the `FrameworkElement::Style` property.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 样式总是被定义为资源（通常在应用程序级别，但也可以在`Page`或`UserControl`级别）。一旦定义，它们可以通过设置`FrameworkElement::Style`属性应用到元素上。
- en: 'Here''s a style defined as part of the `Resources` section of a `Page`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是作为`Page`的`Resources`部分的一部分定义的样式：
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The style has a key (`style1`), and must have `TargetType`. This is the type
    the style may be applied to (and any derived types). The XAML parser has a type
    converter that converts `TargetType` to a `TypeName` object.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该样式有一个键（`style1`），并且必须有`TargetType`。这是样式可以应用到的类型（以及任何派生类型）。XAML解析器具有将`TargetType`转换为`TypeName`对象的类型转换器。
- en: The main ingredient in `Style` is its `Setters` collection (which is also its
    `ContentProperty`). This collection accepts `Setter` objects, which need `Property`
    and `Value`. The property must be a dependency property (not usually a problem,
    as most element properties are dependency properties); these are provided as simple
    strings thanks to type converters used behind the scene.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Style`中的主要成分是其`Setters`集合（也是其`ContentProperty`）。该集合接受`Setter`对象，需要`Property`和`Value`。属性必须是依赖属性（通常不是问题，因为大多数元素属性都是依赖属性）；这些依赖属性由于幕后使用的类型转换器而作为简单字符串提供。'
- en: The above markup sets up the properties `FontSize`, `Background` (with a complex
    property syntax because of the `LinearGradientBrush`), and `Foreground`—all for
    the `Button` controls.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的标记设置了`FontSize`、`Background`（由于`LinearGradientBrush`的复杂属性语法）和`Foreground`属性，都是为`Button`控件设置的。
- en: 'Once defined, the style can be applied to elements using the usual `StaticResource`
    markup extension in XAML by setting the `FrameworkElement::Style` property, as
    in the following example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，样式可以通过在XAML中使用通常的`StaticResource`标记扩展来应用到元素，通过设置`FrameworkElement::Style`属性，如下例所示：
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Readers familiar with WPF may be wondering if the `TargetType` property can
    be omitted so that a greater control range can be covered. This is unsupported
    in the current version of WinRT.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉WPF的读者可能会想知道是否可以省略`TargetType`属性，以便覆盖更大的控件范围。在当前版本的WinRT中不支持这样做。
- en: Setting the style on an incompatible element type (such as a `CheckBox` control
    in this example) causes an exception to be thrown at page load time. If a `CheckBox`
    should also be able to use the same style, the `TargetType` can be changed to
    `ButtonBase` (which covers all button types).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在不兼容的元素类型上设置样式（例如在此示例中的`CheckBox`控件）会导致在页面加载时抛出异常。如果`CheckBox`也应该能够使用相同的样式，则可以将`TargetType`更改为`ButtonBase`（涵盖所有按钮类型）。
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use different styles for different elements, even if a base type seems to cover
    several controls. It's very likely that later some properties may need to be tweaked
    for a particular type, making it difficult to change the style. Build a different
    style for different concrete types. You can also use style inheritance (as described
    later) to shorten some of the markup.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为不同的元素使用不同的样式，即使基本类型似乎覆盖了几个控件。很可能以后某些属性可能需要针对特定类型进行微调，这样更改样式就会变得困难。为不同的具体类型构建不同的样式。您还可以使用样式继承（如后面所述）来缩短一些标记。
- en: 'What happens if an element with an applied style sets a property to a different
    value than the one from `Style`? The local value wins out. This means that the
    following button has a font size of `30` and not `40`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果具有应用样式的元素将属性设置为与`Style`中的属性不同的值会发生什么？本地值获胜。这意味着以下按钮的字体大小为`30`而不是`40`：
- en: '[PRE32]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Implicit (automatic) styles
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式（自动）样式
- en: The previous section showed how to create a style that has a name (`x:Key`)
    and how to apply it to elements. Sometimes, however, we would like a style to
    be applied automatically to all elements of a certain type, to give the application
    a consistent look. For example, we may want all buttons to have a certain font
    size or background, without the need for setting the `Style` property of each
    and every button. This makes creating new buttons easier, as the developer/designer
    doesn't have to know what style to apply (if any, the implicit style in scope
    will be used automatically).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节展示了如何创建具有名称（`x:Key`）的样式以及如何将其应用于元素。然而，有时我们希望样式自动应用于特定类型的所有元素，以使应用程序具有一致的外观。例如，我们可能希望所有按钮都具有特定的字体大小或背景，而无需为每个按钮设置`Style`属性。这样可以更轻松地创建新按钮，因为开发人员/设计人员不必知道应用哪种样式（如果有的话，将自动使用范围内的隐式样式）。
- en: 'To create a `Style` that is applied automatically, the `x:Key` attribute must
    be removed:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自动应用的`Style`，必须删除`x:Key`属性：
- en: '[PRE33]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The key still exists, as the `Style` property is still part of `ResourceDictionary`
    (which implements `IMap<Object, Object>`), but is automatically set to a `TypeName`
    object for the specified `TargetType`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 键仍然存在，因为`Style`属性仍然是`ResourceDictionary`的一部分（实现了`IMap<Object, Object>`），但会自动设置为指定`TargetType`的`TypeName`对象。
- en: Once the `Style` property is defined and any `Button` element (in this example)
    in scope for `ResourceDictionary` of the `Style` property is in, that style will
    be applied automatically. The element can still override any property it wishes
    by setting a local value.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Style`属性被定义，并且在`ResourceDictionary`的`Style`属性范围内有任何`Button`元素（在本例中），那么该样式将自动应用。元素仍然可以通过设置本地值来覆盖任何属性。
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Automatic styles are applied to the exact type only, not to derived types. This
    means that an automatic style for `ButtonBase` is useless, as it's an abstract
    class.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 自动样式仅应用于确切类型，而不适用于派生类型。这意味着`ButtonBase`的自动样式是无用的，因为它是一个抽象类。
- en: An element may wish to revert to its default style and not have an implicit
    style applied automatically. This can be achieved by setting `FrameworkElement::Style`
    to `nullptr` (`x:Null` in XAML).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 元素可能希望恢复其默认样式，并且不希望自动应用隐式样式。这可以通过将`FrameworkElement::Style`设置为`nullptr`（在XAML中为`x:Null`）来实现。
- en: Style inheritance
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样式继承
- en: Styles support the notion of inheritance, somewhat similar to the same concept
    in object orientation. This is done using the `BasedOn` property that must point
    to another style to inherit from. The `TargetType` of the derived style must be
    the same as in the base style.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 样式支持继承的概念，与面向对象中的相同概念有些类似。这是使用`BasedOn`属性完成的，该属性必须指向要继承的另一个样式。派生样式的`TargetType`必须与基本样式中的相同。
- en: 'An inherited style can add `Setter` objects for new properties to set, or it
    can provide a different value for a property that was set by the base style. Here''s
    an example for a base style of a button:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 继承样式可以为新属性添加`Setter`对象，或者可以为基本样式设置的属性提供不同的值。以下是按钮的基本样式示例：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following markup creates three inherited styles:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下标记创建了三种继承样式：
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'These styles are part of a simple integer calculator application. The calculator
    looks like this when running:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些样式是一个简单的整数计算器应用程序的一部分。运行时，计算器如下所示：
- en: '![Style inheritance](img/5022_03_09.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![Style inheritance](img/5022_03_09.jpg)'
- en: 'Most of the elements comprising the calculator are buttons. Here is the numeric
    button markup:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 计算器的大部分元素都是按钮。以下是数字按钮的标记：
- en: '[PRE36]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The operator buttons simply use a different style:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符按钮只是使用了不同的样式：
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `=` button uses the same style as operators, but changes its background
    by setting a local value:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`=`按钮使用与运算符相同的样式，但通过设置本地值来更改其背景：'
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The complete project is named `StyledCalculator` and can be found as part of
    the downloadable source for this chapter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 完整项目名为`StyledCalculator`，可以在本章可下载源代码的一部分中找到。
- en: Style inheritance may seem very useful, but should be used with caution. It
    suffers from the same issues as object oriented inheritance in a deep inheritance
    hierarchy—a change in a base style up in the hierarchy can affect a lot of styles,
    being somewhat unpredictable, leading to a maintenance nightmare. Thus, a good
    rule of thumb to use is to have no more than two inheritance levels. Any more
    than that may cause things to get out of hand.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 样式继承可能看起来非常有用，但应谨慎使用。它遭受与面向对象继承相同的问题，在深层继承层次结构中，上层样式的更改可能会影响很多样式，有点不可预测，导致维护噩梦。因此，一个好的经验法则是最多有两个继承级别。超过这个数量可能会导致事情失控。
- en: Store application styles
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储应用程序样式
- en: A Store app project created by Visual Studio has a default style file named
    `StandardStyles.xaml` in the `Common` folder. The file includes styles for all
    common elements and controls the set up for a common look and feel that is recommended
    as a starting point. It's certainly possible to change these styles or to inherit
    from them if needed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由Visual Studio创建的商店应用项目在“Common”文件夹中有一个名为“StandardStyles.xaml”的默认样式文件。该文件包括所有常见元素和控件的样式，设置了一个推荐的共同外观和感觉作为起点。当然，可以根据需要更改这些样式或从中继承。
- en: Note
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WinRT styles are similar in concept to CSS used in web development to provide
    styling to HTML pages. The cascading part hints to the multilevel nature of CSS,
    much like the multilevel nature of WinRT styles (application, page, panel, specific
    element, and so on).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: WinRT样式在概念上类似于Web开发中使用的CSS，用于为HTML页面提供样式。层叠部分暗示了CSS的多层性质，就像WinRT样式的多层性质一样（应用程序、页面、面板、特定元素等）。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was all about XAML, the declarative language used to build user
    interfaces for Windows Store apps. XAML takes some time getting used to it, but
    its declarative nature and markup extensions cannot easily be matched by procedural
    code in C++ (or other languages). Designer-oriented tools, such as Expression
    Blend and even the Visual Studio designer make it relatively easy to manipulate
    XAML without actually writing XAML, but as developers and designers working with
    other XAML-based technologies have already realized, it's sometimes necessary
    to write XAML by hand, making it an important skill to acquire.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讨论了XAML，这是用于构建Windows商店应用用户界面的声明性语言。XAML需要一些时间来适应，但它的声明性特性和标记扩展很难用C++（或其他语言）的过程性代码来匹配。面向设计师的工具，如Expression
    Blend甚至Visual Studio设计师，使得相对容易地操纵XAML而不实际编写XAML，但正如已经意识到的其他基于XAML的技术的开发人员和设计师所知，有时需要手动编写XAML，这使得它成为一项重要的技能。
- en: In the next chapter, we'll continue to use XAML heavily, while covering elements
    and controls, as well as layout, used in Windows 8 Store applications.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续大量使用XAML，同时涵盖在Windows 8商店应用中使用的元素、控件和布局。
