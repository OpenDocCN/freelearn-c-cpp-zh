["```cpp\nstd::vector<int> v{ 1, 2, 3, 4, 5, 6 };\nassert(contains_any(v, 0, 3, 30));\n\nstd::array<int, 6> a{ { 1, 2, 3, 4, 5, 6 } };\nassert(contains_all(a, 1, 3, 5, 6));\n\nstd::list<int> l{ 1, 2, 3, 4, 5, 6 };\nassert(!contains_none(l, 0, 6));\n```", "```cpp\nclass ipv4\n{\n   std::array<unsigned char, 4> data;\npublic:\n   constexpr ipv4() : data{ {0} } {}\n   constexpr ipv4(unsigned char const a, unsigned char const b, \n                  unsigned char const c, unsigned char const d):\n      data{{a,b,c,d}} {}\n   explicit constexpr ipv4(unsigned long a) :\n      data{ { static_cast<unsigned char>((a >> 24) & 0xFF), \n              static_cast<unsigned char>((a >> 16) & 0xFF),\n              static_cast<unsigned char>((a >> 8) & 0xFF),\n              static_cast<unsigned char>(a & 0xFF) } } {}\n   ipv4(ipv4 const & other) noexcept : data(other.data) {}\n   ipv4& operator=(ipv4 const & other) noexcept \n   {\n      data = other.data;\n      return *this;\n   }\n\n   std::string to_string() const\n   {\n      std::stringstream sstr;\n      sstr << *this;\n      return sstr.str();\n   }\n\n   constexpr unsigned long to_ulong() const noexcept\n   {\n      return (static_cast<unsigned long>(data[0]) << 24) |\n             (static_cast<unsigned long>(data[1]) << 16) |\n             (static_cast<unsigned long>(data[2]) << 8) |\n              static_cast<unsigned long>(data[3]);\n   }\n\n   friend std::ostream& operator<<(std::ostream& os, const ipv4& a)\n   {\n      os << static_cast<int>(a.data[0]) << '.' \n         << static_cast<int>(a.data[1]) << '.'\n         << static_cast<int>(a.data[2]) << '.'\n         << static_cast<int>(a.data[3]);\n      return os;\n   }\n\n   friend std::istream& operator>>(std::istream& is, ipv4& a)\n   {\n      char d1, d2, d3;\n      int b1, b2, b3, b4;\n      is >> b1 >> d1 >> b2 >> d2 >> b3 >> d3 >> b4;\n      if (d1 == '.' && d2 == '.' && d3 == '.')\n         a = ipv4(b1, b2, b3, b4);\n      else\n         is.setstate(std::ios_base::failbit);\n      return is;\n   }\n};\n```", "```cpp\nint main()\n{\n   ipv4 address(168, 192, 0, 1);\n   std::cout << address << std::endl;\n\n   ipv4 ip;\n   std::cout << ip << std::endl;\n   std::cin >> ip;\n   if(!std::cin.fail())\n      std::cout << ip << std::endl;\n}\n```", "```cpp\nipv4& operator++()\n{\n   *this = ipv4(1 + to_ulong());\n   return *this;\n}\n\nipv4& operator++(int)\n{\n   ipv4 result(*this);\n   ++(*this);\n   return *this;\n}\n\nfriend bool operator==(ipv4 const & a1, ipv4 const & a2) noexcept\n{\n   return a1.data == a2.data;\n}\n\nfriend bool operator!=(ipv4 const & a1, ipv4 const & a2) noexcept\n{\n   return !(a1 == a2);\n}\n\nfriend bool operator<(ipv4 const & a1, ipv4 const & a2) noexcept\n{\n   return a1.to_ulong() < a2.to_ulong();\n}\n\nfriend bool operator>(ipv4 const & a1, ipv4 const & a2) noexcept\n{\n   return a2 < a1;\n}\n\nfriend bool operator<=(ipv4 const & a1, ipv4 const & a2) noexcept\n{\n   return !(a1 > a2);\n}\n\nfriend bool operator>=(ipv4 const & a1, ipv4 const & a2) noexcept\n{\n   return !(a1 < a2);\n}\n```", "```cpp\nint main()\n{\n   std::cout << \"input range: \";\n   ipv4 a1, a2;\n   std::cin >> a1 >> a2;\n   if (a2 > a1)\n   {\n      for (ipv4 a = a1; a <= a2; a++)\n      {\n         std::cout << a << std::endl;\n      }\n   }\n   else \n   {\n      std::cerr << \"invalid range!\" << std::endl;\n   }\n}\n```", "```cpp\nint main()\n{\n   // element access\n   array2d<int, 2, 3> a {1, 2, 3, 4, 5, 6};\n   for (size_t i = 0; i < a.size(1); ++i)\n      for (size_t j = 0; j < a.size(2); ++j)\n      a(i, j) *= 2;\n\n   // iterating\n   std::copy(std::begin(a), std::end(a), \n      std::ostream_iterator<int>(std::cout, \" \"));\n\n   // filling \n   array2d<int, 2, 3> b;\n   b.fill(1);\n\n   // swapping\n   a.swap(b);\n\n   // moving\n   array2d<int, 2, 3> c(std::move(b));\n}\n```", "```cpp\ntemplate <class T, size_t R, size_t C>\nclass array2d\n{\n   typedef T                 value_type;\n   typedef value_type*       iterator;\n   typedef value_type const* const_iterator;\n   std::vector<T>            arr;\npublic:\n   array2d() : arr(R*C) {}\n   explicit array2d(std::initializer_list<T> l):arr(l) {}\n   constexpr T* data() noexcept { return arr.data(); }\n   constexpr T const * data() const noexcept { return arr.data(); }\n\n   constexpr T& at(size_t const r, size_t const c) \n   {\n      return arr.at(r*C + c);\n   }\n\n   constexpr T const & at(size_t const r, size_t const c) const\n   {\n      return arr.at(r*C + c);\n   }\n\n   constexpr T& operator() (size_t const r, size_t const c)\n   {\n      return arr[r*C + c];\n   }\n\n   constexpr T const & operator() (size_t const r, size_t const c) const\n   {\n      return arr[r*C + c];\n   }\n\n   constexpr bool empty() const noexcept { return R == 0 || C == 0; }\n\n   constexpr size_t size(int const rank) const\n   {\n      if (rank == 1) return R;\n      else if (rank == 2) return C;\n      throw std::out_of_range(\"Rank is out of range!\");\n   }\n\n   void fill(T const & value)\n   {\n      std::fill(std::begin(arr), std::end(arr), value);\n   }\n\n   void swap(array2d & other) noexcept { arr.swap(other.arr); }\n\n   const_iterator begin() const { return arr.data(); }\n   const_iterator end() const   { return arr.data() + arr.size(); }\n   iterator       begin()       { return arr.data(); }\n   iterator       end()         { return arr.data() + arr.size(); }\n};\n```", "```cpp\ntemplate <typename T>\nT minimum(T const a, T const b) { return a < b ? a : b; }\n\ntemplate <typename T1, typename... T>\nT1 minimum(T1 a, T... args)\n{\n   return minimum(a, minimum(args...));\n}\n\nint main()\n{\n   auto x = minimum(5, 4, 2, 3);\n}\n```", "```cpp\ntemplate <class Compare, typename T>\nT minimumc(Compare comp, T const a, T const b) \n{ return comp(a, b) ? a : b; }\n\ntemplate <class Compare, typename T1, typename... T>\nT1 minimumc(Compare comp, T1 a, T... args)\n{\n   return minimumc(comp, a, minimumc(comp, args...));\n}\n\nint main()\n{\n   auto y = minimumc(std::less<>(), 3, 2, 1, 0);\n}\n```", "```cpp\ntemplate<typename C, typename... Args>\nvoid push_back(C& c, Args&&... args)\n{\n   (c.push_back(args), ...);\n}\n```", "```cpp\nint main()\n{\n   std::vector<int> v;\n   push_back(v, 1, 2, 3, 4);\n   std::copy(std::begin(v), std::end(v), \n             std::ostream_iterator<int>(std::cout, \" \"));\n\n   std::list<int> l;\n   push_back(l, 1, 2, 3, 4);\n   std::copy(std::begin(l), std::end(l), \n             std::ostream_iterator<int>(std::cout, \" \"));\n}\n```", "```cpp\ntemplate<class C, class T>\nbool contains(C const & c, T const & value)\n{\n   return std::end(c) != std::find(std::begin(c), std::end(c), value);\n}\n\ntemplate<class C, class... T>\nbool contains_any(C const & c, T &&... value)\n{\n   return (... || contains(c, value));\n}\n\ntemplate<class C, class... T>\nbool contains_all(C const & c, T &&... value)\n{\n   return (... && contains(c, value));\n}\n\ntemplate<class C, class... T>\nbool contains_none(C const & c, T &&... value)\n{\n   return !contains_any(c, std::forward<T>(value)...);\n}\n```", "```cpp\nvoid bad_handle_example()\n{\n   bool condition1 = false;\n   bool condition2 = true;\n   HANDLE handle = CreateFile(L\"sample.txt\",\n                              GENERIC_READ,\n                              FILE_SHARE_READ,\n                              nullptr,\n                              OPEN_EXISTING,\n                              FILE_ATTRIBUTE_NORMAL,\n                              nullptr);\n\n   if (handle == INVALID_HANDLE_VALUE)\n      return;\n\n   if (condition1)\n   {\n      CloseHandle(handle);\n      return;\n   }\n\n   std::vector<char> buffer(1024);\n   unsigned long bytesRead = 0;\n   ReadFile(handle, \n            buffer.data(), \n            buffer.size(), \n            &bytesRead, \n            nullptr);\n\n   if (condition2)\n   {\n      // oops, forgot to close handle\n      return;\n   }\n\n   // throws exception; the next line will not execute\n   function_that_throws();\n\n   CloseHandle(handle);\n}\n```", "```cpp\ntemplate <typename Traits>\nclass unique_handle\n{\n   using pointer = typename Traits::pointer;\n   pointer m_value;\npublic:\n   unique_handle(unique_handle const &) = delete;\n   unique_handle& operator=(unique_handle const &) = delete;\n\n   explicit unique_handle(pointer value = Traits::invalid()) noexcept\n      :m_value{ value }\n   {}\n\n   unique_handle(unique_handle && other) noexcept\n      : m_value{ other.release() }\n   {}\n\n   unique_handle& operator=(unique_handle && other) noexcept\n   {\n      if (this != &other)\n         reset(other.release());\n      return *this;\n   }\n\n   ~unique_handle() noexcept\n   {\n      Traits::close(m_value);\n   }\n\n   explicit operator bool() const noexcept\n   {\n      return m_value != Traits::invalid();\n   }\n\n   pointer get() const noexcept { return m_value; }\n\n   pointer release() noexcept\n   {\n      auto value = m_value;\n      m_value = Traits::invalid();\n      return value;\n   }\n\n   bool reset(pointer value = Traits::invalid()) noexcept\n   {\n      if (m_value != value)\n      {\n         Traits::close(m_value);\n         m_value = value;\n      }\n      return static_cast<bool>(*this);\n   }\n\n   void swap(unique_handle<Traits> & other) noexcept\n   {\n      std::swap(m_value, other.m_value);\n   }\n};\n\ntemplate <typename Traits>\nvoid swap(unique_handle<Traits> & left, unique_handle<Traits> & right) noexcept\n{\n   left.swap(right);\n}\n\ntemplate <typename Traits>\nbool operator==(unique_handle<Traits> const & left,\n                unique_handle<Traits> const & right) noexcept\n{\n   return left.get() == right.get();\n}\n\ntemplate <typename Traits>\nbool operator!=(unique_handle<Traits> const & left,\n                unique_handle<Traits> const & right) noexcept\n{\n   return left.get() != right.get();\n}\n\nstruct null_handle_traits\n{\n   using pointer = HANDLE;\n   static pointer invalid() noexcept { return nullptr; }\n   static void close(pointer value) noexcept\n   {\n      CloseHandle(value);\n   }\n};\n\nstruct invalid_handle_traits\n{\n   using pointer = HANDLE;\n   static pointer invalid() noexcept { return INVALID_HANDLE_VALUE; }\n   static void close(pointer value) noexcept\n   {\n      CloseHandle(value);\n   }\n};\n\nusing null_handle = unique_handle<null_handle_traits>;\nusing invalid_handle = unique_handle<invalid_handle_traits>;\n```", "```cpp\nvoid good_handle_example()\n{\n   bool condition1 = false;\n   bool condition2 = true;\n\n   invalid_handle handle{\n      CreateFile(L\"sample.txt\",\n                 GENERIC_READ,\n                 FILE_SHARE_READ,\n                 nullptr,\n                 OPEN_EXISTING,\n                 FILE_ATTRIBUTE_NORMAL,\n                 nullptr) };\n\n   if (!handle) return;\n\n   if (condition1) return;\n\n   std::vector<char> buffer(1024);\n   unsigned long bytesRead = 0;\n   ReadFile(handle.get(),\n            buffer.data(),\n            buffer.size(),\n            &bytesRead,\n            nullptr);\n\n   if (condition2) return;\n\n   function_that_throws();\n}\n```", "```cpp\nbool are_equal(double const d1, double const d2, \n               double const epsilon = 0.001)\n{\n   return std::fabs(d1 - d2) < epsilon;\n}\n```", "```cpp\nnamespace temperature\n{\n   enum class scale { celsius, fahrenheit, kelvin };\n\n   template <scale S>\n   class quantity\n   {\n      const double amount;\n   public:\n      constexpr explicit quantity(double const a) : amount(a) {}\n      explicit operator double() const { return amount; }\n   };\n}\n```", "```cpp\nnamespace temperature \n{\n   template <scale S>\n   inline bool operator==(quantity<S> const & lhs, quantity<S> const & rhs)\n   {\n      return are_equal(static_cast<double>(lhs), static_cast<double>(rhs));\n   }\n\n   template <scale S>\n   inline bool operator!=(quantity<S> const & lhs, quantity<S> const & rhs)\n   {\n      return !(lhs == rhs);\n   }\n\n   template <scale S>\n   inline bool operator< (quantity<S> const & lhs, quantity<S> const & rhs)\n   {\n      return static_cast<double>(lhs) < static_cast<double>(rhs);\n   }\n\n   template <scale S>\n   inline bool operator> (quantity<S> const & lhs, quantity<S> const & rhs)\n   {\n      return rhs < lhs;\n   }\n\n   template <scale S>\n   inline bool operator<=(quantity<S> const & lhs, quantity<S> const & rhs)\n   {\n      return !(lhs > rhs);\n   }\n\n   template <scale S>\n   inline bool operator>=(quantity<S> const & lhs, quantity<S> const & rhs)\n   {\n      return !(lhs < rhs);\n   }\n\n   template <scale S>\n   constexpr quantity<S> operator+(quantity<S> const &q1, \n                                   quantity<S> const &q2)\n   {\n      return quantity<S>(static_cast<double>(q1) + \n                         static_cast<double>(q2));\n   }\n\n   template <scale S>\n   constexpr quantity<S> operator-(quantity<S> const &q1, \n                                   quantity<S> const &q2)\n   {\n      return quantity<S>(static_cast<double>(q1) - \n                         static_cast<double>(q2));\n   }\n}\n```", "```cpp\nnamespace temperature\n{\n   template <scale S, scale R>\n   struct conversion_traits\n   {\n      static double convert(double const value) = delete;\n   };\n\n   template <>\n   struct conversion_traits<scale::celsius, scale::fahrenheit>\n   {\n      static double convert(double const value)\n      {\n         return (value * 9) / 5 + 32;\n      }\n   };\n\n   template <>\n   struct conversion_traits<scale::fahrenheit, scale::celsius>\n   {\n      static double convert(double const value)\n      {\n         return (value - 32) * 5 / 9;\n      }\n   };\n\n   template <scale R, scale S>\n   constexpr quantity<R> temperature_cast(quantity<S> const q)\n   {\n      return quantity<R>(conversion_traits<S, R>::convert(\n         static_cast<double>(q)));\n   }\n}\n```", "```cpp\nnamespace temperature\n{\n   namespace temperature_scale_literals\n   {\n      constexpr quantity<scale::celsius> operator \"\" _deg(\n         long double const amount)\n      {\n         return quantity<scale::celsius> {static_cast<double>(amount)};\n      }\n\n      constexpr quantity<scale::fahrenheit> operator \"\" _f(\n         long double const amount)\n      {\n         return quantity<scale::fahrenheit> {static_cast<double>(amount)};\n      }\n   }\n}\n```", "```cpp\nint main()\n{\n   using namespace temperature;\n   using namespace temperature_scale_literals;\n\n   auto t1{ 36.5_deg };\n   auto t2{ 79.0_f };\n\n   auto tf = temperature_cast<scale::fahrenheit>(t1);\n   auto tc = temperature_cast<scale::celsius>(tf);\n   assert(t1 == tc);\n}\n```"]