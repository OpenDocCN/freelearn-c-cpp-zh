- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: STL with Ranges
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有范围的 STL
- en: This chapter discusses the transformative adoption of ranges in C++, marking
    a paradigm shift from traditional iterators. As an integral facet of modern C++,
    ranges champion expressive and ergonomic code. Through this chapter, you will
    grasp the mechanics of utilizing ranges with standard algorithms, achieving cleaner
    code that’s simultaneously intuitive and powerful. By mastering ranges, C++ developers
    can harness a more compositional and streamlined approach to algorithm application,
    setting the stage for more maintainable and efficient code bases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了 C++ 中范围应用的变革性采用，标志着从传统迭代器的范式转变。作为现代 C++ 的一个基本方面，范围推崇表达性和易用性的代码。通过本章，您将掌握使用标准算法利用范围的技术，实现既直观又强大的更简洁代码。通过掌握范围，C++
    开发者可以采用更模块化和高效的算法应用方法，为更可维护和高效的代码库奠定基础。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to ranges
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围简介
- en: Ranges for sorting algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序算法的范围
- en: Ranges for searching algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索算法的范围
- en: Best practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: Introduction to ranges
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围简介
- en: Programming paradigms evolve, and C++ is no exception. As the journey through
    the vast landscape of the C++ **Standard Template Library** (**STL**) unfolds,
    it is evident that adaptability and growth have been at their core. One such evolutionary
    step, which stands out for its expressiveness and efficiency, is the advent of
    ranges in modern C++. But what exactly are ranges?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编程范式不断发展，C++ 也不例外。随着穿越 C++ **标准模板库**（**STL**）广阔领域的旅程展开，其适应性和增长显然是其核心。这一进化步骤，以其表达性和效率而突出，是现代
    C++ 中范围的出现。但范围究竟是什么？
- en: Understanding the essence of ranges
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解范围的本质
- en: '`begin` and `end` to define a sequence, ranges encapsulate this information
    within a unified entity. This seemingly subtle shift has profound implications,
    reshaping how we approach algorithms and data manipulations.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `begin` 和 `end` 定义一个序列，范围将此信息封装在统一的实体中。这种看似微妙的转变具有深远的影响，重塑了我们处理算法和数据操作的方法。
- en: 'At a glance, the following shows the verbose legacy way to sort a vector:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一目了然，以下展示了排序向量的冗长传统方式：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, with ranges, we could express it as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用范围，我们可以这样表达：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The beauty lies in the clarity and conciseness. No longer must we juggle multiple
    iterators; the range elegantly conveys the intent.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 美在于其清晰和简洁。我们不再需要同时处理多个迭代器；范围优雅地传达了意图。
- en: Why the shift to ranges?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么转向范围？
- en: 'The evolution from iterators to ranges wasn’t just a whimsical design choice;
    it addressed pressing needs in the C++ community, such as the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从迭代器到范围的演变不仅仅是一个随意的设计选择；它解决了 C++ 社区迫切需要解决的问题，例如以下内容：
- en: '**Expressiveness**: The preceding example shows that the code becomes more
    readable. Expressing algorithms over entire sequences without explicitly mentioning
    boundary iterators facilitates a more natural, declarative style of coding.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表达性**：前面的示例表明，代码的可读性提高了。在不需要明确提及边界迭代器的情况下，在整个序列上表达算法可以促进更自然、声明式的编码风格。'
- en: '**Composability**: Ranges enable a more functional approach to programming
    in C++. This means algorithms can be seamlessly composed, leading to modular and
    easily understandable code.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可组合性**：范围使 C++ 的编程方法更加函数化。这意味着算法可以无缝组合，从而产生模块化和易于理解的代码。'
- en: '**Error minimization**: By reducing the need to manage individual iterators,
    there’s a lower chance of errors related to mismatched or incorrectly used iterators.
    This leads to safer and more maintainable code.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误最小化**：通过减少管理单个迭代器的需求，降低了与不匹配或错误使用迭代器相关的错误概率。这导致代码更安全、更易于维护。'
- en: A glimpse into range operations
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看范围操作的一瞥
- en: 'Ranges aren’t just about cleaner syntax; they offer a plethora of operations
    that can transform sequences in expressive ways. Some operations include the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 范围不仅仅是关于更简洁的语法；它们提供了一系列可以以表达方式转换序列的操作。以下是一些操作：
- en: '**Filtering**: Easily refine sequences based on certain conditions'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤**：根据特定条件轻松细化序列'
- en: '**Transformations**: Modify sequences by applying functions to their elements'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转换**：通过对其元素应用函数来修改序列'
- en: '**Concatenation**: Seamlessly join multiple sequences'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接**：无缝连接多个序列'
- en: With ranges, these operations can be chained, leading to code that’s both intuitive
    and powerful. For instance, transforming and filtering a sequence becomes a straightforward
    task with ranges.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用范围，这些操作可以串联起来，从而产生既直观又强大的代码。例如，使用范围对序列进行转换和过滤变成了一项简单直接的任务。
- en: Looking ahead – the power of modern STL
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展望未来——现代 STL 的力量
- en: The introduction of ranges in the STL represents a significant stride toward
    a more expressive and ergonomic C++. As developers embark on this new chapter,
    they’ll find that the familiar operations they have come to rely on have been
    enhanced and primed for the modern challenges of the software industry.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 STL 中引入范围表示了向更表达性和更人性化的 C++ 的一大步。随着开发者踏上这一新篇章，他们会发现他们已经依赖的熟悉操作已经得到了增强，并准备好应对软件行业的现代挑战。
- en: Ranges in C++ significantly enhance code quality and developer productivity.
    Ranges offer a more declarative approach to data manipulation, promoting cleaner
    and more readable code. They enable operations on collections of data without
    the explicit need to handle iterators or create temporary containers. This abstraction
    not only reduces boilerplate but also minimizes the likelihood of errors associated
    with manual iterator management. Furthermore, ranges facilitate lazy evaluation,
    where computations are deferred until values are actually needed. This can lead
    to performance improvements, especially in scenarios involving large datasets
    or complex filtering criteria. Looking ahead, ranges have the potential to revolutionize
    C++ coding practices by simplifying algorithm applications, enhancing composability,
    and potentially introducing more opportunities for compiler optimizations. As
    the C++ language evolves, ranges will likely become integral in writing more efficient,
    maintainable, and intuitive code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的范围显著提高了代码质量和开发者生产力。范围提供了一种更声明性的数据操作方法，促进了更干净、更易读的代码。它们允许对数据集合进行操作，而无需显式处理迭代器或创建临时容器。这种抽象不仅减少了样板代码，还最小化了与手动迭代器管理相关的错误可能性。此外，范围还促进了延迟评估，其中计算被推迟到实际需要值时。这可能导致性能改进，尤其是在涉及大数据集或复杂过滤标准的情况下。展望未来，范围有可能通过简化算法应用、增强可组合性和可能引入更多编译器优化机会来彻底改变
    C++ 编码实践。随着 C++ 语言的不断发展，范围很可能会成为编写更高效、可维护和直观代码的必要组成部分。
- en: In this section, we explored the concept of ranges in modern C++, a significant
    advancement in the C++ STL. Ranges represent an abstraction over sequences, offering
    a unified way to handle data sequences as opposed to the traditional pair of iterators.
    This shift to ranges improves code expressiveness, readability, and maintainability.
    Ranges reduce the need for verbose iterator management, minimizing errors and
    enhancing code clarity. They support a variety of operations such as filtering,
    transformations, and concatenation, which can be seamlessly chained for more intuitive
    and powerful coding. The advent of ranges in C++ marks a step toward more declarative
    data manipulation, promising improvements in developer productivity and code quality.
    As C++ continues to evolve, ranges are poised to play a crucial role in shaping
    more efficient and ergonomic coding practices.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了现代 C++ 中范围的概念，这是 C++ STL 的一项重大进步。范围代表了序列的一种抽象，提供了一种统一的方式来处理数据序列，而不是传统的迭代器对。这种向范围的转变提高了代码的表达性、可读性和可维护性。范围减少了冗长迭代器管理的需求，最小化了错误并增强了代码的清晰度。它们支持各种操作，如过滤、转换和连接，这些操作可以无缝连接，以实现更直观和强大的编码。C++
    中范围的引入标志着向更声明性数据操作迈出的一步，承诺提高开发者的生产力和代码质量。随着 C++ 的不断发展，范围有望在塑造更高效、更人性化的编码实践中发挥关键作用。
- en: In the following sections, we’ll delve deeper into the nuances of ranges, exploring
    their applications with classic STL algorithms, and uncovering best practices
    to ensure that they’re leveraged to their utmost potential.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更深入地探讨范围的细微差别，探索它们与经典 STL 算法的应用，并揭示最佳实践以确保它们得到最大限度的利用。
- en: Ranges for sorting algorithms
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序算法的范围
- en: '**Sorting** is a fundamental operation, a bedrock in the vast universe of algorithms.
    Over the years, the STL has empowered us with robust sorting capabilities. With
    the introduction of ranges, this power has been augmented by simplifying the syntax
    and infusing a heightened sense of expressiveness into the mix.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**排序**是一个基本操作，是算法广阔宇宙中的基石。多年来，STL赋予我们强大的排序能力。随着范围的引入，这种能力通过简化语法并注入更强的表现力而得到增强。'
- en: In this section, we will explore how ranges simplify the implementation of sorting
    algorithms in C++. We will examine how range-based sorting reduces the syntactical
    overhead and potential errors associated with traditional iterator-based methods.
    Furthermore, we will discuss how ranges enhance the readability and maintainability
    of sorting code, making it easier to understand and modify.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨范围如何简化C++中排序算法的实现。我们将检查基于范围的排序如何减少与传统的基于迭代器的方法相关的语法开销和潜在错误。此外，我们还将讨论范围如何提高排序代码的可读性和可维护性，使其更容易理解和修改。
- en: Traditional STL sorting – a recap
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统STL排序——回顾
- en: 'Before diving into the enhancements brought by ranges, let’s quickly recall
    the conventional STL sorting approach. Traditionally, the `std::sort` function
    is employed, requiring two iterators marking the beginning and the end of the
    sequence:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨范围带来的增强功能之前，让我们快速回顾一下传统的STL排序方法。传统上，使用`std::sort`函数，需要两个迭代器标记序列的开始和结束：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While effective, this approach leaves room for enhancement in readability and
    user-friendliness. To address this, enter the STL’s range-based sorting.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法有效，但在可读性和用户友好性方面仍有提升空间。为了解决这个问题，引入了STL的基于范围的排序。
- en: Range-based sorting – the basics
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于范围的排序——基础
- en: 'Redefining elegance, the range-based `std::ranges::sort` function allows us
    to pass the sequence to be sorted directly. No fussing with iterators. Given our
    earlier example, with ranges, the sorting becomes the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重新定义优雅，基于范围的`std::ranges::sort`函数允许我们直接传递要排序的序列。无需与迭代器纠缠。根据我们之前的例子，使用范围，排序过程变为以下：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The concise nature of range-based sorting makes it a joy to use, reducing potential
    error avenues and enhancing readability.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 基于范围的排序的简洁性使其使用起来非常愉快，减少了潜在的错误途径，并提高了可读性。
- en: Embracing composability in sorting
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在排序中拥抱组合性
- en: One of the crown jewels of ranges is their ability to facilitate composability,
    which shines exceptionally bright in sorting scenarios. Consider the need to sort
    only a subset of a sequence or the necessity to chain multiple operations before
    sorting. Ranges cater to such needs seamlessly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 范围的皇冠上的宝石之一是它们促进组合的能力，这在排序场景中特别明亮。考虑只需要对序列的子集进行排序的需求，或者在进行排序之前链式连接多个操作的需要。范围无缝地满足这些需求。
- en: 'For example, imagine the requirement to sort only the even numbers from a sequence
    in reverse order. With ranges, this can be expressed in a few lines, harnessing
    the power of filtering combined with sorting:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下需要按逆序对序列中的偶数进行排序的要求。使用范围，这可以在几行代码中表达，利用过滤和排序的结合力量：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the example output[1](B21945_15.xhtml#footnote-000):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出[1](B21945_15.xhtml#footnote-000)：
- en: '[1](B21945_15.xhtml#footnote-000-backlink) This example has been tested to
    work with Visual Studio v17.8.6 but does not yet compile with GCC v13.2 or Clang
    v17.0.1.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](B21945_15.xhtml#footnote-000-backlink) 此示例已测试与Visual Studio v17.8.6兼容，但尚未与GCC
    v13.2或Clang v17.0.1编译。'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, vector data contains a sequence of integers. We use a range
    pipeline to create a view that first filters out the even numbers using `std::views::filter`.
    Then, we use `std::views::transform` to negate the numbers, allowing them to be
    sorted in reverse order. Finally, `std::ranges::to` is used to convert the view
    into a vector. The sorted even numbers are then displayed. This showcases the
    composability of ranges, allowing for concise and expressive manipulation of data
    sequences.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，向量数据包含一系列整数。我们使用范围管道创建一个视图，首先使用`std::views::filter`过滤出偶数。然后，我们使用`std::views::transform`对数字取反，使它们可以按逆序排序。最后，使用`std::ranges::to`将视图转换为向量。然后显示排序后的偶数。这展示了范围的组合能力，允许对数据序列进行简洁且富有表现力的操作。
- en: The ability to chain operations, leading from filtering to sorting fluidly,
    exemplifies the compositional strength of ranges.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 能够链式执行操作，从过滤到排序流畅过渡，展示了范围的组合能力。
- en: Advantages beyond syntax – why ranges shine in sorting
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法之外的优点——为什么范围在排序中闪耀
- en: 'Beyond the evident syntactical elegance, using ranges with STL sorting algorithms
    offers a buffet of benefits, such as the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了明显的语法优雅之外，使用范围与 STL 排序算法结合提供了以下好处：
- en: '`begin` and `end` in a single entity diminishes the risk of mismatched iterators,
    elevating code safety.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `begin` 和 `end` 合并为一个单一实体，降低了不匹配迭代器的风险，提高了代码的安全性。
- en: '**Flexibility**: Ranges, coupled with views, provide a dynamic toolkit. Whether
    sorting with custom comparators or adapting to different data structures, the
    range-based approach remains consistent and straightforward.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：范围与视图相结合，提供了一套动态的工具集。无论是使用自定义比较器进行排序，还是适应不同的数据结构，基于范围的途径都保持一致且简单明了。'
- en: '**Expressive power**: Ranges foster a declarative coding style, wherein the
    intent of the code stands out. This expressiveness proves invaluable when sorting
    complex data types or applying multifaceted logic.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表达力**：范围促进了声明性代码风格，其中代码的意图突出。这种表达力在排序复杂数据类型或应用多方面逻辑时非常有价值。'
- en: The revolution of ranges in sorting
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序中范围的革命
- en: Sorting, an operation as old as programming itself, witnesses a rejuvenation
    with the introduction of ranges. Combining traditional STL sorting prowess with
    the modern elegance of ranges can revolutionize our implementations with more
    intuitive, maintainable, and efficient code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 排序，一种与编程一样古老的操作，随着范围的引入而焕发新生。将传统的 STL 排序能力与现代范围的优雅性相结合，可以革命性地改变我们的实现，使代码更直观、可维护和高效。
- en: Ranges have transformed sorting algorithms in modern C++. We have seen the traditional
    iterator-based approach of STL sorting with the more streamlined and readable
    range-based approach. The traditional method, using `std::sort` with iterators,
    is effective but can be improved in terms of readability and user-friendliness.
    Range-based sorting, using `std::ranges::sort`, simplifies this by allowing direct
    passing of the sequence, reducing syntactical complexity and potential errors.
    A key highlight is the composability of ranges, particularly beneficial in sorting
    scenarios.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 范围已经改变了现代 C++ 中的排序算法。我们已经看到了 STL 排序的传统基于迭代器的方法，以及更简洁、更易读的基于范围的方法。传统方法，即使用 `std::sort`
    和迭代器，是有效的，但在可读性和用户友好性方面可以改进。基于范围的排序，使用 `std::ranges::sort`，通过允许直接传递序列来简化这一点，减少了语法复杂性并降低了潜在错误。一个关键亮点是范围的组合性，这在排序场景中特别有益。
- en: The advantages of using ranges in sorting extend beyond syntax. They provide
    safety by encapsulating the beginning and end of sequences into a single entity,
    reducing the risk of mismatched iterators. They offer flexibility with dynamic
    tools for sorting using custom comparators or different data structures. Moreover,
    ranges enable a declarative coding style, making the code’s intent more apparent,
    especially beneficial for sorting complex data types or applying intricate logic.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用范围进行排序的优势不仅限于语法。它们通过将序列的开始和结束封装为单一实体来提供安全性，减少了不匹配迭代器的风险。它们提供了灵活性，通过动态工具使用自定义比较器或不同的数据结构进行排序。此外，范围使代码风格更具声明性，使代码的意图更加明显，特别是对于排序复杂数据类型或应用复杂逻辑非常有用。
- en: The introduction of ranges in C++ has married the traditional strength of STL
    sorting algorithms with the modern finesse of ranges. This revolution leads to
    more intuitive, maintainable, and efficient code implementations. The exploration
    continues in subsequent sections, delving deeper into the interaction of ranges
    with other STL algorithms for searching and uncovering best practices for their
    effective utilization.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中范围（ranges）的引入将 STL 排序算法的传统优势与现代范围的精致性相结合。这一革命导致了更直观、可维护和高效的代码实现。后续章节将继续探索，深入挖掘范围与其他
    STL 排序算法的交互，并揭示其有效利用的最佳实践。
- en: Ranges for searching algorithms
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索算法的范围
- en: When delving into the domain of algorithmic searching within the STL, it’s evident
    that the advent of ranges heralds an era of simplified and expressive code. To
    appreciate this evolution, looking back at the traditional search methods in the
    STL is essential.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当深入研究 STL 中算法搜索的领域时，很明显，范围的引入预示着一个简化且表达性强的代码时代的到来。为了欣赏这一演变，回顾 STL 中的传统搜索方法是必要的。
- en: 'The classic way of searching within a container involved using functions such
    as `std::find` or `std::find_if`, wherein you’d provide iterators marking the
    search range:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内搜索的经典方式涉及使用诸如 `std::find` 或 `std::find_if` 的函数，其中你需要提供标记搜索范围的迭代器：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Effective? Yes. Optimal in terms of expressiveness and adaptability? Perhaps
    not.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有效？是的。在表达性和适应性方面最优？或许不是。
- en: Finding elegance – range-based searching
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找优雅——基于范围的搜索
- en: 'The transition to more readable and concise code is evident using the range-based
    approach. With ranges, searching operations become inherently more declarative,
    as shown in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于范围的代码，过渡到更易读和简洁的代码是显而易见的。使用范围，搜索操作变得固有的声明性更强，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Beyond mere simplicity, the real power of range-based searching emerges when
    combined with other range adaptors, opening a gateway to more adaptive and modular
    code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的简洁性之外，基于范围的搜索的真正力量在于与其他范围适配器的结合，打开了一条通往更适应性和模块化代码的大门。
- en: Chaining and filtering – the beauty of composability
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接和过滤——可组合性的美丽
- en: 'The elegance of code often lies in its ability to express complex operations
    in a simple, readable manner. Ranges, with their composability, play a pivotal
    role in achieving such elegance. Let’s consider a nuanced example to understand
    this better: finding the first three numbers in a sequence that are both prime
    and greater than a specified value. This task, when approached with traditional
    STL methods, might involve cumbersome loops and condition checks. However, ranges
    transform it into an efficient and easily understandable series of operations.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的优雅之处往往在于其能够以简单、易读的方式表达复杂操作。范围，凭借其可组合性，在实现这种优雅方面发挥着关键作用。让我们考虑一个细微的例子来更好地理解这一点：找到序列中既是素数又大于指定值的第一个三个数。当使用传统的STL方法处理这个任务时，可能需要繁琐的循环和条件检查。然而，范围将其转化为高效且易于理解的操作序列。
- en: 'Let’s look at an interesting example to illustrate this concept:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个有趣的例子来说明这个概念：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is the example output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, we start with a `nums` vector containing a sequence of integers.
    Using ranges, we chain together three operations:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从一个包含一系列整数的`nums`向量开始。使用范围，我们将三个操作串联起来：
- en: 'Filtering for numbers greater than 10: `std::views::filter([](int n) { return
    n > 10; })` selects numbers greater than.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对大于10的数字进行过滤：`std::views::filter([](int n) { return n > 10; })`选择大于的数字。
- en: 'Filtering for prime numbers: `std::views::filter(is_prime)` uses the `is_prime`
    function to keep only prime numbers'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对素数进行过滤：`std::views::filter(is_prime)`使用`is_prime`函数仅保留素数
- en: 'Taking the first three elements: `std::views::take(3)` limits the results to
    the first three elements that meet the previous criteria.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 取前三个元素：`std::views::take(3)`将结果限制为满足先前标准的第一个三个元素。
- en: The result is a seamless integration of conditions in a single, readable line
    of code. This example not only demonstrates the power of chaining and filtering
    but also highlights how ranges can significantly enhance the expressiveness and
    adaptability of C++ code. The combination of simplicity and expressiveness is
    what makes ranges an invaluable feature in modern C++ development.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是在单行可读代码中无缝集成条件。这个例子不仅展示了连接和过滤的力量，还突出了范围如何显著增强C++代码的表达性和适应性。简洁性和表达性的结合使得范围成为现代C++开发中不可或缺的特性。
- en: Understanding views in searches
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解搜索中的视图
- en: '**Views** are pivotal in the range-based landscape, especially in searching
    scenarios. Unlike containers, views don’t own their elements. They present a transformed
    *view* of their source data, which can be another range (such as a container).
    When incorporated into searches, views don’t modify the original data but provide
    a new perspective, which can be particularly useful in modular and reusable code.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**在基于范围的景观中至关重要，尤其是在搜索场景中。与容器不同，视图不拥有自己的元素。它们呈现其源数据的转换视图，这可以是一个范围（例如容器）。当纳入搜索时，视图不会修改原始数据，但提供一个新的视角，这在模块化和可重用代码中特别有用。'
- en: The extended toolkit – more than just find
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展工具包——不仅仅是查找
- en: While `std::ranges::find` is a cornerstone, the modern range-based approach
    offers a broad spectrum of searching algorithms. Functions such as `std::ranges::search`,
    which locates a subsequence, or `std::ranges::find_end`, which finds the last
    occurrence of a sequence, encapsulate the richness of range-based searching. Their
    true power is unlocked with other range adaptors, offering a palette of possibilities
    for efficient and expressive searching tasks.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`std::ranges::find`是基石，但现代基于范围的途径提供了广泛的搜索算法。例如，`std::ranges::search`函数可以定位子序列，或`std::ranges::find_end`函数可以找到序列的最后一个出现，这些函数封装了基于范围的搜索的丰富性。它们的真正力量是通过其他范围适配器解锁的，为高效和表达性搜索任务提供了一系列可能性。
- en: Transitioning from traditional methods, range-based searching in the STL stands
    as a testament to the evolution of C++ toward more readable, modular, and expressive
    code. As we advance further into the world of ranges, harnessing these tools and
    techniques will be paramount for those eager to craft efficient and maintainable
    code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从传统方法过渡到STL中的基于范围的搜索，是C++向更易读、模块化和表达性代码发展的证明。随着我们进一步深入到范围的世界，掌握这些工具和技术对于渴望编写高效且可维护代码的人来说至关重要。
- en: Best practices
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: The transition to range-based STL is undoubtedly exhilarating. With this newfound
    expressiveness and clarity, we have powerful tools at our fingertips. However,
    understanding a set of best practices is essential to maximize the potential of
    ranges and ensure the maintainability of your code base. Let us look at some of
    the best practices that we can implement.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 向基于范围的STL过渡无疑是令人兴奋的。有了这种新的表达性和清晰度，我们手头有了强大的工具。然而，理解一系列最佳实践对于最大限度地发挥范围的作用并确保代码库的可维护性至关重要。让我们看看我们可以实施的一些最佳实践。
- en: Embracing the power of chaining
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受链式操作的力量
- en: 'One of the standout features of ranges is their natural ability to chain operations.
    Chaining not only enhances readability but also improves efficiency by avoiding
    intermediary storage:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 范围的一个显著特点是它们自然地能够链式操作。链式操作不仅增强了可读性，而且通过避免中间存储提高了效率：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This elegant one-liner filters out odd numbers and then doubles the even ones.
    By promoting such chaining, you can foster cleaner, more concise code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这优雅的一行代码过滤掉了奇数，然后加倍了偶数。通过促进这种链式操作，你可以培养出更干净、更简洁的代码。
- en: Guarding against range pitfalls – lifetime awareness
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防范范围陷阱 - 生命周期意识
- en: 'Going all out with ranges is tempting, especially with their composability.
    Yet, caution is advised. One of the most common pitfalls is the unintentional
    dangling of views, as shown in the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 全力以赴使用范围是诱人的，尤其是考虑到它们的可组合性。然而，需要谨慎行事。最常见的陷阱之一是无意中悬垂视图，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code returns a view on a local variable. As this function exits,
    the local variable will be destroyed. Since a view of this destroyed variable
    is being returned, it will lead to undefined behavior. Always be aware of the
    lifetime of the underlying data when working with views.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码返回一个局部变量的视图。当此函数退出时，局部变量将被销毁。由于返回的是已销毁变量的视图，这将导致未定义的行为。在处理视图时，始终要意识到底层数据的生命周期。
- en: Performance considerations – laziness and evaluation
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能考虑 - 懒惰性和评估
- en: 'Ranges, especially views, operate lazily. This means that they evaluate their
    elements only when accessed. While this can be a boon for efficiency, it might
    also lead to pitfalls, especially when combined with stateful operations or side
    effects, as illustrated in the following example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 范围，尤其是视图，是惰性操作的。这意味着它们仅在访问时才评估它们的元素。虽然这可以提高效率，但这也可能导致陷阱，尤其是在与有状态的运算或副作用结合使用时，如下面的示例所示：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If `range` is evaluated multiple times, the side effect in the lambda accumulates,
    leading to unexpected results. It is advisable to force an eager evaluation for
    such scenarios, perhaps by converting the range to a container.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`range`被多次评估，lambda中的副作用会累积，导致意外结果。在这种情况下，建议强制进行急切评估，可能通过将范围转换为容器来实现。
- en: Readability over brevity – striking the balance
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可读性胜于简洁性 - 寻找平衡
- en: 'While ranges enable concise code, remember the cardinal rule: code is read
    more often than written. Overly compacted chains of range operations can be challenging
    to understand, especially for those new to the code base. Strike a balance between
    brevity and clarity.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然范围允许编写简洁的代码，但请记住一个基本原则：代码被阅读的次数比被编写的次数多。过度紧凑的范围操作链可能难以理解，尤其是对于新加入代码库的人来说。在简洁性和清晰性之间找到平衡。
- en: Adhering to range idioms – keep it standard
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循范围习惯用法——保持标准化
- en: As with other parts of the C++ language, certain idioms and patterns have emerged
    for using ranges. When possible, prefer the standard idioms. (For example, use
    `std::ranges::sort` for sorting and `std::ranges::find` for finding. Both of these
    are better than writing your own loops to do essentially the same thing.) This
    makes your code more understandable to other C++ developers and ensures that you
    benefit from community-tested patterns.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++语言的其它部分一样，已经出现了一些用于使用范围的惯用用法和模式。在可能的情况下，优先选择标准惯用用法。（例如，使用`std::ranges::sort`进行排序，使用`std::ranges::find`进行查找。这两者都比编写自己的循环来完成本质上相同的事情要好。）这使得你的代码对其他C++开发者来说更容易理解，并确保你从社区测试过的模式中受益。
- en: This section highlights key best practices for effectively using range-based
    STL in C++. It emphasizes the importance of embracing the power of chaining, which
    enhances code readability and efficiency by avoiding intermediary storage. However,
    it also cautions against common pitfalls, such as dangling views, and advises
    awareness of the lifetime of underlying data. The section notes the lazy evaluation
    nature of ranges, recommending eager evaluation in scenarios involving stateful
    operations or side effects to avoid unexpected results. Additionally, it advises
    maintaining a balance between code conciseness and readability, ensuring that
    code remains accessible and understandable. Finally, it suggests adhering to established
    range idioms, leveraging standard patterns for better clarity and community alignment.
    These practices aim to maximize the potential of ranges while ensuring maintainable
    and robust code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本节强调了在C++中使用基于范围的STL时的关键最佳实践。它强调了拥抱链式操作的力量的重要性，通过避免中间存储来提高代码的可读性和效率。然而，它也警告了常见的陷阱，如悬空视图，并建议关注底层数据的生命周期。本节指出范围的惰性求值特性，建议在涉及有状态操作或副作用的情况下进行急切求值以避免意外结果。此外，它建议在代码简洁性和可读性之间保持平衡，确保代码易于访问和理解。最后，它建议遵循既定的范围习惯用法，利用标准模式以获得更好的清晰度和社区一致性。这些实践旨在最大限度地发挥范围的作用，同时确保代码的可维护性和健壮性。
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the concept of ranges in the C++ STL and how they
    enhance how we work with sequences of elements. We began with an introduction
    to ranges, understanding their essence and the motivations behind the shift to
    this new paradigm. We saw how range operations facilitate more expressive and
    readable code, and we delved into the composability that ranges introduce to sorting
    algorithms.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了C++ STL中的范围概念以及它们如何增强我们处理元素序列的方式。我们从范围的介绍开始，理解其本质以及转向这一新范式背后的动机。我们看到范围操作如何促进更具有表达性和可读性的代码，并深入探讨了范围为排序算法引入的可组合性。
- en: The chapter then focused on range-based sorting, discussing the basic concepts
    and the advantages ranges bring to the table, such as cleaner syntax and improved
    composability. We also examined the application of ranges in searching algorithms,
    appreciating the elegant and powerful ways ranges enable us to chain operations
    and apply filters.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本章接着聚焦于基于范围的排序，讨论了基本概念以及范围带来的优势，例如更简洁的语法和改进的可组合性。我们还考察了范围在搜索算法中的应用，赞赏了范围如何以优雅而强大的方式使我们能够链式操作并应用过滤器。
- en: Ranges help us write cleaner code in a way that better expresses our intent.
    The shift to ranges represents a significant evolution in the STL, offering enhanced
    clarity and efficiency in code. It allows us to compose complex operations in
    a more readable and maintainable way, which is beneficial for both the development
    process and the longevity of the code base.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 范围帮助我们以更好地表达我们意图的方式编写更干净的代码。转向范围代表了STL中的一个重大进化，提供了代码的增强清晰度和效率。它允许我们以更可读和可维护的方式组合复杂操作，这对开发过程和代码库的长期性都有益。
- en: Now that we have a strong understanding of STL data types, algorithms, and other
    core concepts, we will use this knowledge in the next chapter to create our own
    container types that integrate seamlessly with the existing STL algorithms and
    iterators. We will cover the essential requirements for STL compatibility, such
    as iterator implementation and value semantics. We will guide you through the
    effective use of operator overloading and the creation of custom hash functions.
    By learning to create STL-compatible containers, we can extend the STL to suit
    their specific needs, ensuring that their custom types can benefit from the power
    and flexibility of the STL algorithms and practices.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对STL数据类型、算法和其他核心概念有了深入的理解，我们将在下一章中使用这些知识来创建我们自己的容器类型，这些类型可以与现有的STL算法和迭代器无缝集成。我们将涵盖STL兼容性的基本要求，如迭代器实现和值语义。我们将指导您有效地使用操作符重载和创建自定义哈希函数。通过学习创建与STL兼容的容器，我们可以扩展STL以满足其特定需求，确保其自定义类型能够从STL算法和实践的强大功能和灵活性中受益。
- en: 'Part 4: Creating STL-Compatible Types and Algorithms'
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：创建与STL兼容的类型和算法
- en: This part of our book is dedicated to the creation and integration of custom
    types and algorithms within the C++ Standard Template Library ecosystem. We start
    by exploring the construction of STL-compatible containers, detailing the essential
    requirements for seamless interoperability with STL algorithms. We discuss the
    importance of crafting robust iterators and the nuances of operator overloading
    to provide intuitive and consistent behavior for custom types. Special attention
    is given to creating custom hash functions to facilitate the use of user-defined
    types with unordered associative containers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这本书的这一部分致力于在C++标准模板库（STL）生态系统中创建和集成自定义类型和算法。我们首先探讨构建与STL兼容的容器，详细说明与STL算法无缝互操作的基本要求。我们讨论了构建健壮迭代器和操作符重载的细微差别，以提供对自定义类型直观和一致的行为。特别关注创建自定义哈希函数，以促进用户定义类型在无序关联容器中的使用。
- en: Next, we get into the intricacies of developing STL-compatible algorithms. This
    includes mastering template functions, understanding the subtleties of overloading,
    and leveraging inline functions for performance. We will emphasize the use of
    predicates and functors for enhanced flexibility.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解开发与STL兼容算法的复杂性。这包括掌握模板函数，理解重载的微妙之处，并利用内联函数来提高性能。我们将强调使用谓词和函数对象来增强灵活性。
- en: Finally, we are introduced to type traits and policies, powerful tools that
    allow developers to craft more adaptable and modular code. We gain insights into
    implementing these concepts effectively, ensuring that your custom types and algorithms
    not only integrate well with the STL but also adhere to best practices in modern
    C++ programming.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们被介绍到类型特性和策略，这些是强大的工具，允许开发者编写更适应性和模块化的代码。我们获得了有效实施这些概念的知识，确保您的自定义类型和算法不仅与标准模板库（STL）很好地集成，而且遵循现代C++编程的最佳实践。
- en: By the end of this part, you will have gained the knowledge to extend the STL
    to fit your unique requirements, fostering a deeper understanding of template
    metaprogramming and the powerful abstractions provided by C++.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到本部分结束时，您将获得扩展STL以满足您独特需求的知识，这将加深对模板元编程和C++提供的强大抽象的理解。
- en: 'This part has the following chapters:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 16*](B21945_16.xhtml#_idTextAnchor590)*: Creating STL-Types Containers*'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B21945_16.xhtml#_idTextAnchor590)*：创建STL-类型容器*'
- en: '[*Chapter 17*](B21945_17.xhtml#_idTextAnchor636)*: Creating STL-Compatible
    Algorithms*'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第17章*](B21945_17.xhtml#_idTextAnchor636)*：创建与STL兼容的算法*'
- en: '[*Chapter 18*](B21945_18.xhtml#_idTextAnchor658)*: Type Traits and Policies*'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第18章*](B21945_18.xhtml#_idTextAnchor658)*：类型特性和策略*'
