- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Program Analysis Tools
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序分析工具
- en: Producing high-quality code is not an easy task, even for highly experienced
    developers. By including tests in our solution, we lower the chance of making
    basic mistakes in the main code. But that won’t be enough to avoid more intricate
    problems. Every piece of software consists of so many details that keeping track
    of them all becomes a full-time job. Various conventions and specific design practices
    are established by teams responsible for maintaining the product.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编写高质量代码并非易事，即便是经验丰富的开发者也是如此。通过在我们的解决方案中加入测试，我们可以减少在主代码中犯基本错误的可能性。但这还不足以避免更复杂的问题。每一段软件都包含了大量的细节，要追踪所有这些细节几乎成为了一项全职工作。维护产品的团队会建立各种约定和特定的设计实践。
- en: 'Some questions relate to consistent coding style: should we use 80 or 120 columns
    in our code? Should we allow `std::bind` or stick to lambda functions? Is it acceptable
    to use C-style arrays? Should small functions be written in a single line? Should
    we always use auto, or only when it improves readability? Ideally, we should steer
    clear of statements known to be generally incorrect: infinite loops, the use of
    identifiers reserved by a standard library, unintended data loss, unnecessary
    `if` statements, and anything else that is not a “best practice” (see the *Further
    reading* section for more information).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些问题与一致的编码风格有关：我们应该在代码中使用80列还是120列？我们应该允许使用 `std::bind` 还是坚持使用 Lambda 函数？使用
    C 风格的数组是否可以接受？小函数是否应该写成一行？我们是否应该总是使用 auto，还是仅在提高可读性时使用？理想情况下，我们应该避免已知通常不正确的语句：无限循环、使用标准库保留的标识符、无意的数据丢失、不必要的
    `if` 语句以及其他任何不符合“最佳实践”的东西（更多信息请参见 *进一步阅读* 部分）。
- en: 'Another aspect to consider is code modernization. As C++ evolves, it introduces
    new features. Keeping track of all the spots where we can update to the latest
    standard can be challenging. Moreover, doing this manually takes time and increases
    the risk of introducing errors, especially in a large code base. Finally, we should
    check how things operate when set into motion: running the program and checking
    its memory. Is the memory properly released after use? Are we accessing data that
    was correctly initialized? Or does the code attempt to access non-existent pointers?'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的方面是代码的现代化。随着 C++ 的发展，它引入了新的特性。跟踪所有可以更新到最新标准的地方可能是一个挑战。此外，手动进行这一操作既费时又增加了引入错误的风险，尤其是在大型代码库中。最后，我们还应检查在程序运行时其操作是否正常：运行程序并检查其内存。内存是否在使用后正确释放？我们是否访问了已正确初始化的数据？或者代码是否尝试访问不存在的指针？
- en: Managing all these challenges and questions manually is both time-consuming
    and prone to errors. Fortunately, we can use automated tools to inspect and enforce
    rules, correct mistakes, and bring our code up to date. It’s time to explore tools
    for program analysis. Our code will be scrutinized during every build to make
    sure it meets industry standards.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 手动管理所有这些挑战和问题既费时又容易出错。幸运的是，我们可以使用自动化工具来检查和强制执行规则，纠正错误，并使我们的代码保持最新。现在是时候探索程序分析工具了。在每次构建时，我们的代码将会被仔细审查，确保它符合行业标准。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Enforcing formatting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制格式化
- en: Using static checkers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态检查工具
- en: Dynamic analysis with Valgrind
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Valgrind 进行动态分析
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch12](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch12).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章中提到的代码文件，网址为 [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch12](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch12)。
- en: 'To build the examples provided in this book, always use these recommended commands:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建本书中提供的示例，请始终使用以下推荐的命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Be sure to replace the placeholders `<build tree>` and `<source tree>` with
    appropriate paths. As a reminder, **build tree** is the path to target/output
    directory, and **source tree** is the path where your source code is located.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将占位符 `<build tree>` 和 `<source tree>` 替换为适当的路径。提醒一下，**build tree** 是目标/输出目录的路径，**source
    tree** 是源代码所在的路径。
- en: Enforcing formatting
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制格式化
- en: Professional developers usually follow rules. It’s said that senior developers
    know when to break them because they can justify the need. On the flip side, very
    senior developers often avoid breaking rules to save time explaining their choices.
    The key is to focus on issues that genuinely affect a product, rather than getting
    caught up in minor details.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 专业开发人员通常会遵循规则。有人说，资深开发人员知道什么时候可以打破规则，因为他们能为其必要性提供正当理由。另一方面，非常资深的开发人员通常避免打破规则，以节省解释自己选择的时间。关键是要关注真正影响产品的问题，而不是陷入琐碎的细节。
- en: 'When it comes to coding style and formatting, developers face many options:
    should we use tabs or spaces for indentation? If spaces, how many? What should
    be the character limit in a column or a file? These choices typically don’t change
    the program’s behavior but can trigger lengthy discussions that add little value.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码风格和格式化方面，开发人员面临许多选择：我们应该使用制表符还是空格进行缩进？如果是空格，使用多少个？列或文件中的字符限制应该是多少？这些选择通常不会改变程序的行为，但可能引发冗长的讨论，增加的价值不大。
- en: 'Common practices do exist, but debates often center on personal preference
    and anecdotal evidence. For instance, choosing 80 characters per column over 120
    is arbitrary. What matters is maintaining a consistent style, as inconsistency
    can hinder the code’s readability. To ensure consistency, it’s advisable to use
    a formatting tool like `clang-format`. This tool can notify us if the code isn’t
    formatted correctly and even make corrections. Here’s an example command for formatting
    code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 确实存在一些常见的做法，但讨论通常围绕个人偏好和轶事证据展开。例如，选择每列80个字符而非120个字符是任意的。重要的是保持一致的风格，因为不一致可能会妨碍代码的可读性。为了确保一致性，建议使用像`clang-format`这样的格式化工具。这个工具可以通知我们代码是否没有正确格式化，甚至可以自动修正。下面是格式化代码的示例命令：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `-i` option instructs clang-format to edit files directly, while `--style`
    specifies the formatting style to use, such as `LLVM`, `Google`, `Chromium`, `Mozilla`,
    `WebKit`, or a custom style provided in a file (more details are available in
    the *Further reading* section).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i`选项指示clang-format直接编辑文件，而`--style`指定要使用的格式化风格，例如`LLVM`、`Google`、`Chromium`、`Mozilla`、`WebKit`或在文件中提供的自定义风格（更多细节请参见*进一步阅读*部分）。'
- en: 'Of course, we don’t want to execute this command manually every time we make
    a change; `CMake` should handle this as part of the building process. We already
    know how to locate `clang-format` on the system (we’ll need to install it manually
    beforehand). What we haven’t covered is how to apply this external tool to all
    our source files. To do it, we’ll create a convenient function that can be included
    from the `cmake` directory:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不想每次更改时都手动执行此命令；`CMake`应该作为构建过程的一部分来处理此事。我们已经知道如何在系统中找到`clang-format`（我们需要事先手动安装它）。我们尚未讨论的是如何将这个外部工具应用于所有源文件。为此，我们将创建一个便捷的函数，可以从`cmake`目录中包含该函数：
- en: '**ch12/01-formatting/cmake/Format.cmake**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/01-formatting/cmake/Format.cmake**'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Format` function accepts two arguments: `target` and `directory`. It will
    format all source files from the directory, right before the target is built.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Format`函数接受两个参数：`target`和`directory`。它将在目标构建之前格式化来自该目录的所有源文件。'
- en: Technically, not all files in the directory must belong to the target, and the
    target’s sources could be spread across multiple directories. However, tracking
    down all the source files and headers related to the target is complicated, especially
    when we need to exclude headers from external libraries. In this case, it’s easier
    to focus on directories than on logical targets. We can call the function for
    each directory that needs formatting.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，目录中的所有文件不必都属于目标，目标的源文件可能分布在多个目录中。然而，追踪与目标相关的所有源文件和头文件是复杂的，特别是在需要排除外部库的头文件时。在这种情况下，聚焦于目录比聚焦于逻辑目标要容易。我们可以为每个需要格式化的目录调用该函数。
- en: 'This function has the following steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的步骤如下：
- en: Find the installed `clang-format` binary. The `REQUIRED` keyword will halt the
    configuration with an error if the binary wasn’t found.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找已安装的`clang-format`二进制文件。如果未找到该二进制文件，`REQUIRED`关键字会在配置过程中抛出错误。
- en: Create a list of file extensions to format (to be used as a **globbing expression**).
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件扩展名列表以进行格式化（用作**通配符表达式**）。
- en: Prepend each expression with a path to `directory`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个表达式前加上`directory`的路径。
- en: Search recursively for sources and headers (using the previously created list),
    put found file paths into the `SOURCE_FILES` variable (but skip any directory
    paths found)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归搜索源文件和头文件（使用之前创建的列表），将找到的文件路径放入`SOURCE_FILES`变量中（但跳过任何找到的目录路径）。
- en: Attach the formatting command to the `PRE_BUILD` step of `target`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将格式化命令附加到`target`的`PRE_BUILD`步骤。
- en: This approach works well for small to medium-sized code bases. For larger code
    bases, we might need to convert absolute file paths to relative ones and run the
    formatting command, using the directory as a working directory. This could be
    necessary due to character limits in shell commands, which usually cap at around
    13,000 characters.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于小到中型代码库。对于更大的代码库，我们可能需要将绝对文件路径转换为相对路径，并使用目录作为工作目录运行格式化命令。这可能是由于 shell
    命令中的字符限制，通常限制大约为13,000个字符。
- en: 'Let’s explore how to use this function in practice. Here’s our project structure:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探讨一下如何在实践中使用这个功能。这是我们的项目结构：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, we set up the project and add the `cmake` directory to the module path
    for later inclusion:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们设置项目并将`cmake`目录添加到模块路径中，以便稍后包含：
- en: '**ch12/01-formatting/CMakeLists.txt**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/01-formatting/CMakeLists.txt**'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we populate the `listfile` for the `src` directory:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为`src`目录填充`listfile`：
- en: '**ch12/01-formatting/src/CMakeLists.txt**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/01-formatting/src/CMakeLists.txt**'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is straightforward. We create an executable target named `main`, include
    the `Format.cmake` module, and call the `Format()` function for the `main` target
    in the current directory (`src`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这很直接。我们创建一个名为`main`的可执行目标，包含`Format.cmake`模块，并在当前目录（`src`）为`main`目标调用`Format()`函数。
- en: 'Now, we need some unformatted source files. The header contains a simple `unused`
    function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一些未格式化的源文件。头文件包含一个简单的`unused`函数：
- en: '**ch12/01-formatting/src/header.h**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/01-formatting/src/header.h**'
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We’ll also include a source file with excessive, incorrect whitespace:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将包括一个源文件，其中包含多余的、不正确的空白符：
- en: '**ch12/01-formatting/src/main.cpp**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/01-formatting/src/main.cpp**'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Almost there. We just need the formatter’s configuration file, enabled via
    the `--style=file` command-line argument:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 快完成了。我们只需要格式化工具的配置文件，通过`--style=file`命令行参数启用：
- en: '**ch12/01-formatting/.clang-format**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/01-formatting/.clang-format**'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`ClangFormat` will scan the parent directories for the `.clang-format` file,
    which specifies the exact formatting rules. This lets us customize every detail.
    In my case, I’ve started with Google’s coding style and made a few adjustments:
    a 140-character column limit, no tabs, and no short loops, functions, or `if`
    statements on a single line.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClangFormat`将扫描父目录中的`.clang-format`文件，该文件指定了确切的格式化规则。这使我们能够自定义每个细节。在我的案例中，我从Google的编码风格开始，并做了一些调整：140字符列限制，不使用制表符，不允许短的循环、函数或`if`语句写在一行内。'
- en: 'After building the project (formatting occurs automatically before compilation),
    our files look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建项目后（格式化会在编译前自动进行），我们的文件看起来像这样：
- en: '**ch12/01-formatting/src/header.h (formatted)**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/01-formatting/src/header.h（已格式化）**'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The header file was formatted, even though it isn’t used by the target. Short
    functions can’t be on a single line, and as expected, new lines were added. The
    `main.cpp` file also looks pretty slick now. Unneeded whitespace is gone, and
    indentations are standardized:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 即使头文件没有被目标使用，仍然进行了格式化。短函数不能写在一行内，正如预期的那样，添加了新行。`main.cpp`文件现在看起来也相当简洁。不需要的空白符消失了，缩进已标准化：
- en: '**ch12/01-formatting/src/main.cpp (formatted)**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/01-formatting/src/main.cpp（已格式化）**'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Automating formatting saves time during code reviews. If you’ve ever had to
    amend a commit just because of whitespace issues, you know the relief this brings.
    Consistent formatting keeps your code clean effortlessly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化格式化可以节省代码审查时的时间。如果你曾经因为空白符问题而不得不修改提交，你一定能体会到这带来的轻松。统一的格式化使你的代码保持整洁，无需费力。
- en: Applying formatting to an entire code base will most likely introduce a big
    one-off change to the majority of the files in the repository. This may cause
    *a lot* of merge conflicts if you (or your teammates) have some ongoing work.
    It’s best to coordinate such efforts to happen after all pending changes are done.
    If this isn’t possible, consider gradual adoption, perhaps on a per-directory
    basis. Your teammates will appreciate it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对整个代码库应用格式化最有可能会在仓库中的大多数文件中引入一次性的大变动。如果你（或你的团队成员）正在进行一些工作，这可能会导致*大量*的合并冲突。最好在所有待处理的更改完成后再进行此类操作。如果这不可行，可以考虑逐步采用，可能按目录进行。你的团队成员会感激这一点。
- en: Although the formatter excels in making code visually consistent, it’s not a
    comprehensive program analysis tool. For more advanced needs, other utilities
    designed for static analysis are necessary.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管格式化工具在使代码视觉上保持一致方面表现出色，但它不是一个全面的程序分析工具。对于更高级的需求，其他专门用于静态分析的工具是必要的。
- en: Using static checkers
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态检查工具
- en: Static program analysis involves examining source code without running the compiled
    version. Consistently using static checkers can significantly improve code quality
    by making it more consistent and less susceptible to bugs and known security vulnerabilities.
    The C++ community offers a wide range of static checkers like `Astrée`, `clang-tidy`,
    `CLazy`, `CMetrics`, `Cppcheck`, `Cpplint`, `CQMetrics`, `ESBMC`, `FlawFinder`,
    `Flint`, `IKOS`, `Joern`, `PC-Lint`, `Scan-Build`, `Vera++`, and more.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 静态程序分析涉及在不运行已编译版本的情况下检查源代码。始终使用静态检查器可以显著提高代码质量，使其更加一致，不易受到错误和已知安全漏洞的影响。C++社区提供了多种静态检查器，如`Astrée`、`clang-tidy`、`CLazy`、`CMetrics`、`Cppcheck`、`Cpplint`、`CQMetrics`、`ESBMC`、`FlawFinder`、`Flint`、`IKOS`、`Joern`、`PC-Lint`、`Scan-Build`、`Vera++`等。
- en: 'Many of these tools recognize `CMake` as an industry standard and offer ready-to-use
    support or integration tutorials. Some build engineers prefer not to write `CMake`
    code and instead include static checkers through external modules available online.
    An example is the collection by Lars Bilke on his GitHub repository: [https://github.com/bilke/cmake-modules](https://github.com/bilke/cmake-modules).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 其中许多工具将`CMake`视为行业标准，并提供现成的支持或集成教程。一些构建工程师更喜欢不编写`CMake`代码，而是通过在线可用的外部模块来包含静态检查器。例如，Lars
    Bilke在他的GitHub仓库中的集合：[https://github.com/bilke/cmake-modules](https://github.com/bilke/cmake-modules)。
- en: A common belief is that setting up static checkers is complicated. This perception
    exists because static checkers often emulate the behavior of a real compiler to
    understand the code. But it doesn’t have to be difficult.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普遍的看法是设置静态检查器很复杂。这种看法存在是因为静态检查器通常模拟实际编译器的行为来理解代码。但实际上并不一定要很难。
- en: '`Cppcheck` outlines the following simple steps in its manual:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cppcheck`在其手册中概述了以下简单步骤：'
- en: Locate the static checker’s executable.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位静态检查器的可执行文件。
- en: 'Generate a *compile database* with the following:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令生成*编译数据库*：
- en: '`cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON`.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON`。'
- en: 'Run the checker using the generated JSON file:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用生成的JSON文件运行检查器：
- en: '`<path-to-cppcheck> --project=compile_commands.json`'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<path-to-cppcheck> --project=compile_commands.json`'
- en: These steps should be integrated into the build process to ensure they are not
    overlooked.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤应该集成到构建过程中，以确保它们不会被忽略。
- en: 'Since `CMake` knows how to build our targets, can it also support any static
    checkers? Absolutely, and it’s easier than you might think. `CMake` allows you
    to enable checkers on a per-target basis for the following tools:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CMake`知道如何构建我们的目标，它是否也支持任何静态检查器？完全支持，而且比你想的要简单得多。`CMake`允许你为以下工具按目标启用检查器：
- en: '`include-what-you-use` ([https://include-what-you-use.org](https://include-what-you-use.org))'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include-what-you-use` ([https://include-what-you-use.org](https://include-what-you-use.org))'
- en: '`clang-tidy` ([https://clang.llvm.org/extra/clang-tidy](https://clang.llvm.org/extra/clang-tidy))'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clang-tidy` ([https://clang.llvm.org/extra/clang-tidy](https://clang.llvm.org/extra/clang-tidy))'
- en: '`Link What` `You Use` (a built-in `CMake` checker)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Link What` `You Use`（一个内建的`CMake`检查器）'
- en: '`Cpplint` ([https://github.com/cpplint/cpplint](https://github.com/cpplint/cpplint))'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cpplint` ([https://github.com/cpplint/cpplint](https://github.com/cpplint/cpplint))'
- en: '`Cppcheck` ([https://cppcheck.sourceforge.io](https://cppcheck.sourceforge.io))'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cppcheck` ([https://cppcheck.sourceforge.io](https://cppcheck.sourceforge.io))'
- en: 'To enable these checkers, set a target property to a semicolon-separated list
    containing the path to the checker’s executable and any command-line options to
    forward:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用这些检查器，将目标属性设置为包含检查器可执行文件路径和任何需要转发的命令行选项的分号分隔列表：
- en: '`<LANG>_CLANG_TIDY`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<LANG>_CLANG_TIDY`'
- en: '`<LANG>_CPPCHECK`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<LANG>_CPPCHECK`'
- en: '`<LANG>_CPPLINT`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<LANG>_CPPLINT`'
- en: '`<LANG>_INCLUDE_WHAT_YOU_USE`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<LANG>_INCLUDE_WHAT_YOU_USE`'
- en: '`LINK_WHAT_YOU_USE`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LINK_WHAT_YOU_USE`'
- en: 'Replace `<LANG>` with `C` for C sources and `CXX` for C++. If you want to enable
    a checker for all project targets, set a global variable prefixed with `CMAKE_`
    – for example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 用`C`替换`<LANG>`以处理C源代码，用`CXX`处理C++源代码。如果你希望为所有项目目标启用检查器，可以设置一个以`CMAKE_`为前缀的全局变量——例如：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Any target defined after this statement will have its `CXX_CLANG_TIDY` property
    set to this value. Remember that enabling this analysis may slightly extend your
    build time. On the other hand, having more detailed control over how targets are
    tested by the checker can be useful. We can create a straightforward function
    to handle this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在此语句之后定义的任何目标都会将其`CXX_CLANG_TIDY`属性设置为此值。请记住，启用此分析可能会稍微延长构建时间。另一方面，更详细地控制检查器如何测试目标是非常有用的。我们可以创建一个简单的函数来处理此操作：
- en: '**ch12/02-clang-tidy/cmake/ClangTidy.cmake**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/02-clang-tidy/cmake/ClangTidy.cmake**'
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `AddClangTidy` function follows two basic steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddClangTidy` 函数包括两个基本步骤：'
- en: Locate the `clang-tidy` binary and store its path in `CLANG-TIDY_PATH`. The
    `REQUIRED` keyword ensures that configuration stops with an error if the binary
    is not found.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位 `clang-tidy` 二进制文件并将其路径存储在 `CLANG-TIDY_PATH` 中。`REQUIRED` 关键字确保如果找不到二进制文件，配置将停止并抛出错误。
- en: Enable `clang-tidy` for the target by providing the binary path and specific
    options to activate all checks and treat warnings as errors.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供二进制路径和特定选项来启用目标的 `clang-tidy`，以激活所有检查并将警告视为错误。
- en: 'To use this function, we just need to include the module and call it for the
    chosen target:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个功能，我们只需包含模块并为所选目标调用它：
- en: '**ch12/02-clang-tidy/src/CMakeLists.txt**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/02-clang-tidy/src/CMakeLists.txt**'
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This approach is concise and very effective. When building the solution, the
    `clang-tidy` output will appear as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法简洁且非常有效。在构建解决方案时，`clang-tidy` 的输出将如下所示：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that unless you add the `--warnings-as-errors=*` option to the command-line
    arguments, the build will succeed. Organizations should decide on a set of rules
    that must be strictly followed to prevent non-compliant code from entering the
    repository.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除非您将 `--warnings-as-errors=*` 选项添加到命令行参数中，否则构建会成功完成。组织应决定一组必须严格遵循的规则，以防止不合规的代码进入代码库。
- en: '`clang-tidy` also offers a useful `--fix` option that automatically corrects
    your code when possible. This feature is a valuable time-saver and is particularly
    helpful when expanding the list of checks. Just like with formatting, be cautious
    of merge conflicts when adding changes made by static analysis tools to existing
    code bases.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`clang-tidy` 还提供了一个有用的 `--fix` 选项，可以在可能的情况下自动修正您的代码。这个功能是一个宝贵的时间节省工具，尤其在扩展检查项列表时非常有用。与格式化类似，在将静态分析工具所做的更改添加到现有代码库时，要小心合并冲突。'
- en: Depending on your situation, the repository size, and team preferences, you
    should select a handful of checkers that best suit your needs. Including too many
    can become disruptive. Here’s a brief overview of the checkers supported by `CMake`
    right out of the box.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的情况、代码库的大小和团队的偏好，您应选择少量最适合您需求的检查工具。包含过多的检查工具可能会导致干扰。以下是 `CMake` 默认支持的检查工具的简要概述。
- en: clang-tidy
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: clang-tidy
- en: 'Here’s what the official website says about clang-tidy:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是官方文档中关于 clang-tidy 的介绍：
- en: clang-tidy is a clang-based C++ “linter” tool. Its purpose is to provide an
    extensible framework for diagnosing and fixing typical programming errors, like
    style violations, interface misuse, or bugs that can be deduced via static analysis.
    clang-tidy is modular and provides a convenient interface for writing new checks.
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: clang-tidy 是一个基于 clang 的 C++ 静态分析工具。它的目的是提供一个可扩展的框架，用于诊断和修复典型的编程错误，如风格违规、接口误用或通过静态分析可以推断出的错误。clang-tidy
    是模块化的，并提供了一个方便的接口用于编写新的检查项。
- en: The tool is quite versatile, offering more than 400 checks. It pairs well with
    `ClangFormat`, enabling automatically applied fixes (over 150 are available) to
    conform to the same format file. The checks it offers cover performance, readability,
    modernization, C++ core guidelines, and bug-prone areas.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具非常灵活，提供了超过 400 项检查。它与 `ClangFormat` 配合良好，能够自动应用修复（超过 150 项修复可用），以符合相同的格式文件。它提供的检查覆盖了性能、可读性、现代化、C++
    核心指南以及易出错的领域。
- en: Cpplint
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cpplint
- en: 'Here’s a description of `Cpplint` from its official website:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `Cpplint` 官方网站的描述：
- en: Cpplint is a command-line tool to check C/C++ files for style issues following
    Google’s C++ style guide. Cpplint is developed and maintained by Google Inc. at
    google/styleguide.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Cpplint 是一个命令行工具，用于检查 C/C++ 文件的风格问题，遵循 Google 的 C++ 风格指南。Cpplint 由 Google 公司在
    google/styleguide 上开发和维护。
- en: This linter aims to align your code with Google’s style guide. Written in Python,
    it may introduce an unwanted dependency for some projects. The fixes are offered
    in formats consumable by `Emacs`, `Eclipse`, `VS7`, `Junit`, and as `sed` commands.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个静态代码分析工具旨在使您的代码符合 Google 的风格指南。它是用 Python 编写的，可能会为某些项目引入不必要的依赖。修复建议以 `Emacs`、`Eclipse`、`VS7`、`Junit`
    格式提供，也可以作为 `sed` 命令使用。
- en: Cppcheck
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cppcheck
- en: 'Here’s what the official website says about `Cppcheck`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是官方文档中关于 `Cppcheck` 的介绍：
- en: Cppcheck is a static analysis tool for C/C++ code. It provides unique code analysis
    to detect bugs and focuses on detecting undefined behaviour and dangerous coding
    constructs. The goal is to have very few false positives. Cppcheck is designed
    to be able to analyze your C/C++ code even if it has non-standard syntax (common
    in embedded projects).
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Cppcheck是一个用于C/C++代码的静态分析工具。它提供独特的代码分析，检测错误，重点检查未定义的行为和危险的编码结构。目标是尽量减少误报。Cppcheck设计为即使代码有非标准语法（在嵌入式项目中常见），也能够进行分析。
- en: This tool is particularly good for minimizing false positives, making it a reliable
    option for code analysis. It has been around for over 14 years and is still actively
    maintained. It’s especially useful if your code is not compatible with Clang.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具特别擅长最小化误报，使其成为可靠的代码分析选项。它已经存在超过14年，并且仍在积极维护。如果你的代码与Clang不兼容，它尤其有用。
- en: include-what-you-use
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: include-what-you-use
- en: 'Here’s a description of include-what-you-use from its official website:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自官方官网的include-what-you-use描述：
- en: 'The main goal of include-what-you-use is to remove superfluous #includes. It
    does this both by figuring out what #includes are not actually needed for this
    file (for both .cc and .h files), and replacing #includes with forward-declares
    when possible.'
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: include-what-you-use的主要目标是去除多余的#includes。它通过找出此文件（包括.cc和.h文件）中实际上不需要的#includes，并在可能的情况下用前置声明替换#includes来实现这一点。
- en: While having too many included headers may not seem like a significant issue
    in small projects, the time saved from avoiding needless compilation of header
    files can quickly accumulate in larger projects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在小型项目中，包含过多头文件似乎不是什么大问题，但避免不必要的头文件编译所节省的时间，在大型项目中会迅速积累。
- en: Link What You Use
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Link What You Use
- en: 'Here is a description of “Link what you use” on `CMake`''s blog:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`CMake`博客中关于“Link what you use”的描述：
- en: This is a built in CMake feature that uses options of ld and ldd to print out
    if executables link more libraries than they actually require.
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是一个内置的CMake功能，使用ld和ldd的选项打印出可执行文件是否链接了超出实际需求的库。
- en: Static analysis plays a crucial role in industries like medicine, nuclear power,
    aviation, automotive, and machinery, where software errors could be life-threatening.
    Wise developers also adopt these practices in less critical environments, especially
    when the costs are low. Using static analysis during the build process is not
    only more cost-effective than manual bug finding and fixing, but it’s also easy
    to enable with `CMake`. I’d go as far as to say that there’s almost no reason
    to skip these checks in any quality-sensitive software, which includes any software
    involving people other than just the developer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析在医疗、核能、航空、汽车和机械等行业中起着至关重要的作用，因为软件错误可能会威胁生命。明智的开发者也会在非关键环境中采用这些实践，尤其是当成本较低时。在构建过程中使用静态分析不仅比手动发现和修复错误更具成本效益，而且通过`CMake`启用也非常简单。我甚至可以说，对于任何质量敏感的软件（包括涉及开发者以外的其他人的软件），几乎没有理由跳过这些检查。
- en: This feature also helps speed up the build time by focusing on eliminating unneeded
    binary artifacts. Unfortunately, not all bugs can be detected before running a
    program. Luckily, we can take additional steps to gain a deeper understanding
    of our projects, like using `Valgrind`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能还通过专注于消除不必要的二进制文件，帮助加速构建时间。不幸的是，并非所有的错误都能在运行程序之前被检测到。幸运的是，我们可以采取额外的措施，像使用`Valgrind`，来深入了解我们的项目。
- en: Dynamic analysis with Valgrind
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Valgrind进行动态分析
- en: '`Valgrind` ([https://www.valgrind.org](https://www.valgrind.org)) is an *nix
    instrumentation framework for building dynamic analysis utilities, which means
    it performs analysis during a program’s runtime. It comes with a wide range of
    tools for various types of investigations and checks. Some of the tools include:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Valgrind` ([https://www.valgrind.org](https://www.valgrind.org)) 是一个用于构建动态分析工具的*nix工具框架，这意味着它在程序运行时进行分析。它配备了各种工具，适用于多种类型的调查和检查。一些工具包括：'
- en: '`Memcheck`: detects memory management problems'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Memcheck`：检测内存管理问题'
- en: '`Cachegrind`: profiles CPU caches, and identifies cache misses and other issues'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cachegrind`：分析CPU缓存，并识别缓存未命中和其他问题'
- en: '`Callgrind`: an extension of `Cachegrind` that provides extra information on
    call graphs'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Callgrind`：`Cachegrind`的扩展，提供关于调用图的额外信息'
- en: '`Massif`: a heap profiler that shows how different parts of the program use
    the heap over time'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Massif`：一个堆分析器，显示程序不同部分如何随时间使用堆'
- en: '`Helgrind`: a thread debugger for data race issues'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Helgrind`：一个用于数据竞争问题的线程调试器'
- en: '`DRD`: a lighter, more limited version of `Helgrind`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DRD`：`Helgrind`的一个较轻量、功能较为有限的版本'
- en: Each tool on this list is highly useful when the situation calls for it. Most
    system package managers know `Valgrind` and can install it on your OS with ease.
    If you’re using Linux, it may already be installed. Additionally, the official
    website provides the source code for those who prefer to build it themselves.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个工具在需要时都非常有用。大多数系统包管理器都知道`Valgrind`，并可以轻松地在你的操作系统上安装它。如果你使用的是Linux，它可能已经安装了。此外，官方网站还提供了源代码，供那些喜欢自己编译的用户使用。
- en: Our discussion will primarily focus on `Memcheck`, the most commonly used tool
    in the `Valgrind` suite (when developers refer to `Valgrind`, they often mean
    `Valgrind`'s `Memcheck`). We’ll explore how to use it with `CMake`, which will
    make it easier to adopt other tools from the suite if you find them necessary
    later on.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的讨论将主要集中在`Memcheck`上，这是`Valgrind`套件中最常用的工具（当开发者提到`Valgrind`时，通常指的是`Valgrind`的`Memcheck`）。我们将探讨如何与`CMake`一起使用它，这将使得如果以后需要使用其他工具时，更容易采用套件中的其他工具。
- en: Memcheck
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Memcheck
- en: '`Memcheck` is invaluable for debugging memory issues, a topic that can be especially
    complex in C++. Programmers have extensive control over memory management, making
    various mistakes possible. These can range from reading unallocated or already
    freed memory to freeing memory multiple times, and even writing to incorrect addresses.
    These bugs can easily go unnoticed and creep into even straightforward programs.
    Sometimes, a single forgotten variable initialization is all it takes to run into
    trouble.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Memcheck`对于调试内存问题非常宝贵，尤其是在C++中，这个话题可能特别复杂。程序员对内存管理有广泛的控制，因此可能会犯各种错误。这些错误可能包括读取未分配或已经释放的内存，重复释放内存，甚至写入错误的地址。这些漏洞往往容易被忽视，甚至渗透到简单的程序中。有时，仅仅是忘记初始化一个变量，就足以导致问题。'
- en: 'Invoking `Memcheck` looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Memcheck`看起来像这样：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Memcheck` is `Valgrind`''s default tool, but you can also explicitly specify
    it like so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Memcheck`是`Valgrind`的默认工具，但你也可以明确指定它，如下所示：'
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Running `Memcheck` can slow down your program considerably; the manual (see
    the link in *Further reading*) says that programs instrumented with it can be
    10–15 times slower. To avoid waiting for `Valgrind` every time we run tests, we’ll
    create a separate target that will be called from the command line whenever we
    need to test our code. Ideally, this will be done before any new code is merged
    into the main code base. You can include this step in an early Git hook or as
    part of your **Continuous Integration** (**CI**) pipeline.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`Memcheck`会显著降低程序的运行速度；手册（见*进一步阅读*中的链接）表示，使用它的程序可能会变得比正常速度慢10到15倍。为了避免每次运行测试时都需要等待`Valgrind`，我们将创建一个单独的目标，在需要测试代码时从命令行调用。理想情况下，这个步骤应该在任何新代码合并到主代码库之前完成。你可以将这个步骤包含在一个早期的Git钩子中，或作为**持续集成**（**CI**）流水线的一部分。
- en: 'To create a custom target for `Valgrind`, you can use this command after the
    `CMake` generation stage:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`Valgrind`创建自定义目标，可以在`CMake`生成阶段之后使用以下命令：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here’s how you can add such a target in `CMake`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在`CMake`中添加这样的目标：
- en: '**ch12/03-valgrind/cmake/Valgrind.cmake**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/03-valgrind/cmake/Valgrind.cmake**'
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this example, we define a `CMake` function named `AddValgrind` that takes
    the target to be tested (we’ll be able to reuse it across projects). Two main
    things occur here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个名为`AddValgrind`的`CMake`函数，它接受要测试的目标（我们可以在多个项目中重复使用它）。这里发生了两件主要的事情：
- en: '`CMake` checks default system paths for the `valgrind` executable and stores
    its path in the `VALGRIND_PATH` variable. The `REQUIRED` keyword will halt the
    configuration with an error if the binary isn’t found.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMake`会检查默认的系统路径以查找`valgrind`可执行文件，并将其路径存储在`VALGRIND_PATH`变量中。如果没有找到该二进制文件，`REQUIRED`关键字将导致配置中断并报错。'
- en: A custom target, `valgrind`, is created. It runs `Memcheck` on the specified
    binary, with an option to always check for memory leaks.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了一个名为`valgrind`的自定义目标。它会在指定的二进制文件上运行`Memcheck`，并且总是检查内存泄漏。
- en: '`Valgrind` options can be set in various ways:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Valgrind`选项可以通过多种方式设置：'
- en: In the `~/.valgrindrc` file (in your home directory)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`~/.valgrindrc`文件中（在你的主目录下）
- en: Through the `$VALGRIND_OPTS` environment variable
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`$VALGRIND_OPTS`环境变量
- en: In the `./.valgrindrc` file (in the working directory)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`./.valgrindrc`文件中（在工作目录下）
- en: These are checked in that order. Also, note that the last file will only be
    considered if it belongs to the current user, is a regular file, and isn’t marked
    as world-writable. This is a safety mechanism, as options given to `Valgrind`
    can be potentially harmful.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件按顺序进行检查。另外，请注意，只有在文件属于当前用户、是常规文件且没有标记为全局可写时，最后一个文件才会被考虑。这是一个安全机制，因为提供给 `Valgrind`
    的选项可能会有潜在的危害。
- en: 'To use the `AddValgrind` function, we provide it with a `unit_tests` target,
    as we want to run it in a finely controlled environment like unit tests:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `AddValgrind` 函数，我们将其与 `unit_tests` 目标一起使用，因为我们希望在像单元测试这样的精细控制环境中运行它：
- en: '**ch12/03-valgrind/test/CMakeLists.txt (fragment)**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/03-valgrind/test/CMakeLists.txt（片段）**'
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Remember that generating build trees with the `Debug` config allows `Valgrind`
    to tap into the debug information, making its output much clearer.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用 `Debug` 配置生成构建树可以让 `Valgrind` 访问调试信息，从而使输出更加清晰。
- en: 'Let’s see how this works in practice:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个在实践中是如何工作的：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This configures the project, builds the `sut` and `unit_tests` targets, and
    starts the execution of `Memcheck`, which will provide us with general information:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将配置项目，构建 `sut` 和 `unit_tests` 目标，并开始执行 `Memcheck`，它将提供一般信息：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `==954==` prefix contains the process `ID`, helping to distinguish `Valgrind`
    commentary from the output of the tested process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`==954==` 前缀包含进程的 `ID`，有助于区分 `Valgrind` 的注释和被测试进程的输出。'
- en: 'Next, tests are run as usual with `gtest`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，像往常一样运行测试，使用 `gtest`：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'At the end, a summary is presented:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，呈现一个总结：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Uh-oh! We are still using at least 1 byte. Allocations made with `malloc()`
    and `new` aren’t matched with the appropriate `free()` and `delete` operations.
    It seems we have a memory leak in our program. `Valgrind` provides more details
    to find it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们仍然使用了至少 1 字节。通过 `malloc()` 和 `new` 分配的内存没有与适当的 `free()` 和 `delete` 操作匹配。看起来我们的程序中有内存泄漏。`Valgrind`
    提供了更多细节来帮助找到它：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lines starting with `by 0x<address>` indicate individual functions in a call
    stack. I’ve truncated the output (it had some noise from `GTest`) to focus on
    the interesting bit – the topmost function and source reference, `run()(run.cpp:6)`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `by 0x<address>` 开头的行表示调用栈中的单独函数。我已将输出截断（它有来自 `GTest` 的噪声），以便集中显示有趣的部分——最顶层的函数和源代码引用
    `run()(run.cpp:6)`：
- en: 'Finally, the summary is found at the bottom:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，总结信息出现在底部：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`Valgrind` is excellent at finding complex issues. Sometimes, it can dig even
    deeper to find issues that aren’t easily categorized. These will show up in the
    “`possibly lost`" row.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Valgrind` 非常擅长发现复杂问题。有时，它甚至可以更深入地挖掘出一些不容易归类的问题，这些问题会出现在 “`possibly lost`”
    行中。'
- en: 'Let’s see what the issue found by `Memcheck` was in this case:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Memcheck` 这次发现了什么问题：
- en: '**ch12/03-valgrind/src/run.cpp**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/03-valgrind/src/run.cpp**'
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That’s right: the highlighted code is faulty. We do, in fact, create an object
    that isn’t deleted before the test ends. This is the exact reason why having extensive
    test coverage is so important.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 没错：突出显示的代码是有问题的。实际上，我们创建了一个对象，而在测试结束之前没有删除它。这正是为什么拥有广泛的测试覆盖非常重要的原因。
- en: '`Valgrind` is a helpful tool, but its output can become overwhelming in complex
    programs. There is a way to manage this information more efficiently – it’s the
    `Memcheck`-`Cover` project.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Valgrind` 是一个有用的工具，但在复杂程序中，其输出可能会变得难以应对。实际上，有一种更有效地管理这些信息的方法——那就是 `Memcheck`-`Cover`
    项目。'
- en: Memcheck-Cover
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Memcheck-Cover
- en: 'Commercial IDEs like CLion can directly parse `Valgrind`''s output, making
    it easier to navigate through a graphical interface without having to scroll in
    the console. If your editor lacks this feature, a third-party report generator
    can offer a clearer view. `Memcheck`-`Cover`, developed by *David Garcin*, gives
    a better experience by creating an HTML file, as shown in the following figure:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 像 CLion 这样的商业 IDE 可以直接解析 `Valgrind` 的输出，使得通过图形界面浏览变得更加容易，无需在控制台中滚动。如果你的编辑器没有这个功能，第三方报告生成器可以提供更清晰的视图。由
    *David Garcin* 开发的 `Memcheck`-`Cover` 通过生成 HTML 文件提供了更好的体验，如下图所示：
- en: '![](img/B19844_12_01.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_12_01.png)'
- en: 'Figure 12.1: A report generated by Memcheck-Cover'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：由 Memcheck-Cover 生成的报告
- en: 'This neat little project is available on GitHub ([https://github.com/Farigh/memcheck-cover](https://github.com/Farigh/memcheck-cover));
    it requires `Valgrind` and `gawk` (the GNU AWK tool). To use it, we’ll prepare
    a setup function in a separate `CMake` module. It will consist of two parts:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简洁的小项目可以在 GitHub 上找到 ([https://github.com/Farigh/memcheck-cover](https://github.com/Farigh/memcheck-cover))；它需要
    `Valgrind` 和 `gawk`（GNU AWK 工具）。为了使用它，我们将在一个单独的 `CMake` 模块中准备一个设置函数。它将包含两部分：
- en: Fetching and configuring the tool
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取和配置工具
- en: Adding a custom target to run `Valgrind` and generate a report
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个自定义目标来运行`Valgrind`并生成报告
- en: 'Here’s how the configuration looks:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是配置的样子：
- en: '**ch12/04-memcheck/cmake/Memcheck.cmake**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/04-memcheck/cmake/Memcheck.cmake**'
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the first part, we follow the same practices as with a regular dependency:
    include the `FetchContent` module, and specify the project’s repository and desired
    Git tag with `FetchContent_Declare`. Next, we initiate the fetch process and configure
    the binary path, using the `memcheck-cover_SOURCE_DIR` variable set by `FetchContent_Populate`
    (called implicitly by `FetchContent_MakeAvailable`).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，我们遵循与常规依赖项相同的做法：包括`FetchContent`模块，并通过`FetchContent_Declare`指定项目的仓库和所需的Git标签。接下来，我们启动获取过程并配置二进制路径，使用`FetchContent_Populate`（由`FetchContent_MakeAvailable`隐式调用）设置的`memcheck-cover_SOURCE_DIR`变量。
- en: 'The second part of the function is creating the target to generate reports.
    We’ll call it `memcheck` (so that it doesn’t overlap with the previous `valgrind`
    target if we want to keep both options for some reason):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第二部分是创建目标以生成报告。我们将其命名为`memcheck`（这样如果出于某些原因希望保留两个选项，它就不会与之前的`valgrind`目标重叠）：
- en: '**ch12/04-memcheck/cmake/Memcheck.cmake (continued)**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/04-memcheck/cmake/Memcheck.cmake（续）**'
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This happens in two commands:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这一过程包括两个命令：
- en: First, we’ll run the `memcheck_runner.sh` wrapper script, which will execute
    `Valgrind`'s `Memcheck` and collect the output to the file provided with the `-o`
    argument.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将运行`memcheck_runner.sh`包装脚本，它将执行`Valgrind`的`Memcheck`并将输出收集到通过`-o`参数提供的文件中。
- en: Then, we’ll parse the output and create the report with `generate_html_report.sh`.
    This script requires input and output directories provided with the `-i` and `-o`
    arguments.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将解析输出并使用`generate_html_report.sh`生成报告。这个脚本需要通过`-i`和`-o`参数提供输入和输出目录。
- en: Both steps should be executed in the `CMAKE_BINARY_DIR` working directory so
    that the unit test binary can access files through relative paths if needed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤应该在`CMAKE_BINARY_DIR`工作目录中执行，这样单元测试二进制文件就可以通过相对路径访问文件（如果需要的话）。
- en: 'The last thing we need to add to our listfiles is, of course, a call to this
    function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的listfiles中添加的最后一件事，当然是调用这个函数：
- en: '**ch12/04-memcheck/test/CMakeLists.txt (fragment)**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch12/04-memcheck/test/CMakeLists.txt（片段）**'
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After generating a buildsystem with the `Debug` config, we can build the target
    with the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`Debug`配置生成构建系统后，我们可以使用以下命令构建目标：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then, we can enjoy our formatted report, generated as an HTML page.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以享受生成的格式化报告，它作为HTML页面生成。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: “You’ll spend more time reading code than writing it, so optimize for readability
    over writability.” This principle is often echoed in various books on clean code.
    It’s supported by the experiences of many software developers, which is why even
    small details like the number of spaces, newlines, and the order of `#import`
    statements are standardized. This standardization isn’t just for the sake of being
    meticulous; it’s about saving time. Following the practices in this chapter, you
    can forget about manually formatting code. It gets automatically formatted when
    you build, a step you’d do anyway to test the code. With `ClangFormat`, you can
    make sure the formatting is up to the standard of your choosing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: “你将花更多的时间阅读代码，而不是编写代码，所以要优化可读性而非可写性。” 这一原则在各种关于清洁代码的书籍中都有提及。许多软件开发人员的经验也支持这一点，这就是为什么连空格、换行符的数量，以及`#import`语句的顺序等小细节都要标准化。这种标准化不仅仅是为了精益求精；它是为了节省时间。遵循本章的做法，你可以忘记手动格式化代码。当你构建代码时，格式会自动调整，这本来就是你测试代码时要做的一步。借助`ClangFormat`，你可以确保格式符合你选择的标准。
- en: Going beyond simple whitespace adjustments, code should also meet numerous other
    guidelines. That’s where clang-tidy comes in. It helps enforce coding that your
    team or organization agreed on. We discussed this static checker in depth and
    also touched on other options like `Cpplint`, `Cppcheck`, include-what-you-use,
    and Link What You Use. Since static linkers are relatively fast, we can add them
    to our builds with little investment, and it will usually be well worth the price.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的空格调整外，代码还应该遵循许多其他规范。这就是clang-tidy的用武之地。它帮助执行你团队或组织所达成的编码规范。我们深入讨论了这个静态检查工具，还涉及了其他选项，如`Cpplint`、`Cppcheck`、include-what-you-use和Link
    What You Use。由于静态链接器的速度相对较快，我们可以将它们添加到构建过程中，投入非常小，而且通常非常值得。
- en: We also examined `Valgrind` utilities, focusing on `Memcheck` to identify issues
    with memory management, such as incorrect reads and writes. This tool is invaluable
    for avoiding hours of manual debugging and keeping bugs out of a production environment.
    We introduced a way to make `Valgrind`'s output more user-friendly with `Memcheck`-`Cover`,
    an HTML report generator. This is especially useful in environments where running
    an IDE is not possible, like CI pipelines.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还检查了`Valgrind`工具，重点介绍了`Memcheck`，它能帮助识别内存管理中的问题，如不正确的读取和写入。这个工具对于避免长时间的手动调试和防止生产环境中的bug非常宝贵。我们介绍了一种方法，通过`Memcheck`-`Cover`（一个HTML报告生成器）让`Valgrind`的输出更具用户友好性。在无法运行IDE的环境中，像CI流水线，这尤其有用。
- en: This chapter is just a starting point. Many other tools, both free and commercial,
    are available to help you with code quality. Explore them to find what suits you
    best. In the next chapter, we’ll dive into generating documentation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本章只是一个起点。许多其他工具，无论是免费的还是商业的，都可以帮助您提高代码质量。探索它们，找到最适合您的工具。在下一章中，我们将深入探讨生成文档的过程。
- en: Further reading
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following links:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，您可以参考以下链接：
- en: 'C++ Core guidelines, curated by Bjarne Stroustrup, author of C++: [https://github.com/isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++核心指南，由C++的作者Bjarne Stroustrup策划：[https://github.com/isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines)
- en: 'The `ClangFormat` reference: [https://clang.llvm.org/docs/ClangFormat.html](https://clang.llvm.org/docs/ClangFormat.html)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClangFormat`参考：[https://clang.llvm.org/docs/ClangFormat.html](https://clang.llvm.org/docs/ClangFormat.html)'
- en: 'Static analyzers for C++ – a curated list: [https://github.com/analysis-tools-dev/static-analysis#cpp](https://github.com/analysis-tools-dev/static-analysis#cpp)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++的静态分析工具 – 精选列表：[https://github.com/analysis-tools-dev/static-analysis#cpp](https://github.com/analysis-tools-dev/static-analysis#cpp)
- en: 'Built-in static checker support in `CMake`: [https://blog.kitware.com/static-checks-with-cmake-cdash-iwyu-clang-tidy-lwyu-cpplint-and-cppcheck/](https://blog.kitware.com/static-checks-with-cmake-cdash-iwyu-clang-tidy-lwyu-cpplint-and-cppcheck/)'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMake`中的内置静态检查器支持：[https://blog.kitware.com/static-checks-with-cmake-cdash-iwyu-clang-tidy-lwyu-cpplint-and-cppcheck/](https://blog.kitware.com/static-checks-with-cmake-cdash-iwyu-clang-tidy-lwyu-cpplint-and-cppcheck/)'
- en: 'A target property enabling `clang-tidy`: [https://cmake.org/cmake/help/latest/prop_tgt/LANG_CLANG_TIDY.html](https://cmake.org/cmake/help/latest/prop_tgt/LANG_CLANG_TIDY.html)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用`clang-tidy`的目标属性：[https://cmake.org/cmake/help/latest/prop_tgt/LANG_CLANG_TIDY.html](https://cmake.org/cmake/help/latest/prop_tgt/LANG_CLANG_TIDY.html)
- en: 'The `Valgrind` manual: [https://www.valgrind.org/docs/manual/manual-core.html](https://www.valgrind.org/docs/manual/manual-core.html)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Valgrind`手册：[https://www.valgrind.org/docs/manual/manual-core.html](https://www.valgrind.org/docs/manual/manual-core.html)'
- en: Leave a review!
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发表评论！
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below to get a free eBook of your choice.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过在亚马逊上留下评论，帮助像您一样的读者。扫描下面的二维码，获取您选择的免费电子书。
- en: '![](img/Review_Copy.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Review_Copy.png)'
