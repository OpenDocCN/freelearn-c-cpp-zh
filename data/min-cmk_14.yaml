- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Supporting Tools and Next Steps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持工具和后续步骤
- en: In this chapter, we’re going to cover some of the fantastic tools that complement
    the core CMake ecosystem to make developing with CMake easier, faster, and more
    enjoyable. There are some brilliant projects that extend and enhance CMake, and
    knowing about them can make a significant difference in your development experience.
    We’ll also look at some other popular **integrated development environments**
    (**IDEs**) and see how to get them to play nicely with CMake.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一些与CMake核心生态系统相辅相成的出色工具，帮助使CMake开发更加容易、快速和愉快。许多出色的项目扩展和增强了CMake，了解这些工具可以显著改善你的开发体验。我们还将介绍一些其他流行的**集成开发环境**（**IDE**），并了解如何让它们与CMake兼容。
- en: In addition to this, we’ll cover some recommended practices when it comes to
    developing C/C++ applications and how CMake can help with this, as well as some
    final suggestions on structuring our CMake scripts. Finally, we’ll look at the
    road ahead and introduce some CMake topics we didn’t have the opportunity to cover
    in this book and where you can go to learn more about them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们还将介绍一些关于开发C/C++应用程序的推荐实践，以及CMake如何帮助实现这些目标，最后还会提供一些关于如何组织CMake脚本的建议。最后，我们将展望未来，介绍一些本书未能涵盖的CMake话题，并告诉你可以在哪里深入学习这些内容。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将覆盖以下主要内容：
- en: CMake Tools for Visual Studio Code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code的CMake工具
- en: Visual Studio Code extras
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code附加功能
- en: CMake with other IDEs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake与其他IDE的配合
- en: C/C++ build recommendations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C/C++构建建议
- en: CMake script structure
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake脚本结构
- en: Future topics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来的主题
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along, please ensure you have met the requirements outlined in [*Chapter
    1*](B21152_01.xhtml#_idTextAnchor019), *Getting Started*. These include the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本书的内容，请确保你已经满足[*第1章*](B21152_01.xhtml#_idTextAnchor019)《入门》中列出的要求。包括以下内容：
- en: A Windows, Mac, or Linux machine with an up-to-date **operating** **system**
    (**OS**)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台运行最新**操作系统**（**OS**）的Windows、Mac或Linux机器
- en: A working C/C++ compiler (a system default is recommended for each platform
    if you don’t already have this)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款可用的C/C++编译器（如果你尚未安装，建议使用平台的系统默认编译器）
- en: 'The code examples in this chapter can be found by following this link: https://github.com/PacktPublishing/Minimal-CMake.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可以通过以下链接找到：https://github.com/PacktPublishing/Minimal-CMake。
- en: CMake Tools for Visual Studio Code
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code的CMake工具
- en: At the outset of this book, we recommended using **Visual Studio Code** as the
    editor of choice to ensure a consistent experience whether you’re developing on
    Windows, macOS, or Linux. This is completely optional, but there’s a lot to like
    when it comes to using CMake with Visual Studio Code. In this section, we’ll discuss
    how best to use the examples from this book and show how to configure, build,
    and debug our projects all from within Visual Studio Code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书开头，我们推荐使用**Visual Studio Code**作为首选编辑器，以确保无论你是在Windows、macOS还是Linux上开发，都能获得一致的体验。这完全是可选的，但使用CMake与Visual
    Studio Code结合起来有很多优点。在本节中，我们将讨论如何最好地使用本书中的示例，并展示如何在Visual Studio Code中配置、构建和调试项目。
- en: If you follow the steps in [*Chapter 1*](B21152_01.xhtml#_idTextAnchor019),
    *Getting Started*, in the *Visual Studio Code setup* section, you’ll already have
    **CMake Tools** installed as part of the **C/C++** **Extension Pack**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照[*第1章*](B21152_01.xhtml#_idTextAnchor019)《入门》中的*Visual Studio Code设置*部分进行操作，你将已经通过**C/C++扩展包**安装了**CMake
    Tools**。
- en: Navigating the Minimal CMake source code
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航Minimal CMake源代码
- en: 'To be able to navigate around the *Minimal CMake* source code, it is recommended
    to open a Visual Studio Code project from the root of the repository. This can
    be achieved by cloning the repository, and then opening Visual Studio Code from
    that directory:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在*Minimal CMake*源代码中进行导航，建议从仓库的根目录打开一个Visual Studio Code项目。这可以通过克隆仓库，然后从该目录打开Visual
    Studio Code来实现：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You could also change directory to the `mc` folder (`cd mc`), and then run `code
    .` to open Visual Studio Code from there.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以切换到`mc`文件夹（`cd mc`），然后运行`code .`从该目录打开Visual Studio Code。
- en: This is great for navigating the examples and comparing differences and updates
    between each of the parts, but it’s unfortunately not ideal for building and running
    the individual examples. To get a more representative experience of using CMake
    Tools from Visual Studio Code for configuring, building, and debugging the examples,
    it’s easier to open a new instance of Visual Studio Code for each directory that
    contains a root-level `CMakeLists.txt` file. For example, in the case of some
    of the later examples, from the terminal, you would change directory to `ch10/part-5/app`,
    and then type `code .` from that folder (or simply type `code ch10/part-5/app`
    if you were at the root of the repository); this is how you would normally work
    with a CMake project. The accompanying source code is made up of many nested projects
    evolving over time; each `ch<n>/part-<n>` `README.md` file lists the root folders
    to open for reference.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于浏览示例以及比较各部分之间的差异和更新非常有用，但遗憾的是，它不适合构建和运行各个示例。为了获得更具代表性的使用 CMake Tools 在 Visual
    Studio Code 中配置、构建和调试示例的体验，最好为每个包含根级 `CMakeLists.txt` 文件的目录打开一个新的 Visual Studio
    Code 实例。例如，在某些后续示例的情况下，你可以在终端中切换到 `ch10/part-5/app` 目录，然后从该文件夹输入 `code .` （或者如果你在仓库根目录，可以直接输入
    `code ch10/part-5/app`）；这就是你通常与 CMake 项目合作的方式。随附的源代码由多个随着时间演变的嵌套项目组成；每个 `ch<n>/part-<n>`
    的 `README.md` 文件列出了要打开的根文件夹作为参考。
- en: 'In addition to the workflow described previously, Visual Studio Code also supports
    multi-root workspaces (see [https://code.visualstudio.com/docs/editor/multi-root-workspaces](https://code.visualstudio.com/docs/editor/multi-root-workspaces)
    for more information). To activate multi-root workspaces, you can either use the
    **Workspaces: Add Folder to Workspace...** option from the Command Palette, or
    navigate to the **File** menu and select **Add Folder** **to Workspace...**.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前描述的工作流外，Visual Studio Code 还支持多根工作区（有关更多信息，请参见 [https://code.visualstudio.com/docs/editor/multi-root-workspaces](https://code.visualstudio.com/docs/editor/multi-root-workspaces)）。要激活多根工作区，你可以通过命令面板使用
    **工作区：添加文件夹到工作区…** 选项，或者导航到 **文件** 菜单并选择 **添加文件夹到工作区...**。
- en: '![Figure 11.1: The Add Folder to Workspace… option](img/B21152_11_1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1：添加文件夹到工作区… 选项](img/B21152_11_1.jpg)'
- en: 'Figure 11.1: The Add Folder to Workspace… option'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：添加文件夹到工作区… 选项
- en: 'You can then select a folder containing the `CMakeLists.txt` file that you’d
    like to run the example from (in the later examples in the book, this will usually
    be the `app` folder). The following is an example showing the workspace view in
    Visual Studio Code **EXPLORER**:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以选择一个包含 `CMakeLists.txt` 文件的文件夹，在该文件夹中运行示例（在书中的后续示例中，通常是 `app` 文件夹）。以下是一个示例，展示了
    Visual Studio Code **EXPLORER** 中的工作区视图：
- en: "![Figure 11.2: Multi-workspace view in \uFEFFEXPLORER](img/B21152_11_2.jpg)"
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2：EXPLORER 中的多工作区视图](img/B21152_11_2.jpg)'
- en: 'Figure 11.2: Multi-workspace view in EXPLORER'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：EXPLORER 中的多工作区视图
- en: It’s possible to save a workspace and track the folders that are part of it.
    If you choose to do this, a new file will be created with the same name as the
    workspace and the `.code-workspace` file extension. It’s also possible to add
    a display name for folders, which can be useful in helping identify them if multiple
    folders at different positions in the hierarchy share the same name (in the example
    before, the bottom two sub-folders would just be called `app` without the name
    override).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以保存工作区并跟踪其中的文件夹。如果选择这样做，一个新文件将会以与工作区同名并带有 `.code-workspace` 文件扩展名的方式创建。还可以为文件夹添加显示名称，这在多个位置的文件夹具有相同名称时尤其有用（例如，之前提到的底部两个子文件夹，如果没有名称覆盖，它们将被称为
    `app`）。
- en: 'The following is the content of the `.code-workspace` file from the workspace
    displayed previously:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是之前显示的工作区中 `.code-workspace` 文件的内容：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The Visual Studio Code CMake Tools extension also respects multi-root workspaces
    and makes it possible to switch between workspaces when building using the **PROJECT
    OUTLINE** section of the CMake Tools extension in the sidebar (just click the
    gear icon to set the active workspace). Multi-root workspaces can be very convenient
    for keeping multiple projects in a single repository together.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 的 CMake Tools 扩展也支持多根工作区，并使得通过 CMake Tools 扩展侧边栏中的 **项目大纲**
    部分在工作区之间切换成为可能（只需点击齿轮图标以设置活动工作区）。多根工作区对于将多个项目保存在一个单一仓库中非常方便。
- en: Configuring, building, and debugging
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置、构建和调试
- en: 'From within Visual Studio Code, say you’ve opened a project view for a specific
    folder, for example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，如果你打开了某个文件夹的项目视图，例如：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Pressing `F1` will open the Command Palette. From there, typing CMake will
    display all the CMake commands available through the Visual Studio Code CMake
    Tools extension. There, you can search for commands such as `configure` and `build`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 `F1` 会打开命令面板。在命令面板中输入 CMake，会显示所有通过 Visual Studio Code CMake 工具扩展提供的 CMake
    命令。在那里，你可以搜索诸如 `configure` 和 `build` 等命令：
- en: '![](img/B21152_11_3.jpg)![](img/B21152_11_4.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21152_11_3.jpg)![](img/B21152_11_4.jpg)'
- en: 'Figure 11.3: CMake Tools configure and build commands'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：CMake 工具的配置和构建命令
- en: 'There is also a very convenient CMake Tools panel available in the Visual Studio
    Code sidebar with an array of options to allow you to configure, build, test,
    debug, and launch the application all from within Visual Studio Code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 的侧边栏中，还有一个非常方便的 CMake 工具面板，提供了一系列选项，允许你在 Visual Studio
    Code 内部配置、构建、测试、调试和启动应用程序：
- en: '![Figure 11.4: The Visual Studio Code CMake Tools panel](img/B21152_11_5.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4：Visual Studio Code 的 CMake 工具面板](img/B21152_11_5.jpg)'
- en: 'Figure 11.4: The Visual Studio Code CMake Tools panel'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：Visual Studio Code 的 CMake 工具面板
- en: Hovering over each row will display an icon on the right that can be pressed
    to perform that specific action. This is much simpler than configuring a specific
    task in the `launch.json` file within Visual Studio Code, which is needed for
    C/C++ applications not using CMake.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将鼠标悬停在每一行时，右侧会显示一个可以按下的图标，以执行相应的操作。这比在 Visual Studio Code 中为没有使用 CMake 的 C/C++
    应用程序配置 `launch.json` 文件要简单得多。
- en: 'It’s possible users on macOS may experience an issue with the `lldb-mi`. The
    workaround for this is to provide `miDebuggerPath` in your workspace or user `settings.json`
    file. The following is an example path; the exact location may differ slightly
    in your case:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 macOS 的用户可能会遇到 `lldb-mi` 的问题。解决方法是在你的工作区或用户的 `settings.json` 文件中提供 `miDebuggerPath`。以下是一个示例路径，具体位置可能会有所不同：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To open the `settings.json` file, simply hit `F1` to bring up the Command Palette,
    then search `settings`, and select either **Preferences: Open User Settings (JSON)**
    or **Preferences: Open Workspace Settings (JSON)** depending on where you’d like
    to set the option (system-wide, or just for this workspace).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开 `settings.json` 文件，只需按下 `F1` 以打开命令面板，然后搜索 `settings`，并选择 **首选项：打开用户设置（JSON）**
    或 **首选项：打开工作区设置（JSON）**，具体取决于你想在哪设置选项（全系统，或仅此工作区）。
- en: If, for whatever reason, the CMake `launch.json` file and manually set the executable
    location and working directory. To achieve this, go to the **RUN AND DEBUG** panel
    in Visual Studio Code, and press **create a** **launch.json file**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果因为某些原因，CMake 的 `launch.json` 文件和手动设置可执行文件位置以及工作目录，操作方法是进入 Visual Studio Code
    的 **运行与调试** 面板，按下 **创建一个** **launch.json 文件**。
- en: '![Figure 11.5: The Visual Studio Code RUN AND DEBUG panel](img/B21152_11_6.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5：Visual Studio Code 的运行与调试面板](img/B21152_11_6.jpg)'
- en: 'Figure 11.5: The Visual Studio Code RUN AND DEBUG panel'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：Visual Studio Code 的运行与调试面板
- en: Either `launch.json` will open, or the Command Palette will open with an option
    to select a debugger. This will vary depending on the platform you’re on. If you
    configure and build using CMake first, then a C++ debugger will be displayed (if
    there’s no build folder, only the default options will be present).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 会打开 `launch.json`，或者打开命令面板，提供选择调试器的选项。这将根据你所使用的平台有所不同。如果你先使用 CMake 配置和构建，那么会显示
    C++ 调试器（如果没有构建文件夹，则只会显示默认选项）。
- en: 'The `launch.json` file should initially look something like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`launch.json` 文件最初应如下所示：'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is a button toward the lower right of the screen called **Add Configuration...**;
    pressing it will display a list of debug options. Select the most appropriate
    option depending on your platform, for example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕右下角有一个名为 **添加配置...** 的按钮，点击它会显示调试选项列表。根据你的平台选择最合适的选项，例如：
- en: '**macOS**: **{} C/C++: (****lldb) Launch**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**macOS**：**{} C/C++：(****lldb) 启动**'
- en: '**Window**s: **{} C/C++: (****Windows) Launch**'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows**：**{} C/C++：(****Windows) 启动**'
- en: '**Linux**: **{} C/C++: (****gdb) Launch**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux**：**{} C/C++：(****gdb) 启动**'
- en: 'The generated configuration then needs two minor changes: `"program"` needs
    to be set to the location of your executable and `"cwd"` should be set to the
    working directory you’d like the application to run from (in most cases, this
    will be the same as `${workspaceFolder}`).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的配置然后需要做两个小的修改：`"program"` 需要设置为可执行文件的位置，`"cwd"` 应该设置为您希望应用程序运行的工作目录（在大多数情况下，这将与
    `${workspaceFolder}` 相同）。
- en: 'An example macOS configuration is shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个 macOS 配置示例：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this change, pressing *F5* or the **Start Debugging** play symbol from
    the **RUN AND DEBUG** sidebar panel will launch the application and allow you
    to place breakpoints and step through your code. Next, we’ll look at how CMake
    presets integrate with Visual Studio Code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，按下 *F5* 或者在 **RUN AND DEBUG** 侧边栏面板中点击 **Start Debugging** 播放符号将启动应用程序，并允许您设置断点并逐步调试代码。接下来，我们将看看
    CMake 预设如何与 Visual Studio Code 集成。
- en: Visual Studio Code and CMake presets
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio Code 和 CMake 预设
- en: Visual Studio Code handles the configure and build stages similarly to how CMake
    does natively from the command line (making a best guess about the generator and
    choosing some sensible defaults for things such as the `build` folder, which,
    by default, is set to `${workspaceFolder}/build`).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 在配置和构建阶段的处理方式与 CMake 从命令行本地处理方式类似（根据生成器做出最佳猜测，并为诸如 `build`
    文件夹之类的事项选择一些合理的默认值，默认情况下该文件夹设置为 `${workspaceFolder}/build`）。
- en: 'The good news is Visual Studio Code works even better with projects taking
    advantage of CMake presets. If a `CMakePresets.json` file is present at the root
    of the project, when pressing the configure button from within the CMake Tools
    extension in Visual Studio Code, the Command Palette will prompt you to select
    a preset first. It also offers the choice to create a brand-new preset should
    you wish to. Selecting a preset will then configure the project using all the
    settings defined in that preset. The output is displayed in the **OUTPUT** window,
    usually displayed at the bottom of the Visual Studio Code window:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Visual Studio Code 在利用 CMake 预设的项目中表现得更好。如果项目根目录下存在 `CMakePresets.json`
    文件，当您在 Visual Studio Code 中通过 CMake Tools 扩展点击配置按钮时，命令面板会提示您首先选择一个预设。它还提供了创建全新预设的选项。如果选择了预设，项目将使用该预设中定义的所有设置进行配置。输出会显示在
    **OUTPUT** 窗口中，通常位于 Visual Studio Code 窗口的底部：
- en: '![Figure 11.6: Visual Studio Code CMake – configuring the output](img/B21152_11_7.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6: Visual Studio Code CMake – 配置输出](img/B21152_11_7.jpg)'
- en: 'Figure 11.6: Visual Studio Code CMake – configuring the output'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11.6: Visual Studio Code CMake – 配置输出'
- en: Clicking the **Build** icon (appearing next to the Build heading in the CMake
    Tools extension), will then build the application for us, and if we click the
    play icon (displayed when hovering over the **Debug** or **Launch** headings in
    the CMake Tools extension), the application will start. **Debug** is particularly
    useful as it’s possible to then set breakpoints in Visual Studio Code and use
    the **VARIABLES** and **WATCH** window to see the state of variables in your program.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **Build** 图标（出现在 CMake Tools 扩展中的 Build 标题旁边），然后会为我们构建应用程序，如果点击播放图标（当悬停在
    CMake Tools 扩展中的 **Debug** 或 **Launch** 标题上时显示），应用程序将启动。**Debug** 功能特别有用，因为您可以在
    Visual Studio Code 中设置断点，并使用 **VARIABLES** 和 **WATCH** 窗口查看程序中变量的状态。
- en: Interestingly, the `enable_testing()` command be added to our `CMakeLists.txt`
    files (just after `include(CTest)` is fine). Using `ctest` from the command line
    works without it, but for things to work nicely with Visual Studio Code, it’s
    needed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`enable_testing()` 命令需要添加到我们的 `CMakeLists.txt` 文件中（紧接着 `include(CTest)`
    后添加即可）。虽然从命令行使用 `ctest` 可以正常工作，但为了使 Visual Studio Code 中的功能顺利运行，这个命令是必须的。
- en: When it comes to packaging, CMake Tools unfortunately doesn’t respect the `"condition"`
    property we used to hide packaging configurations for other platforms. This means
    the packaging presets will be missing when viewed from CMake Tools. To restore
    them, simply remove the `"condition"` blocks from the package presets in our `CMakePresets.json`
    file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在打包方面，不幸的是，CMake Tools 不会尊重我们用来隐藏其他平台打包配置的 `"condition"` 属性。这意味着在 CMake Tools
    中查看时，打包预设将会丢失。要恢复它们，只需从 `CMakePresets.json` 文件中的包预设中删除 `"condition"` 块。
- en: 'For example, you’d remove the following from the `windows` package preset:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您需要从 `windows` 包预设中移除以下内容：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With these removed, you’ll see the package preset appear as expected:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 删除这些内容后，您将看到包预设按预期出现：
- en: '![Figure 11.7: Package preset listed in CMake Tools](img/B21152_11_8.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7: CMake Tools 中列出的包预设](img/B21152_11_8.jpg)'
- en: 'Figure 11.7: Package preset listed in CMake Tools'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：CMake Tools 中列出的包预设
- en: 'Clicking the pencil icon will let you then select from one of the available
    presets:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 点击铅笔图标，你将可以选择一个可用的预设：
- en: '![Figure 11.8: Selecting a package preset from the Command Palette](img/B21152_11_9.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8：从命令面板选择包预设](img/B21152_11_9.jpg)'
- en: 'Figure 11.8: Selecting a package preset from the Command Palette'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：从命令面板选择包预设
- en: This is a small inconvenience and hopefully will be fixed in a future version
    of CMake Tools. For an example of our project with the small tweaks to make it
    fully compatible with CMake Tools, please see `ch11/part-1/app`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小小的不便，希望在未来版本的 CMake Tools 中修复。有关我们项目的示例，已做了小调整以使其完全兼容 CMake Tools，请参见`ch11/part-1/app`。
- en: Debugging CMakeLists.txt files
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试 CMakeLists.txt 文件
- en: 'Another excellent feature worth briefly mentioning is support for debugging
    `CMakeLists.txt` files. Most of the time, your `CMakeLists.txt` files should be
    simple and declarative enough to not call for debugging, but there’ll undoubtedly
    be cases where stepping through the code to see what’s happening can be incredibly
    useful. After opening Visual Studio Code from a directory containing a `CMakeLists.txt`
    file, open the Command Palette (*F1* or *Cmd* + *Shift* + *P* on macOS, *Ctrl*
    + *Shift* + *P* on Windows/Linux), and search for `CMake Debugger`; this will
    present the **CMake: Configure with CMake Debugger** option. Prior to this, if
    you add some breakpoints (to add breakpoints, click in the left-hand margin of
    the Visual Studio Code text editor, just to the left of the line numbers, or just
    right of the sidebar), execution will stop there and you can then use the **VARIABLES**
    and **WATCH** window to better understand the state of the script as it’s processed.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得简要提及的优秀功能是支持调试`CMakeLists.txt`文件。大多数情况下，`CMakeLists.txt`文件应该足够简单和声明性，不需要调试，但无疑会有一些情况，通过逐步执行代码来查看发生了什么非常有用。打开包含`CMakeLists.txt`文件的目录中的
    Visual Studio Code 后，打开命令面板（*F1* 或 *Cmd* + *Shift* + *P* 在 macOS 上，*Ctrl* + *Shift*
    + *P* 在 Windows/Linux 上），搜索`CMake Debugger`；这将显示**CMake：使用 CMake 调试器配置**选项。在此之前，如果你添加了一些断点（要添加断点，点击
    Visual Studio Code 文本编辑器的左侧边距，位于行号左侧，或位于侧边栏的右侧），执行将在此停止，你可以使用**变量**和**观察**窗口更好地了解脚本处理时的状态。
- en: '*Figure 11**.9* shows an example of what you can expect. In it, we’ve stopped
    on a breakpoint inside an if `APPLE` check. We can see the value of several watch
    variables that have been added, and the **Locals** section contains all relevant
    cache variables, local variables, directories, and targets.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11.9* 显示了你可以期待的一个例子。在其中，我们在一个 `APPLE` 检查的断点处停止。我们可以看到已经添加的几个观察变量的值，**局部**部分包含所有相关的缓存变量、局部变量、目录和目标。'
- en: '![Figure 11.9: Visual Studio Code CMake debugger](img/B21152_11_10.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9：Visual Studio Code CMake 调试器](img/B21152_11_10.jpg)'
- en: 'Figure 11.9: Visual Studio Code CMake debugger'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：Visual Studio Code CMake 调试器
- en: Note that debugging our main `CMakeLists.txt` file doesn’t work quite as well
    with super builds, as the call to our `ExternalProject_Add` command won’t process
    our file directly. To work around this, simply create another regular build (using
    one of the regular CMake presets, such as `multi-ninja`) and then debug using
    that instead.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，调试我们的主`CMakeLists.txt`文件在超级构建中并不完全有效，因为对`ExternalProject_Add`命令的调用无法直接处理我们的文件。为了解决这个问题，只需创建另一个常规构建（使用常规
    CMake 预设之一，如`multi-ninja`），然后使用该构建进行调试。
- en: You can find out more information about CMake Tools by visiting [https://github.com/microsoft/vscode-cmake-tools](https://github.com/microsoft/vscode-cmake-tools)
    and exploring the documentation. More information can also be found by going to
    [https://code.visualstudio.com/docs/cpp/cmake-linux](https://code.visualstudio.com/docs/cpp/cmake-linux)
    for another perspective on getting set up with CMake and Visual Studio Code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问[https://github.com/microsoft/vscode-cmake-tools](https://github.com/microsoft/vscode-cmake-tools)并浏览文档来了解更多关于
    CMake Tools 的信息。还可以通过访问[https://code.visualstudio.com/docs/cpp/cmake-linux](https://code.visualstudio.com/docs/cpp/cmake-linux)来获取另一个关于如何设置
    CMake 和 Visual Studio Code 的视角。
- en: Visual Studio Code extras
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio Code 附加功能
- en: This section covers an assortment of useful tools and features closely related
    to Visual Studio Code and CMake that can make development easier and may come
    in useful while working on future projects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了一些与 Visual Studio Code 和 CMake 密切相关的有用工具和功能，这些工具和功能可以简化开发，并且在未来的项目中可能会非常有用。
- en: Syntax highlighting
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法高亮
- en: The first is a useful extension that provides syntax highlighting in `CMakeLists.txt`
    and `.cmake` files. The extension is simply called `twxs.cmake`. It can either
    be downloaded from [https://marketplace.visualstudio.com/items?itemName=twxs.cmake](https://marketplace.visualstudio.com/items?itemName=twxs.cmake),
    or from within the Visual Studio Code extension manager in the sidebar. It not
    only provides syntax highlighting but also useful snippets and completions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个有用的扩展，它提供了 `CMakeLists.txt` 和 `.cmake` 文件的语法高亮。该扩展名为 `twxs.cmake`。你可以从
    [https://marketplace.visualstudio.com/items?itemName=twxs.cmake](https://marketplace.visualstudio.com/items?itemName=twxs.cmake)
    下载，或者从 Visual Studio Code 的侧边栏扩展管理器中下载。它不仅提供语法高亮，还提供有用的代码片段和自动补全功能。
- en: Generating compile_commands.json
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成 compile_commands.json
- en: 'When using either Ninja or Make generators, a cache variable can be provided
    to CMake called `CMAKE_EXPORT_COMPILE_COMMANDS` to enable the generation of a
    file called `compile_commands.json`. `CMAKE_EXPORT_COMPILE_COMMANDS` can be added
    to a CMake preset or it can be passed at the command line when running the configure
    step, for example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Ninja 或 Make 生成器时，可以向 CMake 提供一个缓存变量，叫做 `CMAKE_EXPORT_COMPILE_COMMANDS`，以启用生成名为
    `compile_commands.json` 的文件。`CMAKE_EXPORT_COMPILE_COMMANDS` 可以添加到 CMake 预设中，也可以在运行配置步骤时通过命令行传递，例如：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '{'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"configurations": ['
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '"configurations": ['
- en: '{'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '...'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '"compileCommands": "${workspaceFolder}/build/multi-ninja/compile_commands.json"'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '"compileCommands": "${workspaceFolder}/build/multi-ninja/compile_commands.json"'
- en: '}'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '],'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '"version": 4'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '"version": 4'
- en: '}'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: python3 -m pip install cmakelang
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m pip install cmakelang
- en: 'python3 -m pip install pyyaml # required by cmake-format'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'python3 -m pip install pyyaml # cmake-format 所需'
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: export PATH="$HOME/.local/bin:$PATH"
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: export PATH="$HOME/.local/bin:$PATH"
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: cmake-format CMakeLists.txt -i
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: cmake-format CMakeLists.txt -i
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'line_width: 80'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'line_width: 80'
- en: 'tab_size: 2'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'tab_size: 2'
- en: 'enable_sort: True'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'enable_sort: True'
- en: 'dangle_parens: False'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 'dangle_parens: False'
- en: 'dangle_align: ''prefix'''
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'dangle_align: ''prefix'''
- en: 'command_case: ''canonical'''
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'command_case: ''canonical'''
- en: 'keyword_case: ''upper'''
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 'keyword_case: ''upper'''
- en: 'line_ending: ''auto'''
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'line_ending: ''auto'''
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'cmake --preset vs # option 1'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'cmake --preset vs # 选项 1'
- en: 'cmake -B build/vs -G "Visual Studio 17" # option 2'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'cmake -B build/vs -G "Visual Studio 17" # 选项 2'
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: cmake -B build/vs -G "Visual Studio 17" -DSUPERBUILD=ON
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: cmake -B build/vs -G "Visual Studio 17" -DSUPERBUILD=ON
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: set_property(
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: set_property(
- en: DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
- en: PROPERTY VS_ specific ones.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: PROPERTY VS_ 特定项。
- en: 'To build and launch the application, we can use the **Local Windows Debugger**
    option at the top center of the screen or press *F5* (to build without running,
    use *F7*):'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要构建并启动应用程序，我们可以使用屏幕顶部中央的 **本地 Windows 调试器** 选项，或者按 *F5*（如果只构建不运行，使用 *F7*）：
- en: '![Figure 11.14: Visual Studio configuration and launch options](img/B21152_11_15.jpg)'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 11.14：Visual Studio 配置和启动选项](img/B21152_11_15.jpg)'
- en: 'Figure 11.14: Visual Studio configuration and launch options'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 11.14：Visual Studio 配置和启动选项
- en: Remember to pick the configuration that maps to the configuration we built our
    third-party dependencies for if using a later part of this book as an example.
    You may experience linker errors if you build your dependencies in `Debug` and
    then try to build the application in `Release` (or vice versa).
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记得选择与我们为第三方依赖项构建的配置相匹配的配置，如果你使用本书后面的示例。若你在 `Debug` 模式下构建依赖项，然后尝试在 `Release`
    模式下构建应用程序（或反之），可能会遇到链接器错误。
- en: 'Once everything has finished building and you can run the executable, in all
    examples from [*Chapter 2*](B21152_02.xhtml#_idTextAnchor032) to [*Chapter 9*](B21152_09.xhtml#_idTextAnchor195),
    you’ll see the following error message printed:'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦所有构建完成，并且你可以运行可执行文件，在从 [*第 2 章*](B21152_02.xhtml#_idTextAnchor032) 到 [*第 9
    章*](B21152_09.xhtml#_idTextAnchor195) 的所有示例中，你将看到以下错误信息：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is because the application is looking for the resource (shader) files in
    the `build/vs/<config>` folder, not the root folder of the project where we’d
    normally run things from the terminal.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为应用程序正在 `build/vs/<config>` 文件夹中寻找资源（着色器）文件，而不是项目的根文件夹，通常我们会从终端在其中运行程序。
- en: 'We saw one way how to address this in [*Chapter 10*](B21152_10.xhtml#_idTextAnchor214),
    *Packaging the Project for Sharing*, but if we’re not at that stage yet, a useful
    workaround is to provide a CMake cache variable called `CMAKE_VS_DEBUGGER_WORKING_DIRECTORY`
    to set the location of the working directory within Visual Studio. This can be
    achieved by setting `CMAKE_VS_DEBUGGER_WORKING_DIRECTORY` for the whole project,
    or by adding the following command to our `CMakeLists.txt` file for a particular
    target:'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在 [*第 10 章*](B21152_10.xhtml#_idTextAnchor214)中看到了解决这一问题的一种方式，*为共享项目打包*，但是如果我们还没有达到那个阶段，一个有用的解决方法是提供一个名为
    `CMAKE_VS_DEBUGGER_WORKING_DIRECTORY` 的 CMake 缓存变量，用于设置 Visual Studio 中工作目录的位置。这可以通过为整个项目设置
    `CMAKE_VS_DEBUGGER_WORKING_DIRECTORY`，或者为特定目标在 `CMakeLists.txt` 文件中添加以下命令来实现：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'cmake --preset xcode # option 1'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'cmake --preset xcode # 选项 1'
- en: 'cmake -B build/xcode -G Xcode # option 2'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'cmake -B build/xcode -G Xcode # 选项 2'
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: set_target_properties(
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: set_target_properties(
- en: ${PROJECT_NAME} PROPERTIES
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ${PROJECT_NAME} PROPERTIES
- en: XCODE_GENERATE_SCHEME TRUE
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: XCODE_GENERATE_SCHEME TRUE
- en: XCODE_SCHEME_WORKING_DIRECTORY ${CMAKE_SOURCE_DIR})
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: XCODE_SCHEME_WORKING_DIRECTORY ${CMAKE_SOURCE_DIR})
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: set_target_properties(
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: set_target_properties(
- en: ${PROJECT_NAME}
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ${PROJECT_NAME}
- en: PROPERTIES
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: PROPERTIES
- en: CXX_STANDARD_REQUIRED ON
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: CXX_STANDARD_REQUIRED ON
- en: 'CMakeLists.txt file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: CMakeLists.txt 文件：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As well as this, it’s also generally recommended to enable as many warnings
    as possible to help catch errors early in the coding process (this can help catch
    things such as uninitialized variable usage and out-of-bounds array access, as
    well as many other things). To enable these warnings, we need to set various compiler
    flags depending on the compiler we’re using. We can use CMake generator expressions
    to help with this and set the correct warnings for whichever compiler we’re using,
    be that **Microsoft Visual C++** (**MSVC**), **GNU Compiler Collection** (**GCC**),
    or Clang.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，通常建议启用尽可能多的警告，以帮助在编码过程中尽早捕捉错误（这有助于捕获未初始化变量的使用、数组越界访问等问题，以及许多其他问题）。为了启用这些警告，我们需要根据所使用的编译器设置不同的编译器标志。我们可以使用
    CMake 生成器表达式来帮助实现这一点，并为所使用的编译器（无论是**Microsoft Visual C++**（**MSVC**）、**GNU 编译器集合**（**GCC**）还是
    Clang）设置正确的警告。
- en: 'The following code is a snippet of what this might look like:'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码片段展示了可能的实现方式：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the snippet above, we use a CMake variable to hold the various compile flags
    we’d like to see, and then apply them using the `target_compile_options` command.
    The warnings you decide to opt in or out of will depend on the project and coding
    practices you’d like to adopt. There’s an excellent list of warnings and what
    they mean available from the `cppbestpractices` GitHub page ([https://github.com/cpp-best-practices/cppbestpractices/blob/master/02-Use_the_Tools_Available.md#compilers](https://github.com/cpp-best-practices/cppbestpractices/blob/master/02-Use_the_Tools_Available.md#compilers)).
    To see an example of the full set of warnings, see `ch11/part-2/app/CMakeLists.txt`.
    Try compiling the project to see how many warnings are detected in the *Minimal
    CMake* example code (there are quite a few, for demonstration purposes, of course).
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上面的片段中，我们使用 CMake 变量来保存我们希望看到的各种编译标志，然后通过 `target_compile_options` 命令应用它们。你决定启用或禁用的警告将取决于你希望采用的项目和编码实践。从
    `cppbestpractices` GitHub 页面（[https://github.com/cpp-best-practices/cppbestpractices/blob/master/02-Use_the_Tools_Available.md#compilers](https://github.com/cpp-best-practices/cppbestpractices/blob/master/02-Use_the_Tools_Available.md#compilers)）可以找到一个关于警告及其含义的优秀列表。要查看完整的警告集示例，请参见
    `ch11/part-2/app/CMakeLists.txt`。尝试编译项目，看看在 *Minimal CMake* 示例代码中可以检测到多少警告（当然，这些警告的数量是为了演示目的）。
- en: Unity builds
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Unity 构建
- en: CMake offers a build setting called `.c` or `.cpp` files) and concatenating
    them together. This is done using the regular C/C++ preprocessor `#include` directive.
    CMake will generate these files dynamically and compile them instead of the existing
    `.c/.cpp` files. In our `app` example project, a single unity `.cpp` file is created
    called `unity_0_cxx.cxx`, which includes all `.cpp` files in our project (this
    file can be found in the `build` folder under `CMakeFiles/minimal-cmake_game-of-life_window.dir/Unity`).
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: CMake 提供了一种构建设置，称为 `.c` 或 `.cpp` 文件，并将它们连接在一起。这是通过常规的 C/C++ 预处理器 `#include`
    指令完成的。CMake 将动态生成这些文件并编译它们，而不是编译现有的 `.c/.cpp` 文件。在我们的 `app` 示例项目中，创建了一个名为 `unity_0_cxx.cxx`
    的单一统一 `.cpp` 文件，它包含了项目中的所有 `.cpp` 文件（该文件可以在 `build` 文件夹下的 `CMakeFiles/minimal-cmake_game-of-life_window.dir/Unity`
    目录中找到）。
- en: To enable unity builds, pass `-DCMAKE_UNITY_BUILD=ON` at the command line (or
    feel free to create a unity CMake preset to do so). One of the downsides to unity
    builds is they break a core rule in C/C++, and that’s that a `.c` or `.cpp` file
    can define values with internal linkage and those definitions are private. This
    means there’s no way they can conflict with any other files as they’re compiled
    individually (this applies to anonymous namespaces as well). When unity builds
    are enabled however, and these source files are grouped together, if two variables
    or functions happen to share a name, things will break (you’ll most likely get
    a multiply defined symbol error). Unity builds can also cause the opposite problem,
    which is where silent dependencies are introduced between source files. Things
    might compile in a unity build if a `.cpp` file pulls in an `include` from an
    earlier `.cpp` file in the same unity file but then won’t compile on its own if
    that include is missing.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要启用 Unity 构建，可以在命令行中传递 `-DCMAKE_UNITY_BUILD=ON`（或者你可以创建一个 Unity CMake 预设来做到这一点）。Unity
    构建的一个缺点是它违反了 C/C++ 中的一个核心规则，那就是 `.c` 或 `.cpp` 文件可以定义具有内部链接的值，这些定义是私有的。这意味着它们不会与其他文件发生冲突，因为它们是单独编译的（这同样适用于匿名命名空间）。然而，当启用
    Unity 构建并且这些源文件被分组在一起时，如果两个变量或函数恰好共享相同的名称，程序将会出错（你最有可能会遇到重复定义符号的错误）。Unity 构建还可能导致相反的问题，即在源文件之间引入隐式依赖。如果
    `.cpp` 文件从同一 Unity 文件中的前一个 `.cpp` 文件引入了 `include`，那么它可能会在 Unity 构建中编译成功，但如果缺少该
    `include`，它就无法单独编译。
- en: Ensuring a project works with both unity builds and without can be a challenge
    unless building with each of them is enabled regularly. The one other downside
    to unity builds is in certain cases, their use can slow down iteration times.
    This is because making a change to one `.cpp` file will trigger recompilation
    of all other files in the same unity file it’s in (as that unity file is compiled
    as one). The change in build time will vary depending on the unity file grouping
    but can lead to longer compile times for minor changes. When working iteratively,
    it may be best to disable unity builds and only enable them for continuation integration
    builds to reduce external resource usage.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保项目在启用和不启用 Unity 构建的情况下都能正常工作可能是一个挑战，除非定期启用这两种构建方式。Unity 构建的另一个缺点是，在某些情况下，它们的使用可能会减慢迭代时间。这是因为对一个
    `.cpp` 文件进行更改时，会触发该文件所在的 Unity 文件中所有其他文件的重新编译（因为该 Unity 文件是作为一个整体进行编译的）。构建时间的变化取决于
    Unity 文件的分组方式，但对于小的更改，它可能会导致更长的编译时间。在迭代开发时，最好禁用 Unity 构建，并仅在持续集成构建时启用它们，以减少外部资源的使用。
- en: It is possible to fine-tune unity builds by excluding files that may not compile
    cleanly, but this can be a laborious process. Trying to enable unity builds for
    an already mature project can be a challenge; so, if you think you’d benefit from
    them, enabling them early in the development process is a wise move. It’s also
    important to measure and profile the time-saving, if any, to understand the impact
    they’re having. To learn more about unity builds, see [https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html](https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html).
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过排除可能无法干净编译的文件，确实可以微调 Unity 构建，但这可能是一个繁琐的过程。尝试为一个已经成熟的项目启用 Unity 构建可能会是一个挑战；因此，如果你认为它们会带来好处，最好在开发早期就启用它们。这也非常重要，要衡量和分析节省的时间（如果有的话），以了解它们带来的影响。要了解更多关于
    Unity 构建的信息，请参阅 [https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html](https://cmake.org/cmake/help/latest/prop_tgt/UNITY_BUILD.html)。
- en: CMake script structure
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: CMake 脚本结构
- en: To try and keep things simple, in *Minimal CMake*, we opted to limit the number
    of `CMakeLists.txt` files in the project to keep things mostly in one place (we
    at most have two `CMakeLists.txt` files per project, one for the third-party dependencies
    and one for the main application itself). This has some advantages; keeping things
    centralized can make things easier to find and make understanding a project easier,
    but as a project grows, dealing with a single, enormous file can become a maintenance
    nightmare (especially with larger teams).
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了尽量保持简单，在*最小化 CMake*中，我们选择将项目中的 `CMakeLists.txt` 文件数量限制在最少的数量，保持大部分内容集中在一个地方（我们每个项目最多有两个
    `CMakeLists.txt` 文件，一个用于第三方依赖，一个用于主应用程序）。这有一些优势；集中管理可以让查找内容和理解项目变得更容易，但随着项目的增长，处理一个庞大的单一文件可能会变成维护噩梦（尤其是对于大团队来说）。
- en: 'To help improve the separation of concerns and make things more modular, it’s
    possible to add `CMakeLists.txt` files to separate directories to handle building
    separate parts of the application and then bring them into the main build using
    `add_subdirectory`. For example, we could move our testing and packaging logic
    to their respective folders, and then include them from the top-level `CMakeLists.txt`
    file in the following way:'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了改善关注点的分离并使事情更加模块化，可以将`CMakeLists.txt`文件添加到不同的目录中，以处理应用程序的不同部分的构建，然后通过`add_subdirectory`将它们引入主构建中。例如，我们可以将测试和打包逻辑移动到各自的文件夹中，然后从顶层的`CMakeLists.txt`文件中按如下方式包含它们：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are some subtleties that we need to be aware of when making these kinds
    of changes though, in this case with the `tests` subfolder. By moving the logic
    from `app/CMakeLists.txt` to `app/tests/CMakeLists.txt`, any relative paths we’d
    been using will no longer work; so, we need to account for them (in our case,
    we need to update the path to `shaders-compiled.cmake` to include the full path
    by using `CMAKE_SOURCE_DIR` explicitly). We need to also remember to call `enable_testing()`
    from the top-level `CMakeLists.txt` file otherwise the tests in the subfolder
    won’t be discovered when using CTest.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，在进行这些更改时，我们需要注意一些细微之处，特别是在`tests`子文件夹的情况下。通过将逻辑从`app/CMakeLists.txt`移动到`app/tests/CMakeLists.txt`，我们之前使用的任何相对路径将不再有效；因此，我们需要处理这些路径（在我们的情况下，我们需要更新`shaders-compiled.cmake`的路径，并显式地使用`CMAKE_SOURCE_DIR`来包含完整路径）。我们还需要记住从顶层的`CMakeLists.txt`文件中调用`enable_testing()`，否则当使用CTest时，子文件夹中的测试将无法被发现。
- en: 'As we’re creating an executable target in the `tests` folder as well, by default,
    it will end up in a `tests` subfolder inside the `build` folder. This will break
    our `RPATH` loading; so, to keep things simple, we ensure it goes to the same
    output directory as before. We can achieve this by using the following command
    in `app/tests/CMakeLists.txt`:'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们也在`tests`文件夹中创建了一个可执行目标，默认情况下，它将位于`build`文件夹中的`tests`子文件夹中。这将破坏我们的`RPATH`加载；因此，为了保持简单，我们确保它进入与之前相同的输出目录。我们可以通过在`app/tests/CMakeLists.txt`中使用以下命令来实现这一点：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Fortunately for us, `CMAKE_BINARY_DIR` will work correctly if we’re using a
    single or multi-config generator (it will map to the correct config folder in
    the multi-config generator case). To see everything in context, please see `ch11/part-3/app`.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 幸运的是，如果我们使用单配置或多配置生成器，`CMAKE_BINARY_DIR`将会正确工作（在多配置生成器的情况下，它将映射到正确的配置文件夹）。要查看完整的上下文，请参阅`ch11/part-3/app`。
- en: We could go even further and move our install logic to a separate `CMakeLists.txt`
    file or extract our utility functions to new `.cmake` files and use `include`
    to bring them in. We can also use the interface target technique discussed in
    [*Chapter 9*](B21152_09.xhtml#_idTextAnchor195), *Writing Tests for the Project*,
    to make a separate target with all the C/C++ warning compilation flags set on
    it, and then have our application and test links against it. CMake offers a large
    degree of freedom and flexibility when it comes to how you structure your scripts,
    and with time and experience (and by reading other `CMakeLists.txt` files), you’ll
    get a feel for what works best for you.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以进一步将安装逻辑移动到一个单独的`CMakeLists.txt`文件中，或者将我们的工具函数提取到新的`.cmake`文件中，并使用`include`将其引入。我们还可以使用在[*第9章*](B21152_09.xhtml#_idTextAnchor195)中讨论的接口目标技术，*为项目编写测试*，创建一个单独的目标，其中包含所有设置的C/C++编译警告标志，然后让我们的应用程序和测试链接到该目标。CMake在脚本结构方面提供了很大的自由度和灵活性，通过时间和经验（并且通过阅读其他`CMakeLists.txt`文件），你将会找到最适合自己的方法。
- en: Future topics
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 未来的主题
- en: This brings us to the end of our CMake journey. The idea with this book has
    always been to try and share the best bits of CMake without getting hung up on
    the minutiae (there has undoubtedly been some minutiae, granted, but it could
    have been much worse). The idea was to show working, practical examples you can
    use and learn from. Without seeing a tool such as CMake in action, it makes it
    next to impossible to appreciate what it can do and to be able to start to understand
    it. We’ve covered a lot of ground, and you hopefully have the tools available
    to start building your own libraries and applications, as well as integrating
    what you build with incredible open source software that’s easier than ever to
    use.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是我们 CMake 之旅的终点。本书的目标一直是尽量分享 CMake 的精华部分，而不陷入琐碎的细节（当然也有一些琐碎的部分，但它本可以更糟）。目的是展示可以使用和学习的实用示例。只有亲眼看到像
    CMake 这样的工具如何实际运作，才能真正理解它的能力，并开始理解它的工作原理。我们已经覆盖了很多内容，希望你现在可以使用这些工具来开始构建自己的库和应用程序，并将你构建的内容与越来越容易使用的开源软件进行集成。
- en: With all that said, there’s still a lot we haven’t covered and a lot more to
    learn. If you’re interested in using CMake to build code for other platforms (for
    example, Android or iOS), **toolchain files** are something to investigate. They
    allow you to build code for a target platform that’s different from the host platform.
    This can be useful when building code for embedded devices, mobile platforms,
    different OSs, or different architectures (e.g., ARM versus x86_64).
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 话虽如此，仍有很多内容我们没有覆盖，还有许多东西需要学习。如果你有兴趣使用 CMake 来构建其他平台的代码（例如 Android 或 iOS），**工具链文件**是值得研究的内容。它们允许你为与主机平台不同的目标平台构建代码。当构建嵌入式设备、移动平台、不同操作系统或不同架构（例如，ARM
    与 x86_64）上的代码时，这非常有用。
- en: We didn’t discuss using a fully-fledged package manager with our project. It’s
    worth exploring the open source package managers `vcpkg` will download prebuilt
    binaries for the library you want to use if they exist for the platform/architecture
    you’re using (they also use toolchain files for this reason; so, understanding
    how they work and why they’re needed will help).
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们没有讨论如何在我们的项目中使用完备的包管理器。值得探索的是开源包管理器 `vcpkg`，它会下载你想使用的库的预构建二进制文件（如果它们适用于你使用的平台/架构的话）（它们也因此使用工具链文件；因此，理解它们的工作原理及其必要性将有所帮助）。
- en: 'There’s another useful tool called `CPM.cmake` ([https://github.com/cpm-cmake/CPM.cmake](https://github.com/cpm-cmake/CPM.cmake))
    that acts as a wrapper around CMake’s `FetchContent` command. It offers a much
    more succinct way to define dependencies (their location, name, and version).
    For example, using Catch2 looks like the following:'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还有一个有用的工具叫做 `CPM.cmake` ([https://github.com/cpm-cmake/CPM.cmake](https://github.com/cpm-cmake/CPM.cmake))，它是
    CMake 的 `FetchContent` 命令的封装器。它提供了一种更简洁的方式来定义依赖项（它们的位置、名称和版本）。例如，使用 Catch2 的代码如下：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There’s also the matter of continuous delivery and continuous integration to
    automate builds on every change to catch issues early. A deep dive into this is
    beyond the scope of this book, but to see a simple example of using GitHub Actions
    to build, test, and package our code, take a look at the `.github/workflows/cmake.yml`
    file from the root of the *Minimal* *CMake* repository.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还有一个问题是关于持续交付和持续集成，用于在每次变更时自动构建，从而尽早发现问题。深入探讨这一点超出了本书的范围，但如果你想看一个简单的示例，展示如何使用
    GitHub Actions 构建、测试和打包代码，可以查看 *Minimal* *CMake* 仓库根目录下的 `.github/workflows/cmake.yml`
    文件。
- en: There are a lot more resources available to help continue learning CMake. The
    first place to start is CMake's official documentation ([https://cmake.org/cmake/help/latest/](https://cmake.org/cmake/help/latest/)).
    It’s not perfect, but it’s improving all the time and is a key resource to lean
    on when looking for details about specific features or properties. If you get
    stuck and need to ask for help, the CMake Discourse community ([https://discourse.cmake.org/](https://discourse.cmake.org/))
    is a great resource and has lots of CMake experts ready and willing to answer
    your questions (searching through the question archive can turn up lots of useful
    information too). In addition to the CMake Discourse community, you can find more
    help by visiting the C++ Slack Workspace ([https://cpplang.slack.com/](https://cpplang.slack.com/)).
    There’s a dedicated CMake channel there and lots of friendly, helpful people with
    vast amounts of CMake knowledge to dispense.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 还有更多资源可以帮助你继续学习 CMake。首先可以查看 CMake 官方文档（[https://cmake.org/cmake/help/latest/](https://cmake.org/cmake/help/latest/)）。它不是完美的，但它在不断改进，且在查找特定功能或属性的细节时是一个重要的资源。如果你遇到困难并需要寻求帮助，CMake
    论坛社区（[https://discourse.cmake.org/](https://discourse.cmake.org/)）是一个很好的资源，里面有许多
    CMake 专家随时准备回答你的问题（通过搜索问题存档也能找到很多有用的信息）。除了 CMake 论坛社区，你还可以访问 C++ Slack 工作区（[https://cpplang.slack.com/](https://cpplang.slack.com/)）获得更多帮助。那里有一个专门的
    CMake 频道，很多友好且乐于助人的人拥有丰富的 CMake 知识，可以为你提供帮助。
- en: 'Another resource you might also find helpful is *Mastering CMake*, a book originally
    written by Ken Martin and Bill Hoffman now freely available online at [https://cmake.org/cmake/help/book/mastering-cmake/](https://cmake.org/cmake/help/book/mastering-cmake/).
    It’s a little dated, but there’s a lot of valuable information there. Speaking
    of books, *Professional CMake: A Practical Guide* ([https://crascit.com/professional-cmake/](https://crascit.com/professional-cmake/))
    by Craig Scott is an incredibly detailed reference on CMake that covers just about
    everything you’d ever need to know about it.'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个你可能会觉得有用的资源是*《掌握 CMake》*，这本书最初由 Ken Martin 和 Bill Hoffman 编写，现在可以在网上免费阅读，网址是[https://cmake.org/cmake/help/book/mastering-cmake/](https://cmake.org/cmake/help/book/mastering-cmake/)。虽然有些过时，但里面有很多有价值的信息。说到书籍，Craig
    Scott 编写的*《专业 CMake：实用指南》*（[https://crascit.com/professional-cmake/](https://crascit.com/professional-cmake/)）是一本非常详细的
    CMake 参考书，几乎涵盖了你需要了解的所有内容。
- en: 'If you’ve enjoyed this book and would like to learn more about CMake, there
    are several more books about CMake from Packt worth checking out, including *Modern
    CMake for C++: Discover a better approach to building, testing, and packaging
    your software*, *CMake Best Practices: Upgrade your C++ builds with CMake for
    maximum efficiency and scalability*, and *CMake Cookbook: Building, testing, and
    packaging modular software with* *modern CMake*.'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你喜欢本书并希望了解更多关于 CMake 的内容，Packt 出版的几本关于 CMake 的书值得一看，包括*《现代 CMake for C++：探索更好的构建、测试和打包软件的方法》*，*《CMake
    最佳实践：用 CMake 升级你的 C++ 构建，达到最大效率和可扩展性》*，以及*《CMake 烹饪书：使用现代 CMake 构建、测试和打包模块化软件》*。
- en: Finally, to see more real-life examples, there are some helpful GitHub repositories
    out there with recommendations and proven approaches to setting up CMake-based
    projects. This includes `cmake_template` from `cppbestpractices` (see [https://github.com/cpp-best-practices/cmake_template](https://github.com/cpp-best-practices/cmake_template))
    and [https://github.com/pr0g/cmake-examples](https://github.com/pr0g/cmake-examples)
    from the author of this book (where this whole endeavor started). There’s also
    an extensive collection of links and resources to repositories, books, and articles
    listed on the `awesome-cmake` GitHub repository ([https://github.com/onqtam/awesome-cmake](https://github.com/onqtam/awesome-cmake)).
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，为了查看更多实际案例，GitHub 上有一些有用的资源库，提供了设置 CMake 项目的建议和经过验证的方法。这些包括来自`cppbestpractices`的`cmake_template`（参见[https://github.com/cpp-best-practices/cmake_template](https://github.com/cpp-best-practices/cmake_template)）以及本书作者的[https://github.com/pr0g/cmake-examples](https://github.com/pr0g/cmake-examples)（这就是整个项目的起源）。此外，`awesome-cmake`
    GitHub 仓库上列出了大量链接和资源，涵盖了库、书籍和文章（[https://github.com/onqtam/awesome-cmake](https://github.com/onqtam/awesome-cmake)）。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 摘要
- en: We’re (finally) done. This brings us to the end of the book and our transformation
    from CMake novice to confident CMake practitioner is complete.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们（终于）完成了。这标志着本书的结束，我们从 CMake 新手到自信的 CMake 从业者的转变也已经完成。
- en: In this chapter, we spent some time getting more familiar with the CMake Tools
    extension for Visual Studio Code and understanding how it can make working with
    CMake easier and more enjoyable. From debugging our CMake scripts to integrating
    seamlessly with CMake presets, CMake Tools is an essential addition when working
    with CMake in Visual Studio Code. We then touched on a few more extensions to
    provide enhancements for syntax highlighting and automatic formatting, improving
    our overall editing experience. We then turned our attention to other popular
    editors to understand how to ensure they work with our project from the outset.
    After that, we looked at some recommendations for how to build our C/C++ code
    and the various pros and cons to keep in mind. Next was a discussion of how to
    split our `CMakeLists.txt` file to keep things manageable as our project grows.
    There’s no right or wrong way to do this but knowing some techniques to break
    things down can help keep maintenance in check (especially as a project or team
    grows). Finally, we looked to the future, getting a glimpse of what else CMake
    has to offer and where to go to learn more.
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中，我们花了一些时间更深入地了解 Visual Studio Code 的 CMake Tools 扩展，并理解它如何让使用 CMake 更加轻松愉快。从调试
    CMake 脚本到与 CMake 预设的无缝集成，CMake Tools 在 Visual Studio Code 中处理 CMake 时是一个必不可少的工具。接着，我们介绍了一些其他扩展，以增强语法高亮和自动格式化，改善整体编辑体验。然后，我们将注意力转向其他流行的编辑器，了解如何确保它们从一开始就与我们的项目兼容。之后，我们提出了一些关于如何构建
    C/C++ 代码的建议，并分析了需要注意的各种利弊。接下来，我们讨论了如何拆分 `CMakeLists.txt` 文件，以便在项目扩展时保持可管理性。这没有标准答案，但了解一些拆分技巧有助于在项目或团队扩展时保持维护的简易性。最后，我们展望未来，了解
    CMake 还能提供哪些功能，并指引您去哪里获取更多的学习资源。
- en: It’s been a privilege to get to share this knowledge with you, and hopefully,
    there has been something of value you’ve taken away from it. The aim has always
    been to get to the point where you know enough CMake so you can get things done,
    and then get on with building your app/library/tool and focus on what matters
    most to you. CMake, while by no means perfect, is the predominant build tool in
    the C and C++ ecosystem, so being proficient with it is a valuable skill and will
    unlock access to other frameworks and libraries to make creating your own software
    simpler.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 很荣幸能与您分享这些知识，希望您能从中收获一些有价值的信息。我们的目标一直是让您掌握足够的 CMake 知识，以便完成任务，然后继续构建您的应用程序/库/工具，专注于最重要的事情。CMake
    虽然并不完美，但它是 C 和 C++ 生态系统中主要的构建工具，因此熟练掌握它是一项宝贵的技能，并将为您解锁其他框架和库，简化您自己的软件创建过程。
- en: Thank you for reading and happy building!
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 感谢阅读，祝您构建愉快！
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
