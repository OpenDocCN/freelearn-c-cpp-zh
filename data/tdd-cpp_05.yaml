- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Adding More Confirm Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多确认类型
- en: The previous chapter introduced confirmations and showed you how to use them
    to verify that the bool values within your tests match what you expect them to
    be. The chapter did this with some exploratory code based on a school grading
    example. We’re going to change the grading example to better fit with a test library
    and add additional types that you will be able to use in your confirms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了确认，并展示了如何使用它们来验证测试中的布尔值是否与预期相符。这一章通过基于学校评分示例的探索性代码来完成。我们将更改评分示例以更好地适应测试库，并添加你可以在确认中使用的一些附加类型。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Fixing the bool confirms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复布尔确认
- en: Confirming equality
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认相等性
- en: Changing the code to fix a problem that line numbers are causing with test failures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改代码以修复行号导致测试失败的问题
- en: Adding more confirm types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多确认类型
- en: Confirming string literals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认字符串字面量
- en: Confirming floating-point values
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认浮点值
- en: How to write confirms
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写确认
- en: The additional types add some new twists to confirms that, in this chapter,
    you’ll learn how to work around. By the end of this chapter, you’ll be able to
    write tests that can verify any result you need to be tested.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些附加类型为确认添加了一些新的变化，在本章中，你将学习如何应对。到本章结束时，你将能够编写可以验证任何需要测试的结果的测试。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All of the code in this chapter uses standard C++ that builds on any modern
    C++ 17, or later, compiler and standard library. The code is based on and continues
    from the previous chapters.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都使用基于任何现代C++ 17或更高版本编译器和标准库的标准C++。代码基于前几章并继续发展。
- en: 'You can find all the code for this chapter at the following GitHub repository:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个GitHub仓库中找到本章的所有代码：
- en: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Test-Driven-Development-with-CPP](https://github.com/PacktPublishing/Test-Driven-Development-with-CPP)'
- en: Fixing the bool confirms
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复布尔确认
- en: The previous chapter explored what it means to confirm a value. However, it
    left us with some temporary code that we need to fix. Let’s start by fixing the
    code in `Confirm.cpp` so that it no longer refers to school grades. We want confirms
    to work with types such as bool. That’s why the confirm macros we have now are
    called `CONFIRM_TRUE` and `CONFIRM_FALSE`. The mention of true and false in the
    macro names are the expected values. Additionally, the macros accept a single
    parameter, which is the actual value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章探讨了确认一个值的意义。然而，它留下了一些我们需要修复的临时代码。让我们首先修复`Confirm.cpp`中的代码，使其不再引用学校评分。我们希望确认可以与如bool这样的类型一起工作。这就是为什么我们现在的确认宏被称为`CONFIRM_TRUE`和`CONFIRM_FALSE`。宏名称中提到的true和false是预期值。此外，这些宏接受一个参数，即实际值。
- en: 'Instead of a test about passing grades, let’s replace it with a test about
    bools like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不用关于通过成绩的测试，而是用关于布尔值的测试来替换它：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The new test is clear about what it tests and needs a new helper function called
    `isNegative` instead of the previous function that determined whether a grade
    was passing or not. I wanted something that is simple and can be used to generate
    a result with an obvious expected value. The `isNegative` function replaces the
    previous `isPassingGrade` function and looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 新的测试清楚地说明了它测试的内容，需要一个名为`isNegative`的新辅助函数，而不是之前的确定成绩是否通过的功能。我想找到一个简单且可以生成具有明显预期值的结果的函数。`isNegative`函数替换了之前的`isPassingGrade`函数，其外观如下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a simple change that removes the exploratory code based on grades and
    gives us something that now fits in the test library. Now, in the next section,
    we can continue with confirms that test for equality.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的更改，移除了基于成绩的探索性代码，现在它适合测试库。现在，在下一节中，我们可以继续使用测试相等性的确认。
- en: Confirming equality
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确认相等性
- en: In a way, the bool confirms do test for equality. They ensure that the actual
    bool value is equal to the expected value. This is what the new confirms that
    are introduced in this chapter will do, too. The only difference is that the `CONFIRM_TRUE`
    and `CONFIRM_FALSE` confirms don’t need to accept a parameter for the expected
    value. Their expected value is implied in their name. We can do this for bool
    types because there are only two possible values.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，布尔确认确实是在测试相等性。它们确保实际布尔值等于预期值。这也是本章引入的新确认将要做的。唯一的区别是，`CONFIRM_TRUE`和`CONFIRM_FALSE`确认不需要接受预期值参数。它们的预期值隐含在它们的名称中。我们可以为布尔类型做这件事，因为只有两种可能的值。
- en: However, let’s say that we want to verify that an actual int value equals 1\.
    Do we really want a macro that’s called `CONFIRM_1`? We would need billions of
    macros for each possible 32-bit int and even more for a 64-bit int. And verifying
    text strings to make sure they match expected values becomes impossible with this
    approach.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设我们想要验证实际整数值是否等于1。我们真的想要一个名为`CONFIRM_1`的宏吗？我们需要数十亿个宏来为每个可能的32位整型值创建宏，对于64位整型值则需要更多。使用这种方法验证文本字符串以确保它们与预期值匹配变得不可能。
- en: Instead, all we need to do is modify the macros for the other types to accept
    both an expected value and an actual value. If the two values are not equal to
    each other, then the macros should result in the test failing with an appropriate
    message that explains what was expected and what was actually received.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们只需要修改其他类型的宏，以便接受预期值和实际值。如果这两个值不相等，则宏应该导致测试失败，并显示适当的错误消息，解释期望值和实际接收到的值。
- en: 'Macros are not designed to resolve different types. They perform simple text
    replacement only. We’ll need real C++ functions to work properly with the different
    types we’ll be checking. Additionally, we might as well change the existing bool
    macros to call a function instead of defining the code directly inside the macro.
    Here are the existing bool macros, as we defined them in the previous chapter:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 宏不是用来解析不同类型的。它们只执行简单的文本替换。我们需要真正的C++函数才能正确地与我们将要检查的不同类型一起工作。此外，我们还可以将现有的布尔宏更改为调用函数，而不是直接在宏中定义代码。以下是我们在上一章中定义的现有布尔宏：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What we need to do is move the `if` and `throw` statements into a function.
    We only need one function for both true and false, and it will look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是将`if`和`throw`语句移动到函数中。我们只需要一个函数来处理真和假，它将看起来像这样：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function can be placed in `Test.h` inside the `MereTDD` namespace right
    before `TestBase` is defined. The function needs to be inline and no longer needs
    to qualify the exception with the namespace since it’s now inside the same namespace.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以放在`MereTDD`命名空间内的`Test.h`文件中，在`TestBase`定义之前。该函数需要是内联的，并且由于它现在位于同一命名空间中，因此不再需要使用命名空间来限定异常。
- en: 'Also, you can see better that this is an equality comparison even for bool
    values. The function checks to make sure that the actual value is equal to the
    expected value, and if not, then it throws an exception. The macros can be simplified
    to call the new function like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以更清楚地看到，即使是对于布尔值，这也是一个相等比较。该函数检查确保实际值等于预期值，如果不等于，则抛出异常。宏可以简化为调用新函数，如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Building and running show that all of the tests pass, and we are ready to add
    additional types to confirm. Let’s start with a new test in `Confirm.cpp` for
    int types like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行结果显示所有测试都通过了，我们现在可以添加额外的类型来确认。让我们从`Confirm.cpp`中的新测试开始，用于整型值，如下所示：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Instead of a bools, this code tests int values. It uses a new helper function
    that should be simple to understand, which just multiplies a value by 2\. We need
    the new helper function to be declared at the top of the same file like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与布尔值不同，此代码测试整数值。它使用一个新的辅助函数，这个函数应该很容易理解，它只是将一个值乘以2。我们需要在文件顶部声明这个新辅助函数，如下所示：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The test won’t build yet. That’s okay because, when using a TDD approach, we
    want to focus on the usage first. This usage seems good. It will let us confirm
    that any int value is equal to whatever we expect it to be. Let’s create the `CONFIRM`
    macro and place it right after the two existing macros that confirm true and false
    like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试目前还不能构建。这是可以接受的，因为当我们使用TDD方法时，我们希望首先关注使用。这种使用看起来很好。它将使我们能够确认任何整数值都等于我们期望它成为的值。让我们创建`CONFIRM`宏，并将其放置在两个现有的确认真和假的宏之后，如下所示：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Changing the macros to call a function is really paying off now. The `CONFIRM`
    macro needs an extra parameter for the expected value, and it can call the same
    function name. How can it call the same function, though? Well, that’s because
    we’re going to overload the function. What we have now only works for bool values.
    This is why we switched to a design that can make use of data types. All we need
    to do is provide another implementation of `confirm` that is overloaded to work
    with ints like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将宏更改为调用函数现在真的很有成效。`CONFIRM`宏需要一个额外的参数来传递预期值，并且可以调用相同的函数名。然而，它是如何调用相同的函数呢？嗯，那是因为我们将要重载函数。我们现在拥有的只适用于布尔值。这就是为什么我们转向了一个可以利用数据类型的设计。我们只需要提供另一个`confirm`的实现，使其可以重载以处理整数，如下所示：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is almost identical to the existing `confirm` function. It takes ints for
    the expected and actual parameters instead of bools and will throw a new exception
    type. The reason for the new exception type is so that we can format a failure
    message that will display both the expected and actual values. The `BoolConfirmException`
    type will only be used for bools and will format a message that only mentions
    what was expected. Additionally, the new `ActualConfirmException` type will format
    a message that mentions both the expected and actual values.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与现有的`confirm`函数相同。它接受预期和实际参数为整数，而不是布尔值，并将抛出一个新的异常类型。引入新异常类型的原因是我们可以格式化一个将显示预期和实际值的失败消息。`BoolConfirmException`类型将仅用于布尔值，并将格式化一个只提及预期的消息。此外，新的`ActualConfirmException`类型将格式化一个提及预期和实际值的消息。
- en: 'The new exception type looks like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 新的异常类型如下：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You might be wondering why the new exception type stores the expected and actual
    values as strings. The constructor accepts ints and then converts the ints into
    strings before formatting the reason. This is because we’ll be adding multiple
    data types, and we don’t really need to do anything different. Each type just
    needs to display a descriptive message based on strings when a test fails.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么新的异常类型将预期和实际值存储为字符串。构造函数接受整数，然后在格式化原因之前将整数转换为字符串。这是因为我们将添加多个数据类型，我们实际上不需要做任何不同的事情。每种类型只需要在测试失败时根据字符串显示描述性消息。
- en: We don’t need to use the expected or actual values for any calculations. They
    just need to be formatted into a readable message. Additionally, this design will
    let us use a single exception for all the data types other than bool. We could
    use this new exception for bools too, but the message doesn’t need to mention
    the actual value for bools. So, we’ll keep the existing exception for bools and
    use this new exception type for everything else.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要使用预期或实际值进行任何计算。它们只需要被格式化为可读的消息。此外，这种设计将使我们能够使用单个异常处理所有除了布尔值之外的数据类型。我们也可以为布尔值使用这个新异常，但对于布尔值，消息不需要提及实际值。因此，我们将保留现有的布尔值异常，并使用这个新的异常类型来处理其他所有情况。
- en: By storing the expected and actual values as strings, all we need is an overloaded
    constructor for each new data type we want to support. Each constructor can convert
    the expected and actual values into strings that can then be formatted into a
    readable message. This is better than having an `IntActualConfirmException` class,
    a `StringActualConfirmException` class, and more.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将预期和实际值存储为字符串，我们需要的只是为每个我们想要支持的新数据类型提供一个重载构造函数。每个构造函数都可以将预期和实际值转换为字符串，然后可以将其格式化为可读的消息。这比有一个`IntActualConfirmException`类、一个`StringActualConfirmException`类等等要好。
- en: 'We can build and run the tests again. The results for both the bool and int
    tests look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次构建和运行测试。布尔和整数测试的结果如下：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So, what happens if the confirms fail? Well, we’ve already seen in the previous
    chapter what a failed bool confirm looks like. But we don’t yet have any tests
    for failure cases. We should add them and make them expected failures so that
    the behavior can be captured. Even a failure should be tested to make sure it
    remains a failure. It would be bad if, in the future, we made some changes to
    the code that turned a failure into a success. That would be a breaking change
    because a failure should be expected. Let’s add a couple of new tests to `Confirm.cpp`
    like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果确认失败会发生什么？嗯，我们在上一章已经看到了失败的布尔确认是什么样子。但我们还没有任何针对失败情况的测试。我们应该添加它们，并使它们成为预期失败，以便可以捕获行为。即使是失败也应该进行测试，以确保它仍然是失败。如果将来我们对代码进行了某些更改，将失败变成了成功，那将是一个破坏性的变化，因为失败应该是预期的。让我们向`Confirm.cpp`添加几个新的测试，如下所示：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We get the expected failures, and they look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取预期的失败，它们看起来像这样：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The next step is to set the expected failure messages so that these tests pass
    instead of fail. However, there’s a problem. The line number is part of the error
    message. We want the line number to be displayed in the test results. But that
    means we also have to include the line number in the expected failure message
    in order to treat the failures as passing. Why is this a problem? Well, that’s
    because every time a test is moved or even when other tests are added or removed,
    the line numbers will change. We don’t want to have to change the expected error
    messages for something that is not really part of the error. The line number tells
    us where the error happened and should not be part of the reason for why it happened.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置预期的错误消息，以便这些测试通过而不是失败。然而，有一个问题。行号是错误消息的一部分。我们希望行号在测试结果中显示。但这意味着我们也必须在预期的失败消息中包含行号，以便将失败视为通过。这为什么会成为问题呢？嗯，那是因为每次测试被移动，甚至当其他测试被添加或删除时，行号都会改变。我们不想不得不更改预期的错误消息，因为这不是错误真正的一部分。行号告诉我们错误发生的位置，不应该成为错误发生原因的一部分。
- en: In the next section, we’ll fix the line numbers with some refactoring.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过一些重构来修复行号。
- en: Decoupling test failures from line numbers
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将测试失败与行号解耦
- en: We need to remove the line number from the confirm failure reason so that tests
    can be given an expected failure reason that won’t change as the test is moved
    or shifted to different locations in the source code file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从确认失败原因中删除行号，以便测试可以给出一个不会随着测试移动或转移到源代码文件的不同位置而改变的预期失败原因。
- en: This type of change is called *refactoring*. We’re not going to make any changes
    that cause different or new behaviors to appear in the code. At least, that’s
    the goal. Using TDD will help you refactor your code because you should already
    have tests in place for all of the important aspects.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的更改被称为*重构*。我们不会做出导致代码中出现不同或新行为的更改。至少，这是目标。使用TDD将帮助你重构代码，因为你应该已经为所有重要方面都设置了测试。
- en: Refactoring with proper tests lets you verify that nothing has changed. Many
    times, refactoring without TDD is avoided because the risk of introducing new
    bugs is too great. This tends to make problems bigger, as the refactoring is delayed
    or avoided entirely.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适当的测试进行重构可以让你验证没有任何东西发生变化。很多时候，为了避免引入新的错误，人们会避免在没有TDD的情况下进行重构。这往往会使问题变得更严重，因为重构被推迟或完全避免。
- en: We have a problem with the line numbers. We could ignore the problem and just
    update the tests with new line numbers in the expected failure messages anytime
    a change is made. But that is not right and will only lead to more work and brittle
    tests. As more tests are added, the problem will only get worse. We really should
    fix the problem now. Because we’re following TDD, we can feel confident that the
    changes we are about to make will not break anything that has already been tested.
    Or, at least, if it does break, we’ll know about it and can fix any breaks right
    away.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在行号上遇到了问题。我们本可以忽略这个问题，并在任何更改发生时只需更新测试中的预期失败消息中的新行号。但这是不正确的，只会导致更多的工作和脆弱的测试。随着测试的增加，问题只会变得更糟。我们真的应该现在解决这个问题。因为我们遵循TDD，我们可以确信我们即将做出的更改不会破坏已经测试过的任何东西。或者，至少，如果它确实破坏了，我们会知道并立即修复任何破坏。
- en: 'The first step is to add line number information to the `ConfirmException`
    base class in `Test.cpp`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在`Test.cpp`中的`ConfirmException`基类中添加行号信息：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, in the `runTests` function, we can get the line from the confirm exception
    and use it to set the failure location in the test like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`runTests`函数中，我们可以从确认异常中获取行号，并使用它来设置测试中的失败位置，如下所示：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Even though we are not starting with a test, notice how I’m still following
    a TDD approach to writing the code, as I’d like it to be used before implementing
    it fully. This is a great example because I originally thought about adding a
    new method to the test class. It was called `setFailedLocation`. But that made
    the existing `setFailed` method seem strange. I almost renamed `setFailed` to
    `setFailedReason`, which would have meant that it would need to be changed in
    the other places it’s called. Instead, I decided to add an extra parameter for
    the line number to the existing `setFailed` method. I also decided to give the
    parameter a default value so that the other code would not need to be changed.
    This makes sense and lets the caller set the failed reason by itself or with a
    line number if known.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们没有从测试开始，请注意我仍然在遵循TDD方法来编写代码，因为我希望在完全实现之前使用它。这是一个很好的例子，因为我最初考虑向测试类添加一个新方法。它被称为`setFailedLocation`。但这样做让现有的`setFailed`方法看起来很奇怪。我几乎将`setFailed`重命名为`setFailedReason`，这将意味着它需要在其他被调用的地方进行更改。相反，我决定向现有的`setFailed`方法添加一个额外的行号参数。我还决定给参数一个默认值，这样其他代码就不需要更改。这很有意义，并允许调用者自行设置失败原因，或者如果知道行号，则可以同时设置。
- en: 'We need to add a line number data member to the `TestBase` class. The line
    number will only be known for confirms, so it will be called `mConfirmLocation`
    like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要向`TestBase`类添加一个行号数据成员。行号将仅适用于确认，因此它将被称为`mConfirmLocation`，如下所示：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The new data member needs to be initialized in the `TestBase` constructor.
    We’ll use the value of -1 to mean that the line number location is not applicable:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 新的数据成员需要在`TestBase`构造函数中初始化。我们将使用-1的值来表示行号位置不适用：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We need to add the line number parameter to the `setFailed` method like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要像这样向`setFailed`方法添加行号参数：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Additionally, we need to add a new getter method for the confirm location like
    this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要为确认位置添加一个新的getter方法，如下所示：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will let the `runTests` function set the line number when it catches a
    confirm exception, and the test will be able to remember the line number. At the
    end of `runTests`, where the failure message is sent to the output, we need to
    test `confirmLocation` and change the output if we have a line number or not,
    as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许`runTests`函数在捕获到确认异常时设置行号，并且测试将能够记住行号。在`runTests`的末尾，当将失败消息发送到输出时，我们需要测试`confirmLocation`，并根据是否有行号来更改输出，如下所示：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will also fix a minor problem with confirms. Previously, the test results
    printed a line that said the test failed and then another line that said a confirm
    failed. The new code will only display either a generic failed message or a confirm
    failed message with a line number.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将修复确认中的一个小问题。之前，测试结果打印了一条说测试失败的行，然后又打印了一条说确认失败的行。新的代码将只显示一个通用的失败消息或带有行号的确认失败消息。
- en: 'We’re not done yet. We need to change both derived exception class constructors
    to initialize the base class line number and to stop including the line number
    as part of the reason. The constructor for `BoolConfirmException` looks like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成。我们需要更改派生异常类构造函数，以初始化基类行号，并停止将行号作为原因的一部分。`BoolConfirmException`的构造函数如下所示：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Additionally, the `ActualConfirmException` class needs to be changed throughout.
    The constructor needs to initialize the base class with the line number, the formatting
    needs to change, and the line number data member can be removed since it’s now
    in the base class. The class looks like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ActualConfirmException`类需要在整个文件中进行更改。构造函数需要使用行号初始化基类，格式需要更改，并且可以删除行号数据成员，因为它现在在基类中。类看起来如下所示：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can build again and running still shows the expected failures. The failure
    reasons are formatted slightly differently than before and look like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次构建并运行，仍然显示预期的失败。失败原因的格式与之前略有不同，如下所示：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It looks almost the same, which is good. Now we can set the expected failure
    messages without needing to worry about the line numbers like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来几乎一样，这是好的。现在我们可以设置预期的失败消息，而不用担心行号，如下所示：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice that the expected failure reason needs to be formatted to exactly match
    what the test displays when it fails. This includes spaces used to indent and
    new lines. Once the expected failure reasons are set, all of the tests pass again
    like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，预期的失败原因需要格式化，以与测试失败时显示的内容完全匹配。这包括用于缩进的空格和新行。一旦设置了预期的失败原因，所有的测试就会再次通过，如下所示：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Both tests are expected failures and are treated as passing. Now we can continue
    adding more confirm types.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个测试都预期会失败，并且被视为通过。现在我们可以继续添加更多确认类型。
- en: Adding more confirm types
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多确认类型
- en: 'Currently, we can confirm bool and int values inside the tests. We need more
    than this, so what should we add next? Let’s add support for the long type. It’s
    similar to an int and, on many platforms, will effectively be the same. Even though
    it may or may not use the same number of bits as an int, to the C++ compiler,
    it is a different type. We can begin by adding a basic test to `Confirm.cpp` that
    tests the long type like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们可以在测试中确认 bool 和 int 值。我们需要更多，所以下一步应该添加什么？让我们添加对 long 类型的支持。它与 int 类似，在许多平台上将有效地相同。即使它可能或可能不使用与
    int 相同数量的位，对于 C++ 编译器来说，它是一个不同的类型。我们可以通过在 `Confirm.cpp` 中添加一个基本的测试来开始，这个测试像这样测试
    long 类型：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The test calls the same `multiplyBy2` helper function, which performs extra
    conversions because it’s not working with longs throughout. We start with long
    literal values by adding the `L` suffix. These get converted into ints in order
    to be passed to `multiplyBy2`. The return value is also an int, which gets converted
    into a long in order to be assigned to `result`. Let’s prevent all of this extra
    conversion by creating an overloaded version of `multiplyBy2` that accepts a long
    type and returns a long type:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 测试调用相同的 `multiplyBy2` 辅助函数，因为它不是在整个过程中使用 long 类型。我们通过添加 `L` 后缀以 long 文字值开始。这些值被转换为
    int 以传递给 `multiplyBy2`。返回值也是一个 int，它被转换为 long 以分配给 `result`。让我们通过创建一个接受 long 类型并返回
    long 类型的重载 `multiplyBy2` 版本来防止所有这些额外的转换：
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we try to build right now, there will be an error because the compiler doesn’t
    know which overload of `confirm` to call. The only available choices are to either
    convert the long expected and actual values into ints or bools. Neither choice
    is a match, and the compiler sees the call as ambiguous. Remember that the `CONFIRM`
    macro gets transformed into a call to the overloaded `confirm` function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试构建，将会出现错误，因为编译器不知道应该调用哪个重载的 `confirm` 函数。唯一可用的选择是将预期的长值和实际值转换为 int 或
    bool。这两种选择都不匹配，编译器将调用视为模糊的。记住，`CONFIRM` 宏会被转换成对重载的 `confirm` 函数的调用。
- en: 'We can fix this by adding a new overloaded version of `confirm` that uses long
    parameters. However, a better solution is to change the existing version of `confirm`
    that uses int parameters into a template like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加一个新的重载 `confirm` 版本，该版本使用 long 参数来解决这个问题。然而，更好的解决方案是将现有的使用 int 参数的 `confirm`
    版本改为模板，如下所示：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We still have the version of `confirm` that uses a bool parameter. The template
    will match both int and long types. Additionally, the template will match types
    that we don’t yet have tests for. The new templated `confirm` method also does
    the conversion into `std::string` when creating the exception to be thrown. In
    [*Chapter 12*](B18567_12.xhtml#_idTextAnchor123), *Creating Better Test Confirmations*,
    you’ll see that there is a problem with how we convert the expected and actual
    values into strings. Or, at least, there is a better way. What we have does work
    but only for numeric types that can be passed to `std::to_string`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有使用 bool 参数的 `confirm` 版本。模板将匹配 int 和 long 类型。此外，模板还将匹配我们尚未测试的类型。新的模板 `confirm`
    方法在创建要抛出的异常时也会将类型转换为 `std::string`。在 [*第12章*](B18567_12.xhtml#_idTextAnchor123)，*创建更好的测试确认*，你会看到我们在将预期值和实际值转换为字符串的方式上存在问题。或者至少，有更好的方法。我们目前的方法是可行的，但仅适用于可以传递给
    `std::to_string` 的数值类型。
- en: 'Let’s update the `ActualConfirmException` constructor to use strings that we
    will now be calling `std::to_string` from within the `confirm` function. The constructor
    looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `ActualConfirmException` 构造函数，使其使用字符串，我们将在 `confirm` 函数内部调用 `std::to_string`。构造函数看起来像这样：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Everything builds, and all the tests pass again. We can add a new test in `Confirm.cpp`
    for a long failure like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一切构建正常，所有测试都通过了。我们可以在 `Confirm.cpp` 中添加一个新的测试，用于测试 long 失败，如下所示：
- en: '[PRE29]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The failure reason string is the same as for an int even though we are testing
    a long type. The test result for the new test looks like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 失败原因字符串与 int 相同，即使我们正在测试 long 类型。新测试的测试结果如下：
- en: '[PRE30]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s try a type that will show something different. A `long long` type can
    definitely hold numeric values that are bigger than an int. Here is a new test
    in `Confirm.cpp` that tests `long long` values:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个会显示不同结果的类型。`long long` 类型可以肯定地存储比 int 更大的数值。下面是 `Confirm.cpp` 中的一个新测试，用于测试
    `long long` 值：
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With a `long long` type, we can have values greater than a maximum 32-bit signed
    value. The code uses single quote marks to make the larger numbers easier to read.
    The compiler ignores the single quote marks, but they help us to visually separate
    every group of thousands. Also, the suffix, `LL`, tells the compiler to treat
    the literal value as a `long long` type.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`long long`类型，我们可以有大于最大32位有符号值的值。代码使用单引号来使较大的数字更容易阅读。编译器忽略单引号，但它们帮助我们视觉上分隔每一组千位数。此外，后缀`LL`告诉编译器将字面值视为`long
    long`类型。
- en: 'The result for this passing test looks like the others:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通过测试的结果看起来和其他的一样：
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We need to look at a `long long` failure test result to see the larger numbers.
    Here is a failure test:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要查看一个`长长`的失败测试结果来查看更大的数字。这里是一个失败测试：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Because we’re not formatting the output with separators, we need to use the
    unadorned numbers in text format without any commas. This is probably for the
    best anyway because some locales use commas and some use dots. Note that we don’t
    try to do any formatting, so the expected failure message also uses no formatting.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不使用分隔符格式化输出，我们需要使用不带逗号的纯数字文本格式。这可能是最好的方式，因为一些地区使用逗号，而一些地区使用点。注意，我们不做任何格式化尝试，所以期望的失败消息也不使用任何格式化。
- en: 'Now we can see that the failure description does indeed match the larger numbers
    and looks like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到失败描述确实与较大的数字匹配，看起来像这样：
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I want to highlight one important point about failure tests. They are purposefully
    using incorrect expected values to force a failure. You will not do this in your
    tests. But then you also will not need to write tests that you *want* to fail.
    We want these tests to fail so that we can verify that the test library is able
    to properly detect and handle any failures. Because of this, we treat the failures
    as passes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调关于失败测试的一个重要观点。它们故意使用不正确的期望值来强制失败。你不会在测试中这样做。但你也无需编写你希望失败的测试。我们希望这些测试失败，以便我们可以验证测试库能够正确地检测和处理任何失败。因此，我们将这些失败视为通过。
- en: We could keep going and add tests for shorts, chars, and all of the unsigned
    versions. However, this is becoming uninteresting at this point because all we
    are doing is testing that the template function works properly. Instead, let’s
    focus on types that use non-template code that has been written to work properly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续添加对短整型、字符和所有无符号版本的测试。然而，在这个点上，这变得不再有趣，因为我们只是在测试模板函数是否正常工作。相反，让我们专注于使用非模板代码的类型，这些代码已经被编写来正常工作。
- en: 'Here is a simple test for the string type:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对字符串类型的一个简单测试：
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Instead of writing a fake helper method that returns a string, this test simply
    declares two strings and will use one as the actual value and the other as the
    expected value. By initializing both strings with the same text, we expect them
    to be equal, so we call `CONFIRM` to make sure they are equal.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是编写一个返回字符串的假辅助方法，这个测试只是声明了两个字符串，并将使用一个作为实际值，另一个作为期望值。通过将两个字符串都初始化为相同的文本，我们期望它们相等，所以我们调用`CONFIRM`来确保它们相等。
- en: When you are writing a test, you will want to assign `result` a value that you
    get from the function or method that you are testing. Our goal here is to test
    that the `CONFIRM` macro and the underlying test library code work properly. So,
    we can skip the function being tested and go straight to the macro with two string
    values where we know what to expect.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写测试时，你将想要给`result`分配一个从你正在测试的函数或方法中获得的值。我们的目标是测试`CONFIRM`宏和底层测试库代码是否正常工作。因此，我们可以跳过被测试的函数，直接使用两个字符串值进行宏测试，其中我们知道期望的结果。
- en: This seems like a reasonable test. And it is. But it doesn’t compile. The problem
    is that the `confirm` template function tries to call `std::to_string` on the
    values provided. This doesn’t make sense when the values are already strings.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个合理的测试。而且确实是。但它无法编译。问题是`confirm`模板函数试图在提供的值上调用`std::to_string`。当值已经是字符串时，这没有意义。
- en: 'What we need is a new overload of `confirm` that uses strings. We’ll actually
    create two overloads, one for string views and one for strings. The first overload
    function looks like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一个新的`confirm`重载，它使用字符串。我们实际上会创建两个重载，一个用于字符串视图，一个用于字符串。第一个重载函数看起来像这样：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This first function takes string views, which will be a better match than the
    template method when working with string views. Then, it passes the strings given
    to the `ActualConfirmException` constructor without trying to call `std::to_string`
    because they are already strings.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个函数接受字符串视图，与模板方法相比，在处理字符串视图时将是一个更好的匹配。然后，它将给定的字符串传递给`ActualConfirmException`构造函数，而不尝试调用`std::to_string`，因为它们已经是字符串。
- en: 'The second overloaded function looks like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重载函数看起来像这样：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This second function takes constant string references, which will also be a
    better match than the template method when working with strings. Then, it converts
    the strings into string views and calls the first function.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第二个函数接受常量字符串引用，与模板方法相比，在处理字符串时将是一个更好的匹配。然后，它将字符串转换为字符串视图并调用第一个函数。
- en: 'Now we can add a string failure test like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一个字符串失败测试，如下所示：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The test result after building and running the tests looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行测试后的测试结果如下：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There’s one more important aspect to consider about strings. We need to consider
    string literals that are really constant char pointers. We’ll explore pointers
    followed by string literals in the next section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '关于字符串，还有一个重要的方面需要考虑。我们需要考虑真正的常量字符指针的字符串字面量。我们将在下一节中探讨跟随字符串字面量的指针。 '
- en: Confirming string literals
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确认字符串字面量
- en: A string literal might look like a string, but the C++ compiler treats a string
    literal as a pointer to the first of a set of constant chars. The set of constant
    chars is terminated with a null character value, which is the numeric value of
    zero. That’s how the compiler knows how long the string is. It just keeps going
    until it finds the null. The reason that the chars are constant is that the data
    is normally stored in memory that is write protected, so it cannot be modified.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量可能看起来像字符串，但C++编译器将字符串字面量视为指向一组常量字符的第一个字符的指针。常量字符集以空字符值终止，这是零的数值。这就是编译器知道字符串有多长的方式。它只是继续进行，直到找到空字符。字符是常量的原因在于数据通常存储在写保护的内存中，因此不能被修改。
- en: When we try to confirm a string literal, the compiler sees a pointer and has
    to decide which overloaded `confirm` function to call. Before we get too far with
    our exploration of string literals, what other problems can we get into with pointers?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试确认一个字符串字面量时，编译器看到的是一个指针，必须决定调用哪个重载的`confirm`函数。在我们深入探索字符串字面量之前，我们可能会遇到哪些与指针相关的问题？
- en: 'Let’s start with the simple bool type and see what kinds of problems we run
    into if we try to confirm bool pointers. This will help you to understand string
    literal pointers by, first, understanding a simpler example test for bool pointers.
    You don’t need to add this test to the project. It is included here just to explain
    what happens when we try to confirm a pointer. The test looks like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的bool类型开始，看看如果我们尝试确认bool指针时会遇到什么问题。这将帮助你通过首先理解一个简单的bool指针示例测试来理解字符串字面量指针。你不需要将此测试添加到项目中。它被包含在这里只是为了解释当我们尝试确认指针时会发生什么。测试看起来是这样的：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding test actually compiles and runs. But it fails with the following
    result:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的测试实际上是可以编译和运行的。但它以以下结果失败：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Line 86 is the second confirm in the test. So, what is going on? Why does the
    confirm think that `pResult2` points to a true value?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第86行是测试中的第二个确认。那么，发生了什么？为什么确认认为`pResult2`指向一个真值？
- en: 'Well, remember that the confirm macro just gets replaced with a call to one
    of the `confirm` methods. The second confirm deals with the following macro:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，记住，confirm宏只是被替换为对`confirm`方法之一的调用。第二个确认处理以下宏：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And it tries to call `confirm` with a hardcoded false bool value, the bool pointer
    that was passed to the macro, and the int line number. There is no exact match
    for a bool, a bool pointer, or an int for any version of `confirm`, so something
    either has to be converted or the compiler will generate an error. We know there
    was no error because the code compiled and ran. So, what got converted?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它尝试使用硬编码的假bool值、传递给宏的bool指针和整行号调用`confirm`。对于任何版本的`confirm`，都没有bool、bool指针或int的确切匹配，所以要么必须进行转换，否则编译器将生成错误。我们知道没有错误，因为代码编译并运行了。那么，转换了什么？
- en: This is a great example of the TDD process, as explained in [*Chapter 3*](B18567_03.xhtml#_idTextAnchor031),
    *The TDD Process*, to write the code first as you want it to be used and compile
    it even if you expect the build to fail. In this case, the build did not fail,
    and that gives us insight that we might have otherwise missed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对TDD过程的一个很好的例子，如第3章[*“TDD过程”*](B18567_03.xhtml#_idTextAnchor031)中所述，首先编写你希望它使用的代码，即使你预期构建会失败也要编译它。在这种情况下，构建没有失败，这让我们得到了我们可能错过的洞察。
- en: The compiler was able to convert the pointer value into a bool and that was
    seen as the best choice available. In fact, I didn’t even get a warning about
    the conversion. The compiler silently made the decision to convert the pointer
    to a bool into a bool value. This is almost never what you want to happen.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器能够将指针值转换为布尔值，并且这被视为最佳选择。实际上，我甚至没有收到关于转换的警告。编译器默默地做出了将指针转换为布尔值的决定，并将其转换为布尔值。这几乎从来不是你想要发生的事情。
- en: So, what does it even mean to convert a pointer into a bool? Any pointer with
    a valid nonzero address will get converted into true. Additionally, any null pointer
    with a zero address will get converted into false. Because we have the real address
    of `result2` stored in the `pResult2` pointer, the conversion was made to a true
    bool value.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，将指针转换为布尔值究竟是什么意思呢？任何具有有效非零地址的指针都会转换为true。此外，任何具有零地址的空指针都会转换为false。因为我们已经将`result2`的实际地址存储在`pResult2`指针中，所以转换成了真实的布尔值。
- en: You might be wondering what happened to the first confirm and why it did not
    fail. Why did the test proceed to the second confirm before it failed? Well, the
    first confirm went through the same conversion for a bool, bool pointer, and int.
    Both conversions resulted in a true bool value because both pointers held valid
    addresses.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道第一个确认发生了什么，为什么它没有失败。为什么测试在失败之前继续进行到第二个确认？嗯，第一个确认对布尔值、布尔指针和整型进行了相同的转换。两种转换都产生了真实的布尔值，因为两个指针都持有有效的地址。
- en: The first confirm called `confirm` with true, true, and the line number, which
    passed. But the second confirm called `confirm` with false, true, and the line
    number, which failed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次确认调用`confirm`时传递了true、true和行号，这通过了。但第二次确认调用`confirm`时传递了false、true和行号，这失败了。
- en: 'To solve this, we either need to add support for pointers of all types or remember
    to dereference the pointers before confirming them. Adding support for pointers
    might seem like a simple solution until we get to string literals, which are also
    pointers. It’s not as simple as it seems and is not something we need to do now.
    Let’s keep the test library as simple as possible. Here is how you can fix the
    bool confirm test shown earlier:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们或者需要添加对所有类型指针的支持，或者记得在确认之前解引用指针。添加对指针的支持可能看起来像是一个简单的解决方案，直到我们到达字符串字面量，它们也是指针。这并不像看起来那么简单，而且现在我们不需要这样做。让我们保持测试库尽可能简单。以下是如何修复前面显示的布尔确认测试的方法：
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice that the tests dereference the pointers instead of passing the pointers
    directly to the macros. This means that the test is really just testing bool values,
    and that’s why I said that you really don’t need to add the test.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，测试解引用了指针而不是直接将指针传递给宏。这意味着测试实际上只是在测试布尔值，这就是为什么我说你实际上不需要添加测试。
- en: String literals are frequently found in the source code. They are an easy way
    to represent an expected string value. The problem with string literals is they
    are not strings. They are a pointer to a constant char. And we can’t just dereference
    a string literal pointer as we did for a bool pointer. That would result in a
    single char. We want to confirm the whole string.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量在源代码中很常见。它们是表示预期字符串值的一种简单方法。字符串字面量的问题是它们不是字符串。它们是一个指向常量字符的指针。我们无法像对布尔指针那样解引用字符串字面量指针。那将导致一个单独的字符。我们想要确认整个字符串。
- en: 'Here is a test that shows what will likely be the major usage of string literals.
    The most common usage will be comparing a string literal with a string. The test
    looks like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个测试，展示了字符串字面量可能的主要用法。最常见的使用是将字符串字面量与字符串进行比较。测试看起来是这样的：
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This works because one of the argument types that ends up getting passed to
    the `confirm` function is `std::string`. The compiler doesn’t find an exact match
    for both arguments; however, because one is a string, it decides to convert the
    string literal into a string, too.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为最终传递给`confirm`函数的参数类型之一是`std::string`。编译器没有找到两个参数的精确匹配；然而，因为一个是字符串，它决定将字符串字面量也转换为字符串。
- en: Where we run into problems is when we try to confirm two string literals for
    both the expected and actual values. The compiler sees two pointers and has no
    clue that they should both be converted into strings. This is not a normal situation
    that you will need to verify in a test. Additionally, if you ever do need to compare
    two string literals, it’s easy to wrap one of them into a `std::string` argument
    type before confirming.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到问题的地方在于当我们尝试确认预期值和实际值的两个字符串字面量时。编译器看到两个指针，并不知道它们都应该被转换为字符串。这不是你需要在测试中验证的正常情况。另外，如果你确实需要比较两个字符串字面量，在确认之前将其中一个包裹成`std::string`参数类型很容易。
- en: Also, in [*Chapter 12*](B18567_12.xhtml#_idTextAnchor123), *Creating Better
    Test Confirmations*, you’ll see how you can get around the problem of confirming
    two string literals. We’ll be improving the whole design used to confirm the test
    results. The design we have now is often called the classic way to confirm values.
    [*Chapter 12*](B18567_12.xhtml#_idTextAnchor123) will introduce a new way that
    is more extensible, easier to read, and more flexible.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在[*第12章*](B18567_12.xhtml#_idTextAnchor123) *创建更好的测试确认方法*中，你会看到如何解决确认两个字符串字面量的问题。我们将改进用于确认测试结果的整体设计。我们现在所使用的设计通常被称为确认值的经典方法。[*第12章*](B18567_12.xhtml#_idTextAnchor123)将介绍一种更可扩展、更易读、更灵活的新方法。
- en: We’ve come a long way in terms of adding support for different types, and you
    also understand how to work with string literals. However, I’ve stayed away from
    the two floating-point types, float and double, because they need some special
    consideration. They will be explained next.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持不同类型方面我们已经取得了长足的进步，你也理解了如何处理字符串字面量。然而，我避开浮点型和双精度浮点型，因为它们需要特别的考虑。它们将在下一节中解释。
- en: Confirming floating point values
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确认浮点值
- en: At the most basic level, confirms work by comparing an expected value with an
    actual value and throwing an exception if they are different. This works for all
    the integral types such as int and long, bool types, and even strings. The values
    either match or don’t match.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本层面上，确认工作是通过比较预期值与实际值，并在它们不同时抛出异常来完成的。这对于所有整型，如int和long，布尔类型，甚至是字符串都适用。值要么匹配，要么不匹配。
- en: This is where things get difficult for the float and double floating point types
    – because it’s not always possible to accurately compare two floating-point values.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于浮点型和双精度浮点型，事情变得困难，因为并不总是能够准确比较两个浮点值。
- en: Even in the decimal system that we are used to from grade school, we understand
    there are some fractional values that can’t be accurately represented. A value
    such as 1/3 is easy to represent as a fraction. But writing it in a floating-point
    decimal format looks like 0.33333 with the digit 3 continuing forever. We can
    get close to the true value of 1/3, but at some point, we have to stop when writing
    0.333333333... And no matter how many 3s we include, there are always more.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在我们从小学就熟悉的十进制系统中，我们也知道存在一些无法准确表示的分数值。例如，1/3很容易表示为分数。但是，以浮点十进制格式书写时，看起来像0.33333，数字3无限循环。我们可以接近1/3的真实值，但在某个点上，我们必须在书写0.333333333...时停止。无论我们包含多少个3，总是还有更多。
- en: In C++, floating-point values use a binary number system that has similar accuracy
    issues. But the accuracy issues in binary are even more common than in decimal.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，浮点值使用具有类似精度问题的二进制数系统。但二进制中的精度问题比十进制中更为常见。
- en: I won’t go into all the details because they are not important. However, the
    main cause of the extra issues in binary is caused by there being fewer factors
    of 2 than there are of 10\. With the base 10 decimal system, the factors are 1,
    2, 5, and 10\. While in binary, the factors of 2 are only 1 and 2.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入所有细节，因为它们并不重要。然而，二进制中额外问题的主要原因是2的因子比10的因子少。在十进制系统中，因子是1、2、5和10。而在二进制中，2的因子只有1和2。
- en: So, why are the factors important? Well, it’s because they determine which fractions
    can be accurately described and which cannot. A fraction such as 1/3 causes trouble
    for both systems because 3 is not a factor in either. Another example is 1/7\.
    These fractions are not very common, though. The fraction of 1/10 is very common
    in decimal. Because 10 is a factor, this means that values such as 0.1, 0.2, 0.3,
    and more can all be accurately represented in decimal.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么因子很重要呢？嗯，这是因为它们决定了哪些分数可以准确描述，哪些不能。例如，1/3这个分数对两个系统都造成麻烦，因为3在两个系统中都不是因子。另一个例子是1/7。这些分数并不常见。1/10的分数在十进制中非常常见。因为10是一个因子，这意味着像0.1、0.2、0.3等值都可以在十进制中准确表示。
- en: Additionally, because 10 is not a factor in binary base 2, these same values
    that are widely used have no representation with a fixed number of digits as they
    do in decimal.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于10不是二进制基数2的因子，这些广泛使用的相同值在十进制中没有用固定数字表示的表示，就像它们在十进制中那样。
- en: So, what all of this means is that if you have a binary floating-point value
    that looks like 0.1, it is close to the actual value but can’t quite be exact.
    It might be displayed as 0.1 when converted into a string but that also involves
    a little bit of rounding.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这一切意味着，如果你有一个看起来像0.1的二进制浮点值，它接近实际值，但无法完全精确。它可能在转换为字符串时显示为0.1，但这也涉及一点舍入。
- en: Normally, we don’t worry about the computer’s inability to accurately represent
    values that we are used to being exact from grade school – that is, until we need
    to test one floating-point value to see if it equals another.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不会担心计算机无法准确表示我们从小学就习惯于精确表示的值——也就是说，直到我们需要测试一个浮点值以查看它是否等于另一个值。
- en: Even something as simple as 0.1 + 0.2 that looks like 0.3 will probably not
    equal 0.3.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 即使像0.1 + 0.2这样看起来等于0.3的简单运算，也可能不等于0.3。
- en: When comparing computer floating-point values, we always have to allow for a
    certain amount of error. As long as the values are close, we can assume they are
    equal.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较计算机浮点值时，我们总是必须允许一定量的误差。只要值接近，我们就可以假设它们相等。
- en: However, the ultimate problem is that there is no good single solution that
    can determine whether two values are close. The amount of error we can represent
    changes depending on how big or how small the values are. Floating-point values
    change drastically when they get really close to 0\. And they lose the ability
    to represent small values as they get larger. Because floating-point values can
    get really large, the amount of accuracy that is lost with large values can also
    be large.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终的问题是，没有好的单一解决方案可以确定两个值是否接近。我们可以表示的误差量取决于值的大小。当浮点值接近0时，它们会急剧变化。并且当它们变大时，它们失去了表示小值的能力。因为浮点值可以变得非常大，所以大值丢失的精度也可能很大。
- en: Let’s imagine if a bank used floating-point values to keep track of your money.
    Would you be happy if your bank could no longer track anything less than a thousand
    dollars just because you have billions? We’re no longer talking about losing a
    few cents. Or maybe you only have 30 cents in your account and you want to withdraw
    all 30 cents. Would you expect the bank to deny your withdrawal because it thinks
    30 cents is more than the 30 cents you have? These are the types of problems that
    floating-point values can lead to.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，如果一家银行使用浮点值来跟踪你的钱。如果你有数十亿美元，但银行却无法跟踪低于一千美元的任何金额，你会高兴吗？我们不再谈论丢失几美分的问题。或者，也许你的账户里只有30美分，你想取出所有的30美分。你会期望银行拒绝你的取款，因为它认为30美分比你账户里的30美分多吗？这些问题就是浮点值可能导致的。
- en: Because we’re following a TDD process, we’re going to start out simple with
    floating point values and include a small margin of error when comparing either
    float, double, or long double values to see whether they are equal. We’re not
    going to get fancy and try to adjust the margin depending on how big or small
    the values are.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在遵循TDD（测试驱动开发）流程，我们将从简单的浮点值开始，并在比较浮点、双精度或长双精度值时包含一个小的误差范围，以查看它们是否相等。我们不会变得复杂，试图根据值的的大小调整误差范围。
- en: 'Here is a test that we will use for the float values:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个我们将用于浮点值的测试：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The test for float types actually passes on my computer.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点类型的测试实际上在我的电脑上通过了。
- en: 'So, what happens if we create another test for double types? The new double
    test looks like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果我们为双精度类型创建另一个测试会发生什么呢？新的双精度测试看起来像这样：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This test is almost identical, yet it fails on my computer. And the crazy part
    is that the failure description makes no sense unless you understand that values
    can be printed as text, which has been adjusted to appear like a nice round number
    when it really is not. Here is what the failure message shows on my computer:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试几乎相同，但在我的电脑上失败了。而且，奇怪的是，除非你理解值可以以文本形式打印出来，并且已经被调整为看起来像是一个很好的圆整数，否则失败描述是没有意义的。以下是我电脑上的失败信息：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Looking at the message, you might ask how it is possible that 0.300000 does
    not equal 0.300000\. The reason is that neither the expected nor the actual values
    are exactly 0.300000\. They have both been adjusted slightly so that they will
    display these round-looking values.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这条消息，你可能会问，为什么0.300000不等于0.300000。原因是预期的值和实际的值都不是精确的0.300000。它们都被稍微调整了一下，以便它们会显示这些看起来像圆整的值。
- en: 'The test for long doubles is almost the same as for doubles. Only the types
    have been changed, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长双精度浮点数（long doubles）的测试几乎与双精度浮点数（doubles）的测试相同。只是类型发生了变化，如下所示：
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The long double test also fails on my machine for the same reason as the test
    with doubles. We can fix all of the floating-point confirms by adding special
    overloads for all three of these types.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 长双精度浮点数测试在我的机器上也因为与双精度浮点数测试相同的原因而失败。我们可以通过为这三种类型添加特殊重载来修复所有的浮点数确认。
- en: 'Here is an overloaded `confirm` function that uses a small margin of error
    when comparing float values:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个重载的`confirm`函数，它在比较浮点值时使用了一个小的误差范围：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We need almost the same overload for doubles as for floats. Here is the double
    overload that does the comparison with a margin of error that is plus or minus
    the expected value:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的重载几乎与浮点数相同。以下是一个双精度浮点数的重载，它使用一个误差范围，这个误差范围是预期值的正负：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Other than the type changes from float to double, this method uses a smaller
    margin of error and leaves off the `f` suffix from the literal values.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从浮点数到双精度浮点数的类型变化之外，这种方法使用了一个更小的误差范围，并且从字面值中省略了`f`后缀。
- en: 'The overload function for long doubles is similar to the one for doubles, as
    follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 长双精度浮点数的重载函数与双精度浮点数的类似，如下所示：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: After adding these overloads for floats, doubles, and long doubles, all the
    tests pass again. We’ll be revisiting the problem of comparing floating-point
    values again in [*Chapter 13*](B18567_13.xhtml#_idTextAnchor131), *How to Test
    Floating-Point and Custom Values*. The comparison solution we have is simple and
    will work for now.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在为浮点数、双精度浮点数和长双精度浮点数添加了这些重载（overloads）之后，所有的测试都再次通过。我们将在[*第13章*](B18567_13.xhtml#_idTextAnchor131)，*如何测试浮点数和自定义值*中再次回顾比较浮点值的问题。我们目前拥有的比较解决方案很简单，并且现在可以工作。
- en: We have also covered all of the confirm types we’ll be supporting at this time.
    Remember the TDD rule to do only what is necessary. We can always enhance the
    design of confirmations later, and that’s exactly what we’ll be doing in [*Chapter
    12*](B18567_12.xhtml#_idTextAnchor123), *Creating Better Test Confirmations*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了我们将要支持的所有确认类型。记住TDD规则，只做必要的事情。我们总是可以在以后增强确认的设计，这正是我们将在[*第12章*](B18567_12.xhtml#_idTextAnchor123)，*创建更好的测试确认*中要做的事情。
- en: Before ending this chapter, I have some advice on writing confirmations. It’s
    nothing that we haven’t already been doing, but it does deserve mentioning so
    that you are aware of the pattern.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这一章之前，我有一些关于编写确认的建议。这并不是我们还没有做的事情，但它确实值得提一下，以便你知道这个模式。
- en: How to write confirms
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何编写确认（confirms）
- en: Usually, there are many different ways you can write your code and your tests.
    What I’ll share here is based on years of experience, and while it’s not the only
    way to write tests, I hope you learn from it and follow a similar style. Specifically,
    I want to share guidance on how to write confirms.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你有很多不同的方式可以编写你的代码和测试。我在这里分享的是基于多年的经验，虽然这并不是编写测试的唯一方式，但我希望你能从中学习，并遵循类似的风格。具体来说，我想分享关于如何编写确认（confirms）的指导。
- en: The most important thing to remember is to keep your confirms outside of the
    normal flow of your tests but still close to where they are needed. When a test
    runs, it performs various activities that you want to ensure work as expected.
    You can add confirms along the way to make sure the test is making progress as
    expected. Or maybe you have a simple test that does one thing and needs one or
    more confirms at the end to make sure everything worked. All of this is good.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是要记住，将你的确认放在测试的正常流程之外，但仍然靠近它们所需的位置。当测试运行时，它会执行各种活动，你需要确保它们按预期工作。你可以在过程中添加确认以确保测试按预期进行。或者，你可能有一个简单的测试，只做一件事，并在最后需要一到多个确认以确保一切正常。所有这些都是好的。
- en: 'Consider the following three examples of test cases. They each do the same
    thing, but I want you to focus on how they are written. Here is the first example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下三个测试用例的例子。它们都做同样的事情，但我希望你关注它们的编写方式。以下是第一个例子：
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This test is one that was used earlier to make sure that we can confirm int
    values. Notice how it performs an action and assigns the result to a local variable.
    Then, that variable is checked to make sure its value matches what is expected.
    If so, the test proceeds to perform another action and assign the result to the
    local variable. This pattern continues, and if all the confirms match the expected
    values, the test passes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试是之前用来确保我们可以确认整数值的测试。注意它如何执行一个动作并将结果分配给一个局部变量。然后，检查该变量以确保其值与预期相符。如果相符，测试将继续执行另一个动作并将结果分配给局部变量。这种模式持续进行，如果所有确认都符合预期值，则测试通过。
- en: 'Here is the same test written in a different form:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相同测试用例的另一种写法：
- en: '[PRE53]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This time, there is no local variable to store the result of each action. Some
    people would consider this an improvement. It *is* shorter. But I feel this hides
    what is being tested. I find it better to think about confirms as something that
    can be removed from a test without changing what a test does. Of course, if you
    do remove a confirm, then the test might miss a problem that the confirm would
    have caught. I’m talking about mentally ignoring confirms to get a feel for what
    a test does, and then thinking about what makes sense to verify along the way.
    Those verification points become the confirms.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，没有局部变量来存储每个动作的结果。有些人可能会认为这是一个改进。它确实更短。但我感觉这隐藏了正在测试的内容。我发现将确认视为可以从测试中移除而不改变测试行为的东西更好。当然，如果你移除了确认，那么测试可能会错过确认本应捕获的问题。我是在谈论心理上忽略确认，以了解测试做了什么，然后思考在过程中哪些内容需要验证。这些验证点变成了确认。
- en: 'Here is another example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This example avoids putting the test steps inside the confirms. However, I feel
    that it goes too far to separate the test steps from the confirms. There’s nothing
    wrong with sprinkling confirms into your test steps. Doing so lets you catch problems
    right away. This example puts all the confirms at the end, which means that it
    also has to wait until the end to catch any problems.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子避免了在确认中放置测试步骤。然而，我感觉它过分地将测试步骤与确认分离。在测试步骤中穿插确认并没有什么问题。这样做可以让你立即发现问题。这个例子将所有确认都放在了最后，这意味着它也必须等到最后才能发现问题。
- en: And then there’s the problem of the multiple result variables needed so that
    each can be checked later. This code looks too forced to me – like a programmer
    who took the long way to reach a goal when there was a simple path available instead.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有这样一个问题，需要多个结果变量以便稍后逐一检查。这段代码在我看来显得有些生硬——就像一个程序员选择了漫长的路径去达到目标，而实际上有一条简单的路径可用。
- en: The first example shows the style of tests written so far in this book, and
    now you can see why they have been written in this manner. They use confirms where
    needed and as close to the point of verification as possible. And they avoid placing
    actual test steps inside the confirms.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子展示了这本书中迄今为止编写的测试风格，现在你可以看到为什么它们要以这种方式编写。它们在需要的地方使用确认，并且尽可能接近验证点。并且它们避免在确认中放置实际的测试步骤。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter took us past the simple ability to confirm true and false values.
    You can now verify anything you need to make sure it matches what you expect.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 本章带我们超越了确认真伪值的基本能力。你现在可以验证任何你需要确保其与预期相符的内容。
- en: We simplified the confirm macros by putting the code into overloaded functions
    with a templated version to handle other types. You saw how to confirm simple
    data types and work with pointers by dereferencing them first.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将代码放入重载函数中，并使用模板版本来处理其他类型，简化了确认宏。你看到了如何确认简单数据类型，并通过先解引用来与指针一起工作。
- en: The code needed to be refactored, and you saw how TDD helps when you need to
    make design changes to your code. I could have written the code in this book to
    make it seem like the code was written perfectly from the very beginning. But
    that wouldn’t help you because nobody writes perfect code from the beginning.
    As our understanding grows, we sometimes need to change the code. And TDD gives
    you the confidence to make those changes as soon as they become known instead
    of waiting – because problems that you delay have a tendency to get bigger instead
    of going away.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 需要重构的代码，你看到了当需要对代码进行设计更改时，TDD是如何帮助你的。我本可以在本书中编写代码，让它看起来像是从一开始就写得完美无缺。但那样做对你没有帮助，因为没有人从一开始就能写出完美的代码。随着我们对知识的理解不断增长，我们有时需要更改代码。而TDD则让你有信心在问题一出现就立即进行更改，而不是等待——因为你推迟解决的问题往往会有扩大的趋势，而不是消失。
- en: And you should be gaining an understanding of how to write your tests and the
    best way to incorporate confirms into your tests.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该正在了解如何编写你的测试，以及将确认信息融入测试的最佳方式。
- en: Up until now, we’ve been working with the C++ features and capabilities found
    in C++ 17\. There is an important new feature found in C++ 20 that will help us
    get line numbers from the compiler. The next chapter will add this C++ 20 feature
    and explore some alternate designs. Even if we stay with the same overall design
    we have now, the next chapter will help you to understand how other testing libraries
    might do things differently.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用C++ 17中找到的C++特性和功能。C++ 20中有一个重要的新特性，可以帮助我们从编译器中获取行号。下一章将添加这个C++
    20特性，并探讨一些替代设计。即使我们保持现在的整体设计不变，下一章也会帮助你理解其他测试库可能如何进行不同的操作。
