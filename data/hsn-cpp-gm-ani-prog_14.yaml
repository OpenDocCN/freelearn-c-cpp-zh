- en: '*Chapter 14*: Using Dual Quaternions for Skinning'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：使用双四元数进行蒙皮'
- en: 'The current skinning implementation blends between skin weights linearly, and
    this is called **Linear Blended Skinning (LBS)** or, sometimes, **Linear Skin
    Blending**. Linearly blending the skin does not preserve the volume of a model,
    which introduces skinning artifacts. An easy way to visualize this artifact is
    to twist one end of a rectangle by 180 degrees, as shown in the following screenshot:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的蒙皮实现在皮肤权重之间线性混合，这称为**线性混合蒙皮（LBS）**或有时称为**线性皮肤混合**。线性混合皮肤不保持模型的体积，这会引入蒙皮伪影。可视化这种伪影的简单方法是将矩形的一端扭曲180度，如下面的屏幕截图所示：
- en: '![Figure 14.1: Comparing linear blended and dual quaternion skinning'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.1：比较线性混合和双四元数蒙皮'
- en: '](img/Figure_14.1_B16191.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.1_B16191.jpg)'
- en: 'Figure 14.1: Comparing linear blended and dual quaternion skinning'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：比较线性混合和双四元数蒙皮
- en: 'An alternate to Linear Skin Blending is **Dual Quaternion Skin Blending**.
    When dual quaternions are used, the volume of the model is maintained. In this
    chapter, you will implement dual quaternion mesh skinning. By the end of this
    chapter, you should be able to use dual quaternions to skin an animated character.
    The following topics are covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 线性皮肤混合的替代方法是**双四元数皮肤混合**。使用双四元数时，模型的体积得以保持。在本章中，您将实现双四元数网格蒙皮。在本章结束时，您应该能够使用双四元数对动画角色进行蒙皮。本章涵盖以下主题：
- en: Introducing dual quaternions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入双四元数
- en: Implementing dual quaternions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现双四元数
- en: Skinning with dual quaternions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用双四元数进行蒙皮
- en: Understanding how to use dual quaternion skinning
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何使用双四元数蒙皮
- en: Introducing dual quaternions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入双四元数
- en: A dual quaternion combines linear and rotational transformations together into
    one variable. This single variable can be interpolated, transformed, and concatenated.
    A dual quaternion can be represented with two quaternions or eight floating-point
    numbers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 双四元数将线性和旋转变换结合到一个变量中。这个单一变量可以进行插值、变换和连接。双四元数可以用两个四元数或八个浮点数表示。
- en: Dual numbers are like complex numbers. A complex number has a real part and
    an imaginary part, and a dual number has a real part and a dual part. Assuming
    ![](img/Formula_14_001.png)is the dual operator, a dual number can be represented
    as ![](img/Formula_14_002.png), where ![](img/Formula_14_003.png) and ![](img/Formula_14_004.png).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 双数就像复数一样。复数有实部和虚部，双数有实部和虚部。假设![](img/Formula_14_001.png)是双重运算符，双数可以表示为![](img/Formula_14_002.png)，其中![](img/Formula_14_003.png)和![](img/Formula_14_004.png)。
- en: 'Operations on dual numbers are done as imaginary numbers, where the dual components
    and real components must be acted on separately. For example, dual quaternion
    addition can be expressed in the following way:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 双数的运算是作为虚数进行的，其中虚部和实部必须分别操作。例如，双四元数的加法可以表示为：
- en: '![](img/Formula_14_005.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_14_005.png)'
- en: Notice how the real and dual parts are added independently.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意实部和虚部是独立添加的。
- en: Important note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: If you are interested in the more formal mathematics behind dual quaternions,
    check out *A Beginner's Guide to Dual-Quaternions* by Ben Kenwright, [at https://cs.gmu.edu/~jmlien/teaching/cs451/uploads/Main/dual-quaternion](https://cs.gmu.edu/~jmlien/teaching/cs451/uploads/Main/dual-quaternion.pdf).pdf.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对双四元数背后更正式的数学感兴趣，请查看Ben Kenwright的*A Beginner's Guide to Dual-Quaternions*，[网址https://cs.gmu.edu/~jmlien/teaching/cs451/uploads/Main/dual-quaternion](https://cs.gmu.edu/~jmlien/teaching/cs451/uploads/Main/dual-quaternion.pdf).pdf。
- en: Dual quaternions are just an extension of dual numbers. The real and dual parts
    are represented by quaternions instead of scalar values, and most of the mathematical
    operations just work. In the next section, you will begin to implement dual quaternions
    in code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 双四元数只是双数的扩展。实部和虚部由四元数代替标量值表示，大多数数学运算都是有效的。在下一节中，您将开始在代码中实现双四元数。
- en: Implementing dual quaternions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现双四元数
- en: In this section, you will implement dual quaternions in code. By the end of
    this section, you will have implemented a dual quaternion struct, along with all
    the mathematical functions needed for using dual quaternions to skin a mesh.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将在代码中实现双四元数。在本节结束时，您将已经实现了一个双四元数结构，以及使用双四元数进行网格蒙皮所需的所有数学函数。
- en: Dual quaternions need to be implemented as structures, similar to transforms
    or matrices. Create two new files, `DualQuaternion.h` and `DualQuaternion.cpp`.
    You will implement the math relevant to dual quaternions in these files.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 双四元数需要被实现为结构，类似于变换或矩阵。创建两个新文件，`DualQuaternion.h`和`DualQuaternion.cpp`。您将在这些文件中实现与双四元数相关的数学。
- en: 'Start by declaring a `DualQuaternion` structure. This structure will allow
    you to access the data in the dual quaternion struct as two quaternions or a floating-point
    array of eight numbers. The constructor should set the dual quaternion to identity.
    The identity dual quaternion has an identity quaternion in its real part and a
    zero quaternion in its dual part, as illustrated in the following code block:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先声明一个`DualQuaternion`结构。这个结构将允许您以两个四元数或八个数字的浮点数组的形式访问双四元数结构中的数据。构造函数应该将双四元数设置为单位。单位双四元数的实部是单位四元数，虚部是零四元数，如下面的代码块所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The real part of a dual quaternion holds rotation data, and the dual part holds
    position data. Dual quaternions do not handle scaling. In the following section,
    you will declare and implement common dual quaternion operations such as addition
    and multiplication.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 双四元数的实部保存旋转数据，虚部保存位置数据。双四元数不处理缩放。在下一节中，您将声明并实现常见的双四元数操作，如加法和乘法。
- en: In the *Implementing dual quaternion operations* subsection, you will implement
    trivial dual quaternion operators such as addition, scaling, multiplication, and
    comparison operators. In the *Measuring, normalizing, and inverting dual quaternions*
    section, you will learn how to implement the dot product for a dual quaternion,
    how to measure the dual quaternion, and how to invert it. In the *Converting transforms
    and dual quaternions* section, you will learn how to convert between the `DualQuaternion`
    and `Transform` structs. Finally, in the *Transforming vectors and points* section,
    you will learn how to transform vectors and points with dual quaternions, as transforms
    or matrices would.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在*实现双四元数操作*子节中，您将实现诸如加法、缩放、乘法和比较运算符之类的平凡双四元数运算符。在*测量、归一化和求逆双四元数*部分，您将学习如何为双四元数实现点积，如何测量双四元数以及如何求逆。在*转换变换和双四元数*部分，您将学习如何在`DualQuaternion`和`Transform`结构之间进行转换。最后，在*变换向量和点*部分，您将学习如何使用双四元数来变换向量和点，就像变换或矩阵一样。
- en: Implementing dual quaternion operations
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现双四元数操作
- en: You will need to define some mathematical operators to work with dual quaternions.
    These functions are addition, scalar multiplication, dual quaternion multiplication,
    and equality comparison operators.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要定义一些数学运算符来处理双四元数。这些函数是加法、标量乘法、双四元数乘法和相等比较运算符。
- en: 'Two dual quaternions are combined through multiplication. Unlike matrices and
    quaternions, dual quaternions multiply left to right. Follow these steps to implement
    the dual quaternion operations:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过乘法将两个双四元数组合在一起。与矩阵和四元数不同，双四元数从左到右相乘。按照以下步骤实现双四元数操作：
- en: 'Declare the addition, scalar multiplication, dual quaternion multiplication,
    and equality comparison operators in `DualQuaternion.h`, like this:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DualQuaternion.h`中声明加法、标量乘法、双四元数乘法和相等比较运算符，就像这样：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implement the addition, scalar multiplication, and comparison functions. They
    are all component-wise operations. Perform component-wise operations separately
    on the real and dual components of the dual quaternion, as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现加法、标量乘法和比较函数。它们都是逐分量操作。分别在双四元数的实部和双部上执行逐分量操作，如下所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Start implementing dual quaternion multiplication by first making sure both
    dual quaternions are normalized, as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先确保两个双四元数都归一化，然后开始实现双四元数乘法：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Combine the real parts of both the normalized quaternions together. The dual
    parts are more involved because![](img/Formula_14_006.png) must equal `0`. Satisfy
    this requirement by multiplying the dual and real sides of both quaternions and
    adding the results, like this:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个归一化四元数的实部合并在一起。双部更复杂，因为![](img/Formula_14_006.png)必须等于`0`。通过将两个四元数的双部和实部相乘并将结果相加来满足此要求，就像这样：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For the most part, the common dual quaternion operators are intuitive, but the
    multiplication order of dual quaternions being against convention makes them a
    little hard to deal with. In the next section, you will learn about the dot product
    and normal implementations for dual quaternions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，常见的双四元数运算符是直观的，但是双四元数的乘法顺序与惯例相反，这使它们有点难以处理。在下一节中，您将了解双四元数的点积和正常实现。
- en: Measuring, normalizing, and inverting dual quaternions
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量、归一化和求逆双四元数
- en: 'The dot product measures how similar two dual quaternions are. The rules for
    the dual quaternion dot product are the same as the vector and quaternion dot
    products. The result of the dot product is a scalar value that has the following
    properties:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 点积测量两个双四元数的相似程度。双四元数点积的规则与向量和四元数点积相同。点积的结果是一个标量值，具有以下属性：
- en: It is positive if the dual quaternions point in the same direction.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果双四元数指向相同方向，则为正。
- en: It is negative if the dual quaternions point in opposite directions.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果双四元数指向相反方向，则为负。
- en: It is zero if the dual quaternions are perpendicular.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果双四元数垂直，则为零。
- en: Non-unit dual quaternions can introduce an unwanted skew into the transformation
    represented by a dual quaternion. To normalize a dual quaternion, both the real
    part and dual part will need to be divided by the length of the real part.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 非单位双四元数可能会引入不需要的扭曲，这是由双四元数表示的变换引起的。要归一化双四元数，实部和双部都需要除以实部的长度。
- en: Normalizing a dual quaternion is like normalizing a regular quaternion, operating
    mainly on the real part. First, find the length of the real part of the dual quaternion,
    then divide both the real and dual parts by the length. This normalizes both the
    real and dual parts to the length of the real part.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 归一化双四元数就像归一化常规四元数一样，主要操作在实部上。首先，找到双四元数的实部的长度，然后将实部和双部都除以长度。这将实部和双部都归一化为实部的长度。
- en: Since the dot product only considers direction, the imaginary part of the dual
    quaternion is not used. Find the dot product of the real parts of both dual quaternions.
    The dual quaternion `conjugate` operation is an extension of quaternion conjugates,
    to find the conjugate of both real and dual parts respectively.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于点积只考虑方向，双四元数的虚部不会被使用。找到两个双四元数的实部的点积。双四元数`共轭`操作是四元数共轭的扩展，分别找到实部和双部的共轭。
- en: 'Follow these steps to implement the `dot product`, `invert`, and `normalize`
    functions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现`点积`、`求逆`和`归一化`函数：
- en: 'Declare the dual quaternion dot product, conjugate and normalization functions
    in  `DualQuaternion.h`, as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DualQuaternion.h`中声明双四元数点积、共轭和归一化函数，如下所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implement the dot product by finding the quaternion dot product of the real
    parts of both dual quaternions and returning their result, like this:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过找到两个双四元数的实部的四元数点积来实现点积，并返回它们的结果，就像这样：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implement the `conjugate` function by taking the quaternion conjugate of the
    real and dual parts separately, like this:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过分别对实部和双部取四元数共轭来实现`conjugate`函数，如下所示：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement the `normalized` function by finding the length of the real part
    and scaling both the dual and real parts by the inverse of the length, as follows:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过找到实部的长度并将双部和实部都缩放为长度的倒数来实现`normalized`函数，如下所示：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Implement a `normalize` function. Unlike `normalized`, the `normalize` function
    takes a dual quaternion reference and normalizes it in place, like this:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`normalize`函数。与`normalized`不同，`normalize`函数接受双四元数引用并就地对其进行规范化，如下所示：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If a dual quaternion changes over time, it might become non-normalized due to
    a floating-point error. If the length of the real part of the dual quaternion
    is not `1`, the dual quaternion needs to be normalized. Instead of checking the
    length against one, which would involve a square root operation, you should check
    if the square length is `1`, and this way, the operation is much faster. In the
    following section, you will learn how to convert between transforms and dual quaternions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果双四元数随时间变化，由于浮点误差可能变得非规范化。如果双四元数的实部长度不是`1`，则需要对双四元数进行规范化。而不是检查长度是否等于一，这将涉及平方根运算，您应该检查平方长度是否为`1`，这样操作速度更快。在接下来的部分，您将学习如何在变换和双四元数之间转换。
- en: Converting transforms and dual quaternions
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换变换和双四元数
- en: Dual quaternions hold similar data to transforms, without the scale component.
    It's possible to convert between the two, but the scale will be lost.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 双四元数包含与变换类似的数据，但没有缩放分量。可以在两者之间进行转换，但会丢失缩放。
- en: When converting a transform to a dual quaternion, the real part of a dual quaternion
    maps to the rotation of a transform. To calculate the dual part, create a pure
    quaternion from the translation vector of the transform. Then, multiply this pure
    quaternion by the rotation of the transform. The result needs to be halved—divide
    it by two or multiply it by 0.5.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将变换转换为双四元数时，双四元数的实部映射到变换的旋转。要计算双部分，从变换的平移向量创建一个纯四元数。然后，将这个纯四元数乘以变换的旋转。结果需要减半——除以二或乘以0.5。
- en: When converting a dual quaternion to a transform, the transform rotation still
    maps the real part of the dual quaternion. To find the position, multiply the
    dual part by two and combine the result with the inverse of the transform's rotation.
    This yields a pure quaternion. The vector part of this pure quaternion is the
    new position.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将双四元数转换为变换时，变换的旋转仍然映射到双四元数的实部。要找到位置，将双部乘以二并将结果与变换的旋转的倒数组合。这将产生一个纯四元数。这个纯四元数的向量部分就是新的位置。
- en: 'Follow these steps to implement the code to convert between `Transform` and
    `DualQuaternion` objects:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现在`Transform`和`DualQuaternion`对象之间转换的代码：
- en: 'Declare functions to convert a dual quaternion to a transform and a transform
    to a dual quaternion in `DualQuaternion.h`, as follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DualQuaternion.h`中声明函数，将双四元数转换为变换和将变换转换为双四元数，如下所示：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Implement the `transformToDualQuat` function. The resulting dual quaternion
    does not need to be normalized. The code for this can be seen in the following
    snippet:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`transformToDualQuat`函数。生成的双四元数不需要被规范化。以下代码中可以看到这个过程：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Implement the `dualQuatToTransform` function. The input dual quaternion is
    assumed to already be normalized. The code for this can be seen in the following
    snippet:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`dualQuatToTransform`函数。假定输入的双四元数已经被规范化。以下代码中可以看到这个过程：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Dual quaternions can be converted to and from matrices as well; however, that
    operation is generally not used. Dual quaternions are used to replace matrices
    in the skinning pipeline, so the matrix conversion isn't necessary. In the following
    section, you will explore how a dual quaternion can transform a vector or a point.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 双四元数也可以转换为矩阵，反之亦然；然而，通常不使用该操作。双四元数用于替换蒙皮流程中的矩阵，因此矩阵转换并不是必要的。在接下来的部分，您将探讨双四元数如何转换向量或点。
- en: Transforming vectors and points
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变换向量和点
- en: Dual quaternions contain rigid transformation data. This means that dual quaternions
    can be used to transform vectors and points. To transform a point by a dual quaternion,
    break the dual quaternion down into rotation and position components, then transform
    the vector the same way a transform would, but without scale.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 双四元数包含刚性变换数据。这意味着双四元数可以用于变换向量和点。要通过双四元数变换点，将双四元数分解为旋转和位置分量，然后以变换的方式变换向量，但不包括缩放。
- en: 'Follow these steps to declare and implement `transform` functions for both
    vectors and points using dual quaternions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤声明和实现使用双四元数对向量和点进行变换的`transform`函数：
- en: 'Declare the `transformVector` and `transformPoint` functions in `DualQuaternion.h`,
    like this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DualQuaternion.h`中声明`transformVector`和`transformPoint`函数，如下所示：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Rotating a vector by a dual quaternion is trivial. Since the real part of the
    dual quaternion contains the rotation, multiply the vector by the real part of
    the dual quaternion, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双四元数旋转向量是微不足道的。由于双四元数的实部包含旋转，将向量乘以双四元数的实部，如下所示：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To transform a point by a dual quaternion, convert the dual quaternion to rotation
    and translation components. Then, apply the following translation and rotation
    components to the vector: `rotation * vector + translation`. This formula works
    the same way as a transform moving the point, but without a scale component. The
    code for this can be seen in the following snippet:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要通过双四元数变换点，将双四元数转换为旋转和平移分量。然后，将这些平移和旋转分量应用于向量：`旋转 * 向量 + 平移`。这个公式的工作方式与变换移动点的方式相同，但没有缩放分量。以下代码中可以看到这个过程：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The dual quaternion class can now be used in place of the `Transform` class.
    Dual quaternions can be arranged in a hierarchy and combined using multiplication,
    and with these new functions, a dual quaternion can transform a point or a vector
    directly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用双四元数类代替`Transform`类。双四元数可以按层次结构排列，并使用乘法进行组合，通过这些新函数，双四元数可以直接转换点或矢量。
- en: In this section, you implemented dual quaternions in code. All the functions
    that you will need to work with dual quaternions are implemented as well. In the
    next section, you will learn how to do mesh skinning using dual quaternions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您在代码中实现了双四元数。您还实现了所有需要使用双四元数的函数。在下一节中，您将学习如何使用双四元数进行网格蒙皮。
- en: Skinning with dual quaternions
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用双四元数进行蒙皮
- en: In this section, you will learn how to modify the skinning algorithm so that
    it works with dual quaternions instead of matrices. Specifically, you will replace
    the skin matrix with a skin dual quaternion that will transform both the vertex
    position and normal position.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何修改蒙皮算法，使其使用双四元数而不是矩阵。具体来说，您将用双四元数替换蒙皮矩阵，这将同时转换顶点位置和法线位置。
- en: 'The problem dual quaternions solve is the linear blending of matrices, which
    is currently implemented in a vertex shader. Specifically, this is the bit of
    code that introduces the skinning artifacts:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 双四元数解决的问题是矩阵的线性混合，目前在顶点着色器中实现。具体来说，这是引入蒙皮伪影的代码段：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are three stages in the animation pipeline where it makes sense to replace
    matrices with dual quaternions. Each of these will have the same result. The three
    places where this should be implemented are listed here, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画流水线中有三个阶段，可以用双四元数替换矩阵。每个阶段都会产生相同的结果。应该实现双四元数的三个地方如下所示：
- en: Convert the matrices to dual quaternions in the vertex shader.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶点着色器中将矩阵转换为双四元数。
- en: Convert the matrices of the current pose to dual quaternions, then pass dual
    quaternions to the vertex shader.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前姿势的矩阵转换为双四元数，然后将双四元数传递给顶点着色器。
- en: Convert each transform of the current pose to a dual quaternion, then accumulate
    the world transform as a dual quaternion.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前姿势的每个变换转换为双四元数，然后累积世界变换为双四元数。
- en: In this chapter, you will implement the third option and add a `GetDualQuaternionPalette`
    function to the `Pose` class. You will also add an overload for the `GetInvBindPose`
    function of the `Skeleton` class. In the following section, you will begin to
    modify the `Skeleton` class to support dual quaternion skinned animation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将实现第三个选项，并向`Pose`类添加`GetDualQuaternionPalette`函数。您还将为`Skeleton`类的`GetInvBindPose`函数添加一个重载。在接下来的部分中，您将开始修改`Skeleton`类以支持双四元数蒙皮动画。
- en: Modifying the pose class
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改姿势类
- en: 'The `Pose` class needs two new functions—one to retrieve the world dual quaternion
    of a specified joint (that is, `GetGlobalDualQuaternion`), and one to convert
    the pose to a dual quaternion palette. Follow these steps to declare and implement
    these functions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pose`类需要两个新函数——一个用于检索指定关节的世界双四元数（即`GetGlobalDualQuaternion`），另一个用于将姿势转换为双四元数调色板。按照以下步骤声明和实现这些函数：'
- en: 'Add declarations for the `GetDualQuaternionPalette` and `GetGlobalDualQuaternion`
    functions to the `Pose` class in `Pose.h`, as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Pose.h`中的`Pose`类中添加`GetDualQuaternionPalette`和`GetGlobalDualQuaternion`函数的声明，如下所示：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Implement the `GetGlobalDualQuaternion` function to return the world space
    dual quaternion of a joint, as follows:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`GetGlobalDualQuaternion`函数以返回关节的世界空间双四元数，如下所示：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Implement the `GetDualQuaternionPalette` function, which should loop through
    all the joints stored in the current pose and store their world space dual quaternions
    in the output vector, as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`GetDualQuaternionPalette`函数，该函数应该循环遍历当前姿势中存储的所有关节，并将它们的世界空间双四元数存储在输出向量中，如下所示：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The dual quaternion conversion happens in joint local space, and because of
    this, you didn't need to add any additional data to the `Pose` class and were
    able to add two new functions instead. In the next section, you will modify the
    `Skeleton` class to provide the inverse bind pose as dual quaternions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 双四元数转换发生在关节本地空间中，因此您不需要向`Pose`类添加任何额外的数据，而是能够添加两个新函数。在下一节中，您将修改`Skeleton`类以提供双四元数的逆绑定姿势。
- en: Modifying the skeleton class
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改骨骼类
- en: 'In order to skin a mesh using dual quaternions, the inverse bind pose of the
    mesh will need to be expressed using dual quaternions as well. In this section,
    you will add an overload to the `GetInvBindPose` function that will fill out a
    reference to a vector of dual quaternion objects. Follow these steps to implement
    the new `GetInvBindPose` function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用双四元数对网格进行蒙皮，网格的逆绑定姿势也需要用双四元数表示。在本节中，您将为`GetInvBindPose`函数添加一个重载，该函数将填充一个双四元数对象的引用。按照以下步骤实现新的`GetInvBindPose`函数：
- en: 'Declare an additional `GetInvBindPose` function in the `Skeleton` class that
    will take a reference to a vector of dual quaternions as an argument. When the
    function is finished, it will have filled out the vector with inverse bind pose
    dual quaternions. The code for this can be seen in the following snippet:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Skeleton`类中声明一个额外的`GetInvBindPose`函数，该函数将以双四元数向量的引用作为参数。当函数完成时，它将填充向量与逆绑定姿势双四元数。可以在以下片段中看到此代码：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Implement the `GetInvBindPose` function override in `Skeleton.cpp`. Resize
    the input vector to be as large as the bind pose. For each joint, get the global
    dual quaternion representation of the joint. Finally, store the conjugate of each
    world space dual quaternion in the output vector. The code for this can be seen
    in the following snippet:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Skeleton.cpp`中重写`GetInvBindPose`函数。调整输入向量的大小与绑定姿势一样大。对于每个关节，获取关节的全局双四元数表示。最后，将每个世界空间双四元数的共轭存储在输出向量中。可以在以下片段中看到此代码：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can now convert both an animated pose and the inverse bind pose of a skeleton
    into arrays of dual quaternions. But in order to use these dual quaternions in
    a shader, they need to be passed to that shader somehow. In the following section,
    you will implement a new dual quaternion uniform type to do this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将骨骼的动画姿势和逆绑定姿势转换为双四元数数组。 但是，为了在着色器中使用这些双四元数，它们需要以某种方式传递到该着色器。 在下一节中，您将实现一个新的双四元数统一类型来执行此操作。
- en: Creating new uniform types
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新的统一类型
- en: In order to use dual quaternions as a replacement for matrices, there needs
    to be a way to use them as shader uniforms. A dual quaternion can be treated as
    a 2x4 matrix, which can be set with the `glUniformMatrix2x4fv` function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将双四元数作为矩阵的替代品，需要一种方法将它们用作着色器统一变量。 双四元数可以被视为2x4矩阵，并且可以使用`glUniformMatrix2x4fv`函数进行设置。
- en: 'Declare a template specialization for the `Uniform` class using a `DualQuaternion`.
    The `Set` function needs to be implemented. It should use the `glUniformMatrix2x4fv`
    function to upload the dual quaternion array as a 2x4 matrix. Implement the new
    `Set` function, as shown in the following code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DualQuaternion`为`Uniform`类声明模板特化。 需要实现`Set`函数。 它应该使用`glUniformMatrix2x4fv`函数将双四元数数组上传为2x4矩阵。
    实现新的`Set`函数，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since the `Set` function is templated, it does not need to be declared in the
    header file; it's just a specialized instance of the function. In the following
    section, you will explore how to implement a vertex shader that uses dual quaternions
    for skinning.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Set`函数是模板化的，因此不需要在头文件中声明； 它只是函数的专门实例。 在下一节中，您将探讨如何实现使用双四元数进行蒙皮的顶点着色器。
- en: Creating a dual quaternion shader
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建双四元数着色器
- en: The only thing left to do in order to support dual quaternion skinning is to
    implement a vertex shader. The new vertex shader will be similar to its linear-blended
    skinning counterpart. Instead of having two `mat4` uniform arrays for the matrix
    palettes, this shader will have two `mat2x4` uniform arrays for dual quaternions.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持双四元数蒙皮，唯一剩下的事情就是实现顶点着色器。 新的顶点着色器将类似于其线性混合蒙皮对应物。 此着色器将不再具有用于矩阵调色板的两个`mat4`统一数组，而是具有用于双四元数的两个`mat2x4`统一数组。
- en: The shader will have to blend dual quaternions together. Whenever two quaternions
    (the real part of the dual quaternions) are blended, there is a chance that the
    blend happens in the wrong neighborhood and the quaternion interpolates the long
    way around. Neighborhooding will need to be kept in mind when blending.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器将不得不混合双四元数。 每当两个四元数（双四元数的实部）混合时，都有可能混合发生在错误的邻域，并且四元数以长方式插值。 在混合时需要牢记邻域。
- en: 'Follow these steps to implement the new vertex shader:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现新的顶点着色器：
- en: 'Start declaring the shader with the `model`, `view`, and `projection` uniforms,
    as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始声明着色器与`model`，`view`和`projection`统一变量，如下所示：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Declare the vertex structure. The input values for a vertex are as follows:
    `position`, `normal`, texture coordinates, and weight and joint influences. Each
    vertex should have up to four weights and influences. The code for this can be
    seen in the following snippet:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明顶点结构。 顶点的输入值如下：`position`，`normal`，纹理坐标，权重和关节影响。 每个顶点应该有最多四个权重和影响。 可以在以下代码片段中看到此代码：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Declare the output values passed to the fragment shader. These are the vertex
    normal, the fragment position in the world space, and the `uv` coordinate, as
    illustrated in the following code snippet:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明传递给片段着色器的输出值。 这些是顶点法线，世界空间中的片段位置和`uv`坐标，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Declare the skinning uniforms. These are no longer arrays of `mat4`; they are
    now arrays of `mat2x4`. A `mat2x4` has two columns with four rows. Subscripting
    a `mat2x4`, index `0` is the real part of our dual quaternion, and index `1` is
    the dual part. The code can be seen in the following snippet:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明蒙皮统一变量。 这些不再是`mat4`数组； 它们现在是`mat2x4`数组。 `mat2x4`有两列四行。 对`mat2x4`进行下标，索引`0`是双四元数的实部，索引`1`是双部。
    代码可以在以下代码片段中看到：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Implement a quaternion multiply function. The code for this is the same as
    that created in [*Chapter 4*](B16191_04_Final_JC_ePub.xhtml#_idTextAnchor069),
    *Implementing Quaternions*, and can be seen in the following snippet:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现四元数乘法函数。 这个函数的代码与[*第4章*](B16191_04_Final_JC_ePub.xhtml#_idTextAnchor069)中创建的代码相同，可以在以下代码片段中看到：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Implement the `normalize` dual quaternion function. A dual quaternion is normalized
    by dividing both its real and dual parts by the magnitude of the real part. The
    code can be seen in the following snippet:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`normalize`双四元数函数。 通过将其实部和双部分都除以实部的大小来规范化双四元数。 代码可以在以下代码片段中看到：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Implement the dual quaternion multiplication function to combine dual quaternions,
    as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现双四元数乘法函数以组合双四元数，如下所示：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Implement a function to transform vectors by dual quaternions, as follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个通过双四元数变换向量的函数，如下所示：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Implement a function to transform points by dual quaternions, as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个通过双四元数变换点的函数，如下所示：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement the main method of the vertex shader. Start the implementation by
    neighborhooding joints 1, 2, and 3 (`joints.y`, `joints.z`, `joints.w`) to joint
    0 (`joints.x`), as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现顶点着色器的主要方法。 通过将关节1、2和3（`joints.y`，`joints.z`，`joints.w`）邻近到关节0（`joints.x`）来开始实现：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Combine the world space dual quaternion of each joint with the inverse bind
    pose dual quaternion of the same joint. Remember: dual quaternion multiplication
    is left to right. Store the result of each multiplication in a new variable. The
    code can be seen in the following snippet:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个关节的世界空间双四元数与相同关节的逆绑定姿势双四元数相结合。 记住：双四元数乘法是从左到右的。 将每次乘法的结果存储在一个新变量中。 代码可以在以下代码片段中看到：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Blend the four skinning dual quaternions together. Implement the blend using
    dual quaternion scalar multiplication and dual quaternion addition. Don''t forget
    to normalize the skin dual quaternion. The code can be seen in the following snippet:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将四个蒙皮双四元数混合在一起。使用双四元数标量乘法和双四元数加法实现混合。不要忘记对皮肤双四元数进行归一化。代码可以在以下片段中看到：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Skin the vertex using the `transformPoint` function with the skin dual quaternion.
    Put the resulting `vec4` through the normal model-view-projection pipeline, as
    follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`transformPoint`函数和皮肤双四元数对顶点进行蒙皮。将结果的`vec4`通过正常的模型视图投影管线，如下所示：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Transform the normal similarly. Don''t forget to pass the `uv` coordinates
    to the fragment shader as well. The code can be seen in the following snippet:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地转换法线。不要忘记将`uv`坐标传递给片段着色器。代码可以在以下片段中看到：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Any animation that animates scale will not work with this method. This dual
    quaternion implementation does not have scaling support. It is possible to hack
    scaling support on top of dual quaternions, but the work involved outweighs its
    benefits in terms of performance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 任何涉及缩放的动画都无法使用这种方法。这种双四元数实现不支持缩放。可以在双四元数之上实现缩放支持，但涉及的工作量超过了其性能上的好处。
- en: In this section, you learned how to implement skinning with dual quaternions.
    This includes modifying pose data and the `Skeleton` class, creating new uniforms,
    and building a new shader. In the following section, you will explore how to use
    the dual quaternion code written up to this point.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何使用双四元数实现蒙皮。这包括修改姿势数据和`Skeleton`类，创建新的统一变量，并构建新的着色器。在接下来的部分中，您将探讨如何使用迄今为止编写的双四元数代码。
- en: Understanding how to use dual quaternion skinning
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解如何使用双四元数蒙皮
- en: This section will explore how you can take the dual quaternion skinning code
    that you have written so far and implement it in an existing application. This
    code is meant to be for reference only; you do not have to follow along with it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨如何将迄今为止编写的双四元数蒙皮代码应用于现有应用程序。此代码仅供参考；您无需跟随它。
- en: Using the dual quaternion-skinned shader is trivial; it would be easy to switch
    between skinning methods at runtime. The following steps demonstrate how the dual
    quaternion shader or a linear-skinned shader could be used to animate the same
    model.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双四元数蒙皮着色器非常简单；在运行时轻松切换蒙皮方法。以下步骤演示了如何使用双四元数着色器或线性蒙皮着色器来对同一模型进行动画化。
- en: 'Keep track of both the dual quaternion pose palette and inverse bind pose palette,
    as well as the linear blend pose palette and inverse bind pose palette. Have a
    look at the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪双四元数姿势调色板和反向绑定姿势调色板，以及线性混合姿势调色板和反向绑定姿势调色板。看一下以下代码：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When the application initializes, cache the inverse bind pose both as a vector
    of matrices and a vector of dual quaternions, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序初始化时，将反向绑定姿势缓存为矩阵向量和双四元数向量，如下所示：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When an animation is sampled, convert the resulting pose palette to both dual
    quaternion and linear blend versions, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在对动画进行采样时，将生成的姿势调色板转换为双四元数和线性混合版本，如下所示：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When the animation is being rendered, make sure that the correct uniforms are
    used, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染动画时，请确保使用正确的统一变量，如下所示：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this sample, switching between the linear blended skinning and the dual quaternion
    skinning shaders is as simple as changing the value of the `mSkinningMethod` variable.
    This works because the only difference between the two shaders is the pose palette
    uniforms.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，轻松切换线性混合蒙皮和双四元数蒙皮着色器只需更改`mSkinningMethod`变量的值。这是因为两种着色器之间唯一的区别是姿势调色板统一变量。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the math behind dual quaternions and implemented
    a dual quaternion class. You discovered some of the skinning artifacts that can
    result from linear blend skinning and how dual quaternions can be used to avoid
    these artifacts. The dual quaternion skinning shader you implemented in this chapter
    can be used to replace the linear blend skinning shader.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了双四元数背后的数学知识，并实现了双四元数类。您发现了线性混合蒙皮可能产生的一些问题，并了解了如何使用双四元数来避免这些问题。本章中实现的双四元数蒙皮着色器可以用来替换线性混合蒙皮着色器。
- en: If you look under `Chapter14` in the downloadable materials for this book, there
    are two samples. `Sample00` contains all the code up to this point. `Sample01`
    renders the same twisting cube model twice. The first cube is rendered with a
    linear blend skinning shader. The second one is rendered with a dual quaternion
    shader.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本书的可下载材料中查看`Chapter14`，会发现有两个示例。`Sample00`包含到目前为止的所有代码。`Sample01`将相同的扭曲立方体模型渲染两次。第一个立方体使用线性混合蒙皮着色器进行渲染。第二个使用双四元数着色器进行渲染。
- en: In the next chapter, you will explore how indexed drawing can be used to animate
    large crowds. This is interesting because it involves moving pose generation to
    the **graphics processing unit** (**GPU**) and performing the entire skinned animation
    pipeline in a vertex shader.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将探讨如何使用索引绘制来对大型人群进行动画化。这很有趣，因为它涉及将姿势生成移动到**图形处理单元**（**GPU**）并在顶点着色器中执行整个蒙皮动画管线。
