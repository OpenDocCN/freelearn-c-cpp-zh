- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: The Fastest C++ Code is Inline Assembly
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最快的C++代码是内联汇编
- en: '*Lower than this you should* *not get*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*低于这个水平，你不应该* *达到*'
- en: In the fast-paced world of C++ developers, where efficiency is paramount, optimizing
    code to squeeze out every last drop of performance has always been a fascinating
    challenge. This journey often takes developers down to the very roots of computing,
    where C++ meets assembly language, and every CPU cycle counts.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++开发者快速发展的世界中，效率至关重要，优化代码以榨取最后一滴性能始终是一个迷人的挑战。这次旅程经常将开发者带到计算的根源，在那里C++遇到汇编语言，每个CPU周期都至关重要。
- en: Circa three decades ago, during the wild 90s, programmers frequently had to
    manually craft every byte of executable code, often diving into the murky waters
    of assembly language (and even lower) to achieve the desired performance. These
    early pioneers of optimization developed techniques that, while rudimentary by
    today’s standards, laid the groundwork for understanding the power and limitations
    of both C++ and assembly.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 大约三十年前，在90年代的狂野时期，程序员经常不得不手动编写每字节的可执行代码，经常深入到汇编语言（甚至更低级别）的浑浊水域，以实现所需的性能。这些早期的优化先驱们开发了虽然现在看来基础，但为理解C++和汇编的强大功能和局限性奠定了基础。
- en: This exploration delves into the specifics of optimizing a seemingly simple
    task, lighting up a pixel on the screen, by comparing handcrafted and optimized
    assembly routines from three decades ago with the modern-day output of advanced
    compilers such as Clang, GCC, and MSVC. As we navigate through the evolution of
    compilers, we’ll see how the balance between human intuition and machine-generated
    optimization has shifted, offering new insights into the ever-evolving relationship
    between the code we write and the machine that ultimately runs our programs. As
    a side note, in this chapter, we’ll focus on Intel’s x86 family of processors
    and delve into specific features, while leaving coverage of the ARM architecture
    for another book, potentially by a different author.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这次探索深入研究了优化一个看似简单的任务——在屏幕上点亮一个像素——的具体细节，通过比较三十年前手工编写的优化汇编程序与现代高级编译器（如Clang、GCC和MSVC）的输出。随着我们穿越编译器的演变历程，我们将看到人类直觉与机器生成优化之间的平衡是如何变化的，这为我们提供了关于我们编写的代码与最终运行程序的机器之间不断演变的关系的新的见解。作为旁注，在本章中，我们将专注于英特尔x86处理器系列，深入探讨特定功能，而将ARM架构的覆盖留给另一本书，可能由不同的作者撰写。
- en: 'In this chapter, you will learn the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: How to use assembly code to speed up your routines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用汇编代码来加速你的程序
- en: How not to use assembly code and trust your compiler’s optimizer to come up
    with the fastest solution
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何不使用汇编代码，并信任编译器的优化器来提供最快的解决方案
- en: Light me a pixel
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点亮一个像素
- en: Circa 30 years ago, at the nearer end of the wild 90s, the author of these lines
    spent quite a significant time optimizing code that was supposed to run as fast
    as possible, consuming the least amount of resources while showing incredible
    spinning graphics on a screen (there was also scrolling involved, too, and other
    not relevant calculations).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 大约30年前，在90年代末期这个狂野的时期，本文作者花费了大量时间优化代码，使其尽可能快地运行，消耗最少的资源，同时在屏幕上显示令人难以置信的旋转图形（还涉及到滚动和其他不相关的计算）。
- en: These applications were called demos (intros, etc.) and showcased some spectacular
    graphical effects, backed by a strong mathematical background, and had an in-house
    developed graphical engine; in those days, there was no DirectX to take all those
    nasty low-level details off your plate, so all had to be done by hand. Methods
    for pixel color calculation, color palette setting, vertical retrace of the CRT
    screen, and flipping of back and front buffers were all coded by hand, using C++
    of the 90s and some assembly language routines for the time-critical bits.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序被称为演示（开场白等），展示了某些令人惊叹的图形效果，背后有强大的数学基础，并拥有自家的图形引擎；在当时，没有DirectX来处理所有那些低级细节，所以所有这些都必须手动完成。像素颜色计算、颜色调色板设置、CRT屏幕的垂直回扫和前后缓冲区的翻转都是用90年代的C++和一些汇编语言例程编写的，用于时间敏感的部分。
- en: 'One of these methods was putting a pixel on the screen, which, in its simplest
    incarnation of the method, looked like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法之一是在屏幕上放置一个像素，在其方法最简单的形式中，看起来是这样的：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'I’ll spare you the very low-level details such as how segment/offset memory
    worked 30 years ago. Instead, imagine that the following apply:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我将省略30年前如何工作的一些非常低级细节，例如段/偏移内存是如何工作的。相反，想象以下内容适用：
- en: You are using DOS (in 1994, in the wild-far-eastern part of Europe, almost everyone
    who had a PC used DOS – kudos to the 0.1 percent of early Linux adopters)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在使用DOS（在1994年，在狂野的东欧部分，几乎每个拥有PC的人都使用DOS – 向早期Linux用户的0.1%致敬）
- en: You are also using a special graphic mode, 0x13 (almost all the games used this
    mode because it allowed 256 colors to be drawn on the screen using the mysterious
    320 by 200 resolution, whose origins only IBM engineers from 40 years ago know)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还在使用一种特殊的图形模式，0x13（几乎所有的游戏都使用这种模式，因为它允许在屏幕上使用神秘的320×200分辨率绘制256种颜色，其起源只有40年前的IBM工程师知道）
- en: In this case, if you put a byte at the **0xA000** segment and a specific offset,
    the graphic card will light up a pixel at the specific coordinates, which can
    be obtained from the preceding formula.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果你在 **0xA000** 段和特定的偏移量处放置一个字节，显卡将在特定的坐标处点亮一个像素，这可以从前面的公式中获得。
- en: Now, after several iterations of the code, the aforementioned programmer observed
    that the routine was not that optimal, and it could have benefited from some optimizations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，经过几轮代码迭代后，上述程序员观察到该程序流程并不那么优化，它可以从一些优化中受益。
- en: 'Please bear with me; the code that was generated by the affordable compiler
    (the one you just copied from the disk that we mentioned in [*Chapter 2*](B22235_02.xhtml#_idTextAnchor026)
    of the book) is in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请耐心等待；由经济型编译器生成的代码（就是你刚刚从磁盘上复制的那份，我们在书中 [*第2章*](B22235_02.xhtml#_idTextAnchor026)
    中提到的）在以下屏幕截图里：
- en: '![Figure 8.1 – Everyone’s favorite Turbo Debugger from 30 years ago](img/B22235_08_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 30年前大家最喜欢的Turbo Debugger](img/B22235_08_01.jpg)'
- en: Figure 8.1 – Everyone’s favorite Turbo Debugger from 30 years ago
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 30年前大家最喜欢的Turbo Debugger
- en: Now, this looks pretty wild, considering the age of it, but again, we need just
    a bit of patience, and all the mystery surrounding why it’s here will be revealed.
    You see, we were discussing how the code generated by the compiler is far from
    being optimal.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑到它的年代，这看起来相当疯狂，但再次强调，我们只需要一点耐心，围绕为什么它在这里的所有谜团都将揭晓。你看，我们正在讨论编译器生成的代码远非最优。
- en: Let’s take a moment to consider this piece of code. After giving it some thought,
    especially from the perspective of someone familiar with assembly language, which
    is becoming increasingly rare these days, it might be clear to them that the compiler
    didn’t struggle as much as we might expect.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间考虑这段代码。经过一番思考，尤其是从熟悉汇编语言的人的角度来看，这在当今越来越少见，他们可能会清楚地意识到编译器并没有像我们预期的那样挣扎。
- en: 'The following is the assembly code that the compiler generated for the **putpixel**
    routine:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为 **putpixel** 程序生成的汇编代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For those not familiar with the notation, **[]** represents the data at the
    address given in the square parentheses, so the parameters are being passed in
    like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不熟悉这种表示法的人来说，**[]** 代表括号内地址的数据，因此参数是这样传递的：
- en: The **x** coordinate of the pixel ( from **[bp+4]** )
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素点的 **x** 坐标（从 **[bp+4]**）
- en: The **y** coordinate of the pixel ( from **[bp+6]** )
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像素点的 **y** 坐标（从 **[bp+6]**）
- en: The color value to set ( from **[bp+8]** )
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要设置的色彩值（从 **[bp+8]**）
- en: Indeed, the code as is contains a lot of unnecessary memory access to move data
    around, when those operations could have been kept in registers, and there is
    quite a lot of unnecessary access to various memory areas, which can be skipped.
    The code compiled by the compiler of the day generated code that was easy to debug,
    but which could have been written much neater. Compilers today generate the same
    kind of code, having a very similar performance, when compiling in Debug mode
    but once you switch them to optimized Release mode, they will do magic.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，当前的代码包含了很多不必要的内存访问来移动数据，而这些操作本可以保留在寄存器中，而且有很多不必要的对各个内存区域的访问，这些是可以跳过的。当时编译器生成的代码易于调试，但可以编写得更整洁。今天的编译器在调试模式下编译时生成相同类型的代码，性能非常相似，但一旦切换到优化的发布模式，它们就会施展魔法。
- en: Modern CPUs are highly complex beasts; when running in protected mode, they
    employ various techniques, such as out-of-order execution, instruction pipelining,
    and other techniques that make really low-level performance analysis nowadays
    quite difficult to nail down properly... but old machines were much simpler! Or
    just use DOS on a modern computer and you will get the same feeling.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现代CPU是非常复杂的生物；在保护模式下运行时，它们采用各种技术，如乱序执行、指令流水线和其他技术，使得现在对真正低级性能的分析相当困难……但旧机器要简单得多！或者，你可以在现代计算机上使用DOS，你会有同样的感觉。
- en: 'Not considering that protected mode was introduced in the early 80286 processors,
    DOS simply could not handle it (and still can’t), so it stuck to what it knew
    best: running programs in real mode. While running in real mode, the processor
    just executed one instruction after the other, and there even was an instruction
    table explaining how many cycles each instruction would take [1](B22235_08.xhtml#footnote-024)
    .'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 没有考虑到保护模式是在早期的80286处理器中引入的，DOS根本无法处理它（现在仍然不能），所以它坚持它最擅长的事情：在实模式下运行程序。在实模式下运行时，处理器只是依次执行指令，甚至有一个指令表解释每个指令将占用多少周期[1](B22235_08.xhtml#footnote-024)。
- en: '[1](B22235_08.xhtml#footnote-024-backlink) [https://zs3.me/intel.php](https://zs3.me/intel.php)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](B22235_08.xhtml#footnote-024-backlink) [https://zs3.me/intel.php](https://zs3.me/intel.php)'
- en: After spending a significant amount of time consulting those tables, we came
    to the conclusion that one **imul** can take longer than two shifts and an add
    on a processor of those days (the same conclusion was drawn by several other thousands
    of programmers all around the world after consulting those tables, but we felt
    that we must be some kind of local heroes for discovering this feature).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在花费了大量时间查阅那些表格后，我们得出结论，在那个时代的处理器上，一个**imul**可能比两个移位和一个加法操作花费更长的时间（全世界有成千上万的程序员在查阅了那些表格后得出了同样的结论，但我们感觉我们一定是某种地方英雄，因为我们发现了这个特性）。
- en: 'Considering that 320 is a very nice number, as it is the sum of 256 and 64,
    after several rounds of optimizations, we came up with the following slightly
    more optimized version for the routine:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到320是一个非常不错的数字，因为它等于256和64的和，经过几轮优化后，我们为这个例程提出了以下稍微更优化的版本：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is not the most optimal routine that one can come up with for this purpose,
    but for our specific requirements, it was more than enough.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是为这个目的可以想到的最优例程，但就我们的具体要求而言，已经足够了。
- en: 'A significantly reduced amount of direct memory access (which was considered
    slow even in the old days), the lengthy multiplication by 320 using **imul** changed
    to multiplication by 256 (this is the shift to the left by 8 operations: **shl
    dx,8** ), and 64 (the same by 6), then a sum, which still adds up to fewer cycles
    than the power-consuming multiplication.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 直接内存访问量显著减少（即使在旧时代，这也被认为是慢的），使用**imul**进行的长时间乘以320的操作改为乘以256（这是左移8位操作：**shl
    dx,8**），然后是64（同样左移6位），然后求和，这样仍然比消耗电力的乘法操作少用几个周期。
- en: And thus, the foundation was laid for the myth that if you really want fast
    code, you have to write it yourself at the lowest possible level.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为“如果你真的想要快速代码，你必须以尽可能低的级别自己编写它”这一神话奠定了基础。
- en: 'As an interesting mental exercise, let’s jump forward in time 30 years, skipping
    several generations of compilers. If we feed the C++ routine as it is to a modern
    compiler (for our purpose, we have used Clang – the latest at the time of writing
    was version 18.1 – but using GCC will get also a very similar result, just using
    a different set of registers), we get the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项有趣的心智练习，让我们跳过30年的时间，跳过几代编译器。如果我们把C++例程直接输入到现代编译器中（为了我们的目的，我们使用了Clang——写作时的最新版本是18.1——但使用GCC也会得到非常相似的结果，只是使用不同的寄存器集），我们得到以下输出：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is way shorter than the one we concocted for our purpose and considered
    optimal targeting the processors from 3 decades ago, but processors have evolved
    a lot in the last 30 years, and a lot more advanced features have come in, with
    new commands (some more words about new commands a bit late in this chapter, so
    stay tuned) and we find it extremely satisfying how compilers’ optimization routines
    have resolved the multiplication with that nice number, 320.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比我们为特定目的编写的代码要短得多，我们当时认为它是最优的，针对的是30年前的处理器，但处理器在过去30年里发展了很多，新增了很多更高级的功能，包括新的命令（关于新命令的更多内容将在本章稍后介绍，所以请耐心等待），我们发现编译器的优化例程如何处理那个令人愉悦的数字320，这一点让我们感到非常满意。
- en: C++ compilers have evolved significantly over the past few decades, from their
    humble beginnings as Turbo C++ or Watcom C++, becoming incredibly sophisticated
    and capable of performing a wide range of optimizations that were previously unimaginable
    due to mostly hardware constraints because, well... 640 KB should be enough for
    everyone.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 编译器在过去几十年中经历了显著的发展，从最初作为 Turbo C++ 或 Watcom C++ 的朴素起点，发展成为极其复杂且能够执行一系列以前由于硬件限制而难以想象的优化，因为，嗯...640
    KB 应该对每个人来说都足够了。
- en: Modern compilers are no longer just simple translators from human-readable code
    to machine code; they have become complex systems that analyze and transform code
    in ways that can drastically improve performance and memory usage, taking into
    consideration some aspects that are all meant to help developers bring out the
    best of their source.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编译器不再仅仅是人类可读代码到机器代码的简单翻译器；它们已经成为复杂的系统，能够以可以显著提高性能和内存使用率的方式分析和转换代码，同时考虑一些旨在帮助开发者发挥其源代码最佳性能的方面。
- en: GCC, Clang, and MSVC all employ advanced optimization techniques such as inlining
    functions, loop unrolling, constant folding, dead code elimination, and aggressive
    optimizations that span across entire modules or programs, since, at their stage,
    they have an overview of the entire application, allowing these high-level optimizations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: GCC、Clang 和 MSVC 都采用了高级优化技术，如内联函数、循环展开、常量折叠、死代码消除以及跨越整个模块或程序的激进优化，因为在这个阶段，它们对整个应用程序有一个全面的了解，这使得这些高级优化成为可能。
- en: On a side note, these compilers also leverage modern hardware features, such
    as vectorization and parallelism, to generate highly efficient machine code that
    can target a specific processor. We will soon see how these optimizations fall
    into place when we present the example in the next section, where we take a mundane
    task and let our compilers churn through it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，这些编译器还利用现代硬件特性，如向量化和平行化，生成针对特定处理器的非常高效的机器代码。我们将在下一节中展示这些优化是如何实现的，我们将展示一个平凡的任务，并让我们的编译器对它进行处理。
- en: 'But till we reach that stage, just one more use case from 30 years ago. The
    subtitle of this chapter is *Lower than this you should not get* . Certainly,
    we meant coding at a lower level, not something else, and right now, we will proudly
    contradict ourselves. Again. Here is the contradiction: *in certain situations,
    you really should get to a level lower* *than assembly* .'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们达到那个阶段之前，再举一个30年前的用例。本章的副标题是*低于这个水平你就不应该尝试*。当然，我们的意思是说在更低级别进行编码，而不是其他事情，而现在，我们将再次自豪地与自己唱反调。这里的矛盾是：*在某些情况下，你真的应该达到比汇编语言更低的级别*。
- en: 'If you are familiar with graphic programming, then I suppose you are familiar
    with the concept of double-buffering and back-buffering. The back buffer is an
    off-screen buffer (memory area, with the same size as the screen) where all the
    rendering (drawing of graphics) happens first. When the rendering is done, the
    back buffer is copied onto the screen in order to show the graphics, the back
    buffer is cleared, and the rendering restarts. At some time in history, Tom Duff,
    a Canadian programmer, invented a wonderful piece of ingenious code that was meant
    to accomplish exactly this task; the name of it is Duff’s device and it has been
    discussed several times in several forums, and we are not going to discuss it
    now. Instead, we will show you the “highly optimized” code that we used to copy
    data from the back buffer to the screen:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉图形编程，那么我想你一定熟悉双缓冲和后缓冲的概念。后缓冲是一个离屏缓冲区（内存区域，大小与屏幕相同），所有渲染（图形绘制）首先在这里发生。当渲染完成后，后缓冲被复制到屏幕上以显示图形，然后清空后缓冲，渲染重新开始。在历史上某个时刻，加拿大程序员汤姆·达夫发明了一块绝妙的代码，旨在完成这项任务；它的名字叫达夫设备，在多个论坛上讨论过几次，我们现在不会讨论它。相反，我们将向您展示我们用来从后缓冲区复制数据到屏幕的“高度优化”的代码：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding trick consists of the **rep movsb** instruction, which will do
    the actual copying of bytes ( **movsb** ), repeated ( **rep** ) 64,000 times,
    as indicated by the CX register (we all know that 64,000 = 320 x 200; that’s why
    they are magic numbers).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的技巧包括 **rep movsb** 指令，它将实际复制字节（**movsb**），重复（**rep**）64,000次，如 CX 寄存器所示（我们都知道64,000
    = 320 x 200；这就是为什么它们是魔数）。
- en: 'This code works perfectly given the circumstances. However, there is an opportunity
    for a tiny bit of optimization; you see, we are using a decent processor – at
    least, an 80386. Unlike its predecessor, the 80286, which was a pure 16-bit processor,
    the 80386 is a huge step forward, since it is the first 32-bit x86 processor coming
    from Intel. So, what we can do is the following: instead of copying 64,000 bytes
    using **rep movsd** , we can harvest the opportunities given by our high-end processor
    and put to use the new 32-bit framework, keywords, and registers. What we do is
    move 16,000 double words (we all know that a byte is measured as 8 bits, two bytes
    are called a word, measuring 16 bits, and two words are called a double word,
    totaling 32 bits) because that is exactly what the new processor has support for:
    operation on 32-bit values. The newly introduced **movsd** command does exactly
    this: copies 4 bytes in one step, so that could be a speed-up of 4 times compared
    to our older code.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这段代码运行得非常完美。然而，还有一点可以微调；你看，我们使用的是一个相当不错的处理器——至少是一个80386。与它的前辈80286（一个纯16位处理器）相比，80386是一个巨大的进步，因为它是英特尔推出的第一个32位x86处理器。所以，我们可以做的是以下这些：我们不是使用**rep
    movsd**来复制64,000字节，而是利用我们高端处理器提供的机会，利用新的32位框架、关键字和寄存器。我们移动16,000个双字（我们都知道一个字节是8位，两个字节称为一个字，测量16位，两个字称为一个双字，总共32位），因为这正是新处理器所支持的：对32位值的操作。新引入的**movsd**命令正是这样做的：一次复制4个字节，这样与我们的旧代码相比，速度可以提高4倍。
- en: Our anecdotical C++ compiler, introduced at the beginning of this book, is Turbo
    C++ Lite. Unfortunately for us, Turbo C++ cannot compile code for anything other
    than processors below 80286, so we are stuck with 16-bit registers and some really
    inefficient register handling.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书开头介绍的轶事C++编译器是Turbo C++ Lite。不幸的是，对于我们的编译器来说，Turbo C++无法编译80286以下处理器的代码，所以我们只能使用16位寄存器和一些非常低效的寄存器处理。
- en: 'And here is where the lowest level of hack anyone can see in C++ code comes
    in – we simply add the bytes of the **rep movsd** command as hexadecimal values
    in the code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这里，C++代码中任何人都能看到的最低级别的黑客行为出现了——我们只是在代码中将**rep movsd**命令的字节作为十六进制值添加进去：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Nothing is simpler and more eye-watering than seeing this in production code,
    right? Now, regardless that our compiler cannot compile code for 80386 because
    it’s stuck in the Stone Age (pretty much like half of the chapter you are reading
    right now), we can still produce code that runs optimally on your processor. Please
    don’t do this.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么比在生产代码中看到这一点更简单和令人眼花缭乱的，对吧？现在，尽管我们的编译器无法编译80386的代码，因为它还停留在石器时代（几乎就像你现在正在阅读的章节的一半一样），我们仍然可以生成在您的处理器上运行最优化的代码。请千万不要这样做。
- en: A note on the past
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于过去的说明
- en: Now, you might ask why we even bother mentioning assembly language in 2024,
    when the major trends exhaust themselves concerning the widespread adoption of
    AI-driven development tools, the growth of low-code/no-code platforms, and the
    continued rise of the Nth iteration of various JavaScript modules that have exactly
    the same output as the previous one, except that the syntax is different.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会问，为什么我们甚至在2024年还要提及汇编语言，当时的主要趋势已经耗尽，关于AI驱动开发工具的广泛应用、低代码/无代码平台的增长以及各种JavaScript模块N次迭代的持续上升，这些模块的输出与之前完全相同，只是语法不同。
- en: 'Regardless that these are the loudest happenings in the IT world nowadays,
    assembly language is still not obsolete. It might not get as much focus as everyone’s
    favorite Rust language (Alex will debate Rust in a later chapter if all goes according
    to plan), but there are still major business branches where the assembly is a
    must, and still essential in several hardware environments that require precise
    control, performance optimization, or direct hardware access, such as the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这些是目前IT世界中最引人注目的事件，汇编语言仍然没有过时。它可能不会像大家最喜欢的Rust语言（如果一切按计划进行，亚历克斯将在下一章辩论Rust）那样受到太多关注，但仍然有一些主要商业部门必须使用汇编语言，并且在需要精确控制、性能优化或直接硬件访问的几个硬件环境中仍然至关重要，例如以下这些：
- en: '**Embedded systems** : Microcontrollers and IoT devices often use assembly
    for efficient, low-level programming. There isn’t too much power on these small
    devices; every bit counts.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌入式系统**：微控制器和物联网设备通常使用汇编语言进行高效的底层编程。在这些小型设备上，电力并不充足；每个比特都很重要。'
- en: '**Operating system** ( **OS** ) **development** : Bootloaders and critical
    parts of OS kernels require assembly for hardware initialization and management.
    To achieve this feat, either you work for a large corporation or start your own
    project. Linux is pretty much accounted for.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**（**OS**）**开发**：引导加载程序和操作系统内核的关键部分需要汇编来进行硬件初始化和管理。要实现这一壮举，要么你为一个大公司工作，要么开始自己的项目。Linux基本上已经涵盖了。'
- en: '**High-performance computing** ( **HPC** ): Assembly is used for optimizing
    performance-critical code, particularly in scientific computing or custom hardware
    (e.g., FPGAs). To pursue this, you must find someone wanting to pay you to pursue
    this.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高性能计算**（**HPC**）：汇编用于优化性能关键代码，尤其是在科学计算或定制硬件（例如，FPGA）中。为了追求这一点，你必须找到愿意付钱让你这样做的人。'
- en: '**Security and reverse engineering** : Analyzing and exploiting binaries often
    involves understanding and writing assembly. This is the most lucrative of all,
    and the most realistic way of getting into assembly programming, unfortunately.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全和逆向工程**：分析和利用二进制文件通常涉及理解和编写汇编。这是最有利可图的，也是进入汇编编程的最现实方式，不幸的是。'
- en: '**Firmware development** : BIOS/UEFI and low-level device drivers are commonly
    written in assembly for direct hardware interaction. Here, again, you must be
    on the payroll of a large corporation, although there are a few open source projects
    too (coreboot, libreboot, or just google free bios to get a decent list).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固件开发**：BIOS/UEFI和低级设备驱动程序通常用汇编编写，以实现直接硬件交互。在这里，你同样必须在大公司的工资单上，尽管也有一些开源项目（如coreboot、libreboot，或者只需谷歌免费BIOS即可获得一个相当不错的列表）。'
- en: '**Legacy systems** : Maintaining older systems or working with retro computing
    often requires assembly. This is the ideal chance to blend both fun and suffering
    into one experience.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遗留系统**：维护较旧的系统或与复古计算一起工作通常需要汇编。这是将乐趣和痛苦融合到一个体验中的理想机会。'
- en: '**Specialized hardware** : DSPs and custom CPU architectures may need assembly
    for specialized, efficient processing.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专用硬件**：DSP和定制CPU架构可能需要汇编进行专用、高效的处理。'
- en: Please don’t dismiss assembly language just yet. It remains relevant and will
    continue to be as long as computers exist. For those who are interested in the
    topic, it has its place. Otherwise, you can stick to standard C++.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要立即放弃汇编语言。只要计算机存在，它就仍然相关，并将继续如此。对于那些对这个主题感兴趣的人来说，它有自己的位置。否则，你可以坚持使用标准的C++。
- en: The sum of all numbers
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有数字的总和
- en: 'Dearest esteemed reader. It is a truth universally acknowledged that all developers
    at some stage in their lives must go through a technical interview. There are
    various levels of interrogations: some just on the level of “Please tell me something
    about yourself” (these are the hardest), while some go deeper and might even ask
    you to write some code on a blackboard or even a computer.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 亲爱的尊敬的读者。这是一个普遍公认的事实，即所有开发者在其生活的某个阶段都必须经历一次技术面试。有各种程度的审问：有些只是“请告诉我一些关于你的事”（这些是最难的），而有些则更深入，甚至可能要求你在黑板上或甚至在电脑上编写一些代码。
- en: One of the programs that very frequently comes up in interview questions is
    to write some code that will calculate the sum of a series of numbers sharing
    a certain peculiarity, for example, the sum of all even numbers, the sum of all
    numbers divisible by, let’s say, five, or the sum of odd numbers in a specific
    interval.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试问题中经常出现的一个程序是编写一些代码来计算一系列具有特定特性的数字的总和，例如，所有偶数的总和，所有可以被，比如说，五整除的数字的总和，或者特定区间内奇数的总和。
- en: 'For simplicity’s sake, let’s stick to something simple: the sum of all odd
    numbers up to 100. The following quick program delivers exactly this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，让我们坚持简单的东西：所有奇数到100的总和。以下快速程序正好提供这一点：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Not an overly complicated program: just iterate through the numbers; check
    whether they are odd; if yes, add their value to the final sum; and, in the end,
    print out the sum (for everyone interested, the sum of odd numbers from 1 to 100
    is exactly 2,500).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不是一个过于复杂的程序：只需遍历数字；检查它们是否为奇数；如果是，将它们的值加到最终的总和中；最后，打印出总和（对感兴趣的每个人来说，从1到100的所有奇数的总和正好是2,500）。
- en: 'But our clear thinking was clouded by the well-known fact (at least, for C++
    programmers) that the fastest C++ code is inline assembly, so we decided to sacrifice
    the portability and understandability of our program on the altar of speed and
    rewrite the main part of it using assembly language. Because, well, that is the
    fastest. Here is our attempt at this, using AT&T assembly syntax, just to demonstrate
    the widely available assembly dialects we can embed in a non-standard compliant
    C++ program:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的清晰思维被众所周知的事实（至少，对于 C++ 程序员来说）所蒙蔽，即最快的 C++ 代码是内联汇编，因此我们决定在速度的祭坛上牺牲我们程序的便携性和可理解性，并决定用汇编语言重写其主要部分。因为，嗯，那是最快的。以下是我们尝试的示例，使用
    AT&T 汇编语法，只是为了展示我们可以嵌入到非标准兼容的 C++ 程序中的广泛可用的汇编方言：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just a quick presentation of what the assembly code does, because I hope the
    other lines of code are self-explanatory.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只是简要说明汇编代码的功能，因为我希望其他代码行是自解释的。
- en: 'Here is the assembly code breakdown:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是汇编代码的分解：
- en: '**"movl $1, %[i]\n"** : This instruction sets **i** to **1** . Although **i**
    was already initialized to **1** in the C++ code, this explicitly sets it again
    in assembly for clarity.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**"movl $1, %[i]\n"** : 这条指令将 **i** 设置为 **1**。尽管 **i** 在 C++ 代码中已经被初始化为 **1**，但在汇编中我们再次明确地设置它以提高清晰度。'
- en: '**"movl $0, %[sum]\n"** : This sets the sum to **0** , ensuring that the sum
    starts from **0** in the assembly code. We have to admit that these two initializations
    are not required, but we wanted them to be a gentle introduction to the assembly
    code so as not to scare you away.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**"movl $0, %[sum]\n"** : 这将和设置为 **0**，确保汇编代码中的和从 **0** 开始。我们必须承认，这两个初始化不是必需的，但我们希望它们是对汇编代码的温和介绍，以免吓到你。'
- en: '**loop_start** : This is just a label, and needs no further clarification.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**loop_start** : 这只是一个标签，无需进一步说明。'
- en: '**"cmpl $100, %[i]\n"** : Compares **i** with **100** . The comparison is used
    to check whether **i** has reached or exceeded **100** .'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**"cmpl $100, %[i]\n"** : 比较 **i** 与 **100**。这个比较用于检查 **i** 是否已达到或超过 **100**。'
- en: '**"jg loop_end\n"** : If **i** is greater than **100** , the program jumps
    to **loop_end** , exiting the loop.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**"jg loop_end\n"** : 如果 **i** 大于 **100**，程序将跳转到 **loop_end**，退出循环。'
- en: '**"addl %[i], %[sum]\n"** : Adds the current value of **i** to **sum** . This
    accumulates the sum of all odd numbers up to **99** .'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**"addl %[i], %[sum]\n"** : 将 **i** 的当前值加到 **sum** 上。这会将所有奇数的和累加到 **99**。'
- en: '**"addl $2, %[i]\n"** : Increments **i** by 2 to move to the next odd number
    (e.g., 1 → 3 → 5, etc.).'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**"addl $2, %[i]\n"** : 将 **i** 增加 2 以移动到下一个奇数（例如，1 → 3 → 5 等）。'
- en: '**"jmp loop_start\n"** : Jumps back to the start of the loop to repeat the
    process.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**"jmp loop_start\n"** : 跳回到循环的开始以重复该过程。'
- en: '**loop_end** : This is the label where the program jumps when **i** exceeds
    **100** , effectively ending the loop.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**loop_end** : 当 **i** 超过 **100** 时，程序会跳转到这个标签，从而有效地结束循环。'
- en: The weirdly looking **"+r" (sum)** and **"+r" (i)** parts are constraints that
    tell the compiler to treat **sum** and **i** as read-write variables, meaning
    their values can be both read from and written to during the assembly operations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来奇怪的 **"+r" (sum)** 和 **"+r" (i)** 部分是约束条件，告诉编译器将 **sum** 和 **i** 作为可读可写变量处理，意味着在汇编操作期间它们的值可以被读取和写入。
- en: As a first drawback, the readability and understandability of the code have
    suffered exponentially. We intentionally use the AT&T syntax for assembly because
    it is much more cumbersome and harder to comprehend, and we want you to suffer
    with it and remember never to use assembly in your code unless you know what you’re
    doing, and then you’re excused.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个缺点，代码的可读性和可理解性受到了指数级的损害。我们故意使用 AT&T 语法进行汇编，因为它更加繁琐且难以理解，我们希望你也能经历这个过程，并记住除非你确切知道自己在做什么，否则不要在你的代码中使用汇编，那时你就可以免责。
- en: Secondly, this code is not portable anymore because there is no such thing as
    **__asm__** under Visual C++; they used **__asm** back in the day (or more recently,
    at the beginning of this chapter, Turbo C demonstrated the introduction of the
    **asm** keyword). And since we are here, the C++ standard does not include a common
    assembly block identifier because assembly language syntax is compiler- and platform-specific,
    and inline assembly is an extension rather than a core part of the language. You
    have been warned. I really hope that the preceding statement managed to entirely
    discourage you from ever considering writing assembly code in the body of your
    C++ function, regardless of the presence of the non-standard keyword to enable
    you to do this.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这段代码不再具有可移植性，因为在Visual C++中没有**__asm__**这样的东西；他们过去使用过**__asm**（或者更近一些，在本章的开头，Turbo
    C展示了**asm**关键字的引入）。既然我们在这里，C++标准也没有包含一个通用的汇编块标识符，因为汇编语言语法是编译器和平台特定的，内联汇编是语言的扩展而不是核心部分。我已经警告过你。我真的希望前面的陈述能够完全阻止你考虑在任何情况下在你的C++函数体中编写汇编代码，无论是否存在非标准的关键字来允许你这样做。
- en: But now that we are here, courtesy of [gcc.godbolt.org](http://gcc.godbolt.org)
    , we have asked the major compilers to churn through the original little C++ program
    (with no assembly incursion at all) at various optimization levels because we
    feel the urge to demonstrate to you that, indeed, entirely skipping the assembly
    language at this stage is the wisest decision you can take.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，得益于[gcc.godbolt.org](http://gcc.godbolt.org)，我们已经要求主要的编译器在各个优化级别上处理原始的C++程序（完全没有汇编侵入），因为我们迫切希望向您展示，确实，在这个阶段完全跳过汇编语言是您可以做出的最明智的决定。
- en: 'The first one to demonstrate how efficient the compiler is in generating optimal
    C++ code is Microsoft Visual C++. Microsoft’s own tiny, squishy C++ compiler has
    several options to generate and optimize the generated code [2](B22235_08.xhtml#footnote-023)
    , but we have a saying here: the shorter the code, the faster it runs. So, we
    have explicitly told the compiler to generate the shortest code ( **/O1** ), which
    is the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个展示编译器在生成最优C++代码方面效率如何的是微软的Visual C++。微软自己的小巧、紧凑的C++编译器有几个选项可以生成和优化生成的代码[2](B22235_08.xhtml#footnote-023)，但我们这里有一个说法：代码越短，运行越快。因此，我们明确告诉编译器生成最短的代码（**/O1**），如下所示：
- en: '[2](B22235_08.xhtml#footnote-023-backlink) [https://learn.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=msvc-170](https://learn.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=msvc-170)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](B22235_08.xhtml#footnote-023-backlink) [https://learn.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=msvc-170](https://learn.microsoft.com/en-us/cpp/build/reference/o-options-optimize-code?view=msvc-170)'
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Interestingly, the assembly output from MSVC is very much in line with the one
    we concocted by hand; it has a loop, a bit differently dealing with the various
    registers based on whether we are currently dealing with an odd or even number,
    but besides this, it’s similar to the one we wrote.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，MSVC的汇编输出与我们手工编写的非常一致；它有一个循环，根据我们当前处理的是奇数还是偶数，对各种寄存器进行了一些不同的处理，但除此之外，它与我们所写的代码相似。
- en: Using the other combinations for optimization flags ( **/Ox** , **/O2** , and
    **/Ot** ) for MSVC did not produce a very different code, just a slightly different
    assignment of the registers, but nothing that would make us say VOW!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他优化标志组合（**/Ox**、**/O2** 和 **/Ot**）为MSVC生成的代码并没有很大不同，只是寄存器的分配略有不同，但没有任何使我们大喊“哇！”的东西。
- en: 'After switching to GCC (14.1) in order for it to churn through our simple code,
    we noticed that for the optimization levels of **–O1** and **–O2** , the code
    generated was very similar to the one generated by MSVC: it had a variable, churned
    through the numbers, and made some test for oddness and sum. That’s it, not black
    magic... unlike the code that was generated for **–O3** .'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换到GCC（14.1）以便它处理我们的简单代码后，我们注意到对于**–O1**和**–O2**优化级别，生成的代码与MSVC生成的代码非常相似：它有一个变量，遍历数字，并对奇偶性和和进行了一些测试。就是这样，不是黑魔法...与为**–O3**生成的代码不同。
- en: Using this flag, we were surprised to see how the **single instruction, multiple
    data** ( **SIMD** ) instructions were being pulled in by the compiler, in order
    to increase the speed, and the unexpected feature this compiler pulled in was
    that it calculated the sum of elements in an evolving 4-element array, starting
    with the values {1, 2, 3, 4} and incrementing each element by 4 over 25 iterations
    using SIMD instructions. The accumulated sum was stored in a SIMD register, and
    after the loop, it was reduced to a single integer, supplying the correct result.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个标志，我们惊讶地看到编译器如何通过**单指令多数据**（**SIMD**）指令来提高速度，而这个编译器引入的意外特性是它计算了一个不断变化的4元素数组的元素总和，从值{1,
    2, 3, 4}开始，并在25次迭代中通过SIMD指令将每个元素增加4。累计的总和存储在一个SIMD寄存器中，循环结束后，它被减少到一个单一的整数，提供了正确的结果。
- en: The assembly code produced for this was simply too long (more than three pages),
    and we decided not to publish it here because it would have been useless, but
    as a fact of curiosity, we mentioned it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为此生成的汇编代码太长了（超过三页），我们决定不在这里发布它，因为它将毫无用处，但作为一个好奇的事实，我们提到了它。
- en: The next compiler that we checked for how it deals with our simple C++ program
    is Clang. At this stage (meaning after the long SIMD instruction dump from GCC
    with **–O3** ), we did not expect anything spectacular, but we had a surprise.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查的下一个编译器是Clang，以处理我们的简单C++程序。在这个阶段（意味着在GCC使用**–O3**选项后的长SIMD指令输出之后），我们并没有期待任何惊人的结果，但我们却遇到了惊喜。
- en: 'Even at **–O1** , Clang greeted us with the following, may I say quite short
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在**–O1**选项下，Clang也向我们展示了以下，可以说相当简短的代码：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What a surprise! It seems that Clang did all the calculations behind the scenes,
    and just simply put the result in the compiled binary. More optimized than this
    it cannot be. We were really thrilled that compilers have matured and grown into
    these clever beasts, so this tantalized us to check whether other compilers can
    be clever like this, too.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 真是令人惊讶！看起来Clang在幕后做了所有的计算，只是简单地将结果放入编译后的二进制文件中。这已经是最优化的了。我们真的很激动，编译器已经成熟并成长得如此聪明，这让我们好奇是否其他编译器也能这样聪明。
- en: GCC exposes the same behavior at **–O3** , but surprisingly, only if we want
    to summarize odd numbers up to 71. At 72, something breaks inside and churns out
    again the long list of SIMD assembly sources.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: GCC在**–O3**选项下表现出相同的行为，但令人惊讶的是，只有当我们想要总结到71的奇数时才会如此。到了72，内部出现了问题，再次生成了长长的SIMD汇编源代码列表。
- en: We could not convince MSVC under any circumstance, combinations of numbers and
    parameters to go the Clang way, and precalculate the number required to print
    out the sum of odd numbers, so we just concluded that it cannot. Maybe it will
    be implemented in the next version, what do you say Microsoft Visual C++ developers?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无论如何都无法说服MSVC（在任何情况下），通过数字和参数的组合走向Clang的道路，并预先计算打印奇数和所需的数字，所以我们得出结论，这是不可能的。也许它将在下一个版本中实现，微软Visual
    C++开发者们，你们怎么看？
- en: A glimpse into the future
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展望未来
- en: There is a phrase circulating amongst C++ developers that goes along the lines
    of *today’s compiler optimizations are the best we’ve ever managed to cobble together
    and a not-so-gentle reminder of just how much better they* *could be* .
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++开发者中流传着一句俗语，大意是“今天的编译器优化是我们迄今为止所能拼凑出的最好的，也是一个不太温柔的提醒，它们*本可以*变得更好”。
- en: Taking into consideration that this book was written in 2024 (hopefully, it
    will be published in 2025, and if all goes according to plan, in 2027, it will
    be obsolete, and we will get a commission to come up with a more up-to-date version
    of it), we have a pretty clear overview of what is happening in the world today.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这本书是在2024年（希望它能在2025年出版，如果一切按计划进行，那么在2027年就会过时，我们将获得一个更新版本的编写任务），我们对当今世界正在发生的事情有一个相当清晰的了解。
- en: However, if you are reading this book while someone tries to grow potatoes on
    a different planet and the walls of your building are covered by graffitied monkeys,
    then you might have had some insights on how far the compilers have come in the
    last 10 years. Actually, it might even happen that Microsoft’s own (yes, we know,
    tiny, squishy) C++ compiler managed to grow up to the stage where it can calculate
    the sum of a few numbers before compilation and GCC is not throwing a tantrum
    at 72. Even for a short, simple program like the one we have.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在阅读这本书的时候，有人试图在另一个星球上种植土豆，而你所在建筑的墙壁上被涂鸦的猴子覆盖，那么你可能已经对编译器在过去 10 年里取得了多大的进步有所了解。实际上，甚至可能发生的情况是，微软自己的（是的，我们知道，小巧，柔软的）C++
    编译器设法成长到能够计算编译前几个数字之和的程度，而 GCC 在 72 的时候也没有发怒。即使是像我们有的这个简短程序这样的短程序也是如此。
- en: Welcome to the future.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到未来。
- en: One instruction to rule them all
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一条指令统治一切
- en: Dear reader. In our previous section of this chapter, unfortunately, we exhausted
    the only pompous introduction we could borrow from various cultural sources concerning
    technical interviews, career and life choices, and whether should we take the
    red pill or the blue one, so let’s focus our attention on more technical questions
    that our candidates might face at a technical interview (the word technical appears
    four times in this short introductory paragraph).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 亲爱的读者。在我们本章的前一节中，不幸的是，我们已经用尽了从各种文化来源借来的关于技术面试、职业和生活选择，以及我们应该选择红色药丸还是蓝色药丸的唯一浮夸介绍，所以让我们将注意力集中在我们的候选人可能在技术面试中遇到的一些更技术性的问题上（在这个简短的介绍段落中，“技术”这个词出现了四次）。
- en: 'One of these questions, served to the author of these lines a few years ago,
    was to write a short code snippet that will count the number of 1 bits (the on
    bits) in a 32-bit integer. Let’s draft up a quick application to do this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题中的一个，几年前被这些文字的作者提出，是要编写一个简短的代码片段来计算一个 32 位整数中 1 位的数量。让我们草拟一个快速应用程序来完成这个任务：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here’s what happens. Firstly, we initialize a counter, starting with **0** .
    The next step is to loop through the bits. While **n** is non-zero, we add the
    least significant bit of **n** to the counter ( **n&1** gives us this value).
    Following this, we shift **n** right by one bit (discarding the least significant
    bit).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是发生的事情。首先，我们初始化一个计数器，从 **0** 开始。下一步是遍历位。当 **n** 非零时，我们将 **n** 的最低有效位添加到计数器中（**n&1**
    给出这个值）。随后，我们将 **n** 右移一位（丢弃最低有效位）。
- en: Once all bits are processed (when **n** becomes **0** ), return the total count
    of 1 bits. Not a very complicated process, just raw work.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理完所有位（当 **n** 变为 **0** 时），返回 1 位的总数。这不是一个很复杂的过程，只是直接的工作。
- en: It seems that this procedure of counting bits in numbers must be of a very peculiar
    interest in computing circles, such as for the purpose of error detection and
    correction, data compression, cryptography, algorithmic efficiency, digital signal
    processing, hardware design, and performance metrics, so no wonder it managed
    to creep itself into the STL (C++ STL, which is the standard template library)
    too in the form of **std::popcount** from C++ 20.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，在数字中计算位的这种程序在计算领域必须具有非常特别的兴趣，例如用于错误检测和纠正、数据压缩、密码学、算法效率、数字信号处理、硬件设计和性能指标，所以它成功渗透到
    STL（C++ STL，即标准模板库）中也就不足为奇了，它以 C++ 20 中的 **std::popcount** 的形式存在。
- en: The interesting part of the story is that not only in the STL do we find this
    handy operation, but it was deemed so useful that it even exists at the level
    of the processors, under the infamous **POPCNT** mnemonic. Infamous it is, due
    to the fact that in 2024, it was effectively used in hindering the installation
    of Windows 11 on older machines that were not officially supported [3](B22235_08.xhtml#footnote-022)
    .
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 故事中有趣的部分在于，我们不仅在 STL 中找到了这个方便的操作，而且它被认为非常有用，以至于它甚至存在于处理器的层面上，在臭名昭著的 **POPCNT**
    助记符下。臭名昭著，是因为在 2024 年，它被有效地用于阻碍在未获得官方支持的旧机器上安装 Windows 11 [3](B22235_08.xhtml#footnote-022)。
- en: '[3](B22235_08.xhtml#footnote-022-backlink) [https://www.theregister.com/2024/04/23/windows_11_cpu_requirements/](https://www.theregister.com/2024/04/23/windows_11_cpu_requirements/)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[3](B22235_08.xhtml#footnote-022-backlink) [https://www.theregister.com/2024/04/23/windows_11_cpu_requirements/](https://www.theregister.com/2024/04/23/windows_11_cpu_requirements/)'
- en: 'But what that means for our candidate, who has to write code to impress the
    interviewers, is that they can simply replace the complicated code from before
    with the following very handy snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但这对我们的候选人来说意味着什么，他们需要编写代码来给面试官留下深刻印象，那就是他们可以简单地用以下非常实用的代码片段替换之前复杂的代码：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Not forgetting to include the **<bit>** header, after feeding the preceding
    program into [gcc.godbolt.org](http://gcc.godbolt.org) ’s compilers, we get a
    strange mishmash of results. The code compiled by GCC, regardless of the optimization
    level, always generates a variation of the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在将前面的程序输入到[gcc.godbolt.org](http://gcc.godbolt.org)的编译器后，我们得到了一个奇怪的混合结果。无论优化级别如何，GCC编译的代码总是生成以下内容的变体：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, the code at some level disappears from our eyes into a strange call deep
    inside the libraries offered by GCC, called **__popcountdi2** [4](B22235_08.xhtml#footnote-021)
    . In order to convince GCC to fully utilize the power of the processor that we
    are running the code on, we need to utilize some of the not-so-well-known command-line
    options, such as **-march** (or **-mpopcnt** for this specific purpose).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，某些级别的代码从我们的视线中消失，进入GCC提供的库中的某个奇怪的调用，称为**__popcountdi2** [4](B22235_08.xhtml#footnote-021)。为了说服GCC充分利用我们在其上运行代码的处理器的能力，我们需要利用一些不太为人所知的命令行选项，例如**-march**（或针对此特定目的的**-mpopcnt**）。
- en: '[4](B22235_08.xhtml#footnote-021-backlink) [https://gcc.gnu.org/onlinedocs/gccint/Integer-library-routines.html](https://gcc.gnu.org/onlinedocs/gccint/Integer-library-routines.html)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[4](B22235_08.xhtml#footnote-021-backlink) [https://gcc.gnu.org/onlinedocs/gccint/Integer-library-routines.html](https://gcc.gnu.org/onlinedocs/gccint/Integer-library-routines.html)'
- en: 'According to the official documentation, [5](B22235_08.xhtml#footnote-020)
    this command will select the appropriate processor instruction set in order to
    use the available extensions of the specific processor. Since, at this stage,
    we know that the **POPCNT** instruction was introduced in the early Core i5 and
    i7 processors, in the Nehalem family, we should simply specify the following to
    GCC: **-march=nehalem** . And now, not surprisingly, the compiler generates the
    following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方文档，[5](B22235_08.xhtml#footnote-020) 此命令将选择合适的处理器指令集，以便使用特定处理器的可用扩展。由于在此阶段，我们知道**POPCNT**指令是在早期的Core
    i5和i7处理器中引入的，在Nehalem系列中，我们应该简单地指定以下内容给GCC：**-march=nehalem**。现在，不出所料，编译器生成了以下内容：
- en: '[5](B22235_08.xhtml#footnote-020-backlink) [https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html](https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[5](B22235_08.xhtml#footnote-020-backlink) [https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html](https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html)'
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Interestingly, if we provide the compiler with just the **-mpopcnt** flag,
    then it generates an extra **xor eax, eax** (meaning it nulls the EAX register)
    so maybe we have witnessed some processor-specific extra optimizations by choosing
    the Nehalem architecture:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果我们只向编译器提供**-mpopcnt**标志，那么它会生成一个额外的**xor eax, eax**（意味着它清零EAX寄存器），因此我们可能已经见证了通过选择Nehalem架构而进行的某些处理器特定的额外优化：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We cannot squeeze more than this out of GCC; there is simply no lower level
    for this functionality, so we focus our attention on the next compiler on our
    list.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法从GCC中挤出更多内容；对于此功能，没有更低级别的实现，因此我们将注意力转向我们列表中的下一个编译器。
- en: 'Without explicitly asking to optimize the code, Clang also generates a generic
    call to a **std::popcount** function, found somewhere in its libraries; however,
    explicitly asking to optimize the generated code, Clang at various levels of optimization
    yields the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有明确要求优化代码，Clang也会生成对某个库中某个位置的**std::popcount**函数的通用调用；然而，明确要求优化生成的代码，Clang在各个优化级别上会产生以下结果：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Surprising as it seems, there is a perfectly logical explanation for this code,
    found at the bit-twiddling site [6](B22235_08.xhtml#footnote-019) of Sean Eron
    Anderson at Stanford. Not considering this extra detour, Clang behaves identically
    to GCC when it comes to handling architecture and specifying the subset of CPU
    extensions to use while generating code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来令人惊讶，但对此代码有一个完全合理的解释，可以在斯坦福的Sean Eron Anderson的位操作网站上找到[6](B22235_08.xhtml#footnote-019)。不考虑这个额外的绕道，Clang在处理架构和指定生成代码时要使用的CPU扩展子集时，与GCC的行为完全相同。
- en: '[6](B22235_08.xhtml#footnote-019-backlink) [https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel](https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[6](B22235_08.xhtml#footnote-019-backlink) [https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel](https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel)'
- en: The last of the big three, Microsoft’s own (we know, tiny, squishy) C++ compiler
    handles the situation very similarly to Clang. When asking to optimize the code
    while we specify an architecture that does not support the **POPCNT** instruction,
    it generates code like the one generated by Clang with low-level bit hacks, while
    if the architecture has support for the **POPCNT** instruction, it will adjust
    to the correct type and will call **POPCNT** for the proper parameters (/std:c++latest
    / arch:SSE4.2 /O1).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在三大编译器中最后一位，微软自己的（我们知道，小巧、柔软的）C++编译器处理情况与Clang非常相似。当我们要求在指定不支持**POPCNT**指令的架构时优化代码，它会生成类似于Clang生成的代码，使用低级位操作，而如果架构支持**POPCNT**指令，它将调整到正确的类型，并调用**POPCNT**以正确的参数（/std:c++latest
    / arch:SSE4.2 /O1）。
- en: Good work, tiny, squishy compiler.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 做得很好，小巧、柔软的编译器。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Myths related to C++ programming are shaped by the language’s evolving history
    through time, the differences and various levels of mastery between the users
    of the language, and psychological needs within the developer community. Early
    C++ compilers, which often generated less optimal code compared to modern compilers,
    contributed to myths about the language’s inefficiency and the necessity of manual
    optimization, such as rewriting entire routines using platform-specific assembly
    languages.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++编程相关的神话是由语言随时间演变的历程、语言用户之间的差异和掌握水平，以及开发者社区中的心理需求所塑造的。早期的C++编译器，通常生成的代码不如现代编译器优化，导致了关于语言效率低下和需要手动优化的神话，例如使用特定平台的汇编语言重写整个例程。
- en: As compilers and language features have advanced, these myths persist, sometimes
    overshadowing modern best practices. This, combined with a culture of elitism
    and a sense of mastery among C++ programmers, reinforces outdated perceptions,
    even as C++ continues to be seen as a powerful and versatile language for serious,
    performance-critical applications.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 随着编译器和语言特性的进步，这些神话依然存在，有时甚至掩盖了现代最佳实践。这一点，加上C++程序员中的精英主义文化和掌握感，强化了过时的观念，尽管C++仍然被视为一种强大且多功能的语言，适用于严肃且性能关键的应用。
- en: In the upcoming chapter, we will host a beauty pageant of programming languages,
    quickly eliminating all but our favorite, and the process will culminate in the
    crowning of the undisputed queen, C++. Admittedly, our admiration for this language
    is so profound that one might suspect the contest was rigged from the very start.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在即将到来的章节中，我们将举办一场编程语言的选美大赛，迅速淘汰所有除了我们最喜欢的语言之外的所有语言，整个过程将以无争议的皇后，C++的加冕而告终。诚然，我们对这种语言的钦佩如此之深，以至于人们可能会怀疑比赛从一开始就被操纵了。
