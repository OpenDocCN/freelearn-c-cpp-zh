- en: Chapter 15. Sound Spatialization and HUD
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。声音空间化和HUD
- en: In this chapter, we will be adding all the sound effects and the HUD. We have
    done this in both of the previous projects, but we will do things a bit differently
    this time. We will explore the concept of sound **spatialization** and how SFML
    makes this otherwise complicated concept nice and easy; in addition, we will build
    a HUD class to encapsulate the code that draws information to the screen.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将添加所有的音效和HUD。我们在之前的两个项目中都做过这个，但这次我们会以稍微不同的方式来做。我们将探讨声音空间化的概念以及SFML如何使这个本来复杂的概念变得简单易行；此外，我们将构建一个HUD类来封装将信息绘制到屏幕上的代码。
- en: 'We will complete these tasks in the following order:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下顺序完成这些任务：
- en: What is spatialization?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是空间化？
- en: How SFML handles spatialization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML如何处理空间化
- en: Building a `SoundManager` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个`SoundManager`类
- en: Deploying emitters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署发射器
- en: Using the `SoundManager` class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SoundManager`类
- en: Building a `HUD` class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个`HUD`类
- en: Using the `HUD` class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`HUD`类
- en: What is Spatialization?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是空间化？
- en: Spatialization is the act of making something relative to the space it is a
    part of, or within. In our daily lives, everything in the natural world, by default,
    is spatialized. If a motorbike whizzes past from left to right we will hear the
    sound grow from faint to loud from one side and as it passes by, it will become
    more prominent in the other ear, before fading into the distance once more. If
    we woke up one morning and the world was no longer spatialized, it would be exceptionally
    weird.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 空间化是使某物相对于其所在的空间或内部的行为。在我们的日常生活中，自然界中的一切默认都是空间化的。如果一辆摩托车从左到右呼啸而过，我们会听到声音从一侧变得微弱到响亮，当它经过时，它会在另一只耳朵中变得更加显著，然后再次消失在远处。如果有一天早上醒来，世界不再是空间化的，那将是异常奇怪的。
- en: If we can make our video games a little bit more like the real world, our players
    can become more immersed. Our zombie game would have been a lot more fun if the
    player could have heard them faintly in the distance and their inhuman wailing
    grew louder as they drew closer, from one direction or another.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能让我们的视频游戏更像现实世界，我们的玩家就能更加沉浸其中。如果玩家能在远处微弱地听到僵尸的声音，而当它们靠近时，它们的不人道的哀嚎声会从一个方向或另一个方向变得更响亮，我们的僵尸游戏会更有趣。
- en: It is probably obvious that the mathematics of spatialization will be complex.
    How do we calculate how loud a given sound will be in a specific speaker, based
    on the direction the sound is coming from, and the distance from the player (the
    hearer of the sound) to the object that is making the sound (the emitter)?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，空间化的数学将会很复杂。我们如何计算特定扬声器中的声音有多大声，基于声音来自的方向以及听者（声音的听者）到发出声音的物体（发射器）的距离？
- en: Fortunately, SFML does all the complicated stuff for us. All we need to do is
    get familiar with a few technical terms and then we can start using SFML to spatialize
    our sound effects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，SFML为我们处理了所有复杂的事情。我们只需要熟悉一些技术术语，然后就可以开始使用SFML来对我们的音效进行空间化。
- en: Emitters, attenuation, and listeners
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发射器、衰减和听众
- en: We will need to be aware of a few pieces of information in order to give SFML
    what it needs to do its work. We will need to be aware of where the sound is coming
    from in our game world. This source of the sound is called an **emitter**. In
    a game, the emitter could be a Zombie, a vehicle, or in the case of our current
    project, a fire tile. We already keep track of the position of objects in our
    game, so giving SFML the emitter location will be quite straightforward.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让SFML能够正常工作，我们需要了解一些信息。我们需要知道声音在我们的游戏世界中来自哪里。这个声音的来源被称为**发射器**。在游戏中，发射器可以是僵尸、车辆，或者在我们当前的项目中，是一个火焰图块。我们已经在游戏中跟踪了物体的位置，所以给SFML发射器位置将会非常简单。
- en: The next factor we need to be aware of is **attenuation**. Attenuation is the
    rate at which a wave deteriorates. You could simplify that statement and make
    it specific to sound by saying that attenuation is how quickly the sound reduces
    in volume. That isn't technically exact, but it is a good enough description for
    the purposes of this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要意识到的下一个因素是**衰减**。衰减是波动恶化的速率。你可以简化这个说法，并将其具体化为声音，即衰减是声音减小的速度。这在技术上并不准确，但对于本章的目的来说，这已经足够好了。
- en: The final factor we need to consider is the **listener**. When SFML spatializes
    the sound, where is it spatializing it relative to? In most games, the logical
    thing to do is use the player character. In our game, we will use Thomas.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑的最后一个因素是**听众**。当SFML对声音进行空间化时，它是相对于什么进行空间化的？在大多数游戏中，合理的做法是使用玩家角色。在我们的游戏中，我们将使用Thomas。
- en: How SFML handles spatialization
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFML如何处理空间化
- en: SFML has a number of functions that allow us to handle emitters, attenuation,
    and listeners. Let's take a look at them hypothetically, and then we will write
    some code to add spatialized sound to our project for real.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: SFML有许多函数可以让我们处理发射器、衰减和听众。让我们先假设一下，然后我们将编写一些代码，真正为我们的项目添加空间化声音。
- en: 'We can set up a sound effect ready to be played, as we have done so often,
    as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置一个准备播放的音效，就像我们经常做的那样，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can set the position of the emitter using the `setPosition` function, as
    shown in the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`setPosition`函数来设置发射器的位置，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As suggested in the comments of the previous code, how exactly you obtain the
    coordinates of the emitter will probably be dependent upon the type of game. As
    shown in the previous code, this would be quite simple in the Zombie Arena project.
    We will have a few challenges to overcome when we set the position in this project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码注释中建议的，你如何获取发射器的坐标可能取决于游戏的类型。就像在Zombie Arena项目中所示的那样，这将是非常简单的。当我们在这个项目中设置位置时，我们将面临一些挑战。
- en: 'We can set the attenuation level using the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码设置衰减级别：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The actual attenuation level can be a little ambiguous. The effect that you
    want the player to get might be different from the accurate scientific formula
    used to reduce the volume over distance based on attenuation. Getting the right
    attenuation level is usually achieved by experimenting. Generally speaking, the
    higher the level of attenuation, the quicker the sound level reduces to silence.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的衰减级别可能有些模糊。您希望玩家得到的效果可能与基于衰减的距离减小音量的准确科学公式不同。获得正确的衰减级别通常是通过实验来实现的。一般来说，衰减级别越高，声音级别降至静音的速度就越快。
- en: 'Also, you might want to set a zone around the emitter where the volume is not
    attenuated at all. You might do this if the feature isn''t appropriate beyond
    a certain range, or you have a large number of sound sources and don''t want to
    overdo the feature. To do so, we can use the `setMinimumDistance` function, as
    shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可能希望在发射器周围设置一个音量完全不衰减的区域。如果该功能在一定范围之外不合适，或者您有大量的声源并且不想过度使用该功能，您可以这样做。为此，我们可以使用`setMinimumDistance`函数，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the previous line of code, attenuation would not begin to be calculated
    until the listener is `150` pixels/units away from the emitter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上一行代码，衰减直到听众离发射器`150`像素/单位远才开始计算。
- en: 'Some other useful functions from the SFML library include the `setLoop` function.
    This function will tell SFML to keep playing the sound over and over when true
    is passed in as a parameter, as demonstrated by the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: SFML库中的一些其他有用函数包括`setLoop`函数。当传入true作为参数时，此函数将告诉SFML在循环播放声音时保持播放，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The sound will continue to play until we ended it with the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 声音将继续播放，直到我们使用以下代码结束它：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From time to time, we will want to know the status of a sound (playing or stopped).
    We can achieve this with the `getStatus` function, as demonstrated in the following
    code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不时地，我们会想要知道声音的状态（正在播放或已停止）。我们可以使用`getStatus`函数来实现这一点，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There is just one more aspect of using sound spatialization with SFML that
    we need to cover. Where is the listener? We can set the position of the listener
    with the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用SFML进行声音空间化的最后一个方面我们需要涵盖的是听众在哪里？我们可以使用以下代码设置听众的位置：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code will make all sounds play relative to that location. This
    is just what we need for the distant roar of a fire tile or incoming zombie, but
    for regular sound effects such as jumping, this is a problem. We could start handling
    an emitter for the location of the player, but SFML makes things simple for us.
    Whenever we want to play a *normal* sound, we simply call `setRelativeToListener`,
    as shown in the following code, and then play the sound in the exact same way
    we have done so far. Here is how we might play a *normal*, un-spatialized jump
    sound effect:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将使所有声音相对于该位置播放。这正是我们需要的远处火瓦或迫近的僵尸的咆哮声，但对于像跳跃这样的常规音效来说，这是一个问题。我们可以开始处理一个发射器来定位玩家的位置，但SFML为我们简化了事情。每当我们想播放*正常*声音时，我们只需调用`setRelativeToListener`，如下面的代码所示，然后以与迄今为止完全相同的方式播放声音。以下是我们可能播放*正常*、非空间化跳跃音效的方式：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All we need to do is call `Listener::setPosition` again before we play any spatialized
    sounds.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在播放任何空间化声音之前再次调用`Listener::setPosition`。
- en: We now have a wide repertoire of SFML sound functions and we are ready to make
    some spatialized noise for real.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了广泛的SFML声音函数，我们准备制作一些真正的空间化噪音。
- en: Building the SoundManager class
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建SoundManager类
- en: You might recall that in the previous project, all the sound code took up quite
    a few lines of code. Now consider that with spatialization, it's going to get
    longer still. To keep our code manageable, we will code a class to manage the
    playing of all our sound effects. In addition, to help us with spatialization,
    we will add a function to the Engine class as well, but we will discuss that when
    we come to it, later in the chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得在上一个项目中，所有的声音代码占用了相当多的行数。现在考虑到空间化，它将变得更长。为了使我们的代码易于管理，我们将编写一个类来管理所有声音效果的播放。此外，为了帮助我们进行空间化，我们还将向Engine类添加一个函数，但我们将在后面的章节讨论。
- en: Coding SoundManager.h
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写SoundManager.h
- en: Let's get started by coding and examining the header file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写和检查头文件。
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File (** `.h` **)** and then in the **Name** field, type `SoundManager.h`.
    Finally, click the **Add** button. We are now ready to code the header file for
    the `SoundManager` class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**标头文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**标头文件（**
    `.h` **）**，然后在**名称**字段中键入`SoundManager.h`。最后，单击**添加**按钮。现在我们准备为`SoundManager`类编写头文件。
- en: 'Add and examine the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 添加并检查以下代码：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is nothing tricky in the code we just added. There are five `SoundBuffer`
    objects and eight `Sound` objects. Three of the `Sound` objects will play the
    same `SoundBuffer`. This explains the reason for the different number of `Sound`/`SoundBuffer`
    objects. We do this so that we can have multiple roaring sound effects playing,
    with different spatialized parameters, simultaneously.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚添加的代码中没有什么棘手的地方。有五个`SoundBuffer`对象和八个`Sound`对象。其中三个`Sound`对象将播放相同的`SoundBuffer`。这解释了不同数量的`Sound`/`SoundBuffer`对象的原因。我们这样做是为了能够同时播放多个咆哮声效，并具有不同的空间化参数。
- en: Notice there is the `m_NextSound` variable that will help us keep track of which
    of these potentially simultaneous sounds we should use next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有一个`m_NextSound`变量，将帮助我们跟踪这些潜在同时发生的声音中我们应该下一个使用哪一个。
- en: There is a constructor, `SoundManager`, where we will set up all our sound effects,
    and there are five functions that will play the sound effects. Four of these functions
    simply play *normal* sound effects and their code will be really simple.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个构造函数`SoundManager`，在那里我们将设置所有的音效，还有五个函数将播放音效。其中四个函数只是简单地播放*普通*音效，它们的代码将非常简单。
- en: One of the functions, `playFire`, will handle the spatialized sound effects
    and will be a bit more in-depth. Notice the parameters of the `playFire` function.
    It receives a `Vector2f`, which is the location of the emitter, and a second `Vector2f`,
    which is the location of the listener.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个函数`playFire`将处理空间化的音效，并且会更加深入。注意`playFire`函数的参数。它接收一个`Vector2f`，这是发射器的位置，和第二个`Vector2f`，这是听众的位置。
- en: Coding the SoundManager.cpp file
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写SoundManager.cpp文件
- en: Now we can code the function definitions. The constructor and the `playFire`
    functions have a fair amount of code, so we will look at them individually. The
    other functions are short and sweet so we will handle them all at once.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写函数定义了。构造函数和`playFire`函数有相当多的代码，所以我们将分别查看它们。其他函数都很简短，所以我们将一次处理它们。
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `SoundManager.cpp`.
    Finally, click the **Add** button. We are now ready to code the `.cpp` file for
    the `SoundManager` class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**C++文件（**`.cpp`**）**，然后在**名称**字段中键入`SoundManager.cpp`。最后，单击**添加**按钮。现在我们准备好为`SoundManager`类编写`.cpp`文件了。
- en: Coding the constructor
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写构造函数
- en: 'Add the following code for the include directives and the constructor to `SoundManager.cpp`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为`SoundManager.cpp`添加以下包含指令和构造函数的代码：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous code, we loaded five sound files into the five `SoundBuffer`
    objects. Next, we associated the eight `Sound` objects with one of the `SoundBuffer`
    objects. Notice that `m_Fire1Sound`, `m_Fire2Sound`, and `m_Fire3Sound` are all
    going to be playing from the same `SoundBuffer`, `m_FireBuffer`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将五个声音文件加载到五个`SoundBuffer`对象中。接下来，我们将八个`Sound`对象与其中一个`SoundBuffer`对象关联起来。请注意，`m_Fire1Sound`、`m_Fire2Sound`和`m_Fire3Sound`都将从同一个`SoundBuffer`，`m_FireBuffer`中播放。
- en: Next, we set the attenuation and minimum distance for the three fire sounds.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置了三个火焰声音的衰减和最小距离。
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The values of `150` and `15`, respectively, were arrived at through experimentation.
    Once the game is running, I encourage you to experiment with these values by changing
    them around and seeing (or rather hearing) the difference.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实验得出了分别为`150`和`15`的值。一旦游戏运行起来，我鼓励你通过改变这些值来进行实验，看（或者说听）听到的差异。
- en: Finally, for the constructor, we used the `setLoop` function on each of the
    fire-related `Sound` objects. Now when we call `play`, they will play continuously.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于构造函数，我们在每个与火相关的`Sound`对象上使用了`setLoop`函数。现在当我们调用`play`时，它们将持续播放。
- en: Coding the playFire function
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写playFire函数
- en: 'Add the `playFire` function shown in the following code, and then we can discuss
    it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 添加下面代码中显示的`playFire`函数，然后我们可以讨论它：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first thing we do is call `Listener::setPosition` and set the location of
    the listener based on the `Vector2f` that is passed in as a parameter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是调用`Listener::setPosition`，并根据作为参数传入的`Vector2f`设置听众的位置。
- en: Next, the code enters a `switch` block based on the value of `m_NextSound`.
    Each of the `case` statements does the exact same thing, but to either `m_Fire1Sound`,
    `m_Fire2Sound`, or `m_Fire3Sound`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码根据`m_NextSound`的值进入了一个`switch`块。每个`case`语句都做了完全相同的事情，但是针对`m_Fire1Sound`、`m_Fire2Sound`或`m_Fire3Sound`。
- en: In each of the `case` blocks, we set the position of the emitter using the passed-in
    parameter with the `setPosition` function. The next part of the code in each `case`
    block checks whether the sound is currently stopped, and if it is, plays the sound.
    We will see quite soon how we arrive at the positions for the emitter and listener
    that are passed into this function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个`case`块中，我们使用传入的参数调用`setPosition`函数来设置发射器的位置。每个`case`块中代码的下一部分检查音效当前是否已停止，如果是，则播放音效。我们很快就会看到如何得到传递到这个函数中的发射器和听众的位置。
- en: The final part of the `playFire` function increments `m_NextSound` and ensures
    that it can only be equal to 1, 2, or 3, as required by the `switch` block.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`playFire`函数的最后部分增加了`m_NextSound`，并确保它只能等于1、2或3，这是`switch`块所需的。'
- en: Coding the rest of the SoundManager functions
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写其余的SoundManager函数
- en: 'Add these four simple functions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这四个简单的函数：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `playFallInFire`, `playFallInWater`, and `playReachGoal` functions do just
    two things. First, they each call `setRelativeToListener`, so the sound effect
    is not spatialized, making the sound effect *normal*, not directional, and then
    they call `play` on the appropriate `Sound` object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`playFallInFire`、`playFallInWater`和`playReachGoal`函数只做两件事。首先，它们各自调用`setRelativeToListener`，所以音效不是空间化的，使音效变得*普通*，而不是定向的，然后它们调用适当的`Sound`对象上的`play`。'
- en: That concludes the `SoundManager` class. Now we can use it in the `Engine` class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了`SoundManager`类。现在我们可以在`Engine`类中使用它。
- en: Adding SoundManager to the game engine
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将SoundManager添加到游戏引擎
- en: 'Open the `Engine.h` file and add an instance of the new `SoundManager` class,
    as shown in the following highlighted code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Engine.h`文件，并添加一个新的`SoundManager`类的实例，如下面突出显示的代码所示：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At this point, we could use `m_SM` to call the various `play...` functions.
    Unfortunately, there is still a bit more work to be done in order to manage the
    locations of the emitters (fire tiles).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以使用`m_SM`来调用各种`play...`函数。不幸的是，仍然有一些工作要做，以便管理发射器（火砖）的位置。
- en: Populating the sound emitters
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充声音发射器
- en: 'Open the `Engine.h` file and add a new prototype for a `populateEmitters` function
    and a new STL `vector` of `Vector2f` objects:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Engine.h`文件，并为`populateEmitters`函数添加一个新的原型和一个新的STL`vector`的`Vector2f`对象：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `populateEmitters` function takes as a parameter a `vector` of `Vector2f`
    objects, as well as a pointer to `int` (a two-dimensional array). The `vector`
    will hold the location of each emitter in a level and the array is our two-dimensional
    array, which holds the layout of a level.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: “populateEmitters”函数以“Vector2f”对象的“vector”和指向“int”的指针作为参数。这个“vector”将保存每个发射器在一个级别中的位置，而数组是我们的二维数组，它保存了一个级别的布局。
- en: Coding the populateEmitters function
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写populateEmitters函数
- en: The job of the `populateEmitters` function is to scan through all the elements
    of `arrayLevel` and decide where to put the emitters. It will store its results
    in `m_FireEmitters`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: “populateEmitters”函数的工作是扫描“arrayLevel”的所有元素，并决定在哪里放置发射器。它将其结果存储在“m_FireEmitters”中。
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File** (`.cpp`) and then in the **Name** field, type `PopulateEmitters.cpp`.
    Finally, click the **Add** button. Now we can code the new function, `populateEmitters`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在“解决方案资源管理器”中右键单击“源文件”，然后选择“添加”|“新项目”。在“添加新项目”窗口中，选择（通过左键单击）“C++文件”（.cpp），然后在“名称”字段中输入“PopulateEmitters.cpp”。最后，单击“添加”按钮。现在我们可以编写新函数“populateEmitters”。
- en: 'Add the code in its entirety; be sure to study the code as you do, and then
    we can discuss it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 添加完整的代码；确保在编写代码时仔细研究代码，然后我们可以讨论它。
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Some of the code might appear complex at first glance. Understanding the technique
    we use to choose where an emitter will make it simpler. In our levels, there are,
    regularly, large blocks of fire tiles. In one of the levels I designed there are
    more than 30 fire tiles together. The code makes sure that there is only one emitter
    within a given rectangle. This rectangle is stored in `previousEmitter` and is
    300 pixels by 300 pixels (`TILE_SIZE * 6`).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码乍一看可能会很复杂。理解我们用来选择发射器位置的技术将使其变得更简单。在我们的级别中，通常会有大块的火砖。在我设计的一个级别中，有超过30个火砖。代码确保在给定的矩形内只有一个发射器。这个矩形存储在“previousEmitter”中，大小为300像素乘以300像素（TILE_SIZE
    * 6）。
- en: The code sets up a nested `for` loop that loops through `arrayLevel` looking
    for fire tiles. When it finds one, it makes sure that it does not intersect with
    `previousEmitter`. Only then does it use the `pushBack` function to add another
    emitter to `vSoundEmitters`. After doing so, it also updates `previousEmitter`
    to avoid getting large clusters of sound emitters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码设置了一个嵌套的“for”循环，循环遍历“arrayLevel”以寻找火砖。当找到一个时，它确保它不与“previousEmitter”相交。只有在这种情况下，它才使用“pushBack”函数向“vSoundEmitters”添加另一个发射器。在这样做之后，它还更新“previousEmitter”以避免得到大量的声音发射器。
- en: Let's make some noise.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制造一些噪音。
- en: Playing sounds
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放声音
- en: 'Open up the `LoadLevel.cpp` file and add the call to the new `populateEmitters`
    function, as highlighted in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 打开“LoadLevel.cpp”文件，并在以下代码中添加对新的“populateEmitters”函数的调用：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first sound to add is the jump sound. You might remember that the keyboard
    handling code is in the pure virtual functions within both the `Bob` and `Thomas`
    classes, and that the `handleInput` function returns `true` when a jump has been
    successfully initiated.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加的第一个声音是跳跃声音。您可能记得键盘处理代码在“Bob”和“Thomas”类的纯虚函数中，而“handleInput”函数在成功启动跳跃时返回“true”。
- en: 'Open up the `Input.cpp` file and add the highlighted lines of code to play
    a jump sound when either Thomas or Bob successfully begins a jump:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 打开“Input.cpp”文件，并添加高亮代码行，以在Thomas或Bob成功开始跳跃时播放跳跃声音。
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open up the `Update.cpp` file and add the highlighted line of code to play
    a success sound when both Thomas and Bob have simultaneously reached the goal
    for the current level:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 打开“Update.cpp”文件，并添加高亮代码行，以在Thomas和Bob同时到达当前级别的目标时播放成功的声音。
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Also within the `Update.cpp` file, we will add code to loop through the `m_FireEmitters`
    vector and decide when we need to call the `playFire` function of the `SoundManager`
    class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在“Update.cpp”文件中，我们将添加代码来循环遍历“m_FireEmitters”向量，并决定何时需要调用“SoundManager”类的“playFire”函数。
- en: 'Look closely at the small amount of context around the new highlighted code.
    It is essential to add this code in exactly the right place:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察新的高亮代码周围的一小部分上下文。在恰当的位置添加这段代码是至关重要的。
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous code is a bit like collision detection for sound. Whenever Thomas
    stays within a 500-by-500 pixel rectangle surrounding a fire emitter, the `playFire`
    function is called, passing in the coordinates of the emitter and of Thomas. The
    `playFire` function does the rest of the work and sets off a spatialized, looping
    sound effect.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码有点像声音的碰撞检测。每当Thomas停留在围绕火砖发射器的500x500像素矩形内时，“playFire”函数就会被调用，传入发射器和Thomas的坐标。然后“playFire”函数会完成其余的工作，并触发一个空间化的循环声音效果。
- en: 'Open up the `DetectCollisions.cpp` file, find the appropriate place, and add
    the highlighted code as shown in the following. The two highlighted lines of code
    trigger the playing of a sound effect when either character falls into a water
    or fire tile:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 打开“DetectCollisions.cpp”文件，找到适当的位置，并按照以下所示添加高亮代码。两行高亮代码触发了当角色掉入水或火砖时播放声音效果。
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Playing the game will allow you to hear all the sounds, including cool spatialization,
    when near a fire tile.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏将允许您听到所有的声音，包括在靠近火砖时的很酷的空间化。
- en: The HUD class
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HUD类
- en: The HUD is super-simple and not really anything different compared to the other
    two projects in the book. What we will do that is different is wrap all the code
    up in a new HUD class. If we declare all the Font, Text, and other variables as
    members of this new class, we can then initialize them in the constructor and
    provide getter functions to all their values. This will keep the `Engine` class
    clear from loads of declarations and initializations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: HUD是超级简单的，与书中的其他两个项目没有什么不同。我们要做的不同之处在于将所有代码封装在一个新的HUD类中。如果我们将所有的字体、文本和其他变量声明为这个新类的成员，然后在构造函数中初始化它们，并为它们提供getter函数，这将使得“Engine”类清除了大量的声明和初始化。
- en: Coding HUD.h
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写HUD.h
- en: First, we will code the `HUD.h` file with all the member variables and function
    declarations. Right-click **Header Files** in the **Solution Explorer** and select
    **Add** | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File** (`.h`) and then in the **Name** field, type `HUD.h`. Finally,
    click the **Add** button. We are now ready to code the header file for the `HUD`
    class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写`HUD.h`文件，其中包含所有成员变量和函数声明。在**解决方案资源管理器**中右键单击**头文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**头文件**（`.h`）并在**名称**字段中键入`HUD.h`。最后，单击**添加**按钮。现在我们准备为`HUD`类编写头文件。
- en: 'Add the following code to `HUD.h`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`HUD.h`中：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the previous code, we added one `Font` instance and three `Text` instances.
    The `Text` objects will be used to show a message prompting the user to start,
    the time remaining, and the current level number.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，我们添加了一个`Font`实例和三个`Text`实例。`Text`对象将用于显示提示用户开始、剩余时间和当前级别编号的消息。
- en: The public functions are more interesting. First, there is the constructor,
    where most of the code will go. The constructor will initialize the `Font` and
    `Text` objects, as well as position them on the screen relative to the current
    screen resolution.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 公共函数更有趣。首先是构造函数，大部分代码将在其中。构造函数将初始化`Font`和`Text`对象，并将它们相对于当前屏幕分辨率定位在屏幕上。
- en: The three getter functions, `getMessage`, `getLevel`, and `getTime` will return
    a `Text` object to the calling code in order to be able to draw them to the screen.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 三个getter函数，`getMessage`、`getLevel`和`getTime`将返回一个`Text`对象给调用代码，以便能够将它们绘制到屏幕上。
- en: The `setLevel` and `setTime` functions will be used to update the text shown
    in `m_LevelText` and `m_TimeText`, `respectively`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`setLevel`和`setTime`函数将用于更新显示在`m_LevelText`和`m_TimeText`中的文本。'
- en: Now we can code all the definitions for the functions we have just outlined.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写刚刚概述的所有函数的定义。
- en: Coding the HUD.cpp file
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写HUD.cpp文件
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `HUD.cpp`. Finally,
    click the **Add** button. We are now ready to code the `.cpp` file for the `HUD`
    class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**C++文件（**
    `.cpp` **）**并在**名称**字段中键入`HUD.cpp`。最后，单击**添加**按钮。现在我们准备为`HUD`类编写`.cpp`文件。
- en: 'Add the include directives and the following code, and then we will discuss
    it:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 添加包含指令和以下代码，然后我们将讨论它：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we store the horizontal and vertical resolution in a `Vector2u` called
    `resolution`. Next, we load the font from the `fonts` directory that we added
    back in [Chapter 12](ch12.html "Chapter 12. Abstraction and Code Management –
    Making Better Use of OOP"), A*bstraction and Code Management - Making Better Use
    of OOP*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将水平和垂直分辨率存储在名为`resolution`的`Vector2u`中。接下来，我们从我们在[第12章](ch12.html "第12章。抽象和代码管理
    - 更好地利用面向对象编程")中添加的`fonts`目录中加载字体。*抽象和代码管理 - 更好地利用面向对象编程*。
- en: 'The next four lines of code set the font, the color, the size, and the text
    of `m_StartText`. The block of code after this captures the size of the rectangle
    that wraps `m_StartText` and performs a calculation to work out how to position
    it centrally on the screen. If you want a more thorough explanation of this part
    of the code, refer back to [Chapter 3](ch03.html "Chapter 3. C++ Strings, SFML
    Time, Player Input, and HUD"): *C++ Strings, SFML Time - Player Input and HUD*.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四行代码设置了`m_StartText`的字体、颜色、大小和文本。此后的代码块捕获了包裹`m_StartText`的矩形的大小，并进行计算以确定如何将其居中放置在屏幕上。如果您想对代码的这部分进行更详细的解释，请参考[第3章](ch03.html
    "第3章。C++字符串、SFML时间、玩家输入和HUD")：*C++字符串、SFML时间 - 玩家输入和HUD*。
- en: The final two blocks of code in the constructor set the font, text size, color,
    position, and actual text for `m_TimeText` and `m_LevelText`. We will see in a
    moment, however, that these two `Text` objects will be updatable through two setter
    functions, whenever it is required.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中的最后两个代码块设置了`m_TimeText`和`m_LevelText`的字体、文本大小、颜色、位置和实际文本。然而，我们很快会看到，这两个`Text`对象将通过两个setter函数进行更新，每当需要时。
- en: 'Add the following getter and setter functions immediately after the code we
    have just added:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚添加的代码之后立即添加以下getter和setter函数：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first three functions in the previous code simply return the appropriate
    `Text` object, `m_StartText`, `m_LevelText`, and `m_TimeText`. We will use these
    functions shortly, when drawing the HUD on the screen. The final two functions,
    `setLevel` and `setTime`, use the `setString` functions to update the appropriate
    `Text` object with the value that will be passed in from the `update` function
    of the `Engine` class every 500 frames.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 先前代码中的前三个函数只是返回适当的`Text`对象，`m_StartText`、`m_LevelText`和`m_TimeText`。我们将很快使用这些函数，在屏幕上绘制HUD时。最后两个函数，`setLevel`和`setTime`，使用`setString`函数来更新适当的`Text`对象，该值将从`Engine`类的`update`函数中每500帧传入。
- en: With all that done, we can put the HUD class to work in our game engine.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，我们可以在游戏引擎中使用HUD类。
- en: Using the HUD class
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HUD类
- en: Open `Engine.h`, add an include for our new class, declare an instance of the
    new `HUD` class, and also declare and initialize two new member variables that
    will keep track of how often we update the HUD. As we have learned in the two
    previous projects, we don't need to do this for every frame.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Engine.h`，添加一个包含我们新类的声明，声明一个新的`HUD`类的实例，并声明并初始化两个新的成员变量，用于跟踪我们更新HUD的频率。正如我们在之前的两个项目中学到的，我们不需要为每一帧都这样做。
- en: 'Add the highlighted code to `Engine.h`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将突出显示的代码添加到`Engine.h`中：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need to add some code to the `update` function of the `Engine` class.
    Open `Update.cpp` and add the highlighted code to update the HUD once every 500
    frames:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`Engine`类的`update`函数中添加一些代码。打开`Update.cpp`并添加突出显示的代码以每500帧更新HUD：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the previous code, `m_FramesSinceLastUpdate` is incremented each frame. When
    `m_FramesSinceLastUpdate` exceeds `m_TargetFramesPerHUDUpdate`, execution enters
    the `if` block. Inside the `if` block, we use `stringstream` objects to update
    our `Text`, as we have done in both previous projects. As you probably expected,
    however, in this project we are using the `HUD` class, so we call the `setTime`
    and `setLevel` functions, passing in the current values that the `Text` objects
    need to be set to.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`m_FramesSinceLastUpdate`在每帧递增。当`m_FramesSinceLastUpdate`超过`m_TargetFramesPerHUDUpdate`时，执行进入`if`块。在`if`块内部，我们使用`stringstream`对象来更新我们的`Text`，就像在之前的项目中所做的那样。然而，正如你可能期望的那样，在这个项目中我们使用了`HUD`类，所以我们调用`setTime`和`setLevel`函数，传入`Text`对象需要设置的当前值。
- en: The final step in the `if` block is to set `m_FramesSinceLastUpdate` back to
    zero so it can start counting toward the next update.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`块中的最后一步是将`m_FramesSinceLastUpdate`设置回零，这样它就可以开始计算下一个更新。'
- en: 'Finally, open the `Draw.cpp` file and add the highlighted code to draw the
    HUD, each frame:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开`Draw.cpp`文件，并添加突出显示的代码来每帧绘制HUD。
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The previous code draws the HUD by using the getter functions from the HUD class.
    Notice that the call to draw the message to that prompts the player to start is
    only used when the game is not currently playing `(!m_Playing)`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用HUD类的getter函数来绘制HUD。请注意，只有在游戏当前未进行时`(!m_Playing)`才会调用绘制提示玩家开始的消息。
- en: Run the game and play a few levels to see the time tick down and the levels
    tick up. When you get back to level one again, notice that you have 10% less time
    than before.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并玩几个关卡，看时间倒计时和关卡增加。当你再次回到第一关时，注意你的时间比之前少了10%。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Our Thomas Was Late game is not only fully playable, with directional sound
    effects and a simple but informative HUD, but we also have the capability to add
    new levels with ease. At this point, we could call it done.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的《Thomas Was Late》游戏不仅可以完全玩得了，还有定向音效和简单但信息丰富的HUD，而且我们还可以轻松添加新的关卡。在这一点上，我们可以说它已经完成了。
- en: It would be nice to add a bit more sparkle. In the following chapter, we will
    look into two gaming concepts. Firstly we will look at particle systems, which
    are how we can handle things such as explosions or other special effects. To achieve
    this, we will need to learn a bit more C++, look at a way we might radically rethink
    how we structure our game code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 增加一些闪光效果会很好。在接下来的章节中，我们将探讨两个游戏概念。首先，我们将研究粒子系统，这是我们如何处理爆炸或其他特殊效果的方法。为了实现这一点，我们需要学习更多的C++知识，看看我们如何彻底重新思考我们的游戏代码结构。
- en: After that, we will add the final flourish to the game when we learn about OpenGL
    and the programmable graphics pipeline. We will then be in a position to dip our
    toes into the **GLSL** language, which allows us to write code that executes directly
    on the GPU, to create some special effects.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当我们学习OpenGL和可编程图形管线时，我们将为游戏添加最后的点睛之笔。然后，我们将有机会涉足**GLSL**语言，这使我们能够编写直接在GPU上执行的代码，以创建一些特殊效果。
