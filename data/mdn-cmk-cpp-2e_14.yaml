- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Installing and Packaging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和打包
- en: 'Our project has been built, tested, and documented. Now, it’s finally time
    to release it to our users. This chapter primarily focuses on the final two steps
    we need to take: installation and packaging. These are advanced techniques that
    build on top of everything we’ve learned so far: managing targets and their dependencies,
    transient usage requirements, generator expressions, and much more.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目已经构建、测试并且文档化完毕。现在，终于到了将其发布给用户的时候。本章主要集中在我们需要采取的最后两步：安装和打包。这些是建立在我们迄今为止所学的所有内容之上的高级技术：管理目标及其依赖关系、临时使用要求、生成器表达式等等。
- en: Installation allows our project to be discoverable and accessible system-wide.
    We will cover how to export targets for use by other projects without needing
    installation and how to install our projects for easy system-wide accessibility.
    We’ll learn how to configure our project to automatically place various artifact
    types in their appropriate directories. To handle more advanced scenarios, we’ll
    introduce low-level commands for installing files and directories, as well as
    for executing custom scripts and CMake commands.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 安装使我们的项目可以被发现并在系统范围内访问。我们将讨论如何导出目标以供其他项目使用而无需安装，以及如何安装我们的项目以便轻松地在系统范围内访问。我们还将学习如何配置项目，使其能够自动将各种工件类型放置到适当的目录中。为了处理更高级的场景，我们将介绍一些低级命令，用于安装文件和目录，以及执行自定义脚本和
    CMake 命令。
- en: 'Next, we’ll explore setting up reusable CMake packages that other projects
    can discover using the `find_package()` command. We’ll explain how to ensure that
    targets and their definitions are not restricted to a specific file system location.
    We’ll also discuss how to write basic and advanced **config files**, along with
    the **version files** associated with packages. Then, to make things modular,
    we’ll briefly introduce the concept of components, both in terms of CMake packages
    and the `install()` command. All this preparation will pave the way for the final
    aspect we’ll be covering in this chapter: using CPack to generate archives, installers,
    bundles, and packages that are recognized by all kinds of package managers in
    different operating systems. These packages can distribute pre-built artifacts,
    executables, and libraries. It’s the easiest way for end users to start using
    our software.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何设置可重用的 CMake 包，其他项目可以通过 `find_package()` 命令进行发现。我们将解释如何确保目标及其定义不局限于特定的文件系统位置。我们还将讨论如何编写基本的和高级的
    **配置文件**，以及与包关联的 **版本文件**。然后，为了使事物更具模块化，我们将简要介绍组件的概念，无论是在 CMake 包还是在 `install()`
    命令方面。所有这些准备工作将为本章的最终部分铺平道路：使用 CPack 生成归档、安装程序、捆绑包和包，这些包能够被不同操作系统中的各种包管理器识别。这些包可以分发预构建的工件、可执行文件和库。这是最终用户开始使用我们软件的最简单方法。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主要主题：
- en: Exporting without installation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需安装即可导出
- en: Installing projects on the system
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统上安装项目
- en: Creating reusable packages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用的包
- en: Defining components
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义组件
- en: Packaging with CPack
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CPack 打包
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch14](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch14).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章中出现的代码文件，网址是[https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch14](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch14)。
- en: 'To build the examples provided in this book, always use the recommended commands:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建本书中提供的示例，请始终使用推荐的命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To install examples, use the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装示例，请使用以下命令：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Be sure to replace the `<build tree>` and `<source tree>` placeholders with
    appropriate paths. As a reminder: **build tree** is the path to the target/output
    directory and **source tree** is the path at which your source code is located.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 `<build tree>` 和 `<source tree>` 占位符替换为适当的路径。提醒一下：**build tree** 是指目标/输出目录的路径，**source
    tree** 是指源代码所在的路径。
- en: Exporting without installation
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无需安装即可导出
- en: How can we make the targets of project `A` available to the consuming project,
    `B`? Usually, we’d use the `find_package()` command, but that requires creating
    a package and installing it on the system. While useful, this approach involves
    some work. Sometimes, we just need a quick way to build a project and make its
    targets available for other projects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何让项目`A`的目标对使用它的项目`B`可用？通常，我们会使用`find_package()`命令，但这要求创建一个包并将其安装到系统中。虽然有用，但这种方法需要一些工作。有时，我们只需要一种快速构建项目并使其目标可供其他项目使用的方法。
- en: 'One time-saving method is to include in project `B` the main listfile of `A`,
    which already contains all the target definitions. However, this file might also
    include global configuration, CMake commands with side effects, additional dependencies,
    and perhaps unwanted targets for `B` (like unit tests). So, this is not the best
    approach. Instead, we can provide a **target export file** for the consuming project,
    `B`, to include with the `include()` command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一种节省时间的方法是包含项目`B`中`A`的主列表文件，该文件已经包含了所有目标定义。然而，这个文件也可能包含全局配置、带有副作用的CMake命令、额外的依赖项，甚至可能包含不适合`B`的目标（比如单元测试）。因此，这不是最好的方法。相反，我们可以为使用项目`B`提供一个**目标导出文件**，让它通过`include()`命令来包含：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will define all targets of `A` with the correct properties set, using commands
    such as `add_library()` and `add_executable()`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用像`add_library()`和`add_executable()`这样的命令，定义所有目标并设置正确的属性。
- en: 'You must specify all targets to export after the `TARGETS` keyword and provide
    the destination filename after `FILE`. The other arguments are optional:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在`TARGETS`关键字后指定所有要导出的目标，并在`FILE`后提供目标文件名。其他参数是可选的：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s the explanation of the individual arguments:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对各个参数的解释：
- en: '`NAMESPACE` is recommended to indicate that the target has been imported from
    other projects.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAMESPACE`建议用来指示目标是从其他项目导入的。'
- en: '`APPEND` prevents CMake from erasing the file’s contents before writing.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APPEND`防止CMake在写入前清除文件内容。'
- en: '`EXPORT_LINK_INTERFACE_LIBRARIES` exports target link dependencies (including
    imported and config-specific variants).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPORT_LINK_INTERFACE_LIBRARIES`导出目标链接依赖关系（包括导入的和配置特定的变体）。'
- en: 'Let’s apply this exporting method to the `Calc` library example, which provides
    two simple methods:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此导出方法应用到`Calc`库示例，它提供了两个简单的方法：
- en: '**ch14/01-export/src/include/calc/basic.h**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/01-export/src/include/calc/basic.h**'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to declare the `Calc` target so we have something to export:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要声明`Calc`目标，以便有东西可以导出：
- en: '**ch14/01-export/src/CMakeLists.txt**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/01-export/src/CMakeLists.txt**'
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, to generate the export file, we are using the `export(TARGETS)` command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了生成导出文件，我们使用`export(TARGETS)`命令：
- en: '**ch14/01-export/CMakeLists.txt (fragment)**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/01-export/CMakeLists.txt（片段）**'
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our exported target declaration file will be located in the `cmake` subdirectory
    of the build tree (following the convention for `.cmake` files). To avoid repeating
    this path later, we’re setting it in the `EXPORT_DIR` variable. Then, we call
    `export()` to generate the target declaration file, `CalcTargets.cmake`, with
    the `calc` target. For projects including this file, it will be visible as `Calc::calc`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的导出目标声明文件将位于构建树的`cmake`子目录中（遵循`.cmake`文件的约定）。为了避免稍后重复此路径，我们将其设置为`EXPORT_DIR`变量。然后，我们调用`export()`生成目标声明文件`CalcTargets.cmake`，其中包含`calc`目标。对于包含此文件的项目，它将作为`Calc::calc`可见。
- en: Note that this export file isn’t *a package* yet. More importantly, all paths
    in this file are absolute and hardcoded to the build tree, making them non-relocatable
    (discussed in the *Understanding the issues with relocatable targets* section).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此导出文件还不是*一个包*。更重要的是，这个文件中的所有路径都是绝对路径并且硬编码为构建树中的路径，导致它们无法移动（在*理解可移动目标的问题*一节中讨论）。
- en: 'The `export()` command also has a shorter version using the `EXPORT` keyword:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`export()`命令也有一个简化版本，使用`EXPORT`关键字：'
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, it requires the name of a predefined export rather than a list of exported
    targets. Such `<export>` instances are named lists of targets that are created
    by `install(TARGETS)` (we’ll cover this command in the *Installing logical targets*
    section).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它需要预定义导出的名称，而不是一个导出目标的列表。此类`<export>`实例是由`install(TARGETS)`创建的目标名称列表（我们将在*安装逻辑目标*一节中讨论此命令）。
- en: 'Here’s a tiny example demonstrating how this shorthand is used in practice:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小示例，演示了这种简写是如何在实践中使用的：
- en: '**ch14/01-export/CMakeLists.txt (continued)**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/01-export/CMakeLists.txt（续）**'
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code works similarly to the previous example, but now it shares a single
    target list between the `export()` and `install()` commands.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的工作方式与之前的示例类似，但现在它在`export()`和`install()`命令之间共享一个单一的目标列表。
- en: 'Both methods of generating export files yield similar results. They include
    some boilerplate code and a few lines defining the target. With `<build-tree>`
    set to the build tree path, they’ll create a **target export file** similar to
    this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 两种生成导出文件的方法产生类似的结果。它们包括一些样板代码和几行定义目标的代码。在将`<build-tree>`设置为构建树路径后，它们将创建类似于以下的**目标导出文件**：
- en: '**<build-tree>/cmake/CalcTargets.cmake (fragment)**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**<build-tree>/cmake/CalcTargets.cmake (片段)**'
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Normally, we wouldn’t edit or even open this file, but it’s important to note
    that the paths will be hardcoded in it (see the highlighted lines). In its current
    form, the built project isn’t relocatable. To change that, some additional steps
    are required. In the next section, we’ll explain what relocation is and why it
    is important.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不会编辑或打开此文件，但需要注意的是，路径将被硬编码在其中（请参见高亮行）。在当前形式下，构建的项目无法重新定位。要改变这一点，需要一些额外的步骤。在下一节中，我们将解释什么是重新定位以及为什么它很重要。
- en: Installing projects on the system
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将项目安装到系统中
- en: 'In *Chapter 1*, *First Steps with CMake*, we indicated that CMake offers a
    command-line mode for installing built projects on the system:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章*，*CMake入门*中，我们提到CMake为将构建的项目安装到系统中提供了命令行模式：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, `<dir>` is the path to the generated build tree (required). The `<options>`
    include:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<dir>`是生成的构建树的路径（必需）。`<options>`包括：
- en: '`--config <cfg>`: This selects the build configuration for multi-configuration
    generators.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--config <cfg>`：选择多配置生成器的构建配置。'
- en: '`--component <comp>`: This limits the installation to the given component.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--component <comp>`：将安装限制为指定的组件。'
- en: '`--default-directory-permissions <permissions>`: This sets the default permissions
    for the installed directories (in `<u=rwx,g=rx,o=rx>` format).'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--default-directory-permissions <permissions>`：设置已安装目录的默认权限（以`<u=rwx,g=rx,o=rx>`格式）。'
- en: '`--install-prefix <prefix>`: This specifies the non-default installation path
    (stored in the `CMAKE_INSTALL_PREFIX` variable). It defaults to `/usr/local` on
    Unix-like systems and to `c:/Program Files/${PROJECT_NAME}` on Windows. Before
    CMake 3.21, you’ll have to use a less-explicit option: `--prefix <prefix>`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--install-prefix <prefix>`：指定非默认的安装路径（存储在`CMAKE_INSTALL_PREFIX`变量中）。在类Unix系统上默认为`/usr/local`，在Windows上默认为`c:/Program
    Files/${PROJECT_NAME}`。在CMake 3.21之前，您必须使用一个不太明确的选项：`--prefix <prefix>`。'
- en: '`-v, --verbose`: This increases the verbosity of the output (achievable also
    by setting the `VERBOSE` environment variable).'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v, --verbose`：增加输出的详细程度（也可以通过设置`VERBOSE`环境变量实现）。'
- en: 'Installations typically involve copying generated artifacts and necessary dependencies
    to a system directory. Using CMake introduces a convenient installation standard
    to all CMake projects and offers several additional benefits:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 安装通常涉及将生成的产物和必要的依赖项复制到系统目录中。使用CMake为所有CMake项目引入了一个方便的安装标准，并提供了几个额外的好处：
- en: It provides platform-specific installation paths for artifacts, depending on
    their types (by following *GNU coding standards*).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为不同类型的产物提供平台特定的安装路径（遵循*GNU编码标准*）。
- en: It enhances the installation process by generating target export files, allowing
    direct reuse of project targets by other projects.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过生成目标导出文件来增强安装过程，允许其他项目直接重用项目的目标。
- en: It creates discoverable packages through **config files**, wrapping the target
    export files and package-specific CMake macros and functions defined by the author.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过**配置文件**创建可发现的包，包装目标导出文件以及作者定义的特定于包的CMake宏和函数。
- en: 'These features are quite powerful as they save a lot of time and simplify the
    usage of projects that are prepared this way. The first step in performing a basic
    installation is copying the built artifacts to their destination directory. This
    brings us to the `install()` command and its various modes:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能非常强大，因为它们节省了大量时间，并简化了以这种方式准备的项目的使用。执行基本安装的第一步是将构建的产物复制到目标目录。这将引导我们进入`install()`命令及其各种模式：
- en: '`install(``TARGETS)`: This installs output artifacts such as libraries and
    executables.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install(``TARGETS)`: 该命令用于安装输出的产物，如库文件和可执行文件。'
- en: '`install(FILES|PROGRAMS)`: This installs individual files and sets their permissions.
    These files don’t need to be part of any logical targets.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install(FILES|PROGRAMS)`：安装单个文件并设置它们的权限。这些文件不需要是任何逻辑目标的一部分。'
- en: '`install(DIRECTORY)`: This installs entire directories.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install(DIRECTORY)`：此命令安装整个目录。'
- en: '`install(SCRIPT|CODE)`: This runs a CMake script or a snippet during installation.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install(SCRIPT|CODE)`：在安装过程中运行 CMake 脚本或代码片段。'
- en: '`install(EXPORT)`: This generates and installs a target export file.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install(EXPORT)`：此命令生成并安装目标导出文件。'
- en: '`install(RUNTIME_DEPENDENCY_SET <set-name> [...])`: This installs runtime dependency
    sets defined in the project.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install(RUNTIME_DEPENDENCY_SET <set-name> [...])`：此命令安装项目中定义的运行时依赖集。'
- en: '`install(IMPORTED_RUNTIME_ARTIFACTS <target>... [...])`: This queries imported
    targets for runtime artifacts and installs them.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install(IMPORTED_RUNTIME_ARTIFACTS <target>... [...])`：此命令查询导入的目标的运行时工件并安装它们。'
- en: Adding these commands to your listfile generates a `cmake_install.cmake` file
    in your build tree. While it’s possible to manually invoke this script with `cmake
    -P`, this is not recommended. The file is intended for internal use by CMake when
    `cmake --install` is executed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些命令添加到你的列表文件中会在构建树中生成一个 `cmake_install.cmake` 文件。虽然可以通过 `cmake -P` 手动调用此脚本，但不推荐这么做。该文件是
    CMake 在执行 `cmake --install` 时内部使用的。
- en: 'Every `install()` mode has a comprehensive set of options, with a few shared
    across modes:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每种 `install()` 模式都有一组全面的选项，其中一些选项在不同模式间是共享的：
- en: '`DESTINATION`: This specifies the installation path. Relative paths are prepended
    with `CMAKE_INSTALL_PREFIX`, while absolute paths are used verbatim (and not supported
    by `cpack`).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DESTINATION`：此选项指定安装路径。相对路径会与 `CMAKE_INSTALL_PREFIX` 一起使用，而绝对路径会按原样使用（并且不被
    `cpack` 支持）。'
- en: '`PERMISSIONS`: This sets file permissions on supported platforms. The available
    values include `OWNER_READ`, `OWNER_WRITE`, `OWNER_EXECUTE`, `GROUP_READ`, `GROUP_WRITE`,
    `GROUP_EXECUTE`, `WORLD_READ`, `WORLD_WRITE`, `WORLD_EXECUTE`, `SETUID`, and `SETGID`.
    Default directory permissions created during installation time can be set with
    the `CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS` variable.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PERMISSIONS`：此选项设置支持平台上的文件权限。可用的值包括 `OWNER_READ`、`OWNER_WRITE`、`OWNER_EXECUTE`、`GROUP_READ`、`GROUP_WRITE`、`GROUP_EXECUTE`、`WORLD_READ`、`WORLD_WRITE`、`WORLD_EXECUTE`、`SETUID`
    和 `SETGID`。可以通过 `CMAKE_INSTALL_DEFAULT_DIRECTORY_PERMISSIONS` 变量设置安装时创建的默认目录权限。'
- en: '`CONFIGURATIONS`: This specifies configurations (`Debug`, `Release`). Options
    following this keyword apply only if the current build configuration is in the
    list.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIGURATIONS`：此选项指定配置（`Debug`、`Release`）。跟随此关键字的选项仅在当前构建配置位于列表中时才适用。'
- en: '`OPTIONAL`: This prevents errors when the installed files don’t exist.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONAL`：如果安装的文件不存在，则不会报错。'
- en: 'Two shared options, `COMPONENT` and `EXCLUDE_FROM_ALL`, are used in component-specific
    installations. These will be discussed in the *Defining components* section later
    in the chapter. For now, let’s take a look at the first installation mode: `install(TARGETS)`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 两个共享选项，`COMPONENT` 和 `EXCLUDE_FROM_ALL`，用于特定组件的安装。这些选项将在本章稍后的*定义组件*部分讨论。现在，让我们先看看第一个安装模式：`install(TARGETS)`。
- en: Installing logical targets
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装逻辑目标
- en: 'Targets defined by `add_library()` and `add_executable()` can easily be installed
    with the `install(TARGETS)` command. This means copying the artifacts that have
    been produced by the buildsystem to the appropriate destination directories and
    setting suitable file permissions for them. The general signature for this mode
    is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `add_library()` 和 `add_executable()` 定义的目标可以通过 `install(TARGETS)` 命令轻松安装。这意味着将构建系统生成的工件复制到适当的目标目录，并为它们设置合适的文件权限。此模式的通用签名如下：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After the initial mode specifier, that is, `TARGETS`, we must provide a list
    of targets we’d like to install. Here, we may optionally assign them to a **named
    export** with the `EXPORT` option, which can be used in `export(EXPORT)` and `install(EXPORT)`
    to produce a target export file. Then, we must configure the installation of output
    artifacts (grouped by type). Optionally, we can provide a list of directories
    that will be added to the target export file for each target in its `INTERFACE_INCLUDE_DIRECTORIES`
    property.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始模式指定符（即 `TARGETS`）之后，我们必须提供我们希望安装的目标列表。在这里，我们可以选择性地通过 `EXPORT` 选项将它们分配给一个**命名的导出**，该导出可以在
    `export(EXPORT)` 和 `install(EXPORT)` 中使用，以生成目标导出文件。接着，我们需要配置输出工件的安装（按类型分组）。可选地，我们还可以提供一个目录列表，这些目录将添加到每个目标的
    `INTERFACE_INCLUDE_DIRECTORIES` 属性的目标导出文件中。
- en: '`[<output-artifact-configuration>...]` provides a list of configuration blocks.
    The full syntax of a single block is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`[<output-artifact-configuration>...]` 提供了一组配置块的列表。单个块的完整语法如下：'
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The command mandates that every output artifact block starts with `<TYPE>`
    (this is the only required element). CMake recognizes several of them:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令要求每个输出产物块以`<TYPE>`开始（这是唯一必需的元素）。CMake识别几种类型：
- en: '`ARCHIVE`: Static libraries (`.a`) and DLL import libraries for Windows-based
    systems (`.lib`).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARCHIVE`：静态库（`.a`）和Windows系统的DLL导入库（`.lib`）。'
- en: '`LIBRARY`: Shared libraries (`.so`), but not DLLs.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIBRARY`：共享库（`.so`），但不包括DLL。'
- en: '`RUNTIME`: Executables and DLLs.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNTIME`：可执行文件和DLL。'
- en: '`OBJECTS`: *Object files* from `OBJECT` libraries.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OBJECTS`：来自`OBJECT`库的*目标文件*。'
- en: '`FRAMEWORK`: Static and shared libraries that have the `FRAMEWORK` property
    set (this excludes them from `ARCHIVE` and `LIBRARY`). This is macOS-specific.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FRAMEWORK`：具有`FRAMEWORK`属性设置的静态库和共享库（这将使它们排除在`ARCHIVE`和`LIBRARY`之外）。这是特定于macOS的。'
- en: '`BUNDLE`: Executables marked with `MACOSX_BUNDLE` (also not part of `RUNTIME`).'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUNDLE`：标记为`MACOSX_BUNDLE`的可执行文件（也不属于`RUNTIME`）。'
- en: '`FILE_SET <set>`: Files in the `<set>` file set specified for the target. Either
    C++ header files or C++ module headers (since CMake 3.23).'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILE_SET <set>`：目标指定的`<set>`文件集中的文件。可以是C++头文件或C++模块头文件（自CMake 3.23起）。'
- en: '`PUBLIC_HEADER`, `PRIVATE_HEADER`, `RESOURCE`: Files specified in the target
    properties with the same name (on Apple platforms, they should be set on the `FRAMEWORK`
    or `BUNDLE` targets).'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUBLIC_HEADER`，`PRIVATE_HEADER`，`RESOURCE`：在目标属性中指定的文件，名称相同（在Apple平台上，它们应该设置在`FRAMEWORK`或`BUNDLE`目标中）。'
- en: 'The CMake documentation claims that if you only configure one artifact type
    (for example, `LIBRARY`), only this type will be installed. For CMake version
    3.26.0, this is not true: all the artifacts will be installed as if they were
    configured with the default options. This can be solved by specifying `<TYPE>
    EXCLUDE_FROM_ALL` for all unwanted artifact types.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: CMake文档声称，如果你只配置了一种产物类型（例如`LIBRARY`），则仅安装这种类型。对于CMake 3.26.0版本而言，这不准确：所有产物都会像使用默认选项一样安装。可以通过为所有不需要的产物类型指定`<TYPE>
    EXCLUDE_FROM_ALL`来解决此问题。
- en: A single `install(TARGETS)` command can have multiple artifact configuration
    blocks. However, be aware that you may only specify one of each type per call.
    That is, if you’d like to configure different destinations of `ARCHIVE` artifacts
    for the `Debug` and `Release` configurations, then you must make two separate
    `install(TARGETS ... ARCHIVE)` calls.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`install(TARGETS)`命令可以包含多个产物配置块。然而，需要注意的是，每次调用时只能指定一种类型。也就是说，如果你想为`Debug`和`Release`配置设置不同的`ARCHIVE`产物目标路径，那么必须分别执行两次`install(TARGETS
    ... ARCHIVE)`调用。
- en: 'You may also omit the type name and specify options for all the artifacts.
    Installation would then be then performed for every file that’s produced by these
    targets, regardless of their type:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以省略类型名称并为所有产物指定选项。安装时将会对这些目标产生的每个文件执行安装，无论其类型如何：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In many cases, you don’t need to provide the `DESTINATION` explicitly, thanks
    to the built-in defaults, but there are a few caveats to keep in mind when dealing
    with different platforms.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你不需要显式地提供`DESTINATION`，因为有内建的默认值，但在处理不同平台时，有一些注意事项需要记住。
- en: Utilizing the default destination for different platforms
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用不同平台的默认安装路径
- en: 'When CMake installs your project’s files, it copies them into a specific directory
    in the system. Different file types belong in different directories. This directory
    is determined by the following formula:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当CMake安装你的项目文件时，它会将文件复制到系统中的特定目录。不同的文件类型应该放在不同的目录中。该目录由以下公式确定：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As mentioned in the previous section, you can explicitly provide the `DESTINATION`
    component for installation, or let CMake use a built-in default based on the type
    of the artifact:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，你可以显式地提供安装的`DESTINATION`组件，或者让CMake根据产物类型使用内建的默认值：
- en: '| **Artifact type** | **Built-in default** | **Install directory variable**
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **产物类型** | **内建默认值** | **安装目录变量** |'
- en: '| `RUNTIME` | `bin` | `CMAKE_INSTALL_BINDIR` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `RUNTIME` | `bin` | `CMAKE_INSTALL_BINDIR` |'
- en: '| `LIBRARY``ARCHIVE` | `lib` | `CMAKE_INSTALL_LIBDIR` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `LIBRARY``ARCHIVE` | `lib` | `CMAKE_INSTALL_LIBDIR` |'
- en: '| `PUBLIC_HEADER``PRIVATE_HEADER``FILE_SET` (`type` `HEADERS`) | `include`
    | `CMAKE_INSTALL_INCLUDEDIR` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `PUBLIC_HEADER``PRIVATE_HEADER``FILE_SET`（`type` `HEADERS`） | `include` |
    `CMAKE_INSTALL_INCLUDEDIR` |'
- en: 'Table 14.1: Default destinations per artifact type'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.1：每种产物类型的默认目标路径
- en: While default paths are useful, they aren’t always appropriate. For example,
    CMake defaults the `DESTINATION` for libraries to `lib`. The full path for libraries
    is then computed as `/usr/local/lib` for Unix-like systems and something like
    `C:\Program Files (x86)\<project-name>\lib` on Windows. However, this is not ideal
    for Debian with multi-arch support, which requires an architecture-specific path
    (e.g., `i386-linux-gnu`) when `INSTALL_PREFIX` is `/usr`. Determining the correct
    path for each platform is a common challenge for Unix-like systems. To address
    this, follow the *GNU Coding Standards*, the link to which is added in the *Further
    reading* section at the end of this chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然默认路径非常有用，但并非总是适用。例如，CMake默认将库的`DESTINATION`设置为`lib`。库的完整路径会被计算为Unix类系统上的`/usr/local/lib`，在Windows上则是类似`C:\Program
    Files (x86)\<project-name>\lib`的路径。然而，对于支持多架构的Debian来说，这并不理想，因为它需要一个架构特定的路径（例如，`i386-linux-gnu`），当`INSTALL_PREFIX`为`/usr`时。为每个平台确定正确的路径是Unix类系统的常见挑战。为了解决这个问题，可以遵循*GNU编码标准*，相关链接会在本章最后的*进一步阅读*部分提供。
- en: We can override the default destinations for each value by setting a `CMAKE_INSTALL_<DIRTYPE>DIR`
    variable. Instead of developing an algorithm to detect the platform and assign
    appropriate paths to the install directory variables, use the CMake `GNUInstallDirs`
    utility module. This module handles most platforms by setting the install directory
    variables accordingly. Just include it using `include()` before any `install()`
    commands, and you’ll be set.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置`CMAKE_INSTALL_<DIRTYPE>DIR`变量来覆盖每个值的默认目标路径。与其开发算法来检测平台并为安装目录变量分配适当的路径，不如使用CMake的`GNUInstallDirs`工具模块。该模块通过相应地设置安装目录变量来处理大多数平台。只需在任何`install()`命令之前通过`include()`包含该模块，就可以完成配置。
- en: 'Users needing custom configurations can override the install directory variables
    via the command-line argument like so:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 需要自定义配置的用户可以通过命令行参数覆盖安装目录变量，如下所示：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, installing the public headers of libraries still presents challenges.
    Let’s explore why.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，安装库的公共头文件仍然存在挑战。让我们来探讨一下原因。
- en: Dealing with public headers
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理公共头文件
- en: 'When managing public headers in CMake, it’s best practice to store them in
    a directory that indicates their origin and introduces namespacing, such as `/usr/local/include/calc`.
    This enables their use in C++ projects with the inclusion directive:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在CMake中管理公共头文件时，最佳实践是将其存储在一个能表示其来源并引入命名空间的目录中，例如`/usr/local/include/calc`。这使得它们可以在C++项目中通过包含指令使用：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Most preprocessors interpret angle-bracketed directives as requests to scan
    standard system directories. We can use the `GNUInstallDirs` module to automatically
    populate the `DESTINATION` part of the installation path, ensuring headers end
    up in the `include` directory.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数预处理器将尖括号指令解释为请求扫描标准系统目录。我们可以使用`GNUInstallDirs`模块自动填充安装路径中的`DESTINATION`部分，确保头文件最终被放置在`include`目录中。
- en: 'Since CMake 3.23.0, we can explicitly add headers to be installed to the appropriate
    target with the `target_sources()` command and the `FILE_SET` keyword. This method
    is preferred, as it takes care of the *relocation* of headers. Here’s the syntax:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从CMake 3.23.0开始，我们可以通过`target_sources()`命令和`FILE_SET`关键字显式地添加要安装到适当目标的头文件。这个方法更为推荐，因为它处理了头文件的*重定位*问题。以下是语法：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Assuming our headers are in the `src/include/calc` directory, here’s a practical
    example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的头文件位于`src/include/calc`目录中，以下是一个实际的示例：
- en: '**ch14/02-install-targets/src/CMakeLists.txt (fragment)**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/02-install-targets/src/CMakeLists.txt (片段)**'
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Having defined the file set, we can use it in the installation command like
    so:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义文件集后，我们可以像这样在安装命令中使用它：
- en: '**ch14/02-install-targets/src/CMakeLists.txt (continued)**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/02-install-targets/src/CMakeLists.txt (续)**'
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We include the `GNUInstallDirs` module and configure the installation of the
    `calc` static library and its headers. Running `cmake` in install mode works as
    expected:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含`GNUInstallDirs`模块并配置`calc`静态库及其头文件的安装。在安装模式下运行`cmake`，如预期那样工作：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Support for the `FILE_SET HEADERS` keyword is a relatively recent update, and
    unfortunately, not all environments will provide the newer version of CMake**.**
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对`FILE_SET HEADERS`关键字的支持是一个相对较新的更新，遗憾的是，并不是所有环境都能提供更新版的CMake**。**
- en: 'If you’re stuck on a version older than 3.23, you’ll need to specify public
    headers (as a semicolon-separated list) in the `PUBLIC_HEADER` property of the
    library target, and deal with the relocation manually (more on this in the *Understanding
    the issues with relocatable targets* section):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的版本低于 3.23，你需要在库目标的 `PUBLIC_HEADER` 属性中指定公共头文件（以分号分隔的列表），并手动处理重定位问题（更多信息请参见
    *理解可重定位目标的问题* 部分）：
- en: '**ch14/03-install-targets-legacy/src/CMakeLists.txt (fragment)**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/03-install-targets-legacy/src/CMakeLists.txt (片段)**'
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You’ll also need to change the destination directory to include the library
    name in the `include` path:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要更改目标目录，将库名包括在 `include` 路径中：
- en: '**ch14/02-install-targets-legacy/src/CMakeLists.txt (continued)**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/02-install-targets-legacy/src/CMakeLists.txt (续)**'
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Explicitly inserting `/calc` in the path is necessary because files specified
    in the `PUBLIC_HEADER` property don’t retain their directory structure. They will
    all be installed in the same destination, even if nested in different base directories.
    This significant drawback led to the development of `FILE_SET`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 显式地将 `/calc` 插入路径是必要的，因为在 `PUBLIC_HEADER` 属性中指定的文件不会保留其目录结构。即使这些文件嵌套在不同的基础目录中，它们也会被安装到同一个目标目录。这一重大缺点促使了
    `FILE_SET` 的开发。
- en: Now, you know how to address most installation cases, but how should you approach
    more advanced scenarios?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道如何处理大多数安装情况，但对于更高级的场景应该如何处理呢？
- en: Low-level installation
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 低级安装
- en: 'Modern CMake is moving away from directly manipulating files. Ideally, we should
    add files to a logical target, using it as a higher level of abstraction to represent
    all underlying assets: source files, headers, resources, configuration, and so
    on. The main advantage is the code’s dryness; usually, adding a file to the target
    requires changing no more than one line.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 CMake 正在逐渐避免直接操作文件。理想情况下，我们应将文件添加到逻辑目标中，使用目标作为一种高级抽象来表示所有底层资源：源文件、头文件、资源、配置等等。主要优势是代码的简洁性；通常，将文件添加到目标只需要更改一行代码。
- en: 'Unfortunately, adding every installed file to a target isn’t always possible
    or convenient. In such cases, three options are available: `install(FILES)`, `install(PROGRAMS)`,
    and `install(DIRECTORY)`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并不是所有的安装文件都可以或方便地添加到一个目标中。在这种情况下，有三种选择：`install(FILES)`、`install(PROGRAMS)`
    和 `install(DIRECTORY)`。
- en: Installing with install(FILES) and install(PROGRAMS)
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 install(FILES) 和 install(PROGRAMS) 安装
- en: The `FILES` and `PROGRAMS` modes are very similar. They can be used to install
    various assets, including public header files, documentation, shell scripts, configuration,
    and runtime assets like images, audio files, and datasets.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`FILES` 和 `PROGRAMS` 模式非常相似。它们可以用来安装各种资源，包括公共头文件、文档、脚本、配置文件以及运行时资源，如图片、音频文件和数据集。'
- en: 'Here’s the command signature:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令签名：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The main difference between `FILES` and `PROGRAMS` is the default file permissions
    set on the copied files. `install(PROGRAMS)` sets `EXECUTE` for all users, whereas
    `install(FILES)` does not (though both will set `OWNER_WRITE`, `OWNER_READ`, `GROUP_READ`,
    and `WORLD_READ`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`FILES` 和 `PROGRAMS` 之间的主要区别是对复制文件设置的默认文件权限。`install(PROGRAMS)` 会为所有用户设置 `EXECUTE`
    权限，而 `install(FILES)` 不会（但两者都会设置 `OWNER_WRITE`、`OWNER_READ`、`GROUP_READ` 和 `WORLD_READ`
    权限）。'
- en: You can modify this behavior by using the optional `PERMISSIONS` keyword, and
    then choosing the leading keyword (`FILES` or `PROGRAMS`) as an indicator of what’s
    installed. We’ve already covered how `PERMISSIONS`, `CONFIGURATIONS`, and `OPTIONAL`
    work. `COMPONENT` and `EXCLUDE_FROM_ALL` will be discussed later in the *Defining
    components* section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用可选的 `PERMISSIONS` 关键字来修改此行为，然后选择前导关键字（`FILES` 或 `PROGRAMS`）作为指示所安装内容的标志。我们已经介绍了
    `PERMISSIONS`、`CONFIGURATIONS` 和 `OPTIONAL` 的工作原理。`COMPONENT` 和 `EXCLUDE_FROM_ALL`
    将在后面的 *定义组件* 部分讨论。
- en: After the initial keyword, we need to list all the files we want to install.
    CMake supports relative and absolute paths, as well as generator expressions.
    Remember that if your file path starts with a generator expression, it must be
    absolute.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始关键字后，我们需要列出所有想要安装的文件。CMake 支持相对路径和绝对路径，也支持生成器表达式。记住，如果文件路径以生成器表达式开头，它必须是绝对路径。
- en: 'The next required keyword is `TYPE` or `DESTINATION`. You can either explicitly
    provide the `DESTINATION` path or ask CMake to look it up for a specific `TYPE`
    file. Unlike in `install(TARGETS)`, `TYPE` in this context does not select any
    subset of the provided files to be installed. Nevertheless, the computation of
    the installation path follows the same pattern (where the `+` symbol denotes a
    platform-specific path separator):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个必需的关键字是 `TYPE` 或 `DESTINATION`。你可以显式地提供 `DESTINATION` 路径，也可以要求 CMake 查找特定
    `TYPE` 文件的路径。与 `install(TARGETS)` 中不同，在此上下文中，`TYPE` 并不选择任何要安装的文件子集。不过，安装路径的计算遵循相同的模式（其中
    `+` 符号表示平台特定的路径分隔符）：
- en: '`${CMAKE_INSTALL_PREFIX} + ${DESTINATION}`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`${CMAKE_INSTALL_PREFIX} + ${DESTINATION}`'
- en: 'Similarly, every `TYPE` will have built-in defaults:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，每个 `TYPE` 都有内置的默认值：
- en: '| **File Type** | **Built-In Default** | **Installation Directory Variable**
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| **文件类型** | **内置默认值** | **安装目录变量** |'
- en: '| `BIN` | `bin` | `CMAKE_INSTALL_BINDIR` |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `BIN` | `bin` | `CMAKE_INSTALL_BINDIR` |'
- en: '| `SBIN` | `sbin` | `CMAKE_INSTALL_SBINDIR` |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `SBIN` | `sbin` | `CMAKE_INSTALL_SBINDIR` |'
- en: '| `LIB` | `lib` | `CMAKE_INSTALL_LIBDIR` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `LIB` | `lib` | `CMAKE_INSTALL_LIBDIR` |'
- en: '| `INCLUDE` | `include` | `CMAKE_INSTALL_INCLUDEDIR` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `INCLUDE` | `include` | `CMAKE_INSTALL_INCLUDEDIR` |'
- en: '| `SYSCONF` | `etc` | `CMAKE_INSTALL_SYSCONFDIR` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `SYSCONF` | `etc` | `CMAKE_INSTALL_SYSCONFDIR` |'
- en: '| `SHAREDSTATE` | `com` | `CMAKE_INSTALL_SHARESTATEDIR` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `SHAREDSTATE` | `com` | `CMAKE_INSTALL_SHARESTATEDIR` |'
- en: '| `LOCALSTATE` | `var` | `CMAKE_INSTALL_LOCALSTATEDIR` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `LOCALSTATE` | `var` | `CMAKE_INSTALL_LOCALSTATEDIR` |'
- en: '| `RUNSTATE` | `$LOCALSTATE/run` | `CMAKE_INSTALL_RUNSTATEDIR` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `RUNSTATE` | `$LOCALSTATE/run` | `CMAKE_INSTALL_RUNSTATEDIR` |'
- en: '| `DATA` | `$DATAROOT` | `CMAKE_INSTALL_DATADIR` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `DATA` | `$DATAROOT` | `CMAKE_INSTALL_DATADIR` |'
- en: '| `INFO` | `$DATAROOT/info` | `CMAKE_INSTALL_INFODIR` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `INFO` | `$DATAROOT/info` | `CMAKE_INSTALL_INFODIR` |'
- en: '| `LOCALE` | `$DATAROOT/locale` | `CMAKE_INSTALL_LOCALEDIR` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `LOCALE` | `$DATAROOT/locale` | `CMAKE_INSTALL_LOCALEDIR` |'
- en: '| `MAN` | `$DATAROOT/man` | `CMAKE_INSTALL_MANDIR` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `MAN` | `$DATAROOT/man` | `CMAKE_INSTALL_MANDIR` |'
- en: '| `DOC` | `$DATAROOT/doc` | `CMAKE_INSTALL_DOCDIR` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `DOC` | `$DATAROOT/doc` | `CMAKE_INSTALL_DOCDIR` |'
- en: 'Table 14.2: Built-in defaults per file type'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.2：每种文件类型的内置默认值
- en: 'The behavior here follows the same principle that was described in the *Utilizing
    the default destination for different platforms* subsection: if no installation
    directory variable for this `TYPE` of file is set, CMake will provide a built-in
    default path. Again, for portability, we can use the `GNUInstallDirs` module.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的行为遵循在 *利用不同平台的默认目标* 小节中描述的相同原则：如果没有为该 `TYPE` 文件设置安装目录变量，CMake 将提供一个内置的默认路径。同样，为了便于移植，我们可以使用
    `GNUInstallDirs` 模块。
- en: 'Some of the built-in guesses in the table are prefixed with installation directory
    variables:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的一些内置猜测以安装目录变量为前缀：
- en: '`$LOCALSTATE` is `CMAKE_INSTALL_LOCALSTATEDIR` or defaults to `var`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$LOCALSTATE` 是 `CMAKE_INSTALL_LOCALSTATEDIR`，或者默认为 `var`'
- en: '`$DATAROOT` is `CMAKE_INSTALL_DATAROOTDIR` or defaults to `share`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$DATAROOT` 是 `CMAKE_INSTALL_DATAROOTDIR`，或者默认为 `share`'
- en: 'As with `install(TARGETS)`, the `GNUInstallDirs` module will provide platform-specific
    installation directory variables. Let’s look at an example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `install(TARGETS)` 一样，`GNUInstallDirs` 模块将提供平台特定的安装目录变量。我们来看一个示例：
- en: '**ch14/04-install-files/CMakeLists.txt**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/04-install-files/CMakeLists.txt**'
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, CMake installs the two header-only libraries, `basic.h` and `nested/calc_extended.h`,
    into the project-specific subdirectory within the system-wide `include directory`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，CMake 将这两个仅包含头文件的库 `basic.h` 和 `nested/calc_extended.h` 安装到系统范围的 `include`
    目录下的项目特定子目录中。
- en: From the `GNUInstallDirs` source, we know that `CMAKE_INSTALL_INCLUDEDIR` is
    the same for all supported platforms. However, using it is still recommended for
    readability and consistency with more dynamic variables. For instance, `CMAKE_INSTALL_LIBDIR`
    varies by architecture and distribution – `lib`, `lib64`, or `lib/<multiarch-tuple>`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `GNUInstallDirs` 源代码中，我们知道 `CMAKE_INSTALL_INCLUDEDIR` 对所有支持的平台都是相同的。然而，仍然推荐使用它以提高可读性，并与更动态的变量保持一致。例如，`CMAKE_INSTALL_LIBDIR`
    会根据架构和发行版有所不同 —— `lib`、`lib64` 或 `lib/<multiarch-tuple>`。
- en: Since CMake 3.20, you can use the `RENAME` keyword with the `install(FILES)`
    and `install(PROGRAMS)` commands. This keyword has to be followed by a new filename
    and only works if the command installs a single file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从 CMake 3.20 开始，你可以在 `install(FILES)` 和 `install(PROGRAMS)` 命令中使用 `RENAME` 关键字。该关键字后面必须跟一个新文件名，并且只有在命令安装单个文件时才有效。
- en: 'The example in this section demonstrates the ease of installing files in the
    appropriate directory. However, there’s one issue – observe the installation output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例演示了将文件安装到合适目录的简便性。然而，有一个问题 —— 请观察安装输出：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Both files are installed in the same directory, regardless of their original
    nesting. Sometimes, this isn’t desirable. In the next section, we’ll explore how
    to handle this situation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 无论原始嵌套如何，两个文件都会被安装到同一目录中。有时，这并不理想。我们将在下一部分探讨如何处理这种情况。
- en: Working with entire directories
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理整个目录
- en: 'If adding individual files to your installation command isn’t suitable, you
    can opt for a broader approach and work with entire directories. The `install(DIRECTORY)`
    mode is designed for this, copying the specified directories verbatim to the chosen
    destination. Here’s how it looks:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将单个文件添加到安装命令中不适用，你可以选择更广泛的方法，处理整个目录。`install(DIRECTORY)`模式就是为此设计的，它将指定的目录逐字复制到选定的目标位置。它的表现如下：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Many options here are similar to those in `install(FILES)` and `install(PROGRAMS)`
    and function in the same manner. One key detail is that if the paths provided
    after the `DIRECTORY` keyword don’t end with `/`, the last directory of the path
    is appended to the destination. For example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的许多选项类似于`install(FILES)`和`install(PROGRAMS)`中的选项，并以相同的方式运行。一个关键细节是，如果在`DIRECTORY`关键字后提供的路径不以`/`结尾，路径的最后一个目录将被附加到目标位置。例如：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This command creates a directory, `/xxx/aaa`, and copies the contents of `aaa`
    to it. In contrast, the following command copies the contents of `aaa` directly
    to `/xxx`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令创建一个目录`/xxx/aaa`，并将`aaa`的内容复制到其中。相比之下，下面的命令将`aaa`的内容直接复制到`/xxx`：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`install(DIRECTORY)` also introduces other mechanisms that are not available
    for files:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`install(DIRECTORY)`还引入了其他文件不可用的机制：'
- en: Output silencing
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出静默
- en: Extended permission control
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展权限控制
- en: File/directory filtering
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件/目录过滤
- en: Let’s start with the output silencing option, `MESSAGE_NEVER`. It disables output
    diagnostics during installation. It is very useful when we have many files in
    the directories we’re installing and it would be too noisy to print them all.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从输出静默选项`MESSAGE_NEVER`开始。它在安装过程中禁用输出诊断。当我们安装的目录中包含大量文件，并且打印所有文件信息会产生太多噪声时，它非常有用。
- en: 'Regarding permissions, `install(DIRECTORY)` supports three options:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 关于权限，`install(DIRECTORY)`支持三种选项：
- en: '`USE_SOURCE_PERMISSIONS` sets the permissions on installed files that follow
    the original files. This only works when `FILE_PERMISSIONS` is not set.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USE_SOURCE_PERMISSIONS`设置已安装文件的权限，跟随原始文件的权限。仅在未设置`FILE_PERMISSIONS`时有效。'
- en: '`FILE_PERMISSIONS` allows us to specify the permissions we want to set on installed
    files and directories. The default permissions are `OWNER_WRITE`, `OWNER_READ`,
    `GROUP_READ`, and `WORLD_READ`.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILE_PERMISSIONS`允许我们指定要设置的已安装文件和目录的权限。默认权限为`OWNER_WRITE`、`OWNER_READ`、`GROUP_READ`和`WORLD_READ`。'
- en: '`DIRECTORY_PERMISSIONS` works similarly to `FILE_PERMISSIONS`, but it will
    set additional `EXECUTE` permissions for all users (this is because `EXECUTE`
    on directories in Unix-like systems denotes permission to list their contents).'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DIRECTORY_PERMISSIONS`的工作方式与`FILE_PERMISSIONS`相似，但它会为所有用户设置额外的`EXECUTE`权限（因为在类Unix系统中，目录的`EXECUTE`权限表示允许列出其内容）。'
- en: Note that CMake ignores permissions options on platforms that don’t support
    them. More nuanced permission control is achievable by adding the `PERMISSIONS`
    keyword after each filtering expression. Files or directories matched by this
    will receive the specified permissions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，CMake会忽略不支持权限选项的平台上的权限设置。通过在每个过滤表达式后添加`PERMISSIONS`关键字，可以实现更精细的权限控制。通过此方式匹配到的文件或目录将会接收指定的权限。
- en: 'Let’s talk about filters or “globbing” expressions. They control which files/directories
    from source directories are installed and follow this syntax:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈过滤器或“通配”表达式。它们控制从源目录中安装哪些文件/目录，并遵循以下语法：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There are two matching methods to choose from:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种匹配方法可以选择：
- en: With `PATTERN`, which is the simpler option, you can provide a pattern with
    the `?` placeholders (matching any character) and the `*` wildcards (matching
    any string). Only paths that end with `<pat>` will be matched.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`PATTERN`（这是一个更简单的选项），你可以提供一个包含`?`占位符（匹配任何字符）和`*`通配符（匹配任何字符串）的模式。只有以`<pat>`结尾的路径才会被匹配。
- en: The `REGEX` option is more advanced, supporting regular expressions. It allows
    the matching of any part of the path, although the `^` and `$` anchors can still
    denote the beginning and end of the path.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REGEX`选项更为高级，支持正则表达式。它允许匹配路径的任何部分，尽管`^`和`$`锚点仍然可以表示路径的开始和结束。'
- en: Optionally, the `FILES_MATCHING` keyword can be set before the first filter,
    specifying that the filters will apply to files and not directories.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，`FILES_MATCHING`关键字可以在第一个过滤器之前设置，指定过滤器将应用于文件，而非目录。
- en: 'Remember two caveats:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 记住两个警告：
- en: '`FILES_MATCHING` requires an inclusive filter. You may exclude some files,
    but no files will be copied unless you also include some. However, all directories
    will be created, regardless of filtering.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILES_MATCHING`需要一个包含性过滤器。你可以排除一些文件，但除非你也包括一些文件，否则没有文件会被复制。然而，所有目录都会被创建，不管是否进行了过滤。'
- en: All subdirectories are included by default; you can only filter out.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有子目录默认都会包含；你只能排除它们。
- en: For each filter method, you can choose to exclude matched paths with the `EXCLUDE`
    command (this only works when `FILES_MATCHING` isn’t used).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个过滤方法，你可以选择使用`EXCLUDE`命令排除匹配的路径（这仅在未使用`FILES_MATCHING`时有效）。
- en: 'Specific permissions for all matched paths can be set by adding the `PERMISSIONS`
    keyword and a list of desired permissions after any filter. Let’s explore this
    with an example where we install three directories in different ways. We have
    some static data files for runtime use:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在任何过滤器后添加`PERMISSIONS`关键字及所需权限的列表来为所有匹配的路径设置特定权限。我们通过一个例子来探讨这个，假设我们安装了三个目录，以不同的方式操作。我们有一些供运行时使用的静态数据文件：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also need some public headers located in the `src` directory among other
    unrelated files:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些位于`src`目录中的公共头文件，以及其他无关的文件：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we need two configuration files at two levels of nesting. To make
    things more interesting, we’ll make `/etc/calc/` contents accessible only to the
    file owner:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要两个配置文件，具有两个级别的嵌套。为了让事情更有趣，我们将使`/etc/calc/`的内容仅对文件所有者可访问：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To install the directory with static data files, we start our project with
    the most basic form of the `install(DIRECTORY)` command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装包含静态数据文件的目录，我们首先使用`install(DIRECTORY)`命令的最基本形式启动项目：
- en: '**ch14/05-install-directories/CMakeLists.txt (fragment)**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/05-install-directories/CMakeLists.txt（片段）**'
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This command will simply take all the contents of our `data` directory and put
    it in `${CMAKE_INSTALL_PREFIX}` and `share/calc`. Note that our source path ends
    with a `/` symbol to indicate we don’t want to copy the `data` directory itself,
    only its contents.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将简单地将我们`data`目录中的所有内容放入`${CMAKE_INSTALL_PREFIX}`和`share/calc`中。请注意，我们的源路径以`/`符号结尾，表示我们不想复制`data`目录本身，只复制其内容。
- en: 'The second case is the opposite: we don’t add the trailing `/` because the
    directory should be included. This is because we’re relying on a system-specific
    path for the `INCLUDE` file type, which is provided by `GNUInstallDirs` (note
    how the `INCLUDE` and `EXCLUDE` keywords represent unrelated concepts):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是相反的：我们不添加尾部的`/`，因为该目录应该被包含。原因是我们依赖于一个特定于系统的路径来处理`INCLUDE`文件类型，这是由`GNUInstallDirs`提供的（注意`INCLUDE`和`EXCLUDE`关键字表示不同的概念）：
- en: '**ch14/05-install-directories/CMakeLists.txt (fragment)**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/05-install-directories/CMakeLists.txt（片段）**'
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Additionally, we have excluded two paths from this operation: the entire `ignored`
    directory and all files ending with `calc_extended.h` (remember how `PATTERN`
    works).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已经从此操作中排除了两个路径：整个`ignored`目录和所有以`calc_extended.h`结尾的文件（记住`PATTERN`是如何工作的）。
- en: 'The third case installs some default configuration files and sets their permissions:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种情况安装一些默认的配置文件并设置它们的权限：
- en: '**ch14/05-install-directories/CMakeLists.txt (fragment)**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/05-install-directories/CMakeLists.txt（片段）**'
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We avoid appending `etc` from the source path to the `SYSCONF` path (as `GNUInstallDirs`
    has already provided this) to prevent duplication. We set two permission rules:
    subdirectories are editable and listable only by the owner, and files ending with
    `nested.conf` are editable only by the owner.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免将`etc`从源路径附加到`SYSCONF`路径（因为`GNUInstallDirs`已经提供了这一点），以防止重复。我们设置了两个权限规则：子目录仅对所有者可编辑和列出，而以`nested.conf`结尾的文件仅对所有者可编辑。
- en: Installing directories covers various use cases, but for other advanced scenarios
    (like post-install configuration), external tools may be required. How do we integrate
    them?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 安装目录涵盖了各种使用案例，但对于其他高级场景（如安装后配置），可能需要外部工具。我们如何将它们集成？
- en: Invoking scripts during installation
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在安装过程中调用脚本
- en: 'If you have ever installed a shared library on a Unix-like system, you might
    recall needing to instruct the dynamic linker to scan trusted directories and
    build its cache using `ldconfig` (refer to the *Further reading* section for references).
    To facilitate fully automatic installations, CMake provides the `install(SCRIPT)`
    and `install(CODE)` modes. Here is the complete syntax:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在类Unix系统上安装过共享库，你可能记得需要指示动态链接器扫描受信目录并使用`ldconfig`构建缓存（参考*进一步阅读*部分获取相关资料）。为了便于完全自动化的安装，CMake提供了`install(SCRIPT)`和`install(CODE)`模式。以下是完整的语法：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**ch14/06-install-code/src/CMakeLists.txt**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/06-install-code/src/CMakeLists.txt**'
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Change the artifact type from `ARCHIVE` to `LIBRARY` in the installation script
    and then add logic to run `ldconfig` afterward:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装脚本中将工件类型从`ARCHIVE`更改为`LIBRARY`，然后添加逻辑以便在之后运行`ldconfig`：
- en: '**ch14/06-install-code/CMakeLists.txt (fragment)**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/06-install-code/CMakeLists.txt（片段）**'
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `if()` condition ensures the command is appropriate for the operating system
    (`ldconfig` should not be executed on Windows or macOS). The provided code must
    be syntactically valid in CMake (errors will only surface during installation).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`if()`条件确保命令适用于操作系统（`ldconfig`不应在Windows或macOS上执行）。提供的代码在CMake中必须是语法有效的（错误只会在安装时显示）。'
- en: 'After running the installation command, confirm its success by printing the
    cached libraries:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 运行安装命令后，通过打印缓存的库来确认安装成功：
- en: '[PRE39]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Both `SCRIPT` and `CODE` modes support generator expressions, adding versatility
    to this command. It can be used for various purposes: printing user messages,
    verifying successful installations, extensive configuration, file signing, and
    more.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`SCRIPT`和`CODE`模式都支持生成器表达式，增加了此命令的多功能性。它可以用于多种目的：打印用户消息、验证安装成功、进行广泛的配置、文件签名等。'
- en: Next, let’s delve into the aspect of managing runtime dependencies in CMake
    installations, one of the newest features of CMake.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们深入探讨在CMake安装中管理运行时依赖项的方面，这是CMake的最新功能之一。
- en: Installing runtime dependencies
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装运行时依赖项
- en: We’ve covered almost all kinds of installable artifacts and their respective
    commands. The final subject to discuss is runtime dependencies. Executables and
    shared libraries often depend on other libraries that must be present in the system
    and are dynamically loaded at program initialization. Since version 3.21, CMake
    can build a list of these required libraries for each target and capture their
    location at build time by referencing the appropriate sections of the binary file.
    This list can then be used to install these runtime artifacts in the system for
    future use.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了几乎所有可安装的工件及其相应的命令。接下来要讨论的主题是运行时依赖项。可执行文件和共享库通常依赖于其他库，这些库必须存在于系统中并在程序初始化时动态加载。从版本3.21开始，CMake可以为每个目标构建所需库的列表，并通过引用二进制文件的适当部分在构建时捕获其位置。然后可以使用该列表将这些运行时工件安装到系统中以备将来使用。
- en: 'For a target defined in the project, this can be achieved in two steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在项目中定义的目标，可以通过两步实现：
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Alternatively, this can be accomplished with a single command with the same
    effect:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过一个命令以相同的效果完成：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If a target is imported, rather than defined in the project, its runtime dependencies
    can be installed as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标是导入的，而不是在项目中定义的，那么它的运行时依赖项可以通过以下方式安装：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If this feature sounds beneficial for your project, I recommend checking the
    official documentation of the `install()` command to learn more.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个功能对你的项目有益，建议查阅`install()`命令的官方文档了解更多信息。
- en: Now that we understand all the different ways we can install files on the system,
    let’s explore how to turn them into a natively available package for other CMake
    projects.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了在系统上安装文件的各种方式，接下来让我们探索如何将它们转换为其他CMake项目可用的本地包。
- en: Creating reusable packages
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重用的包
- en: 'We’ve extensively used `find_package()` in previous chapters and observed its
    convenience and simplicity. To make our project accessible through this command,
    we need to complete a few steps so CMake can treat our project as a coherent package:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们广泛使用了`find_package()`并观察到了它的便捷性和简单性。为了通过此命令访问我们的项目，我们需要完成几个步骤，以便CMake可以将我们的项目视为一个一致的包：
- en: Make our targets relocatable.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使我们的目标可迁移。
- en: Install the *target export file* to a standard location.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*目标导出文件*安装到标准位置。
- en: Create a *config file for the package*.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为包创建*配置文件*。
- en: Generate a *version file* for the package.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为包生成*版本文件*。
- en: 'Let’s start from the beginning: why do targets need to be relocatable and how
    can we do this?'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始：为什么目标需要是可重定位的？我们该如何做到这一点？
- en: Understanding the issues with relocatable targets
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解可重定位目标的问题
- en: 'Installation solves many problems but also introduces some complexity. The
    `CMAKE_INSTALL_PREFIX` is platform specific and can be set by the user at the
    installation stage with the `--install-prefix` command-line argument. The challenge
    is that target export files are generated before installation, during the build
    stage, when the final destination of the installed artifacts is unknown. Consider
    this code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 安装解决了许多问题，但也引入了一些复杂性。`CMAKE_INSTALL_PREFIX`是平台特定的，用户可以在安装阶段通过`--install-prefix`命令行参数设置它。挑战在于，目标导出文件是在安装之前生成的，即在构建阶段，当安装后文件的最终位置尚未确定时。考虑以下代码：
- en: '**ch14/03-install-targets-legacy/src/CMakeLists.txt**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/03-install-targets-legacy/src/CMakeLists.txt**'
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, we specifically add the `include` `directory` to the `include`
    `directories` of `calc`. Since this is a relative path, CMake’s exported target
    generation implicitly prepends this path with the contents of the `CMAKE_CURRENT_SOURCE_DIR`
    variable, pointing to the directory where this listfile is located.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们特地将`include` `directory` 添加到`calc`的`include` `directories`中。由于这是一个相对路径，CMake导出的目标生成过程会自动将该路径与`CMAKE_CURRENT_SOURCE_DIR`变量的内容结合，指向包含此列表文件的目录。
- en: '[PRE44]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'CMake addresses this *carriage-before-the-horse* problem with generator expressions
    that are replaced with their argument or an empty string, depending on the context:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: CMake通过生成器表达式解决了这个*本末倒置*的问题，这些表达式会根据上下文被替换为它们的参数或空字符串：
- en: '`$<BUILD_INTERFACE:...>`: This evaluates to the ‘`...`'' argument for regular
    builds but excludes it for installation.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<BUILD_INTERFACE:...>`：这会在常规构建中评估为‘`...`’参数，但在安装时排除。'
- en: '`$<INSTALL_INTERFACE:...>`: This evaluates to the ‘`...`'' argument for installation
    but excludes it for regular builds.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<INSTALL_INTERFACE:...>`：这会在安装时评估为‘`...`’参数，但在常规构建时排除。'
- en: '`$<BUILD_LOCAL_INTERFACE:...>`: This evaluates to the ‘`...`'' argument when
    used by another target in the same buildsystem (added in CMake 3.26).'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<BUILD_LOCAL_INTERFACE:...>`：当另一个目标在相同的构建系统中使用时，它会评估为‘`...`’参数（此功能在CMake
    3.26中新增）。'
- en: 'These expressions allow the deferment of the decision of which path to use
    to the later stages of the process: building and installation. Here’s how to use
    them in practice:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表达式允许将选择使用哪条路径的决定推迟到后续阶段：构建和安装。以下是如何在实践中使用它们：
- en: '**ch14/07-install-export-legacy/src/CMakeLists.txt (fragment)**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/07-install-export-legacy/src/CMakeLists.txt（片段）**'
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In `target_include_directories()`, we focus on the last two arguments. The used
    generator expressions are mutually exclusive, meaning only one of the arguments
    will be used in the final step, and the other will be erased.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在`target_include_directories()`中，我们关注最后两个参数。使用的生成器表达式是互斥的，这意味着最终步骤中只有一个参数会被使用，另一个会被删除。
- en: 'For regular builds, the `INTERFACE_INCLUDE_DIRECTORIES` property of the `calc`
    target will be expanded, using the first argument:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规构建，`calc`目标的`INTERFACE_INCLUDE_DIRECTORIES`属性将会使用第一个参数进行扩展：
- en: '[PRE46]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'On the other hand, when installing, the value will expand with the second argument:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在安装时，值将使用第二个参数进行扩展：
- en: '[PRE47]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Quotes are not present in the final value; they’re added here to express empty
    text values for clarity.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 引号在最终值中不存在；它们在此处用于表示空文本值，以便于理解。
- en: 'Regarding `CMAKE_INSTALL_PREFIX`: it should not be used as a component in paths
    specified in targets. It would be evaluated during the build stage, making the
    path absolute and potentially different from the one provided during installation
    (if the `--install-prefix` option is used). Instead, use the `$<INSTALL_PREFIX>`
    generator expression:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`CMAKE_INSTALL_PREFIX`：它不应作为路径中指定目标的组件使用。它将在构建阶段进行评估，使得路径变为绝对路径，且可能与安装时提供的路径不同（如果使用了`--install-prefix`选项）。相反，应该使用`$<INSTALL_PREFIX>`生成器表达式：
- en: '[PRE48]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Or, even better, you can use relative paths, which will be prepended with the
    correct installation prefix:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更好的是，你可以使用相对路径，它们会被自动加上正确的安装前缀：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: For more examples and information, please consult the official documentation
    (a link to this can be found in the *Further reading* section).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 若需更多示例和信息，请参考官方文档（链接可以在*进一步阅读*部分找到）。
- en: Now that our targets are *installation compatible*, we can safely generate and
    install their target export files.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的目标是*兼容安装*的，我们可以安全地生成并安装它们的目标导出文件。
- en: Installing target export files
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装目标导出文件
- en: 'We previously touched on target export files in the *Exporting without installation*
    section. The process for installing target export files is quite similar, and
    so is the command syntax for creating them:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在 *不进行安装的导出* 部分提到过目标导出文件。安装目标导出文件的过程非常相似，创建它们的命令语法也是如此：
- en: '[PRE50]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It’s a blend of the plain `export(EXPORT)` and other `install()` commands (its
    options function similarly). Remember, it will create and install a target export
    file for a named export that must be defined with the `install(TARGETS)` command.
    The key difference here is that the generated export file will contain target
    paths evaluated in the `INSTALL_INTERFACE` generator expression, unlike `export(EXPORT)`,
    which uses `BUILD_INTERFACE`. This means we need to be careful about our include
    files and other relatively referenced files.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 它是 `export(EXPORT)` 和其他 `install()` 命令的结合（其选项的功能类似）。请记住，它将创建并安装一个目标导出文件，用于通过
    `install(TARGETS)` 命令定义的命名导出。这里的关键区别在于，生成的导出文件将包含在 `INSTALL_INTERFACE` 生成器表达式中评估的目标路径，而不像
    `export(EXPORT)` 使用 `BUILD_INTERFACE`。这意味着我们需要小心处理包含文件和其他相对引用的文件。
- en: 'Again, with CMake 3.23 or newer this won’t be a problem if `FILE_SET HEADERS`
    is used correctly. Let’s see how we can generate and install the export file for
    the targets from the `ch14/02-install-export` example. To do this, we must call
    `install(EXPORT)` after the `install(TARGETS)` command:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，对于 CMake 3.23 或更高版本，如果正确使用 `FILE_SET HEADERS`，这将不再是问题。让我们看看如何为 `ch14/02-install-export`
    示例中的目标生成并安装导出文件。为此，我们必须在 `install(TARGETS)` 命令之后调用 `install(EXPORT)`：
- en: '**ch14/07-install-export/src/CMakeLists.txt**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/07-install-export/src/CMakeLists.txt**'
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note the reference to the `CalcTargets` export name in `install(EXPORT)`. Running
    `cmake --install` in the build tree will result in the export file being generated
    in the specified destination:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `install(EXPORT)` 中引用 `CalcTargets` 导出名。在构建树中运行 `cmake --install` 将导致导出文件在指定的目标位置生成：
- en: '[PRE52]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If you need to override the default target export filename (`<export name>.cmake`),
    add the `FILE new-name.cmake` argument to change it (the filename must end with
    `.cmake`).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要覆盖默认的目标导出文件名（`<export name>.cmake`），可以通过添加 `FILE new-name.cmake` 参数来更改它（文件名必须以
    `.cmake` 结尾）。
- en: Don’t confuse this – the *target export file* isn’t a *config file*, so you
    can’t use `find_package()` to consume installed targets just yet. However, it’s
    possible to `include()` export files directly if necessary. So, how do we define
    a package that can be consumed by other projects? Let’s find out!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆这一点——*目标导出文件* 不是 *配置文件*，因此你不能直接使用 `find_package()` 来消费已安装的目标。不过，如果需要，也可以直接
    `include()` 导出文件。那么，我们如何定义一个可以被其他项目消费的包呢？让我们来看看！
- en: Writing basic config files
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写基本配置文件
- en: A complete package definition consists of the target export files, the package’s
    *config file*, and the package’s *version file*. However, technically, all that’s
    needed for `find_package()` to work is a config file. It acts as a package definition,
    responsible for providing any package functions and macros, checking requirements,
    finding dependencies, and including target export files.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的包定义包括目标导出文件、包的*配置文件*和包的*版本文件*。然而，从技术上讲，`find_package()` 要正常工作只需要一个配置文件。它充当包定义，负责提供任何包功能和宏，检查需求，查找依赖项，并包含目标导出文件。
- en: 'As we mentioned earlier, users can install your package anywhere on their system
    by using:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，用户可以通过以下方式将包安装到系统的任何位置：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This prefix determines where the installed files will be copied. To support
    this, you must ensure the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个前缀决定了已安装文件的复制位置。为此，你必须确保以下几点：
- en: The paths on the target properties are relocatable (as described in the *Understanding
    the issues with relocatable targets* section).
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标属性中的路径是可重新定位的（如 *理解可重新定位目标的问题* 部分所述）。
- en: The paths that are used in your config file are relative to it.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件中使用的路径是相对于它的。
- en: 'To use such packages that have been installed in non-default locations, the
    consuming projects need to provide `<installation path>` through the `CMAKE_PREFIX_PATH`
    variable during the configuration stage:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用已安装在非默认位置的包，消费项目在配置阶段需要通过 `CMAKE_PREFIX_PATH` 变量提供 `<installation path>`：
- en: '[PRE54]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `find_package()` command will scan the list of paths that are outlined
    in the documentation (see the *Further reading* section) in a platform-specific
    manner. One pattern checked on Windows and Unix-like systems is:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_package()` 命令将以平台特定的方式扫描文档中列出的路径（请参见*进一步阅读*部分）。在 Windows 和类 Unix 系统上检查的一个模式是：'
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This indicates that installing the config file in a path such as `lib/calc/cmake`
    should work. Additionally, CMake requires that config files be named `<PackageName>-config.cmake`
    or `<PackageName>Config.cmake` to be found.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示将配置文件安装到像 `lib/calc/cmake` 这样的路径应该是可行的。此外，CMake 要求配置文件必须命名为 `<PackageName>-config.cmake`
    或 `<PackageName>Config.cmake` 才能被找到。
- en: 'Let’s add the installation of the config file to the `06-install-export` example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将配置文件的安装添加到 `06-install-export` 示例中：
- en: '**ch14/09-config-file/CMakeLists.txt (fragment)**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/09-config-file/CMakeLists.txt（片段）**'
- en: '[PRE56]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This command installs `CalcConfig.cmake` from the same source directory (`CMAKE_INSTALL_LIBDIR`
    will be evaluated to the correct `lib` path for the platform).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令从相同的源目录安装 `CalcConfig.cmake`（`CMAKE_INSTALL_LIBDIR` 会评估为平台正确的 `lib` 路径）。
- en: 'The simplest config file consists of a single line including the target export
    file:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的配置文件由包含目标导出文件的单行组成：
- en: '**ch14/09-config-file/CalcConfig.cmake**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/09-config-file/CalcConfig.cmake**'
- en: '[PRE57]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`CMAKE_CURRENT_LIST_DIR` refers to the directory where the config file resides.
    Since `CalcConfig.cmake` and `CalcTargets.cmake` are installed in the same directory
    in our example (as set by `install(EXPORT)`), the target export file will be included
    correctly.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMAKE_CURRENT_LIST_DIR` 指的是配置文件所在的目录。在我们的示例中，`CalcConfig.cmake` 和 `CalcTargets.cmake`
    安装在同一个目录下（由 `install(EXPORT)` 设置），因此目标导出文件将被正确包含。'
- en: 'To verify our package’s usability, we’ll create a simple project with one listfile:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们包的可用性，我们将创建一个包含一个列表文件的简单项目：
- en: '**ch14/10-find-package/CMakeLists.txt**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/10-find-package/CMakeLists.txt**'
- en: '[PRE58]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To test this, build and install the `09-config-file` example to one directory,
    and then build `10-find-package` while referencing it with the `DCMAKE_PREFIX_PATH`
    argument:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个，将 `09-config-file` 示例构建并安装到一个目录中，然后构建 `10-find-package` 并通过 `DCMAKE_PREFIX_PATH`
    参数引用它：
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This will produce the following output (all the `<*_tree-of_>` placeholders
    will be replaced with real paths):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出（所有的 `<*_tree-of_>` 占位符将被实际路径替换）：
- en: '[PRE60]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This output indicates that the `CalcTargets.cmake` file was found and included
    correctly, and the path to the `include directory` follows the chosen prefix.
    This solution is suitable for basic packaging cases. Now, let’s learn how to handle
    more advanced scenarios.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出表示 `CalcTargets.cmake` 文件已被找到并正确包含，`include directory` 的路径遵循所选择的前缀。这种解决方案适用于基本的打包场景。现在，让我们学习如何处理更高级的场景。
- en: Creating advanced config files
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建高级配置文件
- en: 'If you need to manage more than a single *target export file*, including a
    few macros in your *config file* can be useful. The `CMakePackageConfigHelpers`
    utility module provides access to the `configure_package_config_file()` command.
    To use it, supply a template file that will be interpolated with CMake variables
    to generate a *config file* with two embedded macro definitions:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要管理多个*目标导出文件*，在你的*配置文件*中包含一些宏可能会很有用。`CMakePackageConfigHelpers` 工具模块提供了访问
    `configure_package_config_file()` 命令的功能。使用它时，提供一个模板文件，CMake 变量将插入其中，以生成包含两个嵌入式宏定义的*配置文件*：
- en: '`set_and_check(<variable> <path>)`: This works like `set()`, but it checks
    that `<path>` actually exists and fails with `FATAL_ERROR` otherwise. This is
    recommended for use in your config files to detect incorrect paths early.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_and_check(<variable> <path>)`：这与 `set()` 类似，但它会检查 `<path>` 是否实际存在，否则会因
    `FATAL_ERROR` 失败。建议在配置文件中使用此方法，以便及早发现路径错误。'
- en: '`check_required_components(<PackageName>)`: This is added to the end of the
    `config`file. It verifies whether all components required by the user in `find_package(<package>
    REQUIRED <component>)` have been found.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_required_components(<PackageName>)`：这是添加到 `config` 文件末尾的内容。它检查在 `find_package(<package>
    REQUIRED <component>)` 中，用户所需的所有组件是否已找到。'
- en: 'Paths for complex directory trees can be prepared for installation during *config
    file* generation. Here’s the command signature:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在*配置文件*生成过程中，可以为复杂的目录树准备好安装路径。命令签名如下：
- en: '[PRE61]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `<template>` file will be interpolated with variables and stored in the
    `<output>` path. The `INSTALL_DESTINATION` path is used to transform the paths
    stored in the `PATH_VARS` to be relative to the install destination. The `INSTALL_PREFIX`
    can be provided as a base path to indicate that `INSTALL_DESTINATION` is relative
    to it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`<template>`文件将与变量进行插值并存储在`<output>`路径中。`INSTALL_DESTINATION`路径用于将存储在`PATH_VARS`中的路径转换为相对于安装目标的路径。`INSTALL_PREFIX`可以作为基本路径提供，表示`INSTALL_DESTINATION`相对于此路径。'
- en: 'The `NO_SET_AND_CHECK_MACRO` and `NO_CHECK_REQUIRED_COMPONENTS_MACRO` options
    tell CMake not to add these macro definitions to the generated *config file*.
    Let’s see this generation in practice, extending the `07-install-export` example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`NO_SET_AND_CHECK_MACRO`和`NO_CHECK_REQUIRED_COMPONENTS_MACRO`选项告诉CMake不要将这些宏定义添加到生成的*配置文件*中。让我们在实际中看到这种生成方式，扩展`07-install-export`示例：'
- en: '**ch14/11-advanced-config/CMakeLists.txt (fragment)**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/11-advanced-config/CMakeLists.txt（片段）**'
- en: '[PRE62]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the preceding code, we:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们：
- en: Use `include()` to include the utility module with helpers.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`include()`来包含带有帮助器的实用模块。
- en: Use `set()` to set a variable that will be used to make a relocatable path.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`set()`来设置一个变量，该变量将用于生成可重定位的路径。
- en: Generate the `CalcConfig.cmake` config file for the build tree using the `CalcConfig.cmake.in`
    template, and provide `LIB_INSTALL_DIR` as a variable name to be computed as relative
    to `INSTALL_DESTINATION` or `${CMAKE_INSTALL_LIBDIR}/calc/cmake`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CalcConfig.cmake.in`模板为构建树生成`CalcConfig.cmake`配置文件，并提供`LIB_INSTALL_DIR`作为变量名称，计算为相对于`INSTALL_DESTINATION`或`${CMAKE_INSTALL_LIBDIR}/calc/cmake`。
- en: Pass the config file that was generated for the build tree to `install(FILE)`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将为构建树生成的配置文件传递给`install(FILE)`。
- en: Note that the path in `DESTINATION` in `install(FILES)` and the path in `INSTALL_DESTINATION`
    in `configure_package_config_file()` are equal, which ensures correct relative
    path computation inside of the configuration file.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`install(FILES)`中的`DESTINATION`路径与`configure_package_config_file()`中的`INSTALL_DESTINATION`路径相等，这确保了配置文件内正确的相对路径计算。
- en: 'Finally, we’ll need a `config` file template (their names are usually suffixed
    with `.in`):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个`config`文件模板（它们的名称通常以`.in`结尾）：
- en: '**ch14/11-advanced-config/CalcConfig.cmake.in**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/11-advanced-config/CalcConfig.cmake.in**'
- en: '[PRE63]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This template begins with a `@PACKAGE_INIT@` placeholder. The generator will
    fill it with the definitions of the `set_and_check` and `check_required_components`
    macros.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板以`@PACKAGE_INIT@`占位符开始。生成器将用`set_and_check`和`check_required_components`宏的定义填充它。
- en: The next line sets `CALC_LIB_DIR` to the path passed in the `@PACKAGE_LIB_INSTALL_DIR@`
    placeholder. CMake will fill it with `$LIB_INSTALL_DIR`, provided in the listfile,
    but calculated relative to the installation path. Subsequently, that path is used
    in the `include()` command to include the *target export file*. Finally, `check_required_components()`
    verifies whether all of the components required by the project using this package
    have been found. This command is recommended, even if the package doesn’t have
    any components to ensure the users are using only supported requirements. Otherwise,
    they may incorrectly think they’ve successfully added components (perhaps only
    present in newer versions of the package).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行将`CALC_LIB_DIR`设置为传递给`@PACKAGE_LIB_INSTALL_DIR@`占位符的路径。CMake将使用列表文件中提供的`$LIB_INSTALL_DIR`填充它，但路径是相对于安装路径计算的。随后，该路径将用于`include()`命令来包含*目标导出文件*。最后，`check_required_components()`验证是否已找到使用此包的项目所需的所有组件。即使包没有任何组件，推荐使用此命令，以确保用户仅使用受支持的依赖项。否则，他们可能会错误地认为他们已成功添加了组件（这些组件可能仅存在于包的更新版本中）。
- en: 'The `CalcConfig.cmake` *config file*, when generated this way, looks like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式生成的`CalcConfig.cmake`*配置文件*如下所示：
- en: '[PRE64]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The following diagram, which shows how the various package files are related
    to each other, puts this into perspective:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了各种包文件之间的关系，帮助更好地理解：
- en: '![Figure 11.1 – The file structure for advanced packages ](img/B19844_14_01.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 高级包的文件结构](img/B19844_14_01.png)'
- en: 'Figure 14.1: The file structure for advanced packages'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：高级包的文件结构
- en: All the required sub-dependencies of a package must also be found in the package
    config file. This can be done by calling the `find_dependency()` macro from the
    `CMakeFindDependencyMacro` helper. We learned how to use it in *Chapter 9*, *Managing
    Dependencies in CMake*.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 包的所有必需的子依赖项也必须在包的配置文件中找到。这可以通过调用`CMakeFindDependencyMacro`帮助器中的`find_dependency()`宏来完成。我们在*第9章*《CMake中的依赖管理》中学习了如何使用它。
- en: Definitions for any macros or functions exposed to the consuming project should
    be in a separate file included from the package’s *config file*. Interestingly,
    `CMakePackageConfigHelpers` also helps generate package version files. Let’s explore
    this next.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 任何暴露给消费项目的宏或函数定义应当放在一个单独的文件中，该文件通过包的*配置文件*包含。有趣的是，`CMakePackageConfigHelpers`也有助于生成包的版本文件。接下来我们将探讨这一点。
- en: Generating package version files
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成包的版本文件
- en: 'As your package evolves, gaining new features and phasing out older ones, it’s
    vital to track these changes in a changelog accessible to developers using your
    package. When a specific feature is required, a developer that is using your package
    can specify the minimum version that supports it in `find_package()`, like so:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的包的发展，获得新功能并淘汰旧功能，跟踪这些变化并提供可供开发者使用的变更日志是至关重要的。当开发者需要某个特定功能时，使用你的包的开发者可以在`find_package()`中指定支持该功能的最低版本，如下所示：
- en: '[PRE65]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: CMake will then search for `Calc`'s config file and check whether a *version
    file* named `<config-file>-version.cmake` or `<config-file>Version.cmake` is present
    in the same directory (e.g., `CalcConfigVersion.cmake`). This file contains version
    information and specifies compatibility with other versions. For instance, even
    if you don’t have the exact version 1.2.3 installed, you might have 1.3.5, which
    is marked as compatible with older versions. CMake will accept this package, knowing
    it’s backward compatible.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: CMake将搜索`Calc`的配置文件，并检查是否在同一目录下存在名为`<config-file>-version.cmake`或`<config-file>Version.cmake`的*版本文件*（例如，`CalcConfigVersion.cmake`）。该文件包含版本信息，并指定与其他版本的兼容性。例如，即使你没有安装确切的版本1.2.3，可能会有1.3.5版本，而它被标记为与旧版本兼容。CMake将接受该包，因为它向后兼容。
- en: 'You can use the `CMakePackageConfigHelpers` utility module to generate package
    *version files* by calling `write_basic_package_version_file()`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`CMakePackageConfigHelpers`工具模块，通过调用`write_basic_package_version_file()`来生成包的*版本文件*：
- en: '[PRE66]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: First, provide the `<filename>` for the artifact; ensure it follows the naming
    rules previously discussed. Optionally, you can pass an explicit `VERSION` (in
    major.minor.patch format). If not provided, the version specified in the `project()`
    command is used (an error will occur if the project doesn’t specify one).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，提供生成物件的`<filename>`；确保它遵循之前讨论的命名规则。你可以选择性地传入显式的`VERSION`（采用major.minor.patch格式）。如果未提供，`project()`命令中指定的版本将被使用（如果项目没有指定版本，将会出现错误）。
- en: 'The `COMPATIBILITY` keyword indicates:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`COMPATIBILITY`关键字表示：'
- en: '`ExactVersion` must match all three components of the version and doesn’t support
    ranged versions: (e.g., `find_package(<package> 1.2.8...1.3.4)`).'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExactVersion`必须匹配版本的所有三个组件，并且不支持版本范围：（例如，`find_package(<package> 1.2.8...1.3.4)`）。'
- en: '`SameMinorVersion` matches if the first two components are the same (ignores
    `patch`).'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SameMinorVersion`在前两个组件相同的情况下匹配（忽略`patch`）。'
- en: '`SameMajorVersion` matches if the first component is the same (ignores `minor`
    and `patch`).'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SameMajorVersion`在第一个组件相同的情况下匹配（忽略`minor`和`patch`）。'
- en: '`AnyNewerVersion`, contrary to its name, matches any older version (e.g., version
    1.4.2 is compatible with `find_package(<package> 1.2.8)`).'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnyNewerVersion`与其名称相反，它匹配任何旧版本（例如，版本1.4.2与`find_package(<package> 1.2.8)`兼容）。'
- en: For architecture-dependent packages, an exact architecture match is required.
    However, for architecture-agnostic packages (like header-only libraries or macro
    packages), you can specify the `ARCH_INDEPENDENT` keyword to skip this check.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 对于依赖架构的包，需要精确的架构匹配。然而，对于与架构无关的包（如仅包含头文件的库或宏包），你可以指定`ARCH_INDEPENDENT`关键字来跳过此检查。
- en: 'The following code shows a practical example of how to provide the *version
    file* for the project that we started in the `07-install-export`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何为我们在`07-install-export`中开始的项目提供*版本文件*的实际示例：
- en: '**ch14/12-version-file/CMakeLists.txt (fragment)**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/12-version-file/CMakeLists.txt（片段）**'
- en: '[PRE67]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: For convenience, we configure the version of the package at the top of the file,
    in the `project()` command, switching from the short `project(<name> <languages>)`
    syntax to an explicit, full syntax by adding the `LANGUAGE` keyword.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们在文件的顶部配置了包的版本，在`project()`命令中，将简短的`project(<name> <languages>)`语法切换为显式的完整语法，通过添加`LANGUAGE`关键字。
- en: After including the helper module, we generate the version file and install
    it alongside `CalcConfig.cmake`. By skipping the `VERSION` keyword, we use the
    `PROJECT_VERSION` variable. The package is marked as fully backward compatible
    with `COMPATIBILITY` `AnyNewerVersion`. This installs the package *version file*
    to the same destination as `CalcConfig.cmake`. That’s it – our package is fully
    configured.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含助手模块之后，我们生成版本文件并将其与 `CalcConfig.cmake` 一起安装。通过跳过 `VERSION` 关键字，我们使用 `PROJECT_VERSION`
    变量。该包标记为完全向后兼容，使用 `COMPATIBILITY` `AnyNewerVersion`。这会将 *版本文件* 安装到与 `CalcConfig.cmake`
    相同的目标位置。就这样——我们的包已经完全配置好了。
- en: With this, we concluded the subject of package creation. We now know how to
    deal with relocation and why it is important, how to install *target export files*,
    and how to write *config* and *version files*.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此方法，我们完成了包创建的主题。现在我们知道如何处理重定位及其重要性，如何安装 *目标导出文件*，以及如何编写 *配置文件* 和 *版本文件*。
- en: In the next section, we’ll explore components and their use with packages.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探索组件及其在包中的使用。
- en: Defining components
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义组件
- en: 'We’ll begin by addressing potential confusion surrounding the term **component**.
    Consider the full signature for `find_package()`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论关于术语 **组件** 的潜在混淆。请看 `find_package()` 的完整签名：
- en: '[PRE68]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It’s important not to confuse the components mentioned here with the `COMPONENT`
    keyword that’s used in the `install()` command. Despite sharing the same name,
    they are distinct concepts and must be understood separately. We’ll explore this
    further in the following subsections.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要将这里提到的组件与 `install()` 命令中使用的 `COMPONENT` 关键字混淆。尽管它们使用相同的名称，但它们是不同的概念，必须分别理解。我们将在接下来的子章节中进一步探讨这一点。
- en: How to use components in find_package()
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在 `find_package()` 中使用组件
- en: When calling `find_package()` with a list of `COMPONENTS` or `OPTIONAL_COMPONENTS`,
    we indicate to CMake that we are only interested in packages that provide these
    components. However, it’s crucial to understand that verifying this requirement
    is the responsibility of the package. If the package vendor doesn’t implement
    the necessary checks in the config file, as mentioned in the *Creating advanced
    config files* section, the process will not proceed as expected.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `COMPONENTS` 或 `OPTIONAL_COMPONENTS` 列表调用 `find_package()` 时，我们向 CMake 指示我们只关心提供这些组件的包。然而，必须理解的是，验证这一需求是包本身的责任。如果包的供应商没有在配置文件中实现必要的检查，如
    *创建高级配置文件* 一节所述，过程将不会按预期进行。
- en: Requested components are passed to the config file via the `<package>_FIND_COMPONENTS`
    variable (both optional and non-optional). For every non-optional component, a
    `<package>_FIND_REQUIRED_<component>` variable is set. Package authors could write
    a macro to scan this list and verify the provision of all required components,
    but this is unnecessary. The `check_required_components()` function serves this
    purpose. The *config file* should set the `<package>_<component>_FOUND` variable
    when a necessary component is found. A macro at the file’s end will then verify
    whether all required variables are set.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 请求的组件通过 `<package>_FIND_COMPONENTS` 变量（包括可选和非可选组件）传递给配置文件。对于每个非可选组件，都会设置一个 `<package>_FIND_REQUIRED_<component>`
    变量。包的作者可以编写宏来扫描此列表并验证是否提供了所有必需的组件，但这不是必需的。`check_required_components()` 函数可以完成这个任务。*配置文件*
    应该在找到必需的组件时设置 `<package>_<component>_FOUND` 变量。文件末尾的一个宏将验证是否设置了所有必需的变量。
- en: How to use components in the install() command
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在 `install()` 命令中使用组件
- en: 'Not all produced artifacts need installation in every scenario. For instance,
    a project might install static libraries and public headers for development, but
    by default, it may only need to install a shared library for runtime. To enable
    this dual behavior, artifacts can be grouped under a common name using the `COMPONENT`
    keyword, available in all `install()` commands. Users interested in limiting installation
    to specific components can do so by executing the following case-sensitive command:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有生成的产物在每种情况下都需要安装。例如，一个项目可能为开发安装静态库和公共头文件，但默认情况下，它可能只需要安装共享库以供运行时使用。为了启用这种双重行为，产物可以通过
    `COMPONENT` 关键字在所有 `install()` 命令中进行分组。希望限制安装到特定组件的用户可以通过执行以下区分大小写的命令来实现：
- en: '[PRE69]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Assigning the `COMPONENT` keyword to an artifact doesn’t automatically exclude
    it from the default installation. To achieve this exclusion, the `EXCLUDE_FROM_ALL`
    keyword must be added.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `COMPONENT` 关键字分配给一个产物并不会自动将其从默认安装中排除。要实现这一排除，必须添加 `EXCLUDE_FROM_ALL` 关键字。
- en: 'Let’s explore this concept in a code example:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个代码示例来探讨这个概念：
- en: '**ch14/13-components/CMakeLists.txt (fragment)**'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/13-components/CMakeLists.txt（片段）**'
- en: '[PRE70]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The preceding `install` commands define the following components:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`install`命令定义了以下组件：
- en: '`lib`: This contains the static library and target export files. It’s installed
    by default.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib`：包含静态库和目标导出文件，默认情况下会安装。'
- en: '`headers`: This contains C++ header files. Also installed by default.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers`：包含C++头文件，默认情况下也会安装。'
- en: '`extra`: This executes a piece of code to print a message. Not installed by
    default.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extra`：执行一段代码以打印消息，默认情况下不安装。'
- en: 'Let’s reiterate:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再强调一遍：
- en: '`cmake --install` without the `--component` argument will install both the
    `lib` and `headers` components.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有`--component`参数的`cmake --install`将安装`lib`和`headers`组件。
- en: '`cmake --install --component headers` will only install public headers.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake --install --component headers`将只安装公共头文件。'
- en: '`cmake --install --component extra` will print a message that’s inaccessible
    otherwise (the `EXCLUDE_FROM_ALL` keyword prevents that).'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake --install --component extra`将打印一个通常无法访问的消息（`EXCLUDE_FROM_ALL`关键字会阻止此行为）。'
- en: If the `COMPONENT` keyword isn’t specified for an installed artifact, it defaults
    to `Unspecified`, as defined by the `CMAKE_INSTALL_DEFAULT_COMPONENT_NAME` variable.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装的工件没有指定`COMPONENT`关键字，则默认为`Unspecified`，这一点由`CMAKE_INSTALL_DEFAULT_COMPONENT_NAME`变量定义。
- en: Since there’s no way to list all available components from the cmake command
    line, thoroughly documenting your package’s components can be extremely helpful
    for users. An `INSTALL` “`READM`” file is a good place for this information.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 由于无法通过cmake命令行列出所有可用组件，彻底记录包的组件对用户非常有帮助。一个`INSTALL`“`README`”文件是存放这些信息的好地方。
- en: If `cmake` is invoked with the `--component` argument for a non-existent component,
    the command will complete successfully without warnings or errors, but it won’t
    install anything.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`cmake`在没有指定组件的情况下使用`--component`参数调用一个不存在的组件，命令将会成功完成，但不会安装任何内容，也不会出现警告或错误。
- en: Partitioning our installation into components allows users to selectively install
    parts of the package. Let’s now turn to managing symbolic links for versioned
    shared libraries, a useful feature for optimizing your installation processes.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的安装划分为多个组件使用户能够选择性地安装包的部分内容。现在让我们转向管理版本化共享库的符号链接，这对于优化您的安装过程非常有用。
- en: Managing symbolic links for versioned shared libraries
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理版本化共享库的符号链接
- en: The target platform for your installation may use symbolic links to help linkers
    discover the currently installed version of a shared library. After creating a
    `lib<name>.so` symlink to the `lib<name>.so.1` file, it’s possible to link this
    library by passing the `-l<name>` argument to the linker.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 您的安装目标平台可能使用符号链接来帮助链接器发现当前安装的共享库版本。在创建一个指向`lib<name>.so.1`文件的`lib<name>.so`符号链接后，可以通过将`-l<name>`参数传递给链接器来链接此库。
- en: 'CMake’s `install(TARGETS <target> LIBRARY)` block handles the creation of such
    symlinks when needed. However, we may decide to move that step to another `install()`
    command by adding `NAMELINK_SKIP` to this block:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: CMake的`install(TARGETS <target> LIBRARY)`块在需要时处理创建此类符号链接的操作。不过，我们可以决定将该步骤移到另一个`install()`命令中，方法是向该块添加`NAMELINK_SKIP`：
- en: '[PRE71]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To assign symlinking to another component (instead of disabling it altogether),
    we can repeat the `install()` command for the same target and specify a different
    component, followed by the `NAMELINK_ONLY` keyword:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 要将符号链接分配给另一个组件（而不是完全禁用它），我们可以对相同的目标重复执行`install()`命令，并指定不同的组件，后跟`NAMELINK_ONLY`关键字：
- en: '[PRE72]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The same effect can be achieved with the `NAMELINK_COMPONENT` keyword:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的效果可以通过`NAMELINK_COMPONENT`关键字实现：
- en: '[PRE73]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Now that we have configured automatic installation, we can provide pre-built
    artifacts for our users using the CPack tool, which is included with CMake.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了自动安装，可以使用CMake自带的CPack工具为用户提供预构建的工件。
- en: Packaging with CPack
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CPack进行打包
- en: While building projects from source has its benefits, it can be time-consuming
    and complex, which isn’t ideal for end users, especially non-developers. A more
    convenient distribution method is using binary packages, containing compiled artifacts
    and other necessary static files. CMake supports generating such packages with
    a command-line tool called `cpack`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从源代码构建项目有其优点，但它可能耗时且复杂，这对于最终用户尤其是非开发者来说并不理想。一个更方便的分发方式是使用二进制包，其中包含已编译的工件和其他必要的静态文件。CMake支持通过一个名为`cpack`的命令行工具生成这样的包。
- en: To generate a package, select an appropriate package generator for your target
    platform and package type. Don’t confuse package generators with buildsystem generators
    like Unix Makefiles or Visual Studio.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个软件包，请选择适合目标平台和软件包类型的生成器。不要将软件包生成器与构建系统生成器（如Unix Makefile或Visual Studio）混淆。
- en: 'The following table lists the available package generators:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了可用的软件包生成器：
- en: '| **Generator Name** | **Produced File Types** | **Platform** |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| **生成器名称** | **生成的文件类型** | **平台** |'
- en: '| Archive | 7Z, 7zip - (`.7z`)TBZ2 (`.tar.bz2`)TGZ (`.tar.gz`)TXZ (`.tar.xz`)TZ
    (`.tar.Z`)TZST (`.tar.zst`)ZIP (`.zip`) | Cross-platform |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| Archive | 7Z, 7zip - (`.7z`)TBZ2 (`.tar.bz2`)TGZ (`.tar.gz`)TXZ (`.tar.xz`)TZ
    (`.tar.Z`)TZST (`.tar.zst`)ZIP (`.zip`) | 跨平台 |'
- en: '| Bundle | macOs Bundle (`.bundle`) | macOS |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| Bundle | macOS Bundle (`.bundle`) | macOS |'
- en: '| Cygwin | Cygwin packages | Cygwin |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| Cygwin | Cygwin软件包 | Cygwin |'
- en: '| DEB | Debian packages (`.deb`) | Linux |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| DEB | Debian软件包（`.deb`） | Linux |'
- en: '| External | JSON (`.json`) file for 3rd party packagers | Cross-platform |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| External | 第三方打包工具的JSON（`.json`）文件 | 跨平台 |'
- en: '| FreeBSD | PKG (`.pkg`) | *BSD, Linux, macOS |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| FreeBSD | PKG (`.pkg`) | *BSD, Linux, macOS |'
- en: '| IFW | QT installer binary | Linux, Windows, macOS |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| IFW | QT安装程序二进制文件 | Linux, Windows, macOS |'
- en: '| NSIS | Binary (`.exe`) | Windows |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| NSIS | 二进制文件（`.exe`） | Windows |'
- en: '| NuGet | NuGet package (`.nupkg`) | Windows |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| NuGet | NuGet包（`.nupkg`） | Windows |'
- en: '| productbuild | PKG (`.pkg`) | macOS |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| productbuild | PKG (`.pkg`) | macOS |'
- en: '| RPM | RPM (`.rpm`) | Linux |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| RPM | RPM (`.rpm`) | Linux |'
- en: '| WIX | Microsoft Installer (`.msi`) | Windows |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| WIX | 微软安装程序（`.msi`） | Windows |'
- en: 'Table 14.3: Available package generators'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 表14.3：可用的软件包生成器
- en: Most of these generators have extensive configurations. While it’s beyond this
    book’s scope to delve into all their details, you can find more information in
    the *Further reading* section. We’ll focus on a general use case.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这些生成器中的大多数具有广泛的配置。虽然本书的范围不涉及其所有细节，但你可以在*进一步阅读*部分找到更多信息。我们将专注于一个一般的使用案例。
- en: To use CPack, configure your project’s installation with the necessary `install()`
    commands and build your project. The resulting `cmake_install.cmake` in the build
    tree is used by CPack to prepare binary packages based on the `CPackConfig.cmake`
    file. While you can create this file manually, using `include(CPack)` in your
    project’s listfile is easier. It generates the configuration in the build tree
    and supplies default values where needed.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用CPack，请使用必要的`install()`命令配置项目的安装，并构建项目。生成的`cmake_install.cmake`文件将在构建目录中，供CPack根据`CPackConfig.cmake`文件准备二进制软件包。虽然你可以手动创建此文件，但在项目的清单文件中使用`include(CPack)`更为简便。它会在构建目录中生成配置，并在需要时提供默认值。
- en: 'Let’s extend the `13-components` example for CPack use:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展`13-components`示例，使用CPack：
- en: '**ch14/14-cpack/CMakeLists.txt (fragment)**'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch14/14-cpack/CMakeLists.txt（片段）**'
- en: '[PRE74]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The CPack module extracts the following variables from the `project()` command:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: CPack模块从`project()`命令中提取以下变量：
- en: '`CPACK_PACKAGE_NAME`'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPACK_PACKAGE_NAME`'
- en: '`CPACK_PACKAGE_VERSION`'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPACK_PACKAGE_VERSION`'
- en: '`CPACK_PACKAGE_FILE_NAME`'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPACK_PACKAGE_FILE_NAME`'
- en: 'The `CPACK_PACKAGE_FILE_NAME` stores the structure of the package name:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`CPACK_PACKAGE_FILE_NAME`存储软件包名称的结构：'
- en: '[PRE75]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, `CPACK_SYSTEM_NAME` is the target OS name, like `Linux` or `win32`. For
    example, by executing a ZIP generator on Debian, CPack will generate a file named
    `CPackPackage-1.2.3-Linux.zip`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`CPACK_SYSTEM_NAME`是目标操作系统的名称，如`Linux`或`win32`。例如，在Debian上执行ZIP生成器时，CPack将生成一个名为`CPackPackage-1.2.3-Linux.zip`的文件。
- en: 'To generate packages after building your project, go to the build tree of your
    project and run:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 要在构建项目后生成软件包，请进入项目的构建目录并运行：
- en: '[PRE76]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'CPack reads options from the `CPackConfig.cmake` file, but you can override
    these settings:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: CPack 从 `CPackConfig.cmake` 文件中读取选项，但你可以覆盖这些设置：
- en: '`-G <generators>`: Semicolon-separated list of package generators. The default
    value can be specified in the `CPackConfig.cmake` in the `CPACK_GENERATOR` variable.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-G <generators>`：以分号分隔的软件包生成器列表。默认值可以在`CPackConfig.cmake`中的`CPack_GENERATOR`变量中指定。'
- en: '`-C <configs>`: Semicolon-separated list of build configurations (debug, release)
    to generate packages for (required for multi-configuration buildsystem generators).'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-C <configs>`：以分号分隔的构建配置（调试、发布）列表，用于生成软件包（对于多配置构建系统生成器是必需的）。'
- en: '`-D <var>=<value>`: This overrides a variable that’s set in the `CPackConfig.cmake`
    file.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-D <var>=<value>`：覆盖`CPackConfig.cmake`文件中设置的变量。'
- en: '`--config <config-file>`: This uses a specified config file instead of the
    default `CPackConfig.cmake`.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--config <config-file>`：使用指定的配置文件，而不是默认的`CPackConfig.cmake`。'
- en: '`--verbose, -V`: This provides verbose output.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--verbose, -V`：提供详细输出。'
- en: '`-P <packageName>`: This overrides the package name.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-P <packageName>`：此选项覆盖包名。'
- en: '`-R <packageVersion>`: This overrides the package version.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-R <packageVersion>`：此选项覆盖包版本。'
- en: '`--vendor <vendorName>`: This overrides the package vendor.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--vendor <vendorName>`：此选项覆盖包供应商。'
- en: '`-B <packageDirectory>`: This specifies the output directory for `cpack` (by
    default, this will be the current working directory).'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-B <packageDirectory>`：此选项指定 `cpack` 的输出目录（默认为当前工作目录）。'
- en: 'Let’s try generating packages for our `14-cpack` example project. We’re going
    to use ZIP, 7Z, and the Debian package generator:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试为我们的 `14-cpack` 示例项目生成包。我们将使用 ZIP、7Z 和 Debian 包生成器：
- en: '[PRE77]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You should get these packages:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该获得这些包：
- en: '`CPackPackage-1.2.3-Linux.7z`'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPackPackage-1.2.3-Linux.7z`'
- en: '`CPackPackage-1.2.3-Linux.deb`'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPackPackage-1.2.3-Linux.deb`'
- en: '`CPackPackage-1.2.3-Linux.zip`'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPackPackage-1.2.3-Linux.zip`'
- en: These binary packages are ready for publication on your project’s website, a
    GitHub release, or a package repository for end users.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这些二进制包已经准备好发布到你项目的官方网站、GitHub 发布版或包仓库，供最终用户使用。
- en: Summary
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Navigating the intricacies of writing cross-platform installation scripts can
    be daunting, but CMake significantly simplifies this task. Although it requires
    some initial setup, CMake streamlines the process, integrating seamlessly with
    the concepts and techniques we’ve explored throughout this book.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 编写跨平台安装脚本的复杂性可能令人畏惧，但 CMake 显著简化了这一任务。虽然它需要一些初始设置，但 CMake 精简了这一过程，并与我们在本书中探讨的概念和技术无缝集成。
- en: 'We began by understanding how to export CMake targets from projects, enabling
    their use in other projects without installation. This was followed by insights
    into installing projects that are already configured for export. Delving into
    installation basics, we focused on a crucial aspect: installing CMake targets.
    We now have a grasp of how CMake allocates different destinations for various
    artifact types and the special considerations for public headers. We also examined
    other modes of the `install()` command, encompassing the installation of files,
    programs, and directories, and executing scripts during installation.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先了解了如何从项目中导出 CMake 目标，使其可以在其他项目中使用而无需安装。接着我们深入了解了如何安装已配置好导出的项目。探讨安装基础时，我们重点关注了一个关键方面：安装
    CMake 目标。现在，我们已经掌握了 CMake 如何为各种工件类型分配不同的目标目录，以及对公共头文件的特殊处理。我们还研究了 `install()`
    命令的其他模式，包括安装文件、程序和目录，并在安装过程中执行脚本。
- en: Our journey then led us to CMake’s reusable packages. We explored how to make
    project targets relocatable, facilitating user-defined installation locations.
    This included creating fully defined packages consumable via `find_package()`,
    entailing the preparation of *target export files*, *config files*, and *version
    files*. Acknowledging diverse user needs, we learned how to group artifacts and
    actions into installation components, distinguishing them from the components
    of CMake packages. Our exploration culminated in an introduction to CPack. We
    discovered how to prepare basic binary packages, offering an efficient method
    to distribute pre-compiled software. While mastering the nuances of installation
    and packaging in CMake is an ongoing journey, this chapter lays a robust foundation.
    It equips us to handle common scenarios and delve deeper with confidence.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的旅程带我们来到了 CMake 的可重用包。我们探讨了如何使项目目标可移动，从而便于用户自定义安装位置。这包括创建可通过`find_package()`消费的完全定义的包，涉及到准备*目标导出文件*、*配置文件*和*版本文件*。鉴于用户需求的多样性，我们学习了如何将工件和操作分组到安装组件中，并将其与
    CMake 包的组件区分开来。我们的探索最终介绍了 CPack。我们发现如何准备基本的二进制包，提供了一种高效的方法来分发预编译的软件。虽然掌握 CMake
    中安装和打包的细节是一个持续的过程，但这一章为我们打下了坚实的基础，使我们能够自信地处理常见场景并深入探索。
- en: In the next chapter, we’ll apply our accumulated knowledge by crafting a cohesive,
    professional project, showcasing practical applications of these CMake techniques.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将通过制作一个紧密结合、专业的项目，运用我们积累的知识，展示这些 CMake 技术的实际应用。
- en: Further reading
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'GNU coding standards for destinations: [https://www.gnu.org/prep/standards/html_node/Directory-Variables.html](https://www.gnu.org/prep/standards/html_node/Directory-Variables.html)'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU 目标目录的编码标准：[https://www.gnu.org/prep/standards/html_node/Directory-Variables.html](https://www.gnu.org/prep/standards/html_node/Directory-Variables.html)
- en: Discussion on new public header management with the `FILE_SET` keyword:[https://gitlab.kitware.com/cmake/cmake/-/issues/22468#note_991860](https://gitlab.kitware.com/cmake/cmake/-/issues/22468#note_991860)
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于使用 `FILE_SET` 关键字进行新的公共头文件管理的讨论：[https://gitlab.kitware.com/cmake/cmake/-/issues/22468#note_991860](https://gitlab.kitware.com/cmake/cmake/-/issues/22468#note_991860)
- en: 'How to install a shared library: [https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html](https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html)'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装共享库：[https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html](https://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html)
- en: 'Creating relocatable packages: [https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html#creating-relocatable-packages](https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html#creating-relocatable-packages)'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重新定位的包：[https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html#creating-relocatable-packages](https://cmake.org/cmake/help/latest/guide/importing-exporting/index.html#creating-relocatable-packages)
- en: 'List of paths scanned by `find_package()` to find the config file: [https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-search-procedure](https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-search-procedure)'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_package()`扫描的查找配置文件的路径列表：[https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-search-procedure](https://cmake.org/cmake/help/latest/command/find_package.html#config-mode-search-procedure)'
- en: 'Full documentation of `CMakePackageConfigHelpers`: [https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html](https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html
    )'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakePackageConfigHelpers`的完整文档：[https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html](https://cmake.org/cmake/help/latest/module/CMakePackageConfigHelpers.html)'
- en: 'CPack package generators: [https://cmake.org/cmake/help/latest/manual/cpack-generators.7.html](https://cmake.org/cmake/help/latest/manual/cpack-generators.7.html)'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPack 包生成器：[https://cmake.org/cmake/help/latest/manual/cpack-generators.7.html](https://cmake.org/cmake/help/latest/manual/cpack-generators.7.html)
- en: On preferred package generators for different platforms:[https://stackoverflow.com/a/46013099](https://stackoverflow.com/a/46013099)
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对不同平台的首选包生成器：[https://stackoverflow.com/a/46013099](https://stackoverflow.com/a/46013099)
- en: 'CPack utility module documentation: [https://cmake.org/cmake/help/latest/module/CPack.html](https://cmake.org/cmake/help/latest/module/CPack.html)'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPack 工具模块文档：[https://cmake.org/cmake/help/latest/module/CPack.html](https://cmake.org/cmake/help/latest/module/CPack.html)
- en: Join our community on Discord
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 频道，与作者及其他读者进行讨论：
- en: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
- en: '![](img/QR_Code94081075213645359.png)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code94081075213645359.png)'
