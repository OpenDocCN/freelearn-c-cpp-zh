- en: '*Chapter 12*: Create Your Own Backend'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：创建您自己的后端'
- en: LLVM has a very flexible architecture. You can also add a new target backend
    to it. The core of a backend is the target description, from which most of the
    code is generated. However, it is not yet possible to generate a complete backend,
    and implementing the calling convention requires manually written code. In this
    chapter, we will learn how to add support for a historical CPU.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM具有非常灵活的架构。您也可以向其添加新的目标后端。后端的核心是目标描述，其中大部分代码都是由此生成的。但是，目前还无法生成完整的后端，并且实现调用约定需要手动编写代码。在本章中，我们将学习如何为历史CPU添加支持。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Setting the stage for a new backend introduces you to the M88k CPU architecture
    and shows you where to find the information you need.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为新后端做准备，让您了解M88k CPU架构，并指导您在何处找到所需的信息。
- en: Adding the new architecture to the Triple class teaches you how to make LLVM
    aware of a new CPU architecture.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新架构添加到Triple类将教会您如何使LLVM意识到新的CPU架构。
- en: In Extending the ELF file format definition in LLVM, you will add support for
    the M88k-specific relocations to the libraries and tools that handle ELD object
    files.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在LLVM中扩展ELF文件格式定义，您将为处理ELD对象文件的库和工具添加对M88k特定重定位的支持。
- en: In Creating the target description, you will develop all the parts of the target
    description in the TableGen language.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建目标描述中，您将使用TableGen语言开发目标描述的所有部分。
- en: In Implementing the DAG instruction selection classes, you will create the passes
    and supporting classes required for instruction selection.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现DAG指令选择类中，您将创建所需的指令选择的传递和支持类。
- en: Generating assembler instructions teaches you how to implement the assembler
    printer, which is responsible for textual assembler generation.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成汇编指令教会您如何实现汇编打印机，负责生成文本汇编程序。
- en: In Emitting machine code, you learn about which additional classes you must
    provide to enable the **machine code** (**MC**) layer to write code to object
    files.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发出机器代码中，您将了解必须提供哪些额外的类来使**机器代码**（**MC**）层能够向目标文件写入代码。
- en: In Adding support for disassembling, you will learn how to implement support
    for a disassembler.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在添加反汇编支持中，您将学习如何实现反汇编器的支持。
- en: In Piecing it all together, you will integrate the source for the new backend
    into the build system.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将所有内容组合在一起中，您将把新后端的源代码集成到构建系统中。
- en: By the end of this chapter, you will know how to develop a new and complete
    backend. You will know about the different parts a backend is made of, giving
    you a deeper understanding of the LLVM architecture.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您将了解如何开发一个新的完整后端。您将了解后端由不同部分组成，从而更深入地了解LLVM架构。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for the chapter are available at [https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter12](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter12)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该章节的代码文件可在[https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter12](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter12)找到
- en: You can find the code in action videos at [https://bit.ly/3nllhED](https://bit.ly/3nllhED)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://bit.ly/3nllhED](https://bit.ly/3nllhED)找到代码演示视频
- en: Setting the stage for a new backend
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为新后端做准备
- en: Whether it's needed commercially to support a new CPU or it's only for a hobby
    project to add support for some old architecture, adding a new backend to LLVM
    is a major task. The following sections outline what you need to develop a new
    backend. We will add a backend for the Motorola M88k architecture, which is a
    RISC architecture from the 1980s.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是出于商业需要支持新的CPU，还是仅仅是为了为一些旧的架构添加支持而进行的爱好项目，向LLVM添加新的后端都是一项重大任务。以下各节概述了您需要开发新后端的内容。我们将为20世纪80年代的RISC架构Motorola
    M88k添加一个后端。
- en: References
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'You can read more about the architecture on Wikipedia: [https://en.wikipedia.org/wiki/Motorola_88000](https://en.wikipedia.org/wiki/Motorola_88000).
    The important information about this architecture is still available on the internet.
    You can find the CPU manuals with the instruction set and timing information at
    [http://www.bitsavers.org/components/motorola/88000/](http://www.bitsavers.org/components/motorola/88000/),
    and the System V ABI M88k Processor supplement with the definitions of the ELF
    format and the calling convention can be found at [https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463](https://archive.org/details/bitsavers_attunixSysa0138776555SystemVRelease488000ABI1990_8011463).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在维基百科上阅读更多关于该架构的信息：[https://en.wikipedia.org/wiki/Motorola_88000](https://en.wikipedia.org/wiki/Motorola_88000)。有关该架构的重要信息仍然可以在互联网上找到。您可以在[http://www.bitsavers.org/components/motorola/88000/](http://www.bitsavers.org/components/motorola/88000/)找到包含指令集和时序信息的CPU手册，以及包含ELF格式和调用约定定义的System
    V ABI M88k处理器补充的信息。
- en: OpenBSD, available at [https://www.openbsd.org/](https://www.openbsd.org/),
    still supports the LUNA-88k system. On the OpenBSD system, it is easy to create
    a GCC cross-compiler for M88k. And with GXemul, available at http://gavare.se/gxemul/,
    there exists an emulator capable of running certain OpenBSD releases for the M88k
    architecture.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: OpenBSD，可在[https://www.openbsd.org/](https://www.openbsd.org/)找到，仍然支持LUNA-88k系统。在OpenBSD系统上，很容易为M88k创建GCC交叉编译器。并且有一个名为GXemul的仿真器，可运行M88k架构的某些OpenBSD版本，该仿真器可在http://gavare.se/gxemul/找到。
- en: Taken together, the M88k architecture is long out of production, but we found
    enough information and tools to make it an interesting goal to add an LLVM backend
    for it. We will begin with a very basic task and extend the `Triple` class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，M88k架构已经停产很久了，但我们找到了足够的信息和工具，使其成为向LLVM添加后端的有趣目标。我们将从一个非常基本的任务开始，并扩展`Triple`类。
- en: Adding the new architecture to the Triple class
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将新架构添加到Triple类
- en: 'An instance of the `Triple` class represents the target platform LLVM is producing
    code for. To support a new architecture, the first task is to extend the `Triple`
    class. In the `llvm/include/llvm/ADT/Triple.h` file, you add a member to the `ArchType`
    enumeration and a new predicate:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Triple`类的一个实例代表LLVM正在为其生成代码的目标平台。为了支持新的架构，第一步是扩展`Triple`类。在`llvm/include/llvm/ADT/Triple.h`文件中，您需要向`ArchType`枚举添加一个成员和一个新的谓词：'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside the `llvm/lib/Support/Triple.cpp` file, there are numerous methods that
    use the `ArchType` enumeration. You need to extend all of them; for example, in
    the `getArchTypeName()` method, you need to add a new case statement:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在`llvm/lib/Support/Triple.cpp`文件中，有许多使用`ArchType`枚举的方法。您需要扩展所有这些方法；例如，在`getArchTypeName()`方法中，您需要添加一个新的case语句：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In most cases, the compiler will warn you if you forget to handle the new `m88k`
    enumeration member in one of the functions. Next, we will expand the **Executable
    and Linkable Format** (**ELF**) definition.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，如果您忘记处理一个函数中的新的`m88k`枚举成员，编译器会警告您。接下来，我们将扩展**可执行和可链接格式**（**ELF**）的定义。
- en: Extending the ELF file format definition in LLVM
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展LLVM中的ELF文件格式定义
- en: 'The ELF file format is one of the binary object file formats that LLVM has
    support for to read and write. ELF itself is defined for many CPU architectures,
    and there is also a definition for the M88k architecture. All we need to do is
    to add the definition of the relocations and some flags. The relocations are given
    in [*Chapter 4*](B15647_04_ePub_RK.xhtml#_idTextAnchor066), *Object Files*, of
    the *System V ABI M88k Processor* supplement book:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ELF文件格式是LLVM支持读取和写入的二进制对象文件格式之一。ELF本身为许多CPU架构定义了规范，也有M88k架构的定义。我们需要做的就是添加重定位的定义和一些标志。重定位在《第4章》，《对象文件》，《System
    V ABI M88k Processor》补充书中给出：
- en: 'We need to type the following into the `llvm/include/llvm/BinaryFormat/ELFRelocs/M88k.def`
    file:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`llvm/include/llvm/BinaryFormat/ELFRelocs/M88k.def`文件中输入以下内容：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We also add some flags to the `llvm/include/llvm/BinaryFormat/ELF.h` file and
    include the relocation definitions:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要向`llvm/include/llvm/BinaryFormat/ELF.h`文件添加一些标志，并包括重定位的定义：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code can be added anywhere in the file, but it is best to keep a sorted
    order and insert it before the code for the MIPS architecture.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以添加到文件的任何位置，但最好保持排序顺序，并在MIPS架构的代码之前插入。
- en: 'We also need to expand some other methods. In the `llvm/include/llvm/Object/ELFObjectFile.h`
    file are some methods that translate between enumeration members and strings.
    For example, we must add a new case statement to the `getFileFormatName()` method:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要扩展一些其他方法。在`llvm/include/llvm/Object/ELFObjectFile.h`文件中有一些在枚举成员和字符串之间进行转换的方法。例如，我们必须向`getFileFormatName()`方法添加一个新的case语句：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Similarly, we extend the `getArch()` method.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，我们扩展`getArch()`方法。
- en: 'Last, we use the relocation definitions in the `llvm/lib/Object/ELF.cpp` file,
    in the `getELFRelocationTypeName()` method:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`llvm/lib/Object/ELF.cpp`文件中使用重定位定义，在`getELFRelocationTypeName()`方法中：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To complete the support, you can also add the relocations in the `llvm/lib/ObjectYAML/ELFYAML.cpp`
    file, in the method that maps the `ELFYAML::ELF_REL` enumeration.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成支持，您还可以在`llvm/lib/ObjectYAML/ELFYAML.cpp`文件中添加重定位，在映射`ELFYAML::ELF_REL`枚举的方法中。
- en: At this point, we have completed the support of the m88k architecture in the
    ELF file format. You can use the `llvm-readobj` tool to inspect an ELF object
    file, for example, created by a cross-compiler on OpenBSD. Likewise, you can create
    an ELF object file for the m88k architecture with the `yaml2obj` tool.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经完成了对ELF文件格式中m88k架构的支持。您可以使用`llvm-readobj`工具检查一个ELF目标文件，例如，在OpenBSD上由交叉编译器创建的。同样地，您可以使用`yaml2obj`工具为m88k架构创建一个ELF目标文件。
- en: Is adding support for an object file format mandatory?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为对象文件格式添加支持是否是强制性的？
- en: Integrating support for an architecture into the ELF file format implementation
    requires only a couple of lines. If the architecture for which you create an LLVM
    backend uses the ELF format, then you should take this route. On the other hand,
    adding support for a completely new binary file format is itself a complicated
    task. In this case, a possible approach is to only output assembler files and
    use an external assembler to create object files.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将对架构的支持集成到ELF文件格式实现中只需要几行代码。如果您为其创建LLVM后端的架构使用ELF格式，那么您应该采用这种方式。另一方面，为全新的二进制文件格式添加支持本身就是一项复杂的任务。在这种情况下，一个可能的方法是只输出汇编文件，并使用外部汇编器创建目标文件。
- en: With these additions, the implementation of the ELF file formats now supports
    the M88k architecture. In the next section, we create the target description for
    the M88k architecture, which describes the instructions, registers, calling convention,
    and other details of the architecture.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些添加，ELF文件格式的实现现在支持M88k架构。在下一节中，我们将为M88k架构创建目标描述，描述架构的指令、寄存器、调用约定和其他细节。
- en: Creating the target description
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建目标描述
- en: The **target description** is the heart of a backend implementation. In an ideal
    world, we could generate the whole backend from the target description. This goal
    has not yet been reached, and therefore, we need to extend the generated code
    later. Let's dissect the target description, beginning with the top-level file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标描述**是后端实现的核心。在理想的情况下，我们可以从目标描述生成整个后端。这个目标尚未实现，因此我们需要稍后扩展生成的代码。让我们从顶层文件开始剖析目标描述。'
- en: Implementing the top-level file of the target description
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现目标描述的顶层文件
- en: 'We put the files of our new backend into the `llvm/lib/Target/M88k` directory.
    The target description is in the `M88k.td` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们新后端的文件放入`llvm/lib/Target/M88k`目录。目标描述在`M88k.td`文件中：
- en: 'In this file, we first need to include basic target description classes predefined
    by LLVM and then the files we are going to create in the next sections:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，我们首先需要包括LLVM预定义的基本目标描述类，然后是我们将在下一节中创建的文件：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we also define the supported processor. Among other things, this translates
    into the parameter for the `–mcpu=` option:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们还定义了支持的处理器。除其他事项外，这还转换为`-mcpu=`选项的参数：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With all these definitions done, we now can piece our target together. We define
    these subclasses, in case we need to modify some of the default values. The `M88kInstrInfo`
    class holds all the information about the instructions:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些定义都完成后，我们现在可以将我们的目标组合起来。我们定义这些子类，以防需要修改一些默认值。`M88kInstrInfo`类包含有关指令的所有信息：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We define a parser for the `.s` assembly files, and we additionally state that
    register names are always be prefixed with `%`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为`.s`汇编文件定义了一个解析器，并且我们还声明寄存器名称始终以`%`为前缀：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we define a class for the assembly writer, which is responsible for writing
    `.s` assembly files:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为汇编写入器定义一个类，负责编写`.s`汇编文件：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And lastly, all these records are put together to define the target:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，所有这些记录都被放在一起来定义目标：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that the top-level file is implemented, we create the included files, starting
    with the register definition in the next section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在顶层文件已经实现，我们创建包含的文件，从下一节开始定义寄存器定义。
- en: Adding the register definition
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加寄存器定义
- en: A CPU architecture usually defines a set of registers. The characteristics of
    these registers can vary greatly. Some architectures allow access to subregisters.
    For example, the x86 architecture has special register names to access only a
    part of a register value. Other architectures do not implement this. Besides general-purpose,
    floating-point, and vector registers, an architecture may also define special
    registers, for example, for status codes or for the configuration of floating-point
    operations. You need to define all this information for LLVM.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: CPU架构通常定义一组寄存器。这些寄存器的特性可以有很大的变化。一些架构允许访问子寄存器。例如，x86架构具有特殊的寄存器名称，用于仅访问寄存器值的一部分。其他架构则不实现这一点。除了通用寄存器、浮点寄存器和矢量寄存器外，架构还可以定义特殊寄存器，例如用于状态代码或浮点运算配置。您需要为LLVM定义所有这些信息。
- en: 'The M88k architecture defines general-purpose registers, floating-point registers,
    and control registers. To keep the example small, we will only define the general-purpose
    registers. We begin with defining a super-class for the registers. The encoding
    for registers uses only `5` bits, so we limit the field holding the encoding.
    We also define that all the generated C++ code should reside in the `M88k` namespace:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: M88k架构定义了通用寄存器、浮点寄存器和控制寄存器。为了使示例简单，我们只定义通用寄存器。我们首先定义寄存器的超类。寄存器的编码仅使用`5`位，因此我们限制了保存编码的字段。我们还定义，所有生成的C++代码应该驻留在`M88k`命名空间中：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `M88kReg` class is used for all register types. We define a special class
    for general-purpose registers:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`M88kReg`类用于所有寄存器类型。我们为通用寄存器定义了一个特殊的类：'
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can define all 32 general-purpose registers:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义所有32个通用寄存器：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The single registers need to be grouped in register classes. The sequence order
    of the registers also defines the allocation order in the register allocator.
    Here, we simply add all registers:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 单个寄存器需要分组在寄存器类中。寄存器的序列顺序还定义了寄存器分配器中的分配顺序。在这里，我们只是添加所有寄存器：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And last, we need to define an operand based on the register class. The operand
    is used in selecting DAG nodes to match a register, and it can also be extended
    to denote method names for printing and matching the register in assembly code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要基于寄存器类定义一个操作数。该操作数用于选择DAG节点以匹配寄存器，并且还可以扩展以表示打印和匹配汇编代码中的方法名称：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This finishes our definition of the registers. In the next section, we use these
    definitions to define the calling convention.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对寄存器的定义。在下一节中，我们将使用这些定义来定义调用约定。
- en: Defining the calling convention
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义调用约定
- en: A **calling convention** defines how parameters are passed to functions. Usually,
    the first parameters are passed in registers, and the rest of the parameters are
    passed on the stack. There must also be rules on how aggregates are passed and
    how values are returned from a function. From the definition given here, analyzer
    classes are generated, which are used later during the lowering of calls.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**调用约定**定义了如何传递参数给函数。通常，第一个参数是通过寄存器传递的，其余的参数是通过堆栈传递的。还必须制定关于如何传递聚合和如何从函数返回值的规则。根据这里给出的定义，生成了分析器类，稍后在调用降级期间使用。'
- en: 'You can read about the calling convention used on the M88k architecture in
    [*Chapter 3*](B15647_03_ePub_RK.xhtml#_idTextAnchor048), *Low-Level System Information*,
    of the *System V ABI M88k Processor* supplement book. Let''s translate this into
    the TableGen syntax:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[*第3章*](B15647_03_ePub_RK.xhtml#_idTextAnchor048)中阅读M88k架构使用的调用约定，*低级系统信息*，*System
    V ABI M88k处理器*补充书。让我们将其翻译成TableGen语法：
- en: 'We define a record for the calling convention:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为调用约定定义一个记录：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The M88k architecture only has 32-bit registers, therefore values of smaller
    data types need to be promoted to 32 bit:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: M88k架构只有32位寄存器，因此需要将较小数据类型的值提升为32位：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The calling convention states that for aggregate return values, a pointer to
    the memory is passed in the `r12` register:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用约定规定，对于聚合返回值，内存的指针将传递到`r12`寄存器中：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The registers `r2` to `r9` are used to pass parameters:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寄存器`r2`到`r9`用于传递参数：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Every additional parameter is passed on the stack, in 4 bytes-aligned slots:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个额外的参数都以4字节对齐的插槽传递到堆栈上：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'An additional record defines how results are passed to the calling function.
    32-bit values are passed in the `r2` register, and 64-bit values use the `r2`
    and `r3` registers:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个记录定义了如何将结果传递给调用函数。32位值在`r2`寄存器中传递，64位值使用`r2`和`r3`寄存器：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And last, a calling convention also states which registers have to be preserved
    by the called function:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用约定还说明了由被调用函数保留的寄存器：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If needed, you can also define multiple calling conventions. In the next section,
    we will have a brief look at the scheduling model.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您还可以定义多个调用约定。在下一节中，我们将简要介绍调度模型。
- en: Creating the scheduling model
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建调度模型
- en: 'The scheduling model is used by the code generation to order the instructions
    in an optimal way. Defining a scheduling model improves the performance of the
    generated code, but it is not necessary for code generation. Therefore, we only
    define a placeholder for the model. We add the information that the CPU can issue
    at most two instructions at once, and that it is an in-order CPU:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 调度模型被代码生成用来以最佳方式排序指令。定义调度模型可以提高生成代码的性能，但对于代码生成并不是必需的。因此，我们只为模型定义一个占位符。我们添加的信息是CPU最多可以同时发出两条指令，并且它是一个顺序CPU：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can find recipes on how to create a complete scheduling model in the talk
    *Writing Great Schedulers* on YouTube at [https://www.youtube.com/watch?v=brpomKUynEA](https://www.youtube.com/watch?v=brpomKUynEA).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在YouTube上的[https://www.youtube.com/watch?v=brpomKUynEA](https://www.youtube.com/watch?v=brpomKUynEA)上找到有关如何创建完整调度模型的教程*编写优秀的调度程序*。
- en: Next, we will define the instruction formats and the instructions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义指令格式和指令。
- en: Defining the instruction formats and the instruction information
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义指令格式和指令信息
- en: 'We have already looked at the instruction formats and the instruction information
    in [*Chapter 9*](B15647_09_ePub_RK.xhtml#_idTextAnchor140)*, Instruction Selection*,
    in the *Supporting new machine instructions* section. To define the instructions
    for the M88k architecture, we follow the same approach. First, we define a base
    class for the instruction records. The most important field of this class is the
    `Inst` field, which holds the encoding for the instruction. Most of the other
    field definitions just assign a value to a field defined in the `Instruction`
    superclass:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第9章*](B15647_09_ePub_RK.xhtml#_idTextAnchor140)*，指令选择*中查看了指令格式和指令信息，在*支持新机器指令*部分。为了定义M88k架构的指令，我们遵循相同的方法。首先，我们为指令记录定义一个基类。这个类最重要的字段是`Inst`字段，它保存了指令的编码。这个类的大多数其他字段定义只是为`Instruction`超类中定义的字段赋值：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This base class is used for all instruction formats, so it is also used for
    the `F_JMP` format. You take the encoding for the user manual of the processor.
    The class has two parameters, which must be part of the encoding. The `func` parameter
    defines bits 11 to 15 of the encoding, which defines the instruction as a jump
    with or without saving the return address. The `next` parameter is a bit that
    defines whether the next instruction is executed unconditionally or not. This
    is similar to the delay slot of the MIPS architecture.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基类用于所有指令格式，因此也用于`F_JMP`格式。您可以使用处理器的用户手册中的编码。该类有两个参数，必须是编码的一部分。`func`参数定义了编码的第11到15位，这些位定义了指令是带有或不带有保存返回地址的跳转指令。`next`参数是一个位，定义了下一条指令是否无条件执行。这类似于MIPS架构的延迟槽。
- en: 'The class also defines the `rs2` field, which holds the encoding of the register
    holding the target address. The other parameters are the DAG input and output
    operand, the textual assembler string, a DAG pattern used to select this instruction,
    and an itinerary class for the scheduler model:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还定义了`rs2`字段，其中保存了保存目标地址的寄存器的编码。其他参数包括DAG输入和输出操作数，文本汇编器字符串，用于选择此指令的DAG模式，以及调度器模型的行程类：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And with this, we can finally define the instruction. A jump instruction is
    the last instruction in a basic block, so we need to set the `isTerminator` flag.
    Because control flow can't fall through this instruction, we also have to set
    the `isBarrier` flag. We take the values for the `func` and `next` parameters
    from the user manual of the processor.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们最终可以定义指令了。跳转指令是基本块中的最后一条指令，因此我们需要设置`isTerminator`标志。因为控制流不能通过此指令，我们还必须设置`isBarrier`标志。我们从处理器的用户手册中获取`func`和`next`参数的值。
- en: 'The input DAG operand is a general-purpose register and refers to the operand
    from the preceding register''s information. The encoding is stored in the `rs2`
    field, from the preceding class definition. The output operand is empty. The assembler
    string gives the textual syntax of the instruction and also refers to the register
    operand. The DAG pattern uses the predefine `brind` operator. This instruction
    is selected if the DAG contains an indirect branch node with the target address
    hold in a register:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输入DAG操作数是一个通用寄存器，并指的是前一个寄存器信息中的操作数。编码存储在`rs2`字段中，来自前一个类定义。输出操作数为空。汇编字符串给出了指令的文本语法，也指的是寄存器操作数。DAG模式使用预定义的`brind`操作符。如果DAG包含一个以寄存器中保存的目标地址为目标的间接跳转节点，则选择此指令：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We need to define records for all instructions in this way.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以这种方式为所有指令定义记录。
- en: In this file, we also implement other necessary patterns for instruction selection.
    A typical application is a constant synthesis. The M88k architecture has 32 bit-wide
    registers, but the instructions with immediate values as operands support only
    16 bit-wide constants. As a consequence, operations such as a bitwise `and` between
    a register and a 32-bit constant have to be split into two instructions that use
    16-bit constants.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们还实现了指令选择的其他必要模式。一个典型的应用是常量合成。M88k架构有32位宽的寄存器，但是带有立即数操作数的指令只支持16位宽的常量。因此，诸如寄存器和32位常量之间的按位`and`等操作必须分成两条使用16位常量的指令。
- en: 'Luckily, a flag in the `and` instruction defines whether an operation applies
    to the lower or the upper half of the register. With operators LO16 and HI16 used
    to extract the lower or upper half of a constant, we can formulate a DAG pattern
    for an `and` operation between a register and a 32 bit-wide constant:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`and`指令中的一个标志定义了操作是应用于寄存器的下半部分还是上半部分。使用LO16和HI16操作符来提取常量的下半部分或上半部分，我们可以为寄存器和32位宽常量之间的`and`操作制定一个DAG模式：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `ANDri` operator is the `and` instruction that applies the constant to the
    lower half of the register, and the `ANDriu` operator uses the upper half of the
    register. Of course, before we can use these names in the pattern, we must define
    the instruction like we defined the `jmp` instruction. This pattern solves the
    problem using a 32-bit constant with an `and` operation, generating two machine
    instructions for it during instruction selection.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`ANDri`操作符是将常量应用于寄存器的低半部分的`and`指令，而`ANDriu`操作符使用寄存器的上半部分。当然，在模式中使用这些名称之前，我们必须像定义`jmp`指令一样定义指令。此模式解决了使用32位常量进行`and`操作的问题，在指令选择期间为其生成两条机器指令。'
- en: 'Not all operations can be represented by the predefined DAG nodes. For example,
    the M88k architecture defined bit field operations, which can be seen as generalizations
    of the normal `and`/`or` operations. For such operations, it is possible to introduce
    new node types, for example, for the `set` instruction:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有操作都可以由预定义的DAG节点表示。例如，M88k架构定义了位字段操作，可以看作是普通`and`/`or`操作的泛化。对于这样的操作，可以引入新的节点类型，例如`set`指令：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This defines a new record of the `SDNode` class. The first argument is the C++
    enumeration member that denotes the new operation. The second parameter is the
    so-called type profile and defines the type and number of parameters and the result
    type. The predefined `SDTIntBinOp` class defines two integer parameters and an
    integer result type, which is suitable for this operation. You can look up the
    predefined classes in the `llvm/include/llvm/Target/TargetSelectionDAG.td` file.
    If there is no suitable predefined type profile, then you can define a new one.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了`SDNode`类的新记录。第一个参数是表示新操作的C++枚举成员。第二个参数是所谓的类型配置文件，定义了参数的类型和数量以及结果类型。预定义的`SDTIntBinOp`类定义了两个整数参数和一个整数结果类型，这对于此操作是合适的。您可以在`llvm/include/llvm/Target/TargetSelectionDAG.td`文件中查找预定义的类。如果没有合适的预定义类型配置文件，那么您可以定义一个新的。
- en: 'For calling functions, LLVM requires certain definitions that cannot be predefined
    because they are not completely target-independent. For example, for returns,
    we need to specify a `retflag` record:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调用函数，LLVM需要某些不能预定义的定义，因为它们不完全是与目标无关的。例如，对于返回，我们需要指定`retflag`记录：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Comparing this to `m88k_set` the record, this also defines some flags for the
    DAG node: the chain and glue sequences are used, and the operator can take a variable
    number of arguments.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与`m88k_set`记录进行比较，这也为DAG节点定义了一些标志：链和粘合序列被使用，并且操作符可以接受可变数量的参数。
- en: Implement the instructions iteratively
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步实现指令
- en: A modern CPU can easily have thousands of instructions. It makes sense to not
    implement all instructions at once. Instead, you should first concentrate on basic
    instructions such as logical operations and call and return instructions. This
    is enough to get a very basic backend working. To this base, you then add more
    and more instruction definitions and patterns.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现代CPU很容易有成千上万条指令。一次不要实现所有指令是有意义的。相反，您应该首先集中在基本指令上，例如逻辑操作和调用和返回指令。这足以使基本的后端工作。然后，您可以添加更多的指令定义和模式。
- en: This finishes our implementation of the target description. From the target
    description, a lot of code is automatically generated with the `llvm-tblgen` tool.
    To complete the instruction selection and other parts of the backend, we still
    need to develop a C++ source using the generated code. In the next section, we
    implement the DAG instruction selection.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对目标描述的实现。从目标描述中，使用`llvm-tblgen`工具自动生成了大量代码。为了完成指令选择和后端的其他部分，我们仍然需要使用生成的代码开发C++源代码。在下一节中，我们将实现DAG指令选择。
- en: Implementing the DAG instruction selection classes
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现DAG指令选择类
- en: A large portion of the DAG instruction selector is generated by the `llvm-tblgen`
    tool. We still need to create classes using the generated code and put everything
    together. Let's begin with a part of the initialization process.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: DAG指令选择器的大部分是由`llvm-tblgen`工具生成的。我们仍然需要使用生成的代码创建类，并将所有内容放在一起。让我们从初始化过程的一部分开始。
- en: Initializing the target machine
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化目标机器
- en: 'Each backend has to provide at least one `TargetMachine` class, usually a subclass
    of the `LLVMTargetMachine` class. The `M88kTargetMachine` class holds a lot of
    the details required for code generation, and it also acts as a factory for other
    backend classes, most notably for the `Subtarget` class and the `TargetPassConfig`
    class. The `Subtarget` class holds the configuration for the code generation,
    such as which features are enabled. The `TargetPassConfig` class configures the
    machine passes of the backend. The declaration for our `M88kTargetMachine` class
    is in the `M88ktargetMachine.h` file and looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每个后端都必须提供至少一个`TargetMachine`类，通常是`LLVMTargetMachine`类的子类。`M88kTargetMachine`类包含了代码生成所需的许多细节，并且还充当其他后端类的工厂，尤其是`Subtarget`类和`TargetPassConfig`类。`Subtarget`类保存了代码生成的配置，例如启用了哪些特性。`TargetPassConfig`类配置了后端的机器传递。我们的`M88kTargetMachine`类的声明在`M88ktargetMachine.h`文件中，如下所示：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Please note that there can be a different subtarget for each function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个函数可能有不同的子目标。
- en: 'The implementation in the `M88kTargetMachine.cpp` file is straightforward.
    Most interesting is the setup of the machine passes for this backend. This creates
    the connection to the selection DAG (and, if desired, to global instruction selection).
    The passes created in the class are later added to the pass pipeline to produce
    object files or assemblers from the IR:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`M88kTargetMachine.cpp`文件中的实现是直接的。最有趣的是为此后端设置机器传递。这创建了与选择DAG（如果需要，还有全局指令选择）的连接。类中创建的传递后来被添加到传递管道中，以从IR生成目标文件或汇编程序：'
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `SubTarget` implementation return from the `M88kTargetMachine` class gives
    access to other important classes. The `M88kInstrInfo` class returns information
    about instructions, including registers. The `M88kTargetLowering` class provides
    a lowering of call-related instructions and also allows adding custom DAG rules.
    Most of the class is generated by the `llvm-tblgen` tool, and we need to include
    the generated header.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`SubTarget`实现从`M88kTargetMachine`类返回，可以访问其他重要的类。`M88kInstrInfo`类返回有关指令的信息，包括寄存器。`M88kTargetLowering`类提供了与调用相关指令的降低，并允许添加自定义的DAG规则。大部分类是由`llvm-tblgen`工具生成的，我们需要包含生成的头文件。'
- en: 'The definition in the `M88kSubTarget.h` file is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`M88kSubTarget.h`文件中的定义如下：'
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, we implement the selection DAG.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现选择DAG。
- en: Adding the selection DAG implementation
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加选择DAG实现
- en: 'The selection DAG is implemented in the `M88kDAGtoDAGIsel` class in the file
    of the same name. Here, we benefit from having created the target machine description:
    most of the functionality is generated from this description. In a very first
    implementation, we only need to override the `Select()` function and forward it
    to the generated `SelectCode` function. More functions can be overridden for certain
    cases, for example, if we need to extend the preprocessing of the DAG or if we
    need to add special inline assembler constraints.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 选择DAG在同名文件中的`M88kDAGtoDAGIsel`类中实现。在这里，我们受益于已经创建了目标机器描述：大部分功能都是从这个描述中生成的。在最初的实现中，我们只需要重写`Select()`函数并将其转发到生成的`SelectCode`函数。还可以为特定情况重写更多函数，例如，如果我们需要扩展DAG的预处理，或者如果我们需要添加特殊的内联汇编约束。
- en: 'Because this class is a machine function pass, we also provide a name for the
    pass. The main bulk of the implementation comes from the generated file, which
    we include in the middle of the class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个类是一个机器函数传递，我们还为传递提供了一个名称。主要的实现部分来自生成的文件，我们在类的中间包含了这个文件：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We also add the factory function to create the pass in this file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在这个文件中添加了创建传递的工厂函数：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now we can implement the target-specific operations, which cannot be expressed
    in the target description.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现目标特定的操作，这些操作无法在目标描述中表达。
- en: Supporting target-specific operations
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持目标特定操作
- en: Let's turn to the `M88kTargetLowering` class, defined in the `M88kISelLowering.h`
    file. This class configures the instruction DAG selection process and enhances
    the lowering with target-specific operations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向`M88kTargetLowering`类，在`M88kISelLowering.h`文件中定义。这个类配置指令DAG选择过程，并增强了目标特定操作的降低。
- en: 'In the target description, we defined new DAG nodes. The enumeration used with
    the new types is also defined in this file, continuing the numbering with the
    last predefined number:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标描述中，我们定义了新的DAG节点。与新类型一起使用的枚举也在这个文件中定义，继续使用上一个预定义数字的编号：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The class needs to provide the required lowering methods for the function calls.
    To keep it simple, we look only at returning values. The class can also define
    the `LowerOperation()` hook method for operations that need custom handling. We
    can also enable custom DAG combining methods, for which we define the `PerformDAGCombine()`
    method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该类需要为函数调用提供所需的降低方法。为了保持简单，我们只关注返回值。该类还可以为需要自定义处理的操作定义`LowerOperation()`挂钩方法。我们还可以启用自定义DAG组合方法，为此我们定义`PerformDAGCombine()`方法：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The implementation of the class is in the `M88kISelLowering.cpp` file. First,
    we look at how to lower a return value:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的实现在`M88kISelLowering.cpp`文件中。首先，我们看一下如何降低返回值：
- en: 'The generated functions for the calling convention are needed, so we include
    the generated file:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要调用约定的生成函数，因此我们包含了生成的文件：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `LowerReturn()` method takes a lot of arguments, which are all defined
    by the `TargetLowering` superclass. The most important ones are the `Outs` vector,
    which holds the description of the return argument, and the `OutVals` vector,
    which holds the DAG nodes for the return values:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LowerReturn()`方法有很多参数，所有这些参数都是由`TargetLowering`超类定义的。最重要的是`Outs`向量，它保存了返回参数的描述，以及`OutVals`向量，它保存了返回值的DAG节点：'
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We analyze the return argument with the help of the `CCState` class, passing
    a reference to the generated `RetCC_M88k` function. As result, we have classified
    all the return arguments:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`CCState`类来分析返回参数，并传递一个对生成的`RetCC_M88k`函数的引用。结果，我们已经对所有的返回参数进行了分类：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In case of a `void` function, there is nothing to do and we return. Please
    note that the type of the returned node is `RET_FLAG`. We defined this in the
    target description as the new `ret_flag` node:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是`void`函数，则无需操作并返回。请注意，返回节点的类型是`RET_FLAG`。我们在目标描述中定义了这个新的`ret_flag`节点：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Otherwise, we need to loop over the return arguments. For each return argument,
    we have an instance of the `CCValAssign` class, which tells us how we have to
    treat the argument:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们需要循环遍历返回参数。对于每个返回参数，我们都有一个`CCValAssign`类的实例，告诉我们如何处理参数：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The values may need to be promoted. We add a DAG node with the required extension
    operation, if necessary:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值可能需要提升。如果需要，我们添加一个带有所需扩展操作的DAG节点：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When the value has the right type, we copy the value into a register for returning
    it and chain and glue the copies together. This finishes the loop:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当值具有正确的类型时，我们将该值复制到寄存器中返回，并将复制的链和粘合在一起。这完成了循环：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Last, we need to update the chain and the glue:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要更新链和粘合：
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will then return the `ret_flag` node, connecting the result of the lowering:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将返回`ret_flag`节点，连接降低的结果：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To be able to call functions, we must implement the `LowerFormalArguments()`
    and `LowerCall()` methods. Both methods follow a similar approach and hence are
    not shown here.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够调用函数，我们必须实现`LowerFormalArguments()`和`LowerCall()`方法。这两种方法都遵循类似的方法，因此这里不再显示。
- en: Configuring the target lowering
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置目标降低
- en: 'The methods to lower function calls and arguments must always be implemented,
    as they are always target-dependent. Other operations may or may not have support
    in the target architecture. To make the lowering process aware of it, we set up
    the configuration in the constructor of the `M88kTargetLowering` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 必须始终实现降低函数调用和参数的方法，因为它们始终是与目标相关的。其他操作可能在目标架构中有或没有支持。为了使降低过程意识到这一点，我们在`M88kTargetLowering`类的构造函数中设置了配置：
- en: 'The constructor takes `TargetMachine` and `M88kSubtarget` instances as parameters
    and initializes the corresponding fields with them:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数以`TargetMachine`和`M88kSubtarget`实例作为参数，并用它们初始化相应的字段：
- en: '[PRE47]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We add all the register classes first. We have only general-purpose registers
    defined, therefore it is just a simple call:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先添加所有寄存器类。我们只定义了通用寄存器，因此这只是一个简单的调用：
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After all the register classes are added, we compute the derived properties
    for the registers. For example, since the registers are 32 bits wide, this function
    marks the 64-bit data type as requiring two registers:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加所有寄存器类之后，我们计算寄存器的派生属性。例如，由于寄存器宽度为32位，因此此函数将64位数据类型标记为需要两个寄存器：
- en: '[PRE49]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We also need to tell which register is used for the stack pointer. On the M88k
    architecture, the `r31` register is used:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要告诉哪个寄存器用于堆栈指针。在M88k架构中，使用`r31`寄存器：
- en: '[PRE50]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We also need to define how `boolean` values are represented. Basically, we
    say here that the values 0 and 1 are used. Other possible options are to look
    only at bit 0 of the value, ignoring all other bits, and setting all bits of the
    value either to 0 or 1:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要定义`boolean`值的表示方式。基本上，我们在这里说使用值0和1。其他可能的选项是仅查看值的第0位，忽略所有其他位，并将值的所有位设置为0或1：
- en: '[PRE51]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For every operation that needs special handling, we must call the `setOperationAction()`
    method. The method takes the operation, the value type, and the action to take
    as input. If the operation is valid, then we use the `Legal` action value. If
    the type should be promoted, then we use the `Promote` action value, and if the
    operation should result in a library call, then we use the `LibCall` action value.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个需要特殊处理的操作，我们必须调用`setOperationAction()`方法。该方法以操作、值类型和要执行的操作作为输入。如果操作有效，则使用`Legal`操作值。如果类型应该提升，则使用`Promote`操作值，如果操作应该导致库调用，则使用`LibCall`操作值。
- en: 'If we give the `Expand` action value, then the instruction selection first
    tries to expand this operation into other operations. If this is not possible,
    then a library call is used. And last, we can implement our own action if using
    the `Custom` action value. In this case, the `LowerOperation()`method is called
    for a node with this operation. As an example, we set the `CTTZ` count trailing
    zeros operation to the `Expand` action. This operation will be replaced by a sequence
    of primitive bit operations:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给出`Expand`操作值，则指令选择首先尝试将此操作扩展为其他操作。如果这不可能，则使用库调用。最后，如果使用`Custom`操作值，我们可以实现自己的操作。在这种情况下，将为具有此操作的节点调用`LowerOperation()`方法。例如，我们将`CTTZ`计数尾随零操作设置为`Expand`操作。此操作将被一系列原始位操作替换：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The M88k architecture has a bit field operation, for which it is not easy to
    define a pattern in the target description. Here, we tell the instruction selection
    that we want to perform additional matching on `or` DAG nodes:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: M88k架构具有位字段操作，对于该操作，很难在目标描述中定义模式。在这里，我们告诉指令选择器，我们希望在`or` DAG节点上执行额外的匹配：
- en: '[PRE53]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Depending on the target architecture, setting the configuration in the constructor
    can be much longer. We only defined the bare minimum, ignoring, for example, floating-point
    operations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 根据目标架构，设置构造函数中的配置可能会更长。我们只定义了最低限度，例如忽略了浮点运算。
- en: 'We have marked the `or` operation to perform custom combining on it. As a result,
    the instruction selector calls the `PerformDAGCombine()` method before calling
    the generated instruction selection. This function is called in the various phases
    of the instruction selection, but usually, we perform our matching only after
    the operations are legalized. The common implementation is to look at the operation
    and branch to a function handling the matching:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经标记了`or`操作以执行自定义组合。因此，指令选择器在调用生成的指令选择之前调用`PerformDAGCombine()`方法。此函数在指令选择的各个阶段调用，但通常，我们只在操作被合法化后执行匹配。通用实现是查看操作并跳转到处理匹配的函数。
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the `performORCombine()` method, we try to check whether we can generate
    a `set` instruction for the `or` operation. The `set` instruction sets a number
    of consecutive bits to 1, starting at a specified bit offset. This is a special
    case of the `or` operation, with the second operand being a constant matching
    this format. Because the `or` instruction of the M88k architecture works only
    on 16-bit constants, this matching is beneficial, because otherwise, we would
    have to synthesize the constant, resulting in two `or` instructions. This method
    uses the `isShiftedMask()` helper function to determine whether the constant values
    have the required form.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`performORCombine()`方法中，我们尝试检查是否可以为`or`操作生成`set`指令。`set`指令将一系列连续的位设置为1，从指定的位偏移开始。这是`or`操作的特殊情况，第二个操作数是匹配此格式的常量。由于M88k架构的`or`指令仅适用于16位常量，因此此匹配是有益的，否则，我们将不得不合成常量，导致两个`or`指令。此方法使用`isShiftedMask()`辅助函数来确定常量值是否具有所需的形式。
- en: 'If the second operand is a constant of the required form, then this function
    returns a node representing the `set` instruction. Otherwise, the return value
    `SDValue()` indicates that no matching pattern was found and that the generated
    DAG pattern matcher should be called:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二个操作数是所需形式的常量，则此函数返回表示`set`指令的节点。否则，返回值`SDValue()`表示未找到匹配模式，应调用生成的DAG模式匹配器：
- en: '[PRE55]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: To finish the implementation of the whole lowering process, we need to implement
    the `M88kFrameLowering` class. This class is responsible for handling the stack
    frame. This includes generating the prologue and epilogue code, handling register
    spills, and more. For the very first implementation, you can just provide empty
    functions. Obviously, for complete functionality, this class must be implemented.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成整个降低过程的实现，我们需要实现`M88kFrameLowering`类。这个类负责处理堆栈帧。这包括生成序言和结语代码，处理寄存器溢出等。对于第一个实现，您可以只提供空函数。显然，为了完整的功能，这个类必须被实现。
- en: This finishes our implementation of the instruction selection. Next, we look
    at how the final instructions are emitted.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对指令选择的实现。接下来，我们将看看最终的指令是如何发出的。
- en: Generating assembler instructions
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成汇编指令
- en: The instruction selection implemented in the previous sections lowers the IR
    instructions into `MachineInstr` instances. This is already a much lower representation
    of instruction, but it is not yet the machine code itself. The last pass in the
    backend pipeline is to emit the instructions, either as assembly text or into
    an object file. The `M88kAsmPrinter` machine pass is responsible for this task.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节中实现的指令选择将IR指令降低为`MachineInstr`实例。这已经是指令的更低表示，但还不是机器码本身。后端管道中的最后一步是发出指令，可以是汇编文本，也可以是目标文件。`M88kAsmPrinter`机器传递负责这项任务。
- en: Basically, this pass lowers a `MachineInstr` instance to an `MCInst` instance,
    which is then emitted to a streamer. The `MCInst` class represents the real machine
    code instruction. This additional lowering is required because the `MachineInstr`
    class still does not have all the required details.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这个传递将`MachineInstr`实例降低到`MCInst`实例，然后发出到一个流器。`MCInst`类表示真正的机器码指令。这种额外的降低是必需的，因为`MachineInstr`类仍然没有所有必需的细节。
- en: For the first approach, we can limit our implementation to overriding the `emitInstruction()`
    method. You need to override more methods for supporting several operand types,
    mainly to emit the correct relocations. This class is also responsible for handling
    inline assemblers, which you also need to implement if needed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种方法，我们可以将我们的实现限制在重写`emitInstruction()`方法。您需要重写更多的方法来支持几种操作数类型，主要是为了发出正确的重定位。这个类还负责处理内联汇编器，如果需要的话，您也需要实现它。
- en: 'Because the `M88kAsmPrinter` class is again a machine function pass, we also
    override the `getPassName()` method. The declaration of the class is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`M88kAsmPrinter`类再次是一个机器函数传递，我们还需要重写`getPassName()`方法。该类的声明如下：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Basically, we must handle two different cases in the `emitInstruction()` method.
    The `MachineInstr` instance can still have operands, which are not real machine
    instructions. For example, this is the case for the return `ret_flag` node, having
    the `RET` opcode value. On the M88k architecture, there is no `return` instruction.
    Instead, a jump to the address store in the `r1` register is made. Therefore,
    we need to construct the branch instruction when we detect the `RET` opcode. In
    the default case, the lowering only needs the information from the `MachineInstr`
    instance, and we delegate this task to the `M88kMCInstLower` class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，在`emitInstruction()`方法中我们必须处理两种不同的情况。`MachineInstr`实例仍然可以有操作数，这些操作数不是真正的机器指令。例如，对于返回`ret_flag`节点，具有`RET`操作码值。在M88k架构上，没有`return`指令。相反，会跳转到存储在`r1`寄存器中的地址。因此，当检测到`RET`操作码时，我们需要构造分支指令。在默认情况下，降低只需要`MachineInstr`实例的信息，我们将这个任务委托给`M88kMCInstLower`类：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `M88kMCInstLower` class has no predefined superclass. Its main purpose
    is to handle the various operand types. As we currently only have a very limited
    set of supported operand types, we can reduce this class to having only a single
    method. The `lower()` method sets the opcode and the operand of the `MCInst` instance.
    Only register and immediate operands are handled; other operand types are ignored.
    For the full implementation, we also need to handle memory addresses:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`M88kMCInstLower`类没有预定义的超类。它的主要目的是处理各种操作数类型。由于目前我们只有一组非常有限的支持的操作数类型，我们可以将这个类简化为只有一个方法。`lower()`方法设置`MCInst`实例的操作码和操作数。只处理寄存器和立即操作数；其他操作数类型被忽略。对于完整的实现，我们还需要处理内存地址。'
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The assembler printer needs a factory method, which is called during initialization,
    for example, from the `InitializeAllAsmPrinters()` method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编打印机需要一个工厂方法，在初始化期间调用，例如从`InitializeAllAsmPrinters()`方法：
- en: '[PRE59]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Finally, having lowered the instructions to real machine code instructions,
    we are still not done. We need to implement various small pieces for the MC layer,
    which we look at in the next section.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将指令降低到真实的机器码指令后，我们还没有完成。我们需要在MC层实现各种小的部分，我们将在下一节中讨论。
- en: Emitting machine code
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发出机器码
- en: The MC layer is responsible for emitting machine code in textual or binary form.
    Most of the functionality is either implemented in the various MC classes and
    only needs to be configured, or the implementation is generated from the target
    description.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: MC层负责以文本或二进制形式发出机器码。大部分功能要么在各种MC类中实现并且只需要配置，要么从目标描述生成实现。
- en: 'The initialization of the MC layer takes place in the `MCTargetDesc/M88kMCTargetDesc.cpp`
    file. The following classes are registered with the `TargetRegistry` singleton:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: MC层的初始化在`MCTargetDesc/M88kMCTargetDesc.cpp`文件中进行。以下类已在`TargetRegistry`单例中注册：
- en: '`M88kMCAsmInfo`: This class provides basic information, such as the size of
    a code pointer, the direction of stack growth, the comment symbol, or the name
    of assembler directives.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M88kMCAsmInfo`：这个类提供基本信息，比如代码指针的大小，堆栈增长的方向，注释符号，或者汇编指令的名称。'
- en: '`M88MCInstrInfo`: This class holds information about instructions, for example,
    the name of an instruction.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M88MCInstrInfo`：这个类保存有关指令的信息，例如指令的名称。'
- en: '`M88kRegInfo`: This class provides information about registers, for example,
    the name of a register, or which register is the stack pointer.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M88kRegInfo`：此类提供有关寄存器的信息，例如寄存器的名称或哪个寄存器是堆栈指针。'
- en: '`M88kSubtargetInfo`: This class holds the data of the scheduling model and
    the methods to parse and set CPU features.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M88kSubtargetInfo`：此类保存调度模型的数据和解析和设置CPU特性的方法。'
- en: '`M88kMCAsmBackend`: This class provides helper methods to get the target-dependent
    relocation data for fixups. It also contains factory methods for the object writer
    classes.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M88kMCAsmBackend`：此类提供了获取与目标相关的修正数据的辅助方法。它还包含了用于对象编写器类的工厂方法。'
- en: '`M88kMCInstPrinter`: This class contains helper methods to textually print
    instructions and operands. If an operand defines a custom print method in the
    target description, then it must be implemented in this class.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M88kMCInstPrinter`：此类包含一些辅助方法，用于以文本形式打印指令和操作数。如果操作数在目标描述中定义了自定义打印方法，则必须在此类中实现。'
- en: '`M88kMCCodeEmitter`: This class writes the encoding of an instruction to a
    stream.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M88kMCCodeEmitter`：此类将指令的编码写入流中。'
- en: Depending on the scope of a backend implementation, we do not need to register
    and implement all of these classes. You can omit to register the `MCInstPrinter`
    subclass if you do not support textual assembler output. If you do not add support
    writing of object files, you can omit the `MCAsmBackend` and `MCCodeEmitter` subclasses.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 根据后端实现的范围，我们不需要注册和实现所有这些类。如果不支持文本汇编器输出，则可以省略注册`MCInstPrinter`子类。如果不支持编写目标文件，则可以省略`MCAsmBackend`和`MCCodeEmitter`子类。
- en: 'We begin the file by including the generated parts and providing factory methods
    for it:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先包含生成的部分，并为其提供工厂方法：
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We also provide some factory methods for classes implemented in other files:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为其他文件中实现的类提供了一些工厂方法：
- en: '[PRE61]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To initialize the MC layer, we only need to register all the factory methods
    with the `TargetRegistry` singleton:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化MC层，我们只需要使用`TargetRegistry`单例注册所有工厂方法：
- en: '[PRE62]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Additionally, in the `MCTargetDesc/M88kTargetDesc.h` header file, we also need
    to include the header portion of the generated source, to make it available to
    others, too:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`MCTargetDesc/M88kTargetDesc.h`头文件中，我们还需要包含生成源的头部部分，以便其他人也可以使用：
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We put the source files for the registered classes all in the `MCTargetDesc`
    directory. For the first implementation, it is sufficient to provide just stubs
    for these classes. For example, as long as support for memory addresses is not
    added to the target description, no fixups will be generated. The `M88kMCAsmInfo`
    class can be very quickly implemented, as we only need to set some properties
    in the constructor:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将注册类的源文件都放在`MCTargetDesc`目录中。对于第一个实现，只需为这些类提供存根即可。例如，只要目标描述中没有添加对内存地址的支持，就不会生成修正。`M88kMCAsmInfo`类可以非常快速地实现，因为我们只需要在构造函数中设置一些属性：
- en: '[PRE64]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Having implemented the support classes for the MC layer, we are now able to
    emit the machine code into files.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在为MC层实现了支持类之后，我们现在能够将机器码输出到文件中。
- en: 'In the next section, we implement the class required for disassembling, which
    is the reverse action: turning an object file back into assembler text.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们实现了用于反汇编的类，这是相反的操作：将目标文件转换回汇编器文本。
- en: Adding support for disassembling
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加反汇编支持
- en: The definition of the instructions in the target description allows the construction
    of decoder tables, which are used to disassemble an object file into a textual
    assembler. The decoder tables and a decoder function are generated by the `llvm-tblgen`
    tool. Besides the generated code, we only need to provide the code to register
    and initialize the `M88kDisassembler` class and some helper functions to decode
    registers and operands. We place the implementation in the `Disassembler/M88kDisassembler.cpp`
    file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 目标描述中指令的定义允许构建解码器表，用于将目标文件反汇编为文本汇编器。解码器表和解码器函数由`llvm-tblgen`工具生成。除了生成的代码，我们只需要提供注册和初始化`M88kDisassembler`类以及一些辅助函数来解码寄存器和操作数的代码。我们将实现放在`Disassembler/M88kDisassembler.cpp`文件中。
- en: 'The `getInstruction()` method of the `M88kDisassembler` class does the decoding
    work. It takes an array of bytes as input and decodes the next instruction into
    an instance of the `MCInst` class. The class declaration is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`M88kDisassembler`类的`getInstruction()`方法执行解码工作。它以字节数组作为输入，并将下一条指令解码为`MCInst`类的实例。类声明如下：'
- en: '[PRE65]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The generated classes refer unqualified to the `DecodeStatus` enumeration, so
    we have to make this name visible.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的类未经限定地引用`DecodeStatus`枚举，因此我们必须使此名称可见。
- en: 'To initialize the disassembler, we define a factory function that simply instantiates
    a new object:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化反汇编器，我们定义一个简单的工厂函数来实例化一个新对象：
- en: '[PRE66]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the `LLVMInitializeM88kDisassembler()` function, we register the factory
    function at the target registry:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LLVMInitializeM88kDisassembler()`函数中，我们在目标注册表中注册工厂函数：
- en: '[PRE67]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This function is called from the `InitializeAllDisassemblers()` function or
    the `InitializeNativeTargetDisassembler()` function, when the LLVM core libraries
    are initialized.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当LLVM核心库初始化时，此函数将从`InitializeAllDisassemblers()`函数或`InitializeNativeTargetDisassembler()`函数中调用。
- en: The generated decoder function expects helper functions to decode registers
    and operands. The reason for this is that the encoding of those elements often
    involves special cases not expressed in the target description. For example, the
    distance between two instructions is always even, so the lowest bit can be ignored
    because it is always zero.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的解码器函数需要辅助函数来解码寄存器和操作数。原因是这些元素的编码通常涉及目标描述中未表达的特殊情况。例如，两条指令之间的距离总是偶数，因此可以忽略最低位，因为它总是零。
- en: 'To decode the registers, the `DecodeGPRRegisterClass()` function has to be
    defined. The 32 registers are encoded with a number between 0 and 31, and we can
    use the static `GPRDecoderTable` table to map between the encoding and the generated
    enumeration for the registers:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要解码寄存器，必须定义`DecodeGPRRegisterClass()`函数。32个寄存器用0到31之间的数字进行编码，我们可以使用静态的`GPRDecoderTable`表来在编码和生成的寄存器枚举之间进行映射：
- en: '[PRE68]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'All other required decoder functions follow the same pattern as the `DecodeGPRRegisterClass()`
    function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他所需的解码器函数都遵循与`DecodeGPRRegisterClass()`函数相同的模式：
- en: Check that the value to decode fits the required size restriction. If not, then
    return the `MCDisassembler::Fail` value.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查要解码的值是否符合所需的大小限制。如果不符合，则返回`MCDisassembler::Fail`值。
- en: Decode the value and add it to the `MCInst` instance.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码值并将其添加到`MCInst`实例中。
- en: Return `MCDisassembler::Success` to indicate success.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`MCDisassembler::Success`以指示成功。
- en: 'Then, we can include the generated decoder tables and function:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以包含生成的解码器表和函数：
- en: '`#include "M88kGenDisassemblerTables.inc"`'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`#include "M88kGenDisassemblerTables.inc"`'
- en: Finally, we are able to define the `getInstruction()` method. This method has
    two result values, the decoded instruction and the size of the instruction. If
    the byte array is too small, the size must be set to `0`. This is important because
    the size parameter is used by the caller to advance the pointer to the next memory
    location, even if the decoding failed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以定义`getInstruction()`方法。该方法有两个结果值，解码指令和指令的大小。如果字节数组太小，则大小必须设置为`0`。这很重要，因为大小参数被调用者用来将指针推进到下一个内存位置，即使解码失败也是如此。
- en: 'In the case of the M88k architecture, the method is simple, because all instructions
    are 4 bytes long. So, after extracting 4 bytes from the array, the generated decoder
    function can be called:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于M88k架构，该方法很简单，因为所有指令都是4个字节长。因此，在从数组中提取4个字节后，可以调用生成的解码器函数：
- en: '[PRE69]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This finishes the implementation of the disassembler.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了反汇编器的实现。
- en: After we have implemented all the classes, we only need to set up the build
    system to pick up the new target backend, which we will add in the next section.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了所有类之后，我们只需要设置构建系统以选择新的目标后端，这将在下一节中添加。
- en: Piecing it all together
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有部分组合在一起
- en: 'Our new target, located in the `llvm/lib/Target/M88k` directory, needs to be
    integrated into the build system. To make development easy, we add it as an experimental
    target in the `llvm/CMakeLists.txt` file. We replace the existing empty string
    with the name of our target:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新目标位于`llvm/lib/Target/M88k`目录中，需要集成到构建系统中。为了方便开发，我们将其添加为`llvm/CMakeLists.txt`文件中的实验性目标。我们用我们的目标名称替换现有的空字符串：
- en: '[PRE70]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We also need to provide a `llvm/lib/Target/M88k/CMakeLists.txt` file to build
    our target. Besides listing the C++ files for the target, it also defines the
    generation of the source from the target description.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要提供一个`llvm/lib/Target/M88k/CMakeLists.txt`文件来构建我们的目标。除了列出目标的C++文件外，它还定义了从目标描述生成源代码。
- en: Generating all the types of sources from the target description
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 从目标描述生成所有类型的源
- en: Different runs of the `llvm-tblgen` tool generate different portions of C++
    code. However, I recommend adding the generation of all parts to the `CMakeLists.txt`
    file. The reason for this is that it provides better checking. For example, if
    you make an error with the instruction encoding, then this is only caught during
    the generation of the code for the disassembler. So, even if you do not plan to
    support the disassembler, it is still worth generating the source for it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm-tblgen`工具的不同运行会生成不同部分的C++代码。然而，我建议将所有部分的生成都添加到`CMakeLists.txt`文件中。原因是这样做提供了更好的检查。例如，如果您在指令编码中出错，那么只有在反汇编器代码生成期间才会捕获到错误。因此，即使您不打算支持反汇编器，生成其源代码仍然是值得的。'
- en: 'The file looks as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 文件如下所示：
- en: 'First, we define a new LLVM component named `M88k`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个名为`M88k`的新的LLVM组件：
- en: '[PRE71]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, we name the target description file, add statements to generate the various
    source pieces with TableGen, and define a public target for it:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们命名目标描述文件，添加语句以使用TableGen生成各种源代码片段，并为其定义一个公共目标：
- en: '[PRE72]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We must list all the source files the new component is made of:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须列出新组件由哪些源文件组成：
- en: '[PRE73]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Last, we include the directories with the MC and disassembler classes in the
    build:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在构建中包含了MC和反汇编器类的目录：
- en: '[PRE74]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now we are ready to compile the LLVM with the new backend target. On the build
    directory, we can simply run this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备用新的后端目标编译LLVM。在构建目录中，我们可以简单地运行这个命令：
- en: '[PRE75]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This detects the changed `CmakeLists.txt` file, runs the configuration step
    again, and compiles the new backend. To check that all went well, you can run
    this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检测到更改的`CmakeLists.txt`文件，再次运行配置步骤，并编译新的后端。要检查一切是否顺利，您可以运行这个命令：
- en: '[PRE76]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output should contain the following line in the `Registered Target` section:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该在`Registered Target`部分包含以下行：
- en: '[PRE77]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Hurray! We finished the backend implementation. Let''s try it out. The following
    `f1` function in LLVM IR performs a bitwise AND operation between the two parameters
    of the function and returns the result. Save it in the `example.ll` file:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！我们完成了后端的实现。让我们试试。LLVM IR中的以下`f1`函数执行函数的两个参数之间的按位AND操作，并返回结果。将其保存在`example.ll`文件中：
- en: '[PRE78]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Run the `llc` tool as follows to see the generated assembler text on the console:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`llc`工具如下以在控制台上查看生成的汇编文本：
- en: '[PRE79]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The output is in valid GNU syntax. For the `f1` function, `and` and `jmp` instructions
    are generated. The parameters are passed in the `%r2` and `%r3` registers, which
    are used in the `and` instruction. The result is stored in the `%r2` register,
    which is also the register to return 32-bit values. The return from the function
    is realized with a branch to the address hold in the `%r1` register, which also
    matches the ABI. It all looks very good!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 输出符合有效的GNU语法。对于`f1`函数，生成了`and`和`jmp`指令。参数传递在`%r2`和`%r3`寄存器中，这些寄存器在`and`指令中被使用。结果存储在`%r2`寄存器中，这也是返回32位值的寄存器。函数的返回通过跳转到`%r1`寄存器中保存的地址来实现，这也符合ABI。一切看起来都很不错！
- en: With the topics you learned about in this chapter, you can now implement your
    own LLVM backend. For many relatively simple CPUs such as **digital signal processors**
    (**DSPs**), you do not need to implement more than we did here. Of course, the
    implementation for the M88k CPU architecture does not yet support all features
    of the architecture, for example, floating-point registers. However, you now know
    all the important concepts applied in LLVM backend development, and with this,
    you will be able to add any missing parts!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章学到的知识，你现在可以实现自己的LLVM后端。对于许多相对简单的CPU，比如数字信号处理器（DSP），你不需要实现更多的内容。当然，M88k CPU架构的实现还不支持所有的特性，例如浮点寄存器。然而，你现在已经了解了LLVM后端开发中应用的所有重要概念，有了这些，你将能够添加任何缺失的部分！
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to develop a new backend target for LLVM. You
    first collected the required documentation and made LLVM aware of the new architecture
    by enhancing the `Triple` class. The documentation also includes the relocation
    definition for the ELF file format, and you added support for that to LLVM.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何为LLVM开发一个新的后端目标。你首先收集了所需的文档，并通过增强`Triple`类使LLVM意识到了新的架构。文档还包括ELF文件格式的重定位定义，你还为LLVM添加了对此的支持。
- en: You learned about the different parts the target description contains, and using
    the C++ source generated from it, you learned how to implement an instruction
    selection. For outputting the generated code, you developed an assembler printer
    and learned which support classes are needed to write to an object file. You also
    learned how to add support for disassembling, which is used to turn an object
    file back into assembler text. Lastly, you extended the build system to include
    the new target in the build.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解了目标描述包含的不同部分，并使用从中生成的C++源代码，学会了如何实现指令选择。为了输出生成的代码，你开发了一个汇编打印程序，并学会了需要哪些支持类来写入目标文件。你还学会了如何添加反汇编支持，用于将目标文件转换回汇编文本。最后，你扩展了构建系统，将新的目标包含在构建中。
- en: You are now equipped with everything you need to use LLVM in creative ways in
    your own projects. The LLVM ecosystem is very active, and new features are added
    all the time, so be sure to follow all developments!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经具备了在自己的项目中以创造性方式使用LLVM所需的一切。LLVM生态系统非常活跃，不断添加新特性，所以一定要关注所有的发展！
- en: Being a compiler developer myself, it was a pleasure for me to write about LLVM
    and discover some new features along the way. Have fun with LLVM!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个编译器开发者，能够写关于LLVM并在过程中发现一些新特性对我来说是一种乐趣。享受LLVM的乐趣吧！
