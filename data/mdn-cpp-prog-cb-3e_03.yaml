- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Exploring Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索函数
- en: Functions are a fundamental concept in programming; regardless of what topic
    we are discussing, we will end up talking about functions. Trying to cover everything
    about functions in a single chapter is not only hard but also not very rational.
    Being a fundamental element of the language, functions are encountered in every
    recipe in this book. This chapter, however, covers modern language features related
    to functions and callable objects, with a focus on lambda expressions, concepts
    from functional languages such as higher-order functions, and function templates.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是编程中的基本概念；无论我们讨论什么主题，最终都会谈到函数。试图在一个章节中涵盖关于函数的所有内容不仅困难，而且不太合理。作为语言的基本元素，函数出现在本书的每一道食谱中。然而，这一章涵盖了与函数和可调用对象相关的现代语言特性，重点关注lambda表达式、来自函数式语言的概念，如高阶函数和函数模板。
- en: 'The recipes included in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含的食谱如下：
- en: Defaulted and deleted functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认化和删除函数
- en: Using lambdas with standard algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准算法与lambda表达式
- en: Using generic and template lambdas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型和模板lambda
- en: Writing a recursive lambda
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写递归lambda
- en: Writing function templates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写函数模板
- en: Writing a function template with a variable number of arguments
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写具有可变参数数量的函数模板
- en: Using fold expressions to simplify variadic function templates
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用折叠表达式简化变长函数模板
- en: Implementing the higher-order functions `map` and `fold`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现高阶函数 `map` 和 `fold`
- en: Composing functions into a higher-order function
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数组合成高阶函数
- en: Uniformly invoking anything callable
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统一调用任何可调用对象
- en: We will start this chapter by learning about a feature that makes it easier
    for us to provide special class member functions or prevent any function (member
    or non-member) from being invoked.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个章节开始，学习一个使我们可以更容易地提供特殊类成员函数或防止任何函数（成员或非成员）被调用的特性。
- en: Defaulted and deleted functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认化和删除函数
- en: In C++, classes have special members (constructors, a destructor, and assignment
    operators) that may be either implemented by default by the compiler or supplied
    by the developer. However, the rules for what can be default implemented are a
    bit complicated and can lead to problems. On the other hand, developers sometimes
    want to prevent objects from being copied, moved, or constructed in a particular
    way.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，类有特殊的成员（构造函数、析构函数和赋值运算符），这些成员可能由编译器默认实现，或者由开发者提供。然而，可以默认实现的规则有点复杂，可能会导致问题。另一方面，开发者有时希望防止对象以特定方式被复制、移动或构造。
- en: This is possible by implementing different tricks using these special members.
    The C++11 standard has simplified many of these by allowing functions to be deleted
    or defaulted in the manner we will see in the next section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用这些特殊成员实现不同的技巧来实现。C++11标准通过允许函数被删除或默认，简化了其中许多规则，我们将在下一节中看到这些规则。
- en: Getting started
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'For this recipe, you need to be familiar with the following concepts:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你需要熟悉以下概念：
- en: Special member functions (default constructor, destructor, copy constructor,
    move constructor, copy assignment operator, and move assignment operator)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊成员函数（默认构造函数、析构函数、拷贝构造函数、移动构造函数、拷贝赋值运算符和移动赋值运算符）
- en: The copyable concept (a class features a copy constructor and copy assignment
    operator, making it possible to create copies)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可拷贝的概念（一个类具有拷贝构造函数和拷贝赋值运算符，使得创建副本成为可能）
- en: The movable concept (a class features a move constructor and a move assignment
    operator, making it possible to move objects)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移动的概念（一个类具有移动构造函数和移动赋值运算符，使得移动对象成为可能）
- en: With this in mind, let’s learn how to define default and deleted special functions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们学习如何定义默认和删除的特殊函数。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use the following syntax to specify how functions should be handled:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下语法来指定函数应该如何处理：
- en: 'To default a function, use `=default` instead of the function body. Only special
    class member functions for which the compiler can provide default implementations
    can be defaulted:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将函数默认化，请使用 `=default` 而不是函数体。只有编译器可以提供默认实现的特殊类成员函数才能被默认化：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To delete a function, use `=delete` instead of the function body. Any function,
    including non-member functions, can be deleted:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除一个函数，请使用 `=delete` 而不是函数体。任何函数，包括非成员函数，都可以被删除：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use defaulted and deleted functions to achieve various design goals, such as
    the following examples:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认化和删除函数来实现各种设计目标，例如以下示例：
- en: 'To implement a class that is not copyable and implicitly not movable, declare
    the copy constructor and the copy assignment operator as deleted:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要实现一个不可拷贝且隐式不可移动的类，请将拷贝构造函数和拷贝赋值运算符声明为已删除：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To implement a class that is not copyable but is movable, declare the copy
    operations as deleted and explicitly implement the move operations (and provide
    any additional constructors that are needed):'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要实现一个不可拷贝但可移动的类，请将拷贝操作声明为已删除，并显式实现移动操作（以及提供所需的任何其他构造函数）：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To ensure a function is called only with objects of a specific type, and perhaps
    prevent type promotion, provide deleted overloads for the function (the following
    example with free functions can also be applied to any class member functions):'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要确保函数仅由特定类型的对象调用，并且可能防止类型提升，请为该函数提供已删除的重载（以下示例中的自由函数也可以应用于任何类的成员函数）：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A class has several special members that can be implemented, by default, by
    the compiler. These are the default constructor, copy constructor, move constructor,
    copy assignment, move assignment, and destructor (for a discussion on move semantics,
    refer to the *Implementing move semantics* recipe in *Chapter 9*, *Robustness
    and Performance*). If you don’t implement them, then the compiler does it so that,
    if needed, instances of a class can be created, moved, copied, and destructed.
    However, if you explicitly provide one or more of these special methods, then
    the compiler will not generate the others according to the following rules:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类有多个可以实现的特殊成员，默认情况下可以由编译器实现。这些是默认构造函数、拷贝构造函数、移动构造函数、拷贝赋值、移动赋值和析构函数（关于移动语义的讨论，请参阅第9章“健壮性和性能”中的*实现移动语义*配方）。如果您不实现它们，则编译器会根据以下规则生成它们。然而，如果您显式提供了一个或多个这些特殊方法，则编译器将不会根据以下规则生成其他方法：
- en: If a user-defined constructor exists, the default constructor is not generated
    by default.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在用户定义的构造函数，则默认不生成默认构造函数。
- en: If a user-defined virtual destructor exists, the default destructor is not generated.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在用户定义的虚析构函数，则不生成默认析构函数。
- en: If a user-defined move constructor or move assignment operator exists, then
    the copy constructor and copy assignment operator are not generated by default.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在用户定义的移动构造函数或移动赋值运算符，则默认不生成拷贝构造函数和拷贝赋值运算符。
- en: If a user-defined copy constructor, move constructor, copy assignment operator,
    move assignment operator, or destructor exists, then the move constructor and
    move assignment operator are not generated by default.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在用户定义的拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符或析构函数，则默认不生成移动构造函数和移动赋值运算符。
- en: If a user-defined copy constructor or destructor exists, then the copy assignment
    operator is generated by default.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在用户定义的拷贝构造函数或析构函数，则默认生成拷贝赋值运算符。
- en: If a user-defined copy assignment operator or destructor exists, then the copy
    constructor is generated by default.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在用户定义的拷贝赋值运算符或析构函数，则默认生成拷贝构造函数。
- en: Note that the last two rules in the preceding list are deprecated rules and
    may no longer be supported by your compiler.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面列表中的最后两条规则已被弃用，并且可能不再被您的编译器支持。
- en: Sometimes, developers need to provide empty implementations of these special
    members or hide them in order to prevent the instances of the class from being
    constructed in a specific manner. A typical example is a class that is not supposed
    to be copyable. The classical pattern for this is to provide a default constructor
    and hide the copy constructor and copy assignment operators. While this works,
    the explicitly defined default constructor ensures the class is no longer considered
    trivial and, therefore, a **Plain Old Data** (**POD**) type. The modern alternative
    to this is using a deleted function, as shown in the preceding section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，开发者需要提供这些特殊成员的空实现或隐藏它们，以防止类的实例以特定方式构造。一个典型的例子是一个不应该可拷贝的类。这种情况下，经典的模式是提供一个默认构造函数并隐藏拷贝构造函数和拷贝赋值运算符。虽然这可行，但显式定义的默认构造函数确保该类不再被视为平凡类型，因此是一个**纯旧数据**（**POD**）类型。现代的替代方法是使用已删除的函数，如前节所示。
- en: 'When the compiler encounters `=default` in the definition of a function, it
    will provide the default implementation. The rules for special member functions
    mentioned earlier still apply. Functions can be declared `=default` outside the
    body of a class if and only if they are inlined:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器在函数的定义中遇到`=default`时，它将提供默认实现。前面提到的特殊成员函数的规则仍然适用。如果函数是内联的，那么只有在类体外部声明函数时才能使用`=default`：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The defaulted implementations have several benefits, including the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认实现有几个好处，包括以下内容：
- en: Can be more efficient than the explicit ones.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能比显式实现更高效。
- en: Non-defaulted implementations, even if they are empty, are considered non-trivial,
    and that affects the semantics of the type, which becomes non-trivial (and, therefore,
    non-POD).
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非默认实现，即使它们是空的，也被认为是非平凡的，这影响了类型的语义，使得类型变得非平凡（因此，非POD）。
- en: Helps the user not write explicit default implementations. For instance, if
    a user-defined move constructor is present, then the copy constructor and the
    copy assignment operator are not provided by default by the compiler. However,
    you can still default explicitly and ask the compiler to provide them so that
    you don’t have to do it manually.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助用户不编写显式的默认实现。例如，如果存在用户定义的移动构造函数，那么编译器不会默认提供拷贝构造函数和拷贝赋值运算符。然而，你仍然可以显式地默认它们，并要求编译器提供它们，这样你就不必手动做了。
- en: 'When the compiler encounters `=delete` in the definition of a function, it
    will prevent the calling of the function. However, the function is still considered
    during overload resolution, and only if the deleted function is the best match
    does the compiler generate an error. For example, by giving the previously defined
    overloads for the `run()` function, only calls with long integers are possible.
    Calls with arguments of any other type (including `int`, for which an automatic
    type promotion to `long` exists) will determine a deleted overload to be considered
    the best match and, therefore, the compiler will generate an error:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器在函数的定义中遇到`=delete`时，它将阻止函数的调用。然而，函数在重载解析期间仍然被考虑，只有当删除的函数是最好的匹配时，编译器才会生成错误。例如，通过为之前定义的`run()`函数的重载提供，只有使用长整数的调用是可能的。使用任何其他类型（包括自动提升到`long`的`int`）的参数的调用将确定删除的重载被认为是最佳匹配，因此编译器将生成错误：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that previously declared functions cannot be deleted as the `=delete`
    definition must be the first declaration in a translation unit:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，之前声明的函数不能被删除，因为`=delete`定义必须是翻译单元中的第一个声明：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The rule of thumb (also known as the *Rule of Five*) for class special member
    functions is that if you explicitly define any copy constructor, move constructor,
    copy assignment operator, move assignment operator, or destructor, then you must
    either explicitly define or default all of them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类特殊成员函数的规则（也称为“五规则”）是，如果你明确定义了任何拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符或析构函数，那么你必须要么明确定义，要么默认所有这些。
- en: The user-defined destructor, copy-constructor, and copy assignment operator
    are necessary because objects are constructed from copies in various situations
    (like passing parameters to functions). If they are not user-defined, they are
    provided by the compiler, but their default implementation may be wrong. If the
    class manages resources, then the default implementation does a shallow copy,
    meaning that it copies the value of the handle of the resource (such as a pointer
    to an object) and not the resource itself. In such cases, a user-defined implementation
    must do a deep copy that copies the resource, not the handle to it. The presence
    of the move constructor and move assignment operator are desirable in this case
    because they represent a performance improvement. Lacking these two is not an
    error but a missed optimization opportunity.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的析构函数、拷贝构造函数和拷贝赋值运算符是必要的，因为在各种情况下对象都是从副本中构建的（例如将参数传递给函数）。如果它们没有被用户定义，编译器会提供它们，但它们的默认实现可能是不正确的。如果一个类管理资源，那么默认实现执行的是浅拷贝，这意味着它复制了资源句柄的值（例如指向对象的指针）而不是资源本身。在这种情况下，用户定义的实现必须执行深拷贝，即复制资源而不是其句柄。在这种情况下，移动构造函数和移动赋值运算符的存在是可取的，因为它们代表了性能的提升。缺少这两个运算符不是错误，但是一个被错过的优化机会。
- en: Opposed to the Rule of Five on the one hand but complementing it on the other
    is the so-called *Rule of Zero*. This rule states that unless a class deals with
    ownership of resources, it should have no custom destructors, copy and move constructors,
    and, respectively, copy and move assignment operators.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面与五规则相对立，另一方面与之相补充的是所谓的零规则。该规则指出，除非类处理资源所有权，否则它不应有自定义析构函数、拷贝和移动构造函数，以及相应的拷贝和移动赋值运算符。
- en: 'When designing classes, you should follow these guidelines:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计类时，你应该遵循以下指南：
- en: A class that manages a resource should have the single responsibility of handling
    the ownership of that resource. Such a class must follow the Rule of Five and
    implement a custom destructor, copy/move constructors, and copy/move assignment
    operators.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理资源的类应该只负责处理该资源的所有权。这样的类必须遵循五规则，并实现自定义析构函数、拷贝/移动构造函数和拷贝/移动赋值运算符。
- en: A class that doesn’t manage resources should not have a custom destructor, copy/move
    constructors, and copy/move assignment operators (therefore following the Rule
    of Zero).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不管理资源的类不应该有自定义析构函数、拷贝/移动构造函数和拷贝/移动赋值运算符（因此遵循零规则）。
- en: See also
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Uniformly invoking anything callable*, to learn how to use `std::invoke()`
    to invoke any callable object with the provided arguments'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*统一调用任何可调用对象*，了解如何使用`std::invoke()`以提供的参数调用任何可调用对象'
- en: Using lambdas with standard algorithms
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lambda表达式与标准算法
- en: One of the most important modern features of C++ is lambda expressions, also
    referred to as lambda functions or simply lambdas. Lambda expressions enable us
    to define anonymous function objects that can capture variables in the scope and
    be invoked or passed as arguments to functions. They avoid having to define named
    functions or function objects. Lambdas are useful for many purposes, and in this
    recipe, we will learn how to use them with standard algorithms.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: C++最现代的特性之一是lambda表达式，也称为lambda函数或简称为lambdas。Lambda表达式使我们能够定义匿名函数对象，这些对象可以捕获作用域内的变量，并作为参数调用或传递给函数。它们避免了定义命名函数或函数对象的必要性。Lambda表达式在许多用途中都很有用，在这个菜谱中，我们将学习如何使用它们与标准算法一起。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll discuss standard algorithms that take an argument that’s
    a function or predicate that’s applied to the elements it iterates through. You
    need to know what unary and binary functions are and what predicates and comparison
    functions are. You also need to be familiar with function objects because lambda
    expressions are syntactic sugar for function objects.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论接受一个函数或谓词作为参数的标准算法，该函数或谓词应用于它迭代的元素。你需要了解一元和二元函数是什么，以及谓词和比较函数是什么。你还应该熟悉函数对象，因为lambda表达式是函数对象的语法糖。
- en: How to do it...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You should prefer to use lambda expressions to pass callbacks to standard algorithms
    instead of functions or function objects:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该优先使用lambda表达式将回调传递给标准算法，而不是函数或函数对象：
- en: 'Define anonymous lambda expressions in the place of the call if you only need
    to use the lambda in a single place:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只需要在调用处定义匿名lambda表达式，就使用它：
- en: '[PRE8]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Define a named lambda, that is, one assigned to a variable (usually with the
    `auto` specifier for the type), if you need to call the lambda in multiple places:'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要在多个地方调用lambda，定义一个命名的lambda，即分配给变量的lambda（通常使用`auto`指定器指定类型）：
- en: '[PRE9]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use generic lambda expressions if you need lambdas that only differ in terms
    of their argument types (available since C++14):'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要lambda表达式仅在参数类型方面有所不同（自C++14起可用），请使用泛型lambda表达式：
- en: '[PRE10]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The non-generic lambda expression shown in the second bullet takes a constant
    integer and returns `true` if it is greater than `0`, or `false` otherwise. The
    compiler defines an unnamed function object with the call operator, which has
    the signature of the lambda expression:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点中显示的非泛型lambda表达式接受一个常量整数，如果它大于`0`则返回`true`，否则返回`false`。编译器定义了一个无名的函数对象，具有lambda表达式的签名，该签名具有调用操作符：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The way the unnamed function object is defined by the compiler depends on the
    way we define the lambda expression that can capture variables, use the `mutable`
    specifier or exception specifications, or have a trailing return type. The `__lambda_name__`
    function object shown earlier is actually a simplification of what the compiler
    generates because it also defines a default copy and move constructor, a default
    destructor, and a deleted assignment operator.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器定义未命名函数对象的方式取决于我们定义的可以捕获变量的lambda表达式的方式，使用`mutable`指定符或异常指定符，或者有尾随返回类型。前面展示的`__lambda_name__`函数对象实际上是编译器生成的简化版本，因为它还定义了一个默认的拷贝构造函数、默认析构函数和一个删除的赋值运算符。
- en: It must be well understood that the lambda expression is actually a class. In
    order to call it, the compiler needs to instantiate an object of the class. The
    object instantiated from a lambda expression is called a *lambda closure*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 必须清楚了解lambda表达式实际上是一个类。为了调用它，编译器需要实例化类的对象。从lambda表达式实例化的对象被称为*lambda闭包*。
- en: 'In the following example, we want to count the number of elements in a range
    that are greater than or equal to 5 and less than or equal to 10\. The lambda
    expression, in this case, will look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们想要计算一个范围中大于或等于5且小于或等于10的元素数量。在这种情况下，lambda表达式将看起来像这样：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This lambda captures two variables, `minimum` and `maximum`, by copy (that
    is, value). The resulting unnamed function object created by the compiler looks
    very much like the one we defined earlier. With the default and deleted special
    members mentioned earlier, the class looks like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个lambda通过拷贝（即值）捕获了两个变量，`minimum`和`maximum`。编译器创建的未命名函数对象看起来非常像我们之前定义的。使用前面提到的默认和删除的特殊成员，类看起来像这样：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The lambda expression can capture variables by copy (or value) or by reference,
    and different combinations of the two are possible. However, it is not possible
    to capture a variable multiple times and it is only possible to have `&` or `=`
    at the beginning of the capture list.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式可以通过拷贝（或值）或通过引用捕获变量，并且这两种组合的不同组合是可能的。然而，无法多次捕获一个变量，并且捕获列表的开头只能有`&`或`=`。
- en: 'A lambda expression can access the following kinds of variables: variables
    captured from the enclosing scope, lambda parameters, variables declared locally
    within its body, class data members when the lambda is declared inside a class
    and the pointer is captured by the lambda, and any variable with static storage
    duration such as global variables.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式可以访问以下类型的变量：从封装作用域捕获的变量、lambda参数、在其体内局部声明的变量、当lambda在类内部声明且指针被lambda捕获时的类数据成员，以及任何具有静态存储期的变量，如全局变量。
- en: A lambda can only capture variables from an enclosing function scope. It cannot
    capture variables with static storage duration (that is, variables declared in
    a namespace scope or with the `static` or `external` specifier).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda只能捕获封装函数作用域中的变量。它不能捕获具有静态存储期的变量（即，在命名空间作用域中声明的变量或使用`static`或`external`指定符声明的变量）。
- en: 'The following table shows various combinations for lambda capture semantics:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了lambda捕获语义的各种组合：
- en: '| **Lambda** | **Description** |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| **Lambda** | **描述** |'
- en: '| `[](){}` | Does not capture anything. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `[](){}` | 不捕获任何内容。|'
- en: '| `[&](){}` | Captures everything by reference. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `[&](){}` | 通过引用捕获所有内容。|'
- en: '| `[=](){}` | Captures everything by copy. Implicit capturing of the pointer
    `this` is deprecated in C++20. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `[=](){}` | 通过拷贝捕获所有内容。在C++20中，隐式捕获指针`this`已被弃用。|'
- en: '| `[&x](){}` | Captures only `x` by reference. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `[&x](){}` | 仅通过引用捕获`x`。|'
- en: '| `[x](){}` | Captures only `x` by copy. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `[x](){}` | 仅通过拷贝捕获`x`。|'
- en: '| `[&x...](){}` | Captures pack extension `x` by reference. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `[&x...](){}` | 通过引用捕获pack扩展`x`。|'
- en: '| `[x...](){}` | Captures pack extension `x` by copy. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `[x...](){}` | 通过拷贝捕获pack扩展`x`。|'
- en: '| `[&, x](){}` | Captures everything by reference except for `x` that is captured
    by copy. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `[&, x](){}` | 通过引用捕获所有内容，除了通过拷贝捕获的`x`。|'
- en: '| `[=, &x](){}` | Captures everything by copy except for `x` that is captured
    by reference. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `[=, &x](){}` | 通过拷贝捕获所有内容，除了通过引用捕获的`x`。|'
- en: '| `[&, this](){}` | Captures everything by reference except for the pointer
    `this`, which is captured by copy (`this` is always captured by copy). |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `[&, this](){}` | 通过引用捕获所有内容，除了通过拷贝捕获的指针`this`（`this`总是通过拷贝捕获）。|'
- en: '| `[x, x](){}` | Error; `x` is captured twice. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `[x, x](){}` | 错误；`x`被捕获两次。|'
- en: '| `[&, &x](){}` | Error; everything is captured by reference, and we cannot
    specify again to capture `x` by reference. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `[&, &x](){}` | 错误；所有内容都是通过引用捕获的，我们不能再指定再次通过引用捕获 `x`。|'
- en: '| `[=, =x](){}` | Error; everything is captured by copy, and we cannot specify
    again to capture `x` by copy. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `[=, =x](){}` | 错误；所有内容都是通过复制捕获的，我们不能再指定再次通过复制捕获 `x`。|'
- en: '| `[&this](){}` | Error; the pointer `this` is always captured by copy. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `[&this](){}` | 错误；指针 `this` 总是通过复制捕获。|'
- en: '| `[&, =](){}` | Error; cannot capture everything both by copy and by reference.
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `[&, =](){}` | 错误；不能同时通过复制和引用捕获所有内容。|'
- en: '| `[x=expr](){}` | `x` is a data member of the lambda’s closure initialized
    from the expression `expr`. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `[x=expr](){}` | `x` 是 lambda 的闭包中的数据成员，由表达式 `expr` 初始化。|'
- en: '| `[&x=expr](){}` | `x` is a reference data member of the lambda’s closure
    initialized from the expression `expr`. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `[&x=expr](){}` | `x` 是 lambda 的闭包中的引用数据成员，由表达式 `expr` 初始化。|'
- en: 'Table 3.1: Examples of lambda captures with explanations'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1：带有解释的 lambda 捕获示例
- en: 'The general form of a lambda expression, as of C++17, looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 C++17，lambda 表达式的一般形式如下所示：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All parts shown in this syntax are actually optional except for the capture
    list, which can, however, be empty, and the body, which can also be empty. The
    parameter list can actually be omitted if no parameters are needed. The return
    type does not need to be specified as the compiler can infer it from the type
    of the returned expression. The `mutable` specifier (which tells the compiler
    the lambda can actually modify variables captured by copy, which is not the same
    as capturing by value because the changes are only observed within the lambda),
    the `constexpr` specifier (which tells the compiler to generate a `constexpr`
    call operator), and the exception specifiers and attributes are all optional.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法中显示的所有部分实际上都是可选的，除了捕获列表，它可以空着，主体也可以空着。如果不需要参数，实际上可以省略参数列表。不需要指定返回类型，因为编译器可以从返回表达式的类型中推断它。`mutable`
    说明符（它告诉编译器 lambda 实际上可以修改通过复制捕获的变量，这与通过值捕获不同，因为更改仅在 lambda 内部观察到），`constexpr`
    说明符（它告诉编译器生成 `constexpr` 调用操作符），以及异常说明符和属性都是可选的。
- en: The simplest possible lambda expression is `[]{}`, though it is often written
    as `[](){}`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的 lambda 表达式是 `[]{}`，尽管它通常写作 `[]()`。
- en: 'The latter two examples in the preceding table are forms of generalized lambda
    captures. These were introduced in C++14 to allow us to capture variables with
    move-only semantics, but they can also be used to define new arbitrary objects
    in the lambda. The following example shows how variables can be captured by `move`
    with generalized lambda captures:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表格中后两个示例是泛化 lambda 捕获的形式。这些是在 C++14 中引入的，以便我们可以捕获具有移动语义的变量，但它们也可以用于在 lambda
    中定义新的任意对象。以下示例显示了如何通过泛化 lambda 捕获以 `move` 的方式捕获变量：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lambdas that are written in class methods and need to capture class data members
    can do so in several ways:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在类方法中编写的 lambda，如果需要捕获类数据成员，可以通过几种方式做到：
- en: 'Capturing individual data members with the form `[x=expr]`:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用形式 `[x=expr]` 捕获单个数据成员：
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Capturing the entire object with the form `[=]` (please note that the implicit
    capture of pointer `this` via `[=]` is deprecated in C++20):'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用形式 `[=]` 捕获整个对象（请注意，通过 `[=]` 隐式捕获指针 `this` 在 C++20 中已被弃用）：
- en: '[PRE17]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Capturing the entire object by capturing the `this` pointer. This is necessary
    if you need to invoke other methods of the class. This can be captured either
    as `[this]` when the pointer is captured by value, or `[*this]` when the object
    itself is captured by value. This can make a big difference if the object may
    go out of scope after the capture occurs but before the lambda is invoked:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过捕获 `this` 指针捕获整个对象。如果需要调用类的其他方法，这是必要的。这可以捕获为 `[this]` 当指针通过值捕获时，或者 `[*this]`
    当对象本身通过值捕获时。如果对象在捕获发生之后但在 lambda 调用之前可能超出作用域，这可能会产生重大差异：
- en: '[PRE18]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this latter case, the correct capture should be `[*this]` so that the object
    is copied by value. In this case, invoking the lambda will print *42 john*, even
    though the temporary has gone out of scope.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，正确的捕获应该是 `[*this]`，以便对象通过值复制。在这种情况下，调用 lambda 将打印 *42 john*，即使临时变量已经超出作用域。
- en: 'The C++20 standard introduces several changes to capturing the pointer `this`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: C++20 标准引入了对捕获指针 `this` 的几个更改：
- en: It deprecates the implicit capturing of `this` when you use `[=]`. This will
    produce a deprecation warning to be issued by the compiler.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 `[=]` 时，它会弃用隐式捕获 `this`。这将导致编译器发出弃用警告。
- en: It introduces explicit capturing of the `this` pointer by value when you want
    to capture everything with `[=, this]`. You can still only capture the pointer
    `this` with a `[this]` capture.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要使用 `[=, this]` 显式捕获所有内容时，它引入了通过值捕获 `this` 指针。你仍然只能使用 `[this]` 捕获指针 `this`。
- en: There are cases where lambda expressions only differ in terms of their arguments.
    In this case, the lambdas can be written in a generic way, just like templates,
    but using the `auto` specifier for the type parameters (no template syntax is
    involved). This is addressed in the next recipe, as noted in the upcoming *See
    also* section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，lambda表达式仅在它们的参数方面有所不同。在这种情况下，lambda可以以泛型方式编写，就像模板一样，但使用 `auto` 指定类型参数（不涉及模板语法）。这将在下一道菜谱中解决，正如即将到来的
    *参见* 部分所注明的。
- en: Before C++23, attributes could be specified on a lambda expression between the
    optional exception specifier and the optional trailing return type. Such attributes
    would apply to the type, not the function call operator. However, attributes such
    as `[[nodiscard]]` or `[[noreturn]]` would only make sense on a function, not
    a type.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++23之前，属性可以指定在可选的异常指定符和可选的尾随返回类型之间的lambda表达式中。这些属性将应用于类型，而不是函数调用操作符。然而，如 `[[nodiscard]]`
    或 `[[noreturn]]` 这样的属性仅在函数上才有意义，而不是类型。
- en: 'Therefore, as of C++23, this restriction has changed so that attributes can
    also be specified:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从C++23开始，这个限制已经改变，属性也可以被指定：
- en: after the lambda introducer and its optional capture, or
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在lambda引入符及其可选捕获之后，或者
- en: after the template parameter list and its optional requires clause.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板参数列表及其可选的requires子句之后。
- en: The attributes declared in any of these parts of a lambda declaration apply
    to the function call operator and not the type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda声明中的任何这些部分声明的属性应用于函数调用操作符，而不是类型。
- en: 'Let’s examine the following example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察以下示例：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `[[deprecated]]` attribute applies to the type of the lambda and no warning
    is produced when compiling the snippet. In C++23, we can write the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`[[deprecated]]` 属性应用于lambda的类型，在编译代码片段时不会产生警告。在C++23中，我们可以写出以下代码：'
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With this change, both the `[[nodiscard]]` and `[[deprecated]]` attributes
    apply to the function call operator of the lambda type. This results in two warnings
    being issued: one that a deprecated function is being used, and one that the return
    type is being ignored.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个变化，`[[nodiscard]]` 和 `[[deprecated]]` 属性都应用于lambda类型的函数调用操作符。这导致发出两个警告：一个是指示正在使用弃用的函数，另一个是指示返回类型被忽略。
- en: See also
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using generic and template lambdas*, to learn how to use `auto` for lambda
    parameters and how to define template lambdas in C++20'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用泛型和模板lambda*，了解如何为lambda参数使用 `auto` 并如何在C++20中定义模板lambda'
- en: '*Writing a recursive lambda*, to understand the technique we can use to make
    a lambda call itself recursively'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写递归lambda*，了解我们可以用来使lambda递归调用的技术'
- en: '*Chapter 4*, *Providing metadata to the compiler with attributes*, to learn
    about available standard attributes and how to use them'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第4章*，*使用属性向编译器提供元数据*，了解可用的标准属性以及如何使用它们'
- en: Using generic and template lambdas
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型和模板lambda
- en: In the preceding recipe, we saw how to write lambda expressions and use them
    with standard algorithms. In C++, lambdas are basically syntactic sugar for unnamed
    function objects, which are classes that implement the call operator. However,
    just like any other function, this can be implemented generically with templates.
    C++14 takes advantage of this and introduces generic lambdas that do not need
    to specify actual types for their parameters and use the `auto` specifier instead.
    Though not referred to by this name, generic lambdas are basically lambda templates.
    They are useful in cases where we want to use the same lambda but with different
    types of parameters. Moreover, the C++20 standard takes this a step further and
    supports explicitly defining template lambdas. This helps with some scenarios
    where generic lambdas are cumbersome.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的食谱中，我们看到了如何编写 lambda 表达式以及如何与标准算法一起使用它们。在 C++ 中，lambda 表达式基本上是无名函数对象的语法糖，这些对象是实现了
    call 操作符的类。然而，就像任何其他函数一样，这可以通过模板进行泛型实现。C++14 利用这一点并引入了不需要为它们的参数指定实际类型的泛型 lambda，而是使用
    `auto` 指示符。尽管没有使用这个名字，但泛型 lambda 实际上就是 lambda 模板。当我们需要使用相同的 lambda 但具有不同类型的参数时，它们非常有用。此外，C++20
    标准更进一步，支持显式定义模板 lambda。这有助于一些泛型 lambda 令人繁琐的场景。
- en: Getting started
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: It is recommended that you read the preceding recipe, *Using lambdas with standard
    algorithms*, before you continue with this one to familiarize yourself with the
    fundamentals of lambdas in C++.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你在继续阅读本食谱之前，先阅读前面的食谱，*使用 lambda 与标准算法*，以便熟悉 C++ 中 lambda 的基础知识。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Since C++14, we can write generic lambdas:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C++14 以来，我们可以编写泛型 lambda：
- en: By using the `auto` specifier instead of actual types for lambda expression
    parameters
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `auto` 指示符而不是实际类型作为 lambda 表达式参数
- en: When we need to use multiple lambdas that only differ by their parameter types
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要使用多个 lambda 表达式，而这些 lambda 表达式仅通过它们的参数类型不同时
- en: 'The following example shows a generic lambda used with the `std::accumulate()`
    algorithm, first with a vector of integers and then with a vector of strings:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用 `std::accumulate()` 算法使用泛型 lambda，首先使用整数向量，然后使用字符串向量：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since C++20, we can write template lambdas:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C++20 以来，我们可以编写模板 lambda：
- en: By using a template parameter list in angle brackets (such as `<template T>`)
    after the capture clause
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在捕获子句之后使用尖括号中的模板参数列表（例如 `<template T>`）
- en: 'When you want to:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要：
- en: Restrict the use of a generic lambda with only some types, such as a container,
    or types that satisfy a concept.
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅对某些类型（如容器或满足概念的类型）限制泛型 lambda 的使用。
- en: Make sure that two or more arguments of a generic lambda actually do have the
    same type.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保泛型 lambda 的两个或多个参数实际上具有相同的类型。
- en: Retrieve the type of a generic parameter so that, for example, we can create
    instances of it, invoke static methods, or use its iterator types.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取泛型参数的类型，例如，我们可以创建其实例，调用静态方法或使用其迭代器类型。
- en: Perform perfect forwarding in a generic lambda.
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在泛型 lambda 中执行完美转发。
- en: 'The following example shows a template lambda that can be invoked only using
    an `std::vector`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个只能使用 `std::vector` 调用的模板 lambda：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first example from the previous section, we defined a named lambda expression—that
    is, a lambda expression that has its closure assigned to a variable. This variable
    is then passed as an argument to the `std::accumulate()` function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的第一例中，我们定义了一个命名的 lambda 表达式——即，将它的闭包分配给变量的 lambda 表达式。然后，这个变量被传递给 `std::accumulate()`
    函数作为参数。
- en: This general algorithm takes the beginning and the ending iterators, which define
    a range, an initial value to accumulate over, and a function that is supposed
    to accumulate each value in the range to the total. This function takes a first
    parameter representing the currently accumulated value and a second parameter
    representing the current value to accumulate to the total, and it returns the
    new accumulated value. Note that I did not use the term `add` because this can
    be used for more things than just adding. It can also be used for calculating
    a product, concatenating, or other operations that aggregate values together.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通用算法接受开始和结束迭代器，这些迭代器定义了一个范围，一个要累加的初始值，以及一个函数，该函数将范围中的每个值累加到总和中。这个函数接受一个表示当前累加值的第一个参数和一个表示要累加到总和中当前值的第二个参数，并返回新的累加值。请注意，我没有使用术语
    `add`，因为这不仅可以用于加法，还可以用于计算乘积、连接或其他聚合值的操作。
- en: 'The two calls to `std::accumulate()` in this example are almost the same; only
    the types of the arguments are different:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的两次`std::accumulate()`调用几乎相同；只是参数的类型不同：
- en: In the first call, we pass iterators to a range of integers (from a `vector<int>`),
    0 for the initial sum, and a lambda that adds two integers and returns their sum.
    This produces a sum of all integers in the range; for this example, it is `22`.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一次调用中，我们传递了整数范围（来自`vector<int>`）的迭代器、0作为初始和，以及一个将两个整数相加并返回它们的和的lambda。这会产生范围内所有整数的和；对于这个示例，它是`22`。
- en: In the second call, we pass iterators to a range of strings (from a `vector<string>`),
    an empty string for the initial value, and a lambda that concatenates two strings
    by adding them together and returning the result. This produces a string that
    contains all the strings in the range put together one after another; for this
    example, the result is `hello world!`.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二次调用中，我们传递了字符串范围（来自`vector<string>`）的迭代器、一个空字符串作为初始值，以及一个通过将两个字符串相加并返回结果来连接两个字符串的lambda。这会产生一个包含范围内所有字符串的字符串，一个接一个地放在一起；对于这个示例，结果是`hello
    world!`。
- en: Though generic lambdas can be defined anonymously in the place where they are
    called, it does not really make sense because the very purpose of a generic lambda
    (which is basically, as we mentioned earlier, a lambda expression template) is
    to be reused, as shown in the example from the *How to do it...* section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然泛型lambda可以在它们被调用的地方匿名定义，但这实际上并没有什么意义，因为泛型lambda（基本上，如我们之前提到的，是一个lambda表达式模板）的主要目的就是为了重用，正如在*如何做...*部分中的示例所示。
- en: When defining this lambda expression, when used with multiple calls to `std::accumulate()`,
    instead of specifying concrete types for the lambda parameters (such as `int`
    or `std::string`), we used the `auto` specifier and let the compiler deduce the
    type.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义这个lambda表达式时，当与多个`std::accumulate()`调用一起使用时，我们不是为lambda参数指定具体类型（如`int`或`std::string`），而是使用了`auto`指定符，让编译器推断类型。
- en: 'When encountering a lambda expression that has the `auto` specifier for a parameter
    type, the compiler generates an unnamed function object that has a call operator
    template. For the generic lambda expression in this example, the function object
    would look like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到一个参数类型具有`auto`指定符的lambda表达式时，编译器会生成一个具有调用操作符模板的无名函数对象。对于这个示例中的泛型lambda表达式，函数对象看起来是这样的：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The call operator is a template with a type parameter for each parameter in
    the lambda that was specified with `auto`. The return type of the call operator
    is also `auto`, which means the compiler will deduce it from the type of the returned
    value. This operator template will be instantiated with the actual types that
    the compiler will identify in the context where the generic lambda is used.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 调用操作符是一个模板，它为lambda中每个使用`auto`指定的参数有一个类型参数。调用操作符的返回类型也是`auto`，这意味着编译器将从返回值的类型中推断它。这个操作符模板将使用编译器在泛型lambda使用的上下文中识别的实际类型进行实例化。
- en: 'The C++20 template lambdas are an improvement of the C++14 generic lambdas,
    making some scenarios easier. A typical one was shown in the second example of
    the previous section, where the use of lambda was restricted with arguments of
    the type `std::vector`. Another example is when you want to make sure that two
    parameters of the lambda have the same type. Prior to C++20, this was difficult
    to do, but with template lambdas, it is very easy, as shown in the following example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: C++20的模板lambda是对C++14泛型lambda的改进，使得某些场景更容易实现。一个典型的例子是上一节中的第二个示例，其中lambda的使用被限制为`std::vector`类型的参数。另一个例子是当你想要确保lambda的两个参数具有相同的类型。在C++20之前，这很难做到，但有了模板lambda，这非常简单，如下面的示例所示：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Another scenario for template lambdas is when you need to know the type of
    a parameter so that you can create instances of that type or invoke static members
    of it. With generic lambdas, the solution is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 模板lambda的另一个场景是当你需要知道参数的类型，以便你可以创建该类型的实例或调用它的静态成员时。使用泛型lambda，解决方案如下：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This solution requires the use of `std::decay_t` and `decltype`. `decltype`
    is a type specifier that yields the type of a specified expression and is primarily
    used in writing templates. On the other hand, `std::decay` is a utility from `<type_traits>`
    that performs the same type conversions as when passing function arguments by
    value.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案需要使用`std::decay_t`和`decltype`。`decltype`是一个类型指定符，它返回指定表达式的类型，主要用于编写模板。另一方面，`std::decay`是来自`<type_traits>`的一个实用工具，它执行与通过值传递函数参数相同的类型转换。
- en: 'However, in C++20, the same lambda can be written as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 C++20 中，相同的 lambda 可以这样编写：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A similar situation occurs when we need to do perfect forwarding in a generic
    lambda, which requires the use of `decltype` to determine the types of the arguments:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在泛型 lambda 中进行完美转发时，也会出现类似的情况，这需要使用 `decltype` 来确定参数的类型：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With template lambda, we can rewrite it in a simpler way as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板 lambda，我们可以以更简单的方式重写如下：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As seen in these examples, template lambdas are an improvement on generic lambdas,
    making it easier to handle the scenarios mentioned in this recipe.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如这些示例所示，模板 lambda 是对泛型 lambda 的改进，使得处理本食谱中提到的场景更加容易。
- en: See also
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using lambdas with standard algorithms*, to explore the basics of lambda expressions
    and how you can utilize them with the standard algorithms'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 lambda 与标准算法*，以探索 lambda 表达式的基础知识以及如何利用它们与标准算法。'
- en: '*Chapter 1*, *Using auto whenever possible*, to understand how automatic type
    deduction works in C++'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第一章*，*尽可能使用 auto*，以了解 C++ 中自动类型推导的工作原理'
- en: Writing a recursive lambda
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写递归 lambda
- en: Lambdas are basically unnamed function objects, which means that it should be
    possible to call them recursively. Indeed, they can be called recursively; however,
    the mechanism for doing so is not obvious as it requires assigning the lambda
    to a function wrapper and capturing the wrapper by reference. Though it can be
    argued that a recursive lambda does not really make sense and that a function
    is probably a better design choice, in this recipe, we will look at how to write
    a recursive lambda.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 本质上是无名的函数对象，这意味着应该可以递归地调用它们。确实，它们可以递归地调用；然而，执行此操作的机制并不明显，因为它需要将 lambda
    分配给函数包装器并通过引用捕获包装器。尽管可以争论递归 lambda 并没有真正意义，并且函数可能是一个更好的设计选择，但在本食谱中，我们将探讨如何编写递归
    lambda。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To demonstrate how to write a recursive lambda, we will consider the well-known
    example of the Fibonacci function. This is usually implemented recursively in
    C++, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何编写递归 lambda，我们将考虑斐波那契函数的著名示例。这通常在 C++ 中递归实现，如下所示：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Having this implementation as a starting point, let’s see how we can rewrite
    it using a recursive lambda.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以此实现作为起点，让我们看看我们如何使用递归 lambda 重写它。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In C++11, in order to write a recursive lambda function, you must do the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 中，为了编写递归 lambda 函数，您必须执行以下操作：
- en: Define the lambda in a function scope.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数作用域中定义 lambda。
- en: Assign the lambda to an `std::function` wrapper.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 lambda 分配给 `std::function` 包装器。
- en: Capture the `std::function` object by reference in the lambda in order to call
    it recursively.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 lambda 中通过引用捕获 `std::function` 对象，以便递归地调用它。
- en: 'In C++14, the above pattern can be simplified using a generic lambda:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++14 中，可以使用泛型 lambda 简化上述模式：
- en: Define the lambda in a function scope.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数作用域中定义 lambda。
- en: Declare the first argument with the `auto` placeholder; this is used to pass
    the lambda expression as an argument to itself.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `auto` 占位符声明第一个参数；这用于将 lambda 表达式作为参数传递给自己。
- en: Invoke the lambda expression by passing the lambda itself for the first argument.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过传递 lambda 本身作为第一个参数来调用 lambda 表达式。
- en: 'In C++23, this pattern can be further simplified as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++23 中，此模式可以进一步简化如下：
- en: Define the lambda in a function scope.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数作用域中定义 lambda。
- en: Declare the first argument `this const auto&& self`; this is to enable a new
    C++23 feature called *deducing this* or *explicit object parameter*. You can recursively
    call the lambda expression through the `self` argument.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明第一个参数 `this const auto&& self`; 这是为了启用一个新的 C++23 特性，称为 *推导 this* 或 *显式对象参数*。您可以通过
    `self` 参数递归调用 lambda 表达式。
- en: Invoke the lambda expression by calling it with the explicit arguments (if any)
    and let the compiler deduce the first one.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用它并传递显式参数（如果有）来调用 lambda 表达式，并让编译器推导第一个参数。
- en: 'The following are examples of recursive lambdas:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些递归 lambda 的示例：
- en: 'A recursive Fibonacci lambda expression in the scope of a function that is
    invoked from the scope where it is defined:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在从定义它的作用域调用的函数的作用域中返回的递归 Fibonacci lambda 表达式：
- en: '[PRE30]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A recursive Fibonacci lambda expression returned by a function, which can be
    invoked from any scope:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由函数返回的递归 Fibonacci lambda 表达式，可以从任何作用域调用：
- en: '[PRE31]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A lambda expression as a member of a class that is invoked recursively:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为类成员的 lambda 表达式，该类被递归调用：
- en: '[PRE32]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A recursive Fibonacci generic lambda expression—the C++14 alternative for the
    example from the first bullet:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个递归的Fibonacci泛型lambda表达式——C++14对第一个要点中例子的替代方案：
- en: '[PRE33]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A recursive Fibonacci lambda expression, taking advantage of the C++23 feature
    called explicit object parameter (or deducing this), a further simplified alternative
    to the one above:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个递归的Fibonacci lambda表达式，利用了C++23中的显式对象参数（或推导此）功能，这是上述方法的进一步简化替代方案：
- en: '[PRE34]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing you need to consider when writing a recursive lambda in C++11
    is that a lambda expression is a function object and, in order to call it recursively
    from the lambda’s body, the lambda must capture its closure (that is, the instantiation
    of the lambda). In other words, the lambda must capture itself, and this has several
    implications:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当在C++11中编写递归lambda时，你需要考虑的第一件事是lambda表达式是一个函数对象，并且为了从lambda的主体中递归调用它，lambda必须捕获其闭包（即lambda的实例化）。换句话说，lambda必须捕获自身，这有几个含义：
- en: First of all, the lambda must have a name; an unnamed lambda cannot be captured
    so that it can be called again.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，lambda必须有一个名称；无名的lambda不能被捕获以便再次调用。
- en: Secondly, the lambda can only be defined in a function scope. The reason for
    this is that a lambda can only capture variables from a function scope; it cannot
    capture any variable that has a static storage duration. Objects defined in a
    namespace scope or with the static or external specifiers have static storage
    duration. If the lambda was defined in a namespace scope, its closure would have
    static storage duration and, therefore, the lambda would not capture it.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，lambda只能在函数作用域内定义。这是因为lambda只能捕获函数作用域中的变量；它不能捕获任何具有静态存储期的变量。在命名空间作用域中定义的对象或具有静态或外部指定符的对象具有静态存储期。如果lambda在命名空间作用域中定义，其闭包将具有静态存储期，因此lambda不会捕获它。
- en: The third implication is that the type of the lambda closure cannot remain unspecified;
    that is, it cannot be declared with the `auto` specifier. It is not possible for
    a variable declared with the `auto` type specifier to appear in its own initializer.
    This is because the type of the variable is not known when the initializer is
    being processed. Therefore, you must specify the type of the lambda closure. The
    way we can do this is by using the general-purpose function wrapper `std::function`.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个含义是lambda闭包的类型不能保持未指定；也就是说，不能使用`auto`指定符声明。使用`auto`类型指定符声明的变量不能出现在其自己的初始化器中。这是因为当处理初始化器时，变量的类型是未知的。因此，你必须指定lambda闭包的类型。我们可以通过使用通用函数包装器`std::function`来实现这一点。
- en: Last, but not least, the lambda closure must be captured by reference. If we
    capture by copy (or value), then a copy of the function wrapper is made but the
    wrapper is uninitialized when the capturing is done. We end up with an object
    that we are not able to call. Even though the compiler will not complain about
    capturing by value, when the closure is invoked, an `std::bad_function_call` is
    thrown.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，lambda闭包必须通过引用捕获。如果我们通过复制（或值）捕获，那么将创建函数包装器的副本，但在捕获时包装器未初始化。我们最终得到一个无法调用的对象。即使编译器不会对通过值捕获提出抱怨，当闭包被调用时，会抛出`std::bad_function_call`。
- en: In the first example from the *How to do it...* section, the recursive lambda
    is defined inside another function called `sample()`. The signature and the body
    of the lambda expression are the same as those of the regular recursive function
    `fib` `()`, which was defined in the introductory section. The lambda closure
    is assigned to a function wrapper called `lfib`, which is then captured by reference
    by the lambda and called recursively from its body. Since the closure is captured
    by reference, it will be initialized at the time it has to be called from the
    lambda’s body.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在“如何做……”部分的第一个例子中，递归lambda表达式定义在另一个名为`sample()`的函数内部。lambda表达式的签名和主体与在介绍部分定义的常规递归函数`fib()`的签名和主体相同。lambda闭包被分配给一个名为`lfib`的函数包装器，然后lambda通过引用捕获它，并从其主体中递归调用。由于闭包是通过引用捕获的，因此它将在lambda主体需要调用时初始化。
- en: In the second example, we defined a function that returns the closure of a lambda
    expression that, in turn, defines and invokes a recursive lambda with the argument
    it was in turn invoked with. This is a pattern that must be implemented when a
    recursive lambda needs to be returned from a function. This is necessary because
    the lambda closure must still be available at the time the recursive lambda is
    called. The `fib_create()` method returns a function wrapper that, when invoked,
    creates the recursive lambda that captures itself. The outer `f` lambda does not
    capture anything, especially by reference; therefore, we don’t have this issue
    with dangling references. However, when invoked, it creates a closure of the nested
    lambda, which is the actual lambda we are interested in calling, and returns the
    result of applying that recursive `lfib` lambda to its parameter.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们定义了一个返回lambda表达式闭包的函数，该lambda表达式反过来定义并调用一个递归lambda，该递归lambda使用它被依次调用的参数。这是一个在需要从函数返回递归lambda时必须实现的模式。这是必要的，因为lambda闭包必须在递归lambda被调用时仍然可用。`fib_create()`方法返回一个函数包装器，当被调用时，创建一个捕获自身的递归lambda。外部的`f`
    lambda没有捕获任何东西，特别是通过引用；因此，我们不会遇到悬垂引用的问题。然而，当被调用时，它创建了一个嵌套lambda的闭包，这是我们真正想要调用的lambda，并返回将递归`lfib`
    lambda应用于其参数的结果。
- en: 'Writing a recursive lambda is simpler in C++14, as the fourth example from
    the *How to do it…* section shows. Instead of capturing the lambda’s closure,
    it is passed as an argument (typically, the first). For this purpose, a parameter
    is declared using the `auto` placeholder. Let’s revisit the implementation in
    order to discuss it:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++14中编写递归lambda更简单，如*如何做…*部分的第四个例子所示。不是捕获lambda的闭包，而是将其作为参数传递（通常是第一个）。为此，使用`auto`占位符声明了一个参数。让我们回顾一下实现，以便讨论它：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A lambda expression is a function object with a function call operator. A generic
    lambda is a function object with a template function call operator. The compiler
    generates code similar to the following for the previous snippet:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式是一个具有函数调用操作符的函数对象。一个泛型lambda是一个具有模板函数调用操作符的函数对象。编译器为前面的代码片段生成类似于以下代码的代码：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The function call operator is a template function. Its first parameter has the
    type of the type template parameter. For this primary template, a full explicit
    specialization for the class type itself is provided. This makes it possible to
    invoke the lambda, passing itself as an argument, and therefore, avoiding the
    capturing of an `std::function` object, as it was necessary to do in C++11.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用操作符是一个模板函数。它的第一个参数具有类型模板参数的类型。对于这个主要模板，提供了对类类型的完整显式特化。这使得可以调用lambda，将自身作为参数传递，从而避免捕获`std::function`对象，这在C++11中是必须做的。
- en: 'If your compiler supports C++23, then it’s possible to simplify this even further
    with the help of the *explicit object parameter* feature (also known as *deducing
    this*). This feature was designed to enable the compiler to figure out from within
    a function whether the expression it’s invoked on is an lvalue or an rvalue, or
    if it is *cv-* or *ref-*qualified, and what the type of the expression is. This
    feature makes possible scenarios such as:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编译器支持C++23，那么在*显式对象参数*功能（也称为*推导this*）的帮助下，可以进一步简化这一点。这个功能是为了使编译器能够从函数内部确定它被调用的表达式是一个左值还是右值，或者它是否是*cv-*或*ref-*限定，以及表达式的类型。这个功能使得以下场景成为可能：
- en: Avoiding duplicating code with overloads-based *cv-* and *ref-*qualifiers (for
    instance, the same function with no qualifiers and with a `const` qualifier, which
    is the most usual case).
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过基于重载的*cv-*和*ref-*限定符（例如，没有限定符和具有`const`限定符的相同函数，这是最常见的情况）避免代码重复。
- en: Simplifying the **curiously recurring template pattern** (**CRTP**) by using
    simple inheritance and, therefore, removing the recurrence from the pattern.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用简单的继承来简化**奇特重复模板模式**（**CRTP**），从而从模式中去除重复。
- en: Simplifying writing recursive lambdas.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化编写递归lambda。
- en: For the example given in the *How to do it…* section, the compiler is able to
    deduce the type of the first argument, `self`, making it unnecessary to explicitly
    pass the lambda closure as an argument.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*如何做…*部分给出的例子，编译器能够推断出第一个参数`self`的类型，这使得不需要显式传递lambda闭包作为参数。
- en: 'Notice that in the C++23 example, we have defined a lambda expression using
    the trailing return type syntax:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在C++23的例子中，我们使用尾随返回类型语法定义了一个lambda表达式：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Without this, you would get a compiler error such as the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个，你会得到如下编译器错误：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With a small change in the function implementation, shown next, the trailing
    return type is no longer needed, and the deduce this feature works again:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对函数实现进行微小更改，如以下所示，不再需要尾随返回类型，并且推导这个特性再次工作：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See also
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using generic and template lambdas*, to learn how to use `auto` for lambda
    parameters and how to define template lambdas in C++20'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用通用和模板lambda*，学习如何在C++20中使用`auto`作为lambda参数以及如何定义模板lambda'
- en: '*Chapter 9*, *Static polymorphism with the curiously recurring template pattern*,
    to learn about what the CRTP is and how it works'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第9章*，*使用怪异重复模板模式进行静态多态*，了解CRTP是什么以及它是如何工作的'
- en: Writing function templates
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写函数模板
- en: Generic code is key to avoid writing repetitive code. In C++, this is achieved
    with the help of templates. Classes, functions, and variables can be templated.
    Although templates are often seen as complex and cumbersome, they enable the creation
    of general-purpose libraries, such as the standard library, and help us write
    less and better code.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通用代码是避免编写重复代码的关键。在C++中，这是通过模板实现的。类、函数和变量都可以进行模板化。尽管模板通常被视为复杂且繁琐，但它们能够创建通用库，例如标准库，并帮助我们编写更少且更好的代码。
- en: Templates are first-class citizens of the C++ language and could take an entire
    book to cover in detail. In fact, multiple recipes in this book deal with various
    aspects of templates. In this recipe, we will discuss the basics of writing function
    templates.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是C++语言的一等公民，可能需要整本书来详细说明。实际上，这本书中的多个菜谱都处理了模板的各个方面。在本菜谱中，我们将讨论编写函数模板的基础。
- en: How to do it…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Do the following to create function templates:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建函数模板，请执行以下操作：
- en: 'To create a function template, precede the function declaration with the `template`
    keyword followed by the list of template parameters in angle brackets:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要创建一个函数模板，在函数声明前加上`template`关键字，后跟尖括号中的模板参数列表：
- en: '[PRE40]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To specialize a function template, leave the list of template parameters empty
    and replace the template parameters with actual types or values in the function
    signature:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要专门化一个函数模板，在函数签名中留空模板参数列表，并用实际类型或值替换模板参数：
- en: '[PRE41]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To overload a function template, provide another definition, which can be either
    a template or a non-template:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要重载函数模板，提供另一个定义，这可以是模板或非模板：
- en: '[PRE42]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To ensure a particular function template or specialization of a function template
    cannot be called (is deleted from the overload set), declare it as `deleted`:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要确保特定的函数模板或函数模板的专门化不能被调用（从重载集中删除），请将其声明为`deleted`：
- en: '[PRE43]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works…
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At least at first look, function templates are only slightly different from
    other functions. They are introduced with a template syntax and can be parameterized
    with types, values, or even other templates. However, since templates are only
    blueprints for creating actual code, a function template is basically a blueprint
    that defines a family of functions. Templates only exist in source code, until
    they are used.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 至少乍一看，函数模板与其他函数只有细微的差别。它们使用模板语法引入，可以用类型、值甚至其他模板进行参数化。然而，由于模板只是创建实际代码的蓝图，函数模板基本上是一个定义函数族的蓝图。模板仅在源代码中存在，直到它们被使用。
- en: 'The compiler instantiates the templates based on their use. This process is
    called *template instantiation*. This is done by the compiler by substituting
    the template arguments. For instance, in the case of the `minimum<T>` function
    template shown previously, when we invoke this as `minimum<int>(1, 2)`, the compiler
    substitutes the `int` type for the `T` parameter. There are two forms of instantiation:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器根据其使用情况实例化模板。这个过程称为*模板实例化*。编译器通过替换模板参数来完成此操作。例如，在前面展示的`minimum<T>`函数模板的情况下，当我们以`minimum<int>(1,
    2)`的方式调用它时，编译器将`int`类型替换为`T`参数。存在两种实例化的形式：
- en: '**Implicit instantiation** occurs when the compiler generates code from a template
    based on the templates used in the code. For instance, if the `minimum<T>` function
    is invoked with `int` and `double` values throughout your code, then two overloads
    (one with integer parameters and one with `double` parameters) are generated.
    This is the implicit instantiation, as shown in the following snippet:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式实例化**发生在编译器根据代码中使用的模板生成代码时。例如，如果您的代码中通过 `int` 和 `double` 值调用 `minimum<T>`
    函数，那么将生成两个重载（一个带有整数参数，另一个带有 `double` 参数）。这被称为隐式实例化，如下面的代码片段所示：'
- en: '[PRE44]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Explicit instantiation** occurs when you, as a user, request the compiler
    to generate code from a template even if that instantiation is not used in the
    code. An example of where this is useful is when creating library (binary) files,
    since uninstantiated templates (which are only blueprints) are not put into object
    files. The following shows an example of explicit instantiation of the `minimum<T>`
    function for the `char` type. Keep in mind that if an explicit instantiation is
    not defined in the same namespace as the template, the name must be fully qualified
    in the explicit instantiation definition:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式实例化**发生在您作为用户请求编译器从模板生成代码，即使该实例化在代码中没有使用时。这种用法的一个例子是在创建库（二进制）文件时，因为未实例化的模板（它们只是蓝图）不会被放入对象文件中。以下是一个为
    `char` 类型的 `minimum<T>` 函数显式实例化的示例。请注意，如果显式实例化没有在模板所在的同一命名空间中定义，则必须在显式实例化定义中使用完全限定的名称：'
- en: '[PRE45]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As previously mentioned, templates can have different kinds of parameters.
    These are provided in angle brackets after the `template` keyword and can be the
    following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，模板可以有不同的参数类型。这些参数位于 `template` 关键字之后的角度括号中，可以是以下类型：
- en: '**Type template parameters**, where the parameter is a placeholder for a type.
    This is the case for all the examples seen in the previous section.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型模板参数**，其中参数是类型的占位符。这是前一个章节中看到的所有示例的情况。'
- en: '**Non-type template parameters**, where the parameter is a value of a structural
    type. The integer types, floating-point types (since C++20), pointer types, enumeration
    types, and lvalue reference types are all structural types. In the following example,
    `T` is a type template parameter and `S` is a non-type template parameter:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非类型模板参数**，其中参数是结构化类型的值。整数类型、浮点类型（自C++20起）、指针类型、枚举类型和左值引用类型都是结构化类型。在下面的示例中，`T`
    是一个类型模板参数，而 `S` 是一个非类型模板参数：'
- en: '[PRE46]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In C++17, non-type template parameters can be declared using the `auto` keyword:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，可以使用 `auto` 关键字声明非类型模板参数：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**Template template parameters**, where the type of the parameter is another
    type. In the following example, the `trimin` function template has two template
    parameters, a type template parameter `T`, and a template template parameter `M`:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板模板参数**，其中参数的类型是另一个类型。在下面的示例中，`trimin` 函数模板有两个模板参数，一个类型模板参数 `T` 和一个模板模板参数
    `M`：'
- en: '[PRE48]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Although templates allow us to write one implementation for many types (or
    template parameters, more generally), it is often useful, or maybe necessary,
    to provide modified implementations for different types. This process of providing
    alternative implementations for some template parameters is called specialization.
    The template that is being specialized is called the *primary template*. There
    are two possible forms:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模板允许我们为许多类型（或更一般地说，模板参数）编写一个实现，但为不同类型提供修改后的实现通常是有用的，或者可能是必要的。为某些模板参数提供替代实现的过程称为特化。正在特化的模板称为*主模板*。有两种可能的形式：
- en: '**Partial specialization** is when you provide a different implementation only
    for some of the template parameters.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分特化**是指只为某些模板参数提供不同的实现。'
- en: '**Full specialization** is when you provide a different implementation for
    the entire set of template parameters.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全特化**是指为模板参数的整个集合提供不同的实现。'
- en: Function templates only support full specialization. Partial specialization
    is only possible for class templates. An example of a full specialization was
    provided in the *How to do it…* section when we specialized the `minimum<T>` function
    template for the `const char*` type. Instead of lexicographically comparing the
    two arguments of the function, we decided which is “smaller” based on their length.
    Keep in mind this was an example given only for the purpose of understanding specialization.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板仅支持完全特化。部分特化仅适用于类模板。在*如何做到这一点…*部分提供了一个完全特化的例子，当时我们为`const char*`类型特化了`minimum<T>`函数模板。我们决定不是基于两个参数的字典顺序比较，而是根据它们的长度来决定哪个“更小”。请记住，这只是一个为了理解特化而给出的例子。
- en: 'Function templates can be overloaded just like any other function. You should
    note that when multiple overloads are available, both template and non-template,
    the compiler will prefer a non-template overload. An example was provided earlier.
    Let’s see it again, with only the declarations of the functions:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板可以像任何其他函数一样重载。请注意，当有多个重载可用，包括模板和非模板时，编译器将优先选择非模板重载。前面已经提供了一个例子。让我们再次看看，只包含函数的声明：
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The first call to the `minimum` function takes `std::string` arguments, and,
    therefore, the non-template overload will be invoked. The second call takes `std::wstring`
    arguments, and since the function template is the only matching overload, its
    `std::wstring` instantiation will be invoked.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对`minimum`函数的第一个调用接受`std::string`参数，因此将调用非模板重载。第二个调用接受`std::wstring`参数，由于函数模板是唯一匹配的重载，因此将调用其`std::wstring`实例化。
- en: 'Specifying the template arguments during the invocation of a function template
    is not always necessary. The following two calls are identical:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数模板时指定模板参数并不总是必要的。以下两个调用是相同的：
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There are many cases where the compiler can deduce the template arguments from
    the invocation of the function. In this example, since both function arguments
    are integers, it can figure out that the template argument should be the `int`
    type. Therefore, explicitly specifying this is not necessary. However, there are
    also situations in which the compiler cannot deduce the types. In these cases,
    you must provide them explicitly. An example is given next:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，编译器可以从函数的调用中推导出模板参数。在这个例子中，由于两个函数参数都是整数，它可以推断出模板参数应该是`int`类型。因此，明确指定这一点是不必要的。然而，也存在编译器无法推导类型的情况。在这些情况下，您必须明确提供它们。下面将给出一个例子：
- en: '[PRE51]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The two arguments are an `int` and an `unsigned int`. Therefore, the compiler
    does not know whether the `T` type should be deduced as `int` or `unsigned int`.
    To solve this ambiguity, you must provide the template argument explicitly:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 两个参数是一个`int`和一个`unsigned int`。因此，编译器不知道`T`类型应该推断为`int`还是`unsigned int`。为了解决这种歧义，您必须明确提供模板参数：
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When deducing template arguments, the compiler performs a comparison between
    the template parameters and the arguments used to invoke the function. These must
    have a certain structure for the comparison to succeed and for the compiler to
    successfully deduce all the arguments. A detailed look at this process is, however,
    beyond the scope of this recipe. You can consult other resources, including my
    book *Template Metaprogramming with C++*, which discusses this in detail in *Chapter
    4*, both for function templates and class templates.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在推导模板参数时，编译器会在模板参数和用于调用函数的参数之间进行比较。为了使比较成功并让编译器成功推导出所有参数，这些参数必须具有某种结构。然而，对这个过程的详细探讨超出了本菜谱的范围。您可以查阅其他资源，包括我的书籍《使用C++的模板元编程》，其中在第4章详细讨论了这一点，包括函数模板和类模板。
- en: As mentioned in the introduction, templates are a broad topic that cannot be
    covered in one recipe. We will learn more about templates throughout the book,
    including in the next two recipes, where we will discuss function templates with
    a variable number of arguments.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，模板是一个广泛的主题，无法在一道菜谱中涵盖。我们将在整本书中学习更多关于模板的内容，包括在接下来的两个菜谱中，我们将讨论具有可变数量参数的函数模板。
- en: See also
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Writing a function template with a variable number of arguments*, to learn
    how to write functions that take a variable number of arguments'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写具有可变数量参数的函数模板*，以了解如何编写接受可变数量参数的函数'
- en: '*Chapter 1*, *Simplifying code with class template argument deduction*, to
    see how template argument deduction works for class templates'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第一章*，*使用类模板参数推导简化代码*，以了解模板参数推导对类模板的工作方式。'
- en: Writing a function template with a variable number of arguments
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写具有可变数量参数的函数模板
- en: It is sometimes useful to write functions with a variable number of arguments
    or classes with a variable number of members. Typical examples include functions
    such as `printf`, which takes a format and a variable number of arguments, or
    classes such as `tuple`. Before C++11, the former was possible only with the use
    of variadic macros (which enable writing only type-unsafe functions) and the latter
    was not possible at all. C++11 introduced variadic templates, which are templates
    with a variable number of arguments that make it possible to write both type-safe
    function templates with a variable number of arguments, and also class templates
    with a variable number of members. In this recipe, we will look at writing function
    templates.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有时编写具有可变数量参数的函数或具有可变数量成员的类是有用的。典型的例子包括像`printf`这样的函数，它接受一个格式和可变数量的参数，或者像`tuple`这样的类。在C++11之前，前者只能通过使用可变宏（它只能编写不安全的函数）来实现，而后者根本不可能。C++11引入了可变模板，这些是具有可变数量参数的模板，使得可以编写具有可变数量参数的类型安全函数模板，以及具有可变数量成员的类模板。在这个菜谱中，我们将探讨编写函数模板。
- en: Getting ready
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Functions with a variable number of arguments are called *variadic functions*.
    Function templates with a variable number of arguments are called *variadic function
    templates*. Knowledge of C++ variadic macros (`va_start`, `va_end`, `va_arg`,
    `va_copy`, and `va_list`) is not necessary for learning how to write variadic
    function templates, but it represents a good starting point.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 具有可变数量参数的函数被称为*可变参数函数*。具有可变数量参数的函数模板被称为*可变参数函数模板*。了解C++可变参数宏（`va_start`、`va_end`、`va_arg`、`va_copy`和`va_list`）对于学习如何编写可变参数函数模板不是必需的，但它是一个很好的起点。
- en: We have already used variadic templates in our previous recipes, but this one
    will provide detailed explanations.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的菜谱中使用了可变模板，但这个将提供详细的解释。
- en: How to do it...
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In order to write variadic function templates, you must perform the following
    steps:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写可变参数模板函数，你必须执行以下步骤：
- en: Define an overload with a fixed number of arguments to end compile-time recursion
    if the semantics of the variadic function template require it (refer to `[1]`
    in the following code).
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个具有固定数量参数的重载，如果可变参数模板函数的语义需要结束编译时递归（参见以下代码中的[1]）。
- en: Define a template parameter pack that is a template parameter that can hold
    any number of arguments, including zero; these arguments can be either types,
    non-types, or templates (refer to `[2]`).
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个模板参数包，它是一个可以存储任意数量参数的模板参数，包括零；这些参数可以是类型、非类型或模板（参见[2]）。
- en: Define a function parameter pack to hold any number of function arguments, including
    zero; the size of the template parameter pack and the corresponding function parameter
    pack is the same. This size can be determined with the `sizeof...` operator (refer
    to `[3]` and refer to the end of the *How it works...* section for information
    on this operator).
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数参数包以存储任意数量的函数参数，包括零；模板参数包的大小和相应的函数参数包的大小相同。这个大小可以用`sizeof...`运算符确定（参见[3]），并参考*如何工作...*部分的结尾以获取有关此运算符的信息）。
- en: Expand the parameter pack in order to replace it with the actual arguments being
    supplied (refer to `[4]`).
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展参数包以便用提供的实际参数替换它（参见[4]）。
- en: 'The following example, which illustrates all the preceding points, is a variadic
    function template that adds a variable number of arguments using `operator+`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例，它说明了所有前面的点，是一个使用`operator+`添加可变数量参数的可变参数函数模板：
- en: '[PRE53]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: At first glance, the preceding implementation looks like recursion because the
    function `add()` calls itself, and in a way it is, but it is a compile-time recursion
    that does not incur any sort of runtime recursion and overhead. The compiler actually
    generates several functions with a different number of arguments, based on the
    variadic function template’s usage, so only function overloading is involved and
    not any sort of recursion. However, implementation is done as if parameters would
    be processed in a recursive manner with an end condition.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，前面的实现看起来像是递归，因为 `add()` 函数调用了自身，从某种意义上说确实是，但它是一种编译时递归，不会产生任何运行时递归和开销。实际上，编译器根据变长函数模板的使用生成具有不同参数数量的几个函数，因此只涉及函数重载，而不是递归。然而，实现时似乎参数是以递归方式处理的，有一个结束条件。
- en: 'In the preceding code, we can identify the following key parts:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以识别出以下关键部分：
- en: '`Typename... Ts` is a template parameter pack that indicates a variable number
    of template type arguments.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Typename... Ts` 是一个模板参数包，表示可变数量的模板类型参数。'
- en: '`Ts... rest` is a function parameter pack that indicates a variable number
    of function arguments.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ts... rest` 是一个函数参数包，表示可变数量的函数参数。'
- en: '`rest...` is an expansion of the function parameter pack.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rest...` 是函数参数包的展开。'
- en: The position of the ellipsis is not syntactically relevant. `typename... Ts`,
    `typename ... Ts`, and `typename ...Ts` are all equivalent.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 省略号的位置在语法上并不重要。`typename... Ts`、`typename ... Ts` 和 `typename ...Ts` 都是等效的。
- en: In the `add(T head, Ts... rest)` parameter, `head` is the first element of the
    list of arguments, while `...rest` is a pack with the rest of the parameters in
    the list (this can be zero or more). In the body of the function, `rest...` is
    an expansion of the function parameter pack. This means the compiler replaces
    the parameter pack with its elements in their order. In the `add()` function,
    we basically add the first argument to the sum of the remaining arguments, which
    gives the impression of recursive processing. This recursion ends when there is
    a single argument left, in which case the first `add()` overload (with a single
    argument) is called and returns the value of its argument.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `add(T head, Ts... rest)` 参数中，`head` 是参数列表中的第一个元素，而 `...rest` 是包含列表中其余参数的包（这可以是零个或多个）。在函数体中，`rest...`
    是函数参数包的展开。这意味着编译器将参数包及其元素按顺序替换。在 `add()` 函数中，我们基本上将第一个参数添加到剩余参数的总和中，这给人一种递归处理的印象。这种递归在只剩下一个参数时结束，此时调用第一个
    `add()` 重载（单个参数）并返回其参数的值。
- en: 'This implementation of the function template `add()` enables us to write code,
    as shown here:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这种函数模板 `add()` 的实现使我们能够编写如下所示的代码：
- en: '[PRE54]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When the compiler encounters `add(1, 2, 3, 4, 5)`, it generates the following
    functions (notice that `arg1`, `arg2`, and so on are not the actual names the
    compiler generates), which shows that this process is actually only a sequence
    of calls to overloaded functions and not recursion:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到 `add(1, 2, 3, 4, 5)` 时，它会生成以下函数（注意 `arg1`、`arg2` 等不是编译器实际生成的名称），这表明这个过程实际上只是一系列对重载函数的调用，而不是递归：
- en: '[PRE55]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: With GCC and Clang, you can use the `__PRETTY_FUNCTION__` macro to print the
    name and the signature of the function.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GCC 和 Clang，你可以使用 `__PRETTY_FUNCTION__` 宏来打印函数的名称和签名。
- en: 'By adding an `std::cout << __PRETTY_FUNCTION__ << std::endl`, when using GCC
    or Clang, at the beginning of the two functions we wrote, we get the following
    when running the code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `std::cout << __PRETTY_FUNCTION__ << std::endl`，当使用 GCC 或 Clang 时，在两个我们编写的函数的开始处，运行代码时会得到以下结果：
- en: 'With GCC:'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GCC：
- en: '[PRE56]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'With Clang:'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Clang：
- en: '[PRE57]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Since this is a function template, it can be used with any type that supports
    `operator+`. The other example, `add("hello"s, " "s, "world"s, "!"s)`, produces
    the *hello world!* string. However, the `std::basic_string` type has different
    overloads for `operator+`, including one that can concatenate a string into a
    character, so we should be able to also write the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个函数模板，它可以与支持 `operator+` 操作符的任何类型一起使用。另一个例子，`add("hello"s, " "s, "world"s,
    "!"s)` 产生 *hello world!* 字符串。然而，`std::basic_string` 类型对 `operator+` 有不同的重载，包括一个可以将字符串连接到字符的重载，因此我们应该能够编写以下代码：
- en: '[PRE58]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'However, that will generate compiler errors, as follows (note that I actually
    replaced `std::basic_string<char, std::char_traits<char>, std::allocator<char>
    >` with the string *hello world!* for simplicity):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将生成编译器错误，如下所示（注意我实际上用字符串 *hello world!* 替换了 `std::basic_string<char, std::char_traits<char>,
    std::allocator<char> >` 以简化问题）：
- en: '[PRE59]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'What happens is that the compiler generates the code shown here, where the
    return type is the same as the type of the first argument. However, the first
    argument is either an `std::string` or a `char` (again, `std::basic_string<char,
    std::char_traits<char>, std::allocator<char> >` was replaced with `string` for
    simplicity). In cases where `char` is the type of the first argument, the type
    of the return value `head+add` `(...)`, which is an `std::string`, does not match
    the function return type and does not have an implicit conversion to it:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是编译器生成了这里显示的代码，其中返回类型与第一个参数的类型相同。然而，第一个参数要么是`std::string`要么是`char`（为了简单起见，`std::basic_string<char,
    std::char_traits<char>, std::allocator<char> >`被替换为`string`）。在第一个参数的类型是`char`的情况下，返回值`head+add`
    `(...)`的类型，它是一个`std::string`，与函数返回类型不匹配，并且没有到它的隐式转换：
- en: '[PRE60]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can fix this by modifying the variadic function template so that it has
    `auto` for the return type instead of `T`. In this case, the return type is always
    inferred from the return expression, and in our example, it will be `std::string`
    in all cases:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改变长函数模板，使其返回类型为`auto`而不是`T`来解决这个问题。在这种情况下，返回类型总是从返回表达式中推断出来的，在我们的例子中，在所有情况下都将是`std::string`：
- en: '[PRE61]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It should be further added that a parameter pack can appear in a brace initialization
    and that its size can be determined using the `sizeof...` operator. Also, variadic
    function templates do not necessarily imply compile-time recursion, as we have
    shown in this recipe. All these are shown in the following example:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 应进一步说明参数包可以出现在花括号初始化中，并且可以使用`sizeof...`运算符确定其大小。此外，变长函数模板不一定意味着编译时递归，正如我们在本食谱中所展示的。所有这些都在以下示例中展示：
- en: '[PRE62]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The template parameter pack `T` is expanded (with `T...`) into the type arguments
    of the `std::tuple` class template, and the function parameter pack `a` is expanded
    (with `a...`) into the values for the tuple members using brace initialization.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数包`T`被展开（使用`T...`）为`std::tuple`类模板的类型参数，函数参数包`a`被展开（使用`a...`）为元组成员的值，使用花括号初始化。
- en: See also
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using fold expressions to simplify variadic function templates*, to learn
    how to write simpler and clearer code when creating function templates with a
    variable number of arguments'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用折叠表达式简化变长函数模板*，了解如何在创建具有可变数量参数的函数模板时编写更简单、更清晰的代码'
- en: '*Chapter 2*, *Creating raw user-defined literals*, to understand how to provide
    a custom interpretation of an input sequence so that it changes the normal behavior
    of the compiler'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第二章*，*创建原始用户定义字面量*，了解如何提供对输入序列的定制解释，以便改变编译器的正常行为'
- en: Using fold expressions to simplify variadic function templates
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用折叠表达式简化变长函数模板
- en: In this chapter, we have already discussed folding several times; this is an
    operation that applies a binary function to a range of values to produce a single
    value. We saw this when we discussed variadic function templates and we will see
    it again with higher-order functions. It turns out there is a significant number
    of cases where the expansion of a parameter pack in variadic function templates
    is basically a folding operation. To simplify writing such variadic function templates,
    C++17 introduced fold expressions, which fold an expansion of a parameter pack
    over a binary operator. In this recipe, we will learn how to use fold expressions
    to simplify writing variadic function templates.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经多次讨论了折叠；这是一个将二元函数应用于值范围以产生单个值的操作。我们在讨论变长函数模板时看到了这一点，我们还将再次在高阶函数中看到它。结果证明，在变长函数模板中参数包的展开基本上是一个折叠操作的情况有很多。为了简化编写这样的变长函数模板，C++17引入了折叠表达式，它将参数包的展开折叠到二元运算符上。在本食谱中，我们将学习如何使用折叠表达式来简化编写变长函数模板。
- en: Getting ready
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The examples in this recipe are based on the variadic function template `add`
    `()`, which we wrote in the previous recipe, *Writing a function template with
    a variable number of arguments*. That implementation is a left-folding operation.
    For simplicity, we’ll present the function again:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的示例基于我们在上一食谱中编写的变长函数模板`add` `()`，即*编写具有可变数量参数的函数模板*。该实现是一个左折叠操作。为了简单起见，我们将再次展示该函数：
- en: '[PRE63]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the next section, we will learn how this particular implementation can be
    simplified, as well as other examples of using fold expressions.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何简化这种特定的实现，以及其他使用折叠表达式的示例。
- en: How to do it...
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To fold a parameter pack over a binary operator, use one of the following forms:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要在二元运算符上折叠参数包，可以使用以下形式之一：
- en: 'Left folding with a unary form `(... op pack)`:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一元形式 `(... op pack)` 的左折叠：
- en: '[PRE64]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Left folding with a binary form `(init op ... op pack)`:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用二元形式 `(init op ... op pack)` 的左折叠：
- en: '[PRE65]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Right folding with a unary form `(pack op ...)`:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一元形式 `(pack op ...)` 的右折叠：
- en: '[PRE66]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Right folding with a binary form `(pack op ... op init)`:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用二元形式 `(pack op ... op init)` 的右折叠：
- en: '[PRE67]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The parentheses shown here are part of the fold expression and cannot be omitted.
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里显示的括号是折叠表达式的一部分，不能省略。
- en: How it works...
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When the compiler encounters a fold expression, it expands it in one of the
    following expressions:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到折叠表达式时，它会将其展开为以下表达式之一：
- en: '| **Expression** | **Expansion** |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| **表达式** | **展开** |'
- en: '| `(... op pack)` | `((pack$1 op pack$2) op ...) op pack$n` |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `(... op pack)` | `((pack$1 op pack$2) op ...) op pack$n` |'
- en: '| `(init op ... op pack)` | `(((init op pack$1) op pack$2) op ...) op pack$n`
    |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `(init op ... op pack)` | `(((init op pack$1) op pack$2) op ...) op pack$n`
    |'
- en: '| `(pack op ...)` | `pack$1 op (... op (pack$n-1 op pack$n))` |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `(pack op ...)` | `pack$1 op (... op (pack$n-1 op pack$n))` |'
- en: '| `(pack op ... op init)` | `pack$1 op (... op (pack$n-1 op (pack$n op init)))`
    |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `(pack op ... op init)` | `pack$1 op (... op (pack$n-1 op (pack$n op init)))`
    |'
- en: 'Table 3.2: The possible forms of a fold expression'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2：折叠表达式的可能形式
- en: When the binary form is used, the operator on both the left-hand and right-hand
    sides of the ellipses must be the same, and the initialization value must not
    contain an unexpanded parameter pack.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用二元形式时，省略号左右两边的运算符必须相同，并且初始化值不能包含未展开的参数包。
- en: 'The following binary operators are supported with fold expressions:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 支持以下二元运算符与折叠表达式一起使用：
- en: '| `+` | `-` | `*` | `/` | `%` | `^` | `&` | `&#124;` | `=` | `<` | `>` | `<<`
    |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `+` | `-` | `*` | `/` | `%` | `^` | `&` | `&#124;` | `=` | `<` | `>` | `<<`
    |'
- en: '| `>>` | `+=` | `-=` | `*=` | `/=` | `%=` | `^=` | `&=` | `&#124;=` | `<<=`
    | `>>=` | `==` |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | `+=` | `-=` | `*=` | `/=` | `%=` | `^=` | `&=` | `&#124;=` | `<<=`
    | `>>=` | `==` |'
- en: '| `!=` | `<=` | `>=` | `&&` | `&#124;&#124;` | `,` | `.*` | `->*.` |  |  |  |  |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | `<=` | `>=` | `&&` | `&#124;&#124;` | `,` | `.*` | `->*.` |  |  |  |  |'
- en: 'Table 3.3: The binary operator supported with fold expressions'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.3：与折叠表达式一起支持的二元运算符
- en: 'When using the unary form, only operators such as `*`, `+`, `&`, `|`, `&&`,
    `||`, and `,` (comma) are allowed with an empty parameter pack. In this case,
    the value of the empty pack is as follows:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用一元形式时，只有 `*`、`+`、`&`、`|`、`&&`、`||` 和 `,`（逗号）这样的运算符可以与空参数包一起使用。在这种情况下，空包的值如下：
- en: '| **Operator** | **Empty pack value** |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **空包值** |'
- en: '| `+` | `0` |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `+` | `0` |'
- en: '| `*` | `1` |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `*` | `1` |'
- en: '| `&` | `-1` |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `&` | `-1` |'
- en: '| `&#124;` | `0` |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | `0` |'
- en: '| `&&` | `true` |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | `true` |'
- en: '| `&#124;&#124;` | `false` |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | `false` |'
- en: '| `,` | `void()` |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| `,` | `void()` |'
- en: 'Table 3.4: Operators that can be used with an empty parameter pack'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.4：可以使用空参数包的运算符
- en: 'Now that we have the function templates we implemented earlier (let’s consider
    the left-folding version), we can write the following code:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了之前实现的功能模板（让我们考虑左折叠版本），我们可以编写以下代码：
- en: '[PRE68]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Considering the `add(1, 2, 3, 4, 5)` call, it will produce the following function:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 `add(1, 2, 3, 4, 5)` 调用，它将产生以下函数：
- en: '[PRE69]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It’s worth mentioning that due to the aggressive ways modern compilers do optimizations,
    this function can be inlined and, eventually, we may end up with an expression
    such as `auto sum = 1 + 2 + 3 + 4 + 5`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，由于现代编译器在优化方面的积极方式，这个函数可以被内联，最终我们可能会得到一个如 `auto sum = 1 + 2 + 3 + 4 +
    5` 的表达式。
- en: There’s more...
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Fold expressions work with all overloads for the supported binary operators,
    but do not work with arbitrary binary functions. It is possible to implement a
    workaround for that by providing a wrapper type that will hold a value and an
    overloaded operator for that wrapper type:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 折叠表达式与支持的所有二元运算符的重载一起工作，但不与任意二元函数一起工作。可以通过提供一个将包含值和该包装器类型的重载运算符的包装器类型来实现一个解决方案：
- en: '[PRE70]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the preceding code, `wrapper` is a simple class template that holds a constant
    reference to a value of type `T`. An overloaded `operator<` is provided for this
    class template; this overload does not return a Boolean to indicate that the first
    argument is less than the second, but actually an instance of the `wrapper` class
    type to hold the minimum value of the two arguments. The variadic function template
    `min` `()`, shown here, uses this overloaded `operator<` to fold the pack of arguments
    expanded to instances of the `wrapper` class template:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`wrapper` 是一个简单的类模板，它持有类型 `T` 的值的常量引用。为此类模板提供了一个重载的 `operator<`；这个重载不返回布尔值来指示第一个参数小于第二个参数，而是实际上返回一个
    `wrapper` 类型的实例来保存两个参数中的最小值。这里显示的变长函数模板 `min()` 使用这个重载的 `operator<` 来折叠展开为 `wrapper`
    类模板实例的参数包：
- en: '[PRE71]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This `min()` function is expanded by the compiler to something that could look
    like the following:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `min()` 函数被编译器扩展为类似以下内容：
- en: '[PRE72]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'What we can see here is cascading calls to the binary `operator <` that return
    a `Wrapper<int>` value. Without this, an implementation of the `min()` function
    using fold expressions would not be possible. The following implementation does
    not work:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里可以看到的是对二进制 `operator <` 的级联调用，返回 `Wrapper<int>` 值。没有这个，使用折叠表达式实现的 `min()`
    函数的实现将是不可能的。以下实现不起作用：
- en: '[PRE73]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The compiler would transform this, based on the call `min(3, 1, 2)`, to something
    such as the following:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 根据调用 `min(3, 1, 2)`，编译器将将其转换为以下类似的内容：
- en: '[PRE74]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The result is a function that returns a Boolean, and not the actual integer
    value, which is the minimum between the supplied arguments.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个返回布尔值的函数，而不是实际整数值，这是提供的参数之间的最小值。
- en: See also
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Implementing higher-order functions map and fold*, to learn about higher-order
    functions in functional programming and how to implement the widely used `map`
    and `fold` (or `reduce`) functions'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现高阶函数 map 和 fold*，了解函数式编程中的高阶函数以及如何实现广泛使用的 `map` 和 `fold`（或 `reduce`）函数'
- en: Implementing the higher-order functions map and fold
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现高阶函数 map 和 fold
- en: Throughout the preceding recipes in this book, we have used the general-purpose
    algorithms `std::transform()` and `std::accumulate()` in several examples, such
    as for implementing string utilities to create uppercase or lowercase copies of
    a string or for summing the values of a range.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书前面的食谱中，我们在几个示例中使用了通用算法 `std::transform()` 和 `std::accumulate()`，例如用于实现字符串实用工具以创建字符串的大写或小写副本，或用于计算范围值的总和。
- en: These are basically implementations of the higher-order functions, `map` and
    `fold`. A higher-order function is a function that takes one or more other functions
    as arguments and applies them to a range (a list, vector, map, tree, and so on),
    thus producing either a new range or a value. In this recipe, we will learn how
    to implement the `map` and `fold` functions so that they work with C++ standard
    containers.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本上是高阶函数 `map` 和 `fold` 的实现。高阶函数是一种接受一个或多个其他函数作为参数并将它们应用于范围（列表、向量、映射、树等）的函数，从而产生一个新的范围或一个值。在本食谱中，我们将学习如何实现
    `map` 和 `fold` 函数，以便它们能够与 C++ 标准容器一起工作。
- en: Getting ready
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: '`map` is a higher-order function that applies a function to the elements of
    a range and returns a new range in the same order.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 是一种高阶函数，它将函数应用于范围中的元素并返回一个新范围，顺序相同。'
- en: '`fold` is a higher-order function that applies a combining function to the
    elements of the range to produce a single result. Since the order of the processing
    can be important, there are usually two versions of this function. One is `fold_left`,
    which processes elements from left to right, while the other is `fold_right`,
    which combines the elements from right to left.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold` 是一种高阶函数，它将组合函数应用于范围中的元素以产生单个结果。由于处理顺序可能很重要，通常有两个版本的此函数。一个是 `fold_left`，它从左到右处理元素，而另一个是
    `fold_right`，它从右到左组合元素。'
- en: Most descriptions of the function map indicate that it is applied to a list,
    but this is a general term that can indicate different sequential types, such
    as list, vector, and array, and also dictionaries (that is, maps), queues, and
    so on. For this reason, I prefer to use the term range when describing these higher-order
    functions.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数关于函数 map 的描述表明它应用于列表，但这是一个通用术语，可以指代不同的顺序类型，如列表、向量、数组，以及字典（即映射）、队列等。因此，我更喜欢在描述这些高阶函数时使用术语范围。
- en: As an example, the mapping operation could transform a range of strings into
    a range of integers representing the length of each string. The fold operation
    could then add these lengths to determine the combined length of all the strings.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，映射操作可以将字符串范围转换为表示每个字符串长度的整数范围。然后，折叠操作可以将这些长度相加，以确定所有字符串的总长度。
- en: How to do it...
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To implement the `map` function, you should:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `map` 函数，你应该：
- en: 'Use `std::transform` on containers that support iterating and assignment to
    the elements, such as `std::vector` or `std::list`:'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在支持迭代和元素赋值的容器上使用 `std::transform`，例如 `std::vector` 或 `std::list`：
- en: '[PRE75]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Use other means such as explicit iteration and insertion for containers that
    do not support assignment to the elements, such as `std::map` and `std::queue`:'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不支持对元素进行赋值的容器，例如 `std::map` 和 `std::queue`，使用其他方法，如显式迭代和插入：
- en: '[PRE76]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To implement the `fold` function, you should:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 `fold` 函数，你应该：
- en: 'Use `std::accumulate()` on containers that support iterating:'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在支持迭代的容器上使用 `std::accumulate()`：
- en: '[PRE77]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Use other means to explicitly process containers that do not support iterating,
    such as `std::queue`:'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不支持迭代的容器，例如 `std::queue`，使用其他方法显式处理：
- en: '[PRE78]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: How it works...
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the preceding examples, we implemented the `map` higher-order function in
    a functional way, without side effects. This means it preserves the original range
    and returns a new one. The arguments of the function are the function to apply
    and the range. In order to avoid confusion with the `std::map` container, we have
    called this function `mapf`. There are several overloads for `mapf`, as shown
    earlier:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们以函数式的方式实现了 `map` 高阶函数，没有副作用。这意味着它保留了原始范围并返回一个新的范围。函数的参数是应用函数和范围。为了避免与
    `std::map` 容器混淆，我们称此函数为 `mapf`。`mapf` 有几个重载，如前所述：
- en: The first overload is for containers that support iterating and assignment to
    its elements; this includes `std::vector`, `std::list`, and `std::array`, but
    also C-like arrays. The function takes an `rvalue` reference to a function and
    a range for which `std::begin()` and `std::end()` are defined. The range is passed
    by value so that modifying the local copy does not affect the original range.
    The range is transformed by applying the given function to each element using
    the standard algorithm `std::transform()`; the transformed range is then returned.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个重载适用于支持迭代和对其元素进行赋值的容器；这包括 `std::vector`、`std::list`、`std::array`，以及 C 类型的数组。函数接受一个函数的右值引用和一个定义了
    `std::begin()` 和 `std::end()` 的范围。范围按值传递，以便修改局部副本不会影响原始范围。范围通过使用标准算法 `std::transform()`
    对每个元素应用给定函数进行转换；然后返回转换后的范围。
- en: The second overload is specialized for `std::map`, which does not support direct
    assignment to its elements (`std::pair<T, U>`). Therefore, this overload creates
    a new map, then iterates through its elements using a range-based `for` loop,
    and inserts the result of applying the input function to each element of the original
    map into the new map.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个重载专门针对 `std::map`，它不支持直接对其元素进行赋值（`std::pair<T, U>`）。因此，此重载创建一个新的映射，然后使用基于范围的
    `for` 循环遍历其元素，并将将输入函数应用于原始映射的每个元素的结果插入到新映射中。
- en: The third overload is specialized for `std::queue`, which is a container that
    does not support iterating. It can be argued that a queue is not a typical structure
    to map over, but for the sake of demonstrating different possible implementations,
    we are considering it. In order to iterate over the elements of a queue, the queue
    must be altered—you need to pop elements from the front until the list is empty.
    This is what the third overload does—it processes each element of the input queue
    (passed by value) and pushes the result of applying the given function to the
    front element of the remaining queue.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个重载专门针对 `std::queue`，它是一个不支持迭代的容器。可以争辩说队列不是映射的典型结构，但为了演示不同的可能实现，我们正在考虑它。为了遍历队列的元素，队列必须被修改——你需要从前面弹出元素直到列表为空。这就是第三个重载所做的事情——它处理输入队列（按值传递）的每个元素，并将给定函数应用于剩余队列的前端元素的结果推送到队列的前端。
- en: 'Now that we have these overloads implemented, we can apply them to a lot of
    containers, as shown in the following examples:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了这些重载，我们可以将它们应用到许多容器中，如下面的示例所示：
- en: 'Retain absolute values from a vector. In this example, the vector contains
    both negative and positive values. After applying the mapping, the result is a
    new vector with only positive values:'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留向量中的绝对值。在这个例子中，向量包含正负值。应用映射后，结果是只包含正值的新的向量：
- en: '[PRE79]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Square the numerical values of a list. In this example, the list contains integral
    values. After applying the mapping, the result is a list containing the squares
    of the initial values:'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平方列表中的数值。在这个例子中，列表包含整数。应用映射后，结果是包含初始值平方的列表：
- en: '[PRE80]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Rounded amounts of floating points. For this example, we need to use `std::round()`;
    however, this has overloads for all floating-point types, which makes it impossible
    for the compiler to pick the right one. As a result, we either have to write a
    lambda that takes an argument of a specific floating-point type and returns the
    value of `std::round()` applied to that value, or create a function object template
    that wraps `std::round()` and enables its call operator only for floating-point
    types. This technique is used in the following example:'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数的四舍五入。对于这个例子，我们需要使用`std::round()`；然而，它对所有浮点类型都有重载，这使得编译器无法选择正确的类型。因此，我们要么编写一个lambda，该lambda接受特定浮点类型的参数并返回应用于该值的`std::round()`的值，要么创建一个函数对象模板，该模板包装`std::round()`并仅允许浮点类型调用其调用操作符。这种技术在下例中使用：
- en: '[PRE81]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Uppercase the string keys of a map of words (where the key is the word and
    the value is the number of appearances in the text). Note that creating an uppercase
    copy of a string is itself a mapping operation. Therefore, in this example, we
    use `mapf` to apply `toupper()` to the elements of the string representing the
    key in order to produce an uppercase copy:'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将单词映射的字符串键转换为大写（其中键是单词，值是文本中的出现次数）。请注意，创建字符串的大写副本本身就是一个映射操作。因此，在这个例子中，我们使用`mapf`将`toupper()`应用于表示键的字符串元素，以生成大写副本：
- en: '[PRE82]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Normalize values from a queue of priorities; initially, the values are from
    1 to 100, but we want to normalize them into two values, 1=high and 2=normal.
    All the initial priorities that have a value up to 30 get high priority; the others
    get normal priority:'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化优先级队列中的值；最初，这些值从1到100，但我们希望将它们标准化为两个值，1=高，2=正常。所有初始优先级值在30及以下的都获得高优先级；其余的获得正常优先级：
- en: '[PRE83]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To implement `fold`, we actually have to consider the two possible types of
    folding—that is, from left to right and from right to left. Therefore, we have
    provided two functions called `fold_left` (for left folding) and `fold_right`
    (for right folding). The implementations shown in the previous section are very
    similar: they both take a function, range, and initial value and call `std::accumulate()`
    to fold the values of the range into a single value. However, `fold_left` uses
    direct iterators, whereas `fold_right` uses reverse iterators to traverse and
    process the range. The second overload is a specialization for the type `std::queue`,
    which does not have iterators.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`fold`，我们实际上必须考虑两种可能的折叠方式——即从左到右和从右到左。因此，我们提供了两个函数，称为`fold_left`（用于左折叠）和`fold_right`（用于右折叠）。前一个章节中展示的实现非常相似：它们都接受一个函数、一个范围和一个初始值，并调用`std::accumulate()`将范围的值折叠成一个单一值。然而，`fold_left`使用直接迭代器，而`fold_right`使用反向迭代器遍历和处理范围。第二个重载是一个针对类型`std::queue`的特殊化，因为`std::queue`没有迭代器。
- en: 'Based on these implementations for folding, we can implement the following
    examples:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些折叠实现，我们可以实现以下示例：
- en: 'Adding the values of a vector of integers. In this case, both left and right
    folding will produce the same result. In the following examples, we pass either
    a lambda that takes a sum and a number and returns a new sum or the function object
    `std::plus<>` from the standard library, which applies `operator+` to two operands
    of the same type (basically similar to the closure of the lambda):'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加整数向量的值。在这种情况下，左折叠和右折叠将产生相同的结果。在以下示例中，我们传递一个lambda，该lambda接受一个总和和一个数字，并返回一个新的总和，或者传递标准库中的函数对象`std::plus<>`，该对象将`operator+`应用于相同类型的两个操作数（基本上类似于lambda的闭包）：
- en: '[PRE84]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Concatenating strings from a vector into a single string:'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将向量中的字符串连接成一个单一字符串：
- en: '[PRE85]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Concatenating an array of characters into a string:'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符数组连接成一个字符串：
- en: '[PRE86]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Counting the number of words in text based on their already computed appearances,
    available in a `map<string, int>`:'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据已计算的词频统计文本中的单词数量，这些词频存储在`map<string, int>`中：
- en: '[PRE87]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: There’s more...
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'These functions can be pipelined—that is, they can call one function with the
    result of another. The following example maps a range of integers into a range
    of positive integers by applying the `std::abs()` function to its elements. The
    result is then mapped into another range of squares. These are then summed together
    by applying a left fold on the range:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以被管道化——也就是说，它们可以用另一个函数的结果调用一个函数。以下示例通过将 `std::abs()` 函数应用于其元素，将一系列整数映射到一系列正整数。然后将结果映射到另一个平方数的范围。这些数通过在范围上应用左折叠而相加：
- en: '[PRE88]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'As an exercise, we could implement the `fold` function as a variadic function
    template, in the manner seen earlier. The function that performs the actual folding
    is provided as an argument:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，我们可以将 `fold` 函数实现为一个变长函数模板，就像之前看到的那样。执行实际折叠的函数作为参数提供：
- en: '[PRE89]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'When we compare this with the `add()` function template that we wrote in the
    *Writing a function template with a variable number of arguments* recipe, we can
    notice several differences:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将它与我们在 *编写带有可变数量参数的函数模板* 菜谱中编写的 `add()` 函数模板进行比较时，我们可以注意到几个差异：
- en: The first argument is a function, which is perfectly forwarded when calling
    `fold_left` recursively.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是一个函数，在递归调用 `fold_left` 时会被完美转发。
- en: The end case is a function that requires two arguments because the function
    we use for folding is a binary one (taking two arguments).
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 末尾的情况是一个需要两个参数的函数，因为我们使用的折叠函数是二元的（接受两个参数）。
- en: The return type of the two functions we wrote is declared as `auto` because
    it must match the return type of the supplied binary function `f`, which is not
    known until we call `fold_left`.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们编写的两个函数的返回类型被声明为 `auto`，因为它们必须匹配提供的二元函数 `f` 的返回类型，而 `f` 的返回类型在我们调用 `fold_left`
    之前是未知的。
- en: 'The `fold_left()` function can be used as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold_left()` 函数可以使用如下方式：'
- en: '[PRE90]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Notice that the last call produces a compiler error because the variadic function
    template `fold_left()` requires at least two arguments to be passed in order to
    invoke the supplied binary function.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到最后一次调用会产生编译器错误，因为变长函数模板 `fold_left()` 至少需要传入两个参数才能调用提供的二元函数。
- en: See also
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 2*, *Creating a library of string helpers*, to see how to create useful
    text utilities that are not directly available in the standard library'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第二章*，*创建字符串辅助库*，了解如何创建有用的文本实用工具，这些工具在标准库中并不直接可用'
- en: '*Writing a function template with a variable number of arguments*, to see how
    variadic templates enable us to write functions that can take any number of arguments'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写带有可变数量参数的函数模板*，了解变长模板如何使我们能够编写可以接受任意数量参数的函数'
- en: '*Composing functions into a higher-order function*, to learn the functional
    programming technique for creating a new function from one or more other functions'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将函数组合成高阶函数*，学习从一个或多个其他函数创建新函数的函数式编程技术'
- en: Composing functions into a higher-order function
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数组合成高阶函数
- en: In the previous recipe, we implemented two higher-order functions, `map` and
    `fold`, and saw various examples of using them. At the end of the recipe, we saw
    how they can be pipelined to produce a final value after several transformations
    of the original data. Pipelining is a form of composition, which means creating
    one new function from two or more given functions. In the mentioned example, we
    didn’t actually compose functions; we only called a function with the result produced
    by another, but in this recipe, we will learn how to actually compose functions
    together into a new function. For simplicity, we will only consider unary functions
    (functions that take only one argument).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们实现了两个高阶函数，`map` 和 `fold`，并看到了它们的各种用法示例。在菜谱的结尾，我们看到了它们如何通过几个原始数据的转换来生成最终值。管道化是一种组合形式，这意味着从两个或更多给定的函数中创建一个新的函数。在提到的例子中，我们实际上并没有组合函数；我们只是用一个函数的结果调用另一个函数，但在这个菜谱中，我们将学习如何将函数实际组合成一个新的函数。为了简单起见，我们只考虑一元函数（只接受一个参数的函数）。
- en: Getting ready
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you go forward, it is recommended that you read the previous recipe,
    *Implementing the higher-order functions map and fold*. It is not mandatory for
    understanding this recipe, but we will refer to the `map` and `fold` functions
    we implemented there.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续之前，建议你阅读之前的菜谱，*实现高阶函数 map 和 fold*。这并不是理解这个菜谱的强制要求，但我们将参考在那里实现的 `map` 和 `fold`
    函数。
- en: How to do it...
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To compose unary functions into a higher-order function, you should do the
    following:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一元函数组合成高阶函数，你应该这样做：
- en: 'To compose two functions, provide a function that takes two functions, `f`
    and `g`, as arguments and returns a new function (a lambda) that returns `f(g(x))`,
    where `x` is the argument of the composed function:'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要组合两个函数，提供一个函数，该函数接受两个函数`f`和`g`作为参数，并返回一个新的函数（一个lambda），该函数返回`f(g(x))`，其中`x`是组合函数的参数：
- en: '[PRE91]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'To compose a variable number of functions, provide a variadic template overload
    of the function described previously:'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要组合可变数量的函数，提供之前描述的函数的可变模板重载：
- en: '[PRE92]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: How it works...
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Composing two unary functions into a new one is relatively trivial. Create a
    template function, which we called `compose()` in the earlier examples, with two
    arguments—`f` and `g`—that represent functions, and return a function that takes
    one argument, `x`, and returns `f(g(x))`. It is important that the type of the
    value returned by the `g` function is the same as the type of the argument of
    the `f` function. The returned value of the compose function is a closure—that
    is, it’s an instantiation of a lambda.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个一元函数组合成一个新的函数相对简单。创建一个模板函数，我们在前面的例子中将其称为`compose()`，它有两个参数——`f`和`g`——代表函数，并返回一个接受一个参数`x`的函数，并返回`f(g(x))`。重要的是，`g`函数返回的值的类型与`f`函数的参数类型相同。组合函数返回的值是一个闭包——也就是说，它是lambda的一个实例化。
- en: In practice, it is useful to be able to combine more than just two functions.
    This can be achieved by writing a variadic template version of the `compose()`
    function. Variadic templates are explained in more detail in the *Writing a function
    template with a variable number of arguments* recipe.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，能够组合不仅仅是两个函数是非常有用的。这可以通过编写`compose()`函数的可变模板版本来实现。可变模板在*编写具有可变数量参数的函数模板*配方中有更详细的解释。
- en: 'Variadic templates imply compile-time recursion by expanding the parameter
    pack. This implementation is very similar to the first version of `compose()`,
    except for the following:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 可变模板通过展开参数包来暗示编译时递归。这个实现与`compose()`的第一个版本非常相似，除了以下几点：
- en: It takes a variable number of functions as arguments.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受可变数量的函数作为参数。
- en: The returned closure calls `compose()` recursively with the expanded parameter
    pack; recursion ends when only two functions are left, in which case the previously
    implemented overload is called.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的闭包递归地调用`compose()`与展开的参数包，递归在只剩两个函数时结束，在这种情况下调用之前实现的重载。
- en: Even if the code looks like recursion is happening, this is not true recursion.
    It could be called compile-time recursion, but with every expansion, we get a
    call to another method with the same name but a different number of arguments,
    which does not represent recursion.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 即使代码看起来像是在发生递归，这并不是真正的递归。这可以称为编译时递归，但每次展开都会调用另一个具有相同名称但参数数量不同的方法，这并不代表递归。
- en: 'Now that we have these variadic template overloads implemented, we can rewrite
    the last example from the previous recipe, *Implementing the higher-order functions
    map and fold*. Refer to the following snippet:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了这些可变模板重载，我们可以重写之前配方中的最后一个例子，*实现高阶函数map和fold*。参考以下片段：
- en: '[PRE93]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Having an initial vector of integers, we map it to a new vector with only positive
    values by applying `std::abs()` to each element. The result is then mapped to
    a new vector by doubling the value of each element. Finally, the values in the
    resulting vector are folded together by adding them to the initial value, `0`.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个初始整数向量，我们通过将每个元素应用`std::abs()`映射到一个只包含正值的新的向量。然后将结果映射到一个新的向量，通过将每个元素的值加倍。最后，将结果向量中的值通过将它们加到初始值`0`上折叠在一起。
- en: There’s more...
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Composition is usually represented by a dot (`.`) or asterisk (`*`), such as
    `f . g` or `f * g`. We can actually do something similar in C++ by overloading
    `operator*` (it would make little sense to try to overload the operator dot).
    Similar to the `compose()` function, `operator*` should work with any number of
    arguments; therefore, we will have two overloads, just like in the case of `compose()`:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 组合通常用点（`.`）或星号（`*`）表示，例如`f . g`或`f * g`。实际上，我们可以在C++中通过重载`operator*`（尝试重载操作符点几乎没有意义）做类似的事情。与`compose()`函数类似，`operator*`应该与任何数量的参数一起工作；因此，我们将有两个重载，就像在`compose()`的情况下一样：
- en: The first overload takes two arguments and calls `compose()` to return a new
    function.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个重载接受两个参数并调用`compose()`来返回一个新的函数。
- en: The second overload is a variadic template function that, again, calls `operator*`
    by expanding the parameter pack.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个重载是一个变长模板函数，它再次通过展开参数包来调用`operator*`。
- en: 'Based on these considerations, we can implement `operator*` as follows:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些考虑，我们可以如下实现`operator*`：
- en: '[PRE94]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We can now simplify the actual composition of functions by applying `operator*`
    instead of the more verbose call to `compose()`:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过应用`operator*`而不是更冗长的`compose()`调用来简化函数的实际组合：
- en: '[PRE95]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Although it may not be intuitive at first glance, the functions are applied
    in reverse order rather than the one shown in the text. For instance, in the first
    example, the absolute value of the argument is retained. Then, the result is doubled,
    and the result of that operation is then multiplied by itself. Finally, the result
    is converted to a string. For the supplied argument, `-3`, the final result is
    the string `"36"`.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然乍一看可能不太直观，但函数是按相反的顺序应用的，而不是文本中显示的顺序。例如，在第一个例子中，参数的绝对值被保留。然后，结果被加倍，然后该操作的结果再乘以自身。最后，结果被转换为字符串。对于提供的参数`-3`，最终结果是字符串`"36"`。
- en: See also
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Writing a function template with a variable number of arguments*, to see how
    variadic templates enable us to write functions that can take any number of arguments'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写一个带有可变数量参数的函数模板*，以了解变长模板如何使我们能够编写可以接受任意数量参数的函数'
- en: Uniformly invoking anything callable
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一调用任何可调用对象
- en: Developers, especially those who implement libraries, sometimes need to invoke
    a callable object in a uniform manner. This can be a function, a pointer to a
    function, a pointer to a member function, or a function object. Examples of such
    cases include `std::bind`, `std::function`, `std::mem_fn`, and `std::thread::thread`.
    C++17 defines a standard function called `std::invoke()` that can invoke any callable
    object with the provided arguments. This is not intended to replace direct calls
    to functions or function objects, but it is useful in template metaprogramming
    for implementing various library functions.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者，尤其是那些实现库的开发者，有时需要以统一的方式调用可调用对象。这可能是一个函数、一个函数指针、一个成员函数指针或一个函数对象。此类情况的例子包括`std::bind`、`std::function`、`std::mem_fn`和`std::thread::thread`。C++17定义了一个标准函数`std::invoke()`，它可以调用任何可调用对象并传递提供的参数。这并不是要取代对函数或函数对象的直接调用，但在模板元编程中实现各种库函数时非常有用。
- en: Getting ready
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you should be familiar with how to define and use function
    pointers.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你应该熟悉如何定义和使用函数指针。
- en: 'To exemplify how `std::invoke()` can be used in different contexts, we will
    use the following function and class:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`std::invoke()`如何在不同的上下文中使用，我们将使用以下函数和类：
- en: '[PRE96]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In the next section, we’ll explore the possible use cases for the `std::invoke()`
    function.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨`std::invoke()`函数的可能用例。
- en: How to do it...
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The `std::invoke()` function is a variadic function template that takes the
    callable object as the first argument and a variable list of arguments that are
    passed to the call. `std::invoke()` can be used to call the following:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::invoke()`函数是一个变长函数模板，它接受可调用对象作为第一个参数，以及一个可变数量的参数列表，这些参数被传递给调用。`std::invoke()`可以用来调用以下内容：'
- en: 'Free functions:'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自由函数：
- en: '[PRE97]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Free functions through a pointer to function:'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过函数指针实现的自由函数：
- en: '[PRE98]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Member functions through a pointer to member function:'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过成员函数指针实现的成员函数：
- en: '[PRE99]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Data members:'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据成员：
- en: '[PRE100]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Function objects:'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数对象：
- en: '[PRE101]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Lambda expressions:'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式：
- en: '[PRE102]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In practice, `std:invoke()` should be used in template metaprogramming to invoke
    a function with an arbitrary number of arguments. To exemplify such a case, we’ll
    present a possible implementation for our `std::apply()` function, and also a
    part of the standard library, as of C++17, that calls a function by unpacking
    the members of a tuple into the arguments of the function:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，`std:invoke()`应该在模板元编程中用于调用具有任意数量参数的函数。为了说明这种情况，我们将展示`std::apply()`函数的可能实现，以及C++17标准库的一部分，它通过将元组的成员解包到函数的参数中调用函数：
- en: '[PRE103]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: How it works...
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Before we see how `std::invoke()` works, let’s have a quick look at how different
    callable objects can be invoked. Given a function, obviously, the ubiquitous way
    of invoking it is by directly passing it the necessary parameters. However, we
    can also invoke the function using function pointers. The trouble with function
    pointers is that defining the type of the pointer can be cumbersome. Using `auto`
    can simplify things (as shown in the following code), but in practice, you usually
    need to define the type of the pointer to function first, and then define an object
    and initialize it with the correct function address. Here are several examples:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解`std::invoke()`如何工作之前，让我们快速看一下如何调用不同的可调用对象。给定一个函数，显然，调用它的通用方式是直接传递必要的参数。然而，我们也可以使用函数指针来调用函数。函数指针的问题在于定义指针类型可能会很繁琐。使用`auto`可以简化事情（如下面的代码所示），但在实践中，你通常需要首先定义函数指针的类型，然后定义一个对象并用正确的函数地址初始化它。以下是一些示例：
- en: '[PRE104]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Calling through a function pointer becomes more cumbersome when you need to
    invoke a class function through an object that is an instance of the class. The
    syntax for defining the pointer to a member function and invoking it is not simple:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要通过类的实例调用类函数时，通过函数指针调用会变得更为繁琐。定义成员函数指针和调用它的语法并不简单：
- en: '[PRE105]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Regardless of how cumbersome this kind of call may look, the actual problem
    is writing library components (functions or classes) that are able to call any
    of these types of callable objects, in a uniform manner. This is what benefits,
    in practice, from a standard function, such as `std::invoke()`.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这种调用看起来多么繁琐，实际的问题是编写能够以统一方式调用这些类型可调用对象的库组件（函数或类）。这正是从标准函数，如`std::invoke()`中实际受益的地方。
- en: 'The implementation details of `std::invoke()` are complex, but the way it works
    can be explained in simple terms. Supposing the call has the form `invoke(f, arg1,
    arg2, ..., argN)`, then consider the following:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::invoke()`的实现细节很复杂，但可以用简单的话来解释它的工作方式。假设调用形式为`invoke(f, arg1, arg2, ...,
    argN)`，那么考虑以下：'
- en: 'If `f` is a pointer to a member function of a `T` class, then the call is equivalent
    to either:'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`f`是指向`T`类成员函数的指针，那么调用等同于以下两种情况之一：
- en: '`(arg1.*f)(arg2, ..., argN)`, if `arg1` is an instance of `T`'
  id: totrans-517
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`arg1`是`T`的实例，则为`(arg1.*f)(arg2, ..., argN)`
- en: '`(arg1.get().*f)(arg2, ..., argN)`, if `arg1` is a specialization of `reference_wrapper`'
  id: totrans-518
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`arg1`是`reference_wrapper`的特化，则为`(arg1.get().*f)(arg2, ..., argN)`
- en: '`((*arg1).*f)(arg2, ..., argN)`, if it is otherwise'
  id: totrans-519
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`((*arg1).*f)(arg2, ..., argN)`，如果它不是其他情况'
- en: 'If `f` is a pointer to a data member of a `T` class and there is a single argument—in
    other words, the call has the form `invoke(f, arg1)`—then the call is equivalent
    to either:'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`f`是指向`T`类数据成员的指针，并且有一个单独的参数——换句话说，调用形式为`invoke(f, arg1)`——那么调用等同于以下两种情况之一：
- en: '`arg1.*f` if `arg1` is an instance class `T`'
  id: totrans-521
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`arg1`是`T`的实例，则为`arg1.*f`
- en: '`arg1.get().*f` if `arg1` is a specialization of `reference_wrapper`'
  id: totrans-522
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`arg1`是`reference_wrapper`的特化，则为`arg1.get().*f`
- en: '`(*arg1).*f`, if it is otherwise'
  id: totrans-523
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(*arg1).*f`，如果它不是其他情况'
- en: If `f` is a function object, then the call is equivalent to `f(arg1, arg2, ...,
    argN)`
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`f`是一个函数对象，那么调用等同于`f(arg1, arg2, ..., argN)`
- en: 'The standard library also provides a series of related type traits: `std::is_invocable`
    and `std::is_nothrow_invocable` on the one hand, and `std::is_invocable_r` and
    `std::is_nothrow_invocable_r` on the other hand. The first set determines whether
    a function can be invocable with the supplied arguments, while the second determines
    whether it can be invocable with the supplied arguments and produce a result that
    can be implicitly converted to a specified type. The *nothrow* versions of these
    type traits verify that the call can be done without any exception being thrown.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库还提供了一系列相关的类型特性：一方面是`std::is_invocable`和`std::is_nothrow_invocable`，另一方面是`std::is_invocable_r`和`std::is_nothrow_invocable_r`。第一组确定一个函数是否可以用提供的参数调用，而第二组确定它是否可以用提供的参数调用并产生可以隐式转换为指定类型的结果。这些类型特性的*nothrow*版本验证调用可以在不抛出任何异常的情况下完成。
- en: As of C++20, the `std::invoke` function is `constexpr`, which means it can be
    used to invoke callable objects at compile-time.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 C++20，`std::invoke`函数是`constexpr`，这意味着它可以在编译时调用可调用对象。
- en: In C++23, a similar utility called `std::invoke_r` has been added. This has
    one additional template parameter (the first one), which is a type template parameter
    that represents the type of the return value (unless it is `void`) or a type to
    which the return value can be implicitly converted.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++23 中，已添加了一个类似的实用工具 `std::invoke_r`。它有一个额外的模板参数（第一个），它是一个表示返回值类型的类型模板参数（除非它是
    `void`），或者是一个可以将返回值隐式转换为的类型。
- en: See also
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Writing a function template with a variable number of arguments*, to see how
    variadic templates enable us to write functions that can take any number of arguments'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写一个带有可变数量参数的函数模板*，以了解变长模板如何使我们能够编写可以接受任意数量参数的函数'
- en: Learn more on Discord
  id: totrans-530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_03.xhtml)'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/7xRaTCeEhx](Chapter_03.xhtml)'
- en: '![](img/QR_Code2659294082093549796.png)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2659294082093549796.png)'
