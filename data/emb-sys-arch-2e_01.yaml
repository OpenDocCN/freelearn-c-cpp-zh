- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Embedded Systems – A Pragmatic Approach
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式系统 – 实用方法
- en: Designing and writing software for embedded systems poses a different set of
    challenges than traditional high-level software development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为嵌入式系统设计和编写软件与传统的高级软件开发相比，面临的是一套不同的挑战。
- en: This chapter provides an overview of these challenges and introduces the basic
    components and the platform that will be used as a reference in this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了这些挑战，并介绍了本书中将用作参考的基本组件和平台。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Domain definition
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域定义
- en: '**General-purpose** **input/output** (**GPIO**)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用** **输入/输出** （**GPIO**）'
- en: Interfaces and peripherals
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口和外设
- en: Connected systems
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接系统
- en: Introduction to isolation mechanisms
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离机制简介
- en: The reference platform
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考平台
- en: Domain definition
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域定义
- en: '**Embedded systems** are computing devices that perform specific, dedicated
    tasks with no direct or continued user interaction. Due to the variety of markets
    and technologies, these objects have different shapes and sizes, but often, all
    have a small size and a limited amount of resources.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌入式系统** 是执行特定、专用任务且没有直接或持续用户交互的计算设备。由于市场和技术的多样性，这些设备有不同的形状和大小，但通常，它们都具有较小的尺寸和有限的资源。'
- en: In this book, the concepts and the building blocks of embedded systems will
    be analyzed through the development of the software components that interact with
    their resources and peripherals. The first step is to define the scope for the
    validity of the techniques and the architectural patterns explained in this book,
    within the broader definition of embedded systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，将通过开发与它们的资源和外设交互的软件组件来分析嵌入式系统的概念和构建块。第一步是在嵌入式系统的更广泛定义内，定义本书中解释的技术和架构模式的适用范围。
- en: Embedded Linux systems
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌入式Linux系统
- en: One part of the embedded market relies on devices with enough power and resources
    to run a variant of the GNU/Linux OS. These systems, often referred to as **embedded
    Linux**, are outside the scope of this book, as their development includes different
    strategies of design and integration of the components. A typical hardware platform
    that is capable of running a system based on the Linux kernel is equipped with
    a reasonably large amount of RAM, up to a few gigabytes, and sufficient storage
    space on board to store all the software components provided in the GNU/Linux
    distribution.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式市场的一部分依赖于具有足够功率和资源来运行GNU/Linux OS变体的设备。这些系统通常被称为**嵌入式Linux**，本书的范围不包括它们，因为它们的发展包括组件设计和集成的不同策略。一个典型的能够运行基于Linux内核的系统的硬件平台配备了相当大的RAM，高达几吉字节，以及足够的存储空间来存储GNU/Linux发行版中提供的所有软件组件。
- en: Additionally, for the Linux memory management to provide separate virtual address
    spaces to each process on the system, the hardware must be equipped with a **memory
    management unit** (**MMU**), a hardware component that assists the OS in translating
    physical addresses into virtual addresses, and vice versa, at runtime.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了使Linux内存管理为系统上的每个进程提供独立的虚拟地址空间，硬件必须配备一个**内存管理单元**（**MMU**），这是一个辅助操作系统在运行时将物理地址转换为虚拟地址，反之亦然的硬件组件。
- en: This class of devices presents different characteristics that are often overkill
    for building tailored solutions, which can use a much simpler design and reduce
    the production costs of single units.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这类设备具有不同的特性，对于构建定制解决方案来说通常是过度的，这些解决方案可以使用更简单的设计并降低单件的生产成本。
- en: Hardware manufacturers and chip designers have researched new techniques to
    improve the performance of microcontroller-based systems. In the past few decades,
    they have introduced new generations of platforms that would cut hardware costs,
    firmware complexity, size, and power consumption to provide a set of features
    that are most interesting for the embedded market.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件制造商和芯片设计师已经研究了新技术来提高基于微控制器的系统的性能。在过去几十年中，他们引入了新一代的平台，这些平台将降低硬件成本、固件复杂性、尺寸和功耗，为嵌入式市场提供一套最有趣的功能。
- en: Due to their specifications, in some real-life scenarios, embedded systems must
    be able to execute a series of tasks within a short, measurable, and predictable
    amount of time. These kinds of systems are called **real-time systems** and differ
    from the approach of multi-task computing, which is used in desktops, servers,
    and mobile phones.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的规格，在某些实际场景中，嵌入式系统必须能够在短时间内执行一系列任务，这个时间是短、可测量和可预测的。这类系统被称为**实时系统**，与在桌面、服务器和移动电话中使用的多任务计算方法不同。
- en: '**Real-time processing** is a goal that is extremely hard, if not impossible,
    to reach on embedded Linux platforms. The Linux kernel is not designed for hard
    real-time processing, and even if patches are available to modify the kernel scheduler
    to help meet these requirements, the results are not comparable to bare-metal,
    constrained systems that are designed with this purpose in mind.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**实时处理**是嵌入式Linux平台上极难实现，如果不是不可能实现的目标。Linux内核不是为硬实时处理设计的，即使有补丁可以修改内核调度器以帮助满足这些要求，其结果也无法与专门为此目的设计的裸机、受限系统相提并论。'
- en: Some other application domains, such as battery-powered and energy-harvesting
    devices, can benefit from the low power consumption capabilities of smaller embedded
    devices and the energy efficiency of the wireless communication technologies often
    integrated into embedded connected devices. The higher amount of resources and
    the increased hardware complexity of Linux-based systems often do not scale down
    enough on energy levels or require effort to meet similar figures in power consumption.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他的应用领域，例如电池供电和能量收集设备，可以从较小的嵌入式设备的低功耗能力和通常集成到嵌入式连接设备中的无线通信技术的能效中受益。基于Linux的系统通常在资源量和硬件复杂度上不足以在能耗水平上降低，或者需要付出努力才能达到类似的能耗水平。
- en: The type of microcontroller-based systems that we will analyze in this book
    is 32-bit systems, which are capable of running software in a single-threaded,
    bare-metal application, as well as integrating minimalist real-time OSs, which
    are very popular in the industrial manufacturing of embedded systems, which we
    use daily to accomplish specific tasks. They are becoming more and more adopted
    to help define more generic, multiple-purpose development platforms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将分析基于微控制器的系统类型是32位系统，这些系统能够在单线程、裸机应用程序中运行软件，以及集成简约的实时操作系统，这些操作系统在嵌入式系统的工业制造中非常流行，我们每天使用它们来完成特定任务。它们越来越被采用，以帮助定义更通用、多用途的开发平台。
- en: Low-end 8-bit microcontrollers
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 低端8位微控制器
- en: In the past, **8-bit microcontrollers** dominated the embedded market. The simplicity
    of their design allows us to write small applications that can accomplish a set
    of predefined tasks but are too simple and usually equipped with too few resources
    to implement an embedded system, especially since 32-bit microcontrollers have
    evolved to cover all the use cases for these devices within the same range of
    price, size, and power consumption.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，**8位微控制器**主导了嵌入式市场。它们设计的简单性使我们能够编写能够完成一组预定义任务的小型应用程序，但过于简单，通常配备的资源很少，不足以实现嵌入式系统，尤其是在32位微控制器已经发展到覆盖这些设备在相同的价格、尺寸和功耗范围内的所有用例的情况下。
- en: Nowadays, 8-bit microcontrollers are mostly relegated to the market of educational
    platform kits, aimed at introducing hobbyists and newcomers to the basics of software
    development on electronic devices. 8-bit platforms are not covered in this book
    because they lack the characteristics that allow advanced system programming,
    multithreading, and advanced features to be developed to build professional embedded
    systems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，8位微控制器大多被限制在教育平台套件的市场上，旨在向业余爱好者和新手介绍电子设备上软件开发的基础。由于8位平台缺乏允许开发高级系统编程、多线程和高级功能以构建专业嵌入式系统的特性，本书不涵盖这些平台。
- en: In the context of this book, the term **embedded systems** is used to indicate
    a class of systems running on microcontroller-based hardware architecture, offering
    constrained resources but allowing real-time systems to be built through features
    provided by the hardware architecture to implement system programming.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的语境中，术语**嵌入式系统**指的是一类基于微控制器硬件架构运行的系统，提供有限的资源，但允许通过硬件架构提供的特性来构建实时系统，以实现系统编程。
- en: Hardware architecture
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件架构
- en: The architecture of an embedded system is centered around its microcontroller,
    also sometimes referred to as the **microcontroller unit** (**MCU**). This is
    typically a single integrated circuit containing the processor, RAM, flash memory,
    serial receivers and transmitters, and other core components. The market offers
    many different choices among architectures, vendors, price ranges, features, and
    integrated resources. These are typically designed to be inexpensive, low-resource,
    low-energy consuming, self-contained systems on a single integrated circuit, which
    is the reason why they are often referred to as **System-on-Chip** (**SoC**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统的架构围绕其微控制器构建，有时也称为**微控制器单元**（**MCU**）。这通常是一个包含处理器、RAM、闪存、串行接收器和发送器以及其他核心组件的单个集成电路。市场上提供了许多不同的架构、供应商、价格范围、功能和集成资源的选择。这些通常设计成低成本、低资源、低能耗、自包含的系统，集成在单个集成电路中，这也是它们通常被称为**片上系统**（**SoC**）的原因。
- en: Due to the variety of processors, memories, and interfaces that can be integrated,
    there is no actual reference architecture for microcontrollers. Nevertheless,
    some architectural elements are common across a wide range of models and brands,
    and even across different processor architectures.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以集成的处理器、内存和接口的多样性，微控制器实际上没有实际的参考架构。尽管如此，一些架构元素在广泛的型号和品牌中是通用的，甚至在不同的处理器架构之间也是通用的。
- en: Some microcontrollers are dedicated to specific applications and expose a particular
    set of interfaces to communicate to peripherals and the outside world. Others
    are focused on providing solutions with reduced hardware costs, or with very limited
    energy consumption.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一些微控制器专注于特定应用，并暴露出特定的接口与外围设备和外部世界通信。其他微控制器则专注于提供降低硬件成本或非常有限的能耗的解决方案。
- en: 'Nevertheless, the following set of components is hardcoded into almost every
    microcontroller:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，以下组件几乎被硬编码到每个微控制器中：
- en: '**Microprocessor**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微处理器**'
- en: '**RAM**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAM**'
- en: '**Flash memory**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**闪存**'
- en: '**Serial transceivers**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行收发器**'
- en: Additionally, more and more devices are capable of accessing a network, to communicate
    with other devices and gateways. Some microcontrollers may provide either well-established
    standards, such as *Ethernet or Wi-Fi interfaces*, or specific protocols specifically
    designed to meet the constraints of embedded systems, such as sub-GHz radio interfaces
    or a **Controller Area Network** (**CAN**) bus, being partially or fully implemented
    within the IC.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，越来越多的设备能够访问网络，以与其他设备和网关进行通信。一些微控制器可能提供已建立的标准，如 *以太网或Wi-Fi接口*，或者专门为满足嵌入式系统约束而设计的特定协议，如亚GHz无线接口或**控制器局域网**（**CAN**）总线，部分或全部在集成电路中实现。
- en: 'All the components must share a bus line with the processor, which is responsible
    for coordinating the logic. The RAM, flash memory, and control registers of the
    transceivers are all mapped in the same physical address space:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所有组件都必须与处理器共享总线线，处理器负责协调逻辑。RAM、闪存和收发器的控制寄存器都映射在相同的物理地址空间：
- en: '![Figure 1.1 – A simplified block diagram of the components inside a generic
    microcontroller](img/B18730_01_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 一个通用微控制器内部组件的简化框图](img/B18730_01_01.jpg)'
- en: Figure 1.1 – A simplified block diagram of the components inside a generic microcontroller
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 一个通用微控制器内部组件的简化框图
- en: The addresses where **RAM** and **Flash Memory** are mapped depend on the specific
    model and are usually provided in the datasheet. A microcontroller can run code
    in its native machine language; that is, a sequence of instructions conveyed into
    a binary file that is specific to the architecture it is running on. By default,
    compilers provide a generic executable file as the output of the compilation and
    assembly operations, which needs to be converted into a format that can be executed
    by the target.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**RAM** 和 **Flash Memory** 的映射地址取决于具体型号，通常在数据表中提供。微控制器可以在其原生机器语言中运行代码；也就是说，一系列指令被转换成特定于其运行架构的二进制文件。默认情况下，编译器提供通用可执行文件作为编译和汇编操作的输出，这需要转换成目标格式才能执行。'
- en: The **Processor** part is designed to execute the instructions that have been
    stored in its own specific binary format directly from RAM as well as from its
    internal flash memory. This is usually mapped starting from position zero in memory
    or another well-known address specified in the microcontroller manual. The CPU
    can fetch and execute code from RAM faster, but the final firmware is stored in
    the flash memory, which is usually bigger than the RAM on almost all microcontrollers
    and permits it to retain the data across power cycles and reboots.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理器**部分被设计用来直接从RAM以及其内部的闪存中执行存储在其自身特定二进制格式中的指令。这通常从内存中的零位置或微控制器手册中指定的另一个已知地址开始映射。CPU可以从RAM中更快地获取并执行代码，但最终的固件存储在闪存中，这通常比几乎所有微控制器上的RAM都要大，并且允许它在电源周期和重启之间保留数据。'
- en: Compiling a software operating environment for an embedded microcontroller and
    loading it onto the flash memory requires a host machine, which is a specific
    set of hardware and software tools. Some knowledge about the target device’s characteristics
    is also needed to instruct the compiler to organize the symbols within the executable
    image. For many valid reasons, C is the most popular language in embedded software,
    although not the only available option. Higher-level languages, such as Rust and
    C++, can produce embedded code when combined with a specific embedded runtime,
    or even in some cases by entirely removing the runtime support from the language.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为嵌入式微控制器编译软件操作系统并将其加载到闪存中需要一个主机机器，这是一套特定的硬件和软件工具。还需要了解目标设备特性的某些知识，以便指导编译器在可执行映像中组织符号。由于许多有效的原因，C是嵌入式软件中最流行的语言，尽管它不是唯一可用的选项。高级语言，如Rust和C++，在结合特定的嵌入式运行时或在某些情况下通过完全从语言中移除运行时支持的情况下，可以生成嵌入式代码。
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This book will focus entirely on C code because it abstracts less than any other
    high-level language, thus making it easier to describe the behavior of the underlying
    hardware while looking at the code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将完全专注于C代码，因为它比任何其他高级语言都更少抽象，这使得在查看代码的同时更容易描述底层硬件的行为。
- en: All modern embedded systems platforms also have at least one mechanism (such
    as **JTAG**) for debugging purposes and uploading the software to the flash. When
    the debugging interface is accessed from the host machine, a debugger can interact
    with the breakpoint unit in the processor, interrupting and resuming the execution,
    and can also read and write from any address in memory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代嵌入式系统平台至少都有一种机制（如**JTAG**）用于调试目的和将软件上传到闪存。当从主机机器访问调试接口时，调试器可以与处理器中的断点单元交互，中断和恢复执行，并且还可以从内存中的任何地址读取和写入。
- en: A significant part of embedded programming is communicating the peripherals
    while using the interfaces that the MCU exposes. Embedded software development
    requires basic knowledge of electronics, the ability to understand schematics
    and datasheets, and confidence with the measurement tools, such as logic analyzers
    or oscilloscopes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式编程的一个重要部分是在使用MCU公开的接口的同时与外围设备进行通信。嵌入式软件开发需要基本的电子知识，理解原理图和数据表的能力，以及使用测量工具（如逻辑分析仪或示波器）的信心。
- en: Understanding the challenges
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解挑战
- en: 'Approaching embedded development means keeping the focus on the specifications
    as well as the hardware restrictions at all times. Embedded software development
    is a constant challenge that requires focusing on the most efficient way to perform
    a set of specific tasks but keeping the limited resources available in strong
    consideration. There are several compromises to deal with, which are uncommon
    in other environments. Here are some examples:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接近嵌入式开发意味着始终关注规格以及硬件限制。嵌入式软件开发是一个持续的挑战，需要关注以最高效的方式执行一组特定任务，同时充分考虑可用的有限资源。需要处理一些妥协，这在其他环境中是不常见的。以下是一些例子：
- en: There might be not enough space in the flash to implement a new feature
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在闪存中可能没有足够的空间来实现一个新功能
- en: There might not be enough RAM to store complex structures or make copies of
    large data buffers
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能没有足够的RAM来存储复杂结构或复制大型数据缓冲区
- en: The processor might be not fast enough to accomplish all the required calculations
    and data processing in due time
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器可能不够快，无法及时完成所有必需的计算和数据处理
- en: Battery-powered and resource-harvesting devices might require lower energy consumption
    to meet lifetime expectations
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电池供电和能量收集设备可能需要更低的能耗以满足使用寿命的预期。
- en: Moreover, PC and mobile OSs make large use of the MMU, a component of the processor
    that allows runtime translations between physical and virtual addresses.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，PC和移动操作系统大量使用MMU（内存管理单元），这是处理器的一个组件，它允许在物理地址和虚拟地址之间进行运行时转换。
- en: The MMU is a necessary abstraction to implement address space separation among
    the tasks, as well as between the tasks and the kernel itself. Embedded microcontrollers
    do not have an MMU, and usually lack the amount of non-volatile memory required
    to store kernels, applications, and libraries. For this reason, embedded systems
    are often running in a single task, with the main loop performing all the data
    processing and communication in a specific order. Some devices can run embedded
    OSs, which are far less complex than their PC counterparts.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: MMU是实现任务之间以及任务与内核本身之间地址空间分离的必要抽象。嵌入式微控制器没有MMU，通常缺乏存储内核、应用程序和库所需的大量非易失性内存。因此，嵌入式系统通常在一个任务中运行，主循环按照特定顺序执行所有数据处理和通信。一些设备可以运行嵌入式操作系统，这些操作系统比它们的PC版本要简单得多。
- en: Application developers often see the underlying system as a commodity, while
    embedded development often means that the entire system has to be implemented
    from scratch, from the boot procedure up to the application logic. In an embedded
    environment, the various software components are more closely related to each
    other because of the lack of more complex abstractions, such as memory separations
    between the processes and the OS kernel.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发者通常将底层系统视为一种商品，而嵌入式开发通常意味着整个系统必须从头开始实现，从引导程序到应用程序逻辑。在嵌入式环境中，由于缺乏更复杂的抽象，如进程和操作系统内核之间的内存分离，各种软件组件之间关系更为紧密。
- en: A developer approaching embedded systems for the first time might find testing
    and debugging on some of the systems a bit more intricate than just running the
    software and reading out the results. This becomes especially true in those systems
    that have been designed with little or no human interaction interfaces.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首次接触嵌入式系统的开发者可能会发现，在某些系统中进行测试和调试比仅仅运行软件并读取结果要复杂得多。这在那些设计时几乎没有或没有人机交互界面的系统中尤其如此。
- en: A successful approach requires a healthy workflow, which includes well-defined
    test cases, a list of key performance indicators coming from the analysis of the
    specifications to identify possibilities of trade-offs, several tools and procedures
    at hand to perform all the needed measurements, and a well-established and efficient
    prototyping phase.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一种成功的方法需要健康的流程，这包括定义良好的测试用例、来自规格说明分析的关键性能指标列表，以确定权衡的可能性、可用于执行所有所需测量的工具和程序，以及一个建立良好且高效的原型阶段。
- en: In this context, security deserves some special consideration. As usual, when
    writing code at the system level, it is wise to keep in mind the system-wide consequences
    of possible faults. Most embedded application code runs with extended privileges
    on the hardware, and a single task misbehaving can affect the stability and integrity
    of the entire firmware. As we will see, some platforms offer specific memory protection
    mechanisms and built-in privilege separation, which are useful for building fail-safe
    systems, even in the absence of a full OS based on separating process address
    spaces.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个背景下，安全性值得特别考虑。通常，在系统级别编写代码时，考虑到可能的故障对整个系统的影响是明智的。大多数嵌入式应用程序代码在硬件上以扩展权限运行，单个任务的不当行为可能会影响整个固件的稳定性和完整性。正如我们将看到的，一些平台提供了特定的内存保护机制和内置的权限分离，这对于构建安全系统非常有用，即使在没有基于分离进程地址空间的完整操作系统的情况下也是如此。
- en: Multithreading
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程
- en: One of the advantages of using microcontrollers designed to build embedded systems
    is the possibility to run logically separated tasks within separate execution
    units by time-sharing the resources.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专为构建嵌入式系统设计的微控制器的一个优点是，可以通过时间共享资源在单独的执行单元中运行逻辑上分离的任务。
- en: The most popular type of design for embedded software is based on a single loop-based
    sequential execution model, where modules and components are connected to expose
    callback interfaces. However, modern microcontrollers offer features and core
    logic characteristics that can be used by system developers to build a multitasking
    environment to run logically separated applications.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式软件最流行的设计是基于单循环的顺序执行模型，其中模块和组件连接起来以暴露回调接口。然而，现代微控制器提供了系统开发者可以用来构建多任务环境以运行逻辑上分离的应用程序的功能和核心逻辑特性。
- en: These features are particularly handy in the approach to more complex real-time
    systems, and they help us understand the possibilities of the implementation of
    safety models based on process isolation and memory segmentation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性在处理更复杂的实时系统时特别有用，并帮助我们理解基于进程隔离和内存分段的实现安全模型的可能性。
- en: RAM
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RAM
- en: '*“640 KB of memory ought to be enough* *for everyone”*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*“640 KB的内存对每个人来说都应该足够了”*'
- en: '*– Bill Gates (founder and former director* *of Microsoft)*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*– 比尔·盖茨（微软的创始人兼前董事）*'
- en: This famous statement has been cited many times in the past three decades to
    underline the progress in technology and the outstanding achievements of the PC
    industry. While it may sound like a joke for many software engineers out there,
    it is still in these figures that embedded programming has to be thought about,
    more than 30 years after MS-DOS was initially released.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这句著名的话在过去三十年中被多次引用，以强调技术进步和PC行业的杰出成就。虽然对于许多软件工程师来说这可能听起来像是一个笑话，但30多年后，在MS-DOS最初发布之后，嵌入式编程仍然需要考虑这些数据。
- en: Although most embedded systems are capable of breaking that limit today, especially
    due to the availability of external DRAM interfaces, the simplest devices that
    can be programmed in C may have as little as 4 KB of RAM available to implement
    the entire system logic. This has to be taken into account when designing an embedded
    system, by estimating the amount of memory potentially needed for all the operations
    that the system has to perform, and the buffers that may be used at any time to
    communicate with peripherals and nearby devices.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数嵌入式系统今天都能够突破这个限制，尤其是由于外部DRAM接口的可用性，但可以用C语言编程的最简单设备可能只有4 KB的RAM来实施整个系统逻辑。在设计嵌入式系统时，必须考虑到这一点，通过估算系统必须执行的所有操作所需的潜在内存量，以及任何时间可能用于与外围设备和附近设备通信的缓冲区。
- en: The memory model at the system level is simpler than that of PCs and mobile
    devices. Memory access is typically done at the physical level, so all the pointers
    in your code are telling you the physical location of the data they are pointing
    to. In modern computers, the OS is responsible for translating physical addresses
    into a virtual representation of the running tasks.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 系统级别的内存模型比PC和移动设备的内存模型要简单。内存访问通常在物理级别进行，因此你代码中的所有指针都在告诉你它们所指向的数据的物理位置。在现代计算机中，操作系统负责将物理地址转换为运行任务的虚拟表示。
- en: The advantage of the physical-only memory access on those systems that do not
    have an MMU is the reduced complexity of having to deal with address translations
    while coding and debugging. On the other hand, some of the features that are implemented
    by any modern OS, such as process swapping and dynamically resizing address spaces
    through memory relocation, become cumbersome and sometimes impossible.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些没有MMU的系统中，仅物理内存访问的优势在于减少了在编码和调试时处理地址转换的复杂性。另一方面，任何现代操作系统实现的一些功能，如进程交换和通过内存重定位动态调整地址空间大小，变得繁琐，有时甚至不可能。
- en: Handling memory is particularly important in embedded systems. Programmers who
    are used to writing application code expect a certain level of protection to be
    provided by the underlying OS. A virtual address space does not allow memory areas
    to overlap, and the OS can easily detect unauthorized memory accesses and segmentation
    violations, so it promptly terminates the process and avoids having the whole
    system compromised.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统中处理内存尤为重要。习惯于编写应用程序代码的程序员期望底层操作系统提供一定级别的保护。虚拟地址空间不允许内存区域重叠，操作系统可以轻松检测未经授权的内存访问和段违规，因此它迅速终止进程，避免整个系统受到损害。
- en: On embedded systems, especially when writing bare-metal code, the boundaries
    of each address pool must be checked manually. Accidentally modifying a few bits
    in the wrong memory, or even accessing a different area of memory, may result
    in a fatal, irrevocable error. The entire system may hang, or, in the worst case,
    become unpredictable. A safe approach is required when handling memory in embedded
    systems, in particular when dealing with life-critical devices. Identifying memory
    errors too late in the development process is complex and often requires more
    resources than forcing yourself to write safe code and protecting the system from
    a programmer’s mistakes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统中，尤其是在编写裸机代码时，必须手动检查每个地址池的边界。意外修改错误内存中的几个位，甚至访问不同的内存区域，可能会导致致命的、不可撤销的错误。整个系统可能会挂起，或者在最坏的情况下变得不可预测。在嵌入式系统中处理内存时，特别是在处理生命关键设备时，需要采取安全的方法。在开发过程中太晚识别内存错误是复杂的，并且通常需要比强制自己编写安全代码并保护系统免受程序员错误更多的资源。
- en: Proper memory-handling techniques will be explained in [*Chapter 5*](B18730_05.xhtml#_idTextAnchor149),
    *Memory Management*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的内存处理技术将在[*第五章*](B18730_05.xhtml#_idTextAnchor149) *内存管理*中解释。
- en: Flash memory
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闪存内存
- en: In a server or a personal computer, the executable applications and libraries
    reside in storage devices. At the beginning of the execution, they are accessed,
    transformed, possibly uncompressed, and stored in RAM before the execution starts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器或个人计算机中，可执行应用程序和库驻留在存储设备上。在执行开始之前，它们被访问、转换，可能还会解压缩，并存储在RAM中。
- en: The firmware of an embedded device is, in general, one single binary file containing
    all the software components, which can be transferred to the internal flash memory
    of the MCU. Since the flash memory is directly mapped to a fixed address in the
    memory space, the processor is capable of sequentially fetching and executing
    single instructions from it with no intermediate steps. This mechanism is called
    **execute in** **place** (**XIP**).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式设备的固件通常是一个包含所有软件组件的单个二进制文件，可以传输到MCU的内部闪存内存中。由于闪存直接映射到内存空间中的一个固定地址，处理器能够无中间步骤地顺序从其中获取并执行单个指令。这种机制称为**原地执行**（**XIP**）。
- en: All non-modifiable sections on the firmware do not need to be loaded in memory
    and are accessible through direct addressing in the memory space. This includes
    not only the executable instructions but also all the variables that are marked
    as constant by the compiler. On the other hand, supporting XIP requires a few
    extra steps when preparing the firmware image to be stored in flash, and the linker
    needs to be instructed about the different memory-mapped areas on the target.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 软件固件上的所有不可修改部分不需要加载到内存中，并且可以通过内存空间中的直接寻址来访问。这包括不仅可执行指令，还包括所有被编译器标记为常量的变量。另一方面，支持XIP在准备存储在闪存中的固件映像时需要一些额外的步骤，并且需要指导链接器关于目标上的不同内存映射区域。
- en: The internal flash memory that is mapped in the address space of the microcontroller
    is not accessible for writing. Altering the content of the internal flash can
    be done only by using block-based access, due to the hardware characteristics
    of flash memory devices. Before changing the value of a single byte in flash memory,
    the whole block containing it must be erased and rewritten. The mechanism offered
    by most manufacturers to access block-based flash memory for writing is known
    as **In-Application Programming** (**IAP**). Some filesystem implementations take
    care of abstracting write operations on a block-based flash device, by creating
    a temporary copy of the block where the write operation is performed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在微控制器的地址空间中映射的内部闪存内存不可用于写入。由于闪存存储器的硬件特性，更改内部闪存的内容只能通过基于块的访问方式完成。在更改闪存内存中单个字节的值之前，必须先擦除并重写包含该字节的整个块。大多数制造商提供的用于写入基于块的闪存内存的机制被称为**应用内编程**（**IAP**）。一些文件系统实现通过创建一个临时副本来处理基于块的闪存设备上的写入操作，该副本在执行写入操作时使用。
- en: While selecting the components for a microcontroller-based solution, it is vital
    to match the size of the flash memory to the space required by the firmware. The
    flash is often one of the most expensive components in the MCU, so for deployment
    on a large scale, choosing an MCU with a smaller flash could be more cost-effective.
    Developing software with code size in mind is not very usual nowadays within other
    domains, but it may be required when trying to fit multiple features in such little
    storage. Finally, compiler optimizations may exist on specific architectures to
    reduce code size when building the firmware and linking its components.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择基于微控制器的解决方案的组件时，匹配闪存的大小与固件所需的空间至关重要。闪存通常是MCU中最昂贵的组件之一，因此在大规模部署时，选择具有较小闪存的MCU可能更经济。在其他领域，考虑到代码大小来开发软件现在并不常见，但在尝试将多个功能适应如此小的存储时可能需要这样做。最后，在构建固件及其组件链接时，某些架构上可能存在编译器优化，以减少代码大小。
- en: Additional non-volatile memories that reside outside of the MCU silicon can
    typically be accessed using specific interfaces, such as the **Serial Peripheral
    Interface**. External flash memories use different technologies than internal
    flash, which is designed to be fast and execute code in place. While being generally
    more dense and less expensive, external flash memories do not allow direct memory
    mapping in the physical address space, which makes them unsuitable for storing
    firmware images. This is because it would be impossible to execute the code fetching
    the instructions sequentially unless a mechanism is used to load the executable
    symbols in RAM – read access on these kinds of devices is performed one block
    at a time. On the other hand, write access may be faster compared to IAP, making
    these kinds of non-volatile memory devices ideal for storing data that is retrieved
    at runtime in some designs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在MCU硅芯片之外的非易失性存储器通常可以通过特定的接口访问，例如**串行外设接口**。外部闪存使用的技术与内部闪存不同，内部闪存旨在快速执行代码。虽然外部闪存通常更密集且成本更低，但它们不允许在物理地址空间中进行直接内存映射，这使得它们不适合存储固件映像。这是因为如果没有机制用于在RAM中加载可执行符号，那么执行按顺序获取指令的代码将是不可能的——在这些设备上，读取访问是按块一次进行的。另一方面，与IAP相比，写入访问可能更快，这使得这类非易失性存储器设备对于存储某些设计中在运行时检索的数据非常理想。
- en: General-purpose input/output (GPIO)
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用输入/输出（GPIO）
- en: The most basic functionality that can be achieved with any microcontroller is
    the possibility to control signals on specific pins of the integrated circuit.
    The microcontroller can turn a digital output on or off, which corresponds to
    a reference voltage to be applied to the pin when the value assigned to it is
    1, and zero volts when the value is 0\. In the same way, a pin can be used to
    detect a 1 or a 0 when the pin is configured as input. The software will read
    the digital value “1” when the voltage applied to it is higher than a certain
    threshold.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 任何微控制器都能实现的最基本功能是控制集成电路特定引脚上的信号。微控制器可以打开或关闭数字输出，这对应于当分配给它的值为1时应用于引脚的参考电压，而当值为0时为零伏特。同样，当引脚配置为输入时，可以使用引脚检测1或0。当施加的电压高于某个特定阈值时，软件将读取数字值“1”。
- en: ADC and DAC
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADC和DAC
- en: Some chips have onboard ADC controllers, which are capable of sensing the voltage
    that is applied to the pin and sampling it. This is often used to acquire measurements
    from input peripherals providing a variable voltage as output. The embedded software
    will be able to read the voltage, with an accuracy that depends on the predefined
    range.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一些芯片具有板载ADC控制器，能够检测施加到引脚上的电压并对其进行采样。这通常用于从提供可变电压输出的输入外围设备获取测量值。嵌入式软件能够读取电压，其精度取决于预定义的范围。
- en: A DAC controller is the inverse of an ADC controller, transforming a value on
    a microcontroller register into the corresponding voltage.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: DAC控制器是ADC控制器的逆过程，它将微控制器寄存器上的值转换为相应的电压。
- en: Timers and PWM
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定时器和PWM
- en: Microcontrollers may offer diverse ways to measure time. Often, there is at
    least one interface based on a countdown timer that can trigger an interrupt and
    automatically reset upon expiry.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器可能提供多种测量时间的方法。通常，至少有一个基于倒计时计时器的接口可以触发中断并在到期时自动重置。
- en: GPIO pins configured as output can be programmed to output a square wave with
    a preconfigured frequency and duty cycle. This is called **pulse-wave modulation**
    (**PWM**) and has several uses, from controlling output peripherals to dimming
    an LED or even playing an audible sound through a speaker.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 配置为输出的GPIO引脚可以编程为输出预配置频率和占空比的方波。这被称为**脉冲宽度调制**（**PWM**），有多个用途，从控制输出外设到调节LED亮度，甚至通过扬声器播放可听声音。
- en: More details about GPIO, interrupt timers, and watchdogs will be explored in
    [*Chapter 6*](B18730_06.xhtml#_idTextAnchor194), *General-Purpose Peripherals*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 关于GPIO、中断定时器和看门狗的更多详细信息将在[*第6章*](B18730_06.xhtml#_idTextAnchor194)，“通用外设”中探讨。
- en: Interfaces and peripherals
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口和外设
- en: 'To communicate with peripherals and other microcontrollers, several *de facto*
    standards are well established in the embedded world. Some of the external pins
    of the microcontroller can be programmed to carry out communication with external
    peripherals using specific protocols. A few of the common interfaces available
    on most architectures are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与外设和其他微控制器通信，嵌入式领域已经建立了几个**事实上的**标准。微控制器的一些外部引脚可以被编程以使用特定协议与外部外设进行通信。大多数架构上可用的常见接口如下：
- en: Asynchronous UART-based serial communication
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于异步UART的串行通信
- en: '**Serial Peripheral Interface** (**SPI**) bus'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行外围设备接口**（**SPI**）总线'
- en: '**Inter-integrated circuit** (**I**2**C**) bus'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成电路间**（**I**2**C**）总线'
- en: '**Universal Serial** **Bus** (**USB**)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用串行总线**（**USB**）'
- en: Let’s review each in detail.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一详细回顾。
- en: Asynchronous UART-based serial communication
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于异步UART的串行通信
- en: Asynchronous communication is provided by the **Universal Asynchronous Receiver-Transmitter**
    (**UART**). These kinds of interfaces, commonly known as **serial ports**, are
    called asynchronous because they do not need to share a clock signal to synchronize
    the sender and the receiver, but rather work on predefined clock rates that can
    be aligned while the communication is ongoing. Microcontrollers may contain multiple
    UARTs that can be attached to a specific set of pins upon request. Asynchronous
    communication is provided by UART as a full-duplex channel, through two independent
    wires, connecting the RX pin of each endpoint to the TX pin on the opposite side.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 异步通信由**通用异步收发传输器**（**UART**）提供。这些接口，通常被称为**串行端口**，之所以称为异步，是因为它们不需要共享时钟信号来同步发送方和接收方，而是根据预定义的时钟速率进行工作，这些速率可以在通信过程中对齐。微控制器可能包含多个UART，可以根据请求连接到特定的引脚集。UART作为全双工通道提供异步通信，通过两条独立的线连接每个端点的RX引脚到另一侧的TX引脚。
- en: To understand each other, the systems at the two endpoints must set up the UART
    using the same parameters. This includes the framing of the bytes on the wire
    and the frame rate. All of these parameters have to be known in advance by both
    endpoints to correctly establish a communication channel. Despite being simpler
    than the other types of serial communication, UART-based serial communication
    is still widely used in electronic devices, particularly as an interface for modems
    and GPS receivers. Furthermore, using TTL-to-USB serial converters, it is easy
    to connect a UART to a console on the host machine, which is often handy for providing
    log messages.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了相互理解，两个端点的系统必须使用相同的参数设置UART。这包括在电线上的字节封装和帧速率。所有这些参数都必须在通信通道正确建立之前由两个端点预先知道。尽管比其他类型的串行通信简单，但基于UART的串行通信在电子设备中仍然被广泛使用，尤其是作为调制解调器和GPS接收器的接口。此外，使用TTL到USB串行转换器，很容易将UART连接到主机上的控制台，这对于提供日志消息通常很方便。
- en: SPI
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SPI
- en: 'A different approach to classic UAR—based communication is **SPI**. Introduced
    in the late 1980s, this technology aimed to replace asynchronous serial communication
    toward peripherals by introducing several improvements:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对经典基于UAR的通信的一种不同方法是**SPI**。这种技术在20世纪80年代末推出，旨在通过引入几个改进来取代异步串行通信与外设之间的通信：
- en: Serial clock line to synchronize the endpoints
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 串行时钟线用于同步端点
- en: Master-slave protocol
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主从协议
- en: One-to-many communication over the same three-wire bus
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一条三线总线上进行一点对多点的通信
- en: The master device, usually the microcontroller, shares the bus with one or more
    slaves. To trigger the communication, a separate **slave select** (**SS**) signal
    is used to address each slave connected to the bus. The bus uses two independent
    signals for data transfer, one per direction, and a shared clock line that synchronizes
    the two ends of the communication. Due to the clock line being generated by the
    master, the data transfer is more reliable, making it possible to achieve higher
    bitrates than ordinary UART. One of the keys to the continued success of SPI over
    multiple generations of microcontrollers is the low complexity required for the
    design of slaves, which can be as simple as a single shift register. SPI is commonly
    used in sensor devices, LCDs, flash memory controllers, and network interfaces.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 主设备，通常是微控制器，与一个或多个从设备共享总线。为了触发通信，使用一个单独的**从设备选择**（**SS**）信号来寻址连接到总线的每个从设备。总线使用两个独立的信号进行数据传输，每个方向一个信号，以及一个共享的时钟线来同步通信的两端。由于时钟线是由主设备生成的，因此数据传输更可靠，这使得能够实现比普通UART更高的比特率。SPI在多代微控制器中持续成功的一个关键因素是，从设备的设计复杂性很低，可以简单到只是一个单级移位寄存器。SPI通常用于传感器设备、LCD、闪存控制器和网络接口。
- en: I2C
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I2C
- en: 'I2C is slightly more complex, and that is because it is designed with a different
    purpose in mind: *interconnecting multiple microcontrollers*, as well as multiple
    slave devices, on the same two-wire bus. The two signals are **serial clock**
    (**SCL**) and **serial data** (**SDA**). Unlike SPI or UART, the bus is half-duplex,
    as the two directions of the flow share the same signal. Thanks to a 7-bit slave-addressing
    mechanism incorporated in the protocol, it does not require additional signals
    dedicated to selecting the slaves. Multiple masters are allowed on the same line,
    given that all the masters in the system follow the arbitration logic in the case
    of bus contention.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: I2C稍微复杂一些，这是因为它是基于不同的目的设计的：*在相同的两线总线上连接多个微控制器*以及多个从设备。两个信号是**串行时钟**（**SCL**）和**串行数据**（**SDA**）。与SPI或UART不同，总线是半双工的，因为流量的两个方向共享相同的信号。得益于协议中集成的7位从设备寻址机制，它不需要为选择从设备而专门设置额外的信号。在相同的总线上允许有多个主设备，前提是系统中的所有主设备在总线争用时都遵循仲裁逻辑。
- en: USB
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: USB
- en: The USB protocol, originally designed to replace UART and include many protocols
    in the same hardware connector, is very popular in personal computers, portable
    devices, and a huge number of peripherals.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: USB协议最初设计用来取代UART并在同一硬件连接器中包含许多协议，因此在个人电脑、便携式设备和大量外围设备中非常流行。
- en: This protocol works in host-device mode, with one side of communication, the
    device, exposing services that can be used by the controller, on the host side.
    USB transceivers present in many microcontrollers can work in both modes. By implementing
    the upper layer of the USB standards, different types of devices can be emulated
    by the microcontroller, such as serial ports, storage devices, and point-to-point
    Ethernet interfaces, creating microcontroller-based USB devices that can be connected
    to a host system.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议以主机-设备模式工作，通信的一侧，即设备，在主机侧暴露出控制器可以使用的服务。许多微控制器中存在的USB收发器可以在两种模式下工作。通过实现USB标准的上层，微控制器可以模拟不同类型的设备，例如串行端口、存储设备和点对点以太网接口，从而创建可以连接到主机系统的基于微控制器的USB设备。
- en: If the transceiver supports host mode, the embedded system can act as a USB
    host, and devices can be connected to it. In this case, the system should implement
    device drivers and applications to access the functionality provided by the device.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收发器支持主机模式，嵌入式系统可以作为USB主机，设备可以连接到它。在这种情况下，系统应实现设备驱动程序和应用来访问设备提供的功能。
- en: When both modes are implemented on the same USB controller, the transceiver
    works in **on-the-go** (**OTG**) mode, and selecting and configuring the desired
    mode can be done at runtime.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当在同一USB控制器上实现两种模式时，收发器在**移动模式**（**OTG**）下工作，并且可以在运行时选择和配置所需的模式。
- en: A more extended introduction to some of the most common protocols used for communicating
    with peripherals and neighboring systems will be provided in [*Chapter 7*](B18730_07.xhtml#_idTextAnchor230),
    *Local* *Bus Interfaces*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B18730_07.xhtml#_idTextAnchor230)“本地总线接口”中，将提供对一些最常用的用于与外围设备和相邻系统通信的协议的更详细介绍。
- en: Connected systems
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接的系统
- en: An increasing number of embedded devices designed for different markets are
    now capable of network communication with their peers in the surrounding area
    or with gateways routing their traffic to a broader network or the internet. The
    term **Internet of Things** (**IoT**) has been used to describe the networks where
    those embedded devices can communicate using internet protocols.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在越来越多的嵌入式设备，针对不同的市场设计，现在能够与其周围区域的同侪进行网络通信，或者通过网关路由其流量到更广泛的网络或互联网。术语**物联网**（**IoT**）被用来描述那些嵌入式设备可以使用互联网协议进行通信的网络。
- en: This means that IoT devices can be addressed within the network in the same
    way as more complex systems, such as PCs or mobile devices, and most importantly,
    they use the transport layer protocols typical of internet communications to exchange
    data. TCP/IP is a suite of protocols standardized by the IETF, and it is the fabric
    of the infrastructure for the internet and other self-contained, local area networks.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着物联网设备可以在网络中像更复杂的系统（如PC或移动设备）一样被寻址，最重要的是，它们使用互联网通信典型的传输层协议来交换数据。TCP/IP是由IETF标准化的协议套件，它是互联网和其他自包含局域网基础设施的基石。
- en: The **Internet Protocol** (**IP**) provides network connectivity, but on the
    condition that the underlying link provides packet-based communication and mechanisms
    to control and regulate access to the physical media. Fortunately, many network
    interfaces meet these requirements. Alternative protocol families, which are not
    compatible with TCP/IP, are still in use in several distributed embedded systems,
    but a clear advantage of using the TCP/IP standard on the target is that, in the
    case of communication with non-embedded systems, there is no need for a translation
    mechanism to route the frames outside the scope of the LAN.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**互联网协议**（**IP**）提供网络连接，但前提是底层链接提供基于分组的通信以及控制和调节对物理媒体的访问机制。幸运的是，许多网络接口都满足这些要求。虽然一些分布式嵌入式系统仍在使用与TCP/IP不兼容的替代协议族，但在目标上使用TCP/IP标准的一个明显优势是，在与非嵌入式系统通信的情况下，无需翻译机制来路由超出局域网范围的帧。'
- en: Besides the types of links that are widely used in non-embedded systems, such
    as Ethernet or wireless LAN, embedded systems can benefit from a wide choice of
    technologies that are specifically designed for the requirements introduced by
    IoT. New standards have been researched and put into effect to provide efficient
    communication for constrained devices, defining communication models to cope with
    specific resource usage limits and energy efficiency requirements.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在非嵌入式系统中广泛使用的链接类型，如以太网或无线局域网，嵌入式系统还可以从专门为物联网引入的需求设计的广泛技术中受益。已经研究了新的标准并将其付诸实施，以提供对受限设备的有效通信，定义通信模型以应对特定的资源使用限制和能源效率要求。
- en: Recently, new link technologies have been developed in the direction of lower
    bitrates and power consumption for wide-area network communication. These protocols
    are designed to provide narrow-band, long-range communication. The frame is too
    small to fit IP packets, so these technologies are mostly employed to transmit
    small payloads, such as periodic sensor data, or device configuration parameters
    if a bidirectional channel is available, and they require some form of gateway
    to translate the communication so that it can travel across the internet.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，新的链路技术已经开发出来，旨在为广域网络通信提供更低的比特率和功耗。这些协议旨在提供窄带、长距离通信。帧太小，无法容纳IP数据包，因此这些技术主要用于传输小型有效载荷，例如周期性传感器数据，或者如果存在双向通道，则用于传输设备配置参数，并且它们需要某种形式的网关来翻译通信，以便它可以通过互联网传输。
- en: The interaction with the cloud services, however, requires, in most cases, connecting
    all the nodes in the network, and implementing the same technologies used by the
    servers and the IT infrastructure directly in the host. Enabling TCP/IP communication
    on an embedded device is not always straightforward. Even though there are several
    open source implementations available, system TCP/IP code is complex, big in size,
    and often has memory requirements that may be difficult to meet.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与云服务交互通常需要连接网络中的所有节点，并在主机中直接实现服务器和IT基础设施所使用的相同技术。在嵌入式设备上启用TCP/IP通信并不总是直接的。尽管有几种开源实现可供选择，但系统TCP/IP代码复杂，体积庞大，并且通常具有可能难以满足的内存需求。
- en: The same observation applies to the **Secure Socket Layer** (**SSL**)/**Transport
    Layer Security** (**TLS**) library, which adds confidentiality and authentication
    between the two communication endpoints. Choosing the right microcontroller for
    the task is, again, crucial, and if the system has to be connected to the internet
    and support secure socket communication, then the flash and RAM requirements have
    to be updated in the design phase to ensure integration with third-party libraries.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的观察也适用于**安全套接字层**（**SSL**）和**传输层安全性**（**TLS**）库，它为两个通信端点之间增加了机密性和认证。选择合适的微控制器对于任务至关重要，如果系统需要连接到互联网并支持安全套接字通信，那么在设计阶段就必须更新闪存和RAM的要求，以确保与第三方库的集成。
- en: Challenges of distributed systems
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式系统的挑战
- en: Designing distributed embedded systems, especially those that are based on wireless
    link technologies, adds a set of interesting challenges.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 设计分布式嵌入式系统，尤其是基于无线链路技术的系统，增加了一系列有趣的挑战。
- en: 'Some of these challenges are related to the following aspects:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些挑战中的一些与以下方面相关：
- en: Selecting the correct technologies and protocols
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择正确的技术和协议
- en: Limitations on bitrate, packet size, and media access
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对比特率、包大小和媒体访问的限制
- en: Availability of the nodes
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点的可用性
- en: Single points of failure in the topology
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拓扑中的单点故障
- en: Configuring the routes
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置路由
- en: Authenticating the hosts involved
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证涉及的宿主
- en: The confidentiality of the communication over the media
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体上通信的机密性
- en: The impact of buffering on network speed, latency, and RAM usage
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲对网络速度、延迟和RAM使用的影响
- en: The complexity of implementing the protocol stacks
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现协议栈的复杂性
- en: '[*Chapter 9*](B18730_09.xhtml#_idTextAnchor311), *Distributed Systems and IoT
    Architecture*, analyzes some of the link-layer technologies implemented in embedded
    systems to provide remote communication, where TCP/IP communication is integrated
    into the design of distributed systems that are integrated with IoT services.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第9章*](B18730_09.xhtml#_idTextAnchor311)，*分布式系统和物联网架构*，分析了嵌入式系统中实现的一些链路层技术，以提供远程通信，其中TCP/IP通信被集成到与物联网服务集成的分布式系统设计中。'
- en: Introduction to isolation mechanisms
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离机制的介绍
- en: Some newer microcontrollers include support for isolation between trusted and
    non-trusted software running onboard. This mechanism is based on a CPU extension,
    available only on some specific architectures, which usually relies on a sort
    of physical separation inside the CPU itself between the two modes of execution.
    All the code running from a non-trusted zone in the system will have a restricted
    view of the RAM, devices, and peripherals, which must be dynamically configured
    by the trusted counterpart in advance.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一些较新的微控制器包括对在板上运行的受信任和非受信任软件之间隔离的支持。这种机制基于一种仅在特定架构上可用的CPU扩展，通常依赖于CPU内部两种执行模式之间的一种物理分离。系统中的所有非受信任区域运行的代码都将对RAM、设备和外围设备有一个受限的视图，这必须由受信任的对应方提前动态配置。
- en: Software running from the trusted area can also provide features that are not
    directly accessible from the non-trusted world, through special function calls
    that cross the secure/non-secure boundary.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从受信任区域运行的软件也可以通过跨越安全/非安全边界的特殊功能调用，提供非受信任世界无法直接访问的功能。
- en: '[*Chapter 11*](B18730_11.xhtml#_idTextAnchor403), *Trusted Execution Environment*,
    explores the technology behind **Trust Execution Environments** (**TEEs**), as
    well as the software components involved in real embedded systems to provide a
    safe environment to run non-trusted modules and components.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第11章*](B18730_11.xhtml#_idTextAnchor403)，*可信执行环境*，探讨了**可信执行环境**（**TEEs**）背后的技术，以及涉及实际嵌入式系统的软件组件，以提供一个安全的环境来运行非信任模块和组件。'
- en: The reference platform
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考平台
- en: 'The preferred design strategy for embedded CPU cores is **reduced instruction
    set computer** (**RISC**). Among all the RISC CPU architectures, several reference
    designs are used as guidelines by silicon manufacturers to produce the core logic
    to integrate into the microcontroller. Each reference design differs from the
    others in several characteristics of the CPU implementation. Each reference design
    includes one or more families of microprocessors integrated into embedded systems,
    which share the following characteristics:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式CPU核心的首选设计策略是**精简指令集计算机**（**RISC**）。在所有RISC CPU架构中，硅制造商使用几个参考设计作为指导，以生产集成到微控制器中的核心逻辑。每个参考设计在CPU实现的不同特性方面与其他设计有所不同。每个参考设计包括一个或多个集成到嵌入式系统中的微处理器系列，它们具有以下共同特征：
- en: Word size used for registers and addresses (8-bit, 16-bit, 32-bit, or 64-bit)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于寄存器和地址的词大小（8位、16位、32位或64位）
- en: Instruction set
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令集
- en: Register configurations
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器配置
- en: Endianness
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字节序
- en: Extended CPU features (interrupt controller, FPU, MMU)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展的CPU特性（中断控制器、FPU、MMU）
- en: Caching strategies
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存策略
- en: Pipeline design
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流水线设计
- en: Choosing a reference platform for your embedded system depends on your project
    needs. Smaller, less feature-rich processors are generally more suited to low
    energy consumption, have a smaller MCU packaging, and are less expensive. Higher-end
    systems, on the other hand, come with a bigger set of resources and some of them
    have dedicated hardware to cope with challenging calculations (such as a floating-point
    unit, or an **Advanced Encryption Standard** (**AES**) hardware module to offload
    symmetric encryption operations). 8-bit and 16-bit core designs are slowly giving
    way to 32-bit architectures, but some successful designs remain relatively popular
    in some niche markets and among hobbyists.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的嵌入式系统选择参考平台取决于您的项目需求。较小的、功能较少的处理器通常更适合低功耗、较小的MCU封装和较低的成本。另一方面，高端系统提供更大的资源集，其中一些系统具有专门的硬件来处理具有挑战性的计算（例如浮点单元或用于卸载对称加密操作的**高级加密标准**（**AES**）硬件模块）。8位和16位核心设计正在逐渐被32位架构取代，但一些成功的方案在特定市场和爱好者中仍然相对流行。
- en: ARM reference design
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ARM参考设计
- en: ARM is the most ubiquitous reference design supplier in the embedded market,
    with more than 10 billion ARM-based microcontrollers produced for embedded applications.
    One of the most interesting core designs in the embedded industry is the ARM Cortex-M
    family, which includes a range of models scaling from cost-effective and energy-efficient,
    to high-performance cores specifically designed for multimedia microcontrollers.
    Despite ranging among three different instruction sets (ARMv6, ARMv7, and ARMv8),
    all Cortex-M CPUs share the same programming interface, which improves portability
    across microcontrollers in the same families.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ARM是嵌入式市场中最普遍的参考设计供应商，为嵌入式应用生产了超过100亿个基于ARM的微控制器。嵌入式行业中一些最有趣的内核设计之一是ARM Cortex-M系列，该系列包括一系列从成本效益和节能到专为多媒体微控制器设计的高性能核心。尽管它们分布在三个不同的指令集（ARMv6、ARMv7和ARMv8）中，但所有Cortex-M
    CPU都共享相同的编程接口，这提高了同一系列微控制器之间的可移植性。
- en: Most of the examples in this book will be based on this family of CPUs. Though
    most of the concepts expressed will apply to other core designs as well, picking
    a reference platform now opens the door to a more complete analysis of the interactions
    with the underlying hardware. In particular, some of the examples in this book
    use specific assembly instructions from the ARMv7 instruction set, which is implemented
    in some Cortex-M CPU cores.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数示例将基于这一系列的CPU。尽管其中表达的大部分概念也适用于其他核心设计，但选择一个参考平台现在可以打开对底层硬件交互进行更全面分析的大门。特别是，本书中的一些示例使用了ARMv7指令集的特定汇编指令，这些指令在Cortex-M
    CPU核心中实现。
- en: The Cortex-M microprocessor
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cortex-M微处理器
- en: 'The main characteristic of the 32-bit cores in the Cortex-M family are as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Cortex-M系列32位核心的主要特征如下：
- en: 16 generic-purpose CPU registers
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16个通用CPU寄存器
- en: Thumb 16-bit only instructions for code density optimizations
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅适用于代码密度优化的Thumb 16位指令
- en: A built-in **Nested Vector Interrupt Controller** (**NVIC**) with 8 to 16 priority
    levels
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置**嵌套向量中断控制器**（**NVIC**），具有8到16个优先级级别
- en: ARMv6-M (M0, M0+), ARMv7-M (M3, M4, M7), or ARMv8-M (M23, M33) architecture
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARMv6-M（M0、M0+）、ARMv7-M（M3、M4、M7）或ARMv8-M（M23、M33）架构
- en: Optional 8-region **memory protection** **unit** (**MPU**)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的8区域**内存保护单元**（**MPU**）
- en: Optional TEE isolation mechanism (ARM TrustZone-M)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选TEE隔离机制（ARM TrustZone-M）
- en: The total memory address space is 4 GB. The beginning of the internal RAM is
    typically mapped at the fixed address of `0x20000000`. The mapping of the internal
    flash, as well as the other peripherals, depends on the silicon manufacturer.
    However, the highest 512 MB (`0xE0000000` to `0xFFFFFFFF`) addresses are reserved
    for the **System Control Block** (**SCB**), which groups together several configuration
    parameters and diagnostics that can be accessed by the software at any time to
    directly interact with the core.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 总内存地址空间为4 GB。内部RAM的起始地址通常映射到固定的地址`0x20000000`。内部闪存以及其他外设的映射取决于硅制造商。然而，最高的512
    MB（`0xE0000000`到`0xFFFFFFFF`）地址被保留用于**系统控制块**（**SCB**），它将多个配置参数和诊断信息组合在一起，软件可以在任何时间访问这些信息，以直接与核心交互。
- en: Synchronous communication with peripherals and other hardware components can
    be triggered through interrupt lines. The processor can receive and recognize
    several different digital input signals and react to them promptly, interrupting
    the execution of the software and temporarily jumping to a specific location in
    the memory. Cortex-M supports up to 240 interrupt lines on the high-end cores
    of the family.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 同步与外设和其他硬件组件的通信可以通过中断线触发。处理器可以接收和识别几种不同的数字输入信号，并迅速对其做出反应，中断软件的执行并临时跳转到内存中的特定位置。Cortex-M系列高端核心支持多达240条中断线。
- en: The interrupt vector, located at the beginning of the software image in flash,
    contains the addresses of the interrupt routines that will automatically execute
    on specific events. Thanks to the NVIC, interrupt lines can be assigned priorities
    so that when a higher-priority interrupt occurs while the routine for a lower
    interrupt is executed, the current interrupt routine is temporarily suspended
    to allow the higher-priority interrupt line to be serviced. This ensures minimal
    interrupt latency for these signal lines, which are somewhat critical for the
    system to execute as fast as possible.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 中断向量位于闪存软件图像的起始位置，包含将在特定事件上自动执行的中断例程的地址。得益于NVIC，中断线可以分配优先级，以便在执行较低优先级中断的例程时发生更高优先级的中断，当前的中断例程将暂时挂起，以便为更高优先级的中断线提供服务。这确保了这些信号线的最小中断延迟，这对于系统尽可能快地执行是相当关键的。
- en: 'At any time, the software on the target can run in two privilege modes: unprivileged
    or privileged. The CPU has built-in support for privilege separation between system
    and application software, even providing two different registers for the two separate
    stack pointers. In [*Chapter 10*](B18730_10.xhtml#_idTextAnchor357), *Parallel
    Tasks and Scheduling*, we will examine how to properly implement privilege separation,
    as well as how to enforce memory separation when running untrusted code on the
    target, in more detail. This is, for example, used to hide secrets such as private
    keys from direct access from the non-secure world. In [*Chapter 11*](B18730_11.xhtml#_idTextAnchor403),
    *Trusted Execution Environment*, we will learn how to properly implement privilege
    separation, as well as how to enforce memory separation within an OS when running
    application code on the target with a different level of trust.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时刻，目标上的软件都可以在两种权限模式下运行：非特权或特权模式。CPU内置了对系统软件和应用软件之间权限分离的支持，甚至为两个独立的栈指针提供了两个不同的寄存器。在[*第10章*](B18730_10.xhtml#_idTextAnchor357)“并行任务与调度”中，我们将更详细地探讨如何正确实现权限分离，以及如何在目标上运行不受信任的代码时强制执行内存分离。例如，这用于隐藏诸如私钥之类的秘密，防止非安全世界直接访问。在[*第11章*](B18730_11.xhtml#_idTextAnchor403)“可信执行环境”中，我们将学习如何正确实现权限分离，以及如何在目标上以不同信任级别运行应用代码时，在操作系统内部强制执行内存分离。
- en: A Cortex-M core is present in many microcontrollers, from different silicon
    vendors. Software tools are similar for all the platforms, but each MCU has a
    different configuration to take into account. Convergence libraries are available
    to hide manufacturer-specific details and improve portability across different
    models and brands. Manufacturers provide reference kits and all the documentation
    required to get started, which are intended to be used for evaluation during the
    design phase, and may also be useful for developing prototypes at a later stage.
    Some of these evaluation boards are equipped with sensors, multimedia electronics,
    or other peripherals that extend the functionality of the microcontroller. Some
    even include preconfigured, third-party “middleware” libraries such as TCP/IP
    communication stacks, TLS and cryptography libraries, simple filesystems and other
    accessory components, and modules that can be quickly and easily added to a software
    project.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 许多微控制器中都有 Cortex-M 内核，来自不同的硅供应商。软件工具对所有平台都是相似的，但每个微控制器都有不同的配置需要考虑。收敛库可用于隐藏制造商特定的细节，并提高不同型号和品牌之间的可移植性。制造商提供参考套件和所有必要的文档以供入门，这些套件旨在在设计阶段进行评估，也可能在后续阶段开发原型时有用。其中一些评估板配备了传感器、多媒体电子设备或其他外设，以扩展微控制器的功能。甚至有些包括预配置的第三方“中间件”库，如
    TCP/IP 通信栈、TLS 和加密库、简单的文件系统以及其他辅助组件，以及可以快速轻松添加到软件项目中的模块。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: When approaching embedded software requirements, before anything else, you must
    have a good understanding of the hardware platform and its components. By describing
    the architecture of modern microcontrollers, this chapter pointed out some of
    the peculiarities of embedded devices and how developers should efficiently rethink
    their approach to meeting requirements and solving problems, while at the same
    time taking into account the features and the limits of the target platform.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在接近嵌入式软件需求时，首先必须对硬件平台及其组件有一个良好的理解。通过描述现代微控制器的架构，本章指出了嵌入式设备的一些特性以及开发者应该如何高效地重新思考满足需求和解决问题的方法，同时考虑到目标平台的功能和限制。
- en: In the next chapter, we will analyze the tools and procedures typically used
    in embedded development, including command-line toolchains and **integrated development
    environments** (**IDEs**). We will understand how to organize the workflow and
    how to effectively prevent, locate, and fix bugs.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将分析嵌入式开发中通常使用的工具和流程，包括命令行工具链和**集成开发环境**（**IDEs**）。我们将了解如何组织工作流程以及如何有效地预防、定位和修复错误。
