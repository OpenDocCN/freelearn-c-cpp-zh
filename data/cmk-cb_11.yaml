- en: Writing an Installer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写安装程序
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下节：
- en: Installing your project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装你的项目
- en: Generating export headers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成导出头文件
- en: Exporting your targets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出你的目标
- en: Installing a superbuild
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装超级构建
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: 'In previous chapters, we have shown how to configure, build, and test our projects
    using CMake. Installing projects is an equally important part of the developer''s
    toolbox, and this chapter will demonstrate how to achieve that. The recipes in
    this chapter cover the install-time operations outlined in the following diagram:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们已经展示了如何使用CMake配置、构建和测试我们的项目。安装项目是开发者工具箱中同样重要的一部分，本章将展示如何实现这一点。本章的节涵盖了以下图中概述的安装时操作：
- en: '![](img/fec2ff3d-3814-4c4d-906e-dca48eece499.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fec2ff3d-3814-4c4d-906e-dca48eece499.jpg)'
- en: 'We will walk you through the various steps to be taken in refining the installation
    of a simple C++ project: from making sure that important files built in your project
    are copied over to the right directories, to ensuring that other projects depending
    on your work can detect it using CMake. The four recipes in this chapter will
    build upon the simple example given in [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml),
    *From a Simple Executable to Libraries*, Recipe 3, *Building and linking shared
    and static libraries*. There we tried to build a very simple library and link
    it into an executable. We also showed how to build both a static and a shared
    library out of the same source files. In this chapter, we will go a bit deeper
    and discuss and formalize what happens at install time.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引导你完成精简一个简单的C++项目安装的各个步骤：从确保项目中构建的重要文件被复制到正确的目录，到确保依赖于你的工作的其他项目可以使用CMake检测到它。本章的四个节将基于[第一章](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml)，*从简单可执行文件到库*，第3节，*构建和链接共享和静态库*中给出的简单示例。在那里我们尝试构建一个非常简单的库并将其链接到一个可执行文件中。我们还展示了如何从相同的源文件构建静态和共享库。在本章中，我们将更深入地讨论并正式化安装时发生的事情。
- en: Installing your project
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装你的项目
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-01) and
    has a C++ example. The recipe is valid with CMake version 3.6 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-01)找到，并包含一个C++示例。本节适用于CMake版本3.6（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: In this very first recipe, we will introduce our small project and some of the
    basic concepts that will be used also in the subsequent recipes. Installing files,
    libraries, and executables is a very basic task, but it can present some pitfalls.
    We will walk you through these and show you how to effectively avoid many of them
    with CMake.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一节中，我们将介绍我们的小项目以及将在后续节中使用的一些基本概念。安装文件、库和可执行文件是一项非常基本的任务，但它可能会带来一些陷阱。我们将引导你了解这些陷阱，并展示如何使用CMake有效地避免其中的许多陷阱。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The code from [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml), *From
    a Simple Executable to Libraries*, Recipe 3, *Building and linking shared and
    static libraries*, is used almost unaltered: we will only add a dependency on
    the UUID library. This dependency is conditional, and if the UUID library is not
    found, we will exclude the code using it *via* the preprocessor. The code is properly
    organized into its own `src` subdirectory. The layout of the project is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[第一章](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml)，*从简单可执行文件到库*，第3节，*构建和链接共享和静态库*的代码几乎未作改动地被使用：我们仅添加了对UUID库的依赖。这种依赖是有条件的，如果找不到UUID库，我们将通过预处理器排除使用它的代码。代码被适当地组织到自己的`src`子目录中。项目的布局如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can already see that we have a root `CMakeLists.txt` with one leaf under
    the `src` subdirectory and another under the `tests` subdirectory.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经可以看到，我们有一个根`CMakeLists.txt`，在`src`子目录下有一个叶子，在`tests`子目录下有另一个叶子。
- en: 'The `Message.hpp` header file contains the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Message.hpp`头文件包含以下内容：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is the corresponding implementation in `Message.cpp`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Message.cpp`中相应的实现：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, the sample `hello-world.cpp` executable is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，示例`hello-world.cpp`可执行文件如下：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let us first go through the root `CMakeLists.txt` file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先浏览一下根`CMakeLists.txt`文件：
- en: 'We start, as usual, by requiring a minimum CMake version and defining a C++11
    project. Note that we have set a version for our project with the `VERSION` keyword
    to the `project` command:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们像往常一样，首先要求一个最小CMake版本并定义一个C++11项目。请注意，我们已使用`VERSION`关键字为`project`命令设置了项目版本：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The user can define the installation prefix by means of the `CMAKE_INSTALL_PREFIX`
    variable. CMake will set a sensible default for this variable: `/usr/local` on
    Unix and `C:\Program Files` on Windows, respectively. We print a status message
    reporting its value:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以通过`CMAKE_INSTALL_PREFIX`变量定义安装前缀。CMake将为该变量设置一个合理的默认值：在Unix上是`/usr/local`，在Windows上是`C:\Program
    Files`。我们打印一条状态消息报告其值：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By default, we prefer `Release` configuration for our project. The user will
    be able to set this with the `CMAKE_BUILD_TYPE` variable and we check whether
    that is the case. If not, we set it ourselves to the default, sensible value:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，我们为项目首选`Release`配置。用户将能够使用`CMAKE_BUILD_TYPE`变量设置此项，我们检查是否是这种情况。如果不是，我们将其设置为我们自己的默认合理值：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next we tell CMake where to build the executable, static, and shared library
    targets. This facilitates access to these build targets in case the user does
    not intend to actually install the project. We use the standard CMake `GNUInstallDirs.cmake`
    module. This will guarantee a sensible and portable project layout:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们告诉CMake在哪里构建可执行文件、静态库和共享库目标。这便于用户在不打算实际安装项目的情况下访问这些构建目标。我们使用标准的CMake `GNUInstallDirs.cmake`模块。这将确保一个合理且可移植的项目布局：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Whereas the previous commands fixed the location of build output *within* the
    build directory, the following are needed to fix the location of executables,
    libraries, and include files within the install prefix. These will broadly follow
    the same layout, but we define the new `INSTALL_LIBDIR`, `INSTALL_BINDIR`, `INSTALL_INCLUDEDIR`,
    and `INSTALL_CMAKEDIR` variables, which the users can override, if they are so
    inclined:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然之前的命令固定了构建输出在构建目录内的位置，但以下命令需要固定可执行文件、库和包含文件在安装前缀内的位置。这些将大致遵循相同的布局，但我们定义了新的`INSTALL_LIBDIR`、`INSTALL_BINDIR`、`INSTALL_INCLUDEDIR`和`INSTALL_CMAKEDIR`变量，用户可以覆盖这些变量，如果他们愿意的话：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We report the paths where components will be installed to the user:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向用户报告组件将被安装到的路径：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last directives in the root `CMakeLists.txt` file add the `src` subdirectory,
    enable testing, and add the `tests` subdirectory:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根`CMakeLists.txt`文件中的最后指令添加了`src`子目录，启用了测试，并添加了`tests`子目录：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We now move on to analyze the `src/CMakeLists.txt` leaf. This file defines
    the actual targets to build:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在继续分析`src/CMakeLists.txt`叶文件。该文件定义了实际要构建的目标：
- en: 'Our project depends on the UUID library. As shown in [Chapter 5](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml),
    *Configure-time and Build-time Operations*, Recipe 8, *Probing execution*, we
    can find it with the following snippet:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的项目依赖于UUID库。如[第5章](9612acc1-56f6-4158-a55f-9a9db3714759.xhtml)，*配置时间和构建时间操作*，配方8，*探测执行*所示，我们可以使用以下代码片段找到它：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We wish to build a shared library out of our sources and we declare a target
    called `message-shared`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望从源代码构建一个共享库，并声明一个名为`message-shared`的目标：
- en: '[PRE14]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The sources for this target are specified with the `target_sources` command:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`target_sources`命令指定此目标的源：
- en: '[PRE15]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We declare compile definitions and link libraries for our target. Note that
    all are `PUBLIC`, to ensure that all dependent targets will inherit them properly:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为目标声明编译定义和链接库。请注意，所有这些都是`PUBLIC`，以确保所有依赖目标将正确继承它们：
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then we set additional properties of our target. We will comment upon these
    shortly.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们设置目标的额外属性。我们将在稍后对此进行评论。
- en: '[PRE17]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we add an executable target for our "Hello, world" program:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为我们的“Hello, world”程序添加一个可执行目标：
- en: '[PRE18]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `hello-world_wDSO` executable target is linked against the shared library:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hello-world_wDSO`可执行目标与共享库链接：'
- en: '[PRE19]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `src/CMakeLists.txt` file contains also the installation directives. Before
    considering these, we need to fix the `RPATH` for our executable:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`src/CMakeLists.txt`文件也包含了安装指令。在考虑这些之前，我们需要为我们的可执行文件固定`RPATH`：'
- en: 'With CMake path manipulations, we set the `message_RPATH` variable. This will
    set `RPATH` appropriately for GNU/Linux and macOS:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过CMake路径操作，我们设置了`message_RPATH`变量。这将适当地为GNU/Linux和macOS设置`RPATH`：
- en: '[PRE20]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can now use this variable to fix the `RPATH` for our executable target, `hello-world_wDSO`.
    This is achieved by means of a target property. We are also setting additional
    properties, and we will comment more on these in a moment:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用这个变量来为我们的可执行目标`hello-world_wDSO`修复`RPATH`。这是通过目标属性实现的。我们还设置了额外的属性，稍后我们将对这些属性进行更多评论：
- en: '[PRE21]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We are finally ready to install our library, header, and executable! We use
    the install command offered by CMake to specify where these should go. Note that
    the paths are relative; we will elaborate more on this point further below:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们终于准备好安装我们的库、头文件和可执行文件了！我们使用CMake提供的安装命令来指定这些文件应该去哪里。请注意，路径是相对的；我们将在下面进一步详细说明这一点：
- en: '[PRE22]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `CMakeLists.txt` file in the tests directory contains simple directives
    to ensure that the "Hello, World" executable runs correctly:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 测试目录中的`CMakeLists.txt`文件包含简单的指令，以确保“Hello, World”可执行文件运行正确：
- en: '[PRE23]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let us now configure, build, and install the project and look at the result.
    As soon as any installation directives are added, CMake generates a new target
    called `install` that will run the installation rules:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们配置、构建并安装项目，然后查看结果。一旦添加了任何安装指令，CMake就会生成一个名为`install`的新目标，该目标将运行安装规则：
- en: '[PRE24]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The contents of the build directory on GNU/Linux will be the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在GNU/Linux上，构建目录的内容将是以下内容：
- en: '[PRE25]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'One the other hand, at the install prefix, you can find the following structure:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在安装前缀下，你可以找到以下结构：
- en: '[PRE26]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This means that the locations given in the installation directives are relative
    to the `CMAKE_INSTALL_PREFIX` instance given by the user.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着安装指令中给出的位置是相对于用户给出的`CMAKE_INSTALL_PREFIX`实例的。
- en: How it works
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'There are three salient points to this recipe that we need to discuss in more
    detail:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方有三个要点需要我们更详细地讨论：
- en: The use of `GNUInstallDirs.cmake` to define standard locations for the installation
    of our targets
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`GNUInstallDirs.cmake`来定义我们目标安装的标准位置
- en: The properties set on the shared library and executable targets, in particular
    the handling of the `RPATH`
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享库和可执行目标设置的属性，特别是`RPATH`的处理
- en: The installation directives
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装指令
- en: Installing to standard locations
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装到标准位置
- en: 'What is a good layout for the installation of your project? As long as you
    are the only consumer of your project, this question only has limited relevance.
    However, as soon as you start shipping to the outside world, it will be expected
    that you provide a sensible layout when installing your project. Fortunately,
    there are standards that we can adhere to and CMake can help us with that. Effectively,
    what the `GNUInstallDirs.cmake` module does is to define a set of variables. These
    variables are the names of the subdirectories where different types of files should
    be installed. In our example we used the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的项目安装来说，一个好的布局是什么？只要你自己的项目是唯一的消费者，这个问题就只有有限的关联性。然而，一旦你开始向外界发货，人们就会期望你在安装项目时提供一个合理的布局。幸运的是，有一些标准我们可以遵守，而CMake可以帮助我们做到这一点。实际上，`GNUInstallDirs.cmake`模块所做的是定义一组变量。这些变量是不同类型的文件应该被安装的子目录的名称。在我们的例子中，我们使用了以下内容：
- en: '`CMAKE_INSTALL_BINDIR`: This will give the subdirectory where *user executables*
    should be located, which is the `bin` directory under the chosen install prefix.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_INSTALL_BINDIR`：这将给出*用户可执行文件*应位于的子目录，即所选安装前缀下的`bin`目录。'
- en: '`CMAKE_INSTALL_LIBDIR`: This expands to the subdirectory where *object code
    libraries *– that is, the static and shared libraries – should be located. On
    a 64-bit system, this is `lib64`, whereas on a 32-bit system, it is just `lib`.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_INSTALL_LIBDIR`：这扩展到*对象代码库*应位于的子目录，即静态和共享库。在64位系统上，这是`lib64`，而在32位系统上，它只是`lib`。'
- en: '`CMAKE_INSTALL_INCLUDEDIR`: Finally, we used this variable to obtain the correct
    subdirectory for our C header files. This variable expands to `include`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_INSTALL_INCLUDEDIR`：最后，我们使用这个变量来获取我们的C头文件的正确子目录。这个变量扩展为`include`。'
- en: 'The user might, however, want to override these choices. We allowed for that
    with the following stanza in the root `CMakeLists.txt` file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户可能想要覆盖这些选择。我们在根`CMakeLists.txt`文件中允许了以下节：
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This effectively redefines the `INSTALL_BINDIR`, `INSTALL_LIBDIR`, and `INSTALL_INCLUDEDIR` convenience
    variables to be used within our project. We also define the additional `INSTALL_CMAKEDIR`
    variable, but its role will be discussed in detail in the next few recipes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上重新定义了`INSTALL_BINDIR`、`INSTALL_LIBDIR`和`INSTALL_INCLUDEDIR`便利变量，以便在我们的项目中使用。我们还定义了额外的`INSTALL_CMAKEDIR`变量，但其作用将在接下来的几个配方中详细讨论。
- en: 'The `GNUInstallDirs.cmake` module defines additional variables that will help
    to place installed files in the expected subdirectories of the chosen install
    prefix. Please consult the CMake online documentation: [https://cmake.org/cmake/help/v3.6/module/GNUInstallDirs.html](https://cmake.org/cmake/help/v3.6/module/GNUInstallDirs.html)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`GNUInstallDirs.cmake`模块定义了额外的变量，这些变量将帮助将安装的文件放置在所选安装前缀的预期子目录中。请咨询CMake在线文档：[https://cmake.org/cmake/help/v3.6/module/GNUInstallDirs.html](https://cmake.org/cmake/help/v3.6/module/GNUInstallDirs.html)'
- en: Target properties and RPATH handling
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目标属性和RPATH处理
- en: 'Let us have a closer look at the properties set on the shared library target.
    We had to set the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下设置在共享库目标上的属性。我们必须设置以下内容：
- en: '`POSITION_INDEPENDENT_CODE 1`: This sets the compiler flags needed for generating
    position-independent code. For more details, please consult [https://en.wikipedia.org/wiki/Position-independent_code](https://en.wikipedia.org/wiki/Position-independent_code).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POSITION_INDEPENDENT_CODE 1`: 这设置了生成位置无关代码所需的编译器标志。有关更多详细信息，请咨询[https://en.wikipedia.org/wiki/Position-independent_code](https://en.wikipedia.org/wiki/Position-independent_code)。'
- en: '`SOVERSION ${PROJECT_VERSION_MAJOR}`: This is the version of the application
    programming interface (API) offered by our shared library. Following semantic
    version, we have decided to set it to be the same as the major version of the
    project. CMake targets also have a `VERSION` property. This can be used to specify
    the build version of the target. Note that `SOVERSION` and `VERSION` might differ:
    we might want to offer multiple builds of the same API over time. We are not concerned
    with such granular control in this example: setting just the API version with
    the `SOVERSION` property is enough, CMake will set `VERSION` to the same value
    for us. For more details on please refer to the official documentation: [https://cmake.org/cmake/help/latest/prop_tgt/SOVERSION.html](https://cmake.org/cmake/help/latest/prop_tgt/SOVERSION.html)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOVERSION ${PROJECT_VERSION_MAJOR}`: 这是我们的共享库提供的应用程序编程接口（API）的版本。遵循语义版本，我们决定将其设置为与项目的主要版本相同。CMake目标也有一个`VERSION`属性。这可以用来指定目标的构建版本。注意`SOVERSION`和`VERSION`可能不同：我们可能希望随着时间的推移提供同一API的多个构建。在本示例中，我们不关心这种粒度控制：仅设置API版本与`SOVERSION`属性就足够了，CMake将为我们设置`VERSION`为相同的值。有关更多详细信息，请参阅官方文档：[https://cmake.org/cmake/help/latest/prop_tgt/SOVERSION.html](https://cmake.org/cmake/help/latest/prop_tgt/SOVERSION.html)'
- en: '`OUTPUT_NAME "message"`: This tells CMake that the base name for the library
    is just `message` and not the name of the target `message-shared`: `libmessage.so.1`
    will be generated when building. Proper symbolic links to `libmessage.so` will
    also be generated, as can be seen from the contents of the build directory and
    install prefix given previously.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OUTPUT_NAME "message"`: 这告诉CMake库的基本名称是`message`，而不是目标名称`message-shared`：在构建时将生成`libmessage.so.1`。还会生成到`libmessage.so`的适当符号链接，正如前面给出的构建目录和安装前缀的内容所示。'
- en: '`DEBUG_POSTFIX "_d"`: This tells CMake to add the`_d` postfix to the generated
    shared library if we are building the project in a `Debug` configuration.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG_POSTFIX "_d"`: 这告诉CMake，如果我们以`Debug`配置构建项目，则要在生成的共享库中添加`_d`后缀。'
- en: '`PUBLIC_HEADER "Message.hpp"`: We use this property to set a list of header
    files, in this case only one, defining the API functions offered by our library.
    This is primarily intended for Framework shared library targets on macOS but it
    can also be used on other operating systems and targets, as we have presently
    done. For more details, please see the official documentation: [https://cmake.org/cmake/help/v3.6/prop_tgt/PUBLIC_HEADER.html](https://cmake.org/cmake/help/v3.6/prop_tgt/PUBLIC_HEADER.html).'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUBLIC_HEADER "Message.hpp"`: 我们使用此属性来设置定义库提供的API函数的头文件列表，在这种情况下只有一个。这主要是为macOS上的框架共享库目标设计的，但它也可以用于其他操作系统和目标，正如我们目前所做的。有关更多详细信息，请参阅官方文档：[https://cmake.org/cmake/help/v3.6/prop_tgt/PUBLIC_HEADER.html](https://cmake.org/cmake/help/v3.6/prop_tgt/PUBLIC_HEADER.html)。'
- en: '`MACOSX_RPATH ON`: This sets the directory portion of the “install_name” field
    of shared libraries to `@rpath` on macOS.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MACOSX_RPATH ON`: 这将在macOS上将共享库的“install_name”字段的目录部分设置为`@rpath`。'
- en: '`WINDOWS_EXPORT_ALL_SYMBOLS ON`: This will force compilation on Windows to
    export all symbols. Note that this is usually not a good practice and we will
    show in Recipe 2, *Generating export headers*, how to take care of symbol visibility
    on different platforms.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WINDOWS_EXPORT_ALL_SYMBOLS ON`：这将强制在Windows上编译时导出所有符号。请注意，这通常不是一种好的做法，我们将在第2个菜谱中展示，即“生成导出头文件”，如何在不同平台上处理符号可见性。'
- en: 'Let us now discuss `RPATH`. We are linking our `hello-world_wDSO` executable
    to `libmessage.so.1`. This means that when the executable is called, the shared
    library will be loaded. Thus the information on the location of the library needs
    to be encoded somewhere in order for the loader to do its job successfully. There
    are two approaches regarding the location of the library:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论`RPATH`。我们正在将`hello-world_wDSO`可执行文件链接到`libmessage.so.1`。这意味着当调用可执行文件时，将加载共享库。因此，为了使加载器成功完成其工作，需要在某个地方编码有关库位置的信息。关于库位置有两种方法：
- en: 'It could be made known to the linker by setting environment variables:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过设置环境变量让链接器知道：
- en: On GNU/Linux, this would require appending the path to the `LD_LIBRARY_PATH`
    environment variable. Note that this will most likely pollute the linker path
    for all applications on your system and might cause symbol clashes ([https://gms.tf/ld_library_path-considered-harmful.html](https://gms.tf/ld_library_path-considered-harmful.html)).
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GNU/Linux上，这需要将路径附加到`LD_LIBRARY_PATH`环境变量。请注意，这很可能会污染系统上所有应用程序的链接器路径，并可能导致符号冲突（[https://gms.tf/ld_library_path-considered-harmful.html](https://gms.tf/ld_library_path-considered-harmful.html)）。
- en: 'On macOS, you can similarly set the `DYLD_LIBRARY_PATH` variable. This suffers
    from the same pitfalls as `LD_LIBRARY_PATH` on GNU/Linux and the situation can
    be ameliorated, albeit only partially, by using the `DYLD_FALLBACK_LIBRARY_PATH`
    variable instead. See the following link for an example of this: [https://stackoverflow.com/a/3172515/2528668](https://stackoverflow.com/a/3172515/2528668).'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在macOS上，您可以同样设置`DYLD_LIBRARY_PATH`变量。这和GNU/Linux上的`LD_LIBRARY_PATH`有同样的缺点，但可以通过使用`DYLD_FALLBACK_LIBRARY_PATH`变量来部分缓解这种情况。请参阅以下链接中的示例：[https://stackoverflow.com/a/3172515/2528668](https://stackoverflow.com/a/3172515/2528668)。
- en: It could be encoded into the executable, using the `RPATH` to set the run-time
    search path for the executable.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以被编码到可执行文件中，使用`RPATH`设置运行时搜索路径。
- en: 'The latter approach is preferable and more robust. However, which path should
    be chosen when setting the `RPATH` of the dynamic shared object? We need to make
    sure that running the executable *always* finds the correct shared library, regardless
    of whether it is run in the build tree or in the install tree. This is achieved
    by setting the `RPATH` related properties for the `hello-world_wDSO` target to
    look for a path *relative* to the location of the executable itself, either *via*
    the `$ORIGIN` (on GNU/Linux) or `@loader_path` (on macOS) variables:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 后一种方法更可取且更稳健。但是，在设置动态共享对象的`RPATH`时应该选择哪个路径？我们需要确保无论是在构建树还是在安装树中运行可执行文件，它总是能找到正确的共享库。这是通过为`hello-world_wDSO`目标设置`RPATH`相关属性来实现的，以便查找相对于可执行文件本身位置的路径，无论是通过`$ORIGIN`（在GNU/Linux上）还是`@loader_path`（在macOS上）变量：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once the `message_RPATH` variable is set, the target properties will do the
    rest of the job:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了`message_RPATH`变量，目标属性将完成剩余的工作：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let us examine this command in detail:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查这个命令：
- en: '`SKIP_BUILD_RPATH OFF`: Tells CMake to generate an appropriate `RPATH` so as
    to be able to run the executable from *within* the build tree.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SKIP_BUILD_RPATH OFF`：告诉CMake生成适当的`RPATH`，以便能够在构建树内运行可执行文件。'
- en: '`BUILD_WITH_INSTALL_RPATH OFF`: Turns off generating executable targets with
    their `RPATH` geared to be the same as the one for the install tree. This would
    prevent us from running the executable from within the build tree.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD_WITH_INSTALL_RPATH OFF`：关闭生成具有与安装树相同的`RPATH`的可执行目标。这将阻止我们在构建树内运行可执行文件。'
- en: '`INSTALL_RPATH "${message_RPATH}"`: Sets the `RPATH` for the installed executable
    target to a path previously computed.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSTALL_RPATH "${message_RPATH}"`：将安装的可执行目标的`RPATH`设置为先前计算的路径。'
- en: '`INSTALL_RPATH_USE_LINK_PATH ON`: Tells CMake to append linker search paths
    to the `RPATH` executable.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSTALL_RPATH_USE_LINK_PATH ON`：告诉CMake将链接器搜索路径附加到可执行文件的`RPATH`。'
- en: 'More information on how the loader works on Unix systems may be found in this
    blog post: [http://longwei.github.io/rpath_origin/](http://longwei.github.io/rpath_origin/).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于加载器在Unix系统上如何工作的更多信息，可以在这篇博客文章中找到：[http://longwei.github.io/rpath_origin/](http://longwei.github.io/rpath_origin/)。
- en: Installation directives
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装指令
- en: 'Finally, let us consider the installation directives. We need to install an
    executable, one library, and one header file. Executables and libraries are build
    targets, so we use the `TARGETS` option to the `install` command. Install rules
    for multiple targets can be set at once: CMake is aware of what kind of targets
    they are; that is, whether they are executables, shared libraries, or static libraries:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑安装指令。我们需要安装一个可执行文件、一个库和一个头文件。可执行文件和库是构建目标，因此我们使用`install`命令的`TARGETS`选项。可以一次性设置多个目标的安装规则：CMake知道它们是什么类型的目标；也就是说，它们是可执行文件、共享库还是静态库：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Executables will be installed in `RUNTIME DESTINATION`, which we set to `${INSTALL_BINDIR}`.
    Shared libraries are installed to `LIBRARY DESTINATION`, which we set to `${INSTALL_LIBDIR}`.
    Static libraries would be installed to `ARCHIVE DESTINATION`, which we also set
    to `${INSTALL_LIBDIR}`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件将被安装在`RUNTIME DESTINATION`，我们将其设置为 `${INSTALL_BINDIR}`。共享库被安装到`LIBRARY
    DESTINATION`，我们将其设置为 `${INSTALL_LIBDIR}`。静态库将被安装到`ARCHIVE DESTINATION`，我们也将其设置为
    `${INSTALL_LIBDIR}`：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that we not only specified `DESTINATION`, but also `COMPONENT`. When installing
    the project with the `cmake --build . --target install `command, all components
    were installed, as expected. However, it might be sometimes desirable to only
    install some of them. This is what the `COMPONENT` keyword can help us with. For
    example, to only install libraries, we can run the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不仅指定了`DESTINATION`，还指定了`COMPONENT`。当使用`cmake --build . --target install`命令安装项目时，所有组件都如预期那样被安装了。然而，有时可能只希望安装其中一些组件。这就是`COMPONENT`关键字可以帮助我们的地方。例如，要仅安装库，我们可以运行以下命令：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since the `Message.hpp` header file was set as a public header of the project,
    we can use the `PUBLIC_HEADER` keyword to install it along the other targets to
    the chosen destination: `${INSTALL_INCLUDEDIR}/message`. Users of the library
    can now include the header with: `#include <message/Message.hpp>`, provided the
    proper location is passed to the compiler with the `-I` option.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Message.hpp`头文件被设置为项目的公共头文件，我们可以使用`PUBLIC_HEADER`关键字将其与其他目标一起安装到选定的目的地： `${INSTALL_INCLUDEDIR}/message`。库的用户现在可以通过以下方式包含头文件：`#include
    <message/Message.hpp>`，前提是正确的位置通过`-I`选项传递给编译器。
- en: The various destinations in the installation directives are interpreted as relative
    paths, unless an absolute path is used. But relative to what? There are different
    ways in which CMake can compute the absolute path, depending on what tool is triggering
    the installation. When using `cmake --build . --target install`, as we have done,
    paths will be computed relative to `CMAKE_INSTALL_PREFIX`. However, when using
    CPack, absolute paths will be computed relative to `CPACK_PACKAGING_INSTALL_PREFIX`.
    Usage of CPack will be shown in [Chapter 11](293b5487-bede-4764-bc0e-e74fe110402e.xhtml),
    *Packaging Projects*, Recipe 1, *Generating source and binary packages*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 安装指令中的各种目的地被解释为相对路径，除非使用绝对路径。但是相对于什么？CMake可以根据触发安装的工具以不同的方式计算绝对路径。当我们使用`cmake
    --build . --target install`时，正如我们所做的那样，路径将相对于`CMAKE_INSTALL_PREFIX`计算。然而，当使用CPack时，绝对路径将相对于`CPACK_PACKAGING_INSTALL_PREFIX`计算。CPack的使用将在[第11章](293b5487-bede-4764-bc0e-e74fe110402e.xhtml)，*打包项目*，第1个配方，*生成源代码和二进制包*中展示。
- en: 'Yet another mechanism is available with Unix Makefiles and Ninja generators:
    `DESTDIR`. It is possible to relocate the whole installation tree under the directory
    specified by `DESTDIR`. That is, `env DESTDIR=/tmp/stage cmake --build . --target
    install` will install the project relative to `CMAKE_INSTALL_PREFIX` and under
    the `/tmp/stage` directory. You can read more here: [https://www.gnu.org/prep/standards/html_node/DESTDIR.html](https://www.gnu.org/prep/standards/html_node/DESTDIR.html).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种机制在Unix Makefiles和Ninja生成器中可用：`DESTDIR`。可以将整个安装树重新定位到由`DESTDIR`指定的目录下。也就是说，`env
    DESTDIR=/tmp/stage cmake --build . --target install`将相对于`CMAKE_INSTALL_PREFIX`安装项目，并在`/tmp/stage`目录下。您可以在这里了解更多信息：[https://www.gnu.org/prep/standards/html_node/DESTDIR.html](https://www.gnu.org/prep/standards/html_node/DESTDIR.html)。
- en: There is more
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'Setting the `RPATH` correctly can be rather tricky, but it is essential for
    third-party users. By default, CMake sets the `RPATH` of executables assuming
    they will be run from the build tree. However, upon installation, the `RPATH`
    is cleared, leading to trouble when a user would like to run `hello-world_wDSO`.
    Using the `ldd` tool on Linux, we can inspect the `hello-world_wDSO` executable
    in the build tree to see where the loader will look for `libmessage.so`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正确设置 `RPATH` 可能相当棘手，但对于第三方用户来说至关重要。默认情况下，CMake 设置可执行文件的 `RPATH`，假设它们将从构建树中运行。然而，在安装时，`RPATH`
    被清除，导致用户想要运行 `hello-world_wDSO` 时出现问题。在Linux上使用 `ldd` 工具，我们可以检查构建树中的 `hello-world_wDSO`
    可执行文件，以查看加载器将在哪里查找 `libmessage.so`：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running `ldd hello-world_wDSO` in the installation prefix would result instead
    in the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装前缀中运行 `ldd hello-world_wDSO` 将导致以下结果：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is clearly wrong. However, it would be equally wrong to always hardcode
    the `RPATH` to point to the build tree or to the installation prefix: any of the
    two locations could be erased resulting in corrupted executables. The solution
    presented here sets the `RPATH` differently for the executable in the build tree
    and in the installation prefix, so that it will always point to where "it makes
    sense"; that is, as close to the executable as possible. Running `ldd` in the
    build tree shows the same output:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是错误的。然而，始终将 `RPATH` 硬编码指向构建树或安装前缀也同样错误：这两个位置中的任何一个都可能被删除，导致可执行文件损坏。这里提出的解决方案为构建树中的可执行文件和安装前缀中的可执行文件设置了不同的
    `RPATH`，以便它总是指向“有意义”的地方；也就是说，尽可能靠近可执行文件。在构建树中运行 `ldd` 显示相同的结果：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'On the other hand, in the installation prefix, we now get the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在安装前缀中，我们现在得到以下结果：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have used the CMake install command with the `TARGETS` signature, since
    we needed to install build targets. The command has, however, four additional
    signatures:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用带有 `TARGETS` 签名的CMake安装命令，因为我们需要安装构建目标。但是，该命令还有四个额外的签名：
- en: The `FILES` and `PROGRAMS` signatures. These are used to install files or programs,
    respectively. Upon installation, files will be copied and permissions for them
    set appropriately. That is, for files, read and write permissions to the owner,
    read permissions to the group and other users and groups. For programs, execution
    permissions will be additionally granted. Note that the `PROGRAMS` signature is
    meant for use with executables that are not build targets. See also: [https://cmake.org/cmake/help/v3.6/command/install.html#installing-files](https://cmake.org/cmake/help/v3.6/command/install.html#installing-files).
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FILES` 和 `PROGRAMS` 签名。这些用于安装文件或程序，分别。安装时，文件将被复制，并为其设置适当的权限。也就是说，对于文件，所有者具有读写权限，组和其他用户和组具有读权限。对于程序，还将授予执行权限。请注意，`PROGRAMS`
    签名旨在用于不是构建目标的可执行文件。另请参见：[https://cmake.org/cmake/help/v3.6/command/install.html#installing-files](https://cmake.org/cmake/help/v3.6/command/install.html#installing-files)。'
- en: 'The `DIRECTORY` signature. As the name suggests, this is used to install directories.
    When only a directory name is given, it is, as usual, understood to be relative
    to the current source directory. Granular control over installation of directories
    is possible. Please consult the online documentation: [https://cmake.org/cmake/help/v3.6/command/install.html#installing-directories](https://cmake.org/cmake/help/v3.6/command/install.html#installing-directories).'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DIRECTORY` 签名。顾名思义，这是用来安装目录的。当只给出一个目录名时，它通常被理解为相对于当前源目录。可以对目录的安装进行细粒度控制。请查阅在线文档：[https://cmake.org/cmake/help/v3.6/command/install.html#installing-directories](https://cmake.org/cmake/help/v3.6/command/install.html#installing-directories)。'
- en: The `SCRIPT` signature. You can use this one to define custom installation rules
    within a CMake script. See [https://cmake.org/cmake/help/v3.6/command/install.html#custom-installation-logic](https://cmake.org/cmake/help/v3.6/command/install.html#custom-installation-logic).
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCRIPT` 签名。您可以使用此签名在CMake脚本中定义自定义安装规则。请参阅 [https://cmake.org/cmake/help/v3.6/command/install.html#custom-installation-logic](https://cmake.org/cmake/help/v3.6/command/install.html#custom-installation-logic)。'
- en: The `EXPORT` signature. We defer discussion of this signature to Recipe 3, *Exporting
    your targets*.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPORT` 签名。我们将对此签名的讨论推迟到第3个配方，即*导出您的目标*。'
- en: Generating export headers
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成导出头文件
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-02) and
    has a C++ example. The recipe is valid with CMake version 3.6 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-02)找到，并包含一个C++示例。本节适用于CMake版本3.6（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: 'Let us imagine that the small library that we have introduced has become hugely
    popular, with many people using it. However, some clients would also like a static
    library to be available with the installation. Other clients have noticed that
    all symbols are visible in the shared library. Best practices dictate that shared
    libraries only expose the minimal amount of symbols, thus limiting the visibility
    to the outside world of objects and functions defined in the code. We want to
    make sure that by default all symbols defined in our shared library are hidden
    from the outside world. This will force contributors to the project to clearly
    delimit the interface between the library and external codes, since they will
    have to explicit mark all symbols that also meant to be used outside of the project.
    As such, we wish to do the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设想一下，我们介绍的小型库已经变得非常流行，许多人都在使用它。然而，一些客户也希望在安装时提供一个静态库。其他客户注意到，共享库中的所有符号都是可见的。最佳实践规定，共享库只应公开最小数量的符号，从而限制代码中定义的对象和函数对外界的可见性。我们希望确保默认情况下，我们共享库中定义的所有符号对库外都是隐藏的。这将迫使项目贡献者明确界定库与外部代码之间的接口，因为他们必须明确标记那些也打算在项目外部使用的符号。因此，我们希望做以下事情：
- en: Build both a shared and static library from the same set of source files.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从同一组源文件构建共享和静态库。
- en: Ensure that only the visibility of symbols in the shared library is properly
    delimited.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保只有共享库中的符号可见性得到适当界定。
- en: Recipe 3, *Building and linking static and shared libraries*, in [Chapter 1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml),
    *From a Simple Executable to Libraries*, already showed that CMake offers functionality
    to achieve the first point in a platform-independent way. We did not, however,
    address the issue of symbol visibility. We will revisit both points with the present
    recipe.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第3节，*构建和链接静态和共享库*，在[第1章](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml)，*从简单的可执行文件到库*，已经展示了CMake提供了实现第一点的平台无关功能。然而，我们没有解决符号可见性的问题。我们将使用当前的节重新审视这两点。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will still use mostly the same code as in the previous recipe, but we will
    need to modify `src/CMakeLists.txt` and the `Message.hpp` header file. The latter
    will include the new, autogenerated header file, `messageExport.h`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍将主要使用与上一节相同的代码，但我们需要修改`src/CMakeLists.txt`和`Message.hpp`头文件。后者将包含新的自动生成的头文件`messageExport.h`：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `message_EXPORT` preprocessor directive was introduced in the declaration
    of the `Message` class. This directive will let the compiler generate symbols
    that are visible to the users of the library.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`message_EXPORT`预处理器指令在`Message`类的声明中被引入。这个指令将允许编译器生成对库用户可见的符号。'
- en: How to do it
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Apart from the name of the project, the root `CMakeLists.txt` file is unchanged.
    Let us first look at the `CMakeLists.txt` file in the `src` subdirectory, where
    all the additional work actually happens. We will highlight the changes with respect
    to the file in the previous recipe:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了项目名称之外，根目录的`CMakeLists.txt`文件保持不变。让我们首先看一下`src`子目录中的`CMakeLists.txt`文件，所有额外的工作实际上都在这里进行。我们将根据上一节中的文件来突出显示更改：
- en: 'We declare our `SHARED` library target and its sources for the messaging library.
    Note that compile definitions and link libraries are unchanged:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了我们的`SHARED`库目标及其消息库的源文件。请注意，编译定义和链接库保持不变：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We also set target properties. We have added the `${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}/messageExport.h`
    header file in the list of public headers given as argument to the `PUBLIC_HEADER`
    target property. The `CXX_VISIBILITY_PRESET` and `VISIBILITY_INLINES_HIDDEN` properties
    will be discussed in the next section:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还设置了目标属性。我们在`PUBLIC_HEADER`目标属性的参数中添加了`${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}/messageExport.h`头文件。`CXX_VISIBILITY_PRESET`和`VISIBILITY_INLINES_HIDDEN`属性将在下一节讨论：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We include the standard CMake module `GenerateExportHeader.cmake` module and
    invoke the `generate_export_header` function. This will generate the `messageExport.h`
    header file in a subdirectory of the build directory. We will discuss this function
    and the generated header in more detail very soon:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们包含了标准的CMake模块`GenerateExportHeader.cmake`，并调用了`generate_export_header`函数。这将生成位于构建目录子目录中的`messageExport.h`头文件。我们很快将详细讨论这个函数和生成的头文件：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The export header should be included whenever the visibility of symbols is
    to be changed from its default – hidden – value. We have done that in the `Message.hpp`
    header file, since we want to expose some symbols in our library. Now we list
    the `${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}` directory as a `PUBLIC` include
    directory of the `message-shared` target:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当需要将符号的可见性从默认的隐藏值更改时，都应该包含导出头文件。我们在`Message.hpp`头文件中做到了这一点，因为我们希望在库中暴露一些符号。现在我们将`${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}`目录列为`message-shared`目标的`PUBLIC`包含目录：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we can turn our attention to the generation of the static library:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将注意力转向静态库的生成：
- en: 'We add a library target to generate the static library. The same sources as
    for the shared library will be compiled to get this target:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个库目标来生成静态库。将使用与共享库相同的源代码编译来获得这个目标：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We set compiler definitions, include directories, and link libraries, exactly
    as we did for the shared library target. Note, however, that we added the `message_STATIC_DEFINE`
    compile definition. This is to make sure that our symbols are properly exposed:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了编译定义、包含目录和链接库，就像我们为共享库目标所做的那样。然而，请注意，我们添加了`message_STATIC_DEFINE`编译定义。这是为了确保我们的符号被正确暴露：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We also set properties on the `message-static` target. These will be discussed
    in the next section:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还为`message-static`目标设置了属性。这些将在下一节中讨论：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In addition to the `hello-world_wDSO` executable target, which links against
    the `message-shared` library target, we define another executable target, `hello-world_wAR`.
    This links against the static library:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了链接`message-shared`库目标的`hello-world_wDSO`可执行目标之外，我们还定义了另一个可执行目标`hello-world_wAR`。这个目标链接的是静态库：
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The installation directives now list the additional `message-static` and `hello-world_wAR`
    targets, but are otherwise unchanged:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装指令现在列出了额外的`message-static`和`hello-world_wAR`目标，但其他方面没有变化：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'This recipe demonstrates how to set the visibility of symbols for a shared
    library. The best practice is to keep all symbols hidden by default, explicitly
    exposing only those symbols that we want to be used by dependents on our library.
    This is achieved in two steps. First of all, we need to instruct the compiler
    to hide symbols. Of course, different compilers will have different options available,
    and directly setting these by hand in our `CMakeLists.txt` would not be cross-platform.
    CMake offers a robust and cross-platform way of setting symbol visibility by setting
    two properties on the shared library target:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何为共享库设置符号的可见性。最佳实践是默认隐藏所有符号，只明确暴露我们希望被库依赖者使用的那些符号。这通过两个步骤实现。首先，我们需要指示编译器隐藏符号。当然，不同的编译器将有不同的选项可用，直接在我们的`CMakeLists.txt`中手动设置这些将不是跨平台的。CMake提供了一种设置符号可见性的健壮且跨平台的方法，即通过在共享库目标上设置两个属性：
- en: '`CXX_VISIBILITY_PRESET hidden`: This will hide all symbols, unless explicitly
    marked otherwise. When using the GNU compiler, this adds the flag `-fvisibility=hidden`
    for the target.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CXX_VISIBILITY_PRESET hidden`：这将隐藏所有符号，除非明确标记为其他。当使用GNU编译器时，这为目标添加了`-fvisibility=hidden`标志。'
- en: '`VISIBILITY_INLINES_HIDDEN 1`: This will hide symbols for inline functions.
    If using the GNU compiler, this corresponds to `-fvisibility-inlines-hidden`.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VISIBILITY_INLINES_HIDDEN 1`：这将隐藏内联函数的符号。如果使用GNU编译器，这对应于`-fvisibility-inlines-hidden`。'
- en: On Windows, this is the default behavior. Recall, in fact, that we needed to
    override it in the previous recipe by setting the `WINDOWS_EXPORT_ALL_SYMBOLS` property
    to `ON`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，这是默认行为。实际上，回想一下，在前一个配方中，我们需要通过将`WINDOWS_EXPORT_ALL_SYMBOLS`属性设置为`ON`来覆盖它。
- en: 'How do we mark the symbols we want to be visible? This is determined by the
    preprocessor, and we thus need to provide preprocessor macros that expand to visibility
    attributes that the given compiler on the chosen platform will understand. Once
    again, CMake comes to the rescue with the `GenerateExportHeader.cmake` module
    file. This module defines the `generate_export_header` function, which we invoked
    as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何标记我们希望可见的符号？这是由预处理器决定的，因此我们需要提供预处理器宏，这些宏扩展为给定编译器在所选平台上将理解的可见性属性。再次，CMake通过`GenerateExportHeader.cmake`模块文件来救援。该模块定义了`generate_export_header`函数，我们按如下方式调用它：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The function generates the `messageExport.h` header file, which will contain
    the preprocessor macros needed. The file is generated in the directory `${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}`,
    as requested *via* the `EXPORT_FILE_NAME` option. If this option is left empty,
    the header file would be generated in the current binary directory. The first
    argument to this function is an existing target, `message-shared` in our case.
    Basic invocation of the function only requires passing the name of an existing
    target. Optional arguments, for fine-grained control of all of the generated macros,
    can also be passed:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数生成包含所需预处理器宏的`messageExport.h`头文件。文件在目录`${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}`中生成，如通过`EXPORT_FILE_NAME`选项所请求。如果此选项留空，头文件将在当前二进制目录中生成。该函数的第一
- en: '`BASE_NAME`: This sets the base name of the generated header and macros to
    the passed value.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BASE_NAME`：这设置生成的头文件和宏的基本名称为传入的值。'
- en: '`EXPORT_MACRO_NAME`: This sets the name of the export macro.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPORT_MACRO_NAME`：这设置导出宏的名称。'
- en: '`EXPORT_FILE_NAME`: This sets the name for the export header file generated.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPORT_FILE_NAME`：这设置生成的导出头文件的名称。'
- en: '`DEPRECATED_MACRO_NAME`: This sets the name for the deprecation macro. This
    is used to mark deprecated code, the compiler will emit a deprecation warning
    if clients use it.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEPRECATED_MACRO_NAME`：这设置废弃宏的名称。这用于标记废弃代码，如果客户端使用它，编译器将发出废弃警告。'
- en: '`NO_EXPORT_MACRO_NAME`: This sets the name of the no-export macro.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NO_EXPORT_MACRO_NAME`：这设置不导出宏的名称。'
- en: '`STATIC_DEFINE`: This is for the name of the macro to use when also compiling
    a static library out of the same sources.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STATIC_DEFINE`：这是用于当也从相同源代码编译静态库时使用的宏的名称。'
- en: '`NO_DEPRECATED_MACRO_NAME`: This sets the name of the macro to be used to exclude
    deprecated code from being compiled.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NO_DEPRECATED_MACRO_NAME`：这设置用于排除编译中废弃代码的宏的名称。'
- en: '`DEFINE_NO_DEPRECATED`: This instructs CMake to generate preprocessor code
    to exclude deprecated code from compilation.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFINE_NO_DEPRECATED`：这指示CMake生成预处理器代码，以排除编译中的废弃代码。'
- en: 'On GNU/Linux and using the GNU compiler, CMake will generate the following `messageExport.h`
    export header:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在GNU/Linux上使用GNU编译器时，CMake将生成以下`messageExport.h`导出头文件：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can prepend the classes and functions to be exposed to users with the `message_EXPORT`
    macro. Deprecation can be achieved by prepending with the `message_DEPRECATED`
    macro.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在类和函数前加上`message_EXPORT`宏来向用户公开它们。通过在前面加上`message_DEPRECATED`宏可以实现废弃。
- en: 'The static library is built out of the same sources. However, all symbols are
    supposed to be visible in the static archive, and as can be seen from the contents
    of the `messageExport.h` header file, the `message_STATIC_DEFINE` macro comes
    to the rescue. Once the target has been declared, we set it as a compile definition.
    The additional target properties on the static library are as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 静态库由相同的源代码构建。然而，所有符号都应在静态档案中可见，并且从`messageExport.h`头文件的内容可以看出，`message_STATIC_DEFINE`宏来救援。一旦目标被声明，我们就将其设置为编译定义。静态库上的额外目标属性如下：
- en: '`ARCHIVE_OUTPUT_NAME "message"`: This will ensure that the name of the library
    file is just message, rather than message-static.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARCHIVE_OUTPUT_NAME "message"`：这将确保库文件的名称只是message，而不是message-static。'
- en: '`DEBUG_POSTFIX "_sd"`: This will append the given postfix to the library. This
    uniquely identifies the library as *static* in a `Debug` configuration.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEBUG_POSTFIX "_sd"`：这将给定的后缀附加到库。这独特地将库标识为在`Debug`配置中的*静态*。'
- en: '`RELEASE_POSTFIX "_s"`: This is similar to the previous property, but just
    appends the postfix for a static library in case the target was built in `Release`
    configuration.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RELEASE_POSTFIX "_s"`：这与前面的属性类似，但仅在目标在`Release`配置中构建时附加后缀给静态库。'
- en: There is more
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: 'It is good practice to hide internal symbols when building a shared library.
    This means that the library shrinks in size, because what you expose to the user
    is less than what you have in the library. This defines the Application Binary
    Interface (ABI), which most of the time should coincide with the Application Programming
    Interface (API). This is done in two stages:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建共享库时隐藏内部符号是一种良好的实践。这意味着库的尺寸会缩小，因为你向用户暴露的内容少于库中实际拥有的内容。这定义了应用程序二进制接口（ABI），大多数情况下应该与应用程序编程接口（API）一致。这分为两个阶段进行：
- en: We use the appropriate compiler flags.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用适当的编译器标志。
- en: We mark symbols to be exported with a preprocessor variable (`message_EXPORT`,
    in our example). When compiling, the hiding will be lifted for these symbols (such
    as classes and functions).
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用预处理器变量（在我们的例子中是`message_EXPORT`）来标记要导出的符号。在编译时，这些符号（如类和函数）的隐藏将被解除。
- en: 'Static libraries are just archives of object files. Thus one compiles sources
    into object files and then the archiver bundles them into an archive. There is
    no notion of ABI: all symbols are visible by default and the visibility flags
    for the compiler do not affect static archiving. However, if you are going to
    build a shared and static library from the same source files, you need a way to
    give meaning to the `message_EXPORT` preprocessor variable that now appears in
    the code *in both cases*. This is where the `GenerateExportHeader.cmake` module
    comes in. It will define a header with all the logic for giving the proper definition
    of this preprocessor variable. For shared libraries, it will be what is needed
    by the given combination of platform and compiler. Note that the meaning will
    also change based on whether we are *building* or *using* the shared library.
    Fortunately, CMake takes care of this for us without further intervention. For
    static libraries, it will expand to an empty string doing what we expect: nothing.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 静态库只是对象文件的存档。因此，首先将源代码编译成对象文件，然后存档器将它们捆绑成一个存档。这里没有ABI的概念：所有符号默认都是可见的，编译器的可见性标志不影响静态存档。然而，如果你打算从相同的源文件构建共享库和静态库，你需要一种方法来赋予`message_EXPORT`预处理器变量在代码中*两种情况下*出现的意义。这就是`GenerateExportHeader.cmake`模块的作用。它将定义一个包含所有逻辑的头文件，用于给出这个预处理器变量的正确定义。对于共享库，它将根据平台和编译器的组合提供所需的内容。请注意，意义也会根据我们是*构建*还是*使用*共享库而改变。幸运的是，CMake为我们处理了这一点，无需进一步干预。对于静态库，它将扩展为一个空字符串，做我们期望的事情：什么都不做。
- en: 'The attentive reader will have noticed that building the static and shared
    libraries as shown here will actually require to *compile the sources twice*.
    This was not an expensive operation for our simple example, but it can clearly
    become quite onerous, even for projects that are only slightly bigger than our
    example. Why did we choose this approach over the one using `OBJECT` libraries
    shown in Recipe 3, *Building and linking static and shared libraries*, in [Chapter
    1](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml), *From a Simple Executable to Libraries*?
     `OBJECT` libraries take care of the first step in compiling the library: from
    sources to object files. In that step, the preprocessor intervenes and will evaluate
    `message_EXPORT`. Since the compilation of `OBJECT` libraries happens once, `message_EXPORT`
    is either evaluated to a value compatible with building the shared or the static
    library. Thus to avoid ambiguities, we chose the more robust approach of compiling
    twice, letting the preprocessor evaluate the visibility variable correctly.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者会注意到，按照这里所示构建静态库和共享库实际上需要*编译源代码两次*。对于我们简单的例子来说，这不是一个昂贵的操作，但对于比我们例子稍大的项目来说，这显然可能会变得相当繁重。为什么我们选择这种方法而不是在第3个菜谱中展示的使用`OBJECT`库的方法，即“构建和链接静态和共享库”，在[第1章](037080e9-3b67-421a-b6ec-71b1e51dbe42.xhtml)“从简单的可执行文件到库”中？`OBJECT`库负责编译库的第一步：从源代码到对象文件。在这一步中，预处理器介入并评估`message_EXPORT`。由于`OBJECT`库的编译只发生一次，`message_EXPORT`要么被评估为与构建共享库或静态库兼容的值。因此，为了避免歧义，我们选择了更稳健的方法，即编译两次，让预处理器正确评估可见性变量。
- en: 'For more details on the topic of dynamic shared objects, static archives, and
    symbol visibility, we suggest reading this article: [http://people.redhat.com/drepper/dsohowto.pdf](http://people.redhat.com/drepper/dsohowto.pdf).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 关于动态共享对象、静态存档和符号可见性的更多详细信息，我们建议阅读这篇文章：[http://people.redhat.com/drepper/dsohowto.pdf](http://people.redhat.com/drepper/dsohowto.pdf)。
- en: Exporting your targets
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出你的目标
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-03) and
    has a C++ example. The recipe is valid with CMake version 3.6 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-03)找到，并包含一个C++示例。该食谱适用于CMake版本3.6（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: We can imagine that our message library has been a huge success in the open
    source community. People like it a lot and use it in their own projects to print
    their messages to screen. Users particularly like the fact that each printed message
    gets a unique identifier. But users would also like the library to be more easily
    discoverable, once they compile and install it on their systems. This recipe will
    show how CMake can let us export our targets so that other projects using CMake
    can pick them up easily.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象我们的消息库在开源社区中取得了巨大的成功。人们非常喜欢它，并在自己的项目中使用它来将消息打印到屏幕上。用户特别喜欢每条打印的消息都有一个唯一标识符的事实。但用户也希望库在编译和安装到他们的系统后更容易被发现。本食谱将展示如何使用CMake导出我们的目标，以便使用CMake的其他项目可以轻松地获取它们。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The source code is unchanged with respect to the previous recipe and the structure
    of the project is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码与前一个食谱相比未更改，项目的结构如下：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that we have added a `cmake` subdirectory containing a `messageConfig.cmake.in`
    file. This file will contain our exported targets. We have also added a test to
    check whether the installation and export of the project work as intended.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们添加了一个包含`messageConfig.cmake.in`文件的`cmake`子目录。该文件将包含我们导出的目标。我们还添加了一个测试，以检查项目的安装和导出是否按预期工作。
- en: How to do it
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Once again, the root `CMakeLists.txt` file is unchanged with respect to the
    previous recipe. Moving onto the leaf directory `src` containing our sources:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，根`CMakeLists.txt`文件与前一个食谱相比未更改。转到包含我们源文件的叶目录`src`：
- en: 'We need to find the UUID library and we can re-use the code used in previous
    recipes:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要找到UUID库，我们可以重用之前食谱中使用的代码：
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we set up our shared library target and generate the export header, as
    shown in the previous recipe:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们设置我们的共享库目标并生成导出头文件，如前一个食谱所示：
- en: '[PRE51]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We set `PUBLIC` and `INTERFACE` compile definitions for the target. Note the
    use of the `$<INSTALL_INTERFACE:...>` generator expression for the latter:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为目标设置`PUBLIC`和`INTERFACE`编译定义。注意后者使用`$<INSTALL_INTERFACE:...>`生成器表达式：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, the include directories are set. Once again note the use of `$<BUILD_INTERFACE:...>`
    and `$<INSTALL_INTERFACE:...>` generator expressions. We will comment on these
    later on:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置包含目录。再次注意使用`$<BUILD_INTERFACE:...>`和`$<INSTALL_INTERFACE:...>`生成器表达式。我们将在后面对此进行评论：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We finish off the shared library target by listing link libraries and target
    properties. These are unchanged from the previous recipe:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过列出链接库和目标属性来完成共享库目标。这些与前一个食谱中未更改：
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The same is done for the `message-static` library target:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于`message-static`库目标也是如此：
- en: 'We first declare it and list its sources:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先声明它并列出其源文件：
- en: '[PRE55]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We give `PUBLIC` and `INTERFACE` compile definitions, as in the previous recipe,
    but now using the `$<INSTALL_INTERFACE:...>` generator expression:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们给出`PUBLIC`和`INTERFACE`编译定义，就像在前一个食谱中一样，但现在使用`$<INSTALL_INTERFACE:...>`生成器表达式：
- en: '[PRE56]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We list include directories with the same command used for the shared target:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用与共享目标相同的命令列出包含目录：
- en: '[PRE57]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Link libraries and target properties are unchanged with respect to the previous
    recipe:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接库和目标属性与前一个食谱相比未更改：
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Executables are generated with the exact same commands used in the previous
    recipe:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与前一个食谱中完全相同的命令生成可执行文件：
- en: '[PRE59]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We are now ready to look at the installation rules:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备查看安装规则：
- en: 'We list the installation rules for our targets all together, since CMake can
    correctly place each of the target in the proper destination. This time, we add
    the `EXPORT` keyword so that CMake will generate an exported target file for our
    targets:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将所有目标的安装规则列在一起，因为CMake可以正确地将每个目标放置在适当的目的地。这次，我们添加了`EXPORT`关键字，以便CMake将为我们导出的目标生成一个导出的目标文件：
- en: '[PRE60]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The auto-generated export target file is called `messageTargets.cmake`, and
    we need to explicitly specify install rules for it. The destination of this file
    is `INSTALL_CMAKEDIR` defined in the root `CMakeLists.txt` file:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动生成的导出目标文件名为`messageTargets.cmake`，我们需要为它明确指定安装规则。该文件的目的地是在根`CMakeLists.txt`文件中定义的`INSTALL_CMAKEDIR`：
- en: '[PRE61]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we need to generate the proper CMake configuration files. These will
    guarantee that a downstream project will be able to find the targets exported
    by the message library. To do so, we first include the `CMakePackageConfigHelpers.cmake`
    standard module:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要生成适当的CMake配置文件。这些文件将确保下游项目能够找到由message库导出的目标。为此，我们首先包含`CMakePackageConfigHelpers.cmake`标准模块：
- en: '[PRE62]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We let CMake generate a file containing version information for our library:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们让CMake生成一个包含我们库版本信息的文件：
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Using the `configure_package_config_file` function, we generate the actual
    CMake configuration file. This is based on the template `cmake/messageConfig.cmake.in`
    file:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`configure_package_config_file`函数，我们生成实际的CMake配置文件。这是基于模板`cmake/messageConfig.cmake.in`文件：
- en: '[PRE65]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As a last step, we set the install rules for these two auto-generated configuration
    files:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们为这两个自动生成的配置文件设置安装规则：
- en: '[PRE66]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'What are the contents of the `cmake/messageConfig.cmake.in` template file?
    The header of this file serves as documentation for its users. Let us look at
    the actual CMake commands:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmake/messageConfig.cmake.in`模板文件的内容是什么？该文件的头部作为对其用户的文档。让我们看看实际的CMake命令：'
- en: 'We start with a placeholder that will be replaced by the `configure_package_config_file`
    command:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从一个占位符开始，该占位符将被`configure_package_config_file`命令替换：
- en: '[PRE67]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We include the auto-generated export files for the targets :'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们包含目标的自动生成的导出文件：
- en: '[PRE68]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then we check whether the static and shared libraries and the two "Hello, World"
    executables are present with the `check_required_components` function provided
    by CMake:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用CMake提供的`check_required_components`函数检查静态库、共享库以及两个“Hello, World”可执行文件是否存在：
- en: '[PRE69]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We check whether the target `PkgConfig::UUID` exists. If not, we search again
    for the UUID library, but only if we are not on Windows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查目标`PkgConfig::UUID`是否存在。如果不存在，我们再次搜索UUID库，但仅限于不在Windows系统上时：
- en: '[PRE71]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let us try this out:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下：
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The install tree has the following structure:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 安装树具有以下结构：
- en: '[PRE73]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You will notice that a `share` subdirectory has appeared and it contains all
    the files that we have asked CMake to autogenerate. From now on, the users of
    our `message` library will be able to locate the `message` library by doing this
    in their own  `CMakeLists.txt` file, provided that they set the `message_DIR` CMake
    variable to point to the `share/cmake/message`  directory in the install tree:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到出现了一个`share`子目录，其中包含了所有我们要求CMake自动生成的文件。从现在开始，使用我们的`message`库的用户可以在他们自己的`CMakeLists.txt`文件中通过设置`message_DIR`CMake变量指向安装树中的`share/cmake/message`目录来定位`message`库：
- en: '[PRE74]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: This recipe has covered a lot of ground; let us make sense of it. CMake targets
    are a very useful abstraction for the operations that the build system will perform.
    Using the `PRIVATE`, `PUBLIC`, and `INTERFACE` keywords, we can set how targets
    within the same project will interact with each other. In practice, this lets
    us define how dependencies of target A will affect target B, which depends on
    A. The full power of this mechanism can be appreciated when other projects want
    to use a library as a dependency. If the proper CMake configuration files are
    made available by the library maintainers, then all dependencies can be easily
    resolved with very few CMake commands.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方涵盖了很多内容；让我们来理解它。CMake目标是对构建系统将要执行的操作非常有用的抽象。使用`PRIVATE`、`PUBLIC`和`INTERFACE`关键字，我们可以设置同一项目内的目标将如何相互作用。实际上，这让我们定义了目标A的依赖项将如何影响依赖于A的目标B。当其他项目想要将一个库作为依赖项使用时，可以充分体会到这种机制的强大之处。如果库维护者提供了适当的CMake配置文件，那么所有依赖项都可以很容易地用很少的CMake命令来解决。
- en: 'This problem can be solved by following the pattern outlined in the recipe
    for the `message-static`, `message-shared`, `hello-world_wDSO`, and `hello-world_wAR`
    targets. We will analyze the CMake commands for the `message-shared` target alone,
    but the discussion here is general:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以通过遵循`message-static`、`message-shared`、`hello-world_wDSO`和`hello-world_wAR`目标的配方中概述的模式来解决。我们将单独分析`message-shared`目标的CMake命令，但这里的讨论是通用的：
- en: 'Generate your target and lay out its dependencies within the project build.
    The need to link against the UUID library is a `PUBLIC` requirement for `message-shared`,
    since it will be used both to build targets within the project and targets in
    downstream projects. Compile definitions and include directories need to be set
    both at the `PUBLIC` *or* at the `INTERFACE` level. Some of them will, in fact
    be needed to build targets within the project, others are only relevant for downstream
    projects. Moreover, some of these will only be relevant after the project has
    been installed. This is where the `$<BUILD_INTERFACE:...>` and `$<INSTALL_INTERFACE:...>`
    generator expressions come in. Only downstream targets *external* to the `message`
    library will need these, that is they will only be made visible once the target
    is installed. In our example, the following applies:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目构建中生成目标并布置其依赖项。对于`message-shared`，链接UUID库是一个`PUBLIC`要求，因为它将用于构建项目内的目标以及下游项目中的目标。编译定义和包含目录需要在`PUBLIC`
    *或* `INTERFACE`级别设置。其中一些将用于构建项目内的目标，而其他一些仅与下游项目相关。此外，其中一些仅在项目安装后才相关。这就是`$<BUILD_INTERFACE:...>`和`$<INSTALL_INTERFACE:...>`生成器表达式发挥作用的地方。只有`message`库外部的下游目标才需要这些，也就是说，只有在目标安装后它们才会变得可见。在我们的示例中，以下适用：
- en: '`$<BUILD_INTERFACE:${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}>`  will expand
    to `${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}` only when the `message-shared`
    library target is used within our project.'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<BUILD_INTERFACE:${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}>`仅在`message-shared`库目标在我们的项目内使用时，才会扩展为`${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}`。'
- en: '`$<INSTALL_INTERFACE:${INSTALL_INCLUDEDIR}>` will expand to `${INSTALL_INCLUDEDIR}`
    only when the `message-shared` library target is used as an exported target within
    another build tree.'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$<INSTALL_INTERFACE:${INSTALL_INCLUDEDIR}>`仅在`message-shared`库目标作为另一个构建树内的导出目标使用时，才会扩展为`${INSTALL_INCLUDEDIR}`。'
- en: Describe the install rules for the target, including the name of the `EXPORT`
    file CMake will have to generate.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述目标的安装规则，包括CMake将生成的`EXPORT`文件的名称。
- en: 'Describe the install rules for the export file CMake has generated. The `messageTargets.cmake`
    file will be installed to `INSTALL_CMAKEDIR`. The `NAMESPACE` option to the install
    rule for the target export files will prepend the given string to the name of
    the targets. This is helpful to avoid potential name clashes between targets from
    different projects. The `INSTALL_CMAKEDIR` variable was set in the root `CMakeLists.txt`
    file:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述CMake生成的导出文件的安装规则。`messageTargets.cmake`文件将安装到`INSTALL_CMAKEDIR`。目标导出文件的安装规则的`NAMESPACE`选项将在目标名称前加上给定的字符串。这有助于避免来自不同项目的目标之间的潜在名称冲突。`INSTALL_CMAKEDIR`变量在根`CMakeLists.txt`文件中设置：
- en: '[PRE75]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The final part of our `CMakeLists.txt` generates the configuration files. After
    including the `CMakePackageConfigHelpers.cmake` module, this is done in three
    steps:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们`CMakeLists.txt`的最后一部分生成配置文件。在包含`CMakePackageConfigHelpers.cmake`模块之后，这分为三个步骤完成：
- en: 'We call the `write_basic_package_version_file` CMake function to generate a
    package version file. The first argument to the macro is the path to the versioning
    file: `messageConfigVersion.cmake`. We then specify the version in the Major.Minor.Patch
    format, using the `PROJECT_VERSION` CMake variable. Compatibility with newer versions
    of the library can also be specified. In our case, we guarantee compatibility
    when the library has the same major version, hence the `SameMajorVersion` argument.'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`write_basic_package_version_file` CMake函数来生成一个包版本文件。宏的第一个参数是版本文件的路径：`messageConfigVersion.cmake`。然后，我们使用`PROJECT_VERSION`
    CMake变量以Major.Minor.Patch格式指定版本。还可以指定与库的新版本的兼容性。在我们的例子中，我们保证当库具有相同的major版本时兼容，因此使用了`SameMajorVersion`参数。
- en: Next, we configure our template file, `messageConfig.cmake.in`; this file is
    located in the `cmake` subdirectory of the project.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们配置模板文件`messageConfig.cmake.in`；该文件位于项目的`cmake`子目录中。
- en: Finally, we set the install rules for the newly generated files. Both will be
    installed under `INSTALL_CMAKEDIR`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为新生成的文件设置安装规则。两者都将安装在`INSTALL_CMAKEDIR`下。
- en: There is more
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: 'Clients of the message library are now very happy since they can finally install
    the library on their system and have CMake discover it for them with minimal modifications
    to their own `CMakeLists.txt`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 消息库的客户端现在非常满意，因为他们终于可以在自己的系统上安装该库，并且让CMake为他们发现它，而无需对其自己的`CMakeLists.txt`进行太多修改。
- en: '[PRE76]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Clients can now configure their project with the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端现在可以按以下方式配置他们的项目：
- en: '[PRE77]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The tests included with our example show how to check that the installation
    of the targets went according to plan. Looking at the structure of the `tests`
    folder we notice the `use_target` subdirectory:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中包含的测试展示了如何检查目标的安装是否按计划进行。查看`tests`文件夹的结构，我们注意到`use_target`子目录：
- en: '[PRE78]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This directory contains a small project that uses the exported targets. The
    interesting part is in the `CMakeLists.txt` file specifying the tests:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 该目录包含一个使用导出目标的小型项目。有趣的部分在于指定测试的`CMakeLists.txt`文件：
- en: 'We test that the small project can be configured to use the installed library.
    This is the set up step of the use-target test fixture, as shown in [Chapter 4](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml), *Creating
    and Running Tests*, Recipe 10, *Using test fixtures*:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们测试小型项目是否可以配置为使用已安装的库。这是使用目标测试夹具的设置步骤，如[第4章](5b1b2efb-2ce1-4f8f-b4dd-a05606d8b87c.xhtml)，*创建和运行测试*，食谱10，*使用测试夹具*所示：
- en: '[PRE79]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We test that the small project can be built:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们测试小型项目是否可以构建：
- en: '[PRE80]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The tests of the small projects are also run:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 小型项目的测试也会运行：
- en: '[PRE81]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, we tear down the fixture:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们拆卸夹具：
- en: '[PRE82]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Note that these tests can only be run *after* the project has been installed.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些测试只能在项目安装*之后*运行。
- en: Installing a superbuild
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装超级构建
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-04) and
    has a C++ example. The recipe is valid with CMake version 3.6 (and higher) and
    has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-04)找到，并包含一个C++示例。该食谱适用于CMake版本3.6（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: Our example `message` library has become a huge success, and many other programmers
    use it and are very happy with it. You want to use it in your own project too,
    but are unsure how to manage the dependency properly. You could ship the source
    code for the message library with your own code, but what if the library is already
    installed on the system? [Chapter 8](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml),
    *The Superbuild Pattern*, showed that this is a typical scenario for a superbuild,
    but you are unsure on how to install such a project. This recipe will walk you
    through the details of installing a superbuild.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例`message`库取得了巨大成功，许多其他程序员都在使用它，并且非常满意。您也想在自己的项目中使用它，但不确定如何正确管理依赖关系。您可以将`message`库的源代码与您自己的代码一起打包，但如果该库已经在系统上安装了呢？[第8章](2c4b0d92-f493-4e2c-9732-a1039be79580.xhtml)，*超级构建模式*，展示了这是一个典型的超级构建场景，但您不确定如何安装这样的项目。本食谱将引导您了解安装超级构建的细节。
- en: Getting ready
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'This recipe will build a simple executable linking against the `message` library.
    The layout of the project is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将构建一个简单的可执行文件，该文件链接到`message`库。项目的布局如下：
- en: '[PRE83]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The main `CMakeLists.txt` file coordinates the superbuild. The `external` subdirectory
    contains CMake instructions to handle the dependencies. The `cmake` subdirectory
    contains a Python script and a template CMake script. These will be used to fine-tune
    the installation, the CMake script being first configured and then executed to
    call the Python script to print the `RPATH` for the installed `use_message` executable:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 主`CMakeLists.txt`文件协调超级构建。`external`子目录包含处理依赖关系的CMake指令。`cmake`子目录包含一个Python脚本和一个模板CMake脚本。这些将用于微调安装，首先配置CMake脚本，然后执行以调用Python脚本打印已安装的`use_message`可执行文件的`RPATH`：
- en: '[PRE84]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Printing the `RPATH` can easily be done with platform-native tools that we will
    discuss later on in this recipe.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用平台原生工具打印`RPATH`很容易，我们将在本食谱后面讨论这些工具。
- en: 'Finally, the `src` subdirectory contains the `CMakeLists.txt` and source file
    for the actual project we want to compile. The `use_message.cpp` source file contains
    the following:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`src`子目录包含实际项目要编译的`CMakeLists.txt`和源文件。`use_message.cpp`源文件包含以下内容：
- en: '[PRE85]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: How to do it
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We will start by looking at the root `CMakeLists.txt` file, which is coordinating
    the superbuild:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看协调超级构建的根`CMakeLists.txt`文件开始：
- en: 'Its preamble is unchanged with respect to the previous recipes. We start by
    declaring a C++11 project, we set a sensible default install prefix, build type,
    output directories for our targets, and layout of components in the install tree:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其序言与之前的食谱相比没有变化。我们首先声明一个C++11项目，设置一个合理的默认安装前缀、构建类型、目标的输出目录以及安装树中组件的布局：
- en: '[PRE86]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We set the `EP_BASE` directory property. This will set the layout for the subprojects
    in the superbuild. All subprojects will be checked out and built under the `subprojects`
    folder of `CMAKE_BINARY_DIR`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置`EP_BASE`目录属性。这将设置超级构建中子项目的布局。所有子项目都将在`CMAKE_BINARY_DIR`的`subprojects`文件夹下检出和构建：
- en: '[PRE87]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'We then declare the `STAGED_INSTALL_PREFIX` variable. This variable points
    to the `stage` subdirectory under the build directory. The project will be installed
    here during the build. This is a way of sandboxing the installation process and
    gives us a chance to check that the whole superbuild will install with a correct
    layout:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们声明`STAGED_INSTALL_PREFIX`变量。该变量指向构建目录下的`stage`子目录。项目将在构建期间安装在这里。这是一种沙盒化安装过程的方法，并给我们一个机会来检查整个超级构建是否将按照正确的布局安装：
- en: '[PRE88]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We add the `external/upstream` subdirectory. This contains CMake instructions
    to manage our upstream dependencies, in our case, the `message` library:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加`external/upstream`子目录。这包含管理我们的上游依赖项的CMake指令，在我们的例子中，是`message`库：
- en: '[PRE89]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We then include the `ExternalProject.cmake` standard module:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们包含`ExternalProject.cmake`标准模块：
- en: '[PRE90]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We add our own project as an external project, invoking the `ExternalProject_Add`
    command. The `SOURCE_DIR` option specifies that the sources are in the `src` subdirectory.
    We also pass all appropriate CMake arguments to configure our project. Note the
    use of `STAGED_INSTALL_PREFIX` as the installation prefix for the subproject:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将自己的项目作为外部项目添加，调用`ExternalProject_Add`命令。`SOURCE_DIR`选项指定源代码位于`src`子目录中。我们还传递了所有适当的CMake参数来配置我们的项目。注意使用`STAGED_INSTALL_PREFIX`作为子项目的安装前缀：
- en: '[PRE91]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We now add a test for the `use_message` executable, built by the `recipe-04_core`
    target. This will run the staged installation of the `use_message` executable,
    that is the one located within the build tree:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们为`recipe-04_core`目标构建的`use_message`可执行文件添加一个测试。这将运行位于构建树内的`use_message`可执行文件的临时安装：
- en: '[PRE92]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Finally, we can declare install rules. This time they are rather simple. Since
    everything needed has already been installed with the correct layout in the staging
    area, we only need to copy the whole contents of the staging area to the install
    prefix:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以声明安装规则。这次它们相当简单。由于所需的一切都已按照正确的布局安装在临时区域中，我们只需要将临时区域的全部内容复制到安装前缀：
- en: '[PRE93]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We declare an additional installation rule with the `SCRIPT` argument. The
    CMake script `install_hook.cmake` will be executed, but only on GNU/Linux and
    macOS. This script will print the `RPATH` of the installed executable and run
    it. We will discuss this in more detail in the next section:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`SCRIPT`参数声明一个额外的安装规则。CMake脚本`install_hook.cmake`将被执行，但仅限于GNU/Linux和macOS。该脚本将打印已安装可执行文件的`RPATH`并运行它。我们将在下一节中详细讨论这一点：
- en: '[PRE94]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'You will have noticed that `-Dmessage_DIR=${message_DIR}` has been passed as
    a CMake argument to our own project. This will correctly set the location of the
    message library dependency. The value of `message_DIR` is defined in the `CMakeLists.txt` file
    under the `external/upstream/message` directory. This file handles the dependency
    on the `message` library – let us see how:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，`-Dmessage_DIR=${message_DIR}`作为CMake参数传递给了我们自己的项目。这将正确设置消息库依赖项的位置。`message_DIR`的值在`external/upstream/message`目录下的`CMakeLists.txt`文件中定义。该文件处理对`message`库的依赖——让我们看看它是如何处理的：
- en: 'We first attempt to find the package. Possibly, the user will have already
    installed it somewhere on the system and may have passed the `message_DIR` option
    when configuring:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先尝试找到该软件包。可能用户已经在系统上的某个地方安装了它，并在配置时传递了`message_DIR`选项：
- en: '[PRE95]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'If that was indeed the case and `message` was found, we report the location
    and the version of the target to the user and add a dummy `message_external` target.
    The dummy target is needed to handle superbuild dependencies correctly:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果情况确实如此，并且找到了`message`，我们向用户报告目标的位置和版本，并添加一个虚拟的`message_external`目标。虚拟目标是正确处理超级构建依赖项所必需的：
- en: '[PRE96]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'If the library was not found, we will add it as an external project, download
    it from its online Git repository, and compile it. The install prefix, build type,
    and installation directories layout are all set from the root `CMakeLists.txt`
    file, as are the C++ compiler and flags. The project will be installed to `STAGED_INSTALL_PREFIX`
    and then tested:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果未找到该库，我们将把它作为外部项目添加，从其在线Git存储库下载并编译它。安装前缀、构建类型和安装目录布局都是从根`CMakeLists.txt`文件设置的，C++编译器和标志也是如此。该项目将被安装到`STAGED_INSTALL_PREFIX`，然后进行测试：
- en: '[PRE97]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Finally, we set the `message_DIR` directory to point to the location of the
    freshly built `messageConfig.cmake` file. Note that the path is saved to the CMake
    cache:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`message_DIR`目录设置为指向新构建的`messageConfig.cmake`文件的位置。请注意，路径被保存到CMake缓存中：
- en: '[PRE98]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We are finally ready to compile our own project and successfully link it against
    the `message` library, be it already available on the system or freshly built
    for the purpose. Since this is a superbuild, the code under the `src` subdirectory
    is a fully standalone CMake project:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好编译我们自己的项目，并成功地将其链接到`message`库，无论是系统上已有的还是为了这个目的新构建的。由于这是一个超级构建，位于`src`子目录下的代码是一个完全独立的CMake项目：
- en: 'We declare a C++11 project, as usual:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个C++11项目，一如既往：
- en: '[PRE99]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We attempt finding the `message` library. Within our superbuild, the configuration
    will have `message_DIR` correctly set:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们尝试查找`message`库。在我们的超级构建中，配置将正确设置`message_DIR`：
- en: '[PRE100]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We are ready to add our executable target, `use_message`. This is built from
    the `use_message.cpp` source file and links in the `message::message-shared` target:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们准备好添加我们的可执行目标`use_message`。这是从`use_message.cpp`源文件构建的，并链接了`message::message-shared`目标：
- en: '[PRE101]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Target properties are set for `use_message`. Note once again the `RPATH` fixing:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为目标属性设置`use_message`。再次注意`RPATH`修复：
- en: '[PRE102]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Finally, we set install rules for the `use_message` target:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为`use_message`目标设置安装规则：
- en: '[PRE103]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Let us now look at the contents of the `install_hook.cmake.in` template CMake
    script:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`install_hook.cmake.in`模板CMake脚本的内容：
- en: 'The CMake script is executed outside the scope of our main project and hence
    has no notion of variables or targets defined there. We thus set a variable holding
    the full path to the installed `use_message` executable. Note the use of `@INSTALL_BINDIR@`,
    which will be resolved by `configure_file`:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake脚本在我们的主项目范围之外执行，因此对在那里定义的变量或目标没有任何概念。因此，我们设置一个变量，其中包含已安装的`use_message`可执行文件的完整路径。请注意使用`@INSTALL_BINDIR@`，它将由`configure_file`解析：
- en: '[PRE104]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We need to find the executable for the platform-native tool we will use to
    print the `RPATH` of the installed executable. We will search for  `chrpath`,
    `patchelf`, and `otool`. The search exits as soon one is found to be installed
    with an helpful status message to the user:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要找到用于打印已安装可执行文件的`RPATH`的平台原生工具的可执行文件。我们将搜索`chrpath`、`patchelf`和`otool`。一旦找到其中一个已安装的工具，搜索就会退出，并向用户显示有帮助的状态消息：
- en: '[PRE105]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We check whether the `_patcher` variable is not empty. It would mean no ELF
    patching tool is available and the operation we want to carry out will fail. We
    emit a fatal error and alert the user that one of the ELF patching tools needs
    to be installed:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查`_patcher`变量是否不为空。这意味着没有可用的ELF修补工具，我们想要执行的操作将会失败。我们发出致命错误，并通知用户需要安装其中一个ELF修补工具：
- en: '[PRE106]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'In case one the ELF patching tools was found, we proceed. We invoke the `print_rpath.py` Python
    script, passing the `_executable` variable as argument. We use `execute_process`
    for this purpose:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到了ELF修补工具之一，我们继续进行。我们调用`print_rpath.py` Python脚本，将`_executable`变量作为参数传递。我们为此目的使用`execute_process`：
- en: '[PRE107]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We check the `_res` variable for return code. If execution was successful,
    we print the standard output stream captured in the `_out` variable. Otherwise,
    we print the captured standard output and error streams before exiting with a
    fatal error:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查`_res`变量以获取返回代码。如果执行成功，我们打印在`_out`变量中捕获的标准输出流。否则，我们在退出前打印捕获的标准输出和错误流，并显示致命错误：
- en: '[PRE108]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We invoke once again `execute_process` to run the installed `use_message` executable:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次调用`execute_process`来运行已安装的`use_message`可执行文件：
- en: '[PRE109]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Finally, we report to the user on the result of `execute_process`:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们向用户报告`execute_process`的结果：
- en: '[PRE110]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: How it works
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The superbuild is a very useful pattern in our CMake toolbox. It lets us manage
    complex projects by separating them into smaller, more manageable subprojects.
    In addition, we can use CMake as a package manager for the project we are building.
    CMake can search for our dependencies and, in case they are not found on the system,
    freshly build them for us. The basic pattern requires three `CMakeLists.txt` files:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 超级构建是我们CMake工具箱中非常有用的模式。它允许我们通过将它们分成更小、更易于管理的子项目来管理复杂项目。此外，我们可以将CMake用作项目构建的包管理器。CMake可以搜索我们的依赖项，如果它们在系统上找不到，可以为我们新构建它们。基本模式需要三个`CMakeLists.txt`文件：
- en: The root `CMakeLists.txt`  file contains settings shared by the project and
    the dependencies. It also includes our own project as an external project. In
    our case, we chose the name `${PROJECT_NAME}_core`; that is, `recipe-04_core`,
    since the project name `recipe-04` is used for the superbuild.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根`CMakeLists.txt`文件包含项目和依赖项共享的设置。它还将我们自己的项目作为外部项目包含在内。在我们的例子中，我们选择了名称`${PROJECT_NAME}_core`；也就是说，`recipe-04_core`，因为项目名称`recipe-04`用于超级构建。
- en: The external `CMakeLists.txt` file will attempt to find our upstream dependencies
    and contains the logic to switch between importing targets or building them, depending
    on whether the dependencies were found or not. It is good practice to have separate
    subdirectories for each dependency, containing a similarly structured `CMakeLists.txt`
    file.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部`CMakeLists.txt`文件将尝试找到我们的上游依赖项，并包含根据是否找到依赖项来切换导入目标或构建它们的逻辑。为每个依赖项提供单独的子目录，并包含结构类似的`CMakeLists.txt`文件，这是一个好习惯。
- en: Finally, the `CMakeLists.txt` file for our own project is a standalone CMake
    project file, since, in principle, we can configure and build it on its own without
    the additional facilities for dependency management offered by the superbuild.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们自己的项目的`CMakeLists.txt`文件是一个独立的CMake项目文件，因为原则上，我们可以单独配置和构建它，而不需要超级构建提供的额外依赖管理设施。
- en: 'We will first consider the configuration of the superbuild when the dependency
    on the `message` library is not already satisfied:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将考虑在`message`库的依赖未得到满足时的超级构建配置：
- en: '[PRE111]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We will let CMake find the library for us, and this is the output we obtain:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让CMake为我们找到库，这是我们得到的输出：
- en: '[PRE112]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'As instructed, CMake reports the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如所指示，CMake报告以下内容：
- en: The installation will be staged into the build tree. The staged installation
    is a way of sandboxing the actual installation process. As developers, this is
    useful for checking that all libraries, executables, and files are installed in
    the proper location before running the installation commands. For users, it gives
    the same final structure, but within the build directory. In this way, our project
    is immediately usable, even without running a proper installation.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装将被分阶段到构建树中。分阶段安装是一种沙盒化实际安装过程的方法。作为开发者，这对于检查所有库、可执行文件和文件是否安装在正确位置之前运行安装命令很有用。对于用户来说，它提供了相同的最终结构，但在构建目录内。这样，即使没有运行适当的安装，我们的项目也可以立即使用。
- en: A suitable `message` library was not found on the system. CMake will then run
    the commands provided for building the library prior to building our project,
    in order to satisfy this dependency.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统上没有找到合适的`message`库。然后，CMake将在构建我们的项目之前运行提供用于构建库的命令，以满足这个依赖。
- en: If the library is already at a known location on the system, we can pass the
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果库已经在系统上的已知位置，我们可以传递
- en: '`-Dmessage_DIR` option to CMake:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: CMake的`-Dmessage_DIR`选项：
- en: '[PRE113]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'And, in fact, the library was found and imported. Only build operations for
    our own project will be performed:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，库已被找到并导入。只会执行我们自己项目的构建操作：
- en: '[PRE114]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The final installation rule for the project will copy the contents of the staged
    installation prefix to `CMAKE_INSTALL_PREFIX`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的最终安装规则将复制分阶段安装前缀的内容到`CMAKE_INSTALL_PREFIX`：
- en: '[PRE115]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Note the use of `.` rather than the `${CMAKE_INSTALL_PREFIX}` absolute path,
    such that this rule can be understood properly also by the CPack tool. Usage of
    CPack will be shown in [Chapter 11](293b5487-bede-4764-bc0e-e74fe110402e.xhtml),
    *Packaging Projects*, Recipe 1, *Generating source and binary packages*.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`.`而不是`${CMAKE_INSTALL_PREFIX}`绝对路径，这样这个规则也可以被CPack工具正确理解。CPack的使用将在[第11章](293b5487-bede-4764-bc0e-e74fe110402e.xhtml)，*打包项目*，第1节，*生成源代码和二进制包*中展示。
- en: 'The `recipe-04_core` project builds a simple executable target that links against
    the `message` shared library. As discussed earlier in this chapter, the `RPATH`
    needs to be set properly in order for the executable to run correctly. Recipe
    1 in this chapter showed how to achieve just that with the help of CMake and the
    same pattern was reused here in the `CMakeLists.txt` handling the creation of
    the `use_message` executable:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`recipe-04_core`项目构建一个简单的可执行目标，该目标链接到`message`共享库。正如本章前面所讨论的，需要正确设置`RPATH`，以便可执行文件能够正确运行。本章的第1节展示了如何使用CMake实现这一点，同样的模式在这里被用于处理创建`use_message`可执行文件的`CMakeLists.txt`：'
- en: '[PRE116]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'To check that this is indeed enough, we can use a platform-native tool to print
    the `RPATH` of the installed executable. We wrap the call to the tool into a Python
    script, with is further wrapped into a CMake script. Eventually, the CMake script
    is invoked as an installation rule with the `SCRIPT` keyword:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这确实足够，我们可以使用平台原生工具打印已安装可执行文件的`RPATH`。我们将对该工具的调用封装在一个Python脚本中，该脚本进一步封装在一个CMake脚本中。最终，CMake脚本作为安装规则使用`SCRIPT`关键字被调用：
- en: '[PRE117]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'This additional script is executed at the very end of the installation process:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这个额外的脚本在安装过程的最后执行：
- en: '[PRE118]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'and on a GNU/Linux system we would see the following output:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在GNU/Linux系统上，我们将看到以下输出：
- en: '[PRE119]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The utilities we suggest to use to work with Executable and Linkable Format
    (ELF) objects are PatchELF ([https://nixos.org/patchelf.html](https://nixos.org/patchelf.html)),
    chrpath ([https://linux.die.net/man/1/chrpath](https://linux.die.net/man/1/chrpath)),
    and otool ([http://www.manpagez.com/man/1/otool/](http://www.manpagez.com/man/1/otool/)).
    The first one works on GNU/Linux and macOS, whereas chrpath and otool are GNU/Linux
    and macOS specific, respectively.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议用于处理可执行和可链接格式（ELF）对象的工具包括PatchELF（[https://nixos.org/patchelf.html](https://nixos.org/patchelf.html)）、chrpath（[https://linux.die.net/man/1/chrpath](https://linux.die.net/man/1/chrpath)）和otool（[http://www.manpagez.com/man/1/otool/](http://www.manpagez.com/man/1/otool/)）。第一个工具适用于GNU/Linux和macOS，而chrpath和otool分别适用于GNU/Linux和macOS。
