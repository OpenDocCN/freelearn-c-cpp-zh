- en: Interacting with JavaScript and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与JavaScript交互和调试
- en: There's a great deal of exciting features and proposals in the works for WebAssembly.
    However, at the time of writing this book, the feature set is rather limited.
    As it stands, you can benefit greatly from using some of the features Emscripten
    provides. The process for interacting with C/C++ from JavaScript (and vice versa)
    will differ depending on whether you decide to use Emscripten.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly中有许多令人兴奋的功能和提案。然而，在撰写本书时，功能集相当有限。就目前而言，您可以从Emscripten提供的一些功能中获益良多。从JavaScript与C/C++交互（反之亦然）的过程将取决于您是否决定使用Emscripten。
- en: In this chapter, we will cover how to utilize JavaScript functions with C/C++
    code as well as how to interact with the compiled output of your C/C++ code from
    JavaScript. We'll also describe how Emscripten's *glue* code affects the ways
    a Wasm instance is utilized and how to debug compiled code in the browser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何使用JavaScript函数与C/C++代码以及如何与JavaScript中编译输出的C/C++代码进行交互。我们还将描述Emscripten的*glue*代码如何影响Wasm实例的使用方式以及如何在浏览器中调试编译代码。
- en: 'Our goal for this chapter is to understand the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是理解以下内容：
- en: The differences between Emscripten's `Module` and the browser's `WebAssembly`
    object
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Emscripten的`Module`与浏览器的`WebAssembly`对象之间的差异
- en: How to call compiled C/C++ functions from your JavaScript code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从您的JavaScript代码中调用编译后的C/C++函数
- en: How to call JavaScript functions from your C/C++ code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从您的C/C++代码中调用JavaScript函数
- en: Special considerations to be aware of when working with C++
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用C++时需要注意的特殊考虑事项
- en: Techniques for debugging compiled output in the browser
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中调试编译输出的技术
- en: The Emscripten module versus the WebAssembly object
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Emscripten模块与WebAssembly对象
- en: In the previous chapter, we briefly covered Emscripten's `Module` object and
    how to load it in the browser. The `Module` object provides several convenient
    methods and differs significantly from the browser's `WebAssembly` object. In
    this section, we're going to review Emscripten's `Module` object in greater detail.
    We'll also discuss the difference between Emscripten's `Module` and the objects
    described in WebAssembly's *JavaScript API*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了Emscripten的`Module`对象以及如何在浏览器中加载它。`Module`对象提供了几种方便的方法，并且与浏览器的`WebAssembly`对象有很大的不同。在本节中，我们将更详细地回顾Emscripten的`Module`对象。我们还将讨论Emscripten的`Module`与WebAssembly的*JavaScript
    API*中描述的对象之间的差异。
- en: What is the Emscripten module?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Emscripten模块？
- en: 'Emscripten''s official site provides the following definition for the `Module`
    object:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten的官方网站为`Module`对象提供了以下定义：
- en: '"Module is a global JavaScript object with attributes that Emscripten-generated
    code calls at various points in its execution."'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “Module是一个全局JavaScript对象，Emscripten生成的代码在其执行的各个点上调用它的属性。”
- en: Not only is the loading procedure different from WebAssembly's `compile` and
    `instantiate` functions, but the `Module` provides some helpful functionality
    out of the box that would otherwise require a custom implementation in WebAssembly.
    The `Module` is available in a global scope (`window.Module`) after fetching and
    loading Emscripten's JavaScript *glue* code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Module`不仅在加载过程上与WebAssembly的`compile`和`instantiate`函数不同，而且`Module`在全局范围内提供了一些有用的功能，否则在WebAssembly中需要自定义实现。在获取和加载Emscripten的JavaScript
    *glue*代码后，`Module`在全局范围内(`window.Module`)可用。'
- en: Default methods in the glue code
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 胶水代码中的默认方法
- en: Emscripten's `Module` object provides some default methods and properties to
    aid in debugging and ensuring the successful execution of your compiled code.
    You can utilize the `preRun` and `postRun` properties to execute JavaScript code
    before or after the Module's `run()` function is called, or pipe the output of
    the `print()` and `printErr()` functions to an HTML element on the page. We'll
    utilize some of these methods later in this book. You can read more about them
    at [https://kripken.github.io/emscripten-site/docs/api_reference/module.html](https://kripken.github.io/emscripten-site/docs/api_reference/module.html).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten的`Module`对象提供了一些默认方法和属性，以帮助调试和确保编译代码的成功执行。您可以利用`preRun`和`postRun`属性在`run()`函数调用之前或之后执行JavaScript代码，或将`print()`和`printErr()`函数的输出导入页面上的HTML元素。我们将在本书的后面使用其中一些方法。您可以在[https://kripken.github.io/emscripten-site/docs/api_reference/module.html](https://kripken.github.io/emscripten-site/docs/api_reference/module.html)了解更多信息。
- en: Differences with the WebAssembly object
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly对象的差异
- en: We covered the browser's WebAssembly object and the corresponding loading procedures
    in [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml), *Creating and Loading
    a WebAssembly Module*. WebAssembly's JavaScript and Web APIs define the objects
    and methods available in the browser's `window.WebAssembly` object. Emscripten's
    `Module` can be seen as a combination of WebAssembly's `Module` and `Instance`
    objects, which are present in the `result` object that WebAssembly's instantiation
    function returns. By passing the `-s MODULARIZE=1` flag to the `emcc` command,
    we're able to replicate WebAssembly's instantiation method (to a degree). We will
    examine the differences between Emscripten's `Module` and the browser's `WebAssembly`
    object in greater detail as we evaluate the methods of integrating JavaScript
    and C/C++ in the upcoming sections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)中介绍了浏览器的WebAssembly对象和相应的加载过程，*创建和加载WebAssembly模块*。WebAssembly的JavaScript和Web
    API定义了浏览器的`window.WebAssembly`对象中可用的对象和方法。Emscripten的`Module`可以看作是WebAssembly的`Module`和`Instance`对象的组合，这些对象存在于WebAssembly的实例化函数返回的`result`对象中。通过将`-s
    MODULARIZE=1`标志传递给`emcc`命令，我们能够复制WebAssembly的实例化方法（在一定程度上）。随着我们评估在即将到来的章节中集成JavaScript和C/C++的方法，我们将更详细地检查Emscripten的`Module`与浏览器的`WebAssembly`对象之间的差异。
- en: Calling compiled C/C++ functions from JavaScript
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从JavaScript调用编译后的C/C++函数
- en: Calling functions from a Wasm instance is a relatively straightforward process
    with or without Emscripten's glue code. Utilizing Emscripten's API affords a wider
    range of functionality and integration at the expense of including the glue code
    alongside the `.wasm` file. In this section, we will review the means of interacting
    with the compiled Wasm instance through JavaScript and the added tooling Emscripten
    provides.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从Wasm实例调用函数是一个相对简单的过程，无论是否使用Emscripten的粘合代码。利用Emscripten的API可以提供更广泛的功能和集成，但需要将粘合代码与`.wasm`文件一起包含。在本节中，我们将回顾通过JavaScript与编译后的Wasm实例进行交互的方法以及Emscripten提供的附加工具。
- en: Calling functions from a Module
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Module调用函数
- en: 'Emscripten provides two functions for calling compiled C/C++ functions from
    JavaScript: `ccall()` and `cwrap()`. Both of these functions are present in the
    `Module` object. Deciding which one to use is contingent on whether the function
    will be called more than once. The content in the following sections was taken
    from Emscripten''s API reference documentation for `preamble.js`, which can be
    viewed at [http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html](http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten提供了两个函数来从JavaScript调用编译后的C/C++函数：`ccall()`和`cwrap()`。这两个函数都存在于`Module`对象中。决定使用哪一个取决于函数是否会被多次调用。以下内容摘自Emscripten的API参考文档`preamble.js`，可以在[http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html](http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html)上查看。
- en: You don't need to prefix function calls with `_` when using `ccall()` or `cwrap()` – just
    use the name specified in the C/C++ file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`ccall()`或`cwrap()`时，不需要在函数调用前加上`_`前缀，只需使用C/C++文件中指定的名称。
- en: Module.ccall()
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Module.ccall()
- en: '`Module.ccall()` calls a compiled C function from JavaScript and returns the
    result of that function. The function signature for `Module.ccall()` is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Module.ccall()`从JavaScript调用编译后的C函数，并返回该函数的结果。`Module.ccall()`的函数签名如下：'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You must specify a type name for the `returnType` and `argTypes` parameters.
    The possible types are `"number"`, `"string"`, `"array"`, and `"boolean"`, which
    correspond to the appropriate JavaScript types. You cannot specify `"array"` for
    the `returnType` parameter because there is no way to know the length of the array.
    If the function doesn't return anything, you can specify `null` for the `returnType`
    (note the absence of quotation marks).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`returnType`和`argTypes`参数中必须指定类型名称。可能的类型有`"number"`、`"string"`、`"array"`和`"boolean"`，分别对应适当的JavaScript类型。不能在`returnType`参数中指定`"array"`，因为无法知道数组的长度。如果函数不返回任何内容，可以为`returnType`指定`null`（注意没有引号）。
- en: The `opts` parameter is an optional options object that can contain a Boolean
    property named `async`. Specifying a value of `true` for this property implies
    that the call will perform an async operation. We won't use this parameter for
    any of our examples, but if you wish to learn more about it, the documentation
    is available at [http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html#calling-compiled-c-functions-from-javascript](http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html#calling-compiled-c-functions-from-javascript).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`opts`参数是一个可选的选项对象，可以包含一个名为`async`的布尔属性。为此属性指定值`true`意味着调用将执行异步操作。我们不会在任何示例中使用此参数，但如果您想了解更多信息，可以在文档[http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html#calling-compiled-c-functions-from-javascript](http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html#calling-compiled-c-functions-from-javascript)中找到。'
- en: 'Let''s look at an example of `ccall()`. The following code, taken from the
    Emscripten site, demonstrates how to call a function named `c_add()` from the
    compiled output of a C file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个`ccall()`的例子。以下代码取自Emscripten网站，演示了如何从C文件的编译输出中调用名为`c_add()`的函数：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Module.cwrap()
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Module.cwrap()
- en: '`Module.cwrap()` is similar to `ccall()` in that it calls a compiled C function.
    However, rather than returning a value, it returns a JavaScript function that
    can be reused as many times as needed. The function signature for `Module.cwrap()` is
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Module.cwrap()`类似于`ccall()`，它调用一个编译后的C函数。然而，它不是返回一个值，而是返回一个JavaScript函数，可以根据需要重复使用。`Module.cwrap()`的函数签名如下：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just as with `ccall()`, you can specify string values that represent types for
    the `returnType` and `argTypes` parameters. You cannot use the `"array"` type
    in `argTypes` because there is no way to know the length of the array when the
    function is called. For a function that doesn't return a value, use `null` (with
    no quotation marks) for the `returnType` parameter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ccall()`一样，您可以指定代表`returnType`和`argTypes`参数的字符串值。在调用函数时，不能在`argTypes`中使用`"array"`类型，因为无法知道数组的长度。对于不返回值的函数，可以在`returnType`参数中使用`null`（不带引号）。
- en: 'The following code, taken from the Emscripten site, demonstrates the use of
    `cwrap()` to create a reusable function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码取自Emscripten网站，演示了如何使用`cwrap()`创建可重用的函数：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: C++ and name mangling
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++和名称修饰
- en: 'You may have noticed that the descriptions of `ccall()` and `cwrap()` specified
    that both are used to call a compiled C function. The omission of C++ was intentional
    because an additional step is needed to call functions from a C++ file. C++ supports
    function overloading, which means that you can use the same function name multiple
    times, but pass different arguments to each one to get a different result. Here''s
    an example of some code that uses function overloading:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，`ccall()`和`cwrap()`的描述指出两者都用于调用编译后的C函数。故意省略了C++，因为需要额外的步骤才能从C++文件中调用函数。C++支持函数重载，这意味着可以多次使用相同的函数名称，但对每个函数传递不同的参数以获得不同的结果。以下是使用函数重载的一些代码示例：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The compiler needs to differentiate between these functions. If it used the
    name `addNumbers` and you tried calling the function in one place with two arguments
    and another with three, it would fail. To call the function by name in your compiled
    Wasm, you need to wrap the function in an `extern` block. One implication of wrapping
    the function is that you would have to explicitly define functions for each condition.
    The following code snippet demonstrates how to implement the previous functions
    without name mangling:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器需要区分这些函数。如果它使用了名称`addNumbers`，并且您尝试在一个地方用两个参数调用该函数，在另一个地方用三个参数调用该函数，那么它将失败。要在编译后的Wasm中按名称调用函数，您需要将函数包装在`extern`块中。包装函数的一个影响是您必须明确为每个条件定义函数。以下代码片段演示了如何实现之前的函数而不进行名称混淆：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Calling functions from a WebAssembly instance
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从WebAssembly实例调用函数
- en: 'We demonstrated how to call a function in a Wasm instance from JavaScript in
    the previous chapter, but that was assuming you instantiated a module in the browser
    with no glue code. Emscripten provides the ability to call functions from the
    Wasm instance as well. After a module is instantiated, you call functions by invoking
    them from the `instance.exports` object, which is accessible from the result of
    the resolved `Promise`. MDN''s documentation provides the following function signature
    for `WebAssembly.instantiateStreaming`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中演示了如何从JavaScript中调用Wasm实例中的函数，但那是假设您在浏览器中实例化了一个模块而没有粘合代码。Emscripten还提供了从Wasm实例调用函数的能力。在模块实例化后，您可以通过从已解析的`Promise`的结果中访问的`instance.exports`对象来调用函数。MDN的文档为`WebAssembly.instantiateStreaming`提供了以下函数签名：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You may need to use the `WebAssembly.instantiate()` method, depending on your
    browser. Chrome currently supports `WebAssembly.instantiateStreaming()`, but if
    you encounter an error when attempting to load your module, use the `WebAssembly.instantiate()`
    method instead.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的浏览器，您可能需要使用`WebAssembly.instantiate()`方法。Chrome目前支持`WebAssembly.instantiateStreaming()`，但如果在尝试加载模块时遇到错误，请改用`WebAssembly.instantiate()`方法。
- en: 'The `ResultObject` contains the `instance` object that we need to reference
    to call exported functions from the module. Here''s some code that calls a function
    named `_addTwoNumbers` from the compiled Wasm instance:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultObject`包含我们需要引用的`instance`对象，以便从模块中调用导出的函数。以下是调用编译后的Wasm实例中名为`_addTwoNumbers`的函数的一些代码：'
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Emscripten provides a way to perform function calls in much the same way, albeit
    in a slightly different implementation. If you use the Promise-like API, you can
    access the function from an `asm` object that the promise of the `Module()` resolves
    with. The following example demonstrates how to utilize this functionality:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten提供了一种以类似的方式执行函数调用的方法，尽管实现略有不同。如果使用类似Promise的API，您可以从`Module()`解析出的`asm`对象中访问函数。以下示例演示了如何利用这个功能：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Replicating the WebAssembly's Web API syntax with Emscripten simplifies any
    future refactoring. You can easily replace `Module()` with WebAssembly's `instantiateStreaming()`
    method and `result.asm` with `result.instance` in the future if you decide to
    use WebAssembly's Web API.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Emscripten复制WebAssembly的Web API语法可以简化任何未来的重构。如果决定使用WebAssembly的Web API，您可以轻松地将`Module()`替换为WebAssembly的`instantiateStreaming()`方法，并将`result.asm`替换为`result.instance`。
- en: Calling JavaScript functions from C/C++
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从C/C++调用JavaScript函数
- en: Accessing JavaScript's functionality from C/C++ code allows for added flexibility
    when working with WebAssembly. The methodologies and means of utilizing JavaScript
    differ considerably between Emscripten's glue code and Wasm-only implementations.
    In this section, we will cover the various ways you can integrate JavaScript into
    your C/C++ code with and without Emscripten.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从C/C++代码访问JavaScript的功能可以在使用WebAssembly时增加灵活性。在Emscripten的粘合代码和仅使用Wasm的实现之间，利用JavaScript的方法和手段有很大的不同。在本节中，我们将介绍您可以在C/C++代码中集成JavaScript的各种方式，无论是否使用Emscripten。
- en: Interacting with JavaScript using glue code
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用粘合代码与JavaScript交互
- en: Emscripten provides several techniques for integrating JavaScript with your
    C/C++ code. The techniques available differ in implementation and complexity,
    and some only apply to specific execution environments (for example, the browser).
    Deciding which one to use is contingent on your specific use case. We'll focus
    on the `emscripten_run_script()` function and inlining JavaScript with `EM_*`
    wrappers. The content in the following sections was taken from the *Interacting
    with Code* section of Emscripten's site, which can be viewed at [https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten提供了几种将JavaScript与C/C++代码集成的技术。可用的技术在实现和复杂性上有所不同，有些只适用于特定的执行环境（例如浏览器）。决定使用哪种技术取决于您的具体用例。我们将重点介绍`emscripten_run_script()`函数和使用`EM_*`包装器内联JavaScript的内容。以下部分的内容取自Emscripten网站的*与代码交互*部分，网址为[https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code)。
- en: Executing strings with emscripten_run_script()
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`emscripten_run_script()`执行字符串。
- en: 'The Emscripten site describes the `emscripten_run_script()` function as the
    most direct, but slightly slower approach for calling JavaScript for C/C++. It''s
    a technique that is well suited for a single line of JavaScript code and can be
    useful for debugging. The documentation states that it effectively runs the code
    using `eval()`, which is a JavaScript function that executes a string as code.
    The following code taken from the Emscripten site demonstrates the use of `emscripten_run_script()`
    to call the browser''s `alert()` function with the text `''hi''`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten网站将`emscripten_run_script()`函数描述为调用JavaScript进行C/C++的最直接但略慢的方法。这是一种非常适合单行JavaScript代码的技术，并且对于调试非常有用。文档说明它有效地使用`eval()`运行代码，`eval()`是一个执行字符串作为代码的JavaScript函数。以下代码取自Emscripten网站，演示了使用`emscripten_run_script()`调用浏览器的`alert()`函数并显示文本`'hi'`的方法：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For more complex use cases where performance is a factor, using *inline JavaScript*
    provides a better solution.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于性能是一个因素的更复杂的用例，使用*内联JavaScript*提供了更好的解决方案。
- en: Executing inline JavaScript with EM_ASM()
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EM_ASM()执行内联JavaScript()
- en: 'You can wrap JavaScript code inside your C/C++ file with `EM_ASM()` and it
    will execute when the compiled code is run in the browser. The following code
    demonstrates basic usage:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在C/C++文件中使用`EM_ASM()`包装JavaScript代码，并在浏览器中运行编译后的代码时执行它。以下代码演示了基本用法：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The JavaScript code is executed immediately and cannot be reused within the
    C/C++ file in which it is contained. Arguments can be passed into the JavaScript
    code block where they arrive as variables `$0`, `$1`, and so on. These arguments
    can either be of type `int32_t` or `double`. The following code snippet, taken
    from the Emscripten site, demonstrates how to utilize arguments in an `EM_ASM()`
    block:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码会立即执行，并且无法在包含它的C/C++文件中重复使用。参数可以传递到JavaScript代码块中，其中它们作为变量`$0`，`$1`等到达。这些参数可以是`int32_t`或`double`类型。以下代码片段取自Emscripten网站，演示了如何在`EM_ASM()`块中使用参数：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Reusing inline JavaScript with EM_JS()
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用内联JavaScript与EM_JS()
- en: 'If you need a reusable function within your C/C++ file, you can wrap JavaScript
    code within an `EM_JS()` block and execute it like a normal C/C++ function. The
    definition for `EM_JS()` is described in the following code snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在C/C++文件中使用可重用的函数，可以将JavaScript代码包装在`EM_JS()`块中，并像普通的C/C++函数一样执行它。`EM_JS()`的定义如下代码片段所示：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `return_type` parameter represents the C type that corresponds with the
    JavaScript code''s output (for example, `int` or `float`). If nothing is returned
    from the JavaScript code, specify `void` for the `return_type`. The next parameter,
    `function_name`, represents the name to use when calling the JavaScript code from
    other locations in the C/C++ file. The `arguments` parameter is used to define
    arguments that can be passed into the JavaScript code from the C calling function.
    The `code` parameter is the JavaScript code that''s wrapped in curly braces. The
    following code snippet, taken from the Emscripten site, demonstrates the use of
    `EM_JS()` in a C file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`return_type`参数表示与JavaScript代码输出对应的C类型（例如`int`或`float`）。如果从JavaScript代码中没有返回任何内容，请为`return_type`指定`void`。下一个参数`function_name`表示在从C/C++文件的其他位置调用JavaScript代码时要使用的名称。`arguments`参数用于定义可以从C调用函数传递到JavaScript代码中的参数。`code`参数是用大括号括起来的JavaScript代码。以下代码片段取自Emscripten网站，演示了在C文件中使用`EM_JS()`的方法：'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Examples of using glue code
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用粘合代码的示例
- en: Let's write some code that utilizes all of these features. In this section,
    we will modify the code we used in the *Compiling C without the glue code* and
    *Fetching and instantiating a Wasm file* sections of [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml),
    *Creating and Loading a WebAssembly Module*. This was the code that displayed
    a moving blue rectangle on a red canvas and could be paused and restarted with
    the click of a button. The code for this section is located in the `/chapter-06-interact-with-js`
    folder in the `learn-webassembly` repository. Let's start by updating the C code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来利用所有这些功能。在本节中，我们将修改我们在[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)中使用的代码，即*编译C而不使用粘合代码*和*获取和实例化Wasm文件*部分，*创建和加载WebAssembly模块*。这是显示在红色画布上移动的蓝色矩形的代码，并且可以通过单击按钮暂停和重新启动。本节的代码位于`learn-webassembly`存储库中的`/chapter-06-interact-with-js`文件夹中。让我们首先更新C代码。
- en: The C code
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C代码
- en: 'Create a new folder in your `/book-examples` folder named `/chapter-06-interact-with-js`.
    Create a new file in the `/chapter-06-interact-with-js` folder named `js-with-glue.c`
    and populate it with the following contents:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`/book-examples`文件夹中创建一个名为`/chapter-06-interact-with-js`的新文件夹。在`/chapter-06-interact-with-js`文件夹中创建一个名为`js-with-glue.c`的新文件，并填充以下内容：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see that we used all three of the JavaScript integrations that Emscripten
    provides. There are two functions, `js_clear_rect()` and `js_fill_rect()`, that
    are defined in `EM_JS()` blocks that take the place of the imported functions
    from the original example. The `EM_ASM()` block within the `setIsRunning()` function
    updates the text of a new status element we'll add to the HTML code. The `emscripten_run_script()`
    functions simply log out some status messages. We need to specify `EMSCRIPTEN_KEEPALIVE`
    above the functions we're planning to utilize outside of the module. If you don't
    specify this, the compiler will treat the functions as dead code and remove them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们使用了Emscripten提供的所有三种JavaScript集成。有两个函数`js_clear_rect()`和`js_fill_rect()`，它们在`EM_JS()`块中定义，代替了原始示例中导入的函数。`setIsRunning()`函数中的`EM_ASM()`块更新了我们将添加到HTML代码中的新状态元素的文本。`emscripten_run_script()`函数只是简单地记录一些状态消息。我们需要在我们计划在模块外部使用的函数上方指定`EMSCRIPTEN_KEEPALIVE`。如果不指定这一点，编译器将把这些函数视为死代码并将其删除。
- en: The HTML code
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML代码
- en: 'Let''s create a file named `js-with-glue.html` in the `/chapter-06-interact-with-js`
    folder and populate it with the following contents:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`/chapter-06-interact-with-js`文件夹中创建一个名为`js-with-glue.html`的文件，并填充以下内容：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We added two `<span>` elements to display the status of the rectangle's movement,
    along with a corresponding label. We're using Emscripten's Promise-like API to
    load the module and reference the functions from the compiled code. We're no longer
    passing in the `_jsFillRect` and `_jsClearRect` functions to the module because
    we're handling that within the `js-with-glue.c` file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个`<span>`元素来显示矩形移动的状态，以及相应的标签。我们使用Emscripten的类似Promise的API来加载模块并引用编译代码中的函数。我们不再将`_jsFillRect`和`_jsClearRect`函数传递给模块，因为我们在`js-with-glue.c`文件中处理了这个问题。
- en: Compiling and serving the result
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和提供结果
- en: 'To compile the code, ensure that you''re in the `/chapter-06-interact-with-js`
    folder and run the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译代码，请确保你在`/chapter-06-interact-with-js`文件夹中，并运行以下命令：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once complete, run the following command to start your local server:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，运行以下命令启动本地服务器：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open up a browser and navigate to `http://127.0.0.1:8080/js-with-glue.html`.
    You should see something like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器，转到`http://127.0.0.1:8080/js-with-glue.html`。你应该会看到类似这样的东西：
- en: '![](img/72e12623-7f8d-4d6a-8661-1f13822c1ef5.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72e12623-7f8d-4d6a-8661-1f13822c1ef5.png)'
- en: Glue code running in the browser
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行胶水代码
- en: If you press the Pause button, the caption on the button should change to Start,
    the text next to Status should change to Paused, and the rectangle should stop
    moving.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按下暂停按钮，按钮上的标题应该会变成开始，状态旁边的文本应该会变成暂停，矩形应该会停止移动。
- en: Interacting with JavaScript without glue code
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无需胶水代码与JavaScript交互
- en: Utilizing JavaScript code in C/C++ files follows a different paradigm than the
    techniques used for Emscripten. Rather than writing JavaScript within the C/C++
    files, you pass the functions into your WebAssembly instantiation code. In this
    section, we will describe this process in greater detail.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在C/C++文件中利用JavaScript代码遵循与Emscripten使用的技术不同的范例。你不是在C/C++文件中编写JavaScript，而是将函数传递到你的WebAssembly实例化代码中。在本节中，我们将更详细地描述这个过程。
- en: Passing JavaScript to C/C++ using the import object
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用导入对象将JavaScript传递给C/C++
- en: 'In order to utilize JavaScript''s functionality in your C/C++ code, you need
    to add a function definition to the `importObj.env` argument that gets passed
    into WebAssembly''s instantiation function. You can either define the function
    outside of the `importObj.env` or inline. The following code snippet demonstrates
    each option:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在你的C/C++代码中利用JavaScript的功能，你需要向传递到WebAssembly实例化函数的`importObj.env`参数中添加一个函数定义。你可以在`importObj.env`之外或内联定义函数。以下代码片段演示了每个选项：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Given the manual memory management and strict typing requirements of C, C++,
    and Rust, you're limited in what can be passed in and utilized in a Wasm module.
    JavaScript allows you to easily add, remove, and change the values of properties
    on an object over the course of code execution. You can even extend the language
    by adding functions to the `prototype` of a built-in language feature. C, C++,
    and Rust are much more restrictive, and it can be difficult to take full advantage
    of WebAssembly if you're not familiar with these languages.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到C、C++和Rust的手动内存管理和严格类型要求，你在Wasm模块中可以传递和利用的内容是有限的。JavaScript允许你在代码执行过程中轻松地添加、删除和更改对象的属性值。你甚至可以通过向内置语言特性的`prototype`添加函数来扩展语言。C、C++和Rust更加严格，如果你不熟悉这些语言，要充分利用WebAssembly可能会很困难。
- en: Calling imported functions in C/C++
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C/C++中调用导入的函数
- en: 'You need to define the JavaScript function you passed into `importObj.env`
    within the C/C++ code that utilizes it. The function signature must match what
    you passed in. The following example demonstrates this in greater detail. Here''s
    the JavaScript code that interacts with the compiled C file (`index.html`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在使用`importObj.env`的C/C++代码中定义你传递的JavaScript函数。函数签名必须与你传递的相匹配。以下示例更详细地演示了这一点。以下是与编译的C文件(`index.html`)交互的JavaScript代码：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is the contents of `main.c`, which is compiled to `main.wasm` and used
    within `index.html`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`main.c`的内容，它被编译为`main.wasm`并在`index.html`中使用：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You call the JavaScript function in your C/C++ the same way you'd call a normal
    C/C++ function. Although you prefix your function with a `_` when you pass it
    into the `importObj.env`, you don't need to include the prefix when defining it
    in the C/C++ file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用C/C++中的JavaScript函数的方式与调用普通的C/C++函数相同。虽然当你将它传递到`importObj.env`时，你需要在你的函数前加上`_`，但在C/C++文件中定义时，你不需要包括前缀。
- en: An example without glue code
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个没有胶水代码的例子
- en: The example code from the *Compiling C without the glue code* and *Fetching
    and instantiating a Wasm file* sections of [Chapter 5](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml),
    *Creating and Loading a WebAssembly Module*, demonstrated how to integrate JavaScript
    in our C file without using Emscripten's glue code. In this section, we will modify
    the example code slightly and change the file type to C++.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[第5章](51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml)的*编译不使用胶水代码的C*和*获取和实例化Wasm文件*部分的示例代码演示了如何在我们的C文件中集成JavaScript而不使用Emscripten的胶水代码。在本节中，我们将稍微修改示例代码，并将文件类型更改为C++。
- en: The C++ code
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++代码
- en: 'Create a file named `js-without-glue.cpp` in your `/chapter-06-interact-with-js`
    folder and populate it with the following contents:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`/chapter-06-interact-with-js`文件夹中创建一个名为`js-without-glue.cpp`的文件，并填充以下内容：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code is similar to the previous example, but the shape and direction of
    the element on the canvas has changed. Now, the element is a circle that starts
    in the lower-left corner of the canvas and moves diagonally toward the upper-right.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的例子类似，但画布上元素的形状和方向已经改变。现在，元素是一个圆，从画布的左下角开始，沿对角线向右上移动。
- en: The HTML code
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML代码
- en: 'Next, create a file named `js-without-glue.html` in your `/chapter-06-interact-with-js`
    folder and populate it with the following contents:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在你的`/chapter-06-interact-with-js`文件夹中创建一个名为`js-without-glue.html`的文件，并填充以下内容：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Instead of using the `rect()` element, we can manually draw paths using the
    functions available on the canvas element's 2D context.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用canvas元素的2D上下文上可用的函数手动绘制路径，而不是使用`rect()`元素。
- en: Compiling and serving the result
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和提供结果
- en: 'We''re only generating a Wasm module, so we can use the build task we set up
    in the previous chapter to compile our code. Select Tasks | Run Build Task… or
    use the keyboard shortcut *Ctrl*/*Cmd* + *Shift* + *B* to compile the code. If
    you''re not using VS Code, open a CLI instance in the `/chapter-06-interact-with-js`
    folder and run the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只生成了一个Wasm模块，因此可以使用我们在上一章中设置的构建任务来编译我们的代码。选择任务 | 运行构建任务...或使用键盘快捷键*Ctrl*/*Cmd*
    + *Shift* + *B*来编译代码。如果您不使用VS Code，请在`/chapter-06-interact-with-js`文件夹中打开CLI实例并运行以下命令：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once complete, open a terminal in the `/book-examples` folder, and run the
    following command to start your local server:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，在`/book-examples`文件夹中打开终端，并运行以下命令启动本地服务器：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Open up a browser and navigate to `http://127.0.0.1:8080/chapter-06-interact-with-js/js-without-glue.html`.
    You should see something like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并导航到`http://127.0.0.1:8080/chapter-06-interact-with-js/js-without-glue.html`。您应该会看到类似以下的内容：
- en: '![](img/c981ffdb-10a6-4d61-b87c-fdfa19ce9d83.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c981ffdb-10a6-4d61-b87c-fdfa19ce9d83.png)'
- en: The Wasm module running in the browser without glue code
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行的Wasm模块，无需粘合代码
- en: Just as with the previous examples, if you press the Pause button, the caption
    on the button should change to Start and the circle should stop moving.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，如果按下暂停按钮，则按钮上的标题应更改为开始，并且圆圈应停止移动。
- en: Advanced Emscripten features
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级Emscripten功能
- en: We covered the Emscripten features we'll be using most frequently for communicating
    between JavaScript and C/C++ in the previous sections, but those aren't the only
    capabilities Emscripten provides. There are advanced features and additional APIs
    that you need to be aware of, especially if you plan on adding more complex functionality
    to your application. In this section, we'll briefly review some of these advanced
    features and provide details about where you can learn more.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的部分中介绍了我们将在JavaScript和C/C++之间频繁使用的Emscripten功能，但这并不是Emscripten提供的唯一功能。还有一些高级功能和额外的API，您需要了解，特别是如果您计划向应用程序添加更复杂的功能。在本节中，我们将简要介绍一些这些高级功能，并提供有关您可以了解更多信息的详细信息。
- en: Embind
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Embind
- en: 'Embind is an additional feature that Emscripten offers for connecting JavaScript
    and C++. Emscripten''s site provides the following description:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Embind是Emscripten提供的用于连接JavaScript和C++的附加功能。Emscripten的网站提供了以下描述：
- en: '"Embind is used to bind C++ functions and classes to JavaScript, so that the
    compiled code can be used in a natural way by ''normal'' JavaScript. Embind also
    supports calling JavaScript classes from C++."'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '"Embind用于将C++函数和类绑定到JavaScript，以便编译后的代码可以被''普通''JavaScript以自然的方式使用。Embind还支持从C++调用JavaScript类。"'
- en: 'Embind is a powerful feature that allows for tight integration between JavaScript
    and C++. You can wrap some C++ code in an `EMSCRIPTEN_BINDINGS()` block and reference
    it through the `Module` object in your browser. Let''s look at an example from
    Emscripten''s site. The following file, `example.cpp`, is compiled with the `--bind`
    flag of `emcc`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Embind是一个强大的功能，允许JavaScript和C++之间进行紧密集成。您可以将一些C++代码包装在`EMSCRIPTEN_BINDINGS()`块中，并通过浏览器中的`Module`对象引用它。让我们看一个来自Emscripten网站的例子。以下文件`example.cpp`使用`emcc`的`--bind`标志编译：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The resultant module is loaded in `example.html` and the `lerp()` function
    is called:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的模块在`example.html`中加载，并调用`lerp()`函数：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding example represents a small portion of Embind's capabilities. You
    can learn more about Embind at [https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例仅代表Embind功能的一小部分。您可以在[https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html](https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html)了解更多关于Embind的信息。
- en: File System API
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统API
- en: Emscripten provides support for file operations by using the FS library and
    exposes an API for working with the filesystem. However, it's not included by
    default when you compile your project because it could increase the file's size
    significantly. If your C/C++ code uses files, the library will be added automatically.
    The filesystem types vary based on the execution environment. For example, if
    you're running code inside a worker, the `WORKERFS` filesystem can be used. By
    default, `MEMFS` is used, which stores the data in memory, and any data written
    to memory is lost when the page is reloaded. You can read more about the File
    System API at [https://kripken.github.io/emscripten-site/docs/api_reference/Filesystem-API.html#filesystem-api](https://kripken.github.io/emscripten-site/docs/api_reference/Filesystem-API.html#filesystem-api).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten通过使用FS库提供对文件操作的支持，并公开了一个用于处理文件系统的API。但是，默认情况下在编译项目时不会包含它，因为它可能会显著增加文件的大小。如果您的C/C++代码使用文件，该库将自动添加。文件系统类型根据执行环境而异。例如，如果在worker内运行代码，则可以使用`WORKERFS`文件系统。默认情况下使用`MEMFS`，它将数据存储在内存中，当页面重新加载时，内存中的任何数据都将丢失。您可以在[https://kripken.github.io/emscripten-site/docs/api_reference/Filesystem-API.html#filesystem-api](https://kripken.github.io/emscripten-site/docs/api_reference/Filesystem-API.html#filesystem-api)阅读有关文件系统API的更多信息。
- en: Fetch API
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fetch API
- en: 'Emscripten provides a Fetch API as well. The following is taken from the documentation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten还提供了Fetch API。以下内容摘自文档：
- en: '"The Emscripten Fetch API allows native code to transfer files via XHR (HTTP
    GET, PUT, POST) from remote servers, and to persist the downloaded files locally
    in browser''s IndexedDB storage, so that they can be re-accessed locally on subsequent
    page visits. The Fetch API is callable from multiple threads, and the network
    requests can be run either synchronously or asynchronously as desired."'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '"Emscripten Fetch API允许本机代码通过XHR（HTTP GET、PUT、POST）从远程服务器传输文件，并将下载的文件持久存储在浏览器的IndexedDB存储中，以便可以在随后的页面访问中本地重新访问。Fetch
    API可以从多个线程调用，并且可以根据需要同步或异步运行网络请求。"'
- en: The Fetch API can be used to integrate with Emscripten's other features. If
    you need to fetch data that isn't utilized by Emscripten, you should use the browser's
    Fetch API ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)).
    You can read more about the Fetch API at [https://kripken.github.io/emscripten-site/docs/api_reference/fetch.html](https://kripken.github.io/emscripten-site/docs/api_reference/fetch.html).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Fetch API可用于与Emscripten的其他功能集成。如果您需要获取Emscripten未使用的数据，应使用浏览器的Fetch API ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API))。您可以在[https://kripken.github.io/emscripten-site/docs/api_reference/fetch.html](https://kripken.github.io/emscripten-site/docs/api_reference/fetch.html)上了解有关Fetch
    API的更多信息。
- en: Debugging in the browser
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中调试
- en: Effectively debugging JavaScript code in the browser has not always been easy.
    However, development tooling has markedly improved in the browser and in editors/IDEs
    with built-in debugging capabilities. Unfortunately, adding WebAssembly to a web
    application adds an additional level of complexity to the debugging process. In
    this section, we will review some techniques for debugging JavaScript that utilizes
    Wasm as well as some of the additional capabilities Emscripten offers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中有效地调试JavaScript代码并不总是容易的。然而，浏览器和具有内置调试功能的编辑器/IDE的开发工具已经显著改进。不幸的是，将WebAssembly添加到Web应用程序会给调试过程增加额外的复杂性。在本节中，我们将回顾一些调试JavaScript并利用Wasm的技术，以及Emscripten提供的一些额外功能。
- en: High-level overview
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级概述
- en: Debugging Emscripten's `Module` is relatively straightforward. Emscripten's
    error messages are well formed and descriptive, so you'll usually discover what's
    causing the issue right away. You can view these messages in your browser's development
    tools console.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 调试Emscripten的`Module`相对比较简单。Emscripten的错误消息形式良好且描述清晰，因此通常您会立即发现问题的原因。您可以在浏览器的开发工具控制台中查看这些消息。
- en: If you specified a `.html` output when running the `emcc` command, some debugging
    code will already be built in (`Module.print` and `Module.printErr`). Within the
    HTML file, the loading code sets the `window.onerror` event to call the `Module.printErr`
    event, so you can see details about the error that occurred when loading.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行`emcc`命令时指定了`.html`输出，一些调试代码将已经内置（`Module.print`和`Module.printErr`）。在HTML文件中，加载代码设置了`window.onerror`事件来调用`Module.printErr`事件，因此您可以查看加载时发生的错误的详细信息。
- en: 'One common error you may encounter is calling the wrong function name. If you''re
    using Emscripten''s Promise-like API, you can print out the available functions
    by running the following code in your browser''s console:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到的一个常见错误是调用错误的函数名称。如果您正在使用Emscripten的类似Promise的API，可以通过在浏览器控制台中运行以下代码来打印出可用的函数：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following screenshot shows the output for the `js-with-glue.js` example
    we used in the *Calling JavaScript functions from C/C++* section of this chapter:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了我们在本章的*从C/C++调用JavaScript函数*部分中使用的`js-with-glue.js`示例的输出：
- en: '![](img/7a85c9a2-9f60-48eb-b1d1-196d77f5e9f8.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a85c9a2-9f60-48eb-b1d1-196d77f5e9f8.png)'
- en: Logging the contents of `Module().asm` in the browser console
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器控制台中记录`Module().asm`的内容
- en: Your functions, as well as some functions that Emscripten generates, will be
    prefixed with a `_`. The advantage of writing code that gets compiled is that
    the compiler will catch most errors up front. Given the extensive tooling available
    for languages such as C and C++, you should be able to understand and address
    these errors quickly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您的函数以及Emscripten生成的一些函数将以`_`为前缀。编写可编译的代码的优势在于编译器将在前期捕获大多数错误。鉴于C和C++等语言可用的广泛工具，您应该能够快速理解和解决这些错误。
- en: If you're not using any glue code and instantiating a Wasm file using WebAssembly's
    JavaScript and Web APIs, debugging can get a little more complex. As previously
    stated, you have the advantage of catching most errors at compile time in your
    C or C++ code. Just as with Emscripten, the error messages printed out in your
    browser's development tools console provide a stack trace and a relatively clear
    description of the issue. However, logging to the console may become cumbersome
    and difficult to manage if you're troubleshooting a particularly difficult bug.
    Fortunately, you can use source maps to improve your debugging capabilities.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有使用任何粘合代码，并且使用WebAssembly的JavaScript和Web API实例化Wasm文件，则调试可能会变得更加复杂。正如之前所述，您有优势可以在C或C++代码的编译时捕获大多数错误。与Emscripten一样，浏览器开发工具控制台中打印出的错误消息提供了堆栈跟踪和相对清晰的问题描述。然而，如果您正在解决一个特别棘手的错误，记录到控制台可能会变得繁琐和难以管理。幸运的是，您可以使用源映射来提高调试能力。
- en: Using source maps
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用源映射
- en: 'Emscripten has the ability to generate source maps by passing some additional
    flags to the compiler. Source maps allow your browser to map the source of a file
    to the file being utilized in an application. For example, you can use a JavaScript
    build tool such Webpack to minify the code as part of your build process. However,
    it''s incredibly difficult to navigate and troubleshoot the minified code if you''re
    trying to find a bug. By generating a source map, you can view the code in its
    original form within the browser''s development tools and set breakpoints for
    debugging. Let''s generate a source map for our `/chapter-06-interact-with-js/js-without-glue.cpp`
    file. Within the `/book-examples` folder, run the following command in a terminal:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten有能力通过向编译器传递一些额外的标志来生成源映射。源映射允许浏览器将文件的源映射到应用程序中使用的文件。例如，您可以使用JavaScript构建工具（如Webpack）在构建过程中对代码进行缩小。但是，如果您试图查找错误，导航和调试缩小的代码将变得非常困难。通过生成源映射，您可以在浏览器的开发工具中查看原始形式的代码，并设置断点进行调试。让我们为我们的`/chapter-06-interact-with-js/js-without-glue.cpp`文件生成一个源映射。在`/book-examples`文件夹中，在终端中运行以下命令：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `-g4` argument enables source maps, while the `--source-map-base` argument
    tells the browser where to find the source map file. Once compiled, start your
    local server up from the `/book-examples` folder by running the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g4`参数启用源映射，而`--source-map-base`参数告诉浏览器在哪里找到源映射文件。编译后，通过运行以下命令从`/book-examples`文件夹启动本地服务器：'
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Navigate to `http://127.0.0.1:8080/chapter-06-interact-with-js/js-without-glue.html`,
    open the Developer Tools, and select the Sources tab (in Chrome) or Debugger tab
    (in Firefox). If you''re using Chrome, you should see the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`http://127.0.0.1:8080/chapter-06-interact-with-js/js-without-glue.html`，打开开发者工具，并选择源标签（在Chrome中）或调试器标签（在Firefox中）。如果您使用Chrome，您应该会看到以下内容：
- en: '![](img/ccc8b38d-f748-40fb-8d25-667dc176c0ff.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccc8b38d-f748-40fb-8d25-667dc176c0ff.png)'
- en: Wasm source maps in Chrome Developer Tools
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome开发者工具中的Wasm源映射
- en: 'As you can see, the filenames aren''t very helpful. Each file should include
    the function name at the top, although some of the names may have been mangled.
    You can set breakpoints if you encounter errors, and Chrome''s debugging functionality
    allows you to navigate the call stack. Firefox handles their source maps differently.
    The following screenshot shows the Debugger view in Firefox''s Developer Tools:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，文件名并不是很有帮助。每个文件应该在顶部包含函数名称，尽管其中一些名称可能已经被搅乱。如果遇到错误，您可以设置断点，Chrome的调试功能允许您导航调用堆栈。Firefox以不同的方式处理它们的源映射。以下截图显示了Firefox的开发者工具中的调试器视图：
- en: '![](img/d40de2b0-f550-4e74-bbac-4249f1693ec4.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d40de2b0-f550-4e74-bbac-4249f1693ec4.png)'
- en: Wasm source map in Firefox Developer Tools
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox开发者工具中的Wasm源映射
- en: The source map is a single file that contains the Wat representation of the
    Wasm file. You can set breakpoints and debug code here as well. As WebAssembly
    evolves, more (and better) tooling will become available. In the meantime, logging
    to the console and utilizing source maps are the current debugging methods you
    can use.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 源映射是一个包含Wasm文件的Wat表示的单个文件。您也可以在这里设置断点和调试代码。随着WebAssembly的发展，将会有更多（和更好）的工具可用。与此同时，记录到控制台和利用源映射是您可以使用的当前调试方法。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we focused on the intercommunication of JavaScript and C/C++,
    some of the features Emscripten offers, and how to effectively debug web applications
    that utilize Wasm in the browser. We reviewed the various means of calling compiled
    C/C++ functions from JavaScript, and how to integrate JavaScript with your C/C++
    code. Emscripten's APIs were presented as a way to understand how you can overcome
    some of WebAssembly's current limitations by including glue code with your compiled
    Wasm files. Even though the capabilities Emscripten provides are not present in
    the official WebAssembly *Core Specification* (and may never be), that shouldn't
    deter you from taking advantage of them. Finally, we briefly covered how to debug
    Wasm files in the browser in the context of an Emscripten module or a WebAssembly
    instance.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于JavaScript和C/C++之间的互联，Emscripten提供的一些功能，以及如何有效地调试在浏览器中使用Wasm的Web应用程序。我们回顾了从JavaScript调用编译后的C/C++函数的各种方法，以及如何将JavaScript与您的C/C++代码集成。Emscripten的API被提出作为一种理解如何通过在编译后的Wasm文件中包含粘合代码来克服WebAssembly当前限制的方法。即使Emscripten提供的功能不在官方的WebAssembly
    *Core Specification*中（也许永远不会），这也不应该阻止您利用它们。最后，我们简要介绍了如何在浏览器中调试Wasm文件，以及Emscripten模块或WebAssembly实例的上下文。
- en: In the next chapter, we'll build a real-world WebAssembly application from scratch.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从头开始构建一个真实的WebAssembly应用程序。
- en: Questions
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the names of the two functions available on the `Module` object that
    you use to interact with the compiled code from the browser?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您用于与浏览器中的编译代码交互的`Module`对象上的两个函数的名称是什么？
- en: What do you need to wrap your C++ code in to ensure the function names don't
    get mangled?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要用什么来包装您的C++代码，以确保函数名称不会被搅乱？
- en: What's the difference between `EM_ASM()` and `EM_JS()`?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EM_ASM()`和`EM_JS()`之间有什么区别？'
- en: Which is more performant, `emscripten_run_script()` or `EM_ASM()`/`EM_JS()`?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`emscripten_run_script()`和`EM_ASM()`/`EM_JS()`中哪个更有效？'
- en: 'What do you need to include in the line above your function if you want to
    use it outside of your C/C++ code (hint: it starts with `EMSCRIPTEN`)?'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想在C/C++代码之外使用它，您需要在函数上面的行中包含什么（提示：它以`EMSCRIPTEN`开头）？
- en: Where can you define a function that needs to be passed into the `importObj.env`
    object when instantiating a module?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在哪里可以定义需要传递到`importObj.env`对象中的函数，当实例化模块时？
- en: What additional APIs does Emscripten provide?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Emscripten提供了哪些额外的API？
- en: What is the purpose of source maps?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源映射的目的是什么？
- en: Further reading
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Emscripten API Reference: [http://kripken.github.io/emscripten-site/docs/api_reference/index.html](http://kripken.github.io/emscripten-site/docs/api_reference/index.html)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Emscripten API参考：[http://kripken.github.io/emscripten-site/docs/api_reference/index.html](http://kripken.github.io/emscripten-site/docs/api_reference/index.html)
- en: An Introduction to Source Maps: [http://blog.teamtreehouse.com/introduction-source-maps](http://blog.teamtreehouse.com/introduction-source-maps)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源映射简介：[http://blog.teamtreehouse.com/introduction-source-maps](http://blog.teamtreehouse.com/introduction-source-maps)
- en: Using Browsers to Debug WebAssembly: [http://webassemblycode.com/using-browsers-debug-webassembly](http://webassemblycode.com/using-browsers-debug-webassembly)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浏览器调试WebAssembly：[http://webassemblycode.com/using-browsers-debug-webassembly](http://webassemblycode.com/using-browsers-debug-webassembly)
