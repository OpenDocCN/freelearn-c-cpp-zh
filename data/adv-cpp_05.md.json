["```cpp\n#if !defined(MY_HEADER_INCLUDED)\n#define\u00a0\u00a0\u00a0MY_HEADER_INCLUDED\n// definitions \n#endif // !defined(MY_HEADER_INCLUDED)\n```", "```cpp\n#pragma once\nclass Dialog\n{\npublic:\n\u00a0\u00a0\u00a0\u00a0Dialog();\n\u00a0\u00a0\u00a0\u00a0~Dialog();\n\u00a0\u00a0\u00a0\u00a0void create(const char* message);\n\u00a0\u00a0\u00a0\u00a0bool show();\nprivate:\n\u00a0\u00a0\u00a0\u00a0struct DialogImpl;\n\u00a0\u00a0\u00a0\u00a0DialogImpl* m_pImpl;\n};\n```", "```cpp\n#include \"dialog.hpp\"\n#include <iostream>\n#include <string>\nstruct Dialog::DialogImpl\n{\n\u00a0\u00a0\u00a0\u00a0void create(const char* message)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_message = message;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Creating the Dialog\\n\";\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0bool show()\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Showing the message: '\" << m_message << \"'\\n\";\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0std::string m_message;\n};\nDialog::Dialog() : m_pImpl(new DialogImpl)\n{\n}\nDialog::~Dialog()\n{\n\u00a0\u00a0\u00a0\u00a0delete m_pImpl;\n}\nvoid Dialog::create(const char* message)\n{\n\u00a0\u00a0\u00a0\u00a0m_pImpl->create(message);\n}\nbool Dialog::show()\n{\n\u00a0\u00a0\u00a0\u00a0return m_pImpl->show();\n}\n```", "```cpp\n#include <iostream>\n#include \"dialog.hpp\"\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"\\n\\n------ Pimpl ------\\n\";\n\u00a0\u00a0\u00a0\u00a0Dialog dialog;\n\u00a0\u00a0\u00a0\u00a0dialog.create(\"Hello World\");\n\u00a0\u00a0\u00a0\u00a0if (dialog.show())\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Dialog displayed\\n\";\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Dialog not displayed\\n\";\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Complete.\\n\";\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n#pragma once\n#include <memory>\nclass Dialog\n{\npublic:\n\u00a0\u00a0\u00a0\u00a0Dialog();\n\u00a0\u00a0\u00a0\u00a0void create(const char* message);\n\u00a0\u00a0\u00a0\u00a0bool show();\nprivate:\n\u00a0\u00a0\u00a0\u00a0struct DialogImpl;\n\u00a0\u00a0\u00a0\u00a0std::unique_ptr<DialogImpl> m_pImpl;\n};\n```", "```cpp\nDialog::Dialog() : m_pImpl(std::make_unique<DialogImpl>())\n{\n}\n```", "```cpp\nvoid\noperator()(_Tp* __ptr) const\n{\n\u00a0\u00a0\u00a0\u00a0static_assert(!is_void<_Tp>::value, \"can't delete pointer to incomplete type\");\n\u00a0\u00a0\u00a0\u00a0static_assert(sizeof(_Tp)>0, \"can't delete pointer to incomplete type\");\n\u00a0\u00a0\u00a0\u00a0delete __ptr;\n}\n```", "```cpp\nDialog::~Dialog()\n{\n}\n```", "```cpp\nDialog::~Dialog() = default;\n```", "```cpp\nclass Dialog\n{\npublic:\n\u00a0\u00a0\u00a0\u00a0Dialog();\n\u00a0\u00a0\u00a0\u00a0~Dialog();\n\u00a0\u00a0\u00a0\u00a0Dialog(Dialog&& rhs);\n\u00a0\u00a0\u00a0\u00a0Dialog& operator=(Dialog&& rhs);\n\u00a0\u00a0\u00a0\u00a0void create(const char* message);\n\u00a0\u00a0\u00a0\u00a0bool show();\nprivate:\n\u00a0\u00a0\u00a0\u00a0struct DialogImpl;\n\u00a0\u00a0\u00a0\u00a0std::unique_ptr<DialogImpl> m_pImpl;\n};\n```", "```cpp\nDialog::Dialog() : m_pImpl(std::make_unique<DialogImpl>())\n{\n}\nDialog::~Dialog() = default;\nDialog::Dialog(Dialog&& rhs) = default;\nDialog& Dialog::operator=(Dialog&& rhs) = default;\n```", "```cpp\nDialog(const Dialog& rhs);\nDialog& operator=(const Dialog& rhs);\n```", "```cpp\nDialog::Dialog(const Dialog& rhs) : m_pImpl(nullptr)\n{\n\u00a0\u00a0\u00a0\u00a0if (this == &rhs)\u00a0\u00a0\u00a0// do nothing on copying self\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0\u00a0\u00a0if (rhs.m_pImpl)\u00a0\u00a0\u00a0\u00a0// rhs has something -> clone it\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_pImpl = std::make_unique<DialogImpl>(*rhs.m_pImpl);\n}\nDialog& Dialog::operator=(const Dialog& rhs)\n{\n\u00a0\u00a0\u00a0\u00a0if (this == &rhs)\u00a0\u00a0\u00a0// do nothing on assigning to self\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return *this;\n\u00a0\u00a0\u00a0\u00a0if (!rhs.m_pImpl)\u00a0\u00a0\u00a0// rhs is empty -> delete ours\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_pImpl.reset();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0else if (!m_pImpl)\u00a0\u00a0// ours is empty -> clone rhs\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_pImpl = std::make_unique<DialogImpl>(*rhs.m_pImpl);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0else // use copy of DialogImpl\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*m_pImpl = *rhs.m_pImpl;\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```cpp\n    struct Impl;\n    std::unique_ptr<Impl> m_impl;\n    ```", "```cpp\n    struct Kitchen::Impl\n    {\n    };\n    Kitchen::~Kitchen() = default;\n    ```", "```cpp\n    #pragma once\n    #include <string>\n    #include <memory>\n    class Kitchen\n    {\n    public:\n    \u00a0\u00a0\u00a0\u00a0Kitchen(std::string chef);\n    \u00a0\u00a0\u00a0\u00a0~Kitchen();\n    \u00a0\u00a0\u00a0\u00a0std::string processOrder(std::string order);\n    private:\n    \u00a0\u00a0\u00a0\u00a0struct Impl;\n    \u00a0\u00a0\u00a0\u00a0std::unique_ptr<Impl> m_impl;\n    };\n    ```", "```cpp\n    Kitchen::Impl::Impl(std::string chef) : m_chef{chef}\n    ```", "```cpp\n    struct Kitchen::Impl\n    {\n    \u00a0\u00a0\u00a0\u00a0Impl(std::string chef);\n    \u00a0\u00a0\u00a0\u00a0std::string processOrder(std::string order);\n    \u00a0\u00a0\u00a0\u00a0std::string searchForRecipe(std::string order);\n    \u00a0\u00a0\u00a0\u00a0std::string searchForDessert(std::string order);\n    \u00a0\u00a0\u00a0\u00a0std::string cookRecipe(std::string recipe);\n    \u00a0\u00a0\u00a0\u00a0std::string serveDessert(std::string dessert);\n    \u00a0\u00a0\u00a0\u00a0std::vector<Recipe>::iterator getRecipe(std::string recipe);\n    \u00a0\u00a0\u00a0\u00a0std::vector<Dessert>::iterator getDessert(std::string recipe);\n    \u00a0\u00a0\u00a0\u00a0std::string m_chef;\n    \u00a0\u00a0\u00a0\u00a0std::vector<Recipe> m_recipes;\n    \u00a0\u00a0\u00a0\u00a0std::vector<Dessert> m_desserts;\n    };\n    ```", "```cpp\n    Kitchen::Kitchen(std::string chef) : m_impl(std::make_unique<Kitchen::Impl>(chef))\n    {\n    }\n    std::string Kitchen::processOrder(std::string order)\n    {\n    \u00a0\u00a0\u00a0\u00a0return m_impl->processOrder(order);\n    }\n    ```", "```cpp\n#include <iostream>\nusing FnPtr = void (*)(void);\nvoid function1()\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"function1 called\\n\";\n}\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"\\n\\n------ Function Pointers ------\\n\";\n\u00a0\u00a0\u00a0\u00a0FnPtr fn{function1};\n\u00a0\u00a0\u00a0\u00a0fn();\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Complete.\\n\";\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nFnPtr fn{&function1};\nif(fn != nullptr)\n\u00a0\u00a0\u00a0\u00a0fn();\n```", "```cpp\n#include <iostream>\nusing FnPtr = void (*)(void);\nstruct foo\n{\n\u00a0\u00a0\u00a0\u00a0void bar() { std::cout << \"foo:bar called\\n\"; }\n};\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"\\n\\n------ Function Pointers ------\\n\";\n\u00a0\u00a0\u00a0\u00a0foo object;\n\u00a0\u00a0\u00a0\u00a0FnPtr fn{&object.bar};\n\u00a0\u00a0\u00a0\u00a0fn();\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Complete.\\n\";\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n#include <iostream>\nusing FnPtr = void (*)(void);\nstruct foo\n{\n\u00a0\u00a0\u00a0\u00a0static void bar() { std::cout << \"foo:bar called\\n\"; }\n};\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"\\n\\n------ Function Pointers ------\\n\";\n\u00a0\u00a0\u00a0\u00a0FnPtr fn{&foo::bar};\n\u00a0\u00a0\u00a0\u00a0fn();\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Complete.\\n\";\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nstruct Scaler\n{\n\u00a0\u00a0\u00a0\u00a0Scaler(int scale) : m_scale{scale} {};\n\u00a0\u00a0\u00a0\u00a0int operator()(int value)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return m_scale * value;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0int m_scale{1};\n};\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"\\n\\n------ Functors ------\\n\";\n\u00a0\u00a0\u00a0\u00a0Scaler timesTwo{2};\n\u00a0\u00a0\u00a0\u00a0Scaler timesFour{4};\n\u00a0\u00a0\u00a0\u00a0std::cout << \"3 scaled by 2 = \" << timesTwo(3) << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0std::cout << \"3 scaled by 4 = \" << timesFour(3) << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Complete.\\n\";\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\nstruct Scaler\n{\n\u00a0\u00a0\u00a0\u00a0Scaler(int scale) : m_scale{scale} {};\n\u00a0\u00a0\u00a0\u00a0int operator()(int value)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return m_scale * value;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0int m_scale{1};\n};\nvoid PrintVector(const char* prefix, std::vector<int>& values)\n{\n\u00a0\u00a0\u00a0\u00a0const char* sep = \"\";\n\u00a0\u00a0\u00a0\u00a0std::cout << prefix << \" = [\";\n\u00a0\u00a0\u00a0\u00a0for(auto n : values)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << sep << n;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sep = \", \";\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0std::cout << \"]\\n\";\n}\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"\\n\\n------ Functors with STL ------\\n\";\n\u00a0\u00a0\u00a0\u00a0std::vector<int> values{1,2,3,4,5};\n\u00a0\u00a0\u00a0\u00a0PrintVector(\"Before transform\", values);\n\u00a0\u00a0\u00a0\u00a0std::transform(values.begin(), values.end(), values.begin(), Scaler(3));\n\u00a0\u00a0\u00a0\u00a0PrintVector(\"After transform\", values);\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Complete.\\n\";\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n    struct Printer\n    {\n    \u00a0\u00a0\u00a0\u00a0void operator()(int n)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << m_sep << n;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_sep = \", \";\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0const char* m_sep = \"\";\n    };\n    ```", "```cpp\n    std::cout << \"Average of [\";\n    for( auto n : values )\n    \u00a0\u00a0\u00a0\u00a0std::cout << n << \", \";\n    std::cout << \"] = \";\n    ```", "```cpp\n    std::cout << \"Average of [\";\n    std::for_each(values.begin(), values.end(), Printer());\n    std::cout << \"] = \";\n    ```", "```cpp\n    struct Averager\n    {\n    \u00a0\u00a0\u00a0\u00a0void operator()(int n)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_sum += n;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m_count++;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0float operator()() const\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return static_cast<float>(m_sum)/(m_count==0?1:m_count);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0int m_count{0};\n    \u00a0\u00a0\u00a0\u00a0int m_sum{0};\n    };\n    ```", "```cpp\n    int main(int argc, char**argv)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"\\n------ Exercise 2 ------\\n\";\n    \u00a0\u00a0\u00a0\u00a0std::vector<int> values {1,2,3,4,5,6,7,8,9,10};\n    \u00a0\u00a0\u00a0\u00a0Averager averager = std::for_each(values.begin(), values.end(), \n    \u00a0\u00a0\u00a0\u00a0Averager());\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Average of [\";\n    \u00a0\u00a0\u00a0\u00a0std::for_each(values.begin(), values.end(), Printer());\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"] = \";\n    \u00a0\u00a0\u00a0\u00a0std::cout << averager() << \"\\n\";\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Complete.\\n\";\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```cpp\nvoid FreeFunc(int value);\nstruct Functor \n{\n\u00a0\u00a0\u00a0\u00a0void operator()(int value);\n};\nstd::function<void(int)> func;\nFunctor functor;\nfunc = FreeFunc;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Set target as FreeFunc\nfunc(32);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Call FreeFunc with argument 32\nfunc = functor;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// set target as functor\nfunc(42);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Call Functor::operator() with argument 42\n```", "```cpp\n#include <iostream>\n#include <functional>\nstruct Binder\n{\n\u00a0\u00a0\u00a0\u00a0void method(int a, int b)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"Binder::method(\" << a << \", \" << b << \")\\n\";\n\u00a0\u00a0\u00a0\u00a0}\n};\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"\\n\\n------ Member Functions using bind ------\\n\";\n\u00a0\u00a0\u00a0\u00a0Binder binder;\n\u00a0\u00a0\u00a0\u00a0std::function<void(int,int)> func;\n\u00a0\u00a0\u00a0\u00a0auto func1 = std::bind(&Binder::method, &binder, 1, 2);\n\u00a0\u00a0\u00a0\u00a0auto func2 = std::bind(&Binder::method, &binder, std::placeholders::_1, std::placeholders::_2);\n\u00a0\u00a0\u00a0\u00a0auto func3 = std::bind(&Binder::method, &binder, std::placeholders::_2, std::placeholders::_1);\n\u00a0\u00a0\u00a0\u00a0func = func1;\n\u00a0\u00a0\u00a0\u00a0func(34,56);\n\u00a0\u00a0\u00a0\u00a0func = func2;\n\u00a0\u00a0\u00a0\u00a0func(34,56);\n\u00a0\u00a0\u00a0\u00a0func = func3;\n\u00a0\u00a0\u00a0\u00a0func(34,56);\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Complete.\\n\";\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\n    if (func)\n    {\n    \u00a0\u00a0\u00a0\u00a0func(42);\n    }\n    else\n    {\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"Not calling an empty func()\\n\";\n    }\n    ```", "```cpp\n    void FreeFunction(int n)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"FreeFunction(\" << n << \")\\n\";\n    }\n    ```", "```cpp\n    func = FreeFunction;\n    ```", "```cpp\n    struct FuncClass\n    {\n    \u00a0\u00a0\u00a0\u00a0void member(int n)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << \"FuncClass::member(\" << n << \")\\n\";\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0void operator()(int n)\n    \u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"FuncClass object(\" << n << \")\\n\";\n    \u00a0\u00a0\u00a0\u00a0}\n    };\n    ```", "```cpp\n    FuncClass funcClass;\n    func = funcClass;\n    ```", "```cpp\n    func = std::bind(&FuncClass::member, &funcClass, std::placeholders::_1);\n    ```", "```cpp\n    func = [](int n) {std::cout << \"lambda function(\" << n << \")\\n\";};\n    ```", "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\nvoid PrintVector(const char* prefix, std::vector<int>& values)\n{\n\u00a0\u00a0\u00a0\u00a0const char* sep = \"\";\n\u00a0\u00a0\u00a0\u00a0std::cout << prefix << \" = [\";\n\u00a0\u00a0\u00a0\u00a0for(auto n : values)\n\u00a0\u00a0\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << sep << n;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sep = \", \";\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0std::cout << \"]\\n\";\n}\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"\\n\\n------ Lambdas with STL ------\\n\";\n\u00a0\u00a0\u00a0\u00a0std::vector<int> values{1,2,3,4,5};\n\u00a0\u00a0\u00a0\u00a0PrintVector(\"Before transform\", values);\n\u00a0\u00a0\u00a0\u00a0std::transform(values.begin(), values.end(), values.begin(),\n\u00a0\u00a0\u00a0\u00a0[] (int n) {return 5*n;}\n\u00a0\u00a0\u00a0\u00a0);\n\u00a0\u00a0\u00a0\u00a0PrintVector(\"After transform\", values);\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Complete.\\n\";\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\nint x = 5;\nint y = 6;\nauto fn = [z=x*x+y, x, y] ()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << x << \" * \" << x << \" + \" << y << \" = \" << z << \"\\n\"; \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0};\nfn();\n```", "```cpp\n5 * 5 + 6 = 31\n```", "```cpp\nstruct LambdaCapture\n{\n\u00a0\u00a0auto GetTheNameFunc ()\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0return [myName = myName] () { return myName.c_str(); };\u00a0\u00a0\n\u00a0\u00a0}\n\u00a0\u00a0std::string myName;\n};\n```", "```cpp\n    void PrintVector(const char* prefix, std::vector<int>& values)\n    {\n    \u00a0\u00a0\u00a0\u00a0const char* sep = \"\";\n    \u00a0\u00a0\u00a0\u00a0std::cout << prefix << \" = [\";\n    \u00a0\u00a0\u00a0\u00a0std::for_each(values.begin(), values.end(),\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[&sep] (int n)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0std::cout << sep << n;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sep = \", \";\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0);\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"]\\n\";\n    }\n    ```", "```cpp\n    [sep] (int n) mutable\n    {\n    \u00a0\u00a0\u00a0\u00a0std::cout << sep << n;\n    \u00a0\u00a0\u00a0\u00a0sep = \", \";\n    }\n    ```", "```cpp\n    [sep = \"\"] (int n) mutable\n    {\n    \u00a0\u00a0\u00a0\u00a0std::cout << sep << n;\n    \u00a0\u00a0\u00a0\u00a0sep = \", \";\n    }\n    ```", "```cpp\n    void PrintVector(const char* prefix, std::vector<int>& values)\n    {\n    \u00a0\u00a0\u00a0\u00a0std::cout << prefix << \" = [\";\n    \u00a0\u00a0\u00a0\u00a0std::for_each(values.begin(), values.end(), [sep = \"\"] (int n) mutable\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0{ std::cout << sep << n; sep = \", \";} );\n    \u00a0\u00a0\u00a0\u00a0std::cout << \"]\\n\";\n    }\n    ```", "```cpp\n    std::sort(values.begin(), values.end(), [](int a, int b) {return b<a;} );\n    PrintVector(\"After sort\", values);\n    ```", "```cpp\n    int threshold{25};\n    auto pred = [threshold] (int a) { return a > threshold; };\n    auto count = std::count_if(values.begin(), values.end(), pred);\n    std::cout << \"There are \" << count << \" values > \" << threshold << \"\\n\";\n    ```", "```cpp\n    threshold = 40;\n    count = std::count_if(values.begin(), values.end(), pred);\n    std::cout << \"There are \" << count << \" values > \" << threshold << \"\\n\";\n    ```", "```cpp\n    auto pred = [&threshold] (int a) { return a > threshold; };\n    ```", "```cpp\n#include <iostream>\n#include <string>\ntemplate<typename T, typename... Args>\nT summer(T first, Args... args) {\n\u00a0\u00a0\u00a0\u00a0if constexpr(sizeof...(args) > 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return first + summer(args...);\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return first;\n}\nint main()\n{\n\u00a0\u00a0\u00a0\u00a0std::cout << \"\\n\\n------ Variadic Templates ------\\n\";\n\u00a0\u00a0\u00a0\u00a0auto sum = summer(1, 3, 5, 7, 9, 11);\n\u00a0\u00a0\u00a0\u00a0std::cout << \"sum = \" << sum << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0std::string s1{\"ab\"};\n\u00a0\u00a0\u00a0\u00a0std::string s2{\"cd\"};\n\u00a0\u00a0\u00a0\u00a0std::string s3{\"ef\"};\n\u00a0\u00a0\u00a0\u00a0std::string strsum = summer(s1, s2, s3);\n\u00a0\u00a0\u00a0\u00a0std::cout << \"strsum = \" << strsum << \"\\n\";\n\u00a0\u00a0\u00a0\u00a0std::cout << \"Complete.\\n\";\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```cpp\ntemplate<typename T, typename... Args>\nT summer(T first, Args... args) {\n\u00a0\u00a0\u00a0\u00a0if constexpr(sizeof...(args) > 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return first + summer(args...);\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return first;\n}\n```", "```cpp\ntemplate<typename T, typename T1, typename T2, ..., typename Tn>\nT summer(T first, T1 t1, T2, ..., Tn tn) {\n\u00a0\u00a0\u00a0\u00a0if constexpr(sizeof...( t1, t2, ..., tn) > 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return first + summer(t1, t2, ..., tn);\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return first;\n}\n```", "```cpp\ntemplate<typename T, typename... Args>\nunique_ptr<T> make_unique(Args&&... args)\n{\n\u00a0\u00a0\u00a0\u00a0return unique_ptr<T>(new T(std::forward<Args>(args)...));\n}\n```", "```cpp\ndelegate int Handler(int parameter);\n```"]