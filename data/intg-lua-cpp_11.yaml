- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Multithreading with Lua
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Lua 进行多线程
- en: In the previous chapter, we learned some techniques to manage resources when
    integrating Lua into C++. In this chapter, we will learn how to work with multithreading
    with Lua. If you use Lua in a complex project, chances are that you need to create
    multiple Lua instances. First, we will learn how to contain the multithreading
    part in C++ and make Lua unaware of it. Then, we will see how Lua handles multithreading,
    in case you need to use it. Understanding multithreading will help with the technical
    planning for your projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了一些在将 Lua 集成到 C++ 时管理资源的技术。在本章中，我们将学习如何使用 Lua 进行多线程操作。如果你在一个复杂的项目中使用
    Lua，那么很可能你需要创建多个 Lua 实例。首先，我们将学习如何将多线程部分包含在 C++ 中，并使 Lua 对其无感知。然后，我们将看到 Lua 如何处理多线程，以防你需要使用它。理解多线程将有助于你项目的技术规划。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Multithreading in C++
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 中的多线程
- en: Multithreading in Lua
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lua 中的多线程
- en: Using `coroutine` with C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C++ 中的 `coroutine`
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will use the source code from *Chapter 10* as a base to develop the examples
    in this chapter. Make sure you can access the source code for this book: [https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter11](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter11).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 *第 10 章* 的源代码作为本章节示例的基础。确保你可以访问这本书的源代码：[https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter11](https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter11)。
- en: Multithreading in C++
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 中的多线程
- en: What is **multithreading**?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是**多线程**？
- en: There are a few definitions, depending on the point of view. From the CPU’s
    perspective, a multi-core processor that can execute multiple threads of instructions
    concurrently is real multithreading. From an application’s perspective, using
    multiple threads is multithreading. From a developer’s perspective, more focus
    might be on thread safety and various synchronization mechanisms, which are not
    multithreading itself, but its implications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据不同的视角，有几个定义。从 CPU 的角度来看，能够同时执行多个指令线程的多核处理器是真正的多线程。从应用程序的角度来看，使用多个线程就是多线程。从开发者的角度来看，可能更多地关注线程安全和各种同步机制，这些不是多线程本身，而是其影响。
- en: In this section, we will learn how to use Lua with C++’s native multithreading
    support. Each C++ thread will have its own Lua state. Because the Lua library
    does not keep any state and Lua states are not shared among different threads,
    this is thread-safe.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 Lua 与 C++ 的原生多线程支持。每个 C++ 线程都将有自己的 Lua 状态。因为 Lua 库不保留任何状态，Lua
    状态也不会在不同线程之间共享，所以这是线程安全的。
- en: How does C++ support multithreading?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 如何支持多线程？
- en: 'Since C++11, the standard library supports multithreading with `std::thread`.
    Each `std::thread` instance represents a thread of execution. The most important
    thing to provide to a thread is the thread function. This is what a thread executes.
    In its simplest form, we can create a thread as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 C++11 以来，标准库通过 `std::thread` 支持多线程。每个 `std::thread` 实例代表一个执行线程。提供给线程最重要的东西是线程函数。这就是线程执行的内容。在其最简单的形式中，我们可以创建线程如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we passed a C++ function as the thread function to create a thread. The
    function can optionally take arguments and the `std::thread` constructor will
    forward the arguments to the thread function. After the thread is created, the
    thread function starts to execute in its own thread. When the thread function
    finishes, the thread is ended.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将一个 C++ 函数作为线程函数传递以创建一个线程。该函数可以可选地接受参数，`std::thread` 构造函数将参数转发给线程函数。线程创建后，线程函数开始在它自己的线程中执行。当线程函数完成后，线程结束。
- en: We can also use a class member function or a class static member function as
    the thread function by invoking different constructors. You can refer to a C++
    reference manual to learn more about `std::thread`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过调用不同的构造函数，将类成员函数或类静态成员函数用作线程函数。你可以参考 C++ 参考手册来了解更多关于 `std::thread` 的信息。
- en: Before C++11
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 之前
- en: In the era before C++11, there was no standard multithreading support. People
    had to use third-party libraries or implement their own with a low-level library,
    such as **pthreads**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++11 之前的时代，没有标准的多线程支持。人们不得不使用第三方库或使用低级库（如 **pthreads**）来实现自己的多线程。
- en: This type of multithreading is unlikely to surprise you. This is the type of
    multithreading that people have talked about and have used most, which is **preemptive
    multithreading**. The thread function can be paused at any time and resumed at
    any time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种多线程类型可能不会让你感到惊讶。这是人们谈论并广泛使用的一种多线程类型，即**抢占式多线程**。线程函数可以在任何时候暂停，也可以在任何时候恢复。
- en: Next, we will explore a real example to see C++ multithreading in action.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一个真实示例来探索 C++ 多线程的实际应用。
- en: Using multiple Lua instances
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个 Lua 实例
- en: In this section, we will implement a thread function in which we’ll execute
    a Lua script. Then, we will create multiple threads to execute this same thread
    function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个线程函数，我们将执行一个 Lua 脚本。然后，我们将创建多个线程来执行这个相同的线程函数。
- en: 'Based on the source code from *Chapter 10*, wipe `main.cpp` clean and add the
    following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 *第 10 章* 的源代码，清理 `main.cpp` 并添加以下代码：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we added the necessary headers. `listener` is the Lua executor listener
    and will be shared for all Lua executor instances. `coutMutex` is a mutex for
    printing results with `std::cout`, whose usage we will see next.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了必要的头文件。`listener` 是 Lua 执行器监听器，并将为所有 Lua 执行器实例共享。`coutMutex` 是用于使用
    `std::cout` 打印结果的互斥量，其用法我们将在下面看到。
- en: 'Next, implement the thread function, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实现线程函数，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The thread function takes three integers as arguments, creates a Lua executor,
    and executes a Lua script to add the three integers. Then, it prints out the result.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 线程函数接受三个整数作为参数，创建一个 Lua 执行器，并执行一个 Lua 脚本来添加这三个整数。然后，它打印出结果。
- en: Because there is only one place the standard output can print to, we are guarding
    the standard output with a mutex. Otherwise, the output sequence will be a mix
    of different threads and unreadable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标准输出只有一个可以打印的地方，我们使用互斥量来保护标准输出。否则，输出序列将是一个不同线程的混合，难以阅读。
- en: The way we use this mutex is by creating `std::lock_guard` instead of calling
    `std::mutex::lock` and `std::mutex::unlock` directly. The lock guard will acquire
    the mutex during construction and release the mutex when it goes out of scope
    and gets destroyed. This is an example of the *RAII* principle.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用互斥锁的方式是通过创建 `std::lock_guard` 而不是直接调用 `std::mutex::lock` 和 `std::mutex::unlock`。锁保护器将在构造期间获取互斥量，并在超出作用域和被销毁时释放互斥量。这是一个
    *RAII* 原则的例子。
- en: Recap of RAII
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: RAII 概述
- en: In the previous chapter, we learned about Resource Acquisition is Initialization
    (RAII). The C++ standard library adopts this principle in numerous places. Suppose
    that we do not use the lock this way, but acquire and release it manually. If
    anything goes wrong in between, there is a risk that the lock is not released
    in a thread and breaks the whole application. With the lock guard, the lock is
    always released even if an exception is raised because the C++ language guarantees
    that the lock’s destructor is called when the lock goes out of scope. Before C++11,
    people would implement their own lock guard by creating a wrapper class that acquires
    the lock in the constructor and releases the lock in the destructor. This idiom
    is called `std::scoped_lock`, which can lock on multiple mutexes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了资源获取即初始化（RAII）的概念。C++ 标准库在许多地方采用了这一原则。假设我们不这样使用锁，而是手动获取和释放它。如果在中间发生任何错误，存在风险是锁没有被在线程中释放，从而破坏整个应用程序。使用锁保护器，即使在抛出异常的情况下，锁也会始终被释放，因为
    C++ 语言保证当锁超出作用域时，会调用锁的析构函数。在 C++11 之前，人们会通过创建一个在构造函数中获取锁并在析构函数中释放锁的包装类来实现自己的锁保护器。这种习惯用法被称为
    `std::scoped_lock`，它可以锁定多个互斥量。
- en: 'Finally, let’s implement the `main` function, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们实现 `main` 函数，如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This creates a list of threads and waits for the threads to finish execution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个线程列表并等待线程执行完成。
- en: In the first `for` loop, we use `std::vector::emplace_back` to create the threads
    at the end of the vector in place. Internally, for most C++ implementations, it
    uses *placement new* and invokes `std::thread(threadFunc, i, a, a + 1, a + 2)`.
    We do this because `std::thread` is not copy-constructible. Understandably, it
    does not make sense to copy a thread.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个 `for` 循环中，我们使用 `std::vector::emplace_back` 在向量的末尾就地创建线程。对于大多数 C++ 实现，内部使用
    *placement new* 并调用 `std::thread(threadFunc, i, a, a + 1, a + 2)`。我们这样做是因为 `std::thread`
    不能复制构造。可以理解的是，复制一个线程是没有意义的。
- en: In the second `for` loop, we use `std::thread::join` to wait for all threads
    to finish execution. The `main` function runs in the main thread of the application
    process. When `main` exits, all other threads will be aborted, even if they have
    not finished execution.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个 `for` 循环中，我们使用 `std::thread::join` 等待所有线程完成执行。`main` 函数在应用程序的主线程中运行。当 `main`
    退出时，所有其他线程都将被终止，即使它们还没有完成执行。
- en: Next, we’ll test our example.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将测试我们的示例。
- en: Testing it out
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行测试
- en: 'Compile and execute the project. You should see an output similar to the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并执行项目。你应该会看到以下类似的输出：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you run the project multiple times, you will see the order of the results
    from different threads changes. This verifies that we are using Lua with multiple
    threads.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你多次运行项目，你会看到不同线程的结果顺序发生变化。这验证了我们在 Lua 中使用了多个线程。
- en: For most projects, when integrating Lua into C++, this mechanism should suffice
    for multithreading. This is multithreading with C++. The Lua part just works without
    any additional effort. Each C++ thread has its own Lua instance and executes its
    copy of the Lua scripts. Different Lua instances do not interfere with or know
    about each other.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数项目，当将 Lua 集成到 C++ 中时，这种机制应该足以用于多线程。这是 C++ 中的多线程。Lua 部分无需额外努力即可正常工作。每个 C++
    线程都有自己的 Lua 实例，并执行其 Lua 脚本的副本。不同的 Lua 实例不会相互干扰或了解彼此。
- en: Next, we will explore multithreading in Lua.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索 Lua 中的多线程。
- en: Multithreading in Lua
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lua 中的多线程
- en: To understand multithreading in Lua, let’s begin with a fundamental question.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 Lua 中的多线程，让我们从一个基本问题开始。
- en: How does Lua support multithreading?
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lua 如何支持多线程？
- en: '*Lua does not support* *multithreading. Period.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lua 不支持* *多线程。就这么简单*。'
- en: But we cannot finish this section yet. We will explain this further with two
    approaches – a contemporary one and an old-school one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们还没有完成这个部分。我们将通过两种方法进一步解释这一点——一种当代方法和一种老式方法。
- en: The contemporary approach
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当代方法
- en: Lua is a scripting language and it does not support *preemptive multithreading*.
    It simply does not provide a library function to create a new thread, so there
    is no way to do it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 是一种脚本语言，它不支持 *抢占式多线程*。它根本不提供创建新线程的库函数，因此无法实现。
- en: Nowadays, CPUs and operating systems are designed around *preemptive multithreading*
    – that is, a thread of execution can be paused and resumed at any time. A thread
    has no control over its execution schedule.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，CPU 和操作系统都是围绕 *抢占式多线程* 设计的——也就是说，一个执行线程可以在任何时候暂停和恢复。线程对其执行调度没有控制权。
- en: However, Lua provides a mechanism for `coroutine`, which is usually a function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Lua 为 `协程` 提供了一种机制，这通常是一个函数。
- en: '`coroutine` is also very popular with Kotlin for Android and backend development.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`协程` 在 Kotlin 用于 Android 和后端开发中也非常受欢迎。'
- en: Cooperative multithreading
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 协作式多线程
- en: When we talk about threads, most of the time, the implication is that they are
    threads for CPU cores to execute. When we talk about *cooperative multithreading*,
    in some cases, such as the one for Lua, you may find that there is only one thread
    being executed and one CPU core used, even with coroutines. Arguably, this is
    not multithreading at all. But we do not need to judge. We need to understand
    this because multiple terms can be used for this in different contexts. We can
    also call this **cooperative multitasking**, which is technically more accurate
    from a historical point of view.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论线程时，大多数情况下，其含义是指它们是用于 CPU 核心执行的线程。当我们谈论 *协作式多线程* 时，在某些情况下，例如 Lua，你可能会发现只有一个线程在执行，并且只使用了一个
    CPU 核心，即使有协程。可以说，这根本不是多线程。但我们不需要评判。我们需要理解这一点，因为在不同的上下文中，可能会有多个术语用于此。我们也可以称之为 **协作式多任务处理**，这在历史上从技术角度来看更为准确。
- en: Let’s see Lua’s `coroutine` in action and explain it more.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Lua 的 `协程` 在实际中的应用，并对其进行更详细的解释。
- en: Implementing a Lua coroutine
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现 Lua 协程
- en: 'Replace the content of `script.lua` with the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `script.lua` 的内容替换为以下代码：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`create_square_seq_coroutine` creates a `coroutine` with `coroutine.create`,
    which, in turn, takes an anonymous function as its argument. You can roughly think
    that the inner anonymous function is `coroutine`. The inner function runs a loop
    and `1` to `n`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_square_seq_coroutine` 使用 `coroutine.create` 创建一个 `协程`，而 `coroutine.create`
    又以一个匿名函数作为其参数。你可以大致认为内部匿名函数就是 `协程`。内部函数运行一个循环，从 `1` 到 `n`。'
- en: You can only use `yield` with coroutines. A coroutine will stop execution when
    it reaches a `yield` statement. The values provided to `yield` will be returned
    to the call site, similar to what `return` does. The next time you execute `coroutine`,
    it will resume the execution from where it yielded until it reaches another `yield`
    statement or a `return` statement.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能与协程一起使用`yield`。当协程遇到`yield`语句时，它将停止执行。提供给`yield`的值将被返回到调用点，类似于`return`的作用。下次执行`coroutine`时，它将从上次`yield`的地方继续执行，直到它达到另一个`yield`语句或`return`语句。
- en: 'Let’s start an interactive Lua interpreter to test our `coroutine`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们启动一个交互式Lua解释器来测试我们的`coroutine`：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we create a `coroutine` to return the squares from `1` to `3`. The first
    time we `resume` `coroutine`, it starts to execute from the beginning and returns
    two values, `true` and `1`. `true` is from `coroutine.resume` and means that `coroutine`
    is executed without any error. `1` is what `coroutine` yielded. The next time
    we `resume` `coroutine`, the loop continues with the next iteration and returns
    `4`. Pay special attention to the line when `coroutine.resume` only returns one
    value. The loop has finished but there is still code to be executed for `coroutine`,
    such as the implicit return statement. So, `coroutine.resume` returns `true`.
    After that, `coroutine` has finished and cannot be resumed and `coroutine.resume`
    will return `false` with an error message.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个`coroutine`来返回从`1`到`3`的平方。第一次我们`resume` `coroutine`时，它从开始执行并返回两个值，`true`和`1`。`true`来自`coroutine.resume`，表示`coroutine`执行没有错误。`1`是`coroutine`产生的。下次我们`resume`
    `coroutine`时，循环继续进行下一个迭代并返回`4`。请注意，当`coroutine.resume`只返回一个值时的情况。循环已经完成，但还有代码需要为`coroutine`执行，例如隐式的返回语句。因此，`coroutine.resume`返回`true`。之后，`coroutine`已经完成，无法再恢复，`coroutine.resume`将返回带有错误信息的`false`。
- en: If this is the first time you have used `coroutine` with any programming language,
    this may seem magical and non-logical to you. How could a function, not in a thread,
    not reach its end and get executed from the middle of it again? I will explain
    why this is so ordinary (but do say you know `coroutine` and why it is so glorious
    in an interview) in the last part of this section. Before that, let’s explore
    another example to see a case in which `coroutine` can be very useful.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次在任何编程语言中使用`coroutine`，这可能会让你觉得神奇且不合逻辑。一个不在线程中的函数，怎么可能不达到其结束而再次从中部执行呢？我将在本节的最后部分解释为什么这是如此普通（但请记住，在面试中提到你知道`coroutine`以及为什么它如此辉煌），在此之前，让我们探索另一个例子，看看`coroutine`可以非常有用的一个场景。
- en: Lua coroutine as iterator
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Lua协程作为迭代器
- en: We have seen how to use iterators with the *generic for* to simplify our lives,
    for example, `ipairs`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用迭代器与`generic for`来简化我们的生活，例如`ipairs`。
- en: But what is an iterator?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但迭代器究竟是什么？
- en: An `iterator` returns an **iterator function** that can be called again and
    again until it returns nil or nothing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`iterator`返回一个**迭代函数**，可以反复调用，直到它返回`nil`或无。
- en: 'Based on `coroutine` that we have just implemented to generate a sequence of
    squares, let’s build an iterator. In `script.lua`, add another function, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们刚刚实现用于生成平方序列的`coroutine`，让我们构建一个迭代器。在`script.lua`中添加另一个函数，如下所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`square_seq` is a Lua `iterator` as it returns its inner function as an `iterator`
    `function`. The inner function continues to resume the coroutine created with
    `create_square_seq_coroutine`. It is the caller’s responsibility to stop calling
    the `iterator` `function` when the `iterator` `function` has returned nil or nothing.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`square_seq`是一个Lua `iterator`，因为它返回其内部函数作为`iterator` `function`。内部函数继续恢复使用`create_square_seq_coroutine`创建的协程。当`iterator`
    `function`返回`nil`或无时，调用者有责任停止调用`iterator` `function`。'
- en: 'Let’s test this `iterator` in an interactive Lua interpreter:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在交互式Lua解释器中测试这个`iterator`：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that three values are printed as expected for `1`, `2`, and `3`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，对于`1`、`2`和`3`，打印出了预期的三个值。
- en: And by looking at the usage, you cannot even tell if any coroutine or cooperative
    multithreading is involved. This, I think, is one of the examples where this programming
    paradigm can be more valuable than preemptive multithreading.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看使用情况，你甚至无法判断是否涉及到任何协程或协作多线程。我认为，这是这种编程范式比抢占式多线程更有价值的例子之一。
- en: So far, we have explored Lua `coroutine` and Lua `iterator`. They can be more
    complex, but these examples are enough to show you how they work. You can refer
    to the Lua reference manual to learn more about `coroutine` and `iterator`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了 Lua 的 `coroutine` 和 Lua 的 `iterator`。它们可能更加复杂，但这些示例已经足够展示它们是如何工作的。你可以参考
    Lua 参考手册来了解更多关于 `coroutine` 和 `iterator` 的信息。
- en: Next, let me indulge myself by explaining this in my own terms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我用自己的话来解释这一点。
- en: Introducing multi-stacking
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 介绍多栈
- en: Traditionally, a thread is an execution unit for a CPU core, with its associated
    execution stack and the **program counter** (**PC**). The PC is a CPU register
    for the address of the next instruction to be executed. As you can see, this is
    quite low-level and involves more details that we are not going to talk about.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，一个线程是一个 CPU 核心的执行单元，与其相关的执行栈和 **程序计数器**（**PC**）。PC 是 CPU 寄存器，用于存储下一个要执行的指令的地址。正如你所见，这相当低级，涉及到更多我们不打算讨论的细节。
- en: Because this traditional image has been imprinted in us too much, even implicitly,
    it may have become an obstacle for you to understand coroutines.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种传统观念在我们心中已经根深蒂固，即使是无意识的，它可能已经成为了你理解协程的障碍。
- en: Alternatively, let’s seek help with one of the fundamental principles in computer
    science – **decoupling**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，让我们借助计算机科学中的一个基本原理来寻求帮助——**解耦**。
- en: The widely understood preemptive multithreading mechanism is already an application
    of decoupling. It decouples the thread from the CPU core. With it, you can have
    unlimited threads in the pool while you have limited physical CPU cores.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 广为人知的抢占式多线程机制已经是解耦的应用。它将线程从 CPU 核心中解耦。有了它，你可以在有限的物理 CPU 核心中拥有无限的线程池。
- en: When you accept this, we only need to go one step further. If you accept that
    the execution stack can be decoupled from the execution thread as well, that is
    how `coroutine` works.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你接受这一点，我们只需要再进一步。如果你接受执行栈也可以从执行线程中解耦，这就是 `coroutine` 的工作方式。
- en: In this cooperative multithreading mechanism, a thread can have its own pool
    of execution stacks. An execution stack contains the call stack and PC. So, now,
    we have a three-tier system.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种合作式多线程机制中，一个线程可以有自己的执行栈池。一个执行栈包含调用栈和 PC。因此，现在我们有一个三层系统。
- en: 'I call these coroutines multi-stacking, a term I coinedto better explain it.
    Have a look at *Figure 11**.1*, which implicates the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这些协程称为多栈，这是一个我创造的术语，用以更好地解释它。看看 *图 11.1*。1*，它暗示了以下内容：
- en: '**The relationship between the CPU and threads**: There are more threads than
    CPU cores. A CPU core can execute any thread. When a thread is resumed, it can
    be picked up by any CPU core. This is the *preemptive multithreading* that we
    know of, which usually requires CPU hardware support and is managed by the operating
    system transparently.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU 与线程之间的关系**：线程的数量多于 CPU 核心。一个 CPU 核心可以执行任何线程。当一个线程被恢复时，它可以被任何 CPU 核心拾取。这是我们熟知的
    *抢占式多线程*，这通常需要 CPU 硬件支持，并由操作系统透明地管理。'
- en: '**The relationship between threads and coroutines**: One thread can have multiple
    coroutines, each with its own execution stack. Because the operating system stops
    at the thread level, the operating system has no concept of coroutines. For a
    thread to execute another coroutine, the current coroutine must give up its execution
    and yield willingly. This is why it is called *cooperative multithreading*. The
    coroutine has no concept of threads either; its owning thread can be preempted
    and picked up by another CPU core later, but these are all transparent to the
    coroutine. A coroutine can also be picked up by different threads if the programming
    environment supports that.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程与协程之间的关系**：一个线程可以有多个协程，每个协程都有自己的执行栈。因为操作系统在线程级别停止，操作系统没有协程的概念。为了使一个线程执行另一个协程，当前的协程必须放弃其执行并自愿让出。这就是为什么它被称为
    *合作式多线程*。协程也没有线程的概念；拥有它的线程可以被抢占，并在稍后由另一个 CPU 核心拾取，但这些对协程来说都是透明的。如果编程环境支持，协程也可以被不同的线程拾取。'
- en: '![Figure 11.1 – Multi-stacking](img/B20927_11_01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – 多栈](img/B20927_11_01.jpg)'
- en: Figure 11.1 – Multi-stacking
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 多栈
- en: Take a moment and think about the two relationships, which are explained and
    illustrated in *Figure 11**.1*. This is one of the ways, albeit be unusual, to
    explain coroutines. The goal here is to find similarities between different mechanisms
    and technologies.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 抽空思考一下这两个关系，它们在*图11**.1*中得到了解释和说明。这是解释协程的一种方式，尽管可能有些不寻常。这里的目的是在不同机制和技术之间找到相似之处。
- en: Next, we will look at cooperative multithreading and `coroutine` from another
    perspective.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从另一个角度来探讨协作多线程和`协程`。
- en: The old-school approach
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传统的做法
- en: So far in this section, we have focused on the contemporary approach to explain
    the `coroutine` concept. Hopefully, with the two relationships explained, you
    can understand and tell why `coroutine` adds another valuable layer of multithreading
    support in a modern computing system.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本节中，我们一直专注于解释当代的`协程`概念。希望通过对这两个关系的解释，你能理解和说明为什么`协程`为现代计算系统增加了另一层宝贵的多线程支持。
- en: However, this is nothing new. This is how computers have worked since the beginning.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是什么新鲜事。计算机从一开始就是这样工作的。
- en: Of course, in the very beginning, as you know, we feed the machine paper tape
    with holes. So, it is hopeless for multithreading.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在最开始，正如你所知，我们给机器喂入带孔的纸带。所以，多线程是毫无希望的。
- en: Then, later, it becomes more complex. But still, there is only one processing
    unit in the CPU, and there is a privileged and primitive control program running
    in a dead loop. The main thing the loop does is check if another program wants
    to run. If there is one, it loads the starting address of that program into the
    PC – the program counter of the CPU. Then, the CPU starts to execute the other
    program.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，后来，它变得更加复杂。但仍然，CPU中只有一个处理单元，有一个特权且原始的控制程序在一个死循环中运行。这个循环的主要作用是检查是否有其他程序想要运行。如果有，它将那个程序的起始地址加载到PC中——CPU的程序计数器。然后，CPU开始执行另一个程序。
- en: You have probably guessed the problem. What if there is yet another program
    that wants to run? As it used to be, it has to wait for the first program to finish.
    This, as you can imagine, is not fair. So, we improve it and regulate that all
    programs should play nicely and yield their execution once in a while. Doing this
    allows the privileged control program to resume and find out if another program
    needs to run.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了问题。如果有另一个程序想要运行呢？按照过去的做法，它必须等待第一个程序完成。正如你可以想象的那样，这并不公平。所以，我们改进了它，并规定所有程序都应该友好地轮流执行。这样做允许特权控制程序恢复运行，并找出是否有其他程序需要运行。
- en: This is called *cooperative multithreading*. Each of the programs, besides the
    privileged one, is a `coroutine` instance, except that this term had not been
    invented in that era.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*协作多线程*。除了特权程序之外，每个程序都是一个`协程`实例，只不过在那个时代还没有发明这个术语。
- en: It helps, but not always. Suppose that one program decides to wait for an I/O
    that never happens and does not yield; the computer will be waiting endlessly
    in vain.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于，但并不总是如此。假设有一个程序决定等待一个永远不会发生的I/O，并且不释放；计算机将无休止地徒劳等待。
- en: Much later, the computer became more powerful and could support running more
    complex operating systems. It moved the logic to decide which program to run into
    the operating system. If a program is waiting for I/O or has been running for
    enough time, the operating system will pause it and resume another program to
    run. This is *preemptive multithreading*. As it turns out, this is the right move.
    The operating system is fairer and the computer can do more.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 更晚些时候，计算机变得更加强大，能够支持运行更复杂的操作系统。它将决定哪个程序运行的逻辑移到了操作系统中。如果一个程序正在等待I/O或已经运行了足够长的时间，操作系统将暂停它，并恢复另一个程序的运行。这就是*抢占式多线程*。结果证明，这是一个正确的举措。操作系统更加公平，计算机可以做得更多。
- en: Fast-forward to recent years – Moore’s law no longer applies or at least has
    been paused. So, the CPU is not getting 1,000 cores, but the threads in a working
    computer are ever-increasing. Thus, the cost for the operating system to preempt
    and iterate through all the threads has now become a concern.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到近几年——摩尔定律不再适用，或者至少已经暂停。所以，CPU不会得到1,000个核心，但工作计算机中的线程数量却在不断增加。因此，操作系统抢占和迭代所有线程的成本现在已经成为一个关注点。
- en: What can we do?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做什么？
- en: Some smart guys found out that we just need to do what we did in the beginning
    – use cooperative multithreading again. But this time, the controlling program
    is your main program – since you can’t be selfish with yourself, you will be fair
    to all your coroutines to the best of your ability.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一些聪明的人发现我们只需要做我们最初做的事情——再次使用协作多线程。但这次，控制程序是你的主程序——既然你不能对自己自私，你将尽你所能对所有协程公平。
- en: This is a simplified version of the evolution of the computer system. It is
    not historically perfect and has some dramatic touches to it. The goal is for
    you to realize that `coroutine` is a simple concept and that you can be comfortable
    with it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个计算机系统演变的简化版本。它并非在历史上完全准确，并且加入了一些戏剧性的元素。目标是让你意识到`协程`是一个简单的概念，并且你可以感到舒适地使用它。
- en: Next, we will learn how to use coroutines with C++.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用C++中的协程。
- en: Using coroutine with C++
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++中的协程
- en: Do not use Lua `coroutine` with C++ if you have an alternative. As the iterator
    example showed, you can wrap `coroutine` in a normal function and keep calling
    it until it returns nil.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个替代方案，不要在C++中使用Lua `协程`。正如迭代器示例所示，你可以将`协程`包装在一个普通函数中，并不断调用它，直到它返回nil。
- en: 'But to be less opinionated and for completeness, we can use the following Lua
    library function to start or resume a coroutine from C++:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了减少主观性并保证完整性，我们可以使用以下Lua库函数从C++启动或恢复协程：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The function is similar to `pcall`. It expects the function to be called and,
    optionally, its arguments on the stack. The function will be the coroutine. `L`
    is a stack for the coroutine. `from` is the stack from which the coroutine is
    called. `narg` is the number of arguments to the `coroutine` function. `nresults`
    points to an integer and Lua will output the number of values yielded or returned
    to the integer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数类似于`pcall`。它期望被调用的函数以及可选的堆栈上的参数。这个函数将是协程。`L`是协程的栈。`from`是从中调用协程的栈。`narg`是`协程`函数的参数数量。`nresults`指向一个整数，Lua将输出产生的或返回到整数的值的数量。
- en: 'Let’s see an example to understand how this works. In `LuaExecutor.h`, add
    a function declaration, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解它是如何工作的。在`LuaExecutor.h`中添加一个函数声明，如下所示：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `resume` function supports `coroutine` in a limited way. It does not support
    passing parameters, but this is easy to do and you can refer to `LuaExecutor::call`.
    It only expects one return value as an integer. This is just to demonstrate the
    Lua API, not to add complete support for `coroutine` in our Lua executor.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`resume`函数以有限的方式支持`协程`。它不支持传递参数，但这很容易做到，你可以参考`LuaExecutor::call`。它只期望一个作为整数的返回值。这只是为了演示Lua
    API，而不是在我们的Lua执行器中添加对`协程`的完整支持。'
- en: 'Implement `resume`, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`resume`，如下所示：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a five-step process, separated by newlines, which is explained as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个五步的过程，通过换行符分隔，具体解释如下：
- en: It creates a new Lua state with `lua_newthread`. A reference to the new state
    is also pushed onto the main stack owned by `L`. We can call this new state the
    coroutine state. But `thd` is the coroutine stack. The Lua `lua_newthread` library
    function creates a new Lua state that shares the same global environment with
    the main state `L` but has its own execution stack. Yes, the API name is a bit
    misleading, but it is what it is.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用`lua_newthread`创建一个新的Lua状态。这个新状态的引用也被推送到由`L`拥有的主栈上。我们可以称这个新状态为协程状态。但`thd`是协程栈。Lua的`lua_newthread`库函数创建了一个新的Lua状态，它与主状态`L`共享相同的全局环境，但拥有自己的执行栈。是的，API名称有点误导，但它就是这样。
- en: It pushes the function name to be executed as a coroutine onto the new Lua stack.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将执行为协程的函数名称推送到新的Lua栈上。
- en: It calls `lua_resume` to start or resume the coroutine. Since we are always
    creating a new state named `thd`, we are always starting the coroutine afresh.
    To resume it, we need to save `thd` somewhere and pass it in for future calls.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它调用`lua_resume`来启动或恢复协程。由于我们总是创建一个名为`thd`的新状态，我们总是从头开始启动协程。要恢复它，我们需要将`thd`保存在某个地方，并在未来的调用中传递它。
- en: It checks whether there is an error; or, in case the coroutine does not return
    any result, it means that it has ended.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查是否存在错误；或者，如果协程没有返回任何结果，这意味着它已经结束。
- en: It retrieves the single integer that we expect, pops it from the coroutine stack,
    pops the reference to the coroutine stack from the main stack, and returns the
    value.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检索我们期望的单个整数，从协程栈中弹出，从主栈中弹出协程栈的引用，并返回该值。
- en: Taking care of other Lua states
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 照顾其他Lua状态
- en: A coroutine needs its own Lua state to be executed. You need to keep a reference
    to its Lua state somewhere until you no longer need the coroutine. Without a reference,
    Lua will destroy the state during garbage collection. If you have many coroutines,
    keeping all of those extra Lua states in the main stack can be messy. So, if you
    want to work with coroutines in C++, you need to design a system to hold and query
    those Lua states.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 协程需要自己的 Lua 状态来执行。你需要将其 Lua 状态的引用保存在某个地方，直到你不再需要协程。如果没有引用，Lua 将在垃圾回收期间销毁状态。如果你有很多协程，将所有这些额外的
    Lua 状态保留在主堆栈中可能会很混乱。因此，如果你想在 C++ 中与协程一起工作，你需要设计一个系统来保存和查询这些 Lua 状态。
- en: 'Next, add the following Lua function to `script.lua`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下 Lua 函数添加到 `script.lua` 中：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function yields two values. The `for` loop is hardcoded because we do not
    support passing arguments in `LuaExecutor::resume`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数产生两个值。`for` 循环是硬编码的，因为我们不支持在 `LuaExecutor::resume` 中传递参数。
- en: 'For the last bit of the demonstration, write `main.cpp` like so:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于演示的最后部分，编写 `main.cpp` 如下所示：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This sets up the Lua executor and calls the `resume` function to start `coroutine`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了 Lua 执行器并调用 `resume` 函数以启动 `coroutine`。
- en: 'Compile and run the project; you should see the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行项目；你应该看到以下输出：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This shows how to work with `lua_resume`. You can read the Lua reference manual
    to get more detailed information about this API.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了如何使用 `lua_resume`。你可以阅读 Lua 参考手册以获取有关此 API 的更详细信息。
- en: C++ code can also be executed as a coroutine. This can be done where a `lua_CFunction`
    implementation is provided to `lua_resume`, or Lua code in a coroutine calls a
    `lua_CFunction` implementation. In this case, C++ code can also yield by calling
    `lua_yieldk`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 代码也可以作为协程执行。这可以通过提供 `lua_CFunction` 实现给 `lua_resume` 或者在协程中的 Lua 代码调用 `lua_CFunction`
    实现来完成。在这种情况下，C++ 代码也可以通过调用 `lua_yieldk` 来产生。
- en: Using coroutine with C++ can be very complex, but if you have your use cases
    defined, this can be abstracted to hide the complex details. This section is only
    an eye-opener. You can decide whether to use Lua this way or not.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C++ 与协程结合可能会非常复杂，但如果你已经定义了你的用例，这可以抽象出来以隐藏复杂的细节。本节只是一个引子。你可以决定是否以这种方式使用 Lua。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With that, we have wrapped up the final chapter of this book. In this chapter,
    we focused on multithreading mechanisms, preemptive multithreading and cooperative
    multithreading, and Lua coroutines.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经完成了这本书的最后一章。在这一章中，我们重点介绍了多线程机制、抢占式多线程和协作式多线程，以及 Lua 协程。
- en: Lua coroutines can be used without C++ for advanced Lua programming and you
    can hide all these details from C++. We only touched the tip of the iceberg. You
    can read the Lua reference manual and practice more. You can also explore more
    on how to use coroutines with C++ by experimenting with the related Lua library
    functions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Lua 协程可以在不使用 C++ 的情况下用于高级 Lua 编程，并且你可以将这些所有细节从 C++ 中隐藏起来。我们只是触及了冰山一角。你可以阅读 Lua
    参考手册并多加练习。你也可以通过实验相关的 Lua 库函数来探索如何与 C++ 一起使用协程。
- en: In this book, we implemented `LuaExecutor` progressively. Each chapter added
    more features to it. However, it is not perfect. For example, `LuaValue` can be
    improved to make it easier to work with, and `LuaExecutor` can support more table
    operations. You can use `LuaExecutor` as a base and adapt it to your project or
    implement your own in a completely different way after you have learned the mechanisms.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们逐步实现了 `LuaExecutor`。每一章都为其添加了更多功能。然而，它并不完美。例如，`LuaValue` 可以改进以使其更容易使用，`LuaExecutor`
    也可以支持更多的表操作。你可以在学习机制之后将 `LuaExecutor` 作为基础来适应你的项目，或者以完全不同的方式实现自己的。
- en: I am confident that at this point, you can make improvements and add more features
    that suit you the best. You can always revisit the chapters as reminders and search
    the Lua reference manual for what you need.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信，到这一点，你可以进行改进并添加最适合你的更多功能。你总是可以回顾这些章节作为提醒，并在 Lua 参考手册中搜索你需要的内容。
