- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Sending and Receiving Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送和接收数据
- en: In the previous chapter, we saw how we can establish a connection between two
    computers using the high-level Godot Engine `ENetMultiplayerPeer` API. But what
    do we do after that? Why do we establish connections between computers? The foundation
    of a network is the communication between the connected computers, allowing them
    to send and receive data. This data is transferred by breaking down the content
    into small chunks called **packets**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用 Godot 引擎的高级 `ENetMultiplayerPeer` API 在两台计算机之间建立连接。但之后我们做什么呢？为什么我们要在计算机之间建立连接？网络的基础是连接计算机之间的通信，允许它们发送和接收数据。这些数据通过将内容分解成称为
    **数据包** 的小块来传输。
- en: Each packet is like a postcard containing the necessary information, such as
    the sender’s and receiver’s IP addresses, the communication port, and the message’s
    content. We then send these packets over the network, where they can be routed
    to their intended recipient. Using communication protocols, such as the UDP protocol,
    we break the data into packets at the sending end and reassemble them at the receiving
    end of the relationship.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据包就像一张包含必要信息的明信片，例如发送者和接收者的 IP 地址、通信端口以及消息的内容。然后我们将这些数据包通过网络发送，它们可以被路由到预期的接收者。使用通信协议，如
    UDP 协议，我们在发送端将数据分解成数据包，并在关系的接收端重新组装它们。
- en: In this chapter, we will discuss the fundamentals of how packets are sent and
    received and what makes the UDP protocol unique. For that, we’ll need to go a
    bit lower and use the Godot Engine `UDPServer` and `PacketPeerUDP` classes. These
    are lower-level API classes, so we will go through some intense content here.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将讨论数据包发送和接收的基本原理以及使 UDP 协议独特之处。为此，我们需要稍微深入一些，并使用 Godot 引擎的 `UDPServer`
    和 `PacketPeerUDP` 类。这些是低级 API 类，因此在这里我们将讨论一些内容。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding packets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数据包
- en: Introduction to the **JavaScript Object Notation** (**JSON**) format
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaScript 对象表示法**（**JSON**）格式简介'
- en: Sending packets with `PacketPeerUDP`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `PacketPeerUDP` 发送数据包
- en: Listening to packets with `UDPServer`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `UDPServer` 监听数据包
- en: Authenticating the player
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证玩家身份
- en: Loading the player’s avatar
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载玩家的头像
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we’re going to keep up with our project in Godot Engine, but
    this time, we are going to use the files provided in the `res://02.sending-and-receiving-data`
    folder. So, if you haven’t already done so, download the project’s repository
    using this link: [https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续在 Godot 引擎中跟进我们的项目，但这次，我们将使用 `res://02.sending-and-receiving-data`
    文件夹中提供的文件。因此，如果您还没有这样做，请使用此链接下载项目的仓库：[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)。
- en: Then, with the project added to your Godot Engine project manager, open the
    project and proceed to the `res://02.sending-and-receiving-data` folder.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将项目添加到您的 Godot 引擎项目管理器中，打开项目并转到 `res://02.sending-and-receiving-data` 文件夹。
- en: Understanding packets
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数据包
- en: '**Packets** are fundamental building blocks of communication over the network
    using the UDP protocol. They are small chunks of data that contain all the necessary
    information to reach their intended recipient. This includes the sender’s and
    receiver’s IP addresses, the communication port, and the message’s content.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据包** 是使用 UDP 协议在网络中进行通信的基本构建块。它们是包含所有必要信息以到达其预期接收者的数据小块。这包括发送者和接收者的 IP 地址、通信端口以及消息的内容。'
- en: 'Senders send packets to the receiver over the network. The receiving end reassembles
    the packets, allowing the receiver to understand the message sent. This process
    is known as **packet switching**. You can see a visual representation of this
    here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 发送者通过网络将数据包发送到接收者。接收端重新组装数据包，使接收者能够理解发送的消息。这个过程被称为 **数据包交换**。您可以在以下位置看到这个过程的视觉表示：
- en: '![Figure 2.1 – Packet switching process](img/Figure_02.01_B18527.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 数据包交换过程](img/Figure_02.01_B18527.jpg)'
- en: Figure 2.1 – Packet switching process
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 数据包交换过程
- en: Unlike other protocols, such as the TCP protocol, the UDP protocol does not
    guarantee that packets will arrive in the same order as they were sent. This means
    that the protocol is less reliable but more efficient and faster.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与TCP协议等其他协议不同，UDP协议不保证数据包会按发送顺序到达。这意味着该协议不太可靠，但更高效、更快。
- en: UDP is also different from other protocols due to its lack of connection state.
    Each packet contains all the data it needs to reach its receiving end. We address
    them individually, and the network routes them based on each packet’s own information.
    This contrasts with the TCP protocol as the latter needs to set up a prearranged,
    fixed data channel through a traditional handshake procedure.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: UDP与其他协议的不同之处还在于其缺乏连接状态。每个数据包都包含它到达接收端所需的所有数据。我们单独处理它们，网络根据每个数据包自己的信息进行路由。这与TCP协议形成对比，因为后者需要通过传统的握手程序建立一个预先安排的、固定的数据通道。
- en: This means that we can send these packets using the UDP protocol without a handshake.
    As long as our server is listening to messages at the specific port we’ve assigned,
    it will be able to receive the sender’s message.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以使用UDP协议发送这些数据包而不需要握手。只要我们的服务器在指定的端口上监听消息，它就能接收发送方的消息。
- en: Due to all that, the UDP protocol is more efficient for sending gameplay data
    across a network because it’s fast and doesn’t need to wait for confirmation of
    each packet in order at the receiver’s end. This is a huge advantage for online
    multiplayer games, especially ones where the player’s reaction time is important
    for the gameplay.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些原因，UDP协议在发送网络游戏数据时更加高效，因为它速度快，不需要在接收端等待每个数据包的确认。这对于在线多人游戏来说是一个巨大的优势，尤其是在玩家的反应时间对游戏很重要的情况下。
- en: It’s also common to use the UDP protocol for quick message systems and even
    voice calls. One issue that may come with using UDP for voice calls is that sometimes
    the audio doesn’t reach the other side in the correct order, or in any order at
    all. This causes some issues, but since the communication is meant to be real
    time and users can ask the person at the other end of the conversation to repeat,
    the UDP protocol has become the go-to solution for this type of service. And this
    is what is important to understand—when it is and when it isn’t the proper choice.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UDP协议进行快速消息系统和甚至语音通话也很常见。使用UDP进行语音通话可能带来的一个问题是有时音频无法按正确顺序或任何顺序到达对方。这会引起一些问题，但由于通信旨在实时进行，用户可以要求对话另一端的人重复，UDP协议已成为此类服务的首选解决方案。重要的是要理解——何时以及何时不是正确的选择。
- en: Now that we have taken a glance at the protocols in which we can exchange data
    across the network, we need to understand what this data looks like. Can we send
    instances of objects across the network? How will they assemble at the receiver’s
    end?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经浏览了我们可以通过网络交换数据的协议，我们需要了解这些数据看起来是什么样子。我们能否通过网络发送对象的实例？它们将在接收端如何组装？
- en: Network communication is a bit lower level in this sense; we need to send only
    relevant information in data structures that both the sender and the receiver
    ends can understand. And for that, we commonly avoid passing binary data around,
    such as objects.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意义上，网络通信要低级一些；我们需要在数据结构中发送只有发送方和接收方端点都能理解的相关信息。为此，我们通常避免传递二进制数据，例如对象。
- en: Instead, we serialize the important information and transmit the necessary chunks
    across the network so that the receiver end can create a whole new clone of the
    object using only the data we transmitted. This is way more reliable and allows
    for smaller bandwidth usage. One common data structure that we use is dictionaries
    in the format of JSON files.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将重要信息序列化，并通过网络传输必要的块，以便接收端可以使用我们传输的数据创建一个全新的对象副本。这更加可靠，并且允许更小的带宽使用。我们常用的一个数据结构是以JSON文件格式组织的字典。
- en: Introduction to the JSON format
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON格式简介
- en: In network programming, transmitting objects directly through the network is
    not always reliable, as the data may get corrupted or lost in transit. Moreover,
    transmitting objects containing executable code may pose a security risk if the
    code is malicious. That’s why it’s a common practice to use data serialization
    to convert objects into a format that can be easily transmitted over the network.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络编程中，直接通过网络传输对象并不总是可靠的，因为数据可能在传输过程中被损坏或丢失。此外，如果代码是恶意的，包含可执行代码的对象的传输可能存在安全风险。这就是为什么使用数据序列化将对象转换为易于通过网络传输的格式是一种常见的做法。
- en: One of the most commonly used data serialization formats is JSON. JSON is a
    lightweight, text-based format that can represent complex data structures such
    as arrays and objects, making it an ideal choice for network communication.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的数据序列化格式之一是 JSON。JSON 是一种轻量级的基于文本的格式，可以表示复杂的数据结构，如数组和对象，使其成为网络通信的理想选择。
- en: When using the Godot Engine network API with UDP, sending and receiving JSON
    files is a common practice. With JSON, we can serialize and deserialize data quickly
    and efficiently. JSON files are human-readable, making it easier for developers
    to debug and troubleshoot issues. JSON files are also flexible, meaning we can
    cherry-pick only the relevant data we need to send, making network communication
    even more efficient.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Godot 引擎网络 API 和 UDP 时，发送和接收 JSON 文件是一种常见做法。使用 JSON，我们可以快速高效地进行序列化和反序列化。JSON
    文件是可读的，这使得开发者更容易调试和排除问题。JSON 文件也是灵活的，这意味着我们可以只选择需要发送的相关数据，使网络通信更加高效。
- en: Unlike binary formats, JSON files are easy to read and modify as well. This
    makes it easier to debug and troubleshoot any issues that may arise during the
    transmission of data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与二进制格式不同，JSON 文件易于阅读和修改。这使得在数据传输过程中出现任何问题时更容易进行调试和故障排除。
- en: Now that we understand the advantages and the overall idea behind the JSON format,
    how do we use it properly? How does a JSON file help us transmit data around a
    network and keep players in the same game context?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 JSON 格式的优点和背后的整体理念，我们如何正确地使用它？JSON 文件如何帮助我们通过网络传输数据并保持玩家在相同的游戏上下文中？
- en: As mentioned in this section, serialization is how we cherry-pick only the necessary
    information about a data structure, such as an object, and translate it into a
    format that we can pass around, and even store, to reconstruct the previous data
    structure. Serialization is one of the most important skills to learn in software
    engineering fields, including networks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节所述，序列化是我们挑选出关于数据结构（如对象）的必要信息，并将其转换为可以传递甚至存储的格式的过程。序列化是软件工程领域（包括网络）中需要学习的重要技能之一。
- en: It is through serialization that we can translate the state of our application
    so that other instances of our application can further replicate this state through
    time—for instance, to make a save and load system or through space, as we are
    going to do in online multiplayer games. So, let’s understand how serialization
    works and how to do it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正是通过序列化，我们可以将应用程序的状态转换为其他应用程序实例可以通过时间进一步复制此状态——例如，实现保存和加载系统，或者通过空间，正如我们将在在线多人游戏中做的那样。因此，让我们了解序列化是如何工作的以及如何进行序列化。
- en: Serialization
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化
- en: '`Sprite2D` node, into a simple, linear representation that we can store in
    a file. For instance, `*.tscn` files are serialized files that represent a scene
    in Godot Engine’s editor.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sprite2D` 节点，转换成一个简单、线性的表示，我们可以将其存储在文件中。例如，`*.tscn` 文件是序列化文件，代表 Godot 引擎编辑器中的一个场景。'
- en: Serialization involves converting an object into a format that can be easily
    reconstructed on another machine or in another context. This can involve encoding
    the object’s properties, data, and other relevant information in a standardized
    format, such as JSON. Serialization is essential in network communication because
    it allows data to be transmitted and received efficiently and reliably, while
    also enabling interoperability between different programming languages and systems.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化涉及将对象转换为可以在另一台机器或另一个上下文中轻松重建的格式。这可能涉及以标准格式（如 JSON）编码对象的属性、数据和相关信息。序列化在网络通信中至关重要，因为它允许数据高效、可靠地传输和接收，同时还能实现不同编程语言和系统之间的互操作性。
- en: 'For instance, if we want to recreate a `Sprite2D` node on the client’s side
    based on data provided by the server, we can serialize important properties such
    as its position, rotation, scale, and texture. It would look like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在客户端根据服务器提供的数据重新创建一个 `Sprite2D` 节点，我们可以序列化重要的属性，如其位置、旋转、缩放和纹理。它看起来会是这样：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, on the client’s side, we instantiate a new `Sprite2D` node and use this
    data to ensure it represents what the server wants the client to see. We are going
    to use serialization a lot moving forward. In Godot, we have the `JSON` helper
    class for creating and parsing JSON data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在客户端，我们实例化一个新的 `Sprite2D` 节点，并使用这些数据确保它代表服务器希望客户端看到的内容。我们将在接下来的工作中大量使用序列化。在
    Godot 中，我们有 `JSON` 辅助类用于创建和解析 JSON 数据。
- en: The `JSON.stringify()` method is used to serialize an object or a data type,
    such as an integer or a dictionary, into a JSON-formatted string. This method
    takes an object as input and returns a string containing the JSON representation
    of the input object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON.stringify()` 方法用于将对象或数据类型（如整数或字典）序列化为 JSON 格式的字符串。此方法接受一个对象作为输入，并返回包含输入对象
    JSON 表示的字符串。'
- en: The string can then be transmitted over the network, stored in a file, or used
    in any other context where a string representation of the object is needed. The
    resulting string can easily be deserialized back into an object using the `JSON.parse_string()`
    method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该字符串可以随后在网络中传输、存储在文件中或用于任何需要对象字符串表示的上下文中。使用 `JSON.parse_string()` 方法，生成的字符串可以轻松地反序列化为对象。
- en: On the other hand, the `JSON.parse_string()` method is used to deserialize a
    JSON-formatted string back into a recognized Godot data type or object. This method
    takes a string as input and returns the deserialized data. The resulting object
    can then be used in any context where the original object was needed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`JSON.parse_string()` 方法用于将 JSON 格式的字符串反序列化为可识别的 Godot 数据类型或对象。此方法接受一个字符串作为输入，并返回反序列化的数据。生成的对象可以用于任何需要原始对象的地方。
- en: When deserializing the JSON string, the method takes care of mapping the JSON
    values to the appropriate Godot Engine data types. This includes mapping strings
    to strings, numbers to numbers, and Booleans to Booleans, as well as parsing more
    complex types such as dictionaries and objects.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在反序列化 JSON 字符串时，该方法负责将 JSON 值映射到适当的 Godot 引擎数据类型。这包括将字符串映射到字符串、数字映射到数字以及布尔值映射到布尔值，还包括解析更复杂的数据类型，如字典和对象。
- en: With both `JSON.stringfy()` and `JSON.parse_string()` methods, Godot Engine
    provides a simple and reliable way to convert data into a format that can be transmitted
    over the network or stored in a file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `JSON.stringify()` 和 `JSON.parse_string()` 方法，Godot 引擎提供了一个简单且可靠的方式来将数据转换为可以在网络中传输或存储在文件中的格式。
- en: We saw how we can translate our relevant data into an understandable standard
    format that we can store, transmit, and recreate at the receiver end. Let’s understand
    how we can pass this data around in the network.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何将我们的相关数据转换为可理解的标准格式，以便我们可以在接收端存储、传输和重新创建。让我们了解如何在网络中传递这些数据。
- en: This is fundamental knowledge when we deal with online multiplayer games because
    it’s through this process that we will be able to recreate objects and even the
    whole game state across players, making them share the same game world.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理在线多人游戏时，这是基本知识，因为我们将通过这个过程在玩家之间重新创建对象，甚至整个游戏状态，使他们共享相同的游戏世界。
- en: Sending packets with PacketPeerUDP
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PacketPeerUDP 发送数据包
- en: Now, let’s move on to practical knowledge. In this chapter, your task is to
    implement a login system for a game. Our project already has a cool user interface
    and is able to gather player data, such as their login name and password. Your
    mission is to make sure that only authorized players can access the game’s content
    by implementing a secure authentication feature.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向实际知识。在本章中，你的任务是为一个游戏实现一个登录系统。我们的项目已经有一个酷炫的用户界面，能够收集玩家数据，例如他们的登录名和密码。你的任务是确保只有授权的玩家可以通过实现安全认证功能来访问游戏内容。
- en: Once a player successfully logs in, you need to display their character’s avatar
    based on what we have saved in our database. As a network engineer, you understand
    the importance of security when it comes to online systems. You know that a robust
    authentication system is essential to ensure that only legitimate users are granted
    access to the game’s content.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦玩家成功登录，你需要根据我们在数据库中保存的内容显示他们的角色头像。作为一名网络工程师，你明白在线系统中的安全性至关重要。你知道一个强大的身份验证系统对于确保只有合法用户被授予访问游戏内容是必不可少的。
- en: Therefore, you will need to develop a login system that checks players’ credentials
    against a secure database and verifies if they have permission to access the game’s
    features or not.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你需要开发一个登录系统，该系统将检查玩家的凭证与安全数据库的匹配情况，并验证他们是否有权访问游戏的功能。
- en: With your skills and experience, you need to create a system that will provide
    an excellent user experience while keeping players’ data secure. So, take up the
    challenge, and let’s create a login system that will be a testament to your skills
    as a network engineer!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的技能和经验，你需要创建一个系统，该系统能够在确保玩家数据安全的同时提供卓越的用户体验。所以，接受这个挑战，让我们创建一个登录系统，这将证明你作为网络工程师的技能！
- en: In our project repository, open the `res://02.sending-and-receiving-data//MainMenu.tscn`
    scene, and let’s get started.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目仓库中，打开`res://02.sending-and-receiving-data//MainMenu.tscn`场景，让我们开始吧。
- en: Creating an AuthenticationCredentials Autoload
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建AuthenticationCredentials Autoload
- en: In Godot Engine, **Autoloads** are singletons that Godot loads automatically
    when the game starts. We can create and edit them in the editor itself and access
    them from any script in the game. We use Autoloads to store game-wide data or
    to provide global functionality, making them a convenient way to carry players’
    credentials across the game.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Godot引擎中，**Autoloads**是当游戏开始时Godot自动加载的单例。我们可以在编辑器中创建和编辑它们，并从游戏中的任何脚本中访问它们。我们使用Autoloads来存储游戏范围内的数据或提供全局功能，这使得它们成为携带玩家凭证穿越游戏的一种便捷方式。
- en: One of the main advantages of using Autoloads for carrying player credentials
    is that they are available throughout scene changes. This means that any script
    in the game can access the Autoload and retrieve the players’ credentials when
    needed. This eliminates the need to pass credentials from one script to another,
    making the code cleaner and easier to maintain.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Autoloads携带玩家凭证的主要优势之一是它们在场景变化期间始终可用。这意味着任何游戏中的脚本都可以访问Autoload并在需要时检索玩家的凭证。这消除了从一个脚本传递凭证到另一个脚本的必要性，使得代码更干净且更容易维护。
- en: In addition to that, since Autoloads are persistent throughout the game’s lifetime,
    as long as players don’t close the game, we can access their credentials.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于Autoloads在整个游戏生命周期中都是持久的，只要玩家不关闭游戏，我们就可以访问他们的凭证。
- en: This can make the process of implementing a login system with authentication
    features more efficient and streamlined.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以使实现具有身份验证功能的登录系统的过程更加高效和流畅。
- en: 'So, let’s create our `AuthenticationCredentials` Autoload, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们创建我们的`AuthenticationCredentials` Autoload，如下所示：
- en: Create a new scene using a `Node` node as the root node.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Node`节点作为根节点创建一个新的场景。
- en: Rename the root node `AuthenticationCredentials`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名根节点`AuthenticationCredentials`。
- en: Attach a new script to it, save it as `AuthenticationCredentials.gd`, and open
    it.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其附加一个新的脚本，将其保存为`AuthenticationCredentials.gd`，并打开它。
- en: 'Create a variable to store the player’s username; we can name this variable
    `user`, and it should be an empty string by default:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来存储玩家的用户名；我们可以将这个变量命名为`user`，并且它应该默认为空字符串：
- en: '[PRE1]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, create a variable to store the session’s token when we successfully validate
    a login:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个变量来存储我们在成功验证登录时保存的会话令牌：
- en: '[PRE2]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save the scene, then go to **Project** | **Project Settings** and open the **Autoload**
    tab.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景，然后转到**项目** | **项目设置**并打开**Autoload**选项卡。
- en: 'In the **Path** field, click on the small folder icon:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**路径**字段中，点击小文件夹图标：
- en: '![Figure 2.2 – Autoload tab in the Project Settings menu](img/Figure_02.02_B18527.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 项目设置菜单中的Autoload选项卡](img/Figure_02.02_B18527.jpg)'
- en: Figure 2.2 – Autoload tab in the Project Settings menu
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 – 项目设置菜单中的Autoload选项卡](img/Figure_02.02_B18527.jpg)'
- en: 'From the pop-up menu, select `AuthenticationCredentials.tscn`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出菜单中选择`AuthenticationCredentials.tscn`：
- en: '![Figure 2.3 – Selecting the AuthenticationCredentials scene from the File
    menu](img/Figure_2.03_B18527.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 从文件菜单中选择AuthenticationCredentials场景](img/Figure_2.03_B18527.jpg)'
- en: Figure 2.3 – Selecting the AuthenticationCredentials scene from the File menu
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 从文件菜单中选择AuthenticationCredentials场景
- en: Leave the **Node Name** field as **AuthenticationCredentials** and click on
    the **Add** button.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **节点名称** 字段保留为 **AuthenticationCredentials** 并点击 **添加** 按钮。
- en: And there we have it. Now, you can access the variables and functions defined
    in the script of the `AuthenticationCredentials.gd` scene from anywhere in your
    project by calling the `AuthenticationCredentials` singleton.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了。现在，您可以通过调用 `AuthenticationCredentials` 单例在任何地方访问在 `AuthenticationCredentials.gd`
    场景脚本中定义的变量和函数。
- en: This is useful for keeping track of global state across multiple scenes and
    nodes in your game. It’s important to note that this Autoload should only exist
    on the client’s side of a multiplayer game, and not on the server’s side. So,
    make sure to remove it from your server application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于跟踪游戏中多个场景和节点之间的全局状态非常有用。需要注意的是，这个 Autoload 应该只存在于多人游戏的客户端端，而不是服务器端。所以，请确保从您的服务器应用程序中删除它。
- en: Now, let’s see how we can gather and send players’ credentials to the server.
    For that, we are going to work on the very login screen itself! Open `LoginScreen.tscn`
    and let’s move on to the cool stuff.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何收集并发送玩家的凭证到服务器。为此，我们将直接在登录屏幕本身上工作！打开 `LoginScreen.tscn`，然后继续进行有趣的部分。
- en: Sending players’ credentials
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送玩家的凭证
- en: 'The `Control` node named **LoginScreen** with a user interface that captures
    players’ credentials so that we can authenticate them and give them access to
    our world:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 **LoginScreen** 的 `Control` 节点，其用户界面用于捕获玩家的凭证，以便我们可以进行身份验证并让他们访问我们的世界：
- en: '![Figure 2.4 – The LoginScreen scene’s node hierarchy](img/Figure_02.04_B18527.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 登录屏幕场景的节点层次结构](img/Figure_02.04_B18527.jpg)'
- en: Figure 2.4 – The LoginScreen scene’s node hierarchy
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 登录屏幕场景的节点层次结构
- en: The interface includes two `LineEdit` nodes, one called `LineEdit` nodes allow
    players to input their login credentials. In case of any errors, we can use the
    **ErrorLabel** node to display any necessary messages.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 界面包括两个 `LineEdit` 节点，一个允许玩家输入他们的登录凭证。如果发生任何错误，我们可以使用 **ErrorLabel** 节点来显示必要的消息。
- en: As we collect the players’ credentials here, we can use the **LoginButton**
    node to trigger the login procedure. With this scene in place, our players can
    securely access their avatar screen once they successfully log in.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里收集玩家的凭证，我们可以使用 **LoginButton** 节点来触发登录过程。有了这个场景，一旦玩家成功登录，他们就可以安全地访问他们的头像屏幕。
- en: 'But now, we need to work on validating their logins before loading their avatar.
    So, let’s get our hands dirty. Proceed as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们需要在加载他们的头像之前验证他们的登录。所以，让我们动手吧。按照以下步骤进行操作：
- en: Open the `LoginScreen.gd` script and go to the `send_credentials()` function.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `LoginScreen.gd` 脚本并进入 `send_credentials()` 函数。
- en: Inside the `send_credentials()` function, create a dictionary called `message`
    that contains the user credentials we will authenticate in the server.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `send_credentials()` 函数内部，创建一个名为 `message` 的字典，其中包含我们将要在服务器上验证的用户凭证。
- en: To store these credentials, create a key in the message dictionary called `'authenticate_credentials'`;
    its value should also be a dictionary. We’ll use it to store players’ credentials.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要存储这些凭证，在消息字典中创建一个名为 `'authenticate_credentials'` 的键；其值也应该是一个字典。我们将用它来存储玩家的凭证。
- en: 'Use the `user_line_edit` and `password_line_edit` text properties to capture
    the player’s input for their username and password, respectively:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `user_line_edit` 和 `password_line_edit` 文本属性来捕获玩家输入的用户名和密码：
- en: '[PRE3]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instantiate a new `PacketPeerUDP` object called `packet` using the `PacketPeerUDP.new()`
    constructor:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `PacketPeerUDP.new()` 构造函数实例化一个新的名为 `packet` 的 `PacketPeerUDP` 对象：
- en: '[PRE4]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Connect the `packet` object to the server’s address and port using the `connect_to_host()`
    method. Here, we are using our default `ADDRESS` and `PORT` constants that represent
    the IP address and port number of the server to which the client is connecting.
    They are `127.0.0.1` and `9999` respectively:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `connect_to_host()` 方法将 `packet` 对象连接到服务器的地址和端口。在这里，我们使用默认的 `ADDRESS` 和 `PORT`
    常量，它们分别代表客户端连接到的服务器的 IP 地址和端口号。它们分别是 `127.0.0.1` 和 `9999`：
- en: '[PRE5]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Serialize the message dictionary object into a JSON-formatted string using
    the `JSON.stringify()` method, and send it to the server using the `packet.put_var()`
    method:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `JSON.stringify()` 方法将消息字典对象序列化为 JSON 格式的字符串，并使用 `packet.put_var()` 方法将其发送到服务器：
- en: '[PRE6]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a `while` loop to wait for a response from the server. The `packet.wait()`
    method waits for a packet to arrive at the bound address. It returns an `OK` error
    constant if it receives a packet; otherwise, it returns an error code based on
    Godot’s error constants. So, we can use that to wait for the arrival of our packet
    at the server’s end:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `while` 循环以等待来自服务器的响应。`packet.wait()` 方法等待数据包到达绑定的地址。如果它收到数据包，则返回 `OK`
    错误常量；否则，它返回基于 Godot 错误常量的错误代码。因此，我们可以使用它来等待我们的数据包到达服务器端：
- en: '[PRE7]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we receive a response, we need to deserialize the response data from JSON
    format back into a dictionary object using the `JSON.parse_string()` method. Let’s
    store that in a variable called `response`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们收到响应时，我们需要使用 `JSON.parse_string()` 方法将响应数据从 JSON 格式反序列化为字典对象。让我们将其存储在一个名为
    `response` 的变量中：
- en: '[PRE8]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Check the `response` dictionary for the presence of an authentication token
    using the `in` operator. If the `"token"` string is present, store its value in
    `AuthenticationCredentials.session_token`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `in` 操作符检查 `response` 字典中是否存在认证令牌。如果存在 `"token"` 字符串，将其值存储在 `AuthenticationCredentials.session_token`
    中：
- en: '[PRE9]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After that, we can also store the `user` present in the message we got from
    the server as our player’s username:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们还可以将我们从服务器收到的消息中存在的 `user` 存储为玩家的用户名：
- en: '[PRE10]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Update the user interface to indicate a successful authentication, and switch
    to the `AvatarScreen.tscn` scene. If the token is not present, display an error
    message to the player:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新用户界面以指示成功认证，并切换到 `AvatarScreen.tscn` 场景。如果令牌不存在，向玩家显示错误消息：
- en: '[PRE11]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, after all that, we can change the scene to the actual avatar screen using
    the `get_tree().change_scene_to_file("res://AvatarScreen.tscn")` method and break
    the `while` loop:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在所有这些之后，我们可以使用 `get_tree().change_scene_to_file("res://AvatarScreen.tscn")`
    方法将场景更改为实际的头像屏幕，并中断 `while` 循环：
- en: '[PRE12]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In case we get a response from the server, and it doesn’t have the `"token"`
    key in it, we display an authentication failed message using the `error_label.text`
    and also break the `while` loop:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们从服务器收到响应，但其中不包含 `"token"` 键，我们将使用 `error_label.text` 显示认证失败消息，并中断 `while`
    循环：
- en: '[PRE13]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At this point, the `send_credentials()` method should look like this:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到这一点，`send_credentials()` 方法应该看起来像这样：
- en: '[PRE14]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we’ve seen how the client side works and what it will do with players’
    data, let’s understand how the other side of this connection will receive this
    data and handle it. For that, open the `Server.tscn` scene.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了客户端的工作原理以及它将如何处理玩家数据，让我们了解连接的另一端将如何接收这些数据并处理它。为此，打开 `Server.tscn` 场景。
- en: Listening to packets with UDPServer
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UDPServer 监听数据包
- en: Welcome to our Godot Engine server scene! This scene is where our game’s server
    logic is implemented.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到我们的 Godot 引擎服务器场景！这个场景是我们游戏服务器逻辑的实现之处。
- en: 'The server is the backbone of our game, responsible for authenticating players
    and providing them with data about their avatars, such as their name and texture
    file. This node is called `Server`, and it has a pre-written script that includes
    some essential variables. Among them are two vital variables: `database_file_path`
    and `logged_users`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器是我们游戏的骨架，负责验证玩家并向他们提供有关其头像的数据，例如他们的名字和纹理文件。这个节点被称为 `Server`，它包含一个预写的脚本，其中包含一些基本变量。其中两个至关重要的变量是
    `database_file_path` 和 `logged_users`。
- en: The `database_file_path` variable is the path to the `FakeDatabase` JSON file,
    which represents a fake database that holds the players’ data. The `logged_users`
    variable is a dictionary that stores players who are currently logged in.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`database_file_path` 变量是 `FakeDatabase` JSON 文件的路径，它代表一个包含玩家数据的假数据库。`logged_users`
    变量是一个字典，用于存储当前登录的玩家。'
- en: These variables are crucial to our server’s functionality, and we will use them
    to authenticate players and provide them with the data they need.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量对我们服务器的功能至关重要，我们将使用它们来验证玩家并向他们提供他们所需的数据。
- en: 'Let’s implement the `Server` node’s most important feature, which is to listen
    to packets. Proceed as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现 `Server` 节点最重要的功能，即监听数据包。按照以下步骤进行：
- en: Open the `Server.gd` file.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Server.gd` 文件。
- en: 'Declare a `server` variable and set it to `UDPServer.new()`. This creates a
    new instance of the `UDPServer` class that will allow us to listen to incoming
    connections:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `server` 变量并将其设置为 `UDPServer.new()`。这创建了一个新的 `UDPServer` 类实例，它将允许我们监听传入的连接：
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the `_ready()` function, call the `listen()` method on the `server` variable,
    passing our default `PORT` constant as an argument. This will start the server
    and make it listen for incoming connections:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_ready()` 函数中，调用 `server` 变量的 `listen()` 方法，并将我们的默认 `PORT` 常量作为参数传递。这将启动服务器并使其监听传入的连接：
- en: '[PRE16]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `_process(delta)` function, call the `poll()` method on the `server`
    variable to check for any incoming messages. This method will not block the game
    loop, so we can call it in the `_process(delta)` function safely:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_process(delta)` 函数中，调用 `server` 变量的 `poll()` 方法来检查是否有任何传入的消息。此方法不会阻塞游戏循环，因此我们可以在
    `_process(delta)` 函数中安全地调用它：
- en: '[PRE17]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Call the `is_connection_available()` method on the `server` variable to check
    whether a client sent a message. If it returns `true`, call the `take_connection()`
    method to obtain a `PacketPeerUDP` instance that we can use to read the incoming
    message:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `server` 变量上调用 `is_connection_available()` 方法来检查是否有客户端发送了消息。如果它返回 `true`，则调用
    `take_connection()` 方法以获取一个 `PacketPeerUDP` 实例，我们可以用它来读取传入的消息：
- en: '[PRE18]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use the `get_var()` method on the `PacketPeerUDP` instance we get to obtain
    the incoming message. Since we know that the message is a string in JSON format,
    we can use the `JSON.parse_string()` method to convert it to a dictionary object
    that we can work with:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们从 `PacketPeerUDP` 实例获得的 `get_var()` 方法来获取传入的消息。由于我们知道消息是 JSON 格式的字符串，我们可以使用
    `JSON.parse_string()` 方法将其转换为我们可以工作的字典对象：
- en: '[PRE19]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Check whether the incoming message contains the `"authenticate_credentials"`
    key. If it does, call the `authenticate_player()` function, passing `peer` and
    `message` as arguments:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查传入的消息是否包含 `"authenticate_credentials"` 键。如果包含，则调用 `authenticate_player()`
    函数，并将 `peer` 和 `message` 作为参数传递：
- en: '[PRE20]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will create the `authenticate_player()` method in a moment, but for now,
    our script should look like this:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在稍后创建 `authenticate_player()` 方法，但就目前而言，我们的脚本应该看起来像这样：
- en: '[PRE21]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We just saw how we can open a communication channel between the client and the
    server and start to listen to messages. With that, we can filter these messages
    so that the server knows what the client is requesting—in our case, to authenticate
    the players’ credentials.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何打开客户端和服务器之间的通信通道并开始监听消息。有了这个，我们可以过滤这些消息，以便服务器知道客户端正在请求什么——在我们的案例中，是验证玩家的凭证。
- en: This is a low-level implementation of a network API. With that, we can create
    standard message formats and contents that trigger events on the server side and
    expect standard responses from the server. Let’s see how our server replies to
    this client request.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个网络 API 的低级实现。有了这个，我们可以创建标准消息格式和内容，在服务器端触发事件，并期望从服务器获得标准响应。让我们看看我们的服务器如何回应这个客户端请求。
- en: Authenticating the player
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证玩家
- en: Authenticating player credentials is a crucial aspect of any multiplayer game.
    In our project, we are building a login system for a game using Godot Engine.
    The login system allows players to log in with their username and password and
    then displays their character’s avatar upon successful login.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 验证玩家凭证是多玩家游戏的一个关键方面。在我们的项目中，我们正在使用 Godot 引擎构建一个游戏的登录系统。该登录系统允许玩家使用他们的用户名和密码登录，并在登录成功后显示他们的角色头像。
- en: We are going to use a fake database, stored as a JSON file, to represent the
    players’ credentials. While this approach is simpler than using a full-fledged
    database management system, it has its own security risks. So, be aware of the
    risks of this approach in a production-ready project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个假数据库，以 JSON 文件的形式存储，来表示玩家的凭证。虽然这种方法比使用完整的数据库管理系统更简单，但它有自己的安全风险。因此，在准备就绪的项目中，请注意此方法的风险。
- en: To authenticate player credentials in our project, we will also use Godot’s
    `FileAccess` class to load the fake database from the JSON file and parse the
    data. This will allow us to compare players’ login credentials with the data in
    the database and authenticate the player if the credentials match.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中验证玩家凭证时，我们还将使用 Godot 的 `FileAccess` 类从 JSON 文件加载假数据库并解析数据。这将允许我们比较玩家的登录凭证与数据库中的数据，并在凭证匹配时验证玩家。
- en: Loading a fake database
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载假数据库
- en: Now, let’s load our database so that we can check whether the data we got from
    the player’s client matches anything on our server. In a nutshell, a database
    is an organized collection of data. In our case, we’ll use a JSON file format
    as our database.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们加载我们的数据库，以便我们可以检查从玩家客户端获取的数据是否与服务器上的任何数据匹配。简而言之，数据库是有组织的数据集合。在我们的案例中，我们将使用
    JSON 文件格式作为我们的数据库。
- en: The advantage of using JSON files as databases is that they are easy to manipulate,
    and you don’t need to have prior knowledge of database structures and safety.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JSON文件作为数据库的优势在于它们易于操作，并且您不需要具备数据库结构和安全性的先验知识。
- en: 'For instance, our fake database consists of the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的模拟数据库由以下内容组成：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can even open it in the very Godot Text Editor itself; just double-click
    the `res://FakeDatabase.json` file provided in our base project.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以在Godot文本编辑器中打开它；只需双击我们基础项目中提供的`res://FakeDatabase.json`文件。
- en: The preceding JSON file represents a simple database that contains two user
    entries, `"user1"` and `"user2"`, each with a corresponding set of data. The data
    contained for each user includes a password, an avatar, and a name.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的JSON文件代表一个简单的数据库，包含两个用户条目，`"user1"`和`"user2"`，每个用户都有相应的一组数据。每个用户包含的数据包括密码、头像和姓名。
- en: The `"password"` field holds the plain-text password for each user. This is
    a very simple approach to storing passwords, as it is not secure due to the possibility
    of it being compromised. However, it is suitable for educational purposes.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`"password"`字段包含每个用户的纯文本密码。这是一种非常简单的存储密码的方法，因为它不安全，因为可能被泄露。然而，它适合教育目的。'
- en: The `"avatar"` field contains a reference to a file that represents the user’s
    avatar. In this case, it is referencing two different image files from our game,
    one for each user.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`"avatar"`字段包含一个指向表示用户头像的文件的引用。在这种情况下，它引用了我们游戏中的两个不同的图像文件，每个用户一个。'
- en: Finally, the `"name"` field simply holds a string that represents the player’s
    avatar name.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`"name"`字段简单地存储了一个表示玩家头像名称的字符串。
- en: Note that a database file shouldn’t by any means be available to the client.
    So, in your final project, make sure to remove your database file from Godot’s
    project and into a safe database device.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，数据库文件绝对不应该对客户端可用。因此，在您的最终项目中，请确保将数据库文件从Godot的项目中移除，并放入一个安全的数据库设备中。
- en: 'While JSON files are a great choice for certain projects, they may not be suitable
    for others. Here are some pros and cons to consider:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JSON文件对于某些项目来说是一个很好的选择，但它们可能不适合其他项目。以下是一些需要考虑的优点和缺点：
- en: '**Pros**:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：'
- en: They are easy to read and write, making them a great choice for small projects
    or when the speed of development is a priority
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们易于读写，这使得它们成为小型项目或开发速度优先时的理想选择。
- en: JSON files can be parsed natively by most programming languages, including GDScript
    as we saw previously, which means you don’t need to install any additional software
    or libraries to work with them
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON文件可以被大多数编程语言原生解析，包括我们之前看到的GDScript，这意味着您不需要安装任何额外的软件或库来与之工作。
- en: As we just saw, JSON files are human-readable and can be opened and edited using
    a simple text editor, which makes them great for debugging
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，JSON文件是可读的，可以使用简单的文本编辑器打开和编辑，这使得它们非常适合调试。
- en: '**Cons**:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：'
- en: They don’t scale well for large projects with many concurrent users, as there
    may be issues with data consistency and performance
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不适合大型项目，特别是有大量并发用户的项目，因为可能存在数据一致性和性能问题。
- en: JSON files are not as flexible as other database formats when it comes to querying
    data and performing complex operations
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON文件在查询数据和执行复杂操作方面不如其他数据库格式灵活。
- en: To load and read the data from our JSON fake database file, we’ll use Godot
    Engine’s `FileAccess` class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载和读取我们的JSON模拟数据库文件中的数据，我们将使用Godot引擎的`FileAccess`类。
- en: The `FileAccess` class is a built-in Godot class that provides an interface
    to load, read, write, and save files to and from the user’s disk. It is a powerful
    tool that is essential for any game or application that needs to access files
    from the user’s device.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileAccess`类是一个内置的Godot类，它提供了一个接口来加载、读取、写入和保存文件到用户的磁盘。它是一个强大的工具，对于任何需要从用户设备访问文件的游戏或应用程序来说都是必不可少的。'
- en: 'Let’s dive into the specifics of how to use this class to load and parse our
    JSON fake database file into our game, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们具体探讨如何使用这个类将我们的JSON模拟数据库文件加载并解析到游戏中，如下所示：
- en: Go to the `load_database()` function in the `Server.gd` script.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`Server.gd`脚本中的`load_database()`函数。
- en: 'In the function, create a new instance of the `FileAccess` class by calling
    the `open` method and passing in the path to the JSON file as the first argument
    and `FileAccess.READ` as the second argument. The `READ` constant tells the `FileAccess`
    class that the file should be opened for reading:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数中，通过调用`open`方法并传入JSON文件的路径作为第一个参数，以及`FileAccess.READ`作为第二个参数来创建`FileAccess`类的新实例。`READ`常量告诉`FileAccess`类文件应该以读取模式打开：
- en: '[PRE23]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the file is open, call the `get_as_text()` method to read the contents
    of the file as a text string:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件打开后，调用`get_as_text()`方法以读取文件的内容作为文本字符串：
- en: '[PRE24]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, parse the contents of the file as a JSON string using the `JSON.parse_string()`
    method and store the resulting dictionary in the `fake_database` variable:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`JSON.parse_string()`方法解析文件的正文作为JSON字符串，并将结果字典存储在`fake_database`变量中：
- en: '[PRE25]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Before we move on to replying to the player’s authentication request, let’s
    see how this function looks at the end of these steps:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们继续回复玩家的认证请求之前，让我们看看这个函数在这些步骤结束时的样子：
- en: '[PRE26]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With our database in place, we can look at our valid players and check whether
    the credentials we receive in the message sent by the client match the credentials
    we have stored. Ideally, we would use a safer format to avoid any data leaks or
    hack attacks, but this should do for our small application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据库就绪后，我们可以查看我们的有效玩家，并检查客户端发送的消息中接收到的凭证是否与我们存储的凭证匹配。理想情况下，我们会使用更安全的格式来避免任何数据泄露或黑客攻击，但这对我们的小型应用程序来说应该足够了。
- en: Now, let’s see how we can reply to the client with a valid response based on
    whether the player was successfully authenticated or if the authentication failed.
    In the former case, we will provide an authentication token to the player so that
    they can use it across their play session in order to keep them logged in without
    further authentication procedures.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何根据玩家是否成功认证或认证失败来向客户提供一个有效的响应。在前一种情况下，我们将向玩家提供一个认证令牌，以便他们可以在整个游戏会话中使用它，从而无需进一步的认证程序来保持他们登录状态。
- en: Replying to the authentication request
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回复认证请求
- en: When a client sends their credentials to the server to be authenticated, the
    server will receive them and start the authentication process. The server will
    use the credentials to search in our fake database, which contains user data,
    for a matching record. If the credentials match, the server will generate a session
    token and send it back to the client.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端将凭证发送到服务器进行认证时，服务器将接收它们并开始认证过程。服务器将使用凭证在我们的包含用户数据的假数据库中搜索匹配的记录。如果凭证匹配，服务器将生成会话令牌并将其发送回客户端。
- en: A session token is a unique string of characters that identifies the client
    on the server side, and the client must present it on all subsequent requests
    to the server to prove their identity.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 会话令牌是一串唯一的字符，用于在服务器端标识客户端，客户端必须在所有后续请求中出示它以证明其身份。
- en: To validate credentials, we call the `load_database` function, which we can
    do in the `_ready()` function to load the fake database into our server.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证凭证，我们调用`load_database`函数，我们可以在`_ready()`函数中这样做，将假数据库加载到我们的服务器中。
- en: Then, we will use the username that the player provided through the `logged_users`
    dictionary, along with the username, to keep track of the authenticated users.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用玩家通过`logged_users`字典提供的用户名，以及用户名，来跟踪已认证的用户。
- en: If a client tries to use an invalid or expired session token, the server will
    deny the request, and the client will need to authenticate again. This way, we
    can ensure that only authenticated clients have access to the server’s resources
    as they play.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端尝试使用无效或过期的会话令牌，服务器将拒绝请求，客户端将需要重新认证。这样，我们可以确保只有已认证的客户端在玩游戏时才能访问服务器的资源。
- en: 'Now, let’s move on to the `authenticate_player()` function and create our authentication
    logic. Proceed as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到`authenticate_player()`函数，并创建我们的认证逻辑。按照以下步骤进行：
- en: 'Access the `authenticate_credentials` key from the `message` dictionary and
    store it in the `credentials` variable, like so:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`message`字典中访问`authenticate_credentials`键，并将其存储在`credentials`变量中，如下所示：
- en: '[PRE27]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Check whether the `user` and `password` keys are present in the `credentials`
    dictionary by running the following code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下代码来检查`credentials`字典中是否存在`user`和`password`键：
- en: '[PRE28]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the keys are present, extract the values of the `user` and `password` keys
    from the `credentials` dictionary and store them in separate variables:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在键，从`credentials`字典中提取`user`和`password`键的值并将它们存储在单独的变量中：
- en: '[PRE29]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Check whether the `user` key we just stored is present in our `fake_database`
    dictionary keys:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们刚刚存储的`user`键是否存在于我们的`fake_database`字典键中：
- en: '[PRE30]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If the `user` is key present, check whether the `password` key matches the
    one stored in the `fake_database` dictionary:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`user`键存在，检查`password`键是否与存储在`fake_database`字典中的匹配：
- en: '[PRE31]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the `password` key matches, generate a random integer token and store it
    in the `logged_users` dictionary with `user` as the key so that we can always
    check them when necessary:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`password`键匹配，生成一个随机整数令牌并将其存储在以`user`为键的`logged_users`字典中，这样我们就可以在必要时始终检查它们：
- en: '[PRE32]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a dictionary called `response` with a single key-value pair. The key
    is `token` and the value is the `token` variable:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`response`的字典，包含一个键值对。键是`token`，值是`token`变量：
- en: '[PRE33]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Send the `response` dictionary back to the client in JSON format using the
    `peer.put_var()` method:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`peer.put_var()`方法以JSON格式将`response`字典发送回客户端：
- en: '[PRE34]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the password does not match, send an empty string to the client to indicate
    that the authentication failed:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果密码不匹配，向客户端发送一个空字符串以指示认证失败：
- en: '[PRE35]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With that, we should have a method that properly handles and replies to the
    player’s authentication request. Let’s see how it ended up:'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有了这些，我们应该有一个正确处理并回复玩家认证请求的方法。让我们看看它最终是如何完成的：
- en: '[PRE36]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, let’s move on to one important part of this whole process. The player will
    get a request with a token that, as we saw in the *Sending Player’s Credentials*
    section, they will store in the `AuthenticationCredentials` Autoload. So, after
    that, the player’s game will change the scene to **AvatarScreen** and try to request
    their avatar.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续到整个过程中的一个重要部分。玩家将收到一个带有令牌的请求，正如我们在*发送玩家凭据*部分所看到的，他们将在`AuthenticationCredentials`自动加载中存储这个令牌。因此，之后，玩家的游戏将改变场景到**AvatarScreen**并尝试请求他们的头像。
- en: Let’s see how players will be able to keep their session valid throughout this
    process. The following section is fundamental even after the player actually starts
    playing the game. So, stay tuned to understand how we can always ensure the player
    is still holding a valid token.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看玩家将如何在整个过程中保持他们的会话有效。以下部分在玩家实际开始玩游戏后仍然至关重要。所以，请保持关注，了解我们如何始终确保玩家持有有效的令牌。
- en: Maintaining the player’s session
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维持玩家的会话
- en: One of the most important aspects of any online game is keeping the player’s
    session alive throughout their playtime. In our project, we are going to make
    sure that the player’s token is available throughout the whole game session, even
    when changing between different scenes. This way, we can maintain the player’s
    identity as they play the game.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在线游戏最重要的一个方面是保持玩家的会话在整个游戏过程中活跃。在我们的项目中，我们将确保玩家的令牌在整个游戏会话中都是可用的，即使在切换到不同的场景时也是如此。这样，我们可以在玩家玩游戏时保持他们的身份。
- en: To achieve this, we will store the token on the player’s machine using the `AuthenticationCredentials`
    singleton. This way, the player’s token will be available to all the game’s scripts,
    allowing us to check whether the player is still authenticated before proceeding
    to any other scene.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用`AuthenticationCredentials`单例在玩家的机器上存储令牌。这样，玩家的令牌将可供所有游戏脚本使用，使我们能够在进行任何其他场景之前检查玩家是否仍然处于认证状态。
- en: By keeping the token on the player’s machine, we can avoid constant login requests
    to the server to authenticate the player again, ensuring faster and smoother gameplay.
    To ensure that the player’s credentials are still valid, we will use the `get_authentication_token()`
    method to allow the player’s client to make a request to the server for their
    authentication token.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在玩家的机器上保留令牌，我们可以避免不断向服务器发送登录请求以重新认证玩家，从而确保游戏体验更快更流畅。为了确保玩家的凭据仍然有效，我们将使用`get_authentication_token()`方法允许玩家的客户端向服务器请求他们的认证令牌。
- en: We call this method whenever the player is about to transition to a new scene
    or when a certain amount of time has passed since their last request. This way,
    we can ensure that the player is still authenticated and can proceed with their
    gameplay without any issues.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家即将过渡到新场景或自上次请求以来经过一定时间时，我们调用此方法。这样，我们可以确保玩家仍然处于认证状态，并且可以无任何问题地继续他们的游戏。
- en: 'So, still in the `Server.gd` script, go to the `get_authentication_token()`
    method, and let’s start providing players with what they need to play our game
    moving on! Proceed as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，仍然在 `Server.gd` 脚本中，转到 `get_authentication_token()` 方法，让我们开始为玩家提供他们需要玩我们的游戏所需的东西，继续以下步骤：
- en: 'Inside the `get_authentication_token()` method, let’s extract the user’s information
    from the `message` argument. For that, we can create a new variable called `credentials`
    and assign it the value of the `message` argument:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `get_authentication_token()` 方法内部，让我们从 `message` 参数中提取用户信息。为此，我们可以创建一个名为 `credentials`
    的新变量，并将其赋值为 `message` 参数：
- en: '[PRE37]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, let’s check whether the `credentials` dictionary has a key called `"user"`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们检查 `credentials` 字典中是否有名为 `"user"` 的键：
- en: '[PRE38]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Check whether the `token` key provided by the client matches the stored `token`
    key for the user:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查客户端提供的 `token` 键是否与存储的用户 `token` 键匹配：
- en: '[PRE39]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a variable called `token` to store the `token` key we found in the `logged_users`
    variable. Then, let’s return the user’s authentication `token` key by calling
    the `peer.put_var()` method and passing the JSON-formatted token string so that
    the client receives a response from the server:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `token` 的变量来存储在 `logged_users` 变量中找到的 `token` 键。然后，让我们通过调用 `peer.put_var()`
    方法并传递 JSON 格式的令牌字符串来返回用户的认证 `token` 键，以便客户端从服务器接收响应：
- en: '[PRE40]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Our function should look like this:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的功能应该如下所示：
- en: '[PRE41]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, whenever we need to make any procedure that requires confirmation from
    the server that the player is still in a valid play session, we can call this
    function. But to actually do that, we need to add two lines of code to our server
    so that it understands when the client makes such a request.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论何时我们需要执行任何需要服务器确认玩家仍在有效游戏会话中的程序，我们都可以调用此函数。但为了实际执行，我们需要在我们的服务器中添加两行代码，以便它能够理解客户端何时发出此类请求。
- en: 'In the `_process()` function, we check whether the client is making a request
    for the `authenticate_credentials()` method. Let’s check whether the client is
    making a request for the `get_session_token()` method instead, and if so, we call
    it. The `_process()` function should look like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_process()` 函数中，我们检查客户端是否正在请求 `authenticate_credentials()` 方法。让我们检查客户端是否正在请求
    `get_session_token()` 方法，如果是的话，我们就调用它。`_process()` 函数应该如下所示：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, let’s move on to the final part of our little project, where we are going
    to provide and load the player’s avatar data.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续我们这个小型项目的最后一部分，我们将提供和加载玩家的头像数据。
- en: Loading the player’s avatar
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载玩家的头像
- en: Welcome to **AvatarScreen**! This is where the player will be able to customize
    their avatar appearance and select a unique name in the final version of our (fake)
    game. To display their current available avatar, we need to load the player’s
    avatar data from the database and display it on the screen.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 **AvatarScreen**！这是玩家将能够自定义他们的头像外观并在我们（模拟）游戏的最终版本中选择一个独特名称的地方。为了显示他们当前可用的头像，我们需要从数据库中加载玩家的头像数据并在屏幕上显示它。
- en: 'For that, the `Control` node called `Control` node called **AvatarCard**:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们有一个名为 `Control` 的 `Control` 节点，称为 **AvatarCard**：
- en: '![Figure 2.5 – The AvatarScreen scene’s node hierarchy](img/Figure_02.05_B18527.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – AvatarScreen 场景的节点层次结构](img/Figure_02.05_B18527.jpg)'
- en: Figure 2.5 – The AvatarScreen scene’s node hierarchy
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – AvatarScreen 场景的节点层次结构
- en: The **AvatarCard** node contains a **TextureRect** node to display the avatar’s
    image using a texture file and a **Label** node to display the avatar’s name.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**AvatarCard** 节点包含一个用于使用纹理文件显示头像图像的 **TextureRect** 节点，以及一个用于显示头像名称的 **Label**
    节点。'
- en: 'To load the player’s avatar, we first need to retrieve the path to the image
    file from our fake database, which we previously populated with avatar information.
    So, before we dive into the action in the `Server.gd` script, and let’s work on
    the `get_avatar()` function this time. Proceed as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载玩家的头像，我们首先需要从我们的模拟数据库中检索图像文件的路径，我们之前已经用头像信息填充了这个数据库。因此，在我们深入 `Server.gd`
    脚本中的动作之前，这次让我们专注于 `get_avatar()` 函数。继续以下步骤：
- en: 'Inside the `get_avatar()` function, create a local `dictionary` variable that
    contains the contents of the message:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `get_avatar()` 函数内部，创建一个包含消息内容的本地 `dictionary` 变量：
- en: '[PRE43]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Check whether there’s a `"user"` key present in the `dictionary` variable:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `dictionary` 变量中是否存在 `"user"` 键：
- en: '[PRE44]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we find the `"user"` key in this dictionary, let’s create a local `user`
    variable that is equal to the value of the `user` key in the `dictionary` variable:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在这个字典中找到 `"user"` 键，让我们创建一个本地 `user` 变量，它等于 `dictionary` 变量中 `"user"` 键的值：
- en: '[PRE45]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Check whether the `''token''` key in the `dictionary` variable matches the
    token stored in the `logged_users` dictionary for the user specified by the `user`
    key:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`dictionary`变量中的`'token'`键是否与由`user`键指定的用户存储在`logged_users`字典中的令牌匹配：
- en: '[PRE46]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If this is the case, create a local `avatar` variable that is equal to the
    value of the `''avatar''` key in the `fake_database` dictionary for the user specified
    by the `''``user''` key:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，创建一个本地`avatar`变量，其值等于`fake_database`字典中由`'user'`键指定的用户的`'avatar'`键的值：
- en: '[PRE47]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create a local `nick_name` variable that is equal to the value of the `name`
    key in the `fake_database` dictionary for the user specified by the `user` key:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个本地`nick_name`变量，其值等于`fake_database`字典中由`user`键指定的用户的`name`键的值：
- en: '[PRE48]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a `response` dictionary with the `avatar` and `name` keys and values
    of `avatar` and `nick_name` respectively:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`avatar`和`name`键的`response`字典，其中`avatar`和`nick_name`的值分别对应于`avatar`和`nick_name`：
- en: '[PRE49]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Use the `peer.put_var()` method to send the `response` dictionary as a JSON
    string to the client:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`peer.put_var()`方法将`response`字典作为JSON字符串发送给客户端：
- en: '[PRE50]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With that, we wrapped up our server, so we are ready to move to the `get_avatar()`
    function looks after our work:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样，我们就完成了服务器的封装，因此我们准备好移动到`get_avatar()`函数来继续我们的工作：
- en: '[PRE51]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, let’s open the `AvatarScreen.gd` script so that we can finally display
    our player’s avatar! Go ahead to the `request_authentication()` function because,
    as mentioned before, every time we need to perform operations on the player’s
    data, we need to verify their credentials.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们打开`AvatarScreen.gd`脚本，以便我们最终可以显示玩家的头像！前往`request_authentication()`函数，因为如前所述，每次我们需要对玩家的数据进行操作时，我们都需要验证他们的凭据：
- en: 'Inside the `request_authentication()` function, create a variable called `request`
    that holds a dictionary with the `''get_authentication_token''`, `''user''`, and
    `''token''` keys. The value of `''get_authentication_token''` should be set to
    `true` just so that the server understands the request, while the values of `"user``"`
    and `"token"` should be retrieved from the `AuthenticationCredentials` singleton:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`request_authentication()`函数内部，创建一个名为`request`的变量，它包含一个具有`'get_authentication_token'`、`'user'`和`'token'`键的字典。`'get_authentication_token'`的值应设置为`true`，以便服务器理解请求，而`'user'`和`'token'`的值应从`AuthenticationCredentials`单例中检索：
- en: '[PRE52]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Use `packet` to send this request to the server by encoding the request as
    a JSON string using `JSON.stringify()` and then using the `put_var()` method to
    send it:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`packet`将请求发送到服务器，通过使用`JSON.stringify()`将请求编码为JSON字符串，然后使用`put_var()`方法发送它：
- en: '[PRE53]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Use a `while` loop to wait for a response from the server. Inside the loop,
    create a variable called `data` to store the JSON response from the server, decoded
    using `JSON.parse_string()`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`while`循环等待服务器的响应。在循环内部，创建一个名为`data`的变量来存储服务器返回的JSON响应，使用`JSON.parse_string()`进行解码：
- en: '[PRE54]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Check whether the `data` variable is equal to the `session_token` variable
    stored in the `AuthenticationCredentials` singleton. If it is, call the `request_avatar`
    function and break out of the loop:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`data`变量是否等于存储在`AuthenticationCredentials`单例中的`session_token`变量。如果是，调用`request_avatar`函数并退出循环：
- en: '[PRE55]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'At the end, our `request_authentication()` function should look like this:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们的`request_authentication()`函数应如下所示：
- en: '[PRE56]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It’s finally time to retrieve the player’s avatar data and display their avatar
    so that they can engage in our game world! For that, let’s go to the `request_avatar()`
    function and create the avatar request and creation displaying logic.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在是检索玩家头像数据并显示他们的头像，以便他们可以参与我们的游戏世界的时候了！为此，让我们转到`request_avatar()`函数，创建头像请求和显示逻辑：
- en: 'Inside the `request_avatar()` function, create a dictionary named `request`
    with the `''get_avatar''`, `''token''`, and `"user"` keys and their respective
    values. We get the user and session tokens from the `AuthenticationCredentials`
    Autoload:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`request_avatar()`函数内部，创建一个名为`request`的字典，包含`'get_avatar'`、`'token'`和`"user"`键及其相应的值。我们从`AuthenticationCredentials`
    Autoload获取用户和会话令牌：
- en: '[PRE57]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Use the `packet.put_var()` method to send the `request` dictionary as a JSON-formatted
    string to the server:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`packet.put_var()`方法将`request`字典作为JSON格式的字符串发送到服务器：
- en: '[PRE58]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a `while` loop to wait for the server to respond. Inside the loop, parse
    the response as a dictionary using the `JSON.parse_string` method and store it
    in a variable named `data`:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`while`循环以等待服务器响应。在循环内部，使用`JSON.parse_string`方法将响应解析为字典，并将其存储在名为`data`的变量中：
- en: '[PRE59]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Check whether the dictionary data contains the `"avatar"` key. If it does,
    load the texture of the avatar image from the path in the `"avatar"` key value,
    and set it as the texture of the `texture_rect`. Also, set the value of the `label`
    to the value of the `"name"` key in the `data` dictionary. Finally, exit the `while`
    loop with `break`:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查字典数据是否包含`"avatar"`键。如果包含，则从`"avatar"`键值中的路径加载头像图像的纹理，并将其设置为`texture_rect`的纹理。同时，将`label`的值设置为`data`字典中`"name"`键的值。最后，使用`break`退出`while`循环：
- en: '[PRE60]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We have almost finished our login screen! Before we add the final touch, let’s
    see how the `request_avatar()` method ended up:'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们几乎完成了登录屏幕！在我们添加最后的润色之前，让我们看看`request_avatar()`方法是如何结束的：
- en: '[PRE61]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, the final touch is to add yet another check on the `Server.gd` script
    to handle when we receive an avatar request. So, the `_process()` method should
    become something like this:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，最后的润色是向`Server.gd`脚本添加另一个检查，以处理我们收到头像请求的情况。因此，`_process()`方法应该变成如下所示：
- en: '[PRE62]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: And if we test our game by hitting the **Play** button, or if we test the **MainMenu**
    scene, we can verify that our game is working!
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们通过点击**播放**按钮来测试我们的游戏，或者测试**主菜单**场景，我们可以验证我们的游戏是否正在运行！
- en: 'The first thing we need to do is to select the **Server** button in one of
    the debugging instances:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在一个调试实例中选择**服务器**按钮：
- en: '![Figure 2.6 – Pressing the Server button in the MainMenu scene](img/Figure_02.06_B18527.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 在主菜单场景中按下服务器按钮](img/Figure_02.06_B18527.jpg)'
- en: Figure 2.6 – Pressing the Server button in the MainMenu scene
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 在主菜单场景中按下服务器按钮
- en: 'Then, in another instance, choose **Client**, and it should immediately open
    the **LoginScreen** scene:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在另一个实例中，选择**客户端**，它应该立即打开**登录屏幕**场景：
- en: '![Figure 2.7 – Inserting the player’s username into the client’s LoginScreen
    UserLineEdit](img/Figure_02.07_B18527.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 将玩家的用户名插入到客户端的登录屏幕UserLineEdit中](img/Figure_02.07_B18527.jpg)'
- en: Figure 2.7 – Inserting the player’s username into the client’s LoginScreen UserLineEdit
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 将玩家的用户名插入到客户端的登录屏幕UserLineEdit中
- en: 'Choose one of the users we have available in our fake database and insert their
    credentials:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们假数据库中可用的一个用户，并插入他们的凭证：
- en: '![Figure 2.8 – Inserting the player’s username into the client’s LoginScreen
    PasswordLineEdit](img/Figure_02.08_B18527.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 将玩家的用户名插入到客户端的登录屏幕PasswordLineEdit中](img/Figure_02.08_B18527.jpg)'
- en: Figure 2.8 – Inserting the player’s username into the client’s LoginScreen PasswordLineEdit
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 将玩家的用户名插入到客户端的登录屏幕PasswordLineEdit中
- en: 'As soon as you press the **Login** button with the correct credentials, it
    should load the **AvatarScreen** scene with the respective avatar:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你按下带有正确凭证的**登录**按钮，它应该加载带有相应头像的**头像屏幕**场景：
- en: '![Figure 2.9 – The AvatarScreen scene displaying the player’s avatar after
    a successful authentication](img/Figure_02.09_B18527.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 显示玩家头像的AvatarScreen场景，在成功认证后](img/Figure_02.09_B18527.jpg)'
- en: Figure 2.9 – The AvatarScreen scene displaying the player’s avatar after a successful
    authentication
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 显示玩家头像的AvatarScreen场景，在成功认证后
- en: Congratulations! You’ve made your first login screen with authentication features,
    serializing and deserializing players’ data all across the network. Be proud of
    yourself—this is a great feat!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经制作了第一个带有认证功能的登录屏幕，在整个网络中序列化和反序列化玩家的数据。为自己感到骄傲——这是一项了不起的成就！
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how we can establish a connection between server and
    client using the UDP protocol implementation in Godot Engine’s network API. With
    that, the network peers can open a communication channel and exchange data.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何使用Godot引擎网络API中的UDP协议实现来在服务器和客户端之间建立连接。有了这个，网络对等体可以打开通信通道并交换数据。
- en: Since this implementation works on quite a low-level approach, we saw how we
    can create a simple API for our peers to make, understand, and reply to each other’s
    requests. Depending on the request, it might be necessary to follow a process
    known as serialization, which is how we take relevant information from our game
    state and turn it into a format that we can store and pass around. In our case,
    we saw that JSON format is one of the most common serialization formats.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种实现采用了一种相当低级的方法，我们看到了如何为我们的同伴创建一个简单的API，以便他们可以制作、理解和回复彼此的请求。根据请求的不同，可能需要遵循一个称为序列化的过程，这是我们如何从游戏状态中提取相关信息并将其转换为我们可以存储和传递的格式。在我们的案例中，我们看到了JSON格式是最常见的序列化格式之一。
- en: Using the JSON format, we saw how we can parse our Godot Engine string as JSON
    and also how to turn a JSON file into a dictionary that we can work with more
    efficiently using GDScript.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JSON 格式，我们看到了如何将我们的 Godot 引擎字符串解析为 JSON，以及如何将 JSON 文件转换为字典，这样我们就可以使用 GDScript
    更高效地处理它。
- en: At the end of the chapter, we saw how we can authenticate players’ credentials,
    matching them against a fake database. With successful authentication, we gathered
    players’ data to display their respective avatars based on their data in our database.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾，我们看到了如何验证玩家的凭据，将它们与一个假数据库进行匹配。在成功验证后，我们收集了玩家的数据，根据他们在我们数据库中的数据显示他们各自的头像。
- en: In the next chapter, we are going to add a new complexity level by allowing
    multiple clients to log in to the same server and finally have a shared experience.
    For that, we will create a `Lobby` node that displays all logged players’ names
    and avatars!
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过允许多个客户端登录到同一服务器并最终共享体验来增加一个新的复杂度级别。为此，我们将创建一个显示所有已登录玩家名称和头像的 `Lobby`
    节点！
