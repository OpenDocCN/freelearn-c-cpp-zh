- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Automatically Generating Documentation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动生成文档
- en: Documentation is—without a doubt—an essential part of all projects. Documentation
    conveys information that is not implicitly available to the user. It is a way
    of sharing the intent, functionality, capabilities, and restrictions regarding
    a project and it enables both technical and non-technical people to work on a
    project. However, it is indeed a time-consuming process to write documentation.
    Thus, it is crucial to make use of the tools available for generating documentation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 文档无疑是所有项目中不可或缺的一部分。文档传递的是用户无法直接获得的信息，它是一种分享项目意图、功能、能力和限制的方式，使技术人员和非技术人员都能参与项目的工作。然而，编写文档确实是一个费时的过程。因此，利用现有的工具来生成文档非常重要。
- en: This chapter will show you ways of integrating Doxygen, `dot`, and PlantUML
    into CMake to speed up the documentation process. These tools will let us lessen
    the context switch between code and documentation and ease the maintenance burden
    of documentation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示如何将 Doxygen、`dot` 和 PlantUML 集成到 CMake 中，以加速文档生成过程。这些工具将帮助我们减少代码和文档之间的上下文切换，并减轻文档维护的负担。
- en: 'To understand the skills shared in this chapter, we’ll cover the following
    main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解本章所介绍的技巧，我们将涵盖以下主要内容：
- en: Generating documentation from your code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从代码生成文档
- en: Packaging and distributing documentation with CPack
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CPack 打包和分发文档
- en: Creating dependency graphs of CMake targets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 CMake 目标的依赖图
- en: Let’s begin with the technical requirements.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从技术要求开始。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before you dive further into this chapter, you should have a good grasp of
    the content covered in [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071), *Packaging,
    Deploying, and Installing a CMake Project*, and [*Chapter 5*](B30947_05.xhtml#_idTextAnchor084),
    *Integrating Third-Party Libraries* *and Dependency Management*. The techniques
    that will be used in this chapter are all covered in those two chapters. Additionally,
    it is recommended to obtain this chapter’s example content from [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/tree/main/chapter06](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/tree/main/chapter06).
    All the examples assume that you will be using the development environment container
    provided by the project found at the following link: [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition).
    This is a Debian-like environment that contains all the prerequisites installed
    beforehand. Commands and outputs may differ slightly if a different environment
    is used. If you are not using the provided Docker container, ensure that you have
    installed Doxygen, PlantUML, and Graphviz in your environment. Consult your package
    manager’s index for installation details.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入本章内容之前，你应该对[*第 4 章*](B30947_04.xhtml#_idTextAnchor071)《打包、部署和安装 CMake 项目》和[*第
    5 章*](B30947_05.xhtml#_idTextAnchor084)《集成第三方库和依赖管理》有一个清晰的了解。本章将使用的技术都已在这两章中涵盖。此外，建议从[https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/tree/main/chapter06](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition/tree/main/chapter06)获取本章的示例内容。所有示例都假设你将使用项目提供的开发环境容器，相关链接为：[https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition)。这是一个类似于
    Debian 的环境，已经预先安装了所有必要的依赖。如果使用不同的环境，命令和输出可能会有所不同。如果你没有使用提供的 Docker 容器，请确保你已经在环境中安装了
    Doxygen、PlantUML 和 Graphviz。有关安装详细信息，请查阅你的包管理器索引。
- en: Let’s dive into the realm of documentation by learning ways of generating documentation
    from existing code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过学习如何从现有代码生成文档，来深入了解文档的领域。
- en: Generating documentation from your code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从代码生成文档
- en: Most people, either knowingly or not, structure their software projects in an
    organized way. The organization is a positive side effect of methodologies and
    procedures such as **object-oriented** (**OO**) design, programming language rules,
    personal preference, or habits, or is dictated by project rules. Although rules
    and conventions tend to be boring, adhering to them results in a more understandable
    project structure. When procedures, rules, order, and organization exist, the
    computer can make sense of things. Documentation generation software leverages
    that fact to our benefit.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人，无论是有意识的还是无意识的，都以有组织的方式构建他们的软件项目。这种组织结构是**面向对象**（**OO**）设计、编程语言规则、个人偏好、习惯或项目规则等方法论和程序的积极副作用。尽管规则和约定往往显得枯燥，但遵守它们会导致一个更易理解的项目结构。当程序、规则、秩序和组织存在时，计算机就能理解其中的内容。文档生成软件利用这一点来为我们带来好处。
- en: One of the most prominent tools to generate documentation out of code is Doxygen.
    As a de facto standard for code documentation in C++, it integrates very well
    with CMake. We will learn how we can integrate Doxygen with CMake to automatically
    generate documentation for CMake projects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 生成文档的最显著工具之一是 Doxygen。作为 C++ 中代码文档的事实标准，它与 CMake 的集成非常顺畅。我们将学习如何将 Doxygen 与
    CMake 集成，以自动为 CMake 项目生成文档。
- en: Understanding what Doxygen is
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 Doxygen 是什么
- en: Doxygen is very popular documentation software for C++ projects that allows
    the generation of documentation from code. Doxygen understands C and C++ grammar
    and can see the code structure in a way that a compiler would see it. This allows
    Doxygen to dive into the structure of a software project and look into all class
    definitions, namespaces, anonymous functions, encapsulation, variables, inheritance
    relations, and so on. Doxygen combines this information with inline code documentation
    written by the programmer. The final result is human-readable documentation in
    various formats that is compatible with both online and offline reading.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Doxygen 是一个非常流行的 C++ 项目文档生成软件，它可以从代码中生成文档。Doxygen 理解 C 和 C++ 语法，并能够像编译器一样查看代码结构。这使得
    Doxygen 可以深入了解软件项目的结构，查看所有类定义、命名空间、匿名函数、封装、变量、继承关系等内容。Doxygen 将这些信息与程序员编写的内联代码文档结合起来。最终的结果是兼容在线和离线阅读的各种格式的人类可读文档。
- en: 'In order to be able to make sense of code comments, Doxygen requires comments
    to be in a predefined set of formats. The full documentation of how to create
    code comments that Doxygen can understand can be found here: [https://www.doxygen.nl/manual/docblocks.html](https://www.doxygen.nl/manual/docblocks.html)
    We will be using **Javadoc**-style comments in our examples, which are commonly
    used, but feel free to use whatever suits your personal preference. An example
    Javadoc comment for a C++ function is provided here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够理解代码注释，Doxygen 要求注释必须符合一组预定义的格式。如何创建 Doxygen 可以理解的代码注释的完整文档可以在这里找到：[https://www.doxygen.nl/manual/docblocks.html](https://www.doxygen.nl/manual/docblocks.html)。在我们的示例中，我们将使用**Javadoc**风格的注释，这种注释方式常见，但你可以根据个人偏好选择适合的方式。下面是一个
    C++ 函数的 Javadoc 注释示例：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Doxygen also requires a **Doxyfile**, which essentially contains all the parameters
    of documentation generation, such as output format, excluded file patterns, project
    name, and so on. Because of the sheer number of configuration parameters, configuring
    Doxygen may be intimidating at the start, but fear not—CMake will generate a Doxyfile
    for you too.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Doxygen 还需要一个**Doxyfile**，它本质上包含了所有文档生成的参数，例如输出格式、排除的文件模式、项目名称等。由于配置参数的数量庞大，初始配置
    Doxygen 可能会让人感到畏惧，但不用担心——CMake 也会为你生成一个 Doxyfile。
- en: As we dive further into this chapter, you will start to see the benefits of
    using documentation generation software for your project. Through this, it is
    way easier to keep the documentation consistent with code, and the ability to
    read the code structure also makes graphing easier.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进一步深入本章，你将开始看到为你的项目使用文档生成软件的好处。通过这样做，保持文档与代码的一致性变得更加容易，而且能够查看代码结构也使得绘制图表变得更加简单。
- en: Let’s see how Doxygen and CMake work together.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Doxygen 和 CMake 如何协同工作。
- en: Using Doxygen with CMake
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Doxygen 与 CMake
- en: CMake, being a C++-oriented build system generator, has good support for integrating
    external tools that are commonly used in C++ projects. As you would expect, integrating
    Doxygen with CMake is pretty straightforward. We’ll utilize the `FindDoxygen.cmake`
    module of CMake to integrate Doxygen into our projects. This module is, by default,
    provided by the CMake installation and requires no extra setup.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 作为一个面向 C++ 的构建系统生成器，能够很好地支持集成 C++ 项目中常用的外部工具。正如你所期待的，将 Doxygen 与 CMake
    集成非常简单。我们将使用 CMake 的 `FindDoxygen.cmake` 模块将 Doxygen 集成到我们的项目中。该模块默认由 CMake 安装提供，无需额外的设置。
- en: '`FindDoxygen.cmake` is, as the name suggests, a module package file designated
    to be consumed by the `find_package()` CMake function. Its primary use is locating
    Doxygen in the environment, and also providing some extra utility functions to
    enable documentation generation in a CMake project. To illustrate Doxygen’s abilities,
    we will be following the `Chapter 6` `- Example 01` example for this section.
    Our target is to generate documentation for a simple calculator library along
    with its `README` file. The interface definition of this library looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindDoxygen.cmake`，顾名思义，是一个模块包文件，专门供 `find_package()` CMake 函数使用。它的主要作用是定位环境中的
    Doxygen，并提供一些额外的工具函数以启用 CMake 项目中的文档生成。为了展示 Doxygen 的功能，我们将遵循 `第六章` `- 示例 01`
    的示例。本节的目标是为一个简单的计算器库及其 `README` 文件生成文档。这个库的接口定义如下：'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `calculator` class implements the class interface defined in the `calculator_interface`
    class. It is properly documented in Javadoc format. We will expect Doxygen to
    generate `calculator` and `calculator_interface` classes, together with an inheritance
    diagram. The class definition is in the `calculator.hpp` file and can be found
    under the `include/chapter6/ex01` subdirectory of the `chapter6/ex01_doxdocgen`
    directory. Additionally, we have a Markdown file named `README.md` in the `chapter6/ex01_doxdocgen`
    directory—this contains essential information about the example project’s layout.
    We expect this file to be the main page of the documentation. As our input material
    is ready, let’s start diving into the example further by inspecting the example’s
    `CMakeLists.txt` file, `chapter6/ex01_doxdocgen/CMakeLists.txt`, as usual. The
    `CMakeLists.txt` file begins with finding the Doxygen package, as can be seen
    here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculator` 类实现了在 `calculator_interface` 类中定义的类接口。它已按照 Javadoc 格式进行了适当的文档编写。我们期望
    Doxygen 生成 `calculator` 和 `calculator_interface` 类，并附带继承关系图。类定义位于 `calculator.hpp`
    文件中，位于 `chapter6/ex01_doxdocgen` 目录下的 `include/chapter6/ex01` 子目录中。此外，我们在 `chapter6/ex01_doxdocgen`
    目录下还有一个名为 `README.md` 的 Markdown 文件，其中包含关于示例项目布局的基本信息。我们期望这个文件成为文档的主页。由于我们的输入材料已准备好，让我们像往常一样，继续深入查看示例的
    `CMakeLists.txt` 文件，即 `chapter6/ex01_doxdocgen/CMakeLists.txt` 文件。该 `CMakeLists.txt`
    文件首先查找 Doxygen 包，如下所示：'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `find_package(...)` call will utilize the `FindDoxygen.cmake` module provided
    by the CMake installation to find Doxygen in the environment if present. The `REQUIRED`
    parameter is omitted in order to allow package maintainers to pack the project
    without needing to install Doxygen beforehand, ensuring that Doxygen is detected
    in their environment before proceeding further.. The subsequent lines are setting
    several Doxygen configurations. These configurations will be placed into the Doxyfile
    that will be generated by CMake. Detailed descriptions for each option are listed
    here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_package(...)` 调用将利用 CMake 安装提供的 `FindDoxygen.cmake` 模块来查找环境中是否存在 Doxygen。省略
    `REQUIRED` 参数，目的是允许包维护者打包项目时，无需事先安装 Doxygen，确保在继续之前能够检测到 Doxygen。后续的几行代码设置了几个
    Doxygen 配置。这些配置将被写入由 CMake 生成的 Doxyfile 文件中。每个选项的详细描述如下：'
- en: '`DOXYGEN_OUTPUT_DIRECTORY`: Sets the output directory for Doxygen.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOXYGEN_OUTPUT_DIRECTORY`：设置 Doxygen 的输出目录。'
- en: '`DOXYGEN_GENERATE_HTML`: Instructs Doxygen to emit **HyperText Markup Language**
    (**HTML**) output.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOXYGEN_GENERATE_HTML`：指示 Doxygen 生成 **超文本标记语言** (**HTML**) 输出。'
- en: '`DOXYGEN_GENERATE_MAN`: Instructs Doxygen to emit `MAN` page output.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOXYGEN_GENERATE_MAN`：指示 Doxygen 生成 `MAN` 页面的输出。'
- en: '`DOXYGEN_AUTOLINK_SUPPORT`: Allows Doxygen to automatically link language symbols
    and filenames to relevant documentation pages if available.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOXYGEN_AUTOLINK_SUPPORT`：允许 Doxygen 自动将语言符号和文件名链接到相关的文档页面（如果可用）。'
- en: '`DOXYGEN_HAVE_DOT`: Tells Doxygen the environment has the `dot` command available
    that can be utilized for generating graphs. This will enable Doxygen to enrich
    generated documentation with diagrams such as dependency, inheritance, and collaboration
    diagrams.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOXYGEN_HAVE_DOT`：告诉 Doxygen 环境中有 `dot` 命令可用，可以用来生成图表。这将使 Doxygen 能够通过图表（如依赖图、继承图和协作图）来丰富生成的文档。'
- en: '`DOXYGEN_COLLABORATION_GRAPH`: Tells Doxygen to generate collaboration diagrams
    for classes.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOXYGEN_COLLABORATION_GRAPH`：告诉 Doxygen 为类生成协作图。'
- en: '`DOXYGEN_CLASS_GRAPH`: Tells Doxygen to generate class diagrams for classes.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOXYGEN_CLASS_GRAPH`：告诉 Doxygen 为类生成类图。'
- en: '`DOXYGEN_UML_LOOK`: Instructs Doxygen to generate **Unified Modeling Language**
    (**UML**)-like diagrams.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOXYGEN_UML_LOOK`：指示 Doxygen 生成类似于**统一建模语言**（**UML**）的图表。'
- en: '`DOXYGEN_DOT_UML_DETAILS`: Adds type and parameter information to UML diagrams.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOXYGEN_DOT_UML_DETAILS`：向 UML 图表中添加类型和参数信息。'
- en: '`DOXYGEN_DOT_WRAP_THRESHOLD`: Sets the line wrapping threshold for UML diagrams.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOXYGEN_DOT_WRAP_THRESHOLD`：设置 UML 图表的换行阈值。'
- en: '`DOXYGEN_CALL_GRAPH`: Instructs Doxygen to generate call graphs for functions
    in function documentation.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOXYGEN_CALL_GRAPH`：指示 Doxygen 为函数文档生成调用图。'
- en: '`DOXYGEN_QUIET`: Suppresses Doxygen output generated to **standard** **output**
    (**stdout**).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOXYGEN_QUIET`：抑制生成的 Doxygen 输出到**标准输出**（**stdout**）。'
- en: 'Doxygen’s set of options is pretty extensive and offers a lot more than just
    the options we’ve covered. If you want to customize documentation generation further,
    take a look at a full list of parameters that can be used in Doxyfiles at [https://www.doxygen.nl/manual/config.html](https://www.doxygen.nl/manual/config.html).
    To set any Doxygen option in CMake, prefix the variable name with `DOXYGEN_` and
    set the desired value using `set()`. With that side note written down, let’s go
    back to the example code. The CMake code shown before is followed by the target
    declarations. The following lines of code define a regular static library that
    contains our example code for the documentation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Doxygen 的选项集合非常广泛，提供了比我们所覆盖的选项更多的功能。如果你想进一步自定义文档生成，请查看在 [https://www.doxygen.nl/manual/config.html](https://www.doxygen.nl/manual/config.html)
    上列出的完整参数列表。要在 CMake 中设置任何 Doxygen 选项，请在变量名之前添加 `DOXYGEN_` 前缀，并使用 `set()` 设置所需的值。说完这些附注后，让我们回到示例代码。前面显示的
    CMake 代码后面是目标声明。以下代码行定义了一个常规的静态库，包含我们示例代码的文档：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Subsequently, the following lines of code define an executable that consumes
    the static library target defined before:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，以下代码行定义了一个可执行文件，它使用之前定义的静态库目标：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Lastly, the `doxygen_add_docs(...)` function is called to specify the code
    that we wish to generate documentation from, as can be seen next:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用 `doxygen_add_docs(...)` 函数来指定我们希望生成文档的代码，如下所示：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `doxygen_add_docs(...)` function is a function provided by the `FindDoxygen.cmake`
    module. Its sole purpose is to provide a convenient way to create a CMake target
    for documentation generation without explicitly dealing with Doxygen. The signature
    for the `doxygen_add_docs(...)` function is shown here (non-relevant parameters
    are omitted):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`doxygen_add_docs(...)` 函数是 `FindDoxygen.cmake` 模块提供的一个函数。它的唯一目的是提供一种便捷的方式来创建用于文档生成的
    CMake 目标，而无需显式处理 Doxygen。`doxygen_add_docs(...)` 函数的函数签名如下（非相关参数已省略）：'
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first parameter of the `targetName` function is the name of the documentation
    target. The function will generate a custom target named `targetName`. This target
    will trigger Doxygen and create documentation from the code when built. The next
    list of parameters, `filesOrDirs`, is a list of files or directories that contain
    the code we want to generate from the documentation. The `ALL` parameter is used
    to make CMake’s `ALL` meta-target depend on the documentation target created by
    the `doxygen_add_docs(...)` function, so documentation generation is automatically
    triggered when the `ALL` meta-target is built. Lastly, the `COMMENT` parameter
    is for making CMake print a message to the output when the target is being built.
    `COMMENT` is primarily useful for diagnostic purposes so that we can quickly know
    whether documentation is being generated or not.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`targetName` 函数的第一个参数是文档目标的名称。该函数将生成一个名为 `targetName` 的自定义目标。此目标将在构建时触发 Doxygen，并从代码生成文档。接下来的参数列表
    `filesOrDirs` 是包含我们要生成文档的代码的文件或目录列表。`ALL` 参数用于使 CMake 的 `ALL` 元目标依赖于 `doxygen_add_docs(...)`
    函数创建的文档目标，因此当构建 `ALL` 元目标时，文档生成会自动触发。最后，`COMMENT` 参数用于在构建目标时让 CMake 将一条消息打印到输出中。`COMMENT`
    主要用于诊断目的，帮助我们快速了解文档是否正在生成。'
- en: After this brief introduction of `doxygen_add_docs(...)`, let’s go back to the
    example code and explain what the `doxygen_add_docs(...)` function call does in
    our scenario. It creates a target named `ch6_ex01_doxdocgen_generate_docs`, adds
    `${CMAKE_CURRENT_LIST_DIR}` to the documentation generation directory, requests
    the `ALL` meta-target to depend on it, and specifies a `COMMENT` parameter that
    will be printed when the target is built.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要介绍了 `doxygen_add_docs(...)` 之后，让我们回到示例代码，并解释一下在我们的场景中 `doxygen_add_docs(...)`
    函数调用的作用。它创建了一个名为 `ch6_ex01_doxdocgen_generate_docs` 的目标，将 `${CMAKE_CURRENT_LIST_DIR}`
    添加到文档生成目录，请求 `ALL` 元目标依赖于它，并指定了一个在目标构建时打印的 `COMMENT` 参数。
- en: 'All right—it’s time to test whether this works or not. Go into the `chapter06/`
    directory and configure the project in the `build/` directory with the following
    command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——现在是时候测试这是否有效了。进入 `chapter06/` 目录并使用以下命令在 `build/` 目录中配置项目：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Check the CMake output to see whether the configuration succeeded or not. If
    the configuration was successful, that means CMake succeeded in finding Doxygen
    in the environment. You should be able to see that in the CMake output, as can
    be seen next:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 CMake 输出，以查看配置是否成功。如果配置成功，那就意味着 CMake 成功地在环境中找到了 Doxygen。你应该能在 CMake 输出中看到这一点，具体如下所示：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After a successful configuration, let’s try to build it with the following
    command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 配置成功后，我们尝试使用以下命令构建它：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the build output, you should be able to see that the text we’ve given into
    the `COMMENT` parameter is being printed to the CMake output. This means the documentation
    target is being built and Doxygen is running. Notice that we did not specify a
    `--target` argument to the CMake `build` command, which effectively causes CMake
    to build the `ALL` meta-target. Since we have given the `ALL` argument to the
    `doxygen_add_docs(...)` function, a `ch6_ex01_doxdocgen_generate_docs` target
    is built too. The output of the `build` command should look similar to the output
    given here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建输出中，你应该能够看到我们在 `COMMENT` 参数中输入的文本被打印到 CMake 输出中。这意味着文档目标正在构建，并且 Doxygen 正在运行。注意，我们没有为
    CMake 的 `build` 命令指定 `--target` 参数，这实际上导致 CMake 构建了 `ALL` 元目标。由于我们为 `doxygen_add_docs(...)`
    函数提供了 `ALL` 参数，`ch6_ex01_doxdocgen_generate_docs` 目标也会被构建。`build` 命令的输出应该类似于这里给出的输出：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It seems we have succeeded in building the project and the documentation. Let’s
    inspect the generated documentation in the `${CMAKE_CURRENT_BINARY_DIR}/docs`
    output folder, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经成功构建了项目和文档。让我们检查生成的文档，位于 `${CMAKE_CURRENT_BINARY_DIR}/docs` 输出文件夹中，如下所示：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we can see Doxygen has emitted the `HTML` and `MAN` page output into
    the `html/` and `man/` directories. Let’s inspect the result for each type. To
    inspect the generated `MAN` page, simply type the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 Doxygen 已经将 `HTML` 和 `MAN` 页面输出到 `html/` 和 `man/` 目录中。让我们检查每种类型的结果。要检查生成的
    `MAN` 页面，只需输入以下内容：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To use `man` in the dev container supplied with the repo run, use `sudo unminimize`
    first, as the container image is optimized for size. The command will open the
    Man page and show something like this screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要在仓库提供的开发容器中使用 `man`，首先运行 `sudo unminimize`，因为该容器镜像已针对大小进行了优化。该命令将打开 Man 页面并显示类似于此截图的内容：
- en: '![](img/B30947_06_01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30947_06_01.jpg)'
- en: Figure 6.1 an example man page generated with Doxygen
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 使用 Doxygen 生成的示例手册页
- en: 'Great! Our code comments turned into a Man page. Similarly, let’s inspect the
    HTML output as well. Use a browser of your choice to open the `build/ex01_doxdocgen/docs/html/index.html`
    file, as shown next:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！我们的代码注释变成了手册页。同样，让我们检查 HTML 输出。使用你喜欢的浏览器打开 `build/ex01_doxdocgen/docs/html/index.html`
    文件，如下所示：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will display the main page of your documentation, as shown in the following
    screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示文档的主页，如下所示的截图所示：
- en: '![](img/B30947_06_02.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30947_06_02.jpg)'
- en: Figure 6.2 – The main page of the documentation
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 文档的主页
- en: 'In the preceding screenshot, we can see that Doxygen has rendered the `README.md`
    Markdown file content into the main page. Note that the main page is just provided
    as an example. Doxygen can embed an arbitrary number of Markdown files into generated
    documentation. It even replaces filenames, class names, and function names with
    links to the relevant documentation. This is achieved by Doxygen’s `AUTOLINK`
    feature and the `@ref` Doxygen command. Click on the `calculator` link under the
    `calculator` class. The `calculator` class documentation page should look similar
    to this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，我们可以看到 Doxygen 已经将 `README.md` Markdown 文件的内容渲染到主页中。请注意，主页仅作为示例提供。Doxygen
    可以将任意数量的 Markdown 文件嵌入到生成的文档中。它甚至会将文件名、类名和函数名替换为指向相关文档的链接。这是通过 Doxygen 的 `AUTOLINK`
    功能和 `@ref` Doxygen 命令实现的。点击 `calculator` 类下的 `calculator` 链接。`calculator` 类的文档页面应该如下所示：
- en: '![](img/B30947_06_03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30947_06_03.jpg)'
- en: Figure 6.3 – Generated HTML documentation for the calculator class (basic layout)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 生成的计算器类 HTML 文档（基础布局）
- en: In the preceding screenshot, we can see that Doxygen is aware that the `calculator`
    class inherits from `calculator_interface` and draws an inheritance diagram for
    the `calculator` class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，我们可以看到 Doxygen 知道 `calculator` 类继承自 `calculator_interface`，并为 `calculator`
    类绘制了继承图。
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Doxygen requires the `dot` tool to render diagrams. The `dot` tool is available
    in the Graphviz software package.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Doxygen 需要 `dot` 工具来渲染图表。`dot` 工具包含在 Graphviz 软件包中。
- en: 'Also, the generated diagrams contain function names and encapsulation symbols
    in UML style. Let’s take a look at the detailed member function documentation
    shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，生成的图表包含 UML 风格的函数名称和封装符号。让我们看看下面截图中显示的详细成员函数文档：
- en: '![](img/B30947_06_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30947_06_04.jpg)'
- en: Figure 6.4 – Generated documentation for the div() function of the calculator
    class
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 生成的计算器类 div() 函数文档
- en: 'As we can see in *Figure 6**.3*, Doxygen did a pretty good job of putting the
    contents into a clear, readable layout. If you were reading this API documentation,
    you would be happy. Lastly, let’s navigate to `main.cpp` to look at the documentation
    of `main.cpp` to illustrate what a dependency graph looks like. You can see a
    representation of the documentation page in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在 *图 6.3* 中所见，Doxygen 在将内容排版成清晰、可读的布局方面做得相当不错。如果你在阅读这个 API 文档，你应该会很高兴。最后，让我们导航到
    `main.cpp`，查看 `main.cpp` 的文档，以说明什么是依赖图。你可以在以下截图中看到文档页面的表示：
- en: '![](img/B30947_06_05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30947_06_05.jpg)'
- en: Figure 6.5 – main.cpp documentation page
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – main.cpp 文档页面
- en: 'The dependency graph in the preceding screenshot shows that the `main.cpp`
    file directly depends on `iostream` and `chapter6/ex06/calculator.hpp` and indirectly
    depends on `chapter6/ex06/calculator_interface.hpp` files. It is pretty useful
    to have dependency information available in the documentation. The consumers will
    know exactly what the file dependencies are without having to dive into the code.
    If you scroll down a bit more, you will see a call graph for the `main()` function
    as well, as can be seen in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中显示的依赖图表明，`main.cpp` 文件直接依赖于 `iostream` 和 `chapter6/ex06/calculator.hpp`
    文件，并间接依赖于 `chapter6/ex06/calculator_interface.hpp` 文件。将依赖信息包含在文档中是非常有用的。使用者将准确知道文件依赖关系，而无需深入代码。如果你再往下滚动一点，你会看到
    `main()` 函数的调用图，如下所示的截图所示：
- en: '![](img/B30947_06_06.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30947_06_06.jpg)'
- en: Figure 6.6 – main() function call graph
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – main() 函数调用图
- en: Splendid! We have generated documentation with graphs for our code in two different
    formats with fewer than 20 lines of extra CMake code. How cool is that? Now, with
    that power in your hands, it is hard to find an excuse to avoid documentation.
    But our journey in this chapter is not over yet. The upcoming section will enrich
    our knowledge by teaching us how to embed custom UML diagrams into documentation.
    Let’s go!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们只用了不到 20 行额外的 CMake 代码，就生成了带有图表的文档，支持两种不同的格式。多酷啊！现在，凭借这个功能，要找借口避免文档化就变得很难了。不过，本章的旅程还没有结束。接下来的部分将通过教我们如何将自定义
    UML 图表嵌入文档，进一步丰富我们的知识。让我们继续！
- en: Embedding custom UML diagrams into documentation
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将自定义 UML 图表嵌入文档
- en: 'In the previous section, we learned how to utilize Doxygen to generate diagrams
    and documentation for our CMake project, but not every diagram is inferable from
    the code. We might want to draw custom diagrams to illustrate the elaborate relationships
    of an entity with an external system that is not available in the code context.
    To tackle this, the obvious choice would be somehow making this context available
    in the code or comments to utilize documentation generation again. Well, as could
    be expected, this too is possible with Doxygen. Doxygen allows the embedding of
    PlantUML diagrams into comments, which will enable us to draw any diagram that
    PlantUML supports. But before starting to put PlantUML code in Doxygen comments,
    there’s a small thing that must be taken care of: enabling PlantUML support in
    Doxygen. We have got ourselves a starting point. Let’s roll!'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分，我们学习了如何利用 Doxygen 为我们的 CMake 项目生成图表和文档，但并非每个图表都能从代码中推断出来。我们可能想要绘制自定义图表，以说明一个实体与外部系统之间的复杂关系，而这些关系在代码上下文中是无法体现的。为了解决这个问题，显而易见的选择是将该上下文以某种方式引入到代码或注释中，再次利用文档生成。那么，正如预期的那样，这也是
    Doxygen 可以做到的。Doxygen 允许在注释中嵌入 PlantUML 图表，这将使我们能够绘制任何 PlantUML 支持的图表。但在开始将 PlantUML
    代码放入 Doxygen 注释之前，有一件小事需要处理：在 Doxygen 中启用 PlantUML 支持。我们已经有了一个起点。让我们开始吧！
- en: 'Enabling PlantUML support in Doxygen is pretty easy. Doxygen requires a `PLANTUML_JAR_PATH`
    variable to be set to the location of the `plantuml.jar` file in the environment.
    So, we have to find out where that file is located. To do that, we will use the
    `find_path(...)` CMake function. The `find_path(...)` function is similar to `find_program(...)`,
    except it is designated for locating the path of files instead of program locations.
    So, that means we should be able to locate the path of `plantuml.jar` with `find_path(...)`,
    give this path to Doxygen, and ... profit! Let’s put that theory to the test.
    We will be following `Chapter 6` `- Example 02` for this section. As ever, let’s
    dive into the `CMakeLists.txt` file of the example code, located at the `chapter06/ex02_doxplantuml/CMakeLists.txt`
    path. Let’s start inspecting from the `find_path(...)` call, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Doxygen 中启用 PlantUML 支持非常简单。Doxygen 需要一个 `PLANTUML_JAR_PATH` 变量，该变量必须设置为 `plantuml.jar`
    文件在环境中的位置。因此，我们需要找出该文件的位置。为此，我们将使用 `find_path(...)` CMake 函数。`find_path(...)`
    函数与 `find_program(...)` 类似，不同之处在于它用于定位文件路径，而不是程序位置。也就是说，我们应该能够通过 `find_path(...)`
    找到 `plantuml.jar` 的路径，然后将该路径提供给 Doxygen，接下来就可以……获利了！让我们来验证这个理论。我们将按照 `第 6 章` `-
    示例 02` 来进行这一部分的操作。照例，我们先来查看示例代码的 `CMakeLists.txt` 文件，文件位于 `chapter06/ex02_doxplantuml/CMakeLists.txt`
    路径下。从 `find_path(...)` 调用开始，具体如下：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `find_path(...)` call here, `PLANTUML_JAR_PATH` is the name of the output
    variable. `NAMES` are the filenames that will be searched in the search locations.
    `HINTS` are extra paths in addition to default search locations. These are useful
    for discovering stuff in non-standard locations. Lastly, the `REQUIRED` parameter
    is used for finding `plantuml.jar` a requirement, so CMake will fail and exit
    when `plantuml.jar` cannot be located. The following Doxygen configuration section
    is exactly the same as our previous example, `Chapter 6` `- Example 01`, except
    we are setting `DOXYGEN_PLANTUML_JAR_PATH` to the PlantUML directory path we found
    with the `find_path(...)` call. Also, variables that are not required for this
    example are omitted too. Doxygen should be able to use PlantUML right now. Let’s
    test that with an example PlantUML graph, embedded into the `src/main.cpp` source
    file, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的`find_path(...)`调用中，`PLANTUML_JAR_PATH`是输出变量的名称。`NAMES`是将在搜索位置中查找的文件名。`HINTS`是除默认搜索位置之外的额外路径。这些路径对于在非标准位置发现文件非常有用。最后，`REQUIRED`参数用于将`plantuml.jar`作为一个必需项，因此当找不到`plantuml.jar`时，CMake
    会失败并退出。以下的 Doxygen 配置部分与我们之前的示例《第 6 章 示例 01》完全相同，只不过我们将`DOXYGEN_PLANTUML_JAR_PATH`设置为通过`find_path(...)`调用找到的
    PlantUML 目录路径。此外，未在此示例中需要的变量也被省略了。此时，Doxygen 应该能够使用 PlantUML。让我们通过一个示例 PlantUML
    图表来测试一下，它被嵌入到了 `src/main.cpp` 源文件中，如下所示：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `@startuml` and `@enduml` Doxygen comment keywords are for indicating the
    beginning and the end of a PlantUML diagram, respectively. Regular PlantUML code
    can be placed inside of a `@startuml - @enduml` block. In our example, we have
    a simple system interaction diagram of the application. If everything goes as
    expected, we should see the embedded PlantUML diagram in the `main()` function’s
    documentation. Let’s generate documentation by building the example with the code
    shown here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`@startuml` 和 `@enduml` Doxygen 注释关键词分别用于标示 PlantUML 图表的开始和结束。常规的 PlantUML
    代码可以放在`@startuml - @enduml`块中。在我们的示例中，我们展示了一个应用程序的简单系统交互图。如果一切顺利，我们应该能在`main()`函数的文档中看到嵌入的
    PlantUML 图表。让我们通过构建包含以下代码的示例来生成文档：'
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The documentation for the second example should be built now. Open the generated
    `build/ex02_doxplantuml/docs/html/index.html` HTML documentation with the browser
    of your choice, by running the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例的文档现在应该已经生成。通过运行以下命令，使用你选择的浏览器打开生成的 `build/ex02_doxplantuml/docs/html/index.html`
    HTML 文档：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you scroll down to the main function, you’ll see our UML sequence diagram,
    like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向下滚动到 main 函数，你会看到我们的 UML 时序图，如下所示：
- en: '![](img/B30947_06_07.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30947_06_07.jpg)'
- en: Figure 6.7 – Embedded PlantUML diagram in the main() function documentation
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 嵌入在 main() 函数文档中的 PlantUML 图表
- en: In *Figure 6**.6*, we can see that Doxygen has generated a PlantUML diagram
    and embedded it into the documentation. With that, we’re now able to embed custom
    diagrams into our generated documentation as well. This will allow us to explain
    complicated systems and relationships without having to interact with external
    graphing tools.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 6.6*中，我们可以看到 Doxygen 生成了一个 PlantUML 图表并将其嵌入到了文档中。通过这个功能，我们现在能够将自定义图表嵌入到我们生成的文档中了。这将帮助我们在不需要使用外部绘图工具的情况下，解释复杂的系统和关系。
- en: Now that we have the right tools for generating documentation, it’s time to
    learn how to package and deliver them. In the next section, we will learn about
    ways of delivering documentation, together with the software involved.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了生成文档的正确工具，接下来是学习如何打包和交付这些文档。在接下来的部分，我们将学习文档交付的方式，以及涉及的相关软件。
- en: Packaging and distributing documentation with CPack
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CPack 打包和分发文档
- en: Packaging documentation is no different than packaging software and its artifacts—documentation
    is an artifact of a project, after all. Thus, we will use the techniques we learned
    in [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071), *Packaging, Deploying, and
    Installing a CMake Project*, to package our documentation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 打包文档与打包软件及其构件并没有什么不同——毕竟，文档本身就是项目的一个构件。因此，我们将使用在[*第 4 章*](B30947_04.xhtml#_idTextAnchor071)《打包、部署和安装
    CMake 项目》中学到的技术来打包我们的文档。
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you have not yet read [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071), *Packaging,
    Deploying, and Installing a CMake Project*, it is strongly recommended to do so
    before reading this section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有阅读[*第 4 章*](B30947_04.xhtml#_idTextAnchor071)《打包、部署和安装 CMake 项目》，强烈建议在阅读本节之前先阅读该章节。
- en: 'To illustrate this section, we will return to `Chapter 6` `- Example 01`. We
    will make the documentation we have generated in this example installable and
    packageable. Let’s dive back into the `CMakeLists.txt` file located in the `chapter06/ex01_doxdocgen/`
    folder. With the following code, we will make the `html` and `man` documentation
    installable:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一部分，我们将回到`第6章` `- 示例01`。我们将使我们在这个示例中生成的文档可安装并可打包。让我们重新回到位于`chapter06/ex01_doxdocgen/`文件夹中的`CMakeLists.txt`文件。通过以下代码，我们将使`html`和`man`文档可安装：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Remember that we were using `install(DIRECTORY...)` to install any kind of
    folder while preserving its structure in [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071),
    *Packaging, Deploying, and Installing a CMake Project*? This is exactly what is
    happening here. We are making the generated documentation installable by installing
    `docs/html` and `docs/man` in the default documentation and man page directories
    provided by the `GNUInstallDirs` module. Also, recall that if a thing is installable,
    it means it is also packageable since CMake is able to generate the required packaging
    code from `install(...)` calls. So, let’s include the `CPack` module to enable
    packaging for this example too. The code is illustrated in the following snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前在[*第4章*](B30947_04.xhtml#_idTextAnchor071)中使用`install(DIRECTORY...)`来安装任何类型的文件夹，同时保持其结构吗？*打包、部署和安装
    CMake 项目*？这正是我们在这里所做的。我们通过安装`docs/html`和`docs/man`到`GNUInstallDirs`模块提供的默认文档和man页面目录中，使生成的文档可安装。此外，还要记住，如果某个内容是可安装的，那么它也意味着可以打包，因为
    CMake 可以从`install(...)`调用生成所需的打包代码。所以，让我们也包括`CPack`模块，以便为这个示例启用打包功能。代码在以下片段中展示：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And there we have it! Simple as that. Let’s try building and packaging the
    example project by invoking the following commands:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！就这么简单。让我们尝试通过调用以下命令来构建并打包示例项目：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, let’s summarize what is happening here. We have configured and built the
    `chapter06/` code and invoked CPack to package the project into the `build/pak`
    folder using the generated `CPackConfig.cmake` file. To check whether everything
    is in order, let’s extract the contents of the generated package into the `/tmp/ch6-ex01`
    path by invoking the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们总结一下这里发生了什么。我们已经配置并构建了`chapter06/`代码，并通过调用 CPack 将项目打包到`build/pak`文件夹中，使用了生成的`CPackConfig.cmake`文件。为了检查一切是否正常，我们通过调用以下命令将生成的包的内容提取到`/tmp/ch6-ex01`路径下：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After the extraction completes, the documentation must become available under
    the `/tmp/ch6-ex01/usr/share` path. Since we have used a non-default path, we
    have used the `MANPATH` environment variable to let the `man` command know the
    path of our documentation. Let’s start by checking whether we can access the man
    pages by invoking the `man` command, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 提取完成后，文档应能在`/tmp/ch6-ex01/usr/share`路径下访问。由于我们使用了非默认路径，因此我们使用`MANPATH`环境变量让`man`命令知道我们的文档路径。让我们先检查是否可以通过调用`man`命令访问man页面，如下所示：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `chapter6_ex01_calculator` name is automatically inferred by Doxygen from
    the `chapter6::ex01::calculator` class name. You should be able to see the man
    page output we covered in the previous section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`chapter6_ex01_calculator`的名称是由Doxygen根据`chapter6::ex01::calculator`类名自动推断出来的。你应该能够看到我们在上一节中讨论的man页面输出。'
- en: Up to now, we have learned a great deal about generating and packaging documentation.
    Up next, we will be learning about generating dependency graphs of CMake targets.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了很多关于生成和打包文档的内容。接下来，我们将学习如何生成 CMake 目标的依赖图。
- en: Creating dependency graphs of CMake targets
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 CMake 目标的依赖图
- en: 'In the previous sections, we have been covering the documentation and graphing
    of the software code, but in a large project, we may also need to document and
    visualize the CMake code as well. The relations between CMake targets may be complex,
    and this may make keeping track of all the dependencies hard. Fortunately, CMake
    can again help with this by providing a graph showing all dependencies between
    targets. By calling `cmake --graphviz=my-project.dot /path/to/build/dir`, CMake
    will create files in the DOT language that contain how targets depend on each
    other. The DOT language is a description language for graphs and can be interpreted
    by a multitude of programs, the most famous one being the freely available Graphviz.
    DOT files can be converted to images or even `dot` command-line utility from Graphviz,
    like this: `dot -Tpng filename.dot -``o out.png`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们已经涵盖了软件代码的文档编写和图形化，但在一个大型项目中，我们可能还需要对CMake代码进行文档化和可视化。CMake目标之间的关系可能非常复杂，这可能使得追踪所有依赖关系变得困难。幸运的是，CMake通过提供一个显示所有目标之间依赖关系的图表来帮助我们。通过调用`cmake
    --graphviz=my-project.dot /path/to/build/dir`，CMake将生成包含目标相互依赖关系的DOT语言文件。DOT语言是一种描述图的语言，可以被多种程序解释，其中最著名的是免费的Graphviz。DOT文件可以转换为图像，甚至可以使用Graphviz中的`dot`命令行工具，如下所示：`dot
    -Tpng filename.dot -o out.png`。
- en: 'As [*Chapter 3*](B30947_03.xhtml#_idTextAnchor054) offers more varied targets,
    let’s run this command on the `build` folder for this chapter. This will produce
    an output similar to this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*第3章*](B30947_03.xhtml#_idTextAnchor054)所示，提供了更多的目标，让我们在该章节的`build`文件夹中运行此命令。这将生成类似于以下的输出：
- en: '![](img/B30947_06_08.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B30947_06_08.jpg)'
- en: Figure 6.8 – The project structure of chapter3 visualized with the DOT language
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 使用DOT语言可视化的第3章项目结构
- en: 'Behavior and options can be controlled by the variables provided in `CMakeGraphVizOptions`.
    When creating DOT graphs, CMake will look for a file called `CMakeGraphVizOptions.cmake`
    in the `PROJECT_SOURCE_DIR` and `PROJECT_BINARY_DIR` directories and, if found,
    will use the values provided within. An example of such a config file might look
    like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 行为和选项可以通过`CMakeGraphVizOptions`中提供的变量进行控制。在创建DOT图时，CMake会在`PROJECT_SOURCE_DIR`和`PROJECT_BINARY_DIR`目录中查找名为`CMakeGraphVizOptions.cmake`的文件，如果找到，将使用其中提供的值。这样的配置文件示例如下：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By default, CMake creates dependency graphs for all targets. Setting `GRAPHVIZ_GENERATE_PER_TARGET`
    and `GRAPHVIZ_GENERATE_DEPENDERS` to `FALSE` will reduce the number of files generated.
    A full set of available options can be found in the CMake documentation at [https://cmake.org/cmake/help/latest/module/CMakeGraphVizOptions.html](https://cmake.org/cmake/help/latest/module/CMakeGraphVizOptions.html).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CMake会为所有目标创建依赖图。将`GRAPHVIZ_GENERATE_PER_TARGET`和`GRAPHVIZ_GENERATE_DEPENDERS`设置为`FALSE`将减少生成的文件数量。所有可用选项的完整列表可以在CMake文档中的[https://cmake.org/cmake/help/latest/module/CMakeGraphVizOptions.html](https://cmake.org/cmake/help/latest/module/CMakeGraphVizOptions.html)找到。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we briefly introduced Doxygen and learned how to generate documentation
    from code, as well as how to package generated documentation for deployment. It
    is crucial to have these skills under your belt when it comes to any software
    project. Generating documentation from code greatly reduces the effort for technical
    documentation and has virtually no maintenance cost. From the perspective of a
    software professional, automating deterministic stuff and generating inferable
    information in different representations is most desired. This approach creates
    space and time for other engineering tasks that require more human problem-solving
    skills. Automating tasks reduces the maintenance cost, makes the product more
    stable, and reduces the overall need for human resources. It is a way of converting
    pure human effort to spent electricity by enabling a machine to do the same job.
    Machines are amazingly better at performing deterministic jobs than humans. They
    are never sick, rarely break, and are easily scaled and never tired. Automation
    is a way of harnessing this untamed power.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们简要介绍了 Doxygen，并学习了如何从代码生成文档，以及如何打包生成的文档以便部署。在任何软件项目中，掌握这些技能都是至关重要的。从代码生成文档大大减少了技术文档的工作量，并几乎没有维护成本。作为一名软件专业人士，自动化确定性的任务，并生成可推导的信息以不同的表现形式呈现，是最理想的。这种方法为其他需要更多人工解决问题技能的工程任务创造了时间和空间。自动化任务减少了维护成本，使产品更加稳定，并减少了对人工资源的整体需求。它是一种通过让机器完成相同的工作，将纯粹的人力劳动转化为消耗电力的方式。机器在执行确定性任务方面比人类更优秀。它们永远不会生病，几乎不会损坏，易于扩展且永不疲倦。自动化是一种利用这种未经驯服的力量的方法。
- en: The main orientation of this book is not to teach you how to do things, but
    to teach you how to make a machine work for a particular task. This approach indeed
    requires learning first, but keep in mind that if you are doing a costly operation
    that could be done by a machine manually more than once, you are wasting your
    precious time. Invest in automating things—it is a profitable investment that
    pays for itself quickly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的主要方向不是教你如何做事情，而是教你如何让机器为某个特定任务工作。这种方法确实需要先学习，但请记住，如果你在做一个可以由机器手动完成多次的昂贵操作，那就是在浪费你宝贵的时间。投资于自动化——它是一个快速回报的有利投资。
- en: In the next chapter, we will learn how we can improve our code quality by integrating
    unit testing, code sanitizers, static code analysis, micro-benchmarking, and code
    coverage tools into a CMake project, and of course, we will be automating all
    of this as well.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下章中，我们将学习如何通过将单元测试、代码清理工具、静态代码分析、微基准测试和代码覆盖率工具集成到 CMake 项目中，来提高代码质量，当然，我们也会自动化这些任务。
- en: See you in the next chapter!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下章见！
- en: Questions
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'After completing this chapter, you should be able to answer the following questions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你应该能够回答以下问题：
- en: What is Doxygen?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Doxygen？
- en: What is the easiest way to integrate Doxygen into a CMake project?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Doxygen 集成到 CMake 项目中的最简单方法是什么？
- en: Can Doxygen draw diagrams and graphs? If so, how can we enable this behavior?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Doxygen 能绘制图表和图形吗？如果能，我们如何启用这个功能？
- en: Which Doxygen tags should be used to embed a PlantUML diagram into Doxygen documentation?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用哪些 Doxygen 标签将 PlantUML 图表嵌入 Doxygen 文档中？
- en: Which configuration steps should be taken to enable Doxygen to use PlantUML?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该采取哪些配置步骤来启用 Doxygen 使用 PlantUML？
- en: Given that man/page output is present under the `build/` folder, how can we
    make this documentation installable?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `build/` 文件夹下已有 man/page 输出，如何使这些文档可以安装？
- en: Answers
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Doxygen is the de facto standard of documentation generation tools for C and
    C++ projects.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Doxygen 是 C 和 C++ 项目中文档生成工具的事实标准。
- en: Since CMake already provides a `find` module for Doxygen, this could be done
    by using the `find_package(...)` CMake command.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 CMake 已经提供了一个 `find` 模块来查找 Doxygen，可以通过使用 `find_package(...)` CMake 命令来实现这一点。
- en: Yes—Doxygen can draw graphs given that graphing software such as `dot`, Graphviz,
    and PlantUML is available in the environment. To enable DOT graphing, setting
    `HAVE_DOT` to `TRUE` is sufficient. For PlantUML, `PLANTUML_JAR_PATH` needs to
    be set to the path that contains the `plantuml.jar` file.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的——只要环境中有 `dot`、Graphviz 和 PlantUML 等绘图软件，Doxygen 就可以绘制图形。要启用 DOT 绘图，只需将 `HAVE_DOT`
    设置为 `TRUE`。对于 PlantUML，则需要将 `PLANTUML_JAR_PATH` 设置为包含 `plantuml.jar` 文件的路径。
- en: '`@startuml` and `@enduml`.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@startuml` 和 `@enduml`。'
- en: '`PLANTUML_JAR_PATH` needs to be set to the path that contains the `plantuml.jar`
    file.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PLANTUML_JAR_PATH` 需要设置为包含 `plantuml.jar` 文件的路径。'
- en: With the help of the `install(DIRECTORY)` command.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`install(DIRECTORY)`命令的帮助。
