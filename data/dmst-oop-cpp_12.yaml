- en: '*Chapter 10*: Implementing Association, Aggregation, and Composition'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：实现关联、聚合和组合'
- en: This chapter will continue advancing our knowledge of object-oriented programming
    in C++. We will augment our understanding of object relationships by exploring
    the object-oriented concepts of association, aggregation, and composition. None
    of these OO concepts have direct language support in C++; we will instead learn
    multiple programming techniques to implement these ideas. We will also understand
    which implementation techniques are preferred for various concepts, as well as
    the advantages and pitfalls of various practices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续推进我们对C++面向对象编程的了解。我们将通过探索关联、聚合和组合的面向对象概念来增进我们对对象关系的理解。这些OO概念在C++中没有直接的语言支持；相反，我们将学习多种编程技术来实现这些想法。我们还将了解对于各种概念，哪些实现技术是首选的，以及各种实践的优势和缺陷。
- en: Association, aggregation, and composition occur copiously in OO designs. It
    is crucial to understand how to implement these important object relationships.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关联、聚合和组合在面向对象设计中经常出现。了解如何实现这些重要的对象关系是至关重要的。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding the OO concepts of aggregation and composition, and various implementations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解聚合和组合的OO概念，以及各种实现
- en: Understanding the OO concept of association and its implementation, including
    the importance of back-link maintenance and the utility of reference counting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解关联的OO概念及其实现，包括反向链接维护的重要性和引用计数的实用性
- en: By the end of this chapter, you will understand the OO concepts of association,
    aggregation, and composition, and how to implement these relationships in C++.
    You will also understand many housekeeping approaches necessary to keep these
    relationships up to date, such as reference counting and back-link maintenance.
    Though the concepts are relatively straightforward, you will see why there is
    a substantial amount of bookkeeping required to maintain accuracy for these types
    of object relationships.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您将了解关联、聚合和组合的OO概念，以及如何在C++中实现这些关系。您还将了解许多必要的维护方法，如引用计数和反向链接维护，以保持这些关系的最新状态。尽管这些概念相对简单，但您将看到为了保持这些类型的对象关系的准确性，需要大量的簿记工作。
- en: Let's broaden our understanding of C++ as an OOP language by exploring these
    core object relationships.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过探索这些核心对象关系，让我们扩展对C++作为面向对象编程语言的理解。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The online code for the full program examples can be found at the following
    GitHub URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter10` in a file named `Chp10-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可在以下GitHub链接找到：[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10)。每个完整程序示例都可以在GitHub存储库中找到，位于相应章节标题（子目录）下的文件中，文件名与所在章节编号相对应，后跟破折号，再跟随所在章节中的示例编号。例如，本章的第一个完整程序可以在名为`Chp10-Ex1.cpp`的文件中的子目录`Chapter10`中找到，位于上述GitHub目录下。
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3sag0RY](https://bit.ly/3sag0RY).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的CiA视频可在以下链接观看：[https://bit.ly/3sag0RY](https://bit.ly/3sag0RY)。
- en: Understanding aggregation and composition
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解聚合和组合
- en: The object-oriented concept of aggregation arises in many OO designs. It comes
    up as frequently as inheritance does to specify object relationships. **Aggregation**
    is used to specify Has-A, whole-part, and in some cases, containment relationships.
    A class may contain aggregates of other objects. Aggregation can be broken into
    two categories – *composition* as well as a less strict and *generalized* form
    of aggregation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的聚合概念在许多面向对象设计中出现。它与继承一样频繁，用于指定对象关系。**聚合**用于指定具有-一个、整体-部分以及在某些情况下的包含关系。一个类可以包含其他对象的聚合。聚合可以分为两类——*组合*以及一种不太严格和*泛化*的聚合形式。
- en: Both **generalized aggregation** and **composition** imply a Has-A or whole-part
    relationship. However, the two differ in the existence requirements between the
    two related objects. With generalized aggregation, the objects can exist independently
    from one another; yet with composition, the objects cannot exist without one another.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛化聚合**和**组合**都意味着具有-一个或整体-部分关系。然而，两者在两个相关对象之间的存在要求上有所不同。对于泛化聚合，对象可以独立存在；但对于组合，对象不能没有彼此存在。'
- en: Let's take a look at each variety of aggregation, starting with composition.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看每种聚合的变体，从组合开始。
- en: Defining and implementing composition
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和实现组合
- en: '**Composition** is the most specialized form of aggregation and is often what
    most OO designers and programmers think of when they consider aggregation. Composition
    implies containment, and is most often synonymous with a whole-part relationship
    – that is, the whole entity is composed of one or more parts. The whole *contains*
    the parts. The Has-A relationship will also apply to composition.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合**是聚合的最专业形式，通常是大多数OO设计师和程序员在考虑聚合时所想到的。组合意味着包含，并且通常与整体-部分关系同义——即整体由一个或多个部分组成。整体*包含*部分。具有-一个关系也适用于组合。'
- en: The outer object, or *whole*, can be made up of *parts*. With composition, parts
    do not exist without the whole. Implementation is usually an embedded object –
    that is, a data member of the contained object type. On rare occasions, the outer
    object will contain a pointer or reference to the contained object type; however,
    when this occurs, the outer object will be responsible for the creation and destruction
    of the inner object. The contained object has no purpose without its outer layer.
    Likewise, the outer layer is not *ideally* complete without its inner, contained
    pieces.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 外部对象，或*整体*，可以由*部分*组成。通过组合，部分不存在于整体之外。实现通常是一个嵌入对象 - 也就是说，一个包含对象类型的数据成员。在极少数情况下，外部对象将包含对包含对象类型的指针或引用；然而，当发生这种情况时，外部对象将负责创建和销毁内部对象。包含的对象没有其外层没有目的。同样，外层也不是*理想*的完整，没有内部的，包含的部分。
- en: Let's take a look at a composition example as typically implemented. The example
    will illustrate containment – a `Student` *Has-A(n)* `Id`. More so, we will imply
    that an `Id` is a necessary part of a `Student` and will not exist without a `Student`.
    `Id` objects on their own serve no purpose. `Id` objects simply do not need to
    exist if they are not a part of a primary object that gives them purpose. Likewise,
    you might argue that a `Student` is incomplete without an `Id`, though this is
    a bit subjective! We will implement the *part* using an embedded object within
    the *whole*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个通常实现的组合示例。该示例将说明包含 - `Student` *有一个* `Id`。更重要的是，我们将暗示`Id`是`Student`的一个必要部分，并且没有`Student`就不会存在。`Id`对象本身没有任何目的。如果它们不是给予它们目的的主要对象的一部分，`Id`对象根本不需要存在。同样，您可能会认为`Student`没有`Id`是不完整的，尽管这有点主观！我们将使用嵌入对象在*整体*中实现*部分*。
- en: 'The composition example will be broken into many segments. Though only portions
    of the example are shown, the full program can be found in the following GitHub
    location:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 组合示例将被分成许多部分。虽然只显示了示例的部分，完整的程序可以在以下GitHub位置找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10/Chp10-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10/Chp10-Ex1.cpp)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10/Chp10-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10/Chp10-Ex1.cpp)'
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous code fragment, we have defined an `Id` class. An `Id` will be
    a class that can be contained by other classes needing a fully functional `Id`
    capability. The `Id` will become a *part* of the *whole* objects that may choose
    to contain it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们已经定义了一个`Id`类。`Id`将是一个可以被其他需要完全功能的`Id`的类包含的类。`Id`将成为可能选择包含它的*整体*对象的*部分*。
- en: 'Let''s move onward to build a set of classes that will ultimately contain this
    `Id`. We will start with a class we are familiar with, `Person`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续构建一组最终将包含这个`Id`的类。我们将从一个我们熟悉的类`Person`开始：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous segment of code, we have defined the `Person` class, as we are
    accustomed to describing it. To abbreviate this example, let us assume that the
    accompanying member functions exist as prototyped in the aforementioned class
    definition. You can reference these member functions in the earlier-provided GitHub
    link for the online code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码片段中，我们已经定义了`Person`类，就像我们习惯描述的那样。为了缩写这个示例，让我们假设伴随的成员函数存在于前述的类定义中。您可以在之前提供的GitHub链接中引用这些成员函数的在线代码。
- en: 'Now, let''s define our `Student` class. Though it will contain elements that
    we are accustomed to seeing, `Student` will also contain an `Id`, as an embedded
    object:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义我们的`Student`类。虽然它将包含我们习惯看到的元素，`Student`还将包含一个`Id`，作为一个嵌入对象：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding `Student` class, we routinely notice that `Student` is derived
    from `Person`. As we already know, this means that a `Student` instance will include
    the memory layout of a `Person`, as a `Person` sub-object.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`Student`类中，我们经常注意到`Student`是从`Person`派生的。正如我们已经知道的那样，这意味着`Student`实例将包括`Person`的内存布局，作为`Person`子对象。
- en: However, notice the data member, `Id studentId;`, in the `Student` class definition.
    Here, `studentId` is of type `Id`. It is not a pointer, nor is it a reference
    to an `Id`. Data member `studentId` is an embedded object. This means that when
    a `Student` class is instantiated, not only will the memory from inherited classes
    be included, but also the memory for any embedded objects. We will need to provide
    a means to initialize the embedded object, `studentId`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意`Student`类定义中的数据成员`Id studentId;`。在这里，`studentId`是`Id`类型。它不是指针，也不是对`Id`的引用。数据成员`studentId`是一个嵌入对象。这意味着当实例化`Student`类时，不仅将包括从继承类中继承的内存，还将包括任何嵌入对象的内存。我们需要提供一种初始化嵌入对象`studentId`的方法。
- en: 'Let''s move forward with the `Student` member functions to understand how we
    may initialize, manipulate, and access the embedded object:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续`Student`成员函数，以了解如何初始化，操作和访问嵌入对象：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previously listed member functions of `Student`, let's begin with our
    constructors. Notice in the default constructor we utilize the member initialization
    list (`:`) to specify `studentId("None")`. Because `studentId` is a member object,
    we have the opportunity to select (via the member initialization list) which constructor
    should be used for its initialization. Here, we merely select the one with the
    `Id(const char *)` signature.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Student`的先前列出的成员函数中，让我们从我们的构造函数开始。请注意，在默认构造函数中，我们利用成员初始化列表（`:`）来指定`studentId("None")`。因为`studentId`是一个成员对象，我们有机会选择（通过成员初始化列表）应该用于其初始化的构造函数。在这里，我们仅仅选择具有`Id(const
    char *)`签名的构造函数。
- en: Similarly, in the alternate constructor for `Student`, we use the member initialization
    list to specify `studentId(id)`, which will also select the `Id(const char *)`
    constructor, passing the parameter `id` to this constructor.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在`Student`的替代构造函数中，我们使用成员初始化列表来指定`studentId(id)`，这也将选择`Id(const char *)`构造函数，将参数`id`传递给此构造函数。
- en: The copy constructor for `Student` additionally specifies how to initialize
    the `studentId` member object with the `studentId(ps.studentId)` specification
    in the member initialization list. Here, we simply call the copy constructor for
    `Id`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Student`的复制构造函数还指定了如何使用成员初始化列表中的`studentId(ps.studentId)`来初始化`studentId`成员对象。在这里，我们只是调用了`Id`的复制构造函数。'
- en: In our destructor for `Student`, we do not need to deallocate `studentId`. As
    this data member is an embedded object, its memory will go away when the memory
    for the outer object goes away. Of course, because `studentId` is an object itself,
    its own destructor will first be called before its memory is released. Under the
    hood, the compiler will (covertly) patch in a call to the `Id` destructor for
    `studentId` as the last line of code in the `Student` destructor.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Student`析构函数中，我们不需要释放`studentId`。因为这个数据成员是一个嵌入对象，当外部对象的内存消失时，它的内存也会消失。当然，因为`studentId`本身也是一个对象，它的析构函数会在释放内存之前首先被调用。在幕后，编译器会（隐秘地）在`Student`析构函数的最后一行代码中补充一个对`studentId`的`Id`析构函数的调用。
- en: Lastly, in the previous segment of code, let's notice the call to `studentId.GetId()`
    that occurs in both `Student::Print()` and `Student::GetStudentId()`. Here, the
    embedded object `studentId` calls its own public function `Id::GetId()` to retrieve
    its private data member in the scope of the `Student` class. Because `studentId`
    is private in `Student`, this embedded object may only be accessed within the
    scope of `Student` (that is, member functions of `Student`). However, the addition
    of `Student::GetStudentId()` provides a public wrapper for `Student` instances
    in other scopes to retrieve this information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在前面的代码段中，让我们注意一下`studentId.GetId()`在`Student::Print()`和`Student::GetStudentId()`中的调用。在这里，嵌入对象`studentId`调用它自己的公共函数`Id::GetId()`来检索它在`Student`类作用域内的私有数据成员。因为`studentId`在`Student`中是私有的，所以这个嵌入对象只能在`Student`的作用域内被访问（也就是`Student`的成员函数）。然而，`Student::GetStudentId()`的添加为`Student`实例提供了一个公共的包装器，使得其他作用域中的`Student`实例可以检索这些信息。
- en: 'Finally, let''s take a look at our `main()` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看一下我们的`main()`函数：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the aforementioned `main()` function, we instantiate two `Student` instances,
    `s1` and `s2`. When the memory is created (in this case, on the stack) for each
    `Student`, memory for any inherited classes will also be included as sub-objects.
    Additionally, memory for any embedded objects, such as `Id`, will also be laid
    out as a sub-object within `Student`. The memory for the contained object, or
    *part*, will be allocated along with the allocation for the outer object, or *whole*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的`main()`函数中，我们实例化了两个`Student`实例，`s1`和`s2`。当为每个`Student`创建内存（在这种情况下，是在堆栈上）时，任何继承类的内存也将被包含为子对象。此外，任何嵌入对象的内存，比如`Id`，也将被布置为`Student`的子对象。包含对象或*部分*的内存将与外部对象或*整体*的分配一起分配。
- en: Next, let's notice the access to the contained piece, the embedded `Id` object.
    We start with a call to `s1.GetStudentId()`; `s1` accesses a `Student` member
    function, `GetStudentId()`. That student member function will utilize the member
    object of `studentId` to call `Id::GetId()` on this inner object of type `Id`.
    The member function `Student::GetStudentId()` can implement this desired public
    access by simply returning the value that `Id::GetId()` returns on the embedded
    object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们注意一下对包含的部分，即嵌入的`Id`对象的访问。我们从调用`s1.GetStudentId()`开始；`s1`访问了一个`Student`成员函数`GetStudentId()`。这个学生成员函数将利用`studentId`的成员对象来调用`Id::GetId()`，从而访问`Id`类型的这个内部对象。`Student::GetStudentId()`成员函数可以通过简单地返回`Id::GetId()`在嵌入对象上返回的值来实现这种期望的公共访问。
- en: 'Let''s look at the output for the aforementioned program:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看上述程序的输出：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example details composition with its typical implementation, an embedded
    object. Let's now take a look at a much less used, alternate implementation –
    that of inheritance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子详细介绍了组合及其典型实现，即嵌入对象。现在让我们来看一个使用较少的、替代的实现方式——继承。
- en: Considering an alternate implementation for composition
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑组合的另一种实现方式
- en: It is useful to understand that composition can alternatively be implemented
    using inheritance; however, this is extremely controversial. Remember, inheritance
    is most often used to implement *Is-A and not Has-A* relationships. We briefly
    described using inheritance to implement Has-A relationships in [*Chapter 9*](B15702_09_Final_NM_ePub.xhtml#_idTextAnchor361),
    *Exploring Multiple Inheritance*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 值得理解的是，组合也可以用继承来实现；然而，这是极具争议的。记住，继承通常用于实现*是一个*关系，而不是*有一个*关系。我们在[*第9章*](B15702_09_Final_NM_ePub.xhtml#_idTextAnchor361)中简要描述了使用继承来实现*有一个*关系，即*探索多重继承*。
- en: To recap, you would simply inherit from the *part*, rather than embed the part
    as a data member. When doing so, you no longer need to provide *wrapper* functions
    to the *part*, as we saw in the previous program, with the `Student::GetStudentId()`
    method calling `studentId.GetId()` to provide access to its embedded part. The
    wrapper function was necessary with the embedded object example, as the part (`Id`)
    was private in the whole (`Student`). Programmers could not have accessed the
    private `studentId` data member of `Student` outside the scope of `Student`. Of
    course, member functions of `Student` (such as `GetStudentId()`) can access their
    own class' private data members and in doing so, can implement the `Student::GetStudentId()`
    wrapper function to provide such (safe) access.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你只需从*部分*继承，而不是将部分作为数据成员嵌入。这样做时，你就不再需要为*部分*提供*包装器*函数，就像我们在前面的程序中看到的那样，`Student::GetStudentId()`方法调用`studentId.GetId()`来提供对其嵌入部分的访问。在嵌入对象的例子中，包装器函数是必要的，因为部分（`Id`）在整体（`Student`）中是私有的。程序员无法在`Student`的作用域之外访问`Student`的私有`studentId`数据成员。当然，`Student`的成员函数（如`GetStudentId()`）可以访问它们自己类的私有数据成员，并通过这样做来实现`Student::GetStudentId()`包装器函数，以提供这种（安全的）访问。
- en: Had inheritance been used, the public interface of `Id::GetId()` would have
    been simply inherited as a public interface in `Student`, providing simple access
    without the need to first go through the embedded object explicitly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了继承，Id::GetId()的公共接口将会被简单地继承为Student的公共接口，无需通过嵌入对象显式地进行访问。
- en: Nonetheless, though inheriting a *part* is simple in some ways, it vastly compounds
    multiple inheritance. We know multiple inheritance can provide many potential
    complications. Also, using inheritance, the *whole* can only contain one of each
    *part* – not multiple instances of a *part*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在某些方面继承*部分*很简单，但它大大增加了多重继承的复杂性。我们知道多重继承可能会带来许多潜在的复杂性。此外，使用继承，*整体*只能包含一个*部分*的实例，而不是多个*部分*的实例。
- en: Additionally, implementing a whole-part relationship with inheritance may be
    confusing when one compares the implementation to OO design. Remember, inheritance
    usually means Is-A and not Has-A. For these reasons, the most typical and appreciated
    implementation of an aggregate is through an embedded object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用继承实现整体-部分关系可能会在将实现与OO设计进行比较时产生混淆。请记住，继承通常意味着Is-A而不是Has-A。因此，最典型和受欢迎的聚合实现是通过嵌入对象。
- en: Next, let's move onward to looking at a more general form of aggregation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续看一下更一般形式的聚合。
- en: Defining and implementing a generalized aggregation
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和实现泛化聚合
- en: We have looked at the most commonly used form of aggregation in OO designs,
    that of composition. Most notably, with composition, we have seen that the part
    does not have a reason to exist without the whole. Nonetheless, a more generalized
    (but less common) form of aggregation exists and is sometimes specified in OO
    designs. We will now consider this less-common form of aggregation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过OO设计中最常用的聚合形式，即组合。特别是，通过组合，我们已经看到部分没有理由在没有整体的情况下存在。尽管如此，还存在一种更一般的（但不太常见）聚合形式，并且有时会在OO设计中进行指定。我们现在将考虑这种不太常见的聚合形式。
- en: In a **generalized aggregation**, a *part* may exist without the *whole*. A
    part will be created separately and then attached to the whole at a later point
    in time. When the *whole* goes away, a *part* may then remain to be salvaged for
    use with another outer or *whole* object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在**泛化聚合**中，*部分*可以存在而不需要*整体*。部分将被单独创建，然后在以后的某个时间点附加到整体上。当*整体*消失时，*部分*可能会留下来以供与另一个外部或*整体*对象一起使用。
- en: In a generalized aggregation, the Has-A relationship certainly applies, as does
    the whole-part designation. The difference is that the *whole* object will not
    create nor destroy a *part* sub-object. Consider the straightforward example that
    a `Car` *Has-A(n)* `Engine`. A `Car` object also Has-A set of 4 `Tire` objects.
    The `Engine` or `Tire` objects can be manufactured separately and then passed
    to the constructor of the `Car` to provide these parts to the whole. Yet should
    an `Engine` be destroyed, a new `Engine` can easily be swapped in (using a member
    function), without requiring the entire `Car` to be destroyed and then re-constructed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在泛化聚合中，Has-A关系当然适用，整体-部分的指定也适用。不同之处在于*整体*对象不会创建也不会销毁*部分*子对象。考虑一个简单的例子，汽车*Has-A(n)*发动机。汽车对象还*Has-A*一组4个轮胎对象。发动机或轮胎对象可以单独制造，然后传递给汽车的构造函数，以提供这些部分给整体。然而，如果发动机被销毁，可以轻松地替换为新的发动机（使用成员函数），而无需销毁整个汽车然后重新构建。
- en: A generalized aggregation is equivalent to a Has-A relationship, yet we think
    of this with more flexibility and permanence of the individual parts than we did
    with composition. We consider this relationship as an aggregation simply because
    we wish to equate the objects with a Has-A meaning. The Has-A relationship in
    the `Car`, `Engine`, `Tire` example is strong; the `Engine` and `Tire`s are necessary
    parts, required to make the whole `Car`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 泛化聚合等同于Has-A关系，但我们认为这种关系比组合更灵活，个体部分的持久性更强。我们将这种关系视为聚合，只是因为我们希望赋予对象Has-A的含义。在“汽车”、“发动机”、“轮胎”的例子中，Has-A关系很强；发动机和轮胎是必要的部分，需要组成整个汽车。
- en: Here, implementation typically is with the *whole* containing a pointer (or
    set of pointers) to the *part*(s). It is important to note that the parts will
    be passed into a constructor (or another member function) of the outer object
    to establish the relationship. The critical marker is that the whole will not
    create (nor destroy) the parts. And the parts will never destroy the whole.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，实现通常是*整体*包含指向*部分*（们）的指针。重要的是要注意，部分将被传递到外部对象的构造函数（或其他成员函数）中以建立关系。关键的标志是整体不会创建（也不会销毁）部分。部分也永远不会销毁整体。
- en: Incidentally, the longevity of the individual pieces (and the basic implementation)
    of a generalized aggregation will be similar to our next topic – association.
    Let's move forward to our next section to understand the similarities as well
    as the OO conceptual differences (sometimes subtle) between generalized aggregation
    and association.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，泛化聚合的个体部分的持久性（和基本实现）将类似于我们下一个主题 - 关联。让我们继续前进到我们的下一节，以了解泛化聚合和关联之间的相似之处以及OO概念上的差异（有时是微妙的）。
- en: Understanding associations
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解关联
- en: An **association** models a relationship that exists between otherwise-unrelated
    class types. An association can provide ways for objects to interact to fulfill
    these relationships. Associations are not used for Has-A relationships; however,
    in some cases, there are shades of gray as to whether we're describing a *bona
    fide* Has-A relationship, or if we are merely using the phrase Has-A because it
    sounds appropriate linguistically.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**关联**模拟了存在于否则无关的类类型之间的关系。关联可以提供对象相互作用以实现这些关系的方式。关联不用于Has-A关系；然而，在某些情况下，我们描述的是*真正的*Has-A关系，或者我们只是因为在语言上听起来合适而使用Has-A短语。'
- en: 'Multiplicity for associations exists: one-to-one, one-to-many, many-to-one,
    or many-to-many. For example, a `Student` may be associated with a single `University`,
    and that `University` may be associated with many `Student` instances; this is
    a one-to-many association.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 关联的多重性存在：一对一，一对多，多对一，或多对多。例如，一个`学生`可能与一个`大学`相关联，而那个`大学`可能与许多`学生`实例相关联；这是一对多的关联。
- en: Associated objects have an independent existence. That is, two or more objects
    may be instantiated and exist independently for a portion of the application.
    At some point, one object may wish to assert a dependency or relationship with
    the other object. Later in the application, the associated objects may part ways
    and continue on their own, unrelated paths.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的对象具有独立的存在。也就是说，两个或更多的对象可以在应用程序的某个部分被实例化并独立存在。在应用程序的某个时刻，一个对象可能希望断言与另一个对象的依赖或关系。在应用程序的后续部分，相关的对象可能分道扬镳，继续各自独立的路径。
- en: For example, consider the relationship between a `Course` and an `Instructor`.
    A `Course` is associated with an `Instructor`. A `Course` requires an `Instructor`;
    an `Instructor` is integral to the `Course`. An `Instructor` may be associated
    with many `Course`(s). Yet each part exists independently – one will not create
    nor destroy the other. Instructors may also exist independently without courses;
    perhaps an instructor is taking time to write a book, or is taking a sabbatical,
    or is a professor conducting research.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`课程`和`教师`之间的关系。一个`课程`与一个`教师`相关联。一个`课程`需要一个`教师`；一个`教师`对`课程`是必不可少的。一个`教师`可能与许多`课程`相关联。然而，每个部分都是独立存在的
    - 一个不会创造也不会摧毁另一个。教师也可以独立存在而没有课程；也许一个教师正在花时间写书，或者正在休假，或者是一位进行研究的教授。
- en: In this example, the association is very similar to a generalized aggregation.
    In both cases, the related objects also exist independently. In this case, whether
    one says that `Course` Has-A(n) `Instructor` or that a `Course` has a dependency
    on an `Instructor` can be a shade of gray. You may ask yourself – is it just spoken
    language that makes me choose the wording of Has-A? Do I instead mean that there
    is a necessary link between the two? Perhaps the relationship is an association,
    and its descriptive adornment (to further describe the nature of the association)
    is *teaches*. You may have arguments supporting either choice. For this reason,
    generalized aggregations can be considered specialized types of associations;
    we will see that their implementations are the same, using independently existing
    objects. Nonetheless, we will distinguish a typical association as being a relationship
    between objects that decisively do not support a true Has-A relationship.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，关联非常类似于广义聚合。在这两种情况下，相关的对象也是独立存在的。在这种情况下，无论是说`课程`拥有`教师`还是`课程`对`教师`有依赖都可以是灰色的。你可能会问自己
    - 是不是只是口头语言让我选择了“拥有”的措辞？我是不是指两者之间存在必要的联系？也许这种关系是一种关联，它的描述性修饰（进一步描述关联的性质）是*教*。你可能有支持任何选择的论点。因此，广义聚合可以被认为是关联的专门类型；我们将看到它们的实现是相同的，使用独立存在的对象。尽管如此，我们将区分典型关联作为对象之间明确不支持真正拥有关系的关系。
- en: For example, consider the relationship between `University` and `Instructor`.
    Rather than thinking of this as a Has-A relationship, we may instead consider
    the relationship between the two as that of association; we can think of the adornment
    describing this relationship as *employs*. Likewise, `University` has a relationship
    with many `Student` objects. The association here may be described by the adornment
    *educates*. The distinction can be made that the `University` is made up of `Department`
    objects, `Building` objects, and components of this nature to support any of its
    Has-A relationships through containment, yet its relationships with `Instructor`
    objects, `Student` objects, and so on are made using associations.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`大学`和`教师`之间的关系。我们可以考虑这种关系不是拥有关系，而是关联关系；我们可以认为描述这种关系的修饰是*雇用*。同样，`大学`与许多`学生`对象有关系。这里的关联可以用*教育*来描述。可以区分出`大学`由`系`对象，`楼`对象和这类组件组成，以支持其通过包含的拥有关系，然而它与`教师`对象，`学生`对象等的关系是使用关联来建立的。
- en: Now that we have distinguished typical associations from generalized aggregations,
    let's take a look at how we can implement associations and some of the complexities
    involved.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经区分了典型关联和广义聚合，让我们看看如何实现关联以及涉及的一些复杂性。
- en: Implementing association
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现关联
- en: Typically, an association between two or more objects is implemented using pointers
    or sets of pointers. The *one* side is implemented using a pointer to the associated
    object, whereas the *many* side of the relationship is implemented as a set of
    pointers to the associated objects. A set of pointers may be an array of pointers,
    a linked list of pointers, or truly any collection of pointers. Each type of collection
    will have its own set of advantages and drawbacks. For example, arrays of pointers
    are easy to use, have direct access to specific members, yet have a fixed number
    of items. Linked lists of pointers can accommodate any quantity of items, yet
    accessing a specific element requires traversing past others to find the desired
    item.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，两个或更多对象之间的关联是使用指针或指针集来实现的。*一*方使用指向相关对象的指针来实现，而关系的*多*方则以指向相关对象的指针集合的形式实现。指针集合可以是指针数组，指针链表，或者真正的任何指针集合。每种类型的集合都有其自己的优点和缺点。例如，指针数组易于使用，可以直接访问特定成员，但项目数量是固定的。指针链表可以容纳任意数量的项目，但访问特定元素需要遍历其他元素以找到所需的项目。
- en: Occasionally, a reference may be used to implement the *one* side of an association.
    Recall, a reference must be initialized and cannot at a later date be reset to
    reference another object. Using a reference to model an association implies that
    one instance will be associated with a specific other instance for the duration
    of the primary object's existence. This is extremely restrictive; hence, references
    are used very infrequently to implement associations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，引用可能被用来实现关联的*one*一侧。请记住，引用必须被初始化，并且不能在以后被重置为引用另一个对象。使用引用来建模关联意味着一个实例将与另一个特定实例相关联，而主对象存在期间不能更改。这是非常限制性的；因此，引用很少用于实现关联。
- en: Regardless of the implementation, when the primary object goes away, it will
    not interfere with (that is, delete) the associated object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 无论实现方式如何，当主对象消失时，它都不会影响（即删除）关联的对象。
- en: Let's see a typical example illustrating the preferred implementation of a one-to-many
    association, utilizing a pointer on the *one* side, and a set of pointers on the
    *many* side. In this example, a `University` will be associated with many `Student`
    instances. And, for simplicity, a `Student` will be associated with a single `University`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个典型的例子，说明了首选的一对多关联实现，利用*one*一侧的指针和*many*一侧的指针集合。在这个例子中，一个`University`将与许多`Student`实例相关联。而且，为了简单起见，一个`Student`将与一个`University`相关联。
- en: 'To save space, some portions of this program that are the same as in our last
    example will not be shown; however, the program in its entirety can be found in
    our GitHub as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，本程序中与上一个示例相同的部分将不会显示；但是，整个程序可以在我们的GitHub上找到：
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10/Chp10-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10/Chp10-Ex2.cpp)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10/Chp10-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter10/Chp10-Ex2.cpp)'
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding segment, let's first notice the forward declaration of `class
    Student;`. This declaration will allow our code to reference the `Student` type
    prior to the `Student` class definition. In the `University` class definition,
    we see that there is an array of pointers to `Student`. We also see that the `EnrollStudent()`
    method takes a `Student *` as an argument. The forward declaration enables such
    usage of `Student` prior to its definition.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的段落中，让我们首先注意`class Student;`的前向声明。这个声明允许我们的代码在`Student`类定义之前引用`Student`类型。在`University`类定义中，我们看到有一个指向`Student`的指针数组。我们还看到`EnrollStudent()`方法以`Student
    *`作为参数。前向声明使得在定义之前可以使用`Student`。
- en: We also notice that the `University` has a simple interface with constructors,
    a destructor, and a few member functions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到`University`具有一个简单的接口，包括构造函数、析构函数和一些成员函数。
- en: 'Next, let''s take a look at the `University` member function definitions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下`University`成员函数的定义：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Taking a close look at the preceding `University` methods, we can see that in
    both constructors for `University`, we simply `NULL` out the pointers to the elements
    comprising our `studentBody`. Likewise, in the destructor, we similarly `NULL`
    out our links to the associated `Students`. Shortly, in this section, we will
    see there will be some additional back-link maintenance required, but for now,
    the point is that we will not delete the associated `Student` objects.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察前面的`University`方法，我们可以看到在`University`的两个构造函数中，我们只是将组成`studentBody`的指针`NULL`。同样，在析构函数中，我们也将与关联的`Students`的链接`NULL`。不久，在本节中，我们将看到还需要一些额外的反向链接维护，但现在的重点是我们不会删除关联的`Student`对象。
- en: Since `University` objects and `Student` objects exist independently, neither
    will create nor destroy instances of the other type.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`University`对象和`Student`对象是独立存在的，因此它们之间既不会创建也不会销毁对方类型的实例。
- en: We also come across an interesting member function, `EnrollStudent(Student *)`.
    In this method, a pointer to a specific `Student` will be passed in as an input
    parameter. We merely index into our array of pointers to `Student` objects, namely
    `studentBody`, and set an unused array element to point to the newly enrolled
    `Student`. We keep track of how many current `Student` objects exist using a `currentNumStudents`
    counter, which is incremented with a post increment after the pointer assignment
    to the array is made.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还遇到了一个有趣的成员函数`EnrollStudent(Student *)`。在这个方法中，将传入一个指向特定`Student`的指针作为输入参数。我们只是索引到我们的`Student`对象指针数组`studentBody`中，并将一个未使用的数组元素指向新注册的`Student`。我们使用`currentNumStudents`计数器跟踪当前存在的`Student`对象数量，在指针分配后进行后置递增。
- en: We also notice that `University` has a `Print()` method that prints the university's
    name, followed by its current student body. It does so by simply accessing each
    associated `Student` object in `studentBody` and asking each `Student` instance
    to invoke the `Student::GetFirstName()` and `Student::GetLastName()` methods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注意到`University`有一个`Print()`方法，它打印大学的名称，然后是它当前的学生人数。它通过简单地访问`studentBody`中的每个关联的`Student`对象，并要求每个`Student`实例调用`Student::GetFirstName()`和`Student::GetLastName()`方法来实现这一点。
- en: 'Next, let''s now take a look at our `Student` class definition, along with
    its inline functions. Recall, we''re assuming that the `Person` class is the same
    as seen earlier in this chapter:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下我们的`Student`类定义，以及它的内联函数。请记住，我们假设`Person`类与本章前面看到的一样：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, in the previous code segment, we see the `Student` class definition. Notice
    that we have an association with a `University` with the pointer data member `University
    *univ;`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，我们看到了`Student`类的定义。请注意，我们使用指针数据成员`University *univ;`与`University`关联。
- en: In the class definition for `Student`, we can also see there is a wrapper function
    to encapsulate access to the student's university's name with `Student::GetUniversity()`.
    Here, we allow the associated object, `univ`, to call its public method `University::GetName()`
    and return that value as the result of `Student::GetUniversity()`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Student`的类定义中，我们还可以看到有一个包装函数来封装对学生所在大学名称的访问，即`Student::GetUniversity()`。在这里，我们允许关联对象`univ`调用其公共方法`University::GetName()`，并将该值作为`Student::GetUniversity()`的结果返回。
- en: 'Now, let''s take a look at the non-inline member functions of `Student`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看`Student`的非内联成员函数：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code segment, notice that the default `Student` constructor
    and the destructor both only `NULL` out their link to the `University` object.
    The default constructor has no way to set this link to an existing object, and
    should certainly not create a `University` instance to do so. Likewise, the `Student`
    destructor should not delete the `University` merely because the `Student` object's
    life expectancy is complete.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码段中，请注意默认的`Student`构造函数和析构函数都只将它们与`University`对象的链接`NULL`。默认构造函数无法将此链接设置为现有对象，并且肯定不应该创建`University`实例来这样做。同样，`Student`析构函数不应该仅仅因为`Student`对象的寿命已经结束就删除`University`。
- en: The most interesting part of the preceding code happens in both the alternate
    constructor and copy constructor of `Student`. Let's examine the alternate constructor.
    Here, we establish the link to the associated `University` as well as the back-link
    from the `University` back to the `Student`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中最有趣的部分发生在`Student`的备用构造函数和复制构造函数中。让我们来看看备用构造函数。在这里，我们建立了与关联的`University`的链接，以及从`University`返回到`Student`的反向链接。
- en: In the line of code `this->univ = univ;`, we are assigning the data member,
    `univ` (as pointed to by the `this` pointer), by setting it to point to where
    the input parameter, `univ`, points. Look closely at the previous class definition
    – the identifier for the `University *` is named `univ`. Additionally, the input
    parameter for the `University *` in the alternate constructor is named `univ`.
    We cannot simply assign `univ = univ;` in the body of this constructor. The `univ`
    identifier, which is in the most local scope, is the input parameter, `univ`.
    Assigning `univ = univ;` would set this parameter to itself. Instead, we disambiguate
    the `univ` on the left-hand side of this assignment using the `this` pointer.
    The statement `this->univ = univ;` sets the data member `univ` to the input parameter
    `univ`. Could we merely have renamed the input parameter something different,
    such as `u`? Sure, but it is important to understand how to disambiguate an input
    parameter and data member with the same identifier when the need arises to do
    so.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行`this->univ = univ;`中，我们通过将数据成员`univ`（由`this`指针指向）设置为指向输入参数`univ`指向的位置来进行赋值。仔细看前面的类定义
    - `University *`的标识符名为`univ`。此外，备用构造函数中`University *`的输入参数也被命名为`univ`。我们不能简单地在这个构造函数的主体中赋值`univ
    = univ;`。最本地范围内的`univ`标识符是输入参数`univ`。赋值`univ = univ;`会将该参数设置为自身。相反，我们使用`this`指针来消除赋值左侧的`univ`的歧义。语句`this->univ
    = univ;`将数据成员`univ`设置为输入参数`univ`。我们是否可以简单地将输入参数重命名为不同的名称，比如`u`？当然可以，但重要的是要理解在需要时如何消除具有相同标识符的输入参数和数据成员的歧义。
- en: Now, let's examine the next line of code, `univ->EnrollStudent(this);`. Now
    that `univ` and `this->univ` point to the same object, it does not matter which
    is used to set the back-link. Here, `univ` calls `EnrollStudent()`, which is a
    public member function in the `University` class. No problem, `univ` is of type
    `University`. `University::EnrollStudent(Student *)` expects to be passed a pointer
    to a `Student` to complete the linkage on the `University` side. Luckily, the
    `this` pointer in our `Student` alternate constructor (the scope of the calling
    function) is a `Student *`. `This` is literally the `Student *` that we need to
    create the back-link. Here is another example where the explicit use of the `this`
    pointer is required to complete the task at hand.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看下一行代码`univ->EnrollStudent(this);`。现在`univ`和`this->univ`指向同一个对象，无论使用哪一个来设置反向链接都没有关系。在这里，`univ`调用`EnrollStudent()`，这是`University`类中的一个公共成员函数。没有问题，`univ`的类型是`University`。`University::EnrollStudent(Student
    *)`期望传递一个指向`Student`的指针来完成`University`端的链接。幸运的是，在我们的`Student`备用构造函数中（调用函数的作用域），`this`指针是一个`Student
    *`。`this`就是我们需要创建反向链接的`Student *`。这是另一个需要显式使用`this`指针来完成手头任务的例子。
- en: 'Let''s move forward to our `main()` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进到我们的`main()`函数：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, in the previous code fragment in our `main()` function, we can create
    several independently existing objects, create an association between them, and
    then view that relationship in action.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的`main()`函数中的前面代码片段中，我们可以创建几个独立存在的对象，创建它们之间的关联，然后查看这种关系的实际情况。
- en: First, we instantiate a `University`, namely `u1`. Next, we instantiate three
    `Students`, `s1`, `s2`, and `s3`, and associate each to `University u1`. Note
    that this association can be set when we instantiate a `Student`, or later on,
    for example, if the `Student` class supported a `SelectUniversity(University *)`
    interface to do so.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实例化一个`University`，即`u1`。接下来，我们实例化三个`Students`，`s1`，`s2`和`s3`，并将每个关联到`University
    u1`。请注意，当我们实例化一个`Student`时，可以设置这种关联，或者稍后进行设置，例如，如果`Student`类支持`SelectUniversity(University
    *)`接口来这样做。
- en: We then print out each `Student`, along with the name of the `University` each
    `Student` attends. Then we print out the student body for our `University`, `u1`.
    We notice that the link built between the associated objects is complete in both
    directions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们打印出每个`Student`，以及每个`Student`所就读的`University`的名称。然后我们打印出我们的`University u1`的学生人数。我们注意到，关联对象之间建立的链接在两个方向上都是完整的。
- en: 'Let''s look at the output for the aforementioned program:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看上述程序的输出：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We've seen how easily associations can be set up and utilized between related
    objects. However, a lot of housekeeping will arise from implementing associations.
    Let's move forward to understanding the necessary and related issues of reference
    counting and back-link maintenance, which will help with these housekeeping endeavors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在相关对象之间轻松建立和利用关联。然而，从实现关联中会产生大量的维护工作。让我们继续了解引用计数和反向链接维护的必要和相关问题，这将有助于这些维护工作。
- en: Utilizing back-link maintenance and reference counting
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用反向链接维护和引用计数
- en: In the previous sub-section, we have seen how to implement associations using
    pointers. We've seen how to link an object with a pointer to an object in an associated
    instance. And we've seen how to complete the circular, two-sided relationship
    by establishing a back-link.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的小节中，我们已经看到了如何使用指针来实现关联。我们已经看到了如何使用指向关联实例中的对象的指针来建立对象之间的关系。我们也看到了如何通过建立反向链接来完成循环的双向关系。
- en: However, as is typical for associated objects, the relationships are fluid and
    change over time. For example, the given `Student` body will change quite often
    for a given `University`, or the various `Course` set an `Instructor` will teach
    will change each semester. It will be typical, then, to remove a particular object's
    association to another object, and perhaps associate instead to a different instance
    of that class. But that also means that the associated object must know to remove
    its link to the first-mentioned object. This becomes complicated.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与关联对象一样，关系是流动的，随着时间的推移会发生变化。例如，给定“大学”的“学生”群体会经常发生变化，或者“教师”将在每个学期教授的各种“课程”也会发生变化。因此，通常会删除特定对象与另一个对象的关联，并可能改为与该类的另一个实例关联。但这也意味着关联的对象必须知道如何删除与第一个提到的对象的链接。这变得复杂起来。
- en: For example, consider the `Student` and `Course` relationship. A `Student` is
    enrolled in many `Course` instances. A `Course` contains an association to many
    `Student` instances. This is a many-to-many association. Let's imagine that the
    `Student` wishes to drop a `Course`. It is not enough for a specific `Student`
    instance to remove a pointer to a specific `Course` instance. Additionally, the
    `Student` must let the particular `Course` instance know that the `Student` in
    question should be removed from that `Course`'s roster. This is known as back-link
    maintenance.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，考虑“学生”和“课程”的关系。一个“学生”可以注册多个“课程”实例。一个“课程”包含对多个“学生”实例的关联。这是一种多对多的关联。假设“学生”希望退出一门“课程”。仅仅让特定的“学生”实例移除指向特定“课程”实例的指针是不够的。此外，“学生”必须让特定的“课程”实例知道，应该将相关的“学生”从该“课程”的名单中移除。这被称为反向链接维护。
- en: Consider what would happen in the above scenario if a `Student` were to simply
    `NULL` out its link to the `Course` it was dropping, and do nothing further. The
    `Student` instance in question would be fine. However, the formerly associated
    `Course` instance would still contain a pointer to the `Student` in question.
    Perhaps this would equate to the `Student` receiving a failing grade in the `Course`
    as the `Instructor` still thinks the `Student` in question is enrolled, yet hasn't
    been turning in their homework. In the end, the `Student` has been affected after
    all, with the failing grade.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下，在上述情况下，如果一个“学生”简单地将其与要退出的“课程”的链接设置为`NULL`，然后不再进行任何操作，会发生什么。受影响的“学生”实例将不会有问题。然而，以前关联的“课程”实例仍将包含指向该“学生”的指针。也许这会导致“学生”在“教师”仍然认为该“学生”已注册但没有交作业的情况下获得不及格分数。最终，这位“学生”还是受到了影响，得到了不及格分数。
- en: Remember, with associated objects, one object will not delete the other when
    it is done with the other object. For example, when a `Student` drops a `Course`,
    they will not delete that `Course` – only remove their pointer to the `Course`
    in question (and definitely also handle the required back-link maintenance).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，对于关联的对象，一个对象在完成与另一个对象的交互后不会删除另一个对象。例如，当一个“学生”退出一门“课程”时，他们不会删除那门“课程” - 只是移除他们对相关“课程”的指针（并且肯定也要处理所需的反向链接维护）。
- en: One idea to help us with overall link maintenance is to consider **reference
    counting**. The purpose of reference counting is to keep track of how many pointers
    may be pointing to a given instance. For example, if other objects point to a
    given instance, that instance should not be deleted. Otherwise, the pointers in
    the other object will point to deallocated memory, which will lead to numerous
    run-time errors.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个帮助我们进行整体链接维护的想法是考虑**引用计数**。引用计数的目的是跟踪有多少指针可能指向给定的实例。例如，如果其他对象指向给定的实例，那么该实例就不应该被删除。否则，其他对象中的指针将指向已释放的内存，这将导致大量的运行时错误。
- en: Let's consider an association with multiplicity. Such as the relationship between
    a `Student` and a `Course`. A `Student` should keep track of how many `Course`
    pointers are pointing to the `Student`, that is, how many `Courses` the `Student`
    is taking. A `Student` should not be deleted while various `Courses` point to
    that `Student`. Otherwise, `Courses` will point to deleted memory. One way to
    handle this situation is to check within the `Student` destructor if the object
    (`this`) contains any non-`NULL` pointers to `Courses`. If the object does, it
    then needs to call a method through each of the active `Courses` to request links
    to the `Student` be removed from each such `Course`. After each link is removed,
    the reference counter corresponding to the set of `Course` instances can be decremented.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个具有多重性的关联。比如“学生”和“课程”之间的关系。一个“学生”应该跟踪有多少“课程”指针指向该“学生”，也就是说，该“学生”正在上多少门“课程”。只要有多个“课程”指向该“学生”，就不应该删除该“学生”。否则，“课程”将指向已删除的内存。处理这种情况的一种方法是在“学生”析构函数中检查对象（this）是否包含指向“课程”的非“NULL”指针。如果对象包含这样的指针，那么它需要通过每个活跃的“课程”调用一个方法，请求从每个这样的“课程”中移除对“学生”的链接。在移除每个链接之后，与“课程”实例集对应的引用计数可以递减。
- en: Likewise, the link maintenance should occur in the `Course` class in favor of
    `Student` instances. `Course` instances should not be deleted until all `Student`
    instances enrolled in that `Course` have been notified. Keeping a counter of how
    many `Student` instances point to a particular instance of a `Course` through
    reference counting is helpful. In this example, it is as simple as maintaining
    a variable to reflect the current number of `Student` instances enrolled in the
    `Course`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，链接维护应该发生在`Course`类中，而不是`Student`实例中。在通知所有在该`Course`中注册的`Student`实例之前，不应删除`Course`实例。通过引用计数来跟踪有多少`Student`实例指向`Course`的特定实例是有帮助的。在这个例子中，只需维护一个变量来反映当前注册在`Course`中的`Student`实例的数量就可以了。
- en: We can meticulously conduct link maintenance ourselves, or we may choose to
    use smart pointers to manage the lifetime of an associated object. **Smart pointers**
    can be found in the C++ Standard Library. They encapsulate a pointer (that is,
    wrap a pointer within a class) to add smart features, including reference counting
    and memory management. Because smart pointers utilize templates, which we will
    not cover until [*Chapter 13*](B15702_13_Final_NM_ePub.xhtml#_idTextAnchor486),
    *Working with Templates*, we will just mention their potential utility here.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以自己精心进行链接维护，或者选择使用智能指针来管理关联对象的生命周期。**智能指针**可以在C++标准库中找到。它们封装了一个指针（即在类中包装一个指针）以添加智能特性，包括引用计数和内存管理。由于智能指针使用了模板，而我们直到[*第13章*](B15702_13_Final_NM_ePub.xhtml#_idTextAnchor486)，*使用模板*，我们才会涵盖，所以我们在这里只是提到了它们的潜在实用性。
- en: We have now seen the importance of back-link maintenance and the utility of
    reference counting to fully support associations and their successful implementation.
    Let's now briefly recap the OO concepts we've covered in this chapter – association,
    aggregation, and composition – before moving onward to our next chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了后向链接维护的重要性，以及引用计数的实用性，以充分支持关联及其成功的实现。在继续前进到下一章之前，让我们简要回顾一下本章涵盖的面向对象的概念——关联、聚合和组合。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have pressed forward with our pursuit of object-oriented
    programming by exploring various object relationships – association, aggregation,
    and composition. We have understood the various OO design concepts representing
    these relationships and have seen that C++ does not offer direct language support
    through keywords or specific language features to implement these concepts.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过探索各种对象关系——关联、聚合和组合，继续推进我们对面向对象编程的追求。我们已经理解了代表这些关系的各种面向对象设计概念，并且已经看到C++并没有通过关键字或特定的语言特性直接提供语言支持来实现这些概念。
- en: Nonetheless, we have learned several techniques for implementing these core
    OO relationships, such as embedded objects for composition and generalized aggregation,
    or using pointers to implement association. We have looked at the typical longevity
    of object existence with these relationships, for example, with aggregation, by
    creating and destroying its inner part (through an embedded object, or more rarely
    by allocating and deallocating a pointer member), or through the independent existence
    of associated objects that neither create nor destroy one another. We have also
    looked under the hood at the housekeeping required to implement association, particularly
    those with multiplicity, by examining back-link maintenance and reference counting.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们已经学会了几种实现这些核心面向对象关系的技术，比如使用嵌入对象来实现组合和广义聚合，或者使用指针来实现关联。我们已经研究了这些关系中对象存在的典型寿命，例如通过创建和销毁其内部部分（通过嵌入对象，或者更少见地通过分配和释放指针成员），或者通过相关对象的独立存在，它们既不创建也不销毁彼此。我们还深入研究了实现关联所需的内部工作，特别是那些具有多重性的关联，通过检查后向链接维护和引用计数。
- en: We have added key features to our OOP skills through understanding how to implement
    association, aggregation, and composition. We have seen examples of how these
    relationships may even be more prolific in OO designs than inheritance. By mastering
    these skills, we have completed our core skillset of implementing essential OO
    concepts in C++.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解如何实现关联、聚合和组合，我们已经为我们的面向对象编程技能增添了关键特性。我们已经看到了这些关系在面向对象设计中甚至可能比继承更为常见的例子。通过掌握这些技能，我们已经完成了在C++中实现基本面向对象概念的核心技能组合。
- en: We are now ready to continue to [*Chapter 11*](B15702_11_Final_NM_ePub.xhtml#_idTextAnchor417),
    *Handling Exceptions*, which will begin our quest to expand our C++ programming
    repertoire. Let's continue forward!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备继续到[*第11章*](B15702_11_Final_NM_ePub.xhtml#_idTextAnchor417)，*处理异常*，这将开始我们扩展C++编程技能的探索。让我们继续前进！
- en: Questions
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Add an additional `Student` constructor to the `University`-`Student` example
    in this chapter to accept the `University` constructor argument by reference,
    rather than by pointer. For example, in addition to the constructor with signature
    `Student::Student(const char *fn, const char *ln, char mi, const char *t, float
    avg, const char *course, const char *id, University *univ);`, overload this function
    with a similar one, but with `University &univ` as the last parameter. How does
    this change the implicit call to this constructor?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章的`University`-`Student`示例中添加一个额外的`Student`构造函数，以接受引用而不是指针的`University`构造参数。例如，除了带有签名`Student::Student(const
    char *fn, const char *ln, char mi, const char *t, float avg, const char *course,
    const char *id, University *univ);`的构造函数外，重载此函数，但最后一个参数为`University &univ`。这如何改变对此构造函数的隐式调用？
- en: 'Hint: within your overloaded constructor, you will now need to take the address-of
    (`&`) the `University` reference parameter to set the association (which is stored
    as a pointer). You may need to switch to object notation (`.`) to set the back-link
    (if you use the parameter `univ`, versus the data member `this->univ`).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：在您重载的构造函数中，您现在需要取`University`引用参数的地址（即`&`）来设置关联（存储为指针）。您可能需要切换到对象表示法（`.`）来设置后向链接（如果您使用参数`univ`，而不是数据成员`this->univ`）。
- en: 'Write a C++ program to implement a many-to-many association between objects
    of type `Course` and of type `Student`. You may choose to build on your previous
    programs that encapsulate `Student`. The many-to-many relationship should work
    as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个C++程序来实现“课程”类型对象和“学生”类型对象之间的多对多关联。您可以选择在之前封装“学生”的程序基础上构建。多对多关系应该按以下方式工作：
- en: a. A given `Student` may take zero to many `Course`s, and a given `Course` will
    associate to many `Student` instances. Encapsulate the `Course` class to minimally
    contain a course name, a set of pointers to associated `Student` instances, and
    a reference count to keep track of the number of `Student` instances who are in
    the `Course` (this will equate to how many `Student` instances point to a given
    instance of a `Course`). Add the appropriate interface to reasonably encapsulate
    this class.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: a. 给定的“学生”可以选修零到多门“课程”，而给定的“课程”将与多个“学生”实例关联。封装“课程”类，至少包含课程名称、指向关联“学生”实例的指针集，以及一个引用计数，用于跟踪在“课程”中的“学生”实例数量（这将等同于多少“学生”实例指向给定的“课程”实例）。添加适当的接口来合理封装这个类。
- en: b. Add to your `Student` class a set of pointers to the `Course` instances in
    which that `Student` is enrolled. Additionally, keep track of how many `Course`
    instances a given `Student` is enrolled in. Add appropriate member functions to
    support this new functionality.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: b. 在您的“学生”类中添加指向该“学生”注册的“课程”实例的指针集。此外，跟踪给定“学生”注册的“课程”实例数量。添加适当的成员函数来支持这种新功能。
- en: c. Model your many-sided associations either using a linked-list of pointers
    (that is, the data part is a pointer to the associated object), or as an array
    of pointers to the associated objects. Note that an array will enforce a limit
    on the number of associated objects you can have; however, this may be reasonable
    because a given `Course` can only accommodate a maximum number of `Student`s and
    a `Student` may only enroll up to a maximum number of `Course`s per semester.
    If you choose the array of pointers approach, make sure your implementation includes
    error checking to accommodate exceeding the maximum number of associated objects
    in each array.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: c. 使用指针的链表（即，数据部分是指向关联对象的指针）或作为关联对象的指针数组来对多边关联进行建模。请注意，数组将对您可以拥有的关联对象数量施加限制；但是，这可能是合理的，因为给定的“课程”只能容纳最大数量的“学生”，而“学生”每学期只能注册最大数量的“课程”。如果您选择指针数组的方法，请确保您的实现包括错误检查，以适应每个数组中关联对象数量超过最大限制的情况。
- en: d. Be sure to check for simple errors, such as trying to add `Student`s in a
    `Course` that is full, or adding too many `Course`s to a `Student`'s schedule
    (assume there is an upper bound of 5 courses per semester).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: d. 一定要检查简单的错误，比如尝试在已满的“课程”中添加“学生”，或者向“学生”的课程表中添加过多的“课程”（假设每学期最多有5门课程）。
- en: e. Make sure your destructors do not delete the associated instances.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: e. 确保您的析构函数不会删除关联的实例。
- en: f. Introduce at least three `Student` objects, each of which takes two or more
    `Course`s. Additionally, make sure each `Course` has multiple `Student`s enrolled.
    Print each `Student`, including each `Course` in which they are enrolled. Likewise,
    print each `Course`, showing each `Student` enrolled in the `Course`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: f. 引入至少三个“学生”对象，每个对象都选修两门或更多门“课程”。此外，请确保每门“课程”都有多个“学生”注册。打印每个“学生”，包括他们注册的每门“课程”。同样，打印每门“课程”，显示注册在该“课程”中的每个“学生”。
- en: '(Optional) Enhance your program in *Exercise 2* to gain experience with back-link
    maintenance and reference counting as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）增强您在*练习2*中的程序，以获得以下反向链接维护和引用计数的经验：
- en: 'a. Implement a `DropCourse()` interface for `Student`. That is, create a `Student::
    DropCourse(Course *)` method in `Student`. Here, find the `Course` the `Student`
    wishes to drop in their course list, but before removing the `Course`, call a
    method on that `Course` to remove the aforementioned `Student` (that is, `this`)
    from the `Course`. Hint: you can make a `Course::RemoveStudent(Student *)` method
    to help with back-link removal.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: a. 为“学生”实现一个“DropCourse()”接口。也就是，在“学生”中创建一个“Student::DropCourse(Course *)”方法。在这里，找到“学生”希望在他们的课程列表中删除的“课程”，但在删除“课程”之前，调用该“课程”的一个方法，从该“课程”中删除前述的“学生”（即，`this`）。提示：您可以创建一个“Course::RemoveStudent(Student
    *)”方法来帮助删除反向链接。
- en: b. Now, fully implement proper destructors. When a `Course` is destructed, have
    the `Course` destructor first tell each remaining, associated `Student` to remove
    their link to that `Course`. Likewise, when a `Student` is destructed, loop through
    the `Student`'s course list to ask those `Courses` to remove the aforementioned
    `Student` (that is, `this`) from their student list. You may find reference counting
    in each class (that is, by checking `numStudents` or `numCourses`) helpful to
    see if these tasks must be engaged.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: b. 现在，完全实现适当的析构函数。当一个“课程”被销毁时，让“课程”析构函数首先告诉每个剩余的关联“学生”删除他们与该“课程”的链接。同样，当一个“学生”被销毁时，循环遍历“学生”的课程列表，要求那些“课程”从他们的学生列表中删除前述的“学生”（即，`this`）。您可能会发现每个类中的引用计数（即，通过检查`numStudents`或`numCourses`）有助于确定是否必须执行这些任务。
