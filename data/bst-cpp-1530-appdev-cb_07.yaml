- en: Chapter 7. Manipulating Strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 字符串操作
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Changing cases and case-insensitive comparison
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变大小写和不区分大小写的比较
- en: Matching strings using regular expressions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式匹配字符串
- en: Searching and replacing strings using regular expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式搜索和替换字符串
- en: Formatting strings using safe printf-like functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用安全的printf-like函数格式化字符串
- en: Replacing and erasing strings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换和删除字符串
- en: Representing a string with two iterators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用两个迭代器表示字符串
- en: Using a reference to string type
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符串类型的引用
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This whole chapter is devoted to different aspects of changing, searching, and
    representing strings. We'll see how some common string-related tasks can be easily
    done using the Boost libraries. This chapter is easy enough; it addresses very
    common string manipulation tasks. So, let's begin!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 整章都致力于字符串更改、搜索和表示的不同方面。我们将看到如何使用Boost库轻松完成一些常见的字符串相关任务。本章内容足够简单；它解决了非常常见的字符串操作任务。那么，让我们开始吧！
- en: Changing cases and case-insensitive comparison
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变大小写和不区分大小写的比较
- en: 'This is a pretty common task. We have two non-Unicode or ANSI character strings:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当常见的任务。我们有两个非Unicode或ANSI字符字符串：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We need to compare them in a case-insensitive manner. There are a lot of methods
    to do that; let's take a look at Boost's.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以不区分大小写的方式比较它们。有很多方法可以做到这一点；让我们看看Boost的方法。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of `std::string` is all we need here.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们只需要`std::string`的基本知识。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Here are some different ways to do case-insensitive comparisons:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些不同的方法来进行不区分大小写的比较：
- en: 'The most trivial one is:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最简单的一个是：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the Boost predicate and STL method:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Boost谓词和STL方法：
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Making a lowercase copy of both the strings:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个字符串的小写副本：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Making an uppercase copy of the original strings:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建原始字符串的大写副本：
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Converting the original strings to lowercase:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原始字符串转换为小写：
- en: '[PRE5]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The second method is not an obvious one. In the second method, we compare the
    length of the strings; if they have the same length, we compare the strings character
    by character using an instance of the `boost::is_iequal` predicate. The `boost::is_iequal`
    predicate compares two characters in a case-insensitive way.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法并不明显。在第二种方法中，我们比较字符串的长度；如果它们的长度相同，我们使用`boost::is_iequal`谓词逐字符比较字符串。`boost::is_iequal`谓词以不区分大小写的方式比较两个字符。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Boost.StringAlgorithm` library uses `i` in the name of the method or class,
    if this method is case-insensitive. For example, `boost::is_iequal`, `boost::iequals`,
    `boost::is_iless`, and others.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.StringAlgorithm`库在方法或类的名称中使用`i`，如果这个方法是不区分大小写的。例如，`boost::is_iequal`、`boost::iequals`、`boost::is_iless`以及其他。'
- en: There's more...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Each function and the functional object of the `Boost.StringAlgorithm` library
    that work with cases accept `std::locale`. By default (and in our examples), methods
    and classes use a default constructed `std::locale`. If we work a lot with strings,
    it may be a good optimization to construct a `std::locale` variable once and pass
    it to all the methods. Another good optimization would be to use the ''C'' locale
    (if your application logic permits that) via `std::locale::classic()`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.StringAlgorithm`库中所有与大小写相关的函数和功能对象都接受`std::locale`。默认情况下（以及在我们的示例中），方法和类使用默认构造的`std::locale`。如果我们大量处理字符串，那么构造一个`std::locale`变量一次并传递给所有方法可能是一个很好的优化。另一个好的优化是使用''C''区域设置（如果您的应用程序逻辑允许的话）通过`std::locale::classic()`：'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Nothing forbids you to use both optimizations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么禁止你使用这两种优化。
- en: Unfortunately, C++11 has no string functions from `Boost.StringAlgorithm`. All
    the algorithms are fast and reliable, so do not be afraid to use them in your
    code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，C++11没有`Boost.StringAlgorithm`的字符串函数。所有算法都是快速且可靠的，所以不要害怕在你的代码中使用它们。
- en: See also
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Official documentation on the Boost String Algorithms library can be found at
    [http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html](http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Boost字符串算法库的官方文档可以在[http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html](http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html)找到
- en: See the *C++ Coding Standards* book by Andrei Alexandrescu and Herb Sutter for
    an example on how to make a case-insensitive string with a few lines of code
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅Andrei Alexandrescu和Herb Sutter所著的《*C++编码标准*》一书，了解如何用几行代码创建一个不区分大小写的字符串的示例。
- en: Matching strings using regular expressions
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式匹配字符串
- en: Let's do something useful! It's common that the user's input must be checked
    using some regular expression-specific pattern that provides a flexible means
    of match. The problem is that there are a lot of regex syntaxes; expressions written
    using one syntax are not handled well by the other syntax. Another problem is
    that long regexes are not easy to write.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一些有用的事情！通常，用户的输入必须使用某些正则表达式特定的模式进行检查，这提供了一种灵活的匹配方式。问题是正则表达式语法有很多；使用一种语法编写的表达式不能很好地由另一种语法处理。另一个问题是长正则表达式不容易编写。
- en: So in this recipe, we'll write a program that may use different types of regular
    expression syntaxes and checks that the input strings match the specified regexes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个菜谱中，我们将编写一个程序，该程序可能使用不同类型的正则表达式语法，并检查输入字符串是否与指定的正则表达式匹配。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: This recipe requires basic knowledge of STL. Knowledge of regular expression
    syntax can be helpful, but it is not really required.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱需要基本的 STL 知识。了解正则表达式语法可能会有帮助，但并非必需。
- en: Linking examples against the `libboost_regex` library is required.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将示例链接到 `libboost_regex` 库。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: This regex matcher consists of a few lines of code in the `main()` function;
    however, I use it a lot. It'll help you some day.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式匹配器由 `main()` 函数中的几行代码组成；然而，我经常使用它。它总有一天会帮到你的。
- en: 'To implement it, we''ll need the following headers:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现它，我们需要以下头文件：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At the start of the program, we need to output the available regex syntaxes:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序开始时，我们需要输出可用的正则表达式语法：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now correctly set up flags, according to the chosen syntax:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在根据选择的语法正确设置标志：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we''ll be requesting regex patterns in a loop:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将循环请求正则表达式模式：
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Getting a string to match in a loop:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环中获取一个字符串进行匹配：
- en: '[PRE11]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Applying regex to it and outputting the result:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将正则表达式应用于它并输出结果：
- en: '[PRE12]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finishing our example by restoring `std::cin` and requesting new regex patterns:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过恢复 `std::cin` 并请求新的正则表达式模式来完成我们的示例：
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now if we run the preceding example, we''ll get the following output:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在如果我们运行前面的示例，我们会得到以下输出：
- en: '[PRE14]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All this is done by the `boost::regex` class. It constructs an object that is
    capable of regex parsing and compilation. The `flags` variable adds additional
    configuration options.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是由 `boost::regex` 类完成的。它构建了一个能够进行正则表达式解析和编译的对象。`flags` 变量添加了额外的配置选项。
- en: 'If the regular expression is incorrect, it throws an exception; if the `boost::regex::no_except`
    flag was passed, it reports an error returning as non-zero in the `status()` call
    (just like in our example):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正则表达式不正确，它会抛出异常；如果传递了 `boost::regex::no_except` 标志，它会在 `status()` 调用中返回非零值以报告错误（就像在我们的示例中一样）：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will result in:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Regular expression matching is done by a call to the `boost::regex_match` function.
    It returns `true` in case of a successful match. Additional flags may be passed
    to `regex_match`, but we avoided their usage for brevity of the example.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式匹配是通过调用 `boost::regex_match` 函数来完成的。如果匹配成功，则返回 `true`。可以传递额外的标志给 `regex_match`，但我们为了避免示例的简洁性而避免了它们的用法。
- en: There's more...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++11 contains almost all the `Boost.Regex` classes and flags. They can be found
    in the `<regex>` header of the `std::` namespace (instead of `boost::`). Official
    documentation provides information about the differences between C++11 and `Boost.Regex`.
    It also contains some performance measures that tell `Boost.Regex` is fast.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 几乎包含了所有的 `Boost.Regex` 类和标志。它们可以在 `std::` 命名空间中的 `<regex>` 头文件中找到（而不是
    `boost::`）。官方文档提供了有关 C++11 和 `Boost.Regex` 之间差异的信息。它还包含了一些性能指标，表明 `Boost.Regex`
    很快。
- en: See also
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Searching and replacing strings using regular expressions* recipe will
    give you more information about `Boost.Regex` usage
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “使用正则表达式搜索和替换字符串”菜谱将为你提供更多有关 `Boost.Regex` 使用的详细信息
- en: You may also consider official documentation to get more information about flags,
    performance measures, regular expression syntaxes, and C++11 conformance at [http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以考虑官方文档来获取有关标志、性能指标、正则表达式语法和 C++11 兼容性的更多信息，请参阅 [http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html)
- en: Searching and replacing strings using regular expressions
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式搜索和替换字符串
- en: My wife enjoyed the *Matching strings using regular expressions* recipe very
    much and told me that I'll get no food until I improve it to be able to replace
    parts of the input string according to a regex match. Each matched subexpression
    (part of the regex in parenthesis) must get a unique number starting from 1; this
    number will be used to create a new string.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我的妻子非常喜欢 *使用正则表达式匹配字符串* 配方，并告诉我，除非我将它改进到能够根据正则表达式匹配替换输入字符串的部分，否则我不会得到食物。每个匹配的子表达式（正则表达式中的括号部分）必须从
    1 开始有一个唯一的数字；这个数字将用于创建一个新的字符串。
- en: 'This is how an updated program will work like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是更新后的程序将如何工作的样子：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll be using the code from the *Matching strings using regular expressions*
    recipe. You should read it before getting your hands on this one.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自 *使用正则表达式匹配字符串* 配方的代码。在使用此配方之前，您应该阅读它。
- en: Linking the example against the `libboost_regex` library is required.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 需要将示例链接到 `libboost_regex` 库。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: This recipe is based on the code from the previous one. Let's see what must
    be changed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基于上一个配方中的代码。让我们看看需要更改什么。
- en: 'No additional headers will be included; however, we''ll need an additional
    string to store the replace pattern:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不需要包含额外的头文件；然而，我们需要一个额外的字符串来存储替换模式：
- en: '[PRE18]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We''ll replace `boost::regex_match` with `boost::regex_find` and output matched
    results:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将用 `boost::regex_find` 替换 `boost::regex_match` 并输出匹配的结果：
- en: '[PRE19]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After that, we need to get the replace pattern and apply it:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要获取替换模式并应用它：
- en: '[PRE20]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That's it! Everyone's happy and I'm fed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！大家都满意，我也吃饱了。
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `boost::regex_search` function doesn''t only return a true or a false (such
    as the `boost::regex_match` function does) value, but also stores matched parts.
    We output matched parts using the following construction:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::regex_search` 函数不仅返回一个真或假（如 `boost::regex_match` 函数所做的那样）的值，而且还存储匹配的部分。我们使用以下构造来输出匹配的部分：'
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that we outputted the results by skipping the first result (`results.begin()
    + 1`); that is because `results.begin()` contains the whole regex match.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们通过跳过第一个结果（`results.begin() + 1`）来输出结果；这是因为 `results.begin()` 包含整个正则表达式匹配。
- en: The `boost::regex_replace` function does all the replacing and returns the modified
    string.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::regex_replace` 函数执行所有替换并返回修改后的字符串。'
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are different variants of the `regex_*` function; some of them receive
    bidirectional iterators instead of strings and some provide output to the iterator.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`regex_*` 函数有不同的变体；其中一些接收双向迭代器而不是字符串，而另一些则向迭代器提供输出。'
- en: '`boost::smatch` is a `typedef` for `boost::match_results<std::string::const_iterator>`;
    so if you are using some other bidirectional iterators instead of `std::string::const_iterator`,
    you will need to use the type of your bidirectional iterators as a template parameter
    for `match_results`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::smatch` 是 `boost::match_results<std::string::const_iterator>` 的 `typedef`；因此，如果您使用的是
    `std::string::const_iterator` 以外的其他双向迭代器，您需要将您的双向迭代器类型用作 `match_results` 的模板参数。'
- en: '`match_results` has a format function, so we can tune our example with it.
    Instead of:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`match_results` 具有格式化功能，因此我们可以用它来调整示例。而不是：'
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We may use the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下内容：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By the way, `replace_string` may have different formats:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，`replace_string` 可能具有不同的格式：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All the classes and functions from this recipe exist in C++11, in the `std::`
    namespace of the `<regex>` header.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方中的所有类和函数都存在于 C++11 中，位于 `<regex>` 头文件的 `std::` 命名空间中。
- en: See also
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: The official documentation on `Boost.Regex` will give you more examples and
    information about performance, C++11 standard compatibility, and regular expression
    syntax at [http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html).
    The *Matching strings using regular expressions* recipe will tell you the basics
    of `Boost.Regex`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `Boost.Regex` 的官方文档将为您提供更多示例以及有关性能、C++11 标准兼容性和正则表达式语法的更多信息，请参阅 [http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/regex/doc/html/index.html)。*使用正则表达式匹配字符串*
    配方将向您介绍 `Boost.Regex` 的基础知识。
- en: Formatting strings using safe printf-like functions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用安全的 printf-like 函数格式化字符串
- en: The `printf` family of functions is a threat to security. It is a very bad design
    to allow users to put their own strings as a type and format the specifiers. So
    what do we do when user-defined format is required? How shall we implement the
    `std::string to_string(const std::string& format_specifier) const;` member function
    of the following class?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf`函数族对安全性构成了威胁。允许用户将他们自己的字符串作为类型并格式化说明符是非常糟糕的设计。那么当需要用户定义的格式时我们该怎么办？我们该如何实现以下类的`std::string
    to_string(const std::string& format_specifier) const;`成员函数？'
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of STL is more than enough for this recipe.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，只需要基本的STL知识就足够了。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We wish to allow users to specify their own output format for a string.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望允许用户为字符串指定自己的输出格式。
- en: 'To do that in a safe manner, we''ll need the following header:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全地做到这一点，我们需要以下头文件：
- en: '[PRE26]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we will add some comments for the user:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将为用户添加一些注释：
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now it is time to make all of them work:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候让它们全部工作了：
- en: '[PRE28]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'That''s all. Take a look at this code:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这些了。看看这段代码：
- en: '[PRE29]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Imagine that `class_instance` has a member `i` equal to `100`, an `s` member
    equal to `"Reader"`, and a member `c` equal to `''!''`. Then, the program will
    output the following:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设`class_instance`有一个成员`i`等于`100`，一个成员`s`等于`"Reader"`，一个成员`c`等于`'!'`。然后，程序将输出以下内容：
- en: '[PRE30]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `boost::format` class accepts the string that specifies the resulting string.
    Arguments are passed to `boost::format` using `operator%`. Values `%1%`, `%2%`,
    `%3%`, `%4%`, and so on, in the format specifying string, will be replaced by
    arguments passed to `boost::format`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::format`类接受指定结果的字符串。参数通过`operator%`传递给`boost::format`。在格式指定字符串中指定的`%1%`、`%2%`、`%3%`、`%4%`等值将被传递给`boost::format`的参数替换。'
- en: 'We disable the exceptions for cases when a format string contains fewer arguments
    than passed to `boost::format`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当格式字符串包含的参数少于传递给`boost::format`的参数时，我们禁用异常：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is done to allow some formats like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了允许一些格式，例如：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There's more...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: And what will happen in case of an incorrect format?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果格式不正确会发生什么？
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Well, in that case, no assertion will be triggered and the following lines
    will be outputted to the console:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，在这种情况下，不会触发断言，以下行将被输出到控制台：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: C++11 has no `std::format`. The `Boost.Format` library is not a very fast library;
    try not to use it much in performance critical sections.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: C++11没有`std::format`。`Boost.Format`库不是一个非常快的库；尽量不在性能关键部分使用它。
- en: See also
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official documentation contains more information about the performance of
    the `Boost.Format` library. More examples and documentation on extended printf-like
    format is available at [http://www.boost.org/doc/libs/1_53_0/libs/format/](http://www.boost.org/doc/libs/1_53_0/libs/format/)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档包含了关于`Boost.Format`库性能的更多信息。有关扩展printf-like格式的更多示例和文档，请访问[http://www.boost.org/doc/libs/1_53_0/libs/format/](http://www.boost.org/doc/libs/1_53_0/libs/format/)
- en: Replacing and erasing strings
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串的替换和删除
- en: Situations where we need to erase something in a string, replace a part of the
    string, or erase the first or last occurrence of some substring are very common.
    STL allows us to do most of this, but it usually involves writing too much code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在字符串中删除某些内容、替换字符串的一部分或删除子字符串的第一个或最后一个出现的情况非常常见。STL允许我们完成大部分这些操作，但通常需要编写过多的代码。
- en: 'We saw the `Boost.StringAlgorithm` library in action in the *Changing cases
    and case-insensitive comparison* recipe. Let''s see how it can be used to simplify
    our lives when we need to modify some strings:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*改变大小写和大小写不敏感比较*的示例中看到了`Boost.StringAlgorithm`库的应用。让我们看看它如何简化我们在需要修改字符串时的生活：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ is required for this example.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，需要基本的C++知识。
- en: How to do it...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: This recipe shows how different string-erasing and replacing methods from the
    `Boost.StringAlgorithm` library work.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了`Boost.StringAlgorithm`库中不同的字符串删除和替换方法是如何工作的。
- en: 'Erasing requires the `#include <boost/algorithm/string/erase.hpp>` header:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作需要包含`#include <boost/algorithm/string/erase.hpp>`头文件：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code will output the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将输出以下内容：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Replacing requires the `<boost/algorithm/string/replace.hpp>` header:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 替换操作需要包含`<boost/algorithm/string/replace.hpp>`头文件：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This code will output the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将输出以下内容：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All the examples are self-documenting. The only one that is not obvious is the
    `replace_head_copy` function. It accepts a number of bytes to replace as a second
    parameter and a replace string as the third parameter. So, in the preceding example,
    `Hello` gets replaced with `Whaaaaaaa!`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例都是自文档化的。唯一不明显的是`replace_head_copy`函数。它接受要替换的字节数作为第二个参数，以及替换字符串作为第三个参数。所以，在上面的例子中，`Hello`被替换为`Whaaaaaaa!`。
- en: There's more...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are also methods that modify strings in-place. They don't just end on
    `_copy` and return `void`. All the case insensitive methods (the ones that start
    with `i`) accept `std::locale` as the last parameter, and use a default constructed
    locale as a default parameter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 还有修改字符串的内置方法。它们不仅以`_copy`结尾并返回`void`。所有不区分大小写的方法（以`i`开头的方法）接受`std::locale`作为最后一个参数，并使用默认构造的`locale`作为默认参数。
- en: C++11 does not have `Boost.StringAlgorithm` methods and classes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: C++11没有`Boost.StringAlgorithm`方法和类。
- en: See also
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official documentation contains a lot of examples and a full reference on
    all the methods at [http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html](http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档包含大量示例和所有方法的完整参考，请访问[http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html](http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html)
- en: See the *Changing cases and case-insensitive comparison* recipe from this chapter
    for more information about the `Boost.StringAlgorithm` library.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`Boost.StringAlgorithm`库的更多信息，请参阅本章的*改变大小写和大小写不敏感比较*配方。
- en: Representing a string with two iterators
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用两个迭代器表示字符串
- en: There are situations when we need to split some strings into substrings and
    do something with those substrings. For example, count whitespaces in the string
    and, of course, we want to use Boost and be as efficient as possible.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要将一些字符串分割成子字符串并对这些子字符串进行操作。例如，计算字符串中的空格数，当然，我们希望使用Boost并尽可能高效。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You'll need some basic knowledge of STL algorithms for this recipe.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要了解一些基本的STL算法知识才能使用此配方。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We won't be counting whitespaces; instead we'll split the string into sentences.
    You'll see that it is very easy with Boost.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会计算空格数；相反，我们将字符串分割成句子。您将看到使用Boost做这件事非常简单。
- en: 'First of all, include the right headers:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，包含正确的头文件：
- en: '[PRE40]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now let''s define our test string:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义我们的测试字符串：
- en: '[PRE41]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we make a `typedef` for our splitting iterator:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们为我们的分割迭代器创建一个`typedef`：
- en: '[PRE42]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Construct that iterator:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建那个迭代器：
- en: '[PRE43]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we can iterate between matches:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以遍历匹配项之间：
- en: '[PRE44]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Count the number of characters:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算字符数：
- en: '[PRE45]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And count the whitespaces:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后计算空格数：
- en: '[PRE46]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'That''s it. Now if we run this example, it will output:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样。现在如果我们运行这个示例，它将输出：
- en: '[PRE47]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: The main idea of this recipe is that we do not need to construct `std::string`
    from substrings. We even do not need to tokenize the whole string at once. All
    we need to do is find the first substring and return it as a pair of iterators
    to the beginning and to the end of substring. If we need more substrings, find
    the next substring and return a pair of iterators for that substring.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的核心思想是我们不需要从子字符串中构造`std::string`。我们甚至不需要一次性对整个字符串进行分词。我们只需要找到第一个子字符串，并将其作为一对迭代器返回，一对迭代器分别指向子字符串的开始和结束。如果我们需要更多子字符串，找到下一个子字符串，并返回该子字符串的迭代器对。
- en: '![How it works...](img/4880OS_07_02.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/4880OS_07_02.jpg)'
- en: Now let's take a closer look at `boost::split_iterator`. We constructed one
    using the `boost::make_split_iterator` function that takes `range` as the first
    argument and a binary finder predicate (or binary predicate) as the second. When
    `split_iterator` is dereferenced, it returns the first substring as `boost::iterator_range<const
    char*>`, which just holds a pair of iterators and has a few methods to work with
    them. When we increment `split_iterator`, it will try to find the next substring,
    and if there is no substring found, `split_iterator::eof()` will return `true`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看`boost::split_iterator`。我们使用`boost::make_split_iterator`函数构建了一个迭代器，该函数以`range`作为第一个参数，以二进制查找谓词（或二进制谓词）作为第二个参数。当`split_iterator`被解引用时，它返回第一个子字符串作为`boost::iterator_range<const
    char*>`，它只包含一对迭代器，并有一些方法可以与之交互。当我们增加`split_iterator`时，它将尝试找到下一个子字符串，如果没有找到子字符串，`split_iterator::eof()`将返回`true`。
- en: There's more...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `boost::iterator_range` class is widely used across all the Boost libraries.
    You may find it useful for your own code and libraries in situations where a pair
    of iterators must be returned or where a function should accept/work with a pair
    of iterators.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::iterator_range` 类在所有 Boost 库中都有广泛的应用。你可能会发现在需要返回一对迭代器或函数应该接受/使用一对迭代器的情况下，它对你的代码和库很有用。'
- en: The `boost::split_iterator<>` and `boost::iterator_range<>` classes accept a
    forward iterator type as a template parameter. Because we were working with a
    character array in the preceding example, we provided `const char*` as iterators.
    If we were working with `std::wstring`, we would need to use the `boost::split_iterator<std::wstring::const_iterator>`
    and `boost::iterator_range<std::wstring::const_iterator>` types.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::split_iterator<>` 和 `boost::iterator_range<>` 类接受一个前向迭代器类型作为模板参数。因为我们之前的工作是在字符数组上，所以我们提供了
    `const char*` 作为迭代器。如果我们使用 `std::wstring`，我们需要使用 `boost::split_iterator<std::wstring::const_iterator>`
    和 `boost::iterator_range<std::wstring::const_iterator>` 类型。'
- en: C++11 has neither `iterator_range` nor `split_iterator`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: C++11 既没有 `iterator_range` 也没有 `split_iterator`。
- en: As the `boost::iterator_range` class has no virtual functions and no dynamic
    memory allocations, it is fast and efficient. However, its output stream operator
    `<<` has no specific optimizations for character arrays, so streaming it is slow.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `boost::iterator_range` 类没有虚拟函数和动态内存分配，它既快又高效。然而，它的输出流操作符 `<<` 对字符数组没有特定的优化，因此流操作较慢。
- en: The `boost::split_iterator` class has a `boost::function` class in it, so constructing
    it may be slow; however, iterating adds only a tiny overhead that you won't notice
    even in performance critical sections.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::split_iterator` 类中有一个 `boost::function` 类，因此构造它可能较慢；然而，迭代只会增加微小的开销，你甚至可能在性能关键部分都感觉不到。'
- en: See also
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The next recipe will tell you about a nice replacement for `boost::iterator_range<const
    char*>`.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个配方将告诉你关于 `boost::iterator_range<const char*>` 的一个很好的替代方案。
- en: The official documentation for `Boost.StringAlgorithm` will provide you with
    more detailed information about classes and a whole bunch of examples at [http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html](http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.StringAlgorithm` 的官方文档将为你提供关于类和大量示例的更详细信息，请参阅 [http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html](http://www.boost.org/doc/libs/1_53_0/doc/html/string_algo.html)。'
- en: 'More information about `boost::iterator_range` can be found here: [http://www.boost.org/doc/libs/1_53_0/libs/range/doc/html/range/reference/utilities.html](http://www.boost.org/doc/libs/1_53_0/libs/range/doc/html/range/reference/utilities.html).
    It is a part of the `Boost.Range` library that is not described in this book,
    but you may wish to study it by yourself.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 `boost::iterator_range` 的信息可以在以下链接找到：[http://www.boost.org/doc/libs/1_53_0/libs/range/doc/html/range/reference/utilities.html](http://www.boost.org/doc/libs/1_53_0/libs/range/doc/html/range/reference/utilities.html)。它是
    `Boost.Range` 库的一部分，本书没有描述，但你可能希望自学。
- en: Using a reference to string type
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字符串类型的引用
- en: 'This recipe is the most important recipe in this chapter! Let''s take a look
    at a very common case, where we write a function that accepts a string and returns
    the part of the string between character values passed in the `starts` and `ends`
    arguments:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是本章最重要的配方！让我们看看一个非常常见的案例，其中我们编写一个函数，该函数接受一个字符串，并返回 `starts` 和 `ends` 参数传递的字符值之间的字符串部分：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Do you like this implementation? In my opinion, it looks awful; consider the
    following call to it:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你喜欢这个实现吗？在我看来，它看起来很糟糕；考虑以下对其的调用：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this example, a temporary `std::string` variable will be constructed from
    `"Getting expression (between brackets)"`. The character array is long enough,
    so there is a big chance that dynamic memory allocation will be called inside
    the `std::string` constructor and the character array will be copied into it.
    Then, somewhere inside the `between_str` function, new `std::string` will be constructed,
    which may also lead to another dynamic memory allocation and result in copying.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，一个临时的 `std::string` 变量将从 `"Getting expression (between brackets)"` 构造出来。字符数组足够长，所以有很大可能在
    `std::string` 构造函数内部调用动态内存分配，并将字符数组复制到其中。然后，在 `between_str` 函数的某个地方，将构造一个新的 `std::string`，这也可能导致另一个动态内存分配，并导致复制。
- en: 'So, this simple function may, and in most cases will:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个简单的函数可能，并且在大多数情况下会：
- en: Call dynamic memory allocation (twice)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用动态内存分配（两次）
- en: Copy string (twice)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制字符串（两次）
- en: Deallocate memory (twice)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放内存（两次）
- en: Can we do better?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做得更好吗？
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires basic knowledge of STL and C++.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方需要基本的 STL 和 C++ 知识。
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: We do not really need a `std::string` class here, we only need some pointer
    to the character array and the array's size. Boost has the `std::string_ref` class.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们实际上并不需要一个 `std::string` 类，我们只需要指向字符数组的指针以及数组的大小。Boost 提供了 `std::string_ref`
    类。
- en: 'To use the `boost::string_ref` class, include the following header:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 `boost::string_ref` 类，需要包含以下头文件：
- en: '[PRE50]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Change the method''s signature:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改方法的签名：
- en: '[PRE51]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Change `std::string` to `boost::string_ref:` everywhere inside the function
    body:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数体内将 `std::string` 改为 `boost::string_ref`：
- en: '[PRE52]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `boost::string_ref` constructor accepts size as a second parameter, so
    we need to slightly change the code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`boost::string_ref` 构造函数接受大小作为第二个参数，因此我们需要稍微修改代码：'
- en: '[PRE53]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'That''s it! Now we may call `between("Getting expression (between brackets)",
    ''('', '')'')` and it will work without any dynamic memory allocation and characters
    copying. And we can still use it for `std::string`:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就这样！现在我们可以调用 `between("Getting expression (between brackets)", '(', ')')`，它将无需任何动态内存分配和字符复制即可工作。我们仍然可以使用它来处理
    `std::string`：
- en: '[PRE54]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As already mentioned, `boost::string_ref` contains only a pointer to the character
    array and size of data. It has a lot of constructors and may be initialized in
    different ways:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`boost::string_ref` 只包含指向字符数组的指针和数据的大小。它有很多构造函数，并且可以以不同的方式初始化：
- en: '[PRE55]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `boost::string_ref` class has all the methods required by the container
    class, so it is usable with STL algorithms and Boost algorithms:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::string_ref` 类拥有容器类所需的所有方法，因此它可以与 STL 算法和 Boost 算法一起使用：'
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `boost::string_ref` class does not really own string, so all its methods
    return constant iterators. Because of that, we cannot use it in methods that modify
    data, such as `boost::to_lower(r)`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::string_ref` 类实际上并不拥有字符串，因此它所有的方法都返回常量迭代器。正因为如此，我们不能在修改数据的函数中使用它，例如
    `boost::to_lower(r)`。'
- en: While working with `boost::string_ref`, we should take additional care about
    data that it refers to; it must exist and be valid for the whole lifetime of `boost::string_ref`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `boost::string_ref` 时，我们应该特别注意它所引用的数据；它必须在整个 `boost::string_ref` 的生命周期内存在且有效。
- en: There's more...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `boost::string_ref` class is not a part of C++11, but it is proposed for
    inclusion in the next standard.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::string_ref` 类不是 C++11 的组成部分，但它被提议包含在下一个标准中。'
- en: The `string_ref` classes are fast and efficient; use them wherever it is possible.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_ref` 类快速且高效；在可能的情况下使用它们。'
- en: 'The `boost::string_ref` class is actually a typedef in the `boost::` namespace:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::string_ref` 类实际上是 `boost::` 命名空间中的一个 typedef：'
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You may also find useful the following typedefs for wide characters in the
    `boost::` namespace:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会发现 `boost::` 命名空间中宽字符的以下 typedefs 有用：
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: See also
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official `string_ref` proposal for inclusion in C++ standard can be found
    at [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3442.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3442.html)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `string_ref` 包含到 C++ 标准中的官方提案可以在 [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3442.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3442.html)
    找到
- en: Boost documentation for `string_ref` could be found at [http://www.boost.org/doc/libs/1_53_0/libs/utility/doc/html/string_ref.html](http://www.boost.org/doc/libs/1_53_0/libs/utility/doc/html/string_ref.html)
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string_ref` 的 Boost 文档可以在 [http://www.boost.org/doc/libs/1_53_0/libs/utility/doc/html/string_ref.html](http://www.boost.org/doc/libs/1_53_0/libs/utility/doc/html/string_ref.html)
    找到'
