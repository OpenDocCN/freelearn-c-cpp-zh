- en: Standard Library Containers, Algorithms, and Iterators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库容器、算法和迭代器
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将涵盖以下教程：
- en: Using vector as a default container
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将向量用作默认容器
- en: Using bitset for fixed-size sequences of bits
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用位集处理固定大小的位序列
- en: Using vector<bool> for variable-size sequences of bits
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`vector<bool>`来处理可变大小的位序列
- en: Finding elements in a range
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在范围内查找元素
- en: Sorting a range
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对范围进行排序
- en: Initializing a range
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化范围
- en: Using set operations on a range
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在范围上使用集合操作
- en: Using iterators to insert new elements in a container
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用迭代器在容器中插入新元素
- en: Writing your own random access iterator
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的随机访问迭代器
- en: Container access with non-member functions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非成员函数访问容器
- en: Using vector as a default container
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将向量用作默认容器
- en: The standard library provides various types of containers that store collections
    of objects; the library includes sequence containers (such as `vector`, `array`,
    or `list`), ordered and unordered associative containers (such as `set` and `map`),
    and container adapters that do not store data but provide an adapted interface
    towards a sequence container (such as `stack` and `queue`). All of them are implemented
    as class templates, which means they can be used with any type (providing it meets
    the container requirements). Though you should always use the container that is
    the most appropriate for a particular problem (which not only provides good performance
    in terms of speed of inserts, deletes, access to elements, and memory usage but
    also makes the code easy to read and maintain), the default choice should be `vector`.
    In this recipe, we will see why `vector` should be the preferred choice for a
    container and what are the most common operations with `vector`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了各种类型的容器，用于存储对象的集合；库包括序列容器（如`vector`、`array`或`list`）、有序和无序关联容器（如`set`和`map`），以及不存储数据但提供适应接口向序列容器提供适配的容器适配器（如`stack`和`queue`）。它们都是作为类模板实现的，这意味着它们可以与任何类型一起使用（只要满足容器要求）。虽然您应该始终使用最适合特定问题的容器（不仅在插入、删除、访问元素和内存使用速度方面提供良好性能，而且使代码易于阅读和维护），但默认选择应该是`vector`。在本教程中，我们将看到为什么`vector`应该是首选容器，并且`vector`的最常见操作是什么。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The reader is expected to be familiar with C-like arrays, both statically and
    dynamically allocated.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应该熟悉类C数组，包括静态分配和动态分配。
- en: The class template `vector` is available in the `std` namespace in the `<vector>` header.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板`vector`在`<vector>`头文件中的`std`命名空间中可用。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To initialize a `std::vector` class template, you can use any of the following
    methods, but you are not restricted to only these:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化`std::vector`类模板，可以使用以下任何一种方法，但您不仅限于这些：
- en: 'Initialize from an initialization list:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从初始化列表初始化：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Initialize from a C-like array:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从类C数组初始化：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Initialize from another container:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从另一个容器初始化：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Initialize from a count and a value:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从计数和值初始化：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To modify the content of `std::vector`, use any of the following methods, but
    you are not restricted to only these:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改`std::vector`的内容，请使用以下任何一种方法，但您不仅限于这些：
- en: 'Add an element at the end of the vector with `push_back()`:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`push_back()`在向量末尾添加一个元素：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Remove an element from the end of the vector with `pop_back()`:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pop_back()`从向量末尾删除一个元素：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Insert anywhere in the vector with `insert()`:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`insert()`在向量中的任何位置插入：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add an element by creating it at the end of the vector with `emplace_back()`:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`emplace_back()`在向量末尾创建一个元素：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Insert an element by creating it anywhere in the vector with `emplace()`:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`emplace()`在向量中的任何位置创建元素插入：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To modify the whole content of the vector, use any of the following methods,
    but you are not restricted to only these:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改向量的整个内容，请使用以下任何一种方法，但您不仅限于这些：
- en: 'Assign from another vector with `operator=`; this replaces the content of the
    container:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`operator=`从另一个向量分配；这将替换容器的内容：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Assign from another sequence defined by a begin and end iterator with the `assign()` method;
    this replaces the content of the container:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`assign()`方法从由开始和结束迭代器定义的另一个序列分配；这将替换容器的内容：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Swap the content of two vectors with the `swap()` method:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`swap()`方法交换两个向量的内容：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Remove all the elements with the `clear()` method:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`clear()`方法删除所有元素：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Remove one or more elements with the `erase()` method (which requires either
    an iterator or a pair of iterators that define the range of elements from the
    vector to be removed):'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`erase()`方法删除一个或多个元素（需要定义要删除的向量元素范围的迭代器或一对迭代器）：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To get the address of the first element in a vector, usually to pass the content
    of a vector to a C-like API, use any of the following methods:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取向量中第一个元素的地址，通常将向量的内容传递给类C API，可以使用以下任何一种方法：
- en: 'Use the `data()` method, which returns a pointer to the first element, providing
    direct access to the underlying contiguous sequence of memory where the vector
    elements are stored; this is only available since C++11:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`data()`方法，返回指向第一个元素的指针，直接访问存储向量元素的底层连续内存序列；这仅在C++11之后才可用：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Get the address of the first element:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取第一个元素的地址：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Get the address of the element referred by the `front()` method:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取由`front()`方法引用的元素的地址：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Get the address of the element pointed by the iterator returned from `begin()`:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用从`begin()`返回的迭代器指向的元素的地址：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `std::vector` class is designed to be the C++ container most similar to
    and inter-operable with C-like arrays. A vector is a variable-sized sequence of
    elements, guaranteed to be stored contiguously in memory, which makes the content
    of a vector easily passable to a C-like function that takes a pointer to an element
    of an array and, usually, a size. There are many benefits of using a vector instead
    of C-like arrays and these benefits include:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`类被设计为C++中最类似和可互操作的C类似数组的容器。向量是一个可变大小的元素序列，保证在内存中连续存储，这使得向量的内容可以轻松地传递给一个类似C的函数，该函数接受一个指向数组元素的指针，通常还有一个大小。使用向量而不是C类似的数组有许多好处，这些好处包括：'
- en: No direct memory management is required from the developer, as the container
    does this internally, allocating memory, reallocating, and releasing.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员不需要进行直接的内存管理，因为容器在内部执行这些操作，分配内存，重新分配和释放。
- en: Note that a vector is intended for storing object instances. If you need to
    store pointers, do not store raw pointers but smart pointers. Otherwise, you need
    to handle the lifetime management of the pointed objects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，向量用于存储对象实例。如果需要存储指针，请不要存储原始指针，而是智能指针。否则，您需要处理指向对象的生命周期管理。
- en: The possibility of modifying the size of the vector.
  id: totrans-62
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改向量大小的可能性。
- en: Simple assignment or concatenation of two vectors.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的赋值或两个向量的连接。
- en: Direct comparison of two vectors.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接比较两个向量。
- en: The `vector` class is a very efficient container, with all implementations providing
    a lot of optimizations that most developers are not capable of doing with C-like
    arrays. Random access to its elements and insertion and removal at the end of
    a vector is a constant *O(1)* operation (provided that reallocation is not necessary),
    while insertion and removal anywhere else is a linear *O(n)* operation.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector`类是一个非常高效的容器，所有实现都提供了许多优化，大多数开发人员无法使用C类似的数组进行。对其元素的随机访问以及在向量末尾的插入和删除是一个常数*O(1)*操作（前提是不需要重新分配内存），而在其他任何地方的插入和删除是一个线性*O(n)*操作。'
- en: 'Compared to other standard containers, the vector has various benefits:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他标准容器相比，向量具有各种好处：
- en: It is compatible with C-like arrays and C-like APIs; the content of other containers
    (except for `std::array`) needs to be copied to a vector before being passed to
    a C-like API expecting an array.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与类似C的数组和类似C的API兼容；其他容器的内容（除了`std::array`）需要在传递给期望数组的类似C的API之前复制到向量中。
- en: It has the fastest access to elements of all containers.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有所有容器中元素的最快访问速度。
- en: It has no per-element memory overhead for storing elements, as elements are
    stored in a contiguous space, like a C array (and unlike other containers such
    as `list` that requires additional pointers to other elements, or associative
    containers that require hash values).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储元素的每个元素内存开销为零，因为元素存储在连续的空间中，就像C数组一样（不像其他容器，如`list`需要额外的指针指向其他元素，或者需要哈希值的关联容器）。
- en: '`std::vector` is very similar in semantics to C-like arrays but has a variable
    size. The size of a vector can increase and decrease. There are two properties
    that define the size of a vector:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`在语义上与类似C的数组非常相似，但大小可变。向量的大小可以增加和减少。有两个属性定义了向量的大小：'
- en: '*Capacity* is the number of elements the vector can accommodate without performing
    additional memory allocations; this is indicated by the `capacity()` method.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Capacity*是向量在不执行额外内存分配的情况下可以容纳的元素数量；这由`capacity()`方法表示。'
- en: '*Size* is the actual number of elements in the vector; this is indicated by
    the `size()` method.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Size*是向量中实际元素的数量；这由`size()`方法表示。'
- en: Size is always smaller or equal to capacity. When size is equal to capacity
    and a new element needs to be added, the capacity needs to be modified so that
    the vector has space for more elements. In this case, the vector allocates a new
    chunk of memory and moves the previous content to the new location and then frees
    the previously allocated memory. Though this sounds time-consuming (and it is),
    implementations increase the capacity exponentially, by doubling it each time
    it needs to be changed. As a result, on average, each element of the vector only
    needs to be moved once (that is because all the elements of the vector are moved
    during an increase of capacity, but then an equal number of elements can be added
    without incurring more moves, given that insertions are performed at the end of
    the vector).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 大小始终小于或等于容量。当大小等于容量并且需要添加新元素时，需要修改容量，以便向量有更多元素的空间。在这种情况下，向量分配新的内存块，并将先前的内容移动到新位置，然后释放先前分配的内存。尽管这听起来很耗时（而且确实如此），但实现会按指数增加容量，每次需要更改时将其加倍。因此，平均而言，向量的每个元素只需要移动一次（这是因为在增加容量时向量的所有元素都会移动，但然后可以添加相等数量的元素而不需要进行更多的移动，因为插入是在向量的末尾进行的）。
- en: If you know beforehand how many elements will be inserted in the vector, you
    can first call the `reserve()` method to increase the capacity to at least the
    specified amount (this method does nothing if the specified size is smaller than
    the current capacity) and only then insert the elements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事先知道要插入向量的元素数量，可以首先调用`reserve()`方法将容量增加到至少指定的数量（如果指定的大小小于当前容量，则此方法不执行任何操作），然后再插入元素。
- en: 'On the other hand, if you need to free additional reserved memory, you can
    use the `shrink_to_fit()` method to request this, but it is an implementation
    decision whether to free any memory or not. An alternative to this non-binding
    method, available since C++11, is to do a swap with a temporary, empty vector:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您需要释放额外保留的内存，可以使用`shrink_to_fit()`方法来请求，但是否释放任何内存是一个实现决定。自C++11以来，可用的另一种非绑定方法是与临时的空向量进行交换：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Calling the `clear()` method only removes all the elements from the vector but
    does not free any memory.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`clear()`方法只会从向量中删除所有元素，但不会释放任何内存。
- en: 'It should be noted that the vector implements operations specific to other
    types of containers:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，向量实现了特定于其他类型容器的操作：
- en: '`stack`: With `push_back()` and `emplace_back()` to add at the end and `pop_back()`
    to remove from the end. Keep in mind that `pop_back()` does not return the last
    element that has been removed. You need to access that explicitly, if that is
    necessary, for instance, using the `back()` method before removing the element.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stack`：使用`push_back()`和`emplace_back()`在末尾添加，使用`pop_back()`从末尾移除。请记住，`pop_back()`不会返回已移除的最后一个元素。如果有必要，您需要显式访问它，例如，在移除元素之前使用`back()`方法。'
- en: '`list`: With `insert()` and `emplace()` to add elements in the middle of the
    sequence and `erase()` to remove elements from anywhere in the sequence.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`：使用`insert()`和`emplace()`在序列中间添加元素，使用`erase()`从序列中的任何位置移除元素。'
- en: There’s more...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The rule of thumb for C++ containers is: use `std::vector` as the default container unless
    you have good reasons to use another one.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: C++容器的经验法则是：除非有充分的理由使用其他容器，否则使用`std::vector`作为默认容器。
- en: See also
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using bitset for fixed-size sequences of bits*'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用bitset表示固定大小的位序列*'
- en: '*Using vector<bool> for variable-size sequences of bits*'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用`vector<bool>`表示可变大小的位序列*'
- en: Using bitset for fixed-size sequences of bits
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用bitset表示固定大小的位序列
- en: It is not uncommon for developers to operate with bit flags; this can be either
    because they work with operating system APIs, usually written in C, that take
    various types of arguments (such as options or styles) in the form of bit flags,
    or because they work with libraries that do similar things, or simply because
    some types of problems are naturally solved with bit flags. One can think of alternatives
    to working with bits and bit operations, such as defining arrays having one element
    for every option/flag, or defining a structure with members and functions to model
    the bit flags, but these are often more complicated, and in case you need to pass
    a numerical value representing bit flags to a function you still need to convert
    the array or the structure to a sequence of bits. For this reason, the C++ standard
    provides a container called `std::bitset` for fixed-size sequences of bits.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员通常会使用位标志进行操作；这可能是因为他们使用操作系统API（通常用C编写），这些API接受各种类型的参数（例如选项或样式）以位标志的形式，或者因为他们使用执行类似操作的库，或者仅仅因为某些类型的问题自然而然地使用位标志来解决。可以考虑使用与位和位操作相关的替代方案，例如定义具有每个选项/标志的一个元素的数组，或者定义一个具有成员和函数来模拟位标志的结构，但这些通常更加复杂，而且如果您需要将表示位标志的数值传递给函数，则仍然需要将数组或结构转换为位序列。因此，C++标准提供了一个称为`std::bitset`的固定大小位序列的容器。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you must be familiar with bitwise operations (and, or, xor,
    not, and shifting).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，您必须熟悉位操作（与、或、异或、非和移位）。
- en: The `bitset` class is available in the `std` namespace in the `<bitset>` header.
    A bitset represents a fixed-size sequence of bits, with the size defined at compile
    time. For convenience, in this recipe, all examples will be with bitsets of 8
    bits.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`bitset`类位于`<bitset>`头文件中的`std`命名空间中。bitset表示固定大小的位序列，其大小在编译时定义。为方便起见，在本示例中，所有示例都将使用8位的位集。'
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To construct an `std::bitset` object, use one of the available constructors:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要构造一个`std::bitset`对象，请使用其中一个可用的构造函数：
- en: 'An empty bitset with all bits set to 0:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有位都设置为0的空位集：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A bitset from a numerical value:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数值创建一个位集：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A bitset from a string of `''0''` and `''1''`:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从包含`'0'`和`'1'`的字符串创建一个位集：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A bitset from a string containing any two characters representing `''0''` and
    `''1''`; in this case, we must specify which character represents a 0 and which
    character represents a 1:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从包含表示`'0'`和`'1'`的任意两个字符的字符串创建一个位集；在这种情况下，我们必须指定哪个字符表示0，哪个字符表示1：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To test individual bits in the set or the entire set for specific values, use
    any of the available methods:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 测试集合中的单个位或整个集合的特定值，可以使用任何可用的方法：
- en: '`count()` to get the number of bits set to 1:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count()` 以获取设置为1的位数：'
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`any()` to check whether there is at least one bit set to 1:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any()` 用于检查是否至少有一个位设置为1：'
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`all()` to check whether all the bits are set to 1:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all()` 以检查是否所有位都设置为1：'
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`none()` to check whether all the bits are set to 0:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none()` 以检查是否所有位都设置为0：'
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`test()` to check the value of an individual bit:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test()` 用于检查单个位的值：'
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`operator[]` to access and test individual bits:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator[]` 用于访问和测试单个位：'
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To modify the content of a bitset, use any of the following methods:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改位集的内容，请使用以下任何方法：
- en: 'Member operators `|=`, `&=`, `^= `, and `~` to perform binary or, and, xor,
    and not operations, or non-member operators `|`, `&`, and `^`:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员运算符`|=`, `&=`, `^= `和`~` 以执行二进制或、与、异或和非操作，或非成员运算符`|`, `&`, 和`^`：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Member operators `<<=`, `<<`, `>>=`, `>>` to perform shifting operations:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员运算符`<<=`, `<<`, `>>=`, `>>` 以执行移位操作：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`flip()` to toggle the entire set or an individual bit from 0 to 1 or from
    1 to 0:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flip()` 以将整个集合或单个位从0切换为1或从1切换为0：'
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`set()` to change the entire set or an individual bit to `true` or the specified
    value:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set()` 以将整个集合或单个位更改为`true`或指定的值：'
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`reset()` to change the entire set or an individual bit to false:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset()` 以将整个集合或单个位更改为false：'
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To convert a bitset to a numerical or string value, use the following methods:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要将位集转换为数值或字符串值，请使用以下方法：
- en: '`to_ulong()` and `to_ullong()` to convert to `unsigned long` or `unsigned long
    long`:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to_ulong()` 和 `to_ullong()` 以转换为`unsigned long`或`unsigned long long`：'
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`to_string()` to convert to `std::basic_string`; by default the result is a
    string containing `''0''` and `''1''`, but you can specify a different character
    for these two values:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to_string()` 以转换为`std::basic_string`；默认情况下，结果是一个包含`''0''`和`''1''`的字符串，但您可以为这两个值指定不同的字符：'
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'If you''ve ever worked with C or C-like APIs, chances are you either wrote
    or at least have seen code that manipulates bits to define styles, options, or
    other kinds of values. This usually involves operations, such as:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经使用过C或类似C的API，那么您可能写过或至少看过操作位来定义样式、选项或其他类型值的代码。这通常涉及操作，例如：
- en: Defining the bit flags; these can be enumerations, static constants in a class,
    or macros introduced with `#define` in the C style. Usually, there is a flag representing
    no value (style, option, and so on). Since these are supposed to be bit flags,
    their values are powers of 2.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义位标志；这些可以是枚举、类中的静态常量，或者是C风格中使用`#define`引入的宏。通常，有一个表示无值的标志（样式、选项等）。由于这些被认为是位标志，它们的值是2的幂。
- en: Adding and removing flags from the set (that is, a numerical value). Adding
    a bit flag is done with the bit-or operator (`value |= FLAG`) and removing a bit
    flag is done with the bit-and operator, with the negated flag (`value &= ~FLAG`).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从集合（即数值）中添加和移除标志。使用位或运算符（`value |= FLAG`）添加位标志，使用位与运算符和取反的标志（`value &= ~FLAG`）来移除位标志。
- en: Testing whether a flag is added to the set (`value & FLAG == FLAG`).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试标志是否已添加到集合中（`value & FLAG == FLAG`）。
- en: Calling functions with the flags as an argument.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用带有标志作为参数的函数。
- en: 'The following shows a simple example of flags defining the border style of
    a control that can have a border on the left, right, top, or bottom side, or any
    combination of these, including no border:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的示例，显示了定义控件边框样式的标志，该控件可以在左侧、右侧、顶部或底部有边框，或者包括这些任意组合，甚至没有边框：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The standard `std::bitset` class is intended as a C++ alternative to this C-like
    working style with sets of bits. It enables us to write more robust and safer
    code because it abstracts the bit operations with member functions, though we
    still need to identify what each bit in the set is representing:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`std::bitset`类旨在作为C++中使用位集的C风格工作方式的替代方案。它使我们能够编写更健壮和更安全的代码，因为它通过成员函数抽象了位操作，尽管我们仍然需要确定集合中的每个位表示什么：
- en: Adding and removing flags is done with the `set()` and `reset()` methods, which set
    the value of a bit indicated by its position to 1 or 0 (or `true` and `false`);
    alternatively, we can use the index operator for the same purpose.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`set()`和`reset()`方法来添加和移除标志，这些方法将位的值设置为1或0（或`true`和`false`）；或者，我们可以使用索引运算符来达到相同的目的。
- en: Testing if a bit is set is done with the `test()` method.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`test()`方法来测试位是否被设置。
- en: Conversion from an integer or a string is done through the constructor, and
    conversion to an integer or string is done with member functions so that the values
    from bitsets can be used where integers are expected (such as arguments to functions).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过构造函数从整数或字符串进行转换，通过成员函数将值转换为整数或字符串，以便可以在期望整数的地方使用bitset的值（例如作为函数的参数）。
- en: In addition to these mentioned operations, the `bitset` class has additional
    methods for performing bitwise operations on bits, shifting, testing, and others
    that have been shown in the previous section.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述操作，`bitset`类还有其他用于执行位操作、移位、测试等的附加方法，这些方法在前一节中已经展示过。
- en: Conceptually, `std::bitset` is a representation of a numerical value that enables
    you to access and modify individual bits. Internally, however, a bitset has an
    array of integer values on which it performs bit operations. The size of a bitset
    is not limited to the size of a numerical type; it can be anything, except that
    it is a compile-time constant.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，`std::bitset`是一个表示数值的类，它使您能够访问和修改单个位。然而，在内部，bitset具有一个整数值数组，它执行位操作。bitset的大小不限于数值类型的大小；它可以是任何大小，只要它是一个编译时常量。
- en: 'The example with the control border styles from the previous section can be
    written using `std::bitset` in the following manner:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中的控制边框样式示例可以以以下方式使用`std::bitset`来编写：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There's more...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The bitset can be created from an integer and can convert its value to an integer
    using the `to_ulong()` or `to_ullong()` methods. However, if the size of the bitset
    is larger than the size of these numerical types and any of the bits beyond the
    size of the requested numerical type is set to `1`, then these methods throw an `std::overflow_error` exception because
    the value cannot be represented on `unsigned long` or `unsigned long long`. In
    order to extract all the bits, we need to do the following operations, as shown
    in the next code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: bitset可以从整数创建，并可以使用`to_ulong()`或`to_ullong()`方法将其值转换为整数。但是，如果bitset的大小大于这些数值类型的大小，并且请求的数值类型大小之外的任何位被设置为`1`，那么这些方法会抛出`std::overflow_error`异常，因为该值无法表示为`unsigned
    long`或`unsigned long long`。为了提取所有位，我们需要执行以下操作，如下面的代码所示：
- en: Clear the bits beyond the size of `unsigned long` or `unsigned long long`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除超出`unsigned long`或`unsigned long long`大小的位。
- en: Convert the value to `unsigned long` or `unsigned long long`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值转换为`unsigned long`或`unsigned long long`。
- en: Shift the bitset with the number of bits in `unsigned long` or `unsigned long
    long`.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将位集向左移动`unsigned long`或`unsigned long long`位数。
- en: Do this until all the bits are retrieved.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一直执行此操作，直到检索到所有位。
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For cases where the size of the `bitset` cannot be known at compile time, the
    alternative is `std::vector<bool>`, which we will cover in the next recipe.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无法在编译时知道bitset大小的情况，替代方案是`std::vector<bool>`，我们将在下一个示例中介绍。
- en: See also
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using vector<bool> for variable-size sequences of bits*'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用`vector<bool>`来表示可变大小的位序列*'
- en: Using vector<bool> for variable-size sequences of bits
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`vector<bool>`来表示可变大小的位序列
- en: In the previous recipe, we looked at using `std::bitset` for fixed-size sequences
    of bits. Sometimes, however, an `std::bitset` is not a good choice because you
    do not know the number of bits at compile time, and just defining a set of a large
    enough number of bits is not a good idea because you can get into a situation
    when the number is not actually large enough. The standard alternative for this
    is to use the `std::vector<bool>` container that is a specialization of `std::vector`
    with space and speed optimizations, as implementations do not actually store Boolean
    values, but individual bits for each element.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了如何使用`std::bitset`来表示固定大小的位序列。然而，有时`std::bitset`不是一个好选择，因为在编译时你不知道位的数量，只是定义一个足够大的位集也不是一个好主意，因为你可能会遇到实际上不够大的情况。这种情况的标准替代方案是使用`std::vector<bool>`容器，它是`std::vector`的一个特化，具有空间和速度优化，因为实现实际上不存储布尔值，而是为每个元素存储单独的位。
- en: For this reason, however, `std::vector<bool>` does not meet the requirements
    of a standard container or sequential container, nor does `std::vector<bool>::iterator` meet
    the requirements of a forward iterator. As a result, this specialization cannot
    be used in generic code where a vector is expected. On the other hand, being a
    vector, it has a different interface from that of `std::bitset` and cannot be
    viewed as a binary representation of a number. There are no direct ways to construct `std::vector<bool>`
    from a number or string nor to convert to a number or string.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，因此，`std::vector<bool>`不符合标准容器或顺序容器的要求，`std::vector<bool>::iterator`也不符合前向迭代器的要求。因此，这种特化不能在期望向量的通用代码中使用。另一方面，作为一个向量，它具有与`std::bitset`不同的接口，并且不能被视为数字的二进制表示。没有直接的方法可以从数字或字符串构造`std::vector<bool>`，也不能将其转换为数字或字符串。
- en: Getting ready...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: This recipe assumes you are familiar with both `std::vector` and `std::bitset`.
    If you didn’t read the previous recipes, *Using vector as a default container* and
    *Using bitset for fixed-size sequences of bits*, you should do that before continuing.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例假设您熟悉`std::vector`和`std::bitset`。如果您没有阅读之前的示例，*将向量用作默认容器*和*使用bitset来表示固定大小的位序列*，请在继续之前阅读。
- en: The `vector<bool>` class is available in the `std` namespace in the `<vector>` header.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`vector<bool>`类在`<vector>`头文件中的`std`命名空间中可用。'
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To manipulate an `std::vector<bool>`, use the same methods you would use for
    an `std::vector<T>`, as shown in the following examples:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要操作`std::vector<bool>`，可以使用与`std::vector<T>`相同的方法，如下例所示：
- en: 'Creating an empty vector:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个空向量：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Adding bits to the vector:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向向量中添加位：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Setting the values of individual bits:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置单个位的值：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Using generic algorithms:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用算法：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Removing bits from the vector:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从向量中删除位：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`std::vector<bool>` is not a standard vector because it is designed to provide
    space optimization by storing a single bit for each element instead of a Boolean
    value. Therefore, its elements are not stored in a contiguous sequence and cannot
    be substituted for an array of Booleans. Due to this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector<bool>`不是标准向量，因为它旨在通过存储每个元素的单个位而不是布尔值来提供空间优化。因此，它的元素不是以连续序列存储的，也不能替代布尔数组。由于这个原因：'
- en: 'The index operator cannot return a reference to a specific element because
    elements are not stored individually:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引运算符不能返回对特定元素的引用，因为元素不是单独存储的：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Dereferencing an iterator cannot produce a reference to `bool` for the same
    reason as mentioned earlier:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出于前面提到的同样原因，解引用迭代器不能产生对`bool`的引用：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There is no guarantee that individual bits can be manipulated independently
    at the same time from different threads.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不能保证单个位可以在不同线程中同时独立操作。
- en: The vector cannot be used with algorithms that require forward iterators, such
    as `std::search()`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量不能与需要前向迭代器的算法一起使用，比如`std::search()`。
- en: The vector cannot be used in some generic code where `std::vector<T>` is expected
    if such code requires any of the operations mentioned in this list.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这样的代码需要在列表中提到的任何操作，`std::vector<T>`无法满足预期，那么向量就不能在一些通用代码中使用。
- en: An alternative to `std::vector<bool>` is `std::dequeu<bool>`, which is a standard
    container (a double-ended queue) that meets all container and iterator requirements
    and can be used with all standard algorithms. However, this will not have the
    space optimization that `std::vector<bool>` is providing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector<bool>`的替代方案是`std::dequeu<bool>`，它是一个标准容器（双端队列），满足所有容器和迭代器的要求，并且可以与所有标准算法一起使用。然而，这不会像`std::vector<bool>`提供空间优化。'
- en: There's more...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `std::vector<bool>` interface is very different from `std::bitset`. If
    you want to be able to write code in a similar manner, you can create a wrapper
    on `std::vector<bool>`, which looks like `std::bitset`, where possible. The following
    implementation provides members similar to what is available in `std::bitset`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector<bool>`接口与`std::bitset`非常不同。如果想以类似的方式编写代码，可以创建一个在`std::vector<bool>`上的包装器，看起来像`std::bitset`。以下实现提供了类似于`std::bitset`中可用的成员：'
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is only a basic implementation, and if you want to use such a wrapper,
    you should add additional methods, such as bit logic operations, shifting, maybe
    reading and writing from and to streams, and so on. However, with the preceding
    code, we can write the following examples:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个基本的实现，如果要使用这样的包装器，应该添加额外的方法，比如位逻辑操作、移位、也许从流中读取和写入等等。然而，通过上述代码，我们可以写出以下例子：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: See also
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using vector as a default container*'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将向量用作默认容器*'
- en: '*Using bitset for fixed-size sequences of bits*'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用bitset来表示固定大小的位序列*'
- en: Finding elements in a range
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在范围内查找元素
- en: One of the most common operations we do in any application is searching through
    data. Therefore, it is not surprising that the standard library provides many
    generic algorithms for searching through standard containers or anything that
    can represent a range and is defined by a start and a past-the-end iterator. In
    this recipe, we will see what these standard algorithms are and how they can be
    used.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中，我们经常做的最常见的操作之一就是搜索数据。因此，标准库提供了许多用于搜索标准容器或任何可以表示范围并由开始和结束迭代器定义的东西的通用算法，这并不奇怪。在这个示例中，我们将看到这些标准算法是什么，以及它们如何使用。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For all the examples in this recipe, we will use `std::vector`, but all algorithms
    work with ranges defined by a begin and past-the-end, either input or forward
    iterators, depending on the algorithm (for more information about the various
    types of iterators, see the recipe, *Writing your own random access iterator*).
    All these algorithms are available in the `std` namespace in the `<algorithm>` header.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中的所有示例中，我们将使用`std::vector`，但所有算法都适用于由开始和结束迭代器定义的范围，无论是输入迭代器还是前向迭代器，具体取决于算法（有关各种类型迭代器的更多信息，请参阅示例*编写自己的随机访问迭代器*）。所有这些算法都在`<algorithm>`头文件中的`std`命名空间中可用。
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following is a list of algorithms that can be used for finding elements
    in a range:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以用于在范围中查找元素的算法列表：
- en: 'Use `std::find()` to find a value in a range; this algorithm returns an iterator
    to the first element equal to the value:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::find()`来在范围中查找值；这个算法返回一个迭代器，指向第一个等于该值的元素：
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Use `std::find_if()` to find a value in a range that meets a criterion from
    a unary predicate; this algorithm returns an iterator to the first element for
    which the predicate returns `true`:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::find_if()`来查找范围中满足一元谓词条件的值；这个算法返回一个迭代器，指向谓词返回`true`的第一个元素：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Use `std::find_if_not()` to find a value in a range that does not meet a criterion
    from a unary predicate; this algorithm returns an iterator to the first element
    for which the predicate returns `false`:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::find_if_not()`来查找范围中不满足一元谓词的条件的值；这个算法返回一个迭代器，指向谓词返回`false`的第一个元素：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Use `std::find_first_of()` to search for the occurrence of any value from a
    range in another range; this algorithm returns an iterator to the first element
    that is found:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::find_first_of()`在另一个范围中搜索来自另一个范围的任何值的出现；这个算法返回一个迭代器，指向找到的第一个元素：
- en: '[PRE51]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Use `std::find_end()` to find the last occurrence of a subrange of elements
    in a range; this algorithm returns an iterator to the first element of the last
    subrange in the range:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::find_end()`来查找范围中元素子范围的最后出现；这个算法返回一个迭代器，指向范围中最后一个子范围的第一个元素：
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Use `std::search()` to search for the first occurrence of a subrange in a range;
    this algorithm returns an iterator to the first element of the subrange in the
    range:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::search()`来查找范围中子范围的第一个出现；这个算法返回一个迭代器，指向范围中子范围的第一个元素：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Use `std::search()` with a *searcher*, which is a class that implements a searching
    algorithm and meets some predefined criteria. This overload of `std::search()` was
    introduced in C++17, and available standard searchers implement the *Boyer-Moore*
    and the *Boyer-Moore-Horspool* string searching algorithms:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有*searcher*的`std::search()`，*searcher*是实现搜索算法并满足一些预定义标准的类。这个重载的`std::search()`是在C++17中引入的，可用的标准searchers实现了*Boyer-Moore*和*Boyer-Moore-Horspool*字符串搜索算法：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Use `std::search_n()` to search for *N* consecutive occurrences of a value
    in a range; this algorithm returns an iterator to the first element of the found
    sequence in the range:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::search_n()`来在范围中搜索值的*N*个连续出现；这个算法返回一个迭代器，指向范围中找到的序列的第一个元素：
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Use `std::adjacent_find()` to find two adjacent elements in a range that are
    equal or satisfy a binary predicate; this algorithm returns an iterator to the
    first element that is found:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::adjacent_find()`来查找范围中相邻的两个元素，它们相等或满足二元谓词；这个算法返回一个迭代器，指向找到的第一个元素：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Use `std::binary_search()` to find whether an element exists in a sorted range;
    this algorithm returns a Boolean value to indicate whether the value was found
    or not:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::binary_search()`来查找排序范围中是否存在元素；这个算法返回一个布尔值，指示是否找到了该值：
- en: '[PRE57]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Use `std::lower_bound()` to find the first element in a range not less than
    a specified value; this algorithm returns an iterator to the element:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::lower_bound()`来查找范围中第一个不小于指定值的元素；这个算法返回一个指向元素的迭代器：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Use `std::upper_bound()` to find the first element in a range greater than
    a specified value; this algorithm returns an iterator to the element:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::upper_bound()`来查找范围中大于指定值的第一个元素；这个算法返回一个指向元素的迭代器：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Use `std::equal_range()` to find a subrange in a range whose values are equal
    to a specified value. This algorithm returns a pair of iterators defining the
    first and the one-past-end iterators to the subrange; these two iterators are
    equivalent to those returned by `std::lower_bound()` and `std::upper_bound()`:'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::equal_range()`来查找范围中值等于指定值的子范围。这个算法返回一对迭代器，定义了子范围的第一个和结束迭代器；这两个迭代器等同于`std::lower_bound()`和`std::upper_bound()`返回的迭代器：
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The way these algorithms work is very similar: they all take as arguments iterators
    that define the searchable range and additional arguments that depend on each
    algorithm. Except for `std::search()`, which returns a Boolean, and `std::equal_range()`,
    which returns a pair of iterators, they all return an iterator to the searched
    element or to a subrange. These iterators must be compared with the end iterator
    (that is, the past-last-element) of the range to check whether the search was
    successful or not. If the search did not find an element or a subrange, then the
    returned value is the end iterator.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法的工作方式非常相似：它们都以定义可搜索范围的迭代器和依赖于每个算法的其他参数作为参数。除了`std::search()`返回一个布尔值，`std::equal_range()`返回一对迭代器之外，它们都返回指向搜索元素或子范围的迭代器。这些迭代器必须与范围的结束迭代器（即最后一个元素之后的位置）进行比较，以检查搜索是否成功。如果搜索没有找到元素或子范围，则返回值是结束迭代器。
- en: All these algorithms have multiple overloads, but in the *How to do it...* section,
    we only looked at one particular overload to show how the algorithm can be used.
    For a complete reference of all overloads, you should see other sources.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些算法都有多个重载，但在*如何做...*部分，我们只看了一个特定的重载，以展示如何使用该算法。要获取所有重载的完整参考，请参阅其他来源。
- en: In all the preceding examples, we used constant iterators, but all these algorithms
    work the same with mutable iterators and with reverse iterators. Because they
    take iterators as input arguments, they can work with standard containers, C-like
    arrays, or anything that represents a sequence and has iterators available.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的示例中，我们使用了常量迭代器，但是所有这些算法都可以使用可变迭代器和反向迭代器。因为它们以迭代器作为输入参数，所以它们可以使用标准容器、类C数组或任何表示序列并具有迭代器的东西。
- en: 'A special note on the `std::binary_search()` algorithm is necessary: the iterator
    parameters that define the range to search in should at least meet the requirements
    of the forward iterators. Regardless of the type of the supplied iterators, the
    number of comparisons is always logarithmic on the size of the range. However,
    the number of iterator increments is different if the iterators are random access,
    in which case the number of increments is also logarithmic, or are not random
    access, in which case, it is linear and proportional to the size of the range.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要特别注意`std::binary_search()`算法：定义要搜索的范围的迭代器参数至少应满足前向迭代器的要求。无论提供的迭代器的类型如何，比较的次数始终与范围的大小的对数成正比。但是，如果迭代器是随机访问的，则迭代器的增量数量是不同的，在这种情况下，增量的数量也是对数的，或者不是随机访问的，这种情况下，它是线性的，并且与范围的大小成正比。
- en: 'All these algorithms, except for `std::find_if_not()`, were available before
    C++11\. However, some overloads of them have been introduced in the newer standards.
    An example is `std::search()` that has several overloads introduced in C++17\.
    One of these overloads has the following form:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`std::find_if_not()`之外，所有这些算法在C++11之前就已经存在。但是，它们的一些重载已经在更新的标准中引入。例如，`std::search()`在C++17中引入了几个重载。其中一个重载的形式如下：
- en: '[PRE61]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This overload searches for the occurrence of a pattern defined by a searcher
    function object for which the standard provides several implementations:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此重载搜索由搜索器函数对象定义的模式的出现，标准提供了几种实现：
- en: '`default_searcher` basically delegates the searching to the standard `std::search()`
    algorithm.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_searcher` 基本上将搜索委托给标准的`std::search()`算法。'
- en: '`boyer_moore_searcher` implements the Boyer-Moore algorithm for string searching.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boyer_moore_searcher` 实现了Boyer-Moore算法用于字符串搜索。'
- en: '`boyer_moore_horspool_algorithm` implements the Boyer-Moore-Horspool algorithm
    for string searching.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boyer_moore_horspool_algorithm` 实现了Boyer-Moore-Horspool算法用于字符串搜索。'
- en: There's more...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Many standard containers have a member function `find()`, for finding elements
    in the container. When such a method is available and suits your needs, it should
    be preferred to the general algorithms because these member functions are optimized
    based on the particularities of each container.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 许多标准容器都有一个成员函数`find()`，用于在容器中查找元素。当这样的方法可用且符合您的需求时，应优先使用这些成员函数，因为这些成员函数是根据每个容器的特点进行了优化。
- en: See also
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using vector as a default container*'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用向量作为默认容器*'
- en: '*Initializing a range*'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始化范围*'
- en: '*Using set operations on a range*'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在范围上使用集合操作*'
- en: '*Sorting a range*'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对范围进行排序*'
- en: Sorting a range
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对范围进行排序
- en: In the previous recipe, we looked at the standard general algorithms for searching
    in a range. Another common operation we often need to do is sorting a range because many
    routines, including some of the algorithms for searching, require a sorted range.
    The standard library provides several general algorithms for sorting ranges, and
    in this recipe, we will see what these algorithms are and how they can be used.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的食谱中，我们看了搜索范围的标准通用算法。我们经常需要做的另一个常见操作是对范围进行排序，因为许多例程，包括一些搜索算法，都需要排序的范围。标准库提供了几个用于对范围进行排序的通用算法，在本食谱中，我们将看到这些算法是什么，以及它们如何使用。
- en: Getting ready
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The sorting general algorithms work with ranges defined by a start and end iterator
    and, therefore, can sort standard containers, C-like arrays, or anything that
    represents a sequence and has random iterators available. However, all the examples
    in this recipe will use `std::vector`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 排序通用算法使用由开始和结束迭代器定义的范围，并且可以对标准容器、类C数组或任何表示序列并具有随机迭代器的东西进行排序。但是，本食谱中的所有示例都将使用`std::vector`。
- en: How to do it...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following is a list of standard general algorithms for searching a range:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是搜索范围的标准通用算法列表：
- en: 'Use `std::sort()` for sorting a range:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::sort()`对范围进行排序：
- en: '[PRE62]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Use `std::stable_sort()` for sorting a range but keeping the order of the equal
    elements:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::stable_sort()`对范围进行排序，但保持相等元素的顺序：
- en: '[PRE63]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Use `std::partial_sort()` for sorting a part of a range (and leaving the rest
    in an unspecified order):'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::partial_sort()`对范围的一部分进行排序（并使其余部分处于未指定的顺序）：
- en: '[PRE64]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Use `std::partial_sort_copy()` for sorting a part of a range by copying the
    sorted elements to a second range and leaving the original range unchanged:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::partial_sort_copy()`对范围的一部分进行排序，通过将已排序的元素复制到第二个范围并保持原始范围不变：
- en: '[PRE65]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Use `std::nth_element()` for sorting a range so that the *N*th element is the
    one that would be in that position if the range was completely sorted, and the
    elements before it are all smaller and the ones after it are all greater, without
    any guarantee that they are also ordered:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::nth_element()`对范围进行排序，使得第*N*个元素是如果范围完全排序时将在该位置的元素，并且它之前的元素都更小，之后的元素都更大，没有任何保证它们也是有序的：
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Use `std::is_sorted()` to check whether a range is sorted:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::is_sorted()`来检查一个范围是否已排序：
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Use `std::is_sorted_until()` to find a sorted subrange from the beginning of
    a range:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::is_sorted_until()`来从范围的开头找到一个已排序的子范围：
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works...
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All the preceding general algorithms take random iterators as arguments to define
    the range to be sorted and, some of them additionally take an output range. They
    all have overloads, one that requires a comparison function for sorting the elements,
    and one that does not and uses `operator<` for comparing the elements.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前面的一般算法都接受随机迭代器作为参数来定义要排序的范围，并且其中一些还额外接受一个输出范围。它们都有重载，一个需要比较函数来对元素进行排序，另一个不需要，并使用`operator<`来比较元素。
- en: 'These algorithms work in the following way:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些算法的工作方式如下：
- en: '`std::sort()` modifies the input range so that its elements are sorted according
    to the default or the specified comparison function; the actual algorithm for
    sorting is an implementation detail.'
  id: totrans-265
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::sort()`修改输入范围，使其元素根据默认或指定的比较函数进行排序；排序的实际算法是一个实现细节。'
- en: '`std::stable_sort()` is similar to `std::sort()`, but it guarantees to preserve
    the original order of elements that are equal.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::stable_sort()`类似于`std::sort()`，但它保证保留相等元素的原始顺序。'
- en: '`std::partial_sort()` takes three iterator arguments indicating the first,
    middle, and last element in a range, where middle can be any element, not just
    the one at the natural middle position. The result is a partially sorted range
    so that that first `middle - first` smallest elements from the original range,
    that is, `[first, last)`, are found in the `[first, middle)` subrange and the
    rest of the elements are in an unspecified order, in the `[middle, last)` subrange.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::partial_sort()`接受三个迭代器参数，表示范围中的第一个、中间和最后一个元素，其中中间可以是任何元素，而不仅仅是自然中间位置的元素。结果是一个部分排序的范围，使得原始范围的前`middle
    - first`个最小元素，即`[first, last)`，在`[first, middle)`子范围中找到，其余元素以未指定的顺序在`[middle,
    last)`子范围中。'
- en: '`std::partial_sort_copy()` is not a variant of `std::partial_copy()`, as the
    name may suggest, but of `std::sort()`. It sorts a range without altering it by
    copying its elements to an output range. The arguments of the algorithm are the
    first and last iterators of the input and output ranges. If the output range has
    a size *M* that is greater than or equal to the size *N* of the input range, the
    input range is entirely sorted and copied to the output range; the first *N* elements
    of the output range are overwritten, and the last *M - N* elements are left untouched.
    If the output range is smaller than the input range, then only the first *M* sorted
    elements from the input range are copied to the output range (which is entirely
    overwritten in this case).'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::partial_sort_copy()`不是`std::partial_copy()`的变体，正如名称可能暗示的那样，而是`std::sort()`的变体。它对范围进行排序，而不改变它，通过将其元素复制到输出范围。算法的参数是输入范围和输出范围的第一个和最后一个迭代器。如果输出范围的大小*M*大于或等于输入范围的大小*N*，则输入范围完全排序并复制到输出范围；输出范围的前*N*个元素被覆盖，最后*M-N*个元素保持不变。如果输出范围小于输入范围，则只有输入范围中的前*M*个排序元素被复制到输出范围（在这种情况下，输出范围完全被覆盖）。'
- en: '`std::nth_element()` is basically an implementation of a selection algorithm,
    which is an algorithm for finding the *N*th smallest element of a range. This
    algorithm takes three iterator arguments representing the first, *N*th, and last
    element, and partially sorts the range so that after sorting, the *N*th element
    is the one that would be in that position if the range had been entirely sorted.
    In the modified range, all the *N-1* elements before the *n*th one are smaller
    than it, and all the elements after the *n*th element are greater than it. However,
    there is no guarantee on the order of these other elements.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::nth_element()`基本上是选择算法的实现，这是一种用于找到范围中第*N*个最小元素的算法。该算法接受三个迭代器参数，表示范围的第一个、第*N*个和最后一个元素，并部分排序范围，以便在排序后，第*N*个元素是如果范围已完全排序时将在该位置的元素。在修改后的范围中，第*n*个元素之前的所有*N-1*个元素都小于它，第*n*个元素之后的所有元素都大于它。但是，这些其他元素的顺序没有保证。'
- en: '`std::is_sorted()` checks whether the specified range is sorted according to
    the specified or default comparison function and returns a Boolean value to indicate
    that.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::is_sorted()`检查指定范围是否根据指定或默认的比较函数进行排序，并返回一个布尔值来指示。'
- en: '`std::is_sorted_until()` finds a sorted subrange of the specified range, starting
    from the beginning, using either a provided comparison function or the default
    `operator<`. The returned value is an iterator representing the upper bound of
    the sorted subrange, which is also the iterator of the one-past-last sorted element.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::is_sorted_until()`找到指定范围的已排序子范围，从开头开始，使用提供的比较函数或默认的`operator<`。返回的值是表示已排序子范围的上界的迭代器，也是最后一个已排序元素的迭代器。'
- en: There's more...
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Some standard containers, `std::list` and `std::forward_list`, provide a member
    function, `sort()`, which is optimized for those containers. These member functions
    should be preferred over the general standard algorithm, `std::sort()`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一些标准容器，如`std::list`和`std::forward_list`，提供了一个成员函数`sort()`，该函数针对这些容器进行了优化。应优先使用这些成员函数，而不是一般的标准算法`std::sort()`。
- en: See also
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using vector as a default container*'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用vector作为默认容器*'
- en: '*Initializing a range*'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始化一个范围*'
- en: '*Using set operations on a range*'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在范围上使用集合操作*'
- en: '*Finding elements in a range*'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在范围内查找元素*'
- en: Initializing a range
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化范围
- en: In the previous recipes, we explored the general standard algorithms for searching
    in a range and sorting a range. The algorithms library provides many other general
    algorithms and among them are several that are intended for filling a range with
    values. In this recipe, you will learn what these algorithms are and how they
    should be used.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们探索了用于在范围内搜索和对范围进行排序的一般标准算法。算法库提供了许多其他一般算法，其中包括用于填充范围值的几个算法。在本示例中，您将了解这些算法是什么以及应该如何使用它们。
- en: Getting ready
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: All the examples in this recipe use `std::vector`. However, like all the general
    algorithms, the ones we will see in this recipe take iterators to define the bounds
    of a range and can therefore be used with any standard container, C-like arrays,
    or custom types representing a sequence that have forward iterators defined.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的所有示例都使用`std::vector`。但是，像所有一般算法一样，我们将在本示例中看到的算法使用迭代器来定义范围的边界，因此可以与任何标准容器、类似C的数组或定义了前向迭代器的表示序列的自定义类型一起使用。
- en: Except for `std::iota()`, which is available in the `<numeric>` header, all
    the other algorithms are found in the `<algorithm>` header.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`std::iota()`，它在`<numeric>`头文件中可用，所有其他算法都在`<algorithm>`头文件中找到。
- en: How to do it...
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'To assign values to a range, use any of the following standard algorithms:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要为范围分配值，请使用以下任何标准算法：
- en: '`std::fill()` to assign a value to all the elements of a range; the range is
    defined by a first and last forward iterator:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fill()` 用于为范围内的所有元素分配一个值；范围由第一个和最后一个前向迭代器定义：'
- en: '[PRE69]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`std::fill_n()` to assign values to a number of elements of a range; the range
    is defined by a first forward iterator and a counter that indicates how many elements
    should be assigned the specified value:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::fill_n()` 用于为范围内的多个元素分配值；范围由第一个前向迭代器和一个计数器定义，该计数器指示应分配指定值的元素数量：'
- en: '[PRE70]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`std::generate()` to assign the value returned by a function to the elements
    of a range; the range is defined by a first and last forward iterator, and the
    function is invoked once for each element in the range:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::generate()` 用于将函数返回的值分配给范围内的元素；范围由第一个和最后一个前向迭代器定义，并且该函数为范围内的每个元素调用一次：'
- en: '[PRE71]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`std::generate_n()` to assign the value returned by a function to a number
    of elements of a range; the range is defined by a first forward iterator and a
    counter that indicates how many elements should be assigned the value from the
    function that is invoked once for each element:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::generate_n()` 用于将函数返回的值分配给范围内的多个元素；范围由第一个前向迭代器和一个计数器定义，该计数器指示应为每个元素调用一次的函数分配值：'
- en: '[PRE72]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`std::iota()` to assign sequentially increasing values to the elements of a
    range; the range is defined by a first and last forward iterator, and the values
    are incremented using the prefix `operator++` from an initial specified value:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::iota()` 用于为范围内的元素分配顺序递增的值；范围由第一个和最后一个前向迭代器定义，并且使用从指定初始值开始的前缀`operator++`递增值：'
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: How it works...
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`std::fill()` and `std::fill_n()` work similarly but differ in the way the
    range is specified: for the former by a first and last iterator, for the latter
    by a first iterator and a count. The second algorithm returns an iterator, representing
    either the one-past-last assigned element if the counter is greater than zero,
    or an iterator to the first element of the range otherwise.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::fill()` 和 `std::fill_n()` 的工作方式类似，但在指定范围的方式上有所不同：前者由第一个和最后一个迭代器指定，后者由第一个迭代器和计数指定。第二个算法返回一个迭代器，如果计数大于零，则表示代表最后一个分配的元素，否则表示范围的第一个元素的迭代器。'
- en: '`std::generate()` and `std::generate_n()` are also similar, differing only
    in the way the range is specified. The first takes two iterators, defining the
    range''s lower and upper bounds, and the second, an iterator to the first element
    and a count. Like `std::fill_n()`, `std::generate_n()` also returns an iterator,
    representing either the one-past-last assigned element if the count is greater
    than zero, or an iterator to the first element of the range, otherwise. These
    algorithms call a specified function for each element in the range and assign
    the returned value to the element. The generating function does not take any argument,
    so the value of the argument cannot be passed to the function as this is intended
    as a function to initialize the elements of a range. If you need to use the value
    of the elements to generate new values, you should use `std::transform()`.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::generate()` 和 `std::generate_n()` 也类似，只是在指定范围的方式上有所不同。第一个使用两个迭代器定义范围的下限和上限，第二个使用第一个元素的迭代器和计数。与`std::fill_n()`一样，`std::generate_n()`也返回一个迭代器，如果计数大于零，则表示代表最后一个分配的元素，否则表示范围的第一个元素的迭代器。这些算法为范围内的每个元素调用指定的函数，并将返回的值分配给元素。生成函数不接受任何参数，因此不能将参数的值传递给函数，因为这是用于初始化范围元素的函数。如果需要使用元素的值来生成新值，则应使用`std::transform()`。'
- en: '`std::iota()` takes its name from the ι (iota) function from the APL programming
    language, and though it was a part of the initial STL, it was only included in
    the standard library in C++11\. This function takes a first and last iterator
    to a range and an initial value that is assigned to the first element of the range
    and then used to generate sequentially increasing values using the prefix `operator++`
    for the rest of the elements in the range.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::iota()` 的名称取自 APL 编程语言中的 ι (iota) 函数，尽管它是最初的 STL 的一部分，但它仅在 C++11 中的标准库中包含。此函数接受范围的第一个和最后一个迭代器以及分配给范围的第一个元素的初始值，然后使用前缀`operator++`为范围中的其余元素生成顺序递增的值。'
- en: See also
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using vector as a default container*'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用向量作为默认容器*'
- en: '*Sorting a range*'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对范围进行排序*'
- en: '*Using set operations on a range*'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在范围上使用集合操作*'
- en: '*Finding elements in a range*'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在范围内查找元素*'
- en: '*Generating pseudo-random numbers* recipe of [Chapter 9](9830e5b8-a9ca-41e8-b565-8800a82d9caa.xhtml),
    *Working with Numbers and Strings*'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成伪随机数* 第9章的示例，*使用数字和字符串*'
- en: '*Initializing all bits of internal state of a pseudo-random number generator*
    recipe of [Chapter 9](9830e5b8-a9ca-41e8-b565-8800a82d9caa.xhtml), *Working with
    Numbers and Strings*'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始化伪随机数生成器的内部状态的所有位* 第9章的示例，*使用数字和字符串*'
- en: Using set operations on a range
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在范围上使用集合操作
- en: The standard library provides several algorithms for set operations that enable
    us to do unions, intersections, or differences of sorted ranges. In this recipe,
    we will see what these algorithms are and how they work.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了几种用于集合操作的算法，使我们能够对排序范围进行并集、交集或差异操作。在本示例中，我们将看到这些算法是什么以及它们是如何工作的。
- en: Getting ready
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The algorithms for set operations work with iterators, which means they can
    be used for standard containers, C-like arrays, or any custom type representing
    a sequence that has input iterators available. All the examples in this recipe
    will use `std::vector`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 集合操作的算法使用迭代器，这意味着它们可以用于标准容器、类似C的数组或任何表示具有输入迭代器的序列的自定义类型。本示例中的所有示例都将使用`std::vector`。
- en: 'For all the examples in the next section, we will use the following ranges:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一节中的所有示例，我们将使用以下范围：
- en: '[PRE74]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How to do it...
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Use the following general algorithms for set operations:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下通用算法进行集合操作：
- en: '`std::set_union()` to compute the union of two ranges into a third range:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set_union()`计算两个范围的并集并将结果存储到第三个范围中：'
- en: '[PRE75]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`std::merge()` to merge the content of two ranges into a third one; this is
    similar to `std::set_union()` except that it copies the entire content of the
    input ranges into the output one, not just their union:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::merge()`将两个范围的内容合并到第三个范围中；这类似于`std::set_union()`，不同之处在于它将输入范围的整个内容复制到输出范围中，而不仅仅是它们的并集：'
- en: '[PRE76]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`std::set_intersection()` to compute the intersection of the two ranges into
    a third range:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set_intersection()`计算两个范围的交集并将结果存储到第三个范围中：'
- en: '[PRE77]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '`std::set_difference()` to compute the difference of two ranges into a third
    range; the output range will contain elements from the first range, which are
    not present in the second range:'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set_difference()`计算两个范围的差异并将结果存储到第三个范围中；输出范围将包含来自第一个范围的元素，这些元素在第二个范围中不存在：'
- en: '[PRE78]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`std::set_symmetric_difference()` to compute a dual difference of the two ranges
    into a third range; the output range will contain elements that are present in
    any of the input ranges, but only in one:'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set_symmetric_difference()`计算两个范围的对称差并将结果存储到第三个范围中；输出范围将包含存在于任一输入范围中但仅存在于一个输入范围中的元素：'
- en: '[PRE79]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '`std::includes()` to check if one range is a subset of another range (that
    is, all its elements are also present in the other range):'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::includes()`用于检查一个范围是否是另一个范围的子集（即，它的所有元素也存在于另一个范围中）：'
- en: '[PRE80]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works...
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'All the set operations that produce a new range from two input ranges, in fact,
    have the same interface and work in a similar way:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 所有从两个输入范围产生新范围的集合操作实际上具有相同的接口，并且以类似的方式工作：
- en: They take two input ranges, each defined by a first and last input iterator.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们接受两个输入范围，每个范围由第一个和最后一个输入迭代器定义。
- en: They take an output iterator to an output range where elements will be inserted.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们接受一个输出迭代器，指向将插入元素的输出范围。
- en: They have an overload that takes an extra argument representing a comparison
    binary function object that must return `true` if the first argument is less than
    the second. When a comparison function object is not specified, `operator<` is
    used.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有一个重载，接受一个额外的参数，表示必须返回`true`的比较二进制函数对象，如果第一个参数小于第二个参数。当未指定比较函数对象时，将使用`operator<`。
- en: They return an iterator past the end of the constructed output range.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们返回一个指向构造的输出范围结尾的迭代器。
- en: The input ranges must be sorted using either `operator<` or the provided comparison
    function, depending on the overload that is used.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入范围必须使用`operator<`或提供的比较函数进行排序，具体取决于所使用的重载。
- en: The output range must not overlap any of the two input ranges.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出范围不得与两个输入范围重叠。
- en: 'We will demonstrate the way they work with additional examples using vectors
    of a POD type `Task` that we also used in a previous recipe:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用POD类型`Task`的向量进行额外示例，这与我们之前使用的类型相同：
- en: '[PRE81]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The particular way each algorithm produces the output range is described here:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 每个算法产生输出范围的特定方式在此处描述：
- en: '`std::set_union()` copies all the elements present in one or both of the input
    ranges to the output range, producing a new sorted range. If an element is found
    *M* times in the first range and *N* times in the second range, then all the *M*
    elements from the first range will be copied to the output range in their existing
    order, and then the *N-M* elements from the second range are copied to the output
    range if *N > M*, or 0 elements otherwise:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set_union()`将输入范围中存在的所有元素复制到输出范围，生成一个新的排序范围。如果一个元素在第一个范围中出现*M*次，在第二个范围中出现*N*次，那么第一个范围中的所有*M*个元素将按其现有顺序复制到输出范围中，然后如果*N
    > M*，则从第二个范围中复制* N-M *个元素到输出范围中，否则为0个元素：'
- en: '[PRE82]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '`std::merge()` copies all the elements from both the input ranges into the
    output range, producing a new range sorted with respect to the comparison function:'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::merge()`将两个输入范围中的所有元素复制到输出范围中，生成一个新的排序范围，其排序方式与比较函数有关：'
- en: '[PRE83]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`std::set_intersection()` copies all the elements that are found in both the
    input ranges into the output range, producing a new range sorted with respect
    to the comparison function:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set_intersection()`将在两个输入范围中找到的所有元素复制到输出范围中，生成一个新的排序范围，其排序方式与比较函数有关：'
- en: '[PRE84]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '`std::set_difference()` copies to the output range all the elements from the
    first input range that are not found in the second input range. For equivalent
    elements that are found in both the ranges, the following rule applies: if an
    element is found *M* times in the first range and *N* times in the second range,
    and if *M > N*, then it is copied *M-N* times; otherwise it is not copied:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set_difference()`将第一个输入范围中所有未在第二个输入范围中找到的元素复制到输出范围。对于在两个范围中找到的等效元素，适用以下规则：如果一个元素在第一个范围中出现*M*次，在第二个范围中出现*N*次，如果*M
    > N*，则复制*M-N*次；否则不复制：'
- en: '[PRE85]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '`std::set_symmetric_difference()` copies to the output range all the elements
    that are found in either of the two input ranges but not in both of them. If an
    element is found *M* times in the first range and *N* times in the second range,
    then if *M > N,* the last *M-N* of those elements from the first range are copied
    into the output rage, else, the last *N-M* of those elements from the second range
    will be copied into the output range:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::set_symmetric_difference()`将在两个输入范围中找到的元素中不在两者中都找到的元素复制到输出范围。如果一个元素在第一个范围中出现*M*次，在第二个范围中出现*N*次，则如果*M
    > N*，则将第一个范围中的最后*M-N*个元素复制到输出范围中，否则将第二个范围中的最后*N-M*个元素复制到输出范围中：'
- en: '[PRE86]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: On the other hand, `std::includes()` does not produce an output range; it only
    checks whether the second range is included in the first range. It returns a Boolean
    value that is `true` if the second range is empty or all its elements are included
    in the first range, or `false` otherwise. It also has two overloads, one of them
    specifying a comparison binary function object.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`std::includes()`不会产生输出范围；它只检查第二个范围是否包含在第一个范围中。如果第二个范围为空或其所有元素都包含在第一个范围中，则返回`true`；否则返回`false`。它还有两个重载，其中一个指定比较二进制函数对象。
- en: See also
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using vector as a default container*'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将向量用作默认容器*'
- en: '*Sorting a range*'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对范围进行排序*'
- en: '*Initializing a range*'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*初始化范围*'
- en: '*Using iterators to insert new elements in a container*'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用迭代器在容器中插入新元素*'
- en: '*Finding elements in a range*'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在范围中查找元素*'
- en: Using iterators to insert new elements in a container
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用迭代器在容器中插入新元素
- en: When you’re working with containers, it is often useful to insert new elements
    at the beginning, end, or somewhere in the middle. There are algorithms, such
    as the ones we saw in the previous recipe, *Using set operations on a range*,
    that require an iterator to a range to insert into, but if you simply pass an
    iterator, such as the one returned by `begin()`, it will not insert but overwrite
    the elements of the container. Moreover, it’s not possible to insert at the end
    by using the iterator returned by `end()`. In order to perform such operations,
    the standard library provides a set of iterators and iterator adapters that enable
    these scenarios.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用容器时，通常有必要在开头、结尾或中间某处插入新元素。有一些算法，比如我们在前面的食谱中看到的那些*在范围上使用集合操作*，需要一个范围的迭代器来插入，但如果你简单地传递一个迭代器，比如`begin()`返回的迭代器，它不会插入，而是覆盖容器的元素。此外，使用`end()`返回的迭代器无法在末尾插入。为了执行这样的操作，标准库提供了一组迭代器和迭代器适配器，使这些情况成为可能。
- en: Getting ready
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The iterators and adapters discussed in this recipe are available in the `std`
    namespace in the `<iterator>` header. If you include headers such as, `<algorithm>`,
    you do not have to explicitly include `<iterator>`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中讨论的迭代器和适配器在`<iterator>`头文件中的`std`命名空间中可用。如果包括诸如`<algorithm>`之类的头文件，则不必显式包括`<iterator>`。
- en: How to do it...
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Use the following iterator adapters to insert new elements in a container:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下迭代器适配器在容器中插入新元素：
- en: '`std::back_inserter()` to insert elements at the end, for containers that have
    a `push_back()` method:'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::back_inserter()`用于在末尾插入元素，适用于具有`push_back()`方法的容器：'
- en: '[PRE87]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`std::front_inserter()` to insert elements at the beginning, for containers
    that have a `push_front()` method:'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::front_inserter()`用于在开头插入元素，适用于具有`push_front()`方法的容器：'
- en: '[PRE88]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`std::inserter()` to insert anywhere in a container, for containers that have
    an `insert()` method:'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::inserter()`用于在容器中的任何位置插入，适用于具有`insert()`方法的容器：'
- en: '[PRE89]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: How it works...
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`std::back_inserter()`, `std::front_inserter()`, and `std::inserter()` are
    all helper functions that create iterator adapters of types, `std::back_insert_iterator`,
    `std::front_insert_iterator`, and `std::insert_iterator`. These are all output
    iterators that append, prepend, or insert into the container for which they were
    constructed. Incrementing and dereferencing these iterators does not do anything.
    However, upon assignment, these iterators call the following methods from the
    container:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::back_inserter()`、`std::front_inserter()`和`std::inserter()`都是创建类型为`std::back_insert_iterator`、`std::front_insert_iterator`和`std::insert_iterator`的迭代器适配器的辅助函数。这些都是输出迭代器，用于向它们构造的容器追加、前置或插入。增加和取消引用这些迭代器不会做任何事情。但是，在赋值时，这些迭代器调用容器的以下方法：'
- en: '`std::back_insterter_iterator` calls `push_back()`'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::back_insterter_iterator`调用`push_back()`'
- en: '`std::front_inserter_iterator` calls `push_front()`'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::front_inserter_iterator`调用`push_front()`'
- en: '`std::insert_iterator` calls `insert()`'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::insert_iterator`调用`insert()`'
- en: 'The following is the over-simplified implementation of `std::back_inserter_iterator`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`std::back_inserter_iterator`的过度简化实现：
- en: '[PRE90]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Because of the way the assignment operator works, these iterators can only
    be used with some standard containers:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 由于赋值运算符的工作方式，这些迭代器只能与一些标准容器一起使用：
- en: '`std::back_insert_iterator` can be used with `std::vector`, `std::list`, `std::deque`,
    and `std::basic_string`.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::back_insert_iterator`可以与`std::vector`、`std::list`、`std::deque`和`std::basic_string`一起使用。'
- en: '`std::front_insert_iterator` can be used with `std::list`, `std::forward_list`,
    and `std:deque`.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::front_insert_iterator`可与`std::list`、`std::forward_list`和`std:deque`一起使用。'
- en: '`std::insert_iterator` can be used with all the standard containers.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::insert_iterator`可以与所有标准容器一起使用。'
- en: 'The following example inserts three elements with the value 0 at the beginning
    of an `std::vector`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在`std::vector`的开头插入了三个值为0的元素：
- en: '[PRE91]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `std::inserter()` adapter takes two arguments: the container, and the iterator
    where an element is supposed to be inserted. Upon calling `insert()` on the container,
    the `std::insert_iterator` increments the iterator, so upon being assigned again,
    it can insert a new element into the next position. Here is how the assignment
    operator is implemented for this iterator adapter:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::inserter()`适配器接受两个参数：容器和元素应该插入的迭代器。在容器上调用`insert()`时，`std::insert_iterator`会增加迭代器，因此在再次分配时，它可以在下一个位置插入一个新元素。以下是为这个迭代器适配器实现的赋值运算符：'
- en: '[PRE92]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: There's more...
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'These iterator adapters are intended to be used with algorithms or functions
    that insert multiple elements into a range. They can be used, of course, to insert
    a single element, but that is rather an anti-pattern, since simply calling `push_back()`,
    `push_front()`, or `insert()` is much simpler and intuitive in this case. The
    following examples should be avoided:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这些迭代器适配器旨在与将多个元素插入范围的算法或函数一起使用。当然，它们也可以用于插入单个元素，但在这种情况下，只需调用`push_back()`、`push_front()`或`insert()`就更简单和直观了。应避免以下示例：
- en: '[PRE93]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: See also
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using set operations on a range*'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在范围上使用集合操作*'
- en: Writing your own random access iterator
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自己的随机访问迭代器
- en: In [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml), *Learning Modern
    Core Language Features*, we saw how we can enable range-based for loops for custom
    types by implementing iterators and free `begin()` and `end()` functions to return
    iterators to the first and one-past-the-last element of the custom range. You might
    have noticed that the minimal iterator implementation that we provided in that
    recipe does not meet the requirements for a standard iterator because it cannot
    be copy constructible or assigned and cannot be incremented. In this recipe, we
    will build upon that example and show how to create a random access iterator that
    meets all requirements.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml)中，*学习现代核心语言特性*，我们看到了如何通过实现迭代器和自由的`begin()`和`end()`函数来启用自定义类型的范围-based
    for循环，以返回自定义范围的第一个和最后一个元素的迭代器。您可能已经注意到，在该示例中提供的最小迭代器实现不符合标准迭代器的要求，因为它不能被复制构造或分配，也不能被递增。在这个示例中，我们将建立在这个示例的基础上，展示如何创建一个满足所有要求的随机访问迭代器。
- en: Getting ready
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you should know the types of iterators the standard defines
    and how they are different. A good overview of their requirements is available
    at [http://www.cplusplus.com/reference/iterator/](http://www.cplusplus.com/reference/iterator/).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您应该了解标准定义的迭代器类型及其不同之处。它们的要求的很好的概述可以在[http://www.cplusplus.com/reference/iterator/](http://www.cplusplus.com/reference/iterator/)上找到。
- en: 'To exemplify how to write a random access iterator, we will consider a variant
    of the `dummy_array` class used in the *Enabling range-based for loops for custom
    types* recipe of [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml), *Learning
    Modern Core Language Features*. This is a very simple array concept, with no practical
    value, other than serving as a code base for demonstrating iterators:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明如何编写随机访问迭代器，我们将考虑在[第8章](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml)的*为自定义类型启用基于范围的for循环*示例中使用的`dummy_array`类的变体，这是一个非常简单的数组概念，除了作为演示迭代器的代码库之外，没有实际价值：
- en: '[PRE94]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: All the code shown in the next section, the iterator classes, `typedef`s, and
    the `begin()` and `end()` functions, will be a part of this class.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节中显示的所有代码，迭代器类、`typedef`和`begin()`和`end()`函数，都将成为这个类的一部分。
- en: How to do it...
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To provide mutable and constant random access iterators for the `dummy_array`
    class shown in the previous section, add the following members to the class:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为前面部分显示的`dummy_array`类提供可变和常量随机访问迭代器，将以下成员添加到类中：
- en: 'An iterator class template, which is parameterized with the type of elements
    and the size of the array. The class must have the following public `typedef`s
    that define standard synonyms:'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器类模板，它是用元素的类型和数组的大小参数化的。该类必须有以下公共的`typedef`，定义标准的同义词：
- en: '[PRE95]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Private members for the iterator class: a pointer to the array data and a current
    index into the array:'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器类的私有成员：指向数组数据的指针和数组中的当前索引：
- en: '[PRE96]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Private method for the iterator class to check whether two iterator instances
    point to the same array data:'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器类的私有方法，用于检查两个迭代器实例是否指向相同的数组数据：
- en: '[PRE97]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'An explicit constructor for the iterator class:'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器类的显式构造函数：
- en: '[PRE98]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Iterator class members to meet common requirements for all iterators: copy-constructible,
    copy-assignable, destructible, prefix, and postfix incrementable. In this implementation,
    the post increment operator is implemented in terms of the pre-increment operator
    to avoid code duplication:'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器类成员以满足所有迭代器的通用要求：可复制构造，可复制分配，可销毁，前缀和后缀可递增。在这个实现中，后递增运算符是根据前递增运算符实现的，以避免代码重复：
- en: '[PRE99]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Iterator class members to meet input iterator requirements: test for equality/inequality,
    dereferenceable as rvalues:'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器类成员以满足输入迭代器要求：测试相等/不相等，作为右值解引用：
- en: '[PRE100]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Iterator class members to meet forward iterator requirements: default constructible:'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器类成员以满足前向迭代器要求：默认可构造：
- en: '[PRE101]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Iterator class members to meet bidirectional iterator requirements: decrementable:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器类成员以满足双向迭代器要求：可递减：
- en: '[PRE102]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Iterator class members to meet random access iterator requirements: arithmetic
    add and subtract, comparable for inequality with other iterators, compound assignments,
    and offset dereferenceable:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器类成员以满足随机访问迭代器要求：算术加和减，与其他迭代器不相等的可比性，复合赋值，和偏移解引用：
- en: '[PRE103]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Add `typedef`s to the `dummy_array` class for mutable and constant iterator
    synonyms:'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`dummy_array`类添加可变和常量迭代器的`typedef`：
- en: '[PRE104]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Add the public `begin()` and `end()` functions to the `dummy_array` class to
    return the iterators to the first and one-past-last elements in the array:'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加公共的`begin()`和`end()`函数到`dummy_array`类中，以返回数组中第一个和最后一个元素的迭代器：
- en: '[PRE105]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: How it works...
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The standard library defines five categories of iterators:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库定义了五种迭代器类别：
- en: '*Input iterators*: These are the simplest category and guarantee validity only
    for single-pass sequential algorithms. After being incremented, the previous copies
    may become invalid.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输入迭代器*：这是最简单的类别，仅保证单遍历顺序算法的有效性。增加后，之前的副本可能会变得无效。'
- en: '*Output iterators*: These are basically input iterators that can be used to
    write to the pointed element.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*输出迭代器*：这些基本上是可以用来写入指定元素的输入迭代器。'
- en: '*Forward iterators*: These can read (and write) data to the pointed element. They
    satisfy the requirements for input iterators and, in addition, must be default
    constructible and must support multi-pass scenarios without invalidating the previous
    copies.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*前向迭代器*：这些可以读取（和写入）指定元素的数据。它们满足输入迭代器的要求，并且此外，必须支持默认构造，并且必须支持多遍历场景而不使之前的副本无效。'
- en: '*Bidirectional iterators*: These are forward iterators that, in addition, support
    decrementing, so they can move in both directions.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双向迭代器*：这些是前向迭代器，此外，还支持递减，因此可以向两个方向移动。'
- en: '*Random access iterators*: These support access to any element in the container
    in constant time. They implement all the requirements for bidirectional iterators,
    and, in addition, support arithmetic operations `+` and `-`, compound assignments `+=`
    and `-=`, comparisons with other iterators with `<`, `<=`, `>`, `>=`, and the
    offset dereference operator.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*随机访问迭代器*：这些支持在常数时间内访问容器中的任何元素。它们实现了双向迭代器的所有要求，并且还支持算术运算`+`和`-`，复合赋值`+=`和`-=`，与其他迭代器的比较`<`，`<=`，`>`，`>=`，以及偏移解引用运算符。'
- en: Forward, bidirectional, and random access iterators that also implement the
    requirements of output iterators are called *mutable iterators*.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 还实现了输出迭代器要求的前向、双向和随机访问迭代器称为*可变迭代器*。
- en: In the previous section, we saw how to implement random access iterators, with
    a step-by-step walkthrough of the requirements of each category of iterators (as
    each iterator category includes the requirements of the previous category and
    adds new requirements). The iterator class template is common for both constant
    and mutable iterators, and we have defined two synonyms for it called `iterator`
    and `constant_iterator`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到了如何实现随机访问迭代器，逐步介绍了每个迭代器类别的要求（因为每个迭代器类别包括前一个迭代器类别的要求并添加新的要求）。迭代器类模板对于常量和可变迭代器是通用的，我们定义了两个同义词，称为`iterator`和`constant_iterator`。
- en: After implementing the inner iterator class template, we also defined the `begin()`
    and `end()` member functions that return an iterator to the first and the one-past-last
    element in the array. These methods have overloads to return mutable or constant
    iterators, depending on whether the `dummy_array` class instance is mutable or
    constant.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现内部迭代器类模板之后，我们还定义了`begin()`和`end()`成员函数，返回数组中第一个和最后一个元素的迭代器。这些方法有重载，根据`dummy_array`类实例是可变的还是常量的，返回可变或常量迭代器。
- en: 'With this implementation of the `dummy_array` class and its iterators, we can
    write the following samples. For more examples, check the source code that accompanies
    this book:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`dummy_array`类及其迭代器的这种实现，我们可以编写以下示例。有关更多示例，请查看本书附带的源代码：
- en: '[PRE106]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: There's more...
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Apart from `begin()` and `end()`, a container may have additional methods such
    as `cbegin()`/`cend()` (for constant iterators), `rbegin()`/`rend()` (for mutable
    reverse iterators), and `crbegin()`/ `crend()` (for constant reverse iterators).
    Implementing this is left as an exercise for you.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`begin()`和`end()`之外，容器可能还有其他方法，例如`cbegin()`/`cend()`（用于常量迭代器），`rbegin()`/`rend()`（用于可变反向迭代器），以及`crbegin()`/`crend()`（用于常量反向迭代器）。实现这一点留作练习给你。
- en: On the other hand, in modern C++, these functions that return the first and
    last iterators do not have to be member functions but can be provided as non-member
    functions. In fact, this is the topic of the next recipe, *Container access with
    non-member functions*.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在现代C++中，返回第一个和最后一个迭代器的这些函数不必是成员函数，而可以作为非成员函数提供。实际上，这是下一个配方的主题，*使用非成员函数访问容器*。
- en: See also
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Enabling range-based for loops for custom types* recipe of [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml),
    *Learning Modern Core Language Features*'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml)的*学习现代核心语言特性*配方中的为自定义类型启用基于范围的for循环'
- en: '*Creating type aliases and alias templates* recipe of [Chapter 8](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml),
    *Learning Modern Core Language Features*'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第8章](6737b7e9-2260-4f5a-989b-ead3eb7d9dc1.xhtml)的*学习现代核心语言特性*配方中的创建类型别名和别名模板'
- en: Container access with non-member functions
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用非成员函数访问容器
- en: Standard containers provide the `begin()` and `end()` member functions for retrieving
    iterators to the first and one-past-last element of the container. There are actually
    four sets of these functions. Apart from `begin()`/`end()`, containers provide
    `cbegin()`/`cend()` to return constant iterators, `rbegin()`/`rend()` to return
    mutable reverse iterators, and `crbegin()`/`crend()` to return constant reverse
    iterators. In C++11/C++14, all these have non-member equivalents that work with
    standard containers, C-like arrays, and any custom type that specializes them.
    In C++17, even more non-member functions have been added; `std::data()`--that
    returns a pointer to the block of memory containing the elements of the container,
    `std::size()`--that returns the size of a container or array, and `std::empty()`--that
    returns whether the given container is empty.  These non-member functions are
    intended for generic code but can be used anywhere in your code.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 标准容器提供了`begin()`和`end()`成员函数，用于检索容器的第一个和最后一个元素的迭代器。实际上有四组这样的函数。除了`begin()`/`end()`，容器还提供了`cbegin()`/`cend()`来返回常量迭代器，`rbegin()`/`rend()`来返回可变的反向迭代器，以及`crbegin()`/`crend()`来返回常量反向迭代器。在C++11/C++14中，所有这些都有非成员等价物，可以与标准容器、类C数组和任何专门化它们的自定义类型一起使用。在C++17中，甚至添加了更多的非成员函数；`std::data()`--返回指向包含容器元素的内存块的指针，`std::size()`--返回容器或数组的大小，`std::empty()`--返回给定容器是否为空。这些非成员函数用于通用代码，但可以在代码的任何地方使用。
- en: Getting ready
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use as an example, the `dummy_array` class and its iterators
    that we implemented in the previous recipe, *Writing your own random access iterator*.
    You should read that recipe before continuing with this one.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将以我们在上一个配方中实现的`dummy_array`类及其迭代器为例。在继续本配方之前，您应该先阅读那个配方。
- en: 'Non-member `begin()`/`end()` functions and the other variants, as well as non-member
    `data()`, `size()` and `empty()` are available in the `std` namespace in the `<iterator>` header,
    which is implicitly included with any of the following headers: `<array>`, `<deque>`,
    `<forward_list>`, `<list>`, `<map>`, `<regex>`, `<set>`, `<string>`, `<unordered_map>`,
    `<unordered_set>`, and `<vector>`.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 非成员`begin()`/`end()`函数和其他变体，以及非成员`data()`、`size()`和`empty()`在`std`命名空间中的`<iterator>`头文件中可用，该头文件隐式地包含在以下任何一个头文件中：`<array>`、`<deque>`、`<forward_list>`、`<list>`、`<map>`、`<regex>`、`<set>`、`<string>`、`<unordered_map>`、`<unordered_set>`和`<vector>`。
- en: In this recipe, we will refer to the `std::begin()`/`std::end()` functions,
    but everything discussed also applies to the other functions: `std::cbegin()`/`std::cend()`,
    `std::rbegin()`/`std::rend()`, and `std::crbegin()`/`std::crend()`.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将提到`std::begin()`/`std::end()`函数，但讨论的一切也适用于其他函数：`std::cbegin()`/`std::cend()`、`std::rbegin()`/`std::rend()`和`std::crbegin()`/`std::crend()`。
- en: How to do it...
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Use the non-member `std::begin()`/`std::end()` function and the other variants,
    as well as `std::data()`, `std::size()` and `std::empty()`  with:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非成员`std::begin()`/`std::end()`函数和其他变体，以及`std::data()`、`std::size()`和`std::empty()`与：
- en: 'Standard containers:'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准容器：
- en: '[PRE107]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '(C-like) arrays:'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （类似C的）数组：
- en: '[PRE108]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Custom types that provide corresponding member functions, `begin()`/`end()`,
    `data()`, `empty()`, or `size()`:'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供相应成员函数`begin()`/`end()`、`data()`、`empty()`或`size()`的自定义类型：
- en: '[PRE109]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Generic code where the type of the container is not known:'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型未知的通用代码：
- en: '[PRE110]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: How it works...
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'These non-member functions were introduced in different versions of the standard,
    but all of them were modified in C++17 to return `constexpr auto`:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这些非成员函数是在不同版本的标准中引入的，但它们在C++17中都被修改为返回`constexpr auto`：
- en: '`std::begin()` and `std::end()` in C++11'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++11中的`std::begin()`和`std::end()`
- en: '`std::cbegin()`/`std::cend()`, `std::rbegin()`/`std::rend()`, and `std::crbegin()`/`std::crend()`
    in C++14'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::cbegin()`/`std::cend()`，`std::rbegin()`/`std::rend()`和`std::crbegin()`/`std::crend()`在C++14中'
- en: '`std::data()`, `std::size()`, and `std::empty()` in C++17'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++17中的`std::data()`、`std::size()`和`std::empty()`
- en: 'The `begin()`/`end()` family of functions have overloads for container classes
    and arrays, and all they do is the following:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin()`/`end()`函数族有容器类和数组的重载，它们所做的只是：'
- en: Return the results of calling the container-corresponding member function for
    containers.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回调用容器对应成员函数的结果。
- en: Return a pointer to the first or one-past-last element of the array for arrays.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回数组的第一个或最后一个元素的指针。
- en: 'The actual typical implementation for `std::begin()`/`std::end()` is the following:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::begin()`/`std::end()`的实际典型实现如下：'
- en: '[PRE111]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Custom specialization can be provided for containers that do not have corresponding
    `begin()`/`end()` members but can still be iterated. The standard library actually
    provides such specializations for `std::initializer_list` and `std::valarray`.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为没有相应的`begin()`/`end()`成员但仍可迭代的容器提供自定义专门化。标准库实际上为`std::initializer_list`和`std::valarray`提供了这样的专门化。
- en: Specializations must be defined in the same namespace where the original class
    or function template has been defined. Therefore, if you want to specialize any
    of the `std::begin()`/`std::end()` pairs you must do it in the `std` namespace.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在定义原始类或函数模板的相同命名空间中定义专门化。因此，如果要专门化任何`std::begin()`/`std::end()`对，必须在`std`命名空间中执行。
- en: 'The other non-member functions for container access, that were introduced in
    C++17, have also several overloads:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: C++17中引入的用于容器访问的其他非成员函数也有几个重载：
- en: '`std::data()` has several overloads; for a class `C` it returns `c.data()`,
    for arrays it returns the `array`, and for `std::initializer_list<T>` it returns
    the `il.begin()`.'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::data()`有几个重载；对于类`C`，它返回`c.data()`，对于数组，它返回数组，对于`std::initializer_list<T>`，它返回`il.begin()`。'
- en: '[PRE112]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '`std::size()` has two overloads; for a class `C` it returns `c.size()`, and
    for arrays it returns the size `N`.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::size()`有两个重载；对于类`C`，它返回`c.size()`，对于数组，它返回大小`N`。'
- en: '[PRE113]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '`std::empty()` has several overloads; for a class `C` it returns `c.empty()`,
    for arrays it returns `false`, and for `std::initializer_list<T>` it returns `il.size()
    == 0`.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::empty()` 有几种重载形式；对于类 `C`，它返回 `c.empty()`，对于数组它返回 `false`，对于 `std::initializer_list<T>`
    它返回 `il.size() == 0`。'
- en: '[PRE114]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: There's more...
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: These non-member functions are mainly intended for template code where the container
    is not known and can be a standard container, a C-like array, or a custom type.
    Using the non-member version of these functions enables us to write simpler and
    less code that works with all these types of containers.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这些非成员函数主要用于模板代码，其中容器类型未知，可以是标准容器、类似C的数组或自定义类型。使用这些函数的非成员版本使我们能够编写更简单、更少的代码，可以处理所有这些类型的容器。
- en: However, the use of these functions is not and should not be limited to generic
    code. Though it is rather a matter of personal preference, it can be a good habit
    to be consistent and use them everywhere in your code. All these methods have
    lightweight implementations that will most likely be inlined by the compiler,
    which means that there will be no overhead at all over using the corresponding
    member functions.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用这些函数并不应该局限于通用代码。虽然这更多是个人偏好的问题，但保持一致并在代码中的任何地方使用它们可能是一个好习惯。所有这些方法都有轻量级的实现，很可能会被编译器内联，这意味着与使用相应的成员函数相比，不会有任何额外开销。
- en: See also
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Writing your own random access iterator*'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编写自己的随机访问迭代器*'
