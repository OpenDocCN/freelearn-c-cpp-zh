- en: Chapter 9. User Interfaces – UI and UMG
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。用户界面-UI和UMG
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Drawing using Canvas
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Canvas进行绘图
- en: Adding Slate Widgets to the screen
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Slate小部件添加到屏幕上
- en: Creating screen size-aware scaling for the UI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为UI创建适应屏幕大小的缩放
- en: Displaying and hiding a sheet of UMG elements in-game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏中显示和隐藏一组UMG元素
- en: Attaching function calls to Slate events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数调用附加到Slate事件
- en: Using Data Binding with Unreal Motion Graphics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据绑定与Unreal Motion Graphics
- en: Controlling widget appearance with Styles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用样式控制小部件外观
- en: Creating a custom `SWidget`/`UWidget`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义的SWidget/UWidget
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Displaying feedback to the player is one of the most important elements within
    game design, and this will usually involve some sort of HUD, or at least menus,
    within your game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 向玩家显示反馈是游戏设计中最重要的元素之一，这通常涉及到HUD或至少游戏中的菜单。
- en: In previous versions of Unreal, there was simple HUD support, which allowed
    you to draw simple shapes and text to the screen. However, it was somewhat limited
    in terms of aesthetics, and so, solutions such as **Scaleform** became common
    to work around the limitations. Scaleform leveraged Adobe's Flash file format
    to store vector images and UI scripts. It was not without its own cons for developers,
    though, not least the cost—it was a third-party product requiring an (at times
    expensive) license.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的Unreal版本中，有简单的HUD支持，允许您在屏幕上绘制简单的形状和文本。然而，从美学角度来看，它在某种程度上有一定的限制，因此，诸如Scaleform之类的解决方案变得常见，以解决这些限制。Scaleform利用Adobe的Flash文件格式来存储矢量图像和UI脚本。然而，对于开发人员来说，它也有自己的缺点，尤其是成本方面-它是一个第三方产品，需要（有时昂贵的）许可证。
- en: As a result, Epic developed Slate for the Unreal 4 editor and the in-game UI
    framework. Slate is a collection of widgets (UI elements) and a framework allowing
    a cross-platform interface for the Editor. It is also usable in-game to draw widgets,
    such as sliders and buttons, for menus and HUDs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Epic为Unreal 4编辑器和游戏内UI框架开发了Slate。Slate是一组小部件（UI元素）和一个框架，允许在编辑器中进行跨平台界面。它也可用于游戏中绘制小部件，例如滑块和按钮，用于菜单和HUD。
- en: Slate uses declarative syntax to allow an xml-style representation of user interface
    elements in their hierarchy in native C++. It accomplishes this by making heavy
    use of macros and operator overloading.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Slate使用声明性语法，允许以本机C++中的层次结构的xml样式表示用户界面元素。它通过大量使用宏和运算符重载来实现这一点。
- en: That said, not everybody wants to ask their programmers to design the game's
    HUD. One of the significant advantages of using Scaleform within Unreal 3 was
    the ability to develop the visual appearance of game UIs using the Flash visual
    editor, so visual designers didn't need to learn a programming language. Programmers
    could then insert the logic and data separately. This is the same paradigm espoused
    by the **Windows Presentation Framework** (**WPF**), for example.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，并不是每个人都想要让他们的程序员设计游戏的HUD。在Unreal 3中使用Scaleform的一个重要优势是能够使用Flash可视化编辑器开发游戏UI的视觉外观，因此视觉设计师不需要学习编程语言。程序员可以单独插入逻辑和数据。这与Windows
    Presentation Framework（WPF）的范例相同。
- en: In a similar fashion, Unreal provides **Unreal Motion Graphics** (**UMG**).
    UMG is a visual editor for Slate widgets that allows you to visually style, layout,
    and animate user interfaces. UI widgets (or controls if you've come from a Win32
    background) can have their properties controlled by either Blueprint code (written
    in the Graph view of the UMG window) or from C++. This chapter primarily deals
    with displaying UI elements, creating widget hierarchies, and creating base `SWidget`
    classes that can be styled and used within UMG.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，Unreal提供了Unreal Motion Graphics（UMG）。UMG是Slate小部件的可视化编辑器，允许您以可视化方式样式化、布局和动画化用户界面。UI小部件（或控件，如果您来自Win32背景）的属性可以通过蓝图代码（在UMG窗口的图形视图中编写）或通过C++来控制。本章主要涉及显示UI元素、创建小部件层次结构和创建可以在UMG中进行样式化和使用的基本SWidget类。
- en: Drawing using Canvas
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Canvas进行绘图
- en: '**Canvas** is a continuation of the simple HUD implemented within Unreal 3\.
    While it isn''t so commonly used within shipping games, mostly being replaced
    by Slate/UMG, it''s simple to use, especially when you want to draw text or shapes
    to the screen. Canvas drawing is still used extensively by console commands used
    for debugging and performance analysis such as the `stat game` and other `stat`
    commands. Refer to [Chapter 8](part0102_split_000.html#318PC1-c0ca69a0411046888a488e5085138121
    "Chapter 8. Integrating C++ and the Unreal Editor"), *Integrating C++ and the
    Unreal Editor,* for the recipe for creating your own console commands.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas是在Unreal 3中实现的简单HUD的延续。虽然它在发货游戏中并不常用，大多被Slate/UMG取代，但在您想要在屏幕上绘制文本或形状时，它非常简单易用。Canvas绘图仍然广泛用于用于调试和性能分析的控制台命令，例如`stat
    game`和其他`stat`命令。有关创建自己的控制台命令的方法，请参阅[第8章](part0102_split_000.html#318PC1-c0ca69a0411046888a488e5085138121
    "第8章。集成C++和Unreal Editor")，*集成C++和Unreal Editor*。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open your `<Module>.build.cs` file, and uncomment/add the following line:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的<Module>.build.cs文件，并取消注释/添加以下行：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create a new `GameMode` called `CustomHUDGameMode` using the editor class wizard.
    Refer to [Chapter 4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "Chapter 4. Actors and Components"), *Actors and Components,* if you need a refresher
    on doing this.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器类向导创建一个名为CustomHUDGameMode的新GameMode。如果需要刷新此操作，请参阅[第4章](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "第4章。Actors and Components")，*Actors and Components*。
- en: 'Add a constructor to the class:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加一个构造函数：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following to the constructor implementation:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到构造函数实现中：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Create a new HUD subclass called `CustomHUD`, again using the wizard.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用向导创建一个名为CustomHUD的新HUD子类。
- en: 'Add the `override` keyword to the following function:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`override`关键字添加到以下函数：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now implement the function:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现函数：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Compile** your code, and launch the editor.'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的代码，并启动编辑器。
- en: Within the editor, open the **World Settings** panel from the **Settings** drop-down
    menu:![How to do it...](img/00212.jpeg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，从“设置”下拉菜单中打开“世界设置”面板：![操作步骤...](img/00212.jpeg)
- en: In the **World Settings** dialog, select `CustomHUDGameMode` from the list under
    **GameMode Override**:![How to do it...](img/00213.jpeg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**世界设置**对话框中，从**游戏模式覆盖**列表中选择`CustomHUDGameMode`：![操作步骤...](img/00213.jpeg)
- en: Play and verify that your custom HUD is drawing to the screen:![How to do it...](img/00214.jpeg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放并验证您的自定义HUD是否绘制到屏幕上：![操作步骤...](img/00214.jpeg)
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: All the UI recipes here will be using Slate for drawing, so we need to add a
    dependency between our module and the Slate framework so that we can access the
    classes declared in that module.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的所有UI示例都将使用Slate进行绘制，因此我们需要在我们的模块和Slate框架之间添加依赖关系，以便我们可以访问在该模块中声明的类。
- en: The best place to put custom Canvas draw calls for a game HUD is inside a subclass
    of `AHUD`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自定义Canvas绘制调用放入游戏HUD的最佳位置是在`AHUD`的子类中。
- en: In order to tell the engine to use our custom subclass, though, we need to create
    a new `GameMode`, and specify the type of our custom class.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了告诉引擎使用我们的自定义子类，我们需要创建一个新的`GameMode`，并指定我们自定义类的类型。
- en: Within the constructor of our custom Game Mode, we assign the `UClass` for our
    new HUD type to the `HUDClass` variable. This `UClass` is passed onto each player
    controller as they spawn in, and the controller is then responsible for the `AHUD`
    instance that it creates.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在自定义游戏模式的构造函数中，我们将新HUD类型的`UClass`分配给`HUDClass`变量。这个`UClass`在每个玩家控制器生成时传递给它们，并且控制器随后负责创建它创建的`AHUD`实例。
- en: With our custom `GameMode` loading our custom HUD, we need to actually create
    the said custom HUD class.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的自定义`GameMode`加载了我们的自定义HUD，我们需要实际创建所述的自定义HUD类。
- en: '`AHUD` defines a virtual function called `DrawHUD()`, which is invoked in every
    frame to allow us to draw elements to the screen.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AHUD`定义了一个名为`DrawHUD()`的虚函数，每帧调用该函数以允许我们向屏幕上绘制元素。'
- en: As a result, we override that function, and perform our drawing inside the implementation.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们重写了该函数，并在实现内部执行绘制操作。
- en: 'The first method used is as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先使用的方法如下：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`DrawText` requires a font to draw with. The default font used by `stat` and
    other HUD drawing commands in the engine code is actually stored in the `GEngine`
    class, and can be accessed by using the `GetSmallFont` function, which returns
    an instance of the `UFont` as a pointer.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DrawText`需要一个字体来绘制。引擎代码中`stat`和其他HUD绘制命令使用的默认字体实际上存储在`GEngine`类中，并且可以使用`GetSmallFont`函数访问，该函数返回一个`UFont`的实例指针。'
- en: The remaining arguments that we are use are the actual text that should be rendered,
    as well as the offset, in pixels, at which the text should be drawn.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用的剩余参数是要渲染的实际文本以及应该绘制文本的像素偏移量。
- en: '`DrawText` is a function that allows you to directly pass in the data that
    is to be displayed.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DrawText`是一个允许您直接传入要显示的数据的函数。'
- en: The general `DrawItem` function is a Visitor implementation that allows you
    to create an object that encapsulates the information about the object to be drawn
    and reuse that object on multiple draw calls.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通用的`DrawItem`函数是一个访问者实现，允许您创建一个封装有关要绘制的对象的信息的对象，并在多个绘制调用中重用该对象。
- en: In this recipe, we create an element that can be used to represent a progress
    bar. We encapsulate the required information regarding the width and height of
    our box into an `FCanvasBoxItem`, which we then pass to the `DrawItem` function
    on our Canvas.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本示例中，我们创建了一个用于表示进度条的元素。我们将关于框的宽度和高度的所需信息封装到一个`FCanvasBoxItem`中，然后将其传递给我们的Canvas上的`DrawItem`函数。
- en: The third item that we draw is a filled rectangle. This function uses convenience
    methods defined in the HUD class rather than on the Canvas itself. The filled
    rectangle is placed at the same location as our `FCanvasBox` so that it can represent
    the current value inside the progress bar.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们绘制的第三个元素是一个填充的矩形。此函数使用在HUD类中定义的便利方法，而不是在Canvas本身上定义的方法。填充的矩形放置在与我们的`FCanvasBox`相同的位置，以便它可以表示进度条内的当前值。
- en: Adding Slate Widgets to the screen
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Slate小部件添加到屏幕上
- en: The previous recipe used the `FCanvas` API to draw to the screen. However, `FCanvas`
    suffers from a number of limitations, for example, animations are difficult to
    implement, and drawing graphics on the screen involves creating textures or materials.
    `FCanvas` also doesn't implement anything in the way of widgets or window controls,
    making data entry or other forms of user input more complex than it needs to be.
    This recipe will show you how to begin creating HUD elements onscreen using Slate,
    which provides a number of built-in controls.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例使用了`FCanvas` API来绘制屏幕。然而，`FCanvas`有一些限制，例如，动画很难实现，绘制图形到屏幕上涉及创建纹理或材质。`FCanvas`还没有实现任何小部件或窗口控件，使得数据输入或其他形式的用户输入比必要的复杂。本示例将向您展示如何使用Slate开始在屏幕上创建HUD元素，Slate提供了许多内置控件。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Add `Slate` and `SlateCore` to your module's dependencies if you haven't done
    so already (see recipe *Drawing using Canvas* for how to do this).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请将`Slate`和`SlateCore`添加到您的模块依赖项中（有关如何执行此操作，请参见*使用Canvas进行绘制*的示例）。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Create a new `PlayerController` subclass, `ACustomHUDPlayerController`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ACustomHUDPlayerController`的新的`PlayerController`子类。
- en: 'Override the `BeginPlay` `virtual` method within your new subclass:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的新子类中重写`BeginPlay` `virtual`方法：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code for your overridden `BeginPlay()` inside the subclass''
    implementation:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子类的实现中添加以下代码以覆盖`BeginPlay()`：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you try to compile now, you''ll get some errors regarding classes not being
    defined. This is because we need to include their headers:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您现在尝试编译，您将得到一些关于未定义类的错误。这是因为我们需要包含它们的头文件：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a new `GameMode` called `SlateHUDGameMode`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SlateHUDGameMode`的新的`GameMode`：
- en: 'Add a constructor inside the Game Mode:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏模式中添加一个构造函数：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement the constructor with the following code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现构造函数：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following includes to the implementation file:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件中添加以下包含：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After adding the include to the implementation file, compile your game.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件中添加包含后，编译游戏。
- en: Within the Editor, open **World Settings** from the toolbar:![How to do it...](img/00215.jpeg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，从工具栏打开**世界设置**：![如何操作...](img/00215.jpeg)
- en: Inside **World Settings**, override the level's Game Mode to be our `SlateHUDGameMode`.![How
    to do it...](img/00216.jpeg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**世界设置**中，覆盖关卡的游戏模式为我们的`SlateHUDGameMode`。![如何操作...](img/00216.jpeg)
- en: Play the level, and see your new UI displayed on the screen:![How to do it...](img/00217.jpeg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放关卡，看到新的UI显示在屏幕上：![如何操作...](img/00217.jpeg)
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order for us to reference Slate classes or functions in our code, our module
    must link with the `Slate` and `SlateCore` modules, so we add those to the module
    dependencies.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在我们的代码中引用Slate类或函数，我们的模块必须与`Slate`和`SlateCore`模块链接，因此我们将它们添加到模块依赖项中。
- en: We need to instantiate our UI in one of the classes that loads when the game
    runs, so for this recipe, we use our custom `PlayerController`, in the `BeginPlay`
    function, as the place to create our UI.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在游戏运行时加载的类中实例化我们的UI，因此在这个示例中，我们使用我们的自定义`PlayerController`在`BeginPlay`函数中作为创建UI的位置。
- en: Inside the `BeginPlay` implementation, we create a new `SVerticalBox` using
    the `SNew` function. We add a slot for a widget to our box, and set that slot
    to both horizontal and vertical centering.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BeginPlay`的实现中，我们使用`SNew`函数创建一个新的`SVerticalBox`。我们为我们的框添加一个小部件的插槽，并将该插槽设置为水平和垂直居中。
- en: Inside the slot, which we access using square brackets, we create a button that
    has `Textblock` inside it.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们使用方括号访问的插槽内，我们创建一个内部有`Textblock`的按钮。
- en: In `Textblock`, we set the `Text` property to a string literal value.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Textblock`中，将`Text`属性设置为字符串字面值。
- en: With the UI now created, we call `AddViewportWidgetForPlayer` to display this
    widget on the local player's screen.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建了UI，我们调用`AddViewportWidgetForPlayer`在本地玩家的屏幕上显示此小部件。
- en: With our custom `PlayerController` ready, we now need to create a custom `GameMode`
    to specify that it should use our new `PlayerController`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好我们的自定义`PlayerController`后，现在我们需要创建一个自定义的`GameMode`来指定它应该使用我们的新`PlayerController`。
- en: With the custom `PlayerController` being loaded at the start of the game, when
    `BeginPlay` is called, our UI will be shown.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏开始时加载自定义的`PlayerController`，当调用`BeginPlay`时，我们的UI将显示出来。
- en: The UI is very small at this screen size. Refer to the next recipe for information
    on how to scale it appropriately for the resolution of the game window.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个屏幕尺寸下，UI非常小。请参考下一个示例了解如何根据游戏窗口的分辨率进行适当的缩放。
- en: Creating screen size-aware scaling for the UI
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为UI创建适应屏幕大小的缩放
- en: If you have followed the previous recipe, you will notice that when you use
    **Play In Editor**, the button that loads is unusually small.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照前面的示例操作，您会注意到当您使用**在编辑器中播放**时，加载的按钮非常小。
- en: The reason for this is UI Scaling, a system that allows you to scale the user
    interface based on the screen size. User interface elements are represented in
    terms of pixels, usually in absolute terms (the button should be 10 pixels tall).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由UI缩放引起的，该系统允许您根据屏幕大小缩放用户界面。用户界面元素以像素表示，通常是绝对值（按钮应该是10个像素高）。
- en: The problem with this is that if you use a higher-resolution panel, 10 pixels
    might be much smaller, because each pixel is smaller in size.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，如果您使用更高分辨率的面板，10个像素可能会更小，因为每个像素的大小更小。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The UI scaling system in Unreal allows you to control a global scale modifier,
    which will scale all the controls on the screen based on the screen resolution.
    Given the earlier example, you might wish to adjust the size of the button so
    that its apparent size is unchanged when viewing your UI on a smaller screen.
    This recipe shows two different methods for altering the scaling rates.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎中的UI缩放系统允许您控制全局缩放修饰符，该修饰符将根据屏幕分辨率缩放屏幕上的所有控件。根据前面的示例，您可能希望调整按钮的大小，以便在较小的屏幕上查看UI时其表面大小保持不变。本示例演示了两种不同的方法来改变缩放率。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a custom `PlayerController` subclass. Call it `ScalingUIPlayerController`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自定义的`PlayerController`子类，将其命名为`ScalingUIPlayerController`。
- en: 'Inside the class, override `BeginPlay`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该类中，覆盖`BeginPlay`：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following code in the implementation of that function:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该函数的实现中添加以下代码：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a new `GameMode` subclass called `ScalingUIGameMode`, and give it a
    default constructor:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ScalingUIGameMode`的新的`GameMode`子类，并给它一个默认构造函数：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Within the default constructor, set the default player controller class to
    `ScalingUIPlayerController`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在默认构造函数中，将默认的玩家控制器类设置为`ScalingUIPlayerController`：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This should give you a user interface like the one from the previous recipe.
    Note that the UI is very tiny if you use Play In Editor:![How to do it...](img/00218.jpeg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该给您一个类似于前一个示例的用户界面。请注意，如果您在编辑器中播放，UI会非常小：![如何操作...](img/00218.jpeg)
- en: To alter the rate at which the UI scales down or up, we need to change the scaling
    curve. We can do that through two different methods.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要改变UI缩放的速率，我们需要改变缩放曲线。我们可以通过两种不同的方法来实现。
- en: The In-Editor method
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑器中的方法
- en: Launch Unreal, then open the **Project Settings** dialog through the **Edit**
    menu:![The In-Editor method](img/00219.jpeg)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动虚幻引擎，然后通过**编辑**菜单打开**项目设置**对话框：![编辑器中的方法](img/00219.jpeg)
- en: Under the **User Interface** section, there is a curve that can be used to alter
    the UI scaling factor based on the short dimension of your screen:![The In-Editor
    method](img/00220.jpeg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**用户界面**部分，有一个曲线可以根据屏幕的短边来改变UI缩放因子：![编辑器中的方法](img/00220.jpeg)
- en: Click on the second dot, or keypoint, on the graph.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击图表上的第二个点或关键点。
- en: Change its output value to 1.![The In-Editor method](img/00221.jpeg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其输出值更改为1。![编辑器中的方法](img/00221.jpeg)
- en: The Config file method
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置文件方法
- en: Browse to your project directory, and look inside the `Config` folder:![The
    Config file method](img/00222.jpeg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到项目目录，并查看`Config`文件夹中的内容：![配置文件方法](img/00222.jpeg)
- en: Open `DefaultEngine.ini` inside your text editor of choice.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您选择的文本编辑器中打开`DefaultEngine.ini`。
- en: 'Find the `[/Script/Engine.UserInterfaceSettings]` section:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`[/Script/Engine.UserInterfaceSettings]`部分中找到：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Look for a key called `UIScaleCurve` in that section.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该部分中查找名为`UIScaleCurve`的关键字。
- en: In the value for that key, you'll notice a number of `(Time=x,Value=y)` pairs.
    Edit the second pair so that its `Time` value is `720.000000` and the `Value`
    is `1.000000`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该键的值中，您会注意到许多`(Time=x,Value=y)`对。编辑第二对，使其`Time`值为`720.000000`，`Value`为`1.000000`。
- en: Restart the editor if you have it open.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经打开了编辑器，请重新启动编辑器。
- en: Start the Play In Editor preview to confirm that your UI now remains readable
    at the **PIE** screen's resolution (assuming you are using a 1080p monitor so
    that the PIE window is running at 720p or thereabouts):![The Config file method](img/00223.jpeg)
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动编辑器中的“Play In Editor”预览，以确认您的UI现在在**PIE**屏幕的分辨率下保持可读（假设您使用的是1080p显示器，因此PIE窗口以720p或类似分辨率运行）：![配置文件方法](img/00223.jpeg)
- en: You can also see how the scaling works if you use a **New Editor Window** to
    preview your game.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用**新的编辑器窗口**预览游戏，还可以看到缩放是如何工作的。
- en: To do so, click on the arrow to the right of **Play** on the toolbar.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，请单击工具栏上**播放**右侧的箭头。
- en: Select **New Editor Window**.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**新的编辑器窗口**。
- en: Inside this window, you can use the console command `r.setreswidthxheight` to
    change the resolution, and observe the changes that result from doing so.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个窗口中，您可以使用控制台命令`r.setreswidthxheight`来改变分辨率，并观察由此产生的变化。
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As usual, when we want to use a custom `PlayerController`, we need a custom
    `GameMode` to specify which `PlayerController` to use.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常情况下，当我们想要使用自定义的`PlayerController`时，我们需要一个自定义的`GameMode`来指定使用哪个`PlayerController`。
- en: We create both, a custom `PlayerController` and `GameMode`, and place some `Slate`
    code in the `BeginPlay` method of `PlayerController` so that some UI elements
    are drawn.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个自定义的`PlayerController`和`GameMode`，并在`PlayerController`的`BeginPlay`方法中放置了一些`Slate`代码，以便绘制一些UI元素。
- en: Because the main game viewport is usually quite small within the Unreal editor,
    the UI initially shows in a scaled-down fashion.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为在Unreal编辑器中，主游戏视口通常非常小，所以UI最初以缩小的方式显示。
- en: This is intended to allow for the game UI to take up less room on smaller resolution
    displays, but can have the side effect of making the text very difficult to read
    if the window isn't being stretched to fit the full screen.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这旨在使游戏UI在较小的分辨率显示器上占用更少的空间，但如果窗口没有被拉伸以适应全屏，可能会导致文本非常难以阅读。
- en: Unreal stores the configuration data that should persist between sessions, but
    not necessarily be hard-coded into the executable inside config files.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unreal存储应在会话之间保持的配置数据，但不一定硬编码到可执行文件中的配置文件中。
- en: Config files use an extended version of the `.ini` file format that has been
    commonly used with Windows software.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置文件使用扩展版本的`.ini`文件格式，这个格式通常用于Windows软件。
- en: 'Config files store data using the following syntax:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置文件使用以下语法存储数据：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unreal has a `UserInterfaceSettings` class, with a property called `UIScaleCurve`
    on it.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unreal有一个名为`UserInterfaceSettings`的类，其中有一个名为`UIScaleCurve`的属性。
- en: That `UPROPERTY` is marked as config, so Unreal serializes the value to the
    `.ini` file.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该`UPROPERTY`被标记为配置，因此Unreal将该值序列化到`.ini`文件中。
- en: As a result, it stores the `UIScale` data in the `DefaultEngine.ini` file, in
    the `Engine.UserInterfaceSettings` section.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果，它将`UIScale`数据存储在`DefaultEngine.ini`文件的`Engine.UserInterfaceSettings`部分中。
- en: The data is stored using a text format, which contains a list of key points.
    Editing the `Time`, `Value` pairs alters or adds new key points to the curve.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据使用文本格式存储，其中包含一个关键点列表。编辑`Time`，`Value`对会改变或添加新的关键点到曲线中。
- en: The **Project Settings** dialog is a simple frontend for directly editing the
    `.ini` files yourself, and for designers, it is an intuitive way to edit the curve.
    However, having the data stored textually allows for programmers to potentially
    develop build tools that modify properties such as `UIScale` without having to
    recompile their game.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**项目设置**对话框是直接编辑`.ini`文件的简单前端界面，对于设计师来说，这是一种直观的编辑曲线的方式。然而，将数据以文本形式存储允许程序员潜在地开发修改`UIScale`等属性的构建工具，而无需重新编译游戏。'
- en: '`Time` refers to the input value. In this case, the input value is the narrower
    dimension of the screen (usually, the height).'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Time`指的是输入值。在这种情况下，输入值是屏幕的较窄维度（通常是高度）。'
- en: '`Value` is the universal scaling factor applied to the UI when the screen''s
    narrow dimension is approximately the height of the value in the `Time` field.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Value`是应用于UI的通用缩放因子，当屏幕的较窄维度大约等于`Time`字段中的值的高度时。'
- en: So, to set the UI to remain normal-sized at a 1280x720 resolution, set the time/input
    factor to 720, and the scale factor to 1.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，要将UI设置为在1280x720分辨率下保持正常大小，请将时间/输入因子设置为720，比例因子设置为1。
- en: See also
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can refer to the UE4 documentation for more information regarding config
    files
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以参考UE4文档以获取有关配置文件的更多信息
- en: Displaying and hiding a sheet of UMG elements in-game
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在游戏中显示和隐藏一组UMG元素
- en: So we have already discussed how to add a widget to the viewport, which means
    that it will be rendered on the player's screen.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经讨论了如何将小部件添加到视口中，这意味着它将在玩家的屏幕上呈现。
- en: However, what if we want to have UI elements that are toggled based on other
    factors, such as proximity to certain Actors, or a player holding a key down,
    or if we want a UI that disappears after a specified time?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们希望根据其他因素（例如与某些角色的接近程度、玩家按住某个键或者希望在指定时间后消失的UI）切换UI元素，该怎么办呢？
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Create a new `GameMode` class called `ToggleHUDGameMode`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ToggleHUDGameMode`的新`GameMode`类。
- en: Override `BeginPlay` and `EndPlay`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`BeginPlay`和`EndPlay`。
- en: 'Add the following `UPROPERTY`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`UPROPERTY`：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Lastly add this member variable:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后添加这个成员变量：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement `BeginPlay` with the following code in the method body:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法体中使用以下代码实现`BeginPlay`：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Implement `EndPlay`:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`EndPlay`：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Compile** your code, and start the editor.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译**您的代码，并启动编辑器。'
- en: Within the Editor, open **World Settings** from the toolbar:![How to do it...](img/00224.jpeg)
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，从工具栏打开**World Settings**：![操作步骤...](img/00224.jpeg)
- en: Inside **World Settings**, override the level's **Game Mode** to be our `AToggleHUDGameMode`:![How
    to do it...](img/00225.jpeg)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**World Settings**中，覆盖关卡的**Game Mode**为我们的`AToggleHUDGameMode`：![操作步骤...](img/00225.jpeg)
- en: Play the level, and verify that the UI toggles its visibility every 5 seconds.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏关卡，并验证UI每5秒切换可见性。
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As with most of the other recipes in this chapter, we are using a custom `GameMode`
    class to display our single-player UI on the player''s viewport for convenience:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的大多数其他示例一样，我们使用自定义的`GameMode`类在玩家的视口上显示单人UI以方便操作：
- en: We override `BeginPlay` and `EndPlay` so that we can correctly handle the timer
    that will be toggling our UI on and off for us.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重写`BeginPlay`和`EndPlay`以便正确处理将为我们切换UI的计时器。
- en: To make that possible, we need to store a reference to the timer as a `UPROPERTY`
    to ensure it won't be garbage collected.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要将计时器的引用存储为`UPROPERTY`，以确保它不会被垃圾回收。
- en: Within `BeginPlay`, we create a new `VerticalBox` using the `SNew` macro, and
    place a button in its first slot.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BeginPlay`中，我们使用`SNew`宏创建一个新的`VerticalBox`，并将一个按钮放在其第一个槽中。
- en: Buttons have `Content`, which can be some other widget to host inside them,
    such as `SImage` or `STextBlock`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮有`Content`，可以是其他小部件，如`SImage`或`STextBlock`。
- en: In this instance, we place a `STextBlock` into the `Content` slot. The contents
    of the text block are irrelevant as long as they are long enough for us to be
    able to see our button properly.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将`STextBlock`放入`Content`槽中。文本块的内容不重要，只要足够长，我们就能正确看到按钮。
- en: Having initialized our widget hierarchy, we add the root widget to the player's
    viewport so that it can be seen by them.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始化小部件层次结构后，我们将根小部件添加到玩家的视口中，以便他们可以看到它。
- en: Now we set up a timer to toggle the visibility of our widget. We are using a
    timer to simplify this recipe rather than having to implement user input and input
    bindings, but the principle is the same.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们设置一个计时器来切换小部件的可见性。我们使用计时器来简化这个示例，而不是实现用户输入和输入绑定，但原理是相同的。
- en: To do this, we get a reference to the game world, and its associated timer manager.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们获取游戏世界的引用和其关联的计时器管理器。
- en: With the Timer manager in hand, we can create a new timer.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了计时器管理器，我们可以创建一个新的计时器。
- en: However, we need to actually specify the code to run when the timer expires.
    One simple way to do this is to use a `lambda` function for our toggle the hud
    function.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们需要实际指定计时器到期时要运行的代码。一种简单的方法是使用`lambda`函数来切换hud函数。
- en: Lambdas are anonymous functions. Think of them as literal functions.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lambda`是匿名函数。将它们视为文字函数。'
- en: To link a `lambda` function to the timer, we need to create a `timer` delegate.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将`lambda`函数链接到计时器，我们需要创建一个`timer`委托。
- en: The `FTimerDelegate::CreateLambda` function is designed to convert a `lambda`
    function into a delegate, which the timer can call at the specified interval.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FTimerDelegate::CreateLambda`函数旨在将`lambda`函数转换为委托，计时器可以在指定的间隔调用它。'
- en: The `lambda` needs to access the `this` pointer from its containing object,
    our `GameMode`, so that it can change properties on the widget instance that we
    have created.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lambda`需要从其包含对象（即我们的`GameMode`）访问`this`指针，以便它可以更改我们创建的小部件实例上的属性。'
- en: To give it the access it needs, we begin our `lambda` declaration with the `[]`
    operators, which enclose variables that should be captured into the `lambda`,
    and accessible inside it.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了给它所需的访问权限，我们在`lambda`声明中使用`[]`运算符，它将变量封装在`lambda`中，并在其中可访问。
- en: The curly braces then enclose the function body in the same way they would with
    a normal function declaration.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，花括号将函数体与普通函数声明的方式括起来。
- en: Inside the function, we check if our widget is visible. If it is visible, then
    we hide it using `SWidget::SetVisibility`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，我们检查小部件是否可见。如果可见，则使用`SWidget::SetVisibility`隐藏它。
- en: If the widget isn't visible, then we turn it on using the same function call.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果小部件不可见，则使用相同的函数调用将其打开。
- en: In the rest of the call to `SetTimer`, we specify the interval (in seconds)
    to call the timer, and set the timer to loop.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对`SetTimer`的其余调用中，我们指定调用计时器的间隔（以秒为单位），并设置计时器循环。
- en: One thing we need to be careful of, though, is the possibility of our object
    being destroyed between two timer invocations, potentially leading to a crash
    if a reference to our object is left dangling.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是，我们需要小心的是，在两个计时器调用之间，我们的对象可能被销毁，如果对我们的对象的引用被悬空，则可能导致崩溃。
- en: In order to fix this, we need to remove the timer.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了修复这个问题，我们需要移除计时器。
- en: Given that we set the timer during `BeginPlay`, it makes sense to clear the
    timer during `EndPlay`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鉴于我们在`BeginPlay`中设置了计时器，清除计时器在`EndPlay`中是有意义的。
- en: '`EndPlay` will be called whenever `GameMode` either ends play or is destroyed,
    so we can safely cancel the timer during its implementation.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EndPlay`将在`GameMode`结束游戏或被销毁时调用，因此我们可以在其实现期间安全地取消计时器。'
- en: With `GameMode` set as the default game mode, the UI is created when the game
    begins to play, and the timer delegate executes every 5 seconds to switch the
    visibility of the widgets between `true` and `false`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`GameMode`设置为默认游戏模式后，UI将在游戏开始播放时创建，并且计时器委托每5秒执行一次，以在小部件之间切换可见性。
- en: When you close the game, `EndPlay` clears the timer reference, avoiding any
    problems.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你关闭游戏时，`EndPlay`会清除计时器引用，避免任何问题。
- en: Attaching function calls to Slate events
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数调用附加到Slate事件
- en: While creating buttons is all well and fine, at the moment, any UI element you
    add to the player's screen just sits there without anything happening even if
    a user clicks on it. We don't have any event handlers attached to the Slate elements
    at the moment, so events such as mouse clicks don't actually cause anything to
    happen.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建按钮很好，但目前，无论用户点击它，屏幕上添加的任何UI元素都只是静静地存在。目前我们没有将事件处理程序附加到Slate元素，因此鼠标点击等事件实际上不会导致任何事情发生。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe shows you how to attach functions to these events so that we can
    run custom code when they occur.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例向您展示如何将函数附加到这些事件，以便在事件发生时运行自定义代码。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Create a new `GameMode` subclass called `AClickEventGameMode`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AClickEventGameMode`的新的`GameMode`子类。
- en: 'Add the following `private` members to the class:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`private`成员添加到类中：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following `public` functions, noting the override for `BeginPlay()`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`public`函数，注意`BeginPlay()`的重写：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Within the `.cpp` file, add the implementation for `BeginPlay`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中，添加`BeginPlay`的实现：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Also add an implementation for `ButtonClicked()`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要为`ButtonClicked()`添加一个实现：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Compile** your code, and launch the editor.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译**代码并启动编辑器。'
- en: 'Override the game mode in **World Settings** to be `AClickEventGameMode`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**世界设置**中覆盖游戏模式为`AClickEventGameMode`：
- en: Preview in the editor, and verify that the UI shows a button that changes from
    **Click Me!** to **Clicked!** when you use the mouse cursor to click on it.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中预览，并验证UI是否显示一个按钮，当您使用鼠标光标单击它时，按钮会从**Click Me!**更改为**Clicked!**。
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As with most of the recipes in this chapter, we use `GameMode` to create and
    display our UI to minimize the number of classes extraneous to the point of the
    recipe that you need to create.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与本章中的大多数示例一样，我们使用`GameMode`来创建和显示UI，以最小化需要创建的与示例目的无关的类的数量。
- en: Within our new game mode, we need to retain references to the Slate Widgets
    that we create so that we can interact with them after their creation.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的新游戏模式中，我们需要保留对我们创建的Slate小部件的引用，以便在创建后与它们进行交互。
- en: As a result, we create two shared pointers as member data within our `GameMode`—one
    to the overall parent or root widget of our UI, and the other to the label on
    our button, because we're going to be changing the label text at runtime later.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们在`GameMode`中创建了两个共享指针作为成员数据，一个指向我们UI的整体父级或根部件，另一个指向我们按钮上的标签，因为我们将在运行时更改标签文本。
- en: We override `BeginPlay`, as it is a convenient place to create our UI after
    the game has started, and we will be able to get valid references to our player
    controller.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重写`BeginPlay`，因为它是在游戏开始后创建UI的方便位置，并且我们将能够获得对玩家控制器的有效引用。
- en: We also create a function called `ButtonClicked`. It returns `FReply`, a `struct`
    indicating if an event was handled. The function signature for `ButtonClicked`
    is determined by the signature of `FOnClicked`, a delegate which we will be using
    in a moment.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还创建了一个名为`ButtonClicked`的函数。它返回`FReply`，一个指示是否处理了事件的`struct`。`ButtonClicked`的函数签名由我们将在下一步中使用的委托`FOnClicked`的签名确定。
- en: Inside our implementation of `BeginPlay`, the first thing we do is call the
    implementation we are overriding to ensure that the class is initialized appropriately.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`BeginPlay`实现中，我们首先调用我们要重写的实现，以确保类适当地初始化。
- en: Then, as usual, we use our `SNew` function to create `VerticalBox`, and we add
    a slot to it which is centered.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，像往常一样，我们使用`SNew`函数创建`VerticalBox`，并向其添加一个居中的插槽。
- en: We create a new `Button` inside that slot, and we add a value to the `OnClicked`
    attribute that the button contains.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在该插槽内创建一个新的`Button`，并向其添加一个值，该值包含在`OnClicked`属性中。
- en: '`OnClicked` is a delegate property. This means that the `Button` will broadcast
    the `OnClicked` delegate any time a certain event happens (as the name implies
    in this instance, when the button is clicked).'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnClicked`是一个委托属性。这意味着`Button`将在某个事件发生时广播`OnClicked`委托（正如在此示例中的名称所暗示的那样，当单击按钮时）。'
- en: To subscribe or listen to the delegate, and be notified of the event that it
    refers to, we need to assign a delegate instance to the property.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要订阅或监听委托，并在事件发生时收到通知，我们需要将委托实例分配给属性。
- en: We do that using the standard delegate functions such as `CreateUObject`, `CreateStatic`,
    or `CreateLambda`. Any of those will work—we can bind `UObject` member functions,
    static functions, lambdas, and other functions.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用标准的委托函数（如`CreateUObject`、`CreateStatic`或`CreateLambda`）来实现这一点。其中任何一个都可以工作
    - 我们可以绑定`UObject`成员函数、静态函数、lambda和其他函数。
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Check [Chapter 5](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121
    "Chapter 5. Handling Events and Delegates"), *Handling Events and Delegates,*
    to learn more on delegates to see about the other types of function that we can
    bind to delegates.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看[第5章](part0070_split_000.html#22O7C1-c0ca69a0411046888a488e5085138121 "第5章。处理事件和委托")，*处理事件和委托*，了解更多关于委托的内容，以了解我们可以绑定到委托的其他类型的函数。
- en: '`CreateUObject` expects a pointer to a class instance, and a pointer to the
    member function defined in that class to call.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CreateUObject`期望一个指向类实例的指针，并且一个指向该类中定义的成员函数的指针来调用。'
- en: 'The function has to have a signature that is convertible to the signature of
    the delegate:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数必须具有与委托的签名可转换的签名：
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As can be seen here, `OnClicked` delegate type is `FOnClicked`—this is why the
    `ButtonClicked` function that we declared has the same signature as `FOnClicked`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如此所示，`OnClicked`委托类型为`FOnClicked` - 这就是为什么我们声明的`ButtonClicked`函数具有与`FOnClicked`相同的签名的原因。
- en: By passing in a pointer to this, and the pointer to the function to invoke,
    the engine will call that function on this specific object instance when the button
    is clicked.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传入指向此对象实例的指针和要调用的函数的指针，当单击按钮时，引擎将在此特定对象实例上调用该函数。
- en: After setting up the delegate, we use the `Content()` function, which returns
    a reference to the single slot that the button has for any content that it should
    contain.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置委托后，我们使用`Content()`函数，该函数返回对按钮应包含的任何内容的单个插槽的引用。
- en: We then use `SAssignNew` to create our button's label, using the `TextBlock`
    widget.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`SAssignNew`来创建我们按钮的标签，使用`TextBlock`小部件。
- en: '`SAssignNew` is important, because it allows us to use Slate''s declarative
    syntax, and yet assigns variables to point to specific child widgets in the hierarchy.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SAssignNew`很重要，因为它允许我们使用Slate的声明性语法，并且将变量分配给指向层次结构中特定子小部件的指针。'
- en: '`SAssignNew` first argument is the variable that we want to store the widget
    in, and the second argument is the type of that widget.'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SAssignNew`的第一个参数是我们要将小部件存储在其中的变量，第二个参数是该小部件的类型。'
- en: With `ButtonLabel` now pointing at our button's `TextBlock`, we can set its
    `Text` attribute to a static string.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`ButtonLabel`指向我们按钮的`TextBlock`，我们可以将其`Text`属性设置为静态字符串。
- en: Finally, we add the widget to the player's viewport using `AddViewportWidgetForPlayer`,
    which expects, as parameters, `LocalPlayer` to add the widget to, the widget itself,
    and a depth value (higher values to the front).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`AddViewportWidgetForPlayer`将小部件添加到玩家的视口中，该函数期望`LocalPlayer`作为参数添加小部件，小部件本身和深度值（较高的值在前面）。
- en: To get the `LocalPlayer` instance, we assume we are running without split screen,
    and so, the first player controller will be the only one, that is, the player's
    controller. The `GetFirstLocalPlayerFromController` function is a convenience
    function that simply fetches the first player controller, and returns its local
    player object.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取`LocalPlayer`实例，我们假设我们在没有分屏的情况下运行，因此第一个玩家控制器将是唯一的控制器，即玩家的控制器。`GetFirstLocalPlayerFromController`函数是一个方便函数，它只是获取第一个玩家控制器，并返回其本地玩家对象。
- en: We also need to focus the widget so the player can click on it, and display
    a cursor so that the player knows where their mouse is on the screen.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将焦点放在小部件上，以便玩家可以点击它，并显示一个光标，以便玩家知道鼠标在屏幕上的位置。
- en: We know from the previous step that we can assume the first local player controller
    is the one we're interested in, so we can access it and change its `ShowMouseCursor`
    variable to `true`. This will cause the cursor to be rendered on screen.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从上一步知道我们可以假设第一个本地玩家控制器是我们感兴趣的控制器，所以我们可以访问它并将其`ShowMouseCursor`变量更改为`true`。这将导致光标在屏幕上呈现。
- en: '`SetInputMode` allows us to focus on a widget so that the player can interact
    with it amongst other UI-related functionality, such as locking the mouse to the
    game''s viewport.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SetInputMode`允许我们专注于一个小部件，以便玩家可以与其交互，以及其他与UI相关的功能，例如将鼠标锁定到游戏的视口。'
- en: It uses an `FInputMode` object as its only parameter, which we can construct
    with the specific elements that we wish to include by using the `builder` pattern.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用一个`FInputMode`对象作为其唯一参数，我们可以使用`builder`模式构造具有我们希望包含的特定元素的对象。
- en: The `FInputModeUIOnly` class is a `FInputMode` subclass that specifies that
    we want all input events to be redirected to the UI layer rather than the player
    controller and other input handling.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FInputModeUIOnly`类是一个`FInputMode`子类，指定我们希望所有输入事件重定向到UI层，而不是玩家控制器和其他输入处理。'
- en: The `builder` pattern allows us to chain the method calls to customize our object
    instance before it is sent into the function as the parameter.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`builder`模式允许我们在将对象实例作为参数发送到函数之前，链接方法调用以自定义对象实例。'
- en: We chain `SetLockMouseToViewport(false)` to specify that the player's mouse
    can leave the boundary of the game screen with `SetWidgetToFocus(Widget)`, which
    specifies our top-level widget as the one that the game should direct player input
    to.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们链式调用`SetLockMouseToViewport(false)`来指定玩家的鼠标可以离开游戏屏幕的边界，并使用`SetWidgetToFocus(Widget)`指定我们的顶级小部件作为游戏应该将玩家输入指向的小部件。
- en: Finally, we have our actual implementation for `ButtonClicked`, our event handler.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有了我们的实际实现`ButtonClicked`，我们的事件处理程序。
- en: When the function is run due to our button being clicked, we change our button's
    label to indicate it has been clicked.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当由于点击按钮而运行该函数时，我们将按钮的标签更改为指示它已被点击。
- en: We then need to return an instance of `FReply` to the caller to let the UI framework
    know that the event has been handled, and to not continue propagating the event
    back up the widget hierarchy.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要返回一个`FReply`的实例给调用者，以让UI框架知道事件已经被处理，并且不要继续向上传播事件。
- en: '`FReply::Handled()` returns `FReply` set up to indicate this to the framework.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FReply::Handled()`返回设置为指示给框架的`FReply`。'
- en: We could have used `FReply::Unhandled()`, but this would have told the framework
    that the click event wasn't actually the one we were interested in, and it should
    look for other objects that might be interested in the event instead.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们本可以使用`FReply::Unhandled()`，但这将告诉框架点击事件实际上不是我们感兴趣的事件，它应该寻找其他可能对事件感兴趣的对象。
- en: Use Data Binding with Unreal Motion Graphics
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用虚幻运动图形进行数据绑定
- en: So far, we've been assigning static values to the attributes of our UI widgets.
    However, what if we want to be more dynamic with widget content, or parameters
    such as border color? We can use a principle called data binding to dynamically
    link properties of our UI with variables in the broader program.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直将静态值分配给UI小部件的属性。然而，如果我们想要在小部件内容或参数（如边框颜色）方面更加动态，怎么办？我们可以使用一个称为数据绑定的原则，将我们的UI的属性与更广泛的程序中的变量动态链接起来。
- en: Unreal uses the Attribute system to allow us to bind the value of an attribute
    to the return value from a function, for example. This means that changing those
    variables will automatically cause the UI to change in response, according to
    our wishes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻使用属性系统允许我们将属性的值绑定到函数的返回值，例如。这意味着更改这些变量将自动导致UI根据我们的意愿进行更改。
- en: How to do it...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Create a new `GameMode` subclass called `AAtributeGameMode`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`AAtributeGameMode`的新的`GameMode`子类。
- en: 'Add the following `private` member to the class:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`private`成员添加到类中：
- en: '[PRE27]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following `public` functions, noting the override for `BeginPlay()`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`public`函数，注意`BeginPlay()`的重写：
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the implementation for `BeginPlay` within the `.cpp` file:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中添加`BeginPlay`的实现：
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Also, add an implementation for `GetButtonLabel()`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要为`GetButtonLabel()`添加一个实现：
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Compile** your code, and launch the editor.'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码，并启动编辑器。
- en: Override the game mode in **World Settings** to be `AAtributeGameMode`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**世界设置**中覆盖游戏模式为`AAtributeGameMode`。
- en: Note that in a Play In Editor session, the value on the UI's button changes
    as the player moves around the scene.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，在编辑器中播放时，UI按钮上的值会随着玩家在场景中移动而改变。
- en: How it works...
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Just like almost all other recipes in this chapter, the first thing we need
    to do is create a game mode as a convenient host for our UI. We create the UI
    in the same fashion as in the other recipes, by placing `Slate` code inside the
    `BeginPlay()` method of our game mode.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像本章中几乎所有其他示例一样，我们首先需要创建一个游戏模式作为我们UI的方便宿主。我们以与其他示例相同的方式创建UI，通过将`Slate`代码放在游戏模式的`BeginPlay()`方法中。
- en: 'The interesting feature of this recipe concerns how we set the value of our
    button''s label text:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个示例的有趣之处在于我们如何设置按钮的标签文本的值：
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding syntax is unusually verbose, but what it is actually doing is
    comparatively simple. We assign something to the `Text` property, which is of
    the type `FText`. We can assign `TAttribute<FText>` to this property, and the
    `TAttribute Get()` method will be called whenever the UI wants to ensure that
    the value of `Text` is up to date.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的语法非常冗长，但实际上它所做的事情相对简单。我们将某个值赋给`Text`属性，该属性的类型是`FText`。我们可以将`TAttribute<FText>`赋给该属性，每当UI想要确保`Text`的值是最新的时候，`TAttribute
    Get()`方法就会被调用。
- en: To create `TAttribute`, we need to call the static `TAttribute<VariableType>::Create()`
    method.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建`TAttribute`，我们需要调用静态的`TAttribute<VariableType>::Create()`方法。
- en: This function expects a delegate of some description. Depending on the type
    of delegate passed to `TAttribute::Create`, `TAttribute::Get()` invokes a different
    type of function to retrieve the actual value.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数期望一个委托的某种描述。根据传递给`TAttribute::Create`的委托类型，`TAttribute::Get()`调用不同类型的函数来检索实际值。
- en: In the code for this recipe, we invoke a member function of `UObject`. This
    means we know we will be calling the `CreateUObject` function on some delegate
    type.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例的代码中，我们调用了`UObject`的一个成员函数。这意味着我们知道我们将在某个委托类型上调用`CreateUObject`函数。
- en: Note
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请注意
- en: We can use `CreateLambda`, `CreateStatic`, or `CreateRaw` to invoke a `lambda`,
    a `static`, or a `member` function respectively on a raw C++ class. This will
    give us the current value for the attribute.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`CreateLambda`、`CreateStatic`或`CreateRaw`来分别在原始的C++类上调用`lambda`、`static`或`member`函数。这将为我们提供属性的当前值。
- en: But what delegate type do we want to create an instance of? Because we're templating
    the `TAttribute` class on the actual variable type that the attribute will be
    associated with, we need a delegate that is also templated on the variable type
    as its return value.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是我们想要创建哪种委托类型的实例呢？因为我们在实际变量类型上对`TAttribute`类进行了模板化，所以我们需要一个委托，该委托的返回值也是以变量类型为模板的。
- en: That is to say, if we have `TAttribute<FText>`, the delegate connected to it
    needs to return an `FText`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也就是说，如果我们有`TAttribute<FText>`，与之连接的委托需要返回一个`FText`。
- en: 'We have the following code within `TAttribute`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`TAttribute`中有以下代码：
- en: '[PRE32]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `FGetter` delegate type is declared inside the `TAttribute` class, so its
    return value can be templated on the `ObjectType` parameter of the `TAttribute`
    template.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FGetter`委托类型在`TAttribute`类内声明，因此它的返回值可以在`TAttribute`模板的`ObjectType`参数上进行模板化。'
- en: This means that `TAttribute<Typename>::FGetter` automatically defines a delegate
    with the correct return type of `Typename`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着`TAttribute<Typename>::FGetter`自动定义了一个具有正确返回类型`Typename`的委托。
- en: So we need to create a `UObject`-bound delegate of type and signature for `TAttribute<FText>::FGetter`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们需要创建一个类型和签名为`TAttribute<FText>::FGetter`的`UObject`绑定的委托。
- en: Once we have that delegate, we can call `TAttribute::Create` on the delegate
    to link the delegate's return value to our `TextBlock` member variable `Text`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了那个委托，我们就可以在委托上调用`TAttribute::Create`，将委托的返回值与我们的`TextBlock`成员变量`Text`关联起来。
- en: With our UI defined and a binding between the `Text` property, a `TAttribute<FText>`,
    and a delegate returning `FText`, we can now add the UI to the player's screen
    so that it's visible.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义了我们的UI并将`Text`属性、`TAttribute<FText>`和返回`FText`的委托绑定之后，我们现在可以将UI添加到玩家的屏幕上，以便它可见。
- en: Every frame, the game engine checks all properties to see if they are linked
    to `TAttributes`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每一帧，游戏引擎都会检查所有属性，看它们是否与`TAttributes`相关联。
- en: If there's a connection, then the `TAttribute` `Get()` function is called, invoking
    the delegate, and returning the delegate's return value so that Slate can store
    it inside the widget's corresponding member variable.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在连接，则调用`TAttribute`的`Get()`函数，调用委托，并返回委托的返回值，以便Slate可以将其存储在小部件的相应成员变量中。
- en: For our demonstration of the process, `GetButtonLabel` retrieves the location
    of the first player pawn in the game world.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们演示这个过程时，`GetButtonLabel`检索游戏世界中第一个玩家角色的位置。
- en: We then use `FString::Printf` to format the location data into a human readable
    string, and wrap that in an `FText` so that it can be stored as the `TextBlock`
    text value.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用`FString::Printf`将位置数据格式化为可读的字符串，并将其包装在`FText`中，以便将其存储为`TextBlock`的文本值。
- en: Controlling widget appearance with Styles
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用样式控制小部件的外观
- en: So far in this chapter, we've been creating UI elements that use the default
    visual representation. This recipe shows you how to create a Style in C++ that
    can be used as a common look-and-feel across your whole project.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们一直在创建使用默认可视化表示的UI元素。本示例向您展示了如何在C++中创建一个可以在整个项目中用作常见外观的样式。
- en: How to do it...
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: Create a new class header in your project. Name the file `"CookbookStyle.h"`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目中创建一个新的类头文件。将文件命名为`"CookbookStyle.h"`。
- en: 'Add the following code to the file:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到文件中：
- en: '[PRE33]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a corresponding implementation cpp file for this class, and add the
    following code to it:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个类创建一个相应的实现cpp文件，并将以下代码添加到其中：
- en: '[PRE34]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a new Game Mode subclass, `StyledHUDGameMode`, and add the following
    code to its declaration:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的游戏模式子类“StyledHUDGameMode”，并将以下代码添加到其声明中：
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Likewise, implement `GameMode`:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，实现“GameMode”：
- en: '[PRE36]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Lastly, create a 54x54 pixel png file with a border around it for our button.
    Save it to the `Content` | `Slate` folder with the name `Button.png`:![How to
    do it...](img/00226.jpeg)![How to do it...](img/00227.jpeg)
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个54x54像素的png文件，周围有一个边框用于我们的按钮。将其保存到“Content”|“Slate”文件夹中，名称为“Button.png”：！[如何做...](img/00226.jpeg)！[如何做...](img/00227.jpeg)
- en: 'Finally, we need to set our game''s module to properly initialize the style
    when it is loaded. In your game module''s implementation file, ensure it looks
    like this:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要设置我们的游戏模块以在加载时正确初始化样式。在游戏模块的实现文件中，确保它看起来像这样：
- en: '[PRE37]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Compile** code, and set your game mode override to the new game mode as we''ve
    done in the other recipes this chapter.'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译**代码，并将游戏模式覆盖设置为本章中所做的其他示例中的新游戏模式。'
- en: When you play the game, you will see that your custom border is around the button,
    and the text is white rather than black.![How to do it...](img/00228.jpeg)
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你玩游戏时，你会看到你的自定义边框在按钮周围，并且文本是白色而不是黑色。！[如何做...](img/00228.jpeg)
- en: How it works...
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理是...
- en: In order for us to create styles that can be shared across multiple Slate widgets,
    we need to create an object to contain the styles and keep them in scope.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建可以在多个Slate小部件之间共享的样式，我们需要创建一个对象来包含这些样式并使它们保持在范围内。
- en: Epic provides the `FSlateStyleSet` class for this purpose. `FSlateStyleSet`
    contains a number of styles that we can access within Slate's declarative syntax
    to skin widgets.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Epic为此提供了“FSlateStyleSet”类。FSlateStyleSet包含了许多样式，我们可以在Slate的声明语法中访问这些样式来为小部件设置皮肤。
- en: However, it's inefficient to have multiple copies of our `StyleSet` object scattered
    through the program. We really only need one of these objects.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，将我们的“StyleSet”对象的多个副本散布在程序中是低效的。我们实际上只需要一个这样的对象。
- en: Because `FSlateStyleSet` itself is not a singleton, that is, an object that
    can only have one instance, we need to create a class that will manage our `StyleSet`
    object and ensure that we only have the single instance.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为“FSlateStyleSet”本身不是一个单例，也就是说，一个只能有一个实例的对象，我们需要创建一个管理我们的“StyleSet”对象并确保我们只有一个实例的类。
- en: This is the reason we have the `FCookbookStyle` class.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是为什么我们有“FCookbookStyle”类的原因。
- en: It contains an `Initialize()` function, which we will call in our module's startup
    code.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它包含一个“Initialize()”函数，我们将在模块的启动代码中调用它。
- en: In the `Initialize()` function, we check if we have an instance of our `StyleSet`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Initialize()”函数中，我们检查是否有我们的“StyleSet”的实例。
- en: If we do not have a valid instance, we call the private `Create()` function
    to instantiate one.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们没有一个有效的实例，我们调用私有的“Create()”函数来实例化一个。
- en: We then register the style with the `FSlateStyleRegistry` class.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用“FSlateStyleRegistry”类注册样式。
- en: When our module is unloaded, we will need to reverse this registration process,
    then erase the pointer so it does not dangle.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们的模块被卸载时，我们需要撤销这个注册过程，然后擦除指针，以防止其悬空。
- en: We now have an instance of our class, created during module initialization by
    calling `Create()`.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有了一个类的实例，在模块初始化时通过调用“Create()”来创建。
- en: You'll notice that `Create` is wrapped by a number of macros that all have similar
    form.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到，“Create”被一些具有相似形式的宏包围。
- en: These macros are defined before the function, and undefined after it.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些宏在函数之前定义，在函数之后取消定义。
- en: These macros make it easier for us to simplify the code required within the
    `Create` function by eliminating the need to specify a path and extension for
    all the image resources that our Style might want to use.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些宏使我们能够通过消除我们的样式可能需要使用的所有图像资源的路径和扩展名来简化“Create”函数中所需的代码。
- en: Within the `Create` function, we create a new `FSlateStyleSet` object using
    the function `FSlateGameResources::New()`.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Create”函数内部，我们使用函数“FSlateGameResources::New()”创建一个新的“FSlateStyleSet”对象。
- en: '`New()` needs a name for the style, and the folder paths that we want to search
    for in this Style Set.'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “New()”需要一个样式的名称，以及我们想要在这个样式集中搜索的文件夹路径。
- en: This allows us to declare multiple Style Sets pointing to different directories,
    but using the same names for the images. It also allows us to skin or restyle
    the whole UI simply by switching to a Style Set in one of the other base directories.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这使我们能够声明多个指向不同目录的样式集，但使用相同的图像名称。它还允许我们通过切换到其他基本目录中的样式集来简单地为整个UI设置皮肤或重新设置样式。
- en: '`New()` returns a shared reference object, so we retrieve the actual `FStyleSet`
    instance using the `Get()` function.'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “New()”返回一个共享引用对象，所以我们使用“Get()”函数检索实际的“FStyleSet”实例。
- en: With this reference in hand, we can create the styles we want this set to contain.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个引用，我们可以创建我们想要的样式集。
- en: To add styles to a set, we use the `Set()` method.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将样式添加到集合中，我们使用“Set()”方法。
- en: Set expects the name of the style, and then a style object.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Set期望样式的名称，然后是一个样式对象。
- en: Style objects can be customized using the `builder` pattern.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用“builder”模式自定义样式对象。
- en: We first add a style called `"NormalButtonBrush"`. The name can be arbitrary.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先添加一个名为“NormalButtonBrush”的样式。名称可以任意选择。
- en: Because we want to use this style to change the appearance of buttons, we need
    to use `FButtonStyle` for the second parameter.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们想要使用这个样式来改变按钮的外观，所以我们需要使用第二个参数“FButtonStyle”。
- en: To customize the style to our requirements, we use the Slate builder syntax,
    chaining whatever method calls that we need to set properties on our style.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了根据我们的要求自定义样式，我们使用Slate构建器语法，链接我们需要在样式上设置属性的任何方法调用。
- en: For the first style in this set, we just change the visual appearance of the
    button when it isn't being clicked or is in a non-default state.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个样式集中的第一个样式，我们只是在按钮没有被点击或处于非默认状态时改变其外观。
- en: That means we want to change the brush used when the button is in the normal
    state, and so the function we use is `SetNormal()`.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着我们希望在按钮处于正常状态时更改使用的画刷，因此我们使用的函数是`SetNormal()`。
- en: Using the `BOX_BRUSH` macro, we tell Slate that we want to use `Button.png`,
    which is an image of 54x54 pixel size, and that we want to keep the 14 pixels
    in each corner unstretched for the purposes of nine-slice scaling.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`BOX_BRUSH`宏，我们告诉Slate我们要使用`Button.png`，这是一个54x54像素大小的图像，并且我们要保持每个角的14像素不拉伸，以用于九切片缩放。
- en: Tip
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For a more visual explanation of the nine-slice scaling functionality, take
    a look at `SlateBoxBrush.h` in the engine source.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要更直观地了解九切片缩放功能，请查看引擎源代码中的`SlateBoxBrush.h`。
- en: For the second style in our Style Set, we create a style called `"NormalButtonText"`.
    For this style, we don't want to change everything from defaults in the style;
    we just want to alter one property.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的样式集中的第二个样式中，我们创建了一个名为`"NormalButtonText"`的样式。对于这个样式，我们不想改变样式中的所有默认值，我们只想改变一个属性。
- en: As a result, we access the default text style, and clone it using the copy constructor.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果，我们访问默认的文本样式，并使用拷贝构造函数进行克隆。
- en: With our fresh copy of the default style, we then change the color of the text
    to white, first creating a linear color of R=1 G=1 B=1 A=1, then converting that
    to a Slate color object.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的默认样式的新副本后，我们将文本的颜色更改为白色，首先创建一个线性颜色R=1 G=1 B=1 A=1，然后将其转换为Slate颜色对象。
- en: With our Style Set configured with our two new styles, we can then return it
    to the calling function, which is `Initialize`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置了我们的样式集并使用我们的两个新样式，然后我们可以将其返回给调用函数`Initialize`。
- en: '`Initialize` stores our Style Set reference, and eliminates the need for us
    to create further instances.'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Initialize`存储了我们的样式集引用，并消除了我们创建进一步实例的需要。'
- en: Our style container class also has a `Get()` function, which is used to retrieve
    the actual `StyleSet` for use in Slate.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的样式容器类还有一个`Get()`函数，用于检索用于Slate的实际`StyleSet`。
- en: Because `Initialize()` has already been called at the module startup, `Get()`
    simply returns the `StyleSet` instance that was created within that function.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为`Initialize()`已经在模块启动时被调用，所以`Get()`只是返回在该函数内创建的`StyleSet`实例。
- en: Within the game module, we add the code which actually calls `Initialize` and
    `Shutdown`. This ensures that while our module is loaded, we will always have
    a valid reference to our Slate Style.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏模块中，我们添加了实际调用`Initialize`和`Shutdown`的代码。这确保了在我们的模块加载时，我们始终有一个有效的Slate样式引用。
- en: As always, we create a Game Mode as the host for our UI, and we override `BeginPlay`
    so that we can create the UI when the game starts.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与往常一样，我们创建一个游戏模式作为我们UI的主机，并重写`BeginPlay`以便在游戏开始时创建UI。
- en: The syntax for creating the UI is exactly the same as we've used in previous
    recipes—creating a `VerticalBox` using `SNew`, and then using Slate's declarative
    syntax to populate the box with other widgets.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建UI的语法与我们在之前的示例中使用的完全相同-使用`SNew`创建`VerticalBox`，然后使用Slate的声明性语法填充该框中的其他小部件。
- en: 'It is important to note the two following lines:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重要的是注意以下两行：
- en: '[PRE38]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding lines are part of the declarative syntax for our button, and the
    text that makes its label.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述行是我们按钮的声明性语法的一部分，以及作为其标签的文本。
- en: When we set the style for our widgets using a `<Class>Style()` method, we pass
    in two parameters.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们使用`<Class>Style()`方法为我们的小部件设置样式时，我们传入两个参数。
- en: The first parameter is our actual Style Set, retrieved using `FCookbookStyle::Get()`,
    and the second is a string parameter with the name of the style that we want to
    use.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个参数是我们实际的样式集，使用`FCookbookStyle::Get()`检索，第二个参数是一个字符串参数，其中包含我们要使用的样式的名称。
- en: With these minor changes, we override the styling of the widgets to use our
    custom styles so that when we add the widgets to the player's viewport, they display
    our customizations.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这些小改动，我们重写了小部件的样式，以使用我们的自定义样式，这样当我们将小部件添加到播放器的视口时，它们会显示我们的自定义内容。
- en: Create a custom SWidget/UWidget
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义的SWidget/UWidget
- en: The recipes in this chapter so far have shown you how to create UIs using the
    existing primitive widgets.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章的示例已经向您展示了如何使用现有的基本小部件创建UI。
- en: Sometimes, it is convenient for developers to use composition to collect a number
    of UI elements together, for example, to define a button class that automatically
    has a `TextBlock` as a label rather than manually specifying the hierarchy every
    time they are declared.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，开发人员使用组合来方便地将多个UI元素收集在一起，例如，定义一个按钮类，自动具有`TextBlock`作为标签，而不是每次手动指定层次结构。
- en: Furthermore, if you are manually specifying the hierarchy in C++, rather than
    declaring a compound object consisting of subwidgets, you won't be able to instantiate
    those widgets as a group using UMG.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您在C++中手动指定层次结构，而不是声明由子小部件组成的复合对象，您将无法使用UMG将这些小部件作为一组实例化。
- en: Getting ready
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe shows you how to create a compound `SWidget` that contains a group
    of widgets and exposes new properties to control elements of those subwidgets.
    It will also show you how to create a `UWidget` wrapper, which will expose the
    new compound `SWidget` class to UMG for use by designers.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例向您展示了如何创建一个复合的`SWidget`，其中包含一组小部件，并公开新属性以控制这些子小部件的元素。它还将向您展示如何创建一个`UWidget`包装器，该包装器将新的复合`SWidget`类公开给UMG供设计师使用。
- en: How to do it...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下：
- en: We need to add the UMG module to our module's dependencies.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将UMG模块添加到我们模块的依赖项中。
- en: 'Open up `<YourModule>.build.cs`, and add UMG to the following:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`<YourModule>.build.cs`，并将UMG添加到以下位置：
- en: '[PRE39]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Create a new class called `CustomButton`, and add the following code to its
    declaration:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CustomButton`的新类，并将以下代码添加到其声明中：
- en: '[PRE40]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Implement the class with the following in the corresponding cpp file:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相应的cpp文件中实现以下类：
- en: '[PRE41]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Create a second class, this time based on `UWidget`, called `UCustomButtonWidget`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个类，这次基于`UWidget`，名为`UCustomButtonWidget`。
- en: 'Add the following includes:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下包含：
- en: '[PRE42]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Declare the following delegates before the class declaration:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类声明之前声明以下委托：
- en: '[PRE43]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add the following protected members:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下受保护成员：
- en: '[PRE44]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Also add the following public members:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还添加以下公共成员：
- en: '[PRE45]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now create the implementation for `UCustomButtonWidget`:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建`UCustomButtonWidget`的实现：
- en: '[PRE46]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Create a new Widget Blueprint by right-clicking on the **Content Browser**,
    selecting **User Interface**, and then **Widget Blueprint**:![How to do it...](img/00229.jpeg)
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击**内容浏览器**，选择**用户界面**，然后选择**小部件蓝图**来创建一个新的小部件蓝图：![如何操作...](img/00229.jpeg)
- en: Open your new **Widget Blueprint** by double-clicking on it.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击打开您的新**小部件蓝图**。
- en: Find the **Custom Button Widget** in the Widget Palette:![How to do it...](img/00230.jpeg)
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在小部件面板中找到**自定义按钮小部件**：![如何操作...](img/00230.jpeg)
- en: Drag an instance of it out into the main area.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其拖动到主区域中的一个实例。
- en: With the instance selected, change the **Label** property in the **Details**
    panel:![How to do it...](img/00231.jpeg)
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择实例后，在**详细信息**面板中更改**标签**属性：![如何操作...](img/00231.jpeg)
- en: Verify that your button has changed its label.![How to do it...](img/00232.jpeg)
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您的按钮是否已更改其标签。![如何操作...](img/00232.jpeg)
- en: Now we will create a binding to demonstrate that we can link arbitrary blueprint
    functions to the label property on our widget, which, in turn, drives the Widget's
    textblock label.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个绑定，以证明我们可以将任意蓝图函数链接到小部件上的标签属性，从而驱动小部件的文本块标签。
- en: Click on **Bind** to the right of the **Label** property, and select **Create
    Binding**:![How to do it...](img/00233.jpeg)
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**标签**属性右侧的**绑定**，然后选择**创建绑定**：![如何操作...](img/00233.jpeg)
- en: Within the graph that is now displayed, place a **Get Game Time in Seconds**
    node:![How to do it...](img/00234.jpeg)
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现在显示的图表中，放置一个**获取游戏时间（以秒为单位）**节点：![如何操作...](img/00234.jpeg)
- en: Link the return value from the Get Game Time node to the **Return Value** pin
    in the function:![How to do it...](img/00235.jpeg)
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将获取游戏时间节点的返回值链接到函数中的**返回值**引脚：![如何操作...](img/00235.jpeg)
- en: A convert float to string node will be automatically inserted for you:![How
    to do it...](img/00236.jpeg)
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自动为您插入一个将浮点数转换为字符串的节点：![如何操作...](img/00236.jpeg)
- en: Next, open the **Level Blueprints** by clicking on the **Blueprints** button
    on the taskbar, then selecting **Open Level Blueprint**:![How to do it...](img/00237.jpeg)
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过单击任务栏上的**蓝图**按钮，然后选择**打开关卡蓝图**来打开**关卡蓝图**：![如何操作...](img/00237.jpeg)
- en: Place a construct widget node into the graph:![How to do it...](img/00238.jpeg)
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构造小部件节点放入图表中：![如何操作...](img/00238.jpeg)
- en: Select the class of widget to spawn as the new Widget Blueprint that we created
    a moment ago within the editor:![How to do it...](img/00239.jpeg)
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要生成的小部件类作为我们刚刚在编辑器中创建的新小部件蓝图：![如何操作...](img/00239.jpeg)
- en: Click and drag away from the **Owning Player** pin on the create widget node,
    and place a **Get Player Controller** node:![How to do it...](img/00240.jpeg)
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从创建小部件节点上的“拥有玩家”引脚上点击并拖动，然后放置一个“获取玩家控制器”节点：![如何操作...](img/00240.jpeg)
- en: Likewise, drag away from the return value of the create widget node, and place
    a **Add to Viewport** node.![How to do it...](img/00241.jpeg)
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，从创建小部件节点的返回值上点击并拖动，然后放置一个“添加到视口”节点：![如何操作...](img/00241.jpeg)
- en: Lastly, link the `BeginPlay` node to the execution pin on the create widget
    node.![How to do it...](img/00242.jpeg)
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`BeginPlay`节点链接到创建小部件节点上的执行引脚。![如何操作...](img/00242.jpeg)
- en: Preview your game, and verify that the widget we've displayed onscreen is our
    new custom button with its label bound to the number of seconds that have elapsed
    since the game started:![How to do it...](img/00243.jpeg)
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预览游戏，并验证我们在屏幕上显示的小部件是我们的新自定义按钮，其标签绑定到游戏开始后经过的秒数：![如何操作...](img/00243.jpeg)
- en: How it works...
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In order to use the `UWidget` class, our module needs to include the UMG module
    as one of its dependencies, because `UWidget` is defined inside the UMG module.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用`UWidget`类，我们的模块需要将UMG模块作为其依赖项之一，因为`UWidget`在UMG模块内定义。
- en: The first class that we need to create, however, is our actual `SWidget` class.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们需要创建的第一个类是我们实际的`SWidget`类。
- en: Because we want to aggregate two widgets together into a compound structure,
    we create our new widget as a `CompoundWidget` subclass.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们想要将两个小部件聚合到一个复合结构中，所以我们将我们的新小部件创建为`CompoundWidget`子类。
- en: '`CompoundWidget` allows you to encapsulate a widget hierarchy as a widget itself.'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CompoundWidget`允许您将小部件层次结构封装为小部件本身。'
- en: Inside the class, we use the `SLATE_BEGIN_ARGS` and `SLATE_END_ARGS` macros
    to declare an internal `struct` called `FArguments` on our new `SWidget`.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类内部，我们使用`SLATE_BEGIN_ARGS`和`SLATE_END_ARGS`宏在我们的新`SWidget`上声明一个名为`FArguments`的内部结构。
- en: Within `SLATE_BEGIN_ARGS` and `SLATE_END_ARGS`, the `SLATE_ATTRIBUTE` and `SLATE_EVENT`
    macros are used.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SLATE_BEGIN_ARGS`和`SLATE_END_ARGS`之间，使用了`SLATE_ATTRIBUTE`和`SLATE_EVENT`宏。
- en: '`SLATE_ATTRIBUTE` creates `TAttribute` for the type we give it.'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SLATE_ATTRIBUTE`为我们提供的类型创建`TAttribute`。'
- en: In this class, we declare `TAttribute` called `_Label`, which is more specifically
    a `TAttribute<FString>`.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中，我们声明了一个名为`_Label`的`TAttribute`，更具体地说，它是一个`TAttribute<FString>`。
- en: '`SLATE_EVENT` allows us to create member delegates that we can broadcast when
    something happens internally to the widget.'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SLATE_EVENT`允许我们创建成员委托，当小部件内部发生某些事情时可以广播。'
- en: In `SCustomButton`, we declare a delegate with the signature `FOnClicked`, called
    `ButtonClicked`.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SCustomButton`中，我们声明了一个具有`FOnClicked`签名的委托，名为`ButtonClicked`。
- en: '`SLATE_ARGUMENT` is another macro, unused in this recipe, which creates an
    internal variable with the type and name you provide, appending an underscore
    to the start of the variable name.'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SLATE_ARGUMENT`是另一个宏，在本示例中未使用，它创建一个带有您提供的类型和名称的内部变量，并在变量名前面添加下划线。'
- en: '`Construct()` is the function that widgets implement to self-initialize when
    they are being instantiated.'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Construct()`是小部件在实例化时实现的自我初始化函数。'
- en: You'll notice we also create a `TAttribute` and a `FOnClicked` instance ourselves,
    without the underscores. These are the actual properties of our object into which
    the arguments that we declared earlier will be copied.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到我们还创建了一个没有下划线的`TAttribute`和`FOnClicked`实例，这些是我们对象的实际属性，之前声明的参数将被复制到其中。
- en: Inside the implementation of `Construct`, we retrieve the arguments that were
    passed to us in the `FArgumentsstruct`, and store them inside our actual member
    variables for this instance.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Construct`的实现中，我们检索传递给我们的参数，并将它们存储在此实例的实际成员变量中。
- en: We assign `Label` and `ButtonClicked` based on what was passed in, then we actually
    create our widget hierarchy.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据传入的内容分配`Label`和`ButtonClicked`，然后实际创建我们的小部件层次结构。
- en: We use the same syntax as usual for this with one thing to note, namely, the
    use of `Text_Lambda` to set the text value of our internal text block.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用与通常相同的语法，但需要注意的是，我们使用`Text_Lambda`来设置内部文本块的文本值。
- en: We use a `lambda` function to retrieve the value of our `Label` `TAttribute`
    using `Get()`, then convert it to `FText`, and store it as our text block's `Text`
    property.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`lambda`函数使用`Get()`来检索我们的`Label` `TAttribute`的值，然后将其转换为`FText`，并将其存储为我们文本块的`Text`属性。
- en: Now that we have our `SWidget` declared, we need to create a wrapper `UWidget`
    object that will expose this widget to the UMG system so that designers can use
    the widget within the **WYSIWYG** editor.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经声明了我们的`SWidget`，我们需要创建一个包装器`UWidget`对象，将这个小部件暴露给UMG系统，以便设计师可以在**所见即所得**编辑器中使用该小部件。
- en: This class will be called `UCustomButtonWidget`, and it inherits from `UWidget`
    rather than `SWidget`.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类将被称为`UCustomButtonWidget`，它继承自`UWidget`而不是`SWidget`。
- en: The `UWidget` object needs a reference to the actual `SWidget` that it owns,
    so we place a protected member in the class that will store it as a shared pointer.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UWidget`对象需要引用它拥有的实际`SWidget`，所以我们在类中放置了一个受保护的成员，将其存储为共享指针。'
- en: A constructor is declared, so is a `ButtonClicked` delegate that can be set
    in blueprint. We also mirror a `Label` property that is marked as `BlueprintReadWrite`
    so that it can be set in the UMG editor.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明了一个构造函数，还声明了一个可以在蓝图中设置的`ButtonClicked`委托。我们还镜像了一个被标记为`BlueprintReadWrite`的`Label`属性，以便可以在UMG编辑器中设置它。
- en: Because we want to be able to bind our button's label to a delegate, we add
    the last of our member variables, which is a delegate that returns a `String`.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们希望能够将按钮的标签绑定到一个委托上，所以我们添加了最后一个成员变量，这是一个返回`String`的委托。
- en: The `SynchronizeProperties` function applies properties that have been mirrored
    in our `UWidget` class across to the `SWidget` that we are linked with.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SynchronizeProperties`函数将在我们链接的`SWidget`上应用在`UWidget`类中被镜像的属性。'
- en: '`RebuildWidget` reconstructs the native widget this `UWidget` is associated
    with. It uses `SNew` to construct an instance of our `SCustomButton` widget, and
    uses the Slate declarative syntax to bind the UWidget''s `OnButtonClicked` method
    to the `ButtonClicked` delegate inside the native widget.'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RebuildWidget`重新构建与此`UWidget`关联的本地小部件。它使用`SNew`来构造我们的`SCustomButton`小部件的实例，并使用Slate声明语法将UWidget的`OnButtonClicked`方法绑定到本地小部件内部的`ButtonClicked`委托。'
- en: This means that when the native widget is clicked, the `UWidget` will be notified
    by having `OnButtonClicked` called.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着当本地小部件被点击时，`UWidget`将通过调用`OnButtonClicked`来接收通知。
- en: '`OnButtonClicked` re-broadcasts the clicked event from the native button via
    the UWidget''s `ButtonClicked` delegate.'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnButtonClicked`通过UWidget的`ButtonClicked`委托重新广播来自本地按钮的点击事件。'
- en: This means that UObjects and the UMG system can be notified of the button being
    clicked without having a reference to the native button widget themselves. We
    can bind to `UCustomButtonWidget::ButtonClicked` to be notified about it.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着UObjects和UMG系统可以在没有对本地按钮小部件的引用的情况下被通知到按钮被点击的事件。我们可以绑定到`UCustomButtonWidget::ButtonClicked`来接收通知。
- en: '`OnButtonClicked` then returns `FReply::Handled()` to indicate that the event
    does not need to propagate further.'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnButtonClicked`然后返回`FReply::Handled()`，表示事件不需要进一步传播。'
- en: Inside `SynchronizeProperties`, we call the parent method to ensure that any
    properties in the parent are also synchronized properly.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SynchronizeProperties`中，我们调用父类的方法，以确保父类中的任何属性也能正确同步。
- en: We use the `OPTIONAL_BINDING` macro to link the `LabelDelegate` delegate in
    our `UWidget` class to `TAttribute`, and in turn, the native button's label. It
    is important to note that the `OPTIONAL_BINDING` macro expects the delegate to
    be called `NameDelegate` based on the second parameter to the macro.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`OPTIONAL_BINDING`宏将我们`UWidget`类中的`LabelDelegate`委托与`TAttribute`和本地按钮的标签进行关联。重要的是要注意，`OPTIONAL_BINDING`宏期望委托被称为`NameDelegate`，基于宏的第二个参数。
- en: '`OPTIONAL_BINDING` allows for the value to be overridden by a binding made
    via UMG, but only if the UMG binding is valid.'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OPTIONAL_BINDING`允许通过UMG进行的绑定覆盖值，但前提是UMG绑定是有效的。'
- en: This means that when `UWidget` is told to update itself, for example, because
    the user customizes a value in the **Details** panel within UMG, it will recreate
    the native `SWidget` if necessary, then copy the values set in Blueprint/UMG via
    `SynchronizeProperties` so that everything continues to work as expected.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着当`UWidget`被告知更新自身时，例如，因为用户在UMG中的**详细信息**面板中自定义了一个值，它将在必要时重新创建本地`SWidget`，然后通过`SynchronizeProperties`复制在蓝图/UMG中设置的值，以确保一切正常工作。
