- en: Drawing Shapes and Applying Textures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制形状和应用纹理
- en: The previous chapter was all about setting up our project to use different types
    of libraries, such as GLFW, GLEW, SMFL, and SDL. In this chapter, we'll go beyond
    the setup part and learn to implement some really cool OpenGL stuff. We'll learn
    about shaders and how to use them to create various shapes. Then, we'll move on
    to learn how to create a separate shader file and reference that in our code.
    We'll also discuss how to apply different textures to shapes using the SOIL library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章全是关于设置我们的项目以使用不同类型的库，如GLFW、GLEW、SMFL和SDL。在本章中，我们将超越设置部分，学习实现一些真正酷的OpenGL功能。我们将学习着色器以及如何使用它们来创建各种形状。然后，我们将继续学习如何创建一个单独的着色器文件并在我们的代码中引用它。我们还将讨论如何使用SOIL库将不同的纹理应用到形状上。
- en: 'In this chapter, we''ll cover the following topics in detail:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细介绍以下主题：
- en: Learning to draw a triangle using a shader
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用着色器绘制三角形
- en: Creating a separate shader file and referencing it in the main code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个单独的着色器文件并在主代码中引用它
- en: Drawing a rectangle and applying textures to it using the SOIL library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SOIL库绘制矩形并应用纹理
- en: This chapter will initiate you into OpenGL coding and you'll learn a lot of
    concepts related to it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将引导你进入OpenGL编程，你将学习很多与之相关的概念。
- en: Before we get started with coding, there a few things that we need to understand.
    Firstly, the code we’ll be writing from now on is platform- and framework-independent.
    So, it doesn’t matter if you are using Xcode on Mac or Visual Studio on Windows,
    the OpenGL code on any platform will be the same, as OpenGL is a platform-independent
    programming language. Secondly, for this chapter, we’ll be using the GLFW library.
    As we won’t be writing any GLFW-specific code, the code in this chapter will be
    relevant for SFML, SDL, or any other library that you wish to use.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，有一些事情我们需要理解。首先，从现在开始我们将编写的代码是平台和框架无关的。所以，无论你是在Mac上使用Xcode还是Windows上的Visual
    Studio，任何平台上的OpenGL代码都将相同，因为OpenGL是一种平台无关的编程语言。其次，对于本章，我们将使用GLFW库。由于我们不会编写任何GLFW特定的代码，本章中的代码将适用于SFML、SDL或任何其他你希望使用的库。
- en: So, let's get started.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始吧。
- en: You can refer to all the code files for this chapter in the `Chapter02` folder
    on GitHub. The GitHub link can be found in the preface of the book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上的`Chapter02`文件夹中找到本章的所有代码文件。本书的序言中可以找到GitHub链接。
- en: Drawing a triangle
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制三角形
- en: 'In this section, we’ll be looking at how to draw a triangle in OpenGL using
    the GLFW library. To begin with, let’s go to the file in which we wrote code to
    create an OpenGL rendering window using the GLFW library in the previous chapter,
    and make the necessary changes to it. Let''s take a look at the following steps
    to understand the code required to draw a triangle:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何在OpenGL中使用GLFW库绘制三角形。首先，让我们回到上一章中我们使用GLFW库创建OpenGL渲染窗口的代码文件，并对它进行必要的修改。让我们看一下以下步骤，以了解绘制三角形所需的代码：
- en: 'We''ll begin by including the essential header files in our code:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在我们的代码中包含必要的头文件：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To create shapes in modern OpenGL, we need to create shaders. So, let’s begin
    by adding some shaders to our code. Firstly, we’ll add a constant, `GLchar *`,
    and we’ll call it `vertexShaderSource`. This is going to be a string and its version
    will be `330 core` :'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在现代OpenGL中创建形状，我们需要创建着色器。因此，让我们首先在我们的代码中添加一些着色器。首先，我们将添加一个常量，`GLchar *`，我们将称之为`vertexShaderSource`。这将是一个字符串，其版本将是`330核心`：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `330 core` defines the core shader language version for OpenGL version 3.3\.
    If you're using OpenGL version 4.0, then the shader language version won't necessarily
    be `440`; it could be something different. By looking for it on the internet,
    you can get an idea of which shader version you should be using.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`330核心`定义了OpenGL 3.3版本的着色器语言版本。如果你使用的是OpenGL 4.0版本，那么着色器语言版本不一定是`440`；它可能是其他版本。通过在互联网上查找，你可以了解应该使用哪个着色器版本。'
- en: 'The `vertexShaderSource` that we mentioned in the preceding line of code is
    just going to handle the **location** and **positioning** of our triangle, which
    we’ll define as follows:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在上一行代码中提到的`vertexShaderSource`将仅处理我们三角形的**位置**和**定位**，我们将如下定义：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And in the following code, we’ll have another shader source that is the `fragmentShaderSource`.
    This will handle the **color** and **texture** of our triangle. At the moment,
    we are explicitly setting only the color value in our shader, in the `vec4` variable:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将有另一个着色器源，即`fragmentShaderSource`。这将处理我们三角形的**颜色**和**纹理**。目前，我们在着色器中明确设置的颜色值仅在`vec4`变量中：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To the variable `vec4` in the preceding code, we've assigned the values `1.0f`,
    `0.5f`, `0.2f`, and `1.0f`, which are the red, green, blue, and alpha values.
    The colors that we have defined here have ranges between 0 and 1, with 0 being
    off and 1 being full intensity; this is very similar to RGB color values ranging
    between 0 and 255.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将`vec4`变量的值赋为`1.0f`、`0.5f`、`0.2f`和`1.0f`，这些是红色、绿色、蓝色和alpha值。我们在这里定义的颜色范围在0到1之间，0表示关闭，1表示全强度；这与RGB颜色值在0到255之间的范围非常相似。
- en: 'Next, in the following lines of code, we will define our rendering window as
    discussed in the previous chapter, just take a look at the following code for
    review:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在以下代码行中，我们将定义我们的渲染窗口，正如前一章所讨论的，只需看一下以下代码进行审查：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, before the `while` loop, we''ll add a line of code to define our shader.
    Let''s begin by adding the following code to our program:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`while`循环之前，我们将添加一行代码来定义我们的着色器。让我们首先将以下代码添加到我们的程序中：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding lines of code, we created a variable for `vertexShader` and
    defined the source of the shader with `glShaderSource()`. And for that function,
    we passed the parameters, number `1` as a reference to the `vertexShaderSource`,
    and for the final parameter, we passed `NULL` for now.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们为`vertexShader`创建了一个变量，并使用`glShaderSource()`定义了着色器的源。为此函数，我们传递了参数，将`1`作为`vertexShaderSource`的引用，并将最后一个参数暂时传递为`NULL`。
- en: 'Next, we are going to compile the shader using `glCompileShader()`, and in
    there we''ll pass `vertexShader`. Then, we''re going to check for any compilation
    errors using `GLint success`. We''ll display these compilation errors to the developers
    in the form of a log. Therefore, we define a `char` variable, `infoLog`, and it''s
    going to be an array of 512 items:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`glCompileShader()`编译着色器，并将`vertexShader`传递给它。然后，我们将使用`GLint success`检查任何编译错误。我们将以日志的形式向开发者显示这些编译错误。因此，我们定义了一个`char`变量`infoLog`，它将是一个包含512个项目的数组：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we''ll add `glGetShaderiv()` function to our code. Which will return
    in params the values of parameter for our shader object. For that function, we''ll
    pass the parameters like `vertexShader`, the status of compilation `GL_COMPILE_STATUS`
    and then pass `&success`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将向我们的代码中添加`glGetShaderiv()`函数。它将在`params`中返回我们的着色器对象的参数值。为此函数，我们将传递参数`vertexShader`、编译状态`GL_COMPILE_STATUS`，然后传递`&success`：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, we'll check whether our shader has successfully compiled with the help
    of an `if` statement. If it hasn't been successfully compiled, a shader log will
    be generated and it will let the developer know about the compilation errors.
    To display the errors, we'll add `glGetShaderInfoLog()` function and in it, we'll
    pass the parameters as `vertexShader`, `512`, `NULL`, and `infoLog`, and then
    add
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`if`语句检查我们的着色器是否成功编译。如果它没有成功编译，将会生成一个着色器日志，并让开发者了解编译错误。为了显示错误，我们将添加`glGetShaderInfoLog()`函数，并在其中传递参数`vertexShader`、`512`、`NULL`和`infoLog`，然后添加
- en: '`std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"` and log out the
    `infoLog` so we can see it in more depth:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"`并输出`infoLog`，以便我们可以更深入地了解它：'
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we''ll do the same for the fragment shader, take a look at the following
    highlighted lines of code, to understand the changes made for the fragment shader:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将对片段着色器做同样的操作，看一下以下突出显示的代码行，以了解对片段着色器所做的更改：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Then, we are going to link the shaders. For that, we'll create a variable called
    `shaderProgram` and reference it in `glCreateProgram();`. The `glCreateProgram()`
    creates an empty program object and returns a non-zero value by which it can be
    referenced. A **program object** is an object to which shader objects can be attached.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将链接着色器。为此，我们将创建一个名为`shaderProgram`的变量，并在`glCreateProgram();`中引用它。`glCreateProgram()`创建一个空的程序对象，并通过返回一个非零值来引用它。**程序对象**是一个可以附加着色器对象的实体。
- en: 'Then, we''ll define `glAttachShader();` function to attach our shaders. In
    there we''re going to pass the `shaderProgram`, which is the variable that we
    just created in the previous step. And then we''ll pass the shaders that we''re
    attaching to it. So, the first one we''ll pass is `vertexShader` and then we''ll
    attach the `fragmentShader`. Then, we''ll define the function `glLinkProgram();`,
    and we''ll link the `shaderProgram` to it. Take a look at the following code to
    understand the description:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将定义`glAttachShader();`函数来附加我们的着色器。在那里，我们将传递`shaderProgram`，这是我们之前步骤中刚刚创建的变量。然后我们将传递要附加到其上的着色器。所以，第一个我们将传递的是`vertexShader`，然后我们将附加`fragmentShader`。然后，我们将定义`glLinkProgram();`函数，并将`shaderProgram`链接到它。看看以下代码以了解描述：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next thing we''re going to do is check for any linking errors, always remember
    to check for any errors in your code. We''ll check the error as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将检查任何链接错误，始终记得检查你代码中的任何错误。我们将如下检查错误：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding line of code, we defined `glGetProgramiv();` and referenced
    our `shaderProgram` to it as we'll be checking whether there are any errors present
    in the code. Then, we'll check for the link status and assign its result to success.
    Next, we checked whether the linking of the shaders was successful. If the linking
    was not successful, we do essentially the same as we did in the previous lines
    of code; that is we'll generate the error log.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，我们定义了`glGetProgramiv();`并引用了我们的`shaderProgram`，因为我们将会检查代码中是否存在任何错误。然后，我们将检查链接状态并将结果分配给成功。接下来，我们检查着色器的链接是否成功。如果链接不成功，我们将基本上与之前几行代码做相同的事情；也就是说，我们将生成错误日志。
- en: We define `glGetProgramInfoLog ();`function and in there we pass the parameters
    such as `shaderProgram`, because that's what we're checking in the errors for.
    Then we pass in `512` for the number of items and `NULL` array and the `infoLog`,
    because this is what we're going to assign any error logs to. Then we enter the
    error message that need to be displayed for the developer.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`glGetProgramInfoLog ();`函数，并在其中传递了参数，例如`shaderProgram`，因为这是我们检查错误时需要检查的内容。然后我们传递了`512`作为项目数量，`NULL`数组以及`infoLog`，因为这是我们打算分配任何错误日志的地方。然后我们输入了需要显示给开发者的错误信息。
- en: So, now that we've checked for any errors while linking our shader program,
    we can actually delete the vertex and fragment shaders because we'll no longer
    be using them as they're part of our shader program now. So, we typed `glDeleteShader();`function
    and reference the vertex and fragment shaders to it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经检查了在链接着色器程序时是否有任何错误，我们实际上可以删除顶点和片段着色器，因为我们将不再使用它们，因为它们现在是我们的着色器程序的一部分。所以，我们输入了`glDeleteShader();`函数并引用了顶点和片段着色器。
- en: 'Next, what we''re going to do is define the vertex data so that we can actually
    draw the triangle in terms of position:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要做的是定义顶点数据，以便我们能够根据位置实际绘制三角形：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, if you wanted draw a quadrilateral, you would have to
    define four vertices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果你想绘制一个四边形，你必须定义四个顶点。
- en: In the preceding lines of code, we began by defining a float array, `vertices[]`,
    and in it we defined our left, right, and the top coordinates.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，我们首先定义了一个浮点数组`vertices[]`，并在其中定义了我们的左、右和顶部坐标。
- en: For the coordinates that we defined, in OpenGL by default if you don't explicitly
    set them, the values of your screen range between `-1` and `1`. So, that the value`0`
    is in the middle and `0.5` is 25% of the away from the middle, or 75% is the away
    from the left-hand side. In later sections, we will look at changing that system
    so it's actually using more of the screen.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们定义的坐标，在OpenGL中默认情况下，如果你没有明确设置它们，你的屏幕值范围在`-1`和`1`之间。所以，值`0`位于中间，`0.5`是中间的25%，或者75%是远离左侧。在后面的章节中，我们将探讨如何更改该系统，使其实际上使用更多的屏幕。
- en: Now that we've got the `vertices[]` array created, what we need to do is create
    the **vertex buffer object** (**VBO**) and the **vertex array object** (**VAO**).
    We'll begin by defining `GLuint` variables `VBO`, `VAO`. Then, we're going to
    generate the vertex array by simply typing `glGenVertexArrays();`, and in this
    function, we'll pass `1` and a reference to VAO. Next, we'll generate the buffers
    by defining the function `glGenBuffers();` and to that, we'll pass `1` and pass
    reference `VBO` to it.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`vertices[]`数组，我们需要做的是创建**顶点缓冲对象**（**VBO**）和**顶点数组对象**（**VAO**）。我们首先定义`GLuint`变量`VBO`和`VAO`。然后，我们将通过简单地输入`glGenVertexArrays();`来生成顶点数组，在这个函数中，我们将传递`1`和一个对VAO的引用。接下来，我们将通过定义函数`glGenBuffers();`来生成缓冲区，并将`1`和引用`VBO`传递给它。
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we''ll bind the vertex array object and then bind and set the vertex
    buffers, so let''s get on with that. We''ll add `glBindVertexArray();`function
    and pass `VAO` to it. Then, we''ll add `glBindBuffer();` function and pass `GL_ARRAY_BUFFER`
    and `VBO` to it. Next, we''ll add `glBufferData();` function and pass `GL_ARRAY_BUFFER`
    and `size()`. As we''ll be checking the size of our vertices in a dynamic way
    that is the reason we passed the function `size()` and to this function we''ll
    pass in the vertices that we are drawing, and then finally we''re going pass `GL_STATIC_DRAW`.
    So, this is just the buffer data that we''ll be using to draw our good stuff:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将绑定顶点数组对象，然后绑定并设置顶点缓冲区，让我们继续。我们将添加`glBindVertexArray();`函数并将`VAO`传递给它。然后，我们将添加`glBindBuffer();`函数并将`GL_ARRAY_BUFFER`和`VBO`传递给它。接下来，我们将添加`glBufferData();`函数并将`GL_ARRAY_BUFFER`和`size()`传递给它。由于我们将以动态方式检查顶点的尺寸，因此我们传递了函数`size()`，并将要绘制的顶点传递给此函数，然后最终我们将传递`GL_STATIC_DRAW`。所以，这是我们用来绘制好东西的缓冲区数据：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, we'll create the vertex pointer, so we'll add the function `glVertexAttribPointer()`and
    to this function, we'll pass the parameters as highlighted in the following code.
    Then, we'll enable the vertex array by typing `glEnableVertexAttribArray()` function
    and we'll pass `0` to it.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建顶点指针，因此我们将添加函数`glVertexAttribPointer()`，并将此函数的参数传递如下代码所示。然后，我们将通过输入`glEnableVertexAttribArray()`函数来启用顶点数组，并将`0`传递给它。
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we''ll bind the buffer, adding `glBindBuffer()`function to our code.
    This is going to take two values: `GL_ARRAY_BUFFER` and `0.`'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将绑定缓冲区，将`glBindBuffer()`函数添加到我们的代码中。这将需要两个值：`GL_ARRAY_BUFFER`和`0.`
- en: 'Then to the next line, we''ll add `glBindVertexArray()` function and this is
    going to be `0`. As we are unbinding the vertex array object over here. It''s
    always a good thing to unbind any buffers or arrays to prevent strange bugs. Take
    a look at the following code:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在下一行，我们将添加`glBindVertexArray()`函数，这将是一个`0`。因为我们在这里正在解绑顶点数组对象。始终解绑任何缓冲区或数组以防止出现奇怪的错误是一个好习惯。请看以下代码：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding code to draw the shape
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加代码以绘制形状
- en: 'The next thing we are going to do is add code to draw the triangle:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们将添加代码以绘制三角形：
- en: We are going to draw the shape within our while loop. We'll want to draw it
    after the `glClear()` function. So, once the screen's been cleared and before
    the screen buffers have been swapped, we'll add function `glUseProgram()`. This
    will indicate what shader program we're using, and for our project, it is `shaderProgram`
    that we have linked our vertex and fragment shaders to.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在while循环中绘制形状。我们希望在`glClear()`函数之后绘制它。因此，一旦屏幕被清除，在屏幕缓冲区交换之前，我们将添加`glUseProgram()`函数。这将指示我们正在使用哪个着色器程序，在我们的项目中，这是`shaderProgram`，我们将顶点和片段着色器链接到它。
- en: Then, we'll add `glBindVertexArray();` function and we bind the VAO to it.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加`glBindVertexArray();`函数并将VAO绑定到它。
- en: Next, we'll want to call `glDrawArrays();` function as this will finally draw
    our triangle. In the first thing that we'll pass in the `glDrawArrays();` function
    is the mode, that is `GL_TRIANGLES` or `GL_QUAD` or `GL_LINE`. Depending on how
    many vertices you have and what sort of object or shape you're trying to achieve,
    this will vary—we'll be covering it in more depth later in this chapter. The second
    parameter that we'll pass to `glDrawArrays();` function is `0` and the final parameter
    that we pass is `3`, as we've put how many vertices are there in our shape as
    it's a triangle.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将调用`glDrawArrays();`函数，这将最终绘制我们的三角形。在`glDrawArrays();`函数中，我们将传递的第一个参数是模式，即`GL_TRIANGLES`、`GL_QUAD`或`GL_LINE`。根据你有多少个顶点以及你试图实现的对象或形状，这将有所不同——我们将在本章的后面更深入地介绍它。传递给`glDrawArrays();`函数的第二个参数是`0`，传递的最后一个参数是`3`，因为我们已经将形状中的顶点数设置为`3`，因为它是一个三角形。
- en: Then, add `glBindVertexArray()` function and to it we pass `0`. We are just
    unbinding it.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加`glBindVertexArray()`函数，并将`0`传递给它。我们只是在取消绑定它。
- en: 'Now, there''s literally one last thing to do: cleaning up. We''ll de-allocate
    all the resources once we''ve finished using them. So, outside of the loop, add
    `glDeleteVertexArrays()` function and assign `1` , `&VAO` and then add `glDeleteBuffers()`
    function to delete the buffers. Take a look at the following code to understand
    the preceding code description, also observe the highlighted terms in the code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实际上只剩下最后一件事要做：清理。一旦我们用完所有资源，我们将释放所有资源。因此，在循环外部，添加`glDeleteVertexArrays()`函数并分配`1`，`&VAO`，然后添加`glDeleteBuffers()`函数来删除缓冲区。查看以下代码以了解前面的代码描述，同时观察代码中的高亮术语：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we are ready to run our code. Once it gets complied without any errors,
    you will get the following triangle as the output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好运行我们的代码了。一旦编译无误，你将得到以下三角形作为输出：
- en: '![](img/c9b89358-4600-4127-abaf-3c8acccaa246.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c9b89358-4600-4127-abaf-3c8acccaa246.png)'
- en: Abstracting the shaders
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象着色器
- en: Let's take a look at shaders in this section, even though we've looked at shaders
    in the previous section while creating the triangle and using a shader to color
    it. What we're going to do in this section is to abstract the shader code into
    a vertex shader file and a fragment shader file so that it's a lot neater and
    more reusable. And, we're also going to abstract out the loading of the shader,
    as once we've abstracted that out, we probably won't need to change it at all,
    or at least there won't be too many changes to it. Further, in our projects, we'll
    just use these files to load the shaders in our code, which will make it easy
    to use.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看本节中的着色器，尽管我们在创建三角形并使用着色器为其着色时已经看过着色器。在本节中，我们将把着色器代码抽象成一个顶点着色器文件和一个片段着色器文件，这样会整洁得多，也更易于重用。此外，我们还将抽象出着色器的加载，因为一旦我们抽象出这一点，我们可能根本不需要更改它，或者至少更改不会太多。进一步来说，在我们的项目中，我们只需使用这些文件来在我们的代码中加载着色器，这将使其易于使用。
- en: Creating the shader files
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建着色器文件
- en: 'Follow these steps to create the files:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建文件：
- en: We'll begin by creating two new empty files in our project IDE and name those
    two files `core.vs` and `core.frag`. Here, `vs` stands for vector shader file
    and `frag` stands for fragment shader file.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在我们的项目IDE中创建两个新的空文件，并将这两个文件命名为`core.vs`和`core.frag`。在这里，`vs`代表向量着色器文件，而`frag`代表片段着色器文件。
- en: It doesn't actually matter what you name these as long as you refer to the exact
    name and the extension when you refer to them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你给它们取什么名字都无关紧要，只要在引用它们时，确切地引用名称和扩展名。
- en: 'Then, open your `core.vs` file and cut and paste the `VectorShaderSource` code
    that we had added in the previous section. Make the highlighted changes shown
    in the following code:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开你的`core.vs`文件，剪切并粘贴我们在上一节中添加的`VectorShaderSource`代码。按照以下代码中的高亮更改进行修改：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's save this file and our vector shader file is created. Next, we're going
    to do essentially the same for the fragment shader file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保存这个文件，我们的向量着色器文件就创建完成了。接下来，我们将对片段着色器文件做同样的操作。
- en: 'So, let''s open up `core.frag` in our IDE and cut and paste `fragmentShaderSource`
    code from the code in the previous section. Once pasted, make changes to it as
    highlighted in the following code:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们在我们的IDE中打开`core.frag`，并从上一节中的代码中剪切并粘贴`fragmentShaderSource`代码。粘贴后，按照以下代码中的高亮部分进行修改：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Save this file and we've now created the fragment shader file too. Let's move
    on to create the Shader.h file for abstracting the loading of shader code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件，我们现在也创建了片段着色器文件。让我们继续创建用于抽象着色器代码加载的`Shader.h`文件。
- en: Creating the Shader.h header file
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Shader.h头文件
- en: 'Now, we''ll also create the shader loading file that is `Shader.h` and use
    that to load our shader into the code. Follow these steps to create the `Shader.h`
    file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还将创建一个着色器加载文件，即`Shader.h`，并使用它将我们的着色器加载到代码中。按照以下步骤创建`Shader.h`文件：
- en: So, let's create an empty header file in our project and name that file `Shader.h`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们在我们的项目中创建一个空的头文件，并将其命名为`Shader.h`。
- en: Once this file is created, open it and cut and paste the shader loading code
    from the code that we had mentioned in the previous section.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了这个文件，打开它，并从我们在上一节中提到的代码中剪切并粘贴着色器加载代码。
- en: What we're actually going to do is cut everything just after the `glViewport(
    0, 0, screenWidth, screenHeight );` code and above the vertices array `GLfloat
    vertices[]` code. As the code that we cut was actually loading our shaders.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实际上要做的就是剪切`glViewport( 0, 0, screenWidth, screenHeight );`代码之后的全部内容，以及顶点数组`GLfloat
    vertices[]`代码之上的内容。因为我们剪切出的代码实际上是加载我们的着色器。
- en: 'Then, make the changes shown in the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照以下代码进行更改：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So, what we've got in the preceding lines of code is just some simple `#ifndef`
    and `#define` preventing it from being included multiple times. We're just including
    the stream and string headers because they're what we're going to be loading our
    files into, so we need the correct headers to load it. Then, we need GLEW obviously,
    which assumes you've got GLEW set up.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在前面几行代码中，我们只是使用简单的`#ifndef`和`#define`来防止它被多次包含。我们只是包含流和字符串头文件，因为它们是我们将要加载文件的地方，所以我们需要正确的头文件来加载它。然后，显然我们需要GLEW，这假设你已经设置了GLEW。
- en: 'After that, we''ve got the `GLuint` program, and we''ve got some comments right
    there. We''ll construct the shader on the fly:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们有了`GLuint`程序，并且那里有一些注释。我们将实时构建着色器：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following variables are used to store and load the code and the shader
    file:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下变量用于存储和加载代码和着色器文件：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the following code, we''re just handling some exceptions:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下代码中，我们只是在处理一些异常：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the following code we are using the string stream, what we''re going to
    do is open the file so we''ve got the vertex and the fragment path. Using the
    string streams, we''re reading the file into the actual stream itself. And then,
    because we don''t need it anymore, we can just close it. Then, we''ll load it
    into our strings and catch any errors there. It''s very simple stuff if you''ve
    done C++ before, which we recommend you should be familiar with:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们使用了字符串流，我们要做的是打开文件，以便我们获取顶点和片段路径。使用字符串流，我们将文件读取到实际的流中。然后，因为我们不再需要它了，我们可以直接关闭它。然后，我们将它加载到我们的字符串中，并捕获任何错误。如果你之前做过C++，这很简单，我们建议你应该熟悉C++：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that, we''re just getting the C string. Then, we''re just compiling the
    shaders, which we''ve already done. So, after those first two lines of code, we''re
    sort of done:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们只是获取C字符串。然后，我们只是编译着色器，这我们已经做了。所以，在代码的前两行之后，我们基本上就完成了：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And then here''s a lower line, just saying to use the program:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后这里有一条低行，只是说使用程序：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So, what we've done in the preceding code is make our shader code a bit more
    dynamic. Next, we're going to go to our `main.cpp` and carry out some changes
    to it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在前面的代码中使我们的着色器代码变得更加动态。接下来，我们将进入`main.cpp`并对其进行一些更改。
- en: Making changes to the draw triangle code
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改绘制三角形的代码
- en: 'As we created our shader files and the `Shader.h` header file in the preceding
    sections, we''ll now load those files into our triangle code. To do this, we''ll
    have to make certain changes to the triangle code that we wrote earlier. Check
    out the below mentioned steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在前面的章节中创建了着色器文件和`Shader.h`头文件，我们现在将加载这些文件到我们的三角形代码中。为此，我们必须对我们之前编写的三角形代码进行一些更改。请查看以下步骤：
- en: 'We''ll begin by including the `Shader.h` header file, because without that
    we can''t actually use the `Shader` class:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先包括`Shader.h`头文件，因为没有它，我们实际上无法使用`Shader`类：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, before defining our vertices, we''ll add the following line of highlighted
    code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在我们定义顶点之前，我们将添加以下高亮显示的代码：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For Xcode, this highlighted code will be replaced with the following line of
    code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Xcode，这个高亮显示的代码将被以下行代码替换：
- en: '`Shader ourShader( "resources/shaders/core.vs", "resources/shaders/core.frag"
    );`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shader ourShader( "resources/shaders/core.vs", "resources/shaders/core.frag"
    );`'
- en: If you execute our triangle code without adding this line on Mac you will get
    an error and the triangle won't be generated in your output window.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在Mac上添加这一行执行我们的三角形代码，你将得到一个错误，并且三角形不会在输出窗口中生成。
- en: 'The reason this happens is there are executable files in your project folder,
    but we don''t have any resource files. So, we''ll have to add those file to our
    project:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 发生这种情况的原因是项目文件夹中有可执行文件，但我们没有资源文件。所以，我们必须将这些文件添加到我们的项目中：
- en: What we want to do is go to our project folder in Xcode, right-click on it,
    go to New Folder, and create a folder called `resources`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要做的是在Xcode的项目文件夹中，右键单击它，转到新建文件夹，创建一个名为`resources`的文件夹。
- en: Inside the `resources` folder, we'll create another folder called `shaders`.
    And then in there, we create a folder that's called `images`/`videos` whenever
    we need those particular file types. So, this is going to be good for the future
    as well.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources`文件夹内，我们将创建另一个名为`shaders`的文件夹。然后在那里，当我们需要这些特定文件类型时，我们创建一个名为`images`/`videos`的文件夹。所以，这对未来也会很有好处。
- en: Next, what we'll do is move our shader files, `core.vs` and `core.frag`, into
    the `shader` folder.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将把我们的着色器文件`core.vs`和`core.frag`移动到`shader`文件夹中。
- en: Then, go to your project, go to Build Phases, and then click on + and click
    on the New Copy Files Phase option.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到你的项目，转到构建阶段，然后点击加号，并点击新建复制文件阶段选项。
- en: Once you've clicked that, you'll have a new section, Copy Files (0 items). Open
    that and make sure Destination is set to Resources, and then click on the + sign
    below it.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击之后，你会看到一个新部分，复制文件（0项）。打开它，确保目标设置为Resources，然后点击其下的加号。
- en: Then, select the `resources` folder and click on the Add button.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择`resources`文件夹，并点击添加按钮。
- en: 'Furthermore, there are a few changes that we want to make to our `vertices
    []` array. As you may remember when we created `core.vs`, what we did was we actually
    created an input for the color as well. So, instead of just explicitly setting
    the color, we''re going to allow some sort of color input. And to do that, we''re
    going to expand out the vertices array as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还想对我们的`vertices []`数组做一些修改。你可能记得当我们创建`core.vs`时，我们实际上创建了一个颜色输入。所以，我们不是直接设置颜色，我们将允许某种颜色输入。为此，我们将扩展顶点数组如下：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding lines of code, what we actually did was added the color by
    putting the values for red, green, and blue color. This is going to be really
    exciting because we're assigning a color to each of the vertices, and what's going
    to happen is, it will blend the colors together and this will create a really
    amazing effect on our triangle.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码行中，我们实际上是通过放置红色、绿色和蓝色的值来添加颜色的。这将非常令人兴奋，因为我们正在为每个顶点分配一个颜色，接下来会发生的事情是，颜色将混合在一起，这将在我们三角形上产生一个非常惊人的效果。
- en: 'Next, we''ll go to our position attribute and color attribute code, and replace
    those with the following code:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将进入我们的位置属性和颜色属性代码，并用以下代码替换它们：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding lines of code will define the position and color attributes of
    the triangle. In the `vertices []` as we''ve six values now: 3 for position coordinates
    and other 3 for color coordinates. That is the reason why we''ve put 6 in the
    preceding code because we''ve got `6` so we''ve got two values for each vertex
    and we''ve added color, so we need to add `6` to our code.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行将定义三角形的定位和颜色属性。在`vertices []`中，我们现在有六个值：3个用于位置坐标，另外3个用于颜色坐标。这就是为什么我们在前面的代码中放置了6，因为我们有`6`，所以每个顶点有两个值，我们添加了颜色，因此我们需要在代码中添加`6`。
- en: 'Next, we''ll get rid of:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将删除：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We''ll then move on to our while loop and replace the `glUseProgram( shaderProgram
    )`with the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将进入while循环，并将`glUseProgram( shaderProgram )`替换为以下代码：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With this preceding last minor change to our code, we are now ready to run
    our program. Once it''s successfully complied without any errors, you will get
    the following colorful triangle as output on your screen:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对代码进行上述最后微小的修改，我们现在可以运行我们的程序了。一旦成功编译且没有错误，你将在屏幕上得到以下彩色三角形的输出：
- en: '![](img/b60a45ae-1411-4d36-9474-986fb34cd6f4.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b60a45ae-1411-4d36-9474-986fb34cd6f4.png)'
- en: 'As we''ve added a color to each one of the vertices in the code. The color
    in the output triangle has blended together. That''s what OpenGL does: it blends
    the colors together. Chances are if you''ve Googled OpenGL before, or just in
    general if you''re into game development, you would have come across some sort
    of similar triangle like this. This is almost a rite of passage in OpenGL equivalent
    to the Hello World code in other programming languages.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们已经为每个顶点添加了颜色。输出三角形的颜色已经混合在一起。这就是OpenGL所做的事情：它将颜色混合在一起。如果你之前搜索过OpenGL，或者你一般对游戏开发感兴趣，你可能会遇到一些类似这样的三角形。这几乎是OpenGL的一个入门仪式，相当于其他编程语言中的Hello
    World代码。
- en: Loading and applying textures to the shape
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载并将纹理应用到形状上
- en: In this section, we'll look how to load textures in our code and learn to apply
    these textures to our objects. Textures is an image which is used add detail to
    an object. Imagine object such as cube and if we apply wooden texture to it, then
    it will look like a wooden box in our game world.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何在我们的代码中加载纹理，并学习将这些纹理应用到我们的对象上。纹理是一种用于为对象添加细节的图像。想象一下，如果我们将木纹应用到立方体上，那么在我们的游戏世界中它将看起来像一个木箱。
- en: For this section, our object will be a rectangle. So first we'll learn how to
    draw rectangle shape in OpenGL and then understand how to apply textures to it.
    To apply texture to the shape, we'll prefer when using SOIL library, which is
    the Simple OpenGL Image Library. If you wish, you can use other libraries such
    as libpng which, as the name suggests, just supports PNG format images. But in
    this section, we'll only learn about SOIL, actually about SOIL2.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们的对象将是一个矩形。因此，首先我们将学习如何在 OpenGL 中绘制矩形形状，然后了解如何将其纹理应用到上面。为了将纹理应用到形状上，我们更倾向于使用
    SOIL 库，即简单的 OpenGL 图像库。如果您愿意，您可以使用其他库，如 libpng，它正如其名，仅支持 PNG 格式的图像。但在这个章节中，我们只学习关于
    SOIL 的内容，实际上是关于 SOIL2 的。
- en: SOIL is a cross-platform library and it's supported on Android and iOS as part
    of game development. GLFW doesn't have any image loading methods built in, that
    is the reason why we are going to use SOIL library to load our textures. Also,
    SOIL helps in making our code as dynamic as possible across various platforms,
    and it's really easy to use as well.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: SOIL 是一个跨平台库，它支持 Android 和 iOS 作为游戏开发的一部分。GLFW 没有任何内置的图像加载方法，这就是我们为什么要使用 SOIL
    库来加载我们的纹理。此外，SOIL 有助于使我们的代码在各种平台上尽可能动态，而且使用起来也非常简单。
- en: So, first let's understand how to set up our project to use the SOIL library
    on Windows and Mac platform.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先让我们了解如何在 Windows 和 Mac 平台上设置我们的项目以使用 SOIL 库。
- en: Setting up a project to use SOIL on Windows
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上设置使用 SOIL 的项目
- en: In this section, we'll understand how to set up our project to use the SOIL
    library on a Windows platform. So, we'll begin by downloading the SOIL library
    and Premake. You must be wondering, what is Premake? Premake is a command line
    tool used to generate project files for platforms such as Visual Studio, Xcode,
    and so on.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何在 Windows 平台上设置我们的项目以使用 SOIL 库。因此，我们将从下载 SOIL 库和 Premake 开始。您可能想知道，Premake
    是什么？Premake 是一个用于为 Visual Studio、Xcode 等平台生成项目文件的命令行工具。
- en: 'Follow these steps to understand the set up process:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤了解设置过程：
- en: Open up your web browser and go to the following link [https://bitbucket.org/SpartanJ](https://bitbucket.org/SpartanJ).
    In the Repositories section click on the SOIL2 option and open the webpage, and
    select the first fork under Introduction for the latest version of SOIL library.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的网络浏览器并访问以下链接 [https://bitbucket.org/SpartanJ](https://bitbucket.org/SpartanJ)。在仓库部分点击
    SOIL2 选项并打开网页，然后在简介下选择最新的 SOIL 库版本的第一个分支。
- en: The reason we are downloading the SOIL2 library is beacuse the original SOIL
    library is actually very old and hasn't been updated for a very long time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下载 SOIL2 库的原因是因为原始的 SOIL 库实际上非常旧，并且已经很久没有更新了。
- en: 'Once you''ve downloaded that, just search for Premake on Google or visit the
    following link: [https://premake.github.io/](https://premake.github.io/). Then,
    click on the Download option. It is recommended that you download the latest stable
    branch, so download the 4.4 version, which is currently stable (at the time of
    writing this book).'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，只需在 Google 上搜索 Premake 或访问以下链接：[https://premake.github.io/](https://premake.github.io/)。然后，点击下载选项。建议您下载最新的稳定分支，因此请下载
    4.4 版本，这是目前稳定的版本（在撰写本书时）。
- en: Next, go to the location where you've downloaded the files and extract both
    of the zipped folders.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到您下载文件的位置，并解压这两个压缩文件夹。
- en: Then, go to the `Premake` folder and copy and paste `premake4.exe` into the
    `SOIL` folder, which we just extracted.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到 `Premake` 文件夹，并将 `premake4.exe` 复制粘贴到我们刚刚解压的 `SOIL` 文件夹中。
- en: Open up the command prompt and in here you may want to change the directory
    path to the location where you downloaded and extracted your `SOIL` folder. Suppose
    the `C:` drive is the drive where all your files get downloaded and you have downloaded
    and extracted your `SOIL` folder to that drive, then all you have to do is type
    `cd` in command prompt and then just drag and drop your `SOIL` folder into it.
    It will automatically enter the path where the `SOIL` folder is located.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符，在这里你可能需要将目录路径更改为你下载并解压 `SOIL` 文件夹的位置。假设 `C:` 驱动器是所有文件下载的驱动器，并且你将 `SOIL`
    文件夹下载并解压到该驱动器，那么你只需要在命令提示符中输入 `cd`，然后将 `SOIL` 文件夹拖放到其中。它会自动进入 `SOIL` 文件夹的位置。
- en: If it's any other drive that your downloads go to, then what you have to do
    is first tell command prompt to change it to that particular drive. To do that,
    just type the actual letter of the drive then type `:` and hit *Enter*, and then
    you can follow the previous drag-and-drop process.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的下载文件在另一个驱动器上，那么你首先需要告诉命令提示符将其切换到那个特定的驱动器。要做到这一点，只需输入驱动器的实际字母，然后输入 `:` 并按
    *Enter* 键，然后你可以遵循之前的拖放过程。
- en: Next, in Command Prompt, type in `premake4.exe`—or whatever the executable is
    called—followed by `vs2017` and then hit *Enter*. This will generate our Visual
    Studio project.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在命令提示符中，输入 `premake4.exe`——或者它被称作的任何可执行文件名称——然后输入 `vs2017`，然后按 *Enter* 键。这将生成我们的
    Visual Studio 项目。
- en: If you're using an older version, such as 2010, you can use 2010 in the `vs`
    command. It doesn't have a command for newer versions of Visual Studio, but if
    you enter that, it will prompt you to upgrade some of the properties, so don't
    worry about that.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是较旧版本，例如 2010，你可以在 `vs` 命令中使用 2010。它没有 Visual Studio 新版本的命令，但如果你输入那个命令，它会提示你升级一些属性，所以不用担心。
- en: Now let's go to our `SOIL` folder, open the `make` folder present inside it
    and then open up the `Windows` folder.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `SOIL` 文件夹，打开其中存在的 `make` 文件夹，然后打开 `Windows` 文件夹。
- en: Inside the `Windows` folder, you'll get a `SOIL2.sln` file. Double-click on
    it and once that has opened in Visual Studio, you might get an upgrade the compiler,
    and libraries pop window. Just click on the OK button.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Windows` 文件夹中，你会得到一个 `SOIL2.sln` 文件。双击它，一旦它在 Visual Studio 中打开，可能会弹出一个升级编译器和库的窗口。只需点击
    OK 按钮。
- en: Then, in the Visual Studio, on the right-hand side, you'll see a filenames.
    The only one that we're concerned with is `soil2-static-lib`. Right-click on that
    file and then click on Build option. This will build our project. You can then
    close Visual Studio.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 Visual Studio 中，在右侧，你会看到一些文件名。我们只关心 `soil2-static-lib` 这个文件。右键单击该文件，然后点击构建选项。这将构建我们的项目。然后你可以关闭
    Visual Studio。
- en: Now, if you go back to the `SOIL` folder, there'll be some more folders generated.
    The one we're interested in is the `lib` folder.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你回到 `SOIL` 文件夹，会发现又生成了更多文件夹。我们感兴趣的是 `lib` 文件夹。
- en: Inside the `lib` folder, there's a `Windows` folder which consists of the `.lib`
    file, which is what we need.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `lib` 文件夹内部，有一个 `Windows` 文件夹，其中包含我们需要的 `.lib` 文件。
- en: Copy that `.lib` file and go to the location where you have your OpenGL project
    created. What we'll do there is, the location where `.sln` file is present, we'll
    make a new folder and name it as `External Libraries`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制那个 `.lib` 文件，然后前往你创建 OpenGL 项目的位置。我们将在 `.sln` 文件所在的位置创建一个新的文件夹，并将其命名为 `External
    Libraries`。
- en: In the `External Libraries` folder we will create a sub folder called `SOIL2`,
    and inside that, we'll create a folder called `lib`.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `External Libraries` 文件夹中，我们将创建一个名为 `SOIL2` 的子文件夹，并在其中创建一个名为 `lib` 的文件夹。
- en: Then, in the `lib` folder that we created just now, paste the `soil2-debug.lib`
    file. So, this way we're going to use relative linking to link our SOIL library.
    If you are aware of the absolute linking process and wants to use it, you can
    use that.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在刚才创建的 `lib` 文件夹中，粘贴 `soil2-debug.lib` 文件。这样，我们将使用相对链接来链接我们的 SOIL 库。如果你了解绝对链接过程并希望使用它，你可以使用它。
- en: And now, what we need to do is go back to the `SOIL` folder and copy the files
    present within the `SOIL2` folder and paste that in the `OpenGL_VisualStudio`
    folder which is present inside the `OpenGL` folder
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要做的是回到 `SOIL` 文件夹，复制 `SOIL2` 文件夹中的文件，并将其粘贴到 `OpenGL` 文件夹内的 `OpenGL_VisualStudio`
    文件夹中。
- en: So, once you've got all of these steps sorted, the one last thing to do is link
    up the `soil2-debug.lib` to our project. To link up the `.lib` file to our Visual
    Studio project with the relative linking, you can refer to the *Linking of GLFW
    and GLEW libraries with relative linking* section in the previous chapter.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，一旦你完成了所有这些步骤，最后一件要做的事情是将`soil2-debug.lib`链接到我们的项目中。要使用相对链接将`.lib`文件链接到Visual
    Studio项目，你可以参考上一章中的“使用相对链接链接GLFW和GLEW库”部分。
- en: With this, we have set up our project to use the SOIL library on Visual Studio.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经设置了我们的项目以在Visual Studio中使用SOIL库。
- en: Setting up a project to use SOIL on Mac
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mac上设置使用SOIL的项目
- en: 'In this section, we''ll understand how to set up our project to use the SOIL
    library on a Mac platform. Let''s take a look at the following steps:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何在Mac平台上设置我们的项目以使用SOIL库。让我们看看以下步骤：
- en: 'Open up your web browser and go to the following link: [https://bitbucket.org/SpartanJ](https://bitbucket.org/SpartanJ).'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的网络浏览器并访问以下链接：[https://bitbucket.org/SpartanJ](https://bitbucket.org/SpartanJ)。
- en: In the Repositories section click on the SOIL2 option and open the webpage,
    and select the first fork under Introduction for the latest version of SOIL library.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“存储库”部分点击SOIL2选项并打开网页，然后在“简介”部分选择最新的SOIL库的第一个分支。
- en: Next, go to the location where you've downloaded the files and extract them.
    Once extracted, go to the `src` folder and in it go to the `SOIL2` folder. Then
    just copy and paste that folder into your project directory in your system, which
    also contains your `main.cpp` and `shader` file.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到你下载文件的位置并解压它们。解压后，转到`src`文件夹，然后进入`SOIL2`文件夹。然后只需将这个文件夹复制并粘贴到你的项目目录中，这个目录也包含你的`main.cpp`和`shader`文件。
- en: Now, just add the library to our triangle project as you normally would. So,
    what we will do is right-click on the project in Xcode, go to the Add Files option,
    click on SOIL, and then click on the Add button.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，就像你通常做的那样将库添加到我们的三角形项目中。所以，我们将右键单击项目，在Xcode中转到“添加文件”选项，点击SOIL，然后点击“添加”按钮。
- en: So, once we've got that included, that's it for the setup part. And now, we'll
    go back to our the code from the previous section and make modification to it
    so as to add textures to our shape.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦我们完成了包含操作，设置部分就结束了。现在，我们将回到上一节中的代码，并对其进行修改以向我们的形状添加纹理。
- en: Applying texture to our shape
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将纹理应用到我们的形状上
- en: 'Now that we''re all set up to use the SOIL library, let''s go to our triangle
    code and make the necessary changes to load our shape and apply texture to it.
    Follow these steps:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好使用SOIL库，让我们转到我们的三角形代码，并对它进行必要的修改以加载我们的形状并应用纹理。请按照以下步骤操作：
- en: 'So, we''ll first include the SOIL library into our code; for that, type in
    the following line at the start of your code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们首先将SOIL库包含到我们的代码中；为此，请在代码开头输入以下行：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we have typed `SOIL2/SOIL2.h` because our library is inside the `SOIL2`
    folder.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们输入了`SOIL2/SOIL2.h`，因为我们的库在`SOIL2`文件夹中。
- en: 'The next thing we''re going to do is enable the alpha support for images with
    extension such as PNG. To do that, type in the following lines of code after we
    have defined out `glViewport()` :'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步，我们将启用具有如PNG扩展的图像的alpha支持。要做到这一点，在我们定义了`glViewport()`之后，输入以下代码行：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding lines of code, the `glEnable( GL_BLEND )` function will help
    in blending the image in our shape. Then we used `glBlendFunc()` and to it we
    passed two parameters `GL_SRC_ALPHA` and `GL_ONE_MINUS_SRC_ALPHA`. This is how
    we enabled the alpha support.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，`glEnable(GL_BLEND)`函数将帮助我们混合形状中的图像。然后我们使用了`glBlendFunc()`，并传递了两个参数`GL_SRC_ALPHA`和`GL_ONE_MINUS_SRC_ALPHA`。这就是我们启用alpha支持的方式。
- en: 'Next, we''ll have to modify our vertices as we''ll be using a rectangular shape
    to apply our texture, and also we''ll have to add coordinates for our texture
    too. So take a look at the following vertices array and make the necessary changes
    to your code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改我们的顶点，因为我们将会使用矩形形状来应用纹理，同时我们还需要添加纹理坐标。所以请查看以下顶点数组，并在你的代码中进行必要的修改：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As we''re going to draw a rectangle, we need four different vertices: bottom
    left, bottom right, top left, and top right. In the preceding code, the values
    that we''ve added don''t actually range between -1 and 1; these values range between
    0 and 1 so are know as normalized values. You might hear this term in computer
    graphics quite a lot. Normalized values basically means the values ranged between
    0 and 1\. So, for example, if you had an image that has a width of 1280 x 1280,
    and the normalized version was 0 to 1, if you were to set a value of 0.5, it would
    be at 640 because it''s halfway along and halfway between 0 and 1280 is 640\.
    This is just a very basic overview of normalization. If you want to know a bit
    more about it, feel free to Google it.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们要绘制一个矩形，我们需要四个不同的顶点：左下角、右下角、左上角和右上角。在先前的代码中，我们添加的值实际上不在-1和1之间；这些值在0和1之间，因此被称为归一化值。你可能在计算机图形学中经常听到这个术语。归一化值基本上意味着值在0和1之间。例如，如果你有一个宽度为1280
    x 1280的图像，归一化版本是0到1，如果你将值设置为0.5，它将在640处，因为它在中间，0和1280之间的一半是640。这只是归一化的一个非常基本的概述。如果你想了解更多关于它的信息，请随时Google它。
- en: 'The next thing we''re going to create is another array for indices. Take a
    look at the following code and let''s try to understand it:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们要创建另一个索引数组。看看下面的代码，让我们试着理解它：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The reason we''ve defined two triangles in the preceding array is, as we''re
    drawing a quadrilateral in this section, our rectangle shape actually requires
    two triangle indices to be defined. Take a look at the following image to understand
    the concept:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数组中定义两个三角形的原因是，因为我们在这个部分绘制一个四边形，我们的矩形形状实际上需要定义两个三角形索引。看看下面的图像来理解这个概念：
- en: '![](img/47de2a46-2347-4650-a95c-a7b8d7498a2d.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/47de2a46-2347-4650-a95c-a7b8d7498a2d.png)'
- en: The preceding image shows defining of the triangle coordinates with and without
    indexing. So, let's have a look at the without indexing part. Without indexing,
    to draw a quadrilateral you'll need six different vertices, as seen in the image.
    Even though there are two pairs of similar coordinates that are shared between
    the two triangles, the vertices are not being efficiently defined. With indexing
    approach, however, we can share the vertices. So, as in the with indexing image,
    the two triangles share the same pair of vertices. So we'll reuse those and as
    a result, we'll be defining only four vertices. Ignore the numbering shown in
    the image; it's slightly different to our situation, but the principle still applies.
    And if you try and draw it out on paper and apply the numbers that we got in our
    indices array to the actual triangle or quadrilateral from the two, it will make
    a lot more sense. It might not be obvious why you would want to do this at the
    moment, and that's because we're only drawing a quadrilateral. But, imagine when
    you have a game and you've got thousands if not millions of triangles, and triangles
    forming various complex shapes. Thus this with indexing approach really becomes
    handy and increase the efficiency of your code.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像展示了带有和不带有索引的三角形坐标的定义。那么，让我们来看看不带索引的部分。不带索引的情况下，要绘制一个四边形，你需要六个不同的顶点，如图所示。尽管两个三角形之间共享了两对相似的坐标，但顶点的定义并不高效。然而，使用索引方法，我们可以共享顶点。所以，就像带有索引的图像中那样，两个三角形共享同一对顶点。因此，我们将重用这些顶点，结果我们将只定义四个顶点。忽略图像中显示的编号；它与我们的情况略有不同，但原则仍然适用。如果你尝试在纸上绘制它，并将我们索引数组中得到的数字应用到实际的三角形或四边形上，它将更有意义。你可能现在不明白为什么要这样做，那是因为我们只是在绘制一个四边形。但是，想象一下，当你有一个游戏，你有成千上万的三角形，它们形成各种复杂的形状。因此，这种带有索引的方法确实变得非常方便，并提高了你代码的效率。
- en: 'Next, in our `GLuint` section below our indices, we want to create another
    buffer called `EBO`, so make the change to the code as highlighted in the following
    line:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在我们的`GLuint`部分，在索引下面，我们想要创建另一个名为`EBO`的缓冲区，所以按照以下突出显示的行修改代码：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We need to generate the buffers for the Element Buffer Objects (EBO), so type
    in the following highlighted lines of code and then we also need to bind that
    buffer :'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为元素缓冲对象（EBO）生成缓冲区，所以输入以下突出显示的代码行，然后我们还需要绑定该缓冲区：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we''ll modify our position and the color attributes, and we''ll add one
    more attribute that is the texture coordinate attribute. Let''s check out the
    following highlighted code and try to understand the modifications done to it:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将修改我们的位置和颜色属性，并添加一个额外的属性，即纹理坐标属性。让我们查看以下突出显示的代码，并尝试理解对其所做的修改：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For the position and the color attributes in the preceding code, we have replaced
    `6` with `8`, as we have eight coordinates in our vertices array: three for the
    position, three for the colors, and two for the texture coordinates. And then,
    we created another vertex attribute pointer as the texture coordinate attribute.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，对于位置和颜色属性，我们将 `6` 替换为 `8`，因为我们有八个坐标在我们的顶点数组中：三个用于位置，三个用于颜色，两个用于纹理坐标。然后，我们创建了另一个顶点属性指针作为纹理坐标属性。
- en: Next, we're going to add the texture loading code. In our main code, after we've
    unbinded our vertex array and before the start of `while` loop, we'll add the
    texture loading code.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加纹理加载代码。在我们的主代码中，在我们解绑顶点数组并在 `while` 循环开始之前，我们将添加纹理加载代码。
- en: Firstly we'll need to create an `GLuint` `texture` variable as this will hold
    our reference to the texture.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个 `GLuint` `texture` 变量，因为它将持有我们对纹理的引用。
- en: Next, we'll create `int` variables as `width` and `height`. This will define
    the width and the height of our texture.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建 `int` 变量作为 `width` 和 `height`。这将定义我们的纹理的宽度和高度。
- en: Then we'll need to add `glGenTextures()` function and for this, we specify the
    `size` as `1` and put a reference to our texture variable.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要添加 `glGenTextures()` 函数，为此，我们将 `size` 设置为 `1`，并将对纹理变量的引用放入其中。
- en: 'We''ll then bind the texture using `glBindTexture()` funtion. Take a look at
    the following highlighted code:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用 `glBindTexture()` 函数绑定纹理。请查看以下突出显示的代码：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And then, we are going to set our texture parameters. For that, we''re going
    to add function `glTexParameteri ()` and to this function, we''ll pass the following
    parameter:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将设置我们的纹理参数。为此，我们将添加函数 `glTexParameteri ()`，并将以下参数传递给此函数：
- en: The first parameter that we're going to set is `GL_TEXTURE_2D`
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将要设置的第一个参数是 `GL_TEXTURE_2D`。
- en: Then for the `name` we're going to set the type of wrapping that we'll be using
    `GL_TEXTURE_WRAP_S`.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，对于 `name`，我们将设置我们将使用的包裹类型 `GL_TEXTURE_WRAP_S`。
- en: And for the wrapping, we're going to add `GL_REPEAT`.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于包裹，我们将添加 `GL_REPEAT`。
- en: It is recommended you have a look at different wrapping techniques. You can
    find more information about this in the OpenGL API guides and if you look at [learnopengl.com](https://learnopengl.com/)
    and [open.gl](https://open.gl/), you will get to read a lot more information about
    all the lines of code that we have written.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您查看不同的包裹技术。您可以在OpenGL API指南中找到更多关于此的信息，如果您查看 [learnopengl.com](https://learnopengl.com/)
    和 [open.gl](https://open.gl/)，您将能够阅读更多关于我们所编写的所有代码行信息。
- en: 'So, what we''re going to do next is duplicate the previous line of code and
    make the following changes as highlighted in the code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们接下来要做的是复制上一行代码，并按照代码中的突出显示进行以下更改：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we''re going to set the texture filtering. Check out the following code
    for it:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置纹理过滤。查看以下代码了解详情：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we are going to add the actual texture loading code to the main code.
    For that, we''re going to create unsigned char variable `*image` and this will
    hold the reference to the function `SOIL_load_image()`. And to this function we
    pass the following parameters:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将把实际的纹理加载代码添加到主代码中。为此，我们将创建一个无符号字符变量 `*image`，它将持有对函数 `SOIL_load_image()`
    的引用。我们将以下参数传递给此函数：
- en: First parameter will be the path of the actual image that we're going to use
    as texture for our object. Therefore, we'll put `res/images/image1.jpg`.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数将是实际图像的路径，我们将使用它作为对象的纹理。因此，我们将放置 `res/images/image1.jpg`。
- en: The second parameter will be the refrence to the width and the height of our
    image.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数将是图像宽度和高度的引用。
- en: Then for the third parameter, we're just going to pass it as `0`.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第三个参数，我们只需将其传递为 `0`。
- en: For the fourth parameter we're going to set the loading method so will add `SOIL_LOAD_RGBA`.
    Even if it's a JPEG image, you always want to load it as an alpha image. The reason
    for that is, it allows the code that we're writing now to be more dynamic. So
    if we swap the JPEG image for a PNG image, it'll still work. If you put in a different
    type of alpha image, or an image without alpha, as long as that type is supported
    by SOIL, the code will work fine.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于第四个参数，我们将设置加载方法，所以我们将添加`SOIL_LOAD_RGBA`。即使它是一个JPEG图像，你也总是想将其作为alpha图像加载。这样做的原因是，它允许我们正在编写的代码更加动态。所以如果我们用PNG图像替换JPEG图像，它仍然可以工作。如果你放入不同类型的alpha图像，或者没有alpha的图像，只要该类型由SOIL支持，代码就可以正常工作。
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we''ll specify a two-dimensional texture image adding the function `glTexImage2d()`
    and to this function we are going to pass the highlighted parameters in the following
    code:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将通过添加`glTexImage2d()`函数指定一个二维纹理图像，并将此函数传递以下代码中的突出显示参数：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We'll generate the mipmaps, so we're going to put `glGenerateMipmap()` funtion.
    And for this function, we specify `GL_TEXTURE_2D` as it's a 2D texture that we
    are using.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将生成米柏（mipmap），因此我们将放置`glGenerateMipmap()`函数。对于这个函数，我们指定`GL_TEXTURE_2D`，因为我们使用的是2D纹理。
- en: Then, we're going to free our image data, as it's always good to clean up. So,
    we'll add `SOIL_free_image_data()` function for that we merely specify our image
    character array.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将释放我们的图像数据，因为清理总是好的。所以，我们将添加`SOIL_free_image_data()`函数，我们将仅指定我们的图像字符数组。
- en: 'Then, we''re going to unbind the texture using `glBindTexture()` function and
    to that function we''ll pass `GL_TEXTURE_2D`, and we''ll unbind the texture by
    passing `0`. Have a look at the following code for a clear understanding:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用`glBindTexture()`函数解绑纹理，并将`GL_TEXTURE_2D`传递给该函数，并通过传递`0`来解绑纹理。查看以下代码以获得清晰的理解：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You might be thinking what is a mipmap? A mipmap is essentially a level of detail
    scheme for texture image. It's a way of creating a bunch of small images by a
    factor of 2 of the original image, and then loading the one that is the closest
    to the actual texture being displayed at any given point, depending on the distance
    from the viewer. So if something's further away, the texture required isn't as
    big. Whereas if it's nearer, it requires a bigger texture. So, it just helps in
    loading the texture properly. It is recommended to have a quick check on the internet
    to understand mipmapping a bit more.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想什么是米柏（mipmap）？米柏本质上是一种纹理图像的细节级别方案。它是一种通过原始图像的2倍因子创建一系列小图像的方法，然后根据观察者的距离加载最接近实际显示纹理的图像。所以如果某物较远，所需的纹理不是很大。而如果它更近，则需要更大的纹理。所以，它只是帮助正确加载纹理。建议在网上快速检查以了解更多关于米柏的信息。
- en: We're not done with our code yet. So, we'll move on to our while loop now
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码还没有完成。因此，我们现在将进入while循环。
- en: Modifying the while loop
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改while循环
- en: 'Let''s follow the below mentioned steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤进行：
- en: In the while loop we'll put some code between the point where we're using the
    shader and where we're binding the vertex array. What we want to do here is add
    `glActiveTexture()`function. This function will help us activating the texture
    that we specify.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在while循环中，我们将在使用着色器和绑定顶点数组之间的点之间放置一些代码。我们在这里想要做的是添加`glActiveTexture()`函数。这个函数将帮助我们激活我们指定的纹理。
- en: Then, we'll add function `glBindTexture()`. And for this function, we pass `GL_TEXTURE_2D`
    and `texture`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加`glBindTexture()`函数。对于这个函数，我们将传递`GL_TEXTURE_2D`和`texture`。
- en: Next, we just add `glUniform1i()` function and pass to it the following highlighted
    parameters.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只需添加`glUniform1i()`函数，并将其传递以下突出显示的参数。
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then we''ll add the code to draw our container:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加绘制我们的容器的代码：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And the last thing that we need to do is just delete the buffer for the element
    buffer object. So, we''ll add `glDeleteBuffers( 1, &EBO );` to our code:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要做的就是删除元素缓冲对象（EBO）的缓冲区。所以，我们将添加`glDeleteBuffers(1, &EBO);`到我们的代码中：
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And now, if we run our code. There will be some error in the compilation of
    the code and you will get the output similar to the following image:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的代码，代码编译过程中将出现一些错误，你将得到以下类似的输出：
- en: '![](img/0898dfef-fc48-41c6-87d2-e2a4133820bb.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0898dfef-fc48-41c6-87d2-e2a4133820bb.png)'
- en: This is not what we intended; this is obviously not what we wanted to load in
    our shape. So, let's try to understand the reason behind this. The only reason
    we are getting the wrong output is because we have not updated our vertex and
    fragment shaders for loading the texture. So let's update it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们想要的；这显然不是我们想要加载到我们的形状中的。所以，让我们尝试理解这个原因。我们得到错误输出的唯一原因是我们没有更新我们的顶点和片段着色器以加载纹理。所以，让我们更新它。
- en: Updating the shader files to integrate texture coordinates
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新着色器文件以集成纹理坐标
- en: 'Follow these steps to carry out the modifications in your shader files:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤对您的着色器文件进行修改：
- en: 'First, let''s go to the vertex shader, our `core.vs` file, and make the changes
    highlighted in the following code:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们转到顶点着色器，我们的`core.vs`文件，并对以下代码中突出显示的部分进行修改：
- en: '[PRE49]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You might be wondering what are we doing here in `TexCoord = vec2(texCoord.x,
    1.0 - texCoord.y);`. Well, what we're doing is swapping the y axis by subtracting
    our coordinates from `1`, and this is done simply because most images have the
    top y-axis inverted in OpenGL.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们在`TexCoord = vec2(texCoord.x, 1.0 - texCoord.y);`这里做了什么。好吧，我们正在通过从`1`减去我们的坐标来交换y轴，这仅仅是因为在OpenGL中，大多数图像的顶部y轴是反转的。
- en: 'Next, go to the fragment shader, `core.frag`, and make the following highlighted
    modifications:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转到片段着色器`core.frag`，并对以下突出显示的部分进行修改：
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And now, if we save the updated shader file and run our program, we will get
    the following output:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们保存更新后的着色器文件并运行我们的程序，我们将得到以下输出：
- en: '![](img/7c4c10d5-abb9-4730-93e0-6867b3ef2cd9.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c4c10d5-abb9-4730-93e0-6867b3ef2cd9.png)'
- en: Check whether your image fit are spot on with the ratio. If it looks a bit squashed,
    that's simply because of the coordinates that we have defined for the vertices.
    It's nothing to do with the texture loading. In later chapters, we'll be learning
    to use logical coordinates, so that any image that you load can fit in properly.
    So, that is it for texture loading.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 检查您的图像是否与比例完全匹配。如果看起来有点压扁，那只是因为我们为顶点定义的坐标造成的。这与纹理加载无关。在后面的章节中，我们将学习使用逻辑坐标，这样任何加载的图像都可以正确地适应。所以，这就是纹理加载的全部内容。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned how to draw various shapes using shaders. We began
    by drawing a triangle and adding color to it. Then, we used the triangle concept
    to draw our quadrilateral and learned how to apply texture to it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用着色器绘制各种形状。我们首先绘制了一个三角形并为其添加了颜色。然后，我们使用三角形的概念来绘制我们的四边形，并学习了如何对其应用纹理。
- en: 'In the next chapter, we''ll learn how to apply transformations such as translation
    and rotation to our shape, and learn to draw a cube and apply texture to it. We''ll
    also explore the concepts of projections: Perspective and Orthographic, and how
    to implement those in our world.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将平移和旋转等变换应用到我们的形状上，并学习如何绘制一个立方体并对其应用纹理。我们还将探讨投影的概念：透视和正交投影，以及如何在我们的世界中实现这些投影。
