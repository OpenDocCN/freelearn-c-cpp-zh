- en: Decoupling Gameplay via the Observer Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过观察者模式解耦游戏
- en: Wow! The last two chapters were full of pointer craziness. Those two chapters
    combined, cover what are probably considered the hardest parts of C++. While all
    design patterns deal with pointers and using virtual functions at some level,
    it doesn't get much more difficult than what was covered in [Chapter 7](part0133.html#3UQQQ0-04600e4b10ea45a2839ef4fc3675aeb7),
    *Improving Performance with Object Pools* and [Chapter 8](part0143.html#48C0E0-04600e4b10ea45a2839ef4fc3675aeb7),
    *Controlling UI via the Command Pattern*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！前两章充满了指针疯狂。这两章结合起来，涵盖了可能被认为是C++中最难的部分。虽然所有设计模式都在某种程度上处理指针和使用虚函数，但与第7章《通过对象池提高性能》和第8章《通过命令模式控制UI》中涵盖的内容相比，难度并不会更大。
- en: In [Chapter 7](part0133.html#3UQQQ0-04600e4b10ea45a2839ef4fc3675aeb7), *Improving
    Performance with Object Pools*, we went very low-level into the guts of C++ memory.
    This involved casting and strange pointer manipulation that most people tend to
    avoid. In [Chapter 8](part0143.html#48C0E0-04600e4b10ea45a2839ef4fc3675aeb7),
    *Controlling UI via the Command Pattern*, we dealt with controlling the UI, which
    is more high-level. However, we learned how to control C++ objects and their methods
    in a way that allows us to create flexible code, but can also be very confusing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](part0133.html#3UQQQ0-04600e4b10ea45a2839ef4fc3675aeb7)《通过对象池提高性能》中，我们深入到了C++内存的底层。这涉及到类型转换和奇怪的指针操作，大多数人都会避免。在[第8章](part0143.html#48C0E0-04600e4b10ea45a2839ef4fc3675aeb7)《通过命令模式控制UI》中，我们处理了控制UI的问题，这是一个更高级别的操作。然而，我们学习了如何以允许我们创建灵活代码的方式控制C++对象及其方法，但这也可能非常令人困惑。
- en: If you feel comfortable with those chapters, then you are doing great. If you
    felt that those topics were a little difficult, you are not alone. Either way,
    you should be excited to know that this chapter covers a pattern that is easy
    to understand, easy to implement, and easily allows us to decouple our core systems
    from the gameplay specific code that is likely to change often.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得那些章节很舒服，那么您做得很好。如果您觉得那些主题有点难，您并不孤单。无论如何，您都应该很高兴地知道，本章涵盖了一个易于理解、易于实现且易于将我们的核心系统与可能经常更改的游戏特定代码解耦的模式。
- en: In this chapter, we will cover a pattern called **Observer**, which is used
    to connect objects together in a decoupled way. As you will see, it is very simple
    to implement and can be applied in many places throughout our code base.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一个名为**观察者**的模式，它用于以解耦的方式将对象连接在一起。正如您将看到的，它非常简单易实现，并且可以在我们的代码库的许多地方应用。
- en: Chapter overview
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节概述
- en: This chapter is all about learning how to decouple code using the Observer pattern.
    This chapter is a little different than the others because it isn't about using
    the Observer pattern to solve one big pattern; it is about learning to apply it
    to the many little situations that lead to sloppy code throughout a game's development.
    The Observer pattern will show you that there is a better way.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于学习如何使用观察者模式解耦代码。本章与其他章节略有不同，因为它不是关于使用观察者模式解决一个大模式；它是关于学习将其应用于导致游戏开发过程中代码混乱的许多小情况。观察者模式将向您展示有更好的方法。
- en: First, we will explore the inevitable situation of gameplay code leaking into
    our engine code. Then, we will learn about the Observer pattern and how it can
    improve these situations. Along the way, we will look at some example code from
    the Mach5 Engine. However, since this pattern has so many uses, we will focus
    on how it can be incorporated into a game, as opposed to showing one large specific
    example.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨游戏代码不可避免地泄漏到我们的引擎代码中的情况。然后，我们将学习观察者模式以及它如何改善这些情况。在这个过程中，我们将查看来自Mach5引擎的一些示例代码。然而，由于这个模式有如此多的用途，我们将关注它如何被整合到游戏中，而不是展示一个大型具体的示例。
- en: Your objectives
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的目标
- en: Learn two ways that gameplay code can cause trouble for your engine code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习两种可能导致您的引擎代码出现问题的游戏代码方式
- en: Implement the simple Observer pattern example
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现简单的观察者模式示例
- en: Learn the pros and cons of the Observer pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习观察者模式的优缺点
- en: How gameplay creeps into every system
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏如何渗透到每个系统中
- en: The first time someone makes a game, there is very likely no distinction between
    the game and the engine. This is usually because there is no engine. A common
    first game would include Ticktacktoe or Hangman. Games like these are simple enough
    that they can be completely written in main, or possibly using a few functions.
    They are also simple enough that they don't require complex systems like graphics
    or physics. There is no need for reusable engine code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次有人制作游戏时，游戏和引擎之间很可能没有明显的区别。这通常是因为没有引擎。常见的第一个游戏可能包括井字棋或猜谜游戏。这样的游戏足够简单，可以完全在main函数中编写，或者可能使用几个函数。它们也足够简单，不需要复杂的系统，如图形或物理。不需要可重用的引擎代码。
- en: As you are learning to program more, you may decide to try making a 2D game
    using a graphics API, like DirectX or OpenGL. Code like this can be very difficult
    the first time it is used, so writing cleanly separated code isn't a top priority.
    Just as before, the game is made with just a few functions or classes. Drawing
    code is often mixed with collision code in one single file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你学习编程更多时，你可能会决定尝试使用图形API（如DirectX或OpenGL）制作一个2D游戏。这样的代码第一次使用时可能非常困难，所以编写干净分离的代码不是首要任务。就像以前一样，游戏只是用几个函数或类制作的。绘图代码通常与碰撞代码混合在一个文件中。
- en: 'At some point, we all get to a place where the code is too complex and fragile.
    Hardcoding too many game object types or too many levels make us wish for a better
    way. Of course, that is the reason for this book. We are trying to find a better
    way to create games. Throughout this book there has been one major theme: things
    always change!'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，我们都会到达一个地方，那里的代码变得过于复杂和脆弱。硬编码太多的游戏对象类型或太多的关卡让我们希望有更好的方法。当然，这正是这本书的原因。我们正在尝试找到创建游戏更好的方法。在这本书的整个过程中，有一个主要主题：事情总是变化的！
- en: To cope with this change, we have tried to create a clear distinction between
    the parts of our game that will change and the parts of the game that are unlikely
    to change. In clear terms, we are trying to separate our engine code from our
    gameplay code. This clear separation of parts has lead us through eight chapters
    of patterns that solve very large and specific problems in games. Every game must
    deal with creating flexible game objects with complex behaviors. So, we learned
    about the Component Object Model and Finite Stage Machines. Every game must deal
    with creating an easy to modify UI. So, we learned about using the Command pattern
    to read actions from a file. These are common problems with common solutions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这种变化，我们试图在我们的游戏部分中区分出那些会变化的部分和那些不太可能变化的部分。用明确的话说，我们正在尝试将我们的引擎代码与游戏玩法代码分开。这种清晰的部件分离引导我们通过了八个章节，这些章节解决了游戏中非常庞大和具体的问题。每个游戏都必须处理创建具有复杂行为的灵活游戏对象。因此，我们学习了组件对象模型和有限状态机。每个游戏都必须处理创建易于修改的用户界面。因此，我们学习了如何使用命令模式从文件中读取动作。这些都是常见问题，有常见解决方案。
- en: However, as you write more code and you start to add more features to your game,
    you will always find that the clear separation between engine and gameplay starts
    to blur. One place that this becomes obvious is physics. The physics engine is
    responsible for moving objects as well as testing for and resolving collisions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着你编写更多的代码并开始向你的游戏添加更多功能，你总会发现引擎和游戏玩法之间的清晰分离开始变得模糊。其中一个变得明显的地方是物理。物理引擎负责移动对象，以及测试和解决碰撞。
- en: While this engine should be purely mathematical, the fact is that a game is
    made up of more than just physics objects. It is made of bullets, raiders, players,
    and more. When a bullet collides with a player, we must execute some very specific
    gameplay code, such as deleting the bullet, creating a small particle effect at
    the collision point, and subtracting player health. The question is, where should
    this code be executed? If the code is placed inside the physics engine, it is
    highly coupled with every game object type. If it is executed outside of the engine,
    we need to get the collision information to the correct location in a clean way.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个引擎应该是纯粹的数学，但事实是，一个游戏不仅仅由物理对象组成。它由子弹、侵略者、玩家等等组成。当子弹与玩家碰撞时，我们必须执行一些非常具体的游戏玩法代码，例如删除子弹，在碰撞点创建一个小粒子效果，并减少玩家的生命值。问题是，这段代码应该在何处执行？如果代码放在物理引擎内部，它将与每个游戏对象类型高度耦合。如果它在引擎外部执行，我们需要以干净的方式将碰撞信息传递到正确的位置。
- en: The same problem of creeping gameplay code occurs with achievements. Achievements
    are always game specific but they end up getting mixed all throughout a code base.
    They can range from tracking behavior such as how many bullets the player fired,
    to tracking total time played or how long the game has been paused. However, they
    could always be related to engine specific behavior such as how many times the
    resolution has been changed, how many network connections have been made, how
    many times a UFO game object was created or destroyed, or how many collision events
    of a certain kind have occurred. This blurred line between engine and gameplay
    code, as well as general increased dependencies, makes code reuse very difficult.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏成就也会出现同样的逐渐增加游戏代码的问题。成就总是特定于游戏的，但最终它们会混入整个代码库中。它们可能包括跟踪行为，比如玩家发射了多少子弹，到跟踪总游戏时间或游戏暂停了多久。然而，它们也可能总是与引擎特定的行为相关，比如分辨率更改了多少次，建立了多少网络连接，创建了或销毁了多少UFO游戏对象，或者发生了多少种特定类型的碰撞事件。这种引擎和游戏代码之间的模糊界限，以及一般性的依赖性增加，使得代码重用变得非常困难。
- en: Hardcoding requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬编码需求
- en: 'We know that introducing gameplay code to our engines increases dependencies
    and limits code reuse. We also know that for a given action, the requirements
    are likely to change as gameplay features are added. Imagine the situation of
    adding controller support for split screen multiplayer in our space shooter. As
    more controllers are plugged in, additional players are created, the game difficulty
    is increased, and we split the screen to follow the new player. In this case,
    the original controller detection occurs in the Input Manager, but we need to
    notify a few other engines that something has changed. An example of this code
    might look like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，将游戏代码引入我们的引擎会增加依赖性并限制代码重用。我们还知道，对于特定的动作，随着游戏功能的添加，需求很可能会发生变化。想象一下在我们的太空射击游戏中添加分屏多人游戏控制器支持的情况。随着更多控制器被插入，会创建更多的玩家，游戏难度增加，我们分割屏幕以跟随新玩家。在这种情况下，原始的控制器检测发生在输入管理器中，但我们需要通知几个其他引擎，有事情发生了。这段代码的一个例子可能如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We might be reasonably certain that this code won't change. If we are, then
    hardcoding the requirements is fine. However, if we are not certain, it is good
    to assume that requirements always change. We might need to support online multiplayer
    and send a message to the Network Manager. We might allow the player to choose
    which type of space ship they want from a list of possible player ships, so we
    need to call a different Object Manager function or pause and switch to a new
    Ship Selection Stage via the Stage Manager.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以合理地确信这段代码不会改变。如果我们确信，那么直接硬编码需求是可行的。然而，如果我们不确定，最好假设需求总是会发生变化的。我们可能需要支持在线多人游戏并向网络管理器发送消息。我们可能允许玩家从可能的玩家飞船列表中选择他们想要的飞船类型，因此我们需要调用不同的对象管理器函数，或者通过阶段管理器暂停并切换到新的飞船选择阶段。
- en: In this case, we have a set of objects that need to be notified when an event
    occurs. We want the notification to happen automatically, but we don't want to
    change the Input Manager every time a new object needs to be notified. More generally,
    we have a broadcasting object that we don't want to change every time there is
    a new object that needs to listen. This would be like a Wi-Fi router needing to
    be updated every time a new device is in range.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一组对象，当事件发生时需要被通知。我们希望通知自动发生，但不想每次有新的对象需要被通知时都更改输入管理器。更普遍地说，我们有一个广播对象，我们不想每次有新的对象需要监听时都更改它。这就像Wi-Fi路由器需要每次有新设备进入范围时都进行更新一样。
- en: The situation above describes interactions between different core engines. However,
    these interactions only happen this way because of the specific requirements of
    the game. Even though there is no gameplay code, the functionality of the specific
    game has crept into the input engine, and would need to be changed if we were
    making a different game. Of course, we could try to factor out some of this code
    into a game logic engine or just put similar code into a stage. Is there another
    way? We will consider that, but first, we will explore the problem from the other
    side.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述情况描述了不同核心引擎之间的交互。然而，这些交互之所以以这种方式发生，仅仅是因为游戏的具体需求。即使没有游戏代码，特定游戏的功能已经逐渐渗透到输入引擎中，如果我们要制作不同的游戏，就需要对其进行更改。当然，我们可以尝试将一些代码提取到游戏逻辑引擎中，或者只是将类似的代码放入一个阶段。还有其他方法吗？我们将考虑这一点，但首先，我们将从另一个角度探讨这个问题。
- en: Polling
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮询
- en: Despite your best efforts, gameplay often turns into a mess. There are so many
    interacting parts that it is impossible to completely reduce coupling of gameplay
    code. While it makes sense that a graphics engine and a physics engine can be
    completely independent and decoupled, we shouldn't even try to do this with gameplay.
    Gameplay code is the game. The best we can do is to attempt to handle modifications
    to the game design gracefully.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你尽了最大努力，游戏玩法往往变得一团糟。游戏中有许多相互作用的部件，完全减少游戏代码的耦合是不可能的。虽然图形引擎和物理引擎可以完全独立且解耦是有道理的，但我们甚至不应该尝试在游戏玩法上这样做。游戏代码就是游戏本身。我们能做的最好的事情就是尝试优雅地处理游戏设计的修改。
- en: The most obvious case of this is the state machines that we saw from [Chapter
    4](part0083.html#2F4UM0-04600e4b10ea45a2839ef4fc3675aeb7), *Artificial Intelligence
    using the State Pattern*. The states often need access to the Object Manager and
    so scan the entire list of objects looking for an object. They may also need access
    to physics to see if they are colliding with this frame or the next. The gameplay
    code is the code that glues everything else together, so it can't really be completely
    decoupled.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况最明显的例子是我们从[第4章](part0083.html#2F4UM0-04600e4b10ea45a2839ef4fc3675aeb7)中看到的，*使用状态模式的智能代理*。状态通常需要访问对象管理器，因此会扫描整个对象列表以查找对象。它们也可能需要访问物理引擎以查看它们是否在本帧或下一帧与对象发生碰撞。游戏代码是将其他所有东西粘合在一起的代码，因此它实际上不能完全解耦。
- en: 'Another example of this could be drawing HUD objects in screen space. If the
    window resolution changes, the objects need to be reoriented. A button in the
    center of the screen at 800 x 600 must still be in the center of the screen at
    1280 x 1024\. That means the position can''t be hardcoded and must automatically
    adjust when the resolution changes. There are two ways of doing this. The first
    is the same as the example above; we could have the change resolution button call
    methods of other systems that care. The second would be for objects that care
    about resolution changes to ask the application for the resolution:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子可能是以屏幕空间绘制HUD对象。如果窗口分辨率改变，对象需要重新定位。屏幕中央的800 x 600分辨率的按钮在1280 x 1024分辨率下仍然需要在屏幕中央。这意味着位置不能硬编码，必须在分辨率改变时自动调整。有两种方法可以做到这一点。第一种与上面的例子相同；我们可以让更改分辨率的按钮调用其他系统的方法。第二种是让关心分辨率更改的对象向应用程序请求分辨率：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here is an example `RepositionComponent`. Every frame, it asks the `M5App` for
    the window resolution and sets the object to the specified scale of the window.
    An object that needed to be in the center of the screen would have `x` and `y`
    scale values of `.5`. If the resolution is 800 x 600, the position of the object
    will be `x = 400`, `y = 300`. If the resolution changes to 1280 x 1024, the position
    of the object will be `x = 640`, `y = 512`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个`RepositionComponent`的例子。每一帧，它都会向`M5App`请求窗口分辨率，并将对象设置为窗口指定的缩放比例。一个需要位于屏幕中央的对象会有`x`和`y`缩放值为`.5`。如果分辨率是800
    x 600，对象的位将是`x = 400`，`y = 300`。如果分辨率更改为1280 x 1024，对象的位将是`x = 640`，`y = 512`。
- en: This works exactly as expected, but it does a lot of unnecessary work. The problem
    isn't that this code will make your game slow; you could have thousands of objects
    doing this before seeing slowdown. Still, this component is asking for the resolution
    60 times a second, when a resolution change might only happen once per play session.
    More likely, the player will choose a resolution once, and the game settings will
    save it to a file and automatically load it every session after that.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全符合预期，但它做了很多不必要的操作。问题不在于这段代码会让你的游戏变慢；你可以在看到减速之前让成千上万的物体这样做。然而，这个组件每秒请求60次分辨率，而分辨率更改可能只在一次游戏会话中发生一次。更有可能的是，玩家会选择一次分辨率，游戏设置会将其保存到文件中，并在之后的每次会话中自动加载它。
- en: The problem with this polling method is that the `RepositionComponent` has no
    way of knowing when the resolution changes. It would be nice if this code ran
    only when the data changed. Instead, it constantly asks for the exact same data,
    and calculates the exact same position every frame.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种轮询方法的问题在于`RepositionComponent`无法知道分辨率何时改变。如果这段代码只在数据改变时运行，那会很好。相反，它不断地请求完全相同的数据，并在每一帧计算完全相同的位置。
- en: The example above is small. Problems like this may seem trivial. Individually,
    they won't even be a problem but, when added together, they can affect your game.
    This is true of all the examples so far in this chapter. They seem easy to solve
    one by one, but they can add up to lots of wasted CPU cycles as well as wasted
    developer time. It would be nice to have a pattern that is easy to implement that
    can solve little problems like these that pop up all over a game. Luckily, the
    Observer pattern will do exactly that.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子很小。类似这样的问题可能看起来很微不足道。单独来看，它们甚至可能不是问题，但，当它们累积起来时，可能会影响你的游戏。这一点在本章迄今为止的所有例子中都是成立的。它们看起来很容易一个个解决，但它们可能会累积成大量的浪费的CPU周期以及开发者的时间。如果能有一个易于实现的模式来解决游戏中出现的这些小问题那就太好了。幸运的是，观察者模式正是如此。
- en: The Observer pattern explained
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式解释
- en: The intent of the Observer pattern is to define a one-to-many relationship between
    objects. When the state of one object changes, all its dependents are notified.
    The typical names for the objects in this pattern are the **Subject** (the one),
    and the **Observers** (the many). The Subject will contain data that the Observers
    need to know about. Instead of the usual situation of classes requesting data
    from another (polling), our Subject will notify a list of Observers when the data
    has changed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式的目的是定义对象之间的一对多关系。当一个对象的状态发生变化时，所有依赖它的对象都会得到通知。在这个模式中，对象的典型名称是**主题**（单个），和**观察者**（多个）。主题将包含观察者需要知道的数据。而不是通常的类从另一个类请求数据（轮询）的情况，我们的主题将在数据发生变化时通知观察者列表。
- en: The terms Subject and Observers may seem a little confusing at first. However,
    this concept is very easy, and one that most of us are familiar with. When trying
    to understand the Observer pattern, think of a blog and subscribers. In this case,
    the blog is the Subject and the subscribers are the Observers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 术语主题和观察者一开始可能有点令人困惑。然而，这个概念非常简单，而且是我们大多数人熟悉的。在尝试理解观察者模式时，想想博客和订阅者。在这种情况下，博客是主题，订阅者是观察者。
- en: A blog may be updated once a day, once a week, once a month, or even less. Readers
    of the blog have the option to check for updates as much as they want, however
    this can waste a lot of time if the readers check more frequently than the blog
    is updated. Instead, fans will often choose to subscribe to an e-mail list so
    they can be notified of updates as they come. The blog keeps a list of subscribers
    and sends an e-mail to everyone on the list when an update is posted.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个博客可能每天更新一次，每周更新一次，每月更新一次，甚至更少。博客的读者可以选择检查更新，然而，如果读者检查的频率高于博客更新的频率，这可能会浪费很多时间。相反，粉丝通常会选择订阅电子邮件列表，以便在更新发布时得到通知。博客保留一个订阅者列表，并在更新发布时给列表上的每个人发送电子邮件。
- en: The Subject and Observer
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题和观察者
- en: 'Let''s look at a code example to understand this pattern better. There are
    a few different ways to implement this pattern, so we will discuss implementation
    strategies along the way:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个代码示例来更好地理解这个模式。实现这个模式有几种不同的方法，所以我们将沿途讨论实现策略：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We start off with our `Observer` interface. As always, we make our destructor
    virtual. The only method we need is an `Update` method however, as always, the
    name isn't important. This is the method that the Subject will use to notify the
    Observers that something has changed. One thing you might notice is that the update
    is very specific. In this case, it has two floats as arguments. This is a dependency
    that might change and cause our code to break. We will address improvements a
    little later.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从我们的`Observer`接口开始。和往常一样，我们使我们的析构函数为虚函数。我们需要的唯一方法是`Update`方法，然而，和往常一样，名称并不重要。这是主题将用来通知观察者有东西发生变化的那个方法。你可能注意到更新非常具体。在这种情况下，它有两个浮点数作为参数。这是一个可能会改变并导致我们的代码出错的依赖项。我们将在稍后讨论改进。
- en: 'You might also notice that there is no member data. It could be possible to
    give the base class a pointer to the Subject, and have this class be responsible
    for registering and unregistering (subscribing and unsubscribing) with the Subject.
    We decided to move that behavior into the derived classes so we could keep the
    base class as simple as possible:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也会注意到没有成员数据。可能给基类提供一个指向主题的指针，并让这个类负责向主题注册和注销（订阅和取消订阅）。我们决定将这种行为移动到派生类中，这样我们可以尽可能保持基类简单：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our Subject is almost as simple as the Observer. The key methods we need are
    ways for the Observers to subscribe and unsubscribe to the Subject. Here, we called
    those methods `RegisterObserver` and `UnregisterObserver`. We have also added
    a `Notify` method which will be used to call `Update` on all registered Observers.
    There is no reason that this method needs to be public or even exist at all. As
    long as the derived class calls `Update` on the registered Observers, we are using
    the pattern correctly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主题（Subject）几乎和观察者（Observer）一样简单。我们需要的关键方法是观察者订阅和取消订阅主题的方式。在这里，我们称这些方法为`RegisterObserver`和`UnregisterObserver`。我们还添加了一个`Notify`方法，它将用于调用所有已注册观察者的`Update`方法。这个方法没有必要是公开的，甚至根本不需要存在。只要派生类在注册的观察者上调用`Update`，我们就正确地使用了这个模式。
- en: Again, you will notice that there are no data members in this class. We could
    easily add a vector of Observer pointers here in the base class. In fact, we could
    easily implement these methods because they will almost always be the same. However,
    we have chosen to keep this class simple and let the derived classes choose how
    to implement these methods.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你会注意到这个类中没有数据成员。我们可以在基类中轻松地添加一个观察者指针的向量。实际上，我们可以轻松实现这些方法，因为它们几乎总是相同的。然而，我们选择保持这个类简单，并让派生类选择如何实现这些方法。
- en: The Player
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家
- en: To demonstrate how the Observer pattern can be used, we will look at a common
    situation in games. We will have a Player with some health that will need to be
    shared. The health of the Player can often be used for many things in a game.
    The value of health might be displayed as part of the HUD. It can also be displayed
    as a colored health bar in either the HUD or directly at the top or at the bottom
    of the Player. Additionally, the game may switch to a game over screen when the
    Player health is at or below zero.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示观察者模式如何使用，我们将考察游戏中常见的情景。我们将有一个玩家，其拥有一些需要共享的生命值。玩家的生命值在游戏中可以用于许多事情。生命值的数值可能作为HUD的一部分显示。它也可以在HUD中或直接在玩家的顶部或底部以彩色生命条的形式显示。此外，当玩家生命值达到或低于零时，游戏可能会切换到游戏结束界面。
- en: 'These display elements, as well as the stage switching mechanisms, are dependent
    directly on the Player''s health. Since it is very unlikely that these variables
    are all in the same scope, it would take some work if we tried to implement this
    via polling. In that case, each object would need to find the Player and ask for
    the health value. Since the health of the Player is unlikely to change every frame,
    most of this work is being wasted. Instead, we will make the Player derive from
    the Subject so it can notify all Observers when the health has changed:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些显示元素以及场景切换机制直接依赖于玩家的生命值。由于这些变量不太可能都在同一个作用域中，如果我们尝试通过轮询来实现，这将需要一些工作。在这种情况下，每个对象都需要找到玩家并请求生命值。由于玩家的生命值不太可能每帧都改变，大部分工作都是浪费的。相反，我们将让玩家从主题（Subject）派生，这样当生命值改变时，它就可以通知所有观察者：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This `Player` class is very simple. Since this is only an example, we will
    only be focusing on the health. In the constructor, we can set the max health.
    The `AdjustHealth` method will be used to make the health change. Of course, we
    also implement each of the base class virtual methods. In the `private` section,
    we use an STL vector to keep track of our Observers. We also store our constructor
    value, as well as a variable for our current health:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Player`类非常简单。由于这只是一个示例，我们只会关注生命值。在构造函数中，我们可以设置最大生命值。`AdjustHealth`方法将用于改变生命值。当然，我们也会实现基类中的每个虚拟方法。在`private`部分，我们使用STL向量来跟踪我们的观察者。我们还存储了构造函数的值，以及我们当前生命值的变量：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Player` constructor sets data passed in by the user. Since the base `Subject`
    class has no data, there is nothing special to do here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player`构造函数设置用户传入的数据。由于基`Subject`类没有数据，这里没有特别的事情要做：'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `RegisterObserver` method takes a pointer to an Observer and adds it to
    the vector of the Observers. Depending on the behavior of the Observer, being
    added to the list twice could cause a lot of problems and could be a difficult
    bug to track down. In this example, we have chosen to assert if the same Observer
    is added twice. After that, we add it to our vector:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterObserver`方法接受一个观察者的指针并将其添加到观察者的向量中。根据观察者的行为，被添加到列表两次可能会引起很多问题，并且可能是一个难以追踪的困难错误。在这个例子中，我们选择断言如果相同的观察者被添加两次。之后，我们将其添加到我们的向量中：'
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our `UnregisterObserver` class is a little more forgiving. If we don''t find
    the Observer in the vector, we ignore it, instead of throwing an assert. This
    will make a little more sense later. You will see that our Observers will automatically
    remove or unregister in their own destructors. However, unregistering twice is
    unlikely to cause a problem. The line `std::swap(*itor, *(--m_observers.end()))`
    might look a little scary. Remember that the end method returns an iterator to
    one past the end of the vector. So, before we dereference, we decrement our iterator
    so it is pointing at the last element in the vector. Then we swap and pop, removing
    the correct element:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `UnregisterObserver` 类稍微宽容一些。如果我们没有在向量中找到观察者，我们会忽略它，而不是抛出一个断言。这将在稍后更加清晰。你会看到我们的观察者将自动在它们的析构函数中移除或注销。然而，注销两次不太可能引起问题。`std::swap(*itor,
    *(--m_observers.end()))` 这行代码可能看起来有点吓人。记住，`end` 方法返回一个指向向量末尾之后的迭代器。所以，在我们解引用之前，我们递减我们的迭代器，使其指向向量中的最后一个元素。然后我们交换并弹出，移除正确的元素：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we said before, the `Notify` method doesn't need to exist. It would be fine
    if the class logic notifies the Observers internally, perhaps in `Setter` methods
    or when the data changes as in our `AdjustHealth` method. However, if there was
    more than one piece of data that the Observers cared about, the user could make
    many changes and send all the data to the Observers just once. Or, perhaps initializing
    the Observer data before the game has started.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所说，`Notify` 方法并不需要存在。如果类逻辑在内部通知观察者，比如在 `Setter` 方法或数据变化时，如我们的 `AdjustHealth`
    方法，那就很好了。然而，如果有多个观察者关心的数据，用户可以做出许多更改，并一次性将所有数据发送给观察者。或者，也许在游戏开始之前初始化观察者数据。
- en: 'This method is simple. It loops through the vector of the Observers and calls
    the `Update` method, sending the health data to those that care:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法很简单。它遍历观察者的向量，并调用 `Update` 方法，将健康数据发送给关心这些数据的对象：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method simulates the Player gaining or losing health. As you can see, after
    the health is modified, the class calls its own `Notify` method, letting all Observers
    know about the change.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法模拟玩家获得或失去健康。如你所见，在健康值修改后，类调用自己的 `Notify` 方法，让所有观察者都知道这个变化。
- en: The Observers
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者
- en: 'For this example, we have the three Observers that we mentioned before. Two
    are related to displaying the health of the Player in different ways; the other
    is used for quitting when the health of the Player is zero or less:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们有之前提到的三个观察者。两个与以不同方式显示玩家健康值有关；另一个用于玩家健康值为零或以下时退出：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, each derived `Observer` class overloads the `Update` method
    from base. You will also notice that each constructor takes a pointer to a Subject
    as the only parameter, and saves that pointer into a member variable. This isn''t
    necessary, but it makes registering and unregistering more convenient because
    the objects take care of themselves. In this example, all three of the Observers''
    constructors and destructors do the exact same thing. Here is one:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个派生 `Observer` 类都重载了基类的 `Update` 方法。你也会注意到每个构造函数只接受一个指向主题的指针作为唯一参数，并将该指针保存到成员变量中。这并不是必需的，但它使得注册和注销更加方便，因为对象会自己处理。在这个例子中，所有三个观察者的构造函数和析构函数都做了完全相同的事情。这里有一个例子：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The choice of keeping a pointer to the Subject is up to you. It has some problems,
    which we will look at a little later; however, it allows the Observer to unregister
    in the destructor. This means that the user doesn't need to do it, which makes
    using the `Observers` classes very easy. If we don't keep this pointer, unregistering
    must be done manually and could be difficult depending on how you access the Subject
    and Observers.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 是否保留对主题的指针的选择取决于你。它有一些问题，我们稍后会讨论；然而，它允许观察者在析构函数中注销。这意味着用户不需要这样做，这使得使用 `Observers`
    类非常容易。如果我们不保留这个指针，注销必须手动完成，这可能会根据你如何访问主题和观察者而变得困难。
- en: 'The rest of the `Observer` methods are simple and don''t interact with the
    Subject at all. Instead, the `Update` methods do some logic based on the values
    of `currentHealth` and `maxHealth`. For the two display elements, this means calculating
    some values; for the `StageLogic` class, this means setting `m_isQuitting` to
    true if the value of current health is zero or less. Let''s look at an example
    `Update` from one of the Observers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的 `Observer` 方法都很简单，并且根本不与主题交互。相反，`Update` 方法基于 `currentHealth` 和 `maxHealth`
    的值执行一些逻辑。对于两个显示元素，这意味着计算一些值；对于 `StageLogic` 类，这意味着如果当前健康值为零或更少，则将 `m_isQuitting`
    设置为 true。让我们看看观察者中的一个 `Update` 的例子：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/00056.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00056.jpeg)'
- en: Figure 9 1 Interaction of Subjects and Observers
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9 1 主题和观察者的交互
- en: 'As you can see, the `Update` methods aren''t very complicated. Nothing about
    the above method is using the Subject. The data could have come from anywhere.
    The part that is most interesting is how simple these objects are to use now.
    All three Observers are using the Player''s health, but they don''t need to call
    any `Player` methods. Even though these four objects interact, using them is incredibly
    simple. Let''s look at how we can use these objects together:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Update` 方法并不复杂。上述方法中没有任何部分使用了主题。数据可能来自任何地方。最有趣的部分是这些对象现在使用起来多么简单。所有三个观察者都在使用玩家的健康值，但他们不需要调用任何
    `Player` 方法。尽管这四个对象相互交互，但使用它们却极其简单。让我们看看我们如何一起使用这些对象：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `main` function starts out with a few `const` values to improve readability.
    After that, we create our objects. We first create our `Player`, which is our
    Subject. Then we create our Observers. Each Observer gets a pointer to the Subject.
    Remember, they are only dependent on the Subject interface, not to the derived
    `Player` class. Once all the Observers are created, the `Player` does an initial
    `Notify` call so the Observers start out with the correct data. Finally, we use
    our objects. The simplicity of this while loop is amazing. Since the code linking
    them together is all internal, using the objects together becomes very easy. Compare
    the example above with a version of the code that doesn''t use the Observer pattern:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数开始时使用一些 `const` 值以提高可读性。之后，我们创建我们的对象。我们首先创建我们的 `Player`，它是我们的主题。然后我们创建我们的观察者。每个观察者都获得对主题的指针。记住，它们只依赖于主题接口，而不是派生的
    `Player` 类。一旦所有观察者都创建完毕，`Player` 就会进行一个初始的 `Notify` 调用，以便观察者从正确的数据开始。最后，我们使用我们的对象。这个
    while 循环的简单性令人惊叹。由于将它们链接在一起的代码都是内部的，因此使用这些对象变得非常容易。将上面的例子与不使用观察者模式的代码版本进行比较：'
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using the Observer pattern allows us to write code that is more elegant and
    simple to use. Unfortunately, many programmers write code that is closer to the
    second version. They don't realize that with just a little thought as to how the
    objects will interact, the code is easier to use, easier to read, and is more
    efficient because it only gets data from the Player when the data changes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者模式允许我们编写更优雅、更易于使用的代码。不幸的是，许多程序员编写的代码更接近第二个版本。他们没有意识到，只要稍微思考一下对象之间的交互方式，代码就更容易使用、更容易阅读，并且更高效，因为它只在数据发生变化时从玩家获取数据。
- en: In this simple example, it may not seem like the code is much different, but
    remember that this is just demonstrating the pattern as simply as possible. The
    second version looks reasonable because all the objects are in the same scope.
    Except for the constructor, in a real project, the Observer code stays the same.
    However, the second version can become a mess of Singleton method calls and object
    look ups.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，可能看起来代码并没有太大不同，但请记住，这只是尽可能简单地演示这个模式。第二个版本看起来合理，因为所有对象都在同一个作用域内。除了构造函数外，在实际项目中，观察者代码保持不变。然而，第二个版本可能会变成一个单例方法调用和对象查找的混乱。
- en: Push versus Pull
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推与拉
- en: One big problem with the Observer pattern that we have looked at so far is that
    the `Update` method in the base class is limited. In our case, it can only be
    used with Observers that expect two floats. If we want a different style of Observer,
    we need to create a new `Observer` class and a new Subject to work with it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前观察到的观察者模式的一个大问题是基类中的 `Update` 方法有限制。在我们的例子中，它只能与期望两个浮点数的观察者一起使用。如果我们想要不同的观察者风格，我们需要创建一个新的
    `Observer` 类和一个新的主题来与之一起工作。
- en: This Push version of the pattern is great because the classes are completely
    decoupled. The derived classes don't need to know about each other at all. The
    price to pay for this decoupling is that we need to write lots of `Subject` and
    `Observer` base classes for each method signature we want to use. An alternative
    version of this pattern lets the Observers pull the data they want from the Subject.
    In the Pull version, the Subject sends itself as a parameter in the `Update` method,
    and the Observer uses `Getter` methods from the Subject to only pull the data
    it wants.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的推送版本非常棒，因为类是完全解耦的。派生类根本不需要了解彼此。为了这种解耦，我们需要为每个想要使用的方法签名编写大量的 `Subject` 和
    `Observer` 基类。这个模式的另一种版本允许观察者从 Subject 中拉取他们想要的数据。在拉取版本中，Subject 在 `Update` 方法中将自身作为参数发送，观察者使用
    Subject 的 `Getter` 方法只拉取它想要的数据。
- en: 'That is exactly what is happening in our next example. The `PlayerHealthBar`
    class now takes a pointer to a Subject. In this case, we are expecting the Subject
    to be of type Player. The `Update` method can then use any Player data it needs
    to complete its task:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们下一个例子中发生的情况。`PlayerHealthBar` 类现在接受一个指向 Subject 的指针。在这种情况下，我们期望 Subject
    是 Player 类型。`Update` 方法可以使用它需要的任何 Player 数据来完成其任务：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the Pull version of the pattern, the `Observer` is dependent on the derived
    `Subject` class (in this case the Player), but the `Update` method is more flexible.
    Additionally, this Observer could be observing many different Subjects. The `Update`
    method could have a series of `if` statements to determine which of the many possible
    Subjects performed the call. The classes are more tightly coupled to specific
    objects. However, since an Observer can now observe multiple Subjects, the same
    `Observer` class can be used for a wider range of objects. For example, a single
    `Observer` class could be used to keep track of how many objects of each type
    in the game have died by registering itself with every game object that gets created
    and monitoring the health of all Subjects.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式的拉取版本中，`Observer` 依赖于派生的 `Subject` 类（在这种情况下是 Player），但 `Update` 方法更加灵活。此外，这个观察者可以观察多个不同的
    Subject。`Update` 方法可以有一系列 `if` 语句来确定哪个可能的 Subject 执行了调用。类与特定对象耦合得更紧密。然而，由于观察者现在可以观察多个
    Subject，相同的 `Observer` 类可以用于更广泛的对象。例如，一个单独的 `Observer` 类可以用来跟踪游戏中每种类型的对象死亡的数量，通过将自己注册到每个创建的游戏对象中并监控所有
    Subject 的健康状态。
- en: Benefits of using the Observer pattern
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用观察者模式的好处
- en: At the start of this chapter we saw three problems with interacting gameplay
    code. As we said before, these problems aren't that big, but they creep up all
    over the place and can lead to inflexible code as the project moves forward. The
    Observer pattern solves these problems in a very simple way.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开始，我们看到了交互式游戏代码的三个问题。正如我们之前所说的，这些问题并不大，但它们无处不在，并且随着项目的推进可能导致代码不够灵活。观察者模式以非常简单的方式解决了这些问题。
- en: The biggest benefit of using the Observer pattern is that we can reduce dependency
    and coupling. By using the Push version of the Observer pattern, our classes can
    interact completely through interfaces, so they don't depend on each other at
    all. In the preceding example, the Player and Player Display are completely decoupled.
    This means that changes to one won't affect the other. For starters, this makes
    each class easier to test and debug because they can be worked on separately.
    However, this also means that as the game changes, these classes can change independently.
    This means the individual class can easily be reused within the current project
    or in separate projects. The only problem with the Push version is that we are
    stuck with a single `Update` method signature.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者模式最大的好处是我们可以减少依赖和耦合。通过使用观察者模式的推送版本，我们的类可以完全通过接口进行交互，因此它们之间没有任何依赖。在先前的例子中，Player
    和 Player Display 是完全解耦的。这意味着对其中一个的更改不会影响另一个。首先，这使得每个类更容易进行测试和调试，因为它们可以单独工作。然而，这也意味着随着游戏的变化，这些类可以独立变化。这意味着单个类可以很容易地在当前项目或单独的项目中重用。唯一的问题是推送版本使我们陷入了一个单一的
    `Update` 方法签名。
- en: Using the Pull version of the Observer pattern increases the dependencies; however,
    the Subject/Observer system is much more flexible. An Observer can now listen
    to multiple Subjects, and a Subject can share different data with each of its
    Observers. Even though the dependencies are increased, this is only on the Observer
    side, since Subjects still don't need to know about their Observers. These increased
    dependencies are still better than the alternative, because they are limited to
    only the two classes that need to interact. Without using the Observer pattern,
    a third class would need to be used to link these two classes together.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者模式的拉取版本增加了依赖性；然而，主题/观察者系统要灵活得多。观察者现在可以监听多个主题，主题可以将其不同的数据与每个观察者共享。尽管依赖性增加了，但这仅限于观察者一侧，因为主题仍然不需要了解它们的观察者。这些增加的依赖性仍然比替代方案更好，因为它们仅限于需要交互的两个类。如果不使用观察者模式，则需要使用第三个类来将这些两个类连接起来。
- en: The second benefit of this pattern is that we no longer need to hardcode methods
    or requirements. Since the event is broadcast to any object that registers, there
    is no need to recompile if a new object needs the event. This reduces compile
    times as well as limits the chance of breaking code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式的第二个好处是我们不再需要硬编码方法或要求。由于事件被广播到任何注册的对象，如果新的对象需要事件，则无需重新编译。这减少了编译时间，并限制了破坏代码的机会。
- en: This isn't just limited to connecting systems to other systems. Since Observers
    can register and unregister at runtime, game objects can register themselves with
    other game objects. Imagine an Enemy Space Station that continuously spawns Raiders.
    By registering Raiders with the station that spawned them, each station can act
    as a mini commander, easily coordinating units for attack and defense.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅限于将系统连接到其他系统。由于观察者可以在运行时注册和注销，游戏对象可以将自己注册到其他游戏对象。想象一下一个敌人太空站，它不断地产生掠夺者。通过将掠夺者注册到产生它们的站，每个站都可以充当小型指挥官，轻松地协调攻击和防御的部队。
- en: The last benefit is that there is no need to poll objects. In the preceding
    example, we saw two `while` loops--one using the Observer pattern, and one polling
    for data every frame. We saw how much cleaner the code looked when using the Observer
    pattern. Besides just looking cleaner, the first example is less likely to have
    bugs because once registered, the Observer will always receive the updated data.
    In a larger project, the alternative requires that every object constantly asks
    for the data all over the code base. Ensuring that every object that needs the
    data asks every frame in many locations can be a Herculean task.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个好处是无需轮询对象。在前面的例子中，我们看到了两个 `while` 循环——一个使用观察者模式，另一个每帧轮询数据。我们看到了使用观察者模式时代码看起来多么整洁。除了看起来更整洁之外，第一个例子出现bug的可能性也更低，因为一旦注册，观察者将始终接收到更新的数据。在一个更大的项目中，另一种方法要求每个对象在代码库的许多地方不断请求数据。确保每个需要数据的对象在许多位置每帧都请求数据可能是一项艰巨的任务。
- en: In addition to being very difficult to find and maintain each poll occurrence,
    this method leads to less efficient code. We shouldn't try to prematurely optimize
    our code, and most likely this won't be the bottleneck of our game, so that is
    why we mentioned it last. However, the fastest code is the code that never runs.
    When using the Observer pattern, if the data never changes and the event never
    occurs, the `Update` methods never get called. So, using the Observer method has
    the chance to boost our performance compared to polling dozens or hundreds of
    times per frame.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在每次轮询发生时非常难以找到和维护之外，这种方法还会导致代码效率降低。我们不应该试图过早地优化我们的代码，而且这很可能不是我们游戏的瓶颈，这就是为什么我们最后才提到它。然而，最快的代码是永远不会运行的代码。在使用观察者模式时，如果数据从未改变且事件从未发生，`Update`
    方法永远不会被调用。因此，使用观察者方法有可能比每帧轮询数十次或数百次来提高我们的性能。
- en: Problems using the Observer pattern
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用观察者模式的问题
- en: Of course, the Observer pattern isn't a perfect solution. There is no perfect
    solution, if there was, this would be a very short book. As with every pattern,
    it is important to learn how to use it but also how not to use it. It is equally
    as important to learn when to use a pattern as it is to learn when not to use
    a pattern.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，观察者模式并不是一个完美的解决方案。没有完美的解决方案，如果有，这本书将会非常短。就像每个模式一样，学习如何使用它以及如何不使用它同样重要。学习何时使用一个模式与学习何时不使用一个模式同样重要。
- en: The Observer pattern has some things that you need to look out for when using
    it. The goal of all patterns is to simplify the development cycle. However, if
    a pattern isn't fully understood, lots of time can be wasted debugging layers
    and layers of code that were meant to save time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者模式时需要注意一些事项。所有模式的目的是简化开发周期。然而，如果模式没有被完全理解，可能会浪费很多时间调试本意是为了节省时间的多层代码。
- en: Dangling references
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 悬垂引用
- en: The first major problem that everyone should be aware of is the problem of dangling
    references. We must ensure that the pointers held by our objects never become
    invalidated. The best way to understand this problem is to look at the Command
    pattern and compare it with the Observer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都应该注意的第一个主要问题是悬垂引用的问题。我们必须确保我们对象持有的指针永远不会变得无效。理解这个问题的最好方法是查看命令模式并将其与观察者进行比较。
- en: The biggest difference between the Command pattern and the Observer pattern
    is a difference in ownership. In the Command pattern, the client or user of the
    command owns a pointer. This means that the client is responsible for deleting
    the command. The reason this is important is because no other class owns the command
    pointer, so it should never become invalidated. In the Mach5 Engine, the `UIButtonComponent`
    owns a command. It deletes that command in the destructor or when it is given
    a new command pointer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式和观察者模式之间最大的区别是所有权的差异。在命令模式中，命令的客户或用户拥有一个指针。这意味着客户负责删除命令。这之所以重要，是因为没有其他类拥有命令指针，因此它不应变得无效。在
    Mach5 引擎中，`UIButtonComponent` 拥有一个命令。它在析构函数中删除该命令，或者当它被赋予新的命令指针时。
- en: Contrast this with the Observer pattern. The Subject contains a pointer to an
    Observer, and the Observer can hold a pointer to the Subject. Neither object owns
    the other, and either object can be deleted at any time. They are separate objects
    that just happen to communicate with each other via pointers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与观察者模式进行对比。主题包含一个指向观察者的指针，观察者可以持有指向主题的指针。两个对象都不拥有对方，并且任何时刻都可以删除任一对象。它们是独立的对象，只是恰好通过指针相互通信。
- en: Before an Observer is deleted, it must be unregistered from every Subject it
    is observing. Otherwise, the Subjects will keep trying to Update it via the invalid
    pointer, causing undefined behavior. In the example, we do this by having the
    Observer hold a pointer to the Subject and unregistering itself in the destructor.
    This causes a problem if the Subject gets deleted first. In the example, there
    is no way for the Subject to tell the Observer that it will be deleted. If the
    Subject does get deleted first, the Observers will still try to unregister in
    their own destructor, causing undefined behavior.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除观察者之前，必须将其从它所观察的每一个主题中注销。否则，主题将不断尝试通过无效指针更新它，导致未定义的行为。在示例中，我们通过让观察者持有主题的指针并在析构函数中注销自己来实现这一点。如果主题先被删除，这会导致问题。在示例中，主题没有方法通知观察者它将被删除。如果主题先被删除，观察者仍然会在自己的析构函数中尝试注销，导致未定义的行为。
- en: There are two solutions to this problem. First, we could ensure the Subject
    never gets deleted before the Observers. Second, we could remove the Subject pointer
    from the Observer and ensure that the Observer still gets unregistered from the
    correct Subject before it is deleted. Both solutions can be difficult to guarantee.
    If you implement the Observer pattern in your game, you must consider this problem.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的有两个方案。首先，我们可以确保主题在观察者之前不会被删除。其次，我们可以从观察者中移除主题指针，并确保在它被删除之前，观察者仍然从正确的主题中注销。这两个方案都可能很难保证。如果你在游戏中实现了观察者模式，你必须考虑这个问题。
- en: Overuse
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过度使用
- en: The second problem with the Observer pattern is the danger of overuse. We stated
    before that the Observer pattern is a great choice when the requirements of a
    method aren't completely known or are likely to change. While it is true that
    anything in a game can change, taking this to the extreme would create a project
    that is impossible to program in and that will never be completed. In the most
    extreme case, every object could be both a Subject and an Observer. Every method
    would be ultimately flexible because we could change everything about it at runtime.
    Every call would notify Observers, which in turn would notify more Observers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式第二个问题是过度使用的风险。我们之前提到，当方法的需求不完全清楚或可能发生变化时，观察者模式是一个很好的选择。虽然游戏中的任何事物都可能发生变化，但将其推向极端将导致一个无法编程的项目，并且永远不会完成。在最极端的情况下，每个对象都可以既是主题（Subject）也是观察者（Observer）。每个方法都将最终具有灵活性，因为我们可以在运行时更改其所有内容。每个调用都会通知观察者，进而通知更多的观察者。
- en: Of course, no one would implement their engine to that extreme, but overuse
    of the Observer pattern is still a problem. It can be difficult to debug a method
    that notifies a long list of Observers. This becomes even worse if there are multiple
    layers to traverse before finding any real code. It can be difficult to find the
    right balance. If you feel like your code is becoming a spider web of interconnected
    pointers, it might be time to look for a better solution.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，没有人会将自己的引擎实现到那种极端，但过度使用观察者模式仍然是一个问题。调试通知长列表观察者的方法可能很困难。如果需要穿越多层才能找到任何实际代码，这会变得更糟。找到正确的平衡可能很困难。如果你觉得你的代码正变成一个相互连接的指针蜘蛛网，可能就是时候寻找更好的解决方案了。
- en: Implementing interfaces
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现接口
- en: The next thing to consider is the implementation of the Observer pattern. In
    the above example, the Subject and the Observer were designed to be interface
    classes. C++ doesn't have a language feature that supports interfaces but that
    doesn't mean we can't write code that uses them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要考虑的是观察者模式的实现。在上面的例子中，主题（Subject）和观察者（Observer）被设计成接口类。C++ 没有支持接口的语言特性，但这并不意味着我们不能编写使用它们的代码。
- en: An interface is a class that contains no data members and has no method implementations.
    C++ does allow for the concept of abstract base classes. This is any class that
    marks at least one method a pure virtual, but using the `= 0` notation. This means
    that the class can't be instantiated and instead must be derived from. This is
    different from an interface because abstract base classes can contain member data
    as well as implementations for methods (including pure virtual methods).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一个不包含数据成员且没有方法实现的类。C++ 允许抽象基类的概念。这指的是至少标记一个方法为纯虚函数的类，使用 `= 0` 符号。这意味着该类不能被实例化，而必须被继承。这与接口不同，因为抽象基类可以包含成员数据以及方法实现（包括纯虚方法）。
- en: This distinction is important to us because C++ allows for multiple inheritance,
    although it is strongly recommended that you do not use this feature. Inheriting
    from multiple base classes means that you could be inheriting data members and
    methods with the same name. Since each of the parents could also be inheriting
    from multiple classes, it can be difficult to fully understand the entire tree
    that any derived class gets the implementations from. This will almost certainly
    lead to unexpected behavior. That is why you should avoid multiple inheritances
    and instead stick with a single parent class that your implementation derives
    from.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个区别对我们来说很重要，因为 C++ 允许多重继承，尽管强烈建议不要使用这个特性。从多个基类继承意味着你可能会继承具有相同名称的数据成员和方法。由于每个父类也可能从多个类继承，因此理解任何派生类从哪些实现中继承整个树可能很困难。这几乎肯定会引起意外的行为。这就是为什么你应该避免多重继承，而应该坚持使用单一父类，你的实现是从该父类派生的。
- en: Interfaces are a little different. Many languages do not let you inherit from
    multiple classes that contain implementations, but they do let you implement multiple
    interfaces. Since interfaces do not contain method implementations or data members,
    there is no chance of having name clashes or inheriting unexpected behavior. By
    implementing an interface, you are simply promising that your class will respond
    to a method call. It is the responsibility of the derived class to write the behavior.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接口略有不同。许多语言不允许你从包含实现的多重类中继承，但它们确实允许你实现多个接口。由于接口不包含方法实现或数据成员，因此不存在名称冲突或意外继承行为的风险。通过实现接口，你只是在承诺你的类将响应方法调用。实现行为是派生类的责任。
- en: The Subject and Observer were written as interface classes in case they need
    to be used with Stages, Components, or any other class that already needs to derive
    from a base class. Of course, instead of using multiple inheritance, you could
    always find another solution. For example, you could create a new class that derives
    from the Observer and have your component contain, as opposed to inherit, that
    new class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 主题（Subject）和观察者（Observer）被设计为接口类，以防它们需要与阶段（Stages）、组件（Components）或任何其他需要从基类派生的类一起使用。当然，你不必使用多重继承，总能找到其他解决方案。例如，你可以创建一个新的类，该类从观察者（Observer）派生，让你的组件包含（而不是继承）这个新类，而不是继承。
- en: When to notify
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时通知
- en: The final thing to consider when using the Observer pattern is when to notify
    the Observers. The first option is to notify the Observers after any data has
    changed. In the above example, the Player called `Notify` within the `AdjustHealth`
    method. This means that the Observers will have the most up to date information
    immediately. However, if the `AdjustHealth` method is called many times in one
    frame, time is wasted updating the Observers many times. This problem becomes
    worse if the Observers were observing more than just the Player's health.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用观察者模式时需要考虑的最后一件事是何时通知观察者。第一个选项是在任何数据更改后通知观察者。在上面的例子中，玩家在`AdjustHealth`方法中调用了`Notify`。这意味着观察者将立即获得最新信息。然而，如果`AdjustHealth`方法在一个帧内被多次调用，就会浪费很多时间多次更新观察者。如果观察者观察的不仅仅是玩家的健康，这个问题会变得更糟。
- en: The other option would be to notify the Observers after all data has changed.
    This solution is obviously more efficient but a lot depends on how your system
    works. In the preceding example, it could be possible to update all the Player
    information (in this case, just the health) first, then call `Notify` before displaying
    anything.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是在所有数据更改后通知观察者。显然，这个解决方案更有效，但很大程度上取决于你的系统是如何工作的。在前面的例子中，可能首先更新所有玩家信息（在这种情况下，只是健康），然后在显示任何内容之前调用`Notify`。
- en: In a game engine with many different Subjects and Observers that interact in
    different ways every frame, it can be difficult to know when all data has been
    updated. There might not be a way to sort the game objects such that all Subjects
    are updated before the Observers. It is possible that a HUD object that is an
    Observer has already been updated before the Subject gets updated. This becomes
    even more difficult since other systems such as physics can affect the data inside
    game objects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个具有许多不同主题和观察者，并且每帧以不同方式交互的游戏引擎中，知道何时所有数据都已更新可能很困难。可能没有一种方法可以排序游戏对象，以便在观察者之前更新所有主题。可能存在一种情况，即作为观察者的HUD对象已经在主题更新之前更新了。由于其他系统（如物理系统）可能影响游戏对象中的数据，这变得更加困难。
- en: In the end, there isn't a correct time to notify the Observers. It can be more
    efficient to only notify them once. However, if the system is complex, it probably
    isn't worth the programming trouble trying to batch all `Notify` calls together.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，没有正确的时间来通知观察者。只通知一次可能更有效率。然而，如果系统复杂，尝试批量处理所有`Notify`调用可能不值得编程上的麻烦。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on the communication between reusable engine code
    and game specific gameplay code. We learned that it can be difficult to make a
    clear distinction between these two parts because the gameplay code has the potential
    to creep into every system. This makes sense because to make a game, you must
    write code that interacts with every other system. However, this means reusing
    code is a little difficult.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于可重用引擎代码与特定游戏玩法代码之间的通信。我们了解到，在游戏玩法代码有可能渗透到每个系统的情况下，很难在这两部分之间做出明确的区分。这是有道理的，因为要制作游戏，你必须编写与每个其他系统交互的代码。然而，这也意味着代码的重用会有些困难。
- en: We saw that the solution to this was to decouple our engine and gameplay code
    by having all communication go through interface classes. These interface classes
    were the basis for what is known as the Observer pattern. By using this pattern,
    we can make our code much cleaner and easier to use, and reuse.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，解决这个问题的方法是通过让所有通信都通过接口类来进行，从而解耦我们的引擎和游戏玩法代码。这些接口类是所谓的观察者模式的基础。通过使用这个模式，我们可以使我们的代码更加整洁、易于使用和复用。
- en: The Observer pattern is as easy as it gets when it comes to design patterns.
    Few patterns are as simple to implement or understand. Once you start using it
    you will wonder how you ever programmed without it. However, we also learned there
    are some things to watch out for when using the pattern, the worst of which is
    dangling references.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到设计模式时，观察者模式是最简单的。很少有模式像它一样易于实现或理解。一旦开始使用它，你就会 wonder 你是如何在没有它的前提下编程的。然而，我们也了解到在使用该模式时有一些需要注意的事项，其中最糟糕的是悬挂引用。
- en: Now that we have a great tool for separating gameplay from our engine, let's
    move onto another problem related to code reuse. In the next chapter, we will
    talk about a pattern that allows us to reuse objects and save memory. Along the
    way, we will learn about making great particle systems.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了将游戏玩法与我们的引擎分离的强大工具，让我们继续解决与代码复用相关的问题。在下一章中，我们将讨论一种允许我们复用对象并节省内存的模式。在这个过程中，我们将学习如何制作出色的粒子系统。
