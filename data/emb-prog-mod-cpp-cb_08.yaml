- en: Communication and Serialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信和序列化
- en: Complex embedded systems are rarely composed of a single application. Having
    all the logic in the same application is brittle, error-prone, and sometimes hardly
    feasible because different functions of the system may be developed by different
    teams and even different vendors. That is why isolating the logic of the functions
    in standalone applications and communicating with each other using a well-defined
    protocol is a common approach used to scale embedded software. In addition, this
    kind of isolation can be used with minimal modifications to communicate with applications
    hosted on remote systems, making it even more scalable. We will learn how to build
    robust and scalable applications by splitting their logic into independent components
    that communicate with each other.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的嵌入式系统很少由单个应用程序组成。将所有逻辑放在同一个应用程序中是脆弱的、容易出错的，有时甚至难以实现，因为系统的不同功能可能由不同的团队甚至不同的供应商开发。这就是为什么将函数的逻辑隔离在独立的应用程序中，并使用明确定义的协议相互通信是一种常见的方法，用于扩展嵌入式软件。此外，这种隔离可以通过最小的修改与托管在远程系统上的应用程序通信，使其更具可扩展性。我们将学习如何通过将其逻辑分割为相互通信的独立组件来构建健壮和可扩展的应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using inter-process communication in applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序中使用进程间通信
- en: Exploring the mechanisms of inter-process communication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索进程间通信的机制
- en: Learning about message queue and publisher-subscriber models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习消息队列和发布-订阅模型
- en: Using C++ lambdas for callbacks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++ lambda进行回调
- en: Exploring data serialization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索数据序列化
- en: Using the FlatBuffers library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FlatBuffers库
- en: The recipes in this chapter will help you understand the basic concepts of scalable
    and platform-independent data exchange. They can be used to implement data transfer
    from an embedded system to the cloud or to a remote backend, or to design an embedded
    system using microservice architecture.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例将帮助您了解可扩展和平台无关的数据交换的基本概念。它们可以用于实现从嵌入式系统到云端或远程后端的数据传输，或者使用微服务架构设计嵌入式系统。
- en: Using inter-process communication in applications
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中使用进程间通信
- en: Most modern operating systems use memory virtualization support provided by
    the underlying hardware platform to isolate application processes from each other.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代操作系统使用底层硬件平台提供的内存虚拟化支持，以将应用程序进程彼此隔离。
- en: Each process has its own virtual address space that is completely independent
    of the address spaces of other applications. This provides huge benefits to developers.
    Since the address processes of applications are independent, an application cannot
    accidentally corrupt the memory of another application. As a result, a failure
    in one application does not affect the whole system. Since all the other applications
    keep working, the system can recover by restarting the failing application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有自己完全独立于其他应用程序的虚拟地址空间。这为开发人员带来了巨大的好处。由于应用程序的地址进程是独立的，一个应用程序不能意外地破坏另一个应用程序的内存。因此，一个应用程序的失败不会影响整个系统。由于所有其他应用程序都在继续工作，系统可以通过重新启动失败的应用程序来恢复。
- en: The benefits of memory isolation come at a cost. Since one process cannot access
    the memory of another, it needs to use a dedicated **A****pplication Program Interface** (**API**)
    for data exchange, or **inter-process communication **(**IPC**), which is provided
    by the operating system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 内存隔离的好处是有代价的。由于一个进程无法访问另一个进程的内存，它需要使用专用的**应用程序编程接口**（**API**）进行数据交换，或者由操作系统提供的**进程间通信**（**IPC**）。
- en: In this recipe, we will learn how to exchange information between two processes
    using shared files. It may not be the most performance-efficient mechanism, but
    it is ubiquitous, easy to use, and good enough for various practical use cases.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用共享文件在两个进程之间交换信息。这可能不是最高效的机制，但它是无处不在的，易于使用，并且对于各种实际用例来说足够好。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will create a sample application that creates two processes.
    One process generates data while another reads the data and prints it to the console:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个示例应用程序，创建两个进程。一个进程生成数据，而另一个读取数据并将其打印到控制台：
- en: In your working directory (`~/test`), create a subdirectory called `ipc1`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的工作目录（`~/test`）中，创建一个名为`ipc1`的子目录。
- en: Use your favorite text editor to create an `ipc1.cpp` file in the `ipc1` subdirectory.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`ipc1`子目录中创建一个名为`ipc1.cpp`的文件。
- en: 'We are going to define two templated classes to organize our data exchange.
    The first class, `Writer`, is used to write data into a file. Let''s put its definition
    in the `ipc1.cpp` file:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义两个模板类来组织我们的数据交换。第一个类`Writer`用于将数据写入文件。让我们将其定义放在`ipc1.cpp`文件中：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is followed by the definition of the `Reader` class, which is responsible
    for reading data from a file:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`Reader`类的定义，它负责从文件中读取数据：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we define the data type that we will use for our data:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义将用于我们数据的数据类型：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To wrap everything together, we define the `DoWrites` and `DoReads` functions,
    as well as the `main` function that invokes them:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将所有内容整合在一起，我们定义了`DoWrites`和`DoReads`函数，以及调用它们的`main`函数：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, create a `CMakeLists.txt` file containing the build rules for our
    program:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个包含程序构建规则的`CMakeLists.txt`文件：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can now build and run the application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以构建和运行应用程序了。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In our application, we explore data exchange between two independent processes
    using a shared file in a filesystem. One process writes data to a file, another
    reads data from the same file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们探索了在文件系统中使用共享文件在两个独立进程之间进行数据交换。一个进程向文件写入数据，另一个从同一文件读取数据。
- en: Files can store any unstructured sequences of bytes. In our application, we
    utilize the C++ templates' capabilities to work with strictly typed C++ values
    rather than raw byte streams. This approach helps in writing clean and error-free
    code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 文件可以存储任何非结构化的字节序列。在我们的应用程序中，我们利用C++模板的能力来处理严格类型化的C++值，而不是原始字节流。这种方法有助于编写干净且无错误的代码。
- en: 'We start with a definition of the `Write` class. It is a simple wrapper on
    top of the standard C++ `fstream` class used for file input/output. The constructor
    of the class only opens a file stream to write the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`Write`类的定义开始。它是标准C++ `fstream`类的简单包装，用于文件输入/输出。该类的构造函数只打开一个文件流以进行以下写入：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Besides the constructor, the class contains only one method, `Write`, which
    is responsible for writing data to a file. Since the file API operates with byte
    streams, we first need to convert our templated data type into a raw character
    buffer. We can do this using the C++ `reinterpret_cast`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构造函数，该类只包含一个名为`Write`的方法，负责向文件写入数据。由于文件API操作的是字节流，我们首先需要将我们的模板数据类型转换为原始字符缓冲区。我们可以使用C++的`reinterpret_cast`来实现这一点：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Reader` class does the opposite job—it reads data written by the `Writer` class.
    Its constructor is a bit more complicated. Since the data file might not be ready
    by the time the instance of the `Reader` class is created, the constructor tries
    to open it in a loop until an open attempt succeeds. It makes `10` attempts with
    10-millisecond pauses between each:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reader`类的工作与`Writer`类相反——它读取`Writer`类写入的数据。它的构造函数稍微复杂一些。由于数据文件可能在创建`Reader`类的实例时还没有准备好，构造函数会尝试在循环中打开它，直到成功打开为止。它会尝试10次，每次间隔10毫秒：'
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `Read` method reads data from the input stream into a temporary value and
    returns it to the caller. Similar to the `Write` method, we use `reinterpret_cast`
    to access the memory of our data objects as raw character buffers:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Read`方法从输入流中读取数据到临时值，并将其返回给调用者。与`Write`方法类似，我们使用`reinterpret_cast`来访问我们的数据对象的内存作为原始字符缓冲区：'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also add a wait loop into the `Read` method to wait for data being written
    by `Write`. If we reach the end of the file, we wait for up to 1 second for new
    data:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`Read`方法中添加了一个等待循环，等待`Write`写入数据。如果我们到达文件的末尾，我们等待最多1秒钟获取新数据：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If data is not available in the file at this point, or in the case of an I/O
    error, we throw an exception to indicate it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时文件中没有可用的数据，或者出现I/O错误，我们会抛出异常来指示它：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Please note that we do not need to add any code to handle a situation where
    a file cannot be opened within 1 second, or data is not ready within one second.
    Both of these cases are handled by the same preceding code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要添加任何代码来处理文件在1秒内无法打开的情况，或者数据在一秒内不准备好的情况。这两种情况都由前面的代码处理。
- en: 'Now that the `Writer` and `Reader` classes are implemented, we can define a
    data type for our data exchange. In our application, we will exchange coordinates,
    represented as the `x` and `y` integer values. Our data message looks like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Writer`和`Reader`类已经实现，我们可以为我们的数据交换定义一个数据类型。在我们的应用程序中，我们将交换坐标，表示为`x`和`y`的整数值。我们的数据消息看起来像这样：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For convenience, we override the `<<` operator for our `Message` structure.
    Any time an instance of `Message` is written to an output stream, it is formatted
    as `(x, y)`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们重写了`Message`结构的`<<`运算符。每当`Message`的实例被写入输出流时，它都会被格式化为`(x, y)`：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With all the preparations in place, let''s write the functions for data exchange.
    The `DoWrites` function defines a vector of four coordinates and creates a `Writer`
    object:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作已经就绪，让我们编写数据交换的函数。`DoWrites`函数定义了一个包含四个坐标的向量，并创建了一个`Writer`对象：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, it writes all the coordinates in a loop:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它在循环中写入所有的坐标：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `DoReads` function, in turn, creates an instance of the `Reader` class
    using the same filename as the `Writer` instance before it. It enters an endless
    loop, trying to read all the messages in the file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoReads`函数创建一个`Reader`类的实例，使用与之前的`Writer`实例相同的文件名。它进入一个无限循环，尝试读取文件中的所有消息：'
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When no more messages are available, the `Read` method throws an exception
    that breaks the loop:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有更多的消息可用时，`Read`方法会抛出一个异常来中断循环：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `main` function creates two independent processes, running `DoWrites` in
    one of them and `DoReads` in another. After running the application, we get the
    following output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数创建了两个独立的进程，在其中一个进程中运行`DoWrites`，在另一个进程中运行`DoReads`。运行应用程序后，我们得到以下输出：'
- en: '![](img/8f5ce532-4e3c-401e-8716-87f43e5d0c8c.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f5ce532-4e3c-401e-8716-87f43e5d0c8c.png)'
- en: As we can see, the writer did write four coordinates and the reader was able
    to read the same four coordinates using a shared file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，写入者确实写入了四个坐标，读取者能够使用共享文件读取相同的四个坐标。
- en: There's more...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We created our application to be as simple as possible, focusing on strictly
    typed data exchange and leaving data synchronization and data serialization out
    of the scope. We are going to use this application as a foundation for more advanced
    techniques, which will be described in the recipes that follow.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计应用程序尽可能简单，专注于严格类型化的数据交换，并将数据同步和数据序列化排除在范围之外。我们将使用这个应用程序作为更高级技术的基础，这些技术将在接下来的示例中描述。
- en: Exploring the mechanisms of inter-process communication
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索进程间通信的机制
- en: 'Modern operating systems provide a number of IPC mechanisms beyond the shared
    files we have already learned about, namely the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现代操作系统提供了许多IPC机制，除了我们已经了解的共享文件之外，还有以下机制：
- en: Pipes
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: Named pipes
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名管道
- en: Local sockets
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地套接字
- en: Network sockets
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络套接字
- en: Shared memory
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内存
- en: It is interesting that many of them provide exactly the same API that we use
    when working with regular files. As a result, switching between these types of
    IPC is trivial and the same code that we used to read and write to local files
    can be used to communicate with applications running on a remote network host.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，其中许多提供的API与我们在使用常规文件时使用的API完全相同。因此，在这些类型的IPC之间切换是微不足道的，我们用来读写本地文件的相同代码可以用来与运行在远程网络主机上的应用程序进行通信。
- en: In this recipe, we will learn how to use Portable Operating System Interface
    (**POSIX**) named pipes to communicate between two applications that reside on
    the same computer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用名为**POSIX**的可移植操作系统接口（**POSIX**）命名管道来在同一台计算机上的两个应用程序之间进行通信。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to use the source code of the application we created as part of
    the *Using inter-process communication in applications *recipe as a starting point
    for this recipe.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用作为*在应用程序中使用进程间通信*示例的一部分创建的应用程序的源代码作为本示例的起点。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will start with the source code that uses regular files
    for IPC. We will modify it to use an IPC mechanism called **named pipes**:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将从使用常规文件进行IPC的源代码开始。我们将修改它以使用一种名为**命名管道**的IPC机制：
- en: Copy the contents of the `ipc1` directory into a new directory called `ipc2`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ipc1`目录的内容复制到一个名为`ipc2`的新目录中。
- en: 'Open the `ipc1.cpp` file and add two more `include` instance after `#include
    <unistd.h>`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ipc1.cpp`文件，在`#include <unistd.h>`后添加两个`include`实例：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Modify the `Write` method of the `Writer` class by adding one more line:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`Writer`类的`Write`方法中添加一行来修改`Write`方法：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Modifications in the `Reader` class are more substantial. Both the constructor
    and the `Read` method are affected:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Reader`类中的修改更为重要。构造函数和`Read`方法都受到影响：'
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add a small change to the `DoWrites` function. The only difference is we add
    a 10 millisecond delay after sending each message:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`DoWrites`函数进行小的更改。唯一的区别是在发送每条消息后添加10毫秒的延迟：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, modify our `main` function to create a named pipe instead of a regular
    file:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，修改我们的`main`函数，创建一个命名管道而不是一个常规文件：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can now build and run the application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以构建和运行应用程序了。
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As you can see, we introduced a minimal number of changes to the code of our
    application. All the mechanisms and the API for reading and writing data remain
    the same. The crucial difference hides behind a single line of code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们对应用程序的代码进行了最少量的更改。所有读写数据的机制和API保持不变。关键的区别隐藏在一行代码后面：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This line creates a special type of file called `named pipe`. It looks like
    a regular file—it has a name, permission attributes, and a modification time.
    However, it does not store any real data. Everything written to this file is immediately
    delivered to the processes that read from this file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行创建了一种特殊类型的文件，称为`命名管道`。它看起来像一个常规文件——它有一个名称、权限属性和修改时间。但是，它不存储任何真实的数据。写入到该文件的所有内容都会立即传递给从该文件读取的进程。
- en: This difference has a number of consequences. Since no real data is stored in
    the file, all reading attempts are blocked until any data is  written. Similarly,
    writes are blocked until previous data is read by the readers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异有一系列后果。由于文件中没有存储任何真实数据，所有的读取尝试都会被阻塞，直到有数据被写入。同样，写入也会被阻塞，直到读取者读取了先前的数据。
- en: As a result, there is no further need for external data synchronization. Take
    a look at the `Reader` class implementation. It does not have a retry loop in
    the constructor or in the `Read` method.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不再需要外部数据同步。看一下`Reader`类的实现。它在构造函数或`Read`方法中都没有重试循环。
- en: 'To test that we really do not need to use any additional synchronization, we
    added an artificial delay after writing each of the messages:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们确实不需要使用任何额外的同步，我们在每条消息写入后添加了人为的延迟：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we build and run the application, we can see the following output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建和运行应用程序时，我们可以看到以下输出：
- en: '![](img/6f71e499-25db-4757-96ab-21a9a119babf.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f71e499-25db-4757-96ab-21a9a119babf.png)'
- en: Each `Write` method is followed by the proper `Read` method, despite the fact
    that we did not add any delays or checks anywhere in the `Reader` code. The IPC
    mechanisms of the operating system take care of data synchronization transparently
    for us, leading to cleaner and more readable code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Write`方法后面都跟着适当的`Read`方法，尽管我们在`Reader`代码中没有添加任何延迟或检查。操作系统的IPC机制会透明地为我们处理数据同步，从而使代码更清晰和可读。
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As you can see, working with named pipes is as simple as working with regular
    functions. A socket API is another widely used mechanism of IPC. It is a little
    bit more complex but provides more flexibility. By choosing different transport
    layers, developers can use the same socket APIs for both local data exchange and
    for network connectivity with remote hosts.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用命名管道与使用常规函数一样简单。套接字API是IPC的另一种广泛使用的机制。它稍微复杂一些，但提供了更多的灵活性。通过选择不同的传输层，开发人员可以使用相同的套接字API来进行本地数据交换和与远程主机的网络连接。
- en: More information about socket APIs can be found at [http://man7.org/linux/man-pages/man7/socket.7.html](http://man7.org/linux/man-pages/man7/socket.7.html.).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有关套接字API的更多信息，请访问[http://man7.org/linux/man-pages/man7/socket.7.html](http://man7.org/linux/man-pages/man7/socket.7.html)。
- en: Learning about message queue and publisher-subscriber models
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习消息队列和发布-订阅模型
- en: Most of the IPC mechanisms provided by POSIX operating systems are quite basic.
    Their APIs are built using file descriptors and they treat input and output channels
    as raw sequences of bytes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX操作系统提供的大多数IPC机制都非常基本。它们的API是使用文件描述符构建的，并且将输入和输出通道视为原始的字节序列。
- en: Applications, however, tend to use data fragments of specific lengths and purposes
    for data interchange messages. Despite API mechanisms of operating systems being
    flexible and generic, they are not always convenient for message exchange. That
    is why dedicated libraries and components were built on top of default IPC mechanisms
    to simplify the message exchange mode.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，应用程序往往使用特定长度和目的的数据片段进行数据交换消息。尽管操作系统的API机制灵活且通用，但并不总是方便进行消息交换。这就是为什么在默认IPC机制之上构建了专用库和组件，以简化消息交换模式。
- en: In this recipe, we will learn how to implement an asynchronous data exchange
    between two applications using the **publisher-subscriber** (**pub-sub**) model.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们将学习如何使用**发布者-订阅者**（pub-sub）模型在两个应用程序之间实现异步数据交换。
- en: The model is easy to understand and widely used for the development of software
    systems designed as collections of independent, loosely coupled components communicating
    with each other. The isolation of functions and asynchronous data exchange allows
    us to build flexible, scalable, and robust solutions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型易于理解，并且被广泛用于开发软件系统，这些系统被设计为相互独立、松散耦合的组件集合，它们之间进行通信。函数的隔离和异步数据交换使我们能够构建灵活、可扩展和健壮的解决方案。
- en: In the pub-sub model, applications act as publishers, subscribers, or both.
    Instead of sending requests to particular applications and expecting them to respond,
    an application can publish a message to a specific topic or subscribe to receive
    messages on a topic it is interested in. When publishing a message, the application
    does not care how many subscribers are listening to the topic. Similarly, a subscriber
    does not know which application is going to send a message on a particular topic
    or when to expect it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布-订阅模型中，应用程序可以充当发布者、订阅者或两者兼而有之。应用程序不需要向特定应用程序发送请求并期望它们做出响应，而是可以向特定主题发布消息或订阅接收感兴趣的主题上的消息。在发布消息时，应用程序不关心有多少订阅者正在监听该主题。同样，订阅者不知道哪个应用程序将在特定主题上发送消息，或者何时期望收到消息。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作方法...
- en: The application we created as part of the *Exploring the mechanisms of IPC* recipe
    already contains a number of building blocks we can reuse to implement the pub/sub
    communication.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*探索IPC机制*配方中创建的应用程序已经包含了许多我们可以重用的构建模块，以实现发布/订阅通信。
- en: The `Writer` class can act as a publisher and the `Reader` class as a subscriber.
    We implemented them to handle the strictly defined data types that will define
    our messages. The named pipes mechanism we used in the preceding recipe works
    on a byte level and does not guarantee that messages are delivered automatically.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`Writer`类可以充当发布者，`Reader`类可以充当订阅者。我们实现它们来处理严格定义的数据类型，这些数据类型将定义我们的消息。我们在前面的示例中使用的命名管道机制是在字节级别上工作的，并不能保证消息会自动传递。'
- en: 'To overcome this limitation, we will use the POSIX message queue API instead
    of the named pipes. A name used to identify a message queue that both `Reader`
    and `Writer` will accept in their constructors will be used as a topic:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一限制，我们将使用POSIX消息队列API，而不是命名管道。在它们的构造函数中，`Reader`和`Writer`都将接受用于标识消息队列的名称作为主题：
- en: Copy the contents of the `ipc2` directory that we created in the previous recipe
    into a new directory: `ipc3`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们在上一篇文章中创建的`ipc2`目录的内容复制到一个新目录：`ipc3`。
- en: 'Let''s create a C++ wrapper for the POSIX message queue API. Open `ipc1.cpp` in
    your editor and add the required header files and constant definition:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为POSIX消息队列API创建一个C++包装器。在编辑器中打开`ipc1.cpp`并添加所需的头文件和常量定义：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, define a `MessageQueue` class. This holds a message queue handle as its
    private data member. We can use constructors and destructors to manage the opening
    and closing of the handle in a safe manner using the C++ RAII idiom:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，定义一个`MessageQueue`类。它将一个消息队列句柄作为其私有数据成员。我们可以使用构造函数和析构函数来管理句柄的安全打开和关闭，使用C++
    RAII习惯用法。
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we define two simple methods to write messages into and read messages
    from the queue:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义两个简单的方法来将消息写入队列和从队列中读取消息：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We now modify our `Writer` and `Reader` classes to work with the new API. Our
    `MessageQueue` wrapper does most of the heavy lifting and the code changes are
    minimal. The `Writer` class now looks like this:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在修改我们的`Writer`和`Reader`类，以适应新的API。我们的`MessageQueue`包装器完成了大部分繁重的工作，代码更改很小。`Writer`类现在看起来像这样：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Modifications in the `Reader` class are more substantial. We make it act as
    a subscriber and we encapsulate the logic that fetches and handles messages from
    the queue directly into the class:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Reader`类中的修改更加实质性。我们让它充当订阅者，并将直接从队列中获取和处理消息的逻辑封装到类中：'
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since we still want to keep the `Reader` class as generic as possible, we will
    define a new class (`CoordLogger`), which is derived from `Reader`, to define
    the specific handling of our messages:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们仍然希望尽可能地保持`Reader`类的通用性，我们将定义一个新的类（`CoordLogger`），它是从`Reader`派生出来的，用于定义我们消息的特定处理方式：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `DoWrites` code remains mostly the same; the only change is that we use
    a different constant to identify our queue:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DoWrites`代码基本保持不变；唯一的变化是我们使用不同的常量来标识我们的队列：'
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Since the message handling logic was moved to the `Reader` and `CoordLogger`
    classes, `DoReads` is now as simple as this:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于消息处理逻辑已经移动到`Reader`和`CoordLogger`类中，`DoReads`现在就像这样简单：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The updated `main` function follows:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新后的`main`函数如下：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, our application needs to be linked with the `rt` library. We do this
    by adding one line into our `CMakeLists.txt` file:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的应用程序需要链接`rt`库。我们通过在`CMakeLists.txt`文件中添加一行来实现这一点：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can now build and run the application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以构建和运行应用程序了。
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In our application, we reused a lot of the code from the application we created
    in the preceding recipe, *Exploring the mechanisms of IPC*. To implement the pub-sub
    model, we need to make two important changes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们重用了前面一篇文章中创建的应用程序的大部分代码，*探索IPC机制*。为了实现发布-订阅模型，我们需要进行两个重要的更改：
- en: Make our IPC message-based. We should be able to send and receive messages automatically.
    Messages sent by one publisher should not break messages sent by other publishers
    and subscribers should be able to read messages as a whole.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们的IPC基于消息。我们应该能够自动发送和接收消息。一个发布者发送的消息不应该破坏其他发布者发送的消息，订阅者应该能够整体读取消息。
- en: Let subscribers define the callbacks that are invoked as soon as a new message
    is available.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让订阅者定义在新消息可用时调用的回调。
- en: To make message-based communication, we switch from the named pipes to the POSIX
    message queue API. The message queue API differs from the regular file-based API
    of named pipes, which is why we implement a C++ wrapper on top of the plain C
    interface provided by the Linux standard library.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行基于消息的通信，我们从命名管道切换到了POSIX消息队列API。消息队列API与命名管道的常规基于文件的API不同，这就是为什么我们在Linux标准库提供的纯C接口之上实现了一个C++包装器。
- en: The main goal of the wrapper is to provide safe resource management using the **Resource
    Acquisition Is Initialization** (**RAII**) idiom. We do this by defining the constructors
    that acquire the queue handler by calling `mq_open` and the destructor that releases
    it using `mq_close`. This way, the queue is automatically closed when the corresponding
    instance of the `MessageQueue` class is destroyed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器的主要目标是使用**资源获取即初始化**（**RAII**）习语提供安全的资源管理。我们通过定义通过调用`mq_open`获取队列处理程序的构造函数和使用`mq_close`释放它的析构函数来实现这一点。这样，当`MessageQueue`类的相应实例被销毁时，队列会自动关闭。
- en: The wrapper class has two constructors. One constructor is used to open an existing
    queue. It accepts two parameters—a queue name and access flags. The second constructor
    is used to create a new queue. It accepts two additional parameters—a message
    length and the maximal size of a message in the queue.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器类有两个构造函数。一个构造函数用于打开现有队列。它接受两个参数——队列名称和访问标志。第二个构造函数用于创建一个新队列。它接受两个额外的参数——消息长度和队列中消息的最大大小。
- en: 'In our application, we create a queue in the `main` function, passing `10`
    as the number of messages that can be stored in the queue. The size of the `Message` structure is
    the maximum size of the message in our queue:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们在`main`函数中创建一个队列，将`10`作为可以存储在队列中的消息数量。`Message`结构的大小是我们队列中消息的最大大小：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then, the `DoWrites` and `DoReads` functions open the queue already created
    with the same name.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`DoWrites`和`DoReads`函数打开了已经使用相同名称创建的队列。
- en: Since the public API for our `MessageQueue` class is similar to the `fstream`
    interface we used for IPC using named pipes, it requires only minimal changes
    in the writer and reader to make them work with another IPC mechanism. We use
    an instance of `MessageQueue` instead of `fstream` as a data member, keeping other
    logic unchanged.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`MessageQueue`类的公共API类似于我们用于使用命名管道进行IPC的`fstream`接口，因此只需要对写入器和读取器进行最小的更改，使它们能够与另一种IPC机制一起工作。我们使用`MessageQueue`的实例而不是`fstream`作为数据成员，保持其他逻辑不变。
- en: 'To let subscribers define their callback methods, we need to modify the `Reader`
    class. Instead of a `Read` method that reads and returns a single method, we introduce
    the `Run` method. It loops over all the messages available in the queue. For each
    method being read, it invokes a callback method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让订阅者定义他们的回调方法，我们需要修改`Reader`类。我们引入了`Run`方法，而不是读取并返回单个方法的`Read`方法。它循环遍历队列中所有可用的消息。对于每个被读取的方法，它调用一个回调方法：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Our goal is to keep the `Reader` class generic and reusable for different types
    of messages. However, there is no such thing as a generic callback. Each callback
    is specific and should be defined by users of the `Reader` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是使`Reader`类通用且可重用于不同类型的消息。然而，并不存在通用的回调。每个回调都是特定的，应该由`Reader`类的用户定义。
- en: 'One way to resolve this contradiction is by making `Reader` an abstract class.
    We define our `Callback` method as a `virtual` function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个矛盾的一种方法是将`Reader`定义为抽象类。我们将`Callback`方法定义为`virtual`函数：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, since `Reader` is abstract, we cannot create instances of this class.
    We have to inherit it and provide a definition of the `Callback` method in a derived
    class named `CoordLogger`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于`Reader`是抽象的，我们无法创建这个类的实例。我们必须继承它，并在一个名为`CoordLogger`的派生类中提供`Callback`方法的定义：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Please note that since the `Reader` constructor accepts a parameter, we need
    to define constructors in the inherited class as well. We''ll use the inheriting
    constructors that were added in the C++11 standard:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于`Reader`构造函数接受一个参数，我们需要在继承类中定义构造函数。我们将使用C++11标准中添加的继承构造函数：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, having a `CoordLogger` class that is capable of handling the messages
    of the `Message` type, we can use it in our `DoReads` implementation. We only
    need to create an instance of this class and invoke its `Run` method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了一个能够处理`Message`类型消息的`CoordLogger`类，我们可以在我们的`DoReads`实现中使用它。我们只需要创建这个类的一个实例并调用它的`Run`方法：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When we run the application, we get the following output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，我们会得到以下输出：
- en: '![](img/39b06101-cfed-4a08-9bdd-53fe51e643b6.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39b06101-cfed-4a08-9bdd-53fe51e643b6.png)'
- en: This output is not that different from the output from the preceding recipe,
    but now the implementation is much more scalable. The `DoReads` method does not
    do anything specific to messages. Its only task is to create and run subscribers.
    All data handling is encapsulated in specific classes. You can add, replace, and
    combine publishers and subscribers without changing the architecture of the application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出与前面的输出并没有太大的不同，但现在实现的可扩展性更强了。`DoReads`方法并没有针对消息做任何特定的操作。它的唯一任务是创建和运行订阅者。所有数据处理都封装在特定的类中。您可以在不改变应用程序架构的情况下添加、替换和组合发布者和订阅者。
- en: There's more...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The POSIX message queue API provides basic functionality for message queues
    but it also has a number of limitations. It is not possible to send a message
    to multiple subscribers using one message queue. You have to create a separate
    queue for each subscriber, otherwise only one of the subscribers reading from
    a queue will receive the message.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX消息队列API提供了消息队列的基本功能，但它也有许多限制。使用一个消息队列无法向多个订阅者发送消息。您必须为每个订阅者创建一个单独的队列，否则只有一个订阅者从队列中读取消息。
- en: There are a number of elaborated message queues and pub-sub middleware available
    in the form of external libraries. ZeroMQ is a powerful, flexible and—at the same
    time—lightweight transport library. This makes it an ideal choice for embedded
    applications that are built using the pub-sub model of data exchange.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多详细的消息队列和发布-订阅中间件可用作外部库。ZeroMQ是一个功能强大、灵活且轻量级的传输库。这使它成为使用数据交换的发布-订阅模型构建的嵌入式应用程序的理想选择。
- en: Using C++ lambdas for callbacks
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C++ lambda进行回调
- en: In the pub-sub model, a subscriber usually registers a callback that is being
    invoked when a message from a publisher is delivered to the subscriber.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布-订阅模型中，订阅者通常注册一个回调，当发布者的消息传递给订阅者时会被调用。
- en: In the preceding recipe, we created a mechanism to register callbacks using
    inheritance and abstract classes. It is not the only mechanism available in C++. Lambda
    functions available in C++, starting from the C++11 standard, can be used as an
    alternative solution. This eliminates lots of boilerplate code needed to define
    derived classes and, in most cases, allows developers to express their intent
    in a clearer way.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个使用继承和抽象类注册回调的机制。这不是C++中唯一可用的机制。C++中提供的lambda函数，从C++11标准开始，可以作为替代解决方案。这消除了定义派生类所需的大量样板代码，并且在大多数情况下，允许开发人员以更清晰的方式表达他们的意图。
- en: In this recipe, we will learn how to use C++ lambda functions to define callbacks.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用C++ lambda函数来定义回调。
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are going to use most of the code from the preceding recipe, *Learning about
    message queue and publisher-subscriber models*. We will modify the `Reader` class
    to accept a callback as a parameter. With this modification, we can use `Reader`
    directly and do not need to rely on inheritance to define a callback:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用前面示例中大部分代码，*学习消息队列和发布-订阅模型*。我们将修改`Reader`类以接受回调作为参数。通过这种修改，我们可以直接使用`Reader`，而不需要依赖继承来定义回调：
- en: Copy the contents of the `ipc3` directory that we created in the preceding recipe
    into a new directory: `ipc4`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们在前面示例中创建的`ipc3`目录的内容复制到一个新目录`ipc4`中。
- en: 'Keep all the code unchanged, except for the `Reader` class. Let''s replace
    that with the following code snippet:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持所有代码不变，除了`Reader`类。让我们用以下代码片段替换它：
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that our `Reader` class is changed, we can update the `DoReads` method.
    We can use a lambda function to define a callback handler and pass it to the `Reader` constructor:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的`Reader`类已经改变，我们可以更新`DoReads`方法。我们可以使用lambda函数来定义一个回调处理程序，并将其传递给`Reader`的构造函数：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `CoordLogger` class is not needed anymore, so we can safely remove it from
    our code entirely.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CoordLogger`类不再需要，因此我们可以完全从我们的代码中安全地删除它。'
- en: You can build and run the application.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以构建和运行应用程序。
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we modified the preceding defined `Reader` class to accept
    an additional parameter in its constructor. This parameter has a specific data
    type—a pointer to a function, which will be used as a callback:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们修改了之前定义的`Reader`类，以接受其构造函数中的额外参数。这个参数有一个特定的数据类型——一个指向函数的指针，它将被用作回调：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The handler is stored in the data field for future use:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序存储在数据字段中以供将来使用：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, every time the `Run` method reads a message, it invokes the function stored
    in the `func` field, rather than the `Callback` method that we need to override:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当`Run`方法读取消息时，它会调用存储在`func`字段中的函数，而不是我们需要重写的`Callback`方法：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Getting rid of the `Callback` function makes `Reader` a concrete class and we
    can create its instance directly. However, now we need to provide a handler as
    a parameter of its constructor.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Callback`函数去掉使`Reader`成为一个具体的类，我们可以直接创建它的实例。然而，现在我们需要在它的构造函数中提供一个处理程序作为参数。
- en: With plain C, we would have to define a `named` function and pass its name as
    a parameter. With C++, this approach is also possible, but C++ also provides the
    mechanism of anonymous functions or lambda functions, which can be defined right
    in-place.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯C，我们必须定义一个`named`函数并将其名称作为参数传递。在C++中，这种方法也是可能的，但C++还提供了匿名函数或lambda函数的机制，可以直接在现场定义。
- en: 'In the `DoReads` method, we create a lambda function and pass it directly to
    the `Reader` constructor:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DoReads`方法中，我们创建一个lambda函数，并直接将其传递给`Reader`的构造函数：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Building and running the application produces the following output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行应用程序会产生以下输出：
- en: '![](img/6c9b5c11-a5ea-4454-8e09-6d3b1ff2e1cd.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c9b5c11-a5ea-4454-8e09-6d3b1ff2e1cd.png)'
- en: As we can see, it is identical to the output of the application we created in
    the preceding recipe. However, we do it with less code and in a more readable
    way.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，它与我们在前面的示例中创建的应用程序的输出相同。然而，我们用更少的代码以更可读的方式实现了它。
- en: Lambda functions should be used wisely. They make the code more readable if
    kept minimal. If a function grows bigger than five lines, consider using a named
    function instead.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数应该明智地使用。如果保持最小，它们会使代码更易读。如果一个函数变得比五行更长，请考虑使用命名函数。
- en: There's more...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++ provides flexible mechanisms for working with function-like objects and
    binds them with parameters. These mechanisms are widely used to forward calls
    and build function adapters. The *Function objects* page at [https://en.cppreference.com/w/cpp/utility/functional](https://en.cppreference.com/w/cpp/utility/functional) is
    a good starting point to get a deeper understanding of these topics.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了灵活的机制来处理类似函数的对象，并将它们与参数绑定在一起。这些机制被广泛用于转发调用和构建函数适配器。[https://en.cppreference.com/w/cpp/utility/functional](https://en.cppreference.com/w/cpp/utility/functional)上的*函数对象*页面是深入了解这些主题的好起点。
- en: Exploring data serialization
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索数据序列化
- en: We already briefly touched on some aspects of serialization in [Chapter 3](b89bff48-21be-4288-af10-de42f182d426.xhtml), *Working
    with Different Architectures*. When it comes to data exchange, serialization is
    crucial. The task of serialization is to represent all data being sent by the
    sender application in a way that can be unambiguously read by the receiver application.
    This task is not that straightforward, given that the sender and the receiver
    may be running on different hardware platforms and connected over a variety of
    transport links—a **Transmission Control Protocol**/**Internet Protocol** (**TCP/IP**) network,
    a **Serial Peripheral Interface** (**SPI**) bus, or a serial link.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第3章](b89bff48-21be-4288-af10-de42f182d426.xhtml) *使用不同的架构*中简要涉及了序列化的一些方面。在数据交换方面，序列化是至关重要的。序列化的任务是以一种可以被接收应用程序明确读取的方式表示发送应用程序发送的所有数据。鉴于发送方和接收方可能在不同的硬件平台上运行，并通过各种传输链路连接
    - **传输控制协议**/**互联网协议**（**TCP/IP**）网络，**串行外围接口**（**SPI**）总线或串行链路，这个任务并不那么简单。
- en: There are many different ways of implementing serialization depending on requirements,
    which is why the C++ standard library does not provide it out of the box.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 根据要求实现序列化的方式有很多种，这就是为什么C++标准库没有提供序列化的原因。
- en: In this recipe, we will learn how to implement simple generic serialization
    and deserialization in a C++ application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在C++应用程序中实现简单的通用序列化和反序列化。
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The goal of serialization is to encode any data in a way that can be properly
    decoded on another system or in another application. The typical obstacles for
    developers are as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化的目标是以一种可以在另一个系统或另一个应用程序中正确解码的方式对任何数据进行编码。开发人员通常面临的典型障碍如下：
- en: Platform-specific differences, such as data alignment and endianness.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台特定的差异，如数据对齐和字节顺序。
- en: Data scattered across memory; for example, elements of a linked list can be
    located far away from each other. The representation of disconnected blocks linked
    by pointers is natural for memory but cannot be automatically translated into
    a sequence of bytes when transferring it to another process.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存中分散的数据；例如，链表的元素可能相距甚远。由指针连接的断开块的表示对于内存是自然的，但在传输到另一个进程时，无法自动转换为字节序列。
- en: A generic approach to this problem is letting a class define the functions to
    convert its content into a serialized form and restore an instance of a class
    from the serialized form.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的通用方法是让一个类定义将其内容转换为序列化形式并从序列化形式中恢复类实例的函数。
- en: 'In our application, we will overload `operator<<` of the output stream and `operator>>`
    of the input stream to serialize and deserialize data respectively:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将重载输出流的`operator<<`和输入流的`operator>>`，分别用于序列化和反序列化数据：
- en: In your `~/test` working directory, create a subdirectory called `stream`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`~/test`工作目录中，创建一个名为`stream`的子目录。
- en: Use your favorite text editor to create a `stream.cpp` file in the `stream` subdirectory.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您喜欢的文本编辑器在`stream`子目录中创建一个`stream.cpp`文件。
- en: 'Start with the definition of the data structures that you want to serialize:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从定义要序列化的数据结构开始：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we overload the `<<` and `>>` operators that are responsible for writing
    and reading the `Point` objects into and from a stream respectively. For the `Point`
    data type enter the following:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们重载`<<`和`>>`运算符，负责将`Point`对象分别写入和从流中读取。对于`Point`数据类型，输入以下内容：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'They are followed by the `<<` and `>>` overloaded operators for the `Paths`
    objects:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们后面是`Paths`对象的`<<`和`>>`重载运算符：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, let''s wrap everything up in the `main` function:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`main`函数中总结一切：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, create a `CMakeLists.txt` file containing the build rules for our
    program:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个包含程序构建规则的`CMakeLists.txt`文件：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can now build and run the application.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以构建和运行应用程序了。
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In our test application, we defined a data type to represent paths from a source
    point to multiple destination points. We intentionally used hierarchical structures
    scattered in memory to demonstrate how to approach this problem in a generic way.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试应用程序中，我们定义了一种数据类型，用于表示从源点到多个目标点的路径。我们故意使用了分散在内存中的分层结构，以演示如何以通用方式解决这个问题。
- en: 'If we do not have specific requirements for performance, one of the possible
    approaches to serialization is storing data in text format. Besides its simplicity,
    it has two major advantages:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对性能没有特定要求，序列化的一种可能方法是以文本格式存储数据。除了它的简单性外，它还有两个主要优点：
- en: Text encoding automatically resolves all issues related to endianness, alignment,
    and the size of integer data types.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编码自动解决了与字节顺序、对齐和整数数据类型大小相关的所有问题。
- en: It is readable by humans. Developers can use serialized data for debugging without
    any additional tools.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可供人类阅读。开发人员可以使用序列化数据进行调试，而无需任何额外的工具。
- en: To work with text representation, we can use the input and output streams provided
    by the standard library. They already define functions to write and read formatted
    numbers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用文本表示，我们可以使用标准库提供的输入和输出流。它们已经定义了写入和读取格式化数字的函数。
- en: The `Point` structure is defined as two integer values: `x` and `y`. We override
    `operator<<` for this data type to write the `x` and `y` values followed by spaces.
    This way, we can read them sequentially in the overridden `operator>>` operation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point`结构被定义为两个整数值：`x`和`y`。我们重写了这种数据类型的`operator<<`，以便写入`x`和`y`值，后面跟着空格。这样，我们可以在重写的`operator>>`操作中按顺序读取它们。'
- en: 'The `Path` data type is a bit trickier. It contains a linked list of destinations.
    Since the size of the list may vary, we need to write the actual size of the list
    before serializing its content to be able to recover it properly during deserialization:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`数据类型有点棘手。它包含一个目的地的链表。由于列表的大小可能会变化，我们需要在序列化其内容之前写入列表的实际大小，以便在反序列化期间能够正确恢复它：'
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Since we have the `Point` methods for the `<<` and `>>`  operators already
    overridden, we can use them in the `Paths` methods. This way, we write the `Point`
    objects to a stream or read them from a stream without knowing the contents of
    their data fields. Hierarchical data structures are handled recursively:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经重写了`Point`方法的`<<`和`>>`操作符，我们可以在`Paths`方法中使用它们。这样，我们可以将`Point`对象写入流或从流中读取，而不知道它们的数据字段的内容。层次化数据结构被递归处理：
- en: '[PRE52]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we test our implementation of serialization and deserialization. We
    create a sample instance of the `Paths` object:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们测试我们的序列化和反序列化实现。我们创建一个`Paths`对象的示例实例：
- en: '[PRE53]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, we serialize its content into a string using the `std::stringstream`
    data type:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`std::stringstream`数据类型将其内容序列化为字符串：
- en: '[PRE54]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, we create an empty `Path` object and deserialize the content of the string
    into it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个空的`Path`对象，并将字符串的内容反序列化到其中：
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we check whether they match. When we run the application, we can use
    the following output to do this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查它们是否匹配。当我们运行应用程序时，我们可以使用以下输出来进行检查：
- en: '![](img/f862eddd-5a3d-4234-8b4b-7edb0bf4c0ac.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f862eddd-5a3d-4234-8b4b-7edb0bf4c0ac.png)'
- en: The size of the `destinations` list of the restored object matches the size
    of the `destinations` list of the original object. We can also see the content
    of the serialized data.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复对象的`destinations`列表的大小与原始对象的`destinations`列表的大小相匹配。我们还可以看到序列化数据的内容。
- en: This example shows how to build custom serialization for any data type. It can
    be done without any external libraries. However, in cases where performance and
    memory efficiency matter, using third-party serialization libraries would be a
    more practical approach.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何为任何数据类型构建自定义序列化。可以在没有任何外部库的情况下完成。然而，在性能和内存效率要求的情况下，使用第三方序列化库将是更实用的方法。
- en: There's more...
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Implementing serialization from scratch is difficult. The cereal library at [https://uscilab.github.io/cereal/](https://uscilab.github.io/cereal/) and
    the boost library at [https://www.boost.org/doc/libs/1_71_0/libs/serialization/doc/index.html](https://www.boost.org/doc/libs/1_71_0/libs/serialization/doc/index.html)
    provide a foundation that helps you to add serialization to applications much
    faster and more easily.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始实现序列化是困难的。cereal库在[https://uscilab.github.io/cereal/](https://uscilab.github.io/cereal/)和boost库在[https://www.boost.org/doc/libs/1_71_0/libs/serialization/doc/index.html](https://www.boost.org/doc/libs/1_71_0/libs/serialization/doc/index.html)提供了一个基础，可以帮助您更快速、更容易地向应用程序添加序列化。
- en: Using the FlatBuffers library
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FlatBuffers库
- en: Serialization and deserialization is a complex topic. While ad hoc serialization
    may look simple and straightforward, it is difficult to make it generic, easy
    to use, and fast. Thankfully, there are libraries that handle all of these complexities.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化和反序列化是一个复杂的主题。虽然临时序列化看起来简单直接，但要使其通用、易于使用和快速是困难的。幸运的是，有一些库处理了所有这些复杂性。
- en: 'In this recipe, we will learn how to use one of the serialization libraries:
    FlatBuffers. It was designed with embedded programming in mind, making serialization
    and deserialization memory efficient and fast.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用其中一个序列化库：FlatBuffers。它是专为嵌入式编程设计的，使序列化和反序列化内存高效且快速。
- en: FlatBuffers uses an **Interface Definition Language** (**IDL**) to define a
    data schema. The schema describes all the fields of data structures that we need
    to serialize. When the schema is designed, we use a special tool called **flatc**
    to generate the code for a particular programming language, which is C++ in our
    case.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: FlatBuffers使用**接口定义语言**（**IDL**）来定义数据模式。该模式描述了我们需要序列化的数据结构的所有字段。当设计模式时，我们使用一个名为**flatc**的特殊工具来为特定的编程语言生成代码，这在我们的情况下是C++。
- en: The generated code stores all data in serialized form and provides developers
    with so-called **getter** and **setter** methods to access the data fields. The
    getters perform deserialization on the fly. Storing data in its serialized form
    makes FlatBuffers really memory efficient. There is no need for extra memory to
    store serialized data and, in most cases, the overhead of deserialization is low.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的代码以序列化形式存储所有数据，并为开发人员提供所谓的**getter**和**setter**方法来访问数据字段。getter在使用时执行反序列化。将数据存储在序列化形式中使得FlatBuffers真正的内存高效。不需要额外的内存来存储序列化数据，并且在大多数情况下，反序列化的开销很低。
- en: In this recipe, we will learn how to start using FlatBuffers for data serialization
    in our applications.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在我们的应用程序中开始使用FlatBuffers进行数据序列化。
- en: How to do it...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'FlatBuffers is a set of tools and libraries. Before using it, we need to download
    and build it:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: FlatBuffers是一组工具和库。在使用之前，我们需要下载并构建它：
- en: Download the most recent archive of FlatBuffers, available at [https://codeload.github.com/google/flatbuffers/zip/master](https://codeload.github.com/google/flatbuffers/zip/master),
    and extract it in the `test` directory. This will create a new directory called
    `flatbuffers-master`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载最新的FlatBuffers存档，可在[https://codeload.github.com/google/flatbuffers/zip/master](https://codeload.github.com/google/flatbuffers/zip/master)下载，并将其提取到`test`目录中。这将创建一个名为`flatbuffers-master`的新目录。
- en: 'Switch to the build console, change the directory to `flatbuffers-master`,
    and run the following commands to build and install the library and tools. Make
    sure you run as root. If not, press *Ctrl* + *C* to exit the user shell:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到构建控制台，将目录更改为`flatbuffers-master`，并运行以下命令来构建和安装库和工具。确保以root用户身份运行。如果没有，请按*Ctrl*
    + *C*退出用户shell：
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we are ready to use FlatBuffers in our application. Let''s reuse an application
    we created in one of the previous recipes:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备在我们的应用程序中使用FlatBuffers。让我们重用我们在以前的配方中创建的应用程序：
- en: Copy the contents of the `ipc4` directory into the newly created directory named
    `flat`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ipc4`目录的内容复制到新创建的名为`flat`的目录中。
- en: 'Create a file named `message.fbs`, open it in an editor, and put in the following
    code:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`message.fbs`的文件，打开它并输入以下代码：
- en: '[PRE57]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Generate the C++ source code from `message.fbs` by running the following:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`message.fbs`生成C++源代码，运行以下命令：
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This will create a new file called `message_generated.h`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`message_generated.h`的新文件。
- en: 'Open `ipc1.cpp` in your editor. Add an `include` directive for the generated `message_generated.h`
    file after the `mqueue.h` include:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开`ipc1.cpp`。在`mqueue.h`包含之后，添加一个`include`指令用于生成的`message_generated.h`文件：
- en: '[PRE59]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, get rid of the `Message` struct declared in our code. We are going to use
    the structure generated in the FlatBuffers schema file instead.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，摆脱我们代码中声明的`Message`结构。我们将使用FlatBuffers模式文件中生成的结构。
- en: 'Since FlatBuffers uses getter methods instead of direct access to the structure
    fields, we need to modify the body of the redefined `operator<<` operation we
    used to print point data to the console. The changes are minimal—we only add parentheses
    to each data field:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于FlatBuffers使用getter方法而不是直接访问结构字段，我们需要修改我们重新定义的`operator<<`操作的主体，用于将点数据打印到控制台。更改很小——我们只是为每个数据字段添加括号：
- en: '[PRE60]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The code modifications are done. Now, we need to update the build rules to
    link with the FlatBuffers library. Open `CMakeLists.txt` and put in the following
    lines:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码修改已完成。现在，我们需要更新构建规则以链接FlatBuffers库。打开`CMakeLists.txt`，并输入以下行：
- en: '[PRE61]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Switch to the build console, then change to the user shell:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到构建控制台，然后切换到用户shell：
- en: '[PRE62]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Build and run the application.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。
- en: How it works...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: FlatBuffers is an external library that is not available in the Ubuntu repository
    of packages, which is why we need to download, build, and install it first. After
    the installation is done, we can use it in our application.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: FlatBuffers是一个外部库，不在Ubuntu软件包存储库中，因此我们需要先下载、构建和安装它。安装完成后，我们可以在我们的应用程序中使用它。
- en: We use an existing application we created for the *Using C++ lambdas for callbacks* recipe
    as a starting point. In that application, we defined a structure, called `Message`,
    to represent a type of data we use for IPC. We are going to replace it with a
    new data type provided by FlatBuffers. This new data type will perform all the
    necessary serialization and deserialization transparently for us.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了我们为*使用C++ lambda进行回调*配方创建的现有应用程序作为起点。在该应用程序中，我们定义了一个名为`Message`的结构，用于表示我们用于IPC的数据类型。我们将用FlatBuffers提供的新数据类型替换它。这种新数据类型将为我们执行所有必要的序列化和反序列化。
- en: 'We remove the definition of the `Message` struct from our code completely.
    Instead, we generate a new header file, called `message_generated.h`. This file
    is generated from the `message.fbs` FlatBuffers schema file. This schema file
    defines a structure with two integer fields—`x` and `y`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完全从我们的代码中删除了`Message`结构的定义。相反，我们生成了一个名为`message_generated.h`的新头文件。这个文件是从`message.fbs`的FlatBuffers模式文件生成的。这个模式文件定义了一个具有两个整数字段`x`和`y`的结构：
- en: '[PRE63]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This definition is identical to our preceding definition; the only difference
    is the syntax—FlatBuffers' schema uses a colon to separate field names from the
    field types.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义与我们之前的定义相同；唯一的区别是语法——FlatBuffers的模式使用冒号将字段名与字段类型分隔开。
- en: 'Once `message_generated.h` is created by the `flatc` command invocation, we
    can use it in our code. We add the proper `include` as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`message_generated.h`由`flatc`命令调用创建，我们就可以在我们的代码中使用它。我们添加适当的`include`如下：
- en: '[PRE64]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The generated message is identical to the message structure we used before but
    as we discussed earlier, FlatBuffers stores data in serialized form and needs
    to deserialize it on the fly. That is why, instead of direct access to the data
    fields, we have to use the `x()` accessor method instead of just `x` and the `y()` accessor
    method instead of just `y`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的消息与我们之前使用的消息结构相同，但正如我们之前讨论的，FlatBuffers以序列化形式存储数据，并且需要在运行时对其进行反序列化。这就是为什么，我们不直接访问数据字段，而是使用`x()`访问器方法而不是只是`x`，以及`y()`访问器方法而不只是`y`。
- en: 'The only place we use direct access to the message data field is in the overridden
    `operator<<` operation. We add parentheses to turn direct field access into the
    invocation of the FlatBuffers getter methods:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一使用直接访问消息数据字段的地方是在重写的`operator<<`操作中。我们添加括号将直接字段访问转换为调用FlatBuffers的getter方法：
- en: '[PRE65]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s build and run the application. We will see the following output:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并运行应用程序。我们将看到以下输出：
- en: '![](img/96e44321-cffb-4c7f-9989-b51539a077ff.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96e44321-cffb-4c7f-9989-b51539a077ff.png)'
- en: The output is the same as for our custom message data type. With only a few
    modifications in our code, we migrated our messages to FlatBuffers. Now, we can
    run our publishers and subscribers on multiple computers—which can have different
    architectures—and be sure that each of them interprets messages correctly.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与我们自定义消息数据类型的输出相同。在我们的代码中只进行了少量修改，我们就将我们的消息迁移到了FlatBuffers。现在，我们可以在多台计算机上运行我们的发布者和订阅者——这些计算机可以具有不同的架构，并确保它们每个都正确解释消息。
- en: There's more...
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Besides FlatBuffers, there are a number of other serialization libraries and
    techniques, each having its own pros and cons. Refer to the *C++ Serialization
    FAQ* at [https://isocpp.org/wiki/faq/serialization](https://isocpp.org/wiki/faq/serialization)
    for a better understanding of how to design serialization in your applications.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 除了FlatBuffers之外，还有许多其他序列化库和技术，每种都有其优缺点。请参考[C++序列化FAQ](https://isocpp.org/wiki/faq/serialization)以更好地了解如何在您的应用程序中设计序列化。
