- en: Chapter 5. Handling Events and Delegates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。处理事件和委托
- en: Unreal uses events for notifying classes about things that happen in the game
    world in an efficient manner. Events and delegates are useful to ensure that these
    notifications can be issued in a way which minimizes class coupling, and allows
    arbitrary classes to subscribe to be notified.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal使用事件有效地通知类有关游戏世界中发生的事情。事件和委托对于确保可以以最小化类耦合的方式发出这些通知以及允许任意类订阅以接收通知非常有用。
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中将介绍以下教程：
- en: Handling events implemented via virtual functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过虚函数实现事件处理
- en: Creating a delegate that is bound to a UFUNCTION
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个绑定到UFUNCTION的委托
- en: Unregistering a delegate
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消注册委托
- en: Creating a delegate that takes input parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个带有输入参数的委托
- en: Passing payload data with a delegate binding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用委托绑定传递有效负载数据
- en: Creating a multicast delegate
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个多播委托
- en: Creating a custom Event
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个自定义事件
- en: Creating a Time of Day handler
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个时间处理程序
- en: Creating a respawning pickup for an First Person Shooter
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为第一人称射击游戏创建一个重生拾取物
- en: Handling events implemented via virtual functions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过虚函数实现事件处理
- en: Some `Actor` and `Component` classes provided with Unreal include event handlers
    in the form of virtual functions. This recipe will show you how to customize those
    handlers by overriding the virtual function in question.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal提供的一些`Actor`和`Component`类包括以虚函数形式的事件处理程序。本教程将向您展示如何通过覆盖相关的虚函数来自定义这些处理程序。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Create an empty `Actor` in the Editor. Call it `MyTriggerVolume`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中创建一个空的`Actor`。将其命名为`MyTriggerVolume`。
- en: 'Add the following code to the class header:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类头文件中：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the implementation for the preceding functions to the cpp file:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将前述函数的实现添加到cpp文件中：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compile your project, and place an instance of `MyTriggerActor` into the level.
    Verify that overlap/touch events are handled by walking into the volume, and seeing
    the output printed to the screen:![How to do it...](img/00092.jpeg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的项目，并将`MyTriggerActor`的一个实例放入级别中。通过走进体积并查看屏幕上打印的输出来验证重叠/触摸事件是否已处理：![操作步骤...](img/00092.jpeg)
- en: How it works...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As always, we first declare a `UPROPERTY` to hold a reference to our component
    subobject. We then create two `UFUNCTION` declarations. These are marked as `virtual`
    and `override` so that the compiler understands we want to replace the parent
    implementation, and that our function implementations can be replaced in turn.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与往常一样，我们首先声明一个`UPROPERTY`来保存对我们组件子对象的引用。然后创建两个`UFUNCTION`声明。这些标记为`virtual`和`override`，以便编译器理解我们要替换父类的实现，并且我们的函数实现可以被替换。
- en: In the implementation of the functions, we use `FString::printf` to create an
    `FString` from some preset text, and substitute some data parameters.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数的实现中，我们使用`FString::printf`从预设文本创建一个`FString`，并替换一些数据参数。
- en: Note that the `FString` `OtherActor->GetName()` returns, and is dereferenced
    using the `*` operator before being passed into `FString::Format`. Not doing this
    results in an error.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，`FString` `OtherActor->GetName()`返回，并在传递给`FString::Format`之前使用`*`运算符进行解引用。不这样做会导致错误。
- en: This `FString` is then passed to a global engine function, `AddOnScreenDebugMessage`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将此`FString`传递给全局引擎函数`AddOnScreenDebugMessage`。
- en: The first argument of `-1` tells the engine that duplicate strings are allowed,
    the second parameter is the length of time the message should be displayed for
    in seconds, the third argument is the color, and the fourth is the actual string
    to print itself.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-1`的第一个参数告诉引擎允许重复字符串，第二个参数是消息显示的持续时间（以秒为单位），第三个参数是颜色，第四个参数是要打印的实际字符串。'
- en: Now when a component of our actor overlaps something else, its `UpdateOverlaps`
    function will call `NotifyActorBeginOverlap`, and the virtual function dispatch
    will call our custom implementation.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们的Actor的组件与其他物体重叠时，其`UpdateOverlaps`函数将调用`NotifyActorBeginOverlap`，并且虚函数分发将调用我们的自定义实现。
- en: Creating a delegate that is bound to a UFUNCTION
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个绑定到UFUNCTION的委托
- en: Delegates allow us to call a function without knowing which function is assigned.
    They are a safer version of a raw function pointer. This recipe shows you how
    to associate a `UFUNCTION` to a delegate so that it is called when the delegate
    is executed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 委托允许我们调用一个函数，而不知道分配了哪个函数。它们是原始函数指针的更安全版本。本教程向您展示如何将`UFUNCTION`与委托关联，以便在执行委托时调用它。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure you've followed the previous recipe in order to create a `TriggerVolume`
    class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已按照之前的步骤创建了一个`TriggerVolume`类。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Inside our `GameMode` header, declare the delegate with the following macro,
    just before the class declaration:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`GameMode`头文件中，在类声明之前使用以下宏声明委托：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add a new member to our game mode:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我们的游戏模式添加一个新成员：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a new `Actor` class called `DelegateListener`. Add the following to
    the declaration of that class:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`DelegateListener`的新`Actor`类。将以下内容添加到该类的声明中：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the class implementation, add this to the constructor:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类实现中，将以下内容添加到构造函数中：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `DelegateListener.cpp` file, add `#include "UE4CookbookGameMode.h"`
    between your project''s `include` file and the `DelegateListener` header include.
    Inside the `DelegateListener::BeginPlay` implementation, add the following:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DelegateListener.cpp`文件中，在项目的`include`文件和`DelegateListener`头文件之间添加`#include
    "UE4CookbookGameMode.h"`。在`DelegateListener::BeginPlay`实现中，添加以下内容：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Lastly, implement `EnableLight`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现`EnableLight`：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Put the following code in our TriggerVolume''s `NotifyActorBeginOverlap` function:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码放入我们的TriggerVolume的`NotifyActorBeginOverlap`函数中：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Be sure to add `#include "UE4CookbookGameMode.h"` to your CPP file too so that
    the compiler knows about the class before we use it.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在CPP文件中也添加`#include "UE4CookbookGameMode.h"`，以便编译器在使用之前知道该类。
- en: Compile your game. Make sure that your game mode is set in the current level
    (refer to the *Instantiating an Actor using SpawnActor* recipe in [Chapter 4](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "Chapter 4. Actors and Components"), *Actors and Components* if you don't know
    how), and drag a copy of your TriggerVolume out into the level. Also, drag a copy
    of `DelegateListener` out into the level, and place it about 100 units above a
    flat surface:![How to do it...](img/00093.jpeg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的游戏。确保您的游戏模式设置在当前级别中（如果您不知道如何设置，请参阅[第4章](part0055_split_000.html#1KEEU1-c0ca69a0411046888a488e5085138121
    "第4章。Actors and Components")中的*使用SpawnActor实例化Actor*教程，*Actors and Components*），并将`TriggerVolume`的副本拖到级别中。还将`DelegateListener`的副本拖到级别中，并将其放置在平面表面上方约100个单位处：![操作步骤...](img/00093.jpeg)
- en: When you hit **Play**, and walk into the area covered by the Trigger volume,
    you should see the `PointLight` component, which we added to `DelegateListener`,
    turn on:![How to do it...](img/00094.jpeg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您点击**播放**，并走进Trigger volume覆盖的区域时，您应该看到我们添加到`DelegateListener`的`PointLight`组件打开：![操作步骤...](img/00094.jpeg)
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Inside our `GameMode` header, we declare a type of delegate that doesn't take
    any parameters, called `FTriggerHitSignature`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`GameMode`头文件中，声明一个不带任何参数的委托类型，称为`FTriggerHitSignature`。
- en: We then create an instance of the delegate as a member of our `GameMode` class.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在`GameMode`类的成员中创建委托的实例。
- en: We add a `PointLight` component inside `DelegateListener` so that we have a
    visual representation of the delegate being executed.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`DelegateListener`中添加一个`PointLight`组件，以便我们有一个委托被执行的可视表示。
- en: In the constructor, we initialize our `PointLight`, then disable it.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们初始化我们的`PointLight`，然后禁用它。
- en: We override `BeginPlay`. We first call the parent class's implementation of
    `BeginPlay()`. Then we get the game world, retrieving the `GameMode` class using
    `GetGameMode()`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重写`BeginPlay`。我们首先调用父类的`BeginPlay()`实现。然后，我们获取游戏世界，使用`GetGameMode()`检索`GameMode`类。
- en: Casting the resulting `AGameMode*` to a pointer of our `GameMode` class requires
    the use of the `Cast` template function.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的`AGameMode*`转换为我们的`GameMode`类的指针需要使用`Cast`模板函数。
- en: We can then access the delegate instance member of the `GameMode`, and bind
    our `EnableLight` function to the delegate, so it will be called when the delegate
    is executed.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以访问`GameMode`的委托实例成员，并将我们的`EnableLight`函数绑定到委托，这样当委托被执行时就会调用它。
- en: In this case, we are binding to `UFUNCTION`(), so we use `BindUObject`. If we
    wanted to bind to a plain C++ class function, we would have used `BindRaw`. If
    we want to bind to a static function, we will use `BindStatic()`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们绑定到`UFUNCTION`()，所以我们使用`BindUObject`。如果我们想要绑定到一个普通的C++类函数，我们将使用`BindRaw`。如果我们想要绑定到一个静态函数，我们将使用`BindStatic()`。
- en: When `TriggerVolume` overlaps the player, it retrieves `GameMode`, then calls
    `ExecuteIfBound` on the delegate.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`TriggerVolume`与玩家重叠时，它检索`GameMode`，然后在委托上调用`ExecuteIfBound`。
- en: '`ExecuteIfBound` checks that there''s a function bound to the delegate, and
    then invokes it for us.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ExecuteIfBound`检查委托是否绑定了函数，然后为我们调用它。'
- en: The `EnableLight` function enables the `PointLight` component when invoked by
    the delegate object.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EnableLight`函数在被委托对象调用时启用`PointLight`组件。'
- en: See also
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The next section, *Unregistering a delegate,* shows you how to safely unregister
    your delegate binding in the event of the `Listener` being destroyed before the
    delegate is called
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的部分，*取消委托*，向您展示了如何在`Listener`在委托被调用之前被销毁的情况下安全地取消注册委托绑定
- en: Unregistering a delegate
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消委托
- en: Sometimes, it is necessary to remove a delegate binding. This is like setting
    a function pointer to `nullptr` so that it no longer references an object that
    has been deleted.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有必要移除委托绑定。这就像将函数指针设置为`nullptr`，这样它就不再引用已被删除的对象。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You'll need to follow the previous recipe in order for you to have a delegate
    to unregister.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要按照先前的教程进行操作，以便您有一个要取消注册的委托。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'In `DelegateListener`, add the following overridden function declaration:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DelegateListener`中，添加以下重写函数声明：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement the function like this:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现如下功能：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe combines both of the previous recipes in this chapter so far. We
    override `EndPlay`, which is an event implemented as a virtual function, so that
    we can execute code when our `DelegateListener` leaves play.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本教程将本章迄今为止的两个先前教程结合起来。我们重写`EndPlay`，这是一个作为虚函数实现的事件，这样我们就可以在`DelegateListener`离开游戏时执行代码。
- en: In that overridden implementation, we call the `Unbind()` method on the delegate,
    which unlinks the member function from the `DelegateListener` instance.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重写的实现中，我们在委托上调用`Unbind()`方法，这将从`DelegateListener`实例中取消链接成员函数。
- en: Without this being done, the delegate dangles like a pointer, leaving it in
    an invalid state when the `DelegateListener` leaves the game.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不这样做，委托就会像指针一样悬空，当`DelegateListener`离开游戏时，它就处于无效状态。
- en: Creating a delegate that takes input parameters
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建接受输入参数的委托
- en: So far, the delegates that we've used haven't taken any input parameters. This
    recipe shows you how to change the signature of the delegate so that it accepts
    some input.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的委托没有接受任何输入参数。本教程向您展示如何更改委托的签名，以便它接受一些输入。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Be sure you've followed the recipe at the beginning of this chapter, which shows
    you how to create a `TriggerVolume` and the other infrastructure that we require
    for this recipe.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经按照本章开头的教程进行了操作，该教程向您展示了如何创建`TriggerVolume`和我们为本教程所需的其他基础设施。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Add a new delegate declaration to `GameMode`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`GameMode`添加一个新的委托声明：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a new member to `GameMode`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`GameMode`添加新成员：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a new `Actor` class called `ParamDelegateListener`. Add the following
    to the declaration:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ParamDelegateListener`的新`Actor`类。将以下内容添加到声明中：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the class implementation, add this to the constructor:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类实现中，将以下内容添加到构造函数中：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `ParamDelegateListener.cpp` file, add `#include "UE4CookbookGameMode.h"`
    between your project''s `include` file and the `ParamDelegateListener` header
    include. Inside the `ParamDelegateListener::BeginPlay` implementation, add the
    following:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ParamDelegateListener.cpp`文件中，在项目的`include`文件和`ParamDelegateListener`头文件之间添加`#include
    "UE4CookbookGameMode.h"`。在`ParamDelegateListener::BeginPlay`实现内部添加以下内容：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, implement `SetLightColor`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现`SetLightColor`：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Inside our `TriggerVolume`, in `NotifyActorBeginOverlap`, add the following
    line after the call to `MyStandardDelegate.ExecuteIfBound`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`TriggerVolume`中，在`NotifyActorBeginOverlap`中，在调用`MyStandardDelegate.ExecuteIfBound`之后添加以下行：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our new delegate signature uses a slightly different macro for declaration.
    Note the `_OneParam` suffix at the end of `DECLARE_DELEGATE_OneParam`. As you'd
    expect, we also need to specify what type our parameter will be.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新委托签名使用了一个稍微不同的宏来声明。请注意`DECLARE_DELEGATE_OneParam`末尾的`_OneParam`后缀。正如你所期望的，我们还需要指定参数的类型。
- en: Just like when we created a delegate without parameters, we need to create an
    instance of the delegate as a member of our `GameMode` class.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们创建没有参数的委托时一样，我们需要在我们的`GameMode`类的成员中创建委托的实例。
- en: We now create a new type of `DelegateListener`, one that is expecting a parameter
    to be passed into the function that it binds to the delegate.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在创建了一个新类型的`DelegateListener`，它期望将参数传递到绑定到委托的函数中。
- en: When we call the `ExecuteIfBound()` method for the delegate, we now need to
    pass in the value that will be inserted into the function parameter.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们为委托调用`ExecuteIfBound()`方法时，我们现在需要传入将插入函数参数的值。
- en: Inside the function that we have bound, we use the parameter to set the color
    of our light.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们绑定的函数内部，我们使用参数来设置灯光的颜色。
- en: This means that `TriggerVolume` doesn't need to know anything about the `ParamDelegateListener`
    in order to call functions on it. The delegate has allowed us to minimize coupling
    between the two classes.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着`TriggerVolume`不需要知道任何关于`ParamDelegateListener`的信息，就可以调用它的函数。委托使我们能够最小化两个类之间的耦合。
- en: See also
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Unregistering a delegate* recipe shows you how to safely unregister your
    delegate binding in the event of the Listener being destroyed before the delegate
    is called
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*取消注册委托*食谱向您展示了如何在监听器在调用委托之前被销毁时安全取消注册委托绑定'
- en: Passing payload data with a delegate binding
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用委托绑定传递有效负载数据
- en: With only minimal changes, parameters can be passed through to a delegate at
    creation time. This recipe shows you how to specify data to be always passed as
    parameters to a delegate invocation. The data is calculated when the binding is
    created, and doesn't change from that point forward.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 只需进行最小的更改，就可以在创建时将参数传递给委托。本食谱向您展示了如何指定要始终作为参数传递给委托调用的数据。这些数据在绑定创建时计算，并且从那时起不会改变。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Be sure you've followed the previous recipe. We will be extending the functionality
    of the previous recipe to pass additional creation-time parameters to our bound
    delegate function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经按照之前的步骤进行操作。我们将扩展之前的步骤的功能，以将额外的创建时参数传递给我们绑定的委托函数。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Inside your `AParamDelegateListener::BeginPlay` function, change the call to
    `BindUObject` to the following:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`AParamDelegateListener::BeginPlay`函数内部，将对`BindUObject`的调用更改为以下内容：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Change the declaration of `SetLightColor` to this:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SetLightColor`的声明更改为：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alter the implementation of `SetLightColor` as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`SetLightColor`的实现如下：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Compile and run your project. Verify that when you walk into `TriggerVolume`,
    the light turns off because of the false payload parameter passed in when you
    bound the function.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行您的项目。验证当您走进`TriggerVolume`时，灯光会关闭，因为在绑定函数时传入了错误的有效负载参数。
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we bind the function to the delegate, we specify some additional data (in
    this case, a Boolean of value `false`). You can pass up to four 'payload' variables
    in this fashion. They are applied to your function after any parameters declared
    in the `DECLARE_DELEGATE_*` macro that you used.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们将函数绑定到委托时，我们指定了一些额外的数据（在本例中是一个值为`false`的布尔值）。您可以以这种方式传递多达四个“有效负载”变量。它们会应用于您的函数，而不是您使用的`DECLARE_DELEGATE_*`宏中声明的任何参数之后。
- en: We change the function signature of our delegate so that it can accept the extra
    argument.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们更改了委托的函数签名，以便它可以接受额外的参数。
- en: Inside the function, we use the extra argument to turn the light on or off depending
    on the value being true or false at compile time.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，我们使用额外的参数根据编译时的值是true还是false来打开或关闭灯光。
- en: We don't need to change the call to `ExecuteIfBound`—the delegate system automatically
    applies the delegate parameters, passed in through `ExecuteIfBound`, first. It
    then applies any payload parameters, which are always specified after the function
    reference in a call to `BindUObject`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要更改对`ExecuteIfBound`的调用 - 委托系统会自动首先应用通过`ExecuteIfBound`传入的委托参数，然后应用任何有效负载参数，这些参数始终在对`BindUObject`的调用中函数引用之后指定。
- en: See also
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The recipe *Unregistering a delegate* shows you how to safely unregister your
    delegate binding in the event of the Listener being destroyed before the delegate
    is called
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 食谱*取消注册委托*向您展示了如何在监听器在调用委托之前被销毁时安全取消注册委托绑定
- en: Creating a multicast delegate
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多播委托
- en: The standard delegates used so far in this chapter are essentially a function
    pointer—they allow you to call one particular function on one particular object
    instance. Multicast delegates are a collection of function pointers, each potentially
    on different objects, that will all be invoked when the delegate is **broadcast**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本章迄今为止使用的标准委托本质上是一个函数指针 - 它们允许您在一个特定对象实例上调用一个特定函数。多播委托是一组函数指针，每个指针可能在不同的对象上，当委托被**广播**时，它们都将被调用。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you have followed the initial recipe in the chapter, as
    it shows you how to create `TriggerVolume` that is used to broadcast the multicast
    delegate.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例假设你已经按照本章的初始示例进行了操作，因为它向你展示了如何创建用于广播多播委托的“TriggerVolume”。
- en: How to do it...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add a new delegate declaration to the `GameMode` header:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“GameMode”头文件中添加新的委托声明：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a new `Actor` class called `MulticastDelegateListener`. Add the following
    to the declaration:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“MulticastDelegateListener”的新的“Actor”类。将以下内容添加到声明中：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the class implementation, add this to the constructor:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类实现中，将此添加到构造函数中：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the `MulticastDelegateListener.cpp` file, add `#include "UE4CookbookGameMode.h"`
    between your project''s `include` file and the `MulticastDelegateListener` header
    include. Inside the `MulticastDelegateListener::BeginPlay` implementation, add
    the following:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“MulticastDelegateListener.cpp”文件中，在您项目的“include”文件和“MulticastDelegateListener”头文件包含之间添加“#include
    "UE4CookbookGameMode.h"”。在“MulticastDelegateListener::BeginPlay”实现中，添加以下内容：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement `ToggleLight`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现“ToggleLight”：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Implement our `EndPlay` overridden function:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现我们的“EndPlay”重写函数：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the following line to `TriggerVolume::NotifyActorBeginOverlap()`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“TriggerVolume::NotifyActorBeginOverlap()”中添加以下行：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Compile and load your project. Set the `GameMode` in your level to be our cookbook
    game mode, then drag four or five instances of the `MulticastDelegateListener`
    into the scene.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并加载您的项目。将您的级别中的“GameMode”设置为我们的烹饪书游戏模式，然后将四到五个“MulticastDelegateListener”的实例拖到场景中。
- en: Step into `TriggerVolume` to see all the `MulticastDelegateListener` toggle
    their light's visibility.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步入“TriggerVolume”以查看所有“MulticastDelegateListener”切换其灯光的可见性。
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As you might expect, the delegate type needs to be explicitly declared as a
    multicast delegate rather than a standard single-binding one.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你所期望的那样，委托类型需要明确声明为多播委托，而不是标准的单绑定委托。
- en: Our new `Listener` class is very similar to our original `DelegateListener`.
    The primary difference is that we need to store a reference to our delegate instance
    in `FDelegateHandle`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新“Listener”类与我们原始的“DelegateListener”非常相似。主要区别在于，我们需要在“FDelegateHandle”中存储对委托实例的引用。
- en: When the actor is destroyed, we safely remove ourselves from the list of functions
    bound to the delegate by using the stored `FDelegateHandle` as a parameter to
    `Remove()`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当演员被销毁时，我们可以使用存储的“FDelegateHandle”作为“Remove()”的参数，安全地将自己从绑定到委托的函数列表中移除。
- en: The `Broadcast()` function is the multicast equivalent of `ExecuteIfBound()`.
    Unlike standard delegates, there is no need to check if the delegate is bound
    either in advance or with a call like `ExecuteIfBound`. `Broadcast()` is safe
    to run no matter how many functions are bound, or even if none are.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Broadcast()”函数是“ExecuteIfBound()”的多播等效。与标准委托不同，无需提前检查委托是否绑定，也不需要像“ExecuteIfBound”一样调用。无论绑定了多少个函数，甚至没有绑定任何函数，“Broadcast()”都是安全运行的。
- en: When we have multiple instances of our multicast listener in the scene, they
    each register themselves with the multicast delegate implemented in the `GameMode`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在场景中有多个多播监听器实例时，它们将分别向在“GameMode”中实现的多播委托注册自己。
- en: Then, when the `TriggerVolume` overlaps a player, it broadcasts the delegate,
    and each Listener is notified causing them to toggle the visibility of their associated
    point light.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，当“TriggerVolume”与玩家重叠时，它会广播委托，每个监听器都会收到通知，导致它们切换其关联点光的可见性。
- en: Multicast delegates can take parameters in exactly the same way that a standard
    delegate can.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多播委托可以以与标准委托完全相同的方式接受参数。
- en: Creating a custom Event
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义事件
- en: Custom delegates are quite useful, but one of their limitations is that they
    can be broadcast externally by some other third-party class, that is, their Execute/Broadcast
    methods are publically accessible.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义委托非常有用，但它们的一个限制是它们可以被一些其他第三方类外部广播，也就是说，它们的Execute/Broadcast方法是公开可访问的。
- en: At times, you may want a delegate that is externally assignable by other classes,
    but can only be broadcast by the class which contains them. This is the primary
    purpose of Events.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要一个委托，可以由其他类外部分配，但只能由包含它们的类广播。这是事件的主要目的。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you've followed the initial recipe in this chapter so that you have
    the `MyTriggerVolume` and `CookBookGameMode` implementations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经按照本章的初始示例进行了操作，以便您拥有“MyTriggerVolume”和“CookBookGameMode”的实现。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add the following event declaration macro to the header of your `MyTriggerVolume`
    class:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下事件声明宏添加到您的“MyTriggerVolume”类的头文件中：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add an instance of the declared event signature to the class:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类添加已声明事件签名的实例：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In `AMyTriggerVolume::NotifyActorBeginOverlap`, add this:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“AMyTriggerVolume::NotifyActorBeginOverlap”中添加此内容：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Create a new `Actor` class, called `TriggerVolEventListener`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“TriggerVolEventListener”的新的“Actor”类。
- en: 'Add the following class members to its declaration:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向其声明中添加以下类成员：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Initialize `PointLight` in the class constructor:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类构造函数中初始化“PointLight”：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Inside `BeginPlay`, add the following:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“BeginPlay”中添加以下内容：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lastly, implement `OnTriggerEvent()`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现“OnTriggerEvent()”：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compile your project, and launch the editor. Create a level with the game mode
    set to our `UE4CookbookGameMode`, then drag an instance of `ATriggerVolEventListener`
    and `AMyTriggerVolume` out into the level.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的项目，并启动编辑器。创建一个级别，其中游戏模式设置为我们的“UE4CookbookGameMode”，然后将“ATriggerVolEventListener”和“AMyTriggerVolume”的一个实例拖到级别中。
- en: Select `TriggerVolEventListener`, and you'll see `TriggerVolEventListener` listed
    as a category in the **Details** panel, with the property **Trigger Event Source**:![How
    to do it...](img/00095.jpeg)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“TriggerVolEventListener”，您将在**详细信息**面板中的类别中看到“TriggerVolEventListener”列出，其中包含属性**Trigger
    Event Source**：![如何做...](img/00095.jpeg)
- en: Use the drop-down menu to select your instance of `AMyTriggerVolume` so that
    the Listener knows which event to bind to:![How to do it...](img/00096.jpeg)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用下拉菜单选择您的“AMyTriggerVolume”实例，以便监听器知道要绑定到哪个事件：![如何做...](img/00096.jpeg)
- en: Play your game, and enter the trigger volume's zone of effect. Verify that the
    color of your `EventListener` changes to green.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏，并进入触发体积的影响区域。验证您的`EventListener`的颜色是否变为绿色。
- en: How it works...
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As with all the other types of delegates, Events require their own special macro
    function.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与所有其他类型的代表一样，事件需要它们自己的特殊宏函数。
- en: The first parameter is the class that the event will be implemented into. This
    will be the only class able to call `Broadcast()`, so make sure it is the right
    one.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个参数是事件将被实现到的类。这将是唯一能够调用`Broadcast()`的类，所以确保它是正确的类。
- en: The second parameter is the type name for our new event function signature.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个参数是我们新事件函数签名的类型名称。
- en: We add an instance of this type to our class. Unreal documentation suggests
    `On<x>` as a naming convention.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在我们的类中添加了这种类型的实例。虚幻文档建议使用`On<x>`作为命名惯例。
- en: When something overlaps our `TriggerVolume`, we call broadcast on our own event
    instance.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当某物与我们的`TriggerVolume`重叠时，我们调用我们自己事件实例的广播。
- en: Inside the new class, we create a point light as a visual representation of
    the event being triggered.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新类中，我们创建一个点光源作为事件被触发的可视表示。
- en: We also create a pointer to `TriggerVolume` to listen to events from. We mark
    the `UPROPERTY` as `EditAnywhere`, because this allows us to set it in the Editor
    rather than having to acquire the reference programmatically using `GetAllActorsOfClass`
    or something else.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还创建了一个指向`TriggerVolume`的指针来监听事件。我们将`UPROPERTY`标记为`EditAnywhere`，因为这样可以在编辑器中设置它，而不必使用`GetAllActorsOfClass`或其他方式在程序中获取引用。
- en: Last is our event handler for when something enters the `TriggerVolume`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后是我们的事件处理程序，当某物进入`TriggerVolume`时。
- en: We create and initialize our point light in the constructor as usual.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们像往常一样在构造函数中创建和初始化我们的点光源。
- en: When the game starts, the Listener checks that our `TriggerVolume` reference
    is valid, then binds our `OnTriggerEvent` function to the `TriggerVolume` event.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏开始时，监听器检查我们的`TriggerVolume`引用是否有效，然后将我们的`OnTriggerEvent`函数绑定到`TriggerVolume`事件。
- en: Inside `OnTriggerEvent`, we change our light's color to green.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnTriggerEvent`中，我们将灯光的颜色改为绿色。
- en: When something enters `TriggerVolume`, it causes `TriggerVolume` to call broadcast
    on its own event. Our `TriggerVolEventListener` then has its bound method invoked,
    changing our light's color.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当某物进入`TriggerVolume`时，它会导致`TriggerVolume`调用自己的事件广播。然后我们的`TriggerVolEventListener`就会调用其绑定的方法，改变我们灯光的颜色。
- en: Creating a Time of Day handler
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个时间处理程序
- en: This recipe shows you how to use the concepts introduced in the previous recipes
    to create an actor that informs other actors of the passage of time within your
    game.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程向您展示了如何使用前面介绍的概念来创建一个演员，它通知其他演员游戏内时间的流逝。
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new `Actor` class called `TimeOfDayHandler`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`TimeOfDayHandler`的新的`Actor`类。
- en: 'Add a multicast delegate declaration to the header:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中添加一个多播代表声明：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add an instance of our delegate to the class declaration:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的代表的一个实例添加到类声明中：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the following properties to the class:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到类中：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the initialization of these properties to the constructor:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些属性的初始化添加到构造函数中：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Inside `Tick`, add the following code:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Tick`中，添加以下代码：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Create a new `Actor` class called `Clock`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Clock`的新的`Actor`类。
- en: 'Add the following properties to the class header:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到类头部：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Initialize and transform the components in the constructor:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中初始化和转换组件：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add the following to `BeginPlay`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`BeginPlay`中：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Lastly, implement `TimeChanged` as your event handler.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现`TimeChanged`作为您的事件处理程序。
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Place an instance of `TimeOfDayHandler` and the `AClock` into your level, and
    play to see that the hands on the clock are rotating:![How to do it...](img/00097.jpeg)
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的级别中放置一个`TimeOfDayHandler`和`AClock`的实例，并播放以查看时钟上的指针是否在旋转：![如何做...](img/00097.jpeg)
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`TimeOfDayHandler` contains a delegate which takes two parameters, hence the
    use of the `TwoParams` variant of the macro.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TimeOfDayHandler`包含一个带有两个参数的代表，因此使用宏的`TwoParams`变体。'
- en: Our class contains variables to store hours, minutes, and seconds, and the `TimeScale`,
    which is an acceleration factor used to speed up time for testing purposes.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的类包含变量来存储小时、分钟和秒，以及`TimeScale`，这是一个用于加速测试目的的加速因子。
- en: Inside the handler's `Tick` function, we accumulate elapsed seconds based on
    the time elapsed since the last frame.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理程序的`Tick`函数中，我们根据自上一帧以来经过的时间累积经过的秒数。
- en: We check if the elapsed seconds have gone over 60\. If so, we subtract 60, and
    increment `Minutes`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查经过的秒数是否超过了60。如果是，我们减去60，并增加`Minutes`。
- en: Likewise with `Minutes`—if they go over 60, we subtract 60, and increment `Hours`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，对于`Minutes`——如果它们超过60，我们减去60，并增加`Hours`。
- en: If `Minutes` and `Hours` were updated, we broadcast our delegate to let any
    object that has subscribed to the delegate know that the time has changed.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`Minutes`和`Hours`被更新，我们会广播我们的代表，让订阅了代表的任何对象都知道时间已经改变。
- en: The `Clock` actor uses a series of Scene components and Static meshes to build
    a mesh hierarchy that resembles a clock face.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Clock` actor使用一系列场景组件和静态网格来构建类似时钟表盘的网格层次结构。'
- en: In the `Clock` constructor, we parent the components in the hierarchy, and set
    their initial scale and rotations.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Clock`构造函数中，我们将层次结构中的组件进行父子关联，并设置它们的初始比例和旋转。
- en: In `BeginPlay`, the clock uses `GetAllActorsOfClass()` to fetch all the `time
    of day` handlers in the level.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BeginPlay`中，时钟使用`GetAllActorsOfClass()`来获取级别中所有的`time of day`处理程序。
- en: If there's at least one `TimeOfDayHandler` in the level, the `Clock` accesses
    the first one, and subscribes to its `TimeChanged` event.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果级别中至少有一个`TimeOfDayHandler`，`Clock`就会访问第一个，并订阅其`TimeChanged`事件。
- en: When the `TimeChanged` event fires, the clock rotates the hour and minute hands
    based on how many hours and minutes the time currently has.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`TimeChanged`事件触发时，时钟会根据当前时间的小时和分钟数旋转时针和分针。
- en: Creating a respawning pickup for an First Person Shooter
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为第一人称射击游戏创建一个重生拾取物
- en: This recipe shows you how to create a placeable pickup that will respawn after
    a certain amount of time, suitable as an ammo or other pickup for an FPS.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程向您展示了如何创建一个可放置的拾取物，在一定时间后重新生成，适用于FPS中的弹药或其他拾取物。
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new `Actor` class called `Pickup`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Pickup`的新的`Actor`类。
- en: 'Declare the following delegate type in `Pickup.h`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Pickup.h`中声明以下委托类型：
- en: '[PRE44]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the following properties to the class header:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到类头文件中：
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add the following code to the constructor:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到构造函数中：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement the overridden `NotifyActorBeginOverlap`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现重写的`NotifyActorBeginOverlap`：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Create a second `Actor` class called `PickupSpawner`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个名为`PickupSpawner`的`Actor`类。
- en: 'Add the following to the class header:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到类头文件中：
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Add `Pickup.h` to the includes in the `PickupSpawner` implementation file.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PickupSpawner`的实现文件中将`Pickup.h`添加到包含文件中。
- en: 'Initialize our root component in the constructor:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中初始化我们的根组件：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Spawn a pickup when gameplay starts with the `SpawnPickup` function in `BeginPlay`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BeginPlay`中使用`SpawnPickup`函数在游戏开始时生成一个拾取物：
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Implement `PickupCollected`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`PickupCollected`：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create the following code for `SpawnPickup`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`SpawnPickup`创建以下代码：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Compile and launch the editor, then drag an instance of `PickupSpawner` out
    into the level. Walk into the pickup represented by the spinning cube, and verify
    that it spawns again 10 seconds later:![How to do it...](img/00098.jpeg)
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并启动编辑器，然后将`PickupSpawner`的一个实例拖到关卡中。走到由旋转立方体表示的拾取物上，并验证它在10秒后再次生成：![如何做...](img/00098.jpeg)
- en: How it works...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As usual, we need to create a delegate inside our `Pickup` that our Spawner
    can subscribe to so that it knows when the player collects the pickup.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，在我们的`Pickup`内部创建一个委托，以便我们的Spawner可以订阅它，以便它知道玩家何时收集了拾取物。
- en: The `Pickup` also contains a Static mesh as a visual representation, and a `RotatingMovementComponent`
    so that the mesh will spin in a way to attract the attention of the players.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Pickup`还包含一个静态网格作为视觉表示，以及一个`RotatingMovementComponent`，使网格以一种方式旋转，以吸引玩家的注意。'
- en: Inside the `Pickup` constructor, we load one of the engine's inbuilt meshes
    as our visual representation.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Pickup`构造函数中，我们加载引擎内置的网格作为我们的视觉表示。
- en: We specify that the mesh will overlap with other objects, then set the rotation
    rate of our mesh at 10 units per second in the *X* and *Z* axes.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指定网格将与其他对象重叠，然后在*X*和*Z*轴上将网格的旋转速率设置为每秒10个单位。
- en: When the player overlaps the `Pickup`, it fires off its `PickedUp` delegate
    from the first step.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家与`Pickup`重叠时，它会从第一步触发其`PickedUp`委托。
- en: The `PickupSpawner` has a Scene component to specify where to spawn the pickup
    actor. It has a function for doing so, and a `UPROPERTY`-tagged reference to the
    currently spawned `Pickup`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PickupSpawner`有一个场景组件来指定生成拾取物的位置。它有一个执行此操作的函数，并且有一个`UPROPERTY`标记的对当前生成的`Pickup`的引用。'
- en: In the `PickupSpawner` constructor, we initialize our components as always.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PickupSpawner`构造函数中，我们像往常一样初始化我们的组件。
- en: When play begins, the Spawner runs its `SpawnPickup` function.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏开始时，Spawner运行其`SpawnPickup`函数。
- en: This function spawns an instance of our `Pickup`, then binds `APickupSpawner::PickupCollected`
    to the `OnPickedUp` function on the new instance. It also stores a reference to
    that current instance.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数生成我们的`Pickup`的一个实例，然后将`APickupSpawner::PickupCollected`绑定到新实例上的`OnPickedUp`函数。它还存储对当前实例的引用。
- en: When `PickupCollected` runs after the player has overlapped the `Pickup`, a
    timer is created to respawn the pickup after 10 seconds.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家与`Pickup`重叠后，`PickupCollected`运行，创建一个定时器在10秒后重新生成拾取物。
- en: The existing delegate binding to the collected pickup is removed, then the pickup
    is destroyed.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除到已收集拾取物的现有委托绑定，然后销毁拾取物。
- en: After 10 seconds, the timer fires, running `SpawnActor` again, which creates
    a new `Pickup`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 10秒后，定时器触发，再次运行`SpawnActor`，创建一个新的`Pickup`。
