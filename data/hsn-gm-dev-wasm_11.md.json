["```cpp\n#define LEVEL_WIDTH CANVAS_WIDTH*4\n#define LEVEL_HEIGHT CANVAS_HEIGHT*4\n```", "```cpp\nclass Ship;\nclass Particle;\nclass Emitter;\nclass Collider;\nclass Asteroid;\nclass Star;\nclass PlayerShip;\nclass EnemyShip;\nclass Projectile;\nclass ProjectilePool;\nclass FiniteStateMachine;\nclass Camera;\nclass RenderManager;\nclass Locator;\n```", "```cpp\nclass Vector2D {\n    public:\n        float x;\n        float y;\n\n        Vector2D();\n        Vector2D( float X, float Y );\n\n        void Rotate( float radians );\n        void Normalize();\n        float MagSQ();\n        float Magnitude();\n        Vector2D Project( Vector2D &onto );\n        float Dot(Vector2D &vec);\n        float FindAngle();\n\n        Vector2D operator=(const Vector2D &vec);\n        Vector2D operator*(const float &scalar);\n        void operator+=(const Vector2D &vec);\n        void operator-=(const Vector2D &vec);\n        void operator*=(const float &scalar);\n        void operator/=(const float &scalar);\n Vector2D operator-(const Vector2D &vec);\n Vector2D operator+(const Vector2D &vec);\n};\n```", "```cpp\nVector2D operator-(const Vector2D &vec);\nVector2D operator+(const Vector2D &vec);\n```", "```cpp\nclass Locator {\n    public:\n        bool m_Active = false;\n        bool m_LastActive = false;\n        SDL_Texture *m_SpriteTexture;\n        SDL_Rect m_dest = {.x = 0, .y = 0, .w = 32, .h = 32 };\n        Vector2D m_Position;\n        int m_ColorFlux;\n        float m_Rotation;\n\n        Locator();\n        void SetActive();\n        void Move();\n        void Render();\n};\n```", "```cpp\n        SDL_Texture *m_SpriteTexture;\n        SDL_Rect m_dest = {.x = 0, .y = 0, .w = 32, .h = 32 };\n```", "```cpp\n        Locator();\n        void SetActive();\n        void Move();\n        void Render();\n```", "```cpp\nclass Camera {\n    public:\n        Vector2D m_Position;\n        float m_HalfWidth;\n        float m_HalfHeight;\n\n        Camera( float width, float height );\n        void Move();\n};\n```", "```cpp\nclass RenderManager {\n    public:\n        const int c_BackgroundWidth = 800;\n        const int c_BackgroundHeight = 600;\n        SDL_Texture *m_BackgroundTexture;\n        SDL_Rect m_BackgroundDest = {.x = 0, .y = 0, .w = \n        c_BackgroundWidth, .h = c_BackgroundHeight };\n\n        RenderManager();\n        void RenderBackground();\n        void Render( SDL_Texture *tex, SDL_Rect *src, SDL_Rect *dest, float \n        rad_rotation = 0.0, int alpha = 255, int red = 255, int green = \n        255, int blue = 255 );\n};\n```", "```cpp\nextern Camera* camera;\nextern RenderManager* render_manager;\nextern Locator* locator;\n```", "```cpp\n#include \"game.hpp\"\nCamera::Camera( float width, float height ) {\n    m_HalfWidth = width / 2;\n    m_HalfHeight = height / 2;\n}\n\nvoid Camera::Move() {\n    m_Position = player->m_Position;\n    m_Position.x -= CANVAS_WIDTH / 2;\n    m_Position.y -= CANVAS_HEIGHT / 2;\n}\n```", "```cpp\n#include \"game.hpp\"\n#define BACKGROUND_SPRITE_FILE (char*)\"/sprites/starfield.png\"\n```", "```cpp\nRenderManager::RenderManager() {\n    SDL_Surface *temp_surface = IMG_Load( BACKGROUND_SPRITE_FILE );\n\n    if( !temp_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return;\n    }\n\n    m_BackgroundTexture = SDL_CreateTextureFromSurface( renderer, \n    temp_surface );\n\n    if( !m_BackgroundTexture ) {\n        printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n        return;\n    }\n    SDL_FreeSurface( temp_surface );\n}\n```", "```cpp\nSDL_SetRenderDrawColor( renderer, 0, 0, 0, 255 );\nSDL_RenderClear( renderer );\n```", "```cpp\nvoid RenderManager::RenderBackground() {\n    SDL_SetRenderDrawColor( renderer, 0, 0, 0, 255 );\n    SDL_RenderClear( renderer );\n    SDL_Rect background_rect = {.x = 0, .y=0, .w=CANVAS_WIDTH, \n                                .h=CANVAS_HEIGHT};\n    int start_x = (int)(camera->m_Position.x) % CANVAS_WIDTH;\n    int start_y = (int)(camera->m_Position.y) % CANVAS_HEIGHT;\n    background_rect.x -= start_x;\n    background_rect.y -= start_y;\n    SDL_RenderCopy( renderer, m_BackgroundTexture, NULL, \n                    &background_rect );\n    background_rect.x += CANVAS_WIDTH;\n    SDL_RenderCopy( renderer, m_BackgroundTexture, NULL, \n                    &background_rect );\n    background_rect.x -= CANVAS_WIDTH;\n    background_rect.y += CANVAS_HEIGHT;\n    SDL_RenderCopy( renderer, m_BackgroundTexture, NULL, \n                    &background_rect );\n    background_rect.x += CANVAS_WIDTH;\n    SDL_RenderCopy( renderer, m_BackgroundTexture, NULL, \n                    &background_rect );\n }\n```", "```cpp\n\nvoid RenderManager::Render( SDL_Texture *tex, SDL_Rect *src, SDL_Rect *dest, float rad_rotation,int alpha, int red, int green, int blue ) {\n\n    SDL_Rect camera_dest = *dest;\n    if( camera_dest.x <= CANVAS_WIDTH &&\n        camera->m_Position.x >= LEVEL_WIDTH - CANVAS_WIDTH ) {\n        camera_dest.x += (float)LEVEL_WIDTH;\n    }\n    else if( camera_dest.x >= LEVEL_WIDTH - CANVAS_WIDTH &&\n             camera->m_Position.x <= CANVAS_WIDTH ) {\n             camera_dest.x -= (float)LEVEL_WIDTH;\n    }\n    if( camera_dest.y <= CANVAS_HEIGHT &&\n        camera->m_Position.y >= LEVEL_HEIGHT - CANVAS_HEIGHT ) {\n        camera_dest.y += (float)LEVEL_HEIGHT;\n    }\n    else if( camera_dest.y >= LEVEL_HEIGHT - CANVAS_HEIGHT &&\n             camera->m_Position.y <= CANVAS_HEIGHT ) {\n             camera_dest.y -= (float)LEVEL_HEIGHT;\n    }\n    camera_dest.x -= (int)camera->m_Position.x;\n    camera_dest.y -= (int)camera->m_Position.y;\n\n    SDL_SetTextureAlphaMod(tex,\n                           (Uint8)alpha );\n\n    SDL_SetTextureColorMod(tex,\n                            (Uint8)red,\n                            (Uint8)green,\n                            (Uint8)blue );\n\n    if( rad_rotation != 0.0 ) {\n        float degree_rotation = RAD_TO_DEG(rad_rotation);\n        SDL_RenderCopyEx( renderer, tex, src, &camera_dest,\n                          degree_rotation, NULL, SDL_FLIP_NONE );\n    }\n    else {\n        SDL_RenderCopy( renderer, tex, src, &camera_dest );\n    }\n}\n```", "```cpp\nif( camera_dest.x <= CANVAS_WIDTH &&\n    camera->m_Position.x >= LEVEL_WIDTH - CANVAS_WIDTH ) {\n    camera_dest.x += (float)LEVEL_WIDTH;\n}\nelse if( camera_dest.x >= LEVEL_WIDTH - CANVAS_WIDTH &&\n         camera->m_Position.x <= CANVAS_WIDTH ) {\n    camera_dest.x -= (float)LEVEL_WIDTH;\n}\n```", "```cpp\nif( camera_dest.y <= CANVAS_HEIGHT &&\n    camera->m_Position.y >= LEVEL_HEIGHT - CANVAS_HEIGHT ) {\n    camera_dest.y += (float)LEVEL_HEIGHT;\n}\nelse if( camera_dest.y >= LEVEL_HEIGHT - CANVAS_HEIGHT &&\n         camera->m_Position.y <= CANVAS_HEIGHT ) {\n    camera_dest.y -= (float)LEVEL_HEIGHT;\n}\n```", "```cpp\ncamera_dest.x -= (int)camera->m_Position.x;\ncamera_dest.y -= (int)camera->m_Position.y;\nSDL_SetTextureAlphaMod(tex,\n                        (Uint8)alpha );\n\nSDL_SetTextureColorMod(tex,\n                       (Uint8)red,\n                       (Uint8)green,\n                       (Uint8)blue );\n```", "```cpp\nif( rad_rotation != 0.0 ) {\n    float degree_rotation = RAD_TO_DEG(rad_rotation);\n    SDL_RenderCopyEx( renderer, tex, src, &camera_dest,\n                      degree_rotation, NULL, SDL_FLIP_NONE );\n}\nelse {\n    SDL_RenderCopy( renderer, tex, src, &camera_dest );\n}\n```", "```cpp\nCamera* camera;\nRenderManager* render_manager;\nLocator* locator;\n```", "```cpp\n camera->Move();\n locator->Move();\n```", "```cpp\nvoid move() {\n    player->Move();\n    enemy->Move();\n    projectile_pool->MoveProjectiles();\n    Asteroid* asteroid;\n    std::vector<Asteroid*>::iterator it;\n    int i = 0;\n\n    for( it = asteroid_list.begin(); it != asteroid_list.end(); it++ ) {\n        asteroid = *it;\n        if( asteroid->m_Active ) {\n            asteroid->Move();\n        }\n    }\n    star->Move();\n    camera->Move();\n    locator->Move();\n}\n```", "```cpp\n render_manager->RenderBackground();\n```", "```cpp\n locator->Render();\n```", "```cpp\nvoid render() {\n render_manager->RenderBackground();\n    player->Render();\n    enemy->Render();\n    projectile_pool->RenderProjectiles();\n\n    Asteroid* asteroid;\n    std::vector<Asteroid*>::iterator it;\n    for( it = asteroid_list.begin(); it != asteroid_list.end(); it++ ) {\n        asteroid = *it;\n        asteroid->Render();\n    }\n    star->Render();\n locator->Render();\n\n    SDL_RenderPresent( renderer );\n}\n```", "```cpp\ncamera = new Camera(CANVAS_WIDTH, CANVAS_HEIGHT);\nrender_manager = new RenderManager();\nlocator = new Locator();\n```", "```cpp\nasteroid_list.push_back( new Asteroid(\n                            200, 50, 0.05, \n                            DEG_TO_RAD(10) ) );\nasteroid_list.push_back( new Asteroid(\n                            600, 150, 0.03, \n                            DEG_TO_RAD(350) ) );\nasteroid_list.push_back( new Asteroid(\n                            150, 500, 0.05, \n                            DEG_TO_RAD(260) ) );\nasteroid_list.push_back( new Asteroid(\n                            450, 350, 0.01, \n                            DEG_TO_RAD(295) ) );\nasteroid_list.push_back( new Asteroid(\n                            350, 300, 0.08, \n                            DEG_TO_RAD(245) ) );\nasteroid_list.push_back( new Asteroid(\n                            700, 300, 0.09, \n                            DEG_TO_RAD(280) ) );\nasteroid_list.push_back( new Asteroid(\n                            200, 450, 0.03, \n                            DEG_TO_RAD(40) ) );\n```", "```cpp\nint asteroid_x = 0;\nint asteroid_y = 0;\nint angle = 0;\n\n// SCREEN 1\nfor( int i_y = 0; i_y < 8; i_y++ ) {\n    asteroid_y += 100;\n    asteroid_y += rand() % 400;\n    asteroid_x = 0;\n\n    for( int i_x = 0; i_x < 12; i_x++ ) {\n        asteroid_x += 66;\n        asteroid_x += rand() % 400;\n        int y_save = asteroid_y;\n        asteroid_y += rand() % 400 - 200;\n        angle = rand() % 359;\n        asteroid_list.push_back( new Asteroid(\n                        asteroid_x, asteroid_y,\n                        get_random_float(0.5, 1.0),\n                        DEG_TO_RAD(angle) ) );\n        asteroid_y = y_save;\n    }\n}\n```", "```cpp\n SDL_RenderCopyEx( renderer, m_SpriteTexture, \n                   &m_src, &m_dest, \n                   RAD_TO_DEG(m_Rotation), NULL, SDL_FLIP_NONE );\n```", "```cpp\n render_manager->Render( m_SpriteTexture, &m_src, &m_dest, m_Rotation );\n```", "```cpp\nvoid Asteroid::Render() {\n    m_Explode->Move();\n    m_Chunks->Move();\n    if( m_Active == false ) {\n        return;\n    }\n    m_src.x = m_dest.w * m_CurrentFrame;\n    m_dest.x = m_Position.x + m_Radius / 2;\n    m_dest.y = m_Position.y + m_Radius / 2;\n    render_manager->Render( m_SpriteTexture, &m_src, &m_dest, m_Rotation );\n}\n```", "```cpp\nvoid Collider::WrapPosition() {\n    if( m_Position.x > CANVAS_WIDTH + m_Radius ) {\n        m_Position.x = -m_Radius;\n    }\n    else if( m_Position.x < -m_Radius ) {\n        m_Position.x = CANVAS_WIDTH;\n    }\n\n    if( m_Position.y > CANVAS_HEIGHT + m_Radius ) {\n        m_Position.y = -m_Radius;\n    }\n    else if( m_Position.y < -m_Radius ) {\n        m_Position.y = CANVAS_HEIGHT;\n    }\n}\n```", "```cpp\nvoid Collider::WrapPosition() {\n    if( m_Position.x > LEVEL_WIDTH ) {\n        m_Position.x -= LEVEL_WIDTH;\n    }\n    else if( m_Position.x < 0 ) {\n        m_Position.x += LEVEL_WIDTH;\n    }\n\n    if( m_Position.y > LEVEL_HEIGHT ) {\n        m_Position.y -= LEVEL_HEIGHT;\n    }\n    else if( m_Position.y < 0 ) {\n        m_Position.y += LEVEL_HEIGHT;\n    }\n}\n```", "```cpp\nEnemyShip::EnemyShip() {\n    m_Position.x = 810.0;\n    m_Position.y = 800.0;\n```", "```cpp\nstar_avoid.x = CANVAS_WIDTH / 2;\nstar_avoid.y = CANVAS_HEIGHT / 2;\n```", "```cpp\nstar_avoid.x = LEVEL_WIDTH / 2;\nstar_avoid.y = LEVEL_HEIGHT / 2;\n```", "```cpp\navoid_vec.x = CANVAS_WIDTH / 2;\navoid_vec.y = CANVAS_HEIGHT / 2;\n```", "```cpp\navoid_vec.x = LEVEL_WIDTH / 2;\navoid_vec.y = LEVEL_HEIGHT / 2;\n```", "```cpp\nvoid FiniteStateMachine::AvoidForce() {\n    Vector2D start_corner;\n    Vector2D end_corner;\n    Vector2D avoid_vec;\n    Vector2D dist;\n    float closest_square = 999999999999.0;\n    float msq;\n    Vector2D star_avoid;\n star_avoid.x = LEVEL_WIDTH / 2;\n star_avoid.y = LEVEL_HEIGHT / 2;\n    star_avoid -= m_Ship->m_Position;\n    msq = star_avoid.MagSQ();\n\n    if( msq >= c_StarAvoidDistSQ ) {\n        start_corner = m_Ship->m_Position;\n        start_corner.x -= c_AvoidDist;\n        start_corner.y -= c_AvoidDist;\n        end_corner = m_Ship->m_Position;\n        end_corner.x += c_AvoidDist;\n        end_corner.y += c_AvoidDist;\n\n        Asteroid* asteroid;\n        std::vector<Asteroid*>::iterator it;\n\n        int i = 0;\n        for( it = asteroid_list.begin(); it != asteroid_list.end(); it++ ) {\n            asteroid = *it;\n            if( asteroid->m_Active == true &&\n                asteroid->SteeringRectTest( start_corner, end_corner ) ) {\n                dist = asteroid->m_Position;\n                dist -= m_Ship->m_Position;\n                msq = dist.MagSQ();\n\n                if( msq <= closest_square ) {\n                    closest_square = msq;\n                    avoid_vec = asteroid->m_Position;\n                }\n            }\n        }\n        // LOOP OVER PROJECTILES\n        Projectile* projectile;\n        std::vector<Projectile*>::iterator proj_it;\n\n        for( proj_it = projectile_pool->m_ProjectileList.begin(); \n             proj_it != projectile_pool->m_ProjectileList.end(); proj_it++ ) {\n            projectile = *proj_it;\n            if( projectile->m_Active == true &&\n                projectile->SteeringRectTest( start_corner, end_corner ) ) {\n                dist = projectile->m_Position;\n                dist -= m_Ship->m_Position;\n                msq = dist.MagSQ();\n\n                if( msq <= closest_square ) {\n                    closest_square = msq;\n                    avoid_vec = projectile->m_Position;\n                }\n            }\n        }\n        if( closest_square != 999999999999.0 ) {\n            avoid_vec -= m_Ship->m_Position;\n            avoid_vec.Normalize();\n            float rot_to_obj = avoid_vec.FindAngle();\n\n            if( std::abs( rot_to_obj - m_Ship->m_Rotation ) < 0.75 ) {\n                if( rot_to_obj >= m_Ship->m_Rotation ) {\n                    m_Ship->RotateLeft();\n                }\n                else {\n                    m_Ship->RotateRight();\n                }\n            }\n            m_Ship->m_Velocity -= avoid_vec * delta_time * \n            c_ObstacleAvoidForce;\n        }\n    }\n    else {\n        avoid_vec.x = LEVEL_WIDTH / 2;\n avoid_vec.y = LEVEL_HEIGHT / 2;\n        avoid_vec -= m_Ship->m_Position;\n        avoid_vec.Normalize();\n        float rot_to_obj = avoid_vec.FindAngle();\n        if( std::abs( rot_to_obj - m_Ship->m_Rotation ) < 0.75 ) {\n            if( rot_to_obj >= m_Ship->m_Rotation ) {\n                m_Ship->RotateLeft();\n            }\n            else {\n                m_Ship->RotateRight();\n            }\n        }\n        m_Ship->m_Velocity -= avoid_vec * delta_time * c_StarAvoidForce; \n    }\n}\n```", "```cpp\nvoid Particle::Render() {\n    SDL_SetTextureAlphaMod(m_sprite_texture,\n                            (Uint8)m_alpha );\n\n    if( m_color_mod == true ) {\n        SDL_SetTextureColorMod(m_sprite_texture,\n                                m_current_red,\n                                m_current_green,\n                                m_current_blue );\n    }\n\n    if( m_align_rotation == true ) {\n        SDL_RenderCopyEx( renderer, m_sprite_texture, &m_src, &m_dest, \n                            m_rotation, NULL, SDL_FLIP_NONE );\n    }\n    else {\n        SDL_RenderCopy( renderer, m_sprite_texture, &m_src, &m_dest );\n    }\n}\n```", "```cpp\nvoid Particle::Render() {\n render_manager->Render( m_sprite_texture, &m_src, &m_dest, m_rotation,\n m_alpha, m_current_red, m_current_green, m_current_blue );\n}\n```", "```cpp\nm_Position.x = CANVAS_WIDTH - 210.0;\nm_Position.y = CANVAS_HEIGHT - 200.0;\n```", "```cpp\nPlayerShip::PlayerShip() {\n m_Position.x = LEVEL_WIDTH - 810.0;\n m_Position.y = LEVEL_HEIGHT - 800.0;\n```", "```cpp\nint return_val = SDL_RenderCopy( renderer, m_SpriteTexture, \n                                 &src, &dest );\nif( return_val != 0 ) {\n    printf(\"SDL_Init failed: %s\\n\", SDL_GetError());\n}\n```", "```cpp\n render_manager->Render( m_SpriteTexture, &src, &dest );\n```", "```cpp\nvoid Projectile::Render() {\n    dest.x = m_Position.x + 8;\n    dest.y = m_Position.y + 8;\n    dest.w = c_Width;\n    dest.h = c_Height;\n\n    src.x = 16 * m_CurrentFrame;\n\n render_manager->Render( m_SpriteTexture, &src, &dest );\n}\n```", "```cpp\nSDL_SetTextureColorMod(m_SpriteTexture,\n                        color_red,\n                        color_green,\n                        0 );\n\nSDL_RenderCopyEx( renderer, m_SpriteTexture, \n                    &m_src, &m_dest, \n                    RAD_TO_DEG(m_Ship->m_Rotation), \n                    NULL, SDL_FLIP_NONE );\n```", "```cpp\nrender_manager->Render( m_SpriteTexture, &m_src, &m_dest, m_Ship->m_Rotation,\n                        255, color_red, color_green, 0 );\n```", "```cpp\nvoid Shield::Render() {\n    if( m_Active ) {\n        int color_green = m_ttl / 100 + 1;\n        int color_red = 255 - color_green;\n\n        m_src.x = m_CurrentFrame * m_dest.w;\n\n        m_dest.x = m_Ship->m_Position.x;\n        m_dest.y = m_Ship->m_Position.y;\n render_manager->Render( m_SpriteTexture, &m_src, &m_dest, m_Ship->m_Rotation,\n 255, color_red, color_green, 0 );\n    }\n}\n```", "```cpp\nfloat degrees = (m_Rotation / PI) * 180.0;\nint return_code = SDL_RenderCopyEx( renderer, m_SpriteTexture, \n                                    &src, &dest, \n                                    degrees, NULL, SDL_FLIP_NONE );\nif( return_code != 0 ) {\n    printf(\"failed to render image: %s\\n\", IMG_GetError() );\n}\n```", "```cpp\n render_manager->Render( m_SpriteTexture, &src, &dest, m_Rotation );\n```", "```cpp\nm_Position.x = CANVAS_WIDTH / 2;\nm_Position.y = CANVAS_HEIGHT / 2;\n```", "```cpp\nm_Position.x = LEVEL_WIDTH / 2;\nm_Position.y = LEVEL_HEIGHT / 2;\n```", "```cpp\nvoid Star::Render() {\n    Emitter* flare;\n    std::vector<Emitter*>::iterator it;\n    for( it = m_FlareList.begin(); it != m_FlareList.end(); it++ ) {\n        flare = *it;\n        flare->Move();\n    }\n    m_src.x = m_dest.w * m_CurrentFrame;\n    SDL_RenderCopy( renderer, m_SpriteTexture, \n                    &m_src, &m_dest );\n}\n```", "```cpp\nvoid Star::Render() {\n    Emitter* flare;\n    std::vector<Emitter*>::iterator it;\n    for( it = m_FlareList.begin(); it != m_FlareList.end(); it++ ) {\n        flare = *it;\n        flare->Move();\n    }\n    m_src.x = m_dest.w * m_CurrentFrame;\n    render_manager->Render( m_SpriteTexture, &m_src, &m_dest );\n}\n```", "```cpp\nVector2D Vector2D::operator-(const Vector2D &vec) {\n Vector2D return_vec = *this;\n return_vec -= vec;\n return return_vec;\n}\n\nVector2D Vector2D::operator+(const Vector2D &vec) {\n Vector2D return_vec = *this;\n return_vec += vec;\n return return_vec;\n}\n```", "```cpp\nem++ asteroid.cpp camera.cpp collider.cpp emitter.cpp enemy_ship.cpp finite_state_machine.cpp locator.cpp main.cpp particle.cpp player_ship.cpp projectile_pool.cpp projectile.cpp range.cpp render_manager.cpp shield.cpp ship.cpp star.cpp vector.cpp -o index.html --preload-file sprites -std=c++17 -s USE_WEBGL2=1 -s USE_SDL=2 -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=[\"png\"] -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=[\"png\"] \n```", "```cpp\n Vector2D m_DesiredPosition;\n```", "```cpp\nclass Camera {\n    public:\n        Vector2D m_Position;\n Vector2D m_DesiredPosition;\n\n        float m_HalfWidth;\n        float m_HalfHeight;\n\n        Camera( float width, float height );\n        void Move();\n};\n```", "```cpp\nm_Position = player->m_Position;\nm_Position.x -= CANVAS_WIDTH / 2;\nm_Position.y -= CANVAS_HEIGHT / 2;\n```", "```cpp\nCamera::Camera( float width, float height ) {\n    m_HalfWidth = width / 2;\n    m_HalfHeight = height / 2;\n\n m_Position = player->m_Position;\n m_Position.x -= CANVAS_WIDTH / 2;\n m_Position.y -= CANVAS_HEIGHT / 2;\n}\n```", "```cpp\nm_DesiredPosition = player->m_Position;\nm_DesiredPosition.x -= CANVAS_WIDTH / 2;\nm_DesiredPosition.y -= CANVAS_HEIGHT / 2;\n```", "```cpp\nif( player->m_Active == false ) {\n    m_Position.x = m_Position.x + (m_DesiredPosition.x - m_Position.x) \n    * delta_time;\n    m_Position.y = m_Position.y + (m_DesiredPosition.y - m_Position.y) \n    * delta_time;\n    return;\n}\n```", "```cpp\nProjectile* projectile;\nstd::vector<Projectile*>::iterator it;\nVector2D attractor;\nfor( it = projectile_pool->m_ProjectileList.begin(); it != projectile_pool->m_ProjectileList.end(); it++ ) {\n    projectile = *it;\n    if( projectile->m_Active ) {\n        attractor = projectile->m_Position;\n        attractor -= player->m_Position;\n        attractor.Normalize();\n        attractor *= 5;\n        m_DesiredPosition += attractor;\n    }\n}\n```", "```cpp\nm_DesiredPosition += player->m_Velocity * 2;\n```", "```cpp\nif( abs(m_DesiredPosition.x - m_Position.x) > CANVAS_WIDTH ) {\n    if( m_DesiredPosition.x > m_Position.x ) {\n        m_Position.x += LEVEL_WIDTH;\n    }\n    else {\n        m_Position.x -= LEVEL_WIDTH;\n    }\n}\nif( abs(m_DesiredPosition.y - m_Position.y) > CANVAS_HEIGHT ) {\n    if( m_DesiredPosition.y > m_Position.y ) {\n        m_Position.y += LEVEL_HEIGHT;\n    }\n    else {\n        m_Position.y -= LEVEL_HEIGHT;\n    }\n}\n```", "```cpp\nm_Position.x = m_Position.x + (m_DesiredPosition.x - m_Position.x) * \ndelta_time;\nm_Position.y = m_Position.y + (m_DesiredPosition.y - m_Position.y) * \ndelta_time;\n```", "```cpp\nvoid Camera::Move() {\n    m_DesiredPosition = player->m_Position;\n    m_DesiredPosition.x -= CANVAS_WIDTH / 2;\n    m_DesiredPosition.y -= CANVAS_HEIGHT / 2;\n\n    if( player->m_Active == false ) {\n        m_Position.x = m_Position.x + (m_DesiredPosition.x - m_Position.x) \n        * delta_time;\n        m_Position.y = m_Position.y + (m_DesiredPosition.y - m_Position.y) \n        * delta_time;\n        return;\n    }\n\n    Projectile* projectile;\n    std::vector<Projectile*>::iterator it;\n    Vector2D attractor;\n\n    for( it = projectile_pool->m_ProjectileList.begin(); \n        it != projectile_pool->m_ProjectileList.end(); it++ ) {\n        projectile = *it;\n            if( projectile->m_Active ) {\n            attractor = projectile->m_Position;\n            attractor -= player->m_Position;\n            attractor.Normalize();\n            attractor *= 5;\n            m_DesiredPosition += attractor;\n        }\n    }\n    m_DesiredPosition += player->m_Velocity * 2;\n\n    if( abs(m_DesiredPosition.x - m_Position.x) > CANVAS_WIDTH ) {\n        if( m_DesiredPosition.x > m_Position.x ) {\n            m_Position.x += LEVEL_WIDTH;\n        }\n        else {\n            m_Position.x -= LEVEL_WIDTH;\n        }\n    }\n\n    if( abs(m_DesiredPosition.y - m_Position.y) > CANVAS_HEIGHT ) {\n        if( m_DesiredPosition.y > m_Position.y ) {\n            m_Position.y += LEVEL_HEIGHT;\n        }\n        else {\n            m_Position.y -= LEVEL_HEIGHT;\n        }\n    }\n\n    m_Position.x = m_Position.x + (m_DesiredPosition.x - m_Position.x) * \n    delta_time;\n    m_Position.y = m_Position.y + (m_DesiredPosition.y - m_Position.y) * \n    delta_time;\n}\n```", "```cpp\nem++ asteroid.cpp camera.cpp collider.cpp emitter.cpp enemy_ship.cpp finite_state_machine.cpp locator.cpp main.cpp particle.cpp player_ship.cpp projectile_pool.cpp projectile.cpp range.cpp render_manager.cpp shield.cpp ship.cpp star.cpp vector.cpp -o camera.html --preload-file sprites -std=c++17 -s USE_WEBGL2=1 -s USE_SDL=2 -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=[\"png\"] -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=[\"png\"]\n```"]