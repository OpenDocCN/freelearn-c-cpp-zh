- en: Implementing Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现并发
- en: Multitasking is a key feature in almost all operating systems; it increases
    the efficiency of the CPU and utilizes resources in a better manner. Threads are
    the best way to implement multitasking. A process can contain more than one thread
    to implement multitasking.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多任务处理是几乎所有操作系统的关键特性；它提高了 CPU 的效率，并以更好的方式利用资源。线程是实现多任务的最佳方式。一个进程可以包含多个线程以实现多任务。
- en: 'In this chapter, we will cover the following recipes involving threads:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍涉及线程的以下食谱：
- en: Performing a task with a single thread
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个线程执行任务
- en: Performing multiple tasks with multiple threads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个线程执行多个任务
- en: Using `mutex` to share data between two threads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `mutex` 在两个线程之间共享数据
- en: Understanding how a deadlock is created
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解死锁是如何产生的
- en: Avoiding a deadlock
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免死锁
- en: The terms process and thread can be confusing, so first, we'll make sure that
    you understand them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 进程和线程这两个术语可能会令人困惑，所以首先，我们要确保你理解它们。
- en: What are processes and threads?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程和线程是什么？
- en: Whenever we run a program, the moment that it is loaded from the hard disk (or
    any other storage) into the memory, it becomes a process**.** A **process** is
    executed by a processor, and for its execution, it requires a **program counter
    (PC)** to keep track of the next instruction to be executed, the CPU registers,
    the signals, and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们运行一个程序时，当它从硬盘（或任何其他存储）加载到内存中时，它就变成了一个**进程**。**进程**由处理器执行，并且为了执行它，需要一个**程序计数器（PC**）来跟踪下一个要执行的指令，CPU
    寄存器，信号等。
- en: A **thread** refers to a set of instructions within a program that can be executed
    independently. A thread has its own PC and set of registers, among other things.
    In that way, a process is comprised of several threads. Two or more threads can
    share their code, data, and other resources, but special care must be taken when
    sharing resources among threads, as it might lead to ambiguity and deadlock. An
    operating system also manages a thread pool.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程**指的是程序内可以独立执行的指令集。线程有自己的 PC 和一组寄存器，以及其他一些东西。这样，一个进程由多个线程组成。两个或多个线程可以共享它们的代码、数据和其他资源，但在线程之间共享资源时必须格外小心，因为这可能会导致歧义和死锁。操作系统还管理线程池。'
- en: A **thread pool** contains a collection of threads that are waiting for tasks
    to be allocated to them for concurrent execution. Using threads from the thread
    pool instead of instantiating new threads helps to avoid the delay that is caused
    by creating and destroying new threads; hence, it increases the overall performance
    of the application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程池**包含一组等待分配任务以进行并发执行的线程。使用线程池中的线程而不是实例化新线程有助于避免创建和销毁新线程造成的延迟；因此，它提高了应用程序的整体性能。'
- en: Basically, threads enhance the efficiency of an application through parallelism,
    that is, by running two or more independent sets of code simultaneously. This
    is called **multithreading**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，线程通过并行性提高了应用程序的效率，也就是说，通过同时运行两个或更多独立的代码集。这被称为**多线程**。
- en: Multithreading is not supported by C, so to implement it, POSIX threads (`Pthreads`)
    are used. GCC allows for the implementation of a `pthread`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言不支持多线程，因此为了实现它，使用 POSIX 线程（`Pthreads`）。GCC 允许实现一个 `pthread`。
- en: While using a `pthread`, a variable of the type `pthread_t` is defined to store
    the thread identifier. A **thread identifier** is a unique integer, that is ,assigned
    to a thread in the system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `pthread` 时，定义一个 `pthread_t` 类型的变量来存储线程标识符。**线程标识符**是一个唯一的整数，即分配给系统中的线程。
- en: 'You must be wondering which function is used for creating a thread. The `pthread_create`
    function is invoked to create a thread. The following four arguments are passed
    to the `pthread_create` function:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道用于创建线程的函数是哪个。`pthread_create` 函数被调用来创建线程。以下四个参数传递给 `pthread_create` 函数：
- en: A pointer to the thread identifier, which is set by this function
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程标识符的指针，该指针由该函数设置
- en: The attributes of the thread; usually, `NULL` is provided for this argument
    to use the default attributes
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程的属性；通常，为此参数提供 `NULL` 以使用默认属性
- en: The name of the function to execute for the creation of the thread
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行线程创建时要调用的函数的名称
- en: The arguments to be passed to the thread, set to `NULL` if no arguments need
    to be passed to the thread
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要传递给线程的参数，如果不需要传递参数给线程，则设置为 `NULL`
- en: When two or more threads operate on the same data, that is, when they share
    the same resources, certain check measures must be applied so that only one thread
    is allowed to manipulate the shared resource at a time; other threads' access
    must be blocked. One of the methods that helps to avoid ambiguity when a resource
    is shared among threads is mutual exclusion.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多线程操作相同的数据时，即它们共享相同的资源，必须应用某些检查措施，以确保一次只允许一个线程操作共享资源；其他线程的访问必须被阻塞。帮助避免线程间共享资源时歧义的一种方法就是互斥。
- en: Mutual exclusion
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥
- en: To avoid ambiguity when two or more threads access the same resource, **mutual
    exclusion** implements serializing access to the shared resources. When one thread
    is using a resource, no other thread is allowed to access the same resource. All
    of the other threads are blocked from accessing the same resource until the resource
    is free again.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免两个或更多线程访问相同资源时的歧义，**互斥**实现了对共享资源的串行访问。当一个线程正在使用资源时，不允许其他线程访问相同的资源。所有其他线程在资源再次可用之前都被阻止访问相同的资源。
- en: A `mutex` is basically a lock that is associated with the shared resource. To
    read or modify the shared resource, a thread must first acquire the lock for that
    resource. Once a thread acquires a lock (or `mutex`) for that resource, it can
    go ahead with processing that resource. All of the other threads that wish to
    work on it will be compelled to wait until the resource is unlocked. When the
    thread finishes its processing on the shared resource, it unlocks the `mutex`,
    enabling the other waiting threads to acquire a `mutex` for that resource. Aside
    from `mutex`, a semaphore is also used in process synchronization.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`互斥锁`基本上是与共享资源关联的锁。要读取或修改共享资源，线程必须首先获取该资源的锁。一旦线程获取了该资源的锁（或`互斥锁`），它就可以继续处理该资源。所有其他希望对其工作的线程都将被迫等待，直到资源解锁。当线程完成对共享资源的处理时，它将解锁`互斥锁`，使其他等待的线程能够获取该资源的`互斥锁`。除了`互斥锁`之外，信号量也用于进程同步。'
- en: A **semaphore** is a concept that is used to avoid two or more processes from
    accessing a common resource in a concurrent system. It is basically a variable
    that is manipulated to only allow one process to have access to a common resource
    and implement process synchronization. A semaphore uses the signaling mechanism,
    that is, it invokes `wait` and `signal` functions, respectively, to inform that
    the common resource has been acquired or released. A `mutex`, on the other hand,
    uses the locking mechanism—the process has to acquire the lock on the `mutex`
    object before working on the common resource.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号量**是一个用于避免两个或更多进程在并发系统中同时访问公共资源的概念。它基本上是一个变量，通过操作它只允许一个进程访问公共资源并实现进程同步。信号量使用信号机制，即分别调用`wait`和`signal`函数来通知公共资源已被获取或释放。另一方面，`互斥锁`（mutex）使用锁定机制——进程在操作公共资源之前必须获取`mutex`对象的锁。'
- en: Although `mutex` helps to manage shared resources among threads, there is a
    problem. An application of `mutex` in the wrong order may lead to a deadlock.
    A deadlock occurs in a situation when a thread that has `lock X` tries to acquire
    `lock Y` to complete its processing, while another thread that has `lock Y` tries
    to acquire `lock X` to finish its execution. In such a situation, a deadlock will
    occur, as both of the threads will keep waiting indefinitely for the other thread
    to release its lock. As no thread will be able to finish its execution, no thread
    will be able to free up its locks, either. One solution to avoid a deadlock is
    to let threads acquire locks in a specific order.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`互斥锁`有助于管理线程之间的共享资源，但存在一个问题。`互斥锁`使用顺序错误可能导致死锁。死锁发生在这样一个情况下：一个持有`锁X`的线程试图获取`锁Y`以完成其处理，而另一个持有`锁Y`的线程试图获取`锁X`以完成其执行。在这种情况下，将发生死锁，因为两个线程都将无限期地等待对方释放其锁。由于没有线程能够完成其执行，因此没有线程能够释放其锁。避免死锁的一种解决方案是让线程以特定的顺序获取锁。
- en: 'The following functions are used to create and manage threads:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于创建和管理线程：
- en: '`pthread_join`: This function makes the thread wait for the completion of all
    its spawned threads. If it is not used, the thread will exit as soon as it completes
    its task, ignoring the states of its spawned threads. In other words, `pthread_join`
    blocks the calling thread until the thread specified in this function terminates.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_join`：此函数使线程等待所有派生线程的完成。如果不使用它，线程将在完成任务后立即退出，忽略其派生线程的状态。换句话说，`pthread_join`会阻塞调用线程，直到指定函数中的线程终止。'
- en: '`pthread_mutex_init`: This function initializes the `mutex` object with the
    specified attributes. If `NULL` is used for the attributes, the default `mutex`
    attributes are used for initializing the `mutex` object. When the `mutex` is initialized,
    it is in an unlocked state.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_mutex_init`：此函数使用指定的属性初始化`mutex`对象。如果使用`NULL`作为属性，则使用默认的`mutex`属性来初始化`mutex`对象。当`mutex`初始化时，它处于未锁定状态。'
- en: '`pthread_mutex_lock`: This function locks the specified `mutex` object. If
    the `mutex` is already locked by some other thread, the calling thread will get
    suspended, that is, it will be asked to wait until the `mutex` gets unlocked.
    This function returns the `mutex` object in a locked state. The thread that locks
    the `mutex` becomes its owner and remains the owner until it unlocks the `mutex`.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_mutex_lock`：此函数锁定指定的`mutex`对象。如果`mutex`已被其他线程锁定，调用线程将被挂起，即它将被要求等待直到`mutex`解锁。此函数返回一个锁定状态的`mutex`对象。锁定`mutex`的线程成为其所有者，并在解锁`mutex`之前保持所有者状态。'
- en: '`pthread_mutex_unlock`: This function releases the specified `mutex` object.
    The thread that has invoked the `pthread_mutex_lock` function and is waiting for
    the `mutex` to get unlocked will become unblocked and acquire the `mutex` object,
    that is, the waiting thread will be able to access and lock the `mutex` object.
    If there are no threads waiting for the `mutex`, the `mutex` will remain in the
    unlocked state without any owner thread.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_mutex_unlock`：此函数释放指定的`mutex`对象。调用`pthread_mutex_lock`函数并等待`mutex`解锁的线程将变为非阻塞状态并获取`mutex`对象，即等待的线程将能够访问和锁定`mutex`对象。如果没有线程等待`mutex`，则`mutex`将保持未锁定状态，没有任何所有者线程。'
- en: '`pthread_mutex_destroy`: This function destroys a `mutex` object and frees
    up the resources allocated to it. The `mutex` must be in an unlocked state before
    invoking this method.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_mutex_destroy`：此函数销毁`mutex`对象并释放为其分配的资源。在调用此方法之前，`mutex`必须处于未锁定状态。'
- en: Depending on the operating system, a lock may be a **spinlock**. If any thread
    tries to acquire a lock but the lock is not free, a spinlock will make the thread
    wait in a loop until the lock becomes free. Such locks keep the thread busy while
    it's waiting for the lock to free up. They are efficient, as they avoid the consumption
    of time and resources in process rescheduling or context switching.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据操作系统，锁可能是一个**自旋锁**。如果有任何线程尝试获取锁但锁不可用，自旋锁将使线程在一个循环中等待直到锁变为可用。这种锁在等待锁释放时使线程保持忙碌。它们是高效的，因为它们避免了在进程重新调度或上下文切换中消耗时间和资源。
- en: That is enough theory. Now, let's start with some practical examples!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 理论就到这里。现在，让我们从一些实际例子开始！
- en: Performing a task with a single thread
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单个线程执行任务
- en: In this recipe, we will be creating a thread to perform a task. In this task,
    we will display the sequence numbers from `1` to `5`. The focus of this recipe
    is to learn how a thread is created and how the main thread is asked to wait until
    the thread finishes its task.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个线程来执行任务。在这个任务中，我们将显示从`1`到`5`的序列号。这个菜谱的重点是学习如何创建线程以及如何让主线程等待直到线程完成任务完成。
- en: How to do it…
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Define a variable of the type `pthread_t` to store the thread identifier:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`pthread_t`类型的变量来存储线程标识符：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a thread and pass the identifier that was created in the preceding step
    to the `pthread_create` function. The thread is created with the default attributes.
    Also, specify a function that needs to be executed to create the thread:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个线程并将前一步创建的标识符传递给`pthread_create`函数。线程使用默认属性创建。还要指定需要执行以创建线程的函数：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the function, you will be displaying a text message to indicate that the
    thread has been created and is running:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数中，你将显示一条文本消息来指示线程已被创建并正在运行：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Invoke a `for` loop to display the sequence of numbers from `1` to `5` through
    the running thread:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行线程调用一个`for`循环来显示从`1`到`5`的数字序列：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Invoke the `pthread_join` method in the main function to make the `main` method
    wait until the thread completes its task:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中调用 `pthread_join` 方法，使 `main` 方法等待直到线程完成任务：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `createthread.c` program for creating a thread and making it perform a
    task is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程并使其执行任务的 `createthread.c` 程序如下：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let's go behind the scenes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们幕后看看。
- en: How it works...
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We will define a variable called `tid` of the type `pthread_t` to store the
    thread identifier. A **thread identifier** is a unique integer, that is, assigned
    to a thread in the system. Before creating a thread, the message `In main function`
    is displayed on the screen. We will create a thread and pass the identifier `tid`
    to the `pthread_create` function. The thread is created with the default attributes,
    and the `runThread` function is set to execute to create the thread.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个名为 `tid` 的变量，其类型为 `pthread_t`，用于存储线程标识符。**线程标识符**是一个唯一的整数，即分配给系统中的线程。在创建线程之前，屏幕上会显示消息
    `In main function`。我们将创建一个线程并将标识符 `tid` 传递给 `pthread_create` 函数。线程将以默认属性创建，并将
    `runThread` 函数设置为执行以创建线程。
- en: In the `runThread` function, we will display the text message `Running Thread`
    to indicate that the thread was created and is running. We will invoke a `for`
    loop to display the sequence of numbers from `1` to `5` through the running thread.
    By invoking the `pthread_join` method, we will make the `main` method wait until
    the thread completes its task. It is essential to invoke the `pthread_join` here;
    otherwise, the `main` method will exit without waiting for the completion of the
    thread.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `runThread` 函数中，我们将显示文本消息 `Running Thread` 以指示线程已被创建并正在运行。我们将调用一个 `for` 循环，通过正在运行的线程显示从
    `1` 到 `5` 的数字序列。通过调用 `pthread_join` 方法，我们将使 `main` 方法等待直到线程完成任务。在这里调用 `pthread_join`
    是至关重要的；否则，`main` 方法将在等待线程完成之前退出。
- en: 'Let''s use GCC to compile the `createthread.c` program, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `createthread.c` 程序，如下所示：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you get no errors or warnings, that means the `createthread.c` program has
    been compiled into an executable file, `createthread.exe`. Let''s run this executable
    file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误或警告，这意味着 `createthread.c` 程序已经被编译成可执行文件，名为 `createthread.exe`。让我们运行这个可执行文件：
- en: '![](img/4c19d107-dacb-457d-8c0f-9d9b6707d47b.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c19d107-dacb-457d-8c0f-9d9b6707d47b.png)'
- en: Figure 7.1
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1
- en: Voila! We've successfully completed a task with a single thread. Now, let's
    move on to the next recipe!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用单个线程完成了一个任务。现在，让我们继续下一个菜谱！
- en: Performing multiple tasks with multiple threads
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个线程执行多个任务
- en: In this recipe, you will learn how to multitask by executing two threads in
    parallel. Both of the threads will do their tasks independently. As the two threads
    will not be sharing a resource, there will not be a situation of race condition
    or ambiguity. The CPU will execute any thread randomly at a time, but finally,
    both of the threads will finish the assigned task. The task that the two threads
    will perform is displaying the sequence of numbers from `1` to `5`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何通过并行执行两个线程来实现多任务处理。这两个线程将独立执行它们各自的任务。由于两个线程不会共享资源，因此不会出现竞争条件或歧义的情况。CPU
    将随机执行任何线程，但最终，两个线程都将完成分配的任务。这两个线程将执行的任务是显示从 `1` 到 `5` 的数字序列。
- en: How to do it…
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Define two variables of the type `pthread_t` to store two thread identifiers:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个类型为 `pthread_t` 的变量来存储两个线程标识符：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Invoke the `pthread_create` function twice to create two threads, and assign
    the identifiers that we created in the previous step. The two threads are created
    with the default attributes. Specify two respective functions that need to be
    executed for the two threads:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `pthread_create` 函数两次以创建两个线程，并分配我们在上一步中创建的标识符。这两个线程将以默认属性创建。指定两个线程各自需要执行的两个相应函数：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the function of the first thread, display a text message to indicate that
    the first thread was created and is running:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个线程的函数中，显示一条文本消息以指示第一个线程已被创建并正在运行：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To indicate the execution of the first thread, execute a `for` loop in the
    first function to display the sequence of numbers from `1` to `5`. To distinguish
    from the second thread, the sequence of numbers that were generated by the first
    thread are prefixed by `Thread 1`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了指示第一个线程的执行，在第一个函数中执行一个 `for` 循环以显示从 `1` 到 `5` 的数字序列。为了与第二个线程区分开来，第一个线程生成的数字序列前面会加上前缀
    `Thread 1`：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, in the second thread, display a text message to inform that the
    second thread has also been created and is running:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，在第二个线程中，显示一条文本消息以告知第二个线程也被创建并正在运行：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Again, in the second function, execute a `for` loop to display the sequence
    of numbers from `1` to `5`. To differentiate these numbers from the ones generated
    by `thread1`, this sequence of numbers will be preceded by the text `Thread 2`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，在第二个函数中，执行一个 `for` 循环以显示从 `1` 到 `5` 的数字序列。为了区分这些数字与 `thread1` 生成的数字，这个数字序列将前面加上文本
    `Thread 2`：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Invoke the `pthread_join` twice, and pass the thread identifiers we created
    in step 1 to it. `pthread_join` will make the two threads, and the `main` method
    will wait until both of the threads have completed their tasks:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两次调用 `pthread_join`，并将我们在第一步中创建的线程标识符传递给它。`pthread_join` 将使两个线程，并且 `main` 方法将等待直到两个线程都完成了它们的工作：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When both of the threads are finished, a text message will be displayed to
    confirm this:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当两个线程都完成后，将显示一条文本消息以确认这一点：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `twothreads.c` program for creating two threads and making them work on
    independent resources is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个线程并使它们在独立资源上工作的 `twothreads.c` 程序如下：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, let's go behind the scenes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will define two variables of the type `pthread_t`, by the names `tid1` and
    `tid2`, to store two thread identifiers. These thread identifiers uniquely represent
    the threads in the system. We will invoke the `pthread_create` function twice
    to create two threads and assign their identifiers to the two variables `tid1`
    and `tid2`, whose addresses are passed to the `pthread_create` function.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义两个类型为 `pthread_t` 的变量，分别命名为 `tid1` 和 `tid2`，以存储两个线程标识符。这些线程标识符唯一地表示系统中的线程。我们将两次调用
    `pthread_create` 函数来创建两个线程，并将它们的标识符分配给两个变量 `tid1` 和 `tid2`，其地址传递给 `pthread_create`
    函数。
- en: The two threads are created with the default attributes. We will execute the
    function `runThread1` to create the first thread, and then the `runThread2` function
    to create the second thread.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 两个线程使用默认属性创建。我们将执行 `runThread1` 函数来创建第一个线程，然后执行 `runThread2` 函数来创建第二个线程。
- en: In the `runThread1` function, we will display the message `Running Thread 1`
    to indicate that the first thread was created and is running. In addition, we
    will invoke a `for` loop to display the sequence of numbers from `1` to `5` through
    the running thread. The sequence of numbers that are generated by the first thread
    will be prefixed by `Thread 1`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `runThread1` 函数中，我们将显示消息 `Running Thread 1` 以指示第一个线程已被创建并正在运行。此外，我们将通过运行线程显示从
    `1` 到 `5` 的数字序列。第一个线程生成的数字序列将前面加上 `Thread 1`。
- en: Similarly, in the `runThread2` function, we will display the message `Running
    Thread 2` to inform that the second thread was also created and is running. Again,
    we will invoke a `for` loop to display the sequence of numbers from `1` to `5`.
    To differentiate these numbers from the ones generated by `thread1`, these numbers
    are preceded by the text `Thread 2`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在 `runThread2` 函数中，我们将显示消息 `Running Thread 2` 以告知第二个线程也被创建并正在运行。再次，我们将调用一个
    `for` 循环以显示从 `1` 到 `5` 的数字序列。为了区分这些数字与 `thread1` 生成的数字，这些数字前面将加上文本 `Thread 2`。
- en: We will then invoke the `pthread_join` method twice and pass our two thread
    identifiers, `tid1` and `tid2`, to it. The `pthread_join` is invoked to make the
    two threads, and the `main` method waits until both of the threads have completed
    their respective tasks. When both of the threads are over, that is, when the functions
    `runThread1` and `runThread2` are over, a message saying that `Both threads are
    over` will be displayed in the `main` function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将两次调用 `pthread_join` 方法，并将我们的两个线程标识符 `tid1` 和 `tid2` 传递给它。`pthread_join`
    被调用以使两个线程，并且 `main` 方法等待直到两个线程都完成了它们各自的任务。当两个线程都结束时，即当 `runThread1` 和 `runThread2`
    函数结束时，`main` 函数中将显示一条消息，说明 `Both threads are over`。
- en: 'Let''s use GCC to compile the `twothreads.c` program, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `twothreads.c` 程序，如下所示：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you get no errors or warnings, that means the `twothreads.c` program has
    been compiled into an executable file, `twothreads.exe`. Let''s run this executable
    file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着 `twothreads.c` 程序已被编译成可执行文件，`twothreads.exe`。让我们运行这个可执行文件：
- en: '![](img/e72aa2af-42d0-43b3-a563-eb6f2e637a93.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e72aa2af-42d0-43b3-a563-eb6f2e637a93.png)'
- en: Figure 7.2
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2
- en: You may not get exactly the same output, as it depends on the CPU, but it is
    certain that both threads will exit simultaneously.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不会得到完全相同的输出，因为这取决于CPU，但可以确定的是，两个线程将同时退出。
- en: Voila! We've successfully completed multiple tasks with multiple threads. Now,
    let's move on to the next recipe!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用多个线程完成了多个任务。现在，让我们继续下一个菜谱！
- en: Using mutex to share data between two threads
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用互斥锁在两个线程之间共享数据
- en: Running two or more threads independently, where each accesses its own resources,
    is quite convenient. However, sometimes, we want the threads to share and process
    the same resource simultaneously so that we can finish a task faster. Sharing
    a common resource may lead to problems, as one thread might read the data before
    the other thread writes the updated data, leading to an ambiguous situation. To
    avoid such a situation, `mutex` is used. In this recipe, you will learn how to
    share common resources between two threads.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 独立运行两个或更多线程，其中每个线程访问其自己的资源，相当方便。然而，有时我们希望线程能够同时共享和处理相同的资源，以便我们可以更快地完成任务。共享公共资源可能会导致问题，因为一个线程可能会在另一个线程写入更新数据之前读取数据，导致模糊的情况。为了避免这种情况，使用`mutex`。在本菜谱中，您将学习如何在两个线程之间共享公共资源。
- en: How to do it…
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Define two variables of the `pthread_t` type to store two thread identifiers.
    Also, define a `mutex` object:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个`pthread_t`类型的变量来存储两个线程标识符。同时定义一个`mutex`对象：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Invoke the `pthread_mutex_init` method to initialize the `mutex` object with
    the default `mutex` attributes:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`pthread_mutex_init`方法使用默认的`mutex`属性初始化`mutex`对象：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Invoke the `pthread_create` function twice to create two threads, and assign
    the identifiers that we created in step 1\. Execute a function for creating the
    two threads:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`pthread_create`函数两次以创建两个线程，并分配我们在第一步中创建的标识符。执行创建两个线程的函数：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the function, the `pthread_mutex_lock` method is invoked and the `mutex`
    object is passed to it to lock it:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数中，调用`pthread_mutex_lock`方法并将`mutex`对象传递给它以锁定：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Invoke the `pthread_self` method and assign the ID of the calling thread to
    a variable of the `pthread_t` type. Invoke the `pthread_equal` method and compare
    it with the variable to find out which thread is currently executing. If the first
    thread is being executed, display the message `First thread is running` on the
    screen:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`pthread_self`方法并将调用线程的ID分配给`pthread_t`类型的变量。调用`pthread_equal`方法并将其与变量比较以找出当前正在执行的线程。如果正在执行第一个线程，则在屏幕上显示消息`First
    thread is running`：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To indicate that the thread is executing a common resource, display the text
    message `Processing the common resource` on the screen:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了表明线程正在执行公共资源，在屏幕上显示文本消息`Processing the common resource`：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Invoke the `sleep` method to make the first thread sleep for `5` seconds:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`sleep`方法使第一个线程休眠`5`秒：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After a duration of `5` seconds, display the message `First thread is over`
    on the screen:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过`5`秒的持续时间后，在屏幕上显示消息`First thread is over`：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `pthread_mutex_unlock` function will be invoked, and the `mutex` object
    that we created in the first step will be passed to it to unlock it:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将调用`pthread_mutex_unlock`函数，并将我们在第一步中创建的`mutex`对象传递给它以解锁：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `thread` function will be invoked by the second thread. Lock the `mutex`
    object again:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`thread`函数将由第二个线程调用。再次锁定`mutex`对象：'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To indicate that the second thread is running at the moment, display the message
    `Second thread is running` on the screen:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了表明此时正在运行第二个线程，在屏幕上显示消息`Second thread is running`：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Again, to indicate that the common resource is being accessed by the thread,
    display the message `Processing the common resource` on the screen:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，为了表明线程正在访问公共资源，在屏幕上显示消息`Processing the common resource`：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Introduce a delay of `5` seconds. Then, display the message `second thread
    is over` on the screen:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入`5`秒的延迟。然后，在屏幕上显示消息`second thread is over`：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Unlock the `mutex` object:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解锁`mutex`对象：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Invoke the `pthread_join` method twice and pass the thread identifiers to it:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`pthread_join`方法两次，并将线程标识符传递给它：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Invoke the `pthread_mutex_destroy` method to destroy the `mutex` object:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`pthread_mutex_destroy`方法以销毁`mutex`对象：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `twothreadsmutex.c` program for creating two threads that share common
    resources is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个线程以共享公共资源的`twothreadsmutex.c`程序如下：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, let's go behind the scenes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will first define a `mutex` object by the name `lock`. Recall that a `mutex`
    is basically a lock associated with a shared resource. To read or modify the shared
    resource, a thread needs to first acquire the lock for that resource. We will
    define two variables of the `pthread_t` type , with the names `tid1` and `tid2`,
    to store two thread identifiers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过名称`lock`定义一个`mutex`对象。回想一下，`mutex`基本上是与共享资源相关联的锁。要读取或修改共享资源，线程需要首先获取该资源的锁。我们将定义两个`pthread_t`类型的变量，分别命名为`tid1`和`tid2`，以存储两个线程标识符。
- en: We will invoke the `pthread_mutex_init` method that initializes the `lock` object
    with the default `mutex` attributes. When it's initialized, the `lock` object
    is in an unlocked state. We then invoke the `pthread_create` function twice to
    create two threads and assign their identifiers to the two variables `tid1` and
    `tid2`, whose addresses are passed to the `pthread_create` function. The two threads
    are created with the default attributes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`pthread_mutex_init`方法，用默认的`mutex`属性初始化`lock`对象。初始化后，`lock`对象处于未锁定状态。然后，我们将两次调用`pthread_create`函数来创建两个线程并将它们的标识符分配给两个变量`tid1`和`tid2`，其地址传递给`pthread_create`函数。两个线程以默认属性创建。
- en: Next, we will execute the `runThread` function to create the two threads. In
    the `runThread` function, we will invoke the `pthread_mutex_lock` method and pass
    the `mutex` object `lock` to it to lock it. Now, the rest of the threads (if any)
    will be asked to wait until the `mutex` object `lock` is unlocked. We will invoke
    the `pthread_self` method and assign the ID of the calling thread to the variable
    `id` of the `pthread_t` type. We will then invoke the `pthread_equal` method to
    ensure that if the calling thread is the one with the identifier assigned to the
    `tid1` variable, then the message `First thread is running` will display on the
    screen.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将执行`runThread`函数以创建两个线程。在`runThread`函数中，我们将调用`pthread_mutex_lock`方法并将`mutex`对象`lock`传递给它以锁定它。现在，其余的线程（如果有）将被要求等待，直到`mutex`对象`lock`被解锁。我们将调用`pthread_self`方法并将调用线程的ID赋值给`pthread_t`类型的变量`id`。然后，我们将调用`pthread_equal`方法以确保如果调用线程是分配给`tid1`变量的标识符的线程，则屏幕上会显示消息`First
    thread is running`。
- en: Next, the message `Processing the common resource` is displayed on the screen.
    We will invoke the `sleep` method to make the first thread sleep for `5` seconds.
    After a duration of `5` seconds, the message `First thread is over` will be displayed
    on the screen to indicate that the first thread is over. We will then invoke `pthread_mutex_unlock`
    and pass the `mutex` object `lock` to it to unlock it. Unlocking the `mutex` object
    is an indication to the other threads that the common resource can be used by
    other threads, too.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，屏幕上显示消息`Processing the common resource`。我们将调用`sleep`方法使第一个线程休眠`5`秒。经过`5`秒的持续时间后，屏幕上会显示消息`First
    thread is over`，以指示第一个线程已完成。然后，我们将调用`pthread_mutex_unlock`并将`mutex`对象`lock`传递给它以解锁它。解锁`mutex`对象是向其他线程发出信号，表明其他线程也可以使用公共资源。
- en: The `runThread` method will be invoked by the second thread, with the identifier
    `tid2`. Again, the `mutex` object `lock` is locked, and the `id` of the calling
    thread, that is, the second thread, is assigned to the variable `id`. The message
    `Second thread is running` is displayed on the screen, followed by the message
    `Processing the common resource`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`runThread`方法将由第二个线程调用，其标识符为`tid2`。同样，`mutex`对象`lock`被锁定，调用线程的`id`，即第二个线程，被分配给变量`id`。屏幕上显示消息`Second
    thread is running`，随后显示消息`Processing the common resource`。'
- en: We will introduce a delay of `5` seconds to indicate that the second thread
    is processing the common resource. Then, the message `second thread is over` will
    be displayed on the screen. The `mutex` object `lock` is now unlocked. We will
    invoke the `pthread_join` method twice and pass the `tid1` and `tid2` thread identifiers
    to it. `pthread_join` is invoked to make the two threads and the `main` method
    wait until both of the threads have completed their tasks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引入`5`秒的延迟以指示第二个线程正在处理公共资源。然后，屏幕上显示消息`second thread is over`。此时，`mutex`对象`lock`已解锁。我们将两次调用`pthread_join`方法并将线程标识符`tid1`和`tid2`传递给它。`pthread_join`被调用以使两个线程和`main`方法等待，直到两个线程都完成其任务。
- en: When both of the threads are over, we will invoke the `pthread_mutex_destroy`
    method to destroy the `mutex` object `lock` and free up the resources allocated
    to it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个线程都完成后，我们将调用`pthread_mutex_destroy`方法来销毁`mutex`对象`lock`并释放为其分配的资源。
- en: 'Let''s use GCC to compile the `twothreadsmutex.c` program, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`twothreadsmutex.c`程序，如下所示：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you get no errors or warnings, that means the `twothreadsmutex.c` program
    has been compiled into an executable file, `twothreadsmutex.exe`. Let''s run this
    executable file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着`twothreadsmutex.c`程序已被编译成可执行文件，`twothreadsmutex.exe`。让我们运行这个可执行文件：
- en: '![](img/17df3986-cbaa-4581-968a-aebfb505d087.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17df3986-cbaa-4581-968a-aebfb505d087.png)'
- en: Figure 7.3
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3
- en: Voila! We've successfully used `mutex` to share data between two threads. Now,
    let's move on to the next recipe!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功使用`mutex`在两个线程之间共享数据。现在，让我们继续下一个菜谱！
- en: Understanding how a deadlock is created
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解死锁是如何产生的
- en: 'Locking a resource helps in non-ambiguous results, but locking can also lead
    to a deadlock. A **deadlock** is a situation wherein a thread has acquired the
    lock for one resource and wants to acquire the lock for a second resource. However,
    at the same time, another thread has acquired the lock for the second resource,
    but wants the lock for the first resource. Because the first thread will keep
    waiting for the second resource lock to be free and the second thread will keep
    waiting for the first resource lock to be free, the threads will not be able to
    proceed further, and the application will hang (as the following diagram illustrates):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定资源有助于得到非歧义的结果，但锁定也可能导致死锁。**死锁**是一种情况，其中线程已经获取了一个资源的锁，并希望获取第二个资源的锁。然而，同时，另一个线程已经获取了第二个资源的锁，但希望获取第一个资源的锁。因为第一个线程将一直等待第二个资源锁变为空闲，而第二个线程将一直等待第一个资源锁变为空闲，所以线程将无法进一步进行，应用程序将挂起（如下面的图所示）：
- en: '![](img/f3542d0c-6feb-4768-b80a-67a05effcdb3.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f3542d0c-6feb-4768-b80a-67a05effcdb3.png)'
- en: Figure 7.4
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4
- en: In this recipe, we will use a stack. A stack requires two operations—`push`
    and `pop`. To make only one thread execute a `push` or `pop` operation at a time,
    we will use two `mutex` objects—`pop_mutex` and `push_mutex`. The thread needs
    to acquire locks on both of the objects to operate on the stack. To create a situation
    of deadlock, we will make a thread acquire one lock and ask it to acquire another
    lock, which was already acquired by another thread.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用栈。栈需要两个操作——`push`和`pop`。为了确保一次只有一个线程执行`push`或`pop`操作，我们将使用两个`mutex`对象——`pop_mutex`和`push_mutex`。线程需要在两个对象上获取锁才能操作栈。为了创建死锁的情况，我们将使一个线程获取一个锁，并要求它获取另一个已经被另一个线程获取的锁。
- en: How to do it…
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Define a macro of the value `10`, and define an array of an equal size:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个值为`10`的宏，并定义一个大小相等的数组：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define two `mutex` objects; one will be used while popping from the stack (`pop_mutex`),
    and the other will be used while pushing a value to the stack (`push_mutex`):'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个`mutex`对象；一个将用于从栈中弹出（`pop_mutex`），另一个将用于将值推送到栈中（`push_mutex`）：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To use the `stack`, initialize the value of `top` to `-1`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`stack`，将`top`的值初始化为`-1`：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Define two variables of the type `pthread_t` to store two thread identifiers:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个类型为`pthread_t`的变量来存储两个线程标识符：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Invoke the `pthread_create` function to create the first thread; the thread
    will be created with the default attributes. Execute the `push` function to create
    this thread:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`pthread_create`函数创建第一个线程；该线程将以默认属性创建。执行`push`函数以创建此线程：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Invoke the `pthread_create` function again to create the second thread; this
    thread will also be created with the default attributes. Execute the `pop` function
    to create this thread:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次调用`pthread_create`函数以创建第二个线程；此线程也将以默认属性创建。执行`pop`函数以创建此线程：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `push` function, invoke the `pthread_mutex_lock` method and pass the
    `mutex` object for the `push` operation (`push_mutex`) to lock it:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`push`函数中，调用`pthread_mutex_lock`方法并传递用于`push`操作的`mutex`对象（`push_mutex`）以锁定它：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, the `mutex` object for the `pop` operation (`pop_mutex`) will be locked
    by the first thread:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`pop`操作的`mutex`对象（`pop_mutex`）将被第一个线程锁定：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The user is asked to enter the value to be pushed to the `stack`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户被要求输入要推送到`stack`的值：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The value of `top` is incremented to `0`. The value that was entered in the
    previous step is pushed to the location `stack[0]`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`top`的值递增到`0`。上一步输入的值被推送到`stack[0]`的位置：'
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Invoke `pthread_mutex_unlock` and unlock the `mutex` objects meant for the
    `pop` (`pop_mutex`) and `push` operations (`push_mutex`):'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`pthread_mutex_unlock`并解锁用于`pop`（`pop_mutex`）和`push`操作（`push_mutex`）的`mutex`对象：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'At the bottom of the `push` function, display a text message indicating that
    the value is pushed to the stack:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`push`函数的底部，显示一条文本消息，表明值已推入栈中：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the `pop` function, invoke the `pthread_mutex_lock` function to lock the
    `mutex` object `pop_mutex`. It will lead to a deadlock:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pop`函数中，调用`pthread_mutex_lock`函数来锁定`mutex`对象`pop_mutex`。这将导致死锁：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Again, try to lock the `push_mutex` object, too (although it is not possible,
    as it is always acquired by the first thread):'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次尝试锁定`push_mutex`对象，尽管这是不可能的，因为它总是被第一个线程获取：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The value in the stack, that is, pointed to by the `top` pointer is popped:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 栈中的值，即由`top`指针指向的值将被弹出：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Thereafter, the value of `top` is decremented by `1` to make it `-1` again.
    The value, that, is, popped from the stack is displayed on the screen:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此后，`top`的值将减`1`以再次使其为`-1`。从栈中弹出的值将在屏幕上显示：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, unlock the `mutex` object `push_mutex` and the `pop_mutex` object:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，解锁`mutex`对象`push_mutex`和`pop_mutex`对象：
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the `main` function, invoke the `pthread_join` method and pass the thread
    identifiers that were created in step 1 to it:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中，调用`pthread_join`方法并将步骤1中创建的线程标识符传递给它：
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `deadlockstate.c` program for creating two threads and understanding how
    a deadlock occurs while acquiring locks is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个线程并理解在获取锁时如何发生死锁的`deadlockstate.c`程序如下：
- en: '[PRE53]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, let's go behind the scenes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后。
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will first define a macro called `max` of the value `10`, along with an array
    stack of the size `max`. Then, we will define two `mutex` objects with the names
    `pop_mutex` and `push_mutex`. To use the `stack`, we will initialize the value
    of `top` to `-1`. We will also define two variables of the type `pthread_t`, with
    the names `tid1` and `tid2`, to store two thread identifiers.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个名为`max`的值为`10`的宏，以及一个大小为`max`的数组`stack`。然后，我们将定义两个名为`pop_mutex`和`push_mutex`的`mutex`对象。为了使用`stack`，我们将`top`的值初始化为`-1`。我们还将定义两个类型为`pthread_t`的变量，分别命名为`tid1`和`tid2`，以存储两个线程标识符。
- en: We will invoke the `pthread_create` function to create the first thread, and
    we will assign the identifier returned by the function to the variable `tid1`.
    The thread will be created with the default attributes, and we will execute the
    `push` function to create this thread.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`pthread_create`函数来创建第一个线程，并将函数返回的标识符赋值给变量`tid1`。线程将以默认属性创建，我们将执行`push`函数来创建这个线程。
- en: We will invoke the `pthread_create` function again to create the second thread,
    and we will assign the identifier returned by the function to the variable `tid2`.
    This thread is also created with the default attributes, and we will execute the
    `pop` function to create this thread. On the screen, we will display the message
    `Both threads are created`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次调用`pthread_create`函数来创建第二个线程，并将函数返回的标识符赋值给变量`tid2`。这个线程也将以默认属性创建，我们将执行`pop`函数来创建这个线程。在屏幕上，我们将显示消息`Both
    threads are created`。
- en: In the `push` function, we will invoke the `pthread_mutex_lock` method and pass
    the `mutex` object `push_mutex` to it to lock it. Now, if any other thread asks
    for the `push_mutex` object, it will need to wait until the object is unlocked.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`push`函数中，我们将调用`pthread_mutex_lock`方法并将`mutex`对象`push_mutex`传递给它以锁定它。现在，如果任何其他线程请求`push_mutex`对象，它将需要等待直到对象解锁。
- en: Then, the `mutex` object `pop_mutex` will be locked by the first thread. We
    will be asked to enter the value to be pushed to the stack. The entered value
    will be assigned to the variable `n`. The value of `top` will be incremented to
    `0`. The value that we enter will be pushed to the location `stack[0]`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`mutex`对象`pop_mutex`将被第一个线程锁定。我们将被要求输入要推入栈中的值。输入的值将被分配给变量`n`。`top`的值将增加至`0`。我们输入的值将被推入`stack[0]`的位置。
- en: Next, we will invoke the `pthread_mutex_unlock` and pass the `mutex` object
    `pop_mutex` to it to unlock it. Also, the `mutex` object `push_mutex` will be
    unlocked. At the bottom of the `push` function, we will display the message `Value
    is pushed to stack`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调用`pthread_mutex_unlock`并将`mutex`对象`pop_mutex`传递给它以解锁它。同时，`mutex`对象`push_mutex`也将被解锁。在`push`函数的底部，我们将显示消息`Value
    is pushed to stack`。
- en: In the `pop` function, the `mutex` object `pop_mutex` will be locked, and then
    it will try to lock the `push_mutex` object that is already locked by first thread.
    The value in the stack, that is, pointed at by the pointer `top` will be popped.
    Because the value of `top` is `0`, the value at the `stack[0]` location will be
    picked up and assigned to the variable `k`. Thereafter, the value of `top` will
    decrement by `1` to make it `-1` again. The value, that is, popped from the stack
    will be displayed on the screen. Then, the `mutex` object `push_mutex` will be
    unlocked, followed by unlocking the `pop_mutex` object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pop`函数中，`mutex`对象`pop_mutex`将被锁定，然后它将尝试锁定已被第一个线程锁定的`push_mutex`对象。栈中的值，即由指针`top`指向的值将被弹出。因为`top`的值是`0`，所以`stack[0]`位置的值将被取出并分配给变量`k`。之后，`top`的值将减`1`，再次变为`-1`。从栈中弹出的值将在屏幕上显示。然后，将`mutex`对象`push_mutex`解锁，随后解锁`pop_mutex`对象。
- en: In the `main` function, we will invoke the `pthread_join` method twice and pass
    the `tid1` and `tid2` thread identifiers to it. The reason that we invoke the
    `pthread_join` method is to make the two threads and the `main` method wait until
    both of the threads have completed their tasks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们将调用`pthread_join`方法两次，并将线程标识符`tid1`和`tid2`传递给它。我们调用`pthread_join`方法的原因是使两个线程和`main`方法等待，直到两个线程都完成了它们的工作。
- en: In this program, a deadlock has occurred because in the `push` function, the
    first thread locked the `push_mutex` object and tried to get the lock of the `pop_mutex`
    object, which was already locked by the second thread in the `pop` function. In
    the `pop` function, the thread locked the `mutex` object `pop_mutex` and tried
    to lock the `push_mutex` object, which was already locked by the first thread.
    So, neither of the threads will be able to finish, and they will keep waiting
    indefinitely for the other thread to release its `mutex` object.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，发生了死锁，因为在`push`函数中，第一个线程锁定了`push_mutex`对象并试图获取`pop_mutex`对象的锁，该锁已被第二个线程在`pop`函数中锁定。在`pop`函数中，线程锁定了`mutex`对象`pop_mutex`并试图锁定已被第一个线程锁定的`push_mutex`对象。因此，两个线程中的任何一个都无法完成，它们将无限期地等待另一个线程释放其`mutex`对象。
- en: 'Let''s use GCC to compile the `deadlockstate.c` program, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用GCC编译`deadlockstate.c`程序，如下所示：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you get no errors or warnings, that means the `deadlockstate.c` program
    is compiled into an executable file, `deadlockstate.exe`. Let''s run this executable
    file:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有错误或警告，这意味着`deadlockstate.c`程序已编译成可执行文件，`deadlockstate.exe`。让我们运行这个可执行文件：
- en: '![](img/17247657-f6cd-4575-9d95-2d2be526e873.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/17247657-f6cd-4575-9d95-2d2be526e873.png)'
- en: Figure 7.5
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5
- en: You've now seen how a deadlock can occur. Now, let's move on to the next recipe!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经看到了死锁是如何发生的。现在，让我们继续下一个菜谱！
- en: Avoiding a deadlock
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免死锁
- en: A deadlock can be avoided if the threads are allowed to acquire the locks in
    a sequence. Let's suppose that a thread acquires the lock for a resource and wants
    to acquire the lock for a second resource. Any other thread that tries to acquire
    the first lock will be asked to wait, as it was already acquired by the first
    thread. Therefore, the second thread will not be able to acquire the lock for
    the second resource either, since it can only acquire locks in a sequence. However,
    our first thread will be allowed to acquire the lock to the second resource without
    waiting.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许线程按顺序获取锁，则可以避免死锁。假设一个线程获取了一个资源的锁，并想要获取第二个资源的锁。任何试图获取第一个锁的其他线程将被要求等待，因为它已经被第一个线程获取了。因此，第二个线程也无法获取第二个资源的锁，因为它只能按顺序获取锁。然而，我们的第一个线程将被允许获取第二个资源的锁，而无需等待。
- en: Applying a sequence to the locking of resources is the same as allowing only
    one thread to acquire resources at a time. The other threads will only be able
    to acquire the resources after the previous thread is over. This way, we will
    not have a deadlock on our hands.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将顺序应用于资源锁定与只允许一个线程一次获取资源相同。其他线程只能在之前的线程完成后才能获取资源。这样，我们手中就不会有死锁了。
- en: How to do it…
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Define an array of `10` elements:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含`10`个元素的数组：
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Define two `mutex` objects—one to indicate the `pop` operation of the stack
    (`pop_mutex`), and another to represent the `push` operation of the stack (`push_mutex`):'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个`mutex`对象——一个用于表示栈的`pop`操作（`pop_mutex`），另一个用于表示栈的`push`操作（`push_mutex`）：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To use the `stack`, the value of `top` is initialized to `-1`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用栈，`top`的值被初始化为`-1`：
- en: '[PRE57]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Define two variables of the type `pthread_t`, to store two thread identifiers:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个类型为 `pthread_t` 的变量，以存储两个线程标识符：
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Invoke the `pthread_create` function to create the first thread. The thread
    is created with the default attributes, and the `push` function is executed to
    create the thread:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `pthread_create` 函数以创建第一个线程。该线程使用默认属性创建，并执行 `push` 函数以创建线程：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Invoke the `pthread_create` function again to create the second thread. The
    thread is created with the default attributes, and the `pop` function is executed
    to create this thread:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次调用 `pthread_create` 函数以创建第二个线程。该线程使用默认属性创建，并执行 `pop` 函数以创建此线程：
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To indicate that the two threads were created, display the message `Both threads
    are created`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了指示已创建了两个线程，显示消息 `Both threads are created`：
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the `push` function, invoke the `pthread_mutex_lock` method and pass the
    `mutex` object `push_mutex`, related to the `push` operation, to it, in order
    to lock it:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `push` 函数中，调用 `pthread_mutex_lock` 方法并将与 `push` 操作相关的 `mutex` 对象 `push_mutex`
    传递给它，以锁定它：
- en: '[PRE62]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'After a sleep of `2` seconds, the `mutex` object, that is, meant to invoke
    the `pop` operation `pop_mutex` will be locked by the first thread:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `2` 秒的睡眠之后，第一个线程将锁定用于执行 `pop` 操作的 `mutex` 对象 `pop_mutex`：
- en: '[PRE63]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Enter the value to be pushed to the stack:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入要推入栈中的值：
- en: '[PRE64]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The value of `top` is incremented to `0`. To `stack[0]` location, the value,
    that is, entered by the user is pushed:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`top` 的值增加至 `0`。将用户输入的值推入 `stack[0]` 位置：'
- en: '[PRE65]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Invoke `pthread_mutex_unlock` and pass the `mutex` object `pop_mutex` to it
    to unlock it. Also, the `mutex` object `push_mutex` will be unlocked:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `pthread_mutex_unlock` 并将 `mutex` 对象 `pop_mutex` 传递给它以解锁它。此外，`mutex` 对象 `push_mutex`
    也将被解锁：
- en: '[PRE66]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'At the bottom of the `push` function, display the message `Value is pushed
    to stack`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `push` 函数的底部，显示消息 `Value is pushed to stack`：
- en: '[PRE67]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the `pop` function, the `pthread_mutex_lock` function is invoked to lock
    the `mutex` object `push_mutex`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `pop` 函数中，调用 `pthread_mutex_lock` 函数以锁定 `mutex` 对象 `push_mutex`：
- en: '[PRE68]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'After a sleep (or delay) of `5` seconds, the `pop` function will try to lock
    the `pop_mutex` object, too. However, the `pthread_mutex_lock` function will not
    be invoked, as the thread is kept waiting for the `push_mutex` object to be unlocked:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `5` 秒的睡眠（或延迟）之后，`pop` 函数将尝试锁定 `pop_mutex` 对象。然而，由于线程正在等待 `push_mutex` 对象解锁，因此不会调用
    `pthread_mutex_lock` 函数：
- en: '[PRE69]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The value in the stack pointed to by the pointer `top` is popped. Because the
    value of `top` is `0`, the value at the location `stack[0]` is picked up:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由指针 `top` 指向的栈中的值被弹出。因为 `top` 的值为 `0`，所以从 `stack[0]` 位置取出的值：
- en: '[PRE70]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Thereafter, the value of `top` will be decremented by `1` to make it `-1` again.
    The value, that is, popped from the stack will be displayed on the screen:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此后，`top` 的值将减 `1` 以再次变为 `-1`。从栈中弹出的值将在屏幕上显示：
- en: '[PRE71]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Then, the `mutex` object `pop_mutex` will be unlocked, followed by the `push_mutex`
    object:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将 `mutex` 对象 `pop_mutex` 解锁，接着是 `push_mutex` 对象：
- en: '[PRE72]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the `main` function, invoke the `pthread_join` method twice and pass the
    thread identifiers that were created in step 1 to it:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，调用 `pthread_join` 方法两次，并将步骤 1 中创建的线程标识符传递给它：
- en: '[PRE73]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `avoiddeadlockst.c` program for creating two threads and understanding
    how a deadlock can be avoided while acquiring locks is as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建两个线程并理解在获取锁时如何避免死锁的 `avoiddeadlockst.c` 程序如下：
- en: '[PRE74]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now, let's go behind the scenes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看幕后发生了什么。
- en: How it works...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We will start by defining a macro called `max` of the value `10`. Then, we will
    define an array `stack` of the size `max`. We will define two `mutex` objects
    with the names `pop_mutex` and `push_mutex`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义一个名为 `max` 的宏，其值为 `10`。然后，我们将定义一个大小为 `max` 的数组 `stack`。我们将定义两个名为 `pop_mutex`
    和 `push_mutex` 的 `mutex` 对象。
- en: To use the stack, the value of `top` will be initialized to `-1`. We will define
    two variables of the type `pthread_t`, with the names `tid1` and `tid2`, to store
    two thread identifiers.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用栈，`top` 的值将被初始化为 `-1`。我们将定义两个类型为 `pthread_t` 的变量，分别命名为 `tid1` 和 `tid2`，以存储两个线程标识符。
- en: We will invoke the `pthread_create` function to create the first thread and
    assign the identifier returned by the function to the variable `tid1`. The thread
    will be created with the default attributes, and the `push` function will be executed
    to create this thread.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用 `pthread_create` 函数以创建第一个线程，并将函数返回的标识符分配给变量 `tid1`。该线程将使用默认属性创建，并执行 `push`
    函数以创建此线程。
- en: We will invoke the `pthread_create` function a second time to create the second
    thread, and we'll assign the identifier returned by the function to the variable
    `tid2`. The thread will be created with the default attributes and the `pop` function
    will be executed to create this thread. On the screen, we will display the message
    `Both threads are created`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将第二次调用`pthread_create`函数来创建第二个线程，并将函数返回的标识符赋值给变量`tid2`。该线程将以默认属性创建，并执行`pop`函数来创建此线程。在屏幕上，我们将显示消息`Both
    threads are created`。
- en: In the `push` function, the `pthread_mutex_lock` method is invoked, and the
    `mutex` object `push_mutex` is passed to it to lock it. Now, if any other thread
    asks for the `pop_mutex` object, it will need to wait until the object is unlocked.
    After a sleep of `2` seconds, the `mutex` object `pop_mutex` is locked by the
    first thread.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在`push`函数中，将调用`pthread_mutex_lock`方法，并将`mutex`对象`push_mutex`传递给它以锁定。现在，如果任何其他线程请求`pop_mutex`对象，它将需要等待直到对象被解锁。经过`2`秒的睡眠后，第一个线程将锁定`mutex`对象`pop_mutex`。
- en: We will be prompted to enter the value to be pushed to the stack. The entered
    value will be assigned to the variable `n`. The value of `top` will increment
    to `0`. The value that we enter will be pushed to the location `stack[0]`. Now,
    the `pthread_mutex_unlock` will be invoked, and the `mutex` object `pop_mutex`
    will be passed to it to unlock it. Also, the `mutex` object `push_mutex` will
    be unlocked. At the bottom of the `push` function, the message `Value is pushed
    to stack` will be displayed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将被提示输入要推送到栈中的值。输入的值将被赋值给变量`n`。`top`的值将增加至`0`。我们输入的值将被推送到`stack[0]`的位置。现在，将调用`pthread_mutex_unlock`，并将`mutex`对象`pop_mutex`传递给它以解锁。同时，`mutex`对象`push_mutex`也将被解锁。在`push`函数的底部，将显示消息`Value
    is pushed to stack`。
- en: In the `pop` function, it will try to lock the `mutex` object `push_mutex`,
    but because it is already locked by the first thread, this thread will be asked
    to wait. After a sleep or delay of `5` seconds, it will also try to lock the `pop_mutex`
    object. The value in the stack, that is, pointed at by the pointer `top` will
    be popped. Because the value of top is `0`, the value at `stack[0]` is picked
    up and assigned to the variable `k`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pop`函数中，它将尝试锁定`mutex`对象`push_mutex`，但由于它已被第一个线程锁定，此线程将被要求等待。经过`5`秒的睡眠或延迟后，它也将尝试锁定`pop_mutex`对象。栈中的值，即由指针`top`指向的值将被弹出。因为`top`的值为`0`，所以`stack[0]`中的值被取出并赋值给变量`k`。
- en: Thereafter, the value of `top` will decrement by `1` to make it `-1` again.
    The value, that is, popped from the stack will be displayed on the screen. Then,
    the `mutex` object `pop_mutex` will be unlocked, followed by the `push_mutex`
    object.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，`top`的值将减少`1`，使其再次变为`-1`。从栈中弹出的值将在屏幕上显示。然后，将解锁`mutex`对象`pop_mutex`，接着是`push_mutex`对象。
- en: In the `main` function, the `pthread_join` method is invoked twice, and the
    `tid1` and `tid2` thread identifiers are passed to it. The `pthread_join` is invoked
    to make the two threads and the `main` method wait until both of the threads have
    completed their tasks.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，将两次调用`pthread_join`方法，并将线程标识符`tid1`和`tid2`传递给它。调用`pthread_join`是为了使两个线程和`main`方法等待，直到两个线程都完成了它们的工作。
- en: Here, we avoided a deadlock because the locking and unlocking of the `mutex`
    objects was done in a sequence. In the `push` function, the first thread locked
    the `push_mutex` object and tried to get a lock on the `pop_mutex` object. The
    `pop_mutex` was kept free because the second thread in the `pop` function first
    tried to lock the `push_mutex` object, followed by the `pop_mutex` object. Since
    the first thread had already locked the `push_mutex` object, the second thread
    was asked to wait. Consequently, both of the `mutex` objects, `push_mutex` and
    `pop_mutex`, were in an unlocked state, and the first thread was able to easily
    lock both of the `mutex` objects and use the common resource. After finishing
    its task, the first thread will unlock both of the `mutex` objects, enabling the
    second thread to lock both of the `mutex` objects and access the common resource
    thread.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们避免了死锁，因为对 `mutex` 对象的加锁和解锁是按顺序进行的。在 `push` 函数中，第一个线程锁定了 `push_mutex` 对象，并尝试锁定
    `pop_mutex` 对象。由于 `pop_mutex` 被第二个线程在 `pop` 函数中首先尝试锁定，然后是 `pop_mutex` 对象，所以 `pop_mutex`
    保持空闲状态。由于第一个线程已经锁定了 `push_mutex` 对象，第二个线程被要求等待。因此，两个 `mutex` 对象，`push_mutex` 和
    `pop_mutex`，都处于未锁定状态，第一个线程能够轻松地锁定这两个 `mutex` 对象并使用公共资源。完成其任务后，第一个线程将解锁这两个 `mutex`
    对象，使得第二个线程能够锁定这两个 `mutex` 对象并访问公共资源线程。
- en: 'Let''s use GCC to compile the `avoiddeadlockst.c` program, as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 GCC 编译 `avoiddeadlockst.c` 程序，如下所示：
- en: '[PRE75]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If you get no errors or warnings, that means the `avoiddeadlockst.c` program
    has been compiled into an executable file, `avoiddeadlockst.exe`. Let''s run this
    executable file:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有收到任何错误或警告，这意味着 `avoiddeadlockst.c` 程序已经被编译成一个可执行文件，名为 `avoiddeadlockst.exe`。让我们运行这个可执行文件：
- en: '![](img/a56ba879-74ba-40e3-b40b-ea84687b3d72.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a56ba879-74ba-40e3-b40b-ea84687b3d72.png)'
- en: Figure 7.6
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6
- en: Voila! We've successfully avoided a deadlock.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们已经成功避免了死锁。
