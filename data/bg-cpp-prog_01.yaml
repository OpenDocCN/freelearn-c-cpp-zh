- en: Starting with C++
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从C++开始
- en: Why C++? There will be as many reasons to use C++ as there will be readers of
    this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择C++？使用C++的原因将会有很多，就像本书的读者一样多。
- en: You may have chosen C++ because you have to support a C++ project. Over the
    30 years of its lifetime there have been millions of lines of C++ written, and
    most popular applications and operating systems will be mostly written in C++,
    or will use components and libraries that are. It is nearly impossible to find
    a computer that does not contain some code that has been written in C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能选择C++是因为您需要支持一个C++项目。在其30年的生命周期中，已经有数百万行的C++代码编写，大多数流行的应用程序和操作系统都将主要由C++编写，或者将使用组件和库。几乎不可能找到一台不包含一些C++编写的代码的计算机。
- en: 'Or, you may have chosen C++ to write new code. This may be because your code
    will use a library written in C++, and there are thousands of libraries available:
    open source, shareware, and commercial.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可能选择C++来编写新代码。这可能是因为您的代码将使用C++编写的库，而现有的库有成千上万种：开源、共享软件和商业软件。
- en: Or it may be because you are attracted to the power and flexibility that C++
    offers. Modern high-level languages have been designed to make it easy for programmers
    to perform actions; while C++ has such facilities, it also allows you to get as
    close to the machine as possible, gives you the (sometimes dangerous) power of
    direct memory access. Through language features such as classes and overloading,
    C++ is a flexible language that allows you to extend how the language works and
    write reusable code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您选择C++是因为您被C++所提供的强大和灵活性所吸引。现代高级语言被设计成让程序员轻松执行操作；而C++虽然也有这样的功能，但它也允许您尽可能接近机器，给您直接内存访问的（有时是危险的）能力。通过类和重载等语言特性，C++是一种灵活的语言，允许您扩展语言的工作方式并编写可重用的代码。
- en: Whatever your reason for deciding on C++, you have made the right choice, and
    this book is the right place to start.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择C++的原因是什么，您都做出了正确的选择，而这本书是开始的正确地方。
- en: What will you find in this chapter?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章中会有什么？
- en: Since this book is a hands-on book, it contains code that you can type, compile,
    and run. To compile the code, you will need a C++ compiler and linker, and in
    this book that means Visual Studio 2017 Community Edition, which provides Visual
    C++. This compiler was chosen because it is a free download, it is compliant 
    with C++ standards and it has  very wide range of tools to make writing code easier.
    Visual C++ provides C++11-compliant language features and almost all the language
    features of C++14 and C++17\. Visual C++ is also provided with the C99 runtime
    library, C++11 standard library, and C++14 standard library. All of this mentions
    of **standard** means that the code that you learn to write in this book will
    compile with all other standard C++ compilers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书是一本实践性的书，它包含了您可以输入、编译和运行的代码。要编译代码，您需要一个C++编译器和链接器，在本书中意味着Visual Studio 2017
    Community Edition，它提供了Visual C++。选择这个编译器是因为它是免费下载的，它符合C++标准，并且具有非常广泛的工具范围，使编写代码更容易。Visual
    C++提供了符合C++11标准的语言特性，几乎所有C++14和C++17的语言特性。Visual C++还提供了C99运行时库、C++11标准库和C++14标准库。所有这些**标准**的提及意味着您在本书中学习到的代码将与所有其他标准的C++编译器编译。
- en: This chapter will start with details about how to obtain and install Visual
    Studio 2017 Community Edition. If you already have a C++ compiler, you can skip
    this section. Most of this book is vendor-neutral about the compiler and linker
    tools, but Chapter 10, *Diagnostics and Debugging*, which covers debugging and
    diagnostics, will cover some Microsoft-specific features. Visual Studio has a
    fully featured code editor, so even if you do not use it to manage your projects,
    you'll find it useful to edit your code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从如何获取和安装Visual Studio 2017 Community Edition的细节开始。如果您已经有了C++编译器，可以跳过本节。本书大部分内容对编译器和链接器工具都是中立的，但第10章《诊断和调试》将涵盖一些微软特定的功能，包括调试和诊断。Visual
    Studio拥有功能齐全的代码编辑器，因此即使您不使用它来管理项目，您也会发现它在编辑代码时非常有用。
- en: 'After we''ve described the installation, you''ll learn the basics of C++: how
    source files and projects are structured, and how you can manage projects with
    potentially thousands of files.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们描述了安装之后，您将学习C++的基础知识：源文件和项目的结构，以及如何管理可能包含数千个文件的项目。
- en: Finally, the chapter will finish with a step-by-step structured example. Here
    you will learn how to write simple functions that use the standard C++ library
    and one mechanism to manage files in the project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章将以一个逐步结构化的示例结束。在这里，您将学习如何编写使用标准C++库和一个机制来管理项目中的文件的简单函数。
- en: What is C++?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是C++？
- en: The predecessor of C++ is C, which was designed by Dennis Richie at Bell Labs
    and first released in 1973\. C is a widely used language and was used to write
    the early versions of Unix and Windows. Indeed, the libraries and software-development
    libraries of many operating systems are still written to have C interfaces. C
    is powerful because it can be used to write code that is compiled to a compact
    form, it uses a static type system (so the compiler does the work of type checking),
    and the types and structures of the language allow for direct memory access to
    computer architecture.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: C++的前身是C，由贝尔实验室的Dennis Richie设计，并于1973年首次发布。C是一种广泛使用的语言，被用来编写Unix和Windows的早期版本。事实上，许多操作系统的库和软件开发库仍然是以C接口编写的。C之所以强大，是因为它可以用来编写编译成紧凑形式的代码，它使用静态类型系统（因此编译器进行类型检查），语言的类型和结构允许直接访问计算机体系结构的内存。
- en: 'C, however, is procedural and based on functions, and although it has record
    types (`struct`) to encapsulate data, it does not have object-like behaviors to
    act on that encapsulated state. Clearly there was a need for the power of C but
    the flexibility and extensibility of object-oriented classes: a language that
    was C, with classes. In 1983, Bjarne Stroustrup released C++. The ++ comes from
    the C increment operator `++`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C 是基于函数的过程式语言，虽然它有记录类型（`struct`）来封装数据，但它没有对象行为来操作封装的状态。显然，需要的是 C 的强大功能，但又需要面向对象类的灵活性和可扩展性：一种具有类似
    C 的语言。1983 年，Bjarne Stroustrup 发布了 C++。++ 来自于 C 的增量运算符 `++`。
- en: Strictly, when postfixed to a variable, the `++` operator means *increment the
    variable, but return the variable's value before it was incremented*. So the C
    statements `int c = 1; int d = c++;` will result in variable `d` having a value
    of 1 and variable `c` having a value of 2\. This does not quite express the idea
    that C++ is an increment on C.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 严格地说，当后缀添加到变量时，`++` 运算符表示*增加变量的值，但返回增加之前的值*。因此，C 语句 `int c = 1; int d = c++;`
    将导致变量 `d` 的值为 1，变量 `c` 的值为 2。这并不完全表达了 C++ 是 C 的增量的概念。
- en: Installing Visual C++
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Visual C++
- en: Microsoft's Visual Studio Community 2017 contains the Visual C++ compiler, the
    C++ standard libraries, and a collection of standard tools that you can use to
    write and maintain C++ projects. This book is not about how to write Windows code;
    it is about how to write standard C++ and how to use the C++ Standard Library.
    All the examples in this book will run on the command line. Visual Studio was
    chosen because it is a free download (although you do have to register an e-mail
    address with Microsoft), and it is standards-compliant. If you already have a
    C++ compiler installed, then you can skip this section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 的 Visual Studio Community 2017 包含了 Visual C++ 编译器、C++ 标准库以及一系列标准工具，您可以使用这些工具来编写和维护
    C++ 项目。本书不是关于如何编写 Windows 代码的，而是关于如何编写标准的 C++ 以及如何使用 C++ 标准库。本书中的所有示例都将在命令行上运行。选择
    Visual Studio 是因为它是免费下载的（尽管您必须向 Microsoft 注册一个电子邮件地址），而且它符合标准。如果您已经安装了 C++ 编译器，那么您可以跳过本节。
- en: Setting up
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置中
- en: Before starting the installation, you should be aware that, as part of the agreement
    to install Visual Studio as part of Microsoft's community program, you should
    have a Microsoft account. You are given the option to create a Microsoft account
    the first time you run Visual Studio and if you skip this stage, you will be given
    a 30-day evaluation period. Visual Studio will be fully featured during this month,
    but if you want to use Visual Studio beyond this time you will have to provide
    a Microsoft account. The Microsoft account does not impose any obligation on you,
    and when you use Visual C++ after signing in, your code will still remain on your
    machine with no obligation to pass it to Microsoft.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始安装之前，您应该知道，作为安装 Visual Studio 的一部分，您应该具有 Microsoft 帐户，这是 Microsoft 社区计划的一部分。第一次运行
    Visual Studio 时，您将有选项创建 Microsoft 帐户，如果您跳过此阶段，您将获得一个 30 天的评估期。在这一个月内，Visual Studio
    将具有完整功能，但如果您想在此期限之后继续使用 Visual Studio，您将需要提供 Microsoft 帐户。Microsoft 帐户不会对您施加任何义务，当您使用
    Visual C++ 登录后，您的代码仍将保留在您的计算机上，无需将其传递给 Microsoft。
- en: Of course, if you read this book within one month, you will be able to use Visual
    Studio without having to sign in using your Microsoft account; you may view this
    as an incentive to be diligent about finishing the book!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您在一个月内阅读本书，您将能够使用 Visual Studio 而无需使用 Microsoft 帐户登录；您可以将此视为完成本书的动力！
- en: Downloading the installation files
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载安装文件
- en: To download the Visual Studio Community 2017 installer go to [https://www.visualstudio.com/vs/
    community/](https://www.visualstudio.com/vs/%20community/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载 Visual Studio Community 2017 安装程序，请访问 [https://www.visualstudio.com/vs/
    community/](https://www.visualstudio.com/vs/%20community/)。
- en: When you click on the Download Community 2017 button, your browser will download
    a 1 MB file called `vs_community__1698485341.1480883588.exe`. When you run this
    application, it will allow you to specify the languages and libraries that you
    want installed, and then it downloads and installs all the necessary components.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“下载 Community 2017”按钮后，您的浏览器将下载一个名为 `vs_community__1698485341.1480883588.exe`
    的 1 MB 文件。运行此应用程序后，它将允许您指定要安装的语言和库，然后下载并安装所有必要的组件。
- en: Installing Visual Studio
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Visual Studio
- en: 'Visual Studio 2017 treats Visual C++ as an optional component, so you have
    to explicitly indicate that you want to install it through custom options. When
    you first execute the installer, you will see the following dialog box:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2017 将 Visual C++ 视为可选组件，因此您必须明确指示要通过自定义选项安装它。当您首次执行安装程序时，将会看到以下对话框：
- en: '![](img/1cdfc359-5864-4206-b198-0bd99041523a.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cdfc359-5864-4206-b198-0bd99041523a.png)'
- en: 'When you click on the Continue button the application will set up the installer,
    as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“继续”按钮后，应用程序将设置安装程序，如下所示：
- en: '![](img/a432ff33-a41f-4de9-a6f8-6cdf3e9cd6da.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a432ff33-a41f-4de9-a6f8-6cdf3e9cd6da.png)'
- en: Along the top are three tabs labeled Workloads, Individual Components and Language
    Packs. Make sure that you have selected the Workloads tab (as shown in the screenshot)
    and check the checkbox in the item called Desktop development with C++.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部有三个标签，分别标记为工作负载、单独组件和语言包。确保您已选择了“工作负载”标签（如截图所示），并选中了名为“使用 C++ 进行桌面开发”的复选框。
- en: 'The installer will check that you have enough disk space for the selected option.
    The maximum amount of space Visual Studio will require is 8 GB, although for Visual
    C++ you will use a lot less. When you check Desktop development with C++ item, you
    will see the right side of the dialog change to list the options selected and
    the disk size required, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序将检查您是否有足够的磁盘空间来安装所选的选项。Visual Studio 最大需要的空间为 8 GB，尽管对于 Visual C++，您将使用的空间要少得多。当您选择“使用
    C++ 进行桌面开发”项目时，对话框的右侧将显示所选的选项和所需的磁盘空间，如下所示：
- en: '![](img/6eba5d15-f59e-4ab9-924a-739cfd5aa484.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6eba5d15-f59e-4ab9-924a-739cfd5aa484.png)'
- en: 'For this book, leave the options selected by the installer and then click the
    Install button in the bottom right hand corner. The installer will download all
    the code it needs and it will keep you updated with the progress with the following
    dialog box:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书，保留安装程序选择的选项，然后单击右下角的“安装”按钮。安装程序将下载所有所需的代码，并将通过以下对话框框保持您更新进度：
- en: '![](img/33e49bcf-ace3-4fcc-b91e-1d57b70d5c98.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33e49bcf-ace3-4fcc-b91e-1d57b70d5c98.png)'
- en: 'When the installation is complete the Visual Studio Community 2017 item will
    change to have two buttons, Modify and Launch, as showing here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，Visual Studio Community 2017项目将更改为具有两个按钮“修改”和“启动”，如下所示：
- en: '![](img/752132af-3977-43f6-b00b-ec90f7746839.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/752132af-3977-43f6-b00b-ec90f7746839.png)'
- en: The Modify button allows you to add more components. Click on Launch to run
    Visual Studio for the first time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 修改按钮允许您添加更多组件。单击“启动”以首次运行Visual Studio。
- en: Registering with Microsoft
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Microsoft注册
- en: 'The first time you run Visual Studio it will ask you to sign in to Microsoft
    services through the following dialog:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行Visual Studio时，它会要求您通过以下对话框登录到Microsoft服务：
- en: '![](img/90fe6b32-c2f5-4468-8d32-7beb06f72678.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90fe6b32-c2f5-4468-8d32-7beb06f72678.png)'
- en: You do not have to register Visual Studio, but if you choose not to, Visual
    Studio will only work for 30 days. Registering with Microsoft places no obligations
    on you. If you are happy to register, then you may as well register now. Click
    on Sign in button provide your Microsoft credentials, or if you do not have an
    account then click on Sign up to create an account.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必注册Visual Studio，但如果选择不注册，Visual Studio将只能使用30天。与Microsoft注册不会对您产生任何义务。如果您愿意注册，那么现在可以注册。单击“登录”按钮提供您的Microsoft凭据，或者如果您没有帐户，则单击“注册”以创建一个帐户。
- en: When you click on the Launch button a new window will open, but the installer
    window will remain open. You may find that the installer window hides the Welcome
    window, so check the Windows task bar to see if another window is open. Once Visual
    Studio has started you can close the installer window.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当您单击“启动”按钮时，将打开一个新窗口，但安装程序窗口将保持打开状态。您可能会发现安装程序窗口隐藏了欢迎窗口，因此请检查Windows任务栏，看看是否有其他窗口打开。一旦Visual
    Studio启动，您可以关闭安装程序窗口。
- en: You will now be able to use Visual Studio to edit code, and will have the Visual
    C++ compiler and libraries installed on your machine, so you will be able to compile
    C++ code in Visual Studio or on the command line.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用Visual Studio来编辑代码，并且在您的计算机上安装了Visual C++编译器和库，因此您可以在Visual Studio或命令行中编译C++代码。
- en: Examining C++ projects
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查C++项目
- en: C++ projects can contain thousands of files, and managing these files can be
    a task. When you build the project, should a file be compiled, and if so, by which
    tool? In what order should the files be compiled? What output will these compilers
    produce? How should the compiled files be combined to produce the executable?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: C++项目可能包含数千个文件，管理这些文件可能是一项任务。构建项目时，应该编译文件，如果是的话，使用哪个工具？文件应该以什么顺序进行编译？这些编译器将产生什么输出？如何将编译后的文件组合以生成可执行文件？
- en: Compiler tools will also have a large collection of options, as diverse as debug
    information, types of optimization, support for different language features, and
    processor features. Different combinations of compiler options will be used in
    different circumstances (for example, release builds and debug builds). If you
    compile from a command line, you have to make sure you choose the right options
    and apply them consistently across all the source code you compile.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器工具还将具有大量选项，如调试信息、优化类型、对不同语言功能和处理器功能的支持。在不同情况下将使用不同的编译器选项组合（例如，发布构建和调试构建）。如果您从命令行进行编译，您必须确保选择正确的选项并在所有编译的源代码中一致应用它们。
- en: 'Managing files and compiler options can get very complicated. This is why,
    for production code, you should use a make tool. Two are installed with Visual
    Studio: **MSBuild** and **nmake**. When you build a Visual C++ project in the
    Visual Studio environment, MSBuild will be used and the compilation rules will
    be stored in an XML file. You can also call MSBuild on the command line, passing
    it the XML project file. The nmake tool is Microsoft''s version of the program
    maintenance utility common across many compilers. In this chapter, you will learn
    how to write a simple **makefile** to use with the nmake utility.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 管理文件和编译器选项可能会变得非常复杂。这就是为什么在生产代码中，您应该使用一个make工具。Visual Studio安装了两个：**MSBuild**和**nmake**。在Visual
    Studio环境中构建Visual C++项目时，将使用MSBuild，并且编译规则将存储在一个XML文件中。您还可以在命令行上调用MSBuild，传递XML项目文件。nmake工具是微软版本的通用程序维护实用程序，适用于许多编译器。在本章中，您将学习如何编写一个简单的**makefile**以与nmake实用程序一起使用。
- en: Before going through the basics of project management, first we have to examine
    the files that you will commonly find in a C++ project, and what a compiler will
    do to those files.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行项目管理基础知识之前，我们首先要检查您在C++项目中通常会找到的文件，以及编译器对这些文件的处理。
- en: Compilers
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器
- en: C++ is a high-level language, designed to give you a wealth of language facilities
    and to be readable for you and other developers. The computer's processor executes
    low-level code, and it is the purpose of the compiler to translate C++ to the
    processor's machine code. A single compiler may be able to target several types
    of processor, and if the code is standard C++, it can be compiled with other compilers
    that support other processors.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: C++是一种高级语言，旨在为您和其他开发人员提供丰富的语言功能，并且易于阅读。计算机的处理器执行低级代码，编译器的目的是将C++翻译为处理器的机器代码。单个编译器可能能够针对多种类型的处理器进行编译，如果代码是标准C++，则可以使用支持其他处理器的其他编译器进行编译。
- en: However, the compiler does much more than this. As explained in [Chapter 4](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml),
    *Working With Memory, Arrays, and Pointers*, C++ allows you to split your code
    into functions, which take parameters and return a value, so the compiler sets
    up the memory used to pass this data. In addition, functions can declare variables
    that will only be used within that function ([Chapter 5](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml),
    *Using Functions*, will give more details), and will only exist while the function
    is executed. The compiler sets up this memory, called a **stack frame**. You have
    compiler options about how stack frames are created; for example, the Microsoft
    compiler options `/Gd`, `/Gr`, and `/Gz` determine the order in which function
    arguments are pushed onto the stack and whether the caller function or called
    function removes the arguments from the stack at the end of the call. These options
    are important when you write code that will be shared (but for the purpose of
    this book, the default stack construction should be used). This is just one area,
    but it should impress upon you that compiler settings give you access to a lot
    of power and flexibility.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编译器做的远不止这些。正如[第4章](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml)中所解释的，*内存、数组和指针的使用*，C++允许你将代码分割成函数，这些函数接受参数并返回一个值，因此编译器设置了用于传递这些数据的内存。此外，函数可以声明只在该函数内部使用的变量（[第5章](16029dc8-6d57-416f-ad51-6e991b96a439.xhtml)中将提供更多细节），并且只在函数执行时存在。编译器设置了这个内存，称为**栈帧**。你可以选择编译器选项来确定如何创建栈帧；例如，微软编译器选项`/Gd`、`/Gr`和`/Gz`确定了将函数参数推送到栈上的顺序，以及在调用结束时是调用函数还是被调用函数从栈上移除参数。当你编写将被共享的代码时，这些选项很重要（但是对于本书的目的，应该使用默认的栈构造）。这只是一个方面，但它应该让你明白编译器设置给了你很多的权力和灵活性。
- en: 'The compiler compiles C++ code, and it will issue a compiler error if it comes
    across an error in your code. This is syntax checking of your code. It is important
    to point out that the code you write can be perfect C++ code from a syntax point
    of view, but it can still be nonsense. The syntax checking of the compiler is
    an important check of your code, but you should always use other checking. For
    example, the following code declares an integer variable and assigns it a value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器编译C++代码，如果在你的代码中遇到错误，它将发出编译器错误。这是对你的代码进行语法检查。重要的是要指出，你编写的代码可以从语法角度来看是完美的C++代码，但它仍然可能是无意义的。编译器的语法检查是对你的代码的重要检查，但你应该始终使用其他检查。例如，以下代码声明一个整数变量并为其赋值：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The compiler will issue an error `C2124 : divide or mod by zero`. However,
    the following code will perform the same action using an additional variable,
    which is logically the same, but the compiler will issue no error:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将会发出错误`C2124：除以零或取模`。然而，以下代码将使用一个额外的变量执行相同的操作，逻辑上是相同的，但编译器不会发出错误：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the compiler issues an error it will stop compiling. This means two things.
    Firstly, you get no compiled output, so the error will not find its way into an
    executable. Secondly, it means that, if there are other errors in the source code,
    you will only find out about it once you have fixed the current error and recompiled.
    If you want to perform a syntax check and leave compilation to a later time, use
    the `/Zs` switch.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器发出错误时，它将停止编译。这意味着两件事。首先，你将得不到编译输出，因此错误不会出现在可执行文件中。其次，这意味着，如果源代码中还有其他错误，你只有在修复当前错误并重新编译后才能发现。如果你想进行语法检查并将编译留到以后，可以使用`/Zs`开关。
- en: 'The compiler will also generate warning messages. A warning means that the
    code will compile, but there is, potentially, a problem in the code that will
    affect how the executable will run. The Microsoft compiler defines four levels
    of warnings: level 1 is the most severe (and should be addressed) and level 4
    is informational.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器还会生成警告消息。警告意味着代码将会编译，但代码中可能存在问题，这将影响可执行文件的运行。微软编译器定义了四个警告级别：级别1是最严重的（应该解决），级别4是信息性的。
- en: Warnings are often used to indicate that the language feature being compiled
    is available, but it needs a specific compiler option that the developer has not
    used. During development of code, you will often ignore warnings, since you may
    be testing language features. However, when you get closer to producing production
    code you should pay more attention to warnings. By default, the Microsoft compiler
    will display level 1 warnings, and you can use the `/W` option with a number to
    indicate the levels that you wish to see (for example, `/W2` means you wish to
    see level 2 warnings as well as level 1 warnings). In production code, you may
    use the `/Wx` option, which tells the compiler to treat warnings as errors so
    that you must fix the issues to be able to compile the code. You can also use
    the `pragmas` compiler (`pragmas` will be explained later) and compiler options
    to suppress specific warnings.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 警告通常用于指示正在编译的语言特性是可用的，但它需要开发人员未使用的特定编译器选项。在代码开发过程中，你通常会忽略警告，因为你可能正在测试语言特性。然而，当你接近生产代码时，你应该更加关注警告。默认情况下，微软编译器将显示级别1的警告，你可以使用`/W`选项加上一个数字来指示你希望看到的级别（例如，`/W2`表示你希望看到级别2的警告以及级别1的警告）。在生产代码中，你可以使用`/Wx`选项，它告诉编译器将警告视为错误，因此你必须修复问题才能编译代码。你还可以使用`pragmas`编译器（`pragmas`将在后面解释）和编译器选项来抑制特定的警告。
- en: Linking the code
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接代码
- en: 'A compiler will produce an output. For C++ code, this will be object code,
    but you may have other compiler outputs, such as compiled resource files. On their
    own, these files cannot be executed; not least because the operating system will
    require certain structures to be set up. A C++ project will always be two-stage:
    compile the code into one or more object files and then link the object files
    into an executable. This means that your C++ compiler will provide another tool,
    called a linker.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会产生一个输出。对于C++代码，这将是目标代码，但你可能会有其他编译器输出，比如编译后的资源文件。这些文件本身不能被执行；至少因为操作系统需要设置某些结构。一个C++项目总是两阶段的：将代码编译成一个或多个目标文件，然后将目标文件链接成一个可执行文件。这意味着你的C++编译器将提供另一个工具，称为链接器。
- en: The linker also has options to determine how it will work and specify its outputs
    and inputs, and it will also issue errors and warnings. Like the compiler, the
    Microsoft linker has an option, `/WX`, to treat warnings as errors in release
    builds.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 链接器还有选项来确定它的工作方式并指定其输出和输入，它也会发出错误和警告。与编译器一样，微软的链接器有一个选项`/WX`，在发布版本中将警告视为错误。
- en: Source files
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源文件
- en: 'At the very basic level, a C++ project will contain just one file: the C++
    source file, typically with the extension `cpp` or `cxx`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的层面上，一个C++项目只包含一个文件：C++源文件，通常扩展名为`cpp`或`cxx`。
- en: A simple example
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的例子
- en: 'The simplest C++ program is shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了最简单的C++程序：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first point to make is that the line starting with `//` is a comment. All
    the text until the end of the line is ignored by the compiler. If you want to
    have multiline comments, every line must start with `//`. You can also use C comments.
    A C comment starts with `/*` and ends with `*/` and everything between these two
    symbols is a comment, including line breaks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点要说明的是，以`//`开头的行是注释。编译器会忽略直到行末的所有文本。如果要有多行注释，每一行都必须以`//`开头。你也可以使用C注释。C注释以`/*`开头，以`*/`结尾，两个符号之间的所有内容都是注释，包括换行符。
- en: C comments are a quick way to comment out a portion of your code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: C注释是注释掉代码的一种快速方式。
- en: 'The braces, `{}`, indicates a code block; in this case, the C++ code is for
    the function `main`. We know that this is a function because of the basic format:
    first, there is the type of the return value, then the name of the function with
    a pair of parentheses, which is used to declare the parameters passed to the function
    (and their types). In this example, the function is called `main` and the parentheses
    are empty, indicating that the function has no parameters. The identifier before
    the function name (`int`) says that the function will return an integer.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号`{}`表示一个代码块；在这种情况下，C++代码是为函数`main`而写的。我们知道这是一个函数，因为基本格式是：首先是返回值的类型，然后是函数的名称，后面跟着一对括号，用于声明传递给函数的参数（及其类型）。在这个例子中，函数名为`main`，括号是空的，表示该函数没有参数。函数名前的标识符（int）表示该函数将返回一个整数。
- en: The convention with C++ is that a function called `main` is the **entry point**
    of the executable, that is, when you call the executable from the command line,
    this will be the first function in your code that will be called.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: C++的约定是，一个名为`main`的函数是可执行文件的**入口点**，也就是说，当你从命令行调用可执行文件时，这将是你代码中将被调用的第一个函数。
- en: 'This simple example function immediately immerses you into an aspect of C++
    that irritates programmers of other languages: the language may have rules, but
    the rules don''t always appear to be followed. In this case, the `main` function
    is declared to return an integer, but the code returns no value. The rule in C++
    is that, if the function declares that it returns a value, then it must return
    a value. However, there is a single exception to this rule: if the `main` function
    does not return a value, then a value of `0` will be assumed. C++ contains many
    quirks such as this, but you will soon learn what they are and get used to them.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子函数立即让你了解了C++的一个方面，即激怒其他语言的程序员：语言可能有规则，但规则并不总是被遵循。在这种情况下，`main`函数声明返回一个整数，但代码没有返回任何值。C++的规则是，如果函数声明返回一个值，那么它必须返回一个值。然而，这个规则有一个例外：如果`main`函数不返回值，那么将假定返回值为`0`。C++包含许多这样的怪癖，但你很快就会学会它们并习惯它们。
- en: The `main` function has just one line of code; this is a single statement starting
    with `std` and ending with the semicolon (`;`). C++ is flexible about the use
    of whitespace (spaces, tabs, and newlines) as will be explained in the next chapter.
    However, it is important to note that you have to be careful with literal strings
    (as used here), and every statement is delimited with a semicolon. Forgetting
    a required semicolon is a common source of compiler errors. An extra semicolon
    is simply an empty statement, so for a novice, having too many semicolons can
    be less fatal to your code than having too few.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数只有一行代码；这是一个以`std`开头并以分号(`;`)结尾的单个语句。C++对于空白符（空格、制表符和换行符）的使用是灵活的，这将在下一章中解释。然而，重要的是要注意，你必须小心处理文字字符串（如此处所用），并且每个语句都要用分号分隔。忘记必需的分号是编译器错误的常见来源。额外的分号只是一个空语句，所以对于新手来说，有太多分号可能对你的代码的影响要比太少分号要小。'
- en: The single statement prints the string `Hello, world!` (and a newline) to the
    console. You know that this is a string because it is enclosed in double quote
    marks (`″″`). The string is *put to* the stream object `std::cout` using the operator
    `<<`. The `std` part of the name is a **namespace**, in effect, a collection of
    code with a similar purpose, or from a single vendor. In this case, `std` means
    that the `cout` stream object is part of the standard C++ library. The double
    colon `::` is the **scope resolution** operator, and indicates that you want to
    access the `cout` object declared in the `std` namespace. You can define namespaces
    of your own, and in a large project you should define your own namespaces, since
    it will allow you to use names that may have been declared in other namespaces,
    and this syntax allows you to disambiguate the symbol.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 单个语句将字符串`Hello, world!`（和一个换行符）打印到控制台。您知道这是一个字符串，因为它用双引号（`″″`）括起来。字符串使用运算符`<<`
    *放入*流对象`std::cout`。名称中的`std`是一个**命名空间**，实际上是具有类似目的或来自单个供应商的代码集合。在这种情况下，`std`表示`cout`流对象是标准C++库的一部分。双冒号`::`是**作用域解析**运算符，表示您要访问在`std`命名空间中声明的`cout`对象。您可以定义自己的命名空间，在大型项目中应该定义自己的命名空间，因为这样可以使用可能已在其他命名空间中声明的名称，并且此语法允许您消除符号的歧义。
- en: The `cout` object is an instance of the `ostream` class and this has already
    been created for you before the `main` function is called. The `<<` means that
    a function called `operator <<` is called and is passed the string (which is an
    array of `char` characters). This function prints each character in the string
    to the console until it reaches a `NUL` characte.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`cout`对象是`ostream`类的一个实例，并且在调用`main`函数之前已经为您创建。`<<`表示调用名为`operator <<`的函数，并传递字符串（这是一个`char`字符数组）。此函数将字符串中的每个字符打印到控制台，直到达到`NUL`字符。'
- en: This is an example of the flexibility of C++, a feature called **operator overloading**.
    The `<<` operator is usually used with integers, and is used too shift the bits
    in the integer a specified number of places to the left; `x << y` will return
    a value which has every bit in `x` shifted left by `y` places, in effect returning
    a value that has been multiplied by 2^y. However, in the preceding code, in place
    of the integer `x` there is the stream object `std::cout`, and in place of the
    left shift index there is a string. Clearly, this does not make any sense in the
    C++ definition of the `<<` operator. The C++ standard has effectively redefined
    what the `<<` operator means when used with an `ostream` object on the left-hand
    side. Furthermore, the `<<` operator in this code will print a string to the console,
    and so it takes a string on the right-hand side. The C++ Standard Library defines
    other `<<` operators that allow other data types to be printed to the console.
    They are all called the same way; the compiler determines which function is compiled
    dependent upon the type of the parameter used.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C++灵活性的一个例子，一个称为**运算符重载**的特性。`<<`运算符通常与整数一起使用，并且也用于将整数中的位向左移动指定数量的位置；`x <<
    y`将返回一个值，该值将`x`中的每个位向左移动`y`个位置，实际上返回一个乘以2^y的值。然而，在前面的代码中，`x`的位置是流对象`std::cout`，左移索引的位置是一个字符串。显然，这在C++对`<<`运算符的定义中是没有意义的。当左侧是`ostream`对象时，C++标准重新定义了`<<`运算符的含义。此外，此代码中的`<<`运算符将字符串打印到控制台，因此它在右侧需要一个字符串。C++标准库定义了其他`<<`运算符，允许其他数据类型打印到控制台。它们都以相同的方式调用；编译器根据使用的参数类型确定编译哪个函数。
- en: 'Earlier we said that the `std::cout` object had already been created as an
    instance of the `ostream` class, but gave no indication of how this has occurred.
    This leads us to the last part of the simple source file not already explained:
    the first line starting with `#include`. The `#` here effectively indicates that
    a message of some kind will be given to the compiler. There are various types
    of messages you can send (a few are `#define`, `#ifdef`, `#pragma`, which we will
    return to elsewhere in this book). In this case, `#include` tells the compiler
    to copy the contents of the specified file into the source file at this point,
    which essentially means the contents of that file will be compiled too. The specified
    file is called a **header file**, and is important in file management and the
    reuse of code through libraries.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们说过，`std::cout`对象已经作为`ostream`类的一个实例被创建，但没有说明这是如何发生的。这导致我们来到了尚未解释的简单源文件的最后一部分：以`#include`开头的第一行。这里的`#`有效地表示将向编译器发送某种消息。您可以发送各种类型的消息（其中一些是`#define`、`#ifdef`、`#pragma`，我们将在本书的其他地方返回）。在这种情况下，`#include`告诉编译器将指定文件的内容复制到此处的源文件中，这基本上意味着该文件的内容也将被编译。指定的文件称为**头文件**，在文件管理和通过库重用代码中很重要。
- en: The file `<iostream>` (note, no extension) is part of the Standard Library and
    can be found in the **include directory** provided with the C++ compiler. The
    angle brackets (`<>`) indicate that the compiler should look in the standard directories
    used to store header files, but you can provide the absolute location of a header
    file (or the location relative to the current file) using double quotes (`″″`).
    The C++ Standard Library uses the convention of not using file extensions. You
    should use the extension `h` (or `hpp` and, rarely, `hxx`) when naming your own
    header files. The C Runtime Library (which is also available to your C++ code)
    also uses the extension `h` for its header files.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`<iostream>`（注意，没有扩展名）是标准库的一部分，可以在C++编译器提供的**include目录**中找到。尖括号（`<>`）表示编译器应查找用于存储头文件的标准目录，但您可以使用双引号（`″″`）提供头文件的绝对位置（或相对于当前文件的位置）。C++标准库使用不使用文件扩展名的约定。在命名自己的头文件时，应使用扩展名`h`（或`hpp`，很少使用`hxx`）。C运行时库（也可用于C++代码）还使用扩展名`h`来命名其头文件。
- en: Creating source files
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建源文件
- en: 'Start by finding the Visual Studio 2017 folder on the Start Menu and click
    on the entry for Developer Command Prompt for VS2017\. This will start a Windows
    command prompt and set up the environmental variables to use Visual C++ 2017\.
    However, rather unhelpfully, it will also leave the command line in the Visual
    Studio folder under the Program Files folder. If you intend to do any development,
    you will want to move out of this folder to one where creating and deleting files
    will do no harm. Before you do that, move to the Visual C++ folder and list the
    files:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先找到开始菜单中的Visual Studio 2017文件夹，然后点击Developer Command Prompt for VS2017的条目。这将启动一个Windows命令提示符，并设置环境变量以使用Visual
    C++ 2017。然而，令人不满意的是，它也会将命令行留在Program Files文件夹下的Visual Studio文件夹中。如果你打算进行任何开发，你会想要离开这个文件夹，去一个创建和删除文件不会造成任何损害的地方。在你这样做之前，移动到Visual
    C++文件夹并列出文件：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since the installer will place the C++ files in a folder that includes the current
    build of the compiler, it is safer to use the environment variable `VCToolsInstallDir`
    rather than specifying a specific version so that the latest version is used (in
    this case 14.0.10.2517).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安装程序将C++文件放在一个包含当前编译器版本的文件夹中，因此最好使用环境变量`VCToolsInstallDir`，而不是指定特定版本，以便使用最新版本（在本例中为14.0.10.2517）。
- en: 'There are a few things to notice. First, the folders `bin`, `include`, and
    `lib`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有几件事情需要注意。首先，文件夹`bin`、`include`和`lib`：
- en: '| **Folder** | **Description** |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **文件夹** | **描述** |'
- en: '| `bin` | This contains, indirectly, the executables for Visual C++. The `bin`
    folder will contain separate folders for the CPU type you are using, so you will
    have to navigate below this to get to the actual folder containing the executables.
    The two main executables are `cl.exe`, which is the C++ compiler and `link.exe`,
    which is the linker. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `bin` | 这个文件夹间接包含了Visual C++的可执行文件。`bin`文件夹将包含用于你正在使用的CPU类型的单独文件夹，因此你需要在其中导航以找到包含可执行文件的实际文件夹。两个主要的可执行文件是`cl.exe`，它是C++编译器，和`link.exe`，它是链接器。|'
- en: '| `include` | This folder contains the header files for the C Runtime Library
    and the C++ Standard Library. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `include` | 这个文件夹包含了C运行库和C++标准库的头文件。|'
- en: '| `lib` | This folder contains the static link library files for the C Runtime
    Library and the C++ Standard Library. Again, there will be separate folders for
    the CPU type |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `lib` | 这个文件夹包含了C运行库和C++标准库的静态链接库文件。同样，对于CPU类型会有单独的文件夹。|'
- en: We will refer back to these folders later in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面提到这些文件夹。
- en: The other thing to point out is the file `vcvarsall.bat` which is under the
    `VC\Auxillary\Build` folder. When you click on Developer Command Prompt for VS2017
    on the Start menu, this batch file will be run. If you wish to use an existing
    command prompt to compile C++ code, you can set that up by running this batch
    file. The three most important actions of this batch file are to set up the `PATH`
    environment variable to contain a path to the bin folder, and to set up the `INCLUDE`
    and `LIB` environment variables to point to the include and lib folders, respectively.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件要指出的事情是`vcvarsall.bat`文件，它位于`VC\Auxillary\Build`文件夹下。当你在开始菜单上点击Developer
    Command Prompt for VS2017时，这个批处理文件将被运行。如果你希望使用现有的命令提示符来编译C++代码，你可以通过运行这个批处理文件来设置。这个批处理文件的三个最重要的操作是设置`PATH`环境变量以包含一个指向bin文件夹的路径，并设置`INCLUDE`和`LIB`环境变量分别指向include和lib文件夹。
- en: Now navigate to the root directory and create a new folder, `Beginning_C++`,
    and move to that directory. Next, create a folder for this chapter called `Chapter_01`.
    Now you can switch to Visual Studio; if this is not already running, start it
    from the Start menu.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在导航到根目录并创建一个新文件夹`Beginning_C++`，然后进入该目录。接下来，创建一个名为`Chapter_01`的文件夹。现在你可以切换到Visual
    Studio；如果它还没有运行，可以从开始菜单启动它。
- en: 'In Visual Studio, click the File menu, then New, and then the File... menu
    item to get the New File dialog, and in the left-hand tree-view, click on the Visual
    C++ option. In the middle panel you''ll see two options: C++ File (.cpp) and Header
    File (.h), and C++ properties for `Open` folder, as shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，点击文件菜单，然后选择新建，再选择文件...菜单项，以打开新文件对话框，在左侧树视图中，点击Visual C++选项。在中间面板中，你会看到两个选项：C++文件（.cpp）和头文件（.h），以及`Open`文件夹的C++属性，如下截图所示：
- en: '![](img/092029d9-7d82-4c20-88b6-2f29c506aa3a.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/092029d9-7d82-4c20-88b6-2f29c506aa3a.png)'
- en: The first two file types are used for C++ projects, the third type creates a
    JSON file to aid Visual Studio IntelliSence (help as you type) and will not be
    used in this book.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种文件类型用于C++项目，第三种类型创建一个JSON文件，以帮助Visual Studio IntelliSence（在输入时提供帮助），并且在本书中不会使用。
- en: Click on the first of these and then click the Open button. This will create
    a new empty file called Source1.cpp, so save this to the chapter project folder
    as simple.cpp by clicking on the File menu, then Save Source1.cpp As, and, navigating
    to the project folder, change the name in the File name box to simple.cpp before
    clicking on the Save button.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 点击第一个，然后点击打开按钮。这将创建一个名为Source1.cpp的新空文件，所以将其保存到章节项目文件夹中，命名为simple.cpp，方法是点击文件菜单，然后选择另存为Source1.cpp，然后导航到项目文件夹，在文件名框中更改名称为simple.cpp，最后点击保存按钮。
- en: 'Now you can type in the code for the simple program, shown as following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以输入简单程序的代码，如下所示：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When you have finished typing this code, save the file by clicking on the File menu
    and then the Save simple.cpp option in the menu. You are now ready to compile
    the code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入完这段代码后，通过点击文件菜单然后选择菜单中的保存simple.cpp选项来保存文件。现在你已经准备好编译代码了。
- en: Compiling the code
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译代码
- en: 'Go to the command prompt and type `**cl /?**` command. Since the `PATH` environment
    is set up to include the path to the `bin` folder, you will see the help pages
    for the compiler. You can scroll through these pages by pressing the Return key
    until you get back to the command prompt. Most of these options are beyond the
    scope of this book, but the following table shows some that we will talk about:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 转到命令提示符，输入`**cl /?**`命令。由于`PATH`环境设置为包括`bin`文件夹的路径，您将看到编译器的帮助页面。您可以通过按回车键滚动这些页面，直到返回到命令提示符。这些选项中的大多数超出了本书的范围，但以下表格显示了我们将讨论的一些选项：
- en: '| **Compiler Switch** | **Description** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **编译器开关** | **描述** |'
- en: '| `/c` | Compile only, do not link. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `/c` | 仅编译，不链接。 |'
- en: '| `/D<symbol>` | Defines the constant or macro <symbol>. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `/D<symbol>` | 定义常量或宏<symbol>。 |'
- en: '| `/EHsc` | Enable C++ exception handling but indicate that exceptions from
    `extern ″C″` functions (typically operating system functions) are not handled.
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `/EHsc` | 启用C++异常处理，但指示不处理`extern ″C″`函数（通常是操作系统函数）的异常。 |'
- en: '| `/Fe:<file>` | Provide the name of the executable file to link to. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `/Fe:<file>` | 提供要链接的可执行文件的名称。 |'
- en: '| `/Fo:<file>` | Provide the name of the object file to compile to. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `/Fo:<file>` | 提供要编译的对象文件的名称。 |'
- en: '| `/I <folder>` | Provide the name of a folder to use to search for include
    files. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `/I <folder>` | 提供要用于搜索包含文件的文件夹的名称。 |'
- en: '| `/link<linker options>` | Pass <linker options> to the linker. This must
    come after the source file name and any switches intended for the compiler. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `/link<linker options>` | 将<linker options>传递给链接器。这必须在源文件名和任何用于编译器的开关之后。
    |'
- en: '| `/Tp <file>` | Compile <file> as a C++ file, even if it does not have `.cpp`
    or `.cxx` for its file extension. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `/Tp <file>` | 将<file>编译为C++文件，即使它的文件扩展名不是`.cpp`或`.cxx`。 |'
- en: '| `/U<symbol>` | Remove the previously defined <symbol> macro or constant.
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `/U<symbol>` | 删除先前定义的<symbol>宏或常量。 |'
- en: '| `/Zi` | Enable debugging information. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `/Zi` | 启用调试信息。 |'
- en: '| `/Zs` | Syntax only, do not compile or link. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `/Zs` | 仅语法，不编译或链接。 |'
- en: Note that some options need spaces between the switch and option, some must
    not have a space, and for others, the space is optional. In general, if you have
    the name of a file or folder that contains a space, you should enclose the name
    in double quotes. Before you use a switch, it is best to consult the help files
    to find out how it uses spaces.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，某些选项需要开关和选项之间有空格，某些选项不能有空格，对于其他选项，空格是可选的。一般来说，如果您有一个包含空格的文件或文件夹的名称，您应该用双引号括起来。在使用开关之前，最好查阅帮助文件，了解它如何使用空格。
- en: 'At the command line, type the `**cl simple.cpp**` command. You will find that
    the compiler will issue warnings `**C4530**` and `**C4577**`. The reason is that
    the C++ Standard Library uses exceptions and you have not specified that the compiler
    should provide the necessary support code for exceptions. It is simple to overcome
    these warnings by using the `/EHsc` switch. At the command line, type the `cl
    /EHsc simple.cpp` command. If you typed in the code correctly it should compile:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，输入`**cl simple.cpp**`命令。您会发现编译器会发出警告`**C4530**`和`**C4577**`。原因是C++标准库使用了异常，而您没有指定编译器应提供异常所需的支持代码。使用`/EHsc`开关很容易解决这些警告。在命令行中，输入`cl
    /EHsc simple.cpp`命令。如果您正确输入了代码，它应该可以编译：
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By default, the compiler will compile the file to an object file and then pass
    this file to the linker to link as a command-line executable with the same name
    as the C++ file, but with the `.exe` extension. The line that says `/out:simple.exe`
    is generated by the linker, and `/out` is a linker option.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，编译器将文件编译为对象文件，然后将该文件作为命令行可执行文件传递给链接器，其名称与C++文件相同，但扩展名为`.exe`。`/out:simple.exe`一行是链接器生成的，`/out`是一个链接器选项。
- en: 'List the contents of the folder. You will find three files: `simple.cpp`, the
    source file; simple.obj, the object file which is the output of the compiler;
    and `simple.exe`, the output of the linker after it has linked the object file
    with the appropriate runtime libraries. You may now run the executable by typing
    `simple` on the command line:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列出文件夹的内容。您会发现三个文件：`simple.cpp`，源文件；simple.obj，编译器的输出对象文件；和`simple.exe`，链接器链接了对象文件和适当的运行时库后的输出。现在，您可以通过在命令行上输入`simple`来运行可执行文件：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Passing parameters between the command-line and an executable
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在命令行和可执行文件之间传递参数
- en: Earlier, you found that the `main` function returned a value and by default
    this value is zero. When your application finishes, you can return an error code
    back to the command line; this is so that you can use the executable in batch
    files and scripts, and use the value to control the flow within the script. Similarly,
    when you run an executable, you may pass parameters from the command line, which
    will affect how the executable will behave.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，您发现`main`函数返回一个值，默认情况下这个值是零。当应用程序完成时，您可以将错误代码返回到命令行；这样您可以在批处理文件和脚本中使用可执行文件，并使用该值来控制脚本内的流程。同样，当您运行一个可执行文件时，您可以从命令行传递参数，这将影响可执行文件的行为。
- en: 'Run the simple application by typing the `**simple**` command on the command
    line. In Windows, the error code is obtained through the pseudo environment variable
    `ERRORLEVEL`, so obtain this value through the `**ECHO**` command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在命令行上输入`**simple**`命令来运行简单的应用程序。在Windows中，通过伪环境变量`ERRORLEVEL`获取错误代码，因此通过`**ECHO**`命令获取此值：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To show that this value is returned by the application, change the `main` function
    to return a value other than 0 (in this case, 99, shown highlighted):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示应用程序返回的值，将`main`函数更改为返回非零值（在本例中为99，如下所示）：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Compile this code and run it, and then print out the error code as shown previously.
    You will find that the error code is now given as 99.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '编译此代码并运行它，然后按照之前显示的方式打印出错误代码。您会发现错误代码现在是99。 '
- en: 'This is a very basic mechanism of communication: it only allows you to pass
    integer values, and the scripts that call your code must know what each value
    means. You are much more likely to pass parameters to an application, and these
    will be passed through your code via parameters to the `main` function. Replace
    the `main` function with the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常基本的通信机制：它只允许你传递整数值，调用你的代码的脚本必须知道每个值的含义。你更有可能向应用程序传递参数，并且这些参数将通过`main`函数的参数传递到你的代码中。用以下内容替换`main`函数：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you write the `main` function to take parameters from the command line,
    the convention is that it has these two parameters.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写`main`函数从命令行接受参数时，约定是它有这两个参数。
- en: 'The first parameter is conventionally called `argc`. It is an integer, and
    indicates how many parameters were passed to the application. *This parameter
    is very important.* The reason is that you are about to access memory through
    an array, and this parameter gives the limit of your access. If you access memory
    beyond this limit you will have problems: at best you will be accessing uninitialized
    memory, but at worst you could cause an access violation.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数通常被称为`argc`。它是一个整数，表示传递给应用程序的参数数量。*这个参数非常重要*。原因是你将要通过数组访问内存，这个参数给出了你的访问限制。如果你超出这个限制访问内存，你会遇到问题：最好的情况是访问未初始化的内存，但最坏的情况是可能导致访问违规。
- en: It is important that, whenever you access memory, you understand the amount
    of memory you are accessing and keep within its limits.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 每当访问内存时，重要的是要了解你正在访问的内存量，并保持在其限制内。
- en: 'The second parameter is usually called `argv` and is an array of pointers to
    C strings in memory. You will learn more about arrays and pointers in [Chapter
    4](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml), *Working With Memory, Arrays,
    and Pointers*, and about strings in [Chapter 9](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml),
    *Using Strings*, so we will not give a detailed discussion here. The square brackets
    (`[]`) indicate that the parameter is an array, and the type of each member of
    the array is given by the `char *`. The `*` means that each item is a pointer
    to memory. Normally, this would be interpreted as a pointer to a single item of
    the type given, but strings are different: the `char *` means that in the memory
    the pointer points to there will be zero or more characters followed by the `NUL`
    character (). The length of the string is the count of characters until the `NUL`
    character.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数通常被称为`argv`，是一个指向内存中C字符串的指针数组。你将在[第4章](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml)
    *使用内存、数组和指针*中学到更多关于数组和指针的知识，以及在[第9章](9e1566f8-3b58-4b6d-9753-febcf71cf20a.xhtml)
    *使用字符串*中学到更多关于字符串的知识，所以我们在这里不会进行详细讨论。方括号(`[]`)表示参数是一个数组，数组的每个成员的类型由`char *`给出。`*`表示每个项目是指向内存的指针。通常，这会被解释为指向给定类型的单个项目的指针，但字符串是不同的：`char
    *`表示在指针指向的内存中将会有零个或多个字符，后跟`NUL`字符()。字符串的长度是直到`NUL`字符的字符数。
- en: 'The third line shown here prints to the console the number of strings passed
    to the application. In this example, rather than using the newline escape character
    (`n`) to add a newline, we use the stream `std::endl`. There are several manipulators
    you can use, which will be discussed in Chapter 6, *Classes*. The `std::endl`
    manipulator will put the newline character into the output stream, and then it
    will flush the stream. This line shows that C++ allows you to chain the use of
    the `<<` put operator into a stream. The line also shows you that the `<<` put
    operator is overloaded, that is, there are different versions of the operator
    for different parameter types (in this case, three: one that takes an integer,
    used for `argv`, one that takes a string parameter, and another that takes manipulator
    as a parameter), but the syntax for calling these operators is exactly the same.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的第三行向控制台打印了传递给应用程序的字符串数量。在这个例子中，我们使用流`std::endl`而不是使用换行转义字符(`n`)来添加换行。有几个操纵符可以使用，这将在第6章*类*中讨论。`std::endl`操纵符会将换行字符放入输出流，然后刷新流。这行显示了C++允许你将`<<`放操作符链接到流中。这行还向你展示了`<<`放操作符被重载，也就是说，对于不同的参数类型有不同版本的操作符（在这种情况下有三个：一个接受整数的，用于`argv`，一个接受字符串参数的，另一个接受操纵符作为参数），但调用这些操作符的语法是完全相同的。
- en: 'Finally, there is a code block to print out every string in the `argv` array,
    reproduced here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个代码块来打印`argv`数组中的每个字符串，如下所示：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `for` statement means that the code block will be called until the variable
    `i` is less than the value of `argc`, and after each successful iteration of the
    loop, the variable `i` is incremented (using the prefix increment operator `++`).
    The items in the array are accessed through the square bracket syntax (`[]`).
    The value passed is an *index* into the array.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句意味着代码块将被调用，直到变量`i`小于`argc`的值，并且在每次成功迭代循环后，变量`i`会被递增（使用前缀递增操作符`++`）。通过方括号语法(`[]`)访问数组中的项目。传递的值是数组的*索引*。'
- en: 'Notice that the variable `i` has a starting value of `0`, so the first item
    accessed is `argv[0]`, and since the `for` loop finishes when the variable `i`
    has a value of `argc`, it means that the last item in the array accessed is `argv[argc-1]`.
    This is a typical usage of arrays: the first index is zero and, if there are `n`
    items in the array, the last item has an index of `n-1`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，变量`i`的起始值为`0`，所以访问的第一个项目是`argv[0]`，并且由于`for`循环在变量`i`的值为`argc`时结束，这意味着数组中访问的最后一个项目是`argv[argc-1]`。这是数组的典型用法：第一个索引是零，如果数组中有`n`个项目，最后一个项目的索引是`n-1`。
- en: 'Compile and run this code as you have done before, with no parameters:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 像之前一样编译和运行这段代码，不带参数：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice that, although you did not give a parameter, the program thinks there
    is one: the name of the program executable. In fact, this is not just the name,
    it is the command used to invoke the executable. In this case, you typed the `**simple**` command
    (without the extension) and got the value of the file `simple` as a parameter
    printed on the console. Try this again, but this time invoke the program with
    its full name, `simple.exe`. Now you will find the first parameter is `simple.exe`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管你没有给出参数，程序认为有一个参数：程序可执行文件的名称。实际上，这不仅仅是名称，它是用于调用可执行文件的命令。在这种情况下，你输入了`**simple**`命令（没有扩展名），并在控制台上打印了文件`simple`的值作为参数。再试一次，但这次使用完整名称`simple.exe`调用程序。现在你会发现第一个参数是`simple.exe`。
- en: 'Try calling the code with some actual parameters. Type the `**simple test parameters**` command
    in the command line:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用一些实际参数调用代码。在命令行中输入`**simple test parameters**`命令：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This time the program says that there are three parameters, and it has delimited
    them using the space character. If you want to use a space within a single parameter,
    you should put the entire string in double quotes:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这次程序说有三个参数，并且它已经使用空格字符进行了分隔。如果你想在单个参数中使用空格，你应该将整个字符串放在双引号中：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Bear in mind that `argv` is an array of string pointers, so if you want to pass
    in a numeric type from the command line and you want to use it as a number in
    your program, you will have to convert from its string representation accessed
    through `argv`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`argv`是一个字符串指针数组，所以如果你想从命令行传递一个数字类型，并且想在程序中使用它作为一个数字，你将不得不从通过`argv`访问的字符串表示中进行转换。
- en: The preprocessor and symbols
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理器和符号
- en: The C++ compiler takes several steps to compile a source file. As the name suggests,
    the compiler preprocessor is at the beginning of this process. The preprocessor
    locates the header files and inserts them into the source file. It also substitutes
    macros and defined constants.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: C++编译器在编译源文件时会经历几个步骤。顾名思义，编译器预处理器处于这个过程的开始。预处理器定位头文件并将它们插入到源文件中。它还替换宏和定义的常量。
- en: Defining constants
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义常量
- en: 'There are two main ways to define a constant via the preprocessor: through
    a compiler switch and in code. To see how this works, let''s change the `main`
    function to print out the value of a constant; the two important lines are highlighted:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 定义常量的两种主要方法是通过预处理器：通过编译器开关和代码。要查看这是如何工作的，让我们将`main`函数更改为打印常量的值；两个重要的行已经突出显示：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The line that starts with `#define` is an instruction to the preprocessor,
    and it says that, wherever in the text there is the exact symbol `NUMBER`, it
    should be replaced with 4\. It is a text search and replace, but it will replace
    whole symbols only (so if there is a symbol in the file called `NUMBER99` the
    `NUMBER` part will not be replaced). After the preprocessor has finished its work
    the compiler will see the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以`#define`开头的行是对预处理器的指令，它说，无论在文本中哪里有确切的符号`NUMBER`，它都应该被替换为4。这是一个文本搜索和替换，但它只会替换整个符号（因此如果文件中有一个叫做`NUMBER99`的符号，`NUMBER`部分将不会被替换）。预处理器完成工作后，编译器将看到以下内容：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compile the original code and run it, and confirm that the program simply prints
    4 to the console.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 编译原始代码并运行它，并确认程序只是将4打印到控制台。
- en: 'The text search and replace aspect of the preprocessor can cause some odd results,
    for example, change your `main` function to declare a variable called `NUMBER`,
    as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器的文本搜索和替换方面可能会导致一些奇怪的结果，例如，将你的`main`函数更改为声明一个名为`NUMBER`的变量：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now compile the code. You will get an error from the compiler:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译代码。你将会收到来自编译器的错误：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This indicates that there is an error on line 7, which is the new line declaring
    the variable. However, because of the search and replace conducted by the preprocessor,
    what the compiler sees is a line that looks as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明第7行有一个错误，这是声明变量的新行。然而，由于预处理器进行的搜索和替换，编译器看到的是以下内容：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is not correct C++!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是正确的C++！
- en: In the code that you have typed, it is obvious what is causing the problem because
    you have a `#define` directive for the symbol within the same file. In practice,
    you will include several header files, and these may include files themselves,
    so the errant `#define` directive could be in one of many files. Equally, your
    constant symbols may have the same names as variables in header files included
    after your `#define` directive and may be replaced by the preprocessor.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在你输入的代码中，很明显是什么导致了问题，因为你在同一个文件中为该符号使用了`#define`指令。实际上，你将包括几个头文件，这些头文件本身可能包括文件，因此错误的`#define`指令可能在许多文件中的一个中。同样，你的常量符号可能与在`#define`指令之后包含的头文件中的变量具有相同的名称，并且可能被预处理器替换。
- en: Using `#define` as a way to define global constants is often not a good idea
    and there are much better ways in C++, as you'll see in [Chapter 3](b1227194-5dda-4c73-a8e8-e8d68382abf0.xhtml),
    *Exploring C++ Types*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`#define`作为定义全局常量的方法通常不是一个好主意，在C++中有更好的方法，正如你将在[第3章](b1227194-5dda-4c73-a8e8-e8d68382abf0.xhtml)中看到的，*探索C++类型*。
- en: If you have problems you think are coming from the preprocessor replacing symbols,
    you can investigate this by looking at the source file passed to the compiler
    after the preprocessor has done its work. To do this, compile with the `/EP` switch.
    This will suppress actual compilation and send the output of the preprocessor
    to `stdout` (the command line). Be aware that this could produce a lot of text,
    so it is usually better to direct this output to a file and examine that file
    with the Visual Studio editor.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为问题是由预处理器替换符号引起的，你可以通过查看预处理器完成工作后传递给编译器的源文件来进行调查。为此，使用`/EP`开关进行编译。这将抑制实际编译并将预处理器的输出发送到`stdout`（命令行）。请注意，这可能会产生大量文本，因此通常最好将此输出定向到文件，并使用Visual
    Studio编辑器检查该文件。
- en: 'Another way to provide the values used by the preprocessor is to pass them
    via a compiler switch. Edit the code and remove the line starting with `#define`.
    Compile this code as normal (`**cl /EHsc simple.cpp**`), run it, and confirm that
    the number printed on the console is 99, the value assigned to the variable. Now
    compile the code again with the following line:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 提供给预处理器使用的值的另一种方法是通过编译器开关传递它们。编辑代码并删除以`#define`开头的行。像往常一样编译此代码（`**cl /EHsc simple.cpp**`），运行它，并确认在控制台上打印的数字是99，即分配给变量的值。现在再次使用以下行编译代码：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that there is no space between the `/D` switch and the name of the symbol.
    This tells the preprocessor to replace every `NUMBER` symbol with the text `4`
    and this results in the same errors as above, indicating that the preprocessor
    is attempting to replace the symbol with the value provided.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，/D开关和符号名称之间没有空格。这告诉预处理器将每个`NUMBER`符号替换为文本`4`，这将导致与上述相同的错误，表明预处理器试图用提供的值替换符号。
- en: Tools such as Visual C++ and nmake projects will have a mechanism to define
    symbols through the C++ compiler. The `/D` switch is used to define just one symbol,
    and if you want to define others they will have their own `/D` switch.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Visual C++和nmake项目之类的工具将通过C++编译器定义符号的机制。/D开关用于定义一个符号，如果要定义其他符号，它们将有自己的/D开关。
- en: You are now wondering why C++ has such an odd facility that appears only to
    cause confusing errors. Defining symbols can be very powerful once you understand
    what the preprocessor is doing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在想知道为什么C++有这样一个看似只会导致混乱错误的奇怪功能。一旦您了解了预处理器的工作原理，定义符号就可以变得非常强大。
- en: Using macros
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用宏
- en: One useful feature of preprocessor symbols is **macros**. A macro has parameters
    and the preprocessor will ensure that the search and replace will replace a symbol
    in the macro with the symbol used as a parameter to the macro.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 预处理器符号的一个有用特性是**宏**。宏具有参数，预处理器将确保搜索和替换将使用宏中的符号替换为宏的参数。
- en: 'Edit the `main` function to look as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`main`函数以如下所示：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `main` function calls a macro called `MESSAGE` and passes the command line
    parameters to it. The function then prints the first command line parameters (the
    invocation command) to the console. `MESSAGE` is not a function, it is a macro,
    which means that the preprocessor will replace every occurrence of `MESSAGE` with
    two parameters with the text defined previously, replacing the `c` parameter with
    whatever is passed as the first parameter of the macro, and replacing `v` with
    whatever is used as the second parameter. After the preprocessor has finished
    processing the file, `main` will look as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数调用一个名为`MESSAGE`的宏，并将命令行参数传递给它。然后该函数将第一个命令行参数（调用命令）打印到控制台上。`MESSAGE`不是一个函数，它是一个宏，这意味着预处理器将用之前定义的文本替换每个带有两个参数的`MESSAGE`的出现，将`c`参数替换为宏的第一个参数，将`v`替换为宏的第二个参数。预处理器处理完文件后，`main`将如下所示：'
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that, in the macro definition, the backslash () is used as a line-continuation
    character, so you can have multiline macros. Compile and run this code with one
    or more parameters, and confirm that `MESSAGE` prints out the command-line parameters.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在宏定义中，反斜杠（\）用作换行字符，因此您可以有多行宏。使用一个或多个参数编译和运行此代码，并确认`MESSAGE`打印出命令行参数。
- en: Using symbols
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用符号
- en: You can define a symbol without a value and the preprocessor can be told to
    test for whether a symbol is defined or not. The most obvious situation for this
    is compiling different code for debug builds than for release builds.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定义一个没有值的符号，并且可以告诉预处理器测试符号是否已定义。最明显的情况是为调试构建和发布构建编译不同的代码。
- en: 'Edit the code to add the lines highlighted here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑代码以添加此处突出显示的行：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first line tells the preprocessor to look for the `DEBUG` symbol. If this
    symbol is defined (regardless of its value), then the first definition of the
    `MESSAGE` macro will be used. If the symbol is not defined (a release build) then
    the `MESSAGE` symbol is defined, but it does nothing: essentially, occurrences
    of `MESSAGE` with two parameters will be removed from the code.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行告诉预处理器查找`DEBUG`符号。如果定义了此符号（无论其值如何），则将使用`MESSAGE`宏的第一个定义。如果未定义该符号（发布构建），则`MESSAGE`符号被定义，但不执行任何操作：基本上，带有两个参数的`MESSAGE`的出现将从代码中删除。
- en: 'Compile this code and run the program with one or more parameters. For example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 编译此代码并使用一个或多个参数运行程序。例如：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This shows that the code has been compiled without `DEBUG` defined so `MESSAGE`
    is defined to do nothing. Now compile this code again, but this time with the
    /DDEBUG switch to define the `DEBUG` symbol. Run the program again and you will
    see that the command-line parameters are printed on the console:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明代码已经编译而没有定义`DEBUG`，因此`MESSAGE`被定义为不执行任何操作。现在再次编译此代码，但这次使用/DDEBUG开关来定义`DEBUG`符号。再次运行程序，您将看到命令行参数被打印到控制台上：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code has used a macro, but you can use conditional compilation with symbols
    anywhere in your C++ code. Symbols used in this way allow you to write flexible
    code and choose the code to be compiled through a symbol defined on the compiler
    command line. Furthermore, the compiler will define some symbols itself, for example,
    `__DATE__` will have the current date, `__TIME__` will have the current time,
    and `__FILE__` will have the current file name.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用了一个宏，但您可以在C++代码的任何地方使用符号进行条件编译。以这种方式使用的符号允许您编写灵活的代码，并通过编译器命令行上定义的符号选择要编译的代码。此外，编译器本身将定义一些符号，例如，`__DATE__`将具有当前日期，`__TIME__`将具有当前时间，`__FILE__`将具有当前文件名。
- en: 'Microsoft, and other compiler producers, defines a long list of symbols that
    you can access, and you are advised to look these up in the manual. A few that
    you may find useful are as follows: `__cplusplus` will be defined for C++ source
    files (but not for C files) so you can identify code that needs a C++ compiler;
    `_DEBUG` is set for debug builds (note the preceding underscore), and `_MSC_VER`
    has the current version of the Visual C++ compiler, so you can use the same source
    for various versions of the compiler.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft和其他编译器生产商定义了一长串可以访问的符号，建议您在手册中查找这些符号。您可能会发现一些有用的符号如下：`__cplusplus`将为C++源文件定义（但不会为C文件定义），因此您可以识别需要C++编译器的代码；`_DEBUG`用于调试构建（请注意前面的下划线），`_MSC_VER`具有Visual
    C++编译器的当前版本，因此您可以在各个版本的编译器中使用相同的源代码。
- en: Using pragmas
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用编译器指令
- en: 'Associated with symbols and conditional compilation is the compiler directive,
    `#pragma once`. Pragmas are directives specific to the compiler, and different
    compilers will support different pragmas. Visual C++ defines the `#pragma once`
    to solve the problem that occurs when you have multiple header files each including
    similar header files. The problem is that it may result in the same items being
    defined more than once and the compiler will flag this as an error. There are
    two ways to do this, and the `<iostream>` header file that you include next uses
    both of these techniques. You can find this file in the Visual C++ `include` folder.
    At the top of the file you will find the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 与符号和条件编译相关的是编译器指令`#pragma once`。编译器特定的指令是编译器特定的指令，不同的编译器将支持不同的指令。Visual C++定义了`#pragma
    once`来解决当您有多个头文件每个包含类似的头文件时出现的问题。问题是可能导致相同的项目被定义多次，编译器将将其标记为错误。有两种方法可以解决这个问题，您下一个包含的`<iostream>`头文件将使用这两种技术。您可以在Visual
    C++的`include`文件夹中找到此文件。在文件顶部，您将找到以下内容：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At the bottom, you will find the following line:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，您将找到以下行：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'First the conditional compilation: the first time this header is included,
    the symbol `_IOSTREAM_` will not be defined, so the symbol is defined and then
    the rest of the file will be included until the `#endif` line.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是条件编译：第一次包含此头文件时，符号`_IOSTREAM_`将未定义，因此该符号被定义，然后其余文件将被包含直到`#endif`行。
- en: This illustrates good practice when using conditional compilation. For every
    `#ifndef`, there must be a `#endif`, and often there may be hundreds of lines
    between them. It is a good idea, when you use `#ifdef` or `#ifundef`, to provide
    a comment with the corresponding `#else` and `#endif`, indicating the symbol it
    refers to.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了在使用条件编译时的良好实践。对于每个`#ifndef`，必须有一个`#endif`，并且它们之间可能会有数百行。当您使用`#ifdef`或`#ifundef`时，最好提供一个注释，说明它所指的符号以及相应的`#else`和`#endif`。
- en: If the file is included again then the symbol `_IOSTREAM_` will be defined,
    so the code between the `#ifndef` and `#endif` will be ignored. However, it is
    important to point out that, even if the symbol is defined, the header file will
    still be loaded and processed because the instructions about what to do are contained
    within the file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件再次被包含，则符号`_IOSTREAM_`将被定义，因此在`#ifndef`和`#endif`之间的代码将被忽略。但是，重要的是要指出，即使定义了该符号，头文件仍将被加载和处理，因为关于如何处理的指令包含在文件中。
- en: The `#pragma once` performs the same action as the conditional compilation,
    but it gets around the problem of using a symbol that could be duplicated. If
    you add this single line to the top of your header file, you are instructing the
    preprocessor to load and process this file once. The preprocessor maintains a
    list of the files that it has processed, and if a subsequent header tries to load
    a file that has already been processed, that file will not be loaded and will
    not be processed. This reduces the time it takes for the project to be preprocessed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`#pragma once`执行与条件编译相同的操作，但它解决了使用可能重复的符号的问题。如果将这一行添加到头文件的顶部，您就是在指示预处理器加载和处理此文件一次。预处理器维护了它已处理的文件列表，如果随后的头文件尝试加载已经处理过的文件，那么该文件将不会被加载也不会被处理。这减少了项目预处理所需的时间。'
- en: Before you close the `<iostream>` file, look at the number of lines in the file.
    For `<iostream>` version v6.50:0009 there are 55 lines. This is a small file,
    but it includes `<istream>` (1,157 lines), which includes `<ostream>` (1,036 lines),
    which includes `<ios>` (374 lines), which includes `<xlocnum>` (1,630 lines),
    and so on. The result of preprocessing could mean many tens of thousands of lines
    will be included into your source file even for a program that has one line of
    code!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭`<iostream>`文件之前，查看文件中的行数。对于`<iostream>`版本v6.50:0009，有55行。这是一个小文件，但它包括`<istream>`（1,157行），其中包括`<ostream>`（1,036行），其中包括`<ios>`（374行），其中包括`<xlocnum>`（1,630行），依此类推。预处理的结果可能意味着即使对于只有一行代码的程序，也会包含成千上万行的源文件！
- en: Dependencies
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖关系
- en: A C++ project will produce an executable or library, and this will be built
    by the linker from object files. The executable or library is dependent upon these
    object files. An object file will be compiled from a C++ source file (and potentially
    one or more header files). The object file is dependent upon these C++ source
    and header files. Understanding dependencies is important because it helps you
    understand the order to compile the files in your project, and it allows you to
    make your project builds quicker by only compiling those files that have changed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: C++项目将生成可执行文件或库，这将由链接器从目标文件构建。可执行文件或库依赖于这些目标文件。目标文件将从C++源文件（可能还有一个或多个头文件）编译而成。目标文件依赖于这些C++源文件和头文件。理解依赖关系很重要，因为它可以帮助您理解项目中编译文件的顺序，并且可以通过仅编译已更改的文件来加快项目构建速度。
- en: Libraries
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库
- en: 'When you include a file within your source file, the code within that header
    file will be accessible to your code. Your include file may contain whole function
    or class definitions (these will be covered in later chapters), but this will
    result in the problem mentioned previously: multiple definitions of a function
    or class. Instead, you can declare a class or **function prototype**, which indicates
    how calling code will call the function without actually *defining* it. Clearly,
    the code will have to be defined elsewhere, and this could be a source file or
    a library, but the compiler will be happy because it only sees one definition.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在源文件中包含一个文件时，该头文件中的代码将对您的代码可访问。您的包含文件可能包含整个函数或类的定义（这将在后面的章节中介绍），但这将导致前面提到的问题：函数或类的多重定义。相反，您可以声明一个类或**函数原型**，它指示调用代码将如何调用函数，而不实际*定义*它。显然，代码必须在其他地方定义，这可以是源文件或库，但编译器会很高兴，因为它只看到一个定义。
- en: A library is code that has already been defined; it has been fully debugged
    and tested, and therefore, users should not need to have access to the source
    code. The C++ Standard Library is mostly shared via header files, which helps
    you when you debug your code, but you must resist any temptation to edit these
    files. Other libraries will be provided as compiled libraries.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 库是已经定义好的代码；它已经完全调试和测试过，因此用户不应该需要访问源代码。C++标准库主要通过头文件共享，这有助于您调试代码，但您必须抵制任何编辑这些文件的诱惑。其他库将以编译后的库的形式提供。
- en: 'There are essentially two types of compiled libraries: static libraries and
    dynamic link libraries. If you use a static library, then the compiler will copy
    the compiled code that you use from the static library and place it in your executable.
    If you use a dynamic link (or shared) library, then the linker will add information
    used during runtime (it may be when the executable is loaded, or it may even be
    delayed until the function is called) to load the shared library into memory and
    access the function.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上有两种类型的编译库：静态库和动态链接库。如果您使用静态库，那么编译器将从静态库中复制您使用的编译代码，并将其放入可执行文件中。如果您使用动态链接（或共享）库，那么链接器将在运行时添加信息（可能是在加载可执行文件时，或者甚至延迟到调用函数时）来将共享库加载到内存中并访问函数。
- en: Windows uses the extension `lib` for static libraries and `dll` for dynamic
    link libraries. GNU **gcc** uses the extension `a` for static libraries and `so`
    for shared libraries.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Windows使用扩展名`lib`表示静态库，`dll`表示动态链接库。GNU **gcc**使用扩展名`a`表示静态库，`so`表示共享库。
- en: 'If you use library code in a static or dynamic link library, the compiler will
    need to know that you are calling a function correctly-to make sure your code
    calls a function with the correct number of parameters and correct types. This
    is the purpose of a function prototype: it gives the compiler the information
    it needs to know about calling the function without providing the actual body
    of the function, the function definition.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在静态或动态链接库中使用库代码，编译器将需要知道您是否正确地调用函数-以确保您的代码调用具有正确数量的参数和正确类型的函数。这就是函数原型的目的：它为编译器提供了有关调用函数的信息，而不提供函数的实际主体，即函数定义。
- en: This book will not go into the details of how to write libraries, since it is
    compiler-specific; nor will it go into the details of calling library code, since
    different operating systems have different ways of sharing code. In general, the
    C++ Standard Library will be included in your code through the standard header
    files. The C Runtime Library (which provides some code for the C++ Standard Library)
    will be static-linked, but if the compiler provides a dynamic-linked version you
    will have a compiler option to use this.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不会详细介绍如何编写库，因为这取决于编译器；也不会详细介绍调用库代码的细节，因为不同的操作系统有不同的共享代码方式。一般来说，C++标准库将通过标准头文件包含在您的代码中。C运行时库（为C++标准库提供一些代码）将被静态链接，但如果编译器提供动态链接版本，您将有一个编译器选项来使用它。
- en: Pre-compiled headers
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预编译头文件
- en: When you include a file into your source file, the preprocessor will include
    the contents of that file (after taking into account any conditional compilation
    directives) and, recursively, any files included by that file. As illustrated
    previously, this could result in thousands of lines of code. As you develop your
    code, you will often compile the project so that you can test the code. Every
    time you compile your code, the code defined in the header files will also be
    compiled even though the code in library header files will not have changed. With
    a large project, this can make the compilation take a long time.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将一个文件包含到您的源文件中时，预处理器将包含该文件的内容（在考虑任何条件编译指令后），以及递归地包含该文件包含的任何文件。正如前面所示，这可能导致成千上万行的代码。在开发代码时，您经常会编译项目以便测试代码。每次编译代码时，头文件中定义的代码也将被编译，即使库头文件中的代码没有改变。对于大型项目，这可能会导致编译花费很长时间。
- en: To get around this problem, compilers often offer an option to precompile headers
    that will not change. Creating and using precompiled headers is compiler-specific.
    For example, with the GNU C++ compiler, gcc, you compile a header as if it is
    a C++ source file (with the `/x` switch), and the compiler creates a file with
    an extension of `gch`. When gcc compiles source files that use the header it will
    search for the `gch` file, and if it finds the precompiled header, it will use
    that; otherwise, it will use the header file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，编译器通常提供一个选项来预编译那些不会改变的头文件。创建和使用预编译头文件是与编译器相关的。例如，使用GNU C++编译器gcc，您可以将头文件编译为C++源文件（使用`/x`开关），编译器将创建一个扩展名为`gch`的文件。当gcc编译使用该头文件的源文件时，它将搜索`gch`文件，如果找到预编译头文件，它将使用该文件；否则，它将使用头文件。
- en: In Visual C++ the process is a bit more complicated because you have to specifically
    tell the compiler to look for a precompiled header when it compiles a source file.
    The convention in Visual C++ projects is to have a source file called `stdafx.cpp`,
    which has a single line that includes the file `stdafx.h`. You put all your stable
    header-file includes in `stdafx.h`. Next, you create a precompiled header by compiling
    `stdafx.cpp` using the `/Yc` compiler option to specify that `stdafx.h` contains
    the stable headers to compile. This will create a `pch` file (typically, Visual
    C++ will name it after your project) containing the code compiled up to the point
    of the inclusion of the `stdafx.h` header file. Your other source files must include
    the `stdafx.h` header file as the first header file, but they may also include
    other files. When you compile your source files, you use the `/Yu` switch to specify
    the stable header file (`stdafx.h`), and the compiler will use the precompiled
    header `pch` file instead of the header.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual C++中，这个过程稍微复杂一些，因为你必须明确告诉编译器在编译源文件时查找预编译头文件。在Visual C++项目中的约定是创建一个名为`stdafx.cpp`的源文件，其中包含一行代码，包括文件`stdafx.h`。你将所有稳定的头文件包含在`stdafx.h`中。接下来，通过使用`/Yc`编译器选项编译`stdafx.cpp`来创建一个预编译头文件，指定`stdafx.h`包含了要编译的稳定头文件。这将创建一个`pch`文件（通常，Visual
    C++会根据你的项目命名），其中包含了到包含`stdafx.h`头文件的代码编译的内容。你的其他源文件必须将`stdafx.h`头文件包含为第一个头文件，但它们也可以包含其他文件。在编译源文件时，你使用`/Yu`开关来指定稳定的头文件（`stdafx.h`），编译器将使用预编译头文件`pch`而不是头文件。
- en: When you examine large projects, you will often find precompiled headers are
    used; as you can see, it alters the file structure of the project. The example
    later in this chapter will show how to create and use precompiled headers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查大型项目时，你经常会发现使用了预编译头文件；正如你所看到的，它改变了项目的文件结构。本章后面的示例将展示如何创建和使用预编译头文件。
- en: Project structure
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: It is important to organize your code into modules to enable you to maintain
    it effectively. [Chapter 7](2f4184a2-fec8-4119-a155-389ab43e9f5b.xhtml), *Introduction
    to Object-Orientated Programming*, explains object orientation, which is one way
    to organize and reuse code. However, even if you are writing C-like procedural
    code (that is, your code involves calls to functions in a linear way) you will
    also benefit from organizing it into modules. For example, you may have functions
    that manipulate strings and other functions that access files, so you may decide
    to put the definition of the string functions in one source file, `string.cpp`,
    and the definition of the file functions in another file, `file.cpp`. So that
    other modules in the project can use these files, you must declare the prototypes
    of the functions in a header file and include that header in the module that uses
    the functions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码组织成模块对于有效地进行维护非常重要。[第7章](2f4184a2-fec8-4119-a155-389ab43e9f5b.xhtml)，*面向对象编程简介*，解释了面向对象编程，这是一种组织和重用代码的方式。然而，即使你在编写类似C的过程式代码（即，你的代码涉及线性调用函数），你也会受益于将其组织成模块。例如，你可能有处理字符串的函数和访问文件的其他函数，因此你可能决定将字符串函数的定义放在一个源文件`string.cpp`中，将文件函数的定义放在另一个文件`file.cpp`中。为了让项目中的其他模块可以使用这些文件，你必须在一个头文件中声明这些函数的原型，并在使用这些函数的模块中包含该头文件。
- en: There is no absolute rule in the language about the relationship between the
    header files and the source files that contain the definition of the functions.
    You may have a header file called `string.h` for the functions in `string.cpp`;
    and a header file called `file.h` for the functions in `file.cpp`. Or you may
    have just one file called `utilities.h` that contains the declarations for all
    the functions in both files. The only rule that you have to abide by is that,
    at compile time, the compiler must have access to a declaration of the function
    in the current source file, either through a header file, or the function definition
    itself.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 语言中没有绝对的规则来规定头文件和包含函数定义的源文件之间的关系。你可以为`string.cpp`中的函数创建一个名为`string.h`的头文件；为`file.cpp`中的函数创建一个名为`file.h`的头文件。或者你可以只创建一个名为`utilities.h`的文件，其中包含了这两个文件中所有函数的声明。唯一的规则是，在编译时，编译器必须能够访问当前源文件中函数的声明，无论是通过头文件还是函数定义本身。
- en: The compiler will not *look forward* in a source file, so if function `A` calls
    another function, `B`, in the same source file then function `B` must have already
    been defined before function `A` calls it, or there must be a prototype declaration.
    This leads to a typical convention of having a header file associated with each
    source file that contains the prototypes of the functions in the source file,
    and the source file includes this header. This convention becomes more important
    when you write classes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不会在源文件中*向前查找*，因此如果函数`A`在同一源文件中调用另一个函数`B`，那么函数`B`必须在函数`A`调用它之前已经被定义，或者必须有一个原型声明。这导致了一个典型的约定，即为每个包含源文件中函数原型的源文件创建一个关联的头文件，并且源文件包含这个头文件。当你编写类时，这个约定变得更加重要。
- en: Managing dependencies
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理依赖关系
- en: When a project is built with a building tool, checks are performed to see if
    the output of the build exists and if not, the appropriate actions to build it
    are performed. The common terminology is that the output of a build step is called
    a **target** and the inputs of the build step (for example, source files) are
    the **dependencies** of that target. Each target's dependencies are the files
    used to make them. The dependencies may themselves be a target of a build action
    and have their own dependencies.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用构建工具构建项目时，会执行检查以查看构建的输出是否存在，如果不存在，则执行构建所需的适当操作。常见的术语是构建步骤的输出称为**目标**，构建步骤的输入（例如，源文件）是该目标的**依赖项**。每个目标的依赖项是用于生成它们的文件。这些依赖项本身可能是构建操作的目标，并且具有它们自己的依赖项。
- en: 'For example, the following diagram shows the dependencies in a project:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的图表显示了一个项目中的依赖关系：
- en: '![](img/0998d366-8f1f-4f98-a0a0-9fa730e71d3f.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0998d366-8f1f-4f98-a0a0-9fa730e71d3f.png)'
- en: In this project, there are three source files (`main.cpp`, `file1.cpp`, and
    `file2.cpp`). Each of these includes the same header, `utils.h`, which is precompiled
    (hence there is a fourth source file, `utils.cpp`, that only contains `utils.h`).
    All of the source files depend on `utils.pch`, which in turn depends upon `utils.h`.
    The source file `main.cpp` has the `main` function and calls functions in the
    other two source files (`file1.cpp` and `file2.cpp`), and accesses the functions
    through the associated header files, `file1.h` and `file2.h`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，有三个源文件（`main.cpp`，`file1.cpp`和`file2.cpp`）。每个文件都包含相同的头文件`utils.h`，这是预编译的（因此有第四个源文件`utils.cpp`，只包含`utils.h`）。所有源文件都依赖于`utils.pch`，而`utils.pch`又依赖于`utils.h`。源文件`main.cpp`有`main`函数，并调用其他两个源文件（`file1.cpp`和`file2.cpp`）中的函数，并通过相关的头文件`file1.h`和`file2.h`访问这些函数。
- en: On the first compilation, the build tool will see that the executable depends
    on the four object files, and so it will look for the rule to build each one.
    In the case of the three C++ source files, this means compiling the `cpp` files,
    but since `utils.obj` is used to support the precompiled header, the build rule
    will be different to the other files. When the build tool has made these object
    files, it will then link them together along with any library code (not shown
    here).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次编译时，构建工具将看到可执行文件依赖于四个对象文件，因此它将寻找构建每个对象文件的规则。对于三个C++源文件，这意味着编译`cpp`文件，但由于`utils.obj`用于支持预编译头，构建规则将与其他文件不同。当构建工具制作了这些对象文件后，它将把它们与任何库代码一起链接在一起（这里没有显示）。
- en: Subsequently, if you change `file2.cpp` and build the project, the build tool
    will see that only `file2.cpp` has changed, and since only `file2.obj` depends
    on `file2.cpp`, all the make tool needs to do is compile `file2.cpp` and then
    link the new `file2.obj` with the existing object files to create the executable.
    If you change the header file, `file2.h`, the build tool will see that two files
    depend on this header file, `file2.cpp` and `main.cpp`, and so the build tool
    will compile these two source files and link the new two object files `file2.obj`
    and `main.obj` with the existing object files to form the executable. If, however,
    the precompiled header source file, `util.h`, changes, it means that *all* of
    the source files will have to be compiled.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，如果你改变`file2.cpp`并构建项目，构建工具将看到只有`file2.cpp`已经改变，而只有`file2.obj`依赖于`file2.cpp`，那么make工具需要做的就是编译`file2.cpp`，然后将新的`file2.obj`与现有的对象文件链接在一起创建可执行文件。如果你改变头文件`file2.h`，构建工具将看到两个文件依赖于这个头文件，`file2.cpp`和`main.cpp`，因此构建工具将编译这两个源文件，并将新的两个对象文件`file2.obj`和`main.obj`与现有的对象文件链接在一起形成可执行文件。然而，如果预编译头源文件`util.h`改变了，这意味着*所有*源文件都必须被编译。
- en: For a small project, dependencies are easy to manage, and as you have seen,
    for a single source file project you do not even have to worry about calling the
    linker, because the compiler will do that automatically. As a C++ project gets
    bigger, managing dependencies gets more complex, and this is where development
    environments such as Visual C++ become vital.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个小项目，依赖关系很容易管理，正如你所看到的，对于一个单个源文件项目，你甚至不必担心调用链接器，因为编译器会自动完成这一步。随着C++项目变得更大，管理依赖关系变得更加复杂，这就是开发环境如Visual
    C++变得至关重要的地方。
- en: Makefiles
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Makefiles
- en: If you are supporting a C++ project, you are likely to come across a makefile.
    This is a text file containing the targets, dependencies, and rules for building
    the targets in the project. The makefile is invoked through the make tool, nmake
    on Windows and **make** on Unix-like platforms.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在支持一个C++项目，你可能会遇到一个makefile。这是一个文本文件，包含项目中目标、依赖关系和构建目标的规则。makefile通过make工具调用，Windows上是nmake，Unix类平台上是make。
- en: 'A makefile is a series of rules that look as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: makefile是一系列规则，看起来如下：
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The targets are one or more files that depend on the dependents (which may be
    several files), so that if one or more of the dependents is newer than one or
    more of the targets (and hence has changed since the targets were last built),
    then the targets need to be built again, which is done by running the commands.
    There may be more than one command, and each one is on a separate line prefixed
    with a tab character. A target may have no dependents, in which case the commands
    will always be called.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是一个或多个文件，依赖于依赖项（可能是多个文件），因此如果一个或多个依赖项比一个或多个目标更新（因此自上次构建目标以来已更改），则需要重新构建目标，这是通过运行命令来完成的。可能有多个命令，每个命令都在一个单独的行上，以制表符字符为前缀。一个目标可能没有依赖项，这种情况下命令总是会被调用。
- en: 'For example, using the preceding example, the rule for the executable, `test.exe`
    will be as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用上面的例子，可执行文件`test.exe`的规则将如下：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since the `main.obj` object file depends on the source file `main.cpp`, the
    headers `File1.h` and `File2.h`, and the precompiled header `utils.pch`, the rule
    for this file will be as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`main.obj`对象文件依赖于源文件`main.cpp`，头文件`File1.h`和`File2.h`，以及预编译头`utils.pch`，因此该文件的规则如下：
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The compiler is called with the `/c` switch, which indicates that the code is
    compiled to an object file, but the compiler should not invoke the linker. The
    compiler is told to use the precompiled header file `utils.pch` through the header
    file `utils.h` with the `/Yu` switch. The rules for the other two source files
    will be similar.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器使用`/c`开关调用，表示代码被编译为对象文件，但编译器不应调用链接器。编译器被告知使用预编译头文件`utils.pch`通过头文件`utils.h`使用`/Yu`开关。其他两个源文件的规则将类似。
- en: 'The rule to make the precompiled header file is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 创建预编译头文件的规则如下：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `/Yc` switch tells the compiler to create the precompiled header using the
    header file, `utils.h`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`/Yc`开关告诉编译器使用头文件`utils.h`创建预编译头。'
- en: Makefiles are often much more complicated than this. They will contain macros,
    which group targets, dependents, or command switches. They will contain general
    rules for target types rather than the specific rules shown here, and they will
    have conditional tests. If you need to support or write a makefile, then you should
    look up all of the options in the manual for the tool.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Makefile通常比这复杂得多。它们将包含宏，用于组合目标、依赖项或命令开关。它们将包含目标类型的通用规则，而不是这里显示的具体规则，并且它们将包含条件测试。如果您需要支持或编写makefile，则应查阅工具的手册中的所有选项。
- en: Writing a simple project
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个简单的项目
- en: 'This project will illustrate the features of C++ and projects that you have
    learned in this chapter. The project will use several source files so that you
    can see the effect of dependencies and how the build tool will manage changes
    to the source files. The project is simple: it will ask you to type your first
    name, and then it will print your name and the time and date to the command line.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目将演示您在本章中学到的C++和项目的特性。该项目将使用多个源文件，以便您可以看到依赖关系的影响以及构建工具如何管理对源文件的更改。该项目很简单：它将要求您输入您的名字，然后将您的名字、时间和日期打印到命令行。
- en: The project structure
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'The project uses three functions: the `main` function, which calls two functions
    `print_name` and `print_time`. These are in three separate source files and, since
    the `main` function will call the other two functions in other source files, this
    means the `main` source file will have to have prototypes of those functions.
    In this example, that means a header for each of those files. The project will
    also use a precompiled header, which means a source file and a header file. In
    total, this means three headers and four source files will be used.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目使用三个函数：`main`函数调用两个函数`print_name`和`print_time`。这些函数在三个单独的源文件中，由于`main`函数将调用其他两个源文件中的函数，这意味着`main`源文件将需要这些函数的原型。在这个例子中，这意味着每个文件都需要一个头文件。该项目还将使用预编译头文件，这意味着一个源文件和一个头文件。总共，这意味着将使用三个头文件和四个源文件。
- en: Creating the precompiled header
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建预编译头文件
- en: The code will use the C++ Standard Library to input and output via streams,
    so it will use the `<iostream>` header. The code will use the C++ `string` type
    to handle input, so it will use the `<string>` header. Finally, it accesses the
    C runtime time and date functions, so the code will use the `<ctime>` header.
    These are all standard headers that will not change while you develop the project,
    so they are good candidates for precompiling.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将使用C++标准库通过流进行输入和输出，因此将使用`<iostream>`头文件。该代码将使用C++的`string`类型来处理输入，因此将使用`<string>`头文件。最后，它访问C运行时的时间和日期函数，因此代码将使用`<ctime>`头文件。这些都是标准头文件，在开发项目时不会更改，因此它们是预编译的良好候选。
- en: 'In Visual Studio create a C++ header file and add the following lines:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中创建一个C++头文件，并添加以下行：
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Save the file as `utils.h`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存为`utils.h`。
- en: 'Now create a C++ source file and add a single line to include the header file
    you just created:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个C++源文件，并添加一行以包含您刚刚创建的头文件：
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Save this as `utils.cpp`. You will need to create a makefile for the project,
    so in the New File dialog, select Text File as your file type. Add the following
    rules for building the precompiled header:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存为`utils.cpp`。您需要为项目创建一个makefile，因此在新文件对话框中，选择文本文件作为文件类型。添加以下用于构建预编译头文件的规则：
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Save this file as `makefile.` with the appended period. Since you created this
    file as a text file, Visual Studio will normally automatically give it an extension
    of `txt`, but since we want no extension, you need to add the period to indicate
    no extension. The first line says that the two files, `utils.pch` and `utils.obj`,
    depend on the source file and header file being specified. The second line (prefixed
    with a tab) tells the compiler to compile the C++ file, not to call the linker,
    and it tells the compiler to save the precompiled code included into `utils.h`.
    The command will create `utils.pch` and `utils.obj`, the two targets specified.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`makefile.`并附加句点。由于您将此文件保存为文本文件，Visual Studio通常会自动将其扩展名更改为`txt`，但由于我们不需要扩展名，因此您需要添加句点以指示没有扩展名。第一行表示两个文件`utils.pch`和`utils.obj`依赖于指定的源文件和头文件。第二行（以制表符为前缀）告诉编译器编译C++文件，而不是调用链接器，并告诉编译器将预编译代码保存到`utils.h`中。该命令将创建`utils.pch`和`utils.obj`，这两个指定的目标。
- en: 'When the make utility sees that there are two targets, the default action (when
    a single colon is used between targets and dependencies) is to call the command
    once for each target (there are macros that you can use to determine which target
    is being built). This would mean that the same compiler command would be called
    twice. We do not want this behavior, because both targets are created with a single
    call to the command. The double colon, `::`, is a work around: it tells nmake
    not to use the behavior of calling the command for each target. The result is
    that, when the make utility has called the command once, to make `utils.pch`,
    it then tries to make `utils.obj` but sees that it has already been made, and
    so realizes that it does not need to call the command again.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当make实用程序看到有两个目标时，默认操作（当目标和依赖项之间使用单冒号时）是为每个目标调用一次命令（您可以使用宏来确定正在构建哪个目标）。这意味着同一个编译器命令将被调用两次。我们不希望出现这种行为，因为两个目标是通过一次调用命令创建的。双冒号`::`是一个解决方法：它告诉nmake不要使用为每个目标调用命令的行为。结果是，当make实用程序调用一次命令创建`utils.pch`后，它会尝试创建`utils.obj`，但看到它已经创建，因此意识到不需要再次调用命令。
- en: Now test this out. At the command line, in the folder that contains your project,
    type `nmake`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试一下。在包含您的项目的文件夹中，输入`nmake`命令。
- en: 'If you do not give the name of a makefile, the program maintenance tool will
    automatically use a file called `makefile` (if you want to use a makefile with
    another name, use the `/f` switch to provide the name):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有给出makefile的名称，程序维护工具将自动使用名为`makefile`的文件（如果要使用其他名称的makefile，请使用`/f`开关提供名称）：
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Do a directory listing to confirm that `utils.pch` and `utils.obj` have been
    made.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 进行目录列表以确认`utils.pch`和`utils.obj`已经生成。
- en: Creating the main file
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建主文件
- en: 'Now create a C++ source file and add the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个C++源文件，并添加以下代码：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Save this file as `main.cpp`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`main.cpp`。
- en: The first include file is the precompiled header for the Standard Library headers.
    The other two files provide function prototype declarations for the two functions
    that are called in the `main` function.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个包含文件是标准库头文件的预编译头文件。另外两个文件提供了两个在`main`函数中调用的函数原型声明。
- en: 'You now need to add a rule for the `main` file to the makefile. Add the following
    highlighted line to the top of the file:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您需要为makefile添加一个`main`文件的规则。在文件顶部添加以下突出显示的行：
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This new line says that the `main.obj` target depends on two header files:
    a source file and the precompiled header file, `utils.pch`. At this point, the
    `main.cpp` file will not compile, because the header files do not exist yet. So
    that we can test the makefile, create two C++ header files; in the first header
    file, add the function prototype:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这一新行表示`main.obj`目标依赖于两个头文件：一个源文件和预编译头文件`utils.pch`。此时，`main.cpp`文件将无法编译，因为头文件尚不存在。为了测试makefile，创建两个C++头文件；在第一个头文件中，添加函数原型：
- en: '[PRE37]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Save this file as `name.h`. In the second header file, add the function prototype:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`name.h`。在第二个头文件中，添加函数原型：
- en: '[PRE38]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Save this file as `time.h`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`time.h`。
- en: 'You can now run the make utility, which will compile only the `main.cpp` file.
    Test this out: delete all of the target files by typing `del main.obj utils.obj
    utils.pch` on the command line and then run the make utility again. This time,
    you''ll see that the make utility compiles `utils.cpp` first and then compiles
    `main.cpp`. The reason for this order is because the first target is `main.obj`,
    but since this depends on `utils.pch`, the make tool moves to the next rule and
    uses this to make the precompiled header, before returning to the rule to create
    `main.obj`.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以运行make工具，它将只编译`main.cpp`文件。测试一下：通过在命令行上键入`del main.obj utils.obj utils.pch`来删除所有目标文件，然后再次运行make工具。这一次，您会看到make工具首先编译`utils.cpp`，然后编译`main.cpp`。之所以按照这个顺序是因为第一个目标是`main.obj`，但由于这取决于`utils.pch`，make工具会转移到下一个规则，并使用它来创建预编译头文件，然后返回到创建`main.obj`的规则。
- en: Note that you have not defined `print_name` nor `print_time`, yet the compiler
    does not complain. The reason is that the compiler is only creating object files,
    and it is the responsibility of the linker to resolve the links to the functions.
    The function prototypes in the header files satisfy the compiler that the function
    will be defined in another object file.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您尚未定义`print_name`和`print_time`，但编译器并未抱怨。原因是编译器只创建对象文件，解析函数链接的责任属于链接器。头文件中的函数原型满足编译器，函数将在另一个对象文件中定义。
- en: Using input and output streams
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用输入和输出流
- en: So far, we have seen how to output data to the console via the `cout` object.
    The Standard Library also provides a `cin` stream object to allow you to input
    values from the command line.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到如何通过`cout`对象将数据输出到控制台。标准库还提供了一个`cin`流对象，允许您从命令行输入值。
- en: 'Create a C++ source file and add the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个C++源文件，并添加以下代码：
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Save this file as `name.cpp`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为`name.cpp`。
- en: The first include file is the precompiled header, which will include the two
    Standard Library headers `<iostream>` and `<string>`, so you can use types declared
    in those files. The first line of the function prints the string Your first name?
    on the console. Note that there is a space after the query, so the cursor will
    remain on the same line, ready for the input.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个包含文件是预编译头文件，它将包括两个标准库头文件`<iostream>`和`<string>`，因此您可以使用这些文件中声明的类型。函数的第一行在控制台上打印字符串“Your
    first name?”。请注意，查询后有一个空格，因此光标将保持在同一行上，准备输入。
- en: The next line declares a C++ `string` object variable. Strings are zero or more
    characters, and each character will take up memory. The `string` class does all
    the work of allocating and freeing the memory that will be used by the string.
    This class will be described in more detail in [Chapter 8](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml),
    *Using the Standard Library Containers*. The `cin` overloads the `>>` operator
    to get input from the console. When you press the Enter key the `>>` operator
    will return the characters you typed into the `name` variable (treating the space
    character as a delimiter). The function then prints out the contents of the `name`
    variable to the console without a newline.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行声明了一个C++ `string` 对象变量。字符串是零个或多个字符，每个字符将占用内存。`string` 类负责分配和释放字符串将使用的内存。这个类将在[第8章](b2eeebba-fe22-4565-a40f-6d0bfaee813b.xhtml)中更详细地描述，*使用标准库容器*。`cin`重载了`>>`运算符，从控制台获取输入。当您按下Enter键时，`>>`运算符将返回您键入到`name`变量中的字符（将空格字符视为分隔符）。然后函数将在不换行的情况下将`name`变量的内容打印到控制台上。
- en: 'Now add a rule for this source file to the makefile; add the following lines
    to the top of the file:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为此源文件添加一个规则到makefile；在文件顶部添加以下行：
- en: '[PRE40]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Save this file and run the make tool to confirm that it will make the `name.obj`
    target.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件并运行make工具，确认它将创建`name.obj`目标。
- en: Using time functions
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用时间函数
- en: 'The final source file will obtain the time and print this on the console. Create
    a C++ source file and add the following lines:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的源文件将获取时间并将其打印在控制台上。创建一个C++源文件，并添加以下行：
- en: '[PRE41]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The two functions, `std::time` and `std::gmtime`, are C functions, and `std::time_t`
    is a C type; all are available through the C++ Standard Library. The `std::time`
    function obtains the time as the number of seconds since midnight on January 1,
    1970\. The function returns a value of type `std::time_t`, which is a 64-bit integer.
    The function can optionally copy this value to another variable if you pass a
    pointer to where, in memory, the variable is stored. In this example, we do not
    need this facility, so we pass the C++ `nullptr` to the function to indicate that
    a copy should not be performed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数`std::time`和`std::gmtime`是C函数，`std::time_t`是C类型；所有这些都可以通过C++标准库获得。`std::time`函数获取自1970年1月1日午夜以来的秒数作为时间。该函数返回`std::time_t`类型的值，这是一个64位整数。如果您传递一个指向变量存储位置的指针，该函数可以选择将此值复制到另一个变量中。在这个例子中，我们不需要这个功能，所以我们将C++的`nullptr`传递给函数，表示不应执行复制。
- en: Next, we need to convert the number of seconds to a string that has the time
    and date in a format you can understand. This is the purpose of the `std::ctime`
    function, which takes as a parameter a pointer to the variable that holds the
    number of seconds. The `now` variable has the number of seconds, and the `&` operator
    is used to obtain the address of this variable in memory. Memory and pointers
    are covered in more detail in [Chapter 4](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml),
    *Working With Memory, Arrays, and Pointers*. This function returns a string, but
    you have not allocated any memory for this string, nor should you attempt to free
    the memory used by this string. The `std::ctime` function creates a **statically
    allocated** memory buffer, which will be used by all the code running on the current
    execution thread. Every time you call the `std::ctime` function on the same thread
    of execution, the memory location used will be the same, although the contents
    of the memory may change.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将秒数转换为您可以理解的时间和日期格式的字符串。这就是`std::ctime`函数的目的，它以指向保存秒数的变量的指针作为参数。`now`变量包含秒数，`&`运算符用于获取该变量在内存中的地址。内存和指针在[第4章](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml)，*内存、数组和指针的使用*中有更详细的介绍。该函数返回一个字符串，但您没有为该字符串分配任何内存，也不应尝试释放该字符串使用的内存。`std::ctime`函数创建一个**静态分配**的内存缓冲区，该缓冲区将被当前执行线程上运行的所有代码使用。每次在同一执行线程上调用`std::ctime`函数时，使用的内存位置将是相同的，尽管内存的内容可能会改变。
- en: This function illustrates how important it is to check the manual to see who
    has responsibility for allocating and freeing memory. [Chapter 4](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml),
    *Working With Memory, Arrays, and Pointers*, goes into more detail about memory
    allocation.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数说明了查看手册以查看谁负责分配和释放内存是多么重要。[第4章](63ba5350-63d3-4dff-9ba2-b330f041d670.xhtml)，*内存、数组和指针的使用*，更详细地介绍了内存分配。
- en: The string returned from `std::ctime` is printed to the console using several
    calls to the put `<<` operator to format the output.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 从`std::ctime`返回的字符串使用多次调用`<<`运算符打印到控制台以格式化输出。
- en: 'Now add a build rule to the makefile. Add the following to the top of the file:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在makefile中添加一个构建规则。在文件顶部添加以下内容：
- en: '[PRE42]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Save this file and run the make tool, and confirm that it builds the `time.obj`
    target.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件并运行make工具，并确认它构建了`time.obj`目标。
- en: Building the executable
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建可执行文件
- en: 'You now have all the object files needed for your project, so the next task
    is to link them together. To do this, add the following line to the top of the
    makefile:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经拥有项目所需的所有对象文件，下一个任务是将它们链接在一起。为此，在makefile的顶部添加以下行：
- en: '[PRE43]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The target here is the executable, and the dependents are the four object files.
    The command to build the executable calls the link tool and uses a special syntax.
    The `$@` symbol is interpreted by the make tool as use the target, and so the
    `/out` switch will actually be `/out:time_test.out`. The `$**` symbol is interpreted
    by the make tool as *use all the dependencies* so that all the dependencies are
    linked.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是可执行文件，依赖项是四个对象文件。构建可执行文件的命令调用链接工具并使用特殊的语法。`$@`符号被make工具解释为使用目标，因此`/out`开关实际上将是`/out:time_test.out`。`$**`符号被make工具解释为*使用所有依赖项*，因此所有依赖项都会被链接。
- en: Save this file and run the make utility. You should find that only the link
    tool will be called, and it will link together the object files to create the
    executable.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件并运行make工具。您会发现只有链接工具会被调用，并且它将链接对象文件以创建可执行文件。
- en: 'Finally, add a rule to clean the project. It is good practice to provide a
    mechanism to remove all of the files created by the compile process and leave
    the project clean, with only the source files. After the line to link the object
    files, add the following lines:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加一个清理项目的规则。提供一种机制来删除编译过程创建的所有文件，并保持项目干净，只留下源文件是一个很好的做法。在链接对象文件的行之后，添加以下行：
- en: '[PRE44]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The target `clean` is a pseudo target: no file is actually made, and for this
    reason, there are no dependencies. This illustrates a feature of the make utility:
    if you call nmake with the name of a target, the utility will make just that target.
    If you do not specify a target then the utility will make the first target mentioned
    in the makefile, in this case `time_test.exe`.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`clean`目标是一个伪目标：实际上没有文件被创建，因此也没有依赖项。这说明了make工具的一个特性：如果您使用目标的名称调用nmake，该工具将只制作该目标。如果您不指定目标，则该工具将制作makefile中提到的第一个目标，在本例中是`time_test.exe`。'
- en: The `clean` pseudo target has three commands. The first command prints `Cleaning
    the project...` to the console. The `@` symbol here tells the make utility to
    run the command without printing the command to the console. The second and third
    commands call the command-line tool `del` to delete the files. Clean the project
    now by typing `nmake clean` on the command line, and confirm that the directory
    has just the header files, source files, and the makefile.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`clean`伪目标有三个命令。第一个命令将`Cleaning the project...`打印到控制台。这里的`@`符号告诉make实用程序运行命令而不将命令打印到控制台。第二和第三个命令调用命令行工具`del`来删除文件。现在通过在命令行上输入`nmake
    clean`来清理项目，并确认目录中只有头文件、源文件和makefile。'
- en: Testing the code
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码
- en: 'Run the make utility again so that the executable is built. On the command
    line, run the example by typing the `**time_test**` command. You will be asked
    to type your first name; do this, and press the Enter key. You should find that
    your name, the time, and date are printed on the console:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行make实用程序，以便构建可执行文件。在命令行上，通过输入`**time_test**`命令来运行示例。系统会要求您输入您的名字；请这样做，并按Enter键。您会发现您的名字、时间和日期被打印在控制台上：
- en: '[PRE45]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Changing the project
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改项目
- en: 'Now that you have the basic project structure, with a makefile you can make
    changes to the files and be reassured that, when the project is rebuilt, only
    the files that have changed will be compiled. To illustrate this, change the `print_name`
    function in `name.cpp` to ask for your name in a more polite way. Change the first
    line in the function body as highlighted here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了基本的项目结构，有了一个makefile，您可以对文件进行更改，并放心，当项目重新构建时，只有更改的文件才会被编译。为了说明这一点，将`name.cpp`中的`print_name`函数更改为以更礼貌的方式要求您的名字。更改函数体中的第一行如下所示：
- en: '[PRE46]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Save the file and then run the make utility. This time, only the `name.cpp`
    source file is compiled, and the resulting file, `name.obj`, is linked with the
    existing object files.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，然后运行make实用程序。这次，只有`name.cpp`源文件被编译，生成的文件`name.obj`与现有的对象文件链接。
- en: 'Now change the `name.h` header file and add a comment in the file:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更改`name.h`头文件并在文件中添加注释：
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Make the project. What do you find? This time, *two* source files are compiled,
    `name.cpp` and `main.cpp`, and they are linked with the existing object files
    to create the executable. To see why these two files are compiled, take a look
    at the dependency rules in the makefile. The only file that was changed was `name.h`,
    and this file is named in the dependency list of `name.obj` and `main.obj`, hence,
    these two files are rebuilt. Since these two files are in the dependency list
    of `time_test.exe`, the executable will be rebuilt, too.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 制作项目。您发现了什么？这次，*两个*源文件被编译，`name.cpp`和`main.cpp`，它们与现有的对象文件链接以创建可执行文件。要了解为什么这两个文件被编译，请查看makefile中的依赖规则。唯一更改的文件是`name.h`，并且该文件在`name.obj`和`main.obj`的依赖列表中，因此，这两个文件将被重新构建。由于这两个文件在`time_test.exe`的依赖列表中，因此可执行文件也将被重新构建。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was a gentle, but thorough, introduction to C++. You learned about
    the reasons to use the language and how to install the compiler from one vendor.
    You learned how C++ projects are structured, about source files and header files,
    and how code is shared through libraries. You also learned how to maintain projects
    using makefiles, and, through a simple example, you have had hands-on experience
    of editing and compiling code.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对C++的温和但彻底的介绍。您了解了使用这种语言的原因以及如何从一个供应商那里安装编译器。您了解了C++项目的结构，源文件和头文件，以及代码如何通过库共享。您还学会了如何使用makefile来维护项目，并通过一个简单的示例，您已经亲身体验了编辑和编译代码。
- en: You have a compiler, an editor, and a tool to manage projects, so now you are
    ready to learn more details about C++, starting in the following chapter with
    C++ statements and controlling execution flow in an application.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经有了编译器、编辑器和项目管理工具，现在您可以准备学习更多关于C++的细节，从下一章开始学习C++语句和控制应用程序的执行流程。
