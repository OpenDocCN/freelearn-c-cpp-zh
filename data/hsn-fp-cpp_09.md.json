["```cpp\nauto lineFilledWith = [](const auto& line, const auto tokenToCheck){\n    return all_of_collection(line, [&tokenToCheck](auto const token){   \n        return token == tokenToCheck;});\n};\n```", "```cpp\nauto lineFilledWithX = [](const auto& line){\n    return lineFilledWith(line, 'X');\n};\n```", "```cpp\nauto lineFilledWithX = bind(lineFilledWith, _1, 'X'); \nauto lineFilledWithO = bind(lineFilledWith, _1, 'O');\n```", "```cpp\nint processA(){\n    a  = f1(....)\n    b = f2(a, ...)\n    c = f3(b, ...)\n}\n```", "```cpp\nint processB(){\n    a  = f1Prime(....)\n    b = f2(a, ...)\n    c = f3(b, ...)\n}\n```", "```cpp\nint processA(){\n    a  = f1(....)\n    return doSomething(a)\n}\n\nint processB(){\n    a = f1Prime(....)\n    return doSomething(a)\n}\n\nint doSomething(auto a){\n    b = f2(a, ...)\n    return f3(b, ...)\n}\n```", "```cpp\nprocessA = f3(f2(f1(....), ...), ...)\nprocessB = f3(f2(f1Prime(....), ...), ...)\n```", "```cpp\nC = f3 \u2218 f2\nprocessA = C \u2218 f1\nprocessB  = C \u2218 f1Prime\n```", "```cpp\nauto lineFilledWith = [](const auto& line, const auto& tokenToCheck){\n    return allOfCollection(line, [&tokenToCheck](const auto& token){  \n        return token == tokenToCheck;});\n};\n\nauto lineFilledWithX = bind(lineFilledWith, _1, 'X'); \nauto lineFilledWithO = bind(lineFilledWith, _1, 'O');\n\nauto xWins = [](const auto& board){\n    return any_of_collection(allLinesColumnsAndDiagonals(board), \n        lineFilledWithX);\n};\n\nauto oWins = [](const auto& board){\n    return any_of_collection(allLinesColumnsAndDiagonals(board), \n        lineFilledWithO);\n};\n\n```", "```cpp\nauto xWins = [](const auto& board){\n    return any_of_collection(allLinesColumnsAndDiagonals(board), []  \n        (const auto& line) { return lineFilledWith(line, 'X');});\n};\n\nauto oWins = [](const auto& board){\n    return any_of_collection(allLinesColumnsAndDiagonals(board), []\n        (const auto& line) { return lineFilledWith(line, 'O');});\n};\n```", "```cpp\nauto tokenWins = [](const auto& board, const auto& token){\n    return any_of_collection(allLinesColumnsAndDiagonals(board),  \n        [token](auto line) { return lineFilledWith(line, token);});\n};\nauto xWins = [](auto const board){\n    return tokenWins(board, 'X');\n};\n\nauto oWins = [](auto const board){\n    return tokenWins(board, 'O');\n}\n```", "```cpp\nauto xWins = bind(tokenWins, _1, 'X');\nauto oWins = bind(tokenWins, _1, 'O');\n```", "```cpp\nauto tokenWins = [](const auto& board, const auto& token){\n    return any_of_collection(allLinesColumnsAndDiagonals(board),  \n        [token](auto line) { return lineFilledWith(line, token);});\n};\n```", "```cpp\nauto tokenWins = [](const auto& board, const auto& token){\n    return any_of_collection(\n            allLinesColumnsAndDiagonals(board), \n            bind(lineFilledWith, _1, token)\n    );\n};\n```", "```cpp\ntemplate <typename F, typename G, typename H>\nauto foo(F f, G g, H h){\n    return [=](auto first, auto second){\n    return f(g(first), \n    bind(h, _1, second));\n    };\n}\nauto tokenWins = compose(any_of_collection, allLinesColumnsAndDiagonals, lineFilledWith);\n```", "```cpp\ntemplate <typename CollectionBooleanOperation, typename CollectionProvider, typename Predicate>\nauto booleanOperationOnProvidedCollection(CollectionBooleanOperation collectionBooleanOperation, CollectionProvider collectionProvider, Predicate predicate){\n    return [=](auto collectionProviderSeed, auto predicateFirstParameter){\n      return collectionBooleanOperation(collectionProvider(collectionProviderSeed), \n              bind(predicate, _1, predicateFirstParameter));\n  };\n}\nauto tokenWins = booleanOperationOnProvidedCollection(any_of_collection, allLinesColumnsAndDiagonals, lineFilledWith);\n```", "```cpp\nenum Result {\n    XWins,\n    OWins,\n    GameNotOverYet,\n    Draw\n};\n\nResult winner(const Board& board){ \n    if(board.anyLineFilledWith(Token::X) ||    \n        board.anyColumnFilledWith(Token::X) || \n        board.anyDiagonalFilledWith(Token::X)) \n    return XWins; \n\n    if(board.anyLineFilledWith(Token::O) ||  \n        board.anyColumnFilledWith(Token::O) ||  \n        board.anyDiagonalFilledWith(Token::O)) \n    return OWins; \n\n    if(board.notFilledYet()) \n    return GameNotOverYet; \n\nreturn Draw; \n}\n```", "```cpp\nenum Token {\n    X,\n    O,\n    Blank\n};\n\n```", "```cpp\nusing Line = vector<Token>;\n\nclass Board{\n    private: \n        const vector<Line> _board;\n\n    public: \n        Board() : _board{Line(3, Token::Blank), Line(3, Token::Blank),  \n            Line(3, Token::Blank)}{}\n        Board(const vector<Line>& initial) : _board{initial}{}\n...\n}\n```", "```cpp\n        bool anyLineFilledWith(const Token& token) const{\n            for(int i = 0; i < 3; ++i){\n                if(_board[i][0] == token && _board[i][1] == token &&  \n                    _board[i][2] == token){\n                    return true;\n                }\n            }\n            return false;\n        };\n```", "```cpp\nif(condition) return value;\n```", "```cpp\nauto tokenWins = [](const auto board, const auto& token){\n    return board.anyLineFilledWith(token) ||   \nboard.anyColumnFilledWith(token) || board.anyDiagonalFilledWith(token);\n};\n\nauto xWins = bind(tokenWins, _1, Token::X);\nauto oWins = bind(tokenWins, _1, Token::O);\n\nauto gameNotOverYet = [](auto board){\n    return board.notFilledYet();\n};\n\nResult winner(const Board& board){ \n    auto gameNotOverYetOnBoard = bind(gameNotOverYet, board);\n    auto xWinsOnBoard = bind(xWins, board);\n    auto oWinsOnBoard = bind(oWins, board);\n\n    if(xWins()) \n        return XWins; \n\n    if(oWins())\n        return OWins; \n\n    if(gameNotOverYetOnBoard()) \n        return GameNotOverYet; \n\n    return Draw; \n}\n```", "```cpp\nauto True = [](){\n    return true;\n};\n\nResult winner(Board board){\n    auto gameNotOverYetOnBoard = bind(gameNotOverYet, board);\n    auto xWinsOnBoard = bind(xWins, board);\n    auto oWinsOnBoard = bind(oWins, board);\n\n    vector<pair<function<bool()>, Result>> rules = {\n        {xWins, XWins},\n        {oWins, OWins},\n        {gameNotOverYetOnBoard, GameNotOverYet},\n        {True, Draw}\n    };\n\n    auto theRule = find_if(rules.begin(), rules.end(), [](auto pair){\n            return pair.first();\n            });\n    // theRule will always be found, the {True, Draw} by default.\n    return theRule->second;\n}\n```", "```cpp\nauto True = [](){\n    return true;\n};\n\nusing Rule = pair<function<bool()>, Result>;\n\nauto condition = [](auto rule){\n    return rule.first();\n};\n\nauto result = [](auto rule){\n    return rule.second;\n};\n\n// assumes that a rule is always found\nauto findTheRule = [](const auto& rules){\n    return *find_if(rules.begin(), rules.end(), [](auto rule){\n return condition(rule);\n });\n};\n\nauto resultForFirstRuleThatApplies = [](auto rules){\n    return result(findTheRule(rules));\n};\n\nResult winner(Board board){\n    auto gameNotOverYetOnBoard = bind(gameNotOverYet, board);\n    vector<Rule> rules {\n        {xWins, XWins},\n        {oWins, OWins},\n        {gameNotOverYetOnBoard, GameNotOverYet},\n        {True, Draw}\n    };\n\n    return resultForFirstRuleThatApplies(rules);\n}\n```"]