["```cpp\n'&' \n\n```", "```cpp\n'*' \n\n```", "```cpp\n// Declare a pointer to hold the address of a variable of type int \n\nint* pHealth; \n\n```", "```cpp\nint* pHealth; \n\n```", "```cpp\nint * pHealth; \n\n```", "```cpp\nint *pHealth; \n\n```", "```cpp\n// A regular int variable called health \nint health = 5; \n\n// Declare a pointer to hold the address of a variable of type int \nint* pHealth; \n\n// Initialize pHealth to hold the address of health, \n// using the \"address of\" operator \npHealth = &health; \n\n```", "```cpp\n  pHealth = &health; \n\n```", "```cpp\n// A regular int variable called health \nint health = 5; \nint score = 0; \n\n// Declare a pointer to hold the address of a variable of type int \nint* pHealth; \n\n// Initialize pHealth to hold the address of health \npHealth = &health; \n\n// Re-initialize pHealth to hold the address of score \npHealth = &score; \n\n```", "```cpp\n// Some regular int variables \nint score = 0; \nint hiScore = 10; \n\n// Declare 2 pointers to hold the addresses of ints \nint* pIntPointer1; \nint* pIntPointer2; \n\n// Initialize pIntPointer1 to hold the address of score \npIntPointer1 = &score; \n\n// Initialize pIntPointer2 to hold the address of hiScore \npIntPointer2 = &hiScore; \n\n// Add 10 to score directly \nscore += 10; \n// Score now equals 10 \n\n// Add 10 to score using pIntPointer1 \n*pIntPointer1 += 10; \n// score now equals 20- A new high score \n\n// Assign the new hi score to hiScore using only pointers \n*pIntPointer2 = *pIntPointer1; \n// hiScore and score both equal 20 \n\n```", "```cpp\n// Add 10 to score using pIntPointer1 \n*pIntPointer1 += 10; \n// score now equals 20, A new high score \n\n```", "```cpp\n// Assign the new hi-score to hiScore with only pointers \n*pIntPointer2 = *pIntPointer1; \n// hiScore and score both equal 20 \n\n```", "```cpp\nint* pToInt = nullptr; \n\n```", "```cpp\npToInt = new int; \n\n```", "```cpp\ndelete pToInt; \n\n```", "```cpp\npToInt = nullptr; \n\n```", "```cpp\nvoid myFunction(int *pInt) \n{ \n   // dereference and increment the value stored  \n   // at the address pointed to by the pointer \n   *pInt ++ \n   return; \n} \n\n```", "```cpp\nint someInt = 10; \nint* pToInt = &someInt; \n\nmyFunction(&someInt); \n// someInt now equals 11 \n\nmyFunction(pToInt); \n// someInt now equals 12 \n\n```", "```cpp\nPlayer player; \nPlayer* pPlayer = &Player; \n\n```", "```cpp\n// Call a member function of the player class \npPlayer->moveLeft() \n\n```", "```cpp\n// Declare an array of ints \nint arrayOfInts[100]; \n//  Declare a pointer to int and initialize it with the address of the first element of the array, arrayOfInts \nint* pToIntArray = arrayOfInts; \n\n// Use pToIntArray just as you would arrayOfInts \narrayOfInts[0] = 999; \n// First element of arrayOfInts now equals 999 \n\npToIntArray[0] = 0; \n// First element of arrayOfInts now equals 0 \n\n```", "```cpp\nmap<string, int> accounts; \n\n```", "```cpp\naccounts[\"John\"] = 1234567; \n\n```", "```cpp\naccounts[\"Onkar\"] = 7654321; \naccounts[\"Wilson\"] = 8866772; \n\n```", "```cpp\nint accountNumber = accounts[\"Onkar\"]; \n\n```", "```cpp\naccounts.erase(\"John\"); \n\n```", "```cpp\nint size = accounts.size(); \n\n```", "```cpp\nif(accounts.find(\"John\") != accounts.end()) \n{ \n   // This code won't run because John was erased \n} \n\nif(accounts.find(\"Onkar\") != accounts.end()) \n{ \n   // This code will run because Onkar is in the map \n} \n\n```", "```cpp\nfor (map<string,int>::iterator it = accounts.begin(); it ! = \n  accounts.end();  ++ it) \n{ \n    it->second +=1; \n} \n\n```", "```cpp\nfor (auto it = accounts.begin(); it != accounts.end();  ++ it) \n{ \n    it->second +=1; \n} \n\n```", "```cpp\n#pragma once \n#ifndef TEXTURE_HOLDER_H \n#define TEXTURE_HOLDER_H \n\n#include <SFML/Graphics.hpp> \n#include <map> \n\nusing namespace sf; \nusing namespace std; \n\nclass TextureHolder \n{ \nprivate: \n   // A map container from the STL, \n   // that holds related pairs of String and Texture \n   std::map<std::string, Texture> m_Textures; \n\n   // A pointer of the same type as the class itself \n   // the one and only instance \n   static TextureHolder* m_s_Instance; \n\npublic: \n   TextureHolder(); \n   static Texture& GetTexture(string const& filename); \n\n}; \n\n#endif \n\n```", "```cpp\nstatic TextureHolder* m_s_Instance; \n\n```", "```cpp\nstatic Texture& GetTexture(string const& filename); \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"TextureHolder.h\" \n\n// Include the \"assert feature\" \n#include <assert.h> \n\nTextureHolder* TextureHolder::m_s_Instance = nullptr; \n\nTextureHolder::TextureHolder() \n{ \n   assert(m_s_Instance == nullptr); \n   m_s_Instance = this; \n} \n\n```", "```cpp\nsf::Texture& TextureHolder::GetTexture(std::string const& filename) \n{ \n   // Get a reference to m_Textures using m_S_Instance \n   auto& m = m_s_Instance->m_Textures; \n   // auto is the equivalent of map<string, Texture> \n\n   // Create an iterator to hold a key-value-pair (kvp) \n   // and search for the required kvp \n   // using the passed in filename \n   auto keyValuePair = m.find(filename); \n   // auto is equivelant of map<string, Texture>::iterator \n\n   // Did we find a match? \n   if (keyValuePair != m.end()) \n   { \n      // Yes \n      // Return the texture, \n      // the second part of the kvp, the texture \n      return keyValuePair->second; \n   } \n   else \n   { \n      // Filename not found \n      // Create a new key value pair using the filename \n      auto& texture = m[filename]; \n      // Load the texture from file in the usual way \n      texture.loadFromFile(filename); \n\n      // Return the texture to the calling code \n      return texture; \n   } \n} \n\n```", "```cpp\n#pragma once \n#include <SFML/Graphics.hpp> \n\nusing namespace sf; \n\nclass Zombie \n{ \nprivate: \n   // How fast is each zombie type? \n   const float BLOATER_SPEED = 40; \n   const float CHASER_SPEED = 80; \n   const float CRAWLER_SPEED = 20; \n\n   // How tough is each zombie type \n   const float BLOATER_HEALTH = 5; \n   const float CHASER_HEALTH = 1; \n   const float CRAWLER_HEALTH = 3; \n\n   // Make each zombie vary its speed slightly \n   const int MAX_VARRIANCE = 30; \n   const int OFFSET = 101 - MAX_VARRIANCE; \n\n   // Where is this zombie? \n   Vector2f m_Position; \n\n   // A sprite for the zombie \n   Sprite m_Sprite; \n\n   // How fast can this one run/crawl? \n   float m_Speed; \n\n   // How much health has it got? \n   float m_Health; \n\n   // Is it still alive? \n   bool m_Alive; \n\n   // Public prototypes go here \n}; \n\n```", "```cpp\n   // Is it still alive? \n   bool m_Alive; \n\n   // Public prototypes go here\n   public:\n   // Handle when a bullet hits a zombie\n   bool hit();\n\n   // Find out if the zombie is alive\n   bool isAlive();\n\n   // Spawn a new zombie\n   void spawn(float startX, float startY, int type, int seed);\n\n   // Return a rectangle that is the position in the world\n   FloatRect getPosition();\n\n   // Get a copy of the sprite to draw\n   Sprite getSprite();\n\n   // Update the zombie each frame\n   void update(float elapsedTime, Vector2f playerLocation); \n\n}; \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"zombie.h\" \n#include \"TextureHolder.h\" \n#include <cstdlib> \n#include <ctime> \n\nusing namespace std; \n\n```", "```cpp\nvoid Zombie::spawn(float startX, float startY, int type, int seed) \n{ \n\n   switch (type) \n   { \n   case 0: \n      // Bloater \n      m_Sprite = Sprite(TextureHolder::GetTexture( \n         \"graphics/bloater.png\")); \n\n      m_Speed = 40; \n      m_Health = 5; \n      break; \n\n   case 1: \n      // Chaser \n      m_Sprite = Sprite(TextureHolder::GetTexture( \n         \"graphics/chaser.png\")); \n\n      m_Speed = 70; \n      m_Health = 1; \n      break; \n\n   case 2: \n      // Crawler \n      m_Sprite = Sprite(TextureHolder::GetTexture( \n         \"graphics/crawler.png\")); \n\n      m_Speed = 20; \n      m_Health = 3; \n      break; \n   } \n\n   // Modify the speed to make the zombie unique \n   // Every zombie is unique. Create a speed modifier \n   srand((int)time(0) * seed); \n\n   // Somewhere between 80 an 100 \n   float modifier = (rand() % MAX_VARRIANCE) + OFFSET; \n\n   // Express this as a fraction of 1 \n   modifier /= 100; // Now equals between .7 and 1 \n   m_Speed *= modifier; \n\n   // Initialize its location \n   m_Position.x = startX; \n   m_Position.y = startY; \n\n   // Set its origin to its center \n   m_Sprite.setOrigin(25, 25); \n\n   // Set its position \n   m_Sprite.setPosition(m_Position); \n} \n\n```", "```cpp\nbool Zombie::hit() \n{ \n   m_Health--; \n\n   if (m_Health < 0) \n   { \n      // dead \n      m_Alive = false; \n      m_Sprite.setTexture(TextureHolder::GetTexture( \n         \"graphics/blood.png\")); \n\n      return true;  \n   } \n\n   // injured but not dead yet \n   return false; \n} \n\n```", "```cpp\nbool Zombie::isAlive() \n{ \n   return m_Alive; \n} \n\nFloatRect Zombie::getPosition() \n{ \n   return m_Sprite.getGlobalBounds(); \n} \n\nSprite Zombie::getSprite() \n{ \n   return m_Sprite; \n} \n\n```", "```cpp\nvoid Zombie::update(float elapsedTime,  \n   Vector2f playerLocation) \n{ \n   float playerX = playerLocation.x; \n   float playerY = playerLocation.y; \n\n   // Update the zombie position variables \n   if (playerX > m_Position.x) \n   { \n      m_Position.x = m_Position.x +  \n         m_Speed * elapsedTime; \n   } \n\n   if (playerY > m_Position.y) \n   { \n      m_Position.y = m_Position.y +  \n         m_Speed * elapsedTime; \n   } \n   if (playerX < m_Position.x) \n   { \n      m_Position.x = m_Position.x -  \n         m_Speed * elapsedTime; \n   } \n\n   if (playerY < m_Position.y) \n   { \n      m_Position.y = m_Position.y -  \n         m_Speed * elapsedTime; \n   } \n\n   // Move the sprite \n   m_Sprite.setPosition(m_Position); \n\n   // Face the sprite in the correct direction \n   float angle = (atan2(playerY - m_Position.y, \n      playerX - m_Position.x) \n      * 180) / 3.141; \n\n   m_Sprite.setRotation(angle); \n\n} \n\n```", "```cpp\n#pragma once \n#include \"Zombie.h\" \n\nusing namespace sf; \n\nint createBackground(VertexArray& rVA, IntRect arena); \nZombie* createHorde(int numZombies, IntRect arena);\n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"ZombieArena.h\" \n#include \"Zombie.h\" \n\nZombie* createHorde(int numZombies, IntRect arena)  \n{ \n   Zombie* zombies = new Zombie[numZombies]; \n\n   int maxY = arena.height - 20; \n   int minY = arena.top + 20; \n   int maxX = arena.width - 20; \n   int minX = arena.left + 20; \n\n   for (int i = 0; i < numZombies; i++) \n   { \n\n      // Which side should the zombie spawn \n      srand((int)time(0) * i); \n      int side = (rand() % 4); \n      float x, y; \n\n      switch (side) \n      { \n      case 0: \n         // left \n         x = minX; \n         y = (rand() % maxY) + minY; \n         break; \n\n      case 1: \n         // right \n         x = maxX; \n         y = (rand() % maxY) + minY; \n         break; \n\n      case 2: \n         // top \n         x = (rand() % maxX) + minX; \n         y = minY; \n         break; \n\n      case 3: \n         // bottom \n         x = (rand() % maxX) + minX; \n         y = maxY; \n         break; \n      } \n\n      // Bloater, crawler or runner \n      srand((int)time(0) * i * 2); \n      int type = (rand() % 3); \n\n      // Spawn the new zombie into the array \n      zombies[i].spawn(x, y, type, i); \n\n   } \n   return zombies; \n} \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"ZombieArena.h\" \n#include \"Zombie.h\" \n\n```", "```cpp\nZombie* createHorde(int numZombies, IntRect arena)  \n{ \n   Zombie* zombies = new Zombie[numZombies]; \n\n```", "```cpp\nint maxY = arena.height - 20; \nint minY = arena.top + 20; \nint maxX = arena.width - 20; \nint minX = arena.left + 20; \n\n```", "```cpp\nfor (int i = 0; i < numZombies; i++) \n\n```", "```cpp\n// Which side should the zombie spawn \nsrand((int)time(0) * i); \nint side = (rand() % 4); \nfloat x, y; \n\n```", "```cpp\nswitch (side) \n{ \n   case 0: \n      // left \n      x = minX; \n      y = (rand() % maxY) + minY; \n      break; \n\n   case 1: \n      // right \n      x = maxX; \n      y = (rand() % maxY) + minY; \n      break; \n\n   case 2: \n      // top \n      x = (rand() % maxX) + minX; \n      y = minY; \n      break; \n\n   case 3: \n      // bottom \n      x = (rand() % maxX) + minX; \n      y = maxY; \n      break;       \n} \n\n```", "```cpp\n// Bloater, crawler or runner \nsrand((int)time(0) * i * 2); \nint type = (rand() % 3); \n\n// Spawn the new zombie into the array \nzombies[i].spawn(x, y, type, i); \n\n```", "```cpp\nreturn zombies; \n\n```", "```cpp\n#include \"stdafx.h\" \n#include <SFML/Graphics.hpp> \n#include \"ZombieArena.h\" \n#include \"Player.h\" \n#include \"TextureHolder.h\" \n\nusing namespace sf; \n\nint main() \n{ \n // Here is the instance of TextureHolder\n   TextureHolder holder; \n\n   // The game will always be in one of four states \n   enum class State { PAUSED, LEVELING_UP, GAME_OVER, PLAYING }; \n   // Start with the GAME_OVER state \n   State state = State::GAME_OVER; \n\n```", "```cpp\n// Create the background \nVertexArray background; \n// Load the texture for our background vertex array \nTexture textureBackground; \ntextureBackground.loadFromFile(\"graphics/background_sheet.png\"); \n\n// Prepare for a horde of zombies\nint numZombies;\nint numZombiesAlive;\nZombie* zombies = nullptr; \n\n// The main game loop \nwhile (window.isOpen()) \n\n```", "```cpp\nif (state == State::PLAYING) \n{ \n   // Prepare thelevel \n   // We will modify the next two lines later \n   arena.width = 500; \n   arena.height = 500; \n   arena.left = 0; \n   arena.top = 0; \n\n   // Pass the vertex array by reference  \n   // to the createBackground function \n   int tileSize = createBackground(background, arena); \n\n   // Spawn the player in the middle of the arena \n   player.spawn(arena, resolution, tileSize); \n\n // Create a horde of zombies\n   numZombies = 10;\n\n   // Delete the previously allocated memory (if it exists)\n   delete[] zombies;\n   zombies = createHorde(numZombies, arena);\n   numZombiesAlive = numZombies; \n\n   // Reset the clock so there isn't a frame jump \n   clock.restart(); \n} \n\n```", "```cpp\n/* \n **************** \n UPDATE THE FRAME \n **************** \n */ \nif (state == State::PLAYING) \n{ \n   // Update the delta time \n   Time dt = clock.restart(); \n   // Update the total game time \n   gameTimeTotal += dt; \n   // Make a decimal fraction of 1 from the delta time \n   float dtAsSeconds = dt.asSeconds(); \n\n   // Where is the mouse pointer \n   mouseScreenPosition = Mouse::getPosition(); \n\n   // Convert mouse position to world coordinates of mainView \n   mouseWorldPosition = window.mapPixelToCoords( \n      Mouse::getPosition(), mainView); \n\n   // Update the player \n   player.update(dtAsSeconds, Mouse::getPosition()); \n\n   // Make a note of the players new position \n   Vector2f playerPosition(player.getCenter()); \n\n   // Make the view center around the player           \n   mainView.setCenter(player.getCenter()); \n\n // Loop through each Zombie and update them\n   for (int i = 0; i < numZombies; i++)\n   {\n     if (zombies[i].isAlive())\n     {\n        zombies[i].update(dt.asSeconds(), playerPosition);\n     }\n   } \n\n}// End updating the scene \n\n```", "```cpp\n/* \n ************** \n Draw the scene \n ************** \n */ \n\nif (state == State::PLAYING) \n{ \n   window.clear(); \n\n   // set the mainView to be displayed in the window \n   // And draw everything related to it \n   window.setView(mainView); \n\n   // Draw the background \n   window.draw(background, &textureBackground); \n\n // Draw the zombies\n   for (int i = 0; i < numZombies; i++)\n   {\n     window.draw(zombies[i].getSprite());\n   } \n\n   // Draw the player \n   window.draw(player.getSprite()); \n} \n\n```", "```cpp\n   }// End of main game loop \n\n // Delete the previously allocated memory (if it exists)\n   delete[] zombies; \n\n   return 0; \n} \n\n```", "```cpp\n// Load the texture for our background vertex array \nTexture textureBackground;\ntextureBackground.loadFromFile(\"graphics/background_sheet.png\");\n\n```", "```cpp\n// Load the texture for our background vertex array \nTexture textureBackground = TextureHolder::GetTexture(\n  \"graphics/background_sheet.png\");\n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"player.h\" \n\nPlayer::Player() \n{ \n   m_Speed = START_SPEED; \n   m_Health = START_HEALTH; \n   m_MaxHealth = START_HEALTH; \n\n   // Associate a texture with the sprite \n   // !!Watch this space!! \n m_Texture.loadFromFile(\"graphics/player.png\");\n   m_Sprite.setTexture(m_Texture); \n\n   // Set the origin of the sprite to the center,  \n   // for smooth rotation \n   m_Sprite.setOrigin(25, 25); \n} \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"player.h\" \n#include \"TextureHolder.h\" \n\nPlayer::Player() \n{ \n   m_Speed = START_SPEED; \n   m_Health = START_HEALTH; \n   m_MaxHealth = START_HEALTH; \n\n   // Associate a texture with the sprite \n   // !!Watch this space!! \n m_Sprite = Sprite(TextureHolder::GetTexture(\n      \"graphics/player.png\")); \n\n   // Set the origin of the sprite to the center,  \n   // for smooth rotation \n   m_Sprite.setOrigin(25, 25); \n} \n\n```"]