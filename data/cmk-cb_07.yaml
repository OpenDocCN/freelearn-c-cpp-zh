- en: Generating Source Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成源代码
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Generating sources at configure time
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配置时生成源代码
- en: Generating source code at configure time using Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python在配置时生成源代码
- en: Generating source code at build time using Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python在构建时生成源代码
- en: Recording the project version information for reproducibility
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录项目版本信息以确保可复现性
- en: Recording the project version from a file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件记录项目版本
- en: Recording the Git hash at configure time
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在配置时记录Git哈希
- en: Recording the Git hash at build time
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建时记录Git哈希
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: For most projects, the source code is tracked using a version control system;
    it typically serves as input for the build system, which transforms it into objects,
    libraries, and executables. In certain cases, we use the build system to generate
    source code during the configuration or build steps. This can be useful to fine-tune
    the source code based on information gathered in the configuration step, or to
    automatize an otherwise error-prone mechanical generation of repetitive code. Another
    frequent use case for generating source code is to record information about the
    configuration or compilation for reproducibility. In this chapter, we will illustrate
    various strategies to generate source code, using the powerful tools provided
    by CMake.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数项目，源代码是通过版本控制系统进行跟踪的；它通常作为构建系统的输入，构建系统将其转换为对象、库和可执行文件。在某些情况下，我们使用构建系统在配置或构建步骤中生成源代码。这可以用于根据在配置步骤中收集的信息来微调源代码，或者自动化原本容易出错的重复代码的机械生成。生成源代码的另一个常见用例是记录配置或编译信息以确保可复现性。在本章中，我们将展示使用CMake提供的强大工具生成源代码的各种策略。
- en: Generating sources at configure time
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在配置时生成源代码
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-01),
    including a Fortran/C example. The recipe is valid with CMake version 3.10 (and
    higher), and has been tested on GNU/Linux, macOS, and Windows with MSYS Makefiles.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-01](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-01)找到，包括一个Fortran/C示例。该配方适用于CMake版本3.10（及以上），并在GNU/Linux、macOS和Windows（使用MSYS
    Makefiles）上进行了测试。
- en: The most straightforward code generation happens at configure time. For example,
    CMake can detect the operating system and available libraries; based on that information,
    we can tailor what sources are built, to offer maximum performance to the end
    user of our library or program. In this and some of the following recipes, we
    will illustrate how to generate a simple source file that defines a function to
    report the build system configuration.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的代码生成发生在配置时。例如，CMake可以检测操作系统和支持的库；基于这些信息，我们可以定制构建哪些源代码，以向我们的库或程序的最终用户提供最佳性能。在本章和后续的一些配方中，我们将展示如何生成一个简单的源文件，该文件定义了一个函数来报告构建系统配置。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The code sample for this recipe is in Fortran and C, setting the stage for
    [Chapter 9](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml), *Mixed-language Projects*,
    where mixed-language programming will be discussed. The main program is a simple
    Fortran executable that calls a C function, `print_info()`, which will print the
    configuration information. It is worth noting that with Fortran 2003, the compiler
    will take care of name mangling (given a proper interface declaration of the C
    function), as seen in the simple `example.f90` source file that we will use:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码示例是Fortran和C语言的，为[第9章](2fb9e4a6-0f37-45ab-a49c-d9da9b54ed41.xhtml)，*混合语言项目*，其中将讨论混合语言编程。主程序是一个简单的Fortran可执行文件，它调用一个C函数`print_info()`，该函数将打印配置信息。值得注意的是，使用Fortran
    2003，编译器将处理名称重整（给定C函数的适当接口声明），正如我们在简单的`example.f90`源文件中看到的：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `print_info()` C function is defined in the template file, `print_info.c.in`.
    The variables starting and ending with `@` will be substituted for their actual
    values at configure time:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_info()` C函数在模板文件`print_info.c.in`中定义。以`@`开始和结束的变量将在配置时被替换为其实际值：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'In our `CMakeLists.txt`, we first have to collect the configuration options,
    and can then substitute their values for the corresponding placeholders in `print_info.c.in`;
    we compile both the Fortran and C sources into one executable:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`CMakeLists.txt`中，我们首先必须收集配置选项，然后可以用它们的值替换`print_info.c.in`中相应的占位符；我们将Fortran和C源文件编译成一个可执行文件：
- en: 'We create a mixed Fortran-C project, as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个混合Fortran-C项目，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We obtain the username for the user configuring the project by using `execute_process`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过使用`execute_process`获得配置项目的用户的用户名：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using the `cmake_host_system_information()` function (which we already encountered
    in [Chapter 2](c1fec057-4e5f-4a9b-b404-30dc74f5d7b7.xhtml), *Detecting the Environment*,
    Recipe 5, *Discovering the host processor instruction set*), we can query for
    more system information:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cmake_host_system_information()`函数（我们在[第2章](c1fec057-4e5f-4a9b-b404-30dc74f5d7b7.xhtml)，*检测环境*，第5个配方，*发现主机处理器指令集*中已经遇到过），我们可以查询更多系统信息：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We also obtain a timestamp for the configuration, by using a string manipulation
    function:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还通过使用字符串操作函数获得配置的时间戳：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We are now ready to configure the template file, `print_info.c.in`, by using
    CMake''s own `configure_file` function. Notice that we only require the strings
    starting and terminating with `@` to be substituted:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备通过使用CMake自己的`configure_file`函数来配置模板文件`print_info.c.in`。请注意，我们只要求以`@`开始和结束的字符串被替换：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we add an executable target and define the target sources, as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加一个可执行目标并定义目标源，如下所示：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is an example output:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是示例输出：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The command `configure_file` can copy files and replace their contents with
    variable values. In our example, we used `configure_file` to both modify the contents
    of our template file and copy it to a location where it could then be compiled
    into our executable. Let us look at our invocation of `configure_file`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure_file`命令可以复制文件并将它们的內容替换为变量值。在我们的示例中，我们使用`configure_file`来修改我们的模板文件的内容，并将其复制到一个可以编译到我们的可执行文件的位置。让我们看看我们对`configure_file`的调用：'
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first argument is the name of the scaffold: `print_info.c.in`. CMake assumes
    that the input file is located relative to the root directory of the project;
    that is, in `${CMAKE_CURRENT_SOURCE_DIR}/print_info.c.in`. The second argument
    is the name of the configured file, which we chose to be `print_info.c`. The output
    file is assumed to be located relative to the project build directory; that is,
    in `${CMAKE_CURRENT_BINARY_DIR}/print_info.c`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是脚手架的名称：`print_info.c.in`。CMake假设输入文件位于相对于项目根目录的位置；也就是说，在`${CMAKE_CURRENT_SOURCE_DIR}/print_info.c.in`中。第二个参数是我们选择的配置文件的名称，即`print_info.c`。输出文件假设位于相对于项目构建目录的位置；也就是说，在`${CMAKE_CURRENT_BINARY_DIR}/print_info.c`中。
- en: When limiting the invocation to just two arguments, the input and output files,
    CMake will not only configure variables of the form `@VAR@`, but also those of
    the form `${VAR}`. This can be inconvenient when `${VAR}` is part of the syntax
    and should not be touched (such as in shell scripts). To instruct CMake in this
    regard, the option `@ONLY` should be passed to the invocation of `configure_file`,
    as we illustrated previously.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当仅限制为两个参数，即输入和输出文件时，CMake不仅会配置形如`@VAR@`的变量，还会配置形如`${VAR}`的变量。当`${VAR}`是语法的一部分且不应被修改时（例如在shell脚本中），这可能会造成不便。为了在这方面指导CMake，应该将选项`@ONLY`传递给`configure_file`的调用，正如我们之前所展示的。
- en: There is more
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: Note that the substitution of placeholders with values expects the variable
    names in CMake to be exactly the same as those used in the to-be configured file,
    and placed in between `@`-markers. Any CMake variable defined at the point where
    `configure_file` is invoked can be used. This includes all built-in CMake variables,
    such as `CMAKE_VERSION` or `CMAKE_GENERATOR`, in our example. Moreover, whenever
    the template file is modified, rebuilding the code will trigger a regeneration
    of the build system. In this way, the configured file will always be up to date.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将占位符替换为值时，期望CMake中的变量名与待配置文件中使用的变量名完全相同，并且位于`@`标记之间。在调用`configure_file`时定义的任何CMake变量都可以使用。这包括所有内置的CMake变量，例如`CMAKE_VERSION`或`CMAKE_GENERATOR`，在我们的示例中。此外，每当模板文件被修改时，重新构建代码将触发构建系统的重新生成。这样，配置的文件将始终保持最新。
- en: A complete list of internal CMake variables can be obtained from the CMake manual
    by using `cmake --help-variable-list`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的内部CMake变量列表可以通过使用`cmake --help-variable-list`从CMake手册中获得。
- en: The command `file(GENERATE ...)` provides an interesting alternative to `configure_file`
    as it allows generator expressions to be evaluated as part of the configured file.
    However, `file(GENERATE ...)` updates the output file every time CMake is run
    which forces a rebuild of all targets which depend on that output. See also [https://crascit.com/2017/04/18/generated-sources-in-cmake-builds/](https://crascit.com/2017/04/18/generated-sources-in-cmake-builds/).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`file(GENERATE ...)`命令提供了一个有趣的替代`configure_file`的方法，因为它允许生成器表达式作为配置文件的一部分进行评估。然而，`file(GENERATE
    ...)`每次运行CMake时都会更新输出文件，这迫使所有依赖于该输出的目标重新构建。另请参见[https://crascit.com/2017/04/18/generated-sources-in-cmake-builds/](https://crascit.com/2017/04/18/generated-sources-in-cmake-builds/)。'
- en: Generating source code at configure time using Python
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python在配置时生成源代码
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-02),
    including a Fortran/C example. The recipe is valid with CMake version 3.10 (and
    higher), and has been tested on GNU/Linux, macOS, and Windows with MSYS Makefiles.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本方法的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-02](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-02)找到，包括一个Fortran/C示例。本方法适用于CMake版本3.10（及以上），并在GNU/Linux、macOS和Windows上使用MSYS
    Makefiles进行了测试。
- en: In this recipe, we will revisit the previous example, and will again generate
    `print_info.c` from the template `print_info.c.in`. However, this time, we will
    imagine that the CMake function `configure_file()` has not been invented yet,
    and will emulate it with a Python script. The goal of this recipe is to learn
    how we can generate source code at configure time by using a now familiar example.
    Of course, we will probably favor `configure_file()` for a real project, but when
    faced with the challenge of generating sources using Python at configure time,
    we will know how to do it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本方法中，我们将回顾之前的示例，并再次从模板`print_info.c.in`生成`print_info.c`。然而，这一次，我们将假设CMake函数`configure_file()`尚未被发明，并将使用Python脚本来模拟它。本方法的目标是学习如何通过使用一个熟悉的示例在配置时生成源代码。当然，在实际项目中，我们可能会更倾向于使用`configure_file()`，但是当我们面临在配置时使用Python生成源代码的挑战时，我们将知道如何操作。
- en: We should point out that this recipe has a serious limitation and cannot emulate `configure_file()`
    fully. The approach that we will present here cannot generate an automatic dependency
    which would regenerate `print_info.c` at build time. In other words, if you remove
    the generated `print_info.c` after the configure step, this file will not be regenerated
    and the build step will fail. To properly mimic the behavior of `configure_file()`
    we would require `add_custom_command()` and `add_custom_target()`, which we will
    use in the subsequent Recipe 3, *Generating source code at build time using Python*,
    where we will overcome this limitation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该指出，这个方法有一个严重的局限性，无法完全模拟`configure_file()`。我们在这里介绍的方法无法生成自动依赖项，该依赖项会在构建时重新生成`print_info.c`。换句话说，如果在配置步骤后删除了生成的`print_info.c`，该文件将不会被重新生成，构建步骤将会失败。为了正确模仿`configure_file()`的行为，我们需要使用`add_custom_command()`和`add_custom_target()`，我们将在接下来的第3个方法中使用，即“使用Python在构建时生成源代码”，在那里我们将克服这个限制。
- en: In this recipe, we will use a relatively simple Python script which we will
    detail below. This script will read in `print_info.c.in` and replace the placeholders
    in the file with parameters passed to the Python script from CMake. For more sophisticated
    templating, we recommend external tools, such as Jinja (see [http://jinja.pocoo.org](http://jinja.pocoo.org/)).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本方法中，我们将使用一个相对简单的Python脚本，下面我们将详细介绍。该脚本将读取`print_info.c.in`，并使用从CMake传递给Python脚本的参数替换文件中的占位符。对于更复杂的模板，我们推荐使用外部工具，如Jinja（参见[http://jinja.pocoo.org](http://jinja.pocoo.org/)）。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The files `print_info.c.in` and `example.f90` are unchanged with respect to
    the previous recipe. In addition, we will use a Python script, `configurator.py`,
    which provides one function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_info.c.in`和`example.f90`文件与前一个方法相比没有变化。此外，我们将使用一个Python脚本`configurator.py`，它提供了一个函数：'
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function reads an input file, goes over all of the keys of a `vars_dict`
    dictionary, replaces the pattern `@key@` with its corresponding value, and writes
    the results to an output file. The key-value pairs will be provided by CMake.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数读取一个输入文件，遍历`vars_dict`字典的所有键，将模式`@key@`替换为其对应值，并将结果写入输出文件。键值对将由CMake提供。
- en: How to do it
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Similar to the previous recipe, we need to configure a template file, but this
    time, we will emulate the `configure_file()` function with a Python script. We
    keep the `CMakeLists.txt` largely unchanged, but we replace `configure_file(print_info.c.in
    print_info.c @ONLY)` with a set of commands, which we will introduce step by step:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个配方类似，我们需要配置一个模板文件，但这次，我们将用Python脚本来模拟`configure_file()`函数。我们基本上保持`CMakeLists.txt`不变，但我们用一组命令替换了`configure_file(print_info.c.in
    print_info.c @ONLY)`，我们将逐步介绍这些命令：
- en: 'First, we construct a variable, `_config_script`, which will hold a Python
    script that we will execute a moment later:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们构造一个变量，`_config_script`，它将保存我们稍后要执行的Python脚本：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then use `find_package` to ensure that the Python interpreter is available
    for CMake to use:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`find_package`来确保CMake可以使用Python解释器：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the Python interpreter was found, we can execute `_config_script` from within
    CMake, to generate the `print_info.c` file:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到了Python解释器，我们可以在CMake内部执行`_config_script`，以生成`print_info.c`文件：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After that, we define the executable target and dependencies, but this is unchanged
    from the previous recipe. Also, the obtained output is unchanged.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们定义了可执行目标和依赖项，但这与上一个配方中的相同。同样，得到的输出也没有变化。
- en: How it works
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: Let us examine the changes that we applied to `CMakeLists.txt`, by discussing
    them backwards.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过倒叙的方式来审视我们对`CMakeLists.txt`所做的更改。
- en: We executed a Python script that generates `print_info.c`. To run the Python
    script, we first had to detect Python and construct the Python script. The Python
    script imports the `configure_file` function, which we defined in `configurator.py`.
    It requires that we provide it with file locations for reading and writing, as
    well as a dictionary holding CMake variables and their values as key-value pairs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行了一个生成`print_info.c`的Python脚本。为了运行Python脚本，我们首先必须检测Python并构造Python脚本。Python脚本导入了我们在`configurator.py`中定义的`configure_file`函数。它要求我们提供读写文件的位置，以及一个保存CMake变量及其值作为键值对的字典。
- en: This recipe has shown an alternative way of generating a configuration report
    that can be compiled into an executable, or even a library target, by delegating
    the generation of sources to an external script. The first approach that we discussed
    in the previous recipe was cleaner and simpler, but with the approach that we
    have presented in this recipe, we have the flexibility to implement, in principle,
    any configure-time step that Python (or another language) allows. Using the present
    approach, we can perform actions that go *beyond* what `cmake_host_system_information()`
    currently provides.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了一种生成配置报告的替代方法，该报告可以编译成可执行文件，甚至是一个库目标，通过将源的生成委托给外部脚本。我们在上一个配方中讨论的第一个方法更干净、更简单，但通过本配方中提出的方法，我们可以在原则上实现Python（或其他语言）允许的任何配置时步骤。使用当前的方法，我们可以执行超出`cmake_host_system_information()`当前提供的功能的操作。
- en: However, we need to remember the limitation of this approach which cannot generate
    an automatic dependency which would regenerate `print_info.c` at build time. In
    the next recipe we will overcome this limitation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要记住这种方法的局限性，它无法生成自动依赖项，以便在构建时重新生成`print_info.c`。在下一个配方中，我们将克服这个限制。
- en: There is more
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'It is possible to express this recipe more compactly. Instead of explicitly
    constructing `vars_dict`, which felt a bit repetitive, we could have used `get_cmake_property(_vars
    VARIABLES)` to obtain a list of *all* variables defined at this particular time,
    and could have looped over all elements of `_vars` to access their values:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以更简洁地表达这个配方。我们不必显式地构造`vars_dict`，这感觉有些重复，而是可以使用`get_cmake_property(_vars VARIABLES)`来获取此时定义的所有变量的列表，并可以遍历`_vars`的所有元素来访问它们的值：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using this approach, it is possible to build `vars_dict` implicitly. However,
    care has to be taken to escape values that contain characters such as "`;`", which
    Python interprets as terminating an instruction.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，可以隐式地构建`vars_dict`。然而，必须注意转义包含诸如"`；`"这类字符的值，因为Python会将其解释为终止指令。
- en: Generating source code at build time using Python
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python在构建时生成源代码
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-03),
    including a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-03](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-03)找到，包括一个C++示例。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: Being able to generate source code at build time is a powerful feature in the
    toolbox of the pragmatic developer who wishes to generate possibly lengthy and
    repetitive code based on some rules, while at the same time avoiding tracking
    the generated code explicitly in the source code repository. We can, for instance,
    imagine generating different source code, based on the detected platform or architecture.
    Or, we can use the simplicity of Python to generate explicit and efficient C++
    code at build time, based on the input that we gathered during the configuration
    step. Other relevant examples are parser generators, such as Flex ([https://github.com/westes/flex](https://github.com/westes/flex))
    and Bison ([https://www.gnu.org/software/bison/](https://www.gnu.org/software/bison/)),
    meta-object compilers, such as Qt moc ([http://doc.qt.io/qt-5/moc.html](http://doc.qt.io/qt-5/moc.html)),
    and serialization frameworks, such as Google protobuf ([https://developers.google.com/protocol-buffers/](https://developers.google.com/protocol-buffers/)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在构建时生成源代码是实用开发者工具箱中的一个强大功能，他们希望根据某些规则生成可能冗长且重复的代码，同时避免在源代码仓库中显式跟踪生成的代码。例如，我们可以想象根据检测到的平台或架构生成不同的源代码。或者，我们可以使用Python的简单性在构建时根据配置步骤中收集的输入生成明确且高效的C++代码。其他相关的例子包括解析器生成器，如Flex（[https://github.com/westes/flex](https://github.com/westes/flex)）和Bison（[https://www.gnu.org/software/bison/](https://www.gnu.org/software/bison/)），元对象编译器，如Qt
    moc（[http://doc.qt.io/qt-5/moc.html](http://doc.qt.io/qt-5/moc.html)），以及序列化框架，如Google
    protobuf（[https://developers.google.com/protocol-buffers/](https://developers.google.com/protocol-buffers/)）。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To provide a concrete example, we imagine that we need to write a code to verify
    whether a number is prime. Many algorithms exist, and we can, for instance, use
    the sieve of Eratosthenes to separate prime numbers from non-primes. If we have
    to verify many numbers, we will not want to run the sieve of Eratosthenes algorithm
    for every single one of them. What we would like to do instead is tabulate all
    prime numbers once, up to a certain limit, and use a table lookup to verify a
    large set of numbers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个具体的例子，我们设想需要编写一段代码来验证一个数是否为质数。存在许多算法，例如，我们可以使用埃拉托色尼筛法来区分质数和非质数。如果我们需要验证很多数，我们不希望为每一个数都运行埃拉托色尼筛法算法。相反，我们希望一次性列出所有质数，直到某个上限，并使用查表法来验证大量数字。
- en: In this example, we will generate the C++ code for the lookup table (a vector
    of prime numbers) by using Python at compile time. Of course, to solve this particular
    programming problem, we could also generate the lookup table using C++, and we
    could do it at runtime instead.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用Python在编译时生成查找表（一个质数向量）的C++代码。当然，为了解决这个特定的编程问题，我们也可以使用C++在运行时生成查找表。
- en: 'Let us start out with the following Python script, called `generate.py`. This
    script takes two command-line arguments - an integer that will limit the search,
    and an output filename:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个名为`generate.py`的Python脚本开始。这个脚本接受两个命令行参数——一个将限制搜索的整数和一个输出文件名：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Our goal is to generate a header file, `primes.hpp`, at compile time, and include
    it in the following example code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是生成一个头文件`primes.hpp`，在编译时生成，并在以下示例代码中包含它：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to do it
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'The following is a breakdown of the commands in `CMakeLists.txt`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`CMakeLists.txt`中命令的分解：
- en: 'First, we need to define the project and detect the Python interpreter, as
    follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要定义项目并检测Python解释器，如下所示：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We decided to place the to-be-generated code under `${CMAKE_CURRENT_BINARY_DIR}/generated`,
    and we need to instruct CMake to create this directory:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们决定将待生成的代码放在`${CMAKE_CURRENT_BINARY_DIR}/generated`下，我们需要指示CMake创建这个目录：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The Python script expects an upper bound for the prime numbers, and, with the
    following command, we can set a default:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个Python脚本期望得到一个质数的上限，通过以下命令，我们可以设置一个默认值：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we define a custom command to generate the header file:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个自定义命令来生成头文件：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we define the executable and its target, including the directory and
    dependency:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义了可执行文件及其目标，包括目录和依赖项：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We are now ready to test the implementation, as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备测试实现，如下所示：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'To generate the header file, we defined a custom command that executes the
    `generate.py` script and takes `${MAX_NUMBER}` and the file path (`${CMAKE_CURRENT_BINARY_DIR}/generated/primes.hpp`)
    as arguments:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成头文件，我们定义了一个自定义命令，该命令执行`generate.py`脚本，并接受`${MAX_NUMBER}`和文件路径（`${CMAKE_CURRENT_BINARY_DIR}/generated/primes.hpp`）作为参数：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to trigger the source code generation, we need to add it as a source
    code dependency in the definition of the executable, a task easily achieved with
    `target_sources`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了触发源代码生成，我们需要在可执行文件的定义中将其添加为源代码依赖项，这一任务可以通过`target_sources`轻松实现：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we do not have to define a new custom target. The header
    file will be generated as a dependency of `example`, and will be rebuilt every
    time the `generate.py` script changes. If the code generation script produces
    several source files, it is important that all generated files are listed as dependencies
    of some target.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们不必定义一个新的自定义目标。头文件将作为`example`的依赖项生成，并且每当`generate.py`脚本更改时都会重新构建。如果代码生成脚本生成多个源文件，重要的是所有生成的文件都被列为某个目标的依赖项。
- en: There is more
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多内容
- en: We mentioned that all generated files should be listed as dependencies of some
    target. However, we might be in a situation where we do not know this list of
    files, since it is determined by the scripts generating the files, depending on
    input that we provide to the configuration. In this case, we might be tempted
    to use `file(GLOB ...)` to collect generated files into a list (see [https://cmake.org/cmake/help/v3.5/command/file.html](https://cmake.org/cmake/help/v3.5/command/file.html)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到所有生成的文件都应该被列为某个目标的依赖项。然而，我们可能会遇到这样的情况：我们不知道这些文件的列表，因为它是根据我们提供给配置的输入由生成文件的脚本决定的。在这种情况下，我们可能会倾向于使用`file(GLOB
    ...)`来收集生成的文件到一个列表中（参见[https://cmake.org/cmake/help/v3.5/command/file.html](https://cmake.org/cmake/help/v3.5/command/file.html)）。
- en: However, remember that `file(GLOB ...)` is executed at configure time, whereas
    code generation happens at build time. Therefore, we may need an additional level
    of indirection, where we place the `file(GLOB ...)` command in a separate CMake
    script which we execute at using `${CMAKE_COMMAND} -P`, in order to get the list
    of generated files at build time.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，`file(GLOB ...)`是在配置时执行的，而代码生成发生在构建时。因此，我们可能需要一个额外的间接层，将`file(GLOB ...)`命令放在一个单独的CMake脚本中，我们使用`${CMAKE_COMMAND}
    -P`执行该脚本，以便在构建时获取生成的文件列表。
- en: Recording the project version information for reproducibility
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录项目版本信息以确保可重复性
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-04),
    including C and Fortran examples. The recipe is valid with CMake version 3.5 (and
    higher), and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-04](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-04)找到，包括C和Fortran示例。本配方适用于CMake版本3.5（及更高版本），并在GNU/Linux、macOS和Windows上进行了测试。
- en: Code versions matter, not only for reproducibility but also to document API
    capabilities or simplify support requests and bug reporting. The source code is
    typically under some version control, and additional semantic version numbers
    (see e.g. [https://semver.org](https://semver.org)) can be attached using Git
    tags, for example. However, not only does the source code need to be versioned,
    but the executable needs to record the project version so that it can be printed
    to the code output or user interface.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 代码版本不仅对可重复性很重要，而且对于记录API能力或简化支持请求和错误报告也很重要。源代码通常在某种版本控制下，并且可以使用Git标签等附加语义版本号（参见例如[https://semver.org](https://semver.org)）。然而，不仅源代码需要版本化，可执行文件也需要记录项目版本，以便它可以打印到代码输出或用户界面。
- en: In this example, we will define the version number inside of the CMake sources.
    Our goal is to record the program version to a header file at the moment when
    we configure the project. The generated header file can then be included in the
    code at the right place and time, to print the code version to the output file(s)
    or screen.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将在CMake源代码中定义版本号。我们的目标是记录程序版本，以便在配置项目时将其记录到头文件中。生成的头文件随后可以在代码中的正确位置和时间被包含，以便将代码版本打印到输出文件或屏幕上。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will use the following C file (`example.c`) to print the version information:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下C文件（`example.c`）来打印版本信息：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we assume that `PROJECT_VERSION_MAJOR`, `PROJECT_VERSION_MINOR`, and
    `PROJECT_VERSION` are defined in `version.h`. Our goal is to generate `version.h`
    from the following scaffold, `version.h.in`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设`version.h`中定义了`PROJECT_VERSION_MAJOR`，`PROJECT_VERSION_MINOR`和`PROJECT_VERSION`。我们的目标是根据以下骨架生成`version.h`，即`version.h.in`：
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will use preprocessor definitions, but we could also employ string or integer
    constants for more type safety (and we will demonstrate that later). From the
    CMake perspective, the approach is the same.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用预处理器定义，但也可以使用字符串或整数常量以获得更多类型安全性（我们稍后将演示）。从CMake的角度来看，方法是一样的。
- en: How to do it
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'We will follow these steps to register the version in our template header file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下步骤在我们的模板头文件中注册版本：
- en: 'To track the code version, we can define the project version when invoking
    the CMake `project` command in `CMakeLists.txt`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了追踪代码版本，我们可以在`CMakeLists.txt`中调用CMake的`project`命令时定义项目版本：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then configure `version.h`, based on `version.h.in`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后根据`version.h.in`配置`version.h`：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, we define the executable and provide the target include path:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义可执行文件并提供目标包含路径：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: When invoking the CMake `project` command with a `VERSION` argument, CMake will
    set the `PROJECT_VERSION_MAJOR`, `PROJECT_VERSION_MINOR`, and `PROJECT_VERSION_PATCH`
    for our project. The key command in this recipe is `configure_file`, which takes
    an input file (in this case, `version.h.in`) and generates an output file (in
    this case, `generated/version.h`) by expanding all placeholders between `@` to
    their corresponding CMake variables. It replaces `@PROJECT_VERSION_MAJOR@` with
    `2`, and so on. With the keyword `@ONLY`, we limit `configure_file` to only expand
    `@variables@`, but to not touch `${variables}`. The latter form is not used in
    `version.h.in`, but they frequently appear when configuring a shell script using
    CMake.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`VERSION`参数调用CMake的`project`命令时，CMake将为我们的项目设置`PROJECT_VERSION_MAJOR`，`PROJECT_VERSION_MINOR`和`PROJECT_VERSION_PATCH`。本食谱中的关键命令是`configure_file`，它接受一个输入文件（在这种情况下，`version.h.in`）并生成一个输出文件（在这种情况下，`generated/version.h`），通过将所有`@`之间的占位符扩展为其对应的CMake变量。它将`@PROJECT_VERSION_MAJOR@`替换为`2`，以此类推。使用关键字`@ONLY`，我们限制`configure_file`仅扩展`@variables@`，但不触及`${variables}`。后一种形式在`version.h.in`中没有使用，但它们经常出现在使用CMake配置shell脚本时。
- en: 'The generated header file can be included in our example code, and the version
    information is available to be printed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的头文件可以包含在我们的示例代码中，并且版本信息可供打印：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: CMake understands version numbers given in the format `X.Y.Z.t`, and will set
    the variables `PROJECT_VERSION` and `<project-name>_VERSION` to the passed value.
    In addition, the `PROJECT_VERSION_MAJOR` (`<project-name>_VERSION_MAJOR`), `PROJECT_VERSION_MINOR`
    (`<project-name>_VERSION_MINOR`), `PROJECT_VERSION_PATCH` (`<project-name>_VERSION_PATCH`),
    and `PROJECT_VERSION_TWEAK` (`<project-name>_VERSION_TWEAK`), will be set to `X`,
    `Y`, `Z`, and `t`, respectively.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: CMake理解以`X.Y.Z.t`格式给出的版本号，并将设置`PROJECT_VERSION`和`<project-name>_VERSION`变量为传入的值。此外，`PROJECT_VERSION_MAJOR`（`<project-name>_VERSION_MAJOR`），`PROJECT_VERSION_MINOR`（`<project-name>_VERSION_MINOR`），`PROJECT_VERSION_PATCH`（`<project-name>_VERSION_PATCH`），和`PROJECT_VERSION_TWEAK`（`<project-name>_VERSION_TWEAK`）将被设置为`X`，`Y`，`Z`，和`t`，分别。
- en: There is more
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: To make sure that the preprocessor variables are only defined if the CMake variable
    is considered a true constant, one can employ `#cmakedefine` instead of `#define`
    in the header files that are about to be configured, by using `configure_file`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保预处理器变量仅在CMake变量被视为真常量时定义，可以在即将配置的头文件中使用`#cmakedefine`而不是`#define`，通过使用`configure_file`。
- en: 'Depending on whether the CMake variable is defined and evaluates to a true
    constant, `#cmakedefine YOUR_VARIABLE` will then be replaced with either `#define
    YOUR_VARIABLE ...` or `/* #undef YOUR_VARIABLE */`. There is also `#cmakedefine01`,
    which will set a variable to either `0` or `1`, depending on whether the variable
    is defined.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '根据CMake变量是否被定义并且评估为真常量，`#cmakedefine YOUR_VARIABLE`将被替换为`#define YOUR_VARIABLE
    ...`或`/* #undef YOUR_VARIABLE */`。还有`#cmakedefine01`，它将根据变量是否定义将变量设置为`0`或`1`。'
- en: Recording the project version from a file
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件记录项目版本
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-05),
    including a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-05](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-05)找到，包括一个C++示例。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: The goal of this recipe is similar to the previous one, but the starting point
    is different; our plan is to read the version information from a file, rather
    than setting it inside of `CMakeLists.txt`. The motivation for keeping the version
    in a separate file, outside of CMake sources, is to allow other build frameworks
    or development tools to use the information, independent of CMake, without duplicating
    the information in several files. One example of a build framework that you might
    like to employ in parallel to CMake is the Sphinx documentation framework, generating
    documentation and deploying it to the Read the Docs service to serve your code
    documentation online.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的目标与前一个相似，但起点不同；我们的计划是从文件中读取版本信息，而不是在`CMakeLists.txt`内部设置它。将版本信息保存在CMake源代码之外的单独文件中的动机是允许其他构建框架或开发工具使用该信息，独立于CMake，而不在几个文件中重复信息。您可能希望与CMake并行使用的构建框架的一个例子是Sphinx文档框架，它生成文档并将其部署到Read
    the Docs服务以在线提供您的代码文档。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will start with a file called `VERSION`, containing the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个名为`VERSION`的文件开始，其中包含以下内容：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This time, we will choose to go for more type safety, and will define `PROGRAM_VERSION`
    as a string constant in `version.hpp.in`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将选择更注重类型安全，并将`PROGRAM_VERSION`定义为`version.hpp.in`中的字符串常量：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will include the generated `version.hpp` in the following example source
    code (`example.cpp`):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面的示例源代码（`example.cpp`）中包含生成的`version.hpp`：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How to do it
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'The following shows how to accomplish our task, step by step:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了我们如何一步步完成任务：
- en: '`CMakeLists.txt` defines the minimum version, project name, language, and standard:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt`定义了最低版本、项目名称、语言和标准：'
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We read the version information from the file, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们按照以下方式从文件中读取版本信息：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We then configure the header file:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们配置头文件：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we define the executable and its dependencies:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义了可执行文件及其依赖项：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We are then ready to test it out:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们准备测试它：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'We used the following construct to read the version string from a file called
    `VERSION`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了以下结构从名为`VERSION`的文件中读取版本字符串：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we first check that this file exists, and issue an error message if it
    does not. If it exists, we read its contents into a variable called `PROGRAM_VERSION`,
    which we strip of any trailing whitespace. Once the variable `PROGRAM_VERSION`
    is set, it can be used to configure `version.hpp.in` to generate `generated/version.hpp`,
    as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先检查该文件是否存在，如果不存在则发出错误消息。如果存在，我们将文件内容读入名为`PROGRAM_VERSION`的变量中，并去除任何尾随空格。一旦设置了变量`PROGRAM_VERSION`，就可以用来配置`version.hpp.in`以生成`generated/version.hpp`，如下所示：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Recording the Git hash at configure time
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在配置时记录Git哈希
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-06),
    including a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的代码可在[https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-06](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-06)找到，包括一个C++示例。该食谱适用于CMake版本3.5（及以上），并在GNU/Linux、macOS和Windows上进行了测试。
- en: Most modern source code repositories are tracked using Git as version control
    system, a fact that can be attributed to the huge popularity of the repository
    hosting platform GitHub. We will, therefore, use Git in this recipe; the motivation
    and implementation will, however, translate to other version control systems.
    If we look at Git as an example, the Git hash of a commit uniquely determines
    the state of the source code. Therefore, to uniquely brand the executable, we
    will try to burn the Git hash into the executable by recording the hash string
    in a header file that can be included and used at the right place in the code.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代源代码仓库都使用 Git 作为版本控制系统进行跟踪，这一事实可以归因于仓库托管平台 GitHub 的巨大流行。因此，在本食谱中，我们将使用 Git；然而，动机和实现将适用于其他版本控制系统。如果我们以
    Git 为例，一个提交的 Git 哈希值唯一地确定了源代码的状态。因此，为了唯一地标记可执行文件，我们将尝试通过在头文件中记录哈希字符串来将 Git 哈希值烧录到可执行文件中，该头文件可以在代码中的正确位置包含和使用。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will need two source files, both very similar to the previous recipe. One
    will be configured with the recorded hash (`version.hpp.in`), as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个源文件，都与之前的食谱非常相似。一个将使用记录的哈希值进行配置（`version.hpp.in`），如下所示：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We will also need an example source file (`example.cpp`), which will print
    the hash to the screen:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个示例源文件（`example.cpp`），它将打印哈希值到屏幕上：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This recipe also assumes that we are in a Git repository with at least one commit.
    So, initialize this example with `git init`, and create commits with `git add
    <filename>`, followed by `git commit`, in order to get a meaningful example.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱还假设我们处于至少有一个提交的 Git 仓库中。因此，使用 `git init` 初始化这个示例，并通过 `git add <filename>`
    和 `git commit` 创建提交，以获得有意义的示例。
- en: How to do it
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'The following illustrates the steps to record versioning information from Git:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤说明了如何从 Git 记录版本信息：
- en: 'In `CMakeLists.txt`, we first define the project and language support:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CMakeLists.txt` 中，我们首先定义项目和语言支持：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We then use the following code snippet to define a variable, `GIT_HASH`:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码片段来定义一个变量，`GIT_HASH`：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The rest of `CMakeLists.txt` is similar to the one in the previous recipes:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余的 `CMakeLists.txt` 与之前的食谱中的相似：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can verify the output as follows (the hash will differ):'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式验证输出（哈希值会有所不同）：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'We use `find_package(Git QUIET)` to detect whether Git is available on the
    system. If it is (if `GIT_FOUND` is true), we run a Git command: `${GIT_EXECUTABLE}
    log -1 --pretty=format:%h`. This command gives us the short version of the current
    commit hash. Of course, we have full flexibility to run another Git command, instead.
    We ask the `execute_process` command to place the result of the command into a
    variable called `GIT_HASH`, which we subsequently strip of any trailing whitespace.
    With `ERROR_QUIET`, we ask the command to not stop the configuration if the Git
    command fails for some reason.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `find_package(Git QUIET)` 来检测系统上是否安装了 Git。如果安装了（如果 `GIT_FOUND` 为真），我们运行一个
    Git 命令：`${GIT_EXECUTABLE} log -1 --pretty=format:%h`。这个命令给我们提供了当前提交哈希的简短版本。当然，我们完全有灵活性来运行另一个
    Git 命令，而不是这个。我们要求 `execute_process` 命令将命令的结果放入一个名为 `GIT_HASH` 的变量中，然后我们去除任何尾随的空白。使用
    `ERROR_QUIET`，我们要求命令在 Git 命令由于某种原因失败时不停止配置。
- en: 'Since the Git command might fail (the source code might have been distributed
    outside of the Git repository) or Git might not even be available on the system,
    we wish to set a default for the variable, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Git 命令可能会失败（源代码可能已经在 Git 仓库之外分发）或者系统上甚至可能没有安装 Git，我们希望为变量设置一个默认值，如下所示：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: One problem with this recipe is that the Git hash is recorded at configure time,
    not at build time. In the next recipe, we will demonstrate how to implement the
    latter approach.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的一个问题是 Git 哈希值是在配置时记录的，而不是在构建时。在下一个食谱中，我们将演示如何实现后一种方法。
- en: Recording the Git hash at build time
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构建时记录 Git 哈希值
- en: The code for this recipe is available at [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-07),
    including a C++ example. The recipe is valid with CMake version 3.5 (and higher),
    and has been tested on GNU/Linux, macOS, and Windows.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的代码可以在 [https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-07](https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-06/recipe-07)
    找到，包括一个 C++ 示例。这个食谱适用于 CMake 版本 3.5（及更高版本），并且已经在 GNU/Linux、macOS 和 Windows 上进行了测试。
- en: In the previous recipe, we recorded the state of the code repository (Git hash)
    at configure time, and it is very useful to have the state of the repository recorded
    in the executable. However, one unsatisfactory aspect of the previous approach
    is that if we changed branches or committed changes after having configured the
    code, the version record included in our source code could point to the wrong
    Git hash. In this recipe, we wish to go a step further and demonstrate how to
    record the Git hash (or, generally, perform other actions) at build time, to make
    sure that these actions are run every time we build the code, since we may configure
    only once but build several times.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们在配置时记录了代码仓库的状态（Git哈希），并且在可执行文件中记录仓库状态非常有用。然而，之前方法的一个不满意之处是，如果我们更改分支或提交更改后配置代码，源代码中包含的版本记录可能会指向错误的Git哈希。在本配方中，我们希望更进一步，并演示如何在构建时记录Git哈希（或一般而言，执行其他操作），以确保每次我们构建代码时都会运行这些操作，因为我们可能只配置一次，但构建多次。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use the same `version.hpp.in` as in the previous recipe, and will modify
    the `example.cpp` file only minimally, to make it clear that it prints a build-time
    Git hash:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与之前配方相同的`version.hpp.in`，并且只会对`example.cpp`文件进行最小限度的修改，以确保它打印出构建时的Git哈希值：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How to do it
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Saving the Git information to the `version.hpp` header file at build time will
    require the following operations:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建时将Git信息保存到`version.hpp`头文件将需要以下操作：
- en: 'We will move most of the code from the `CMakeLists.txt` of the previous recipe
    to a separate file, and will call the file `git-hash.cmake`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把之前配方中`CMakeLists.txt`的大部分代码移动到一个单独的文件中，并将其命名为`git-hash.cmake`：
- en: '[PRE49]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `CMakeLists.txt` is now left with a part that we recognize very well:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt`现在剩下我们非常熟悉的部分：'
- en: '[PRE50]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The remaining part of `CMakeLists.txt` records the Git hash every time we build
    the code, as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt`的剩余部分记录了每次我们构建代码时Git哈希值，如下所示：'
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'In this recipe, we achieved the execution of CMake code at build time. For
    this, we defined a custom command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们实现了在构建时执行CMake代码。为此，我们定义了一个自定义命令：
- en: '[PRE52]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We also defined a custom target, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个自定义目标，如下所示：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The custom command invokes CMake to execute the `git-hash.cmake` CMake script.
    This is achieved by using the `-P` CLI switch, to pass the location of the script.
    Notice that we can pass options with the `-D` CLI switch, as we usually would.
    The `git-hash.cmake` script generates `${TARGET_DIR}/generated/version.hpp`. The
    custom target is added to the `ALL` target, and depends on the output of the custom
    command. In other words, when we build the default target, we make sure that the
    custom command is run. Also, observe that the custom command has the `ALL` target
    as output. With that, we make sure that `version.hpp` is generated every time.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义命令调用CMake执行`git-hash.cmake`CMake脚本。这是通过使用`-P`CLI开关来实现的，以传递脚本的位置。请注意，我们可以使用`-D`CLI开关传递选项，就像我们通常所做的那样。`git-hash.cmake`脚本生成`${TARGET_DIR}/generated/version.hpp`。自定义目标添加到`ALL`目标，并依赖于自定义命令的输出。换句话说，当我们构建默认目标时，我们确保自定义命令被执行。此外，请注意自定义命令将`ALL`目标作为输出。这样，我们确保每次都会生成`version.hpp`。
- en: There is more
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: We could enhance the recipe in order to include extra information in addition
    to the recorded Git hash. It is not unusual to detect whether the build environment
    is "dirty", that is, whether it contains uncommitted changes and untracked files,
    or "clean". This information could be detected using `git describe --abbrev=7
    --long --always --dirty --tags`. Depending on the ambition for reproducibility
    one could even record the full output of `git status` into a header file but we
    leave these enhancements as an exercise.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以增强配方，以便在记录的Git哈希之外包含额外信息。检测构建环境是否“脏”（即是否包含未提交的更改和未跟踪的文件）或“干净”并不罕见。可以使用`git
    describe --abbrev=7 --long --always --dirty --tags`检测此信息。根据可重复性的雄心，甚至可以将`git status`的完整输出记录到头文件中，但我们将其作为练习留给读者。
