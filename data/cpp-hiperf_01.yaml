- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: A Brief Introduction to C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++简介
- en: This book aims to provide you with a solid foundation to write efficient applications,
    as well as an insight into strategies for implementing libraries in modern C++.
    I have tried to take a practical approach to explain how C++ works today, where
    modern features from C++11 up to C++20 are a natural part of the language, rather
    than looking at C++ historically.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书旨在为您提供编写高效应用程序的坚实基础，以及实现现代C++库的策略。我试图以实用的方式来解释C++如何运作，现代C++11到C++20的现代特性是语言的自然部分，而不是从历史上看C++。
- en: 'In this chapter, we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Cover some of the features of C++ that are important for writing robust, high-performance
    applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍一些对编写健壮、高性能应用程序很重要的C++特性
- en: Discuss the advantages and disadvantages of C++ over competing languages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论C++相对于竞争语言的优势和劣势
- en: Go over the libraries and compilers used in this book
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看本书中使用的库和编译器
- en: Why C++?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择C++？
- en: Let's begin by exploring some of the reasons for using C++ today. In short,
    C++ is a highly portable language that offers zero-cost abstractions. Furthermore,
    C++ provides programmers with the ability to write and manage large, expressive,
    and robust code bases. In this section, we'll look at what we mean by *zero-cost
    abstractions*, compare C++ abstraction with abstraction in other languages, and discuss
    portability and robustness, and why such features are important.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探讨一些今天使用C++的原因。简而言之，C++是一种高度可移植的语言，提供了零成本的抽象。此外，C++为程序员提供了编写和管理大型、富有表现力和健壮的代码库的能力。在本节中，我们将探讨*零成本抽象*的含义，将C++的抽象与其他语言中的抽象进行比较，并讨论可移植性和健壮性，以及为什么这些特性很重要。
- en: Let's begin by getting into zero-cost abstractions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始进入零成本抽象。
- en: Zero-cost abstractions
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 零成本抽象
- en: Active code bases grow. The more developers working on a code base, the larger
    the code base becomes. In order to manage the growing complexity of a code base,
    we need language features such as variables, functions, and classes to be able
    to create our own abstractions with custom names and interfaces that suppress
    details of the implementation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃的代码库会不断增长。有更多的开发人员在一个代码库上工作，代码库就会变得更大。为了管理代码库不断增长的复杂性，我们需要语言特性，比如变量、函数和类，能够使用自定义名称和接口创建我们自己的抽象，以抑制实现的细节。
- en: C++ allows us to define our own abstractions but it also comes with built-in
    abstractions. The concept of a C++ function, for example, is in itself an abstraction
    for controlling program flow. The range-based `for`-loop is another example of
    a built-in abstraction that makes it possible to iterate over a range of values
    more directly. As programmers, we add new abstraction continuously while developing
    programs. Similarly, new versions of C++ introduce new abstractions to the language
    and the standard library. But constantly adding abstractions and new levels of
    indirection comes at a price – efficiency. This is where zero-cost abstractions
    play its role. A lot of the abstractions offered by C++ come at a very low runtime
    cost with respect to space and time.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许我们定义自己的抽象，但它也带有内置的抽象。例如，C++函数的概念本身就是控制程序流的抽象。基于范围的`for`循环是另一个内置抽象的例子，它使得直接迭代一系列值成为可能。作为程序员，我们在开发程序时不断添加新的抽象。同样，C++的新版本引入了语言和标准库的新抽象。但是不断添加抽象和新的间接层是有代价的——效率。这就是零成本抽象发挥作用的地方。C++提供的许多抽象在空间和时间方面的运行成本非常低。
- en: With C++, you are free to talk about memory addresses and other computer-related
    low-level terms when needed. However, in a large-scale software project, it is
    desirable to express code in terms that deal with whatever the application is
    doing, and let the libraries handle the computer-related terminology. The source
    code of a graphics application may deal with pencils, colors, and filters, whereas
    a game may deal with mascots, castles, and mushrooms. Low-level computer-related
    terms, such as memory addresses, can stay hidden in C++ library code where performance
    is critical.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++，当需要时可以自由地谈论内存地址和其他与计算机相关的低级术语。然而，在大型软件项目中，希望用处理应用程序正在执行的任务的术语来表达代码，并让库处理与计算机相关的术语。图形应用程序的源代码可能涉及铅笔、颜色和滤镜，而游戏可能涉及吉祥物、城堡和蘑菇。低级的与计算机相关的术语，比如内存地址，可以留在C++库代码中，其中性能至关重要。
- en: Programming languages and machine code abstractions
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程语言和机器码抽象
- en: In order to relieve programmers from the need to deal with computer-related
    terms, modern programming languages use abstractions so that a list of strings,
    for example, can be handled and thought of as a list of strings rather than a
    list of addresses that we may easily lose track of if we make the slightest typo.
    Not only do the abstractions relieve the programmers from bugs, they also make
    the code more expressive by using concepts from the domain of the application.
    In other words, the code is expressed in terms that are closer to a spoken language
    than if expressed with abstract programming keywords.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让程序员摆脱处理与计算机相关的术语的需要，现代编程语言使用抽象，这样一个字符串列表，例如，可以被处理和看作是一个字符串列表，而不是一个我们可能会因为轻微的拼写错误而失去追踪的地址列表。这些抽象不仅让程序员摆脱了错误，还通过使用应用程序领域的概念使代码更具表现力。换句话说，代码用更接近口语的术语表达，而不是用抽象的编程关键字表达。
- en: C++ and C are two completely different languages nowadays. Still, C++ is highly
    compatible with C and has inherited a lot of its syntax and idioms from C. To
    give you some examples of C++ abstractions, I will show how a problem can be solved
    in both C and C++.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C++和C现在是两种完全不同的语言。不过，C++与C高度兼容，并且从C继承了很多语法和习惯用法。为了给你一些C++抽象的例子，我将展示如何在C和C++中解决一个问题。
- en: 'Take a look at the following C/C++ code snippets, which correspond to the question:
    "How many copies of Hamlet are in this list of books?"'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下C/C++代码片段，它们对应于问题：“这个书籍列表中有多少本《哈姆雷特》？”
- en: 'We will begin with the C version:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从C版本开始：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The equivalent version using C++ would look something like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++的等效版本看起来会是这样的：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Although the C++ version is still more of a robot language than a human language,
    a lot of programming lingo is gone thanks to the higher levels of abstraction.
    Here are some of the noticeable differences between the preceding two code snippets:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C++版本仍然更像机器语言而不是人类语言，但由于更高级别的抽象，许多编程术语已经消失。以下是前两个代码片段之间的一些显著差异：
- en: The pointers to raw memory addresses are not visible at all
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始内存地址的指针根本不可见
- en: The `std::forward_list<std::string>` container replaces the hand crafted linked
    list using `string_elem_t`
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_list<std::string>`容器替换了手工制作的使用`string_elem_t`的链表'
- en: The `std::count()` function replaces both the `for`-loop and the `if`-statement
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::count()`函数替换了`for`循环和`if`语句'
- en: The `std::string` class provides a higher-level abstraction over `char*` and
    `strcmp()`
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::string`类提供了对`char*`和`strcmp()`的更高级别抽象'
- en: Basically, both versions of `num_hamlet()` translate to roughly the same machine
    code, but the language features of C++ makes it possible to let the libraries
    hide computer-related terminology such as pointers. Many of the modern C++ language
    features can be seen as abstractions on top of basic C functionality.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`num_hamlet()`的两个版本都会转换为大致相同的机器代码，但C++的语言特性使得库可以隐藏计算机相关的术语，比如指针。许多现代C++语言特性可以被视为对基本C功能的抽象。
- en: Abstractions in other languages
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他语言中的抽象
- en: Most programming languages are based on abstractions, which are transformed
    into machine code to be executed by the CPU. C++ has evolved into a highly expressive
    language, just like many of the other popular programming languages of today.
    What distinguishes C++ from most other languages is that while the other languages
    have implemented these abstractions at the cost of runtime performance, C++ has
    always strived to implement its abstractions at zero cost at runtime. This doesn't
    mean that an application written in C++ is by default faster than the equivalent
    in, say, C#. Rather, it means that by using C++, you'll have fine-grained control
    of the emitted machine code instructions and memory footprint if needed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都是基于抽象构建的，这些抽象被转换为机器代码，由CPU执行。C++已经发展成为一种高度表达性的语言，就像今天许多其他流行的编程语言一样。C++与大多数其他语言的区别在于，其他语言实现这些抽象是以运行时性能为代价的，而C++始终致力于以零成本实现其抽象。这并不意味着用C++编写的应用程序默认比用其他语言（比如C#）编写的应用程序更快。相反，这意味着通过使用C++，您可以对生成的机器代码指令和内存占用进行精细控制（如果需要）。
- en: To be fair, optimal performance is very rarely required today, and compromising
    performance for lower compilation times, garbage collection, or safety, like other
    languages do, is in many cases more reasonable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，如今很少需要最佳性能，而为了更低的编译时间、垃圾回收或安全性而牺牲性能，就像其他语言所做的那样，在许多情况下更为合理。
- en: The zero-overhead principle
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 零开销原则
- en: '"Zero-cost abstractions" is a commonly used term, but it is afflicted with
    a problem – most abstractions usually do cost. If not while running the program,
    it almost always cost somewhere down the line, such as long compilation times,
    compilation error messages that are hard to interpret and so forth. What is usually
    more interesting to talk about is the zero-overhead principle. Bjarne Stroustrup,
    the inventor of C++, defines the zero-overhead principle like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: “零成本抽象”是一个常用的术语，但它存在一个问题 - 大多数抽象通常都是有成本的。即使在程序运行时没有成本，也几乎总是在某个地方产生成本，比如长时间的编译时间，难以解释的编译错误消息等等。通常更有趣的是讨论零开销原则。C++的发明者Bjarne
    Stroustrup这样定义零开销原则：
- en: What you don't use, you don't pay for
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不使用的东西，你就不需要付费
- en: What you do use, you couldn't hand code any better
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你使用的东西，你无法手工编码得更好
- en: This a core principle in C++ and a very important aspect of the evolution of
    the language. Why, you may ask? Abstractions built on this principle will be accepted
    and used broadly by performance-aware programmers and in a context where performance
    is highly critical. Finding abstractions that many people agree on and use extensively,
    makes our code bases easier to read and maintain.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C++的一个核心原则，也是语言演变的一个非常重要的方面。为什么，你可能会问？基于这一原则构建的抽象将被性能意识强烈的程序员广泛接受和使用，并且在性能非常关键的环境中使用。找到许多人都同意并广泛使用的抽象，使我们的代码库更易于阅读和维护。
- en: On the contrary, features in the C++ language that don't fully follow the zero-overhead
    principle tend to be abandoned by programmers, projects, and companies. Two of
    the most notable features in this category are **exceptions** (unfortunately)
    and **Run-time Type Information** (**RTTI**). Both these features can have an
    impact on the performance even when they are not being used. I strongly recommend
    using exceptions though, unless you have a very good reason not to. The performance
    overhead is in most cases negligible compared to using some other mechanism for
    handling errors.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，C++语言中不完全遵循零开销原则的特性往往会被程序员、项目和公司所放弃。在这一类中最显著的两个特性是异常（不幸的是）和运行时类型信息（RTTI）。即使没有使用这些特性，它们都可能对性能产生影响。我强烈建议使用异常，除非你有非常充分的理由不这样做。与使用其他机制处理错误相比，性能开销在大多数情况下都是可以忽略的。
- en: Portability
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可移植性
- en: C++ has been a popular and comprehensive language for a long time. It's highly
    compatible with C, and very little has been deprecated in the language, for better
    or worse. The history and design of C++ has made it into a highly portable language,
    and the evolution of modern C++ has ensured that it will stay that way for a long
    time to come. C++ is a living language, and compiler vendors are currently doing
    a remarkable job to implement new language features rapidly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C++长期以来一直是一种受欢迎且全面的语言。它与C高度兼容，语言中很少有被弃用的部分，无论是好是坏。C++的历史和设计使其成为一种高度可移植的语言，而现代C++的发展确保了它将长期保持这种状态。C++是一种活跃的语言，编译器供应商目前正在非常出色地迅速实现新的语言特性。
- en: Robustness
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 健壮性
- en: In addition to performance, expressiveness, and portability, C++ offers a set
    of language features that gives the programmer the ability to write robust code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了性能、表现力和可移植性之外，C++还提供了一系列语言特性，使程序员能够编写健壮的代码。
- en: In the experience of the authors, robustness does not refer to strength in the
    programming language itself – it's possible to write robust code in any language.
    Rather, strict ownership of resources, `const` correctness, value semantics, type
    safety, and the deterministic destruction of objects are some of the features
    offered by C++ that makes it easier to write robust code. That is, the ability
    to write functions, classes, and libraries that are easy to use and hard to misuse.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在作者的经验中，健壮性并不是指编程语言本身的强大性 - 在任何语言中都可以编写健壮的代码。相反，资源的严格所有权，const正确性，值语义，类型安全以及对象的确定性销毁是C++提供的一些功能，使得编写健壮的代码更容易。也就是说，能够编写易于使用且难以误用的函数、类和库。
- en: C++ of today
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 今天的C++
- en: To sum it up, the C++ of today provides programmers with the ability to write
    an expressive and robust code base while still having the option to target almost
    any hardware platform or real-time requirements. Among the most commonly used
    languages today, C++ alone possesses all of these properties.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，今天的C++为程序员提供了编写富有表现力和健壮的代码基础的能力，同时还可以选择针对几乎任何硬件平台或实时需求。在今天最常用的语言中，只有C++具有所有这些特性。
- en: I've now provided a brief rundown as to why C++ remains a relevant and widely
    used programming language today. In the next section, we'll look at how C++ compares
    to other modern programming languages.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经简要介绍了为什么C++仍然是一种相关且广泛使用的编程语言。在接下来的部分，我们将看看C++与其他现代编程语言的比较。
- en: C++ compared with other languages
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与其他语言相比的C++
- en: A multitude of application types, platforms, and programming languages have
    emerged since C++ was first released. Still, C++ remains a widely used language,
    and its compilers are available for most platforms. The major exception, as of
    today, is the web platform, where JavaScript and its related technologies are
    the foundation. However, the web platform is evolving into being able to execute
    what was previously only possible in desktop applications, and in that context,
    C++ has found its way into web applications using technologies such as Emscripten,
    asm.js, and WebAssembly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++首次发布以来，出现了大量的应用类型、平台和编程语言。然而，C++仍然是一种广泛使用的语言，其编译器适用于大多数平台。截至今天，唯一的例外是Web平台，JavaScript及其相关技术是其基础。然而，Web平台正在发展，能够执行以前只在桌面应用程序中可能的功能，在这种情况下，C++已经通过使用诸如Emscripten、asm.js和WebAssembly等技术进入了Web应用程序。
- en: In this section, we'll begin by looking at competing languages in the context
    of performance. Following this, we'll look at how C++ handles object ownership
    and garbage collection in comparison to other languages, and how we can avoid
    null objects in C++. Finally, we'll cover some drawbacks of C++ that users should
    keep in mind when considering whether the language is appropriate for their requirements.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将首先从性能的角度比较竞争性语言。接下来，我们将看看C++如何处理对象所有权和垃圾回收，以及如何避免在C++中出现空对象。最后，我们将介绍一些C++的缺点，用户在考虑语言是否适合其需求时应该牢记。
- en: Competing languages and performance
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 竞争性语言和性能
- en: In order to understand how C++ achieves its performance compared to other programming
    languages, let's discuss some fundamental differences between C++ and most other
    modern programming languages.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解C++如何实现与其他编程语言相比的性能，让我们讨论一些C++与大多数其他现代编程语言之间的基本区别。
- en: For simplicity, this section will focus on comparing C++ to Java, although the
    comparisons for most parts also apply to other programming language based upon a garbage
    collector, such as C# and JavaScript.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，本节将重点比较C++和Java，尽管大部分比较也适用于基于垃圾收集器的其他编程语言，如C#和JavaScript。
- en: Firstly, Java compiles to bytecode, which is then compiled to machine code while
    the application is executing, whereas the majority of C++ implementations directly
    compiles the source code to machine code. Although bytecode and just-in-time compilers
    may theoretically be able to achieve the same (or, theoretically, even better)
    performance than precompiled machine code, as of today, they usually do not. To
    be fair, though, they perform well enough for most cases.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Java编译为字节码，然后在应用程序执行时将其编译为机器代码，而大多数C++实现直接将源代码编译为机器代码。尽管字节码和即时编译器在理论上可能能够实现与预编译的机器代码相同（或者在理论上甚至更好）的性能，但截至今天，它们通常做不到。不过，公平地说，它们对大多数情况来说表现得足够好。
- en: Secondly, Java handles dynamic memory in a completely different manner from
    C++. In Java, memory is automatically deallocated by a garbage collector, whereas
    a C++ program handles memory deallocations manually or by a reference counting
    mechanism. The garbage collector does prevent memory leaks, but at the cost of
    performance and predictability.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，Java以完全不同的方式处理动态内存，与C++不同。在Java中，内存由垃圾收集器自动释放，而C++程序通过手动或引用计数机制处理内存释放。垃圾收集器确实可以防止内存泄漏，但以性能和可预测性为代价。
- en: 'Thirdly, Java places all its objects in separate heap allocations, whereas
    C++ allows the programmer to place objects both on the stack and on the heap.
    In C++, it''s also possible to create multiple objects in one single heap allocation.
    This can be a huge performance gain for two reasons: objects can be created without
    always allocating dynamic memory, and multiple related objects can be placed adjacent
    to one another in memory.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，Java将所有对象放在单独的堆分配中，而C++允许程序员将对象放在堆和栈上。在C++中，还可以在一个单一的堆分配中创建多个对象。这可以有两个原因带来巨大的性能提升：对象可以在不总是分配动态内存的情况下创建，并且多个相关对象可以相邻地放置在内存中。
- en: 'Take a look at how memory is allocated in the following example. The C++ function
    uses the stack for both objects and integers; Java places the objects on the heap:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的例子中内存是如何分配的。C++函数在栈上同时使用对象和整数；Java将对象放在堆上：
- en: '| C++ | Java |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| C++ | Java |'
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| C++ places everything on the stack:![](img/B15619_01_01.png) | Java places
    the `Car` objects on the heap:![](img/B15619_01_02.png) |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| C++将所有内容都放在堆栈上:![](img/B15619_01_01.png) | Java将`Car`对象放在堆上:![](img/B15619_01_02.png)
    |'
- en: 'Now take a look at the next example and see how an array of `Car` objects are
    placed in memory when using C++ and Java, respectively:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看下一个例子，看看在使用C++和Java时，`Car`对象的数组是如何放置在内存中的：
- en: '| C++ | Java |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| C++ | Java |'
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| The following diagram shows how the `Car` objects are laid out in memory
    in C++:![](img/B15619_01_03.png) | The following diagram shows how the `Car` objects
    are laid out in memory in Java:![](img/B15619_01_04.png) |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 以下图表显示了在C++中`Car`对象在内存中的布局:![](img/B15619_01_03.png) | 以下图表显示了在Java中`Car`对象在内存中的布局:![](img/B15619_01_04.png)
    |'
- en: The C++ vector contains the actual `Car` objects placed in one contiguous memory
    block, whereas the equivalent in Java is a contiguous memory block of *references*
    to `Car` objects. In Java, the objects have been allocated separately, which means
    that they can be located anywhere on the heap.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: C++向量包含放置在一个连续内存块中的实际`Car`对象，而Java中的等价物是对`Car`对象的*引用*的连续内存块。在Java中，对象已经分别分配，这意味着它们可以位于堆的任何位置。
- en: This affects the performance, as Java, in this example, effectively has to execute
    five allocations in the Java heap space. It also means that whenever the application
    iterates the list, there is a performance win for C++, since accessing nearby
    memory locations is faster than accessing several random spots in memory.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这会影响性能，因为在这个例子中，Java实际上需要在Java堆空间中执行五次分配。这也意味着每当应用程序迭代列表时，C++都会获得性能优势，因为访问附近的内存位置比访问内存中的几个随机位置更快。
- en: Non-performance-related C++ language features
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++语言的非性能相关特性
- en: It's tempting to believe that C++ should only be used if performance is a major
    concern. Isn't it the case that C++ just increases the complexity of the code
    base due to manual memory handling, which may result in memory leaks and hard-to-track
    bugs?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易认为只有在性能是主要关注点时才应该使用C++。难道不是这样吗？C++只是因为手动内存处理而增加了代码库的复杂性，这可能导致内存泄漏和难以跟踪的错误吗？
- en: This may have been true several C++ versions ago, but a modern C++ programmer
    relies on the provided containers and smart pointer types, which are part of the
    standard library. A substantial part of the C++ features added over the last 10
    years has made the language both more powerful and simpler to use.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能在几个C++版本前是真的，但现代C++程序员依赖于标准库中提供的容器和智能指针类型。在过去的10年中，C++增加的大部分特性使得这门语言更加强大和更容易使用。
- en: 'I would like to highlight some old but powerful features of C++ here that relate
    to robustness rather than performance, which are easily overlooked: value semantics,
    `const` correctness, ownership, deterministic destruction, and references.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里强调一些C++的旧但强大的特性，这些特性与健壮性有关，而不是性能，很容易被忽视：值语义、`const`正确性、所有权、确定性销毁和引用。
- en: Value semantics
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值语义
- en: C++ supports both value semantics and reference semantics. Value semantics lets
    us pass objects by value instead of just passing references to objects. In C++,
    value semantics is the default, which means that when you pass an instance of
    a class or struct, it behaves in the same way as passing an `int`, `float`, or
    any other fundamental type. To use reference semantics, we need to explicitly
    use references or pointers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: C++支持值语义和引用语义。值语义允许我们按值传递对象，而不仅仅是传递对象的引用。在C++中，值语义是默认的，这意味着当你传递一个类或结构的实例时，它的行为与传递`int`、`float`或任何其他基本类型的行为相同。要使用引用语义，我们需要明确使用引用或指针。
- en: 'The C++ type system gives us the ability to explicitly state the ownership
    of an object. Compare the following implementations of a simple class in C++ and
    Java. We will start with the C++ version:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: C++类型系统使我们能够明确陈述对象的所有权。比较C++和Java中一个简单类的以下实现。我们将从C++版本开始：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The corresponding implementation in Java could look like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中对应的实现可能如下所示：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the C++ version, the programmer states that the `toppings` are completely
    encapsulated by the `Bagel` class. Had the programmer intended the topping list
    to be shared among several bagels, it would have been declared as a pointer of
    some kind: `std::shared_ptr` if the ownership is shared among several bagels,
    or `std::weak_ptr` if someone else owns the topping list and is supposed to modify
    it as the program executes.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++版本中，程序员声明`toppings`完全被`Bagel`类封装。如果程序员打算让夹料列表在几个百吉饼之间共享，它将被声明为某种指针：如果所有权在几个百吉饼之间共享，则为`std::shared_ptr`，如果其他人拥有夹料列表并且应该在程序执行时修改它，则为`std::weak_ptr`。
- en: In Java, objects reference each other with shared ownership. Therefore, it's
    not possible to distinguish whether the topping list is intended to be shared
    among several bagels or not, or whether it is handled somewhere else or, if it
    is, as in most cases, completely owned by the `Bagel` class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，对象之间共享所有权。因此，无法区分夹心面包的夹料列表是打算在几个百吉饼之间共享还是不共享，或者它是否在其他地方处理，或者如果是在大多数情况下，是否完全由`Bagel`类拥有。
- en: 'Compare the following functions; as every object is shared by default in Java
    (and most other languages), programmers have to take precautions for subtle bugs
    such as this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 比较以下函数；由于在Java（和大多数其他语言）中默认情况下每个对象都是共享的，程序员必须对诸如此类的微妙错误采取预防措施：
- en: '| C++ | Java |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| C++ | Java |'
- en: '|'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Const correctness
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: const正确性
- en: Another powerful feature of C++, which Java and many other languages lack, is
    the ability to write fully `const` correct code. Const correctness means that
    each member function signature of a class explicitly tells the caller whether
    the object will be modified or not; and it will not compile if the caller tries
    to modify an object declared `const`. In Java, it is possible to declare constants
    using the `final` keyword, but this lacks the ability to declare member functions
    as `const`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: C++的另一个强大特性是能够编写完全“const”正确的代码，而Java和许多其他语言则缺乏这一能力。Const正确性意味着类的每个成员函数签名都明确告诉调用者对象是否会被修改；如果调用者尝试修改声明为“const”的对象，则不会编译。在Java中，可以使用“final”关键字声明常量，但这缺乏将成员函数声明为“const”的能力。
- en: 'Here is an example of how we can use `const` member functions to prevent unintentional
    modifications of objects. In the following `Person` class, the member function
    `age()` is declared `const` and is therefore not allowed to mutate the `Person`
    object, whereas `set_age()` mutates the object and *cannot* be declared `const`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，说明如何使用“const”成员函数防止意外修改对象。在下面的“Person”类中，成员函数“age()”声明为“const”，因此不允许改变“Person”对象，而“set_age()”改变对象，*不能*声明为“const”：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It''s also possible to distinguish between returning mutable and immutable
    references to members. In the following `Team` class, the member function `leader()`
    `const` returns an immutable `Person`, whereas `leader()` returns a `Person` object
    that may be mutated:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以区分返回可变和不可变引用的成员。在下面的“Team”类中，成员函数“leader() const”返回一个不可变的“Person”，而“leader()”返回一个可能被改变的“Person”对象：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let''s see how the compiler can help us find errors when we try to mutate
    immutable objects. In the following example, the function argument `teams` is
    declared `const`, explicitly showing that this function is not allowed to modify
    them:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看编译器如何帮助我们找到在尝试改变不可变对象时的错误。在下面的示例中，函数参数“teams”声明为“const”，明确显示此函数不允许修改它们：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we want to write a function that *can* mutate the `teams` object, we simply
    remove `const`. This signals to the caller that this function may mutate the `teams`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想编写一个*可以*改变“teams”对象的函数，我们只需删除“const”。这向调用者发出信号，表明此函数可能会改变“teams”：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Object ownership
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象所有权
- en: Except in very rare situations, a C++ programmer should leave the memory handling
    to containers and smart pointers, and never have to rely on manual memory handling.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除非在非常罕见的情况下，C++程序员应该将内存处理留给容器和智能指针，而不必依赖手动内存处理。
- en: To put it clearly, the garbage collection model in Java could almost be emulated
    in C++ by using `std::shared_ptr` for every object. Note that garbage-collecting
    languages don't use the same algorithm for allocation tracking as `std::shared_ptr`.
    The `std::shared_ptr` is a smart pointer based on a reference-counting algorithm
    that will leak memory if objects have cyclic dependencies. Garbage-collecting
    languages have more sophisticated methods that can handle and free cyclic dependent
    objects.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 明确地说，通过使用“std::shared_ptr”可以在C++中几乎模拟Java中的垃圾收集模型。请注意，垃圾收集语言不使用与“std::shared_ptr”相同的分配跟踪算法。“std::shared_ptr”是基于引用计数算法的智能指针，如果对象具有循环依赖关系，它将泄漏内存。垃圾收集语言具有更复杂的方法，可以处理和释放循环依赖对象。
- en: However, rather than relying on a garbage collector, forcing a strict ownership
    delicately avoids subtle bugs that may result from sharing objects by default,
    as in the case of Java.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与依赖垃圾收集器不同，通过精心避免共享对象默认情况下的严格所有权，可以避免由此产生的微妙错误，就像Java中的情况一样。
- en: If a programmer minimizes shared ownership in C++, the resulting code is easier
    to use and harder to abuse, as it can force the user of the class to use it as
    it is intended.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序员在C++中最小化了共享所有权，生成的代码将更易于使用，更难被滥用，因为它可以强制类的用户按照预期使用它。
- en: Deterministic destruction in C++
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++中的确定性销毁
- en: The destruction of objects is deterministic in C++. That means that we (can)
    know exactly when an object is being destroyed. This is not the case for garbage-collected
    languages like Java where the garbage collector decides when an unreferenced object
    is being finalized.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，对象的销毁是确定性的。这意味着我们（可以）确切地知道对象何时被销毁。而在Java等垃圾收集语言中，垃圾收集器决定未引用对象何时被终结，这种情况并非如此。
- en: In C++, we can reliably reverse what has been done during the lifetime of an
    object. At first, this might seem like a small thing. But it turns out to have
    a great impact on how we can provide exception safety guarantees and handle resources
    (such as memory, file handles, mutex locks, and more) in C++.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，我们可以可靠地撤销对象生命周期中所做的操作。起初，这可能看起来微不足道。但事实证明，这对我们如何提供异常安全保证以及在C++中处理资源（如内存、文件句柄、互斥锁等）有很大影响。
- en: Deterministic destruction is also one of the features that makes C++ predictable.
    Something that is highly valued among programmers and a requirement for performance-critical
    applications.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性销毁也是使C++可预测的特性之一。这是程序员非常重视的东西，也是对性能关键应用的要求。
- en: We will spend more time talking about object ownership, lifetimes, and resource
    management later on in the book. So don't be too worried if this doesn't make
    much sense at the moment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面花更多时间讨论对象所有权、生命周期和资源管理。因此，如果目前这些内容还不太清楚，不要太担心。
- en: Avoiding null objects using C++ references
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用C++引用避免空对象
- en: In addition to strict ownership, C++ also has the concept of references, which
    is different from references in Java. Internally, a reference is a pointer that
    is not allowed to be null or repointed; therefore, no copying is involved when
    passing it to a function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了严格的所有权外，C++还有引用的概念，这与Java中的引用不同。在内部，引用是一个不允许为空或重新指向的指针；因此，当将其传递给函数时不涉及复制。
- en: As a result, a function signature in C++ can explicitly restrict the programmer
    from passing a null object as a parameter. In Java, the programmer must use documentation
    or annotations to indicate non-null parameters.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，C++中的函数签名可以明确限制程序员传递null对象作为参数。在Java中，程序员必须使用文档或注释来指示非null参数。
- en: Take a look at these two Java functions for computing the volume of a sphere.
    The first one throws a runtime exception if a null object is passed to it, whereas
    the second one silently ignores null objects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这两个用于计算球体体积的Java函数。第一个如果传递了null对象就会抛出运行时异常，而第二个则会悄悄地忽略null对象。
- en: 'This first implementation in Java throws a runtime exception if passed a null
    object:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，第一个实现如果传递了null对象就会抛出运行时异常：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This second implementation in Java silently handles null objects:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，第二个实现会悄悄地处理null对象：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In both functions implemented in Java, the caller of the function has to inspect
    the implementation of the function in order to determine whether null objects
    are allowed or not.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中实现的这两个函数中，调用函数的人必须检查函数的实现，以确定是否允许null对象。
- en: In C++, the first function signature explicitly accepts only initialized objects
    by using a reference that cannot be null. The second version using a pointer as
    an argument explicitly shows that null objects are handled.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，第一个函数签名明确只接受通过引用初始化的对象，引用不能为null。使用指针作为参数的第二个版本明确显示了处理null对象。
- en: 'C++ arguments passed as references indicates that null values are not allowed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: C++中作为引用传递的参数表示不允许null值：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'C++ arguments passed as pointers indicates that null values are being handled:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: C++中作为指针传递的参数表示正在处理null值：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Being able to use references or values as arguments in C++ instantly informs
    the C++ programmer how the function is intended to be used. Conversely, in Java,
    the user must inspect the implementation of the function, as objects are always
    passed as pointers, and there's a possibility that they could be null.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在C++中使用引用或值作为参数立即告知C++程序员函数的预期使用方式。相反，在Java中，用户必须检查函数的实现，因为对象总是作为指针传递，并且存在它们可能为null的可能性。
- en: Drawbacks of C++
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++的缺点
- en: Comparing C++ with other programming languages wouldn't be fair without mentioning
    some of its drawbacks. As mentioned earlier, C++ has more concepts to learn, and
    is therefore harder to use correctly and to its full potential. However, if a
    programmer can master C++, the higher complexity turns into an advantage and the
    code base becomes more robust and performs better.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不提及一些缺点，将C++与其他编程语言进行比较是不公平的。正如前面提到的，C++有更多的概念需要学习，因此更难正确使用和发挥其全部潜力。然而，如果程序员能够掌握C++，更高的复杂性就会变成优势，代码库变得更加健壮并且性能更好。
- en: There are, nonetheless, some shortcomings of C++, which are simply just shortcomings.
    The most severe of those shortcomings are long compilation times and the complexity
    of importing libraries. Up until C++20, C++ has relied on an outdated import system
    where imported headers are simply pasted into whatever includes them. C++ modules,
    which are being introduced in C++20, will solve some of the problems of the system,
    which is based on including header files, and will also have a positive impact
    on compilation times for large projects.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C++也有一些缺点，这些缺点只是缺点。其中最严重的是长时间的编译时间和导入库的复杂性。直到C++20，C++一直依赖于一个过时的导入系统，其中导入的头文件只是简单地粘贴到需要它们的地方。C++20中引入的模块将解决系统的一些问题，该系统基于包含头文件，并且还将对大型项目的编译时间产生积极影响。
- en: Another apparent drawback of C++ is the lack of provided libraries. While other
    languages usually come with all the libraries needed for most applications, such
    as graphics, user interfaces, networking, threading, resource handling, and so
    on, C++ provides, more or less, nothing more than the bare minimum of algorithms,
    threads, and, as of C++17, file system handling. For everything else, programmers
    have to rely on external libraries.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: C++的另一个明显缺点是缺乏提供的库。而其他语言通常提供大多数应用程序所需的所有库，例如图形、用户界面、网络、线程、资源处理等，C++提供的几乎只是最基本的算法、线程，以及从C++17开始的文件系统处理。对于其他一切，程序员必须依赖外部库。
- en: To summarize, although C++ has a steeper learning curve than most other languages,
    if used correctly, the robustness of C++ is an advantage compared to many other
    languages. So, despite the compilation times and lack of provided libraries, I
    believe that C++ is a well-suited language for large-scale projects, even for
    projects where performance is not the highest priority.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，尽管C++的学习曲线比大多数其他语言要陡峭，但如果使用正确，C++的健壮性与许多其他语言相比是一个优势。因此，尽管编译时间长且缺乏提供的库，我认为C++是一个非常适合大型项目的语言，即使对于性能不是最高优先级的项目也是如此。
- en: Libraries and compilers used in this book
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书中使用的库和编译器
- en: As mentioned earlier, C++ does not provide more than the bare necessities in
    terms of libraries. In this book, we will, therefore, have to rely on external
    libraries where necessary. The most commonly used library in the world of C++
    is probably the Boost library ([http://www.boost.org](http://www.boost.org)).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，C++在库方面并没有提供更多的东西。因此，在本书中，我们必须在必要时依赖外部库。在C++世界中最常用的库可能是Boost库（[http://www.boost.org](http://www.boost.org)）。
- en: Some parts of this book use the Boost library where the standard C++ library
    is not enough. We will only use the header-only parts of the Boost library, which
    means that using them yourself does not require any specific build setup; rather,
    you just have to include the specified header file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一些部分使用了Boost库，因为标准C++库不够。我们只会使用Boost库的头文件部分，这意味着使用它们自己不需要任何特定的构建设置；而只需要包含指定的头文件即可。
- en: In addition, we will use Google Benchmark, a microbenchmark support library,
    to evaluate the performance of small code snippets. Google Benchmark will be introduced
    in *Chapter 3*, *Analyzing and Measuring Performance*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用Google Benchmark，一个微基准支持库，来评估小代码片段的性能。Google Benchmark将在*第3章* *分析和测量性能*中介绍。
- en: The repository available at [https://github.com/PacktPublishing/Cpp-High-Performance-Second-Edition](https://github.com/PacktPublishing/Cpp-High-Performance-Second-Edition)
    with the accompanying source code of the book uses the Google Test framework to
    make it easier for you to build, run, and test the code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可在[https://github.com/PacktPublishing/Cpp-High-Performance-Second-Edition](https://github.com/PacktPublishing/Cpp-High-Performance-Second-Edition)找到本书的存储库，其中包含了书中的源代码，使用了Google
    Test框架，使您更容易构建、运行和测试代码。
- en: It should also be mentioned that this book uses a lot of new features from C++20\.
    At the time of writing, some of these features are not fully implemented by the
    compilers we use (Clang, GCC, and Microsoft Visual C++). Some of the features
    presented are completely missing or are only supported experimentally. An excellent
    up-to-date summary of the current status of the major C++ compilers can be found
    at [https://en.cppreference.com/w/cpp/compiler_support](https://en.cppreference.com/w/cpp/compiler_support).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该提到，本书使用了很多来自C++20的新功能。在撰写本文时，我们使用的编译器（Clang、GCC和Microsoft Visual C++）尚未完全实现其中一些功能。其中一些功能完全缺失或仅支持实验性功能。关于主要C++编译器当前状态的最新摘要可以在[https://en.cppreference.com/w/cpp/compiler_support](https://en.cppreference.com/w/cpp/compiler_support)找到。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I have highlighted some features and drawbacks of C++ and how
    it has evolved to the state it is in today. Further, we discussed the advantages
    and disadvantages of C++ compared with other languages, both from the perspective
    of performance and robustness.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我已经强调了C++的一些特点和缺点，以及它是如何发展到今天的状态的。此外，我们讨论了C++与其他语言相比的优缺点，从性能和健壮性的角度来看。
- en: In the next chapter, we will explore some modern and essential C++ features
    that have had a major impact on how the language has developed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些对C++语言发展产生重大影响的现代和基本功能。
