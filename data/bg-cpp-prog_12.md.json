["```cpp\nint main() \n{ \n   // Declare an instance of Engine \n   Engine engine; \n\n   // Start the engine \n   engine.run(); \n\n   // Quit in the usual way when the engine is stopped \n   return 0; \n} \n\n```", "```cpp\n#pragma once \n#ifndef TEXTURE_HOLDER_H \n#define TEXTURE_HOLDER_H \n\n#include <SFML/Graphics.hpp> \n#include <map> \n\nclass TextureHolder \n{ \nprivate: \n   // A map container from the STL, \n   // that holds related pairs of String and Texture \n   std::map<std::string, sf::Texture> m_Textures; \n\n   // A pointer of the same type as the class itself \n   // the one and only instance \n   static TextureHolder* m_s_Instance; \n\npublic: \n   TextureHolder(); \n   static sf::Texture& GetTexture(std::string const& filename); \n\n}; \n\n#endif \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"TextureHolder.h\" \n#include <assert.h> \n\nusing namespace sf; \nusing namespace std; \n\nTextureHolder* TextureHolder::m_s_Instance = nullptr; \n\nTextureHolder::TextureHolder() \n{ \n   assert(m_s_Instance == nullptr); \n   m_s_Instance = this; \n} \n\nsf::Texture& TextureHolder::GetTexture(std::string const& filename) \n{ \n   // Get a reference to m_Textures using m_S_Instance \n   auto& m = m_s_Instance->m_Textures; \n   // auto is the equivalent of map<string, Texture> \n\n   // Create an iterator to hold a key-value-pair (kvp) \n   // and search for the required kvp \n   // using the passed in file name \n   auto keyValuePair = m.find(filename); \n   // auto is equivalent of map<string, Texture>::iterator \n\n   // Did we find a match? \n   if (keyValuePair != m.end()) \n   { \n      // Yes \n      // Return the texture, \n      // the second part of the kvp, the texture \n      return keyValuePair->second; \n   } \n   else \n   { \n      // File name not found \n      // Create a new key value pair using the filename \n      auto& texture = m[filename]; \n      // Load the texture from file in the usual way \n      texture.loadFromFile(filename); \n\n      // Return the texture to the calling code \n      return texture; \n   } \n} \n\n```", "```cpp\n#pragma once \n#include <SFML/Graphics.hpp> \n#include \"TextureHolder.h\" \n\nusing namespace sf; \n\nclass Engine \n{ \nprivate: \n   // The texture holder \n   TextureHolder th; \n\n   const int TILE_SIZE = 50; \n   const int VERTS_IN_QUAD = 4; \n\n   // The force pushing the characters down \n   const int GRAVITY = 300; \n\n   // A regular RenderWindow \n   RenderWindow m_Window; \n\n   // The main Views \n   View m_MainView; \n   View m_LeftView; \n   View m_RightView; \n\n   // Three views for the background \n   View m_BGMainView; \n   View m_BGLeftView; \n   View m_BGRightView; \n\n   View m_HudView; \n\n   // Declare a sprite and a Texture  \n   // for the background \n   Sprite m_BackgroundSprite; \n   Texture m_BackgroundTexture; \n\n   // Is the game currently playing? \n   bool m_Playing = false; \n\n   // Is character 1 or 2 the current focus? \n   bool m_Character1 = true; \n\n   // Start in fullscreen mode \n   bool m_SplitScreen = false; \n\n   // How much time is left in the current level \n   float m_TimeRemaining = 10; \n   Time m_GameTimeTotal; \n\n   // Is it time for a new/first level? \n   bool m_NewLevelRequired = true; \n\n   // Private functions for internal use only \n   void input(); \n   void update(float dtAsSeconds); \n   void draw(); \n\npublic: \n   // The Engine constructor \n   Engine(); \n\n   // Run will call all the private functions \n   void run(); \n\n}; \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"Engine.h\" \n\nEngine::Engine() \n{ \n   // Get the screen resolution  \n   // and create an SFML window and View \n   Vector2f resolution; \n   resolution.x = VideoMode::getDesktopMode().width; \n   resolution.y = VideoMode::getDesktopMode().height; \n\n   m_Window.create(VideoMode(resolution.x, resolution.y), \n      \"Thomas was late\", \n      Style::Fullscreen); \n\n   // Initialize the fullscreen view \n   m_MainView.setSize(resolution); \n   m_HudView.reset( \n      FloatRect(0, 0, resolution.x, resolution.y)); \n\n   // Inititialize the split screen Views \n   m_LeftView.setViewport( \n      FloatRect(0.001f, 0.001f, 0.498f, 0.998f)); \n\n   m_RightView.setViewport( \n      FloatRect(0.5f, 0.001f, 0.499f, 0.998f)); \n\n   m_BGLeftView.setViewport( \n      FloatRect(0.001f, 0.001f, 0.498f, 0.998f)); \n\n   m_BGRightView.setViewport( \n      FloatRect(0.5f, 0.001f, 0.499f, 0.998f)); \n\n   m_BackgroundTexture = TextureHolder::GetTexture( \n      \"graphics/background.png\"); \n\n   // Associate the sprite with the texture \n   m_BackgroundSprite.setTexture(m_BackgroundTexture); \n\n} \n\n```", "```cpp\nvoid Engine::run() \n{ \n   // Timing    \n   Clock clock; \n\n   while (m_Window.isOpen()) \n   { \n      Time dt = clock.restart(); \n      // Update the total game time \n      m_GameTimeTotal += dt; \n      // Make a decimal fraction from the delta time \n      float dtAsSeconds = dt.asSeconds(); \n\n      // Call each part of the game loop in turn \n      input(); \n      update(dtAsSeconds); \n      draw(); \n   } \n} \n\n```", "```cpp\nvoid Engine::input() \n{ \n   Event event; \n   while (m_Window.pollEvent(event)) \n   { \n      if (event.type == Event::KeyPressed) \n      {         \n         // Handle the player quitting \n         if (Keyboard::isKeyPressed(Keyboard::Escape)) \n         { \n            m_Window.close(); \n         } \n\n         // Handle the player starting the game \n         if (Keyboard::isKeyPressed(Keyboard::Return)) \n         { \n            m_Playing = true; \n         } \n\n         // Switch between Thomas and Bob \n         if (Keyboard::isKeyPressed(Keyboard::Q)) \n         { \n            m_Character1 = !m_Character1; \n         } \n\n         // Switch between full and split screen \n         if (Keyboard::isKeyPressed(Keyboard::E)) \n         { \n            m_SplitScreen = !m_SplitScreen; \n         } \n      } \n   }   \n} \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"Engine.h\" \n#include <SFML/Graphics.hpp> \n#include <sstream> \n\nusing namespace sf; \n\nvoid Engine::update(float dtAsSeconds) \n{ \n\n   if (m_Playing) \n   { \n      // Count down the time the player has left \n      m_TimeRemaining -= dtAsSeconds; \n\n      // Have Thomas and Bob run out of time? \n      if (m_TimeRemaining <= 0) \n      { \n         m_NewLevelRequired = true; \n      } \n\n   }// End if playing \n\n} \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"Engine.h\" \n\nvoid Engine::draw() \n{ \n   // Rub out the last frame \n   m_Window.clear(Color::White); \n\n   if (!m_SplitScreen) \n   { \n      // Switch to background view \n      m_Window.setView(m_BGMainView); \n      // Draw the background \n      m_Window.draw(m_BackgroundSprite); \n      // Switch to m_MainView \n      m_Window.setView(m_MainView);     \n   } \n   else \n   { \n      // Split screen view is active \n\n      // First draw Thomas' side of the screen \n\n      // Switch to background view \n      m_Window.setView(m_BGLeftView); \n      // Draw the background \n      m_Window.draw(m_BackgroundSprite); \n      // Switch to m_LeftView \n      m_Window.setView(m_LeftView); \n\n      // Now draw Bob's side of the screen \n\n      // Switch to background view \n      m_Window.setView(m_BGRightView); \n      // Draw the background \n      m_Window.draw(m_BackgroundSprite); \n      // Switch to m_RightView \n      m_Window.setView(m_RightView); \n\n   } \n\n   // Draw the HUD \n   // Switch to m_HudView \n   m_Window.setView(m_HudView); \n\n   // Show everything we have just drawn \n   m_Window.display(); \n} \n\n```", "```cpp\nif (!m_SplitScreen) \n{ \n} \nelse \n{ \n} \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"Engine.h\" \n\nint main() \n{ \n   // Declare an instance of Engine \n   Engine engine; \n\n   // Start the engine VRRrrrrmmm \n   engine.run(); \n\n   // Quit in the usual way when the engine is stopped \n   return 0; \n} \n\n```"]