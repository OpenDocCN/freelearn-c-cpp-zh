- en: The New C++17 Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的C++17功能
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Using structured bindings to unpack bundled return values
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用结构化绑定来解包捆绑的返回值
- en: Limiting variable scopes to `if` and `switch` statements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将变量范围限制为`if`和`switch`语句
- en: Profiting from the new bracket initializer rules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从新的括号初始化规则中获益
- en: Letting the constructor automatically deduce the resulting template class type
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让构造函数自动推断结果模板类类型
- en: Simplifying compile-time decisions with constexpr-if
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用constexpr-if简化编译时决策
- en: Enabling header-only libraries with inline variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内联变量启用仅头文件库
- en: Implementing handy helper functions with fold expressions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用折叠表达式实现方便的辅助函数
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: C++ got a lot of additions in C++11, C++14, and, most recently, C++17\. By now,
    it is a completely different language compared to what it was just a decade ago.
    The C++ standard does not only standardize the language, as it needs to be understood
    by the compilers, but also the C++ standard template library (STL).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: C++在C++11、C++14和最近的C++17中增加了很多内容。到目前为止，它与十年前完全不同。C++标准不仅标准化了语言，因为它需要被编译器理解，还标准化了C++标准模板库（STL）。
- en: This book explains how to put the STL to the best use with a broad range of
    examples. But at first, this chapter will concentrate on the most important new
    language features. Mastering them will greatly help you write readable, maintainable,
    and expressive code a lot.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将解释如何通过大量示例充分利用STL。但首先，本章将集中讨论最重要的新语言特性。掌握它们将极大地帮助您编写可读、可维护和富有表现力的代码。
- en: We will see how to access individual members of pairs, tuples, and structures
    comfortably with structured bindings and how to limit variable scopes with the
    new `if` and `switch` variable initialization capabilities. The syntactical ambiguities,
    which were introduced by C++11 with the new bracket initialization syntax, which
    looks the same for initializer lists, were fixed by *new bracket initializer rules*.
    The exact *type* of template class instances can now be *deduced* from the actual
    constructor arguments, and if different specializations of a template class will
    result in completely different code, this is now easily expressible with constexpr-if.
    The handling of variadic parameter packs in template functions became much easier
    in many cases with the new *fold expressions*. At last, it became more comfortable
    to define static globally accessible objects in header-only libraries with the
    new ability to declare inline variables, which was only possible for functions
    before.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何使用结构化绑定舒适地访问对、元组和结构的单个成员，以及如何使用新的`if`和`switch`变量初始化功能来限制变量范围。C++11引入了新的括号初始化语法，它看起来与初始化列表相同，引入了语法上的歧义，这些问题已经通过*新的括号初始化规则*得到解决。现在可以从实际构造函数参数中*推断*模板类实例的确切*类型*，如果模板类的不同特化将导致完全不同的代码，现在可以使用constexpr-if轻松表达。在许多情况下，使用新的*折叠表达式*可以使模板函数中的可变参数包处理变得更加容易。最后，使用新的内联变量声明静态全局可访问对象在仅头文件库中变得更加舒适，这在之前只对函数可行。
- en: Some of the examples in this chapter might be more interesting for implementers
    of libraries than for developers who implement applications. While we will have
    a look at such features for completeness reasons, it is not too critical to understand
    all the examples of this chapter immediately in order to understand the rest of
    this book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的一些示例对库的实现者可能更有趣，而对于实现应用程序的开发人员来说可能不那么重要。虽然出于完整性的原因我们将研究这些特性，但不需要立即理解本章的所有示例就能理解本书的其余部分。
- en: Using structured bindings to unpack bundled return values
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用结构化绑定来解包捆绑的返回值
- en: 'C++17 comes with a new feature, which combines syntactic sugar and automatic
    type deduction: **structured bindings**. These help to assign values from pairs,
    tuples, and structs into individual variables. In other programming languages,
    this is also called **unpacking**.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++17带来了一个新特性，结合了语法糖和自动类型推断：**结构化绑定**。这有助于将对、元组和结构的值分配给单独的变量。在其他编程语言中，这也被称为**解包**。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Applying a structured binding in order to assign multiple variables from one
    bundled structure is always one step. Let''s first see how it was done before
    C++17\. Then, we can have a look at multiple examples that show how we can do
    it in C++17:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应用结构化绑定以从一个捆绑结构中分配多个变量始终是一步。让我们首先看看C++17之前是如何做的。然后，我们可以看一下多个示例，展示了我们如何在C++17中做到这一点：
- en: 'Accessing individual values of an `std::pair`: Imagine we have a mathematical
    function, `divide_remainder`, which accepts a *dividend* and a *divisor* parameter
    and returns the fraction of both as well as the remainder. It returns those values
    using an `std::pair` bundle:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问`std::pair`的单个值：假设我们有一个数学函数`divide_remainder`，它接受*被除数*和*除数*参数，并返回两者的分数以及余数。它使用`std::pair`捆绑返回这些值：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Consider the following way of accessing the individual values of the resulting
    pair:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下访问结果对的单个值的方式：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Instead of doing it as shown in the preceding code snippet, we can now assign
    the individual values to individual variables with expressive names, which is
    much better to read:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用有表达力的名称将单个值分配给单独的变量，这样阅读起来更好：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Structured bindings also work with `std::tuple`: Let''s take the following
    example function, which gets us online stock information:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化绑定也适用于`std::tuple`：让我们看看以下示例函数，它可以获取在线股票信息：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Assigning its result to individual variables looks just like in the example
    before:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将其结果分配给单独的变量看起来就像前面的示例：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Structured bindings also work with custom structures: Let''s assume a structure
    like the following:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化绑定也适用于自定义结构：假设有以下结构：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can access these members using structured bindings. We can even do
    that in a loop, assuming we have a whole vector of those:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用结构化绑定访问这些成员。假设我们有一个整个向量：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Structured bindings are always applied with the same pattern:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化绑定总是以相同的模式应用：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The list of variables `var1, var2, ...` must exactly match the number of variables
    contained by the expression being assigned from.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量列表`var1, var2, ...`必须与被赋值的表达式包含的变量数量完全匹配。
- en: 'The `<pair, tuple, struct, or array expression>` must be one of the following:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<pair, tuple, struct, or array expression>`必须是以下之一：'
- en: An `std::pair`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`std::pair`。
- en: An `std::tuple`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`std::tuple`。
- en: A `struct`. All members must be *non-static* and defined in the *same base class*.
    The first declared member is assigned to the first variable, the second member
    to the second variable, and so on.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`struct`。所有成员必须是*非静态*的，并且定义在*同一个基类*中。第一个声明的成员被分配给第一个变量，第二个成员被分配给第二个变量，依此类推。
- en: An array of fixed size.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定大小的数组。
- en: The type can be `auto`, `const auto`, `const auto&`, and even `auto&&`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型可以是`auto`、`const auto`、`const auto&`，甚至`auto&&`。
- en: Not only for the sake of *performance*, always make sure to minimize needless
    copies by using references when appropriate.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅出于*性能*的考虑，始终确保通过在适当的情况下使用引用来最小化不必要的复制。
- en: 'If we write *too many* or *not enough* variables between the square brackets,
    the compiler will error out, telling us about our mistake:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在方括号之间写入*太多*或*太少*的变量，编译器将报错，告诉我们我们的错误：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This example obviously tries to stuff a tuple variable with three members into
    only two variables. The compiler immediately chokes on this and tells us about
    our mistake:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子显然试图将一个包含三个成员的元组变量塞入只有两个变量的情况中。编译器立即对此进行了处理，并告诉我们我们的错误：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A lot of fundamental data structures from the STL are immediately accessible
    using structured bindings without us having to change anything. Consider, for
    example, a loop that prints all the items of an `std::map`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: STL中的许多基本数据结构都可以立即使用结构化绑定进行访问，而无需我们改变任何内容。例如，考虑一个循环，打印出`std::map`的所有项：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This particular example works because when we iterate over an `std::map` container,
    we get the `std::pair<const key_type, value_type>` nodes on every iteration step.
    Exactly these nodes are unpacked using the structured bindings feature (`key_type`
    is the `species` string and `value_type` is the population count `size_t`) in
    order to access them individually in the loop body.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的例子之所以有效，是因为当我们遍历一个`std::map`容器时，我们在每次迭代步骤上得到`std::pair<const key_type,
    value_type>`节点。正是这些节点使用结构化绑定功能（`key_type`是`species`字符串，`value_type`是人口计数`size_t`）进行拆包，以便在循环体中单独访问它们。
- en: 'Before C++17, it was possible to achieve a similar effect using `std::tie`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17之前，可以使用`std::tie`来实现类似的效果：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example shows how to unpack the resulting pair into two variables. The
    `std::tie` is less powerful than structured bindings in the sense that we have
    to define all the variables we want to bind to *before*. On the other hand, this
    example shows a strength of `std::tie` that structured bindings do *not* have:
    the value `std::ignore` acts as a dummy variable. The fraction part of the result
    is assigned to it, which leads to that value being dropped because we do not need
    it in that example.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何将结果对拆分成两个变量。`std::tie`在某种意义上比结构化绑定功能弱，因为我们必须在*之前*定义我们想要绑定的所有变量。另一方面，这个例子展示了`std::tie`的一个优势，结构化绑定没有：值`std::ignore`充当一个虚拟变量。结果的小数部分被分配给它，这导致该值被丢弃，因为在这个例子中我们不需要它。
- en: When using structured bindings, we don't have `tie` dummy variables, so we have
    to bind all the values to named variables. Doing so and ignoring some of them
    is efficient, nevertheless, because the compiler can optimize the unused bindings
    out easily.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用结构化绑定时，我们没有`tie`虚拟变量，因此我们必须将所有的值绑定到命名变量。尽管如此，忽略其中一些是有效的，因为编译器可以轻松地优化未使用的绑定。
- en: 'Back in the past, the `divide_remainder` function could have been implemented
    in the following way, using output parameters:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 回到过去，`divide_remainder`函数可以以以下方式实现，使用输出参数：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Accessing it would have looked like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 访问它看起来像这样：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A lot of people will still prefer this over returning complex structures like
    pairs, tuples, and structs, arguing that this way the code would be *faster*,
    due to avoided intermediate copies of those values. This is *not true* any longer
    for modern compilers, which optimize intermediate copies away.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人仍然更喜欢这种方式，而不是返回像对、元组和结构这样的复杂结构，他们认为这样代码会更*快*，因为避免了这些值的中间复制。对于现代编译器来说，这*不再是真的*，因为它们会优化掉中间复制。
- en: Apart from the missing language features in C, returning complex structures
    via return value was considered slow for a long time because the object had to
    be initialized in the returning function and then copied into the variable that
    should contain the return value on the caller side. Modern compilers support **return
    value optimization** (RVO), which enables for omitting intermediate copies.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了C语言中缺少的语言特性外，通过返回值返回复杂结构长时间被认为是慢的，因为对象必须在返回函数中初始化，然后复制到应该包含返回值的变量中。现代编译器支持**返回值优化**（RVO），可以省略中间复制。
- en: Limiting variable scopes to if and switch statements
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将变量范围限制在if和switch语句中
- en: It is good style to limit the scope of variables as much as possible. Sometimes,
    however, one first needs to obtain some value, and only if it fits a certain condition,
    it can be processed further.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能限制变量的范围是一个很好的风格。然而，有时候，我们首先需要获取一些值，只有在符合某种条件的情况下，才能进一步处理。
- en: For this purpose, C++17 comes with `if` and `switch` statements with initializers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，C++17提供了带有初始化程序的`if`和`switch`语句。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we use the initializer syntax in both the supported contexts
    in order to see how they tidy up our code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们在支持的上下文中都使用了初始化程序语法，以便看到它们如何整理我们的代码：
- en: 'The `if` statements: Imagine we want to find a character in a character map
    using the `find` method of `std::map`:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`语句：假设我们想要使用`std::map`的`find`方法在字符映射中找到一个字符：'
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `switch` statements: This is how it would look to get a character from
    the input and, at the same time, check the value in a `switch` statement in order
    to control a computer game:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`语句：这是从输入中获取字符并同时在`switch`语句中检查值以控制计算机游戏的样子。'
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `if` and `switch` statements with initializers are basically just syntax
    sugar. The following two samples are equivalent:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 带有初始化器的`if`和`switch`语句基本上只是语法糖。以下两个示例是等效的：
- en: '*Before* C++17:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*C++17之前*：'
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Since* C++17:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*自* C++17：'
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The same applies to `switch` statements:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于`switch`语句：
- en: 'Before C++17:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17之前：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since C++17:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++17以来：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This feature is very useful to keep the scope of a variable as short as necessary.
    Before C++17, this was only possible using extra braces around the code, as the
    pre-C++17 examples show. The short lifetimes reduce the number of variables in
    the scope, which keeps our code tidy and makes it easier to refactor.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性非常有用，可以使变量的作用域尽可能短。在C++17之前，只能在代码周围使用额外的大括号来实现这一点，正如C++17之前的示例所示。短暂的生命周期减少了作用域中的变量数量，使我们的代码整洁，并且更容易重构。
- en: There's more...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Another interesting use case is the limited scope of critical sections. Consider
    the following example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的用例是临界区的有限作用域。考虑以下例子：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At first, an `std::lock_guard` is created. This is a class that accepts a mutex
    argument as a constructor argument. It *locks* the mutex in its constructor, and
    when it runs out of scope, it *unlocks* it again in its destructor. This way,
    it is impossible to *forget* to unlock the mutex. Before C++17, a pair of extra
    braces was needed in order to determine the scope where it unlocks again.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个`std::lock_guard`。这是一个接受互斥体参数作为构造函数参数的类。它在其构造函数中*锁定*互斥体，并且当它超出作用域时，在其析构函数中再次*解锁*它。这样，忘记解锁互斥体是不可能的。在C++17之前，需要一对额外的大括号来确定它再次解锁的作用域。
- en: 'Yet another interesting use case is the scope of weak pointers. Consider the
    following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的用例是弱指针的作用域。考虑以下情况：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is another example where we would have a useless `shared_pointer` variable
    leaking into the current scope, although it has a potentially useless state outside
    the `if` conditional block or noisy extra brackets!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子，我们会有一个无用的`shared_pointer`变量泄漏到当前作用域，尽管它在`if`条件块外部或有嘈杂的额外括号时可能是无用的！
- en: 'The `if` statements with initializers are especially useful when using *legacy*
    APIs with output parameters:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 带有初始化器的`if`语句在使用*遗留*API和输出参数时特别有用：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`GetExitCodeProcess` is a Windows kernel API function. It returns the exit
    code for a given process handle but only if that handle is valid. After leaving
    this conditional block, the variable is useless, so we don''t need it in any scope
    any longer.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetExitCodeProcess`是Windows内核API函数。它返回给定进程句柄的退出代码，但只有在该句柄有效时才会返回。离开这个条件块后，变量就变得无用了，所以我们不再需要它在任何作用域中。'
- en: Being able to initialize variables within `if` blocks is obviously very useful
    in a lot of situations and, especially, when dealing with legacy APIs that use
    output parameters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在`if`块中初始化变量在许多情况下显然非常有用，特别是在处理使用输出参数的遗留API时。
- en: Keep your scopes tight using `if` and `switch` statement initializers. This
    makes your code more compact, easier to read, and in code refactoring sessions,
    it will be easier to move around.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if`和`switch`语句的初始化器来保持作用域紧凑。这样可以使您的代码更紧凑，更易于阅读，并且在代码重构会话中，移动代码会更容易。
- en: Profiting from the new bracket initializer rules
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从新的大括号初始化规则中获益
- en: C++11 came with the new brace initializer syntax `{}`. Its purpose was to allow
    for *aggregate* initialization, but also for usual constructor calling. Unfortunately,
    it was too easy to express the wrong thing when combining this syntax with the
    `auto` variable type. C++17 comes with an enhanced set of initializer rules. In
    this recipe, we will clarify how to correctly initialize variables with which
    syntax in C++17.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: C++11带来了新的大括号初始化语法`{}`。它的目的是允许*聚合*初始化，但也允许通常的构造函数调用。不幸的是，当将这个语法与`auto`变量类型结合使用时，很容易表达错误的事情。C++17带来了增强的初始化规则。在本教程中，我们将阐明如何在C++17中使用哪种语法正确初始化变量。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Variables are initialized in one step. Using the initializer syntax, there
    are two different situations:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在一步中初始化。使用初始化语法，有两种不同的情况：
- en: 'Using the brace initializer syntax *without* `auto` type deduction:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不带有`auto`类型推断的大括号初始化语法中：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using the brace initializer syntax *with* `auto` type deduction:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有`auto`类型推断的大括号初始化语法：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Without `auto` type deduction, there's not much to be surprised about in the
    brace `{}` operator, at least, when initializing regular types. When initializing
    containers such as `std::vector`, `std::list`, and so on, a brace initializer
    will match the `std::initializer_list` constructor of that container class. It
    does this in a *greedy* manner, which means that it is not possible to match non-aggregate
    constructors (non-aggregate constructors are usual constructors in contrast to
    the ones that accept an initializer list).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`auto`类型推断时，在使用大括号`{}`操作符初始化常规类型时，不会有太多令人惊讶的地方。当初始化容器如`std::vector`、`std::list`等时，大括号初始化将匹配该容器类的`std::initializer_list`构造函数。它以*贪婪*的方式进行匹配，这意味着不可能匹配非聚合构造函数（非聚合构造函数是通常的构造函数，与接受初始化列表的构造函数相对）。
- en: '`std::vector`, for example, provides a specific non-aggregate constructor,
    which fills arbitrarily many items with the same value: `std::vector<int> v (N,
    value)`. When writing `std::vector<int> v {N, value}`, the `initializer_list`
    constructor is chosen, which will initialize the vector with two items: `N` and
    `value`. This is a special pitfall one should know about.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`，例如，提供了一个特定的非聚合构造函数，它可以用相同的值填充任意多个项目：`std::vector<int> v (N, value)`。当写成`std::vector<int>
    v {N, value}`时，将选择`initializer_list`构造函数，它将用两个项目`N`和`value`初始化向量。这是一个特殊的陷阱，人们应该知道。'
- en: 'One nice detail about the `{}` operator compared to constructor calling using
    normal `()` parentheses is that they do no implicit type conversions: `int x (1.2);`
    and `int x = 1.2;` will initialize `x` to value `1` by silently rounding down
    the floating point value and converting it to int. `int x {1.2};`, in contrast,
    will not compile because it wants to *exactly* match the constructor type.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用普通的`()`括号调用构造函数相比，`{}`操作符的一个好处是它们不进行隐式类型转换：`int x (1.2);` 和 `int x = 1.2;`
    会将`x`初始化为值`1`，通过将浮点值四舍五入并将其转换为int。相比之下，`int x {1.2};` 不会编译，因为它要*完全*匹配构造函数类型。
- en: One can controversially argue about which initialization style is the best one.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可以就哪种初始化样式是最好的进行有争议的讨论。
- en: Fans of the bracket initialization style say that using brackets makes it very
    explicit, that the variable is initialized with a constructor call, and that this
    code line is not reinitializing anything. Furthermore, using `{}` brackets will
    select the only matching constructor, while initializer lines using `()` parentheses
    try to match the closest constructor and even do type conversion in order to match.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 支持大括号初始化样式的人说，使用大括号使得变量被构造函数调用初始化非常明确，并且这行代码不会重新初始化任何东西。此外，使用`{}`大括号将选择唯一匹配的构造函数，而使用`()`括号的初始化行则尝试匹配最接近的构造函数，甚至进行类型转换以进行匹配。
- en: The additional rule introduced in C++17 affects the initialization with `auto`
    type deduction--while C++11 would correctly make the type of the variable `auto
    x {123};` an `std::initializer_list<int>` with only one element, this is seldom
    what we would want. C++17 would make the same variable an `int`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: C++17引入的附加规则影响了使用`auto`类型推断的初始化--虽然C++11会正确地将变量`auto x {123};`的类型推断为只有一个元素的`std::initializer_list<int>`，但这很少是我们想要的。C++17会将相同的变量推断为`int`。
- en: 'Rule of thumb:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则：
- en: '`auto var_name {one_element};` deduces `var_name` to be of the same type as
    `one_element`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto var_name {one_element};` 推断`var_name`与`one_element`的类型相同'
- en: '`auto var_name {element1, element2, ...};` is invalid and does not compile'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto var_name {element1, element2, ...};` 是无效的，无法编译'
- en: '`auto var_name = {element1, element2, ...};` deduces to an `std::initializer_list<T>`
    with `T` being of the same type as all the elements in the list'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auto var_name = {element1, element2, ...};` 推断为一个`std::initializer_list<T>`，其中`T`与列表中所有元素的类型相同'
- en: C++17 has made it harder to accidentally define an initializer list.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: C++17使得意外定义初始化列表变得更加困难。
- en: Trying this out with different compilers in C++11/C++14 mode will show that
    some compilers actually deduce `auto x {123};` to an `int`, while others deduce
    it to `std::initializer_list<int>`. Writing code like this can lead to problems
    regarding portability!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11/C++14模式下尝试使用不同的编译器将会显示一些编译器实际上将`auto x {123};`推断为`int`，而其他编译器将其推断为`std::initializer_list<int>`。编写这样的代码可能会导致可移植性问题！
- en: Letting the constructor automatically deduce the resulting template class type
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让构造函数自动推断出结果模板类的类型
- en: A lot of classes in C++ are usually specialized on types, which could be easily
    deduced from the variable types the user puts in their constructor calls. Nevertheless,
    before C++17, this was not a standardized feature. C++17 lets the compiler *automatically*
    deduce template types from constructor calls.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的许多类通常是专门针对类型进行特化的，这些类型可以很容易地从用户在构造函数调用中放入的变量类型中推断出来。然而，在C++17之前，这不是一个标准化的特性。C++17允许编译器从构造函数调用中*自动*推断模板类型。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'A very handy use case for this is constructing `std::pair` and `std::tuple`
    instances. These can be specialized and instantiated and specialized in one step:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的一个非常方便的用例是构造`std::pair`和`std::tuple`实例。这些可以在一步中进行专门化和实例化：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let’s define an example class where automatic template type deduction would
    be of value:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个示例类，其中自动模板类型推断将会有价值：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Okay, this is just another template class. We previously had to write the following
    in order to instantiate it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这只是另一个模板类。以前我们必须这样写才能实例化它：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now just omit the template specialization part:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以省略模板专门化部分：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Before C++17, this was only possible by implementing a *make function helper*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17之前，只能通过实现*make函数助手*来实现这一点：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Using such helpers, it was possible to have a similar effect:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的辅助函数，可以实现类似的效果：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The STL already comes with a lot of helper functions such as that one: `std::make_shared`,
    `std::make_unique`, `std::make_tuple`, and so on. In C++17, these can now mostly
    be regarded as obsolete. Of course, they will be provided further for compatibility
    reasons.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: STL已经提供了许多类似的辅助函数，如`std::make_shared`、`std::make_unique`、`std::make_tuple`等。在C++17中，这些现在大多可以被视为过时。当然，它们将继续提供以确保兼容性。
- en: There's more...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'What we just learned about was *implicit template type deduction*. In some
    cases, we cannot rely on implicit type deduction. Consider the following example
    class:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学到的是*隐式模板类型推断*。在某些情况下，我们不能依赖隐式类型推断。考虑以下示例类：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This struct, `sum`, accepts an arbitrary number of parameters and adds them
    together using a fold expression (have a look at the fold expression recipe a
    little later in this chapter to get more details on fold expressions). The resulting
    sum is saved in the member variable `value`. Now the question is, what type is
    `T`? If we don''t want to specify it explicitly, it surely needs to depend on
    the types of the values provided in the constructor. If we provide string instances,
    it needs to be `std::string`. If we provide integers, it needs to be `int`. If
    we provide integers, floats, and doubles, the compiler needs to figure out which
    type fits all the values without information loss. In order to achieve that, we
    provide an *explicit deduction guide*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构`sum`接受任意数量的参数，并使用折叠表达式将它们相加（稍后在本章中查看折叠表达式示例，以获取有关折叠表达式的更多详细信息）。结果的和保存在成员变量`value`中。现在的问题是，`T`是什么类型？如果我们不想明确指定它，它肯定需要依赖于构造函数中提供的值的类型。如果我们提供字符串实例，它需要是`std::string`。如果我们提供整数，它需要是`int`。如果我们提供整数、浮点数和双精度浮点数，编译器需要找出哪种类型适合所有值而不会丢失信息。为了实现这一点，我们提供了一个*显式推导指南*：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This deduction guide tells the compiler to use the `std::common_type_t` trait,
    which is able to find out which common type fits all the values. Let''s see how
    to use it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个推导指南告诉编译器使用`std::common_type_t`特性，它能够找出适合所有值的公共类型。让我们看看如何使用它：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the first line we instantiate a `sum` object with constructor arguments of
    type `unsigned`, `double`, `int`, and `float`. The `std::common_type_t` returns
    `double` as the common type, so we get a `sum<double>` instance. In the second
    line, we provide an `std::string` instance and a C-style string. Following our
    deduction guide, the compiler constructs an instance of type `sum<std::string>`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们使用`unsigned`，`double`，`int`和`float`类型的构造函数参数实例化了一个`sum`对象。`std::common_type_t`返回`double`作为公共类型，所以我们得到一个`sum<double>`实例。在第二行中，我们提供了一个`std::string`实例和一个C风格的字符串。根据我们的推导指南，编译器构造了一个`sum<std::string>`类型的实例。
- en: When running this code, it will print `10` as the numeric sum and `abcdef` as
    the string *sum*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码时，它将打印数字和字符串的和。
- en: Simplifying compile time decisions with constexpr-if
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用constexpr-if简化编译时决策
- en: In templated code, it is often necessary to do certain things differently, depending
    on the type the template is specialized for. C++17 comes with constexpr-if expressions,
    which simplify the code in such situations *a lot*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板化的代码中，通常需要根据模板专门化的类型来做一些不同的事情。C++17带来了constexpr-if表达式，它大大简化了这种情况下的代码。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll implement a little helper template class. It can deal
    with different template type specializations because it is able to select completely
    different code in some passages, depending on what type we specialize it for:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将实现一个小的辅助模板类。它可以处理不同的模板类型专门化，因为它能够根据我们为其专门化的类型在某些段落中选择完全不同的代码：
- en: 'Write the part of the code that is generic. In our example, it is a simple
    class, which supports adding a type `U` value to the type `T` member value using
    an `add` function:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写通用部分的代码。在我们的例子中，这是一个简单的类，支持使用`add`函数将类型`U`的值添加到类型`T`的成员值中：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Imagine that type `T` is `std::vector<something>` and type `U` is just `int`.
    What shall it mean to add an integer to a whole vector? Let''s say it means that
    we add the integer to every item in the vector. This will be done in a loop:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设类型`T`是`std::vector<something>`，类型`U`只是`int`。将整数添加到整个向量意味着什么？我们说这意味着我们将整数添加到向量中的每个项目。这将在循环中完成：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The next and last step is to *combine* both worlds. If `T` is a vector of `U`
    items, do the *loop* variant. If it is not, just implement the *normal* addition:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步，也是最后一步是*结合*两个世界。如果`T`是`U`项的向量，则执行*循环*变体。如果不是，则只需实现*正常*的加法：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The class can now be put to use. Let''s see how nicely it works with completely
    different types, such as `int`, `float`, `std::vector<int>`, and `std::vector<string>`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以使用该类。让我们看看它如何与完全不同的类型一起工作，例如`int`，`float`，`std::vector<int>`和`std::vector<string>`：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The new constexpr-if works exactly like usual if-else constructs. The difference
    is that the condition that it tests has to be evaluated at *compile time*. All
    runtime code that the compiler creates from our program will not contain any branch
    instructions from constexpr-if conditionals. One could also put it that it works
    in a similar manner to preprocessor `#if` and `#else` text substitution macros,
    but for those, the code would not even have to be syntactically well-formed. All
    the branches of a constexpr-if construct need to be *syntactically well-formed*,
    but the branches that are *not* taken do not need to be *semantically valid*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 新的constexpr-if的工作方式与通常的if-else结构完全相同。不同之处在于它测试的条件必须在*编译时*进行评估。编译器从我们的程序创建的所有运行时代码都不包含来自constexpr-if条件语句的任何分支指令。也可以说它的工作方式类似于预处理器`#if`和`#else`文本替换宏，但对于这些宏，代码甚至不需要在语法上是良好形式的。constexpr-if结构的所有分支都需要*语法上良好形式*，但*不*采取的分支不需要*语义上有效*。
- en: In order to distinguish whether the code should add the value `x` to a vector
    or not, we use the type trait `std::is_same`. An expression `std::is_same<A, B>::value`
    evaluates to the Boolean value `true` if `A` and `B` are of the same type. The
    condition used in our recipe is `std::is_same<T, std::vector<U>>::value`, which
    evaluates to `true` if the user specialized the class on `T = std::vector<X>`
    and tries to call `add` with a parameter of type `U = X`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分代码是否应该将值`x`添加到向量中，我们使用类型特征`std::is_same`。表达式`std::is_same<A, B>::value`在`A`和`B`是相同类型时求值为布尔值`true`。我们的条件是`std::is_same<T,
    std::vector<U>>::value`，如果用户将类专门化为`T = std::vector<X>`并尝试使用类型`U = X`的参数调用`add`，则求值为`true`。
- en: 'There can, of course, be multiple conditions in one constexpr-if-else block
    (note that `a` and `b` have to depend on template parameters and not only on compile-time
    constants):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，constexpr-if-else块中可以有多个条件（注意`a`和`b`必须依赖于模板参数，而不仅仅是编译时常量）：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With C++17, a lot of meta programming situations are much easier to express
    and to read.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++17，许多元编程情况更容易表达和阅读。
- en: There's more...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In order to relate how much constexpr-if constructs are an improvement to C++,
    we can have a look at how the same thing could have been implemented *before*
    C++17:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明constexpr-if结构对C++的改进有多大，我们可以看看在C++17*之前*如何实现相同的事情：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Without using constexpr-if, this class works for all different types we wished
    for, but it looks super complicated. How does it work?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用constexpr-if的情况下，这个类适用于我们希望的所有不同类型，但看起来非常复杂。它是如何工作的？
- en: The implementations alone of the *two different* `add` functions look simple.
    It's their return type declaration, which makes them look complicated, and which
    contains a trick--an expression such as `std::enable_if_t<condition, type>` evaluates
    to `type` if `condition` is `true`. Otherwise, the `std::enable_if_t` expression
    does not evaluate to anything. That would normally considered an error, but we
    will see why it is not.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*两个不同*`add`函数的实现看起来很简单。它们的返回类型声明使它们看起来复杂，并且包含一个技巧--例如`std::enable_if_t<condition,
    type>`表达式在`condition`为`true`时评估为`type`。否则，`std::enable_if_t`表达式不会评估为任何东西。这通常被认为是一个错误，但我们将看到为什么它不是。'
- en: For the second `add` function, the same condition is used in an *inverted* manner.
    This way, it can only be `true` at the same time for one of the two implementations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个`add`函数，相同的条件以*反转*的方式使用。这样，它只能同时对两个实现中的一个为`true`。
- en: 'When the compiler sees different template functions with the same name and
    has to choose one of them, an important principle comes into play: **SFINAE**,
    which stands for **Substitution Failure is not an Error**. In this case, this
    means that the compiler does not error out if the return value of one of those
    functions cannot be deduced from an erroneous template expression (which `std::enable_if`
    is, in case its condition evaluates to `false`). It will simply look further and
    try the *other* function implementation. That is the trick; that is how this works.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器看到具有相同名称的不同模板函数并且必须选择其中一个时，一个重要的原则就会发挥作用：**SFINAE**，它代表**替换失败不是错误**。在这种情况下，这意味着如果其中一个函数的返回值无法从错误的模板表达式中推导出（如果其条件评估为`false`，则`std::enable_if`是错误的），则编译器不会报错。它将简单地继续寻找并尝试*其他*函数实现。这就是诀窍；这就是它是如何工作的。
- en: What a hassle. It is nice to see that this became so much easier with C++17.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 真是麻烦。很高兴看到这在C++17中变得如此容易。
- en: Enabling header-only libraries with inline variables
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内联变量启用仅头文件库
- en: While it was always possible in C++ to declare individual functions *inline*,
    C++17 additionally allows us to declare *variables* inline. This makes it much
    easier to implement *header-only* libraries, which was previously only possible
    using workarounds.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在C++中一直可以声明单独的函数*内联*，但C++17还允许我们声明*变量*内联。这使得实现*仅头文件*库变得更加容易，这在以前只能使用变通方法实现。
- en: How it's done...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何实现的...
- en: 'In this recipe, we create an example class that could suit as a member of a
    typical header-only library. The target is to give it a static member and instantiate
    it in a globally available manner using the `inline` keyword, which would not
    be possible like this before C++17:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个示例类，它可以作为典型的仅头文件库的成员。目标是使用`inline`关键字以静态成员的方式实例化它，并以全局可用的方式使用它，这在C++17之前是不可能的。
- en: 'The `process_monitor` class should both contain a static member and be globally
    accessible itself, which would produce double-defined symbols when included from
    multiple translation units:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`process_monitor`类应该同时包含一个静态成员并且本身应该是全局可访问的，这将在从多个翻译单元包含时产生双重定义的符号：'
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we now include this in multiple `.cpp` files in order to compile and link
    them, this would fail at the linker stage. In order to fix this, we add the `inline`
    keyword:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在在多个`.cpp`文件中包含这个以便编译和链接它们，这将在链接阶段失败。为了解决这个问题，我们添加`inline`关键字：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Voila, that's it!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 看，就是这样！
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: C++ programs do often consist of multiple C++ source files (these do have `.cpp`
    or `.cc` suffices). These are individually compiled to modules/object files (which
    usually have .o suffices). Linking all the modules/object files together into
    a single executable or shared/static library is then the last step.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: C++程序通常由多个C++源文件组成（这些文件具有`.cpp`或`.cc`后缀）。这些文件被单独编译为模块/对象文件（通常具有.o后缀）。然后将所有模块/对象文件链接在一起成为单个可执行文件或共享/静态库是最后一步。
- en: At the link stage, it is considered an error if the linker can find the definition
    of one specific symbol *multiple* times. Let's say, for example, we have a function
    with a signature such as `int foo();`. If two modules define the same function,
    which is the right one? The linker can't just roll the dice. Well, it could, but
    that's most likely not what any programmer would ever want to happen.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接阶段，如果链接器可以找到一个特定符号的定义*多次*，则被视为错误。例如，我们有一个带有`int foo();`签名的函数。如果两个模块定义了相同的函数，那么哪一个是正确的？链接器不能随意选择。嗯，它可以，但这很可能不是任何程序员想要发生的事情。
- en: 'The traditional way to provide globally available functions is to *declare*
    them in the header files, which will be included by any C++ module that needs
    to call them. The definition of every of those functions will be then put *once*
    into separate module files. These are then linked together with the modules that
    desire to use these functions. This is also called the **One Definition Rule**
    (**ODR**). Check out the following illustration for better understanding:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 提供全局可用函数的传统方法是在头文件中*声明*它们，这些头文件将被任何需要调用它们的C++模块包含。然后，这些函数的定义将被放入单独的模块文件中*一次*。然后，这些模块与希望使用这些函数的模块一起链接在一起。这也被称为**一次定义规则**（**ODR**）。查看以下插图以更好地理解：
- en: '![](img/ee850b95-1991-4682-a5d1-1c7290509001.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee850b95-1991-4682-a5d1-1c7290509001.png)'
- en: However, if this were the only way, then it would not have been possible to
    provide header-only libraries. Header-only libraries are very handy because they
    only need to be included using `#include` into any C++ program file and then are
    immediately available. In order to use libraries that are not header-only, the
    programmer must also adapt the build scripts in order to have the linker link
    the library modules together with his own module files. Especially for libraries
    with only very short functions, this is unnecessarily uncomfortable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果这是唯一的方法，那么就不可能提供仅包含头文件的库。仅包含头文件的库非常方便，因为它们只需要使用`#include`包含到任何C++程序文件中，然后立即可用。为了使用不是仅包含头文件的库，程序员还必须调整构建脚本，以便链接器将库模块与自己的模块文件一起链接。特别是对于只有非常短函数的库，这是不必要的不舒服。
- en: For such cases, the `inline` keyword can be used to make an exception in order
    to allow *multiple* definitions of the same symbol in different modules. If the
    linker finds multiple symbols with the same signature, but they are declared inline,
    it will just choose the first one and trust that the other symbols have the same
    definition. That all equal inline symbols are defined completely equal is basically
    a *promise* from the programmer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，`inline`关键字可以用来做一个例外，以允许在不同模块中*多次*定义相同的符号。如果链接器找到具有相同签名的多个符号，但它们被声明为内联，它将只选择第一个并相信其他符号具有相同的定义。所有相等的内联符号都完全相等的定义基本上是程序员的*承诺*。
- en: Regarding our recipe example, the linker will find the `process_monitor::standard_string`
    symbol in every module that includes `foo_lib.hpp`. Without the `inline` keyword,
    it would not know which one to choose, so it would abort and report an error.
    The same applies to the `global_process_monitor` symbol. Which one is the right
    one?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的reciple示例，链接器将在每个包含`foo_lib.hpp`的模块中找到`process_monitor::standard_string`符号。没有`inline`关键字，它将不知道选择哪一个，因此它将中止并报告错误。对`global_process_monitor`符号也是一样。哪一个才是正确的？
- en: After declaring both the symbols `inline`, it will just accept the first occurrence
    of each symbol and *drop* all the others.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明两个符号`inline`后，它将只接受每个符号的第一次出现，并*丢弃*所有其他出现。
- en: Before C++17, the only clean way would be to provide this symbol via an additional
    C++ module file, which would force our library users to include this file in the
    linking step.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17之前，唯一的干净方法是通过额外的C++模块文件提供此符号，这将迫使我们的库用户在链接步骤中包含此文件。
- en: The `inline` keyword traditionally also has *another* function. It tells the
    compiler that it can *eliminate* the function call by taking its implementation
    and directly putting it where it was called. This way, the calling code contains
    one function call less, which can often be considered faster. If the function
    is very short, the resulting assembly will also be shorter (assuming that the
    number of instructions that do the function call, saving and restoring the stack,
    and so on, is higher than the actual payload code). If the inlined function is
    very long, the binary size will grow and this might sometimes not even lead to
    faster code in the end.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`inline`关键字传统上还有*另一个*功能。它告诉编译器可以通过获取其实现并直接将其放在调用它的地方来*消除*函数调用。这样，调用代码包含一个函数调用少，这通常被认为更快。如果函数非常短，生成的汇编代码也会更短（假设执行函数调用的指令数量，保存和恢复堆栈等比实际有效载荷代码更高）。如果内联函数非常长，二进制大小将增长，这有时甚至可能不会导致最终更快的代码。'
- en: Therefore, the compiler will only use the `inline` keyword as a hint and might
    eliminate function calls by inlining them. But it can also inline some functions
    *without* the programmer having it declared inline.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，编译器只会将`inline`关键字作为提示，并可能通过内联来消除函数调用。但它也可以内联一些函数，*而不需要*程序员声明为内联。
- en: There's more...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One possible workaround before C++17 was providing a `static` function, which
    returns a reference to a `static` object:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17之前的一个可能的解决方法是提供一个`static`函数，它返回一个`static`对象的引用：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This way, it is completely legal to include the header file in multiple modules
    but still getting access to exactly the same instance everywhere. However, the
    object is *not* constructed *immediately* at the start of program but only on
    the first call of this getter function. For some use cases, this is indeed a problem.
    Imagine that we want the constructor of the static, globally available object
    to do something important at *program start* (just as our reciple example library
    class), but due to the getter being called near the end of the program, it is
    too late.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，将头文件包含在多个模块中是完全合法的，但仍然可以在任何地方访问到完全相同的实例。然而，对象并不是在程序开始时立即构造的，而是只有在第一次调用此getter函数时才会构造。对于某些用例，这确实是一个问题。想象一下，我们希望静态的全局可用对象的构造函数在*程序开始*时做一些重要的事情（就像我们的reciple示例库类），但由于getter在程序结束时被调用，这就太晚了。
- en: Another workaround is to make the non-template class `foo` a template class,
    so it can profit from the same rules as templates.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方法是将非模板类`foo`变为模板类，这样它就可以从与模板相同的规则中获益。
- en: Both strategies can be avoided in C++17.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种策略在C++17中都可以避免。
- en: Implementing handy helper functions with fold expressions
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用折叠表达式实现方便的辅助函数
- en: Since C++11, there are variadic template parameter packs, which enable implementing
    functions that accept arbitrarily many parameters. Sometimes, these parameters
    are all combined into one expression in order to derive the function result from
    that. This task became really easy with C++17, as it comes with fold expressions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++11以来，有可变模板参数包，它们使得实现接受任意多个参数的函数成为可能。有时，这些参数都被合并成一个表达式，以便从中导出函数结果。这在C++17中变得非常容易，因为它带有折叠表达式。
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s implement a function that takes arbitrarily many parameters and returns
    their sum:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个函数，它接受任意多个参数并返回它们的总和：
- en: 'At first, we define its signature:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义它的签名：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'So, we have a parameter pack `ts` now, and the function should expand all the
    parameters and sum them together using a fold expression. If we use any operator
    (`+`, in this example) together with `...` in order to apply it to all the values
    of a parameter pack, we need to surround the expression with parentheses:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，现在我们有一个参数包`ts`，函数应该展开所有参数并使用折叠表达式将它们相加。如果我们使用任何操作符（在这个例子中是`+`）与`...`一起，以便将其应用于参数包的所有值，我们需要用括号括起表达式：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can now call it this way:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以这样调用它：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It does not only work with `int` types; we can call it with any type that just
    implements the `+` operator, such as `std::string`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它不仅适用于`int`类型；我们可以用任何实现了`+`运算符的类型来调用它，比如`std::string`：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: What we just did was a simple recursive application of a binary operator (`+`)
    to its parameters. This is generally called *folding*. C++17 comes with **fold
    expressions**, which help expressing the same idea with less code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚做的是对其参数进行简单的递归应用二元运算符(`+`)。这通常被称为*折叠*。C++17带有**折叠表达式**，它可以用更少的代码表达相同的想法。
- en: 'This kind of expression is called **unary fold**. C++17 supports folding parameter
    packs with the following binary operators: `+`, `-`, `*`, `/`, `%`, `^`, `&`,
    `|`, `=`, `<`, `>`, `<<`, `>>`, `+=`, `-=`, `*=`, `/=`, `%=`, `^=`, `&=`, `|=`,
    `<<=`, `>>=`, `==`, `!=`, `<=`, `>=`, `&&`, `||`, `,`, `.*`, `->*`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的表达式称为**一元折叠**。C++17支持使用以下二元操作符对参数包进行折叠：`+`、`-`、`*`、`/`、`%`、`^`、`&`、`|`、`=`、`<`、`>`、`<<`、`>>`、`+=`、`-=`、`*=`、`/=`、`%=`、`^=`、`&=`、`|=`、`<<=`、`>>=`、`==`、`!=`、`<=`、`>=`、`&&`、`||`、`,`、`.*`、`->*`。
- en: By the way, in our example code, it does not matter if we write `(ts + …)` or
    `(… + ts)`; both work. However, there is a difference that may be relevant in
    other cases--if the `…` dots are on the *right-hand* side of the operator, the
    fold is called a *right* fold. If they are on the *left-hand* side, it is a *left*
    fold.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，在我们的示例代码中，如果我们写`(ts + ...)`或`(… + ts)`都没有关系；两者都可以。然而，在其他情况下可能会有所不同--如果`…`点在操作符的*右侧*，则折叠称为*右*折叠。如果它们在*左侧*，则是*左*折叠。
- en: In our `sum` example, a unary left fold expands to `1 + (2 + (3 + (4 + 5)))`,
    while a unary right fold will expand to `(((1 + 2) + 3) + 4) + 5`. Depending on
    the operator in use, this can make a difference. When adding numbers, it does
    not.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`sum`示例中，一元左折叠展开为`1 + (2 + (3 + (4 + 5)))`，而一元右折叠将展开为`(((1 + 2) + 3) + 4)
    + 5`。根据使用的操作符，这可能会有所不同。当添加数字时，它并不会有所不同。
- en: There's more...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In case someone calls `sum()` with *no* arguments, the variadic parameter pack
    contains no values that could be folded. For most operators, this is an error
    (for some, it is not; we will see this in a minute). We then need to decide if
    this should stay an error or if an empty sum should result in a specific value.
    The obvious idea is that the sum of nothing is `0`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人用*没有*参数调用`sum()`，则变参参数包不包含可以折叠的值。对于大多数操作符来说，这是一个错误（对于一些操作符来说不是；我们将在一分钟内看到）。然后我们需要决定这是否应该保持为错误，或者空的总和是否应该导致特定的值。显而易见的想法是，什么都没有的总和是`0`。
- en: 'This is how it’s done:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的实现方式：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This way, `sum()` evaluates to `0`, and `sum(1, 2, 3)` evaluates to `(1 + (2
    + (3 + 0)))`. Such folds with an initial value are called **binary folds**.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`sum()`的结果是`0`，`sum(1, 2, 3)`的结果是`(1 + (2 + (3 + 0)))`。这种带有初始值的折叠称为**二进制折叠**。
- en: 'Again, it works if we write `(ts + ... + 0)`, or `(0 + ... + ts)`, but this
    makes the binary fold a binary *right* fold or a binary *left* fold again. Check
    out the following diagram:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们写`(ts + ... + 0)`或`(0 + ... + ts)`，它也可以工作，但这会使二进制折叠再次成为二进制*右*折叠或二进制*左*折叠。看看下面的图表：
- en: '![](img/4c518bfa-0a12-435d-820f-0199ee897ce3.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4c518bfa-0a12-435d-820f-0199ee897ce3.png)'
- en: When using binary folds in order to implement the no-argument case, the notion
    of an *identity* element is often important--in this case, adding a `0` to any
    number changes nothing, which makes `0` an identity element. Because of this property,
    we can add a `0` to any fold expression with the operators `+` or `-`, which leads
    to the result `0` in case there are no parameters in the parameter pack. From
    a mathematical point of view, this is correct. From an implementation view, we
    need to define what is correct, depending on what we need.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用二进制折叠来实现无参数情况时，*单位*元素的概念通常很重要--在这种情况下，将`0`添加到任何数字都不会改变任何东西，这使`0`成为单位元素。由于这个属性，我们可以使用`+`或`-`运算符将`0`添加到任何折叠表达式中，这将导致在参数包中没有参数的情况下结果为`0`。从数学的角度来看，这是正确的。从实现的角度来看，我们需要根据需要定义什么是正确的。
- en: 'The same principle applies to multiplication. Here, the identity element is
    `1`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的原则适用于乘法。在这里，单位元素是`1`：
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The result of `product(2, 3)` is `6`, and the result of `product()` without
    parameters is `1`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`product(2, 3)`的结果是`6`，没有参数的`product()`的结果是`1`。'
- en: The logical **and** (`&&`) and **or** (`||`) operators come with *built-in*
    identity elements. Folding an empty parameter pack with `&&` results in `true`,
    and folding an empty parameter pack with `||` results in `false`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑**和**(`&&`)和**或**(`||`)操作符带有*内置*单位元素。使用`&&`对空参数包进行折叠的结果是`true`，使用`||`对空参数包进行折叠的结果是`false`。
- en: Another operator that defaults to a certain expression when applied on empty
    parameter packs is the comma operator (`,`), which then defaults to `void()`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个操作符，当应用于空参数包时默认为某个表达式的逗号操作符（`,`），然后默认为`void()`。
- en: In order to ignite some inspiration, let's have a look at some more little helpers
    that we can implement using this feature.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了激发一些灵感，让我们看看我们可以使用这个特性实现的一些更多的小助手。
- en: Match ranges against individual items
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配范围与单个项目
- en: 'How about a function that tells whether some range contains *at least one*
    of the values we provide as variadic parameters:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如何编写一个函数，告诉我们某个范围是否包含我们提供的变参参数中的*至少一个*值：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The helper function uses the `std::count` function from the STL. This function
    takes three parameters: the first two parameters are the *begin* and *end* iterators
    of some iterable range, and as the third parameter, it takes a *value* which will
    be compared to all the items of the range. The `std::count` method then returns
    the number of all the elements within the range that are equal to the third parameter.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助函数使用STL中的`std::count`函数。该函数接受三个参数：前两个参数是某个可迭代范围的*begin*和*end*迭代器，作为第三个参数，它接受一个*value*，该值将与范围内的所有项目进行比较。然后，`std::count`方法返回范围内等于第三个参数的所有元素的数量。
- en: In our fold expression, we always feed the *begin* and *end* iterators of the
    same parameter range into the `std::count` function. However, as the third parameter,
    each time we put one other parameter from the parameter pack into it. In the end,
    the function sums up all the results and returns it to the caller.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的折叠表达式中，我们总是将相同参数范围的*begin*和*end*迭代器传递给`std::count`函数。然而，作为第三个参数，每次我们都将参数包中的另一个参数放入其中。最后，函数将所有结果相加并将其返回给调用者。
- en: 'We can use it like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用它：
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As we can see, the `matches` helper function is quite versatile--it can be called
    on vectors or even on strings directly. It would also work on initializer lists,
    on instances of `std::list`, `std::array`, `std::set`, and so on!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`matches`帮助函数非常灵活--它可以直接在向量或字符串上调用。它还可以在初始化列表、`std::list`、`std::array`、`std::set`等实例上工作！
- en: Check if multiple insertions into a set are successful
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查多次插入集合是否成功
- en: 'Let''s write a helper that inserts an arbitrary number of variadic parameters
    into an `std::set` and returns if all the insertions are *successful*:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个帮助函数，将任意数量的可变参数插入到`std::set`中，并返回所有插入是否*成功*：
- en: '[PRE51]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'So, how does this work? The `insert` function of `std::set` has the following
    signature:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这是如何工作的呢？`std::set`的`insert`函数具有以下签名：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The documentation says that when we try to insert an item, the `insert` function
    will return an `iterator` and a `bool` variable in a pair. The `bool` value is
    `true` if the insertion is successful. If it is successful, the iterator points
    to the *new element* in the set. Otherwise, the iterator points to the *existing*
    item, which would *collide* with the item to be inserted.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 文档表示，当我们尝试插入一个项目时，`insert`函数将返回一个对中的`iterator`和`bool`变量。如果插入成功，`bool`值为`true`。如果成功，迭代器指向集合中的*新元素*。否则，迭代器指向*现有*项目，它将与要插入的项目*冲突*。
- en: Our helper function accesses the `.second` field after insertion, which is just
    the `bool` variable that reflects success or fail. If all the insertions lead
    to `true` in all the return pairs, then all the insertions were successful. The
    fold expression combines all the insertion results with the `&&` operator and
    returns the result.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的帮助函数在插入后访问`.second`字段，这只是反映成功或失败的`bool`变量。如果所有插入在所有返回对中都导致`true`，那么所有插入都成功了。折叠表达式使用`&&`运算符将所有插入结果组合在一起并返回结果。
- en: 'We can use it like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用它：
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Note that if we try to insert, for example, three elements, but the second
    element can already not be inserted, the `&& ...` fold will short-circuit and
    stop inserting all the other elements:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们尝试插入三个元素，但第二个元素已经无法插入，`&& ...`折叠将会短路并停止插入所有其他元素：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Check if all the parameters are within a certain range
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查所有参数是否在某个范围内
- en: 'If we can check if *one* variable is within some specific range, we can also
    do the same thing with *multiple* variables using fold expressions:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以检查*一个*变量是否在某个特定范围内，我们也可以使用折叠表达式来对*多个*变量执行相同的操作。
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The expression, `(min <= ts && ts <= max)`, does tell for every value of the
    parameter pack if it is between `min` and `max` (*including* `min` and `max`).
    We choose the `&&` operator to reduce all the Boolean results to a single one,
    which is only `true` if all the individual results are `true`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`(min <= ts && ts <= max)`确实告诉了参数包的每个值是否在`min`和`max`之间（*包括*`min`和`max`）。我们选择`&&`运算符将所有布尔结果减少为单个结果，只有当所有个别结果都为`true`时才为`true`。
- en: 'This is how it looks in action:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的实际效果：
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Interestingly, this function is very versatile because the only requirement
    it imposes on the types we use is that they are *comparable* with the `<=` operator.
    And this requirement is also fulfilled by `std::string`, for example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这个函数非常灵活，因为它对我们使用的类型的唯一要求是它们可以使用`<=`运算符进行比较。例如，`std::string`也满足这个要求：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Pushing multiple items into a vector
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多个项目推入向量
- en: 'It''s also possible to write a helper that does not reduce any results but
    processes multiple actions of the same kind. Like inserting items into an `std::vector`,
    which does not return any results (`std::vector::insert()` signalizes error by
    throwing exceptions):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以编写一个不减少任何结果但处理相同类型的多个操作的帮助函数。比如将项目插入到`std::vector`中，它不返回任何结果（`std::vector::insert()`通过抛出异常来表示错误）：
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that we use the comma (`,`) operator in order to expand the parameter pack
    into individual `vec.push_back(...)` calls without folding the actual result.
    This function also works nicely with an *empty* parameter pack because the comma
    operator has an implicit identity element, `void()`, which translates to *do nothing*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用逗号（`,`）运算符来将参数包展开为单独的`vec.push_back(...)`调用，而不是折叠实际结果。这个函数也很好地处理了*空*参数包，因为逗号运算符具有隐式的单位元素`void()`，它转换为*什么也不做*。
