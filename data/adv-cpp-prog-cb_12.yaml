- en: A Closer Look at Type Deduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仔细观察类型推断
- en: In this chapter, you will learn all of the ins and outs of type deduction in
    C++, including some of the new additions in C++17\. This chapter is important
    as it will teach you all of the ways in which the compiler will attempt to deduce
    type information automatically for you. Without a firm understanding of how type
    deduction works in C++, it is possible to create code that doesn't work as expected,
    especially when using `auto` and template programming. The knowledge gained from
    this chapter will provide you with the skills to properly leverage type deduction
    in your own applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习C++中类型推断的所有细节，包括C++17中的一些新添加。本章非常重要，因为它将教会您编译器将如何尝试自动推断类型信息。如果不了解C++中类型推断的工作原理，可能会创建出现预期之外的代码，特别是在使用`auto`和模板编程时。从本章中获得的知识将为您提供在自己的应用程序中正确利用类型推断的技能。
- en: 'The recipes in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例如下：
- en: Using auto and type deduction
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用auto和类型推断
- en: Learning how `decltype` type deduction rules work
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习`decltype`类型推断规则的工作方式
- en: Working with template function type deduction
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板函数类型推断
- en: Leveraging template class type deduction in C++17
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++17中利用模板类类型推断
- en: Working with user-defined type deduction in C++17
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++17中使用用户定义的类型推断
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Before running these examples, you must install the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中的示例，您必须具有对运行Ubuntu 18.04的计算机的管理访问权限，并具有功能正常的互联网连接。在运行这些示例之前，您必须安装以下内容：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此软件安装在Ubuntu 18.04以外的任何操作系统上，则需要GCC 7.4或更高版本和CMake 3.6或更高版本。
- en: Code files for this chapter can be found at [https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter12](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter12).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter12](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter12)找到。
- en: Using auto and type deduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用auto和类型推断
- en: In this recipe, we will learn how the compiler handles the `auto` keyword, specifically
    for type deduction. This recipe is important because how `auto` is handled is
    not intuitive, and without a clear understanding of how `auto` works, your code
    will likely contain bugs and performance issues. The topics included in this recipe
    have a general description of `auto`, type deduction, forwarding (or universal)
    references, l-values, and r-values.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习编译器如何处理`auto`关键字，特别是类型推断。本示例很重要，因为`auto`的处理方式并不直观，如果不清楚`auto`的工作原理，您的代码可能会包含错误和性能问题。本示例中包括`auto`的一般描述、类型推断、转发（或通用）引用、l值和r值。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例中的示例所需的适当工具。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to try the recipe:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤尝试本示例：
- en: 'From a new Terminal, run the following command to download the source code:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile the source code, run the following:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译源代码后，可以通过运行以下命令执行本示例中的每个示例：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用及其与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `auto` keyword is a feature added to C++11 called a **placeholder type specifier**.
    In other words, the `auto` keyword is used to tell the compiler a variable's type
    will be deduced from its initializer. Unlike other languages that use placeholder
    types, the `auto` keyword must still adhere to the strict type system of C++,
    meaning `auto` should not be confused with `std::any`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`关键字是C++11中添加的一个特性，称为**占位类型说明符**。换句话说，`auto`关键字用于告诉编译器变量的类型将从其初始化程序中推断出来。与其他使用占位类型的语言不同，`auto`关键字仍然必须遵守C++的严格类型系统，这意味着`auto`不应与`std::any`混淆。'
- en: 'For example, the following is possible with `std::any`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用`std::any`可以实现以下功能：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following is not allowed with `auto`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不允许使用`auto`的情况：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the first example, we define `std::any`, which stores an integer. We then
    replace the integer inside `std::any` with a C-style string. With respect to `auto`,
    this is not possible as, once the compiler deduces the variable's type at initialization,
    the type cannot change (no different than any other variable in C++).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们定义了`std::any`，它存储一个整数。然后，我们用C风格的字符串替换`std::any`中的整数。就`auto`而言，这是不可能的，因为一旦编译器在初始化时推断出变量的类型，类型就不能改变（与C++中的任何其他变量一样）。
- en: 'Let''s look at a simple example of how to initialize a variable using `auto`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用`auto`初始化变量的简单示例：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running this example results in the following output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例将产生以下输出：
- en: '![](img/2a971f5a-11f4-4d46-a47e-a62cfab04dbe.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a971f5a-11f4-4d46-a47e-a62cfab04dbe.png)'
- en: As shown in the preceding code, we create four variables using `auto`, initialize
    them, and then use a function called `show_type()` to return the output of the
    variable's type.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们使用`auto`创建了四个变量，对它们进行初始化，然后使用一个名为`show_type()`的函数返回变量类型的输出。
- en: For more information about how the `show_type()` function works, please see
    the code that comes with this chapter (the details of this function will make
    more sense after you finish reading this entire chapter).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`show_type()`函数的更多信息，请参阅本章附带的代码（在阅读完整个章节后，这个函数的细节会更容易理解）。
- en: The first variable in our example, `i1`, is deduced as an integer. This is because
    numeric types in C++ are always deduced as an integer, which we see with the `c`
    and `r` variables in our example as well. The reason is the compiler is allowed
    to increase the size of any variable during compilation, meaning, when the compiler
    sees `c + 42`, the first thing it does is store the value of `c` in a temporary
    integer before completing the addition.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中的第一个变量`i1`被推断为整数。这是因为C++中的数值类型总是被推断为整数，我们在示例中的`c`和`r`变量中也看到了这一点。原因是编译器允许在编译期间增加任何变量的大小，这意味着当编译器看到`c
    + 42`时，它首先将`c`的值存储在一个临时整数中，然后完成加法。
- en: The second variable, `i2`, in our example is also deduced as an integer as the
    `{}` notation is another form of initialization for any type in C++, with some
    additional rules. Specifically, `i3` and `i4` are deduced as `std::initializer_list`
    of integers since the last two use the `= {}` notation, which is defined by the
    C++ specification to always deduce to `std::initializer_list` in C++17\. It should
    be noted that this assumes the compiler adheres to the specification, which is
    not always the case in this specific example, which is why critical system specifications
    such as AUTOSAR do not allow this type of initialization.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，第二个变量`i2`也被推断为整数，因为`{}`符号是C++中任何类型的另一种初始化形式，具有一些额外的规则。具体来说，`i3`和`i4`被推断为整数的`std::initializer_list`，因为最后两个使用了`=
    {}`符号，根据C++17的规定，它们总是被推断为`std::initializer_list`。值得注意的是，这假设编译器遵守规范，在这个特定的例子中并不总是如此，这就是为什么像AUTOSAR这样的关键系统规范不允许这种类型的初始化。
- en: 'The `auto` keyword can also be combined with CV qualifiers (that is, `const`/`volatile`)
    as well. Check out this example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`关键字也可以与CV限定符（即`const`/`volatile`）结合使用。看看这个例子：'
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding examples results in the following output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子产生了以下输出：
- en: '![](img/a4a02c94-dc87-4f79-b3bf-e2e8118cf556.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4a02c94-dc87-4f79-b3bf-e2e8118cf556.png)'
- en: As shown in the preceding screenshot, each variable is decorated with the proper
    CV qualifiers as defined.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，每个变量都带有适当的CV限定符。
- en: 'Up until now, in each example, we could have simply replaced the use of `auto`
    with `int` and nothing would have changed, which begs the question, why use `auto`
    in the first place? There are a couple of reasons why:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在每个示例中，我们可以简单地用`int`替换`auto`，什么都不会改变，这就引出了一个问题，为什么要首先使用`auto`？有几个原因：
- en: 'Using something other than `auto` means your code is likely specifying a variable''s
    type twice. For example, `int *ptr = new int;` states that the `ptr` variable is
    an integer twice: once in the variables declaration, and a second time in the
    variable''s initialization.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用除`auto`之外的东西意味着你的代码很可能会两次指定变量的类型。例如，`int *ptr = new int;`表示`ptr`变量是整数两次：一次在变量声明中，一次在变量的初始化中。
- en: Some types in C++ are really long (for example, iterators), and the use of `auto`
    can greatly simplify the verbosity of your code, for example, `auto i = v.begin()`.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++中的一些类型非常长（例如迭代器），使用`auto`可以极大地简化代码的冗长，例如`auto i = v.begin()`。
- en: When writing template code, `auto` is required to properly handle reference
    types such as forwarding references.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写模板代码时，`auto`需要正确处理引用类型，比如转发引用。
- en: 'Working with references is where the use of `auto` gets confusing, and where
    most people make mistakes. To better explain, let''s look at the following example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 处理引用是使用`auto`变得混乱的地方，也是大多数人犯错误的地方。为了更好地解释，让我们看看以下例子：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This results in the following output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下输出：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As shown in the preceding example, we create an integer, `i`, and set it to
    `42`. We then create two more integers: one is a copy of `i`, while the second
    is a reference to `i`. As shown in the output, we get the expected types, `int`
    and `int&`. Using the `auto` keyword, we could expect that if we said something
    like `auto a = i2`, we would get an `int&` type as `i2` is a reference to an integer,
    and since `auto` deduced its type based on how it is initialized, we should get `int&`.
    The problem is, we do not. Instead, we get `int`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们创建了一个整数`i`，并将其设置为`42`。然后我们创建了另外两个整数：一个是`i`的副本，另一个是对`i`的引用。如输出所示，我们得到了预期的类型，`int`和`int&`。使用`auto`关键字，我们可以期望，如果我们说类似`auto
    a = i2`，我们会得到`int&`类型，因为`i2`是对整数的引用，而且由于`auto`根据初始化方式推断其类型，我们应该得到`int&`。问题是，我们没有。相反，我们得到了`int`。
- en: 'The reason for this is that `auto` gets its type based on how it is initialized
    without including the reference type. In other words, the use of `auto` in the
    example is only picking up on the `i2` type, without paying attention to whether
    or not `i2` is an integer or a reference to an integer. To force `auto` to be
    a reference to an integer, we must use the following syntax:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`auto`的类型是根据它的初始化方式确定的，而不包括引用类型。换句话说，示例中对`auto`的使用只是捕捉了`i2`的类型，而没有注意`i2`是整数还是整数的引用。要强制`auto`成为整数的引用，我们必须使用以下语法：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This results in the following output:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下输出：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This output is as expected. The same rules apply to r-value references, but
    become even more complicated. For example, consider this code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出是预期的。相同的规则也适用于右值引用，但会变得更加复杂。例如，考虑以下代码：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This results in the following output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下输出：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This output is again as expected. Based on what we have already learned, we
    would expect that the following would be required to get an r-value reference:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出再次符合预期。根据我们已经学到的知识，我们期望以下内容需要才能获得r值引用：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The problem is that this results in the following output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这导致了以下输出：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As shown in the preceding example, we did not get an r-value reference as expected.
    Anything labeled `auto &&` in C++ is considered a forwarding reference (this is
    also known as a universal reference, a term coined by Scott Meyers). The universal
    reference will deduce to either an l-value or r-value reference, depending on
    what the universal reference is initialized with.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，我们没有得到预期的r值引用。在C++中，任何标记为`auto &&`的东西都被认为是一个转发引用（这也被称为通用引用，这是Scott
    Meyers创造的术语）。通用引用将根据初始化的内容推导为l值或r值引用。
- en: 'So, for example, consider the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，考虑以下代码：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code results in the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码导致了以下结果：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is because `i1` was defined earlier as an integer, and so `a6` becomes
    an l-value reference to `i1`. The following is also true:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`i1`之前被定义为整数，所以`a6`变成了`i1`的l值引用。以下也是真的：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code results in the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码导致了以下结果：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is because `i2` was defined earlier as an l-value reference to an integer,
    which means that the universal reference becomes an l-value reference to an integer
    as well.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`i2`之前被定义为整数的l值引用，这意味着通用引用也变成了整数的l值引用。
- en: 'The confusing result is the following, as already shown in the preceding code
    snippet:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 混乱的结果如下，如前面的代码片段中已经显示的那样：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This again results in the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次导致了以下结果：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `i3` was defined earlier as an r-value reference to an integer (proven
    by the resulting output), but the universal reference did not forward the r-valueness
    from `i3`. This is because, although `i3` was defined as an r-value reference,
    once it is used, it becomes an l-value reference. As Scott Meyer has stated in
    the past, if a variable has a name (in our case, `i3`), it is an l-value, even
    if it starts off as an r-value. Another way to look at this is once a variable
    is used (as in accessed in any way), the variable is an l-value. So, the preceding
    code actually works as it should. `i3`, although defined as an r-value, is an
    l-value, and so the universal reference becomes an l-value reference to an integer,
    just the same as `i1` and `i2`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`i3`之前被定义为整数的r值引用（根据结果输出），但通用引用没有从`i3`中转发r值。这是因为，尽管`i3`被定义为r值引用，一旦被使用，它就变成了l值引用。正如Scott
    Meyer过去所说的，如果一个变量有一个名字（在我们的例子中是`i3`），它就是一个l值，即使它起初是一个r值。另一种看待这个问题的方式是，一旦一个变量被使用（即以任何方式被访问），这个变量就是一个l值。因此，前面的代码实际上是按照预期工作的。`i3`，尽管被定义为r值，是一个l值，因此通用引用变成了整数的l值引用，就像`i1`和`i2`一样。
- en: 'To get an r-value reference using `auto`, you must do the same thing as you
    would without the use of `auto`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`auto`获得r值引用，你必须像不使用`auto`一样做相同的事情：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This results in the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下结果：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As shown in the preceding code snippet, the best way to think about `auto` is
    to simply replace the word `auto` with the actual type (in this case, `int`),
    and whatever rules apply to the actual type also apply to `auto`. The difference
    is that if you attempted to write `int &&blah = i`, you would get an error as
    the compiler would recognize that you are attempting to create an r-value reference
    from an l-value reference, which is not possible (as you can only create an r-value
    reference from another r-value reference).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，思考`auto`的最佳方式就是简单地用实际类型（在本例中为`int`）替换`auto`，并且实际类型适用的规则也适用于`auto`。不同之处在于，如果你尝试写`int
    &&blah = i`，你会得到一个错误，因为编译器会认识到你试图从一个l值引用创建一个r值引用，这是不可能的（因为你只能从另一个r值引用创建一个r值引用）。
- en: The reason the preceding examples are so important is that `auto` will not generate
    a complaint from the compiler. Instead, it will produce an l-value when you meant
    to create an r-value, which could result in inefficiencies or bugs. The most important
    thing to learn about the use of `auto` is that if it has a name, it is an l-value;
    otherwise, it is an r-value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子之所以如此重要，是因为`auto`不会引起编译器的投诉。相反，它会在你想要创建r值时产生一个l值，这可能导致效率低下或错误。关于使用`auto`最重要的一点是，如果它有一个名字，它就是一个l值；否则，它就是一个r值。
- en: 'For example, consider the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This code results in the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码导致了以下结果：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As the numeric value `42` does not have a variable name, it is a constant, and
    hence, the universal reference becomes an r-value reference to an integer.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数值`42`没有变量名，它是一个常数，因此通用引用变成了整数的r值引用。
- en: 'It should also be noted that the use of `auto` confusingly does inherit CV
    qualifiers when dealing with references. Check out this example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该注意，使用`auto`在处理引用时会继承CV限定符，这可能会让人感到困惑。看看这个例子：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This results in the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下结果：
- en: '![](img/638a9ffc-4c76-48bd-9656-a209fb3c43b6.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/638a9ffc-4c76-48bd-9656-a209fb3c43b6.png)'
- en: As shown in the preceding screenshot, the first integer remains an `int` type
    because a copy of `const int` is an `int`. Both `i2` and `i3`, however, become
    references to `const int`. If we were to replace `auto` with `int`, we would get
    a compiler error as you cannot create a non-`const` reference to `const int`,
    yet the use of `auto` will gladly convert your non-`const` variable into a `const`
    variable for you. The problem with this is that you will end up with odd error
    messages when you attempt to modify your variable, complaining that the variable
    is read-only when, in fact, you have not explicitly defined the variable as `const`.
    In general, it is good practice to always mark a variable defined with `auto`
    as `const` if you expect `const`, or non-`const` if you do not, preventing these
    sometimes hard-to-identify bugs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，第一个整数仍然是`int`类型，因为`const int`的副本是`int`。然而，`i2`和`i3`都变成了对`const int`的引用。如果我们用`auto`替换`int`，我们将得到一个编译器错误，因为您不能创建对`const
    int`的非`const`引用，但是使用`auto`将乐意将您的非`const`变量转换为`const`变量。这样做的问题是，当您尝试修改变量时，您将得到奇怪的错误消息，抱怨变量是只读的，而实际上，您并没有明确地将变量定义为`const`。一般来说，如果您期望`const`，则将使用`auto`定义的变量标记为`const`，如果您不期望`const`，则将其标记为非`const`，以防止这些有时难以识别的错误。
- en: Learning how decltype type deduction rules work
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习decltype类型推断规则的工作方式
- en: In this recipe, we will learn about how type deduction works with `decltype()`
    and `decltype(auto)`, and how to avoid the issues of referenceness with `auto`
    using `decltype(auto)` instead.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习`decltype()`和`decltype(auto)`的类型推断工作原理，以及如何使用`decltype(auto)`来避免`auto`处理引用的问题。
- en: This recipe is important as `auto` has some strange behavior in how it handles
    references that `decltype()` addresses, providing C++ with a means to handle type
    deduction more predictably, especially when working with C++ templates.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程很重要，因为`auto`在处理引用时有一些奇怪的行为，而`decltype()`则提供了一种更可预测地处理类型推断的方式，特别是在使用C++模板时。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有适当的工具来编译和执行本教程中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to try this recipe:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来尝试这个教程：
- en: 'From a new Terminal, run the following command to download the source code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中，运行以下命令来下载源代码：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To compile the source code, run the following command:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译源代码，请运行以下命令：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Neither `auto` nor `typename` in C++ provides the ability to get a variable''s
    type and create new types using that information. To better explain why you might
    want to do this, let''s look at the following example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，`auto`和`typename`都不能提供获取变量类型并使用该信息创建新类型的能力。为了更好地解释为什么您可能想要这样做，让我们看下面的例子：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We start our example with a function that takes any function as an input and
    returns the result of this function plus `10`. We can then execute this function
    as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个接受任何函数作为输入并返回此函数的结果加上`10`的函数开始。然后我们可以执行此函数如下：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As shown in the preceding example, we pass the `question()` function a pointer
    to another function that returns `short`. On executing this function, we store
    the results and then we use a function called `show_type()`, which is designed
    to output what type the provided type is. This results in the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们将`question()`函数传递给另一个返回`short`的函数的指针。在执行此函数时，我们存储结果，然后使用一个名为`show_type()`的函数，该函数旨在输出所提供类型的类型。结果如下：
- en: '![](img/e8f08892-9ea4-4d72-9d86-197819b5e39f.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8f08892-9ea4-4d72-9d86-197819b5e39f.png)'
- en: The problem with this example is the fact that the type that is returned is
    not the same type that we were given. C++ is allowed to increase the size of any
    variable as needed, and often does with shorts, especially when you attempt to
    perform arithmetic on a short with numeric values as numeric values are represented
    as integers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的问题在于返回的类型与我们给定的类型不同。C++允许根据需要增加任何变量的大小，并且通常会对short进行增加，特别是当您尝试对具有数值值的short执行算术运算时，因为数值值被表示为整数。
- en: 'Since we do not know what the return type of the provided function will be
    in the `question()` function, there is no way to fix this issue. Enter `decltype()`.
    To explain, let''s update our example to address the preceding problem:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不知道`question()`函数中提供的函数的返回类型，因此无法解决此问题。输入`decltype()`。为了解释清楚，让我们更新我们的示例来解决前面的问题：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As shown in the preceding example, we replaced `auto` with `decltype(func())`.
    This tells the compiler to get the return type of `func()` and use that type to
    define `x`. As a result, the compiler converts this template into the following
    function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们用`decltype(func())`替换了`auto`。这告诉编译器获取`func()`的返回类型，并使用该类型来定义`x`。结果，编译器将此模板转换为以下函数：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This happens instead of the following, which was expected initially:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这发生在最初预期的以下情况：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This then results in the following output when executed:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在执行时会得到以下输出：
- en: '![](img/74f2a492-4468-4399-82cf-1bcb78645046.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74f2a492-4468-4399-82cf-1bcb78645046.png)'
- en: 'As shown in the preceding screenshot, we are now getting the proper type returned
    from our `question()` function. With C++14, we can take this example a bit further
    and write it this way:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，我们现在从我们的`question()`函数中得到了正确的类型返回。使用C++14，我们可以进一步将此示例编写为：
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the example in the preceding code snippet, we converted the `question()`
    function into `constexpr`, which allows the compiler to optimize out the function
    call, replacing a call to `question()` with the `func() + 10` statement. We also
    remove the need for a stack-based variable by explicitly telling the compiler
    what type we wish the function to return using the `-> decltype()` function return
    syntax. It should be noted that this syntax is needed as the following would not
    compile:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码片段的示例中，我们将`question()`函数转换为`constexpr`，这允许编译器优化掉函数调用，用`func() + 10`语句替换对`question()`的调用。我们还通过显式告诉编译器我们希望函数返回的类型来消除了对基于堆栈的变量的需求，使用`->
    decltype()`函数返回语法。需要注意的是，由于以下内容不会编译，因此需要此语法：
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code will not compile because the compiler does not have the definition
    of `func()` yet, and hence it doesn't know what its type is. The `->` syntax addresses
    this by placing the return type at the end of the function definition instead
    of at the front.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将无法编译，因为编译器还没有`func()`的定义，因此不知道它的类型。`->`语法通过将返回类型放在函数定义的末尾而不是开头来解决了这个问题。
- en: 'The `decltype()` specifier can also be used in place of `auto` as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`decltype()`说明符也可以用于替代`auto`，如下所示：'
- en: '[PRE39]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This results in the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下输出：
- en: '![](img/fb6593f6-0f30-46a3-9beb-ca5ecc548089.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb6593f6-0f30-46a3-9beb-ca5ecc548089.png)'
- en: In this example, we create two integers using `decltype(auto)` and initialize
    them to `42`. In this specific case, `decltype(auto)` and `auto` operate exactly
    the same. Both define the placeholder type as an integer as both are initialized
    using a numeric value, which, by default, is `int`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，我们使用`decltype(auto)`创建了两个整数，并将它们初始化为`42`。在这种特定情况下，`decltype(auto)`和`auto`的操作完全相同。两者都将占位符类型定义为整数，因为两者都使用了默认的`int`初始化为数值，这是默认的。 '
- en: 'Like `auto`, you can decorate `decltype(auto)` with CV qualifiers (that is,
    `const`/`volatile`) as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与`auto`一样，您可以使用CV限定符（即`const`/`volatile`）装饰`decltype(auto)`，如下所示：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This results in the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下输出：
- en: '![](img/ded88455-57d8-42c0-bf42-bf31d47ed56a.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ded88455-57d8-42c0-bf42-bf31d47ed56a.png)'
- en: 'The real magic of `decltype(auto)` is how it handles references. To demonstrate
    this, let''s start with the following example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`decltype(auto)`的真正魔力在于它如何处理引用。为了证明这一点，让我们从以下示例开始：'
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When executed, we see the following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们看到以下输出：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As shown in the preceding example, we have created an integer, an l-value reference
    to an integer, and an r-value reference to an integer. Let''s see what happens
    if we attempt to use `auto` instead of `int` as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们创建了一个整数，一个整数的左值引用和一个整数的右值引用。让我们看看如果尝试使用`auto`而不是`int`会发生什么：
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We then see the following output:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们看到以下输出：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As shown in the preceding example, we are only given integers. All of the references
    were removed. The only way to get references with `auto` is if we explicitly define
    them as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，我们只得到了整数。所有引用都被移除了。使用`auto`获取引用的唯一方法是如果我们明确定义它们，如下所示：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This results in the following, expected, output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下预期的输出：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The problem with having to add the extra `&` operators to explicitly define
    the reference type is that this assumes that, in our template code, we actually
    know what the references should be. If this information is not available, we would
    have no way of writing a template function and know whether we could create an
    l-value or r-value reference, likely resulting in a copy.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 必须添加额外的`&`运算符来显式定义引用类型的问题在于，这假设在我们的模板代码中，我们实际上知道引用应该是什么。如果没有这些信息，我们将无法编写模板函数，并且不知道是否可以创建左值引用或右值引用，很可能会导致复制。
- en: 'To overcome this, `decltype(auto)` not only inherits the type and CV qualifiers
    during initialization, it also inherits the references as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这一点，`decltype(auto)`不仅在初始化期间继承类型和CV限定符，还继承引用关系，如下所示：
- en: '[PRE47]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The preceding code, when executed, results in the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码会导致以下结果：
- en: '[PRE48]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As shown in the preceding example, `decltype(auto)` can be used to inherit all
    of the type information of the value it is being initialized to, including referenceness.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，`decltype(auto)`可以用于继承被初始化的值的所有类型信息，包括引用关系。
- en: Working with template function type deduction
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板函数类型推断
- en: In this recipe, we will learn how template function type deduction works. Specifically,
    this recipe will teach you how template function type deduction works the same
    as `auto` type deduction, as well as how function type deduction can be used with
    some odd types (for example, C-style arrays).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将学习模板函数类型推断的工作原理。具体来说，本示例将教你模板函数类型推断与`auto`类型推断相同的工作方式，以及如何将函数类型推断与一些奇怪的类型（例如C风格数组）一起使用。
- en: This recipe is important as it will teach you how to write function templates
    properly, eliminating the need to explicitly define type information when invoking
    a function template.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例很重要，因为它将教会你如何正确地编写函数模板，消除在调用函数模板时显式定义类型信息的需要。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE49]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有正确的工具来编译和执行本示例中的示例。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to try this recipe:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤尝试这个配方：
- en: 'From a new Terminal, run the following command to download the source code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令以下载源代码：
- en: '[PRE50]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To compile the source code, run the following command:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE51]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译后，可以通过运行以下命令执行本文中的每个示例：
- en: '[PRE52]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to lessons being taught in this
    recipe.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本文所教授的课程的关系。
- en: How it works...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In C++11, the standards committee added the ability to automatically deduce
    a template function's type information based on the arguments that were passed
    to the function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，标准委员会添加了根据传递给函数的参数自动推断模板函数类型信息的能力。
- en: 'Check out this example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个例子：
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding function creates a standard template function that executes a
    function called `show_type()` designed to output the type information that it
    is provided with.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数创建了一个标准模板函数，执行一个名为`show_type()`的函数，用于输出提供的类型信息。
- en: 'Before C++11, we would use this function as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前，我们会这样使用这个函数：
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The compiler already knows that the template should define the `T` type as
    an integer as that is what the function was provided for. C++11 removes this redundancy,
    allowing the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器已经知道模板应该将`T`类型定义为整数，因为这就是函数提供的内容。C++11去除了这种冗余，允许以下操作：
- en: '[PRE55]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This results in the following output when executed:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时会得到以下输出：
- en: '![](img/acf27d37-b223-47d6-8cca-91327b06bcef.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/acf27d37-b223-47d6-8cca-91327b06bcef.png)'
- en: 'Like `auto`, however, this type deduction gets interesting when r-value references
    are used, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与`auto`一样，当使用r值引用时，这种类型推断变得有趣，如下所示：
- en: '[PRE56]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding example defines `t` as a forwarding reference (also known as
    a universal reference). The universal reference takes on whatever reference type
    it is passed. For example, we call this function as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例将`t`定义为转发引用（也称为通用引用）。通用引用接受传递给它的任何引用类型。例如，我们可以这样调用这个函数：
- en: '[PRE57]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We get the following output:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '![](img/55fe5e8f-d61e-4087-9c56-e55f50384a8a.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55fe5e8f-d61e-4087-9c56-e55f50384a8a.png)'
- en: 'The preceding output shows that the template function was given an l-value
    reference to an integer. This is because `i`, in our main function, is an l-value,
    even though the function appears to be requesting an r-value reference. To get
    an r-value reference, we must provide an r-value, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示，模板函数得到了一个整数的l值引用。这是因为在我们的主函数中，`i`是一个l值，即使函数似乎要求一个r值引用。要获得一个r值引用，我们必须提供一个r值，如下所示：
- en: '[PRE58]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This results in the following output when executed:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时会得到以下输出：
- en: '![](img/04ac53de-9f09-4000-afe6-8a9a9d78835b.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04ac53de-9f09-4000-afe6-8a9a9d78835b.png)'
- en: 'As shown in the preceding screenshot, now that we have given the universal
    reference an r-value, we get an r-value. It should be noted that a universal reference
    only has the following signature:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，现在我们已经给了通用引用一个r值，我们得到了一个r值。应该注意的是，通用引用只有以下签名：
- en: '[PRE59]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For example, the following is not a universal reference:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下不是通用引用：
- en: '[PRE60]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Neither is the following a universal reference:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下也不是通用引用：
- en: '[PRE61]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Both of the preceding examples are r-value references, and hence require that
    an r-value be provided (in other words, both of these functions define move operations).
    A universal reference will accept both an l-value and an r-value reference. Although
    this seems like an advantage, it has the downside that it is sometimes difficult
    to know whether your template function has received an l-value or an r-value.
    Currently, the best way to ensure your template function acts like an r-value
    reference and not a universal reference is to use SFINAE:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个例子都是r值引用，因此需要提供一个r值（换句话说，这两个函数都定义了移动操作）。通用引用将接受l值和r值引用。尽管这似乎是一个优势，但它的缺点是有时很难知道你的模板函数接收了一个l值还是一个r值。目前，确保你的模板函数像一个r值引用而不是一个通用引用的最佳方法是使用SFINAE：
- en: '[PRE62]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, it is also possible to perform type deduction on less common types
    such as C-style arrays, as in this example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还可以对不常见的类型进行类型推断，比如C风格数组，就像这个例子中所示：
- en: '[PRE63]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The preceding function states that we wish to have a C-style array of type
    `T` and size `N` passed to the function and then outputs its type when executed.
    We can use this function as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数说明我们希望将类型为`T`且大小为`N`的C风格数组传递给函数，然后在执行时输出其类型。我们可以这样使用这个函数：
- en: '[PRE64]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This automatically deduces to an r-value reference of a C-style array of type
    `int` and size `6`. As shown in this recipe, C++ provides several mechanisms for
    allowing the compiler to determine what types are leveraged in template functions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这自动推断为一个类型为`int`且大小为`6`的C风格数组的r值引用。正如本文所示，C++提供了几种机制，允许编译器确定在模板函数中使用了哪些类型。
- en: Leveraging template class type deduction in C++17
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++17中利用模板类类型推断
- en: In this recipe, we will learn how class type deduction works with class templates
    in C++17\. This recipe is important as C++17 added the ability to deduce the type
    of a template class from its constructor, which reduces both the verbosity and
    redundancy of your code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将学习C++17中类模板的类类型推断是如何工作的。这个配方很重要，因为C++17增加了从构造函数中推断模板类类型的能力，从而减少了代码的冗长和冗余。
- en: The knowledge gained from this recipe will provide you with the ability to write
    C++ classes that properly deduce their types from the class constructor without
    the need for explicit type declarations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个配方中获得的知识将使您能够编写C++类，这些类可以从类构造函数中正确推断其类型，而无需显式类型声明。
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE65]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有正确的工具来编译和执行本教程中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to try this recipe:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤尝试这个教程：
- en: 'From a new Terminal, run the following command to download the source code:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中，运行以下命令下载源代码：
- en: '[PRE66]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To compile the source code, run the following command:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE67]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译后，您可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE68]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用，以及它们与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Class template type deduction is a new feature added in C++17 that provides
    the ability to deduce the type of a template class from its constructor. Suppose
    we have the following class template:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板类型推断是C++17中新增的一个功能，它提供了从构造函数中推断模板类的类型的能力。假设我们有以下类模板：
- en: '[PRE69]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As shown in the preceding code snippet, we have a simple class template that
    takes a type `T` during construction and uses a `show_type()` function to output
    whatever type it is given. Before C++17, this class would have been instantiated
    using the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的代码片段所示，我们有一个简单的类模板，在构造时接受一个类型`T`，并使用`show_type()`函数输出它所给定的任何类型。在C++17之前，这个类将使用以下方式实例化：
- en: '[PRE70]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'With C++17, we can now instantiate this class as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++17，我们现在可以实例化这个类如下：
- en: '[PRE71]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The reason this works is that the constructor of the class takes a type `T`
    as an argument. Since we provided a numeric integer as the parameter, type `T` of
    the class is deduced as an integer. This type deduction includes support for references
    as well. Check out this example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因是类的构造函数接受一个类型`T`作为参数。由于我们提供了一个数字整数作为参数，类的类型`T`被推断为整数。这种类型推断也包括对引用的支持。查看以下示例：
- en: '[PRE72]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In the preceding example, our class takes `T&` as a parameter in the constructor of
    the class, which allows us to instantiate the class as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们的类在构造函数中以`T&`作为参数，这使我们可以实例化类如下：
- en: '[PRE73]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This results in the following when executed:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时会产生以下结果：
- en: '![](img/b10d531e-b7d8-49ce-b509-30aa6f695860.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b10d531e-b7d8-49ce-b509-30aa6f695860.png)'
- en: 'As shown in the preceding example, type `T` of the class was deduced as an
    l-value reference to an integer. Most of the type deduction rules that apply to
    function templates also apply to class templates, but there are some exceptions.
    For example, class template constructors do not support forwarding references
    (universal references). Consider the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的示例所示，类的类型`T`被推断为整数的左值引用。大多数适用于函数模板的类型推断规则也适用于类模板，但也有一些例外。例如，类模板的构造函数不支持转发引用（通用引用）。考虑以下代码：
- en: '[PRE74]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The preceding constructor is not a universal reference; it is an r-value reference,
    meaning we cannot do the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的构造函数不是一个通用引用；它是一个r值引用，这意味着我们不能做以下操作：
- en: '[PRE75]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This is not possible as it would be attempting to bind an l-value to an r-value,
    which is not allowed. Instead, like any other r-value reference, we must instantiate
    the class using the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不可能的，因为这将尝试将一个左值绑定到一个右值，这是不允许的。相反，像任何其他r值引用一样，我们必须使用以下方式实例化类：
- en: '[PRE76]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Or we can bind it with the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以使用以下方式绑定它：
- en: '[PRE77]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The reason universal references are not supported for class template type deduction
    is the fact that class template type deduction uses the constructor to deduce
    the type and then fills in the type for the rest of the class based on whatever
    type was deduced, meaning by the time the constructor is compiled, it looks like
    this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通用引用不支持类模板类型推断的原因是，类模板类型推断使用构造函数来推断类型，然后根据推断出的类型填充类的其余部分的类型，这意味着在构造函数编译时，它看起来像这样：
- en: '[PRE78]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This defines an r-value reference.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个r值引用。
- en: 'To get a universal reference in the constructor, or any other function, you
    must use a member function template, which itself can still support type deduction
    but is not used to deduce any of the class''s types. Check out this example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要在构造函数或任何其他函数中获得一个通用引用，您必须使用一个成员函数模板，它本身仍然可以支持类型推断，但不用于推断类的任何类型。查看以下示例：
- en: '[PRE79]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In the preceding example, we create a class template with type `T`, and we
    define the constructor as a member function template. The constructor itself takes `T
    &&t` and `U &&u`. In this case, however, `t` is an r-value reference and `u` is
    a universal reference, even though they look identical. Both can be deduced by
    the compiler with C++17 as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们创建了一个带有类型`T`的类模板，并将构造函数定义为成员函数模板。构造函数本身接受`T &&t`和`U &&u`。然而，在这种情况下，`t`是一个r值引用，`u`是一个通用引用，尽管它们看起来相同。在C++17中，编译器可以推断两者如下：
- en: '[PRE80]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'It should also be noted that the constructor does not have to have any of the
    types in any specific order for deduction to work. The only requirement is that
    all of the types are present in the constructor''s arguments. For example, consider
    the following code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该注意，构造函数不必按任何特定顺序具有所有类型才能进行推断。唯一的要求是构造函数的参数中包含所有类型。例如，考虑以下代码：
- en: '[PRE81]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The preceding example can be instantiated as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例可以实例化如下：
- en: '[PRE82]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, type deduction also supports more than one template type, as in this
    example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，类型推导还支持多个模板类型，就像这个例子中一样：
- en: '[PRE83]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The preceding example creates a class template with two generic types. The
    constructor for this class creates a `const` l-value reference to a type `T`,
    while also taking an r-value reference to a type `U`. This class can be instantiated
    as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例创建了一个具有两个通用类型的类模板。这个类的构造函数创建了对类型`T`的`const`左值引用，同时还接受了对类型`U`的右值引用。可以这样实例化这个类：
- en: '[PRE84]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This results in the following output:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/137fb1ac-46dc-4fe1-b8f4-6d95dcdbdfcf.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/137fb1ac-46dc-4fe1-b8f4-6d95dcdbdfcf.png)'
- en: As shown in the preceding example, both `T` and `U` are successfully deduced.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如上例所示，`T`和`U`都成功推导出来了。
- en: Working with user-defined type deduction in C++17
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++17中使用用户定义的类型推导
- en: In this recipe, we will learn how to help the compiler with class template type
    deduction using user-defined deduction guides. Most of the time, user-defined
    deduction guides are not needed, but in some cases, they might be to ensure the
    compiler deduces the proper types. This recipe is important because, without user-defined
    type deduction, certain types of template schemes are simply not possible, as
    will be shown.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用用户定义的推导指南来帮助编译器进行类模板类型推导。大多数情况下，不需要用户定义的推导指南，但在某些情况下，为了确保编译器推断出正确的类型，可能需要使用它们。这个示例很重要，因为如果没有用户定义的类型推导，某些类型的模板方案根本不可能，这将会被证明。
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE85]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This will ensure that your operating system has the proper tools to compile
    and execute the examples in this recipe. Once this is complete, open a new Terminal.
    We will use this Terminal to download, compile, and run our examples.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例中的示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to try this recipe:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来尝试这个示例：
- en: 'From a new Terminal, run the following command to download the source code:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端运行以下命令来下载源代码：
- en: '[PRE86]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To compile the source code, run the following command:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE87]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，可以通过运行以下命令来执行本示例中的每个示例：
- en: '[PRE88]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Class template type deduction is a much-needed feature in C++17 as it helps
    to reduce both the redundancy and verbosity of our C++. There are situations where,
    however, the compiler will deduce the wrong type—an issue that could be addressed
    if we didn''t rely on type deduction. To better understand this type of issue,
    let''s look at the following example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板类型推导是C++17中一个非常需要的特性，因为它有助于减少我们的C++中的冗余和冗长。然而，在某些情况下，编译器会推断出错误的类型，如果我们不依赖于类型推导，这个问题是可以解决的。为了更好地理解这种问题，让我们看一下下面的例子：
- en: '[PRE89]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In the preceding example, we have created a simple class template whose constructor
    takes a type `T` and uses a `show_type()` function to output whatever type it
    is given. Now suppose that we wish to use this class to instantiate a version
    that takes an unsigned integer. There are two ways to do this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们创建了一个简单的类模板，其构造函数接受类型`T`，并使用`show_type()`函数输出给定的任何类型。现在假设我们希望使用这个类来实例化一个接受无符号整数的版本。有两种方法可以做到这一点：
- en: '[PRE90]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The preceding method is the most obvious as we are explicitly telling the compiler
    what type we wish to have, while not using type deduction at all. Another method
    to get an unsigned integer would be to use the proper numeric literal syntax as
    follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法是最明显的，因为我们明确告诉编译器我们希望拥有的类型，而根本不使用类型推导。获取无符号整数的另一种方法是使用正确的数字文字语法，如下所示：
- en: '[PRE91]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: In the preceding example, we are leveraging type deduction, but we have to make
    sure we always add `U` to our integers. The advantage of this approach is that
    the code is explicit. The disadvantage to this approach is that if we forget to
    add `U` to state that we wish to have an unsigned integer, we could inadvertently
    create a class with the `int` type instead of the `unsigned` type.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们利用了类型推导，但我们必须确保始终将`U`添加到我们的整数上。这种方法的优点是代码是显式的。这种方法的缺点是，如果我们忘记添加`U`来表示我们希望有一个无符号整数，我们可能会无意中创建一个具有`int`类型而不是`unsigned`类型的类。
- en: 'To prevent this issue, we can leverage a user-defined type deduction to tell
    the compiler that if it sees an integer type, we really mean an unsigned type,
    as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这个问题，我们可以利用用户定义的类型推导来告诉编译器，如果它看到一个整数类型，我们真正想要的是一个无符号类型，如下所示：
- en: '[PRE92]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The preceding statement tells the compiler that if it sees a constructor with
    an `int` type, `int` should produce a class with the `unsigned` type.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的语句告诉编译器，如果它看到一个带有`int`类型的构造函数，`int`应该产生一个具有`unsigned`类型的类。
- en: The left-hand side takes a constructor signature, while the right-hand side
    takes a class template signature.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧采用构造函数签名，右侧采用类模板签名。
- en: 'Using this method, we can take any constructor signature that we see and convert
    it into the class template type we wish, as in this example:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以将我们看到的任何构造函数签名转换为我们希望的类模板类型，就像这个例子中一样：
- en: '[PRE93]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The user-defined type deduction guide tells the compiler that if it sees a
    C-style string, it should create `std::string` instead. We can then run our example
    with the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的类型推导指南告诉编译器，如果它看到一个C风格的字符串，应该创建`std::string`。然后我们可以通过以下方式运行我们的示例：
- en: '[PRE94]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We then get the following output:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们得到以下输出：
- en: '![](img/33a212a7-2507-4906-af8c-813b8dcb6bc0.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33a212a7-2507-4906-af8c-813b8dcb6bc0.png)'
- en: As shown in the preceding screenshot, the class was constructed with `std::string`
    (or at least GCC's internal representation of `std::string`) and not a C-style
    string.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的屏幕截图所示，该类是使用`std::string`（或至少是GCC内部表示的`std::string`）构建的，而不是C风格的字符串。
