- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Creating a CMake Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 CMake 项目
- en: By now, you should be familiar with how to use CMake and its basic concepts,
    such as the two-stage build. So far, we have only looked at how CMake is used
    with code that already exists, but the more interesting part is when it comes
    to building an application using CMake. In this chapter, you will learn how to
    build executables and libraries and how to use them together. We will have an
    in-depth look at creating different kinds of libraries and we will present some
    good practices about how to structure CMake projects. As libraries often come
    with a variety of compiler settings, we will learn how we can set them and pass
    them on to dependent libraries if necessary. Since dependencies in projects can
    get quite complicated, we will also learn how to visualize the dependencies between
    the different targets.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经熟悉了如何使用 CMake 及其基本概念，如两阶段构建。目前，我们只讨论了如何使用 CMake 与现有代码配合，但更有趣的部分是如何使用
    CMake 构建应用程序。在本章中，你将学习如何构建可执行文件和库，并学习如何将它们一起使用。我们将深入探讨创建不同类型的库，并展示一些关于如何构建 CMake
    项目的好实践。由于库通常伴随着多种编译器设置，我们将学习如何设置它们，并在必要时将这些设置传递给依赖库。由于项目中的依赖关系可能变得相当复杂，我们还将学习如何可视化不同目标之间的依赖关系。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up a project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置项目
- en: Creating a “hello world” executable
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个“hello world”可执行文件
- en: Creating a simple library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的库
- en: Bringing it together
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合它们
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with the previous chapters, all the examples have been tested with CMake
    3.21 and run on one of the following compilers:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的章节一样，所有示例都已使用 CMake 3.21 测试，并在以下编译器之一上运行：
- en: GCC 9 or newer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 9 或更新版本
- en: Clang 12 or newer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Clang 12 或更新版本
- en: MSVC 19 or newer
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSVC 19 或更新版本
- en: All the examples and source code for this chapter are available in this book’s
    GitHub repository, [https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition),
    in the `chapter03` subfolder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有示例和源代码可以在本书的 GitHub 仓库中找到，[https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition](https://github.com/PacktPublishing/CMake-Best-Practices---2nd-Edition)，在
    `chapter03` 子文件夹中。
- en: Setting up a project
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'Although CMake can work with almost any file structure for a project, there
    are some good practices regarding how to organize files. The examples in this
    book follow the following common pattern:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 CMake 可以处理几乎任何项目文件结构，但有一些关于如何组织文件的好实践。本书中的示例遵循以下常见模式：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are three folders and one file present in a minimal project structure.
    They are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个最小化项目结构中，包含三个文件夹和一个文件。它们如下：
- en: '`build`: The folder where the `build` files and binaries are placed. When checking
    out a fresh project, the build folder is usually not yet present as it will be
    generated by CMake. It is typically named `build`, but it can have any name.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`：存放`build`文件和二进制文件的文件夹。当克隆一个新项目时，通常不会看到 `build` 文件夹，因为它将由 CMake 生成。它通常被命名为
    `build`，但也可以有任何名称。'
- en: '`include/project_name`: This folder contains all the header files that are
    publicly accessible from outside the project. Adding a subfolder that contains
    the project’s name is helpful since includes are done with `<project_name/somefile.h>`,
    making it easier to figure out which library a header file is coming from.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include/project_name`：该文件夹包含所有外部可访问的公共头文件。添加一个包含项目名称的子文件夹是有帮助的，因为头文件的引用通常是通过
    `<project_name/somefile.h>` 完成的，这样更容易判断头文件来自哪个库。'
- en: '`src`: This folder contains all the source and header files that are private.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：这个文件夹包含所有私有的源文件和头文件。'
- en: '`CMakeLists.txt`: This is the root CMake file. The `build` folder can be placed
    almost anywhere. Placing it in the project root is just very convenient. However,
    we strongly advise against choosing any non-empty folder as the `build` folder.
    In particular, putting the build/files into either `include` or `src` is considered
    a bad practice. Additional folders such as `test` or `doc` are often present for
    organizing tests and documentation pages.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMakeLists.txt`：这是根 CMake 文件。`build` 文件夹几乎可以放在任何位置。将其放在项目根目录下是非常方便的。然而，我们强烈建议避免选择任何非空文件夹作为
    `build` 文件夹。特别是，将构建文件放入 `include` 或 `src` 中被认为是一个不好的做法。通常会有 `test` 或 `doc` 等附加文件夹，用于组织测试和文档页面。'
- en: Working with nested projects
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用嵌套项目
- en: When you’re nesting projects inside each other, each project should map the
    file structure above and each `CMakeLists.txt` should be written so that the sub-project
    can be built standalone. This means that each `CMakeLists.txt` file of a sub-project
    should specify `cmake_minimum_required` and, optionally, a project definition
    as well. We will cover large projects and superbuilds in depth in [*Chapter* *10*](B30947_10.xhtml#_idTextAnchor158),
    *Handling Distributed Repositories and Dependencies in* *a Super-Build*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将项目嵌套在彼此内部时，每个项目应当映射上面的文件结构，并且每个`CMakeLists.txt`文件应编写成使子项目能够独立构建。这意味着每个子项目的`CMakeLists.txt`文件应该指定`cmake_minimum_required`，并可选择性地定义项目。我们将在[*第10章*](B30947_10.xhtml#_idTextAnchor158)中深入讨论大型项目和超级构建，*处理分布式仓库和依赖关系的超级构建*。
- en: 'Nested projects look something like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套项目看起来像这样：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the folder structure is repeated inside the `subproject` folder. Sticking
    to such a folder structure and making the subproject buildable on its own makes
    it easier to move projects around. It also allows developers to only build parts
    of a project, which can come in handy for big projects where build times may get
    rather long.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，文件夹结构在`subproject`文件夹中得到了重复。坚持这种文件夹结构并使子项目能够独立构建，可以更容易地移动项目。这也允许开发人员只构建项目的一部分，这在大型项目中尤为有用，因为在这些项目中，构建时间可能会相当长。
- en: Now that we have the file structure covered, let’s start by creating a simple,
    standalone executable without any special dependencies. Later in this chapter,
    we will create various kinds of libraries and bring them all together.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了文件结构的设置，接下来让我们从创建一个简单的独立可执行文件开始，不涉及任何特殊的依赖项。本章后面，我们将创建各种类型的库并将它们组合在一起。
- en: Creating a “hello world” executable
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个“hello world”可执行文件
- en: 'First, we will create a simple executable from a simple hello world C++ program.
    The following C++ program will print out `Welcome to CMake` `Best Practices`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从一个简单的hello world C++程序创建一个简单的可执行文件。下面的C++程序将打印出`Welcome to CMake`和`Best
    Practices`：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To build this, we need to compile it and give the executable a name. Let’s
    see what the `CMakeLists.txt` file to build this executable looks like:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建这个，我们需要编译它并给可执行文件命名。让我们看看用来构建这个可执行文件的`CMakeLists.txt`文件长什么样：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the first line, `cmake_minimum_required(VERSION 3.21)`, we tell CMake which
    version of CMake is expected to be used and which features CMake will enable.
    Trying to build this project with a CMake version less than the one specified
    will result in an error. For this book, we are using CMake 3.21 for all the examples,
    but for compatibility reasons, you could select a lower version.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行`cmake_minimum_required(VERSION 3.21)`中，我们告诉CMake预期使用的CMake版本以及CMake将启用哪些功能。如果尝试使用低于指定版本的CMake构建这个项目，会导致错误。在本书中，我们使用CMake
    3.21进行所有示例，但为了兼容性，你可以选择较低的版本。
- en: For this example, version 3.1 would be the absolute minimum because, before
    that, the `target_sources` command is not available. It is good practice to put
    the `cmake_minimum_required` command at the top of each `CMakeLists.txt` file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，版本3.1将是绝对的最低要求，因为在此之前，`target_sources`命令是不可用的。一个好的做法是将`cmake_minimum_required`命令放在每个`CMakeLists.txt`文件的顶部。
- en: Next, the project is set up using the `project()` command. The first argument
    is the project’s name – in our case, `"hello_world_standalone"`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`project()`命令设置项目。第一个参数是项目的名称——在我们的例子中是`"hello_world_standalone"`。
- en: Next, the version of the project is set to version 1.0\. What follows is a brief
    description and the home page’s URL. Finally, the `LANGUAGES CXX` attribute specifies
    that we are building a C++ project. Apart from the project’s name, all the arguments
    are optional.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，项目的版本设置为1.0。接下来是简短的描述和主页的URL。最后，`LANGUAGES CXX`属性指定我们正在构建一个C++项目。除了项目名称，所有其他参数都是可选的。
- en: Invoking the `add_executable(hello_world)` command creates a target called `hello_world`.
    This will also be the name of the executable file that’s created by this target.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`add_executable(hello_world)`命令会创建一个名为`hello_world`的目标。这也将是由这个目标创建的可执行文件的名称。
- en: Now that the target has been created, adding the C++ source files to the target
    is done with `target_sources`. In this case, `hello_world` is the target name,
    as specified in `add_executable`. The `PRIVATE` definition specifies that the
    sources are only used to build this target and are not visible for any dependent
    targets. After the scope specifier, there’s a list of source files that are relative
    to the path of the current `CMakeLists.txt` file. If needed, the location of the
    currently processed `CMakeLists.txt` file can be accessed with the `CMAKE_CURRENT_SOURCE_DIR`
    variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在目标已经创建，使用`target_sources`将C++源文件添加到目标中。在这种情况下，`hello_world`是目标名称，如`add_executable`中所指定。`PRIVATE`定义指定源文件仅用于构建此目标，并且对任何依赖的目标不可见。在作用域说明符之后，是一组相对于当前`CMakeLists.txt`文件路径的源文件列表。如果需要，可以通过`CMAKE_CURRENT_SOURCE_DIR`变量访问当前正在处理的`CMakeLists.txt`文件的位置。
- en: Sources can be added directly to the `add_executable` function or separately
    using the `target_sources` functions. Adding them with `target_sources` allows
    you to explicitly define where the sources can be used by using `PRIVATE`, `PUBLIC`,
    or `INTERFACE`. However, specifying anything other than `PRIVATE` only makes sense
    for library targets. When source files are directly added to the `add_executable`
    command, they are automatically `PRIVATE`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件可以直接添加到`add_executable`函数中，或者使用`target_sources`函数单独添加。通过`target_sources`添加可以显式地定义源文件的使用范围，使用`PRIVATE`、`PUBLIC`或`INTERFACE`。然而，除`PRIVATE`外的任何指定仅对库目标有意义。当源文件直接添加到`add_executable`命令时，它们默认是`PRIVATE`的。
- en: 'A common pattern that you often see is naming the main executable of a project
    after the project’s name by using the `PROJECT_NAME` variable, like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的模式是将项目的主可执行文件命名为项目的名称，可以通过使用`PROJECT_NAME`变量来实现，例如：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: While this seems to be convenient at first glance, it is not a good practice.
    The project’s name and the target carry a different semantic meaning, so they
    should be treated as separate things, so using `PROJECT_NAME` as the name for
    targets should be avoided.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管乍一看这似乎很方便，但这不是一个好的做法。项目的名称和目标承载着不同的语义，因此应该视为两个独立的事物，因此应避免使用`PROJECT_NAME`作为目标的名称。
- en: Executables are important and quite easy to create, but unless you’re building
    a huge monolith, libraries are a good way to modularize and distribute code. In
    the next section, we will learn how libraries are built and how to handle different
    linking methods.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件很重要，而且相对容易创建，但除非你正在构建一个巨大的整体应用，否则库是模块化和分发代码的好方式。在下一节中，我们将学习如何构建库以及如何处理不同的链接方法。
- en: Creating a simple library
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的库
- en: Creating a library works similarly to creating an executable, although there
    are a few additional things to consider since library targets are usually used
    by other targets, either in the same project or by other projects. Since libraries
    usually have an internal part and a publicly visible API, we must take this into
    account when adding files to the project.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 创建库的过程与创建可执行文件相似，尽管由于库目标通常会被其他目标使用（无论是同一项目中的目标，还是其他项目中的目标），因此需要考虑一些额外的因素。由于库通常有一个内部部分和一个公开的API，我们在将文件添加到项目时必须考虑这一点。
- en: 'A simple project for a library will look like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的库项目将是这样的：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, the file starts with setting `cmake_minimum_required` and the project
    information, which should be familiar to you by now.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，文件以设置`cmake_minimum_required`和项目信息开始，你现在应该已经很熟悉这些内容了。
- en: Next, the target for the library is created with `add_library` – in this case,
    the type of library is not determined. We could pass `STATIC` or `SHARED` instead
    to determine the linking type of the library explicitly. By omitting this, we
    allow any downstream consumers of the library to choose how to build and link
    it. Generally, static libraries are easiest to handle, but have drawbacks regarding
    compile time and modularized distribution. More information about building shared
    libraries can be found in the *Symbol visibility in shared* *libraries* subsection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`add_library`创建库的目标——在这种情况下，库的类型未被确定。我们可以传递`STATIC`或`SHARED`来显式地确定库的链接类型。如果省略这一部分，我们允许库的任何下游使用者选择如何构建和链接它。通常，静态库最容易处理，但在编译时间和模块化分发方面有一些缺点。有关构建共享库的更多信息，请参见*共享库中的符号可见性*子部分。
- en: If the type of the library is omitted, the `BUILD_SHARED_LIBS` variable determines
    whether the libraries are built as shared or static libraries by default. This
    variable should not be set unconditionally in the `CMakeLists.txt` files of a
    project; it should always be passed on by the user.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略库的类型，`BUILD_SHARED_LIBS`变量决定默认情况下库是作为共享库还是静态库构建。此变量不应在项目的`CMakeLists.txt`文件中无条件设置；它应始终由用户传递。
- en: 'Additionally to just defining the library target, it is good practice to also
    define a library alias, which is done with the following line:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义库目标外，良好的实践是还定义一个库别名，可以通过以下代码实现：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This creates an alias name called `ch3_hello::hello` that refers to the `hello`
    target.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个别名，名为`ch3_hello::hello`，它指代`hello`目标。
- en: Next, the sources for the library are added with `target_sources`. The first
    argument is the target name, followed by the sources separated by the `PRIVATE`,
    `PUBLIC`, or `INTERFACE` keyword. In practice, source files are almost always
    added with the `PRIVATE` specifier. The `PRIVATE` and `PUBLIC` keywords specify
    where the sources should be used for compiling. Specifying `PRIVATE` means that
    the sources will only be used in the `hello` target itself. If `PUBLIC` is used,
    then the sources will be added to `hello` and any target that links to `hello`.
    As we mentioned previously, this is not usually desired. The `INTERFACE` keyword
    would mean that the sources are not added to `hello` but should be added to anything
    that links against `hello`. This is usually only the case for headers and not
    for source files. Generally, anything that’s specified as `PRIVATE` for a target
    can be seen as a build requirement for the target. Sources marked as `PUBLIC`
    are build and interface requirements for a target and sources marked as `INTERFACE`
    are interface-only. Finally, the `include` directories for the library are set
    using `target_include_directories`. All the files inside the folders specified
    by this command can be accessed using `#include <file.hpp>` (with the angle brackets)
    instead of `#include ""`, although the version with the quotes may still work.
    The `include` directories follow the same semantics as the source files when it
    comes to `PRIVATE`, `PUBLIC`, and `INTERFACE`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`target_sources`添加库的源文件。第一个参数是目标名称，后面是由`PRIVATE`、`PUBLIC`或`INTERFACE`关键字分隔的源文件。在实际操作中，源文件几乎总是使用`PRIVATE`修饰符添加。`PRIVATE`和`PUBLIC`关键字指定了源文件在哪些地方用于编译。指定`PRIVATE`意味着源文件仅会在`hello`目标本身中使用。如果使用`PUBLIC`，则源文件会添加到`hello`以及任何链接到`hello`的目标中。如前所述，这通常不是期望的行为。`INTERFACE`关键字意味着源文件不会添加到`hello`中，但会添加到任何与`hello`链接的目标中。这通常只适用于头文件，而不适用于源文件。一般来说，任何指定为`PRIVATE`的目标都可以视为该目标的构建要求。标记为`PUBLIC`的源文件是构建和接口要求，而标记为`INTERFACE`的源文件仅为接口要求。最后，使用`target_include_directories`设置库的`include`目录。通过此命令指定的文件夹中的所有文件可以通过`#include
    <file.hpp>`（使用尖括号）而非`#include ""`来访问，尽管使用引号的版本仍然有效。`include`目录在`PRIVATE`、`PUBLIC`和`INTERFACE`的语义上与源文件类似。
- en: '`PRIVATE` includes paths that will not be included in the target property,
    `INTERFACE_INCLUDE_DIRECTORIES`. CMake will read this property when targets depend
    on the library to determine which of the `include` directories are visible to
    the dependee.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`PRIVATE`包含的路径不会被包括在目标属性`INTERFACE_INCLUDE_DIRECTORIES`中。当目标依赖于库时，CMake会读取此属性，以确定哪些`include`目录对被依赖目标可见。'
- en: Since the C++ code of the library uses features that are tied to a modern version
    of C++, such as C++11/14/17/20 or C++23 (to be released soon), we must set the
    `cxx_std_17` property. Since this standard is necessary to compile the library
    itself and also to interface against the library, it is set to `PUBLIC`. Setting
    it to `PUBLIC` or `INTERFACE` is only necessary if the header files contain code
    that requires a certain standard. If only the internal code is dependent on a
    certain standard, setting it to `PRIVATE` is preferred. Generally, try to set
    the public C++ standard to the lowest that works. It is also possible to only
    enable certain features of one of the modern C++ standards, but this is rather
    uncommon.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于库的C++代码使用了与现代C++版本相关的特性，例如C++11/14/17/20或即将发布的C++23，我们必须设置`cxx_std_17`属性。由于此标准对于编译库本身以及与库的接口都是必要的，因此它设置为`PUBLIC`。只有当头文件中包含需要特定标准的代码时，才有必要将其设置为`PUBLIC`或`INTERFACE`。如果仅内部代码依赖于某个标准，则更倾向于将其设置为`PRIVATE`。通常，尽量将公共C++标准设置为能正常工作的最低版本。也可以只启用某个现代C++标准的特定特性，但这相对较少见。
- en: A full list of the available compile features can be found at [https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html](https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的编译特性完整列表可以在[https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html](https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html)找到。
- en: Library aliases
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库别名
- en: Library aliases are a way to refer to a library without creating a new build
    target, sometimes referred to as namespaces. A common pattern is to create a library
    alias in the form of `MyProject::Library` for each library that is installed from
    a project.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 库别名是一种在不创建新构建目标的情况下引用库的方式，有时也被称为命名空间。一个常见的模式是为从项目安装的每个库创建一个形如`MyProject::Library`的库别名。
- en: 'They can be used to semantically group multiple targets. They also help avoid
    clashes in naming, especially when projects contain common targets such as libraries
    named `utils`, `helpers`, and similar. It is good practice to collect all the
    targets of the same project under the same namespace. When you’re linking libraries
    from other projects, including the namespace prevents you from accidentally including
    a wrong library. It is considered good practice to create an alias with a namespace
    for all libraries to group them so that they can be referenced by their namespace:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以用于语义上将多个目标分组。它们还可以帮助避免命名冲突，特别是当项目中包含常见的目标（例如名为`utils`、`helpers`等的库）时。一个好的做法是将同一项目的所有目标放在同一个命名空间下。当你从其他项目链接库时，包含命名空间可以防止你不小心链接错误的库。被认为是好习惯的是，为所有库创建一个带有命名空间的别名，将它们分组，以便可以通过命名空间引用它们：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In addition to helping with determining the origin of a target, CMake uses namespaces
    to recognize imported targets and create better diagnostic messages, as we will
    see when we look at installing and packaging in [*Chapter 4*](B30947_04.xhtml#_idTextAnchor071),
    *Packaging, Deploying, and Installing a CMake Project*, as well as in [*Chapter
    5*](B30947_05.xhtml#_idTextAnchor084), *Integrating Third-Party Libraries**and
    Dependency Management*, where we will cover dependency management.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了帮助确定目标的来源外，CMake 还使用命名空间来识别导入的目标，并创建更好的诊断消息，正如我们在安装和打包部分中看到的，在[*第 4 章*](B30947_04.xhtml#_idTextAnchor071)中，*CMake
    项目的打包、部署和安装*，以及在[*第 5 章*](B30947_05.xhtml#_idTextAnchor084)中，*集成第三方库和依赖管理*，我们将讲解依赖管理时也会涉及此内容。
- en: Always use namespaces
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用命名空间
- en: As a good practice, always alias your targets with a namespace and reference
    them using the `namespace::` prefix.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为好习惯，始终使用命名空间别名目标，并通过`namespace::`前缀引用它们。
- en: Generally, whenever you’re referencing a target from outside of your project,
    use the fully qualified name including the namespace to add them with `target_link_library`.
    While aliases are a way to semantically name the build targets used in CMake,
    they only have limited influence on what the resulting library file is actually
    called when built. But for this, CMake also offers convenient functions to control
    the naming and make sure that libraries conform to the naming conventions of the
    different operating systems.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你从项目外部引用目标时，使用包含命名空间的完整名称并通过`target_link_library`添加它们。虽然别名是语义化命名 CMake 构建目标的一种方式，但它们对构建后实际生成的库文件名称的影响有限。不过，CMake
    提供了方便的函数来控制命名并确保库符合不同操作系统的命名约定。
- en: Naming libraries
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名库
- en: 'When you’re creating libraries using `add_library(<name>)`, the name of the
    library must be globally unique inside the project as name collisions are errors.
    By default, the actual filename of the library is constructed according to the
    conventions on the platform, such as `lib<name>.so` on Linux and `<name>.lib`
    or `<name>.dll` on Windows. The name of the file can be changed from the default
    behavior by setting the `OUTPUT_NAME` property of a target. This can be seen in
    the following example, where the name of the output file has been changed from
    `ch3_hello` to `hello`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`add_library(<name>)`创建库时，库的名称必须在项目内全局唯一，因为名称冲突会导致错误。默认情况下，库的实际文件名是根据平台的约定构造的，例如
    Linux 上的`lib<name>.so`，以及 Windows 上的`<name>.lib`或`<name>.dll`。通过设置目标的`OUTPUT_NAME`属性，可以更改文件名的默认行为。以下示例中，输出文件的名称已从`ch3_hello`更改为`hello`：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Avoid names for libraries with the prefix or postfix of `lib` as CMake may append
    or prepend the appropriate string to the filename, depending on the platform.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用以`lib`为前缀或后缀的库名，因为 CMake 可能会根据平台自动在文件名的前面或后面附加适当的字符串。
- en: 'A frequently used naming convention for shared libraries is to add the version
    to the filename to specify the build version and API version. By specifying the
    `VERSION` and `SOVERSION` properties for a library target, CMake will create the
    necessary filenames and symbolic links when building and installing the library:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库常用的命名约定是将版本添加到文件名中，以指定构建版本和API版本。通过为库目标指定`VERSION`和`SOVERSION`属性，CMake将在构建和安装库时创建必要的文件名和符号链接：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On Linux, this example will result in a filename of `libhello.so.1.0.0` with
    symlinks from `libhello.so` and `libhello.so.1` pointing to the actual library
    file. The following screenshot shows the generated file and the symbolic links
    pointing to it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，以上示例将生成名为`libhello.so.1.0.0`的文件，并且从`libhello.so`和`libhello.so.1`到实际库文件的符号链接也会创建。以下截图显示了生成的文件和指向它的符号链接：
- en: '![Figure 3.1 – The library file and the generated symlinks when building with
    the SOVERSION property](img/B30947_03_01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 构建时带有SOVERSION属性的库文件和生成的符号链接](img/B30947_03_01.jpg)'
- en: Figure 3.1 – The library file and the generated symlinks when building with
    the SOVERSION property
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 构建时带有SOVERSION属性的库文件和生成的符号链接
- en: Another convention that’s often seen in projects is adding a different postfix
    to the filename for the various build configurations. CMake handles this by setting
    the `CMAKE_<CONFIG>_POSTFIX` global variable to or whatever the convention is
    or adding the `<CONFIG>_POSTFIX` property to the targets. If this variable is
    set, the postfix will be automatically added to non-executable targets. As with
    most global variables, they should be passed to CMake over the command line or
    as a preset rather than hardcoded in the `CMakeLists.txt` file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中常见的一种约定是为不同的构建配置添加不同的文件名后缀。CMake通过设置`CMAKE_<CONFIG>_POSTFIX`全局变量或者添加`<CONFIG>_POSTFIX`属性到目标来处理这一点。如果设置了这个变量，后缀会自动添加到非可执行目标上。与大多数全局变量一样，它们应通过命令行或预设传递给CMake，而不是硬编码在`CMakeLists.txt`文件中。
- en: 'The postfix for debug libraries can also be set explicitly to a single target,
    as shown in the following example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 调试库的后缀也可以明确地为单个目标设置，如下例所示：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will result in the library file and symlinks being named `libhellod.so`
    when you’re building in the debug configuration. Since linking libraries is done
    over targets rather than filenames in CMake, picking the correct filename happens
    automatically, so we do not have to keep track manually. However, one thing to
    watch out for when linking shared libraries is symbol visibility. We’ll look at
    this in the next section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，在调试配置下构建时，库文件和符号链接将被命名为`libhellod.so`。由于在CMake中，库链接是通过目标而非文件名进行的，选择正确的文件名会自动完成，因此我们无需手动跟踪。然而，在链接共享库时需要注意的一点是符号的可见性。我们将在下一节中讨论这个问题。
- en: Symbol visibility in shared libraries
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享库中的符号可见性
- en: To link against shared libraries, the linker must know which symbols can be
    used from outside the library. These symbols can be classes, functions, types,
    and more, and the process of making them visible is called exporting.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要链接共享库，链接器必须知道哪些符号可以从库外部使用。这些符号可以是类、函数、类型等，公开它们的过程称为导出。
- en: Compilers have different ways and default behavior when specifying symbol visibility,
    which makes specifying this in a platform-independent way a bit of a hassle. It
    starts with the default visibility of the compilers; GCC and Clang assume that
    all the symbols are visible, while Visual Studio compilers, by default, hide all
    the symbols unless they’re explicitly exported. By setting `CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS`,
    the default behavior of MSVC can be changed, but this is a brute-force approach
    to the problem and can only be used if all the symbols of a library should be
    exported.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器在指定符号可见性时有不同的方式和默认行为，这使得以平台无关的方式指定这一点变得有些麻烦。首先是编译器的默认可见性；GCC和Clang默认假定所有符号都是可见的，而Visual
    Studio编译器默认隐藏所有符号，除非显式导出。通过设置`CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS`，可以改变MSVC的默认行为，但这是一个粗暴的解决方法，只能在库的所有符号都应该导出的情况下使用。
- en: While setting all the symbols to publicly visible is an easy way to ensure that
    linking is easy, it has a few downsides.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将所有符号设置为公开可见是确保链接顺利的简单方法，但它也有一些缺点。
- en: By exporting everything, there is no way of preventing the use of internal code
    by dependent targets.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导出所有内容，无法防止依赖目标使用内部代码。
- en: Since every symbol can be used by external code, the linker cannot discard dead
    code, so the resulting libraries tend to be bloated. This is especially true if
    the library contains templates, which tend to blow up the number of symbols considerably.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个符号都可以被外部代码使用，链接器无法丢弃死代码，因此生成的库往往会变得臃肿。如果库包含模板，这一点尤其明显，因为模板会显著增加符号的数量。
- en: Since every symbol is exported, the only clue about what should be considered
    hidden or internal has to come from the documentation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个符号都被导出，唯一可以判断哪些符号应该被视为隐藏或内部的线索只能来自文档。
- en: Exposing the internal symbols of a library may expose things that should be
    kept hidden.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露库的内部符号可能会暴露应该保持隐藏的内容。
- en: Setting all symbols to visible
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 设置所有符号为可见
- en: Be careful when you’re setting all symbols to be visible in a shared library,
    especially when you’re concerned about security issues or when the size of the
    binary is important.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设置共享库中的所有符号都可见时，尤其是在关注安全问题或二进制大小很重要的情况下，要小心。
- en: Changing the default visibility
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改默认可见性
- en: 'To change the default visibility of the symbols, set the `<LANG>_VISIBILITY_PRESET`
    property to `HIDDEN`. This property can be set either globally or for a single
    library target. `<LANG>` is substituted for the language that the library is written
    in, such as `CXX` for C++ or `C` for C. If all the symbols are hidden symbols
    to be exported, they must be marked specially in the code. The most common way
    to do this is to specify a preprocessor definition that determines whether a symbol
    is visible or not:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改符号的默认可见性，将`<LANG>_VISIBILITY_PRESET`属性设置为`HIDDEN`。此属性可以全局设置，也可以针对单个库目标进行设置。`<LANG>`会替换为库所使用的编程语言，例如C++使用`CXX`，C语言使用`C`。如果所有符号都应该是隐藏的并且要导出，它们必须在代码中特别标记。最常见的做法是指定一个预处理器定义来决定一个符号是否可见：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `HELLO_EXPORT` definition will contain information about whether the symbol
    will be exported when the library is compiled or whether it should be imported
    when you’re linking against the library. GCC and Clang use the `__attribute__(…)`
    keyword to determine this behavior, while on Windows, `_declspec(…)` is used.
    Writing header files that handle this in a cross-platform manner is not an easy
    task, especially if you also have to consider that libraries might be built as
    static and object libraries. Luckily, CMake provides the `generate_export_header`
    macro, which is imported by the `GenerateExportHeader` module, to make this easier.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`HELLO_EXPORT`定义将包含关于符号在库编译时是否会导出的信息，或者在链接库时是否应当导入。GCC和Clang使用`__attribute__(…)`关键字来确定此行为，而在Windows上使用的是`_declspec(…)`。编写能够跨平台处理的头文件并不是一件容易的事，特别是当你还需要考虑库可能被构建为静态库和对象库时。幸运的是，CMake提供了`generate_export_header`宏，它由`GenerateExportHeader`模块导入，以简化这一过程。'
- en: 'In the following example, the symbols for the `hello` library are set to be
    hidden by default. Then, they are individually enabled again with the use of the
    `generate_export_header` macro, which is imported by the `GenerateExportHeader`
    module. Additionally, this example sets the `VISIBILITY_INLINES_HIDDEN` property
    to `TRUE` to further reduce the export symbol table by hiding inlined class member
    functions. Setting the visibility for inlines is not strictly necessary, but it’s
    often done when the default visibility is set:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`hello`库的符号默认设置为隐藏。然后，使用`GenerateExportHeader`模块导入的`generate_export_header`宏单独启用它们。此外，示例还将`VISIBILITY_INLINES_HIDDEN`属性设置为`TRUE`，以通过隐藏内联类成员函数来进一步减少导出符号表。设置内联符号的可见性并非严格必要，但通常在设置默认可见性时会这样做：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The call to `generate_export_header` creates a file named `export_hello.hpp`
    in the `CMAKE_CURRENT_BINARY_DIR/export/hello` directory that can be included
    in the files of the library. It is good practice to put these generated files
    in a subfolder of the build directory so that only part of the directory is added
    to the `include` path. The `include` structure of the generated files should match
    the `include` structure of the rest of the library. So, if, in this example, all
    the public header files are included by calling `#include <hello/a_public_header.h>`,
    the export header should also be placed in a folder called `hello`. The generated
    file also has to be added to the installation instructions, as explained in [*Chapter
    4*](B30947_04.xhtml#_idTextAnchor071), *Packaging, Deploying, and Installing a
    CMake Project*. Additionally, to create the export file, the necessary compiler
    flags for exporting the symbols must be set to the target.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`generate_export_header`会在`CMAKE_CURRENT_BINARY_DIR/export/hello`目录下创建一个名为`export_hello.hpp`的文件，该文件可以在库的其他文件中包含。将这些生成的文件放在构建目录的子文件夹中是一种好的做法，这样只有部分目录会被添加到`include`路径中。生成的文件的`include`结构应该与库其他部分的`include`结构保持一致。所以，在这个例子中，如果所有公共头文件都是通过`#include
    <hello/a_public_header.h>`方式包含的，那么导出头文件也应该放在名为`hello`的文件夹中。生成的文件还必须添加到安装指令中，正如在[*第4章*](B30947_04.xhtml#_idTextAnchor071)中所解释的那样，*打包、部署和安装CMake项目*。此外，为了生成导出文件，必须为目标设置必要的编译器标志来导出符号。
- en: Since the generated header file must be included in the files that declare the
    classes, functions, and types to be exported, `CMAKE_CURRENT_BINARY_DIR/export/`
    is added to `target_include_directories`. Note that this has to be `PUBLIC` so
    that dependent libraries can find the file as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生成的头文件必须包含在声明要导出的类、函数和类型的文件中，因此`CMAKE_CURRENT_BINARY_DIR/export/`被添加到`target_include_directories`中。请注意，这必须是`PUBLIC`，以便依赖的库也能够找到该文件。
- en: There are many more options regarding the `generate_export_header` macros, but
    what we have seen in this section covers the majority of use cases. Additional
    information about setting symbol visibility can be retrieved from the official
    CMake documentation at [https://cmake.org/cmake/help/latest/module/GenerateExportHeader.html](https://cmake.org/cmake/help/latest/module/GenerateExportHeader.html).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`generate_export_header`宏还有许多其他选项，但我们在本节中所看到的已经涵盖了大部分常见用例。有关设置符号可见性的更多信息，请参阅官方CMake文档：[https://cmake.org/cmake/help/latest/module/GenerateExportHeader.html](https://cmake.org/cmake/help/latest/module/GenerateExportHeader.html)。
- en: Interface or header-only libraries
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口库或头文件库
- en: Header-only libraries are a bit special as they are not compiled; instead, they
    export their headers so that they’re directly included in other libraries. In
    most aspects, header-only libraries work like normal libraries, but their header
    files are exposed using the `INTERFACE` keyword, rather than the `PUBLIC` keyword.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件库有点特殊，因为它们不需要编译；相反，它们导出自己的头文件，以便可以直接在其他库中包含。在大多数方面，头文件库的工作方式与普通库相似，但它们的头文件是通过`INTERFACE`关键字公开的，而不是通过`PUBLIC`关键字。
- en: 'Since header-only libraries do not need to be compiled, they do not add sources
    to the targets. The following code creates a minimal header-only library:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于头文件库不需要编译，它们不会将源代码添加到目标中。以下代码创建了一个最小的头文件库：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is also worth noting that before CMake version `3.19`, the `INTERFACE` libraries
    could not have any `target_sources` added. Now, header-only libraries can have
    sources listed, but it is rarely used
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，在CMake版本`3.19`之前，`INTERFACE`库不能添加任何`target_sources`。现在，头文件库可以列出源代码，但这种用法很少见。
- en: Object libraries – for internal use only
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象库——仅供内部使用
- en: Sometimes, you may want to split off code so that parts of it can be reused
    without the need to create a full-blown library. A common practice is when you
    want to use some code in an executable and unit tests, without the need to recompile
    everything twice.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想要拆分代码，以便某些部分可以被重用，而无需创建完整的库。一个常见的做法是，当你想在可执行文件和单元测试中使用一些代码，而无需重新编译所有内容两次时。
- en: For this, CMake provides object libraries, where the sources are compiled, but
    not archived or linked. An object library is created by calling `add_library(MyLibrary
    OBJECT)`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，CMake提供了对象库，其中源代码会被编译，但不会被归档或链接。通过调用`add_library(MyLibrary OBJECT)`来创建一个对象库。
- en: Since CMake 3.12, these objects can be used like normal libraries by adding
    them to `target_link_libraries` functions. Before version 3.12, object libraries
    needed to be added with a generator expression; that is, `$<TARGET_OBJECTS:MyLibrary>`.
    This expands to a list of objects during build system generation. This can still
    be done, but it is no longer recommended as it quickly becomes unmaintainable,
    especially if there are multiple object libraries in a project.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 自CMake 3.12以来，这些目标可以像普通库一样通过将它们添加到`target_link_libraries`函数中来使用。在3.12版本之前，目标库需要通过生成表达式添加，即`$<TARGET_OBJECTS:MyLibrary>`。这将在构建系统生成期间扩展为一个对象列表。虽然这仍然可以做到，但不再推荐这样做，因为它会迅速变得难以维护，尤其是在项目中有多个目标库的情况下。
- en: When to use object libraries
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用目标库
- en: Object libraries help speed up building and modularizing code without making
    the modules public.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 目标库有助于加速构建和模块化代码，而无需将模块公开。
- en: With object libraries, all the different types of libraries are covered. Libraries
    on their own are fun to write and maintain, but unless they are integrated into
    a bigger project, they do not do anything. So, let’s see how all the libraries
    we’ve defined so far can be used in an executable.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用目标库时，所有不同类型的库都被涵盖。库本身编写和维护都很有趣，但除非它们集成到更大的项目中，否则它们什么也做不了。所以，让我们看看到目前为止我们定义的所有库如何在可执行文件中使用。
- en: Bringing it together – using your libraries
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇总 - 使用你的库
- en: So far, we have created three different libraries – a binary library to be linked
    either statically or dynamically, an interface or header-only library, and a precompiled
    but not linked object library.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了三种不同的库——一个二进制库，可以静态或动态链接，一个接口或仅头文件库，以及一个已预编译但未链接的目标库。
- en: Let’s learn how to use them in an executable in a shared project. Installing
    them as system libraries or using them as external dependencies will be covered
    in [*Chapter 5*](B30947_05.xhtml#_idTextAnchor084), *Integrating Third-Party Libraries*
    *and* *Dependency Management*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何在共享项目中将它们用于可执行文件。将它们作为系统库安装或作为外部依赖项使用将在[*第五章*](B30947_05.xhtml#_idTextAnchor084)，*集成第三方库*和*依赖管理*中讨论。
- en: So, we can either put the `add_library` calls in the same `CMakeLists.txt` file
    or we can integrate them by using `add_subdirectory`. Both are valid options and
    depend on how the project is set up, as described in the *Setting up a project*
    and *Working with nested projects* sections of this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以将`add_library`调用放在同一个`CMakeLists.txt`文件中，或者通过使用`add_subdirectory`将它们集成在一起。两者都是有效的选项，具体取决于项目的设置，如本章的*设置项目*和*处理嵌套项目*部分所述。
- en: 'In the following example, we’re assuming that three libraries have been defined
    with `CMakeLists.txt` files in the `hello_lib`, `hello_header_only`, and `hello_object`
    directories. These libraries can be included using the `add_subdirectory` command.
    Here, a new target called `chapter3`, which is our executable, is created. Then,
    the libraries are added to the executable by `target_link_libraries`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们假设在`hello_lib`、`hello_header_only`和`hello_object`目录中已定义了三个带有`CMakeLists.txt`文件的库。这些库可以通过`add_subdirectory`命令包含进来。在这里，我们创建了一个名为`chapter3`的新目标，即我们的可执行文件。然后，通过`target_link_libraries`将这些库添加到可执行文件中：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The target of `target_link_libraries` can either be an executable or another
    library. Again, the libraries are linked using an access specifier, which is either
    of the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`target_link_libraries`的目标可以是一个可执行文件，也可以是另一个库。同样，库是通过访问说明符进行链接的，访问说明符可以是以下之一：'
- en: '`PRIVATE`: The library is used to link against, but it is not a part of the
    public interface. The linked library is only a requirement when you’re building
    the target.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRIVATE`：该库用于链接，但它不是公共接口的一部分。链接的库只有在构建目标时才是必需的。'
- en: '`INTERFACE`: The library is not linked against, but it is part of the public
    interface. The linked library is a requirement when you’re using the target somewhere
    else. This is usually only used when you’re linking header-only libraries from
    other header-only libraries.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERFACE`：该库不会被链接，但它是公共接口的一部分。当你在其他地方使用该目标时，链接的库是必需的。这通常只在你链接其他只包含头文件的库时使用。'
- en: '`PUBLIC`: The library is linked against, and it is part of the public interface.
    So, the library is both a build dependency and a usage dependency.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUBLIC`：该库被链接，并且它是公共接口的一部分。因此，该库既是构建依赖项，也是使用依赖项。'
- en: Attention – bad practices
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 – 不良做法
- en: The following practices are actively discouraged by the authors of this book
    as they tend to create unmaintainable projects that make it hard to port between
    different build environments. However, we have included them for completeness.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的作者强烈不推荐以下做法，因为它们往往会创建难以维护的项目，并使得在不同的构建环境之间移植变得困难。不过，我们将其包括在内以确保内容的完整性。
- en: Instead of passing another target after `PUBLIC`, `PRIVATE`, or `INTERFACE`,
    you can also pass full paths to libraries or the filename of a library, such as
    `/usr/share/lib/mylib.so` or just `mylib.so`. These practices are possible but
    discouraged as they make the CMake project less portable. Additionally, it is
    possible to pass linker flags here by passing something such as `-nolibc`, though
    again, this is discouraged. If special linker flags are needed for all the targets,
    then passing them using the command line is the preferred way. If a single library
    needs special flags, then using `target_link_options` is the preferred way to
    do this, preferably in combination with the options that are set over the command
    line.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PUBLIC`、`PRIVATE` 或 `INTERFACE` 后面传递另一个目标时，您还可以传递库的完整路径或库的文件名，例如 `/usr/share/lib/mylib.so`
    或仅 `mylib.so`。这些做法是可以实现的，但不推荐使用，因为它们会使 CMake 项目变得不易移植。此外，您还可以通过传递类似 `-nolibc`
    这样的内容来传递链接器标志，尽管同样不推荐这样做。如果所有目标都需要特殊的链接器标志，最好通过命令行传递它们。如果单个库需要特殊的标志，则使用 `target_link_options`
    是推荐的做法，最好与命令行上设置的选项结合使用。
- en: In the next section, we’ll look at setting compiler and linker options.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何设置编译器和链接器选项。
- en: Setting compiler and linker options
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置编译器和链接器选项
- en: 'C++ compilers have lots of options regarding some of the most common flags
    to be set and it is also a common practice to set preprocessor definitions from
    the outside. In CMake, these are passed using the `target_compile_options` command.
    Changing linker behavior is done with the `target_link_options` command. Unfortunately,
    compilers and linkers may have different ways of how flags are set. For instance,
    in GCC and Clang, options are passed with a dash (`-`), while the Microsoft compiler
    takes slashes (`/`) as prefixes for its options. But by using generator expressions,
    which we covered in [*Chapter 1*](B30947_01.xhtml#_idTextAnchor015), *Kickstarting
    CMake*, this can be conveniently handled in CMake, as shown in the following example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 编译器有很多选项，涉及一些常见的标志设置，同时从外部设置预处理器定义也是一种常见做法。在 CMake 中，这些选项是通过 `target_compile_options`
    命令传递的。更改链接器行为则通过 `target_link_options` 命令实现。不幸的是，编译器和链接器可能在设置标志的方式上有所不同。例如，在 GCC
    和 Clang 中，选项是通过连字符（`-`）传递的，而 Microsoft 编译器则使用斜杠（`/`）作为选项的前缀。但通过使用生成器表达式（在[*第 1
    章*](B30947_01.xhtml#_idTextAnchor015)《启动 CMake》中介绍过），可以方便地在 CMake 中处理这些差异，以下是一个示例：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s look at the generator expression in detail.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看这个生成器表达式。
- en: '`$<$<CXX_COMPILER_ID:MSVC>:/SomeOption>` is a nested generator expression that
    is evaluated inside out. Generator expressions are evaluated during build system
    generation. First, `$<CXX_COMPILER_ID:MSVC>` evaluates to `true` if the C++ compiler
    equals `MSVC`. If this is the case, then the outer expression will return `/SomeOption`,
    which is then passed to the compiler. If the inner expression evaluates to `false`,
    then nothing is passed on.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`$<$<CXX_COMPILER_ID:MSVC>:/SomeOption>` 是一个嵌套的生成器表达式，按从内到外的顺序进行求值。生成器表达式在构建系统生成期间进行求值。首先，`$<CXX_COMPILER_ID:MSVC>`
    如果 C++ 编译器为 `MSVC`，则求值为 `true`。如果是这种情况，那么外部表达式将返回 `/SomeOption`，然后传递给编译器。如果内部表达式求值为
    `false`，则什么都不会传递。'
- en: '`$<$<CXX_COMPILER_ID:GNU,Clang,AppleClang>:-fopenmp>` works similarly, but
    instead of just checking against a single value, a list containing `GNU,Clang,AppleClang`
    is passed. If `CXX_COMPILER_ID` matches either of these, the inner expression
    evaluates to `true` and `someOption` is passed to the compiler.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`$<$<CXX_COMPILER_ID:GNU,Clang,AppleClang>:-fopenmp>` 类似地工作，但它不仅检查单一的值，而是传递一个包含
    `GNU,Clang,AppleClang` 的列表。如果 `CXX_COMPILER_ID` 与这些值中的任何一个匹配，则内部表达式求值为 `true`，并将
    `someOption` 传递给编译器。'
- en: Passing compiler or linker options as `PRIVATE` marks them as a build requirement
    for this target that is not needed for interfacing the library. If `PRIVATE` is
    substituted with `PUBLIC`, then the compile option also becomes a usage requirement
    and all the targets that depend on the original targets will use the same compiler
    options. Exposing compiler options to the dependent targets is something that
    needs to be done with caution. If a compiler option is only needed to use a target
    but not to build it, then `keyword INTERFACE` can be used. This is mostly the
    case when you’re building header-only libraries.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将编译器或链接器选项传递为 `PRIVATE` 标记它们是此目标的构建要求，而不需要在库接口中使用。如果将 `PRIVATE` 替换为 `PUBLIC`，则编译选项也会成为一个使用要求，所有依赖于原始目标的目标将使用相同的编译选项。将编译器选项暴露给依赖目标需要谨慎处理。如果某个编译选项仅用于使用目标，但不用于构建目标，则可以使用
    `keyword INTERFACE`。这通常出现在构建仅包含头文件的库时。
- en: A special case of compiler options is preprocessor or compile definitions, which
    are passed to the underlying program. These are passed with the `target_compile_definitions`
    function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 编译选项的特殊情况是预处理器或编译定义，这些定义会传递给底层程序。它们是通过 `target_compile_definitions` 函数传递的。
- en: Debugging compiler options with compilation databases
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用编译数据库调试编译选项
- en: To see all the compile options, you can look at the generated build files, such
    as Makefiles or Visual Studio projects. A much more convenient way is to let CMake
    export all the compile commands as a JSON compilation database.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有编译选项，可以查看生成的构建文件，例如 Makefile 或 Visual Studio 项目。更方便的方法是让 CMake 将所有编译命令导出为
    JSON 编译数据库。
- en: By enabling the `CMAKE_EXPORT_COMPILE_COMMANDS` variable, a file called `compile_commands.json`
    containing the full commands for compiling is created in the `build` folder.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用 `CMAKE_EXPORT_COMPILE_COMMANDS` 变量，CMake 会在 `build` 文件夹中创建一个名为 `compile_commands.json`
    的文件，里面包含完整的编译命令。
- en: 'Enabling this option and running CMake will produce results similar to the
    following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此选项并运行 CMake 后，将生成类似以下内容的结果：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note the addition of the manually specified `-fopenMP` flag from the previous
    example. `compile_commands.json` can be used as a build-system-agnostic way to
    load the commands. Some IDEs, such as VS Code and Clion, can interpret the JSON
    file and generate project information themselves.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意从之前示例中手动指定的 `-fopenMP` 标志的添加。`compile_commands.json` 可以作为一种与构建系统无关的方式来加载命令。一些
    IDE，如 VS Code 和 Clion，能够解析该 JSON 文件并自动生成项目信息。
- en: The full specifications of the compile commands database can be found at [https://clang.llvm.org/docs/JSONCompilationDatabase.html](https://clang.llvm.org/docs/JSONCompilationDatabase.html).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 编译命令数据库的完整规范可以在 [https://clang.llvm.org/docs/JSONCompilationDatabase.html](https://clang.llvm.org/docs/JSONCompilationDatabase.html)
    找到。
- en: 'There are more and more tools out there that use the `compile_commands.json`
    database to figure out the exact compilation options passed on, so a lot of projects
    turn the creation on by default. Notably, most tools from LLVM, such as the `clang-tidy`
    linter or `clangd` for code completion, benefit a lot from having access to the
    compilation database. It also often comes in handy for debugging compiler options
    in case something does not work as expected: [https://clang.llvm.org/docs/JSONCompilationDatabase.html](https://clang.llvm.org/docs/JSONCompilationDatabase.html).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，越来越多的工具使用 `compile_commands.json` 数据库来确定传递的确切编译选项，因此许多项目默认启用此功能。特别是，大多数来自
    LLVM 的工具，例如 `clang-tidy` 静态分析工具或用于代码补全的 `clangd`，都能从访问编译数据库中获益匪浅。如果编译选项出现问题，也可以通过该数据库方便地调试编译选项：[https://clang.llvm.org/docs/JSONCompilationDatabase.html](https://clang.llvm.org/docs/JSONCompilationDatabase.html)。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now that you’ve completed this chapter, you’re ready to create applications
    and libraries with CMake and start building more complex projects than just “hello
    world.” You have learned how to link different targets together and how compiler
    and linker options can be passed to targets. We also covered object libraries
    for internal use only and discussed symbol visibility for shared libraries. Finally,
    you learned how to document these dependencies automatically so that you have
    an overview of large projects.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了本章的内容，准备好使用 CMake 创建应用程序和库，并开始构建比“hello world”更复杂的项目。你已经学会了如何将不同的目标链接在一起，以及如何将编译器和链接器选项传递给目标。我们还讨论了仅供内部使用的对象库，并讲解了共享库的符号可见性。最后，你学会了如何自动化文档化这些依赖关系，以便对大型项目有一个概览。
- en: In the next chapter, you will learn how to package and install your applications
    and libraries on different platforms.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何在不同平台上打包和安装你的应用程序和库。
- en: Questions
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答以下问题，测试你对本章的理解：
- en: What is the CMake command for creating an executable target?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建可执行目标的 CMake 命令是什么？
- en: What is the CMake command for creating a library target?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建库目标的 CMake 命令是什么？
- en: How can you specify whether a library is statically or dynamically linked?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何指定一个库是静态链接还是动态链接？
- en: What is special about object libraries and where do they come in handy?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象库有什么特别之处，在哪里使用它们最为方便？
- en: How can you specify the default symbol visibility for shared libraries?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何指定共享库的默认符号可见性？
- en: How are compiler options specified for a target and how can you see the compile
    commands?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何为目标指定编译器选项，如何查看编译命令？
- en: Answers
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'The CMake command for creating an executable target is:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建可执行目标的 CMake 命令是：
- en: '`add_executable`'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`add_executable`'
- en: 'The CMake command for creating a library target is:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建库目标的 CMake 命令是：
- en: '`add_library`'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`add_library`'
- en: By adding the `SHARED` or `STATIC` keyword or by setting the `BUILD_SHARED_LIBS`
    global variable
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加 `SHARED` 或 `STATIC` 关键字，或者设置 `BUILD_SHARED_LIBS` 全局变量
- en: Object libraries are libraries that are compiled but not linked. They are useful
    for internally separating code and reducing compile time.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象库是已编译但未链接的库。它们用于在内部分离代码，并减少编译时间。
- en: By globally setting the `<``LANG>_VISIBILITY_PRESET` property
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过全局设置 `<LANG>_VISIBILITY_PRESET` 属性
- en: By calling the `target_compile_options` function. The compile options can be
    seen in the `compile_commands.json` file, which is generated if the `CMAKE_EXPORT_COMPILE_COMMANDS`
    variable is set to `true`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `target_compile_options` 函数。编译选项可以在 `compile_commands.json` 文件中查看，该文件会在将
    `CMAKE_EXPORT_COMPILE_COMMANDS` 变量设置为 `true` 时生成。
