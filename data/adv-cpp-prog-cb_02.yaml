- en: Using Exceptions for Error Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异常处理错误
- en: In this chapter, we will learn some advanced C++ exception handling techniques.
    We assume here that you have a basic understanding of how to throw as well as
    catch a C++ exception. Instead of focusing on the basics of C++ exceptions, this
    chapter will teach you some of the more advanced techniques of C++ exception handling.
    This includes the proper use of the `noexcept` specifier and the `noexcept` operator
    so that you can properly mark your APIs as either possibly throwing an exception
    or explicitly not throwing a C++ exception, instead of calling `std::terminate()`
    when an error occurs that cannot be handled.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习一些高级的C++异常处理技术。我们在这里假设您已经基本了解如何抛出和捕获C++异常。本章不是专注于C++异常的基础知识，而是教会您一些更高级的C++异常处理技术。这包括正确使用`noexcept`指定符和`noexcept`运算符，以便您可以正确地标记您的API，要么可能抛出异常，要么明确地不抛出C++异常，而是在发生无法处理的错误时调用`std::terminate()`。
- en: This chapter will also explain what the term **Resource Acquisition is Initialization**
    (**RAII**) is and how it complements C++ exception handling. We will also discuss
    why you should never throw a C++ exception from a class's destructor and how to
    handle these types of issues. Finally, we will look at how to create your own
    custom C++ exceptions including providing some basic guidelines on what to do
    and what not to do when creating your own exceptions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将解释术语**资源获取即初始化**（**RAII**）是什么，以及它如何补充C++异常处理。我们还将讨论为什么不应该从类的析构函数中抛出C++异常以及如何处理这些类型的问题。最后，我们将看看如何创建自己的自定义C++异常，包括提供一些关于创建自己的异常时要做和不要做的基本准则。
- en: From the information provided in this chapter, you will gain a better understanding
    of how C++ exceptions work under the hood and the types of things that can be
    done with C++ exceptions to build more robust and reliable C++ programs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章提供的信息中，您将更好地了解C++异常在底层是如何工作的，以及可以用C++异常做哪些事情来构建更健壮和可靠的C++程序。
- en: 'The recipes in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的配方如下：
- en: Using the noexcept specifier
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`noexcept`指定符
- en: Using the noexcept operator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`noexcept`运算符
- en: Using RAII
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RAII
- en: Learning why to never throw exceptions in destructors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习为什么永远不要在析构函数中抛出异常
- en: Easily creating your own exception classes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松创建自己的异常类
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Before running these examples, you must install the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中的示例，您必须具有对运行Ubuntu 18.04的计算机的管理访问权限，并且具有功能正常的互联网连接。在运行这些示例之前，您必须安装以下内容：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是安装在Ubuntu 18.04以外的任何操作系统上，则需要GCC 7.4或更高版本和CMake 3.6或更高版本。
- en: Using the noexcept specifier
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`noexcept`指定符
- en: The `noexcept` specifier is used to tell the compiler whether a function may
    or may not throw a C++ exception. If a function is marked with the `noexcept`
    specifier, it is not allowed to throw an exception and, if it does, `std::terminate()`
    will be called when the exception is thrown. If the function doesn't have the
    `noexcept` specifier, exceptions can be thrown as normal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`noexcept`指定符用于告诉编译器一个函数是否可能抛出C++异常。如果一个函数标记有`noexcept`指定符，它是不允许抛出异常的，如果抛出异常，将会调用`std::terminate()`。如果函数没有`noexcept`指定符，异常可以像平常一样被抛出。'
- en: In this recipe, we will explore how to use the `noexcept` specifier in your
    own code. This specifier is important because it is a contract between the API
    that you are creating and the user of the API. When the `noexcept` specifier is
    used, it tells the user of the API that they do not need to consider exceptions
    when using the API. It also tells the author that if they add the `noexcept` specifier
    to their API, they have to ensure that no exceptions are thrown, which, in some
    cases, requires the author to catch all possible exceptions and either handle
    them or call `std::terminate()` if the exception cannot be handled. Also, there
    are certain operations, such as `std::move`, where exceptions cannot be thrown
    without the fear of corruption as a move operation oftentimes cannot be safely
    reversed if an exception is thrown. Finally, with some compilers, adding `noexcept`
    to your APIs will reduce the overall size of the function, resulting in a smaller
    overall application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨如何在自己的代码中使用`noexcept`指定符。这个指定符很重要，因为它是你正在创建的API和API的用户之间的一个合同。当使用`noexcept`指定符时，它告诉API的用户在使用API时不需要考虑异常。它还告诉作者，如果他们将`noexcept`指定符添加到他们的API中，他们必须确保不会抛出任何异常，这在某些情况下需要作者捕获所有可能的异常并处理它们，或者在无法处理异常时调用`std::terminate()`。此外，有一些操作，比如`std::move`，在这些操作中不能抛出异常，因为移动操作通常无法安全地被逆转。最后，对于一些编译器，将`noexcept`添加到你的API中将减少函数的总体大小，从而使应用程序的总体大小更小。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有的技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有正确的工具来编译和执行本配方中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To try this recipe, perform the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个配方，请执行以下步骤：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中运行以下命令以下载源代码：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile the source code, run the following:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码被编译，您可以通过运行以下命令来执行本食谱中的每个示例：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些例子，并解释每个示例程序的作用，以及它与本食谱中所教授的课程的关系。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, let''s briefly review how C++ exceptions are thrown and caught. In the
    following example, we will throw an exception from a function and then catch the
    exception in our `main()` function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们简要回顾一下C++异常是如何抛出和捕获的。在下面的例子中，我们将从一个函数中抛出一个异常，然后在我们的`main()`函数中捕获异常：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As shown in the preceding example, we created a function called `foo()` that
    throws an exception. This function is called in our `main()` function inside a
    `try`/`catch` block, which is used to catch any exceptions that might be thrown
    by the code executed inside the `try` block, which in this case is the `foo()`
    function. When the exception is thrown by the `foo()` function, it is successfully
    caught and outputted to `stdout`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，我们创建了一个名为`foo()`的函数，它会抛出一个异常。这个函数在我们的`main()`函数中被调用，位于一个`try`/`catch`块中，用于捕获在`try`块中执行的代码可能抛出的任何异常，这种情况下是`foo()`函数。当`foo()`函数抛出异常时，它被成功捕获并输出到`stdout`。
- en: 'All of this works because we did not add the `noexcept` specifier to the `foo()`
    function. By default, a function is allowed to throw an exception, just as we
    did in this example. In some cases, however, we do not want to allow exceptions
    to be thrown, depending on how we expect a function to execute. Specifically,
    how a function handles exceptions can be defined as the following (known as exception
    safety):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是因为我们没有向`foo()`函数添加`noexcept`说明符。默认情况下，函数允许抛出异常，就像我们在这个例子中所做的那样。然而，在某些情况下，我们不希望允许抛出异常，这取决于我们期望函数执行的方式。具体来说，函数如何处理异常可以定义为以下内容（称为异常安全性）：
- en: '**No-throw guarantee**: The function cannot throw an exception, and if an exception
    is thrown internally, the exception must be caught and handled, including allocation
    failures.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无抛出保证**：函数不能抛出异常，如果内部抛出异常，必须捕获和处理异常，包括分配失败。'
- en: '**Strong exception safety**: The function can throw an exception, and if an
    exception is thrown, any state that was modified by the function is rolled back
    or undone with no side effects.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强异常安全性**：函数可以抛出异常，如果抛出异常，函数修改的任何状态都将被回滚或撤消，没有副作用。'
- en: '**Basic exception safety**: The function can throw an exception, and if an
    exception is thrown, any state that was modified by the function is rolled back
    or undone, but side effects are possible. It should be noted that these side effects
    do not include invariants, meaning the program is in a valid, non-corrupted state.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基本异常安全性**：函数可以抛出异常，如果抛出异常，函数修改的任何状态都将被回滚或撤消，但可能会有副作用。应该注意，这些副作用不包括不变量，这意味着程序处于有效的、非损坏的状态。'
- en: '**No exception safety**: The function can throw an exception, and if an exception
    is thrown, the program could enter a corrupted state.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无异常安全性**：函数可以抛出异常，如果抛出异常，程序可能会进入损坏的状态。'
- en: In general, if a function has a no-throw guarantee, it is labeled with `noexcept`;
    otherwise, it is not. An example of why exception safety is so important is with
    `std::move`. For example, suppose we have two instances of `std::vector` and we
    wish to move one vector into another. To perform the move, `std::vector` might
    move each element of the vector from one instance to the other. If the object
    is allowed to throw when it is moved, the vector could end up with an exception
    in the middle of the move (that is, half of the objects in the vector are moved
    successfully). When the exception occurs, `std::vector` would obviously attempt
    to undo the moves that it has already performed by moving these back to the original
    vector before returning the exception. The problem is, attempting to move the
    objects back would require `std::move()`, which could throw and exception again,
    resulting in a nested exception. In practice, moving one `std::vector` instance
    to another doesn't actually perform an object-by-object move, but resizing does,
    and, in this specific issue, the standard library requires the use of `std::move_if_noexcept`
    to handle this situation to provide exception safety, which falls back to a copy
    when the move constructor of an object is allowed to throw.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果一个函数具有无抛出保证，它会被标记为`noexcept`；否则，它不会。异常安全性如此重要的一个例子是`std::move`。例如，假设我们有两个`std::vector`实例，我们希望将一个向量移动到另一个向量中。为了执行移动，`std::vector`可能会将向量的每个元素从一个实例移动到另一个实例。如果在移动时允许对象抛出异常，向量可能会在移动过程中出现异常（也就是说，向量中的一半对象被成功移动）。当异常发生时，`std::vector`显然会尝试撤消已经执行的移动，将这些移回原始向量，然后返回异常。问题是，尝试将对象移回将需要`std::move()`，这可能再次抛出异常，导致嵌套异常。实际上，将一个`std::vector`实例移动到另一个实例并不实际执行逐个对象的移动，但调整大小会，而在这个特定问题中，标准库要求使用`std::move_if_noexcept`来处理这种情况以提供异常安全性，当对象的移动构造函数允许抛出时，会退回到复制。
- en: The `noexcept` specifier is used to overcome these types of issues by explicitly
    stating that the function is not allowed to throw an exception. This not only
    tells the user of the API that they can safely use the function without fear of
    an exception being thrown and potentially corrupting the execution of the program,
    but it also forces the author of the function to safely handle all possible exceptions
    or call `std::terminate()`. Although `noexcept`, depending on the compiler, also
    provides optimizations by reducing the overall size of the application when defined,
    its main use is to state the exception safety of a function such that other functions
    can reason about how a function will execute.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`noexcept`说明符通过明确声明函数不允许抛出异常来解决这些问题。这不仅告诉API的用户他们可以安全地使用该函数，而不必担心抛出异常可能会破坏程序的执行，而且还迫使函数的作者安全地处理所有可能的异常或调用`std::terminate()`。尽管`noexcept`根据编译器的不同还提供了通过减少应用程序的整体大小来进行优化，但它的主要用途是说明函数的异常安全性，以便其他函数可以推断函数的执行方式。'
- en: 'In the following example, we add the `noexcept` specifier to our `foo()` function
    defined earlier:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们为之前定义的`foo()`函数添加了`noexcept`说明符：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When this example is compiled and executed, we get the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译并执行此示例时，我们得到以下结果：
- en: '![](img/f99d2218-74b5-47f1-8108-6a38646732a8.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f99d2218-74b5-47f1-8108-6a38646732a8.png)'
- en: As shown in the preceding example, the `noexcept` specifier was added, which
    tells the compiler that `foo()` is not allowed to throw an exception. Since, however,
    the `foo()` function does throw an exception, when it is executed, `std::terminate()`
    is called. In fact, in this example, `std::terminate()` will always be called,
    which is something the compiler is able to detect and warn about.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，添加了`noexcept`说明符，告诉编译器`foo()`不允许抛出异常。然而，`foo()`函数确实抛出异常，因此在执行时会调用`std::terminate()`。实际上，在这个示例中，`std::terminate()`总是会被调用，这是编译器能够检测并警告的事情。
- en: 'Calling `std::terminate()` is obviously not the desired outcome of a program.
    In this specific case, since the author has labeled the function as `noexcept`,
    it is up to the author to handle all possible exceptions. This can be done as
    follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 显然调用`std::terminate()`并不是程序的期望结果。在这种特定情况下，由于作者已经将函数标记为`noexcept`，因此需要作者处理所有可能的异常。可以按照以下方式处理：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As shown in the preceding example, the exception is wrapped in a `try`/`catch`
    block to ensure the exception is safely handled before the `foo()` function completes
    its execution. Also, in this example, only exceptions that originate from `std::exception()`
    are caught. This is the author's way of saying which types of exceptions can be
    safely handled. If, for example, an integer was thrown instead of `std::exception()`,
    `std::terminate()` would still be executed automatically since `noexcept` was
    added to the `foo()` function. In other words, as the author, you are only required
    to handle the exceptions that you can, in fact, safely handle. The rest will be
    sent to `std::terminate()` for you; just understand that, by doing this, you change
    the exception safety of the function. If you intend for a function to be defined
    with a no-throw guarantee, the function cannot throw an exception at all.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，异常被包裹在`try`/`catch`块中，以确保在`foo()`函数完成执行之前安全地处理异常。此外，在这个示例中，只捕获了源自`std::exception()`的异常。这是作者表明可以安全处理哪些类型的异常的方式。例如，如果抛出的是整数而不是`std::exception()`，由于`foo()`函数添加了`noexcept`，`std::terminate()`仍然会自动执行。换句话说，作为作者，你只需要处理你确实能够安全处理的异常。其余的将被发送到`std::terminate()`；只需理解，这样做会改变函数的异常安全性。如果你打算定义一个不抛出异常的函数，那么该函数就不能抛出异常。
- en: It should also be noted that if you mark a function as `noexcept`, you need
    to not only pay attention to exceptions that you throw but also to the functions
    that may throw themselves. In this case, `std::cout` is being used inside the
    `foo()` function, which means the author has to either knowingly ignore any exceptions
    that `std::cout` could throw, which would result in a call to `std::terminate()`
    (which is what we are doing here), or the author needs to identify which exceptions
    `std::cout` could throw and attempt to safely handle them, including exceptions
    such as `std::bad_alloc`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 还需注意的是，如果将函数标记为`noexcept`，不仅需要关注自己抛出的异常，还需要关注可能抛出异常的函数。在这种情况下，`foo()`函数内部使用了`std::cout`，这意味着作者要么故意忽略`std::cout`可能抛出的任何异常，导致调用`std::terminate()`（这就是我们这里正在做的），要么作者需要确定`std::cout`可能抛出的异常，并尝试安全地处理它们，包括`std::bad_alloc`等异常。
- en: The `std::vector.at()` function throws an `std::out_of_range()` exception if
    the provided index is out of bounds with respect to the vector. In this case,
    the author can catch this type of exception and return a default value, allowing
    the author to safely mark the function as `noexcept`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的索引超出了向量的边界，`std::vector.at()`函数会抛出`std::out_of_range()`异常。在这种情况下，作者可以捕获这种类型的异常并返回默认值，从而可以安全地将函数标记为`noexcept`。
- en: 'The `noexcept` specifier is also capable of acting as a function, taking a
    Boolean expression, as in the following example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`noexcept`说明符还可以作为一个函数，接受一个布尔表达式，如下面的示例所示：'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This results in the following when executed:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时会得到以下结果：
- en: '![](img/c75fc0ac-3445-4fe6-a20c-934b783a5d96.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c75fc0ac-3445-4fe6-a20c-934b783a5d96.png)'
- en: As shown in the preceding example, the `noexcept` specifier was written as `noexcept(true)`.
    If the expression evaluates to true, it is as if `noexcept` was provided. If the
    expression evaluates to false, it is as if the `noexcept` specifier was left out,
    allowing exceptions to be thrown. In the preceding example, the expression evaluates
    to true, which means that the function is not allowed to throw an exception, which
    results in `std::terminate()` being called when `foo()` throws an exception.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，`noexcept`说明符被写为`noexcept(true)`。如果表达式求值为true，则就好像提供了`noexcept`一样。如果表达式求值为false，则就好像省略了`noexcept`说明符，允许抛出异常。在前面的示例中，表达式求值为true，这意味着该函数不允许抛出异常，这导致在`foo()`抛出异常时调用`std::terminate()`。
- en: 'Let''s look at a more complicated example to demonstrate how this can be used.
    In the following example, we will create a function called `foo()` that will shift
    an integer value by 32 bits and cast the result to a 64-bit integer. This example
    will be written using template metaprogramming, allowing us to use this function
    on any integer type:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更复杂的示例来演示如何使用它。在下面的示例中，我们将创建一个名为`foo()`的函数，它将一个整数值向左移32位并将结果转换为64位整数。这个示例将使用模板元编程来编写，允许我们在任何整数类型上使用这个函数：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This results in the following when executed:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时将得到以下结果：
- en: '![](img/182cbe31-a769-4160-884a-7f9445e380d2.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/182cbe31-a769-4160-884a-7f9445e380d2.png)'
- en: As shown in the preceding example, the issue with the `foo()` function is that
    if the user provides a 64-bit integer, it cannot shift by 32 bits without generating
    an overflow. If the integer provided, however, is 32 bits or less, the `foo()`
    function is perfectly safe. To implement the `foo()` function, we used the `noexcept`
    specifier to state that the function is not allowed to throw an exception if the
    provided integer is 32 bits or less. If the provided integer is greater than 32
    bits, an exception is allowed to throw, which, in this case, is an `std::runtime_error()` exception
    stating that the integer is too large to be safely shifted.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，`foo()`函数的问题在于，如果用户提供了64位整数，它无法进行32位的移位而不产生溢出。然而，如果提供的整数是32位或更少，`foo()`函数就是完全安全的。为了实现`foo()`函数，我们使用了`noexcept`说明符来声明如果提供的整数是32位或更少，则该函数不允许抛出异常。如果提供的整数大于32位，则允许抛出异常，在这种情况下是一个`std::runtime_error()`异常，说明整数太大无法安全移位。
- en: Using the noexcept operator
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用noexcept运算符
- en: The `noexcept` operator is a compile-time check that is used to ask the compiler
    whether a function is labeled `noexcept` or not. With C++17, this can be paired
    with a compile-time `if` statement (that is, an `if` statement that is evaluated
    at compile time and that can be used to add/remove code from an executable during
    compilation) to change the semantics of a program based on whether or not a function
    is allowed to throw an exception.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`noexcept`运算符是一个编译时检查，用于询问编译器一个函数是否被标记为`noexcept`。在C++17中，这可以与编译时`if`语句配对使用（即在编译时评估的`if`语句，可用于根据函数是否允许抛出异常来改变程序的语义）来改变程序的语义。'
- en: In this recipe, we will explore how to use the `noexcept` operator in your own
    code. This operator is important because, in some cases, you may not know whether
    a function is capable of throwing an exception by simply looking at its definition.
    For example, if a function uses the `noexcept` specifier, your code might not
    be able to determine whether the function will throw, as you might not know—based
    on the function's inputs—what the `noexcept` specifier will evaluate to. The `noexcept`
    operator provides you with a mechanism to handle these types of scenarios, which
    is essential, especially when metaprogramming.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将探讨如何在自己的代码中使用`noexcept`运算符。这个运算符很重要，因为在某些情况下，你可能无法通过简单地查看函数的定义来确定函数是否能够抛出异常。例如，如果一个函数使用了`noexcept`说明符，你的代码可能无法确定该函数是否会抛出异常，因为你可能无法根据函数的输入来确定`noexcept`说明符将求值为什么。`noexcept`运算符为你提供了处理这些情况的机制，这是至关重要的，特别是在元编程时。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有适当的工具来编译和执行本教程中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to try the recipe:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤尝试本教程：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中，运行以下命令下载源代码：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To compile the source code, run the following:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译后，可以通过运行以下命令来执行本教程中的每个示例：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本教程中所教授的课程的关系。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `noexcept` operator is used to determine whether a function can throw.
    Let''s start with a simple example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`noexcept`运算符用于确定一个函数是否能够抛出异常。让我们从一个简单的示例开始：'
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This results in the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下结果：
- en: '![](img/afafa314-071a-4aa9-8896-0c19d3282f99.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afafa314-071a-4aa9-8896-0c19d3282f99.png)'
- en: As shown in the preceding example, we defined a `foo()` function that outputs
    to `stdout`. We don't actually execute `foo()` but, instead, we use the `noexcept`
    operator to check to see whether the `foo()` function could throw. As you can
    see, the answer is yes; this function can throw. This is because we did not label
    the `foo()` function with `noexcept`, and, as stated in the previous recipe, functions
    can throw by default.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，我们定义了一个输出到`stdout`的`foo()`函数。我们实际上没有执行`foo()`，而是使用`noexcept`操作符来检查`foo()`函数是否可能抛出异常。如你所见，答案是肯定的；这个函数可能会抛出异常。这是因为我们没有用`noexcept`标记`foo()`函数，正如前面的例子所述，函数默认可以抛出异常。
- en: It should also be noted that we added `!` to the `noexcept` expression. This
    is because `noexcept` returns `true` if the function is labeled `noexcept`, which
    means that the function is not allowed to throw. However, in our example, we are
    not asking whether the function cannot throw, but instead we are asking whether
    the function can throw, hence the logical Boolean reversal.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该注意到我们在`noexcept`表达式中添加了`!`。这是因为如果函数被标记为`noexcept`，`noexcept`会返回`true`，这意味着函数不允许抛出异常。然而，在我们的例子中，我们询问的不是函数是否不会抛出异常，而是函数是否可能抛出异常，因此需要逻辑布尔反转。
- en: 'Let''s expand upon this by adding a couple more functions to our example. Specifically,
    in the following example, we will add some functions that throw as well as some
    functions that are labeled `noexcept`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在我们的例子中添加一些函数来扩展这一点。具体来说，在下面的例子中，我们将添加一些会抛出异常的函数以及一些被标记为`noexcept`的函数：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This results in the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/6c634422-311e-40ae-a7f8-e20aa940f7a4.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c634422-311e-40ae-a7f8-e20aa940f7a4.png)'
- en: As shown in the preceding example, if a function is labeled with `noexcept`,
    the `noexcept` operator returns `true` (which, in our example, outputs `false`).
    More importantly, a keen observer would notice that the functions that throw exceptions
    do not change the output of the `noexcept` operator. That is, the `noexcept` operator
    returns `false` if a function *can* throw an exception, not if it *will* throw
    an exception. This is important as the only way to know whether a function *will*
    throw an exception is to execute it. The only thing the `noexcept` specifier states
    is whether or not an exception is allowed to be thrown by the function. It doesn't
    state whether or not an exception *will* be thrown. By extension, the `noexcept`
    operator doesn't tell you whether the function *will* throw or not but instead
    tells you whether the function is labeled with the `noexcept` specifier (and,
    more importantly, what the `noexcept` specifier evaluates to).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果一个函数被标记为`noexcept`，`noexcept`操作符会返回`true`（在我们的例子中输出为`false`）。更重要的是，敏锐的观察者会注意到抛出异常的函数并不会改变`noexcept`操作符的输出。也就是说，如果一个函数*可以*抛出异常，`noexcept`操作符会返回`false`，而不是*会*抛出异常。这一点很重要，因为唯一能知道一个函数*会*抛出异常的方法就是执行它。`noexcept`指定符唯一说明的是函数是否允许抛出异常。它并不说明是否*会*抛出异常。同样，`noexcept`操作符并不能告诉你函数*会*抛出异常与否，而是告诉你函数是否被标记为`noexcept`（更重要的是，`noexcept`指定符的求值结果）。
- en: 'Before we attempt to use the `noexcept` specifier in a more realistic example,
    let''s look at the following example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试在更现实的例子中使用`noexcept`指定符之前，让我们看下面的例子：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As shown in the preceding example, we have defined a `foo()` function that
    throws, and then we call this function from our main function, resulting in `std::terminate()`
    being called because we didn''t handle the exception before leaving the program.
    In a more complicated setting, we might not know whether `foo()` throws or not,
    and, as a result, we may not want to add the additional overhead of exception
    handling if it is not needed. To better explain this, let''s examine the resulting
    assembly code for the `main()` function for this example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，我们定义了一个会抛出异常的`foo()`函数，然后从我们的主函数中调用这个函数，导致调用`std::terminate()`，因为我们在离开程序之前没有处理异常。在更复杂的情况下，我们可能不知道`foo()`是否会抛出异常，因此可能不希望在不需要的情况下添加额外的异常处理开销。为了更好地解释这一点，让我们检查这个例子中`main()`函数的汇编代码：
- en: '![](img/8741e7cf-194c-44e7-84c5-b48af8c04011.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8741e7cf-194c-44e7-84c5-b48af8c04011.png)'
- en: As you can see, the `main` function is simple and doesn't contain any additional
    logic outside of calling the `foo` function. Specifically, the `main` function
    doesn't have any catch logic in it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`main`函数很简单，除了调用`foo`函数外没有其他逻辑。具体来说，`main`函数中没有任何捕获逻辑。
- en: 'Now, let''s use the `noexcept` operator in a more concrete example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在一个更具体的例子中使用`noexcept`操作符：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As shown in the preceding example, we use the `noexcept` operator in conjunction
    with the `constepxr` operator in the `if` statement that was added in C++17\.
    This allows us to ask the compiler whether `foo()` is allowed to throw. If it
    is, we execute the `foo()` function inside a `try`/`catch` block so that we can
    handle any possible exceptions as needed. If we examine the assembly of this function,
    as shown in the following screenshot, we can see that some additional `catch`
    logic was added to the resulting binary to handle the exceptions as needed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，我们在C++17中添加的`if`语句中使用了`noexcept`操作符和`constepxr`操作符。这使我们能够询问编译器`foo()`是否允许抛出异常。如果允许，我们在`try`/`catch`块中执行`foo()`函数，以便根据需要处理任何可能的异常。如果我们检查这个函数的汇编代码，如下面的截图所示，我们可以看到一些额外的`catch`逻辑被添加到生成的二进制文件中，以根据需要处理异常：
- en: '![](img/49f6bfba-8bae-40ba-8987-e352f7b9625c.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49f6bfba-8bae-40ba-8987-e352f7b9625c.png)'
- en: 'Now, let''s take this same example one step further by stating that the `foo()`
    function is not allowed to throw using the `noexcept` specifier:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进一步说明，使用`noexcept`指定符来声明`foo()`函数不允许抛出异常：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As shown in the preceding example, the program calls `std::terminate()` since
    the `foo()` function was labeled `noexcept`. Furthermore, if we look at the resulting
    assembly, we can see that the `main()` function no longer contains the additional
    `try`/`catch` logic, which means that our optimization worked:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，程序调用了`std::terminate()`，因为`foo()`函数被标记为`noexcept`。此外，如果我们查看生成的汇编代码，我们可以看到`main()`函数不再包含额外的`try`/`catch`逻辑，这意味着我们的优化起作用了：
- en: '![](img/2d0478f9-51e3-4438-b303-7d4872bf5a80.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2d0478f9-51e3-4438-b303-7d4872bf5a80.png)'
- en: 'Finally, we might possibly not know how to label our own function if we do
    not know whether a function that was called can throw or not. Let''s look at the
    following example to demonstrate this issue:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们不知道被调用的函数是否会抛出异常，可能无法正确标记自己的函数。让我们看下面的例子来演示这个问题：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This results in the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下结果：
- en: '![](img/5c98505b-2992-4bc6-a927-e4eb3315fd00.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c98505b-2992-4bc6-a927-e4eb3315fd00.png)'
- en: As shown in the preceding example, the `foo1()` function is not labeled with
    the `noexcept` specifier, which means it is allowed to throw an exception. In
    `foo2()`, we want to ensure that our `noexcept` specifier is correct but we call
    `foo1()`, and, in this example, we assume that we don't know whether `foo1()`
    is `noexcept` or not.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，`foo1()`函数没有使用`noexcept`指定符标记，这意味着它允许抛出异常。在`foo2()`中，我们希望确保我们的`noexcept`指定符是正确的，但我们调用了`foo1()`，在这个例子中，我们假设我们不知道`foo1()`是否是`noexcept`。
- en: To ensure `foo2()` is labeled properly, we combine the lessons learned in this
    recipe and the previous one to mark the function properly. Specifically, we use
    the `noexcept` operator to tell us whether the `foo1()` function will throw, and
    then we use the `noexcept` specifier's Boolean expression syntax to use the results
    of the `noexcept` operator to label `foo2()` as `noexcept` or not. If `foo1()`
    is labeled with `noexcept`, the `noexcept` operator will return `true`, resulting
    in `foo2()` being marked as `noexcept(true)`, which is the same as simply stating
    `noexcept`. If `foo1()` is not labeled as `noexcept`, the `noexcept` operator
    will return `false`, in which case the `noexcept` specifier will be labeled as
    `noexcept(false)`, which is the same as not adding the `noexcept` specifier (that
    is, the function is allowed to throw an exception).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保`foo2()`被正确标记，我们结合了本示例和上一个示例中学到的知识来正确标记函数。具体来说，我们使用`noexcept`运算符来告诉我们`foo1()`函数是否会抛出异常，然后我们使用`noexcept`指定符的布尔表达式语法来使用`noexcept`运算符的结果来标记`foo2()`是否为`noexcept`。如果`foo1()`被标记为`noexcept`，`noexcept`运算符将返回`true`，导致`foo2()`被标记为`noexcept(true)`，这与简单地声明`noexcept`相同。如果`foo1()`没有被标记为`noexcept`，`noexcept`运算符将返回`false`，在这种情况下，`noexcept`指定符将被标记为`noexcept(false)`，这与不添加`noexcept`指定符相同（即，函数允许抛出异常）。
- en: Using RAII
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RAII
- en: RAII is a programming principle that states that a resource is tied to the lifetime
    of the object that acquired the resource. RAII is a powerful feature of the C++
    language that really helps to set C++ apart from C, helping to prevent resource
    leaks and general instability.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: RAII是一种编程原则，它规定资源与获取资源的对象的生命周期绑定。RAII是C++语言的一个强大特性，它真正有助于将C++与C区分开来，有助于防止资源泄漏和一般不稳定性。
- en: In this recipe, we will dive into how RAII works and how RAII can be used to
    ensure that C++ exceptions do not introduce resource leaks. RAII is a critical
    technology for any C++ application and should be used whenever possible.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将深入探讨RAII的工作原理以及如何使用RAII来确保C++异常不会引入资源泄漏。RAII对于任何C++应用程序来说都是至关重要的技术，应该尽可能地使用。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例所需的适当工具。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'You need to perform the following steps to try the recipe:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行以下步骤来尝试这个示例：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中运行以下命令来下载源代码：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To compile the source code, run the following:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦源代码编译完成，您可以通过运行以下命令来执行本示例中的每个示例：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它们与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'To better understand how RAII works, we must first examine how a class in C++
    works as C++ classes are used to implement RAII. Let''s look at a simple example. C++
    classes provide support for both constructors and destructors as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解RAII的工作原理，我们必须首先研究C++中类的工作原理，因为C++类用于实现RAII。让我们看一个简单的例子。C++类提供了对构造函数和析构函数的支持，如下所示：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This results in the following when compiled and executed:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致编译和执行时的以下结果：
- en: '![](img/1991efef-e0b0-48f0-9c36-1a62bfbec715.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1991efef-e0b0-48f0-9c36-1a62bfbec715.png)'
- en: In the preceding example, we create a class with both a constructor and a destructor.
    When we create an instance of the class, the constructor is called, and, when
    the instance of the class loses scope, the class is destroyed. This is a simple
    C++ pattern that has been around since the initial versions of C++ were created
    by Bjarne Stroustrup. Under the hood, the compiler calls a construction function
    when the class is first instantiated, but, more importantly, the compiler has
    to inject code into the program that executes the destruction function when the
    instantiation of the class loses scope. The important thing to understand here
    is that this additional logic is inserted into the program automatically by the
    compiler for the programmer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们创建了一个既有构造函数又有析构函数的类。当我们创建类的实例时，构造函数被调用，当类的实例失去作用域时，类被销毁。这是一个简单的C++模式，自从Bjarne
    Stroustrup创建了最初的C++版本以来一直存在。在底层，编译器在类首次实例化时调用一个构造函数，但更重要的是，编译器必须向程序注入代码，当类的实例失去作用域时执行析构函数。这里需要理解的重要一点是，这个额外的逻辑是由编译器自动为程序员插入的。
- en: Before the introduction of the classes, the programmer had to add construction
    and destruction logic to the program manually, and, while construction is a fairly
    simple thing to get right, destruction is not. A classic example of this type
    of issue in C is storing a file handle. The programmer will add a call to an `open()`
    function to open the file handle and, when the file is done, will add a call to
    `close()` to close the file handle, forgetting to execute the `close()` function
    on all possible error cases that might crop up. This is inclusive of when the
    code is hundreds of lines long and someone new to the program adds another error
    case, forgetting also to call `close()` as needed.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入类之前，程序员必须手动向程序添加构造和析构逻辑，而构造是一个相当容易做到正确的事情，但析构却不是。在C中这种问题的一个经典例子是存储文件句柄。程序员会添加一个调用`open()`函数来打开文件句柄，当文件完成时，会添加一个调用`close()`来关闭文件句柄，忘记在可能出现的所有错误情况下执行`close()`函数。这包括当代码有数百行长，而程序的新成员添加了另一个错误情况，同样忘记根据需要调用`close()`。
- en: 'RAII solves this issue by ensuring that, once the class loses scope, the resource
    that was acquired is released, no matter what the control-flow path was. Let''s
    look at the following example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: RAII通过确保一旦类失去作用域，所获取的资源就会被释放，解决了这个问题，无论控制流路径是什么。让我们看下面的例子：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we allocate an integer and initialize it in the constructor
    of a class. The important thing to notice here is that we do not need to check
    for `nullptr` from the `new` operator. This is because the `new` operator will
    throw an exception if the memory allocation fails. If this occurs, not only will
    the rest of the constructor not be executed, but the object itself will not be
    constructed. This means if the constructor successfully executed, you know that
    the instance of the class is in a valid state and actually contains a resource
    that will be destroyed when the instance of the class loses scope
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在类的构造函数中分配一个整数并对其进行初始化。这里需要注意的重要一点是，我们不需要从`new`运算符中检查`nullptr`。这是因为如果内存分配失败，`new`运算符会抛出异常。如果发生这种情况，不仅构造函数的其余部分不会被执行，而且对象本身也不会被构造。这意味着如果构造函数成功执行，你就知道类的实例处于有效状态，并且实际上包含一个在类的实例失去作用域时将被销毁的资源。
- en: The destructor of the class then outputs to `stdout` and deletes the previously
    allocated memory. The important thing to understand here is that, no matter what
    control path the code takes, this resource will be released when the instance
    of the class loses scope. The programmer only needs to worry about the lifetime
    of the class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，类的析构函数输出到`stdout`并删除先前分配的内存。这里需要理解的重要一点是，无论代码采取什么控制路径，当类的实例失去作用域时，这个资源都将被释放。程序员只需要担心类的生命周期。
- en: 'This idea that the lifetime of the resource is directly tied to the lifetime
    of the object that allocated the resource is important as it solves a complicated
    issue for the control flow of a program in the presence of C++ exceptions. Let''s
    look at the following example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的生命周期与分配资源的对象的生命周期直接相关的这个想法很重要，因为它解决了在C++异常存在的情况下程序的控制流的一个复杂问题。让我们看下面的例子：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, we create the same class as the previous example, but, in our
    `foo()` function, we throw an exception. The `foo()` function, however, doesn't
    need to catch this exception to ensure that the memory allocated is properly freed.
    Instead, the destructor handles this for us. In C++, many functions might throw
    and, without RAII, every single function that could throw would need to be wrapped
    in a `try`/`catch` block to ensure that any resources that were allocated are
    properly freed. We, in fact, see this pattern a lot in C code, especially in kernel-level
    programming where `goto` statements are used to ensure that, within a function,
    if an error occurs, the function can properly unwind itself to release any resources
    might have previously been acquired. This result is a nest of code dedicated to
    checking the result of every function call within the program and the logic needed
    to properly handle the error.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了与上一个例子相同的类，但是在我们的`foo()`函数中，我们抛出了一个异常。然而，`foo()`函数不需要捕获这个异常来确保分配的内存被正确释放。相反，析构函数会为我们处理这个问题。在C++中，许多函数可能会抛出异常，如果没有RAII，每个可能抛出异常的函数都需要被包裹在`try`/`catch`块中，以确保任何分配的资源都被正确释放。事实上，在C代码中，我们经常看到这种模式，特别是在内核级编程中，使用`goto`语句来确保在函数内部，如果发生错误，函数可以正确地释放之前获取的任何资源。结果就是代码的嵌套，专门用于检查程序中每个函数调用的结果和正确处理错误所需的逻辑。
- en: With this type of programming model, it's no wonder that resource leaks are
    so common in C. RAII combined with C++ exceptions remove the need for this error-prone
    logic, resulting in code that is less likely to leak resources.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这种类型的编程模型，难怪资源泄漏在C中如此普遍。RAII与C++异常结合消除了这种容易出错的逻辑，从而使代码不太可能泄漏资源。
- en: How RAII is handled in the presence of C++ exceptions is outside the scope of
    this book as it requires a deeper dive into how C++ exception support is implemented.
    The important thing to remember is that C++ exceptions are faster than checking
    the return value of a function for an error (as C++ exceptions are implemented
    using a no overhead algorithm) but are slow when an actual exception is thrown
    (as the program has to unwind the stack and properly execute each class destructor
    as needed). For this reason, and others such as maintainability, C++ exceptions
    should never be used for valid control flow.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++异常存在的情况下如何处理RAII超出了本书的范围，因为这需要更深入地了解C++异常支持是如何实现的。重要的是要记住，C++异常比检查函数的返回值是否有错误更快（因为C++异常是使用无开销算法实现的），但当实际抛出异常时速度较慢（因为程序必须解开堆栈并根据需要正确执行每个类的析构函数）。因此，出于这个原因以及其他原因，比如可维护性，C++异常不应该用于有效的控制流。
- en: 'Another way that RAII can be used is the `finally` pattern, which is provided
    by the C++ **Guideline Support Library** (**GSL**). The `finally` pattern leverages
    the destructor-only portion of RAII to provide a simple mechanism to perform non-resource-based
    cleanup when the control flow of a function is complicated or could throw. Consider
    the following example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: RAII的另一种用法是`finally`模式，它由C++ **指导支持库** (**GSL**) 提供。`finally`模式利用了RAII的仅析构函数部分，提供了一个简单的机制，在函数的控制流复杂或可能抛出异常时执行非基于资源的清理。考虑以下例子：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding example, we create a class that is capable of storing a lambda
    function that is executed when an instance of the `finally` class loses scope.
    In this particular case, we output to `stdout` when the `finally` class is destroyed.
    Although this uses a pattern similar to that of RAII, this technically is not
    RAII as no resource has been acquired.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个能够存储在`finally`类实例失去作用域时执行的lambda函数的类。在这种特殊情况下，当`finally`类被销毁时，我们输出到`stdout`。尽管这使用了类似于RAII的模式，但从技术上讲，这不是RAII，因为没有获取任何资源。
- en: Also, if a resource does need to be acquired, RAII should be used instead of
    the `finally` pattern. The `finally` pattern, instead, is useful when you are
    not acquiring a resource but want to execute code when a function returns no matter
    what control flow path the program takes (a conditional branch or C++ exception).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果确实需要获取资源，应该使用RAII而不是`finally`模式。`finally`模式则在不获取资源但希望在函数返回时执行代码时非常有用（无论程序采取什么控制流路径，条件分支或C++异常）。
- en: 'To demonstrate this, let''s look at a more complicated example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，让我们看一个更复杂的例子：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When executed, we get the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，我们得到以下结果：
- en: '![](img/974fa02a-a5bd-462b-aa43-3951b03d15dc.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/974fa02a-a5bd-462b-aa43-3951b03d15dc.png)'
- en: In the preceding example, we want to ensure that we always output to `stdout`
    no matter what the code does. In the middle of execution, we throw an exception,
    and even though the exception was thrown, our `finally` code is executed as intended.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们希望无论代码做什么，都能始终输出到`stdout`。在执行过程中，我们抛出了一个异常，尽管抛出了异常，我们的`finally`代码仍然按预期执行。
- en: Learning why to never throw exceptions in destructors
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习为什么永远不要在析构函数中抛出异常
- en: In this recipe, we will discuss the issues with C++ exceptions, specifically
    in regard to throwing exceptions within a class destructor, something that should
    be avoided at all costs. The lessons learned in this recipe are important because,
    unlike other functions, a C++ class destructor is marked as `noexcept` by default,
    which means that if you accidentally throw an exception inside a class destructor,
    your program will call `std::terminate()`, even though the destructor my not be
    overtly labeled `noexcept`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将讨论C++异常的问题，特别是在类析构函数中抛出异常的问题，这是应该尽量避免的。这个食谱中学到的经验很重要，因为与其他函数不同，C++类析构函数默认标记为`noexcept`，这意味着如果你在类析构函数中意外地抛出异常，你的程序将调用`std::terminate()`，即使析构函数没有明确标记为`noexcept`。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher, and run the following in a Terminal
    window:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请确保满足所有的技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有适当的工具来编译和执行本食谱中的示例。完成后，打开一个新的终端。我们将使用这个终端来下载、编译和运行我们的示例。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to try the recipe:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来尝试这个食谱：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中运行以下命令来下载源代码：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To compile the source code, run the following:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令在本食谱中执行每个示例：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐步介绍这些示例，并解释每个示例程序的作用以及它与本食谱中教授的课程的关系。
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we will learn why throwing exceptions in a destructor is a
    *bad* idea, and why class destructors are labeled as `noexcept` by default. To
    start, let''s look at a simple example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习为什么在析构函数中抛出异常是一个*糟糕*的想法，以及为什么类析构函数默认标记为`noexcept`。首先，让我们看一个简单的例子：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When we execute this, we get the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这个时，我们得到以下结果：
- en: '![](img/3d30c668-41a6-430a-8fc4-a95a1da1f660.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d30c668-41a6-430a-8fc4-a95a1da1f660.png)'
- en: In this example, we can see that if we throw an exception from a class destructor,
    `std::terminate()` is called. This is because, by default, a class destructor
    is marked as `noexcept`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到，如果我们从类析构函数中抛出异常，将调用`std::terminate()`。这是因为，默认情况下，类析构函数被标记为`noexcept`。
- en: 'We can change this by explicitly allowing a class destructor to throw by marking
    the class''s destructor as `noexcept(false)`, as shown in the next example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将类的析构函数标记为`noexcept(false)`来明确允许类析构函数抛出异常，就像下一个例子中所示的那样：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As shown in the preceding example, when the class is destroyed, an exception
    is thrown and properly handled. Even though this was successfully handled, we
    have to ask ourselves, what is the state of the program after we catch this exception?
    The destructor didn't successfully complete. If this class was more complex and
    had state/resources that it was managing, can we conclude that the state/resources
    that we care about were properly handled/released? The short answer is no. This
    is the same as destroying a hard drive with a hammer. If you slam a hard drive
    with a hammer to destroy it, did you actually destroy the data on the hard drive?
    There is no way to know because, when you hit the hard drive with the hammer,
    you broke the electronics that would have been used to answer that very question.
    When you attempt to destroy a hard drive, you need a reliable process that ensures
    that, under no circumstance could the process of destroying the drive leave data
    in a recoverable state. Otherwise, you have no way of knowing what state you are
    in, with no way of going back.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，当销毁类时，会抛出异常并得到正确处理。即使这个异常被成功处理了，我们仍然要问自己，在捕获这个异常后程序的状态是什么？析构函数并没有成功完成。如果这个类更复杂，并且有状态/资源需要管理，我们能否得出结论，我们关心的状态/资源是否得到了正确处理/释放？简短的答案是否定的。这就像用锤子摧毁硬盘一样。如果你用锤子猛击硬盘来摧毁它，你真的摧毁了硬盘上的数据吗？没有办法知道，因为当你用锤子猛击硬盘时，你损坏了本来可以用来回答这个问题的电子设备。当你试图销毁硬盘时，你需要一个可靠的过程，确保在任何情况下都不会使销毁硬盘的过程留下可恢复的数据。否则，你无法知道自己处于什么状态，也无法回头。
- en: The same applies to C++ classes. Destroying a C++ class needs to be an operation
    that must provide basic exception safety (that is, the state of the program is
    deterministic with some possible side effects). Otherwise, the only other logical
    course of action is to call `std::terminate()` since you cannot be sure what will
    happen if the program continues to execute.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于C++类。销毁C++类必须是一个必须提供基本异常安全性的操作（即，程序的状态是确定性的，可能会有一些副作用）。否则，唯一的逻辑行为是调用`std::terminate()`，因为你无法确定程序继续执行会发生什么。
- en: 'Besides putting the program in an undefined state, the other issue with throwing
    an exception from a destructor is, what happens if an exception has already been
    thrown? What does the `try`/`catch` block catch? Let''s look at an example of
    this type of issue:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将程序置于未定义状态之外，从析构函数中抛出异常的另一个问题是，如果已经抛出了异常会发生什么？`try`/`catch`块会捕获什么？让我们看一个这种类型问题的例子：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding example, we mark the destructor as `noexcept(false)` just
    like we did in the previous example, but we throw before the destructor is called,
    which means that, when the destructor is called, there is already an exception
    being processed. Now, when we attempt to throw, `std::terminate()` is called even
    though the destructor was marked as `noexcept(false)`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们像在前一个例子中一样将析构函数标记为`noexcept(false)`，但是在调用析构函数之前抛出异常，这意味着当调用析构函数时，已经有一个异常正在被处理。现在，当我们尝试抛出异常时，即使析构函数被标记为`noexcept(false)`，也会调用`std::terminate()`：
- en: '![](img/afeb2214-83a3-4320-bc7d-abea44492169.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afeb2214-83a3-4320-bc7d-abea44492169.png)'
- en: 'The reason for this is the C++ library has no way of handling this situation
    because the `try`/`catch` block cannot handle more than one exception. It is possible,
    however, to have more than one pending exception; we simply need a `try`/`catch`
    block to handle each exception. This situation occurs when we have nested exceptions,
    as in this example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为C++库无法处理这种情况，因为`try`/`catch`块无法处理多个异常。然而，可以有多个待处理的异常；我们只需要一个`try`/`catch`块来处理每个异常。当我们有嵌套异常时，就会出现这种情况，就像这个例子一样：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this example, we will start by creating a class that outputs the results
    of calling `std::uncaught_exceptions()`, which returns the total number of exceptions
    currently being processed. We will then create a second class that creates the
    first class and then throws from its destructor, with the important note that
    all of the code in the destructor is wrapped in a `try`/`catch` block:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将首先创建一个类，输出调用`std::uncaught_exceptions()`的结果，该函数返回当前正在处理的异常总数。然后我们将创建一个第二个类，创建第一个类，然后从其析构函数中抛出异常，重要的是要注意，析构函数中的所有代码都包裹在一个`try`/`catch`块中：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When this example is executed, we get the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此示例时，我们得到以下结果：
- en: '![](img/afcfefea-5caa-45ba-8cb6-817eb3023c2f.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/afcfefea-5caa-45ba-8cb6-817eb3023c2f.png)'
- en: Finally, we will create this second class and throw again with another `try`/`catch`
    block. Unlike the previous example, all of the exceptions are being properly handled,
    and, in fact, `noexcept(false)` is not needed to ensure that this code executes
    properly as, for each exception that is thrown, we have a `try`/`catch` block.
    Even though an exception was thrown inside a destructor, it was properly handled,
    which means that the destructor executes safely and remains `noexcept`-compliant,
    even though the second class is executing in the presence of the two exceptions
    being processed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建第二个类，并再次使用另一个`try`/`catch`块抛出异常。与前一个例子不同的是，所有的异常都被正确处理了，实际上，不需要`noexcept(false)`来确保这段代码的正常执行，因为对于每个抛出的异常，我们都有一个`try`/`catch`块。即使在析构函数中抛出了异常，它也被正确处理了，这意味着析构函数安全地执行并保持了`noexcept`的兼容性，即使第二个类在处理两个异常的情况下执行。
- en: Easily creating your own exception classes
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轻松创建自己的异常类
- en: In this recipe, you will learn how to easily create your own exception types.
    This is an important lesson to learn as, although C++ exceptions are easy to create
    yourself, some guidelines should be followed to ensure this is done safely.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您将学习如何轻松创建自己的异常类型。这是一个重要的课程，因为尽管C++异常很容易自己创建，但应遵循一些准则以确保安全地完成这些操作。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before beginning, please ensure that all of the technical requirements are
    met, including installing Ubuntu 18.04 or higher and running the following in
    a Terminal window:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 开始之前，请确保满足所有技术要求，包括安装Ubuntu 18.04或更高版本，并在终端窗口中运行以下命令：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will ensure your operating system has the proper tools to compile and execute
    the examples in this recipe. Once this is complete, open a new Terminal. We will
    use this Terminal to download, compile, and run our examples.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保您的操作系统具有编译和执行本示例所需的适当工具。完成后，打开一个新的终端。我们将使用此终端来下载、编译和运行示例。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Perform the following steps to try the recipe:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤尝试本示例：
- en: 'From a new Terminal, run the following to download the source code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新的终端中运行以下命令以下载源代码：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To compile the source code, run the following:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译源代码，请运行以下命令：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once the source code is compiled, you can execute each example in this recipe
    by running the following commands:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码编译完成后，您可以通过运行以下命令来执行本示例中的每个示例：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将逐个介绍这些示例，并解释每个示例程序的作用以及它与本示例中所教授的课程的关系。
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Creating your own C++ exceptions allows you to filter out what type of exception
    you are getting. For example, did the exception come from your code or the C++
    library? By creating your own C++ exceptions, you can easily answer these questions
    during runtime in your own code. Let''s look at the following example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的C++异常允许您过滤出您所获得的异常类型。例如，异常是来自您的代码还是C++库？通过创建自己的C++异常，您可以在运行时轻松回答这些问题。让我们看下面的例子：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As shown in the preceding example, we create our own C++ exception by inheriting
    `std::exception`. This is not a requirement. Technically, anything can be a C++
    exception including an integer. Starting from `std::exception`, however, gives
    you a standard interface to work from including overriding the `what()` function,
    which describes the exception that was thrown.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如上例所示，我们通过继承`std::exception`创建了自己的C++异常。这不是必需的。从技术上讲，任何东西都可以是C++异常，包括整数。然而，从`std::exception`开始，可以为您提供一个标准接口，包括重写`what()`函数，描述抛出的异常。
- en: In this preceding example, we return a hardcoded string in the `what()` function.
    This is the ideal type of exception (even more so than the exceptions that are
    provided by the C++ library). This is because this type of exception is `nothrow
    copy-constructable`. Specifically, this means that the exception itself can be
    copied without the copy generating an exception, for example, due to `std::bad_alloc`.
    The exception types provided by the C++ library support construction from `std::string()`,
    which could throw `std::bad_alloc`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们在`what()`函数中返回了一个硬编码的字符串。这是理想的异常类型（甚至比C++库提供的异常更理想）。这是因为这种类型的异常是`nothrow
    copy-constructable`。具体来说，这意味着异常本身可以被复制，而复制不会引发异常，例如由于`std::bad_alloc`。C++库提供的异常类型支持从`std::string()`构造，这可能会引发`std::bad_alloc`。
- en: 'The issue with the preceding C++ exception is that you would need `1` exception
    type for every type of message you wish to provide. Another way to implement a
    safe exception type is to use the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 上述C++异常的问题在于，您需要为每种消息类型提供`1`种异常类型。实现安全异常类型的另一种方法是使用以下方法：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding example, we store a pointer to `const char*` (that is, a C-style
    string). C-style strings are stored globally as constants within the program.
    This type of exception satisfies all of the same preceding rules, and no allocations
    are taking place during the construction of the exception. It should also be noted
    that, since the strings are stored globally, this type of operation is safe.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们存储了指向`const char*`（即C风格字符串）的指针。C风格字符串作为常量存储在程序中。这种类型的异常满足了所有先前的规则，并且在构造异常期间不会发生任何分配。还应该注意，由于字符串是全局存储的，这种操作是安全的。
- en: 'Many types of exceptions can be created using this approach, including things
    other than strings that are accessible through custom getters (that is, without
    having to use the `what()` function). If, however, these preceding rules are not
    an issue for you, the easiest way to create a custom C++ exception is to simply
    subclass an existing C++ exception such as `std::runtime_error()`, as in the following
    example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法可以创建许多类型的异常，包括通过自定义getter访问的字符串以外的其他内容（即，无需使用`what()`函数）。然而，如果这些先前的规则对您不是问题，创建自定义C++异常的最简单方法是简单地对现有的C++异常进行子类化，例如`std::runtime_error()`，如下例所示：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When this example is executed, we get the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此示例时，我们会得到以下结果：
- en: '![](img/a982b81c-4220-43df-82f3-73b32e54b2ae.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a982b81c-4220-43df-82f3-73b32e54b2ae.png)'
- en: In the preceding example, we create our own C++ exception in just a few lines
    of code by subclassing `std::runtime_error()`. We can then use different `catch`
    blocks to figure out what type of exception was thrown. Just remember that if
    you use the `std::string` version of `std::runtime_error()`, you could end up
    with `std::bad_alloc` being thrown during the construction of the exception itself.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们通过对`std::runtime_error()`进行子类化，仅用几行代码就创建了自己的C++异常。然后，我们可以使用不同的`catch`块来确定抛出了什么类型的异常。只需记住，如果您使用`std::runtime_error()`的`std::string`版本，您可能会在异常本身的构造过程中遇到`std::bad_alloc`的情况。
