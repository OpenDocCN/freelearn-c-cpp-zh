["```cpp\n0000000000000000000000000000000000000000000000 \n0000000000000000000000000000000000000000000000 \n0000000000000000000000000000000000000000000000 \n0000000000000000000000000000000000000000000000 \n0000000000000000000000000000000000000000000000 \n0000000000000000000000000000000000000000000000 \n1111111111000111111222222221111133111111111411 \n0000000000000000001222222221000133100000001110 \n0000000000000000001222222221000133100000000000 \n0000000000000000001222222221000133100000000000 \n0000000000000000001111111111000111100000000000 \n\n```", "```cpp\n#pragma once \n\n#include <SFML/Graphics.hpp> \nusing namespace sf; \nusing namespace std; \n\nclass LevelManager \n{ \nprivate: \n   Vector2i m_LevelSize; \n   Vector2f m_StartPosition; \n   float m_TimeModifier = 1; \n   float m_BaseTimeLimit = 0; \n   int m_CurrentLevel = 0; \n   const int NUM_LEVELS = 4; \n\n// public declarations go here \n\n```", "```cpp\npublic: \n\n   const int TILE_SIZE = 50; \n   const int VERTS_IN_QUAD = 4; \n\n   float getTimeLimit(); \n\n   Vector2f getStartPosition(); \n\n   int** nextLevel(VertexArray& rVaLevel); \n\n   Vector2i getLevelSize(); \n\n   int getCurrentLevel(); \n\n}; \n\n```", "```cpp\n#include \"stdafx.h\" \n#include <SFML/Graphics.hpp> \n#include <SFML/Audio.hpp> \n#include \"TextureHolder.h\" \n#include <sstream> \n#include <fstream> \n#include \"LevelManager.h\" \n\nusing namespace sf; \nusing namespace std; \n\nint** LevelManager::nextLevel(VertexArray& rVaLevel) \n{ \n   m_LevelSize.x = 0; \n   m_LevelSize.y = 0; \n\n   // Get the next level \n   m_CurrentLevel++; \n   if (m_CurrentLevel > NUM_LEVELS) \n   { \n      m_CurrentLevel = 1; \n      m_TimeModifier -= .1f; \n   } \n\n   // Load the appropriate level from a text file \n   string levelToLoad; \n   switch (m_CurrentLevel) \n   { \n\n   case 1: \n      levelToLoad = \"levels/level1.txt\"; \n      m_StartPosition.x = 100; \n      m_StartPosition.y = 100; \n      m_BaseTimeLimit = 30.0f; \n      break; \n\n   case 2: \n      levelToLoad = \"levels/level2.txt\"; \n      m_StartPosition.x = 100; \n      m_StartPosition.y = 3600; \n      m_BaseTimeLimit = 100.0f; \n      break; \n\n   case 3: \n      levelToLoad = \"levels/level3.txt\"; \n      m_StartPosition.x = 1250; \n      m_StartPosition.y = 0; \n      m_BaseTimeLimit = 30.0f; \n      break; \n\n   case 4: \n      levelToLoad = \"levels/level4.txt\"; \n      m_StartPosition.x = 50; \n      m_StartPosition.y = 200; \n      m_BaseTimeLimit = 50.0f; \n      break; \n\n   }// End switch \n\n```", "```cpp\n   ifstream inputFile(levelToLoad); \n   string s; \n\n   // Count the number of rows in the file \n   while (getline(inputFile, s)) \n   { \n      ++m_LevelSize.y; \n   } \n\n   // Store the length of the rows \n   m_LevelSize.x = s.length(); \n\n```", "```cpp\n   // Go back to the start of the file \n   inputFile.clear(); \n   inputFile.seekg(0, ios::beg); \n\n   // Prepare the 2d array to hold the int values from the file \n   int** arrayLevel = new int*[m_LevelSize.y]; \n   for (int i = 0; i < m_LevelSize.y; ++i) \n   { \n      // Add a new array into each array element \n      arrayLevel[i] = new int[m_LevelSize.x]; \n   } \n\n```", "```cpp\n    // Loop through the file and store all the values in the 2d array \n   string row; \n   int y = 0; \n   while (inputFile >> row) \n   { \n      for (int x = 0; x < row.length(); x++) { \n\n         const char val = row[x]; \n         arrayLevel[y][x] = atoi(&val); \n      } \n\n      y++; \n   } \n\n   // close the file \n   inputFile.close(); \n\n```", "```cpp\n   // What type of primitive are we using? \n   rVaLevel.setPrimitiveType(Quads); \n\n   // Set the size of the vertex array \n   rVaLevel.resize(m_LevelSize.x * m_LevelSize.y * VERTS_IN_QUAD); \n\n   // Start at the beginning of the vertex array \n   int currentVertex = 0; \n\n   for (int x = 0; x < m_LevelSize.x; x++) \n   { \n      for (int y = 0; y < m_LevelSize.y; y++) \n      { \n         // Position each vertex in the current quad \n         rVaLevel[currentVertex + 0].position =  \n            Vector2f(x * TILE_SIZE,  \n            y * TILE_SIZE); \n\n         rVaLevel[currentVertex + 1].position =  \n            Vector2f((x * TILE_SIZE) + TILE_SIZE,  \n            y * TILE_SIZE); \n\n         rVaLevel[currentVertex + 2].position =  \n            Vector2f((x * TILE_SIZE) + TILE_SIZE,  \n            (y * TILE_SIZE) + TILE_SIZE); \n\n         rVaLevel[currentVertex + 3].position =  \n            Vector2f((x * TILE_SIZE),  \n            (y * TILE_SIZE) + TILE_SIZE); \n\n         // Which tile from the sprite sheet should we use \n         int verticalOffset = arrayLevel[y][x] * TILE_SIZE; \n\n         rVaLevel[currentVertex + 0].texCoords =  \n            Vector2f(0, 0 + verticalOffset); \n\n         rVaLevel[currentVertex + 1].texCoords =  \n            Vector2f(TILE_SIZE, 0 + verticalOffset); \n\n         rVaLevel[currentVertex + 2].texCoords =  \n            Vector2f(TILE_SIZE, TILE_SIZE + verticalOffset); \n\n         rVaLevel[currentVertex + 3].texCoords =  \n            Vector2f(0, TILE_SIZE + verticalOffset); \n\n         // Position ready for the next four vertices \n         currentVertex = currentVertex + VERTS_IN_QUAD; \n      } \n   } \n\n   return arrayLevel; \n} // End of nextLevel function \n\n```", "```cpp\nVector2i LevelManager::getLevelSize() \n{ \n   return m_LevelSize; \n} \n\nint LevelManager::getCurrentLevel() \n{ \n   return m_CurrentLevel; \n} \n\nfloat LevelManager::getTimeLimit() \n{ \n   return m_BaseTimeLimit * m_TimeModifier; \n\n} \nVector2f LevelManager::getStartPosition() \n{ \n   return m_StartPosition; \n} \n\n```", "```cpp\n#pragma once \n#include <SFML/Graphics.hpp> \n#include \"TextureHolder.h\" \n#include \"Thomas.h\" \n#include \"Bob.h\" \n#include \"LevelManager.h\" \n\nusing namespace sf; \n\nclass Engine \n{ \nprivate: \n   // The texture holder \n   TextureHolder th; \n\n   // Thomas and his friend, Bob \n   Thomas m_Thomas; \n   Bob m_Bob; \n\n // A class to manage all the levels\n   LevelManager m_LM; \n\n   const int TILE_SIZE = 50; \n   const int VERTS_IN_QUAD = 4; \n\n   // The force pushing the characters down \n   const int GRAVITY = 300; \n\n   // A regular RenderWindow \n   RenderWindow m_Window; \n\n   // The main Views \n   View m_MainView; \n   View m_LeftView; \n   View m_RightView; \n\n   // Three views for the background \n   View m_BGMainView; \n   View m_BGLeftView; \n   View m_BGRightView; \n\n   View m_HudView; \n\n   // Declare a sprite and a Texture for the background \n   Sprite m_BackgroundSprite; \n   Texture m_BackgroundTexture; \n\n   // Is the game currently playing? \n   bool m_Playing = false; \n\n   // Is character 1 or 2 the current focus? \n   bool m_Character1 = true; \n\n   // Start in full screen mode \n   bool m_SplitScreen = false; \n\n   // How much time is left in the current level \n   float m_TimeRemaining = 10; \n   Time m_GameTimeTotal; \n\n   // Is it time for a new/first level? \n   bool m_NewLevelRequired = true; \n\n // The vertex array for the level tiles\n   VertexArray m_VALevel;\n   // The 2d array with the map for the level\n   // A pointer to a pointer\n   int** m_ArrayLevel =  NULL;\n   // Texture for the level tiles\n   Texture m_TextureTiles; \n   // Private functions for internal use only \n   void input(); \n   void update(float dtAsSeconds); \n   void draw();    \n\n // Load a new level\n   void loadLevel(); \n\npublic: \n   // The Engine constructor \n   Engine(); \n\n   ... \n   ...       \n   ... \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"Engine.h\" \n\nvoid Engine::loadLevel() \n{ \n   m_Playing = false; \n\n   // Delete the previously allocated memory \n   for (int i = 0; i < m_LM.getLevelSize().y; ++i) \n   { \n      delete[] m_ArrayLevel[i]; \n\n   } \n   delete[] m_ArrayLevel; \n\n   // Load the next 2d array with the map for the level \n   // And repopulate the vertex array as well \n   m_ArrayLevel = m_LM.nextLevel(m_VALevel); \n\n   // How long is this new time limit \n   m_TimeRemaining = m_LM.getTimeLimit(); \n\n   // Spawn Thomas and Bob \n   m_Thomas.spawn(m_LM.getStartPosition(), GRAVITY); \n   m_Bob.spawn(m_LM.getStartPosition(), GRAVITY); \n\n   // Make sure this code isn't run again \n   m_NewLevelRequired = false; \n} \n\n```", "```cpp\nEngine::Engine() \n{ \n   // Get the screen resolution and create an SFML window and View \n   Vector2f resolution; \n   resolution.x = VideoMode::getDesktopMode().width; \n   resolution.y = VideoMode::getDesktopMode().height; \n\n   m_Window.create(VideoMode(resolution.x, resolution.y), \n      \"Thomas was late\", \n      Style::Fullscreen); \n\n   // Initialize the full screen view \n   m_MainView.setSize(resolution); \n   m_HudView.reset( \n      FloatRect(0, 0, resolution.x, resolution.y)); \n\n   // Inititialize the split-screen Views \n   m_LeftView.setViewport( \n      FloatRect(0.001f, 0.001f, 0.498f, 0.998f)); \n\n   m_RightView.setViewport( \n      FloatRect(0.5f, 0.001f, 0.499f, 0.998f)); \n\n   m_BGLeftView.setViewport( \n      FloatRect(0.001f, 0.001f, 0.498f, 0.998f)); \n\n   m_BGRightView.setViewport( \n      FloatRect(0.5f, 0.001f, 0.499f, 0.998f)); \n\n   // Can this graphics card use shaders? \n   if (!sf::Shader::isAvailable()) \n   { \n      // Time to get a new PC \n      m_Window.close(); \n   } \n\n   m_BackgroundTexture = TextureHolder::GetTexture( \n      \"graphics/background.png\"); \n\n   // Associate the sprite with the texture \n   m_BackgroundSprite.setTexture(m_BackgroundTexture); \n\n // Load the texture for the background vertex array\n   m_TextureTiles = TextureHolder::GetTexture(\"graphics/tiles_sheet.png\"); \n} \n\n```", "```cpp\nvoid Engine::update(float dtAsSeconds) \n{ \n   if (m_NewLevelRequired) \n   { \n      // These calls to spawn will be moved to a new \n      // LoadLevel function soon \n      // Spawn Thomas and Bob \n //m_Thomas.spawn(Vector2f(0,0), GRAVITY);\n      //m_Bob.spawn(Vector2f(100, 0), GRAVITY); \n\n      // Make sure spawn is called only once \n //m_TimeRemaining = 10;\n      //m_NewLevelRequired = false;\n\n      // Load a level\n      loadLevel();        \n   } \n\n```", "```cpp\nvoid Engine::draw() \n{ \n   // Rub out the last frame \n   m_Window.clear(Color::White); \n\n   if (!m_SplitScreen) \n   { \n      // Switch to background view \n      m_Window.setView(m_BGMainView); \n      // Draw the background \n      m_Window.draw(m_BackgroundSprite); \n      // Switch to m_MainView \n      m_Window.setView(m_MainView);     \n\n // Draw the Level\n      m_Window.draw(m_VALevel, &m_TextureTiles); \n\n      // Draw thomas \n      m_Window.draw(m_Thomas.getSprite()); \n\n      // Draw thomas \n      m_Window.draw(m_Bob.getSprite()); \n   } \n   else \n   { \n      // Split-screen view is active \n\n      // First draw Thomas' side of the screen \n\n      // Switch to background view \n      m_Window.setView(m_BGLeftView); \n      // Draw the background \n      m_Window.draw(m_BackgroundSprite); \n      // Switch to m_LeftView \n      m_Window.setView(m_LeftView); \n\n // Draw the Level\n      m_Window.draw(m_VALevel, &m_TextureTiles); \n\n      // Draw thomas \n      m_Window.draw(m_Bob.getSprite()); \n\n      // Draw thomas \n      m_Window.draw(m_Thomas.getSprite()); \n\n      // Now draw Bob's side of the screen \n\n      // Switch to background view \n      m_Window.setView(m_BGRightView); \n      // Draw the background \n      m_Window.draw(m_BackgroundSprite); \n      // Switch to m_RightView \n      m_Window.setView(m_RightView); \n\n // Draw the Level\n     m_Window.draw(m_VALevel, &m_TextureTiles); \n\n      // Draw thomas \n      m_Window.draw(m_Thomas.getSprite()); \n\n      // Draw bob \n      m_Window.draw(m_Bob.getSprite()); \n\n   } \n\n   // Draw the HUD \n   // Switch to m_HudView \n   m_Window.setView(m_HudView); \n\n   // Show everything we have just drawn \n   m_Window.display(); \n} \n\n```", "```cpp\n   // Private functions for internal use only \n   void input(); \n   void update(float dtAsSeconds); \n   void draw(); \n\n   // Load a new level \n   void loadLevel(); \n\n // Run will call all the private functions\n   bool detectCollisions(PlayableCharacter& character); \n\npublic: \n   // The Engine constructor \n   Engine(); \n\n```", "```cpp\n#include \"stdafx.h\" \n#include \"Engine.h\" \n\nbool Engine::detectCollisions(PlayableCharacter& character) \n{ \n   bool reachedGoal = false; \n   // Make a rect for all his parts \n   FloatRect detectionZone = character.getPosition(); \n\n   // Make a FloatRect to test each block \n   FloatRect block; \n\n   block.width = TILE_SIZE; \n   block.height = TILE_SIZE; \n\n   // Build a zone around thomas to detect collisions \n   int startX = (int)(detectionZone.left / TILE_SIZE) - 1; \n   int startY = (int)(detectionZone.top / TILE_SIZE) - 1; \n   int endX = (int)(detectionZone.left / TILE_SIZE) + 2; \n\n   // Thomas is quite tall so check a few tiles vertically \n   int endY = (int)(detectionZone.top / TILE_SIZE) + 3; \n\n   // Make sure we don't test positions lower than zero \n   // Or higher than the end of the array \n   if (startX < 0)startX = 0; \n   if (startY < 0)startY = 0; \n   if (endX >= m_LM.getLevelSize().x) \n      endX = m_LM.getLevelSize().x; \n   if (endY >= m_LM.getLevelSize().y) \n      endY = m_LM.getLevelSize().y; \n\n```", "```cpp\n   // Has the character fallen out of the map? \n   FloatRect level(0, 0,  \n      m_LM.getLevelSize().x * TILE_SIZE,  \n      m_LM.getLevelSize().y * TILE_SIZE); \n\n   if (!character.getPosition().intersects(level)) \n   { \n      // respawn the character \n      character.spawn(m_LM.getStartPosition(), GRAVITY); \n   } \n\n```", "```cpp\n   // Loop through all the local blocks \n   for (int x = startX; x < endX; x++) \n   { \n      for (int y = startY; y < endY; y++) \n      { \n         // Initialize the starting position of the current block \n         block.left = x * TILE_SIZE; \n         block.top = y * TILE_SIZE; \n\n         // Has character been burnt or drowned? \n         // Use head as this allows him to sink a bit \n         if (m_ArrayLevel[y][x] == 2 || m_ArrayLevel[y][x] == 3) \n         { \n            if (character.getHead().intersects(block)) \n            { \n               character.spawn(m_LM.getStartPosition(), GRAVITY); \n               // Which sound should be played? \n               if (m_ArrayLevel[y][x] == 2)// Fire, ouch! \n               { \n                  // Play a sound \n\n               } \n               else // Water \n               { \n                  // Play a sound \n               } \n            } \n         } \n\n         // Is character colliding with a regular block \n         if (m_ArrayLevel[y][x] == 1) \n         { \n\n            if (character.getRight().intersects(block)) \n            { \n               character.stopRight(block.left); \n            } \n            else if (character.getLeft().intersects(block)) \n            { \n               character.stopLeft(block.left); \n            } \n\n            if (character.getFeet().intersects(block)) \n            { \n               character.stopFalling(block.top); \n            } \n            else if (character.getHead().intersects(block)) \n            { \n               character.stopJump(); \n            } \n         } \n\n         // More collision detection here once we have  \n         // learned about particle effects \n\n         // Has the character reached the goal? \n         if (m_ArrayLevel[y][x] == 4) \n         { \n            // Character has reached the goal \n            reachedGoal = true; \n         } \n\n      } \n\n   } \n\n```", "```cpp\n   // All done, return, whether or not a new level might be required \n   return reachedGoal; \n} \n\n```", "```cpp\nif (m_Playing) \n{ \n   // Update Thomas \n   m_Thomas.update(dtAsSeconds); \n\n   // Update Bob \n   m_Bob.update(dtAsSeconds); \n\n // Detect collisions and see if characters\n   // have reached the goal tile\n   // The second part of the if condition is only executed\n   // when thomas is touching the home tile\n   if (detectCollisions(m_Thomas) && detectCollisions(m_Bob))\n   {\n     // New level required\n     m_NewLevelRequired = true;\n     // Play the reach goal sound\n   }\n   else\n   {\n     // Run bobs collision detection\n     detectCollisions(m_Bob);\n   } \n\n   // Count down the time the player has left \n   m_TimeRemaining -= dtAsSeconds; \n\n   // Have Thomas and Bob run out of time? \n   if (m_TimeRemaining <= 0) \n   { \n      m_NewLevelRequired = true; \n   } \n\n}// End if playing \n\n```", "```cpp\nif (m_Playing) \n{ \n   // Update Thomas \n   m_Thomas.update(dtAsSeconds); \n\n   // Update Bob \n   m_Bob.update(dtAsSeconds); \n\n   // Detect collisions and see if characters\n   // have reached the goal tile \n   // The second part of the if condition is only executed \n   // when thomas is touching the home tile \n   if (detectCollisions(m_Thomas) && detectCollisions(m_Bob)) \n   { \n      // New level required \n      m_NewLevelRequired = true; \n\n      // Play the reach goal sound \n\n   } \n   else \n   { \n      // Run bobs collision detection \n      detectCollisions(m_Bob); \n   } \n\n // Let bob and thomas jump on each others heads\n   if (m_Bob.getFeet().intersects(m_Thomas.getHead()))\n   {\n     m_Bob.stopFalling(m_Thomas.getHead().top);\n   }\n   else if (m_Thomas.getFeet().intersects(m_Bob.getHead()))\n   {\n     m_Thomas.stopFalling(m_Bob.getHead().top);\n   } \n\n   // Count down the time the player has left \n   m_TimeRemaining -= dtAsSeconds; \n\n   // Have Thomas and Bob run out of time? \n   if (m_TimeRemaining <= 0) \n   { \n      m_NewLevelRequired = true; \n   } \n\n}// End if playing \n\n```"]