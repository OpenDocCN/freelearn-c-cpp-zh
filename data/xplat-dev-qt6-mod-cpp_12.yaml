- en: '*Chapter 9*: Testing and Debugging'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：测试和调试'
- en: Debugging and testing are essential parts of software development. In this chapter,
    you will learn how to debug Qt projects, about different debugging techniques,
    and about debuggers supported by Qt. Debugging is the process of discovering the
    root cause of an error or undesired behavior and resolving it. We will also discuss
    unit testing using the Qt Test framework. Qt Test is a unit testing framework
    for Qt-based applications and libraries. It has all of the features that most
    unit testing frameworks provide. Additionally, it provides support for testing
    **Graphical User Interfaces** (**GUIs**). This module helps in writing unit tests
    for Qt-based applications and libraries in a convenient way. You will also learn
    techniques to test a GUI using different GUI testing tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和测试是软件开发的重要部分。在本章中，您将学习如何调试Qt项目，不同的调试技术以及Qt支持的调试器。调试是发现错误或不良行为根本原因并解决它的过程。我们还将讨论使用Qt测试框架进行单元测试。Qt
    Test是一个用于Qt应用程序和库的单元测试框架。它具有大多数单元测试框架提供的所有功能。此外，它还提供了对**图形用户界面**（**GUI**）的支持。该模块有助于以方便的方式为基于Qt的应用程序和库编写单元测试。您还将学习使用不同GUI测试工具测试GUI的技术。
- en: 'Specifically, we will discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将讨论以下主题：
- en: Debugging in Qt
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Qt中调试
- en: Debugging strategies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试策略
- en: Debugging a C++ application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试C++应用程序
- en: Debugging a Qt Quick application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试Qt Quick应用程序
- en: Testing in Qt
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Qt中进行测试
- en: Integrating with Google's C++ testing framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Google的C++测试框架集成
- en: Testing Qt Quick applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Qt Quick应用程序
- en: GUI testing tools
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI测试工具
- en: By the end of this chapter, you will be familiar with debugging and testing
    techniques for your Qt application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将熟悉调试和测试技术，以用于您的Qt应用程序。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements for this chapter include minimum versions of Qt 6.0.0
    and Qt Creator 4.14.0 installed on the latest version of a desktop platform such
    as Windows 10, Ubuntu 20.04, or macOS 10.14\.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括在最新版本的桌面平台（如Windows 10、Ubuntu 20.04或macOS 10.14）上安装的Qt 6.0.0和Qt Creator
    4.14.0的最低版本。
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter09](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter09).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码都可以从以下GitHub链接下载：[https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter09](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter09)。
- en: Important note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The screenshots used in this chapter are taken from the Windows platform. You
    will see similar screens based on the underlying platform on your machine.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的屏幕截图来自Windows平台。您将在您的机器上基于底层平台看到类似的屏幕。
- en: Debugging in Qt
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Qt中调试
- en: In software development, technical problems arise often. To address these issues,
    we must first identify and resolve all of them before releasing our application
    to the public to maintain quality and our reputation. Debugging is a technique
    for locating these underlying technological issues.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，技术问题经常出现。为了解决这些问题，我们必须首先识别并解决所有问题，然后才能将应用程序发布到公众以保持质量和声誉。调试是一种定位这些潜在技术问题的技术。
- en: In the coming sections, we will discuss popular debugging techniques used by
    software engineers to ensure their software's stability and quality.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论软件工程师使用的流行调试技术，以确保其软件的稳定性和质量。
- en: Debuggers supported by Qt
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Qt支持的调试器
- en: 'Qt supports several different types of debuggers. The debugger you use can
    vary depending on the platform and compiler you''re using for your project. The
    following is a list of debuggers that are widely used with Qt:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Qt支持多种不同类型的调试器。您使用的调试器可能会因项目所用的平台和编译器而有所不同。以下是与Qt广泛使用的调试器列表：
- en: '**GNU Symbolic Debugger** (**GDB**) is a cross-platform debugger developed
    by the GNU Project.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GNU Symbolic Debugger**（**GDB**）是由GNU项目开发的跨平台调试器。'
- en: '**Microsoft Console Debugger** (**CDB**) is a debugger from Microsoft for Windows.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Microsoft Console Debugger**（**CDB**）是微软为Windows开发的调试器。'
- en: '**Low Level Virtual Machine Debugger** (**LLDB**) is a cross-platform debugger
    developed by the LLVM Developer group.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Low Level Virtual Machine Debugger**（**LLDB**）是由LLVM开发组开发的跨平台调试器。'
- en: '**QML/JavaScript Debugger** is a QML and JavaScript debugger provided by the
    Qt company.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QML/JavaScript Debugger**是Qt公司提供的QML和JavaScript调试器。'
- en: If you're using the MinGW compiler on Windows, you won't need to do any manual
    setup with GDB because it's typically included with your Qt installation. If you're
    using a different operating system, such as Linux, you may need to manually install
    it before linking it to Qt Creator. Qt Creator automatically detects the presence
    of the GDB and adds it to its debugger list.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows上使用MinGW编译器，则不需要对GDB进行任何手动设置，因为它通常包含在Qt安装中。如果您使用其他操作系统，如Linux，在将其链接到Qt
    Creator之前，您可能需要手动安装它。Qt Creator会自动检测GDB的存在并将其添加到其调试器列表中。
- en: You can also use `gdbserver` by specifying either `--vgdb=yes` or `--vgdb=full`.
    You can specify `--vgdb-error=number` to activate `gdbserver` after a certain
    number of errors are displayed. If you set the value to `0`, then `gdbserver`
    will be active at initialization, allowing you to set breakpoints before the application
    launches. It's worth noting that `vgdb` is included in the **Valgrind** distribution.
    It does not need to be installed separately.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过指定`--vgdb=yes`或`--vgdb=full`来使用`gdbserver`。您可以指定`--vgdb-error=number`来在显示一定数量的错误后激活`gdbserver`。如果将值设置为`0`，则`gdbserver`将在初始化时激活，允许您在应用程序启动之前设置断点。值得注意的是，`vgdb`包含在**Valgrind**发行版中。它不需要单独安装。
- en: If your favorite platform is Windows, you can install CDB on your machine. By
    default, the built-in debugger of Visual Studio won't be available. Therefore,
    you must install the CDB debugger separately by choosing debugging tools for Windows
    as an optional component when installing the Windows SDK. Qt Creator usually recognizes
    the existence of CDB and adds it to the debugger list under **Options**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢的平台是Windows，您可以在计算机上安装CDB。默认情况下，Visual Studio的内置调试器将不可用。因此，在安装Windows SDK时，您必须选择调试工具作为可选组件单独安装CDB调试器。Qt
    Creator通常会识别CDB的存在，并将其添加到**选项**下的调试器列表中。
- en: Android debugging is a little more challenging than debugging on a regular desktop
    environment. Different packages, such as JDK, Android SDK, and Android NDK, are
    required for Android development. On the desktop platform, you will need the **Android
    Debug Bridge** (**ADB**) driver to allow USB debugging. You must enable developer
    mode and accept USB debugging on the Android device to proceed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Android调试比在常规桌面环境中调试要困难一些。Android开发需要不同的软件包，如JDK、Android SDK和Android NDK。在桌面平台上，您需要**Android调试桥**（**ADB**）驱动程序来允许USB调试。您必须在Android设备上启用开发者模式并接受USB调试才能继续。
- en: The debugger used on macOS and iOS is **LLDB**. It is included with Xcode by
    default. Qt Creator will automatically detect its presence and link it with a
    kit. If you're familiar with debuggers and know what you're doing, you can also
    add non-GDB debuggers to your favorite IDE.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: macOS和iOS上使用的调试器是**LLDB**。它默认包含在Xcode中。Qt Creator将自动检测其存在并将其链接到一个工具包。如果您熟悉调试器并知道自己在做什么，还可以将非GDB调试器添加到您喜爱的IDE中。
- en: 'The debugger plugin determines a suitable native debugger for each package
    based on what''s available on your machine. You can overcome this preference by
    adding new debuggers. You can find the available debuggers in the **Debuggers**
    tab present under the **Kits** settings under the **Options** menu as shown in
    *Figure 9.1*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器插件根据计算机上可用的内容，为每个软件包确定合适的本地调试器。您可以通过添加新的调试器来克服这种偏好。您可以在**选项**菜单下的**Kits**设置中的**调试器**选项卡中找到可用的调试器，如*图9.1*所示：
- en: '![Figure 9.1 – The Debuggers tab under the Kits selection screen showing the
    Add button'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 - 选取屏幕下的调试器选项卡显示添加按钮'
- en: '](img/Figure_9.1_B16231.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B16231.jpg)'
- en: Figure 9.1 – The Debuggers tab under the Kits selection screen showing the Add
    button
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 - 选取屏幕下的调试器选项卡显示添加按钮
- en: In the **Debuggers** tab, you can see **Add**, **Clone**, and **Remove** buttons
    on the right side. You can clone an existing debugger configuration and modify
    it to suit your requirements. Alternatively, if you are aware of the debugger's
    details and configuration, then you can create a new debugger configuration using
    the **Add** button. You can also remove a faulty or obsolete debugger configuration
    by clicking the **Remove** button. Don't forget to click the **Apply** button
    to save your changes. Please note that you can't modify auto-detected debugger
    configurations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在**调试器**选项卡中，您可以在右侧看到**添加**、**克隆**和**删除**按钮。您可以克隆现有的调试器配置并修改以满足您的要求。或者，如果您了解调试器的详细信息和配置，那么您可以使用**添加**按钮创建新的调试器配置。您还可以通过单击**删除**按钮删除有问题或过时的调试器配置。不要忘记单击**应用**按钮以保存更改。请注意，您无法修改自动检测到的调试器配置。
- en: In this section, we learned about various supported debuggers. In the next section,
    we will discuss how to debug an application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了各种支持的调试器。在下一节中，我们将讨论如何调试应用程序。
- en: Debugging strategies
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试策略
- en: There are different debugging strategies to find the root cause of an issue.
    Before attempting to locate a bug in the application, it is critical to thoroughly
    understand the program or library. You can't find mistakes if you don't know what
    you're doing. Only if you have a thorough understanding of the system and how
    it operates will you be able to identify bugs in the application. Previous experience
    can aid in the detection of similar types of bugs as well as the resolution of
    bugs. The individual expert's knowledge determines how easily the developer can
    locate the bug. You can add debug print statements and breakpoints to analyze
    the flow of the program. You can do forward analysis or backward analysis to track
    the bug's location.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的调试策略来找到问题的根本原因。在尝试定位应用程序中的错误之前，深入了解程序或库至关重要。如果您不知道自己在做什么，就无法找到错误。只有对系统及其运行方式有深入了解，才能够识别应用程序中的错误。以往的经验可以帮助检测类似类型的错误以及解决错误。个人专家的知识决定了开发人员能够多快地定位错误。您可以添加调试打印语句和断点来分析程序的流程。您可以进行前向分析或后向分析来跟踪错误的位置。
- en: 'When debugging, the following steps are used to find the root cause and resolve
    it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试时，以下步骤用于查找根本原因并解决问题：
- en: Identify the issue.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定问题。
- en: Locate the issue.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位问题。
- en: Analyze the issue.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析问题。
- en: Resolve the issue.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决问题。
- en: Fix the side effects.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复副作用。
- en: Regardless of the programming language or platform, the most important thing
    to know when debugging your application is which section of your code is causing
    the problem. You can find the faulty code in a number of ways.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 无论编程语言或平台如何，调试应用程序时最重要的是知道代码的哪一部分导致了问题。您可以通过多种方式找到有问题的代码。
- en: If the defect is raised by your QA team or a user, then inquire when the issue
    occurred. Look at the log files or any error messages. Comment out the suspected
    section of the code, then build and run the application again to see if the issue
    persists. If the issue is reproducible, do forward and backward analysis by printing
    messages and commenting out lines of code before you find the one that's causing
    the issue.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺陷是由您的QA团队或用户提出的，请询问问题发生的时间。查看日志文件或任何错误消息。注释掉怀疑的代码部分，然后再次构建和运行应用程序，以查看问题是否仍然存在。如果问题是可重现的，通过打印消息和注释掉代码行来进行前向和后向分析，直到找到导致问题的代码行。
- en: You can also set a breakpoint in the built-in debugger to search for variable
    changes within your targeted feature. If one of the variables has updated to an
    unexpected value or an object pointer has become an invalid pointer, then you
    can easily identify it. Inspect all of the modules you used in the installer and
    ensure that you and your users have the same version number of the application.
    If you are using a different version or different branch, then check out the branch
    with the specified version tag, then debug the code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在内置调试器中设置断点，以搜索目标功能中的变量更改。如果其中一个变量已更新为意外值，或者对象指针已成为无效指针，则可以轻松识别它。检查您在安装程序中使用的所有模块，并确保您和您的用户使用的是应用程序的相同版本号。如果您使用的是不同版本或不同分支，请检出带有指定版本标签的分支，然后调试代码。
- en: In the next section, we will discuss how to debug your C++ code by printing
    debug messages and adding breakpoints.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何通过打印调试消息和添加断点来调试您的C++代码。
- en: Debugging a C++ application
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试C++应用程序
- en: The `QDebug` class can be used to print the value of a variable to the application
    output window. `QDebug` is similar to `std::cout` in the standard library, but
    it has the benefit of being part of Qt, which means it supports Qt classes out
    of the box and can display its value without the need for conversion.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDebug`类可用于将变量的值打印到应用程序输出窗口。`QDebug`类似于标准库中的`std::cout`，但它的好处是它是Qt的一部分，这意味着它支持Qt类，并且可以在不需要转换的情况下显示其值。'
- en: 'To enable debugging messages, we must include the `QDebug` header as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用调试消息，我们必须包含`QDebug`头文件，如下所示：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Qt provides several global macros for generating different types of debug messages.
    They can be used for different purposes, mentioned as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Qt提供了几个用于生成不同类型调试消息的全局宏。它们可以用于不同的目的，如下所述：
- en: '`qDebug()` provides a custom debug message.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qDebug()`提供自定义调试消息。'
- en: '`qInfo()` provides informational messages.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qInfo()`提供信息性消息。'
- en: '`qWarning()` reports warnings and recoverable errors.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qWarning()`报告警告和可恢复错误。'
- en: '`qCritical()` provides critical error messages and reports system errors.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qCritical()`提供关键错误消息和报告系统错误。'
- en: '`qFatal()` provides fatal error messages before exiting.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qFatal()`在退出之前提供致命错误消息。'
- en: 'You can see if your feature is working correctly by using `qDebug()`. After
    you''ve finished looking for the error, remove the line of code that contains
    `qDebug()` to avoid unwanted console logs. Let''s look at how to use `qDebug()`
    to print out variables to the output pane with an example. Create a sample `QWidget`
    application and add a function, `setValue(int value)`, and add the following code
    inside the function definition:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`qDebug()`来查看您的功能是否正常工作。在查找错误完成后，删除包含`qDebug()`的代码行，以避免不必要的控制台日志。让我们看看如何使用`qDebug()`来打印变量到输出窗格的示例。创建一个样本`QWidget`应用程序，并添加一个函数`setValue(int
    value)`，并在函数定义内添加以下代码：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding code will show the following output in the output window present
    at the bottom of Qt Creator:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将在Qt Creator底部的输出窗口中显示以下输出：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can figure out whether the value was changed by another function by looking
    at how many times the function is used and called inside the application. If the
    debug message is printed multiple times, then it is invoked from multiple places.
    Check if the correct value is sent to all calling functions. To eliminate unnecessary
    console logs in the output console window, remove the line of code that contains
    `qDebug()` once you have finished looking for the issue. Alternatively, you may
    implement conditional compilation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看函数的使用次数和在应用程序内调用的次数来确定值是否被另一个函数更改。如果调试消息多次打印，则它是从多个位置调用的。检查是否将正确的值发送到所有调用函数。在查找问题完成后，删除包含`qDebug()`的代码行，以消除输出控制台窗口中不必要的控制台日志。或者，您可以实现条件编译。
- en: 'Let''s look further into debugging and debugging options in Qt Creator:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步了解Qt Creator中的调试和调试选项：
- en: You can see a **Debug** menu in the menu bar. When you click on it, you will
    see a context menu with submenus as shown in *Figure 9.2*:![Figure 9.2 – Debug
    menu in Qt Creator
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在菜单栏中看到一个**调试**菜单。单击它时，您将看到一个上下文菜单，其中包含如*图9.2*所示的子菜单：![图9.2 - Qt Creator中的调试菜单
- en: '](img/Figure_9.2_B16231.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.2_B16231.jpg)'
- en: Figure 9.2 – Debug menu in Qt Creator
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 - Qt Creator中的调试菜单
- en: To start debugging, press *F5* or click on the start **Debug** button at the
    bottom left of Qt Creator as shown here:![Figure 9.3 – The Start debugging button
    in Qt Creator
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始调试，请按*F5*或单击Qt Creator左下角的开始**调试**按钮，如下所示：![图9.3 - Qt Creator中的开始调试按钮
- en: '](img/Figure_9.3_B16231.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.3_B16231.jpg)'
- en: Figure 9.3 – The Start debugging button in Qt Creator
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 - Qt Creator中的开始调试按钮
- en: If Qt Creator complains about the debugger with an error message, then check
    to see if your project package has a debugger.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果Qt Creator以错误消息抱怨调试器，则检查您的项目包是否有调试器。
- en: If the error persists, close Qt Creator and go to your project folder, where
    you can delete the `.pro.user` file.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果错误仍然存在，请关闭Qt Creator并转到您的项目文件夹，您可以在那里删除`.pro.user`文件。
- en: Then reload the project in Qt Creator. Your project will be reconfigured by
    Qt Creator, and the debug mode should now be functional.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在Qt Creator中重新加载项目。Qt Creator将重新配置您的项目，并且调试模式现在应该可用。
- en: 'A great way to debug your application is to set a breakpoint:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 调试应用程序的一个很好的方法是设置断点：
- en: You will see a pop-up menu of three choices when you right-click on the line
    number of your script in Qt Creator.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您在Qt Creator中右键单击脚本的行号时，将会看到一个包含三个选项的弹出菜单。
- en: You can also click on the line number to add a breakpoint. Click on the line
    number to set a breakpoint. You will see a red dot appearing on the line number.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以单击行号添加断点。单击行号设置断点。您将在行号上看到一个红点出现。
- en: Next, press the *F5* key on the keyboard or click on the start **Debug** button.
    Once you run the application in debug mode, you will notice a yellow arrow appearing
    on top of the first red dot:![Figure 9.4 –  Qt Creator showing debugging windows
    and breakpoints
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按下键盘上的*F5*键或单击**Debug**按钮。运行应用程序以调试模式，您会注意到第一个红点上方出现了一个黄色箭头：![图9.4 -  Qt
    Creator显示调试窗口和断点
- en: '](img/Figure_9.4_B16231.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.4_B16231.jpg)'
- en: Figure 9.4 – Qt Creator showing debugging windows and breakpoints
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 - Qt Creator显示调试窗口和断点
- en: The debugger has come to a halt at the first breakpoint. The variable, along
    with its meaning and type, will now be displayed in the **Locals** and **Expression**
    windows on the right-hand side of your Qt Creator.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试器已在第一个断点处停止。现在，变量及其含义和类型将显示在Qt Creator右侧的**Locals**和**Expression**窗口中。
- en: 'This approach can be used to quickly examine the application. To remove a breakpoint,
    just click on the red dot icon once more or from the right-click context menu:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种方法可以快速检查应用程序。要删除断点，只需再次单击红点图标或从右键单击上下文菜单中删除：
- en: '![Figure 9.5 – Context menu showing right-click options on a breakpoint marking'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5 - 上下文菜单显示断点标记的右键单击选项'
- en: '](img/Figure_9.5_B16231.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.5_B16231.jpg)'
- en: Figure 9.5 – Context menu showing right-click options on a breakpoint marking
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 - 上下文菜单显示断点标记的右键单击选项
- en: It's important to remember that you must run your application in debug mode.
    This is because when you compile in debug mode, your application or library will
    have additional debugging symbols that allow your debugger to access information
    from the binary's source code, such as the names of identifiers, variables, and
    functions. This is the reason the application or library binaries are larger in
    file size when compiled in debug mode.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，必须在调试模式下运行应用程序。这是因为在调试模式下编译时，您的应用程序或库将具有额外的调试符号，允许调试器从二进制源代码中访问信息，例如标识符、变量和函数的名称。这就是为什么在调试模式下编译的应用程序或库二进制文件在文件大小上更大的原因。
- en: 'You can learn about more features and their usage in the following documentation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下文档中了解更多功能及其用法：
- en: '[https://doc.qt.io/qt-6/debug.html](https://doc.qt.io/qt-6/debug.html%20)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://doc.qt.io/qt-6/debug.html](https://doc.qt.io/qt-6/debug.html%20)'
- en: Important note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Some anti virus applications prevent debuggers from retrieving information.
    One such anti virus is Avira. If it is installed on a production PC, the launching
    of the debugger could fail on the Windows platform.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一些防病毒应用程序会阻止调试器检索信息。Avira就是这样的防病毒软件。如果在生产PC上安装了它，调试器在Windows平台上可能会失败。
- en: In the next section, we will discuss how to debug a Qt Quick application and
    locate issues inside a QML file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何调试Qt Quick应用程序并定位QML文件中的问题。
- en: Debugging a Qt Quick application
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Qt Quick应用程序
- en: In the last section, we discussed how to debug your C++ code. But you are probably
    still wondering how to debug code written in QML. Qt also has a provision to debug
    your QML code. When you are developing a Qt Quick application, there are a lot
    of options to troubleshoot issues. In this section, we will discuss various debugging
    techniques related to QML and how to use them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了如何调试C++代码。但您可能仍然想知道如何调试QML中编写的代码。Qt还提供了调试QML代码的功能。在开发Qt Quick应用程序时，有很多选项可以解决问题。在本节中，我们将讨论与QML相关的各种调试技术以及如何使用它们。
- en: 'Just like the `QDebug` class, there are different console APIs that are available
    for debugging in QML. They are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`QDebug`类一样，在QML中有不同的控制台API可用于调试。它们如下：
- en: '`Log`: This is used to print general messages.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Log`：用于打印一般消息。'
- en: '`Assert`: This is used to verify an expression.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Assert`：用于验证表达式。'
- en: '`Timer`: This is used to measure the time spent between calls.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Timer`：用于测量调用之间花费的时间。'
- en: '`Trace`: This is used to print a stack trace of a JavaScript execution.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Trace`：用于打印JavaScript执行的堆栈跟踪。'
- en: '`Count`: This is used to find the number of calls made to a function.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Count`：用于查找对函数的调用次数。'
- en: '`Profile`: This is used to profile QML and JavaScript code.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Profile`：用于对QML和JavaScript代码进行分析。'
- en: '`Exception`: It is used to print error messages.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exception`：用于打印错误消息。'
- en: 'The Console API provides several convenient functions to print different types
    of debug messages such as `console.log()`, `console.debug()`, `console.info()`,
    `console.warn()`, and `console.error()`. You can print a message with the value
    of a parameter as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台API提供了几个方便的函数来打印不同类型的调试消息，例如`console.log()`、`console.debug()`、`console.info()`、`console.warn()`和`console.error()`。您可以按以下方式打印带有参数值的消息：
- en: '[PRE3]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also check the creation of a component by adding the message inside
    `Components.onCompleted:{…}`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在`Components.onCompleted:{…}`中添加消息来检查组件的创建：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To verify that an expression is true, you can use `console.assert()`, such
    as the following, for example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证表达式是否为真，您可以使用`console.assert()`，例如以下示例：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You will find the time spent between calls is logged by `console.time()` and
    `console.timeEnd()`. The stack trace of the JavaScript execution at the stage
    where it was called is printed by `console.trace()`. The function name, filename,
    line number, and column number are all included in the stack trace details.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现`console.time()`和`console.timeEnd()`记录了调用之间花费的时间。`console.trace()`打印了JavaScript执行的堆栈跟踪。堆栈跟踪详细信息包括函数名、文件名、行号和列号。
- en: '`console.count()` returns the current number of times a piece of code has been
    executed, as well as a message. The QML and JavaScript profiling are activated
    when you use `console.profile()` and deactivated when `console.profileEnd()` is
    called. You can use `console.exception()` to print an error message along with
    the stack trace of the JavaScript execution.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.count()`返回代码执行次数以及消息。当使用`console.profile()`时，QML和JavaScript分析被激活，当调用`console.profileEnd()`时被停用。您可以使用`console.exception()`打印错误消息以及JavaScript执行的堆栈跟踪。'
- en: 'You can add a breakpoint in the same way we discussed in an earlier section,
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以与前一节讨论的相同方式添加断点，如下所示：
- en: To step into the code in the stack, click on the **Step Into** button on the
    toolbar or press *F11*.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入堆栈中的代码，单击工具栏上的**Step Into**按钮或按下*F11*键。
- en: To step out, press *Shift* + *F11*. To hit the breakpoint, add a breakpoint
    at the end of the method and click **Continue**.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要退出，请按*Shift* + *F11*。要命中断点，请在方法末尾添加断点，然后单击**Continue**。
- en: Open the QML debugger console output pane to run JavaScript commands in the
    current context.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开QML调试器控制台输出窗格，以在当前上下文中运行JavaScript命令。
- en: You can find the issues and watch the values while running your Qt Quick application.
    It will help you to find the portion of the code that is causing unexpected behavior
    and requires modification.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Qt Quick应用程序时，您可以找到问题并观察值。这将帮助您找到导致意外行为并需要修改的代码部分。
- en: In this section, we learned about debugging in a QML environment. In the next
    section, we will discuss the testing framework in Qt.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了在QML环境中进行调试。在下一节中，我们将讨论Qt中的测试框架。
- en: Testing in Qt
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Qt中进行测试
- en: '**Unit testing** is a way of testing a simple application, class, or function
    using an automated tool. We will discuss what it is and why we would like to do
    it before going over how to incorporate it into our approach using Qt Test. Unit
    testing is the process of breaking down an application into its smallest functional
    units and then testing each unit with real-world situations within the initiative''s
    framework. A unit is the smallest component of an application that can be tested.
    A unit test in procedural programming usually focuses on a function or process.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是使用自动化工具测试简单应用程序、类或函数的一种方法。在讨论如何将其纳入我们的方法之前，我们将讨论它是什么以及为什么我们希望这样做。单元测试是将应用程序分解为最小的功能单元，然后在倡议框架内使用真实世界的情况对每个单元进行测试的过程。单元是可以测试的应用程序的最小组件。在过程式编程中，单元测试通常侧重于函数或过程。'
- en: A unit in object-oriented programming is usually an interface, a class, or a
    single function. Unit testing identifies issues early in the implementation process.
    This covers glitches in the programmer's implementation as well as defects in
    or incomplete portions of the unit's specification. During the creation process,
    a unit test is a short code fragment developed by the developer of the unit to
    be tested. There are many unit testing tools to test your C++ code. Let's explore
    the benefits and features of Qt's testing framework.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，单元通常是接口、类或单个函数。单元测试早期识别实施过程中的问题。这涵盖了程序员实现中的缺陷，以及单元规范中的缺陷或不完整部分。在创建过程中，单元测试是由要测试的单元的开发人员开发的短代码片段。有许多单元测试工具可用于测试您的C++代码。让我们探讨Qt测试框架的优势和特点。
- en: Unit testing in Qt
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Qt中进行单元测试
- en: 'Qt Test is a unit testing platform for Qt-based applications and libraries.
    Qt Test includes all of the features present in traditional unit testing applications,
    as well as plugins for testing graphical user interfaces. It helps make writing
    unit tests for Qt-based programs and libraries even easier. *Figure 9.6* shows
    the **Testing** section under **Options**:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Test是用于基于Qt的应用程序和库的单元测试平台。Qt Test包括传统单元测试应用程序中的所有功能，以及用于测试图形用户界面的插件。它有助于更轻松地为基于Qt的程序和库编写单元测试。*图9.6*显示了**选项**下的**测试**部分：
- en: '![Figure 9.6 – Screenshot showing Qt Test preferences under the Qt Creator
    Options menu'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6–显示Qt Creator选项菜单下的Qt Test首选项的屏幕截图'
- en: '](img/Figure_9.6_B16231.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.6_B16231.jpg)'
- en: Figure 9.6 – Screenshot showing Qt Test preferences under the Qt Creator Options
    menu
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6–显示Qt Creator选项菜单下的Qt Test首选项的屏幕截图
- en: Previously, unit testing may have been done manually, especially for GUI testing,
    but now there is a tool that allows you to write code to validate code automatically,
    which might seem counterintuitive at first, but it works properly. Qt Test is
    a specialized testing framework for unit testing based on Qt.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，单元测试可能是手动完成的，特别是对于GUI测试，但现在有一个工具可以让您编写代码自动验证代码，这乍一看似乎有些违反直觉，但它确实有效。Qt Test是一个基于Qt的专门单元测试框架。
- en: 'You have to add `testlib` in your project file (`.pro`) to use Qt''s built-in
    unit testing module:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须在项目文件（.pro）中添加`testlib`以使用Qt的内置单元测试模块：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, run `qmake` to add the module available for your project. In order for
    the test system to find and implement it, you must use the `QTest` header and
    declare the test functions as private slots. The `QTest` header contains all functions
    and statements related to Qt Test. To use the `QTest` features, simply add the
    following line to your C++ file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行`qmake`以将模块添加到您的项目中。为了使测试系统找到并实现它，您必须使用`QTest`头文件并将测试函数声明为私有槽。`QTest`头文件包含与Qt
    Test相关的所有函数和语句。要使用`QTest`功能，只需在您的C++文件中添加以下行：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should write test cases for every possible scenario, and then run the tests
    every time your baseline code changes to ensure that the system continues to behave
    as intended. It is an extremely useful tool for ensuring that any programming
    updates made don't break existing features.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该为每种可能的情况编写测试用例，然后在基线代码更改时运行测试，以确保系统继续按预期行为。这是一个非常有用的工具，可以确保任何编程更新不会破坏现有功能。
- en: 'Let''s create a simple test application using Qt Creator''s built-in wizard.
    Select **Auto Test Project** from the **New Project** menu as shown in *Figure
    9.7*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Qt Creator内置的向导创建一个简单的测试应用程序。从**新建项目**菜单中选择**自动测试项目**，如*图9.7*所示：
- en: '![Figure 9.7 – New auto test project option in the project wizard'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7–项目向导中的新自动测试项目选项'
- en: '](img/Figure_9.7_B16231.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.7_B16231.jpg)'
- en: Figure 9.7 – New auto test project option in the project wizard
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7–项目向导中的新自动测试项目选项
- en: 'Once the test project skeleton is generated, you can modify the generated files
    to suit your needs. Open the `.pro` file of your test project and add the following
    lines of code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 生成测试项目框架后，您可以修改生成的文件以满足您的需求。打开测试项目的`.pro`文件，并添加以下代码行：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s create a C++ class named `TestClass`. We will add our test functions
    to this class. This class must be derived from `QObject`. Let''s have a look at
    `tst_testclass.cpp`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`TestClass`的C++类。我们将把我们的测试函数添加到这个类中。这个类必须派生自`QObject`。让我们看一下`tst_testclass.cpp`：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we have declared two test functions to test sample strings
    and values. You need to implement the test functions with a test scenario for
    the declared test cases. Let''s compare two strings and do a simple arithmetic
    operation. You can use macros such as `QCOMPARE` and `QVERIFY` to test the values:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了两个测试函数来测试样本字符串和值。您需要为声明的测试用例实现测试函数的测试场景。让我们比较两个字符串并进行简单的算术运算。您可以使用诸如`QCOMPARE`和`QVERIFY`之类的宏来测试值：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To execute all the test cases, you have to add macros such as `QTEST_MAIN()`
    at the bottom of the file. The `QTEST_MAIN()` macro expands to a simple `main()`
    method that runs all the test functions. The `QTEST_APPLESS_MAIN()` macro is useful
    for simple standalone non-GUI tests where the `QApplication` object is not used.
    Use `QTEST_GUILESS_MAIN()` if the GUI is not required but an event loop is required:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行所有测试用例，您必须在文件底部添加诸如`QTEST_MAIN()`的宏。`QTEST_MAIN()`宏扩展为一个简单的`main()`方法，用于运行所有测试函数。`QTEST_APPLESS_MAIN()`宏适用于简单的独立非GUI测试，其中不使用`QApplication`对象。如果不需要GUI但需要事件循环，则使用`QTEST_GUILESS_MAIN()`：
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To make the test case a standalone executable, we have added the `QTEST_APPLESS_MAIN()`
    macro and the `moc` generated file for the class. You may use a number of other
    macros to test the application. For further information, please visit the following
    link:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试用例成为一个独立的可执行文件，我们添加了`QTEST_APPLESS_MAIN()`宏和类的`moc`生成文件。您可以使用许多其他宏来测试应用程序。有关更多信息，请访问以下链接：
- en: '[http://doc.qt.io/qt-6/qtest.html#macros](http://doc.qt.io/qt-6/qtest.html#macros%20)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://doc.qt.io/qt-6/qtest.html#macros](http://doc.qt.io/qt-6/qtest.html#macros%20)'
- en: 'When you run the preceding example, you will see the output with the test results
    as shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行上面的示例时，您将看到如下所示的测试结果输出：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can see that one test case failed as it did not meet the test criteria.
    Similarly, you can add more test cases and fetch parameters from another class
    to test the functionality. You can also run all tests with the **Run All Tests**
    option from the **Tests** context menu from the Qt Creator menu bar as shown in
    *Figure 9.8*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到一个测试用例失败，因为它未满足测试标准。类似地，您可以添加更多的测试用例，并从另一个类中获取参数来测试功能。您还可以使用**运行所有测试**选项从Qt
    Creator菜单栏的**测试**上下文菜单中运行所有测试，如*图9.8*所示：
- en: '![Figure 9.8 – Tests option under the Tools menu'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 - 工具菜单下的测试选项'
- en: '](img/Figure_9.8_B16231.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.8_B16231.jpg)'
- en: Figure 9.8 – Tests option under the Tools menu
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 - 工具菜单下的测试选项
- en: 'You can also view all test cases in the left side project explorer view. Select
    **Tests** from the project explorer dropdown. You can enable or disable certain
    test cases in this window. *Figure 9.9* displays the two test cases we wrote earlier.
    You can also see that we are not using other test frameworks for this test project:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在左侧的项目资源管理器视图中查看所有测试用例。从项目资源管理器下拉菜单中选择**测试**。您可以在此窗口中启用或禁用某些测试用例。*图9.9*显示了我们之前编写的两个测试用例。您还可以看到我们没有在这个测试项目中使用其他测试框架：
- en: '![Figure 9.9 – Tests explorer option in the project explorer dropdown'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9 - 项目资源管理器下拉菜单中的测试资源管理器选项'
- en: '](img/Figure_9.9_B16231.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.9_B16231.jpg)'
- en: Figure 9.9 – Tests explorer option in the project explorer dropdown
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 - 项目资源管理器下拉菜单中的测试资源管理器选项
- en: 'You can use several `QTest` convenient functions to simulate GUI events such
    as keyboard or mouse events. Let''s look at their usage with a simple code snippet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用几个`QTest`便利函数来模拟GUI事件，如键盘或鼠标事件。让我们看一个简单的代码片段的用法：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, the test code simulates a keyboard text `Enter` event
    on a `lineedit` control and then verifies the entered text. You can also simulate
    mouse-click events using `QTest::mouseClick()`. You can use it as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，测试代码模拟了`lineedit`控件上的键盘文本`Enter`事件，然后验证了输入的文本。您还可以使用`QTest::mouseClick()`来模拟鼠标点击事件。您可以按照以下方式使用它：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Qt's Test framework is also useful in **test-driven development** (**TDD**).
    In TDD, you write a test first, then code the actual logic. The test will initially
    fail as there is no implementation. You then write the bare minimum code required
    to pass the test before moving on to the next test. This is how you iteratively
    develop a feature before you have implemented the necessary functionality.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的测试框架在**测试驱动开发**（**TDD**）中也很有用。在TDD中，您首先编写一个测试，然后编写实际的逻辑代码。由于没有实现，测试最初会失败。然后，您编写必要的最少代码以通过测试，然后再进行下一个测试。这是在实现必要功能之前迭代开发功能的方法。
- en: In this section, we learned how to create test cases and simulate GUI interaction
    events. In the next section, you will learn how to use Google's C++ testing framework.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何创建测试用例并模拟GUI交互事件。在下一节中，您将学习如何使用Google的C++测试框架。
- en: Integrating with Google's C++ testing framework
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Google的C++测试框架集成
- en: '**GoogleTest** is a testing and mocking framework developed by Google. The
    **GoogleMock** project has been merged into GoogleTest. GoogleTest requires a
    compiler that supports at least C++11 standards. It is a cross-platform test framework
    and it supports major desktop platforms such as Windows, Linux, and macOS. It
    helps you write better C++ tests with advanced features such as mocking. You can
    integrate Qt Test with GoogleTest to get the best of both frameworks. If you intend
    to use both testing framework features, then you should use GoogleTest as the
    primary testing framework and inside the test cases, you can use Qt Test''s features.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**GoogleTest**是由Google开发的测试和模拟框架。**GoogleMock**项目已合并到GoogleTest中。GoogleTest需要支持至少C++11标准的编译器。它是一个跨平台的测试框架，支持Windows、Linux和macOS等主要桌面平台。它可以帮助您使用高级功能（如模拟）编写更好的C++测试。您可以将Qt
    Test与GoogleTest集成，以充分利用两个框架的优势。如果您打算使用两个测试框架的功能，则应将GoogleTest用作主要测试框架，并在测试用例中使用Qt
    Test的功能。'
- en: 'Qt Creator has built-in support for GoogleTest. You can find the **Google Test**
    tab in the **Testing** section on the **Options** screen and set your global GoogleTest
    preferences as shown in *Figure 9.10*:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator内置支持GoogleTest。您可以在**选项**屏幕的**测试**部分中找到**Google测试**选项卡，并设置全局的GoogleTest偏好，如*图9.10*所示：
- en: '![Figure 9.10 – The Google Test tab in the Testing section under the Options
    menu'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.10 - 选项菜单下测试部分中的Google测试选项卡'
- en: '](img/Figure_9.10_B16231.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.10_B16231.jpg)'
- en: Figure 9.10 – The Google Test tab in the Testing section under the Options menu
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 - 选项菜单下测试部分中的Google测试选项卡
- en: 'You can download the GoogleTest source code from the following link:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下链接下载GoogleTest源代码：
- en: '[https://github.com/google/googletest](https://github.com/google/googletest%20)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/google/googletest](https://github.com/google/googletest%20)'
- en: 'You can learn more about features and their usage in the following documentation:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下文档中了解更多关于功能及其用法的信息：
- en: '[https://google.github.io/googletest/primer.html](https://google.github.io/googletest/primer.html%20)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://google.github.io/googletest/primer.html](https://google.github.io/googletest/primer.html%20)'
- en: 'After you download the source code, build the libraries before creating a sample
    application. You can also build the unified GoogleTest source code along with
    your test project. Once you generate the libraries, follow these steps to run
    your GoogleTest application:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下载源代码后，在创建示例应用程序之前构建库。您还可以将统一的GoogleTest源代码与测试项目一起构建。生成库后，按照以下步骤运行您的GoogleTest应用程序：
- en: To create a simple GoogleTest application using Qt Creator's built-in wizard,
    select **Auto Test Project** from the **New Project** menu. Then follow through
    the screens until you come across **Project and Test Information**.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用Qt Creator内置的向导创建一个简单的GoogleTest应用程序，请从**新建项目**菜单中选择**自动测试项目**。然后按照屏幕操作直到出现**项目和测试信息**。
- en: On the **Project and Test Information** screen, select **Google Test** for **Test
    framework**. Then add information for the **Test suite name** and **Test case
    name** fields as shown in *Figure 9.11*:![Figure 9.11 – Google Test option in
    the project creation wizard
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目和测试信息**屏幕上，选择**Google测试**作为**测试框架**。然后按照*图9.11*所示添加**测试套件名称**和**测试用例名称**字段的信息：![图9.11
    - 项目创建向导中的Google测试选项
- en: '](img/Figure_9.11_B16231.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.11_B16231.jpg)'
- en: Figure 9.11 – Google Test option in the project creation wizard
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 - 项目创建向导中的Google测试选项
- en: In the next step, you can fill in the `.pro` file.![Figure 9.12 – Option to
    add the GoogleTest source directory in the project creation wizard
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以填写`.pro`文件。![图9.12 - 在项目创建向导中添加GoogleTest源目录的选项
- en: '](img/Figure_9.12_B16231.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.12_B16231.jpg)'
- en: Figure 9.12 – Option to add the GoogleTest source directory in the project creation
    wizard
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 - 在项目创建向导中添加GoogleTest源目录的选项
- en: Click **Next** and follow the instructions to generate the skeleton of the project.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**下一步**，按照说明生成项目的框架。
- en: 'To use GoogleTest, you have to add the header file into your test project:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用GoogleTest，您必须将头文件添加到测试项目中：
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can see the main function has already been created by the wizard:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以看到主函数已经被向导创建：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can create a simple test case with the following syntax:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用以下语法创建一个简单的测试用例：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'GoogleTest also provides macros such as `ASSERT_*` and `EXPECT_*` to check
    conditions and values:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GoogleTest还提供了诸如`ASSERT_*`和`EXPECT_*`的宏来检查条件和值：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In most cases, it is a standard procedure to do some custom initialization
    work before running multiple tests. If you want to evaluate a test''s time/memory
    footprint, you''ll have to write some test-specific code. Test fixtures help in
    setting up specific testing requirements. The `fixture` class is derived from
    the `::testing::Test` class. Please note that instead of `TEST`, the `TEST_F`
    macro is used. You can allocate resources and do initializations in the constructor
    or in the `SetUp()` function. Similarly, you can deallocate in the destructor
    or in the `TearDown()` function. A test function inside a text fixture is defined
    as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，在运行多个测试之前进行一些自定义的初始化工作是标准的程序。如果您想评估测试的时间/内存占用情况，您将不得不编写一些特定于测试的代码。测试装置有助于设置特定的测试要求。`fixture`类是从`::testing::Test`类派生的。请注意，使用`TEST_F`宏而不是`TEST`。您可以在构造函数或`SetUp()`函数中分配资源和进行初始化。同样，您可以在析构函数或`TearDown()`函数中释放资源。测试装置中的测试函数定义如下：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To create and use a test fixture, create a class derived from the `::testing::Test`
    class as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建和使用测试装置，创建一个从`::testing::Test`类派生的类，如下所示：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we created a custom push button inside the `SetUp()`
    function. Then we tested two test functions to test the size and *Enter* key handling.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们在`SetUp()`函数中创建了一个自定义的按钮。然后我们测试了两个测试函数来测试大小和*Enter*键处理。
- en: When you run the preceding test, you will see the test results in the output
    window.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行上述测试时，您将在输出窗口中看到测试结果。
- en: GoogleTest builds a new test fixture at runtime for each test specified with
    `TEST_F()`. It instantly initializes by calling the `SetUp()` function and runs
    the test. Then it calls `TearDown()` to do the cleanup, and removes the test fixture.
    It is important to note that different tests within the same test suite can have
    different test fixture objects. Before building the next test fixture, GoogleTest
    always deletes the previous one. It does not reuse test fixtures for multiple
    tests. Any modifications done to the fixture by one test have no effect on the
    other tests.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: GoogleTest在运行时为使用`TEST_F()`指定的每个测试构建一个新的测试装置。它通过调用`SetUp()`函数立即进行初始化并运行测试。然后调用`TearDown()`进行清理，并移除测试装置。重要的是要注意，同一测试套件中的不同测试可以具有不同的测试装置对象。在构建下一个测试装置之前，GoogleTest始终删除先前的测试装置。它不会为多个测试重用测试装置。一个测试对测试装置所做的任何修改对其他测试没有影响。
- en: We discussed how to create a GoogleTest project with a simple test case and
    how to design a test fixture or test suite. Now you can create test cases for
    your existing C++ application. GoogleTest is a very mature test framework. It
    also integrates the mocking mechanism that was earlier available under GoogleMock.
    Explore different features and experiment with test cases.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了如何使用简单的测试用例创建GoogleTest项目以及如何设计测试夹具或测试套件。现在您可以为现有的C++应用程序创建测试用例。GoogleTest是一个非常成熟的测试框架。它还集成了早期在GoogleMock下可用的模拟机制。探索不同的功能并尝试测试用例。
- en: 'There is also a ready-made GUI tool that integrates both test frameworks to
    test your Qt application. **GTest Runner** is a Qt-based automated test runner
    and GUI with powerful features for Windows and Linux platforms. However, the code
    is not actively maintained and is not upgraded to Qt 6\. You can learn more about
    features and usages of GTest Runner at the following link:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个现成的GUI工具，集成了两个测试框架，用于测试您的Qt应用程序。**GTest Runner**是一个基于Qt的自动化测试运行器和GUI，具有强大的功能，适用于Windows和Linux平台。但是，该代码目前没有得到积极维护，并且尚未升级到Qt
    6。您可以在以下链接了解有关GTest Runner功能和用法的更多信息：
- en: '[https://github.com/nholthaus/gtest-runner](https://github.com/nholthaus/gtest-runner%20)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/nholthaus/gtest-runner](https://github.com/nholthaus/gtest-runner%20)'
- en: In this section, you learned how to use `QTest` and `GoogleTest` together. You
    have seen the features of both testing frameworks. You can create mock objects
    using the GoogleMock feature of the GoogleTest framework. Now you can write your
    own test fixtures for a custom C++ class or custom widget. In the next section,
    we will discuss testing in Qt Quick.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何同时使用`QTest`和`GoogleTest`。您已经了解了两种测试框架的特点。您可以使用GoogleTest框架的GoogleMock功能创建模拟对象。现在您可以为自定义的C++类或自定义小部件编写自己的测试夹具。在下一节中，我们将讨论Qt
    Quick中的测试。
- en: Testing Qt Quick applications
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Qt Quick应用程序
- en: '`TestCase` QML type. Functions with names beginning with `test_` are identified
    as test cases that need to be executed. The test harness recursively searches
    for the required source directory for `tst_ *.qml` files. You can keep all test
    `.qml` files under one directory and define the `QUICK_TEST_SOURCE_DIR`. If it
    is not defined, then only `.qml` files available in the current directory will
    be included during test execution. Qt doesn''t ensure binary compatibility for
    the Qt Quick Test module. You have to use the appropriate version of the module.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestCase` QML类型。以`test_`开头的函数被识别为需要执行的测试用例。测试工具会递归搜索`tst_ *.qml`文件所需的源目录。您可以将所有测试`.qml`文件放在一个目录下，并定义`QUICK_TEST_SOURCE_DIR`。如果未定义，则只有当前目录中可用的`.qml`文件将在测试执行期间包含在内。Qt不保证Qt
    Quick测试模块的二进制兼容性。您必须使用模块的适当版本。'
- en: 'You have to add `QUICK_TEST_MAIN()` to the C++ file to begin the execution
    of the test cases, as shown next:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将`QUICK_TEST_MAIN()`添加到C++文件中，以开始执行测试用例，如下所示：
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You need to add the `qmltest` module to enable Qt Quick Test. Add the following
    lines of code to the `.pro` file:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要添加`qmltest`模块以启用Qt Quick测试。将以下代码添加到`.pro`文件中：
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s see a demo of a basic arithmetic calculation to see how the module works.
    We will do some calculations such as addition, subtraction, and multiplication
    and intentionally make some mistakes so that test cases will fail:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个基本算术计算的演示，以了解模块的工作原理。我们将进行一些计算，如加法、减法和乘法，并故意犯一些错误，以便测试用例失败：
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When you run the preceding example, you will see the output with the test results
    as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行上述示例时，您将看到以下测试结果的输出：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Please note that `cleanupTestCase()` is called right after the test execution
    has been completed. This function can be used to clean up before everything is
    destructed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`cleanupTestCase()`在测试执行完成后立即调用。此函数可用于在一切被销毁之前进行清理。
- en: 'You can also perform data-driven tests as shown here:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以执行数据驱动的测试，如下所示：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Please note that the table data can be provided to a test using a function
    name that ends with `_data`. When you run the preceding example, you will see
    the output with the test results as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，可以使用以`_data`结尾的函数名向测试提供表格数据。当您运行上述示例时，您将看到以下测试结果的输出：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can also run benchmark tests in QML. The Qt benchmark framework will run
    functions with names that begin with `benchmark_` several times, with an average
    timing value recorded for the runs. It is similar to the `QBENCHMARK` macro in
    the C++ version of `benchmark_once_` to get the effect of the `QBENCHMARK_ONCE`
    macro. Let''s have a look at the following benchmarking example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在QML中运行基准测试。Qt基准测试框架将多次运行以`benchmark_`开头的函数，并记录运行的平均时间值。这类似于C++版本中的`QBENCHMARK`宏，用于获得`QBENCHMARK_ONCE`宏的效果。让我们看一个基准测试的示例：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding example, we are creating a custom QML element. We want to measure
    how much time it takes to create the element. Hence, we wrote the preceding benchmark
    code. A normal benchmark test runs multiple times and shows the duration of the
    operation. Here, we have benchmarked the creation once. This technique is very
    useful in evaluating the performance of your QML code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们创建了一个自定义的QML元素。我们想要测量创建该元素所需的时间。因此，我们编写了上述基准测试代码。普通的基准测试会多次运行并显示操作的持续时间。在这里，我们对创建进行了基准测试一次。这种技术在评估您的QML代码的性能时非常有用。
- en: 'When you run the preceding example, you will see the output with the test results
    as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行上述示例时，您将看到以下测试结果的输出：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To run the benchmark multiple times, you can remove the `once` keyword from
    the test case as follows: `function benchmark_create_component() {...}`. You can
    also test dynamically created objects using `Qt.createQmlObject()`.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要多次运行基准测试，可以从测试用例中删除`once`关键字，如下所示：`function benchmark_create_component() {...}`。您还可以使用`Qt.createQmlObject()`测试动态创建的对象。
- en: 'There is also a benchmarking tool named **qmlbench** for benchmarking the overall
    performance of a Qt application. It is a feature-rich benchmarking tool available
    under **qt-labs**. The tool also helps in measuring the refresh rate of the user
    interface. You can explore more about this tool at the following link:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为**qmlbench**的基准测试工具，用于基准测试Qt应用程序的整体性能。这是一个功能丰富的基准测试工具，可在**qt-labs**下使用。该工具还有助于测量用户界面的刷新率。您可以在以下链接中了解更多关于此工具的信息：
- en: '[https://github.com/qt-labs/qmlbench](https://github.com/qt-labs/qmlbench%20)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/qt-labs/qmlbench](https://github.com/qt-labs/qmlbench%20)'
- en: 'Like a C++ implementation, you can also simulate keyboard events such as `keyPress()`,
    `keyRelease()`, and `keyClick()` in QML. The events are delivered to the QML object
    that is currently being focused on. Let''s have a look at the following example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++实现一样，您还可以在QML中模拟键盘事件，例如`keyPress()`、`keyRelease()`和`keyClick()`。事件将传递到当前正在聚焦的QML对象。让我们看看以下示例：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding example, the keyboard event is delivered after the QML viewing
    window has been displayed. Attempts to deliver events before that will be unsuccessful.
    To keep track of when the window is shown, the `when` and `windowShown` properties
    are used.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，键盘事件是在显示QML查看窗口后传递的。在此之前尝试传递事件将不成功。为了跟踪窗口何时显示，使用了`when`和`windowShown`属性。
- en: 'When you run the preceding example, you will see the output with the test results
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行前面的例子时，您将看到以下测试结果的输出：
- en: '[PRE30]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can use `SignalSpy` to watch signal emission. In the following example,
    we have used `SignalSpy` to detect the `clicked` signal on a `Button`. When the
    signal is emitted, the `clickSpy` count is increased:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`SignalSpy`来监视信号发射。在以下示例中，我们使用`SignalSpy`来检测`Button`上的`clicked`信号。当信号被发射时，`clickSpy`计数会增加：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When you run the preceding example, you will see the output with the test results
    as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行前面的例子时，您将看到以下测试结果的输出：
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `QUICK_TEST_MAIN_WITH_SETUP` macro is used to execute C++ code before any
    of the QML tests are run. This can be useful for setting context properties on
    the QML engine. A test application can include several `TestCase` instances. The
    application terminates after running all test cases. You can enable or disable
    test cases from the **Tests** explorer:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`QUICK_TEST_MAIN_WITH_SETUP`宏用于在运行任何QML测试之前执行C++代码。这对于在QML引擎上设置上下文属性非常有用。测试应用程序可以包括多个`TestCase`实例。运行所有测试用例后，应用程序将终止。您可以从**Tests**资源管理器中启用或禁用测试用例：'
- en: '![Figure 9.13 – The Tests explorer showing Quick Test with the available test
    cases'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13 - 测试资源管理器显示具有可用测试用例的快速测试'
- en: '](img/Figure_9.13_B16231.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.13_B16231.jpg)'
- en: Figure 9.13 – The Tests explorer showing Quick Test with the available test
    cases
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 - 测试资源管理器显示具有可用测试用例的快速测试
- en: In this section, we discussed different testing approaches to test a QML object.
    In the next section, we will get familiar with GUI testing and learn about a few
    popular tools.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了测试QML对象的不同测试方法。在下一节中，我们将熟悉GUI测试，并了解一些流行的工具。
- en: GUI testing tools
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GUI测试工具
- en: You can easily evaluate one or more classes as unit tests, but we have to manually
    write all of the test cases. GUI testing is an especially challenging task. How
    can we document user interactions such as mouse clicks without coding them in
    C++ or QML? This question has baffled developers. There are a number of GUI testing
    tools available on the market that help us do this. Some of them are expensive,
    some of them are open source. We will discuss a few such tools in this section.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地将一个或多个类评估为单元测试，但我们必须手动编写所有测试用例。GUI测试是一项特别具有挑战性的任务。我们如何记录用户交互，例如鼠标点击，而不需要在C++或QML中编写代码？这个问题困扰着开发人员。市场上有许多GUI测试工具可帮助我们做到这一点。其中一些价格昂贵，一些是开源的。我们将在本节中讨论一些此类工具。
- en: 'However, you may not need a complete GUI testing framework. Some issues can
    be figured out with simple tricks. For example, while working with the GUI, you
    may also have to inspect different properties such as the alignment and boundaries
    of visual elements. One of the easiest ways is to add a `Rectangle` to inspect
    the boundary as shown in the next code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可能不需要一个完整的GUI测试框架。一些问题可以通过简单的技巧解决。例如，在处理GUI时，您可能还需要检查不同属性，如可视元素的对齐和边界。其中最简单的方法之一是添加一个`Rectangle`来检查边界，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When you run the preceding code snippet, you will see the GUI with element
    boundaries in colors as shown in the next screenshot:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行前面的代码片段时，您将看到GUI中的元素边界以颜色显示，如下一张截图所示：
- en: '![Figure 9.14 – Output of the visual boundaries of GUI elements using Rectangle'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14 - 使用矩形输出GUI元素的视觉边界'
- en: '](img/Figure_9.14_B16231.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.14_B16231.jpg)'
- en: Figure 9.14 – Output of the visual boundaries of GUI elements using Rectangle
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 - 使用矩形输出GUI元素的视觉边界
- en: In the preceding example, you can see that the text element is placed centrally
    inside the rectangle with a blue border. Without the blue border, you might have
    wondered why it was not centrally placed in the GUI. You can also see the boundaries
    and margins of each element. When the text element width is less than the font
    width, then you will observe clipping. You can also find whether there are any
    overlapping regions between user interface elements. In this way, you can find
    issues in a specific element of the GUI without using the `SG_VISUALIZE` environment
    variable.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您可以看到文本元素被放置在带有蓝色边框的矩形内部。如果没有蓝色边框，您可能会想知道为什么它没有在GUI中央放置。您还可以看到每个元素的边界和边距。当文本元素的宽度小于字体宽度时，您将观察到裁剪。您还可以找出用户界面元素之间是否有重叠区域。通过这种方式，您可以在不使用`SG_VISUALIZE`环境变量的情况下找到GUI特定元素的问题。
- en: Let's discuss a few GUI testing tools.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些GUI测试工具。
- en: The Linux Desktop Testing Project (LDTP)
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux桌面测试项目（LDTP）
- en: The **Linux Desktop Testing Project** (**LDTP**) provides a high-quality test
    automation infrastructure and cutting-edge tools for testing and improving Linux
    desktop platforms. LDTP is a GUI testing framework that runs on all platforms.
    It pokes around in the application's user interface using the accessibility libraries.
    The framework also includes tools for recording test cases depending on how the
    user interacts with the GUI.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux桌面测试项目**（**LDTP**）提供了一个高质量的测试自动化基础设施和尖端工具，用于测试和改进Linux桌面平台。LDTP是一个在所有平台上运行的GUI测试框架。它使用可访问性库在应用程序的用户界面中进行探测。该框架还包括根据用户与GUI交互的方式记录测试用例的工具。'
- en: 'To click on a push button, use the following syntax:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要单击按钮，请使用以下语法：
- en: '[PRE34]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To get the current slider value of the given object, use the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取给定对象的当前滑块值，请使用以下代码：
- en: '[PRE35]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To use LDTP for your GUI application, you must add an accessible name to all
    your QML objects. You can use object names as the accessible names as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要为您的GUI应用程序使用LDTP，必须为所有QML对象添加可访问名称。您可以使用对象名称作为可访问名称，如下所示：
- en: '[PRE36]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding code, we have added an accessible name to the QML control
    so that the LDTP tool can find this button. The LDTP requires the window name
    of the user interface to locate the child control. Let''s say the window name
    is **Example**, then to generate a click event, use the following command on the
    LDTP script:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们为QML控件添加了可访问名称，以便LDTP工具可以找到此按钮。LDTP需要用户界面的窗口名称来定位子控件。假设窗口名称是**Example**，那么要生成单击事件，请在LDTP脚本上使用以下命令：
- en: '[PRE37]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding LDTP command locates the `quitButton` and generates a button-click
    event.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 上述LDTP命令定位`quitButton`并生成按钮单击事件。
- en: 'You can learn more about its features and uses at the following link:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接了解其特点和用途：
- en: '[https://ldtp.freedesktop.org/user-doc/](https://ldtp.freedesktop.org/user-doc/%20)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://ldtp.freedesktop.org/user-doc/](https://ldtp.freedesktop.org/user-doc/%20)'
- en: GammaRay
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GammaRay
- en: KDAB developed a software introspection tool named `QObject` introspection mechanism.
    This works on a local machine as well as a remote embedded target. It extends
    the capabilities of the instruction-level debugger while adhering to the same
    standards as the underlying frameworks. This is particularly useful for complex
    projects that use frameworks such as scene graphs, model/view, state machine,
    and so on. There are several tools available to inspect the objects and their
    properties. However, it stands out from other tools with its in-depth association
    with Qt's complex framework.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: KDAB开发了一个名为`QObject`内省机制的软件内省工具。这个工具可以在本地机器和远程嵌入式目标上使用。它扩展了指令级调试器的功能，同时遵循底层框架的标准。这对于使用场景图、模型/视图、状态机等框架的复杂项目特别有用。有几种工具可用于检查对象及其属性。然而，它与Qt复杂框架的深度关联使其脱颖而出。
- en: 'You can download GammaRay from the following link:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从以下链接下载GammaRay：
- en: '[https://github.com/KDAB/GammaRay/wiki/Getting-GammaRay](https://github.com/KDAB/GammaRay/wiki/Getting-GammaRay%20)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/KDAB/GammaRay/wiki/Getting-GammaRay](https://github.com/KDAB/GammaRay/wiki/Getting-GammaRay%20)'
- en: 'You can learn more about its features and uses at the following link:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接了解其特点和用途：
- en: '[https://www.kdab.com/development-resources/qt-tools/gammaray/](https://www.kdab.com/development-resources/qt-tools/gammaray/%20)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.kdab.com/development-resources/qt-tools/gammaray/](https://www.kdab.com/development-resources/qt-tools/gammaray/%20)'
- en: Squish
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Squish
- en: '**Squish** is a cross-platform GUI test automation tool for desktop, mobile,
    embedded, and web applications. You can automate GUI testing for your cross-platform
    application written with Qt Widgets or Qt Quick. Squish is used by thousands of
    organizations around the world to test their GUI with functional regression tests
    and system tests.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**Squish**是一个用于桌面、移动、嵌入式和Web应用程序的跨平台GUI测试自动化工具。您可以使用Squish自动化GUI测试，用于使用Qt Widgets或Qt
    Quick编写的跨平台应用程序。Squish被全球数千家组织用于通过功能回归测试和系统测试测试其GUI。'
- en: 'You can learn more about the tool at the following link:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接了解有关该工具的更多信息：
- en: '[https://www.froglogic.com/squish/](https://www.froglogic.com/squish/%20)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.froglogic.com/squish/](https://www.froglogic.com/squish/%20)'
- en: In this section, we discussed various GUI testing tools. Explore them and try
    them with your project. Let's summarize our learning in this chapter.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了各种GUI测试工具。探索它们，并尝试在您的项目中使用它们。让我们总结一下本章的学习成果。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned what debugging is and how to use different
    debugging techniques to identify technical issues in a Qt application. Apart from
    that, we've looked at the various debuggers that Qt supports on various operating
    systems. Finally, we learned how to use unit testing to simplify some of the debugging
    measures. We discussed unit testing, and you learned how to use the Qt Test framework.
    You saw how to debug a Qt Quick application. We also discussed various other testing
    frameworks and tools supported by Qt. Now you can write unit tests for your custom
    classes. The unit tests will fail and automatically alert if someone accidentally
    modifies some specific logic.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了调试是什么，以及如何使用不同的调试技术来识别Qt应用程序中的技术问题。除此之外，我们还看了Qt在各种操作系统上支持的各种调试器。最后，我们学习了如何使用单元测试来简化一些调试措施。我们讨论了单元测试，并学习了如何使用Qt测试框架。您看到了如何调试Qt
    Quick应用程序。我们还讨论了Qt支持的各种其他测试框架和工具。现在，您可以为自定义类编写单元测试。如果有人意外修改了某些特定逻辑，单元测试将失败并自动发出警报。
- en: In [*Chapter 10*](B16231_10_Final_ASB_ePub.xhtml#_idTextAnchor240), *Deploying
    Qt Applications*, you will learn about deploying Qt applications on various platforms.
    It will help you in creating installable packages for your target platform.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第10章*](B16231_10_Final_ASB_ePub.xhtml#_idTextAnchor240)，*部署Qt应用程序*，您将学习如何在各种平台上部署Qt应用程序。这将帮助您为目标平台创建可安装的软件包。
