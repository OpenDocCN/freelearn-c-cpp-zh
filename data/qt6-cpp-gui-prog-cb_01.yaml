- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Look-and-Feel Customization with Qt Designer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Qt Designer 进行外观和感觉定制
- en: Qt 6 allows us to easily design our program’s user interface through a method
    most people are familiar with. Qt not only provides us with a powerful user interface
    toolkit, called **Qt Designer**, which enables us to design our user interface
    without writing a single line of code, but it also allows advanced users to customize
    their user interface components through a simple scripting language called **Qt**
    **Style Sheet**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 6 允许我们通过大多数人熟悉的方法轻松设计程序的用户界面。Qt 不仅为我们提供了一个强大的用户界面工具包，称为 **Qt Designer**，它使我们能够在不写任何代码的情况下设计用户界面，而且还允许高级用户通过一种简单的脚本语言，称为
    **Qt 样式表**，来自定义他们的用户界面组件。
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Using style sheets with Qt Designer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Qt Designer 与样式表结合使用
- en: Customizing basic style sheets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制基本样式表
- en: Creating a login screen using style sheets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用样式表创建登录屏幕
- en: Using resources in style sheets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在样式表中使用资源
- en: Customizing properties and sub-controls
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制属性和子控件
- en: Styling in **Qt Modeling** **Language** (**QML**)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 **Qt 模型语言**（**QML**）中进行样式化
- en: Exposing the QML object pointer to C++
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 QML 对象指针暴露给 C++
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter include having **Qt 6.1.1 MinGW
    64-bit** and **Qt Creator 12.0.2**. The code that’s used in this chapter can be
    downloaded from this book’s GitHub repository: [https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter01](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter01).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括拥有 **Qt 6.1.1 MinGW 64-bit** 和 **Qt Creator 12.0.2**。本章使用的代码可以从本书的
    GitHub 仓库下载：[https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter01](https://github.com/PacktPublishing/QT6-C-GUI-Programming-Cookbook---Third-Edition-/tree/main/Chapter01)。
- en: Using style sheets with Qt Designer
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Qt Designer 与样式表结合使用
- en: In this example, we will learn how to change the look and feel of our program
    and make it look more professional by using style sheets and resources. Qt allows
    you to decorate your **graphical user interfaces** (**GUIs**) using a style sheet
    language called **Qt Style Sheets**, which is very similar to **Cascading Style
    Sheets** (**CSS**), something that’s used by web designers to decorate their websites.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将学习如何通过使用样式表和资源来改变我们程序的外观和感觉，使其看起来更加专业。Qt 允许您使用一种名为 **Qt 样式表** 的样式表语言来装饰您的
    **图形用户界面**（**GUI**），这与网页设计师用来装饰他们网站的 **层叠样式表**（**CSS**）非常相似。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let’s get started by learning how to create a new project and get ourselves
    familiar with Qt Designer:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习如何创建一个新项目，并熟悉 Qt Designer：
- en: Open up **Qt Creator** and create a new project. If this is the first time you
    have used Qt Creator, you can either click the big button, which reads **Create
    Project…**, or simply go to **File** | **New Project…**.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **Qt Creator** 并创建一个新项目。如果您是第一次使用 Qt Creator，您可以点击大按钮，上面写着 **创建项目…**，或者简单地转到
    **文件** | **新建项目…**。
- en: Select **Application (Qt)** from the **Projects** window and select **Qt** **Widgets
    Application**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**窗口中选择**应用程序（Qt**）并选择**Qt 小部件应用程序**。
- en: Click the **Choose...** button at the bottom. A window will pop out and ask
    you to insert the project’s name and its location.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击底部的**选择...**按钮。会出现一个窗口，要求您输入项目的名称和位置。
- en: Click **Next** several times, then click the **Finish** button to create the
    project. We will stick with the default settings for now. Once the project has
    been created, the first thing you will see is a panel with tons of big icons on
    the left-hand side of the window, which is called the mode selector panel; we
    will discuss this in more detail in the *Dissecting Qt* *Designer* recipe.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步** 几次，然后点击 **完成** 按钮来创建项目。我们现在将保持默认设置。一旦项目创建完成，您将首先看到左侧窗口中带有大量大图标的面板，这被称为模式选择面板；我们将在
    *剖析 Qt Designer* 菜谱中更详细地讨论这一点。
- en: You will see all your source files listed on the sidebar panel, which is located
    next to the mode selector panel. This is where you can select which file you want
    to edit. In this case, this is `mainwindow.ui`, because we are about to start
    designing the program’s UI.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将在侧边栏面板上看到所有源文件列表，该面板位于模式选择面板旁边。您可以选择要编辑的文件。在这种情况下，这是 `mainwindow.ui`，因为我们即将开始设计程序的
    UI。
- en: Double-click the `mainwindow.ui` file; you will see an entirely different interface
    appear out of nowhere. Qt Creator helped you switch from the script editor to
    the UI editor (Qt Designer) because it detected the `.ui` extension on the file
    you’re trying to open.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`mainwindow.ui`文件；您将看到一个完全不同的界面突然出现。Qt Creator帮助您从脚本编辑器切换到UI编辑器（Qt Designer），因为它检测到您要打开的文件上的`.ui`扩展名。
- en: You will also notice that the highlighted button on the mode selector panel
    has changed from **Edit** to **Design**. You can switch back to the script editor
    or change to any other tools by clicking one of the buttons located in the upper
    half of the mode selector panel.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还会注意到模式选择面板上高亮的按钮已从**编辑**更改为**设计**。您可以通过点击模式选择面板上半部分的按钮之一切换回脚本编辑器或切换到任何其他工具。
- en: Let’s go back to Qt Designer and look at the `mainwindow.ui` file. This is the
    main window of our program (as the filename implies) and it’s empty by default,
    without any widget on it. You can try to compile and run the program by pressing
    the **Run** button (the green arrow button) at the bottom of the mode selector
    panel; you will see an empty window pop up once the compilation is complete.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到Qt Designer，查看`mainwindow.ui`文件。这是我们的程序的主窗口（如文件名所示），默认情况下它是空的，没有任何小部件。您可以通过按下模式选择面板底部的**运行**按钮（绿色箭头按钮）来尝试编译并运行程序；一旦编译完成，您将看到一个空窗口弹出。
- en: Let’s add a push button to our program’s UI by clicking on the **Push Button**
    item in the **Widget Box** area (under the **Buttons** category) and dragging
    it to our main window in the form editor. Keep the push button selected; you will
    see all the properties of this button inside the **Property Editor** area on the
    right-hand side of your window. Scroll down to the middle and look for a property
    called **styleSheet**. This is where you will apply styles to your widget, which
    may or may not be inherited from its children or grandchildren recursively, depending
    on how you set your style sheet. Alternatively, you can right-click on any widget
    in your UI at the form editor and select **Change styleSheet...** from the pop-up
    menu.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在程序的UI中添加一个按钮，通过在**小部件框**区域（位于**按钮**类别下）点击**推按钮**项并将其拖动到表单编辑器中的主窗口中来实现。保持推按钮选中状态；您将在窗口右侧的**属性编辑器**区域看到该按钮的所有属性。向下滚动到中间，寻找一个名为**styleSheet**的属性。这就是您将应用样式到您的控件的地方，这些样式可能或可能不是从其子控件或孙控件递归继承的，具体取决于您如何设置样式表。或者，您可以在表单编辑器中的UI中的任何控件上右键单击，并从弹出菜单中选择**更改样式表...**。
- en: You can click on the input field of the **styleSheet** property to directly
    write the style sheet code, or click on the **…** button beside the input field
    to open up the **Edit Style Sheet** window, which has a bigger space for writing
    longer code for style sheets. At the top of the window, you can find several buttons,
    such as **Add Resource**, **Add Gradient**, **Add Color**, and **Add Font**, that
    can help you kickstart your coding if you can’t remember the properties’ names.
    Let’s try to do some simple styling with the **Edit Style** **Sheet** window.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以点击**styleSheet**属性的输入字段来直接编写样式表代码，或者点击输入字段旁边的**…**按钮来打开**编辑样式表**窗口，该窗口有更大的空间来编写较长的样式表代码。在窗口顶部，您可以找到几个按钮，例如**添加资源**、**添加渐变**、**添加颜色**和**添加字体**，如果您记不住属性名称，这些按钮可以帮助您开始编码。让我们尝试使用**编辑样式表**窗口进行一些简单的样式设置。
- en: Click **Add Color** and choose a color.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加颜色**并选择一种颜色。
- en: Pick a random color from the color picker window – let’s say, a pure red color.
    Then, click **OK**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从颜色选择器窗口中随机选择一种颜色——比如说，纯红色。然后，点击**确定**。
- en: 'A line of code has been added to the text field in the **Edit Style Sheet**
    window, which in my case is as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**编辑样式表**窗口的文本字段中已经添加了一行代码，在我的情况下如下所示：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Click the **OK** button; the text on your push button should change to red.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**按钮；您的推按钮上的文本应变为红色。
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let’s take a bit of time to get familiar with Qt Designer’s interface before
    we start learning how to design our own UI:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始学习如何设计自己的UI之前，让我们花点时间熟悉Qt Designer的界面：
- en: '![Figure 1.1 – Overview of Qt Designer’s interface](img/B20976_01_001.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – Qt Designer界面的概述](img/B20976_01_001.jpg)'
- en: Figure 1.1 – Overview of Qt Designer’s interface
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – Qt Designer界面的概述
- en: 'The explanation for the preceding screenshot is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图的解释如下：
- en: '**Menu bar**: The menu bar houses application-specific menus that provide easy
    access to essential functions, such as creating new projects, saving files, undoing,
    redoing, copying, and pasting. It also allows you to access development tools
    that come with Qt Creator, such as the compiler, debugger, and profiler.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**菜单栏**：菜单栏包含特定于应用程序的菜单，提供对基本功能的轻松访问，例如创建新项目、保存文件、撤销、重做、复制和粘贴。它还允许您访问Qt Creator附带的开发工具，例如编译器、调试器和性能分析器。'
- en: '**Widget Box**: This is where you can find all the different types of widgets
    provided by Qt Designer. You can add a widget to your program’s UI by clicking
    one of the widgets from the **Widget Box** area and dragging it to the form editor.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**部件箱**：在这里，您可以找到Qt Designer提供的所有不同类型的部件。您可以通过从**部件箱**区域中选择一个部件并将其拖动到表单编辑器中来将部件添加到程序的UI中。'
- en: '**Mode selector**: The mode selector is a side panel that places shortcut buttons
    for easy access to different tools. You can quickly switch between the script
    editor and form editor by clicking the **Edit** or **Design** button on the mode
    selector panel, which is very useful for multitasking. You can also easily navigate
    to the debugger and profiler tools at the same speed and manner.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模式选择器**：模式选择器是一个侧面板，其中放置了快捷按钮，以便轻松访问不同的工具。您可以通过点击模式选择器面板上的**编辑**或**设计**按钮快速在脚本编辑器和表单编辑器之间切换，这对于多任务处理非常有用。您还可以以相同的方式和速度轻松导航到调试器和性能分析工具。'
- en: '**Build shortcuts**: The build shortcuts are located at the bottom of the mode
    selector panel. You can build, run, and debug your project easily by pressing
    the shortcut buttons here.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建快捷键**：构建快捷键位于模式选择器面板的底部。您可以通过按下这里的快捷按钮轻松构建、运行和调试项目。'
- en: '**Form editor**: The form editor is where you edit your program’s UI. You can
    add different widgets to your program by selecting a widget from the **Widget
    Box** area and dragging it to the form editor.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**表单编辑器**：表单编辑器是您编辑程序UI的地方。您可以通过从**部件箱**区域选择一个部件并将其拖动到表单编辑器中来向程序添加不同的部件。'
- en: '**Form toolbar**: From here, you can quickly select a different form to edit.
    Click the drop-down box located at the top of the **Widget Box** area and select
    the file you want to open with Qt Designer. Beside the drop-down box are buttons
    to switch between the different modes of the form editor, and also buttons to
    change the layout of your UI.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**表单工具栏**：从这里，您可以快速选择要编辑的不同表单。点击**部件箱**区域顶部的下拉框并选择您想要用Qt Designer打开的文件。在下拉框旁边是按钮，用于在表单编辑器的不同模式之间切换，以及按钮用于更改UI布局。'
- en: '`.ui` file. All the widgets are arranged according to their parent-child relationship
    in the hierarchy. You can select a widget from the **Object Inspector** area to
    display its properties in the **Property** **Editor** area.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.ui`文件。所有部件都根据它们在层次结构中的父子关系排列。您可以从**对象检查器**区域选择一个部件，在**属性****编辑器**区域显示其属性。'
- en: '**Property Editor**: The **Property Editor** area will display all the properties
    of the widget you selected from either the **Object Inspector** area or the form
    editor window.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**属性编辑器**：**属性编辑器**区域将显示您从**对象检查器**区域或表单编辑器窗口中选择的部件的所有属性。'
- en: '**Action Editor** and **Signals & Slots Editor**: This window contains two
    editors: **Action Editor** and **Signals & Slots Editor**. Both can be accessed
    from the tabs beneath the window. **Action Editor** is where you create actions
    that can be added to a menu bar or toolbar in your program’s UI.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动作编辑器**和**信号与槽编辑器**：此窗口包含两个编辑器：**动作编辑器**和**信号与槽编辑器**。您可以通过窗口下方的标签访问这两个编辑器。**动作编辑器**是您创建可以添加到程序UI菜单栏或工具栏中的动作的地方。'
- en: '**Output panes**: Output panes consist of several different windows that display
    information and output messages related to script compilation and debugging. You
    can switch between different output panes by pressing the buttons that carry a
    number before them, such as **1 Issues**, **2 Search Results**, or **3** **Application
    Output**.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**输出面板**：输出面板由几个不同的窗口组成，显示与脚本编译和调试相关的信息和输出消息。您可以通过按下带有数字的按钮在不同输出面板之间切换，例如**1
    问题**、**2 搜索结果**或**3 应用程序输出**。'
- en: There’s more...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: In this recipe, we discussed how to apply style sheets to Qt widgets through
    C++ coding. Although that method works well, most of the time, the person who
    is in charge of designing the program’s UI is not the programmer, but rather a
    UI designer who specializes in designing user-friendly UI. In this case, it’s
    better to let the UI designer design the program’s layout and style sheet with
    a different tool and not mess around with the code. Qt provides an all-in-one
    editor called **Qt Creator**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们讨论了如何通过C++编码将样式表应用到Qt小部件上。虽然这种方法效果不错，但大多数情况下，负责设计程序UI的人不是程序员，而是一个专注于设计用户友好UI的UI设计师。在这种情况下，最好让UI设计师使用不同的工具来设计程序的布局和样式表，而不是与代码纠缠。Qt提供了一个名为**Qt
    Creator**的一站式编辑器。
- en: Qt Creator consists of several different tools, such as a script editor, compiler,
    debugger, profiler, and UI editor. The UI editor, which is also called **Qt Designer**,
    is the perfect tool for designers to design their program’s UI without writing
    any code. This is because Qt Designer adopted the *what you see is what you get*
    approach by providing an accurate visual representation of the final result, which
    means whatever you design with Qt Designer will turn out the same visually when
    the program is compiled and run.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Creator由几个不同的工具组成，例如脚本编辑器、编译器、调试器、性能分析器和UI编辑器。UI编辑器，也称为**Qt Designer**，是设计师在没有编写任何代码的情况下设计程序UI的完美工具。这是因为Qt
    Designer采用了*所见即所得*的方法，通过提供最终结果的准确视觉表示，这意味着你用Qt Designer设计的任何内容在程序编译和运行时都将具有相同的视觉表现。
- en: 'The similarities between Qt Style Sheets and CSS are as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Qt样式表与CSS之间的相似之处如下：
- en: 'This is how a typical piece of CSS code looks:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就是典型的CSS代码的样子：
- en: '[PRE1]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is how Qt Style Sheets look, which is almost the same as the preceding
    CSS:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这就是Qt样式表的样子，它与前面的CSS几乎相同：
- en: '[PRE2]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, both of them contain a selector and a declaration block. Each
    declaration contains a property and a value, separated by a colon. In Qt, a style
    sheet can be applied to a single widget by calling the `QObject::setStyleSheet()`
    function in C++ code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它们都包含一个选择器和声明块。每个声明包含一个属性和一个值，由冒号分隔。在Qt中，可以通过在C++代码中调用`QObject::setStyleSheet()`函数将样式表应用到单个小部件上。
- en: 'Consider the following, for example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下内容：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code will turn the text of a button with the `myPushButton` variable
    name to blue. You can achieve the same result by writing the declaration in the
    style sheet property field in Qt Designer. We will discuss Qt Designer more in
    the *Customizing basic style* *sheets* recipe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将`myPushButton`变量名的按钮文本变为蓝色。你同样可以通过在Qt Designer的样式表属性字段中编写声明来实现相同的结果。我们将在*自定义基本样式表*示例中进一步讨论Qt
    Designer。
- en: 'Qt Style Sheets also supports all the different types of selectors defined
    in the CSS2 standard, including the `usernameEdit` object name, we can do this
    by using an ID selector to refer to it:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Qt样式表还支持CSS2标准中定义的所有不同类型的选择器，包括`usernameEdit`对象名称，我们可以通过使用ID选择器来引用它：
- en: 'QLineEdit#usernameEdit { background-color: blue }'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'QLineEdit#usernameEdit { background-color: blue }'
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To learn about all the selectors available in CSS2 (which are also supported
    by Qt Style Sheets), please refer to this document: [http://www.w3.org/TR/REC-CSS2/selector.html](http://www.w3.org/TR/REC-CSS2/selector.html).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解CSS2中所有可用的选择器（Qt样式表也支持这些选择器），请参阅此文档：[http://www.w3.org/TR/REC-CSS2/selector.html](http://www.w3.org/TR/REC-CSS2/selector.html)。
- en: Customizing basic style sheets
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义基本样式表
- en: In the previous recipe, you learned how to apply a style sheet to a widget with
    Qt Designer. Let’s go crazy and push things further by creating a few other types
    of widgets and changing their style properties to something bizarre for the sake
    of learning.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，你学习了如何使用Qt Designer将样式表应用到小部件上。让我们疯狂一点，进一步探索，创建一些其他类型的小部件，并将它们的样式属性更改为一些奇怪的东西，以学习为目的。
- en: This time, however, we will not apply the style to every single widget one by
    one; instead, we will learn to apply the style sheet to the main window and let
    it inherit down the hierarchy to all the other widgets so that the style sheet
    is easier to manage and maintain in the long run.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一次，我们不会逐个将样式应用到每个小部件上；相反，我们将学习如何将样式表应用到主窗口，并让它向下继承到所有其他小部件，这样样式表就更容易在长期内进行管理和维护。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the following example, we will format different types of widgets on the
    canvas and add some code to the style sheet to change its appearance:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将对画布上的不同类型的小部件进行格式化，并在样式表中添加一些代码以改变其外观：
- en: Remove the style sheet from `PushButton` by selecting it and clicking the small
    arrow button beside the **styleSheet** property. This button will revert the property
    to its default value, which in this case is the empty style sheet.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择`PushButton`并单击**样式表**属性旁边的箭头按钮来从`PushButton`移除样式表。此按钮将属性还原为其默认值，在这种情况下是空样式表。
- en: Add a few more widgets to the UI by dragging them one by one from the **Widget
    Box** area to the form editor. I’ve added a line edit, combo box, horizontal slider,
    radio button, and a check box.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从**小部件框**区域逐个拖动它们到表单编辑器中，向UI添加更多小部件。我已经添加了一个行编辑器、组合框、水平滑块、单选按钮和一个复选框。
- en: 'For the sake of simplicity, delete **menuBar**, **mainToolBar**, and **statusBar**
    from your UI by selecting them in the **Object Inspector** area, right-clicking,
    and choosing **Remove**. Now, your UI should look similar to this:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化，通过在**对象检查器**区域选择它们，右键单击并选择**移除**来从你的UI中删除**菜单栏**、**主工具栏**和**状态栏**。现在，你的UI应该看起来类似于这样：
- en: '![Figure 1.2 – Dragging and dropping some widgets onto the form editor](img/B20976_01_002.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 将一些小部件拖放到表单编辑器中](img/B20976_01_002.jpg)'
- en: Figure 1.2 – Dragging and dropping some widgets onto the form editor
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 将一些小部件拖放到表单编辑器中
- en: 'Select the main window from either the form editor or the **Object Inspector**
    area, then right-click and choose **Change styleSheet...** to open the **Edit
    Style Sheet** window. Insert the following into the style sheet:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从表单编辑器或**对象检查器**区域选择主窗口，然后右键单击并选择**更改样式表...**以打开**编辑样式表**窗口。将以下内容插入到样式表中：
- en: '[PRE4]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will see a bizarre-looking UI with everything covered in yellow with a
    thick border. This is because the preceding style sheet does not have a selector,
    which means the style will apply to the children widgets of the main window down
    the hierarchy. To change that, let’s try something different:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到一个奇特的UI，所有内容都被黄色覆盖，并且有粗边框。这是因为前面的样式表没有选择器，这意味着样式将应用于主窗口层次结构下的子小部件。为了改变这一点，让我们尝试不同的方法：
- en: '[PRE5]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This time, only **PushButton** will get the style described in the preceding
    code, and all the other widgets will return to the default styling. You can try
    to add a few more push buttons to your UI; they will all look the same:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，只有**PushButton**将获得前面代码中描述的样式，所有其他小部件将恢复到默认样式。你可以尝试向你的UI添加更多按钮；它们都将看起来相同：
- en: '![Figure 1.3 – Changing the push buttons to yellow](img/B20976_01_003.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 将按钮改为黄色](img/B20976_01_003.jpg)'
- en: Figure 1.3 – Changing the push buttons to yellow
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 将按钮改为黄色
- en: 'This happens because we specifically tell the selector to apply the style to
    all the widgets with the `QPushButton` class. We can also apply the style to just
    one of the push buttons by mentioning its name in the style sheet, as shown in
    the following code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是因为我们明确告诉选择器将样式应用于具有`QPushButton`类的所有小部件。我们也可以通过在样式表中提及其名称来仅将样式应用于一个按钮，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once you understand this method, we can add the following code to the style
    sheet:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你理解了这种方法，我们就可以将以下代码添加到样式表中：
- en: '[PRE7]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code changes the style of all the push buttons, as well as some properties
    of the `pushButton_2` button. We keep the style sheet of `pushButton_3` as-is.
    Now, the buttons will look like this:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码会改变所有按钮的样式，以及`pushButton_2`按钮的一些属性。我们保持`pushButton_3`的样式表不变。现在，按钮将看起来像这样：
- en: '![Figure 1.4 – Applying a different style to each button](img/B20976_01_004.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 为每个按钮应用不同的样式](img/B20976_01_004.jpg)'
- en: Figure 1.4 – Applying a different style to each button
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 为每个按钮应用不同的样式
- en: The first set of style sheets will change all widgets of the `QPushButton` type
    to a white rectangular button with no border and red text. The second set of style
    sheets only changes the border of a specific `QPushButton` widget called `pushButton_2`.
    Notice that the background color and text color of `pushButton_2` remain white
    and red, respectively, because we didn’t override them in the second set of style
    sheets, hence it will return to the style described in the first set of style
    sheets since it applies to all the `QPushButton` widgets. The text of the third
    button has also changed to red because we didn’t describe the **Color** property
    in the third set of style sheets.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一组样式表将所有`QPushButton`类型的小部件更改为无边框的白色矩形按钮，文本为红色。第二组样式表仅更改名为`pushButton_2`的特定`QPushButton`小部件的边框。请注意，`pushButton_2`的背景颜色和文本颜色仍然分别是白色和红色，因为我们没有在第二组样式表中覆盖它们，因此它将返回到第一组样式表中描述的样式，因为它适用于所有`QPushButton`小部件。第三个按钮的文本也变为红色，因为我们没有在第三组样式表中描述**颜色**属性。
- en: 'Create another set of style sheets that use the universal selector by using
    the following code:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一组使用通用选择器的样式表，可以使用以下代码：
- en: '[PRE8]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The universal selector will affect all the widgets, regardless of their type.
    Therefore, the preceding style sheet will apply a nice gradient color to all the
    widgets’ backgrounds and set their text to white with a one-pixel solid outline
    that is also white. Instead of writing the name of the color (that is, white),
    we can use the `rgb` function (`rgb(255, 255, 255)`) or hex code (`#ffffff`) to
    describe the color value.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通用选择器将影响所有小部件，无论它们的类型如何。因此，前面的样式表将应用一个漂亮的渐变颜色到所有小部件的背景，并将它们的文本设置为白色，并带有白色的一像素实线轮廓。我们不需要写出颜色的名称（即白色），我们可以使用`rgb`函数（`rgb(255,
    255, 255)`）或十六进制代码（`#ffffff`）来描述颜色值。
- en: 'As before, the preceding style sheet will not affect the push buttons because
    we have already given them their own styles, which will override the general style
    described in the universal selector. Just remember that in Qt, the more specific
    style will ultimately be used when there is more than one style with an influence
    on a widget. This is how the UI will look now:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前一样，前面的样式表不会影响按钮，因为我们已经为它们提供了自己的样式，这将覆盖通用选择器中描述的通用样式。只需记住，在Qt中，当有多个样式影响小部件时，最终将使用更具体的样式。这就是UI现在的样子：
- en: '![Figure 1.5 – Applying a gradient background to all the other widgets](img/B20976_01_005.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 将渐变背景应用到所有其他小部件](img/B20976_01_005.jpg)'
- en: Figure 1.5 – Applying a gradient background to all the other widgets
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 将渐变背景应用到所有其他小部件
- en: How it works…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: If you are ever involved in web development using HTML and CSS, Qt’s style sheets
    work the same way as CSS. Style sheets provide the definitions to describe the
    presentation of the widgets – what the colors are for each element in the widget
    group, how thick the border should be, and so on. If you specify the name of the
    widget to the style sheet, it will change the style of the particular `PushButton`
    widget with the name you provide. None of the other widgets will be affected and
    will remain as the default style.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经参与过使用HTML和CSS的Web开发，Qt的样式表与CSS的工作方式相同。样式表提供了定义来描述小部件的展示——每个小部件组中每个元素的色彩是什么，边框应该有多厚，等等。如果你将小部件的名称指定给样式表，它将更改你提供的名称的特定`PushButton`小部件的样式。其他小部件将不受影响，并保持默认样式。
- en: To change the name of a widget, select the widget from either the form editor
    or the **Object Inspector** area and change the **objectName** property in the
    property window. If you used the ID selector previously to change the style of
    the widget, changing its object name will break the style sheet and lose the style.
    To fix this problem, simply change the object name in the style sheet as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改小部件的名称，从表编辑器或**对象检查器**区域选择小部件，并在属性窗口中更改**objectName**属性。如果你之前使用ID选择器更改小部件的样式，更改其对象名称将破坏样式表并丢失样式。要解决这个问题，只需在样式表中更改对象名称即可。
- en: Creating a login screen using style sheets
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用样式表创建登录屏幕
- en: Next, we will learn how to put all the knowledge we learned in the previous
    recipe together and create a fake graphical login screen for an imaginary operating
    system. Style sheets are not the only thing you need to master to design a good
    UI. You will also need to learn how to arrange the widgets neatly using the layout
    system in Qt Designer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何将之前学到的所有知识结合起来，为虚构的操作系统创建一个假图形登录界面。除了样式表之外，你还需要掌握如何使用 Qt Designer
    中的布局系统整齐地排列小部件。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let’s get started by following these steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤开始：
- en: 'We need to design the layout of the graphical login screen before we start
    doing anything. Planning is very important to produce good software. The following
    is a sample layout design I made to show you how I imagine the login screen will
    look. Just a simple line drawing like this is sufficient, so long as it conveys
    the message clearly:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始做任何事情之前，我们需要设计图形登录界面的布局。规划对于制作优秀的软件非常重要。以下是我制作的示例布局设计，以展示我如何想象登录界面的外观。只要能清楚地传达信息，这样的简单线条草图就足够了：
- en: '![Figure 1.6 – A simple drawing depicting the login screen](img/B20976_01_006.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – 描述登录界面的简单草图](img/B20976_01_006.jpg)'
- en: Figure 1.6 – A simple drawing depicting the login screen
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 描述登录界面的简单草图
- en: Go back to Qt Designer again.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次回到 Qt Designer。
- en: We will be placing the widgets at the top panel first, then the logo and the
    login form beneath it.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在顶部面板放置小部件，然后在下面放置标志和登录表单。
- en: Select the main window and change its width and height from `400` and `300`
    to `800` and `600`, respectively – we’ll need a bigger space in which to place
    all the widgets.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择主窗口，将其宽度和高度分别从`400`和`300`改为`800`和`600`——我们需要更大的空间来放置所有小部件。
- en: Click and drag a label under the **Display Widgets** category from the **Widget
    Box** area to the form editor.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**显示小部件**类别中点击并拖动一个标签到**小部件框**区域的表单编辑器。
- en: Change the `currentDateTime` and change its text property to the current date
    and time for display purposes – for example, `Wednesday, 25-10-2023` `3:14 PM`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`currentDateTime`并更改其文本属性以显示当前日期和时间——例如，`周三，25-10-2023` `3:14 PM`。
- en: Click and drag `PushButton` under the `restartButton` and `shutdownButton`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动`PushButton`到`restartButton`和`shutdownButton`下。
- en: Select the main window and click the small icon button on the form toolbar that
    says **Lay Out Vertically** when you mouse over it. You will see that the widgets
    are automatically arranged on the main window, but that’s not exactly what we
    want yet.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择主窗口，并点击表单工具栏上的小图标按钮，当鼠标悬停时它显示为**垂直布局**。你会看到小部件会自动排列在主窗口上，但这还不是我们想要的。
- en: Click and drag a **Horizontal Layout** widget under the **Layouts** category
    to the main window.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**布局**类别下，点击并拖动一个**水平布局**小部件到主窗口。
- en: Click and drag the two push buttons and the text label into the horizontal layout.
    You will see the three widgets being arranged in a horizontal row, but vertically,
    they are located in the middle of the screen. The horizontal arrangement is almost
    correct, but the vertical position is off.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动两个按钮和文本标签到水平布局中。你会看到三个小部件被排列成一行，但在垂直方向上，它们位于屏幕的中间。水平排列几乎正确，但垂直位置不正确。
- en: Click and drag a **Vertical Spacer** widget from the **Spacers** category and
    place it beneath the **Horizontal Layout** widget we created in *Step 9* (under
    the red rectangular outline). All the widgets will be pushed to the top by the
    spacer.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**间隔**类别中点击并拖动一个**垂直间隔**小部件，并将其放置在我们在第 9 步中创建的**水平布局**小部件下方（在红色矩形轮廓下）。所有小部件都会被间隔推到顶部。
- en: Place a **Horizontal Spacer** widget between the text label and the two buttons
    to keep them apart. This will ensure the text label always sticks to the left
    and the buttons align to the right.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本标签和两个按钮之间放置一个**水平间隔**小部件，以保持它们之间的距离。这将确保文本标签始终保持在左侧，而按钮则对齐到右侧。
- en: Set both the `55 x 55`. Set the **text** property of the buttons to empty, as
    we will be using icons instead of text. We will learn how to place an icon in
    the button widgets in the *Using resources in style* *sheets* recipe.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个按钮的`55 x 55`设置为相同。将按钮的**文本**属性设置为空，因为我们将会使用图标而不是文本。我们将在*使用样式表中的资源*菜谱中学习如何在按钮小部件中放置图标。
- en: 'Your UI should look similar to this:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的 UI 应该看起来像这样：
- en: '![Figure 1.7 – Pushing apart the text and buttons using a horizontal spacer](img/B20976_01_007.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – 使用水平间隔将文本和按钮分开](img/B20976_01_007.jpg)'
- en: Figure 1.7 – Pushing apart the text and buttons using a horizontal spacer
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 使用水平间距将文本和按钮分开
- en: 'Next, we will be adding the logo. Follow these steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加标志。按照以下步骤操作：
- en: Add a **Horizontal Layout** widget between the top panel and a **Vertical Spacer**
    widget to serve as a container for the logo.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部面板和**水平间距**小部件之间添加一个**水平布局**小部件，用作标志的容器。
- en: After adding the **Horizontal Layout** widget, you will find that the layout
    is way too thin in height (almost zero height) for you to add any widgets to it.
    This is because the layout is empty and it’s being pushed by the vertical spacer
    under it into zero height. To solve this problem, we can set its **vertical margin**
    (either **layoutTopMargin** or **layoutBottomMargin**) to be temporarily bigger
    until a widget is added to the layout.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加**水平布局**小部件后，您会发现布局的高度（几乎为零高度）太窄，以至于您无法向其中添加任何小部件。这是因为布局是空的，并且被其下的垂直间距推到零高度。为了解决这个问题，我们可以将其**垂直间距**（无论是**layoutTopMargin**还是**layoutBottomMargin**）临时设置得更大，直到向布局中添加小部件。
- en: Add a `logo`. We will learn more about how to insert an image into the label
    to use it as a logo in the *Using resources in style sheets* recipe. For now,
    just empty out the `150` `x 150`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`logo`。我们将在*使用样式表中的资源*配方中了解更多关于如何将图像插入到标签中，以便将其用作标志。现在，只需将`150` `x 150`清空即可。
- en: Set the vertical margin of the layout back to zero if you haven’t already done
    so.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请将布局的垂直间距设置回零。
- en: 'The logo will now appear to be invisible, so we will just place a temporary
    style sheet to make it visible until we add an image to it in the *Using resources
    in style sheets* recipe. The style sheet is really simple:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标志现在看起来将不可见，因此我们将放置一个临时样式表来使其可见，直到我们在*使用样式表中的资源*配方中添加图像。样式表非常简单：
- en: '[PRE9]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Your UI should look similar to this:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的UI应该看起来类似于这个：
- en: '![Figure 1.8 – Putting the placeholder logo in the middle](img/B20976_01_008.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8 – 将占位符标志放置在中间](img/B20976_01_008.jpg)'
- en: Figure 1.8 – Putting the placeholder logo in the middle
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 将占位符标志放置在中间
- en: 'Now, let’s create the login form:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建登录表单：
- en: Add a `100`) so that you can add a widget to it more easily.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`100`)，以便您可以更轻松地向其中添加小部件。
- en: Add a `20`) so that we can place widgets in it.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`20`)，以便我们可以将其中的小部件放置进去。
- en: Right-click the `QWidget` object, it will automatically inherit all the properties
    from the widget class, which means we can now adjust its size to suit our needs.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`QWidget`对象，它将自动继承小部件类的所有属性，这意味着我们现在可以调整其大小以满足我们的需求。
- en: Rename the `QWidget` object, which we just converted from the layout, `loginForm`
    and change both its `350` `x 200`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们刚刚从布局转换过来的`QWidget`对象重命名为`loginForm`，并将其大小改为`350 x 200`。
- en: Since we already placed the `loginForm` widget inside **Horizontal Layout**,
    we can set its **layoutTopMargin** property back to zero.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经在**水平布局**中放置了`loginForm`小部件，我们可以将其**layoutTopMargin**属性设置回零。
- en: 'Add the same style sheet that you did for the logo to the `loginForm` widget
    to make it visible temporarily. However, this time, we need to add an ID selector
    in front so that it will only apply the style to `loginForm` and not its children
    widgets:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您为标志添加的相同样式表添加到`loginForm`小部件中，使其临时可见。然而，这次，我们需要在前面添加一个ID选择器，以便它只会将样式应用于`loginForm`而不是其子小部件：
- en: '[PRE10]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Your UI should look something like this:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的UI应该看起来类似于这个：
- en: '![Figure 1.9 – Constructing the frame for the login form](img/B20976_01_009.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9 – 构建登录表单的框架](img/B20976_01_009.jpg)'
- en: Figure 1.9 – Constructing the frame for the login form
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – 构建登录表单的框架
- en: 'We are not done with the login form yet. Now that we have created the container
    for the login form, it’s time to put more widgets into the form:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成登录表单。现在我们已经创建了登录表单的容器，是时候将更多小部件放入表单中：
- en: 'Place two horizontal layouts in the login form container. We need two layouts:
    one for the username field and another for the password field.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在登录表单容器中放置两个水平布局。我们需要两个布局：一个用于用户名字段，另一个用于密码字段。
- en: Add `Username:` and the one beneath to `Password:`. Rename the two line edits
    to `username` and `password`, respectively.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Username:`和其下方的`Password:`添加到`loginForm`中。将两个行编辑分别重命名为`username`和`password`。
- en: Add a push button beneath the password layout and change its `Login`. Rename
    it `loginButton`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在密码布局下方添加一个按钮，并将其`Login`改为`loginButton`。
- en: You can add a `Login` button to distance them slightly. After the `5`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在`5`之后添加一个`Login`按钮，以稍微分隔它们。
- en: Select the `loginForm` container and set all its margins to `35`. This is to
    make the login form look better by adding some space to all its sides.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`loginForm`容器并将其所有边距设置为`35`。这是为了通过在其所有边上添加一些空间来使登录表单看起来更好。
- en: Set the `Username`, `Password`, and `loginButton` widgets to `25` so that they
    don’t look so cramped.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Username`、`Password`和`loginButton`小部件的值设置为`25`，这样它们看起来就不会那么拥挤。
- en: 'Your UI should look something like this:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的UI应该看起来像这样：
- en: '![Figure 1.10 – Adding widgets to the login form](img/B20976_01_010.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图1.10 – 向登录表单添加小部件](img/B20976_01_010.jpg)'
- en: Figure 1.10 – Adding widgets to the login form
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 – 向登录表单添加小部件
- en: Note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Alternatively, you can use a grid layout for the **Username** and **Password**
    fields to keep their sizes uniform.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用网格布局来保持**Username**和**Password**字段的大小一致。
- en: 'We’re not done yet! As you can see, the login form and the logo are both sticking
    to the top of the main window due to the **Vertical Spacer** widget beneath them.
    The logo and the login form should be placed at the center of the main window
    instead of the top. To fix this problem, follow these steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成！正如你所见，由于它们下面的**垂直间距**小部件，登录表单和标志都粘附在主窗口的顶部。标志和登录表单应该放置在主窗口的中心而不是顶部。要解决这个问题，请按照以下步骤操作：
- en: Add another **Vertical Spacer** widget between the top panel and the logo’s
    layout. This will counter the spacer at the bottom to balance out the alignment.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部面板和标志布局之间添加另一个**垂直间距**小部件。这将抵消底部的间距，以平衡对齐。
- en: If you think that the logo is sticking too close to the login form, you can
    add a `10`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你认为标志与登录表单的距离太近，你可以添加一个`10`。
- en: Right-click the top panel’s layout and choose `topPanel`. The layout must be
    converted into **QWidget** because we cannot apply style sheets to a layout. This
    is because a layout doesn’t have any properties other than margins.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击顶部面板的布局并选择`topPanel`。布局必须转换为**QWidget**，因为我们不能将样式表应用到布局上。这是因为布局除了边距之外没有其他属性。
- en: There is a little bit of a margin around the edges of the main window – we don’t
    want that. To remove the margins, select the **centralWidget** object from the
    **Object Inspector** window, which is right under the **MainWindow** panel, and
    set all the margin values to zero.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主窗口的边缘有一点边距 – 我们不希望这样。要删除边距，请从**对象检查器**窗口中选择**centralWidget**对象，该窗口位于**MainWindow**面板下方，并将所有边距值设置为零。
- en: 'Run the project by clicking the **Run** button (with the green arrow icon)
    to see what your program looks like. If everything goes well, you should see something
    like this:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击**运行**按钮（带有绿色箭头图标）来运行项目，看看你的程序看起来像什么。如果一切顺利，你应该看到如下所示的内容：
- en: '![Figure 1.11 – We’re done with the layout – for now](img/B20976_01_011.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图1.11 – 我们完成了布局 – 至少目前是这样](img/B20976_01_011.jpg)'
- en: Figure 1.11 – We’re done with the layout – for now
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 – 我们完成了布局 – 至少目前是这样
- en: Now, let’s decorate the UI using style sheets! Since all the important widgets
    have been given object names, it’s easier for us to apply the style sheets to
    them from the main window since we will only write the style sheets to the main
    window and let them inherit down the hierarchy tree.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用样式表来装饰UI！由于所有重要的小部件都已经赋予了对象名称，因此从主窗口应用样式表到它们会更容易，因为我们只需将样式表写入主窗口，并让它们从层次结构树中继承下来。
- en: Right-click on **MainWindow** from the **Object Inspector** area and choose
    **Change styleSheet...**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**对象检查器**区域中右键单击**MainWindow**，然后选择**更改样式表...**。
- en: 'Add the following code to the style sheet:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到样式表中：
- en: '[PRE11]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The background of the main window will change color. We will learn how to use
    an image for the background in the *Using resources in style sheets* recipe. So,
    the color is just temporary.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主窗口的背景将改变颜色。我们将在*使用样式表中的资源*配方中学习如何使用图像作为背景。所以，颜色只是临时的。
- en: In Qt, if you want to apply styles to the main window itself, you must apply
    them to its **centralWidget** widget instead of the main window since the window
    is just a container.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Qt中，如果你想将样式应用到主窗口本身，你必须将其应用到其**centralWidget**小部件上，而不是主窗口，因为窗口只是一个容器。
- en: 'Add a nice gradient color to the top panel:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部面板上添加一个漂亮的渐变色：
- en: '[PRE12]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Apply the black color to the login form and make it look semi-transparent.
    We will also make the corners of the login form container slightly rounded by
    setting the `border-radius` property:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将黑色应用到登录表单，并使其看起来半透明。我们还将通过设置`border-radius`属性使登录表单容器的角落略微圆滑：
- en: '[PRE13]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Apply styles to the general types of widgets:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将样式应用到小部件的一般类型：
- en: '[PRE14]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding style sheets will change all the labels’ texts to a white color;
    this includes the text on the widgets as well because, internally, Qt uses the
    same type of label on the widgets that have text on them. Also, we made the corners
    of the line edit widgets slightly rounded.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的样式表将所有标签的文本颜色更改为白色；这包括小部件上的文本，因为内部 Qt 使用与具有文本的小部件相同的标签类型。此外，我们还使行编辑小部件的角落略微圆滑。
- en: 'Apply style sheets to all the push buttons on our UI:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将样式表应用于我们 UI 上的所有按钮：
- en: '[PRE15]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding style sheet changes the text of all the buttons to a white color,
    then sets its background color to blue, and makes its corners slightly rounded.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前样式表将所有按钮的文本颜色改为白色，然后将背景颜色设置为蓝色，并使其角落略微圆滑。
- en: 'To push things even further, we will make it so that the color of the push
    buttons changes when we mouse over it by using the `hover` keyword:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更进一步，我们将使用 `hover` 关键字使按钮的颜色在鼠标悬停时改变：
- en: '[PRE16]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding style sheet will change the background color of the push buttons
    to green when we mouse over them. We will talk more about this in the *Customizing
    properties and* *sub-controls* recipe.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们将鼠标悬停在按钮上时，之前的样式表将按钮的背景颜色更改为绿色。我们将在*自定义属性和* *子控件* 菜单中进一步讨论这一点。
- en: You can further adjust the size and margins of the widgets to make them look
    even better. Remember to remove the border line of the login form by removing
    the style sheet that we applied directly to it in *step 6*.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以进一步调整小部件的大小和边距，使它们看起来更好。请记住，通过移除在 *步骤 6* 中直接应用于登录表单的样式表来移除登录表单的边框线。
- en: 'Your login screen should look something like this:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的登录屏幕应该看起来像这样：
- en: '![Figure 1.12 – Applying colors and styles to the widgets](img/B20976_01_012.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12 – 将颜色和样式应用于小部件](img/B20976_01_012.jpg)'
- en: Figure 1.12 – Applying colors and styles to the widgets
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 将颜色和样式应用于小部件
- en: How it works…
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This example focused more on the layout system of Qt. Qt’s layout system allows
    our application GUI to automatically arrange itself within the given space by
    arranging the children objects of each widget. The spacer items that we used in
    this recipe help push the widgets contained in a layout outward to create spacing
    along the width of the spacer item.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例更多地关注 Qt 的布局系统。Qt 的布局系统允许我们的应用程序 GUI 通过排列每个小部件的子对象自动在给定空间内排列自己。我们在此菜谱中使用的空格项有助于将布局中包含的小部件推向外部，从而在空格项的宽度上创建间距。
- en: 'To locate a widget in the middle of the layout, we must put two spacer items
    into the layout: one on the left-hand side of the widget and one on the right-hand
    side of the widget. The widget will then be pushed to the middle of the layout
    by the two spacers.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要在布局中间定位小部件，我们必须在布局中放入两个空格项：一个在小部件的左侧，一个在小部件的右侧。然后，两个空格会将小部件推向布局的中间。
- en: Using resources in style sheets
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在样式表中使用资源
- en: Qt provides us with a platform-independent resource system that allows us to
    store any type of file in our program’s executable for later use. There is no
    limit to the types of files we can store in our executable – images, audio, video,
    HTML, XML, text files, binary files, and so on are all permitted.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 为我们提供了一个平台无关的资源系统，允许我们将任何类型的文件存储在我们的程序的可执行文件中以供以后使用。我们可以在可执行文件中存储的文件类型没有限制——图像、音频、视频、HTML、XML、文本文件、二进制文件等等都是允许的。
- en: The resource system is really useful for embedding resource files (such as icons
    and translation files) into the executable so that it can be accessed by the application
    at any time. To achieve this, we must tell Qt which files we want to add to its
    resource system in the `.qrc` file; Qt will handle the rest during the build process.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 资源系统对于将资源文件（如图标和翻译文件）嵌入可执行文件以便应用程序随时访问非常有用。为了实现这一点，我们必须在`.qrc`文件中告诉 Qt 我们想要添加到其资源系统中的文件；Qt
    将在构建过程中处理其余部分。
- en: How to do it…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To add a new `.qrc` file to our project, go to `resources`) and click the `.qrc`
    file will now be created and automatically opened by Qt Creator. You don’t have
    to edit the `.qrc` file directly in XML format as Qt Creator provides you with
    the user interface to manage your resources.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新的 `.qrc` 文件添加到我们的项目中，请转到 `resources`) 并点击 `.qrc` 文件现在将被 Qt Creator 创建并自动打开。您不需要直接以
    XML 格式编辑 `.qrc` 文件，因为 Qt Creator 为您提供了用户界面来管理您的资源。
- en: 'To add images and icons to your project, you need to make sure that the images
    and icons are being placed in your project’s directory. While the `.qrc` file
    is opened in Qt Creator, click the **Add** button, followed by the **Add Prefix**
    button. The prefix is used to categorize your resources so that they can be better
    managed when you have a ton of resources in your project:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图像和图标添加到你的项目中，你需要确保图像和图标被放置在你的项目目录中。当`.qrc`文件在Qt Creator中打开时，点击**添加**按钮，然后点击**添加前缀**按钮。前缀用于对资源进行分类，以便在项目中有大量资源时能更好地管理：
- en: Rename the prefix you just created to `/icons`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你刚刚创建的前缀重命名为`/icons`。
- en: Create another prefix by clicking **Add**, followed by **Add Prefix**.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**添加**，然后点击**添加前缀**来创建另一个前缀。
- en: Rename the new prefix `/images`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新前缀重命名为`/images`。
- en: Select the `/icon` prefix and click **Add**, followed by **Add Files**.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`/icon`前缀，然后点击**添加**，接着点击**添加文件**。
- en: A file selection window will appear; use that to select all the icon files.
    You can select multiple files at a time by holding the *Ctrl* key on your keyboard
    while clicking on the files to select them. Click **Open** once you’re done.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会出现一个文件选择窗口；使用它来选择所有图标文件。你可以在按住键盘上的*Ctrl*键的同时点击文件来选择多个文件。完成后点击**打开**。
- en: Select the `/images` prefix and click the **Add** button, followed by the **Add
    Files** button. The file-selection window will pop up again; this time, we will
    select the background image.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`/images`前缀，然后点击**添加**按钮，接着点击**添加文件**按钮。将再次弹出文件选择窗口；这次我们将选择背景图像。
- en: 'Repeat the preceding steps, but this time, we will add the logo image to the
    `/images` prefix. Don’t forget to save once you’re done by pressing *Ctrl* + *S*.
    Your `.qrc` file should now look like this:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复前面的步骤，但这次我们将把标志图像添加到`/images`前缀。完成后，按*Ctrl* + *S*保存。你的`.qrc`文件现在应该看起来像这样：
- en: '![Figure 1.13 – Showing the structure of the resource file](img/B20976_01_013.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图1.13 – 显示资源文件的结构](img/B20976_01_013.jpg)'
- en: Figure 1.13 – Showing the structure of the resource file
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 – 显示资源文件的结构
- en: Go back to the `mainwindow.ui` file; let’s make use of the resources we have
    just added to our project. Select the restart button located on the top panel.
    Scroll down the **Property Editor** area until you see the **icon** property.
    Click the little button with a drop-down arrow icon and click **Choose Resources**
    from its menu.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`mainwindow.ui`文件；让我们利用我们刚刚添加到项目中的资源。选择位于顶部面板上的重启按钮。滚动到**属性编辑器**区域，直到你看到**图标**属性。点击带有下拉箭头图标的小按钮，并从其菜单中选择**选择资源**。
- en: The **Select Resource** window will pop up. Click on the icons prefix on the
    left panel and select the restart icon on the right panel. Press **OK**.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选择资源**窗口将弹出。在左侧面板上点击图标前缀，然后在右侧面板上选择重启图标。按**确定**。'
- en: A tiny icon will appear on the button. This icon looks very tiny because the
    default icon size is set to `16 x 16`. Change the `50 x 50`; you will see that
    the icon appears bigger. Repeat the preceding steps for the shutdown button, except
    this time, choose the shutdown icon instead.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮上会出现一个小图标。这个图标看起来非常小，因为默认图标大小设置为`16 x 16`。将其更改为`50 x 50`；你会看到图标变得更大。重复前面的步骤为关机按钮，这次选择关机图标。
- en: 'The two buttons should now look like this:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个按钮现在应该看起来像这样：
- en: '![Figure 1.14 – Applying icons to the push buttons](img/B20976_01_014.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图1.14 – 将图标应用到按钮上](img/B20976_01_014.jpg)'
- en: Figure 1.14 – Applying icons to the push buttons
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 – 将图标应用到按钮上
- en: Let’s use the image we added to the resource file as our logo. Select the logo
    widget and remove the style sheet that we added earlier to render its outline.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用添加到资源文件中的图像作为我们的标志。选择标志小部件，并移除我们之前添加的样式表以渲染其轮廓。
- en: Scroll down the **Property Editor** area until you see the **pixmap** property.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到**属性编辑器**区域，直到你看到**pixmap**属性。
- en: Click the little drop-down button behind the **pixmap** property and select
    **Choose Resources** from the menu. Select the logo image and click **OK**. The
    logo size no longer follows the dimension you set previously; it follows the actual
    dimension of the image instead. We cannot change its dimension because this is
    simply how the **pixmap** property works.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**pixmap**属性后面的下拉小按钮，并从菜单中选择**选择资源**。选择标志图像并点击**确定**。标志的大小不再遵循你之前设置的维度；它遵循图像的实际维度。我们无法更改其维度，因为这正是**pixmap**属性的工作方式。
- en: 'If you want more control over the logo’s dimension, you can remove the image
    from the **pixmap** property and use a style sheet instead. You can use the following
    code to apply an image to the icon container:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想对标志的尺寸有更多控制，你可以从 **pixmap** 属性中移除图像，并使用样式表代替。你可以使用以下代码将图像应用到图标容器中：
- en: '[PRE17]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To obtain the path of the image, right-click the image’s name in the file list
    window and choose **Copy path**. The path will be saved to your operating system’s
    clipboard; now, you can just paste it into the preceding style sheet. Using this
    method will ensure that the image fits the dimensions of the widget that you applied
    the style to. Your logo should now appear like what’s shown in the following screenshot:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取图像的路径，在文件列表窗口中右键单击图像的名称，并选择 **复制路径**。路径将被保存到你的操作系统剪贴板；现在，你只需将其粘贴到前面的样式表中。使用这种方法将确保图像适合你应用样式的控件尺寸。现在，你的标志应该看起来像以下截图所示：
- en: '![Figure 1.15 – The logo is now appearing at the top of the login form](img/B20976_01_015.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.15 – 标志现在出现在登录表单的顶部](img/B20976_01_015.jpg)'
- en: Figure 1.15 – The logo is now appearing at the top of the login form
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.15 – 标志现在出现在登录表单的顶部
- en: 'Apply the wallpaper image to the background using a style sheet. Since the
    background dimension will change according to the window size, we cannot use `border-image`
    property in a style sheet. Right-click the main window and select **Change styleSheet...**
    to open the **Edit Style Sheet** window. We will add a new line under the style
    sheet of the **centralWidget** widget:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用样式表将壁纸图像应用到背景上。由于背景尺寸会根据窗口大小变化，我们无法在样式表中使用 `border-image` 属性。右键单击主窗口并选择 **更改样式表...**
    以打开 **编辑样式表** 窗口。我们将在 **centralWidget** 小部件的样式表下添加一行新内容：
- en: '[PRE18]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It’s really that simple and easy! Your login screen should now look like this:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真的是非常简单和容易！你的登录屏幕现在应该看起来像这样：
- en: '![Figure 1.16 – The final result looks neat](img/B20976_01_016.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.16 – 最终结果看起来整洁](img/B20976_01_016.jpg)'
- en: Figure 1.16 – The final result looks neat
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.16 – 最终结果看起来整洁
- en: How it works…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The resource system in Qt stores binary files, such as images and translation
    files, in the executable when it gets compiled. It reads the `.qrc`) in your project
    to locate the files that need to be stored in the executable and include them
    in the build process. A `.qrc` file looks something like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 的资源系统在编译时将二进制文件，如图像和翻译文件，存储在可执行文件中。它读取你的项目中的 `.qrc`) 以定位需要存储在可执行文件中的文件，并将它们包含在构建过程中。一个
    `.qrc` 文件看起来像这样：
- en: '[PRE19]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It uses `.qrc` file, or one of its subdirectories.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 `.qrc` 文件，或其子目录之一。
- en: Customizing properties and sub-controls
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义属性和子控件
- en: Qt’s style sheet system enables us to create stunning and professional-looking
    UIs with ease. In this example, we will learn how to set custom properties for
    our widgets and use them to switch between different styles.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 的样式表系统使我们能够轻松地创建令人惊叹且专业的 UI。在这个例子中，我们将学习如何为我们的小部件设置自定义属性，并使用它们在不同的样式之间切换。
- en: How to do it…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to customize widget properties and sub-controls:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤自定义小部件属性和子控件：
- en: 'Let’s create a new Qt project. I have prepared the UI for this purpose. The
    UI contains three buttons on the left-hand side and a **tab widget** with three
    pages located on the right-hand side, as shown in the following screenshot:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 Qt 项目。我已经为此准备了 UI。UI 包含左侧的三个按钮和右侧的 **标签小部件**，其中包含三个页面，如下面的截图所示：
- en: '![Figure 1.17 – Basic user interface with three tabs and buttons](img/B20976_01_017.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.17 – 基本用户界面，包含三个标签和按钮](img/B20976_01_017.jpg)'
- en: Figure 1.17 – Basic user interface with three tabs and buttons
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17 – 基本用户界面，包含三个标签和按钮
- en: 'The three buttons are blue because I’ve added the following style sheet to
    the main window (not to the individual button):'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个按钮是蓝色的，因为我已经将以下样式表添加到主窗口中（而不是单独的按钮）：
- en: '[PRE20]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'I will explain what **pseudo-states** are in Qt by adding the following style
    sheet to the main window. You might be familiar with this:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将通过向主窗口添加以下样式表来解释 Qt 中的 **伪状态** 是什么。你可能已经熟悉这个了：
- en: '[PRE21]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We used the preceding style sheet in the *Creating a login screen using style
    sheets* recipe, to make the buttons change color when there is a mouse-over event.
    This is made possible by Qt Style Sheet’s `hover` separated from the `QPushButton`
    class by a colon. Every widget has a set of generic pseudo-states, such as `QPushButton`,
    but not for `QLineEdit`. Let’s add the **pressed** pseudo-state to change the
    buttons’ color to yellow when the user clicks on it:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 *使用样式表创建登录界面* 的配方中使用了前面的样式表，使按钮在鼠标悬停事件发生时改变颜色。这是通过 Qt 样式表的 `hover` 与 `QPushButton`
    类通过冒号分隔来实现的。每个小部件都有一组通用伪状态，例如 `QPushButton`，但不是 `QLineEdit`。让我们添加一个 **pressed**
    伪状态，当用户点击按钮时将按钮的颜色变为黄色：
- en: '[PRE22]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Pseudo-states allow the users to load a different set of style sheets based
    on the condition that applies to them. Qt pushes this concept further by implementing
    **dynamic properties** in Qt Style Sheets. This allows us to change the style
    sheet of a widget when a custom condition has been met. We can make use of this
    feature to change the style sheet of our buttons based on a custom condition that
    we can set using custom properties in Qt. First, we will add this style sheet
    to our main window:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 伪状态允许用户根据适用于他们的条件加载不同的样式表集。Qt 通过在 Qt 样式表中实现 **动态属性** 来进一步推进这一概念。这允许我们在满足自定义条件时更改小部件的样式表。我们可以利用这个特性，根据我们可以在
    Qt 中使用自定义属性设置的特定条件来更改按钮的样式表。首先，我们将添加此样式表到我们的主窗口：
- en: '[PRE23]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This changes the push button’s background color to red if the `pagematches`
    property returns `QPushButton` class. However, we can add it to our buttons using
    `QObject::setProperty()`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将如果 `pagematches` 属性返回 `QPushButton` 类，则将按钮的背景颜色更改为红色。然而，我们可以使用 `QObject::setProperty()`
    将它添加到我们的按钮中：
- en: 'In your `mainwindow.cpp` source code, add the following code right after `ui->setupUi(this)`:'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的 `mainwindow.cpp` 源代码中，在 `ui->setupUi(this)` 之后添加以下代码：
- en: '[PRE24]'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code will add a custom property called `pagematches` to the first
    button and set its value as true. This will make the first button turn red by
    default.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将为第一个按钮添加一个名为 `pagematches` 的自定义属性，并将其值设置为 true。这将使第一个按钮默认变为红色。
- en: 'After that, right-click on `currentChanged(int)` option from the list and click
    **OK**. Qt will generate a slot function for you, which looks something like this:'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，从列表中右键单击 `currentChanged(int)` 选项，并点击 **OK**。Qt 将为你生成一个槽函数，看起来像这样：
- en: '[PRE25]'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `mainwindow.cpp`; you will see the function’s declaration there. Let’s
    add some code to the function:'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将在 `mainwindow.cpp` 中看到函数的声明。让我们向该函数添加一些代码：
- en: '[PRE26]'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code sets the `pagematches` properties of all three buttons to
    **false** when **Tab Widget** switches its current page. Be sure to reset everything
    before we decide which button should change to red.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码在 **Tab Widget** 切换到当前页面时将所有三个按钮的 `pagematches` 属性设置为 **false**。在决定哪个按钮应该变为红色之前，请确保重置一切。
- en: Check the `index` variable supplied by the event signal; this will tell you
    the index number of the current page. Set the `pagematches` property of one of
    the buttons to `index` number.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查由事件信号提供的 `index` 变量；这将告诉你当前页面的索引号。将一个按钮的 `pagematches` 属性设置为 `index` 号。
- en: 'Refresh the style of all three buttons by calling `polish()`. You may also
    want to add the following header to `mainwindow.h`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `polish()` 来刷新所有三个按钮的样式。你可能还希望在 `mainwindow.h` 中添加以下头文件：
- en: '[PRE27]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Build and run the project. You should now see the three buttons changing to
    red whenever you switch **Tab Widget** to a different page. Also, the buttons
    will change to green when there is a mouse-over, as well as change to yellow when
    you click on them:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行项目。现在你应该看到每次你将 **Tab Widget** 切换到不同的页面时，三个按钮都会变为红色。此外，当鼠标悬停时，按钮将变为绿色，当你点击它们时，颜色将变为黄色：
- en: '![Figure 1.18 – The final result looks like this](img/B20976_01_018.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.18 – 最终结果看起来是这样的](img/B20976_01_018.jpg)'
- en: Figure 1.18 – The final result looks like this
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.18 – 最终结果看起来是这样的
- en: How it works…
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Qt provides users the freedom to add custom properties to any type of widget.
    Custom properties are very useful if you want to change a particular widget when
    a special condition is met, whereas Qt doesn’t provide such a context by default.
    This allows the user to extend the usability of Qt and makes it a flexible tool
    for customized solutions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 为用户提供添加任何类型小部件自定义属性的自由。如果你想在满足特定条件时更改特定小部件，自定义属性非常有用，而 Qt 默认不提供这样的上下文。这允许用户扩展
    Qt 的可用性，使其成为定制解决方案的灵活工具。
- en: For example, if we have a row of buttons on our main window and we need one
    of them to change its color depending on which page `QObject::setProperty()`.
    To read the custom property, we can use another function called `QObject::property()`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们主窗口上有一排按钮，并且我们需要其中一个按钮根据页面改变其颜色，我们可以使用`QObject::setProperty()`。要读取自定义属性，我们可以使用另一个名为`QObject::property()`的函数。
- en: Next, we will talk about sub-controls in Qt Style Sheets. Often, a widget is
    not just a single object, but a combination of more than one object or control,
    used to form a more complex widget. These objects are called **sub-controls**.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论Qt样式表中的子控件。通常，一个小部件不仅仅是一个单独的对象，而是由多个对象或控件组合而成，用于形成一个更复杂的小部件。这些对象被称为**子控件**。
- en: 'For example, a spin box widget contains an input field, a down button, an up
    button, an up arrow, and a down arrow, which is quite complicated compared to
    some other widgets. In this case, Qt grants us more flexibility by allowing us
    to change every sub-control using a style sheet if we want to. We can do so by
    specifying the name of the sub-control behind the widget’s class name, separated
    by a double colon. For instance, if I want to change the image of the down button
    to a spin box, I can write my style sheet as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个旋转框小部件包含一个输入字段、一个下按钮、一个上按钮、一个上箭头和一个下箭头，与一些其他小部件相比，这相当复杂。在这种情况下，Qt通过允许我们通过样式表更改每个子控件来赋予我们更多的灵活性。我们可以通过在控件类名后面指定子控件的名称来实现，名称由双冒号分隔。例如，如果我想将下按钮的图像更改为旋转框，我可以将我的样式表编写如下：
- en: '[PRE28]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will only apply the image to the down button of my spin box, and not to
    any other parts of the widget. By combining **custom properties**, **pseudo-states**,
    and **sub-controls**, Qt provides us with a very flexible method to customize
    our user interface.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会将图像应用到我的旋转框的下按钮，而不会应用到小部件的任何其他部分。通过结合**自定义属性**、**伪状态**和**子控件**，Qt为我们提供了一个非常灵活的方法来自定义我们的用户界面。
- en: Note
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Visit the following link to learn more about pseudo-states and subcontrols
    in Qt: [http://doc.qt.io/qt-6/stylesheet-reference.html](http://doc.qt.io/qt-6/stylesheet-reference.html).'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 访问以下链接了解有关Qt中伪状态和子控件的更多信息：[http://doc.qt.io/qt-6/stylesheet-reference.html](http://doc.qt.io/qt-6/stylesheet-reference.html)。
- en: Styling in Qt Modeling Language (QML)
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt建模语言（QML）中的样式
- en: '**Qt Meta Language** or **Qt Modeling Language** (**QML**) is a JavaScript-inspired
    user interface markup language that’s used by Qt to design user interfaces. Qt
    provides you with **Qt Quick Components** (widgets powered by the QML technology)
    to easily design touch-friendly UI without C++ programming. We will learn more
    about how to use QML and Qt Quick Components to design our program’s UI by following
    the steps provided in this recipe.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt元语言**或**Qt建模语言**（**QML**）是一种受JavaScript启发的用户界面标记语言，Qt用它来设计用户界面。Qt为你提供了**Qt
    Quick组件**（由QML技术驱动的控件），以便在不使用C++编程的情况下轻松设计触摸友好的UI。我们将通过遵循本食谱中提供的步骤来学习如何使用QML和Qt
    Quick组件来设计我们程序的UI。'
- en: How to do it…
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps to learn about styling in QML:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤了解QML中的样式：
- en: 'Since Qt 6, The Qt Company has released a separate program called **Qt Design
    Studio** for developing Qt Quick applications. It’s intended to separate the different
    tasks of designers and programmers. So, if you’re a GUI designer, you should use
    **Qt Design Studio**, while sticking to Qt Creator if you’re a programmer. Once
    you have installed and opened Qt Design Studio, create a new project by pressing
    on the big **Create Project…** button or by going to **File** | **New Project…**
    from the top menu:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自从Qt 6以来，Qt公司发布了一个名为**Qt Design Studio**的独立程序，用于开发Qt Quick应用程序。它的目的是将设计师和程序员的任务分开。因此，如果你是GUI设计师，你应该使用**Qt
    Design Studio**，如果你是程序员，则应坚持使用Qt Creator。一旦安装并打开Qt Design Studio，可以通过点击大号**创建项目…**按钮或从顶部菜单中选择**文件**
    | **新建项目…**来创建一个新项目：
- en: '![Figure 1.19 – Creating a new QML project in Qt Design Studio](img/B20976_01_019.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图1.19 – 在Qt Design Studio中创建新的QML项目](img/B20976_01_019.jpg)'
- en: Figure 1.19 – Creating a new QML project in Qt Design Studio
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.19 – 在Qt Design Studio中创建新的QML项目
- en: Once the **New Project** window appears, key in the default width and height
    of your project window and insert a name for your project. Then, select the directory
    where you want your project to be created, select a default GUI style, pick a
    target Qt version, and click the **Create** button. Your Qt Quick project will
    now be created by Qt Design Studio.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 **新建项目** 窗口出现时，输入项目窗口的默认宽度和高度，并为你的项目输入一个名称。然后，选择你想要创建项目所在的目录，选择默认的 GUI 风格，选择目标
    Qt 版本，并点击 **创建** 按钮。现在，Qt Design Studio 将创建你的 Qt Quick 项目。
- en: 'There are some differences between a `App.qml` file inside the project resource.
    This `.qml` file is the UI description file that’s written using the QML markup
    language. If you double-click the `main.qml` file, Qt Creator will open the script
    editor and you will see something like this:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源中，`App.qml` 文件与其他文件有一些区别。这个 `.qml` 文件是使用 QML 标记语言编写的 UI 描述文件。如果你双击 `main.qml`
    文件，Qt Creator 将打开脚本编辑器，你会看到如下内容：
- en: '[PRE29]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This file tells Qt to create a window that loads the **Screen01** user interface
    and a window title with your project name. The **Screen01** interface comes from
    another file called **Screen01.ui.qml**.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此文件指示 Qt 创建一个窗口，加载 **Screen01** 用户界面以及带有你的项目名称的窗口标题。**Screen01** 界面来自另一个名为 **Screen01.ui.qml**
    的文件。
- en: 'If you open the `main.cpp` file located in the `scr` folder in your project,
    you will see the following line of code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你打开位于你项目 `scr` 文件夹中的 `main.cpp` 文件，你会看到以下代码行：
- en: '[PRE30]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code tells Qt’s QML engine to load the `main.qml` file when the
    program starts. If you want to load the other `.qml` file, you know where to look
    for the code. The `src` folder is hidden from your Qt Design Studio project; you
    can look for it inside your project directory.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码告诉 Qt 的 QML 引擎在程序启动时加载 `main.qml` 文件。如果你想加载其他 `.qml` 文件，你知道在哪里查找代码。`src`
    文件夹在 Qt Design Studio 项目中是隐藏的；你可以在你的项目目录中找到它。
- en: 'If you build the project now, all you’ll get is a huge window with simple text
    and a push button that says **Press me**. The window’s background color and the
    text will change when you press the push button:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在构建项目，你将得到一个带有简单文本和显示“**按我**”的按钮的巨大窗口。当你按下按钮时，窗口的背景颜色和文本将发生变化：
- en: '![Figure 1.20 – Your first Qt Quick program](img/B20976_01_020.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.20 – 你的第一个 Qt Quick 程序](img/B20976_01_020.jpg)'
- en: Figure 1.20 – Your first Qt Quick program
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20 – 你的第一个 Qt Quick 程序
- en: 'To add UI elements, we’ll create a **Qt Quick UI File** by going to **File**
    | **New File…** and selecting **Qt Quick UI File** under the **Files and Classes**
    | **Qt Quick** **Files** category:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加 UI 元素，我们将通过转到 **文件** | **新建文件…** 并在 **文件和类** | **Qt Quick** **文件**类别下选择
    **Qt Quick UI 文件** 来创建一个 **Qt Quick UI 文件**：
- en: '![Figure 1.21 - Creating a new Qt Quick UI file](img/B20976_01_021.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.21 - 创建新的 Qt Quick UI 文件](img/B20976_01_021.jpg)'
- en: Figure 1.21 - Creating a new Qt Quick UI file
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.21 - 创建新的 Qt Quick UI 文件
- en: 'Set `Main`, followed by clicking the **Finish** button:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `Main`，然后点击 **完成** 按钮：
- en: '![Figure 1.22 – Giving your Qt Quick component a meaningful name](img/B20976_01_022.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.22 – 为你的 Qt Quick 组件赋予一个有意义的名称](img/B20976_01_022.jpg)'
- en: Figure 1.22 – Giving your Qt Quick component a meaningful name
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.22 – 为你的 Qt Quick 组件赋予一个有意义的名称
- en: A new file called `Main.ui.qml` has been added to your project resources. Try
    to open the `Main.ui.qml` file by double-clicking on it, if it hasn’t been automatically
    opened by Qt Design Studio upon creation. You will see a completely different
    UI editor compared to what we had for the C++ project in the previous recipes.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已在你的项目资源中添加了一个名为 `Main.ui.qml` 的新文件。尝试通过双击它来打开 `Main.ui.qml` 文件，如果它没有被 Qt Design
    Studio 在创建时自动打开。你将看到一个与之前 C++ 项目中完全不同的 UI 编辑器。
- en: 'Let’s open `App.qml` and replace **Screen01** with **Main**, like so:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开 `App.qml` 并将 **Screen01** 替换为 **Main**，如下所示：
- en: '[PRE31]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When `App.qml` is loaded by the QML engine, it will also import `Main.ui.qml`
    into the UI since `Main` is now being called in the `App.qml` file. Qt will check
    whether `Main` is a valid UI by searching for its `.qml` file based on the naming
    convention. This concept is similar to the C++ project we completed in all our
    previous recipes; the `App.qml` file acts like the `main.cpp` file and `Main.ui.qml`
    acts like the `MainWindow` class. You can also create other UI templates and use
    them in `App.qml`. Hopefully, this comparison will make it easier to understand
    how QML works.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当QML引擎加载`App.qml`时，它也会将`Main.ui.qml`导入UI中，因为现在在`App.qml`文件中正在调用`Main`。Qt会通过根据命名约定搜索其`.qml`文件来检查`Main`是否是一个有效的UI。这个概念与我们在所有之前的食谱中完成的C++项目类似；`App.qml`文件就像`main.cpp`文件，而`Main.ui.qml`就像`MainWindow`类。您还可以创建其他UI模板并在`App.qml`中使用它们。希望这个比较会使理解QML的工作方式更容易。
- en: 'Open `Main.ui.qml`. You should see only one item listed in the **Navigator**
    window: **Item**. This is the base layout of the window, which shouldn’t be deleted.
    It is similar to **centralWidget**, which we used in the previous recipe.'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开`Main.ui.qml`。您应该在**导航器**窗口中只看到一个项被列出：**项**。这是窗口的基本布局，不应该被删除。它类似于我们在之前的食谱中使用的**centralWidget**。 '
- en: 'The canvas is empty at the moment, so let’s drag a **Mouse Area** item and
    **Text** items to the canvas from the **QML Types** panel on the left. Resize
    **Mouse Area** so that it fills the entire canvas. Also, make sure that both **Mouse
    Area** and the **Text** items are being placed under the **Item** item in the
    **Navigator** panel, as shown in the following screenshot:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前画布是空的，所以让我们从左侧的**QML类型**面板中拖动一个**鼠标区域**项和**文本**项到画布上。调整**鼠标区域**的大小，使其填充整个画布。同时，确保**鼠标区域**和**文本**项都被放置在**导航器**面板中的**项**项下，如下面的截图所示：
- en: '![Figure 1.23 – Dragging and dropping a mouse area and text items onto the
    canvas](img/B20976_01_023.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图1.23 – 将鼠标区域和文本项拖放到画布上](img/B20976_01_023.jpg)'
- en: Figure 1.23 – Dragging and dropping a mouse area and text items onto the canvas
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.23 – 将鼠标区域和文本项拖放到画布上
- en: 'The **Mouse Area** item is an invincible item that gets triggered when the
    mouse is clicking on it, or when a finger is touching it (for mobile platforms).
    The **Mouse Area** item is also used in a **button** component, which we will
    be using in a while. The **Text** item is self-explanatory: it is a label that
    displays a block of text in the application.'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**鼠标区域**项是一个不可摧毁的项，当鼠标点击它时或当手指触摸它（在移动平台上）时会被触发。**鼠标区域**项也用于**按钮**组件，我们稍后会使用它。**文本**项是自解释的：它是一个标签，用于在应用程序中显示文本块。'
- en: 'On the **Navigator** window, we can hide or show an item by clicking on the
    icon that resembles an eye beside the item. When an item is hidden, it will not
    appear on the canvas or the compiled application. Just like the widgets in a C++
    Qt project, Qt Quick Components are arranged in a hierarchy based on the parent-child
    relationship. All the child items will be placed under the parent item with an
    indented position. In our case, we can see that the **Mouse Area** and **Text**
    elements are positioned slightly to the right compared to the **Item** item because
    they are both children of the **Item** element. We can rearrange the parent-child
    relationship, as well as their position in the hierarchy, by using a click-and-drag
    method from the **Navigator** window. You can try clicking on the **Text** item
    and dragging it on top of the mouse area. You will then see that the **Text**
    item has changed its position and is now located beneath the mouse area with a
    wider indentation:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导航器**窗口中，我们可以通过点击项旁边类似眼睛的图标来隐藏或显示一个项。当一个项被隐藏时，它将不会出现在画布或编译的应用程序中。就像C++ Qt项目中的小部件一样，Qt
    Quick组件根据父子关系进行分层排列。所有子项都将放置在具有缩进位置的父项下。在我们的例子中，我们可以看到**鼠标区域**和**文本**元素相对于**项**项稍微向右偏移，因为它们都是**项**元素的子项。我们可以通过使用**导航器**窗口中的点击和拖动方法来重新排列父子关系，以及它们在层次结构中的位置。您可以尝试点击**文本**项并将其拖动到鼠标区域上方。然后您会看到**文本**项的位置已经改变，现在位于鼠标区域下方，并且有更宽的缩进：
- en: '![Figure 1.24 – Rearranging the parent-child relationship between items](img/B20976_01_024.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图1.24 – 重新排列项之间的父子关系](img/B20976_01_024.jpg)'
- en: Figure 1.24 – Rearranging the parent-child relationship between items
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.24 – 重新排列项之间的父子关系
- en: We can rearrange them by using the arrow buttons located at the top of the **Navigator**
    window, as shown in the preceding screenshot. Anything that happens to the parent
    item will also affect all its children, such as moving the parent item, and hiding
    and showing the parent item.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过使用位于**导航器**窗口顶部的箭头按钮来重新排列它们，如前面的截图所示。父项发生的任何变化也会影响所有子项，例如移动父项，以及隐藏和显示父项。
- en: Note
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can pan around the canvas view by holding the middle mouse button (or mouse
    scroll) while moving your mouse around. You can also zoom in and out by scrolling
    your mouse while holding the *Ctrl* key on your keyboard. By default, scrolling
    your mouse will move the canvas view up and down. However, if your mouse cursor
    is on top of the horizontal scroll bar of the canvas, scrolling the mouse will
    move the view to the left and right.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过按住鼠标中键（或鼠标滚轮）并移动鼠标来在画布视图中平移。您还可以通过在键盘上按住*Ctrl*键并滚动鼠标来放大和缩小。默认情况下，滚动鼠标将上下移动画布视图。然而，如果鼠标光标位于画布的水平滚动条上，则滚动鼠标将视图左右移动。
- en: Delete both the **Mouse Area** item and **Text** items as we will be learning
    how to create a user interface from scratch using QML and Qt Quick.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除**鼠标区域**项和**文本**项，因为我们将要学习如何从头开始使用QML和Qt Quick创建用户界面。
- en: Set the `800 x 600` as we’re going to need a bigger space for the widgets.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`800 x 600`，因为我们需要更大的空间来放置小部件。
- en: Copy the images we used in the previous C++ project, in the *Using resources
    in style sheets* recipe, over to the QML project’s folder since we are going to
    recreate the same login screen with QML.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们在上一个C++项目中使用的图像复制到QML项目的文件夹中，因为我们将要使用QML重新创建相同的登录屏幕。
- en: Add the images to the resource file so that we can use them for our UI.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像添加到资源文件中，以便我们可以在UI中使用它们。
- en: 'Open **Qt Design Studio** and switch to the **Resources** window. Click and
    drag the background image directly to the canvas. Switch over to the **Layout**
    tab on the **Properties** pane and click the fill anchor button, indicated here
    by a red circle. This will make the background image always stick to the window
    size:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Qt设计工作室**并切换到**资源**窗口。直接将背景图像拖动到画布上。切换到**属性**面板上的**布局**选项卡并单击填充锚点按钮，如这里用红色圆圈所示。这将使背景图像始终粘附到窗口大小：
- en: '![Figure 1.25 – Selecting the fill anchor button to make the item follow the
    size of its parent object](img/B20976_01_025.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图1.25 – 选择填充锚点按钮以使项目跟随其父对象的大小](img/B20976_01_025.jpg)'
- en: Figure 1.25 – Selecting the fill anchor button to make the item follow the size
    of its parent object
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.25 – 选择填充锚点按钮以使项目跟随其父对象的大小
- en: Click and drag a **Rectangle** component from the **Library** window to the
    canvas. We will use this as the top panel for our program.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**库**窗口拖动一个**矩形**组件到画布上。我们将用它作为程序的顶部面板。
- en: For the top panel, enable the top anchor, left anchor, and right anchor so that
    the panel sticks to the top of the window and follows its width. Make sure all
    the margins are set to zero.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于顶部面板，启用顶部锚点、左侧锚点和右侧锚点，以便面板粘附到窗口顶部并跟随其宽度。确保所有边距都设置为零。
- en: Go to the `#805bcce9` and the second color to `#80000000`. This will create
    a half-transparent panel with a blue gradient.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将颜色更改为`#805bcce9`和第二个颜色为`#80000000`。这将创建一个半透明的带有蓝色渐变的面板。
- en: Add a `Wednesday, 25-10-2023 3:14 PM`) for display purposes. Then, set the text
    color to white.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为显示目的，添加一个`周三，25-10-2023 3:14 PM`。然后，将文本颜色设置为白色。
- en: Switch over to the **Layout** tab and enable the top anchor and left anchor
    so that the text widget will always stick to the top-left corner of the screen.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**布局**选项卡并启用顶部锚点和左侧锚点，以便文本小部件始终粘附到屏幕的左上角。
- en: Add a `50 x 50`. Then, make it a child of the top panel by dragging it on top
    of the top panel in the **Navigator** window.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`50 x 50`。然后，通过在**导航器**窗口中将它拖动到顶部面板上，使其成为顶部面板的子项。
- en: Set the color of the mouse area to blue (`#27a9e3`) and set its radius to `2`
    to make its corners slightly rounded. Enable the top anchor and right anchor to
    make it stick to the top-right corner of the window. Set the top anchor’s margin
    to `8` and the right anchor’s margin to `10` to create some space.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标区域的颜色设置为蓝色（`#27a9e3`），并将其半径设置为`2`以使其角落略微圆滑。启用顶部锚点和右侧锚点以使其粘附到窗口的右上角。将顶部锚点的边距设置为`8`，将右侧锚点的边距设置为`10`以创建一些空间。
- en: Open the **Resources** window and drag the shutdown icon to the canvas. Make
    it a child of the **Mouse Area** item we created a moment ago. Then, enable the
    fill anchor to make it fit the size of the mouse area.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**资源**窗口，并将关机图标拖动到画布中。使其成为我们刚刚创建的**鼠标区域**项的子元素。然后，启用填充锚点，使其与鼠标区域的尺寸相匹配。
- en: 'Phew – that’s a lot of steps! Now, your items should be arranged as follows
    in the **Navigator** window:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 呼——这有很多步骤！现在，您的项目在**导航器**窗口中应该如下排列：
- en: '![Figure 1.26 – Be cautious about the parent-child relationship between items](img/B20976_01_026.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图1.26 – 注意项目之间的父子关系](img/B20976_01_026.jpg)'
- en: Figure 1.26 – Be cautious about the parent-child relationship between items
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.26 – 注意项目之间的父子关系
- en: 'The parent-child relationship and the layout anchors are both very important
    to keep the widgets in the correct positions when the main window changes its
    size. Your top panel should look something like this:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 父子关系和布局锚点都非常重要，以保持小部件在主窗口更改尺寸时的正确位置。您的顶部面板应该看起来像这样：
- en: '![Figure 1.27 – Completing the top banner design](img/B20976_01_027.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图1.27 – 完成顶部横幅设计](img/B20976_01_027.jpg)'
- en: Figure 1.27 – Completing the top banner design
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.27 – 完成顶部横幅设计
- en: Let’s work on the login form. Add a new `360 x 200` and set its radius to `15`.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们着手处理登录表单。添加一个新的`360 x 200`，并将其半径设置为`15`。
- en: Set its color to `#80000000`; this will change it to black with 50% transparency.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其颜色设置为`#80000000`；这将使其变为黑色，并具有50%的不透明度。
- en: 'Enable the vertical center anchor and the horizontal center anchor to make
    the rectangle always align with the center of the window. Then, set the margin
    of the vertical center anchor to `100` so that it moves slightly lower to the
    bottom. This will ensure we have the space to place the logo. The following screenshot
    illustrates the settings for **Anchors**:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用垂直居中锚点和水平居中锚点，使矩形始终与窗口的中心对齐。然后，将垂直居中锚点的边距设置为`100`，使其稍微向下移动到底部。这将确保我们有足够的空间放置标志。以下截图展示了**锚点**的设置：
- en: '![Figure 1.28 – Setting the alignment and margin](img/B20976_01_028.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图1.28 – 设置对齐和边距](img/B20976_01_028.jpg)'
- en: Figure 1.28 – Setting the alignment and margin
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.28 – 设置对齐和边距
- en: Add the text objects to the canvas. Make them children of the login form (the
    `Username:` and `Password:`. Change their text color to white and position them
    accordingly. We don’t need to set a margin this time because they will follow
    the rectangle’s position.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本对象添加到画布中。使它们成为登录表单的子元素（`用户名:`和`密码:`）。将它们的文本颜色更改为白色，并相应地定位它们。这次我们不需要设置边距，因为它们将跟随矩形的定位。
- en: Add two text input objects to the canvas and place them next to the text widgets
    we just created. Make sure the text input is also a child of the login form. Since
    the text input doesn’t contain any background color property, we need to add two
    rectangles to the canvas to use as their background.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布上添加两个文本输入对象，并将它们放置在我们刚刚创建的文本小部件旁边。确保文本输入也是登录表单的子元素。由于文本输入不包含任何背景颜色属性，我们需要在画布上添加两个矩形作为它们的背景。
- en: Add two rectangles to the canvas and make each of them a child of one of the
    text inputs we just created. Set the `5` to give them some rounded corners. After
    that, enable fill anchors on both of the rectangles so that they will follow the
    size of the text input widgets.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布上添加两个矩形，并将它们各自设置为刚刚创建的文本输入的子元素。设置`5`以给它们一些圆角。之后，在两个矩形上启用填充锚点，以便它们跟随文本输入小部件的尺寸。
- en: Now, let’s create the login button beneath the password field. Add a mouse area
    to the canvas and make it a child of the login form. Resize it to your preferred
    dimension and move it into place.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在密码字段下方创建登录按钮。将鼠标区域添加到画布中，并使其成为登录表单的子元素。调整其尺寸到您喜欢的尺寸，并将其移动到合适的位置。
- en: Since the mouse area does not contain any background color property, we need
    to add a `#27a9e3`) and enable the fill anchor so that it fits nicely with the
    mouse area.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于鼠标区域不包含任何背景颜色属性，我们需要添加一个`#27a9e3`并启用填充锚点，以便它与鼠标区域很好地匹配。
- en: Add a text object to the canvas and make it a child of the login button. Change
    its text color to white and set its `Login`. Finally, enable the horizontal center
    anchor and the vertical center anchor so that they align with the center of the
    button.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布上添加一个文本对象，并使其成为登录按钮的子元素。将其文本颜色更改为白色，并设置其`登录`。最后，启用水平居中锚点和垂直居中锚点，使它们与按钮的中心对齐。
- en: 'You will now get a login form that looks pretty similar to the one we made
    in the C++ project:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你将看到一个登录表单，它的外观与我们在 C++ 项目中制作的非常相似：
- en: '![Figure 1.29 – Final design of the login form](img/B20976_01_029.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.29 – 登录表单的最终设计](img/B20976_01_029.jpg)'
- en: Figure 1.29 – Final design of the login form
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.29 – 登录表单的最终设计
- en: Now, it’s time to add the logo, which is very simple. Open the **Resources**
    window and drag the logo image to the canvas.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候添加标志了，这非常简单。打开**资源**窗口，并将标志图像拖放到画布上。
- en: Make it a child of the login form and set its size to `512` `x 200`.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让它成为登录表单的子元素，并设置其大小为 `512` `x 200`。
- en: Position it on top of the login form. With that, you’re done.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其放置在登录表单的顶部。这样，您就完成了。
- en: 'This is what the entire UI looks like when compiled. We have successfully recreated
    the login screen from the C++ project, but this time, we did it with QML and Qt
    Quick:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是编译后的整个 UI 的样子。我们已经成功地将 C++ 项目的登录屏幕重新创建出来，但这次我们使用的是 QML 和 Qt Quick：
- en: '![Figure 1.30 – The final result](img/B20976_01_030.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.30 – 最终结果](img/B20976_01_030.jpg)'
- en: Figure 1.30 – The final result
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.30 – 最终结果
- en: How it works…
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'The Qt Quick editor uses a very different approach for placing widgets in the
    application compared to the form editor. The user can decide which method is best
    suited to their purposes. The following screenshot shows what the Qt Quick Designer
    looks like:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Quick 编辑器在将小部件放置在应用程序中与表单编辑器相比采用了一种非常不同的方法。用户可以决定哪种方法最适合他们的需求。以下截图显示了 Qt
    Quick 设计器的样子：
- en: '![Figure 1.31 – Overview of Qt Design Studio’s user interface](img/B20976_01_031.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.31 – Qt Design Studio 用户界面概览](img/B20976_01_031.jpg)'
- en: Figure 1.31 – Overview of Qt Design Studio’s user interface
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.31 – Qt Design Studio 用户界面概览
- en: 'Let’s look at the various elements of the editor’s UI:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看编辑器 UI 的各个元素：
- en: '**Navigator**: The **Navigator** window displays the items in the current QML
    file as a tree structure. It’s similar to the object operator window in the other
    Qt Designer we used in the *Using style sheets with Qt* *Designer* recipe.'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**导航器**：**导航器**窗口以树状结构显示当前 QML 文件中的项目。它与我们在“使用 Qt Designer 的样式表”配方中使用的其他 Qt
    Designer 中的对象操作窗口类似。'
- en: '**Library**: The **Library** window displays all the Qt Quick Components or
    Qt Quick Controls available in QML. You can click and drag it to the canvas window
    to add to your UI. You can also create your own custom QML components and display
    them here.'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**库**：**库**窗口显示了 QML 中可用的所有 Qt Quick 组件或 Qt Quick 控件。您可以将它拖放到画布窗口中，以将其添加到您的
    UI 中。您还可以创建自己的自定义 QML 组件，并将它们显示在这里。'
- en: '**Assets**: The **Assets** window displays all the resources in a list that
    can then be used in your UI design.'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**资产**：**资产**窗口以列表形式显示所有可以用于 UI 设计的资源。'
- en: '**Add Modules**: The **Add Modules** button allows you to import different
    QML modules into your current QML file, such as a Bluetooth module, a WebKit module,
    or a positioning module, to add additional functionality to your QML project.'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加模块**：**添加模块**按钮允许您将不同的 QML 模块导入到当前的 QML 文件中，例如蓝牙模块、WebKit 模块或定位模块，以向您的
    QML 项目添加额外的功能。'
- en: '**Properties**: Similar to the **Property Editor** area we used in the previous
    recipe, the **Properties** pane in QML Designer displays the properties of the
    selected item. You can also change the properties of the items in the code editor.'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**属性**：与我们在前面的配方中使用的**属性编辑器**区域类似，QML 设计器的**属性**面板显示所选项目的属性。您还可以在代码编辑器中更改项目的属性。'
- en: '**Canvas**: The canvas is the working area where you create QML components
    and design applications.'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**画布**：画布是您创建 QML 组件和设计应用程序的工作区域。'
- en: '**Workspace selector**: The workspace selector area displays the different
    layouts available in the Qt Design Studio editor, allowing the user to select
    the workspace that suits their needs.'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工作区选择器**：工作区选择器区域显示了 Qt Design Studio 编辑器中可用的不同布局，允许用户选择适合他们需求的工区。'
- en: '**Style selector**: This selector is where you can select a different style
    to preview how your application will look when running on a specific platform.
    This is very useful when developing cross-platform applications.'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**样式选择器**：这个选择器是您可以选择不同样式以预览应用程序在特定平台上运行时的外观的地方。这对于开发跨平台应用程序非常有用。'
- en: Exposing the QML object pointer to C++
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 QML 对象指针暴露给 C++
- en: Sometimes, we want to modify the properties of a QML object through C++ scripting,
    such as changing the text of a label, hiding/showing the widget, or changing its
    size. Qt’s QML engine allows you to register your QML objects to C++ types, which
    automatically exposes all its properties.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望通过C++脚本修改QML对象的属性，例如更改标签的文本、隐藏/显示小部件或更改其大小。Qt的QML引擎允许你将你的QML对象注册到C++类型，这会自动暴露其所有属性。
- en: How to do it…
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We want to create a label in QML and change its text occasionally. To expose
    the label object to C++, we can do the following:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在QML中创建一个标签并偶尔更改其文本。为了将标签对象暴露给C++，我们可以这样做：
- en: 'Create a C++ class called `MyLabel` that extends from the `QObject` class in
    `mylabel.h`:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mylabel.h`中创建一个名为`MyLabel`的C++类，它扩展了`QObject`类：
- en: '[PRE32]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `mylabel.cpp` source file, define a function called `SetMyObject()`
    to save the object pointer. This function will later be called in QML in `mylabel.cpp`:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mylabel.cpp`源文件中，定义一个名为`SetMyObject()`的函数来保存对象指针。此函数将在QML中的`mylabel.cpp`中被调用：
- en: '[PRE33]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In `main.cpp`, include the `MyLabel` header and register it to the QML engine
    using the `qmlRegisterType()` function:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.cpp`中，包含`MyLabel`头文件并使用`qmlRegisterType()`函数将其注册到QML引擎：
- en: '[PRE34]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that there are four parameters you need to declare in `qmlRegisterType()`.
    Besides declaring your class name (`MyLabel`), you also need to declare your library
    name (`MyLabelLib`) and its version (`1.0`). This will be used to import your
    class into QML.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在`qmlRegisterType()`中你需要声明四个参数。除了声明你的类名（`MyLabel`）外，你还需要声明你的库名（`MyLabelLib`）及其版本（`1.0`）。这将用于将你的类导入QML。
- en: 'Map the QML engine to our label object in QML and import the class library
    we defined earlier in *Step 3* by calling `import MyLabelLib 1.0` in our QML file.
    Notice that the library name and its version number have to match the one you
    declared in `main.cpp`; otherwise, it will throw an error. After declaring `MyLabel`
    in QML and setting its ID as `mylabel.SetMyObject(myLabel)` to expose its pointer
    to C/C++ right after the label is initialized:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在QML中将QML引擎映射到我们的标签对象，并通过在QML文件中调用`import MyLabelLib 1.0`来导入我们在*第3步*中定义的类库。请注意，库的名称及其版本号必须与你在`main.cpp`中声明的相匹配；否则，它将抛出错误。在QML中声明`MyLabel`并将其ID设置为`mylabel.SetMyObject(myLabel)`以在标签初始化后立即将其指针暴露给C/C++之后：
- en: '[PRE35]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Wait until the label is fully initiated before exposing its pointer to C/C++;
    otherwise, you may cause the program to crash. To make sure it’s fully initiated,
    call the `SetMyObject()` function within `Component.onCompleted` and not in any
    other functions or event callbacks. Now that the QML label has been exposed to
    C/C++, we can change any of its properties by calling the `setProperty()` function.
    For instance, we can set its visibility to `true` and change its text to `Bye`
    `bye world!`:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将标签的指针暴露给C/C++之前，请等待标签完全初始化；否则，你可能会使程序崩溃。为了确保它已完全初始化，请在`Component.onCompleted`中调用`SetMyObject()`函数，而不是在其他任何函数或事件回调中。现在，QML标签已经暴露给C/C++，我们可以通过调用`setProperty()`函数更改其任何属性。例如，我们可以将其可见性设置为`true`并将文本更改为`Bye`
    `bye world!`：
- en: '[PRE36]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Besides changing the properties, we can also call its functions by calling
    the following code:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了改变属性外，我们还可以通过以下代码调用其函数：
- en: '[PRE37]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Or, simply, we can call the `invokedMethod()` function with only two parameters
    if we do not expect any values to be returned from it:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，如果我们不期望从它返回任何值，我们可以仅用两个参数调用`invokedMethod()`函数：
- en: '[PRE38]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works…
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: QML is designed in such a way that it can be expanded through C++ code. The
    classes in the Qt QML module permit QML objects to be used and operate from C++,
    and the capability of the QML engine united with Qt’s **meta-object system** allows
    C++ functionality to be called directly from QML. To add some C++ data or usage
    to QML, it should come forward from a QObject-derived class. QML object types
    could be instituted from C++ and supervised to access their properties, appeal
    their methods, and get their signal alerts. This is possible because all QML object
    types are executed using QObject-derived classes, allowing the QML engine to forcibly
    load and inspect objects through the Qt meta-object system.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: QML的设计方式使其可以通过C++代码进行扩展。Qt QML模块中的类允许从C++使用和操作QML对象，QML引擎与Qt的**元对象系统**的结合能力允许直接从QML调用C++功能。要向QML添加一些C++数据或用法，它应该从一个QObject派生类中提出。可以从C++建立QML对象类型，并监督访问它们的属性、调用它们的方法和获取它们的信号警报。这是可能的，因为所有QML对象类型都是使用QObject派生类执行的，这使得QML引擎能够通过Qt元对象系统强制加载和检查对象。
- en: There’s more…
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Qt 6 comes with two different types of GUI kits – Qt Widgets and Qt Quick. Both
    have their strengths and advantages over the other, giving programmers the ability
    and freedom to design their application’s interface without having to worry about
    feature constraints and performance issues.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 6提供了两种不同的GUI工具包——Qt Widgets和Qt Quick。它们各自都有相对于对方的优点和优势，为程序员提供了设计和应用界面的能力和自由，无需担心功能限制和性能问题。
- en: Qt 6 allows you to pick the best method and programming language that suits
    your working style and requirements for your project. By going through this chapter,
    you will be able to create a good-looking and functional cross-platform application
    using Qt 6 in no time.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 6允许你选择最适合你工作风格和项目需求的最佳方法和编程语言。通过阅读本章，你将能够迅速创建一个外观美观且功能齐全的跨平台应用程序，使用Qt 6。
