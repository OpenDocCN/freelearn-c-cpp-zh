["```cpp\n_ _ _ \n_ _ _ \n_ _ _\n```", "```cpp\nX _ _    \nO _ _ \n_ _ _\n```", "```cpp\nX X _ \nO _ _ \n_ _ _\n```", "```cpp\nX X O \nO _ _ \n_ _ _\n```", "```cpp\nX X _ \nO X _ \nX _ _\n```", "```cpp\nX X X \nO O _ \n_ _ _\n```", "```cpp\nX _ _ \nX O O \nX _ _\n```", "```cpp\nX O _ \nO X _ \n_ _ X\n```", "```cpp\n_ O X \nO X _ \nX _ _\n```", "```cpp\nX X _ \nO O O \nX _ _\n```", "```cpp\nX O _ \nX O X \n_ O _\n```", "```cpp\nO X _ \n_ O X \nX _ O\n```", "```cpp\nX X O \n_ O X \nO _ _\n```", "```cpp\nX X O \nO X X \nX O O\n```", "```cpp\nboard -> collection(all lines, all columns, all diagonals) -> any(collection, filledWithX) -> X won\n```", "```cpp\nX X X\n```", "```cpp\nline | column | diagonal -> all tokens equal X -> line | column | diagonal filled with X\n```", "```cpp\nboard -> collection(all lines, all columns, all diagonals) -> if any(collection, filledWithX) -> X won \n\nfilledWithX(line|column|diagonal L) = all(token on L equals 'X')\n```", "```cpp\nboard -> collection of coordinates for lines, columns, diagonals -> apply coordinates to the board -> obtain list of elements for lines, columns, and diagonals\n```", "```cpp\nauto trueForAll = [](auto x) { return true; };\nauto falseForAll = [](auto x) { return false; };\nauto equalsChara = [](auto x){ return x == 'a';};\nauto notChard = [](auto x){ return x != 'd';};\n\nTEST_CASE(\"all_of\"){\n    vector<char> abc{'a', 'b', 'c'};\n\n    CHECK(all_of(abc.begin(), abc.end(), trueForAll));\n    CHECK(!all_of(abc.begin(), abc.end(), falseForAll));\n    CHECK(!all_of(abc.begin(), abc.end(), equalsChara));\n    CHECK(all_of(abc.begin(), abc.end(), notChard));\n}\n```", "```cpp\nauto all_of_collection = [](const auto& collection, auto lambda){\n    return all_of(collection.begin(), collection.end(), lambda);\n};\n\nTEST_CASE(\"all_of_collection\"){\n    vector<char> abc{'a', 'b', 'c'};\n\n    CHECK(all_of_collection(abc, trueForAll));\n    CHECK(!all_of_collection(abc, falseForAll));\n    CHECK(!all_of_collection(abc, equalsChara));\n    CHECK(all_of_collection(abc, notChard));\n}\n```", "```cpp\nauto lineFilledWithX = [](const auto& line){\n    return all_of_collection(line, [](const auto& token){ return token == 'X';});\n};\n\nTEST_CASE(\"Line filled with X\"){\n    vector<char> line{'X', 'X', 'X'};\n\n    CHECK(lineFilledWithX(line));\n}\n```", "```cpp\nusing Line = vector<char>;\n```", "```cpp\nTEST_CASE(\"Line not filled with X\"){\n    CHECK(!lineFilledWithX(Line{'X', 'O', 'X'}));\n    CHECK(!lineFilledWithX(Line{'X', ' ', 'X'}));\n}\n```", "```cpp\nauto lineFilledWith = [](const auto line, const auto tokenToCheck){\n    return all_of_collection(line, [&tokenToCheck](const auto token){  \n        return token == tokenToCheck;});\n};\n\nauto lineFilledWithX = bind(lineFilledWith, _1, 'X'); \nauto lineFilledWithO = bind(lineFilledWith, _1, 'O');\n```", "```cpp\nTEST_CASE(\"transform\"){\n    vector<char> abc{'a', 'b', 'c'};\n\n// Not the best version, see below\nvector<char> aaa(3);\ntransform(abc.begin(), abc.end(), aaa.begin(), [](auto element){return \n    'a';});\nCHECK_EQ(vector<char>{'a', 'a', 'a'}, aaa);\n}\n```", "```cpp\nTEST_CASE(\"transform-fixed\") { \n    const auto abc = vector{'a', 'b', 'c'}; \n    vector<char> aaa; \n    aaa.reserve(abc.size()); \n    transform(abc.begin(), abc.end(), back_inserter(aaa), \n            [](const char elem) { return 'a'; }\n    ); \n    CHECK_EQ(vector{'a', 'a', 'a'}, aaa); \n}\n```", "```cpp\nauto transform_all = [](auto const source, auto lambda){\n    auto destination; // Compilation error: the type is not defined\n    ...\n}\n```", "```cpp\ntemplate<typename Destination>\nauto transformAll = [](auto const source,  auto lambda){\n    Destination result;\n    result.reserve(source.size());\n    transform(source.begin(), source.end(), back_inserter(result), \n        lambda);\n    return result;\n};\n\n```", "```cpp\nauto turnAllToa = [](auto x) { return 'a';};\n\nTEST_CASE(\"transform all\"){\n    vector abc{'a', 'b', 'c'};\n\n    CHECK_EQ(vector<char>({'a', 'a', 'a'}), transform_all<vector<char>>\n        (abc, turnAllToa));\n    CHECK_EQ(\"aaa\", transform_all<string>(abc,turnAllToa));\n}\n```", "```cpp\nauto makeCaps = [](auto x) { return toupper(x);};\n\nTEST_CASE(\"transform all\"){\n    vector<char> abc = {'a', 'b', 'c'};\n\n    CHECK_EQ(\"ABC\", transform_all<string>(abc, makeCaps));\n}\n```", "```cpp\nauto toNumber = [](auto x) { return (int)x - 'a' + 1;};\n\nTEST_CASE(\"transform all\"){\n    vector<char> abc = {'a', 'b', 'c'};\n    vector<int> expected = {1, 2, 3};\n\n    CHECK_EQ(expected, transform_all<vector<int>>(abc, toNumber));\n}\n```", "```cpp\nusing Coordinate = pair<int, int>;\n```", "```cpp\nauto accessAtCoordinates = [](const auto& board, const Coordinate&  \n    coordinate){\n        return board[coordinate.first][coordinate.second];\n};\n\nauto projectCoordinates = [](const auto& board, const auto&  \n    coordinates){\n        auto boardElementFromCoordinates = bind(accessAtCoordinates,  \n        board, _1);\n        return transform_all<Line>(coordinates,  \n            boardElementFromCoordinates);\n};\n```", "```cpp\nauto line = [](auto board, int lineIndex){\n   return projectCoordinates(board, lineCoordinates(board, lineIndex));\n};\n```", "```cpp\nauto lineCoordinates = [](const auto board, auto lineIndex){\n    vector<int> range{0, 1, 2};\n    return transformAll<vector<Coordinate>>(range, [lineIndex](auto  \n        index){return make_pair(lineIndex, index);});\n};\n```", "```cpp\ndef range = [0..board.size()]\n```", "```cpp\nauto toRange = [](auto const collection){\n    vector<int> range(collection.size());\n    iota(begin(range), end(range), 0);\n    return range;\n};\n```", "```cpp\nusing Board = vector<Line>;\nusing Line = vector<char>;\n\nauto lineCoordinates = [](const auto board, auto lineIndex){\n    auto range = toRange(board);\n    return transform_all<vector<Coordinate>>(range, [lineIndex](auto  \n        index){return make_pair(lineIndex, index);});\n};\n\nTEST_CASE(\"lines\"){\n    Board board {\n        {'X', 'X', 'X'},\n        {' ', 'O', ' '},\n        {' ', ' ', 'O'}\n    };\n\n    Line expectedLine0 = {'X', 'X', 'X'};\n    CHECK_EQ(expectedLine0, line(board, 0));\n    Line expectedLine1 = {' ', 'O', ' '};\n    CHECK_EQ(expectedLine1, line(board, 1));\n    Line expectedLine2 = {' ', ' ', 'O'};\n    CHECK_EQ(expectedLine2, line(board, 2));\n}\n```", "```cpp\nauto columnCoordinates = [](const auto& board, const auto columnIndex){\n    auto range = toRange(board);\n    return transformAll<vector<Coordinate>>(range, [columnIndex](const  \n        auto index){return make_pair(index, columnIndex);});\n};\n\nauto column = [](auto board, auto columnIndex){\n    return projectCoordinates(board, columnCoordinates(board,  \n        columnIndex));\n};\n\nTEST_CASE(\"all columns\"){\n    Board board{\n        {'X', 'X', 'X'},\n        {' ', 'O', ' '},\n        {' ', ' ', 'O'}\n    };\n\n    Line expectedColumn0{'X', ' ', ' '};\n    CHECK_EQ(expectedColumn0, column(board, 0));\n    Line expectedColumn1{'X', 'O', ' '};\n    CHECK_EQ(expectedColumn1, column(board, 1));\n    Line expectedColumn2{'X', ' ', 'O'};\n    CHECK_EQ(expectedColumn2, column(board, 2));\n}\n```", "```cpp\nauto mainDiagonalCoordinates = [](const auto board){\n    auto range = toRange(board);\n    return transformAll<vector<Coordinate>>(range, [](auto index) \n       {return make_pair(index, index);});\n};\nauto mainDiagonal = [](const auto board){\n    return projectCoordinates(board, mainDiagonalCoordinates(board));\n};\n\nTEST_CASE(\"main diagonal\"){\n    Board board{\n        {'X', 'X', 'X'},\n        {' ', 'O', ' '},\n        {' ', ' ', 'O'}\n    };\n\n    Line expectedDiagonal = {'X', 'O', 'O'};\n\n    CHECK_EQ(expectedDiagonal, mainDiagonal(board));\n}\n```", "```cpp\nauto secondaryDiagonalCoordinates = [](const auto board){\n    auto range = toRange(board);\n    return transformAll<vector<Coordinate>>(range, [board](auto index) \n        {return make_pair(index, board.size() - index - 1);});\n};\n\nauto secondaryDiagonal = [](const auto board){\n    return projectCoordinates(board, \n        secondaryDiagonalCoordinates(board));\n};\n\nTEST_CASE(\"secondary diagonal\"){\n    Board board{\n        {'X', 'X', 'X'},\n        {' ', 'O', ' '},\n        {' ', ' ', 'O'}\n    };\n\n    Line expectedDiagonal{'X', 'O', ' '};\n\n    CHECK_EQ(expectedDiagonal, secondaryDiagonal(board));\n}\n```", "```cpp\ntypedef vector<Line> Lines;\n\nauto allLines = [](auto board) {\n    auto range = toRange(board);\n    return transform_all<Lines>(range, [board](auto index) { return \n        line(board, index);});\n};\n\nauto allColumns = [](auto board) {\n    auto range = toRange(board);\n    return transform_all<Lines>(range, [board](auto index) { return \n        column(board, index);});\n};\n\nauto allDiagonals = [](auto board) -> Lines {\n    return {mainDiagonal(board), secondaryDiagonal(board)};\n};\n```", "```cpp\nauto concatenate = [](auto first, const auto second){\n    auto result(first);\n    result.insert(result.end(), make_move_iterator(second.begin()), \n        make_move_iterator(second.end()));\n    return result;\n};\n\n```", "```cpp\nauto concatenate3 = [](auto first, auto const second, auto const third){\n    return concatenate(concatenate(first, second), third);\n};\n```", "```cpp\nauto allLinesColumnsAndDiagonals = [](const auto board) {\n    return concatenate3(allLines(board), allColumns(board),  \n        allDiagonals(board));\n};\n\nTEST_CASE(\"all lines, columns and diagonals\"){\n    Board board {\n        {'X', 'X', 'X'},\n        {' ', 'O', ' '},\n        {' ', ' ', 'O'}\n    };\n\n    Lines expected {\n        {'X', 'X', 'X'},\n        {' ', 'O', ' '},\n        {' ', ' ', 'O'},\n        {'X', ' ', ' '},\n        {'X', 'O', ' '},\n        {'X', ' ', 'O'},\n        {'X', 'O', 'O'},\n        {'X', 'O', ' '}\n    };\n\n    auto all = allLinesColumnsAndDiagonals(board);\n    CHECK_EQ(expected, all);\n}\n```", "```cpp\nTEST_CASE(\"any_of\"){\n    vector<char> abc = {'a', 'b', 'c'};\n\n    CHECK(any_of(abc.begin(), abc.end(), trueForAll));\n    CHECK(!any_of(abc.begin(), abc.end(), falseForAll));\n    CHECK(any_of(abc.begin(), abc.end(), equalsChara));\n    CHECK(any_of(abc.begin(), abc.end(), notChard));\n}\n```", "```cpp\nauto any_of_collection = [](const auto& collection, const auto& fn){\n return any_of(collection.begin(), collection.end(), fn);\n};\n\nTEST_CASE(\"any_of_collection\"){\n    vector<char> abc = {'a', 'b', 'c'};\n\n    CHECK(any_of_collection(abc, trueForAll));\n    CHECK(!any_of_collection(abc, falseForAll));\n    CHECK(any_of_collection(abc, equalsChara));\n    CHECK(any_of_collection(abc, notChard));\n}\n```", "```cpp\nauto xWins = [](const auto& board){\n    return any_of_collection(allLinesColumnsAndDiagonals(board), \n        lineFilledWithX);\n};\n\nTEST_CASE(\"X wins\"){\n    Board board{\n        {'X', 'X', 'X'},\n        {' ', 'O', ' '},\n        {' ', ' ', 'O'}\n    };\n\n    CHECK(xWins(board));\n}\n```", "```cpp\nTEST_CASE(\"board to string\"){\n    Board board{\n        {'X', 'X', 'X'},\n        {' ', 'O', ' '},\n        {' ', ' ', 'O'}\n    };\n    string expected = \"XXX\\n O \\n  O\\n\";\n\n    CHECK_EQ(expected, boardToString(board));\n}\n```", "```cpp\nauto lineToString = [](const auto& line){\n    return transformAll<string>(line, [](const auto token) -> char { \n        return token;});\n};\n\nTEST_CASE(\"line to string\"){\n    Line line {\n        ' ', 'X', 'O'\n    };\n\n    CHECK_EQ(\" XO\", lineToString(line));\n}\n```", "```cpp\nauto boardToLinesString = [](const auto board){\n    return transformAll<vector<string>>(board, lineToString);\n};\n\nTEST_CASE(\"board to lines string\"){\n    Board board{\n        {'X', 'X', 'X'},\n        {' ', 'O', ' '},\n        {' ', ' ', 'O'}\n    };\n    vector<string> expected{\n        \"XXX\",\n        \" O \",\n        \"  O\"\n    };\n\n    CHECK_EQ(expected, boardToLinesString(board));\n}\n```", "```cpp\nTEST_CASE(\"accumulate\"){\n    vector<int> values = {1, 12, 23, 45};\n\n    auto add = [](int first, int second){return first + second;};\n    int result = accumulate(values.begin(), values.end(), 0, add);\n    CHECK_EQ(1 + 12 + 23 + 45, result);\n}\n```", "```cpp\n    int resultWithInit100 = accumulate(values.begin(), values.end(),  \n        100, add);\n    CHECK_EQ(1oo + 1 + 12 + 23 + 45, resultWithInit100);\n```", "```cpp\n    vector<string> strings {\"Alex\", \"is\", \"here\"};\n    auto concatenate = [](const string& first, const string& second) ->  \n        string{\n        return first + second;\n    };\n    string concatenated = accumulate(strings.begin(), strings.end(),  \n        string(), concatenate);\n    CHECK_EQ(\"Alexishere\", concatenated);\n```", "```cpp\n    string concatenatedWithPrefix = accumulate(strings.begin(),  \n        strings.end(), string(\"Pre_\"), concatenate);\n    CHECK_EQ(\"Pre_Alexishere\", concatenatedWithPrefix);\n```", "```cpp\nauto accumulateAll = [](auto source, auto lambda){\n    return accumulate(source.begin(), source.end(), typename  \n        decltype(source)::value_type(), lambda);\n};\n```", "```cpp\nauto boardToString = [](const auto board){\n    auto linesAsString = boardToLinesString(board);\n    return accumulateAll(linesAsString, \n        [](string current, string lineAsString) { return current + lineAsString + \"\\n\"; }\n    );\n};\nTEST_CASE(\"board to string\"){\n    Board board{\n        {'X', 'X', 'X'},\n        {' ', 'O', ' '},\n        {' ', ' ', 'O'}\n    };\n    string expected = \"XXX\\n O \\n  O\\n\";\n\n    CHECK_EQ(expected, boardToString(board));\n}\n```", "```cpp\n    map<string, Line> linesWithDescription{\n        {\"first line\", line(board, 0)},\n        {\"second line\", line(board, 1)},\n        {\"last line\", line(board, 2)},\n        {\"first column\", column(board, 0)},\n        {\"second column\", column(board, 1)},\n        {\"last column\", column(board, 2)},\n        {\"main diagonal\", mainDiagonal(board)},\n        {\"secondary diagonal\", secondaryDiagonal(board)},\n    };\n```", "```cpp\nauto equals1 = [](auto value){ return value == 1; };\nauto greaterThan11 = [](auto value) { return value > 11; };\nauto greaterThan50 = [](auto value) { return value > 50; };\n\nTEST_CASE(\"find if\"){\n    vector<int> values{1, 12, 23, 45};\n\n    auto result1 = find_if(values.begin(), values.end(), equals1);\n    CHECK_EQ(*result1, 1);\n\n    auto result12 = find_if(values.begin(), values.end(), \n        greaterThan11);\n    CHECK_EQ(*result12, 12);\n\n    auto resultNotFound = find_if(values.begin(), values.end(), \n        greaterThan50);\n    CHECK_EQ(resultNotFound, values.end());\n}\n```", "```cpp\nauto findInCollection = [](const auto& collection, auto fn){\n    auto result = find_if(collection.begin(), collection.end(), fn);\n    return (result == collection.end()) ? nullopt : optional(*result);\n};\n\nTEST_CASE(\"find in collection\"){\n    vector<int> values {1, 12, 23, 45};\n\n    auto result1 = findInCollection(values, equals1);\n    CHECK_EQ(result1, 1);\n\n    auto result12 = findInCollection(values, greaterThan11);\n    CHECK_EQ(result12, 12);\n\n    auto resultNotFound = findInCollection(values, greaterThan50);\n    CHECK(!resultNotFound.has_value());\n}\n```", "```cpp\nauto howDidXWin = [](const auto& board){\n    map<string, Line> linesWithDescription = {\n        {\"first line\", line(board, 0)},\n        {\"second line\", line(board, 1)},\n        {\"last line\", line(board, 2)},\n        {\"first column\", column(board, 0)},\n        {\"second column\", column(board, 1)},\n        {\"last column\", column(board, 2)},\n        {\"main diagonal\", mainDiagonal(board)},\n        {\"secondary diagonal\", secondaryDiagonal(board)},\n    };\n    auto found = findInCollection(linesWithDescription,[](auto value) \n        {return lineFilledWithX(value.second);}); \n    return found.has_value() ? found->first : \"X did not win\";\n};\n```", "```cpp\nauto oWins = [](auto const board){\n    return any_of_collection(allLinesColumnsAndDiagonals(board),  \n        lineFilledWithO);\n};\nTEST_CASE(\"O wins\"){\n    Board board = {\n        {'X', 'O', 'X'},\n        {' ', 'O', ' '},\n        {' ', 'O', 'X'}\n    };\n\n    CHECK(oWins(board));\n}\n```", "```cpp\nauto draw = [](const auto& board){\n    return full(board) && !xWins(board) && !oWins(board); \n};\n\nTEST_CASE(\"draw\"){\n    Board board {\n        {'X', 'O', 'X'},\n        {'O', 'O', 'X'},\n        {'X', 'X', 'O'}\n    };\n\n    CHECK(draw(board));\n}\n```", "```cpp\nauto full = [](const auto& board){\n    return all_of_collection(board, fullLine);\n};\n```", "```cpp\nauto noneOf = [](const auto& collection, auto fn){\n    return none_of(collection.begin(), collection.end(), fn);\n};\n\nauto isEmpty = [](const auto token){return token == ' ';};\nauto fullLine = [](const auto& line){\n    return noneOf(line, isEmpty);\n};\n```", "```cpp\nauto inProgress = [](const auto& board){\n    return !full(board) && !xWins(board) && !oWins(board); \n};\nTEST_CASE(\"in progress\"){\n    Board board {\n        {'X', 'O', 'X'},\n        {'O', ' ', 'X'},\n        {'X', 'X', 'O'}\n    };\n\n    CHECK(inProgress(board));\n}\n```", "```cpp\nauto findInCollection = [](const auto& collection, auto fn){\n    auto result = find_if(collection.begin(), collection.end(), fn);\n    return (result == collection.end()) ? nullopt : optional(*result);\n};\n```", "```cpp\nreturn found.has_value() ? found->first : \"X did not win\";\n```", "```cpp\nauto findInCollectionWithDefault = [](auto collection, auto \n    defaultResult, auto lambda){\n        auto result = findInCollection(collection, lambda);\n        return result.has_value() ? (*result) : defaultResult;\n}; \n```", "```cpp\nauto howDidXWin = [](auto const board){\n    map<string, Line> linesWithDescription = {\n        {\"first line\", line(board, 0)},\n        {\"second line\", line(board, 1)},\n        {\"last line\", line(board, 2)},\n        {\"first column\", column(board, 0)},\n        {\"second column\", column(board, 1)},\n        {\"last column\", column(board, 2)},\n        {\"main diagonal\", mainDiagonal(board)},\n        {\"secondary diagonal\", secondaryDiagonal(board)},\n        {\"diagonal\", secondaryDiagonal(board)},\n    };\n    auto xDidNotWin = make_pair(\"X did not win\", Line());\n    auto xWon = [](auto value){\n        return lineFilledWithX(value.second);\n    };\n\n    return findInCollectionWithDefault(linesWithDescription, xDidNotWin, xWon).first; \n};\n\nTEST_CASE(\"X did not win\"){\n    Board board {\n        {'X', 'X', ' '},\n        {' ', 'O', ' '},\n        {' ', ' ', 'O'}\n    };\n\n    CHECK_EQ(\"X did not win\", howDidXWin(board));\n}\n```"]