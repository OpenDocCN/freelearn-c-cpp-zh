- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: System Tick (SysTick) Timer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统滴答（SysTick）定时器
- en: In this chapter, we will learn about the **System Tick** (**SysTick**) timer,
    an important core peripheral in all Arm Cortex microcontrollers. We will begin
    by introducing the SysTick timer and discussing its most common use cases. Following
    this, we will explore the SysTick timer registers in detail. Finally, we will
    develop a driver for the SysTick timer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于**系统滴答（SysTick）**定时器的内容，这是所有Arm Cortex微控制器的一个重要核心外设。我们将从介绍SysTick定时器及其最常见用途开始。随后，我们将详细探讨SysTick定时器的寄存器。最后，我们将开发一个SysTick定时器的驱动程序。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要主题：
- en: Introduction to the SysTick timer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SysTick定时器简介
- en: Developing a driver for the SysTick timer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发SysTick定时器驱动程序
- en: By the end of this chapter, you will have a good understanding of the SysTick
    timer and be able to effectively implement and utilize it in your Arm Cortex-M
    projects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将很好地理解SysTick定时器，并能够有效地在Arm Cortex-M项目中实现和利用它。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到，地址为
- en: '[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。'
- en: Introduction to the SysTick timer
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SysTick定时器简介
- en: The **System Tick** timer, commonly known as **SysTick**, is a fundamental component
    of all Arm Cortex microcontrollers. Regardless of the processor core—whether it’s
    Cortex-M0, Cortex-M1, or Cortex-M7—and the silicon manufacturer—be it STMicroelectronics,
    Texas Instruments, or any other—every Arm Cortex microcontroller includes a SysTick
    timer. In this section, we will learn about this essential peripheral and explore
    its registers in detail.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 系统滴答（SysTick）定时器，通常称为SysTick，是所有Arm Cortex微控制器的核心组件。无论处理器核心是Cortex-M0、Cortex-M1还是Cortex-M7，以及硅制造商是STMicroelectronics、Texas
    Instruments还是其他任何公司，每个Arm Cortex微控制器都包含一个SysTick定时器。在本节中，我们将了解这个基本的外设并详细探讨其寄存器。
- en: Overview of the SysTick timer
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SysTick定时器概述
- en: The SysTick timer is a **24-bit down counter** integral to all Arm Cortex-M
    processors. It is designed to offer a configurable time base that can be used
    for various purposes, such as **task scheduling**, **system monitoring**, and
    **time tracking**. This timer provides us with a simple and efficient means of
    **generating periodic interrupts** and serves as a cornerstone for implementing
    system timing functions, including **operating system** (**OS**) tick generation
    for **real-time operating systems** (**RTOSs**). Using SysTick makes our code
    more portable since it is part of the core and not a vendor-specific peripheral.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: SysTick定时器是所有Arm Cortex-M处理器的**24位向下计数器**。它被设计为提供可配置的时间基准，可用于各种目的，如**任务调度**、**系统监控**和**时间跟踪**。这个定时器为我们提供了一种简单高效的方法来**生成周期性中断**，并作为实现系统定时功能的基础，包括为**实时操作系统（RTOS）**生成**操作系统（OS）**滴答。使用SysTick使得我们的代码更具可移植性，因为它属于核心，而不是供应商特定的外设。
- en: 'The key features of the SysTick timer include the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SysTick定时器的关键特性包括以下内容：
- en: '**24-bit Reloadable Counter**: The counter decrements from a specified value
    to zero, then reloads automatically to provide a continuous timing operation'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**24位可重载计数器**：计数器从指定值递减到零，然后自动重载以提供连续的定时操作'
- en: '**Core Integration**: Being part of the core, it requires minimal configuration
    and offers low-latency interrupt handling'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心集成**：作为核心的一部分，它需要最小的配置并提供低延迟的中断处理'
- en: '**Configurable Clock Source**: SysTick can operate either from the core clock
    or an external reference clock, providing flexibility in timing accuracy and power
    consumption'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可配置的时钟源**：SysTick可以从核心时钟或外部参考时钟运行，提供在定时精度和功耗方面的灵活性'
- en: '**Interrupt Generation**: When the counter reaches zero, it can trigger an
    interrupt'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中断生成**：当计数器达到零时，它可以触发一个中断'
- en: 'The SysTick timer typically serves three primary use cases:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: SysTick定时器通常有三个主要用途：
- en: '**OS Tick Generation**: In an RTOS environment, SysTick is commonly used to
    generate the system tick interrupt, which drives the OS scheduler'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统滴答生成**：在实时操作系统（RTOS）环境中，SysTick通常用于生成系统滴答中断，驱动操作系统调度器'
- en: '**Periodic Task Execution**: It can be used to trigger regular tasks, such
    as sensor sampling or communication checks'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**周期性任务执行**：它可以用来触发定期任务，如传感器采样或通信检查'
- en: '**Time Delay Functions**: SysTick can provide precise delays for various timing
    functions within the firmware'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间延迟函数**：SysTick 可以在固件中提供精确的延迟，用于各种定时功能'
- en: Now let’s explore the registers in the SysTick timer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索 SysTick 定时器中的寄存器。
- en: SysTick timer registers
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SysTick 定时器寄存器
- en: 'The SysTick timer consists of four primary registers:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: SysTick 定时器由四个主要寄存器组成：
- en: SysTick Control and Status Register (`SYST_CSR`)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SysTick 控制和状态寄存器（`SYST_CSR`）
- en: SysTick Reload Value Register (`SYST_RVR`)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SysTick 重载值寄存器（`SYST_RVR`）
- en: SysTick Current Value Register (`SYST_CVR`)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SysTick 当前值寄存器（`SYST_CVR`）
- en: SysTick Calibration Value Register (`SYST_CALIB`)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SysTick 校准值寄存器（`SYST_CALIB`）
- en: Let’s analyze them one by one, starting with the Control and Status Register.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析它们，从控制和状态寄存器开始。
- en: The SysTick Control and Status Register (SYST_CSR)
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SysTick 控制和状态寄存器（SYST_CSR）
- en: 'The `SYST_CSR` register controls the SysTick timer’s operation and provides
    status information. It has the following bits:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`SYST_CSR` 寄存器控制 SysTick 定时器的操作并提供状态信息。它具有以下位：'
- en: '**ENABLE (Bit 0)**: Enables or disables the SysTick counter'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ENABLE（位 0）**：启用或禁用 SysTick 计数器'
- en: '**TICKINT (Bit 1)**: Enables or disables the SysTick interrupt'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TICKINT（位 1）**：启用或禁用 SysTick 中断'
- en: '**CLKSOURCE (Bit 2)**: Selects the clock source (0 = external reference clock,
    1 = processor clock)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CLKSOURCE（位 2）**：选择时钟源（0 = 外部参考时钟，1 = 处理器时钟）'
- en: '**COUNTFLAG (Bit 16)**: Indicates whether the counter has reached zero since
    the last read (1 = yes, 0 = no)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COUNTFLAG（位 16）**：指示自上次读取以来计数器是否已达到零（1 = 是，0 = 否）'
- en: 'This is the structure of the SysTick Control and Status Register:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 SysTick 控制和状态寄存器的结构：
- en: '![Figure 8.1: The SysTick Control and Status Register](img/B21914_08_1.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1：SysTick 控制和状态寄存器](img/B21914_08_1.jpg)'
- en: 'Figure 8.1: The SysTick Control and Status Register'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：SysTick 控制和状态寄存器
- en: The next register is the SysTick Reload Value Register (`SYST_RVR`).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个寄存器是 SysTick 重载值寄存器（`SYST_RVR`）。
- en: The SysTick Reload Value Register (SYST_RVR)
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SysTick 重载值寄存器（SYST_RVR）
- en: This register specifies the start value to load into the SysTick Current Value
    Register. It is crucial for setting the timer’s period and understanding its bit
    assignments and calculations is essential for effective SysTick configuration.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此寄存器指定要加载到 SysTick 当前值寄存器的起始值。这对于设置定时器的周期至关重要，并且理解其位分配和计算对于有效的 SysTick 配置是必不可少的。
- en: 'It has the following fields:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有以下字段：
- en: '**Bits [31:24] Reserved**: These bits are reserved'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位 [31:24] 保留**：这些位是保留的'
- en: '`SYST_CVR` register when the counter is enabled and when it reaches zero'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当计数器启用且计数器达到零时，`SYST_CVR` 寄存器
- en: 'This is the structure of the SysTick Reload Value Register:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 SysTick 重载值寄存器的结构：
- en: '![Figure 8.2: The SysTick Reload Value Register](img/B21914_08_2.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2：SysTick 重载值寄存器](img/B21914_08_2.jpg)'
- en: 'Figure 8.2: The SysTick Reload Value Register'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：SysTick 重载值寄存器
- en: Since SysTick is a 24-bit timer, the `RELOAD` value can be any value in the
    range **0x00000001** to **0x00FFFFFF**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SysTick 是一个 24 位定时器，`RELOAD` 值可以是 **0x00000001** 到 **0x00FFFFFF** 范围内的任何值。
- en: To calculate the `RELOAD` value based on the desired timer period, we determine
    the number of clock cycles for the desired period, and then subtract 1 from this
    number to get the `RELOAD` value.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据所需的定时器周期计算 `RELOAD` 值，我们确定所需周期的时钟周期数，然后从该数字中减去 1 以获得 `RELOAD` 值。
- en: 'For example, if the `RELOAD` value would be calculated as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 `RELOAD` 值计算如下：
- en: 'Calculate the number of clock cycles in 1 ms:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 1 毫秒内的时钟周期数：
- en: '**Clock cycles = 16,000,000 cycles/second * 0.001 second =** **16,000 cycles**'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**时钟周期 = 16,000,000 个周期/秒 * 0.001 秒 =** **16,000 个周期**'
- en: 'Note: 1ms = 0.001 second'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：1ms = 0.001 秒
- en: 'Subtract 1 from the calculated number of clock cycles:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从计算出的时钟周期数中减去 1：
- en: '**RELOAD = 16,000 - 1 = 15,999** since counting from 0 to 15,999 will give
    us 16000 ticks.'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**RELOAD = 16,000 - 1 = 15,999**，因为从 0 到 15,999 的计数将给我们 16000 个滴答。'
- en: Meaning, to configure the SysTick timer for a 1 ms period with a 16 MHz clock,
    we would set the `RELOAD` value to `SYST_CVR`).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着，为了配置 SysTick 定时器以 1 ms 的时间周期和 16 MHz 的时钟，我们将 `RELOAD` 值设置为 `SYST_CVR`）。
- en: The SysTick Current Value Register
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SysTick 当前值寄存器
- en: The SysTick Current Value Register (`SYST_CVR`) holds the current value of the
    SysTick counter. We can use this register to monitor the countdown process and
    to reset the counter when necessary.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: SysTick 当前值寄存器（`SYST_CVR`）保存 SysTick 计数器的当前值。我们可以使用此寄存器来监控倒计时过程，并在必要时重置计数器。
- en: 'It has the following fields:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有以下字段：
- en: '**Bits [31:24] Reserved**: These bits are reserved and should not be modified.
    They must be written as zero.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位[31:24]保留**：这些位是保留位，不应修改。它们必须写为零。'
- en: '`COUNTFLAG` bit in the SysTick Control and Status Register (`SYST_CSR`). This
    is the SysTick Current Value Register:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COUNTFLAG`位在SysTick控制和状态寄存器（`SYST_CSR`）中。这是SysTick当前值寄存器：'
- en: '![Figure 8.3: The SysTick Current Value Register](img/B21914_08_3.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：SysTick当前值寄存器](img/B21914_08_3.jpg)'
- en: 'Figure 8.3: The SysTick Current Value Register'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：SysTick当前值寄存器
- en: The SysTick Calibration Value Register
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SysTick校准值寄存器
- en: The final register of the SysTick timer is the SysTick Calibration Value Register
    (`SYST_CALIB`). This register provides us with the calibration properties of the
    SysTick timer.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SysTick定时器的最后一个寄存器是SysTick校准值寄存器（`SYST_CALIB`）。此寄存器为我们提供了SysTick定时器的校准属性。
- en: The names of these registers are slightly different in the STM32 header files.
    *Table 8.1* provides a clear correspondence between the register names used in
    the *Arm Generic User Guide* documentation and those in the STM32-specific header
    files. This correspondence will help us understand and reference them correctly
    in our code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些寄存器的名称在STM32头文件中略有不同。*表8.1*提供了在*Arm通用用户指南*文档中使用的寄存器名称与STM32特定头文件中使用的寄存器名称之间的清晰对应关系。这种对应关系将帮助我们正确理解和在我们的代码中引用它们。
- en: '| **Function** | **Arm Generic** **User Guide** | **STM32** **Header File**
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **Arm通用** **用户指南** | **STM32** **头文件** |'
- en: '| --- | --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Control and Status | SYST_CSR | SysTick->CTRL |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 控制和状态 | SYST_CSR | SysTick->CTRL |'
- en: '| Reload Value | SYST_RVR | SysTick->LOAD |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 重载值 | SYST_RVR | SysTick->LOAD |'
- en: '| Current Value | SYST_CVR | SysTick->VAL |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 当前值 | SYST_CVR | SysTick->VAL |'
- en: '| Calibration Value | SYST_CALIB | SysTick->CALIB |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 校准值 | SYST_CALIB | SysTick->CALIB |'
- en: 'Table 8.1: Correspondence of SysTick register names'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1：SysTick寄存器名称对应关系
- en: In the next section, we will use the information we have learned to develop
    a driver for the SysTick timer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用我们所学到的知识开发SysTick定时器的驱动程序。
- en: Developing a driver for the SysTick timer
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发SysTick定时器的驱动程序
- en: In this section, we will develop a driver for the SysTick timer to generate
    precise delays.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开发一个用于生成精确延迟的SysTick定时器驱动程序。
- en: Let’s start by making a copy of our last project in our IDE, following the steps
    we learned in [*Chapter 7*](B21914_07.xhtml#_idTextAnchor217). Rename the copied
    project to `SysTick`. Next, create a new file named `systick.c` in the `Src` folder
    and another file named `systick.h` in the `Inc` folder, just like we did for the
    GPIO drivers in the previous lesson.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的集成开发环境（IDE）中按照我们在[*第7章*](B21914_07.xhtml#_idTextAnchor217)中学到的步骤，复制我们上一个项目。将复制的项目重命名为`SysTick`。接下来，在`Src`文件夹中创建一个名为`sttyck.c`的新文件，在`Inc`文件夹中创建一个名为`sttyck.h`的新文件，就像我们在上一课中为GPIO驱动器所做的那样。
- en: 'Populate your `systick.c` file with the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码填充你的`systick.c`文件：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s break it down.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其分解。
- en: 'We start with the header file inclusion:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从包含头文件开始：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This line includes the header file, `systick.h`, which in turn includes `stm32fxx.h`
    to provide access to the register definitions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码包含了头文件`systick.h`，它反过来包含`stm32fxx.h`以提供对寄存器定义的访问。
- en: 'Next, we define all the macros we need:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义所有需要的宏：
- en: '`#define CTRL_ENABLE (1U << 0)`: Macro to enable the SysTick timer.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#define CTRL_ENABLE (1U << 0)`: 宏定义用于启用SysTick定时器。'
- en: '`#define CTRL_CLKSRC (1U << 2)`: Macro to select the internal clock source
    for the SysTick timer.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#define CTRL_CLKSRC (1U << 2)`: 宏定义选择SysTick定时器的内部时钟源。'
- en: '`#define CTRL_COUNTFLAG (1U << 16)`: Macro to check the `COUNTFLAG` bit, which
    indicates when the timer has counted to zero.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#define CTRL_COUNTFLAG (1U << 16)`: 宏定义用于检查`COUNTFLAG`位，该位指示定时器已计数到零。'
- en: '`#define ONE_MSEC_LOAD 16000`: Macro to define the number of clock cycles in
    1 millisecond. This assumes the microcontroller’s clock frequency is 16 MHz. This
    is the default configuration of the NUCLEO-F411 development board.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#define ONE_MSEC_LOAD 16000`: 宏定义1毫秒中的时钟周期数。这假设微控制器的时钟频率为16 MHz。这是NUCLEO-F411开发板的默认配置。'
- en: Next, we move on to the function implementation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入函数实现。
- en: 'First, we have the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有以下内容：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This line loads the SysTick timer with the number of clock cycles for 1 millisecond.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将SysTick定时器加载为1毫秒的时钟周期数。
- en: 'Then, we clear the Current Value register with the following to reset the timer:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下方法清除当前值寄存器以重置定时器：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we select the internal clock source:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们选择内部时钟源：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To enable the SysTick timer, we use the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用SysTick定时器，我们使用以下方法：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we enter the loop that handles the delay:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们进入处理延迟的循环：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This loop runs for the specified delay duration. Inside each iteration, it waits
    for the `COUNTFLAG` bit to be set, which indicates the timer has counted down
    to zero.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此循环运行指定的延迟时间。在每个迭代中，它等待 `COUNTFLAG` 位被设置，这表示定时器已计数到零。
- en: 'Finally, we disable the SysTick timer:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们禁用 SysTick 定时器：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And that’s it! With these steps, we’ve successfully implemented a delay function
    using the SysTick timer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！通过这些步骤，我们已成功使用 SysTick 定时器实现了延迟函数。
- en: Our next task is to populate the `systick.h` file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是填充 `systick.h` 文件。
- en: 'Here is the code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Over here, the `#include <stdint.h>` directive is needed to ensure that we have
    access to standard integer type definitions provided by the C standard library.
    These definitions include fixed-width integer types such as `uint32_t`, `int32_t`,
    `uint16_t`, and so on, which are essential for writing portable and clear code,
    especially in embedded systems programming.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，需要 `#include <stdint.h>` 指令以确保我们可以访问由 C 标准库提供的标准整数类型定义。这些定义包括固定宽度整数类型，如
    `uint32_t`、`int32_t`、`uint16_t` 等，这对于编写可移植和清晰的代码至关重要，尤其是在嵌入式系统编程中。
- en: With the driver files complete, we are now ready to test inside `main.c`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动文件完成后，我们现在可以在 `main.c` 中进行测试。
- en: First, let’s enhance our `gpio.c` file by adding a new function that toggles
    the LED. This will simplify our code by allowing us to toggle the LED with a single
    function call instead of calling `led_on()` and `led_off()` separately.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过添加一个新的切换 LED 的函数来增强我们的 `gpio.c` 文件。这将通过允许我们通过单个函数调用切换 LED 而不是分别调用 `led_on()`
    和 `led_off()` 来简化我们的代码。
- en: 'Add the following function to your `gpio.c` file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下函数添加到你的 `gpio.c` 文件中：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function toggles the state of the LED connected to pin PA5 by using the
    bitwise `XOR` operation on the **Output Data** **Register** (**ODR**).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过在 **输出数据寄存器**（**ODR**）上执行位异或操作来切换连接到 PA5 引脚的 LED 的状态。
- en: 'Next, declare this function in the `gpio.h` file by adding the following line:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `gpio.h` 文件中声明此函数，添加以下行：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, update your `main.c` file as shown here to call the SysTick delay
    and LED toggle functions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照以下示例更新你的 `main.c` 文件以调用 SysTick 延迟和 LED 切换函数：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we are **toggling the LED at a 500ms interval**. Build the
    project and run it on your development board. You should see the green LED blinking.
    To experiment further, you can modify the delay value and observe how the blinking
    rate of the LED changes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们以 500ms 的时间间隔 **切换 LED**。构建项目并在你的开发板上运行它。你应该看到绿色 LED 闪烁。为了进一步实验，你可以修改延迟值并观察
    LED 闪烁速率的变化。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the SysTick timer, a core peripheral of all Arm
    Cortex microcontrollers. We began with an introduction to the SysTick timer, discussing
    its significance and common applications, such as generating OS ticks in real-time
    operating systems, executing periodic tasks, and providing precise time delays.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 SysTick 定时器，这是所有 Arm Cortex 微控制器的核心外设。我们首先介绍了 SysTick 定时器，讨论了其重要性和常见应用，例如在实时操作系统中生成
    OS 拓扑，执行周期性任务，以及提供精确的时间延迟。
- en: We then examined the SysTick timer’s registers in detail. These included the
    Control and Status Register (`SYST_CSR`), which manages the timer’s operation
    and status; the Reload Value Register (`SYST_RVR`), which sets the timer’s countdown
    period; the Current Value Register (`SYST_CVR`), which holds the current value
    of the countdown; and the Calibration Value Register (`SYST_CALIB`), which provides
    essential calibration properties for accurate timing. We also provided a comparison
    between the register names used in the Arm Generic User Guide and those in the
    STM32 header files to ensure clear correspondence for accurate coding.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后详细检查了 SysTick 定时器的寄存器。这些包括控制状态寄存器（`SYST_CSR`），它管理定时器的操作和状态；重载值寄存器（`SYST_RVR`），它设置定时器的倒计时周期；当前值寄存器（`SYST_CVR`），它持有倒计时的当前值；以及校准值寄存器（`SYST_CALIB`），它提供了精确计时所需的基本校准属性。我们还提供了
    Arm 通用用户指南中使用的寄存器名称与 STM32 头文件中使用的寄存器名称之间的比较，以确保准确编码的清晰对应。
- en: The chapter concluded with the development of a SysTick timer driver. We walked
    through the creation and implementation of the `systick_msec_delay` function,
    which introduces millisecond delays using the SysTick timer. To test the driver,
    we integrated it with GPIO functions to toggle our green LED, demonstrating how
    to achieve precise timing and control in embedded systems.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以开发一个SysTick定时器驱动程序结束。我们回顾了`systick_msec_delay`函数的创建和实现过程，该函数通过SysTick定时器引入毫秒级延迟。为了测试该驱动程序，我们将其与GPIO功能集成，以切换我们的绿色LED，展示了如何在嵌入式系统中实现精确的时序和控制。
- en: In the next chapter, we shall learn about another timer peripheral. Unlike the
    SysTick timer, the configuration of this timer peripheral is specific to STM32
    microcontrollers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习另一个定时器外设。与SysTick定时器不同，这个定时器外设的配置是针对STM32微控制器特定的。
