- en: '*Chapter 17*: Sound Spatialization and the HUD'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第17章*：声音空间化和HUD'
- en: In this chapter, we will be adding all the sound effects and the HUD. We have
    done this in two of the previous projects, but we will do things a bit differently
    this time. We will explore the concept of sound **spatialization** and how SFML
    makes this otherwise complicated concept nice and easy. In addition, we will build
    a HUD class to encapsulate our code that draws information to the screen.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将添加所有音效和HUD。我们已经在之前的两个项目中这样做过，但这次我们将有所不同。我们将探讨声音**空间化**的概念以及SFML如何使这个原本复杂的概念变得简单易行。此外，我们还将构建一个HUD类来封装将信息绘制到屏幕上的代码。
- en: We will complete these tasks in the following order.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下顺序完成这些任务。
- en: What is spatialization?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是空间化？
- en: How SFML handles spatialization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML如何处理空间化
- en: Building a SoundManager class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建SoundManager类
- en: Deploying emitters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署发射器
- en: Using the SoundManager class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SoundManager类
- en: Building a `HUD` class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个`HUD`类
- en: Using the `HUD` class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`HUD`类
- en: What is spatialization?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是空间化？
- en: '**Spatialization** is the act of making something relative to the space it
    is a part of, or within. In our daily lives, everything in the natural world,
    by default, is spatialized. If a motorbike whizzes past from left to right, we
    will hear the sound grow from faint to loud from one side to the other. As it
    passes by, it will become more prominent in the other ear, before fading into
    the distance once more. If we were to wake up one morning and the world was no
    longer spatialized, it would be exceptionally weird.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**空间化**是将某物与它所包含的空间或其中的空间相关联的行为。在我们的日常生活中，自然世界中的所有事物默认都是空间化的。如果一辆摩托车从左到右呼啸而过，我们将会听到声音从一侧的微弱到另一侧的响亮。当它经过时，它会在另一只耳朵中变得更加突出，然后再逐渐消失在远处。如果我们某天早上醒来，发现世界不再空间化，那将会非常奇怪。'
- en: If we can make our video games a little bit more like the real world, our players
    can become more immersed. Our zombie game would have been a lot more fun if the
    player could have heard them faintly in the distance and their inhuman wailing
    grew louder as they drew closer, from one direction or another.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能让我们的视频游戏更接近现实世界，我们的玩家可以更加沉浸其中。如果玩家能在远处听到僵尸微弱的声音，而他们的非人类尖叫随着他们越来越近而变得越来越大，我们的僵尸游戏会更有趣。
- en: It is probably obvious that the mathematics of spatialization will be complex.
    How do we calculate how loud a given sound will be in a specific speaker based
    on the distance and direction from the player (the hearer of the sound) to the
    object that is making the sound (the emitter)?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能很明显，空间化的数学将是复杂的。我们如何根据玩家（声音的听者）到发出声音的对象（发射器）的距离和方向来计算特定扬声器中给定声音的响度？
- en: Fortunately, SFML does all the complicated processes for us. All we need to
    do is get familiar with a few technical terms and then we can start using SFML
    to spatialize our sound effects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，SFML为我们处理了所有复杂的过程。我们只需要熟悉一些技术术语，然后我们就可以开始使用SFML来空间化我们的音效。
- en: Emitters, attenuation, and listeners
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发射器、衰减和听者
- en: We will need to be aware of a few pieces of information in order to give SFML
    what it needs to do its work. We will need to be aware of where the sound is coming
    from in our game world. This source of the sound is called an **emitter**. In
    a game, the emitter could be a zombie, a vehicle, or in the case of our current
    project, a fire tile. We have already been keeping track of the position of the
    objects in our game, so giving SFML the emitter's location will be quite straightforward.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给SFML提供它完成工作所需的信息，我们需要了解一些信息。我们需要知道声音在我们的游戏世界中是从哪里发出的。这个声音的来源被称为**发射器**。在游戏中，发射器可以是僵尸、车辆，或者在我们当前的项目中，是一个火砖。我们已经一直在跟踪我们游戏中对象的位置，因此向SFML提供发射器的位置将非常直接。
- en: The next factor we need to be aware of is **attenuation**. Attenuation is the
    rate at which a wave deteriorates. You could simplify that statement and make
    it specific to sound and say that attenuation is how quickly the sound reduces
    in volume. It isn't technically accurate, but it is a good enough description
    for the purposes of this chapter and our game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要关注的下一个因素是**衰减**。衰减是波衰减的速度。你可以简化这个陈述，并使其具体到声音，即衰减是声音减少音量的速度。这从技术上讲并不准确，但对于本章和我们的游戏来说，这是一个足够好的描述。
- en: The final factor that we need to consider is the **listener**. When SFML spatializes
    the sound, where is it spatializing it relative to; where are the "ears" of the
    game.? In most games, the logical thing to do is use the player character. In
    our game, we will use Thomas (our player character).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑的最后一个因素是**监听器**。当 SFML 空间化声音时，它是相对于什么进行空间化的；游戏的“耳朵”在哪里？在大多数游戏中，合乎逻辑的做法是使用玩家角色。在我们的游戏中，我们将使用托马斯（我们的玩家角色）。
- en: Handling spatialization using SFML
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SFML 处理空间化
- en: SFML has several functions that allow us to handle emitters, attenuation, and
    listeners. Let's take a look at them hypothetically and then we will write some
    code to add spatialized sound to our project for real.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: SFML 有几个函数允许我们处理发射器、衰减和监听器。让我们假设地看看它们，然后我们将编写一些代码来真正地将空间化声音添加到我们的项目中。
- en: 'We can set up a sound effect ready to be played, as we have done so often already,
    like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置一个准备播放的声音效果，就像我们经常做的那样，如下所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can set the position of the emitter using the `setPosition` function shown
    in the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码中显示的 `setPosition` 函数来设置发射器的位置：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As suggested in the comments of the previous code, how exactly we can obtain
    the coordinates of the emitter will probably be dependent on the type of game.
    As shown in the previous code, this would be quite simple in the Zombie Arena
    project. We will have a few challenges to overcome when we set the position in
    this project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一段代码的注释中所建议的，我们如何确切地获取发射器的坐标可能会取决于游戏类型。正如前一段代码所示，在僵尸竞技场项目中，这将会非常简单。在我们这个项目中设置位置时，我们将面临一些挑战。
- en: 'We can set the attenuation level as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置衰减级别如下：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The actual attenuation level can be a little ambiguous. The effect that we want
    the player to get might be different from the accurate scientific formula that
    is used to reduce the volume over distance based on attenuation. Getting the right
    attenuation level is usually achieved by experimenting. The higher the level of
    attenuation, the quicker the sound level reduces to silence.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的衰减级别可能有点模糊。我们希望玩家获得的效果可能与基于衰减的准确科学公式所使用的减少距离上的音量不同。获得正确的衰减级别通常是通过实验来实现的。衰减级别越高，音量降低到静音的速度就越快。
- en: 'Also, we might want to set a zone around the emitter where the volume is not
    attenuated at all. We might do this if the feature isn''t appropriate beyond a
    certain range or if we have many sound sources and don''t won''t to "overdo" the
    feature. To do so, we can use the `setMinimumDistance` function as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能还想设置一个围绕发射器的区域，其中音量不会衰减。如果我们认为这个特性在某个范围之外不合适，或者如果我们有多个声音源并且不想“过度”使用这个特性，我们可能会这样做。为此，我们可以使用如下所示的
    `setMinimumDistance` 函数：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the previous line of code, attenuation would not  be calculated until the
    listener is 150 pixels/units away from the emitter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一行代码，衰减只有在监听器距离发射器 150 像素/单位时才会计算。
- en: 'Some other useful functions from the SFML library include the `setLoop` function.
    This function will tell SFML to keep playing the sound over and over when `true`
    is passed in as a parameter, like in the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: SFML 库中还有一些其他有用的函数，包括 `setLoop` 函数。当将 `true` 作为参数传入时，此函数会告诉 SFML 无限次地播放声音，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The sound would continue to play until we end it with the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 声音将继续播放，直到我们使用以下代码结束它：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From time to time, we would want to know the status of a sound (playing or
    stopped). We can achieve this with the `getStatus` function, as demonstrated in
    the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想知道声音的状态（播放或停止）。我们可以通过以下代码中的 `getStatus` 函数来实现，如下所示：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There is just one more aspect of using sound spatialization with SFML that
    we need to cover. The listener. Where is the listener? We can set the position
    of the listener with the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SFML 进行声音空间化时，我们需要覆盖的最后一个方面是监听器。监听器在哪里？我们可以使用以下代码设置监听器的位置：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code will make all the sounds play relative to that location.
    This is just what we need for the distant roar of a fire tile or incoming zombie,
    but for regular sound effects like jumping, this is a problem. We could start
    handling an emitter for the location of the player, but SFML makes things simple
    for us. Whenever we want to play a "normal" sound, we simply call `setRelativeToListener`,
    as shown in the following code, and then play the sound in the exact same way
    we have done so far. Here is how we might play a "normal" unspatialized jump sound
    effect:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将使所有声音相对于该位置播放。这正是我们需要的，用于远处火砖或即将到来的僵尸的咆哮声，但对于像跳跃这样的常规声音效果，这是一个问题。我们可以开始处理玩家的位置发射器，但SFML为我们简化了这些事情。每次我们想要播放一个“正常”的声音时，我们只需像以下代码所示调用`setRelativeToListener`，然后以我们迄今为止相同的方式播放声音。以下是我们可能播放的“正常”非空间化跳跃声音效果的方式：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All we need to do is call `Listener::setPosition` again before we play any spatialized
    sounds.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是在我们播放任何空间化声音之前再次调用`Listener::setPosition`。
- en: We now have a wide repertoire of SFML sound functions, and we are ready to make
    some spatialized noise for real.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有丰富的SFML声音函数，我们准备好真正制作一些空间化噪音了。
- en: Building the SoundManager class
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建SoundManager类
- en: You might recall from the previous project that all the sound code took up quite
    a few lines of code. Now, consider that, with spatialization, it's going to get
    longer still. To keep our code manageable, we will code a class to manage all
    our sound effects being played. In addition, to help us with spatialization, we
    will add a function to the `Engine` class as well, but we will discuss that when
    we come to it, later in this chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得上一个项目中，所有的声音代码占据了相当多的代码行。现在，考虑到空间化，它还将变得更长。为了保持我们的代码可管理，我们将编写一个类来管理所有正在播放的声音效果。此外，为了帮助我们进行空间化，我们还将向`Engine`类添加一个函数，但我们将稍后在本章中讨论这一点。
- en: Coding SoundManager.h
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写SoundManager.h
- en: Let's get started by coding and examining the header file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写和检查头文件。
- en: Right-click `SoundManager.h`. Finally, click the `SoundManager` class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击`SoundManager.h`。最后，点击`SoundManager`类。
- en: 'Add and examine the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 添加并检查以下代码：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There is nothing tricky in the code we just added. There are five `SoundBuffer`
    objects and eight `Sound` objects. Three of the `Sound` objects will play the
    same `SoundBuffer`. This explains the reason for the different number of `Sound`/`SoundBuffer`
    objects. We do this so that we can have multiple roaring sound effects playing,
    with different spatialized parameters, simultaneously.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的代码中没有什么复杂的。有五个`SoundBuffer`对象和八个`Sound`对象。其中三个`Sound`对象将播放相同的`SoundBuffer`。这解释了为什么`Sound`/`SoundBuffer`对象的数量不同。我们这样做是为了能够同时播放多个具有不同空间化参数的咆哮声音效果。
- en: Note the `m_NextSound` variable, which will help us keep track of which of these
    simultaneous sounds we should use next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`m_NextSound`变量，它将帮助我们跟踪下一次应该使用这些同时播放的声音中的哪一个。
- en: There is a constructor, `SoundManager`, where we will set up all our sound effects,
    and there are five functions that will play the sound effects. Four of these functions
    simply play "normal" sound effects and their code will be simpler.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个构造函数`SoundManager`，我们将设置所有声音效果，并且有五个函数将播放声音效果。其中四个函数简单地播放“正常”声音效果，它们的代码会更简单。
- en: One of the functions, `playFire`, will handle the spatialized sound effects
    and will be a bit more in-depth. Notice the parameters of the `playFire` function.
    It receives a `Vector2f`, which is the location of the emitter and a second `Vector2f`,
    which is the location of the listener.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个函数`playFire`将处理空间化声音效果，并且会稍微深入一些。注意`playFire`函数的参数。它接收一个`Vector2f`，这是发射器的位置，以及第二个`Vector2f`，这是听者的位置。
- en: Coding the SoundManager.cpp file
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写SoundManager.cpp文件
- en: Now, we can code the function definitions. The constructor and the `playFire`
    functions have a large amount of code, so we will look at them individually. The
    other functions are short and sweet, so we will handle them all at once.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写函数定义。构造函数和`playFire`函数有大量的代码，所以我们将单独查看它们。其他函数都很短小精悍，所以我们将一次性处理它们。
- en: Right-click `SoundManager.cpp`. Finally, click the `.cpp` file for the `SoundManager`
    class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击`SoundManager.cpp`。最后，点击`SoundManager`类的`.cpp`文件。
- en: Coding the constructor
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写构造函数
- en: 'Add the following code for the include directives and the constructor to `SoundManager.cpp`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`SoundManager.cpp`的包含指令和构造函数中：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous code, we loaded five sound files into the five `SoundBuffer`
    objects. Next, we associated the eight `Sound` objects with one of the `SoundBuffer`
    objects. Notice that `m_Fire1Sound`, `m_Fire2Sound`, and `m_Fire3Sound` are all
    going to be playing from the same `SoundBuffer`, `m_FireBuffer`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将五个声音文件加载到五个`SoundBuffer`对象中。接下来，我们将八个`Sound`对象与一个`SoundBuffer`对象关联起来。请注意，`m_Fire1Sound`、`m_Fire2Sound`和`m_Fire3Sound`都将从同一个`SoundBuffer`，即`m_FireBuffer`中播放。
- en: Next, we set the attenuation and minimum distance for the three fire sounds.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置了三个火焰声音的衰减和最小距离。
- en: Tip
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: The values of `150` and `15`, respectively, were arrived at through experimentation.
    Once the game is running, it is advisable to experiment with these values by changing
    them around and seeing (or rather, hearing) the difference.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`150`和`15`的值是通过实验得到的。一旦游戏开始运行，建议通过更改这些值来实验，看看（或者更确切地说，听听）它们之间的差异。'
- en: Finally, for the constructor, we use the `setLoop` function on each of the fire-related
    `Sound` objects. Now, when we call `play`, they will play continuously.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于构造函数，我们在每个与火焰相关的`Sound`对象上使用`setLoop`函数。现在，当我们调用`play`时，它们将连续播放。
- en: Coding the playFire function
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写`playFire`函数
- en: 'Add the `playFire` function as follows. Then, we can discuss it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`playFire`函数如下。然后，我们可以讨论它：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first thing we do is call `Listener::setPosition` and set the location of
    the listener based on the `Vector2f` that is passed in as a parameter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用`Listener::setPosition`并根据传入的参数`Vector2f`设置听者的位置。
- en: Next, the code enters a `switch` block that tests the value of `m_NextSound`.
    Each of the `case` statements does the exact same thing but to either `m_Fire1Sound`,
    `m_Fire2Sound`, or `m_Fire3Sound`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码进入一个`switch`块，测试`m_NextSound`的值。每个`case`语句都做完全相同的事情，但针对`m_Fire1Sound`、`m_Fire2Sound`或`m_Fire3Sound`。
- en: In each of the `case` blocks, we set the position of the emitter using the passed
    in parameter with the `setPosition` function. The next part of the code in each
    `case` block checks whether the sound is currently stopped, and, if it is, plays
    the sound. Soon, we will see how we arrive at the positions for the emitter and
    listener that are passed into this function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个`case`块中，我们使用`setPosition`函数和传入的参数设置发射器的位置。每个`case`块中的代码的下一部分检查声音是否当前已停止，如果是，则播放声音。很快，我们将看到如何得到传递给此函数的发射器和听者的位置。
- en: The final part of the `playFire` function increments `m_NextSound` and ensures
    that it can only be equal to 1, 2, or 3, as required by the `switch` block.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`playFire`函数的最后部分增加`m_NextSound`，并确保它只能等于1、2或3，这是`switch`块所要求的。'
- en: Coding the rest of the SoundManager functions
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写SoundManager的其他函数
- en: 'Add these four simple functions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下四个简单函数：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `playFallInFire`, `playFallInWater`, and `playReachGoal` functions do just
    two things. First, they each call `setRelativeToListener` so that the sound effect
    is not spatialized, making the sound effect "normal", not directional, and then
    they call `play` on the appropriate `Sound` object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`playFallInFire`、`playFallInWater`和`playReachGoal`函数只做两件事。首先，它们各自调用`setRelativeToListener`，以便声音效果不是空间化的，使声音效果“正常”，而不是方向性的，然后它们在适当的`Sound`对象上调用`play`。'
- en: That concludes the `SoundManager` class. Now, we can use it in the `Engine`
    class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`SoundManager`类就完成了。现在，我们可以在`Engine`类中使用它。
- en: Adding SoundManager to the game engine
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将SoundManager添加到游戏引擎中
- en: 'Open the `Engine.h` file and add an instance of the new `SoundManager` class,
    as shown in the following highlighted code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Engine.h`文件，并添加一个新的`SoundManager`类实例，如下所示的高亮代码：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: At this point, we could use `m_SM` to call the various `play...` functions.
    Unfortunately, there is still a bit more work to be done in order to manage the
    locations of the emitters (fire tiles).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以使用`m_SM`调用各种`play...`函数。不幸的是，为了管理发射器（火焰瓷砖）的位置，我们还需要做一些额外的工作。
- en: Populating the sound emitters
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充声音发射器
- en: 'Open the `Engine.h` file and add a new prototype for a `populateEmitters` function
    and a new STL `vector` of `Vector2f` objects:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Engine.h`文件，并添加一个`populateEmitters`函数的新原型和一个新的STL `vector`，包含`Vector2f`对象：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `populateEmitters` function takes a `vector` of `Vector2f` objects as a
    parameter, as well as a pointer to pointer to `int` (a two-dimensional array).
    The `vector` will hold the location of each emitter in a level. The array is the
    two-dimensional array that holds the layout of a level.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`populateEmitters`函数接受一个`Vector2f`对象的`vector`作为参数，以及一个指向`int`指针的指针（一个二维数组）。`vector`将保存每个发射器在关卡中的位置。数组是包含关卡布局的二维数组。'
- en: Coding the populateEmitters function
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写populateEmitters函数
- en: The job of the `populateEmitters` function is to scan through all the elements
    of `arrayLevel` and decide where to put the emitters. It will store its results
    in `m_FireEmitters`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`populateEmitters`函数的职责是遍历`arrayLevel`数组中的所有元素，并决定将发射器放置在哪里。它将结果存储在`m_FireEmitters`中。'
- en: Right-click `PopulateEmitters.cpp`. Finally, click the `populateEmitters`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击`PopulateEmitters.cpp`。最后，点击`populateEmitters`。
- en: 'Add the code in its entirety. Be sure to study the code as you do, so that
    we can discuss it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码完整地添加进去。确保你在添加代码的同时仔细研究代码，这样我们就可以讨论它：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Some of the code might appear complex at first glance. Understanding the technique
    we are using to choose where an emitter will be makes this simpler. In our levels,
    there are large blocks of fire tiles. For example, in one of the levels, there
    are more than 30 fire tiles together in a group. The code makes sure that there
    is only one emitter within a given rectangle. This rectangle is stored in `previousEmitter`
    and is 300 pixels by 300 pixels (`TILE_SIZE * 6`).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码可能乍一看很复杂。理解我们用来选择发射器位置的技巧会使它变得简单。在我们的关卡中，有大量的火砖块。例如，在一个关卡中，有超过30块火砖聚集在一起。代码确保在给定的矩形内只有一个发射器。这个矩形存储在`previousEmitter`中，大小为300像素乘300像素（`TILE_SIZE
    * 6`）。
- en: The code sets up a nested `for` loop that loops through `arrayLevel`, looking
    for fire tiles. When it finds one, it makes sure that it does not intersect with
    `previousEmitter`. Only then does it use the `pushBack` function to add another
    emitter to `vSoundEmitters`. After doing so, it also updates `previousEmitter`
    to avoid getting large clusters of sound emitters.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码设置了一个嵌套的`for`循环，遍历`arrayLevel`，寻找火砖。当找到火砖时，它会确保它不与`previousEmitter`相交。只有在确保不相交后，它才会使用`pushBack`函数向`vSoundEmitters`添加另一个发射器。之后，它还会更新`previousEmitter`以避免出现大量声音发射器的聚集。
- en: Let's make some noise.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制造一些噪音。
- en: Playing sounds
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放声音
- en: 'Open the `LoadLevel.cpp` file and add the call to the new `populateEmitters`
    function, as highlighted in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`LoadLevel.cpp`文件，并添加对新的`populateEmitters`函数的调用，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first sound to add is the jump sound. We remember that the keyboard handling
    code is in the pure virtual functions within both the `Bob` and `Thomas` classes
    and that the `handleInput` function returns `true` when a jump has been successfully
    initiated.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要添加的声音是跳跃声音。我们记得键盘处理代码位于`Bob`和`Thomas`类中的纯虚函数内，并且当成功发起跳跃时，`handleInput`函数返回`true`。
- en: 'Open the `Input.cpp` file and add the following highlighted lines of code to
    play a jump sound when Thomas or Bob successfully begins a jump:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Input.cpp`文件，并添加以下高亮代码行以在托马斯或鲍勃成功开始跳跃时播放跳跃声音：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Open the `Update.cpp` file and add the following highlighted line of code to
    play a success sound when Thomas and Bob have simultaneously reached the goal
    for the current level:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Update.cpp`文件，并添加以下高亮代码行以在托马斯和鲍勃同时达到当前关卡目标时播放成功声音：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Also, within the `Update.cpp` file, we will add code to loop through the `m_FireEmitters`
    vector and decide when we need to call the `playFire` function of the `SoundManager`
    class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`Update.cpp`文件中，我们将添加代码来遍历`m_FireEmitters`向量，并决定何时调用`SoundManager`类的`playFire`函数。
- en: 'Look closely at the small amount of context around the new highlighted code.
    It is essential to add this code in exactly the right place:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察新高亮代码周围的小部分上下文。在正确的位置添加此代码是至关重要的：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code is a bit like collision detection for sound. Whenever Thomas
    strays within a 500 by 500-pixel rectangle surrounding a fire emitter, the `playFire`
    function is called, passing in the coordinates of the emitter and of Thomas. The
    `playFire` function does the rest of the work and plays a spatialized, looping
    sound effect.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码有点类似于声音的碰撞检测。每当托马斯进入围绕火发射器的一个500像素乘500像素的矩形内时，就会调用`playFire`函数，并将发射器和托马斯的坐标传递给它。`playFire`函数完成剩余的工作并播放一个空间化的循环声音效果。
- en: 'Open the `DetectCollisions.cpp` file, find the appropriate place, and add the
    following highlighted code. The two highlighted lines of code trigger the sound
    effect when either character falls into a water or fire tile:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `DetectCollisions.cpp` 文件，找到合适的位置，并添加以下突出显示的代码。这两行突出显示的代码会在任意一个角色掉入水或火焰方块时触发声音效果：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Playing the game will now allow you to hear all the sounds, including cool spatialization,
    when you're near a fire tile.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩游戏将允许你在靠近火焰方块时听到所有声音，包括酷炫的空间化效果。
- en: Implementing the HUD class
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 HUD 类
- en: The HUD is super-simple and not really anything different compared to the Zombie
    Arena project. What we will do that is different is wrap all the code up in a
    new `HUD` class. If we declare all the `Font`, `Text`, and other variables as
    members of this new class, we can then initialize them in the constructor and
    provide getter functions to all their values. This will keep the `Engine` class
    clear from loads of declarations and initializations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: HUD 非常简单，与僵尸竞技场项目相比并没有什么不同。我们将要做的是将所有代码封装在一个新的 `HUD` 类中。如果我们将所有 `Font`、`Text`
    和其他变量声明为这个新类的成员，我们就可以在构造函数中初始化它们，并为它们的值提供获取函数。这将使 `Engine` 类免于大量的声明和初始化。
- en: Coding HUD.h
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 HUD.h
- en: First, we will code the `HUD.h` file with all the member variables and function
    declarations. Right-click `HUD.h`. Finally, click the `HUD` class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用所有成员变量和函数声明来编写 `HUD.h` 文件。右键点击 `HUD.h`。最后，点击 `HUD` 类。
- en: 'Add the following code to `HUD.h`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `HUD.h` 文件中：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, we added one `Font` instance and three `Text` instances.
    The `Text` objects will be used to show a message prompting the user to start,
    the time remaining, and the current level number.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一个 `Font` 实例和三个 `Text` 实例。`Text` 对象将用于显示提示用户开始、剩余时间和当前关卡编号的消息。
- en: The public functions are more interesting. First, there is the constructor where
    most of the code will go. The constructor will initialize the `Font` and `Text`
    objects, as well as position them on the screen relative to the current screen
    resolution.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 公共函数更有趣。首先，是构造函数，大部分代码将在这里编写。构造函数将初始化 `Font` 和 `Text` 对象，并将它们相对于当前屏幕分辨率定位在屏幕上。
- en: The three getter functions, `getMessage`, `getLevel`, and `getTime`, will return
    a `Text` object to the calling code so that it can draw them to the screen.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 三个获取函数 `getMessage`、`getLevel` 和 `getTime` 将返回一个 `Text` 对象给调用代码，以便它可以将它们绘制到屏幕上。
- en: The `setLevel` and `setTime` functions will be used to update the text shown
    in `m_LevelText` and `m_TimeText`, respectively.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`setLevel` 和 `setTime` 函数将分别用于更新显示在 `m_LevelText` 和 `m_TimeText` 中的文本。'
- en: Now, we can code all the definitions for the functions we have just declared.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写我们刚刚声明的所有函数的定义。
- en: Coding the HUD.cpp file
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 HUD.cpp 文件
- en: Right-click `HUD.cpp`. Finally, click the `.cpp` file for the `HUD` class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 `HUD.cpp`。最后，点击 `HUD` 类的 `.cpp` 文件。
- en: 'Add the include directives and the following code. Then, we will discuss it:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 添加包含指令和以下代码。然后，我们将讨论它：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we store the horizontal and vertical resolution in a `Vector2u` called
    `resolution`. Next, we load the font from the `fonts` directory that we added
    back in [*Chapter 14*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292), *Abstraction
    and Code Management – Making Better Use of OOP*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将水平和垂直分辨率存储在一个名为 `resolution` 的 `Vector2u` 中。接下来，我们从添加回的 `fonts` 目录中加载字体，这是在
    [*第 14 章*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292)，*抽象和代码管理 – 更好地使用面向对象编程*
    中提到的。
- en: The next four lines of code set the font, the color, the size, and the text
    of `m_StartText`. The block of code after this captures the size of the rectangle
    that wraps `m_StartText` and performs a calculation to work out how to position
    it centrally on the screen. If you want a more thorough explanation of this part
    of the code, then refer to [*Chapter 3*](B14278_03_Final_AG_ePub.xhtml#_idTextAnchor098),
    *C++ Strings and SFML Time – Player Input and HUD*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四行代码设置了 `m_StartText` 的字体、颜色、大小和文本。在这段代码之后，它捕获了包裹 `m_StartText` 的矩形的尺寸，并执行计算以确定如何在屏幕上将其居中。如果你想要对这个代码部分的更详细解释，请参考
    [*第 3 章*](B14278_03_Final_AG_ePub.xhtml#_idTextAnchor098)，*C++ 字符串和 SFML 时间 –
    玩家输入和 HUD*。
- en: In the final two blocks of code in the constructor, the font, text size, color,
    position, and actual text for `m_TimeText` and `m_LevelText` are set. In a moment,
    we will see that these two `Text` objects will be updatable through two setter
    functions, whenever it is required.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数的最后两个代码块中，设置了 `m_TimeText` 和 `m_LevelText` 的字体、文本大小、颜色、位置和实际文本。稍后我们将看到，这两个
    `Text` 对象将通过两个设置函数进行更新，当需要时。
- en: 'Add the following getter and setter functions immediately underneath the code
    we have just added:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 立即将以下获取和设置函数添加到我们刚刚添加的代码下方：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first three functions in the previous code simply return the appropriate
    `Text` object, that is, `m_StartText`, `m_LevelText`, or `m_TimeText`. We will
    use these functions shortly when we draw the HUD to the screen. The final two
    functions, `setLevel` and `setTime`, use the `setString` functions to update the
    appropriate `Text` object with the value that will be passed in from the `update`
    function of the `Engine` class, every 500 frames.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的前三个函数简单地返回适当的 `Text` 对象，即 `m_StartText`、`m_LevelText` 或 `m_TimeText`。我们将在将
    HUD 绘制到屏幕上时不久使用这些函数。最后的两个函数，`setLevel` 和 `setTime`，使用 `setString` 函数来更新适当的 `Text`
    对象，该对象将使用从 `Engine` 类的 `update` 函数传递的值，每 500 帧。
- en: With all that done, we can put the HUD class to work in our game engine.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，我们可以在我们的游戏引擎中使用 HUD 类。
- en: Using the HUD class
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HUD 类
- en: Open `Engine.h`, add an include for our new class, declare an instance of the
    new `HUD` class, and declare and initialize two new member variables that will
    keep track of how often we update the HUD. As we learned in the previous projects,
    we don't need to update the HUD every frame.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Engine.h` 文件，为我们的新类添加一个包含语句，声明一个新 `HUD` 类的实例，并声明并初始化两个新的成员变量，这两个变量将跟踪我们更新
    HUD 的频率。正如我们在前面的项目中所学到的，我们不需要每帧都更新 HUD。
- en: 'Add the following highlighted code to `Engine.h`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下突出显示的代码添加到 `Engine.h`：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need to add some code to the `update` function of the `Engine` class.
    Open `Update.cpp` and add the following highlighted code to update the HUD once
    every 500 frames:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要向 `Engine` 类的 `update` 函数中添加一些代码。打开 `Update.cpp` 文件，并添加以下突出显示的代码以每 500
    帧更新一次 HUD：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, `m_FramesSinceLastUpdate` is incremented each frame.
    When `m_FramesSinceLastUpdate` exceeds `m_TargetFramesPerHUDUpdate`, then execution
    enters the `if` block. Inside the `if` block, we use `stringstream` objects to
    update our `Text`, like we did in the previous projects. In this project, we are
    using the `HUD` class, so we call the `setTime` and `setLevel` functions by passing
    in the current values that the `Text` objects need to be set to.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`m_FramesSinceLastUpdate` 在每帧都会增加。当 `m_FramesSinceLastUpdate` 超过 `m_TargetFramesPerHUDUpdate`
    时，执行进入 `if` 块。在 `if` 块内部，我们使用 `stringstream` 对象来更新我们的 `Text`，就像我们在前面的项目中做的那样。在这个项目中，我们使用
    `HUD` 类，因此我们通过传递当前 `Text` 对象需要设置的值来调用 `setTime` 和 `setLevel` 函数。
- en: The final step in the `if` block is to set `m_FramesSinceLastUpdate` back to
    zero so it can start counting toward the next update.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 块中的最后一步是将 `m_FramesSinceLastUpdate` 设置回零，以便它可以开始计算下一次更新。'
- en: 'Finally, open the `Draw.cpp` file and add the following highlighted code to
    draw the HUD each frame:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开 `Draw.cpp` 文件，并添加以下突出显示的代码以每帧绘制 HUD：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code draws the HUD by using the getter functions from the HUD
    class. Notice that the call to draw the message that prompts the player to start
    is only used when the game is not currently playing `(!m_Playing)`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码通过使用 HUD 类的获取函数来绘制 HUD。请注意，调用绘制提示玩家开始游戏的信息的代码仅在游戏当前未在播放时使用 `(!m_Playing)`。
- en: Run the game and play a few levels to see the time tick down and the levels
    tick up. When you get back to level 1 again, notice that you have 10% less time
    than before.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并玩几个关卡，以查看时间逐渐减少，关卡逐渐增加。当你再次回到关卡 1 时，请注意你比之前少了 10% 的时间。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored sound spatialization. Our "Thomas Was Late"
    game is not only fully playable now, but we have added directional sound effects
    and a simple but informative HUD. We can also add new levels with ease. At this
    point, we could call it a day.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了声音空间化。我们的 "Thomas Was Late" 游戏现在不仅完全可玩，我们还添加了方向性音效和一个简单但信息丰富的 HUD。我们也可以轻松添加新关卡。到目前为止，我们可以称之为完成了。
- en: It would be nice to add a bit more sparkle. In the next chapter, we will look
    into two gaming concepts. First, we will look at particle systems, which are how
    we can handle things such as explosions or other special effects. To achieve this,
    we will need to learn a bit more C++. Due to this, the topic of multiple inheritance
    will be introduced.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 希望能增加一些亮点。在下一章中，我们将探讨两个游戏概念。首先，我们将研究粒子系统，这是如何处理爆炸或其他特殊效果的方法。为了实现这一点，我们需要学习更多关于C++的知识。因此，多重继承这一主题将被引入。
- en: After that, we will add the final flourish to the game when we learn about OpenGL
    and the programmable graphics pipeline. We will then be able to dip our toes into
    the **GLSL** language, which allows us to write code that executes directly on
    the GPU so that we can create some special effects.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当我们学习OpenGL和可编程图形管线时，我们将为游戏增添最后的点缀。那时，我们将能够尝试接触**GLSL**语言，它允许我们编写直接在GPU上执行代码，从而创建一些特殊效果。
