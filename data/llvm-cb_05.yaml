- en: Chapter 5. Implementing Optimizations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 实现优化
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Writing a dead code elimination pass
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写死代码消除传递
- en: Writing an inlining transformation pass
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写内联转换传递
- en: Writing a pass for memory optimization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写内存优化传递
- en: Combining LLVM IR
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合LLVM IR
- en: Transforming and optimizing loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换和优化循环
- en: Reassociating expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新关联表达式
- en: Vectorizing IR
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量化IR
- en: Other optimization passes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他优化传递
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we saw how to write a pass in LLVM. We also demonstrated
    writing a few analysis passes with an example of alias analysis. Those passes
    just read the source code and gave us information about it. In this chapter, we
    will go further and write transformation passes that will actually change the
    source code, trying to optimize it for the faster execution of code. In the first
    two recipes, we will show you how a transformation pass is written and how it
    changes the code. After that, we will see how we can make changes in the code
    of passes to tinker with the behavior of the passes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何在LLVM中编写传递。我们还通过别名分析示例演示了编写几个分析传递。这些传递只是读取源代码并提供了有关它的信息。在本章中，我们将进一步编写转换传递，这些传递实际上会更改源代码，试图优化代码以实现更快的执行。在前两个食谱中，我们将向您展示如何编写转换传递以及它是如何更改代码的。之后，我们将看到我们如何可以在传递的代码中进行更改，以调整传递的行为。
- en: Writing a dead code elimination pass
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写死代码消除传递
- en: In this recipe, you will learn how to eliminate dead code from the program.
    By dead code elimination, we mean removing the code that has no effect whatsoever
    on the results that the source program outputs on executing. The main reasons
    to do so are reduction of the program size, which makes the code quality good
    and makes it easier to debug the code later on; and improving the run time of
    the program, as the unnecessary code is prevented from being executed. In this
    recipe, we will show you a variant of dead code elimination, called aggressive
    dead code elimination, that assumes every piece of code to be dead until proven
    otherwise. We will see how to implement this pass ourselves, and what modifications
    we need to make so that the pass can run just like other passes in the `lib/Transforms/Scalar`
    folder of the LLVM trunk.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将学习如何从程序中消除死代码。通过消除死代码，我们指的是移除对源程序执行输出的结果没有任何影响的代码。这样做的主要原因包括减少程序大小，从而提高代码质量并使代码更容易调试；以及提高程序的运行时间，因为不必要的代码被阻止执行。在本食谱中，我们将向您展示一种死代码消除的变体，称为激进死代码消除，它假设每一段代码都是死代码，直到证明其不是为止。我们将看到如何自己实现这个传递，以及我们需要对传递进行哪些修改，以便它可以在LLVM主干的`lib/Transforms/Scalar`文件夹中的其他传递一样运行。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To show the implementation of dead code elimination, we will need a piece of
    test code, on which we will run the aggressive dead code elimination pass:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示死代码消除的实现，我们需要一段测试代码，我们将在这个代码上运行激进死代码消除传递：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this test code, we can see that a call to the `strlen` function is made in
    the `test` function, but the return value is not used. So, this should be treated
    as dead code by our pass.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段测试代码中，我们可以看到在`test`函数中调用了`strlen`函数，但返回值没有被使用。因此，这应该被我们的传递视为死代码。
- en: 'In the file, include the `InitializePasses.h` file, located at `/llvm/`; and
    in the `llvm` namespace, add an entry for the pass that we are going to write:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中，包含位于`/llvm/`的`InitializePasses.h`文件；并在`llvm`命名空间中，添加我们即将编写的传递的条目：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `scalar.h` file, located at `include/llvm-c/scalar.h/Transform/`, add
    the entry for the pass:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`scalar.h`文件中，位于`include/llvm-c/scalar.h/Transform/`，添加传递的条目：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `include/llvm/Transform/scalar.h` file, add the entry for the pass in
    the `llvm` namespace:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`include/llvm/Transform/scalar.h`文件中，在`llvm`命名空间中添加传递的条目：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `lib/Transforms/Scalar/scalar.cpp` file, add the entry for the pass
    in two places. In the `void` `llvm::initializeScalarOpts(PassRegistry` `&Registry)`
    function, add the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在`lib/Transforms/Scalar/scalar.cpp`文件中，在两个地方添加传递的条目。在`void llvm::initializeScalarOpts(PassRegistry
    &Registry)`函数中，添加以下代码：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We will now write the code for the pass:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写传递的代码：
- en: 'Include the necessary header files:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Declare the structure of our pass:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明我们的传递结构：
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Initialize the pass and its ID:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化传递及其ID：
- en: '[PRE7]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement the actual pass in the `runOnFunction` function:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`runOnFunction`函数中实现实际的传递：
- en: '[PRE8]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the preceding pass after compiling the `testcode.ll` file, which can be
    found in the *Getting ready* section of this recipe:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编译`testcode.ll`文件后运行前面的pass，该文件可以在本教程的*准备工作*部分找到：
- en: '[PRE9]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The pass works by first collecting a list of all the root instructions that
    are live in the first `for` loop of the `runOnFunction` function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此pass通过首先在`runOnFunction`函数的第一个`for`循环中收集所有活跃的根指令列表来工作。
- en: Using this information, we move backwards, propagating liveness to the operands
    in the `while` `(!Worklist.empty())` loop.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些信息，我们在`while` `(!Worklist.empty())`循环中向后传播活跃性到操作数。
- en: In the next `for` loop, we remove the instructions that are not live, that is,
    dead. Also, we check whether any reference was made to these values. If so, we
    drop all such references, which are also dead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个`for`循环中，我们移除不活跃的指令，即死代码。同时，我们检查是否对这些值有任何引用。如果有，我们将丢弃所有这样的引用，它们也是死代码。
- en: On running the the pass on the test code, we see the dead code; the call to
    the `strlen` function is removed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试代码上运行此pass后，我们看到死代码；`strlen`函数的调用被移除。
- en: Note that the code has been added to the LLVM trunk revision number 234045\.
    So, when you are actually trying to implement it, some definitions might be updated.
    In this case, modify the code accordingly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码已被添加到LLVM主分支修订号234045中。因此，当您实际尝试实现它时，一些定义可能会更新。在这种情况下，相应地修改代码。
- en: See also
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For various other kinds of dead code elimination method, you can refer to the
    `llvm/lib/Transfroms/Scalar` folder, where the code for other kinds of DCEs is
    present.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他各种死代码消除方法，您可以参考`llvm/lib/Transforms/Scalar`文件夹，其中包含其他类型DCEs的代码。
- en: Writing an inlining transformation pass
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写内联转换pass
- en: As we know, by inlining we mean expanding the function body of the function
    called at the call site, as it may prove useful through faster execution of code.
    The compiler takes the decision whether to inline a function or not. In this recipe,
    you will learn to how to write a simple function-inlining pass that makes use
    of the implementation in LLVM for inlining. We will write a pass that will handle
    the functions marked with the `alwaysinline` attribute.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，内联意味着在调用点展开被调用函数的函数体，因为它可能通过代码的更快执行而变得有用。编译器决定是否内联一个函数。在本教程中，您将学习如何编写一个简单的函数内联pass，该pass利用LLVM的内联实现。我们将编写一个处理带有`alwaysinline`属性的函数的pass。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s write a test code that we will run our pass on. Make the necessary changes
    in the `lib/Transforms/IPO/IPO.cpp` and `include/llvm/InitializePasses.h` files,
    the `include/llvm/Transforms/IPO.h` file, and the `/include/llvm-c/Transforms/IPO.h`
    file to include the following pass. Also make the necessary `makefile` changes
    to include his pass:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个测试代码，我们将在这个测试代码上运行我们的pass。在`lib/Transforms/IPO/IPO.cpp`和`include/llvm/InitializePasses.h`文件、`include/llvm/Transforms/IPO.h`文件以及`/include/llvm-c/Transforms/IPO.h`文件中做出必要的更改，以包含以下pass。还需要对`makefile`进行必要的更改以包含此pass：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How to do it…
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做这件事...
- en: 'We will now write the code for the pass:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写pass的代码：
- en: 'Include the necessary header files:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含必要的头文件：
- en: '[PRE11]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Describe the class for our pass:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述我们的pass的类：
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Initialize the pass and add the dependencies:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化pass并添加依赖项：
- en: '[PRE13]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Implement the function to get the inlining cost:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现获取内联成本的函数：
- en: '[PRE14]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Write the other helper methods:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写其他辅助方法：
- en: '[PRE15]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Compile the pass. After compiling, run it on the preceding test case:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译通过。编译完成后，在先前的测试用例上运行它：
- en: '[PRE16]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This pass that we have written will work for the functions with the `alwaysinline`
    attribute. The pass will always inline such functions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的这个pass将适用于具有`alwaysinline`属性的函数。这个pass将始终内联这些函数。
- en: The main function at work here is `InlineCost` `getInlineCost(CallSite` `CS)`.
    This is a function in the `inliner.cpp` file, which needs to be overridden here.
    So, on the basis of the inlining cost calculated here, we decide whether or not
    to inline a function. The actual implementation, on how the inlining process works,
    is in the `inliner.cpp` file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里工作的主函数是`InlineCost` `getInlineCost(CallSite` `CS`)`。这是一个位于`inliner.cpp`文件中的函数，需要在这里重写。因此，基于这里计算的内联成本，我们决定是否内联一个函数。内联过程的实际实现，即内联过程是如何工作的，可以在`inliner.cpp`文件中找到。
- en: In this case, we return `InlineCost::getAlways()`; for the functions marked
    with the `alwaysinline` attribute. For the others, we return `InlineCost::getNever()`.
    In this way, we can implement inlining for this simple case. If you want to dig
    deeper and try other variations of inlining—and learn how to make decisions about
    inlining—you can check out the `inlining.cpp` file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们返回 `InlineCost::getAlways()`；对于带有 `alwaysinline` 属性的函数。对于其他函数，我们返回
    `InlineCost::getNever()`。这样，我们可以实现这个简单情况的内联。如果你想要深入了解并尝试其他内联变体——以及学习如何做出内联决策——你可以查看
    `inlining.cpp` 文件。
- en: When this pass is run over the test code, we see that the call of the `inner1`
    function is replaced by its actual function body.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个传递在测试代码上运行时，我们看到 `inner1` 函数的调用被其实际函数体所替换。
- en: Writing a pass for memory optimization
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写内存优化传递
- en: In this recipe, we will briefly discuss a transformation pass that deals with
    memory optimization.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将简要讨论一个处理内存优化的转换传递。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need the opt tool installed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你需要安装 opt 工具。
- en: How to do it…
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现它…
- en: 'Write the test code on which we will run the `memcpy` optimization pass:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写我们将运行 `memcpy` 优化传递的测试代码：
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the `memcpyopt` pass on the preceding test case:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的测试用例上运行 `memcpyopt` 传递：
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `Memcpyopt` pass deals with eliminating the `memcpy` calls wherever possible,
    or transforms them into other calls.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Memcpyopt` 传递处理尽可能消除 `memcpy` 调用，或将它们转换为其他调用。'
- en: 'Consider this `memcpy` call:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个 `memcpy` 调用：
- en: '`call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arr_i8, i8* bitcast ([3 x i32]*
    @cst to i8*), i64 12, i32 4, i1 false)`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`call void @llvm.memcpy.p0i8.p0i8.i64(i8* %arr_i8, i8* bitcast ([3 x i32]*
    @cst to i8*), i64 12, i32 4, i1 false)`。'
- en: 'In the preceding test case, this pass converts it into a `memset` call:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试用例中，这个传递将其转换为 `memset` 调用：
- en: '`call void @llvm.memset.p0i8.i64(i8* %arr_i8, i8 -1, i64 12, i32 4, i1 false)`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`call void @llvm.memset.p0i8.i64(i8* %arr_i8, i8 -1, i64 12, i32 4, i1 false)`。'
- en: If we look into the source code of the pass, we realize that this transformation
    is brought about by the `tryMergingIntoMemset` function in the `MemCpyOptimizer.cpp`
    file in `llvm/lib/Transforms/Scalar`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看传递的源代码，我们会意识到这种转换是由 `llvm/lib/Transforms/Scalar` 文件夹中的 `MemCpyOptimizer.cpp`
    文件中的 `tryMergingIntoMemset` 函数引起的。
- en: The `tryMergingIntoMemset` function looks for some other pattern to fold away
    when scanning forward over instructions. It looks for stores in the neighboring
    memory and, on seeing consecutive ones, it attempts to merge them together into
    `memset`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`tryMergingIntoMemset` 函数在扫描指令时会寻找一些其他模式来折叠。它寻找相邻内存中的存储，并在看到连续的存储时，尝试将它们合并到
    `memset` 中。'
- en: The `processMemSet` function looks out for any other neighboring `memset` to
    this `memset`, which helps us widen out the `memset` call to create a single larger
    store.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`processMemSet` 函数会检查这个 `memset` 附近的任何其他相邻的 `memset`，这有助于我们扩展 `memset` 调用来创建一个更大的存储。'
- en: See also
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To see the details of the various types of memory optimization passes, go to
    [http://llvm.org/docs/Passes.html#memcpyopt-memcpy-optimization](http://llvm.org/docs/Passes.html#memcpyopt-memcpy-optimization).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看各种内存优化传递的详细信息，请访问 [http://llvm.org/docs/Passes.html#memcpyopt-memcpy-optimization](http://llvm.org/docs/Passes.html#memcpyopt-memcpy-optimization)。
- en: Combining LLVM IR
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合 LLVM IR
- en: In this recipe, you will learn about instruction combining in LLVM. By instruction
    combining, we mean replacing a sequence of instructions with more efficient instructions
    that produce the same result in fewer machine cycles. In this recipe, we will
    see how we can make modifications in the LLVM code to combine certain instructions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，你将了解 LLVM 中的指令组合。通过指令组合，我们指的是用更有效的指令替换一系列指令，这些指令在更少的机器周期内产生相同的结果。在这个配方中，我们将看到我们如何修改
    LLVM 代码以组合某些指令。
- en: Getting started
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'To test our implementation, we will write test code that we will use to verify
    that our implementation is working properly to combine instructions:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的实现，我们将编写测试代码，我们将使用它来验证我们的实现是否正确地组合了指令：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to do it…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现它…
- en: Open the `lib/Transforms/InstCombine/InstCombineAndOrXor.cpp` file.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `lib/Transforms/InstCombine/InstCombineAndOrXor.cpp` 文件。
- en: 'In the `InstCombiner::visitXor(BinaryOperator` `&I)` function, go to the `if`
    condition—`if` `(Op0I` `&&` `Op1I)`—and add this:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `InstCombiner::visitXor(BinaryOperator &I)` 函数中，进入 `if` 条件——`if `(Op0I &&
    Op1I)`——并添加以下内容：
- en: '[PRE20]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now build LLVM again so that the Opt tool can use the new functionality and
    run the test case in this way:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在重新构建 LLVM，以便 Opt 工具可以使用新功能并按这种方式运行测试用例：
- en: '[PRE21]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we added code to the instruction combining file, which handles
    transformations involving the AND, OR, and XOR operators.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们在指令组合文件中添加了代码，该代码处理涉及AND、OR和XOR运算符的转换。
- en: We added code for matching the pattern of the `(A` `|` `(B` `^` `C))` `^` `((A`
    `^` `C)` `^` `B)` form, and reduced it to `A` `&` `(B` `^` `C)`. The `if (match(Op0I,
    m_Or(m_Xor(m_Value(B), m_Value(C)), m_Value(A))) && match(Op1I, m_Xor( m_Xor(m_Specific(A),
    m_Specific(C)), m_Specific(B))))` line looks out for the pattern similar to the
    one shown at the start of this paragraph.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了匹配`(A` `|` `(B` `^` `C))` `^` `((A` `^` `C)` `^` `B)`形式的代码，并将其简化为`A` `&`
    `(B` `^` `C)`。`if (match(Op0I, m_Or(m_Xor(m_Value(B), m_Value(C)), m_Value(A)))
    && match(Op1I, m_Xor( m_Xor(m_Specific(A), m_Specific(C)), m_Specific(B))))`这一行寻找与段落开头所示模式相似的图案。
- en: The `return` `BinaryOperator::CreateAnd(A,` `Builder->CreateXor(B,C));` line
    returns the reduced value after building a new instruction, replacing the previous
    matched code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`return` `BinaryOperator::CreateAnd(A,` `Builder->CreateXor(B,C));`这一行在构建新指令后返回简化后的值，替换了之前匹配的代码。'
- en: When we run the `instcombine` pass over the test code, we get the reduced result.
    You can see the number of operations is reduced from five to two.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在测试代码上运行`instcombine`优化步骤时，我们得到减少后的结果。你可以看到操作数从五个减少到两个。
- en: See also
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: The topic of instruction combining is very wide, and there are loads and loads
    of possibilities. Similar to the instruction combining function is the instruction
    simplify function, where we simplify complicated instructions but don't necessarily
    reduce the number of instructions, as is the case with instruction combining.
    To look more deeply into this, go through the code in the `lib/Transforms/InstCombine`
    folder
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令组合的主题非常广泛，有大量的可能性。与指令组合功能相似的是指令简化功能，我们在其中简化复杂的指令，但不一定减少指令的数量，就像指令组合那样。要深入了解这一点，请查看`lib/Transforms/InstCombine`文件夹中的代码。
- en: Transforming and optimizing loops
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换和优化循环
- en: In this recipe, we will see how we can transform and optimize loops to get shorter
    execution times. We will mainly be looking into the **Loop-Invariant Code Motion**
    (**LICM**) optimization technique, and see how it works and how it transforms
    the code. We will also look at a relatively simpler technique called **loop deletion**,
    where we eliminate loops with non-infinite, computable trip counts that have no
    side effects on a function's return value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将了解如何转换和优化循环以获得更短的执行时间。我们将主要关注**循环不变代码移动**（**LICM**）优化技术，并了解其工作原理和代码转换方式。我们还将查看一个相对简单的技术，称为**循环删除**，其中我们消除那些具有非无限、可计算的循环次数且对函数返回值没有副作用的无用循环。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You must have the opt tool built for this recipe.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须为这个配方构建opt工具。
- en: How to do it…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Write the test cases for the LICM pass:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为LICM（Loop-Invariant Code Motion）优化步骤编写测试用例：
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Execute the LICM pass on this test code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下测试代码上执行LICM优化步骤：
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Write the test code for the loop deletion pass:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为循环删除优化步骤编写测试代码：
- en: '[PRE24]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, run the loop deletion pass over the test code:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在测试代码上运行循环删除优化步骤：
- en: '[PRE25]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The LICM pass performs loop-invariant code motion; it tries to move the code
    that is not modified in the loop out of the loop. It can go either above the loop
    in the pre-header block, or after the loop exits from the exit block.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: LICM优化步骤执行循环不变代码移动；它试图将循环中未修改的代码移出循环。它可以移动到循环前头的代码块之上，或者从退出块之后退出循环。
- en: In the example shown earlier, we saw the `%i2` `=` `mul` `i32` `%i,` `17` part
    of the code being moved above the loop, as it is not getting modified within the
    loop block shown in that example.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面显示的示例中，我们看到了代码的`%i2` `=` `mul` `i32` `%i,` `17`部分被移动到循环之上，因为它在那个示例中显示的循环块内没有被修改。
- en: The loop deletion pass looks out for loops with non-infinite trip counts that
    have no effect on the return value of the function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 循环删除优化步骤会寻找那些具有非无限循环次数且不影响函数返回值的循环。
- en: In the test code, we saw how both the basic blocks `bb:` and `bb2:`, which have
    the loop part, get deleted. We also saw how the `foo` function directly branches
    to the return statement.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试代码中，我们看到了具有循环部分的两个基本块`bb:`和`bb2:`都被删除了。我们还看到了`foo`函数直接跳转到返回语句。
- en: There are many other techniques for optimizing loops, such as `loop-rotate`,
    `loop-unswitch`, and `loop-unroll`, which you can try yourself. You will then
    see how they affect the code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他优化循环的技术，例如`loop-rotate`、`loop-unswitch`和`loop-unroll`，你可以亲自尝试。然后你会看到它们如何影响代码。
- en: Reassociating expressions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新关联表达式
- en: In this recipe, you will learn about reassociating expressions and how it helps
    in optimization.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将了解重新关联表达式及其在优化中的帮助。
- en: Getting Ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The opt tool should be installed for this recipe to work.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该 opt 工具需要安装才能使本食谱生效。
- en: How to do it…
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Write the test case for a simple reassociate transformation:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为简单的重新关联转换编写测试用例：
- en: '[PRE26]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the reassociate pass on this test case to see how the code is modified:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个测试用例上运行重新关联传递，以查看代码是如何修改的：
- en: '[PRE27]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works …
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的 …
- en: By reassociation, we mean applying algebraic properties such as associativity,
    commutativity, and distributivity to rearrange an expression to enable other optimizations,
    such as constant folding, LICM, and so on.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新关联，我们是指应用代数性质，如结合性、交换性和分配性，来重新排列一个表达式，以便启用其他优化，例如常量折叠、LICM 等。
- en: In the preceding example, we used the inverse property to eliminate patterns
    such as `"X` `+` `~X"` `->` `"-1"` using reassociation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了逆性质来消除像 `"X` `+` `~X"` `->` `"-1"` 这样的模式，通过重新关联来实现。
- en: The first three lines of the test case give us the expression of the form `(b+(a+1234))+~a`.
    In this expression, using the reassociate pass, we transform `a+~a` `to` `-1`.
    Hence, in the result, we get the final return value as `b+1234-1` `=` `b+1233`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例的前三行给出了形式为 `(b+(a+1234))+~a` 的表达式。在这个表达式中，使用重新关联传递，我们将 `a+~a` 转换为 `-1`。因此，在结果中，我们得到最终的返回值是
    `b+1234-1` `=` `b+1233`。
- en: The code that handles this transformation is in the `Reassociate.cpp` file,
    located under `lib/Transforms/Scalar`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种转换的代码位于 `lib/Transforms/Scalar` 下的 `Reassociate.cpp` 文件中。
- en: 'If you look into this file, specifically the code segment, you can see that
    it checks whether there are `a` and `~a` in the operand list:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看此文件，特别是代码段，你可以看到它检查操作数列表中是否有 `a` 和 `~a`：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following code is responsible for handling and inserting the `-1` value
    when it gets such values in the expression:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码负责在表达式中遇到此类值时处理和插入 `-1` 值：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Vectorizing IR
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量化 IR
- en: '**Vectorization** is an important optimization for compilers where we can vectorize
    code to execute an instruction on multiple datasets in one go. If the backend
    architecture supports vector registers, a broad range of data can be loaded into
    those vector registers, and special vector instructions can be executed on the
    registers.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**向量化**是编译器的重要优化，我们可以向量化代码以一次执行多个数据集上的指令。如果后端架构支持向量寄存器，可以加载大量数据到这些向量寄存器中，并在寄存器上执行特殊的向量指令。'
- en: There are two types of vectorization in LLVM—**Superword-Level Parallelism**
    (**SLP**) and **loop vectorization**. Loop vectorization deals with vectorization
    opportunities in a loop, while SLP vectorization deals with vectorizing straight-line
    code in a basic block. In this recipe, we will see how straight-line code is vectorized.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LLVM 中有两种类型的向量化——**超词并行性**（**SLP**）和**循环向量化**。循环向量化处理循环中的向量化机会，而 SLP 向量化处理基本块中的直线代码的向量化。在本食谱中，我们将看到直线代码是如何向量化。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: SLP vectorization constructs a bottom-up tree of the IR expression, and broadly
    compares the nodes of the tree to see whether they are similar and hence can be
    combined to form vectors. The file to be modified is `lib/Transform/Vectorize/SLPVectorizer.cpp`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: SLP 向量化构建 IR 表达式的自下而上的树，并广泛比较树的节点，以查看它们是否相似，从而可以组合成向量。需要修改的文件是 `lib/Transform/Vectorize/SLPVectorizer.cpp`。
- en: We will try to vectorize a piece of straight-line code, such as `return` `a[0]`
    `+` `a[1]` `+` `a[2]` `+` `a[3]`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试向量化一段直线代码，例如 `return` `a[0]` `+` `a[1]` `+` `a[2]` `+` `a[3]`。
- en: The expression tree for the preceding type of code will be a somewhat one-sided
    tree. We will run a DFS to store the operands and the operators.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前一类代码的表达式树将是一个有点单边的树。我们将运行 DFS 来存储操作数和运算符。
- en: 'The IR for the preceding kind of expression will look like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 前一类表达式的 IR 将看起来像这样：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The vectorization model follows three steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 向量化模型遵循三个步骤：
- en: Checking whether it's legal to vectorize.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否可以向量化。
- en: Calculating the profitability of the vectorized code over the scalarized code.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算向量化代码相对于标量代码的盈利能力。
- en: Vectorizing the code if these two conditions are satisfied.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果满足这两个条件，则向量化代码：
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到它...
- en: 'Open the `SLPVectorizer.cpp` file. A new function needs to be implemented for
    DFS traversal of the expression tree for the IR shown in the *Getting ready* section:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `SLPVectorizer.cpp` 文件。需要实现一个新函数，用于对 *准备就绪* 部分中显示的 IR 表达式的表达式树进行 DFS 遍历：
- en: '[PRE31]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Calculate the cost of the resultant vectorized IR and conclude whether it is
    profitable to vectorize. In the `SLPVectorizer.cpp` file, add the following lines
    to the `getReductionCost()` function:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算结果向量化 IR 的成本，并得出是否进行向量化是有利可图的结论。在 `SLPVectorizer.cpp` 文件中，向 `getReductionCost()`
    函数中添加以下行：
- en: '[PRE32]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the same function, after calculating `PairwiseRdxCost` and `SplittingRdxCost`,
    compare them with `HAddCost`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一函数中，在计算 `PairwiseRdxCost` 和 `SplittingRdxCost` 之后，将它们与 `HAddCost` 进行比较：
- en: '[PRE33]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `vectorizeChainsInBlock()` function, call the `matchFlatReduction()`
    function you just defined:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `vectorizeChainsInBlock()` 函数中，调用您刚刚定义的 `matchFlatReduction()` 函数：
- en: '[PRE34]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define two global flags to keep a track of horizontal reduction, which feeds
    into a return:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个全局标志以跟踪水平减少，该减少输入到返回中：
- en: '[PRE35]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Allow the vectorization of small trees if they feed into a return. Add the
    following line to the `isFullyVectorizableTinyTree()` function:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果小树能够返回输入，则允许对它们进行向量化。将以下行添加到 `isFullyVectorizableTinyTree()` 函数中：
- en: '[PRE36]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Compile the LLVM project after saving the file containing the preceding code,
    and run the opt tool on the example IR, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 保存包含上述代码的文件后，编译 LLVM 项目，并在示例 IR 上运行 opt 工具，如下所示：
- en: 'Open the `example.ll` file and paste the following IR in it:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `example.ll` 文件，并将以下 IR 粘贴到其中：
- en: '[PRE37]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the opt tool on `example.ll`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `example.ll` 上运行 opt 工具：
- en: '[PRE38]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output will be vectorized code, like the following:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将是向量化的代码，如下所示：
- en: '[PRE39]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As observed, the code gets vectorized. The `matchFlatReduction()` function performs
    a DFS traversal of the expression and stores all the loads in `ReducedVals`, while
    adds are stored in `ReductionOps`. After this, the cost of horizontal vectorization
    is calculated in `HAddCost` and compared with scalar cost. It turns out to be
    profitable. Hence, it vectorizes the expression. This is handled in the `tryToReduce()`
    function, which is already implemented.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到代码被向量化了。`matchFlatReduction()` 函数对表达式进行深度优先遍历，并将所有加载存储在 `ReducedVals` 中，而加法存储在
    `ReductionOps` 中。之后，在 `HAddCost` 中计算水平向量化的成本，并与标量成本进行比较。结果证明这是有利的。因此，它将表达式向量化。这由
    `tryToReduce()` 函数处理，该函数已经实现。
- en: See also…
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容……
- en: For detailed vectorization concepts, refer to the paper *Loop-Aware SLP in GCC*
    by Ira Rosen, Dorit Nuzman, and Ayal Zaks
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于详细的向量化概念，请参阅 Ira Rosen、Dorit Nuzman 和 Ayal Zaks 撰写的论文 *GCC 中的循环感知 SLP*。
- en: Other optimization passes
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他优化过程
- en: In this recipe, we will look at some more transformational passes, which are
    more like of utility passes. We will look at the `strip-debug-symbols` pass and
    the `prune-eh` pass.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看一些更多的转换过程，这些过程更像是工具过程。我们将查看 `strip-debug-symbols` 过程和 `prune-eh`
    过程。
- en: Getting ready…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作……
- en: The opt tool must be installed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 必须安装 opt 工具。
- en: How to do it…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Write a test case for checking the strip-debug pass, which strips off the debug
    symbols from the test code:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试用例来检查 strip-debug 过程，该过程从测试代码中删除调试符号：
- en: '[PRE40]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run the `strip-debug-symbols` pass by passing the `–strip-debug` command-line
    option to the `opt` tool:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `–strip-debug` 命令行选项传递给 `opt` 工具来运行 `strip-debug-symbols` 过程：
- en: '[PRE41]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Write a test case for checking the `prune-eh` pass:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试用例来检查 `prune-eh` 过程：
- en: '[PRE42]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Run the pass to remove unused exception information by passing the `–prune-eh`
    command-line option to the opt tool:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `–prune-eh` 命令行选项传递给 opt 工具来运行该过程，以删除未使用的异常信息：
- en: '[PRE43]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In the first case, where we are running the `strip-debug` pass, it removes the
    debug information from the code, and we can get compact code. This pass must be
    used only when we are looking for compact code, as it can delete the names of
    virtual registers and the symbols for internal global variables and functions,
    thus making the source code less readable and making it difficult to reverse engineer
    the code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，当我们运行 `strip-debug` 过程时，它会从代码中删除调试信息，我们可以得到紧凑的代码。此过程仅在寻找紧凑代码时必须使用，因为它可以删除虚拟寄存器的名称以及内部全局变量和函数的符号，从而使源代码更难以阅读，并使代码逆向工程变得困难。
- en: The part of code that handles this transformation is located in the `llvm/lib/Transforms/IPO/StripSymbols.cpp`
    file, where the `StripDeadDebugInfo::runOnModule` function is responsible for
    stripping the debug information.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 处理此转换的代码部分位于 `llvm/lib/Transforms/IPO/StripSymbols.cpp` 文件中，其中 `StripDeadDebugInfo::runOnModule`
    函数负责删除调试信息。
- en: The second test is for removing unused exception information using the `prune-eh`
    pass, which implements an interprocedural pass. This walks the call-graph, turning
    invoke instructions into call instructions only if the callee cannot throw an
    exception, and marking functions as `nounwind` if they cannot throw the exceptions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试是使用`prune-eh`过程来移除未使用的异常信息，该过程实现了一个跨过程过程。它会遍历调用图，只有当被调用者不能抛出异常时，才将调用指令转换为调用指令，并且如果函数不能抛出异常，则将其标记为`nounwind`。
- en: See also
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to [http://llvm.org/docs/Passes.html#transform-passes](http://llvm.org/docs/Passes.html#transform-passes)
    for other transformation passes
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考以下链接了解其他转换过程：[http://llvm.org/docs/Passes.html#transform-passes](http://llvm.org/docs/Passes.html#transform-passes)
