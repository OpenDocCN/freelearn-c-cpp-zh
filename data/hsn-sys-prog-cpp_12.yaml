- en: Learning to Program POSIX and C++ Threads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习编程 POSIX 和 C++ 线程
- en: In this chapter, the reader will learn how to program both POSIX and C++ threads.
    We will start by discussing how to program with POSIX threads, and then move on
    to C++ threads, providing a comparison of the APIs for each one.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者将学习如何编程使用 POSIX 和 C++ 线程。我们将首先讨论如何使用 POSIX 线程编程，然后转向 C++ 线程，提供每个 API
    的比较。
- en: Then we will present three examples. The first will demonstrate how to use threading
    to perform a parallel computation. The second will demonstrate how to create your
    own high-resolution timer using threading in order to perform benchmarking (albeit
    a timer that is likely not very accurate).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将呈现三个示例。第一个示例将演示如何使用线程执行并行计算。第二个示例将演示如何使用线程创建自己的高分辨率计时器以进行基准测试（尽管该计时器可能不太准确）。
- en: The third and final example will build upon our existing debugging example to
    provide support for multiple clients.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个和最后一个示例将在现有的调试示例基础上构建，以提供对多个客户端的支持。
- en: It should be noted that this chapter assumes the reader already has a basic
    understanding of threading, thread synchronization, and the challenges associated
    with race conditions and deadlock. Here, we will only focus on the APIs provided
    by POSIX and C++ for working with threads.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，本章假定读者已经基本了解线程、线程同步以及与竞争条件和死锁相关的挑战。在这里，我们将只关注 POSIX 和 C++ 提供的用于处理线程的 API。
- en: 'The chapter will cover the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: POSIX threads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX 线程
- en: C++ threads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 线程
- en: Parallel computation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行计算
- en: Benchmarking with threads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程进行基准测试
- en: Thread logging
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程日志记录
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to follow the examples in this chapter, the reader must have the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵循本章的示例，读者必须具备以下知识：
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够编译和执行 C++17 的基于 Linux 的系统（例如，Ubuntu 17.10+）
- en: GCC 7+
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 7+
- en: CMake 3.6+
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.6+
- en: An internet connection
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: To download all the code in this chapter, including the examples and code snippets,
    go to the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter12).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载本章中的所有代码，包括示例和代码片段，请转到以下链接：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter12)。
- en: Understanding POSIX threads
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 POSIX 线程
- en: 'A thread is similar to a process, with the main distinctions being the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 线程类似于进程，主要区别如下：
- en: Threads are contained within processes
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程包含在进程内
- en: Threads inherently share a memory space with other threads of the same process,
    while processes do not share resources unless explicitly told to (using inter-process
    communication mechanisms)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程本质上与同一进程的其他线程共享内存空间，而进程不共享资源，除非明确告知（使用进程间通信机制）。
- en: Like processes, however, threads are scheduled for execution at any time by
    the operating system. This may mean executing in parallel with other threads,
    leading to performance optimizations if properly used, but at the expense of introducing
    threading-specific logic bugs, such as race conditions and deadlock.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与进程一样，线程也可以被操作系统随时调度执行。如果正确使用，这可能意味着与其他线程并行执行，从而导致性能优化，但代价是引入特定于线程的逻辑错误，如竞争条件和死锁。
- en: The goal of this section is to briefly review POSIX threads. These largely influenced
    the design of C++ threads, which will be discussed later.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是简要回顾 POSIX 线程。这些在很大程度上影响了 C++ 线程的设计，稍后将进行讨论。
- en: The basics of POSIX threads
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POSIX 线程的基础知识
- en: 'The most basic use of a thread is to create it, and then join the thread, which,
    in effect, waits for the thread to finish its work before returning as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的最基本用法是创建它，然后加入线程，这实际上是在线程完成工作之前等待线程完成。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, a `mythread()` function is created with the signature
    `(void *)(*)(void *)`, which is required by POSIX threads. In this example, the
    thread simply outputs to `stdout` and returns.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，创建了一个具有 `(void *)(*)(void *)` 签名的 `mythread()` 函数，这是 POSIX 线程所需的。在此示例中，线程只是简单地输出到
    `stdout` 并返回。
- en: 'In the `main()` function, two threads are created using the `pthread_create()`
    function, which takes the following form:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，使用 `pthread_create()` 函数创建了两个线程，其形式如下：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, a `pthread_t` type is created and passed to the first argument.
    The attribute argument is ignored using a `nullptr`, and so is the argument to
    the thread itself (since it is not used). The only other thing we provide the
    `pthread_create` with function is the thread itself, which is a function pointer
    to our `mythread()` function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，创建了一个 `pthread_t` 类型，并传递给第一个参数。使用 `nullptr` 忽略了属性参数，线程本身的参数也是如此（因为它没有被使用）。我们向
    `pthread_create` 函数提供的唯一其他内容是线程本身，它是指向我们的 `mythread()` 函数的函数指针。
- en: 'To wait for the thread to complete, we use the `pthread_join()` function, which
    takes the following form:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要等待线程完成，我们使用 `pthread_join()` 函数，其形式如下：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previously-created `pthread` is provided as the first argument to this function,
    while the return value of the `pthread` is ignored using a `nullptr` (since the
    thread doesn't return a value).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 先前创建的 `pthread` 作为此函数的第一个参数提供，而 `pthread` 的返回值使用 `nullptr` 忽略（因为线程不返回值）。
- en: The result of this example is that `Hello World` is output to `stdout` twice
    (since two threads are created).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的结果是“Hello World”被输出到“stdout”两次（因为创建了两个线程）。
- en: 'It should be noted that there are several issues with this example, which we
    will only briefly address in this chapter (as entire books can be written on the
    topic of parallel computing):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，此示例存在几个问题，我们将在本章中简要讨论（因为整本书都可以写关于并行计算的主题）：
- en: '**Type safety**: Both the argument to the thread and its return value are passed
    as a `void *`, completely removing any and all forms of type safety with respect
    to the thread itself. As a result, the `pthread` interface is not C++ Core Guideline
    compliant, and encourages the creation of hard-to-find logic errors. As will be
    demonstrated, C++ largely addresses these issues, albeit using an interface ,
    which, at times, might seem difficult to follow.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型安全**：线程的参数和返回值都作为`void *`传递，完全消除了与线程本身相关的任何形式的类型安全。因此，`pthread`接口不符合C++核心指南，并鼓励创建难以发现的逻辑错误。正如将要演示的，C++在很大程度上解决了这些问题，尽管有时可能难以遵循接口。'
- en: '**Race conditions**: The preceding example does not attempt to address the
    possible race conditions of both threads outputting to `stdout` at the same time.
    As a result, if this example is executed enough times, it is likely that corruption
    with respect to its output would result.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞争条件**：前面的例子并没有尝试解决两个线程同时输出到`stdout`可能出现的竞争条件。因此，如果这个例子被执行足够多次，很可能会导致输出方面的损坏。'
- en: '**No input/output**: Often, threads operate on globally-defined data without
    the need for input or output, but it is entirely possible that input and/or output
    may be needed in a different situation. This example doesn''t address how to accomplish
    this.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有输入/输出**：通常，线程在不需要输入或输出的情况下操作全局定义的数据，但完全有可能在不同的情况下需要输入和/或输出。这个例子没有解决如何实现这一点。'
- en: Threads are implemented differently depending on the operating system, and cross-platform
    software needs to take this into account. Some operating systems implement threads
    as separate processes, while others implement threads as separate, scheduleable
    tasks within a process.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的实现方式因操作系统而异，跨平台软件需要考虑这一点。一些操作系统将线程实现为单独的进程，而另一些将线程实现为进程内的单独的可调度任务。
- en: Either way, the POSIX specification dictates that a thread be identifiable,
    regardless of the underlying implementation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，POSIX规范规定线程是可识别的，而不管底层实现如何。
- en: 'To identify a thread, the following may be used:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别线程，可以使用以下方法：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding example is identical to the first, with the exception that, instead
    of outputting `Hello World` to `stdout`, we use the `pthread_self()` function
    to output the thread''s identifier. The `pthread_self()` function takes the following
    form:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子与第一个例子相同，唯一的区别是，我们使用`pthread_self（）`函数而不是将`Hello World`输出到`stdout`来输出线程的标识符。`pthread_self（）`函数采用以下形式：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since the `pthread_t` type is usually implemented using an integer type, in
    our preceding example, we can output the value of this type to `stdout` using
    `std::cout`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pthread_t`类型通常使用整数类型实现，在我们前面的例子中，我们可以使用`std::cout`将这种类型的值输出到`stdout`。
- en: 'To provide support for input and output, the `pthread` API provides a `void
    *` for both the input and the output of the thread function. The following example
    demonstrates how to do this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持输入和输出，`pthread` API为线程函数的输入和输出都提供了`void *`。以下示例演示了如何做到这一点：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, the thread function assumes the parameter it is passed is a
    pointer to an integer. It takes the value provided, increments it, and then returns
    it back to the caller (which, in this case, is the `main()` function).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，线程函数假设它传递的参数是一个整数的指针。它获取提供的值，递增它，然后将其返回给调用者（在这种情况下是`main（）`函数）。
- en: In the `main()` function, we create both an input and an output value, with
    the input being initialized to `42`. A pointer to the input value is provided
    during the creation of the thread, and a pointer to the output value is provided
    while joining the threads.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main（）`函数中，我们创建了一个输入值和一个输出值，其中输入被初始化为`42`。在线程创建时提供了指向输入值的指针，并在加入线程时提供了指向输出值的指针。
- en: Finally, the resulting value is output to `stdout`. This is `44`, since two
    threads were created, each of which increments the provided input once.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，结果值被输出到`stdout`。这是`44`，因为创建了两个线程，每个线程递增了提供的输入一次。
- en: Since both threads are operating on the same integer, it is possible that a
    race condition could corrupt the results of these threads if they happen to execute
    at the same time; a problem that will be addressed later on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个线程都在同一个整数上操作，如果它们恰好同时执行，可能会出现竞争条件，这可能会破坏这些线程的结果；这个问题将在以后解决。
- en: Yielding
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产量
- en: One advantage to using threads is that they can execute for a very long time
    without preventing the execution of your main thread/application. The downside
    is that threads that execute without an end can end up consuming too much CPU.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程的一个优点是它们可以长时间执行而不会阻止主线程/应用程序的执行。缺点是，没有结束的线程可能会消耗太多的CPU。
- en: 'For example, consider the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, we create a thread that uses a `while(true)` statement,
    which executes as fast as possible, forever. Such a thread would execute until
    the operating system decided to preempt the thread to schedule another thread
    or process, resulting in the output of the thread occurring in a blocked, almost
    serial fashion.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个使用`while(true)`语句的线程，它尽可能快地永远执行。这样的线程将执行，直到操作系统决定抢占线程以调度另一个线程或进程，导致线程的输出以阻塞的几乎串行的方式发生。
- en: 'In some cases, however, the user might need the thread to perform an action
    and then release its access to the CPU to allow another thread to perform its
    task. To accomplish this, we use the `pthread_yield()` API, which takes the following
    form:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，用户可能需要线程执行一个动作，然后释放其对CPU的访问权，以允许另一个线程执行其任务。为了实现这一点，我们使用`pthread_yield（）`API，它采用以下形式：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, the use of the `yield` function provides each thread
    with an opportunity to execute, resulting in a better-shuffled output of `thread
    1` and `thread 2`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，使用`yield`函数为每个线程提供了执行的机会，导致`线程1`和`线程2`的输出更好地混合在一起。
- en: Although this function is provided, it should be noted that the operating system
    is excellent at handling threads that must perform a lot of work, and `pthread_yield()`
    should only be used when the user explicitly understands how it might provide
    optimization in their specific use case (since overuse of the `pthread_yield()`
    function can actually result in performance degradation).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管提供了这个函数，但应该注意操作系统在处理必须执行大量工作的线程时非常出色，`pthread_yield()`只有在用户明确了解它如何在特定用例中提供优化时才应该使用（因为过度使用`pthread_yield()`函数实际上可能会导致性能下降）。
- en: It should also be noted that `pthread_yield()` is not available on all Unix
    systems.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该注意到`pthread_yield()`并不是所有Unix系统都可用。
- en: 'In addition to `pthread_yield()`, the POSIX API also provides functions to
    put a thread to sleep if there is nothing to do (resulting in better performance
    and battery life), as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`pthread_yield()`，POSIX API还提供了一些函数，如果没有要执行的任务，可以使线程休眠（从而提高性能和电池寿命），如下所示：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, we create a thread that outputs `Hello World` once
    a second by creating a single thread that outputs to `stdout`, and then uses the
    `sleep()` function to put the thread to sleep for a second.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个线程，每秒输出一次“Hello World”，方法是创建一个输出到`stdout`的单个线程，然后使用`sleep()`函数使线程休眠一秒钟。
- en: It should be noted that the use of `sleep()` should be handled with care, as
    it is possible for the operating system to race the `sleep()` call by yielding
    before `sleep()` is called.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，对`sleep()`的使用应该谨慎，因为操作系统可能在调用`sleep()`之前就已经执行了`sleep()`调用。
- en: Synchronization
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步
- en: Race conditions are a common problem when using threads, and solving race conditions
    without introducing deadlock (a thread that can no longer execute due to logic
    bugs with thread synchronization logic) is a complicated topic deserving of its
    own book.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件在使用线程时是一个常见问题，解决竞争条件而不引入死锁（由于线程同步逻辑的逻辑错误而无法执行的线程）是一个复杂的主题，值得有专门的书籍来讨论。
- en: 'The following example attempts to demonstrate the issues with potential race
    conditions:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例试图演示潜在竞争条件的问题：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To produce a race condition, we must execute threads fast enough, and for long
    enough (especially on modern hardware), that one thread performs an operation
    on a shared resource when another thread is in the middle of completing its own
    operation on that same shared resource.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要产生竞争条件，我们必须以足够快的速度执行线程，并且足够长的时间（特别是在现代硬件上），以便一个线程在另一个线程在同一共享资源上执行操作时，另一个线程正在完成自己对该共享资源的操作。
- en: There are many, many ways to do this. In the case of the preceding example,
    we have a thread that increments a counter, and then we create `8000` of these
    threads, increasing the chance that a race condition might occur. At some point
    during execution, two threads read the current value of the counter at the exact
    same time, incrementing the value and storing the incremented value at the same
    time. This results in the counter only being incremented once, even though two
    threads were executing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种方法可以做到这一点。在前面的示例中，我们有一个递增计数器的线程，然后我们创建了`8000`个这样的线程，增加了竞争条件发生的机会。在执行过程中的某个时刻，两个线程同时读取计数器的当前值，增加该值并同时存储增加后的值。这导致计数器只增加了一次，尽管有两个线程在执行。
- en: As a result, and as can be seen from the output of the example, the count in
    some cases is less than `8000`. In these cases, race conditions occurred, resulting
    in corruption.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从示例的输出中可以看出，在某些情况下，计数小于`8000`。在这些情况下，发生了竞争条件，导致了数据损坏。
- en: 'To solve this issue, we must protect the critical region, which, in this case,
    is the part of the thread that uses the shared resource. The following example
    demonstrates one way to do this using a mutex (which ensures mutual exclusion
    to a critical region):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们必须保护关键区域，这在这种情况下是使用共享资源的线程部分。以下示例演示了使用互斥锁（确保对关键区域的互斥访问）的一种方法：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, we wrap the critical region with a mutex. A mutex
    leverages atomic operations (operations that are guaranteed by hardware to manipulate
    a shared resource without corruption) to gain access to a critical region, one
    thread at a time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们用互斥锁包装了关键区域。互斥锁利用原子操作（由硬件保证的操作，可以在不损坏的情况下操作共享资源）来一次让一个线程访问关键区域。
- en: If a thread attempts to gain access to a critical region while another thread
    is actively using the region, it waits until the thread is complete. Once the
    thread is complete, all the waiting threads race to get access to the critical
    region, and the thread that wins gets access while the remaining threads continue
    to wait. (Each operating system has its own way of implementing this to prevent
    the possibility of starvation; another topic that is beyond of scope of this book.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个线程在另一个线程正在使用关键区域时尝试访问关键区域，它将等待直到该线程完成。一旦线程完成，所有等待的线程都会竞争访问关键区域，获胜的线程获得访问权限，而其余线程继续等待。（每个操作系统都有自己的实现方式，以防止饥饿的可能性；这是本书范围之外的另一个主题。）
- en: As can be seen from the output of the preceding example, the use of a mutex
    around the critical region (in this case, the incrementing of the `count` variable)
    prevents the possibility of a race condition, resulting in `8000` being output
    every time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面示例的输出中可以看出，使用互斥锁包围关键区域（在这种情况下是递增`count`变量）可以防止竞争条件的发生，每次输出都是`8000`。
- en: The problem with mutexes is that each time the mutex is locked, a thread must
    wait until it is unlocked before it can continue. This is what protects the critical
    region from other threads, but it results in deadlock if the same thread attempts
    to lock the same mutex more than once (for example, when using recursion), or
    if mutexes are locked in the wrong order.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁的问题在于每次锁定互斥锁时，线程必须等待直到解锁才能继续。这样可以保护关键区域免受其他线程的干扰，但如果同一线程尝试多次锁定同一互斥锁（例如在使用递归时），或者以错误的顺序锁定互斥锁，就会导致死锁。
- en: 'To overcome this problem, the POSIX API provides the ability to turn a mutex
    into a recursive mutex, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，POSIX API提供了将互斥锁转换为递归互斥锁的能力，如下所示：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, we are able to lock the mutex more than once without
    causing a deadlock by first setting the mutex to recursive mode using a mutex
    attribute. It should be noted that this additional flexibility typically comes
    with additional overhead.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们能够多次锁定互斥锁，而不会因此造成死锁，首先使用互斥锁属性将互斥锁设置为递归模式。应该注意，这种额外的灵活性通常伴随着额外的开销。
- en: The last POSIX API we will discuss in this chapter is the condition variable.
    As was demonstrated previously, a mutex may be used to synchronize access to critical
    regions of code. Another form of thread synchronization is to ensure threads execute
    in the proper order, which is what condition variables allow.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章讨论的最后一个POSIX API是条件变量。正如之前所演示的，互斥锁可以用来同步对代码的关键区域的访问。线程同步的另一种形式是确保线程按正确的顺序执行，这就是条件变量所允许的。
- en: 'In the following example, threads 1 and 2 may execute at any time:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，线程1和2可以随时执行：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we create two threads, each outputting to `stdout` in a critical
    region that is guarded using a mutex. The rest of the example is the same as with
    previous examples in this chapter. As shown, `thread 2` is executed first, and
    then `thread 1` (this is largely due to `thread 2` being created first). However,
    there is still the possibility that `thread 1` could have executed first, as there
    is nothing controlling the order in which threads execute.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了两个线程，每个线程都在使用互斥锁保护的关键区域中输出到`stdout`。示例的其余部分与本章中之前的示例相同。如所示，`线程2`首先执行，然后是`线程1`（这主要是因为`线程2`先创建）。然而，仍然有可能`线程1`先执行，因为没有控制线程执行顺序的东西。
- en: 'To solve this, the POSIX API provides a condition variable that may be used
    to synchronize the order of threads, as shown here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，POSIX API提供了一个条件变量，可以用来同步线程的顺序，如下所示：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see, `thread 1` executes first, and then `thread 2`, even though
    `thread 2` was created first. To accomplish this, we use the `pthread_cond_wait()`
    and `pthread_cond_signal()` functions, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`线程1`首先执行，然后是`线程2`，尽管`线程2`是先创建的。为了实现这一点，我们使用`pthread_cond_wait()`和`pthread_cond_signal()`函数，如下所示：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `pthread_cond_wait()` function takes a pointer to a condition variable,
    and a mutex. When it is executed, it unlocks the mutex and waits for a call to `pthread_cond_signal()`
    to be executed. Once the signal is sent, `pthread_cond_wait()` locks the mutex
    again and continues execution.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`pthread_cond_wait()`函数接受一个指向条件变量和互斥锁的指针。当它被执行时，它会解锁互斥锁并等待`pthread_cond_signal()`的调用。一旦发送了信号，`pthread_cond_wait()`再次锁定互斥锁并继续执行。'
- en: The use of the `predicate` variable, which is also guarded by the mutex, is
    used to ensure that any spurious wake-ups are handled. Specifically, it is possible
    for the `pthread_cond_wait()` function to wake up even though the condition variable
    has not yet been signaled. As a result, you must always pair the `pthread_cond_wait()`
    function with a `predicate`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`predicate`变量，它也受到互斥锁的保护，用于确保处理任何虚假唤醒。具体来说，`pthread_cond_wait()`函数可能会在条件变量尚未被发出信号的情况下唤醒。因此，您必须始终将`pthread_cond_wait()`函数与`predicate`配对使用。
- en: Exploring C++ threads
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索C++线程
- en: In the previous section, we learned how POSIX provides support for threads.
    In this section, we will discuss C++ threads, which are largely inspired by POSIX
    threads. They provide similar functionality while simplifying the APIs in some
    ways, and also providing type safety.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们学习了POSIX如何支持线程。在本节中，我们将讨论C++线程，它们在很大程度上受到了POSIX线程的启发。它们提供了类似的功能，同时在某些方面简化了API，并提供了类型安全性。
- en: The basics of C++ threads
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++线程的基础知识
- en: 'To demonstrate the simplicity of C++ threads, the following example, like the
    first example in this chapter, creates two threads and then waits for them to
    finish executing:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示C++线程的简单性，下面的例子，就像本章中的第一个例子一样，创建了两个线程，然后等待它们执行完毕：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are some notable differences compared to the POSIX version of this example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与此示例的POSIX版本相比，有一些显著的区别：
- en: The thread function itself may take on a number of different function signatures,
    and is not limited to `(void *)(*)(void *)`. In this example, the thread function
    uses the `void(*)()` signature.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程函数本身可能具有多种不同的函数签名，并不限于`(void *)(*)(void *)`。在这个例子中，线程函数使用了`void(*)()`签名。
- en: The constructor of the thread type also creates the thread (no need to define
    the type, and then explicitly create the thread later).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程类型的构造函数也创建了线程（无需定义类型，然后显式创建线程）。
- en: It should be noted that in Linux, the `pthread` library still needs to be linked
    to the example. This is because, under the hood, C++ is using `pthread` instances
    to provide thread support.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，在Linux中，仍然需要将`pthread`库链接到示例中。这是因为在底层，C++使用`pthread`实例来提供线程支持。
- en: 'Like the POSIX version, C++ also provides the ability to get the thread ID,
    as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与POSIX版本相似，C++也提供了获取线程ID的能力，如下所示：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, we use both the `this_thread` namespace and the thread
    itself to get the ID, demonstrating that there are two different ways to query
    a thread's ID (depending on the point of view of the caller).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们同时使用了`this_thread`命名空间和线程本身来获取ID，演示了查询线程ID的两种不同方式（取决于调用者的观点）。
- en: The input and output of C++ threads is a good example of how C++ threading,
    in some ways, is more complicated than POSIX threading. As was stated, the biggest
    issue with POSIX threads with respect to input and output is a clear lack of type
    safety.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: C++线程的输入和输出是C++线程在某些方面比POSIX线程更复杂的一个很好的例子。正如所述，关于输入和输出，POSIX线程最大的问题是明显缺乏类型安全性。
- en: To solve this, C++ provides a concept called C++ futures, which, by itself,
    probably deserves its own chapter. We will describe them here briefly, to give
    the reader some general knowledge of how they work.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，C++提供了一个叫做C++ futures的概念，它本身可能值得有自己的章节。我们将在这里简要描述它们，以便让读者对它们的工作原理有一些一般性的了解。
- en: 'In the following example, we create a `mythread()` function that has the signature
    `int(*)(int)`, which takes a value, adds one, and returns the result (very similar
    to the preceding POSIX example of input and output):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们创建了一个`mythread()`函数，它的签名是`int(*)(int)`，它接受一个值，加一，然后返回结果（与前面的POSIX例子的输入和输出非常相似）：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With C++ futures, we need to first tell C++ the signature type of our thread
    to ensure type safety. To accomplish this in our example (there are many ways
    to leverage the future's APIs, this is simply one of them), we create a `std::packaged_task{}`
    and provide it with our thread function signature.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C++ futures，我们需要首先告诉C++我们的线程的签名类型，以确保类型安全。为了在我们的例子中实现这一点（利用future的API有很多种方式，这只是其中一种），我们创建了一个`std::packaged_task{}`，并为它提供了我们的线程函数签名。
- en: This does a couple of things. First, it tells the APIs which thread to call,
    and, in addition, it sets storage aside for the result of the thread that can
    be retrieved later using `std::future{}`. Once `std::packaged_task{}` is created,
    we get the `std::future{}` from `packaged_task{}` using the `get_future()` function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这做了一些事情。首先，它告诉API调用哪个线程，另外，它为线程的结果设置了存储，以便稍后使用`std::future{}`检索。一旦创建了`std::packaged_task{}`，我们就可以使用`get_future()`函数从`packaged_task{}`中获取`std::future{}`。
- en: Finally, we start the thread by creating a thread object and passing it the `std::packaged_task{}`
    object  created previously.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过创建一个线程对象并将之前创建的`std::packaged_task{}`对象传递给它来启动线程。
- en: We can provide the thread with its initial input in the constructor of the thread,
    which takes all of the arguments of the thread as additional, template-based arguments.
    To retrieve the result of the thread, we use `get()` from the future, which is
    valid once the thread has completed and been joined (hence the name *future*).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在线程的构造函数中为线程提供初始输入，将所有的线程参数作为额外的基于模板的参数。要检索线程的结果，我们使用来自future的`get()`，这在线程完成并加入后是有效的（因此称为*future*）。
- en: Although futures are, in some ways, more complicated than simply passing a `void
    *` around, the interface is elegant, allowing for threads to take on any desired
    signature type while also providing type safety. (No `reinterpret_casts()` were
    needed to provide this example, ensuring Core Guideline Compliance and reducing
    the likelihood of hard-to-find logic bugs.)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管futures在某些方面比简单地传递`void *`更复杂，但接口是优雅的，允许线程采用任何所需的签名类型，同时也提供类型安全。（在这个例子中不需要`reinterpret_casts()`，确保了核心指导方针的合规性，减少了难以发现的逻辑错误的可能性。）
- en: Yielding
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让出
- en: 'Similar to POSIX threads, C++ threads provide the ability to yield a thread,
    relinquishing the CPU so that other threads that need to perform their tasks may
    do so. This is expressed as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与POSIX线程类似，C++线程提供了让出线程的能力，让出CPU，以便其他需要执行任务的线程可以这样做。表达如下：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, we leverage the `yield()` function provided by the
    `this_thread` namespace, which yields the calling thread. As a result, it is better
    capable of shuffling the output of the thread between the two threads, as previously
    demonstrated.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们利用了`this_thread`命名空间提供的`yield()`函数，它让出调用线程。因此，它更能够在两个线程之间重新排列线程的输出，正如之前所演示的那样。
- en: 'In addition to yielding, a thread might need to stop its execution for a given
    amount of time. Similar to `sleep()` in POSIX, C++ provides the ability to sleep
    the currently executing thread. The difference with C++ is that a more granular
    API is provided, allowing the user to easily decide which type of granularity
    they prefer (including nanosecond and second resolutions), as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了让出，线程可能需要停止执行一段时间。类似于POSIX中的`sleep()`，C++提供了让当前执行线程休眠的能力。C++的不同之处在于提供了更精细的API，允许用户轻松地决定他们喜欢哪种类型的粒度（包括纳秒和秒的分辨率），如下所示：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, we create a thread that outputs `Hello World` to `stdout`.
    Just prior to outputting to `stdout`, the thread sleeps for a second by calling
    the `sleep_for()` provided by the `this_thread` namespace, and using the second
    literal to define `1` second, resulting in `Hello World` being output to `stdout`
    each second.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个线程，将`Hello World`输出到`stdout`。在输出到`stdout`之前，线程通过调用`this_thread`命名空间提供的`sleep_for()`来休眠一秒，并使用秒字面量来定义`1`秒，结果是每秒将`Hello
    World`输出到`stdout`。
- en: Synchronization
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步
- en: 'Another notable difference between POSIX threads and C++ threads is the simplicity
    of thread synchronization. Like the POSIX APIs, C++ provides the ability to create
    a mutex, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX线程和C++线程之间的另一个显著区别是线程同步的简单性。与POSIX API类似，C++提供了创建互斥锁的能力，如下所示：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, we create a thread that increments a shared counter,
    which is surrounded by a C++ `std::mutex{}`, in effect creating a guarded critical
    region. We then create two threads, wait for them to complete, and then output
    the result to `stdout`, which ends up being `2` as we executed two threads.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个线程，它会增加一个共享的计数器，这个计数器被C++的`std::mutex{}`包围，实际上创建了一个受保护的临界区。然后我们创建了两个线程，等待它们完成，然后将结果输出到`stdout`，结果是`2`，因为我们执行了两个线程。
- en: 'The problem with POSIX threads and the preceding C++ example is seen when a
    thread has to leave a critical region in more than one place, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX线程和前面的C++例子的问题在于当一个线程不得不在多个地方离开临界区时，会出现问题：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, the critical region is exited in more than one place,
    and, as a result, the mutex must be unlocked in multiple places to prevent deadlock.
    Although this seems a simple example, an uncountable number of deadlock bugs have
    resulted from simply forgetting to unlock a mutex before returning from a critical
    region.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，临界区在多个地方退出，因此必须在多个地方解锁互斥锁，以防止死锁。尽管这似乎是一个简单的例子，但由于简单地忘记在从临界区返回之前解锁互斥锁，导致了无数的死锁错误。
- en: 'To prevent this problem, C++ provides `std::lock_guard{}`, which provides a
    simple mechanism for unlocking a mutex using **Resource Acquisition Is Initialization**
    (**RAII**) as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这个问题，C++提供了`std::lock_guard{}`，它提供了一个使用**资源获取即初始化**（**RAII**）的简单机制来解锁互斥锁。
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, we create an RAII-based lock guard in the thread instead
    of manually locking and unlocking the mutex. As a result, in this example, the
    entire thread is in the critical region as the mutex is locked when the guard
    is created and unlocked when the lock goes out of scope (that is, when the thread
    returns).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们在线程中创建了一个基于RAII的锁保护，而不是手动锁定和解锁互斥锁。因此，在这个例子中，整个线程都处于临界区，因为当创建保护时互斥锁被锁定，当锁超出范围时（即线程返回时）被解锁。
- en: As demonstrated in the preceding example, it's impossible to accidentally forget
    to unlock the mutex, as unlocking the mutex is handled for us by the lock guard.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在之前的例子中所演示的，不可能意外忘记解锁互斥锁，因为解锁互斥锁是由锁保护处理的。
- en: 'In some cases, the user might wish the thread to perform other useful work
    while waiting to gain access to a critical region. To accomplish this, `std::mutex{}`
    provides `try_lock()` as an alternative to `lock()`, which returns `false` if
    the lock could not be acquired:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，用户可能希望线程在等待访问临界区时执行其他有用的工作。为了实现这一点，`std::mutex{}`提供了`try_lock()`作为`lock()`的替代方法，如果无法获得锁，则返回`false`。
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding example, we continue to try to lock the mutex in an endless
    `while` loop. We could, however, perform some additional work if `try_lock()`
    returns `false`, or we could sleep for a given amount of time before trying again,
    thereby reducing stress on the operating system and battery.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们继续在无限的`while`循环中尝试锁定互斥锁。然而，如果`try_lock()`返回`false`，我们可以执行一些额外的工作，或者在再次尝试之前睡眠一段时间，从而减轻操作系统和电池的压力。
- en: 'If you wish to use `try_lock` with a lock guard to prevent the need to manually
    unlock the mutex, you may do so using the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望使用`try_lock`与锁保护一起，以防止手动解锁互斥锁的需要，可以使用以下方法：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, we introduce two new features of C++ threads. The first is
    `std::unique_lock{}`, which is similar to `std::lock_guard{}`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们介绍了C++线程的两个新特性。第一个是`std::unique_lock{}`，它类似于`std::lock_guard{}`。
- en: '`std::lock_guard{}` is a simple RAII wrapper around a mutex, while `std::unique_lock`
    provides similar facilities to `std::unique_ptr{}`, in that the resulting lock
    is movable (not copyable), and provides additional APIs above and beyond a simple
    RAII wrapper.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::lock_guard{}`是一个简单的RAII包装器，而`std::unique_lock`提供了类似于`std::unique_ptr{}`的功能，即生成的锁是可移动的（不可复制的），并提供了超出简单RAII包装器的额外API。'
- en: As a side note, with respect to all of these lock guards, don't forget to define
    the guard's variable, otherwise the lock will be locked and unlocked immediately,
    resulting in hard-to-find bugs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个副作用，关于所有这些锁保护，不要忘记定义保护的变量，否则锁将立即被锁定和解锁，导致难以发现的错误。
- en: One of the additional APIs provided by `std::unique_lock` is the ability to
    defer locking the mutex (that is, not locking on the construction of the lock
    itself). This provides the user with the ability to better control when locking
    occurs, using one of the many lock functions, such as `lock()`, `try_lock()`,
    `try_lock_for()`, and `try_lock_until()`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_lock`提供的另一个额外API是延迟锁定互斥锁的能力（即在锁本身的构造时不锁定）。这使用户能够更好地控制锁定发生的时间，使用诸如`lock()`、`try_lock()`、`try_lock_for()`和`try_lock_until()`之类的许多锁函数。'
- en: In our preceding example, we try to lock the critical region, and, if that fails,
    we sleep for a second before trying again. Other modifiers include the `std::adopt_lock{}`
    and `std::try_lock{}` modifiers, which either assume the mutex is already locked,
    or that the constructor tries to lock without blocking.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们尝试锁定临界区，如果失败，就在再次尝试之前睡眠一秒。其他修饰符包括`std::adopt_lock{}`和`std::try_lock{}`修饰符，它们要么假设互斥锁已经被锁定，要么构造函数尝试锁定而不阻塞。
- en: 'In addition to regular mutexes, C++ also provides, like POSIX, a recursive
    mutex, as shown in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的互斥锁，C++还提供了像POSIX一样的递归互斥锁，如下所示：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we are capable of creating two lock guards on the same recursive
    lock without creating deadlock (as destructors are executed in reverse order to
    construction, ensuring the locks are unlocked in the proper order).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们能够在同一个递归锁上创建两个锁保护，而不会创建死锁（因为析构函数的执行顺序与构造相反，确保锁以正确的顺序被解锁）。
- en: 'Another common problem with mutexes relates to locking more than one mutex
    at the same time; that is to say, if more than one critical region exists and
    a particular operation must operate on both critical regions at the same time.
    To accomplish this, C++17 added `std::scoped_lock{}`, which is similar to `std::lock_guard{}`,
    but accepts more than one lock, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁的另一个常见问题与同时锁定多个互斥锁有关；也就是说，如果存在多个临界区，并且特定操作必须同时在两个临界区上操作。为了实现这一点，C++17添加了`std::scoped_lock{}`，它类似于`std::lock_guard{}`，但接受多个锁，如下所示：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, more than one mutex is locked and unlocked using the `std::scoped_lock{}`
    class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用`std::scoped_lock{}`类锁定和解锁了不止一个互斥锁。
- en: '`std::unique_lock{}` is similar to `std::unique_ptr{}` in that it guards a
    resource and prevents copying. Similar to `std::shared_ptr{}` the mutex APIs also
    provide `std::shared_lock{}`, which provides the ability for more than one thread
    to gain access to the same mutex. The following code demonstrates this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::unique_lock{}`类似于`std::unique_ptr{}`，它保护资源并防止复制。与`std::shared_ptr{}`类似，互斥量API还提供`std::shared_lock{}`，它提供了多个线程访问同一互斥量的能力。以下代码演示了这一点：'
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding example, we have two threads—a producer and a consumer. The
    producer (`mythread1`) increments a counter, while the consumer (`mythread2`)
    outputs the count to `stdout`. In the `main()` function we create three threads—one
    producer and two consumers.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有两个线程——一个生产者和一个消费者。生产者（`mythread1`）增加计数器，而消费者（`mythread2`）将计数输出到`stdout`。在`main()`函数中，我们创建三个线程——一个生产者和两个消费者。
- en: We could implement this scenario using a regular `std::mutex`; however, such
    an implementation would be suboptimal as both consumers are not modifying the
    counter, meaning multiple consumers could safely execute simultaneously without
    corrupting the results if they happen to collide (as no modifications are being
    made).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用常规的`std::mutex`来实现这种情况；但是，这样的实现将是次优的，因为两个消费者都没有修改计数器，这意味着多个消费者可以在不损坏结果的情况下同时执行，如果它们碰巧发生冲突（因为没有进行修改）。
- en: If a regular `std::muted` is used, however, the consumers would have to wait
    on each other, which would also be suboptimal (obviously ignoring the fact that
    `stdout` is also a shared resource that should be treated as its own critical
    region to prevent corruption of `stdout` itself).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果使用常规的`std::muted`，消费者将不得不互相等待，这也是次优的（显然忽略了`stdout`也是一个共享资源，应该被视为自己的临界区，以防止`stdout`本身的损坏）。
- en: In order to solve this problem, we leverage `std::shared_mutex` instead of a
    regular `std::mutex`. In the producer, we lock the mutex using `std::unique_lock{}`,
    which ensures exclusive access to the critical region. In the consumer, however,
    we leverage `std::shared_lock{}`, which only waits on previous locks using `std::unique_lock{}`.
    If the mutex was acquired using `std::shared_lock{}`, the thread continues execution
    without waiting, sharing access to the critical region.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们利用`std::shared_mutex`代替常规的`std::mutex`。在生产者中，我们使用`std::unique_lock{}`锁定互斥量，这确保了对临界区的独占访问。然而，在消费者中，我们利用`std::shared_lock{}`，它只等待使用`std::unique_lock{}`的先前锁定。如果使用`std::shared_lock{}`获取了互斥量，线程将继续执行而不等待，共享对临界区的访问。
- en: 'Finally, prior to C++17 with the addition of `std::scoped_lock{}`, the only
    way to lock more than one mutex was to use the `std::lock()` (and friends) functions,
    as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在C++17之前，通过添加`std::scoped_lock{}`，锁定多个互斥量的唯一方法是使用`std::lock()`（和friends）函数，如下所示：
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As with POSIX, C++ also provides the ability to control the order in which
    threads execute, using condition variables. In the following example, we create
    two threads and synchronize the order of their execution using a condition variable,
    similar to the condition variable example for POSIX:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与POSIX一样，C++也提供了使用条件变量控制线程执行顺序的能力。在下面的例子中，我们创建两个线程，并使用条件变量来同步它们的执行顺序，类似于POSIX的条件变量示例：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As shown in the preceding example, although the second thread is created first,
    it executes last. This is accomplished by creating a C++ condition variable. In
    the second thread, we protect the critical region using `std::unique_lock{}`,
    and then we wait for the first thread to signal that it has completed by making
    a call to `notify_one()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，尽管第二个线程是先创建的，但它最后执行。这是通过创建一个C++条件变量实现的。在第二个线程中，我们使用`std::unique_lock{}`保护临界区，然后等待第一个线程通过调用`notify_one()`来发出已完成的信号。
- en: Once the first thread has completed and notified the second thread, the second
    thread finishes its execution.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦第一个线程完成并通知第二个线程，第二个线程就完成了它的执行。
- en: 'This same approach also works for more than one thread in broadcast mode using
    C++ threads, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也适用于使用C++线程进行广播模式的多个线程，如下所示：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, the first thread completes its work and then signals to all
    the remaining threads to complete. The second thread protects the critical region
    with a mutex, and waits for a signal from the first thread.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，第一个线程完成它的工作，然后通知所有剩余的线程完成。第二个线程用互斥量保护临界区，并等待第一个线程的信号。
- en: The problem is that once the first thread executes and signals that it is done,
    the remaining threads will attempt to execute, but only one thread can acquire
    the critical region, resulting in the third thread waiting for the critical region
    to be unlocked and being notified. For this reason, when the second thread is
    complete, it must notify the condition variable again to unlock the remaining
    thread, allowing all three to complete.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于一旦第一个线程执行并发出完成的信号，剩余的线程将尝试执行，但只有一个线程可以获取临界区，导致第三个线程等待临界区被解锁并收到通知。因此，当第二个线程完成时，它必须再次通知条件变量以解锁剩余的线程，从而允许所有三个线程完成。
- en: 'To overcome this, we will combine everything learned in this section, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将结合本节学到的所有内容，如下所示：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This example is identical to the previous example, with one simple change. Instead
    of `std::mutex{}`, we make use of `std::shared_mutex{},` and `std::shared_lock{}`
    is used to lock the mutex.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与前一个例子相同，只有一个简单的改变。我们使用`std::shared_mutex{}`而不是`std::mutex{}`，并且使用`std::shared_lock{}`来锁定互斥量。
- en: In order to be able to use a shared mutex in place of a regular mutex, `std::condition_variable_any{}` must
    be used instead of `std::condition_variable{}`. By using `std::shared_mutex{}`
    instead of `std::mutex{}`, when the first thread signals that it has completed,
    the remaining threads are free to complete their work and process the critical
    region simultaneously.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用共享互斥量代替常规互斥量，必须使用`std::condition_variable_any{}`而不是`std::condition_variable{}`。通过使用`std::shared_mutex{}`而不是`std::mutex{}`，当第一个线程发出已完成的信号时，剩余的线程可以自由完成它们的工作并同时处理临界区。
- en: 'Finally, C++ provides a convenient mechanism for calling a function once if
    more than one thread is needed, but allowing only one to execute initialization
    logic (a feature that POSIX also provides but is not covered in this book), as
    follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，C++提供了一个方便的机制，如果需要多个线程，但只允许一个执行初始化逻辑（这也是POSIX提供的功能，但本书未涵盖），如下所示：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, more than one thread is created, but `Hello World` is only
    executed once using the `std::call_once{}` wrapper. It should be noted that although
    this seems simple, `std::call_once{}` ensures that the flag that holds the state
    as to whether or not the wrapped logic has yet to be executed is flipped atomically,
    thereby preventing the possibility of race conditions, however unlikely they might
    be.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，创建了多个线程，但是使用`std::call_once{}`包装器只执行了一次`Hello World`。值得注意的是，尽管这看起来很简单，但`std::call_once{}`确保了标志的原子翻转，以确定包装逻辑是否已经执行，从而防止可能的竞争条件，尽管它们可能是不太可能发生的。
- en: Studying an example on parallel computation
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究并行计算的示例
- en: 'In this example, we will demonstrate how to perform a parallel computation
    task that will calculate prime numbers, using threading. In this example, the
    following inclusion files and namespaces are required:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将演示如何使用线程执行并行计算任务，计算质数。在这个示例中，需要以下包含文件和命名空间：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Calculating prime values is an expensive operation for large numbers, but thankfully,
    they can be calculated in parallel. It should be noted that in our example, we
    don't attempt to optimize our search algorithm, as our goal here is to provide
    a readable example of threading. There are many methods, some simple, for improving
    the performance of the code in this example.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大数来说，计算质数值是一项昂贵的操作，但幸运的是，它们可以并行计算。值得注意的是，在我们的示例中，我们并没有尝试优化我们的搜索算法，因为我们的目标是提供一个可读的线程示例。有许多方法，一些简单的方法，可以改进此示例中代码的性能。
- en: 'To store the prime numbers that our program finds, we will define the following
    class:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储我们的程序找到的质数，我们将定义以下类：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This class provides a place for us to store each prime number using the `add()`
    function. Once all the primes that we plan to search for are found, we provide
    a `print()` function that is capable of printing the identified prime numbers
    in sorted order.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了一个地方，让我们使用`add()`函数存储每个质数。一旦找到我们计划搜索的所有质数，我们提供一个`print()`函数，能够按排序顺序打印已识别的质数。
- en: 'The thread that we will use to check whether a number is a prime number is
    as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用来检查一个数字是否为质数的线程如下：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this thread, we loop through every possible multiple of the number provided,
    and check to see whether the modulus is `0`. If it is `0`, the number is not a
    prime. If no multiple is found, the number is a prime and it is added to our list.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个线程中，我们循环遍历用户提供的数字的每个可能的倍数，并检查模是否为`0`。如果是`0`，则该数字不是质数。如果没有找到任何倍数，则该数字是质数，并且将其添加到我们的列表中。
- en: 'Finally, in our `protected_main()` function, we search for a set of primes.
    We start by first converting all of our arguments so that they may be processed:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的`protected_main()`函数中，我们搜索一组质数。我们首先将所有参数转换，以便对其进行处理：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We are expecting three arguments. The first argument will provide the highest
    possible number we wish to check to see whether it is a prime number; the second
    argument is the total number of threads we wish to create to search for prime
    numbers, and the third will determine whether we want to print the results.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望有三个参数。第一个参数将提供我们希望检查是否为质数的最大可能数字；第二个参数是我们希望创建的用于搜索质数的线程总数；第三个参数将确定我们是否要打印结果。
- en: 'The next task is to get the highest possible prime number to search for, as
    well as to get the total number of threads to create. Consider the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是获取要搜索的最大可能质数，以及获取要创建的线程总数。考虑以下代码：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once we know how many primes to search for, and how many threads to create,
    we search for our prime numbers as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道要搜索多少个质数，以及要创建多少个线程，我们就按照以下方式搜索我们的质数：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this code, we search for all the primes up to the number provided by the
    user, incrementing by the total number of threads provided by the user. We then
    create a list of threads, providing each thread with the number it should look
    for prime from.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们搜索用户提供的数字范围内的所有质数，逐个增加用户提供的线程总数。然后，我们创建一个线程列表，为每个线程提供它应该从哪个数字开始寻找质数。
- en: Once all the threads are created, we wait for the threads to finish. It should
    be noted that there are many ways to further optimize this logic, including preventing
    the recreation of threads, thus preventing the overuse of `malloc()`, but this
    example provides a simple mechanism to demonstrate the point of this example.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有线程都创建好了，我们就等待这些线程完成。值得注意的是，有许多方法可以进一步优化这个逻辑，包括防止线程的重新创建，从而防止过度使用`malloc()`，但这个示例提供了一个简单的机制来演示这个示例的要点。
- en: 'The last thing we do in the `protected_main()` function is check to see whether
    the user wants to see the results, and to print them if so:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`protected_main()`函数中，我们做的最后一件事是检查用户是否想要查看结果，并在需要时打印它们：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we execute the `protected_main()` function using our `main()`, and
    catch any exceptions that might arise as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用我们的`main()`执行`protected_main()`函数，并捕获可能出现的任何异常，如下所示：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Compiling and testing
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和测试
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples—find it at the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter12/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter12/CMakeLists.txt).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译这段代码，我们利用了与其他示例相同的`CMakeLists.txt`文件，可以在以下链接找到：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter12/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter12/CMakeLists.txt)。
- en: 'With this code in place, we can compile this code using the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以使用以下方式编译这段代码：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To execute the example, run the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此示例，请运行以下命令：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As shown in this snippet, the prime numbers up to `20` are identified. To demonstrate
    the effectiveness of threading, execute the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如本片段所示，找到了最多`20`个素数。为了演示线程的有效性，请执行以下操作：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As can be seen, as the total number of threads decreases, the total amount of
    time the application takes to find the prime numbers increases.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，随着线程总数的减少，应用程序查找素数所需的总时间也会增加。
- en: Studying an example on benchmarking with threads
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究使用线程进行基准测试的示例
- en: In previous chapters, we discussed how to benchmark software using various different
    mechanisms. In this chapter, we will explore creating our own high-resolution
    timer using a thread, instead of using the high-resolution timer provided by the
    C++ chrono APIs.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们讨论了如何使用各种不同的机制对软件进行基准测试。在本章中，我们将探讨使用线程创建自己的高分辨率计时器，而不是使用C++ chrono
    API提供的高分辨率计时器。
- en: To accomplish this, we will create a thread with the sole job of counting as
    fast as possible. It should be noted that although this will provide a high-resolution
    timer that is extremely sensitive, it has a lot of disadvantages compared to computer
    architectures such as Intel. These provide hardware instructions with higher resolution
    than is possible here, while being less susceptible to CPU frequency scaling.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将创建一个线程，其唯一工作是尽可能快地计数。值得注意的是，尽管这将提供一个非常敏感的高分辨率计时器，但与英特尔等计算机架构相比，它有很多缺点。这些提供了比这里可能的更高分辨率的硬件指令，同时对CPU频率缩放的影响较小。
- en: 'In this example, the following inclusion and namespaces are needed:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，需要以下包含和命名空间：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will store the high-resolution timer in a `count` variable, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把高分辨率计时器存储在`count`变量中，如下所示：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `enable_counter` Boolean will be used to turn the timer off, while the mutex
    and condition variable will be used to turn the timer on at the correct time.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`enable_counter`布尔值将用于关闭计时器，而互斥锁和条件变量将用于在正确的时间打开计时器。'
- en: 'Our high-resolution timer will consist of the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的高分辨率计时器将包括以下内容：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The timer will notify the condition variable that it is running once it is
    started, and will continue to count until the `enable_counter` flag is set to
    `false`. To time an operation, we will use the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器将在启动后通知条件变量它正在运行，并将继续计数，直到`enable_counter`标志被设置为`false`。为了计时一个操作，我们将使用以下命令：
- en: '[PRE47]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This logic creates the timer thread, and then waits for it to start using the
    condition variable. Once the timer is started, it will execute the function under
    test and then disable the timer and wait for the thread to complete, returning
    the resulting total number of ticks.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑创建了计时器线程，然后使用条件变量等待它启动。一旦计时器启动，它将执行测试函数，然后禁用计时器并等待线程完成，返回结果的总计时数。
- en: 'In our `protected_main()` function, we ask the user for the total number of
    times to loop in a `for` loop, and then time how long it takes to execute the
    `for` loop, outputting the results to `stdout` when we are done, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`protected_main()`函数中，我们要求用户输入在`for`循环中循环的总次数，然后计算执行`for`循环所需的时间，并在完成后将结果输出到`stdout`，如下所示：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we execute the `protected_main()` function using our `main()`, and
    catch any exceptions that might arise, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用我们的`main()`执行`protected_main()`函数，并捕获可能出现的任何异常，如下所示：
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Compiling and testing
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和测试
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter12/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter12/CMakeLists.txt).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译此代码，我们将利用我们一直在使用的相同`CMakeLists.txt`文件：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter12/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter12/CMakeLists.txt)。
- en: 'With this code in place, we can compile this code using the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以使用以下命令编译此代码：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To execute the code, run the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行代码，请运行以下命令：
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As shown in this snippet, the example is run with a loop of `1000000` iterations,
    and the number of ticks it took to execute the loop is output to the console.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如本片段所示，示例将循环`1000000`次，并将执行循环所需的时钟周期数输出到控制台。
- en: Studying an example on thread logging
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 研究线程日志示例
- en: The final example in this chapter will build upon our existing debugger example
    to add support for multiple clients. In [Chapter 10](2d0b3ea6-499f-4064-a278-c480d2c74c75.xhtml), *Programming
    POSIX Sockets Using C++*, we added support for networking to the example debugger,
    providing the ability to offload our debugging logs to a server in addition to
    the local system.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个示例将在现有的调试器示例基础上构建，以支持多个客户端。在[第10章](2d0b3ea6-499f-4064-a278-c480d2c74c75.xhtml)中，*使用C++编程POSIX套接字*，我们为示例调试器添加了对网络的支持，除了本地系统外，还提供了将调试日志卸载到服务器的功能。
- en: The problem with this is that the server could only accept one connection before
    closing, as it didn't have the logic for handling more than one client. In this
    example, we will fix that issue.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于服务器在关闭之前只能接受一个连接，因为它没有处理多个客户端的逻辑。在这个示例中，我们将解决这个问题。
- en: 'To start, we will need to define our port and max debug string length, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义我们的端口和最大调试字符串长度，如下所示：
- en: '[PRE52]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The server will require the following include statements:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将需要以下包含语句：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As with our previous example, the log file will be defined as global, and a
    mutex will be added to synchronize access to the log:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，日志文件将被定义为全局，并且将添加互斥锁以同步对日志的访问：
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Instead of the `recv()` function being defined in the server, we will define
    it globally to provide easy access to our client threads (each client will spawn
    a new thread):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将全局定义`recv()`函数，而不是在服务器中定义它，以便为客户端线程提供方便访问（每个客户端将生成一个新线程）：
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As with the `recv()` function, the `log()` function will also be moved out
    of the server and will create our client threads. Each time a connection is made
    by a client, the server will spawn a new thread (the `log()` function), which
    is implemented as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与`recv()`函数一样，`log()`函数也将从服务器中移出，并将创建我们的客户端线程。每当客户端建立连接时，服务器将生成一个新线程（`log()`函数），其实现如下：
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The only difference with using the `log()` function, compared to the example
    in [Chapter 10](2d0b3ea6-499f-4064-a278-c480d2c74c75.xhtml), *Programming POSIX
    Sockets Using C++*, is the addition of `std::unique_lock{}` to guard access to
    the log (in the event that more than one client attempts to write to the log at
    the same time). The handle is passed to the log function instead of the handle
    being a member of the server, and we flush the log file after each write to ensure
    all the writes are actually written to disk, as we will close the server application
    by killing it.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与在[第10章](2d0b3ea6-499f-4064-a278-c480d2c74c75.xhtml)中的示例相比，使用`log()`函数的唯一区别是添加了`std::unique_lock{}`以保护对日志的访问（以防多个客户端同时尝试写入日志）。句柄被传递给日志函数，而不是句柄作为服务器的成员，我们在每次写入后刷新日志文件，以确保所有写入实际写入磁盘，因为我们将通过终止服务器应用程序来关闭它。
- en: 'Finally, the server is modified to accept incoming connections and spawn threads
    as a result. The server starts with the same logic in the previous example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，服务器被修改为接受传入的连接并生成线程作为结果。服务器从前一个示例中的相同逻辑开始：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The server''s constructor creates a socket, and binds the socket to the ports
    identified. The major difference with the server is in the use of the `listen()`
    function, which used to be the `log()` function. Consider the following code for
    it:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的构造函数创建一个套接字，并将套接字绑定到标识的端口。服务器的主要区别在于使用`listen()`函数，该函数曾经是`log()`函数。考虑以下代码：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `listen()` function listens on the socket for new connections. When a connection
    is made, it creates a thread using the `log()` function and provides the `log`
    function with the handle of the new client.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`listen()`函数在套接字上监听新连接。当建立连接时，它使用`log()`函数创建一个线程，并向`log`函数提供新客户端的句柄。'
- en: There is no need to ensure the server and or clients are closed properly, as
    TCP will handle this for us, eliminating the need to track each client thread
    once created (that is, there is no need to `join()` the thread when it is complete).
    For this reason, we use the `detach()` function, which tells C++ that a `join()`
    will not take place, and the thread should continue to execute even after the
    thread object is destroyed.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 无需确保服务器和/或客户端正确关闭，因为TCP将为我们处理这一点，消除了创建每个客户端线程后跟踪每个客户端线程的需要（即，当完成时无需`join()`线程）。因此，我们使用`detach()`函数，告诉C++不会发生`join()`，线程应该在线程对象被销毁后继续执行。
- en: Finally, we loop, waiting for more clients to connect.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们循环等待更多客户端连接。
- en: 'The remaining logic for the server is the same. We create the server in the
    `protected_main()` function and execute the `protected_main()` function in our
    `main()` function, attempting to catch any exceptions that might occur. The following
    code shows this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的剩余逻辑是相同的。我们在`protected_main()`函数中创建服务器，并在`main()`函数中执行`protected_main()`函数，尝试捕获可能发生的任何异常。以下代码显示了这一点：
- en: '[PRE59]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Finally, the client logic for this example is identical to the client logic
    found in [Chapter 10](2d0b3ea6-499f-4064-a278-c480d2c74c75.xhtml), *Programming
    POSIX Sockets using C++*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，此示例的客户端逻辑与[第10章](2d0b3ea6-499f-4064-a278-c480d2c74c75.xhtml)中找到的客户端逻辑相同。
- en: Compiling and testing
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译和测试
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples—[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译此代码，我们利用了与其他示例相同的`CMakeLists.txt`文件——[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter11/CMakeLists.txt)。
- en: 'With this in place, we can compile the code using the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以使用以下命令编译代码：
- en: '[PRE60]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'To execute the server, run the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行服务器，请运行以下命令：
- en: '[PRE61]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To execute the client, open a new Terminal and run the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行客户端，请打开一个新的终端并运行以下命令：
- en: '[PRE62]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As shown in this snippet, when the client is executed, the client and server
    side both output `DEBUG: Hello World` to `stderr`. In addition, the client outputs `Hello
    World` to `stderr` as the second call to `std::clog` is not redirected.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '如本片段所示，当客户端执行时，客户端和服务器端都会将`DEBUG: Hello World`输出到`stderr`。此外，客户端将`Hello World`输出到`stderr`，因为第二次调用`std::clog`时未重定向。'
- en: 'Both log files contain the redirected `DEBUG: Hello World`. Finally, we can
    execute the client more than once, resulting in the server logging the output
    from both clients instead of just one.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '两个日志文件都包含重定向的`DEBUG: Hello World`。最后，我们可以多次执行客户端，导致服务器记录来自两个客户端的输出，而不仅仅是一个。'
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed how to program threads using both POSIX and C++
    APIs. We then discussed three examples. The first example demonstrated how to
    use threading to perform a parallel computation, while the second demonstrated
    how to create your own high-resolution timer using threading to perform benchmarking.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用POSIX和C++ API编程线程。然后我们讨论了三个示例。第一个示例演示了如何使用线程执行并行计算，而第二个示例演示了如何使用线程创建自己的高分辨率计时器来进行基准测试。
- en: Finally, the third example built upon our existing debugging example to provide
    support for multiple clients. The next, and final, chapter will discuss the error
    handling features provided by C and C++, including C style error handling and
    exceptions.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三个示例建立在我们现有的调试示例基础上，为多个客户端提供支持。下一章，也是最后一章，将讨论C和C++提供的错误处理功能，包括C风格的错误处理和异常。
- en: Questions
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do you get the ID of a thread using POSIX? What about when using C++?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使用POSIX获取线程的ID？在使用C++时呢？
- en: What is the main issue with POSIX thread input and output?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: POSIX线程输入和输出的主要问题是什么？
- en: What is a race condition?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是竞争条件？
- en: What is deadlock?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 死锁是什么？
- en: What is `std::future{}` in C++, and what problem is it trying to solve?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++中的`std::future{}`是什么，它试图解决什么问题？
- en: What is the main reason for using `std::call_once()`?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`std::call_once()`的主要原因是什么？
- en: What is the difference between `std::shared_mutex` and `std::mutex`?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::shared_mutex`和`std::mutex`之间有什么区别？'
- en: What is the purpose of a recursive mutex?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归互斥锁的目的是什么？
- en: Further reading
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
