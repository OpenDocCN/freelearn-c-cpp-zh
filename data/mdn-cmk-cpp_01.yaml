- en: '*Chapter 3*: Setting Up Your First CMake Project'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第*3章*：设置你的第一个CMake项目
- en: 'We have now gathered enough information to start talking about the core function
    of CMake: *building projects*. In CMake, a **project** contains all the source
    files and configuration necessary to manage the process of bringing our solutions
    to life. Configuration starts by performing all the checks: whether the target
    platform is supported, whether it has all the necessary dependencies and tools,
    and whether the provided compiler works and supports required features.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经收集了足够的信息，可以开始讨论CMake的核心功能：*构建项目*。在CMake中，一个**项目**包含管理将我们的解决方案带入生活的所有源文件和配置。配置从执行所有检查开始：目标平台是否受支持，是否拥有所有必要的依赖项和工具，以及提供的编译器是否工作并支持所需功能。
- en: When that's done, CMake will generate a buildsystem for the build tool of our
    choice and run it. Source files will be compiled and linked with each other and
    their dependencies to produce output artifacts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，CMake将为我们的选择构建工具生成一个构建系统并运行它。源文件将与彼此以及它们的依赖项编译和链接，以产生输出工件。
- en: Projects can be used internally by a group of developers to produce packages
    that users can install on their systems through package managers or they can be
    used to provide single-executable installers. Projects can also be shared in an
    open-source repository so that users can use CMake to compile projects on their
    machines and install them directly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 项目可以由一组开发人员内部使用，产生用户可以通过包管理器在其系统上安装的包，或者它们可以用来提供单执行文件安装器。项目还可以在开源存储库中分享，以便用户可以使用CMake在他们的机器上编译项目并直接安装它们。
- en: Using CMake projects to their full potential will improve the developing experience
    and the quality of the produced code because we can automate many dull tasks,
    such as running tests after the build, checking code coverage, formatting the
    code, and checking source code with linters and other tools.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 充分利用CMake项目将改善开发体验和生成代码的质量，因为我们可以自动化许多单调的任务，例如在构建后运行测试，检查代码覆盖率，格式化代码，以及使用linters和其他工具检查源代码。
- en: To unlock the power of CMake projects, we'll go over some key decisions first
    – these are how to correctly configure the project as a whole and how to partition
    it and set up the source tree so that all files are neatly organized in the right
    directories.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分发挥CMake项目的力量，我们首先要了解一些关键决策——这些决策是如何正确配置整个项目以及如何划分项目和设置源代码树，以便所有文件都整齐地组织在正确的目录中。
- en: We'll then learn how to query the environment the project is built on – for
    example, what architecture it is? What tools are available? What features do they
    support? And what standard of the language is in use? Finally, we'll learn how
    to compile a test **C++** file to verify if the chosen compiler meets the standard
    requirements set in our project.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将学习如何查询项目构建的环境——例如，它的架构是什么？有哪些工具可用？它们支持哪些功能？并使用的是哪种语言标准？最后，我们将学习如何编译一个测试**C++**文件，以验证所选编译器是否满足我们项目中设定的标准要求。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Basic directives and commands
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本指令和命令
- en: How to partition your project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何划分你的项目
- en: Thinking about the project structure
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思考项目结构
- en: Scoping the environment
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域环境
- en: Configuring the toolchain
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置工具链
- en: Disabling in-source builds
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用源代码内构建
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter03](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter03).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中出现的代码文件：[https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter03](https://github.com/PacktPublishing/Modern-CMake-for-Cpp/tree/main/examples/chapter03)。
- en: 'To build examples provided in this book always use recommended commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建本书提供的示例，始终使用推荐命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace placeholders `<build tree>` and `<source tree>` with appropriate
    paths. As a reminder: **build tree** is the path to target/output directory, **source
    tree** is the path at which your source code is located.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 务必将占位符`<build tree>`和`<source tree>`替换为合适的路径。作为提醒：**build tree**是目标/输出目录的路径，**source
    tree**是源代码所在的路径。
- en: Basic directives and commands
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本指令和命令
- en: 'In [*Chapter 1*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014)*,* *First
    Steps with CMake*, we already looked at a simple project definition. Let''s revisit
    it. It is a directory with a `CMakeLists.txt` file that contains a few commands
    configuring the language processor:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014)*，*CMake的初步步骤*中，我们已经看了一个简单的项目定义。让我们回顾一下。这是一个包含`CMakeLists.txt`文件的目录，其中包含了几条配置语言处理器的命令：
- en: 'chapter01/01-hello/CMakeLists.txt: Hello world in CMake language'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: chapter01/01-hello/CMakeLists.txt：CMake语言中的Hello world
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the same chapter, in the *Project files* section, we learned about a few
    basic commands. Let's explain them in depth.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一章节中，在*项目文件*部分，我们了解了一些基本命令。让我们深入解释一下。
- en: Specifying the minimum CMake version – cmake_minimum_required()
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定最小的CMake版本——cmake_minimum_required()
- en: This isn't strictly a project-specific command, as it should be used with scripts
    as well, but it is so important that we repeat it here. As you know, `cmake_minimum_required()`
    will check whether the system has the right CMake version, but implicitly, it
    will also call another command, `cmake_policy(VERSION)`, which will tell CMake
    what the right policies are to use for this project. What are these policies?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个严格的项目特定命令，因为它也应该用于脚本，但我们在这里重复它是因为它非常重要。正如你所知，`cmake_minimum_required()`将检查系统是否有正确的CMake版本，但隐式地，它还会调用另一个命令，`cmake_policy(VERSION)`，这将告诉CMake对于这个项目应该使用哪些正确的策略。这些策略是什么？
- en: Over the last 20 years of CMake's development, there have been many changes
    to how commands behave as CMake and the languages it supports have evolved. To
    keep the syntax clean and simple, CMake's team decided to introduce policies to
    reflect these changes. Whenever a backward-incompatible change was introduced,
    it came with a policy that enabled the new behavior.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在CMake发展的过去20年中，随着CMake及其支持的语言的发展，命令的行为发生了许多变化。为了保持语法简洁明了，CMake团队决定引入策略来反映这些变化。每当引入一个向后不兼容的更改时，它都会附带一个策略，启用新的行为。
- en: By calling `cmake_minimum_required()`, we tell CMake that it needs to apply
    the policies up to the version provided in the argument. When CMake gets upgraded
    with new policies, we don't need to worry about them breaking our project, as
    the new policies won't be enabled. If we test the project with the newest version
    and if we're happy with the outcome, we can send the updated project to our users.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`cmake_minimum_required()`，我们告诉CMake需要应用到提供参数中的版本的策略。当CMake通过新的策略升级时，我们不需要担心它们会破坏我们的项目，因为新策略不会被启用。如果我们用最新版本测试项目并且结果令我们满意，我们可以把更新后的项目发送给我们的用户。
- en: Policies can affect every single aspect of CMake, including other important
    commands like `project()`. For that reason, it is important to start your `CMakeLists.txt`
    file by setting the version you're working with. Otherwise, you will get warnings
    and errors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 策略可以影响CMake的每一个方面，包括其他重要命令如`project()`。因此，很重要的一点是，你要在`CMakeLists.txt`文件开始时设定你正在使用的版本。否则，你会收到警告和错误。
- en: 'Every version introduces quite a few policies – there isn''t any real value
    in describing them unless you''re having issues with upgrading legacy projects
    to the latest CMake version. In that case, refer to the official documentation
    on policies: [https://cmake.org/cmake/help/latest/manual/cmake-policies.7.html](https://cmake.org/cmake/help/latest/manual/cmake-policies.7.html).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个版本都引入了许多策略——除非你正在将旧项目升级到最新的CMake版本遇到问题，否则描述它们并没有真正的价值。在这种情况下，请参考官方文档中的策略：[https://cmake.org/cmake/help/latest/manual/cmake-policies.7.html](https://cmake.org/cmake/help/latest/manual/cmake-policies.7.html)。
- en: Defining languages and metadata – project()
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义语言和元数据——project()
- en: 'Technically, CMake doesn''t need the `project()` command. Any directory containing
    the `CMakeLists.txt` file will be parsed in project mode. CMake implicitly adds
    that command to the top of the file. But we already know that we need to start
    by specifying the minimum version, so it''s best not to forget about calling `project()`.
    We can use one of its two forms:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，CMake不需要`project()`命令。任何包含`CMakeLists.txt`文件的目录都会以项目模式被解析。CMake隐式地在文件顶部添加了这个命令。但我们已经知道我们需要首先指定最小版本，所以最好不要忘记调用`project()`。我们可以使用它的两种形式之一：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We need to specify `<PROJECT-NAME>`, but the other arguments are optional.
    Calling this command will implicitly set the following variables:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指定`<PROJECT-NAME>`，但其他参数是可选的。调用这个命令将隐式地设置以下变量：
- en: '`PROJECT_NAME`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_NAME`'
- en: '`CMAKE_PROJECT_NAME` (only in the top-level `CMakeLists.txt`)'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_PROJECT_NAME`（仅在最顶层的`CMakeLists.txt`中）'
- en: '`PROJECT_SOURCE_DIR`, `<PROJECT-NAME>_SOURCE_DIR`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_SOURCE_DIR`、`<PROJECT-NAME>_SOURCE_DIR`'
- en: '`PROJECT_BINARY_DIR`, `<PROJECT-NAME>_BINARY_DIR`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_BINARY_DIR`、`<PROJECT-NAME>_BINARY_DIR`'
- en: 'What languages are supported? Quite a few. Here''s a list of language keywords
    you can use to configure your project: `C`, `CXX` (C++), `CUDA`, `OBJC` (Objective-C),
    `OBJCXX` (Objective C++), `Fortran`, `ISPC`, `ASM`, as well as `CSharp` (C#) and
    `Java`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 支持哪些语言？很多。以下是您可以用来配置项目的语言关键词列表：`C`、`CXX`（C++）、`CUDA`、`OBJC`（Objective-C）、`OBJCXX`（Objective
    C++）、`Fortran`、`ISPC`、`ASM`，以及`CSharp`（C#）和`Java`。
- en: CMake enables C and C++ by default, so you may want to explicitly specify only
    `CXX` for your C++ projects. Why? The `project()` command will detect and test
    the available compilers for your chosen language, so choosing the correct ones
    will allow you to save time during the configuration stage by skipping any checks
    for unused languages.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: CMake默认支持C和C++，所以您可能只想明确指定`CXX`用于您的C++项目。为什么？`project()`命令将检测和测试您选择的可用编译器，所以选择正确的编译器将使您在配置阶段节省时间，通过跳过任何对未使用语言的检查。
- en: 'Specifying `VERSION` will make the following variables available:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 指定`VERSION`将使以下变量可用：
- en: '`PROJECT_VERSION`, `<PROJECT-NAME>_VERSION`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_VERSION`、`<PROJECT-NAME>_VERSION`'
- en: '`CMAKE_PROJECT_VERSION` (only in the top-level `CMakeLists.txt`)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_PROJECT_VERSION`（仅在顶级`CMakeLists.txt`中）'
- en: '`PROJECT_VERSION_MAJOR`, `<PROJECT-NAME>_VERSION_MAJOR`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_VERSION_MAJOR`、`<PROJECT-NAME>_VERSION_MAJOR`'
- en: '`PROJECT_VERSION_MINOR`, `<PROJECT-NAME>_VERSION_MINOR`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_VERSION_MINOR`、`<PROJECT-NAME>_VERSION_MINOR`'
- en: '`PROJECT_VERSION_PATCH`, `<PROJECT-NAME>_VERSION_PATCH`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_VERSION_PATCH`、`<PROJECT-NAME>_VERSION_PATCH`'
- en: '`PROJECT_VERSION_TWEAK`, `<PROJECT-NAME>_VERSION_TWEAK`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PROJECT_VERSION_TWEAK`、`<PROJECT-NAME>_VERSION_TWEAK`'
- en: The preceding variables will be useful for configuring packages or for passing
    to compiled files to make the version available in the final executable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量将有助于配置软件包，或将版本传递给编译文件，以便在最终可执行文件中可用。
- en: Following this principle, we can set `DESCRIPTION` and `HOMEPAGE_URL`, which
    will set the variables in the same way.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这一原则，我们可以设置`DESCRIPTION`和`HOMEPAGE_URL`，这将以相同的方式设置变量。
- en: CMake also allows specification of the used languages with `enable_language(<lang>)`,
    which will not create any metadata variables.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CMake还允许通过`enable_language(<lang>)`指定使用的语言，这将不会创建任何元数据变量。
- en: The preceding commands will allow us to create a basic listfile and initialize
    an empty project. Now, we can start adding things to build. Structure doesn't
    really matter for the tiny, single-file projects we have used in our examples
    so far. But what happens when there's more code?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令将允许我们创建一个基本的列表文件并初始化一个空项目。现在，我们可以开始添加东西来构建。对于迄今为止我们所用的例子中的微小单文件项目，结构确实不太重要。但是当代码量增加时会发生什么？
- en: Partitioning your project
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 划分您的项目
- en: 'As our solutions grow in the number of lines and files they have, we slowly
    understand that the inevitable is coming: either we start partitioning the project
    or we drown in lines of code and a multitude of files. We can approach this problem
    in two ways: by portioning the CMake code and by moving the source files to subdirectories.
    In both cases, we aim to follow the design principle called **separation of concerns**.
    Put simply, break your code into chunks, grouping code with closely related functionality
    while decoupling other pieces of code to create strong boundaries.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的解决方案在行数和文件数量上的增长，我们逐渐意识到不可避免的事情即将发生：要么我们开始分区项目，要么我们淹没在代码行和众多文件中。我们可以用两种方法来解决这个问题：通过分区CMake代码，或将源文件移动到子目录中。在这两种情况下，我们都旨在遵循一个称为**关注点分离**的设计原则。简单来说，就是将代码分成块，将具有紧密相关功能的代码分组，同时将其他代码片段解耦，以创建强大的边界。
- en: We talked a bit about partitioning CMake code when discussing listfiles in [*Chapter
    1*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014), *First Steps with CMake*.
    We spoke about the `include()` command, which allows CMake to execute the code
    from an external file. Calling `include()` doesn't introduce any scopes or isolations
    that are not defined within the file (if the included file contains functions,
    their scope will be handled correctly upon calling).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014)《CMake的初步步骤》中讨论列表文件时，我们稍微提到了分区CMake代码。我们讨论了`include()`命令，该命令允许CMake执行来自外部文件的代码。调用`include()`不会引入任何未在文件中定义的作用域或隔离（如果包含的文件包含函数，那么在调用时它们的作用域将会被正确处理）。
- en: This method helps with separation of concerns, but only a little – specialized
    code is extracted to separate files and can even be shared across unrelated projects,
    but it can still pollute the global variable scope with its internal logic if
    the author is not careful. An old truth in programming is that *even the worst
    mechanism is better than the best intentions*. We'll learn how to deal with this
    problem in a second, but for now, let's shift our focus to source code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有助于关注点的分离，但效果有限——专用代码被提取到单独的文件中，甚至可以跨不相关的项目共享，但如果作者不小心，它仍然可能会用其内部逻辑污染全局变量作用域。编程中的一个古老真理是，*即使是最糟糕的机制也比最好的意图好*。我们将在后面学习如何解决这个问题，但现在，让我们将重点转移到源代码上。
- en: 'Let''s consider an example of software that supports a small car rental company
    – it will have many source files defining different aspects of the software: managing
    customers, cars, parking spots, long-term contracts, maintenance records, employee
    records, and so on. If we were to put all of these files in a single directory,
    finding anything would be a nightmare. Therefore, we create a number of directories
    in the main directory of our project and move the related files inside it. Our
    `CMakeLists.txt` file might look similar to this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个支持小型汽车租赁公司的软件示例——它将有很多源文件，定义软件的不同方面：管理客户、车辆、停车位、长期合同、维护记录、员工记录等等。如果我们把这些文件都放在一个单一的目录中，找到任何东西都将是一场噩梦。因此，我们在项目的主目录中创建多个目录，并将相关文件移入其中。我们的`CMakeLists.txt`文件可能看起来像这样：
- en: chapter03/01-partition/CMakeLists.txt
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第三章/01-partition/CMakeLists.txt
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That''s all great, but as you can see, we still have the list of source files
    from the nested directory in a top-level file! To increase the separation of concerns,
    we could put the list of sources in another listfile and use the aforementioned
    `include()` command with a `cars_sources` variable, like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但正如您所看到的，我们仍然在顶层文件中包含了嵌套目录的源文件列表！为了增加关注点的分离，我们可以将源文件列表放在另一个列表文件中，并使用前述的`include()`命令和`cars_sources`变量，像这样：
- en: chapter03/02-include/CMakeLists.txt
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第三章/02-include/CMakeLists.txt
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The new nested listfile would contain the sources:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 新的嵌套列表文件将包含以下源文件：
- en: chapter03/02-include/cars/cars.cmake
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第三章/02-include/cars/cars.cmake
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'CMake would effectively set `cars_sources` in the same scope as `add_executable`,
    filling the variable with all of the files. This solution works, but it has a
    few flaws:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: CMake将有效地在`add_executable`相同的范围内设置`cars_sources`，用所有文件填充该变量。这个解决方案可行，但它有几个缺点：
- en: '**The variables from the nested directory will pollute the top-level scope
    (and vice versa)**:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套目录中的变量将污染顶层作用域（反之亦然）**：'
- en: While it's not an issue in a simple example, in more complex, multi-level trees
    with multiple variables used in the process, it can quickly become a hard-to-debug
    problem.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的示例中这不是问题，但在更复杂的多级树结构中，存在多个变量在过程中使用，它可能很快变得难以调试。
- en: '**All of the directories will share the same configuration**:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有目录将共享相同的配置**：'
- en: This issue shows its true colors as projects mature over the years. Without
    any granularity, we have to treat every translation unit the same, and we cannot
    specify different compilation flags, choose a newer language version for some
    parts of the code, and silence warnings in chosen areas of the code. Everything
    is global, meaning that we need to introduce changes to all of the source files
    at the same time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在项目随时间成熟的过程中显示了其真实面目。由于没有任何粒度，我们必须对每个翻译单元一视同仁，无法指定不同的编译标志，为代码的某些部分选择更新的语言版本，以及在代码的特定区域静默警告。一切都是全局的，这意味着我们需要同时对所有源文件引入更改。
- en: '**There are shared compilation triggers**:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存在共享编译触发器**：'
- en: Any changes to the configuration will mean that all of the files will have to
    be recompiled, even if the change is meaningless for some of them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 配置的任何更改都意味着所有文件都将需要重新编译，即使更改对其中一些文件来说毫无意义。
- en: '**All of the paths are relative to the top-level**:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有路径都是相对于顶层而言的**：'
- en: Note that in `cars.cmake`, we had to provide a full path to the `cars/car.cpp`
    file. This results in a lot of repeated text ruining the readability and going
    against the **Don't Repeat Yourself** (**DRY**) principle of clean coding. Renaming
    a directory would be a struggle.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`cars.cmake`中，我们不得不提供`cars/car.cpp`文件的全路径。这导致很多重复的文本破坏了可读性，违反了**不要重复自己**（**DRY**）的清洁编码原则。重命名目录将是一场斗争。
- en: The alternative is to use the `add_subdirectory()` command, which introduces
    a variable scope and more. Let's take a look.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`add_subdirectory()`命令，它引入了变量作用域等。让我们来看看。
- en: Scoped subdirectories
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域子目录
- en: 'It''s a common practice to structure your project following the natural structure
    of the filesystem, where nested directories represent the discrete elements of
    the application: the business logic, GUI, API, and reporting, and finally, separate
    directories with tests, external dependencies, scripts, and documentation. To
    support this concept, CMake offers the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的做法是按照文件系统的自然结构来组织项目，其中嵌套目录表示应用程序的离散元素：业务逻辑、GUI、API和报告，最后，单独的目录包含测试、外部依赖、脚本和文档。为了支持这个概念，CMake提供了以下命令：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As already established, this adds a source directory to our build. Optionally,
    we may provide a path in which built files will be written (`binary_dir`). The
    `EXCLUDE_FROM_ALL` keyword will disable the default building of targets defined
    in the subdirectory (we'll cover *targets* in the next chapter). This may be useful
    for separating parts of the project that aren't needed for the core functionality
    (for example, *examples* and *extensions*).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这将为我们的构建添加一个源目录。可选地，我们可以提供一个路径，其中将生成文件（`binary_dir`）。`EXCLUDE_FROM_ALL`关键字将禁用子目录中定义的目标的默认构建（我们将在下一章讨论*目标*）。这对于分离不需要核心功能的项目的部分（例如*示例*和*扩展*）可能很有用。
- en: 'This command will look for a `CMakeLists.txt` file in the `source_dir` path
    (evaluated relative to the current directory). This file will then be parsed in
    the directory scope, meaning that all the flaws mentioned in the previous method
    aren''t present:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在`source_dir`路径（相对于当前目录评估）中寻找一个`CMakeLists.txt`文件。然后在该目录作用域中解析该文件，意味着前面方法中提到的所有缺陷都不存在：
- en: Variable changes are isolated to the nested scope.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量更改被限制在嵌套作用域内。
- en: You're free to configure the nested artifacts however you like.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以自由地以任何喜欢的方式配置嵌套的艺术品。
- en: Changing the nested `CMakeLists.txt` file doesn't require building unrelated
    targets.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改嵌套的`CMakeLists.txt`文件不需要构建无关的目标。
- en: Paths are local to the directory, and they can even be added to the parent *include
    path* if desired.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径仅限于目录本地，如果需要，它们甚至可以添加到父级*包含路径*中。
- en: 'Let''s take a look at a project with `add_subdirectory()`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用`add_subdirectory()`的项目：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we have two `CMakeLists.txt` files. The top-level file will use the nested
    directory, `cars`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有两个`CMakeLists.txt`文件。顶层文件将使用嵌套目录`cars`：
- en: chapter03/02-add_subdirectory/CMakeLists.txt
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03/02-add_subdirectory/CMakeLists.txt
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last line is used to link the artifacts from the `cars` directory to the
    `Rental` executable. It is a target-specific command, which we''ll discuss in
    depth in the next chapter. Let''s see what the nested listfile looks like:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行用于将来自`cars`目录的艺术品链接到`Rental`可执行文件。这是一个目标特定的命令，我们将在下一章深入讨论。让我们看看嵌套列表文件看起来如何：
- en: chapter03/02-add_subdirectory/cars/CMakeLists.txt
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03/02-add_subdirectory/cars/CMakeLists.txt
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, I have used `add_library()` to produce a globally visible target,
    `cars`, and added the `cars` directory to its public *include directories* with
    `target_include_directories()`. This allows `main.cpp` to include the `cars.h`
    file without providing a relative path:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我使用`add_library()`来生成一个全局可见的目标`cars`，并使用`target_include_directories()`将其添加到其公共*包含目录*中。这允许`main.cpp`不提供相对路径即可包含`cars.h`文件：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see the `add_library()` command in the nested listfile, so did we start
    working with libraries in this example? Actually, no. Since we used the `OBJECT`
    keyword, we're indicating we're only interested in producing the *object files*
    (exactly as we did in the previous example). We just grouped them under a single
    logical target (`cars`). You may already have a sense of what a *target* is. Hold
    that thought – we'll get there in a second.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在嵌套列表文件中看到`add_library()`命令，所以我们是在这个例子中开始使用库了吗？实际上，不是。由于我们使用了`OBJECT`关键字，我们表明我们只对生成*对象文件*感兴趣（与上一个例子完全一样）。我们只是将它们分组在一个逻辑目标（`cars`）下。您可能已经对*目标*有一个大致的了解。暂时保留那个想法——我们马上就会讨论到。
- en: Nested projects
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套项目
- en: In the previous section, we briefly mentioned the `EXCLUDE_FROM_ALL` argument
    used in the `add_subdirectory()` command. The CMake documentation suggests that
    if we have such parts living inside the source tree, they should have their own
    `project()` commands in their `CMakeLists.txt` files so that they can generate
    their own buildsystems and can be built independently.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们简要提到了 `add_subdirectory()` 命令中使用的 `EXCLUDE_FROM_ALL` 参数。CMake 文档建议，如果我们有这样的部分存在于源树中，它们在自己的
    `CMakeLists.txt` 文件中应该有自己的 `project()` 命令，这样它们就可以生成自己的构建系统，并且可以独立构建。
- en: Are there any other scenarios where this would be useful? Sure. For example,
    one scenario would be when you're working with multiple C++ projects built in
    one **CI**/**CD** pipeline (perhaps when building a framework or a set of libraries).
    Alternatively, maybe you're porting the buildsystem from a legacy solution, such
    as GNU Make, which uses plain **makefiles**. In such a case, you might want an
    option to slowly break things down into more independent pieces – possibly to
    put them in a separate build pipeline, or just to work on a smaller scope, which
    could be loaded by an IDE such as **CLion**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他哪些场景会用到这个功能呢？当然。例如，一个场景是当你在一个 **CI**/**CD** 管道中构建多个 C++ 项目（也许是在构建框架或一系列库时）。另一种情况可能是，你可能正在从遗留解决方案（如
    GNU Make）中移植构建系统，该解决方案使用普通的 **makefiles**。在这种情况下，你可能需要一个选项，逐步将事物分解成更独立的单元——可能要把它们放在单独的构建管道中，或者只是为了在一个更小的范围内工作，这可以被如
    **CLion** 这样的 IDE 加载。
- en: You can achieve that by adding the `project()` command to the listfile in the
    nested directory. Just don't forget to prepend it with `cmake_minimum_required()`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在嵌套目录中的 listfile 添加 `project()` 命令来实现。只是不要忘记用 `cmake_minimum_required()`
    它前缀。
- en: Since project nesting is supported, could we somehow connect related projects
    that are built side by side?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于支持项目嵌套，我们能否 somehow 连接并排构建的相关项目？
- en: External projects
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部项目
- en: 'It is technically possible to reach from one project to another, and CMake
    will support that to some extent. There''s even a `load_cache()` command that
    allows you to load values from another project''s cache. That said, this isn''t
    a regular or a recommended use case, and it will lead to issues with cyclical
    dependencies and project coupling. It''s best to avoid this command and make a
    decision: should our related projects be nested, connected through libraries,
    or merged into a single project?'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上可以从一个项目到达另一个项目，CMake 也在一定程度上支持这一点。甚至还有一个 `load_cache()` 命令，允许你从另一个项目的缓存中加载值。话说回来，这并不是一个常规或推荐的使用场景，它会导致循环依赖和项目耦合的问题。最好避免使用这个命令，并做出决定：我们的相关项目应该嵌套、通过库连接，还是合并成一个项目？
- en: 'These are the partitioning tools at our disposal: *including listfiles*, *adding
    subdirectories*, and *nesting projects*. But how should we use them so our projects
    stay maintainable and easy to navigate and extend? To do this, we need a well-defined
    project structure.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们可用的分区工具：*包括 listfiles*、*添加子目录*和*嵌套项目*。但我们应该如何使用它们，使我们的项目保持可维护性、易于导航和扩展？为了实现这一点，我们需要一个定义良好的项目结构。
- en: Thinking about the project structure
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思考项目结构
- en: It's no secret that as a project grows, it becomes harder and harder to find
    things in it – both in listfiles and in the source code. Therefore, it is very
    important to maintain the project hygiene right from the get-go.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，随着项目增长，在 listfiles 和源代码中找到东西变得越来越难。因此，从一开始就保持项目卫生非常重要。
- en: Imagine a scenario where you need to deliver some important, time-sensitive
    changes, and they don't fit well in either of the two directories in your project.
    Now, you need to quickly push a *cleanup commit* that introduces more directories
    and another level of hierarchy for your files so that your changes can have a
    nice place to fit. Or (what's worse), you decide to just shove them anywhere and
    create a ticket to deal with the issue later.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，你需要交付一些重要、时间敏感的更改，它们不适合你的项目中的两个目录之一。现在，你需要快速推送一个 *cleanup commit* ，引入更多的目录和另一层文件层次结构，以便你的更改有一个好的地方放置。或者（更糟糕的是），你决定只是把它们推到任何地方，并创建一个票证稍后处理问题。
- en: Over the course of the year, these tickets accumulate, the technical debt grows,
    and so does the cost of maintaining the code. This becomes extremely troublesome
    when there's a crippling bug in a live system that needs a quick fix and when
    people unfamiliar with the code base need to introduce their changes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个一年中，这些工单积累，技术债务增长，维护代码的成本也在增加。当需要快速修复现场系统的严重错误，且不熟悉代码库的人需要引入他们的更改时，这变得极其麻烦。
- en: 'So, we need a good project structure. But what does this mean? There are a
    few rules that we can borrow from other areas of software development (for example,
    system design). The project should have the following characteristics:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们需要一个好的项目结构。但这意味着什么？我们可以从软件开发的其他领域（例如，系统设计）借鉴几条规则。项目应该具有以下特征：
- en: It should be easy to navigate and extend.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该易于导航和扩展。
- en: It should be self-contained – for example, project-specific files should be
    in the project directory and nowhere else.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是自包含的——例如，项目特定的文件应该在项目目录中，而不应该在其他地方。
- en: The abstraction hierarchy should be expressed through executables and binaries.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象层次应该通过可执行文件和二进制文件来表达。
- en: 'There is no single agreed-upon solution, but among the many available project
    structure templates online, I recommend following this one, as it is simple and
    very extensible:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种单一公认的解决方案，但在网上可用的众多项目结构模板中，我建议遵循这个模板，因为它简单且非常可扩展：
- en: '![ Figure 3.1 – An example of a project structure'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.1 – 项目结构示例'
- en: '](img/Figure_3.1.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.1.jpg)'
- en: Figure 3.1 – An example of a project structure
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 项目结构示例
- en: 'This project outlines the directories for the following components:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目概述了以下组件的目录结构：
- en: '`cmake`: Includes macros and functions, find_modules, and one-off scripts'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake`：包括宏和函数、find_modules 以及一次性脚本'
- en: '`src`: Will store the source of our binaries and libraries'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：将存储我们的二进制文件和库的源代码'
- en: '`doc`: Used for building the documentation'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doc`：用于构建文档'
- en: '`extern`: Configuration for the external projects we are building from source'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extern`：我们从中源代码构建的外部项目的配置'
- en: '`test`: Contains code for automated tests'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`：包含自动化测试的代码'
- en: 'In this structure, the `CMakeLists.txt` file should exist in the following
    directories: the top-level project directory, `src`, `doc`, `extern`, and `test`.
    The main listfile shouldn''t declare any build steps on its own, but instead,
    it should use the `add_subdirectory()` command to execute all of the listfiles
    in the nested directories. In turn, these may delegate this work to even deeper
    layers if needed.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种结构中，`CMakeLists.txt` 文件应该存在于以下目录中：顶级项目目录、`src`、`doc`、`extern` 和 `test`。主列表文件不应该声明任何自身的构建步骤，而是应该使用
    `add_subdirectory()` 命令来执行嵌套目录中的所有列表文件。如果有需要，这些还可以将这项工作委托给更深层次的目录。
- en: Note
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some developers suggest separating the executables from the libraries and creating
    two top-level directories instead of one: `src` and `lib`. CMake treats both artifacts
    the same, and separation at this level doesn''t really matter.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者建议将可执行文件与库分开，创建两个顶级目录（`src` 和 `lib`），而不是一个。CMake 将这两种工件同等对待，在这种层次上进行分离并不真正重要。
- en: Having multiple directories in the `src` directory comes in handy for bigger
    projects. But if you're building just a single executable or library, you may
    skip them and store your source files directly in `src`. In any case, remember
    to add a `CMakeLists.txt` file there and execute any nested listfiles as well.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `src` 目录中有多个目录对于大型项目来说非常有用。但如果你只是构建一个可执行文件或库，你可以跳过它们，并将源文件直接存储在 `src` 中。无论如何，记得在那里添加一个
    `CMakeLists.txt` 文件，并执行任何嵌套的列表文件。
- en: 'This is how your file tree might look for a single target:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标文件树可能看起来是这样的：
- en: '![Figure 3.2 – The directory structure of an executable'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.2 – 可执行文件的目录结构'
- en: '](img/Figure_3.2.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.2.jpg)'
- en: Figure 3.2 – The directory structure of an executable
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 可执行文件的目录结构
- en: 'We see a `CMakeLists.txt` file in the root of the `app1` directory – it will
    configure the key project settings and include all listfiles from nested directories.
    The `src` directory contains another `CMakeLists.txt` file along with the `.cpp`
    implementation files: two classes and the main file with the executable''s entry
    point. The `CMakeLists.txt` file should define a target that uses these sources
    to build an executable – we''ll learn how to do that in the next chapter.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`app1`目录的根目录中看到一个`CMakeLists.txt`文件——它将配置关键的项目设置并包括嵌套目录中的所有列表文件。`src`目录包含另一个`CMakeLists.txt`文件以及`.cpp`实现文件：两个类和带有可执行程序入口点的主文件。`CMakeLists.txt`文件应该定义一个目标，使用这些源文件构建一个可执行文件——我们将在下一章学习如何做到这一点。
- en: Our header files go to the `include` directory – these are used by `.cpp` implementation
    files to declare symbols from other C++ translation units.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的头文件放在`include`目录中——这些文件被`.cpp`实现文件用来声明来自其他C++翻译单元的符号。
- en: We have a `test` directory to store the source code for our automated tests,
    and we also have `lib3`, which contains a library specific to this executable
    only (libraries used elsewhere in the project or exported outside of it should
    live in the `src` directory).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`test`目录来存储自动化测试的源代码，我们还有`lib3`，它包含了一个只针对这个可执行文件的库（项目其他地方使用的库或导出到项目外的库应该放在`src`目录中）。
- en: 'This structure is pretty expressive and allows for many extensions of the project.
    As we keep adding more and more classes, we can easily group them in libraries
    to speed up the compilation process. Let''s see what a library looks like:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构非常具有表现力，并允许项目的许多扩展。随着我们不断添加更多的类，我们可以很容易地将它们分组到库中，以加快编译过程。让我们看看库的样子：
- en: '![Figure 3.3 – The directory structure of a library'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 – 库的目录结构](img/Figure_3.3.jpg)'
- en: '](img/Figure_3.3.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.4.jpg)'
- en: Figure 3.3 – The directory structure of a library
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 库的目录结构
- en: 'As it turns out, libraries follow the same structure as executables, with only
    a small difference: there is an optional `lib3` directory in the `include` directory.
    This should only be present if we use the library externally from the project.
    It provides the public header files that other projects will consume during compilation.
    We''ll return to this subject when we start building our own libraries in [*Chapter
    5*](B17205_05_Final_JC_ePub.xhtml#_idTextAnchor126)*,* *Compiling C++ Sources
    with CMake*.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明，库遵循与可执行文件相同的结构，只有一个小的区别：在`include`目录中有一个可选的`lib3`目录。只有当我们从项目中外部使用库时，这个目录才应该存在。它提供了其他项目在编译时将消耗的公共头文件。我们将在[第5章](B17205_05_Final_JC_ePub.xhtml#_idTextAnchor126)*，*使用CMake编译C++源代码*中回到这个主题，构建我们自己的库。
- en: So, we have discussed how files are laid out in a directory structure. Now,
    it's time to take a look at how individual `CMakeFiles.txt` files come together
    to form a single project and what their role is in a bigger scenario.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经讨论了文件是如何布局在目录结构中的。现在，是时候看看单独的`CMakeFiles.txt`文件是如何组合成一个项目的，以及它们在大场景中的作用。
- en: '![Figure 3.4 – How CMake merges listfiles together in a single project'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – CMake如何将列表文件合并到一个项目中'
- en: '](img/Figure_3.4.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.4.jpg)'
- en: Figure 3.4 – How CMake merges listfiles together in a single project
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – CMake如何将列表文件合并到一个项目中
- en: 'In *Figure 3.4*, each box represents a `CMakeLists.txt` listfile residing in
    a given directory, while the labels in cursive text represent the actions executed
    by each file (from top to bottom). Let''s analyze this project once more from
    CMake''s perspective:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图3.4*中，每个框代表了一个位于特定目录中的`CMakeLists.txt`文件列表，而草体字中的标签代表了每个文件执行的动作（从上到下）。让我们从CMake的角度再次分析这个项目：
- en: The execution starts from the root of the project – that is, from a listfile
    residing in the source tree. This file will set the minimum required CMake version
    with the appropriate policies, set the project name, supported languages, global
    variables, and include the files from the `cmake` directory so that their contents
    are available globally.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行从项目的根开始——也就是说，从源树中的一个列表文件开始。这个文件将设置所需的最小CMake版本和相应的策略，设置项目名称，支持的语言，全局变量，并包括来自`cmake`目录的文件，以便它们的内容在全局范围内可用。
- en: The next step is to enter the scope of the `src` directory by calling the `add_subdirectory(src
    bin)` command (we'd like to put compiled artifacts in `<binary_tree>/bin` rather
    than `<binary_tree>/src`).
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是进入`src`目录的作用域，通过调用`add_subdirectory(src bin)`命令（我们想将编译后的工件放在`<binary_tree>/bin`中，而不是`<binary_tree>/src`）。
- en: 'CMake reads the `src/CMakeLists.txt` file and discovers that its only purpose
    is to add four nested subdirectories: `app1`, `app2`, `lib1`, and `lib2`.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake 读取 `src/CMakeLists.txt` 文件并发现它的唯一目的是添加四个嵌套子目录：`app1`、`app2`、`lib1` 和 `lib2`。
- en: CMake enters the variable scope of `app1` and learns about another nested library,
    `lib3`, which has its own `CMakeLists.txt` file; then the scope of `lib3` is entered.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake 进入了 `app1` 的变量作用域，并了解了一个嵌套库 `lib3`，该库拥有自己的 `CMakeLists.txt` 文件；然后进入了 `lib3`
    的作用域。
- en: The `lib3` library adds a static library target with the same name. CMake returns
    to the parent scope of `app1`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lib3` 库添加了一个与名称相同的静态库目标。CMake 返回 `app1` 的父作用域。'
- en: The `app1` subdirectory adds an executable that depends on `lib3`. CMake returns
    to the parent scope of `src`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`app1` 子目录添加了一个依赖于 `lib3` 的可执行文件。CMake 返回 `src` 的父作用域。'
- en: CMake will continue entering the remaining nested scopes and executing their
    listfiles until all `add_subdirectory()` invocations have been completed.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake 将继续进入剩余的嵌套作用域并执行它们的列表文件，直到所有 `add_subdirectory()` 调用完成。
- en: 'CMake returns to the top-level scope and executes three remaining commands:
    `add_subdirectory(doc)`, `add_subdirectory(extern)`, and `add_subdirectory(test)`.
    Each time, CMake enters the new scope and executes commands from the appropriate
    listfile.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CMake 返回顶层作用域并执行剩余的三个命令：`add_subdirectory(doc)`、`add_subdirectory(extern)` 和
    `add_subdirectory(test)`。每次，CMake 进入新的作用域并从相应的列表文件中执行命令。
- en: All of the targets are collected and checked for their correctness. CMake now
    has all of the necessary information to generate a buildsystem.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有目标都被收集并检查其正确性。CMake 现在拥有生成构建系统的所有必要信息。
- en: We need to remember that the preceding steps are happening in the exact order
    in which we wrote the commands in our listfiles. Sometimes this matters, while
    other times, not so much. We'll get to the bottom of that in the next chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，前面的步骤是按照我们编写命令的准确顺序发生的。有时这很重要，而其他时候，则不那么重要。我们在下一章解决这个问题。
- en: So, when is the right time to create the directories to contain all of the elements
    of the project? Should we do it right from the start – create everything needed
    for the future and keep the directories empty – or wait until we actually have
    the files that need to go in their own category? This is a choice – we could follow
    the extreme-programming rule **YAGNI** (**you aren't gonna need it**), or we could
    try to make our project future-proof and lay good foundations for new developers
    to come.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，创建包含项目所有元素的目录的正确时机是什么时候呢？我们应该从一开始就创建未来所需的一切并保持目录空空如也，还是等到我们实际上需要放入其自己类别的文件时再做呢？这是一个选择——我们可以遵循极端编程规则
    **YAGNI**（**你不需要它**），或者我们可以尝试使我们的项目具有未来性，并为即将到来的新开发者打下良好的基础。
- en: 'Try to aim for a good balance between these approaches – if you suspect that
    your project might one day need an `extern` directory, then add it (you may need
    to create an empty `.keep` file to check a directory into the repository). To
    help others know where to put their external dependencies, create a `readme` file,
    and lay the path for less experienced programmers who will travel this road in
    the future. You may have observed this yourself: developers are reluctant to create
    directories, especially in the root of the project. If we provide a good project
    structure, people will be inclined to follow it.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在這些方法之间寻求良好的平衡——如果你怀疑你的项目可能有一天需要一个 `extern` 目录，那么添加它（你可能需要创建一个空白的 `.keep`
    文件以将目录检入仓库）。为了帮助其他人知道将他们的外部依赖项放在哪里，创建一个 `readme` 文件，为未来踏上这条道路的 less 经验丰富的程序员铺平道路。你自己可能已经注意到了这一点：开发者不愿意创建目录，尤其是在项目的根目录中。如果我们提供一个好的项目结构，人们倾向于遵循它。
- en: Some projects can be built in almost every environment, while others are quite
    particular about their specifics. The top-level listfile is the perfect place
    to assess how to proceed with the project, depending on what is available. Let's
    see how to do this.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目可以在几乎所有的环境中构建，而其他项目则非常关注它们的特定环境。顶层列表文件是评估如何进行项目的最佳位置，取决于有什么可用。让我们来看看如何做到这一点。
- en: Scoping the environment
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境作用域
- en: CMake provides multiple ways of querying the environment with `CMAKE_` variables,
    `ENV` variables, and special commands. For example, collected information can
    be used to support cross-platform scripts. These mechanisms allow us to avoid
    using platform-specific shell commands that may not be easily portable or differ
    in naming across environments.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: CMake提供了多种查询环境的方法，使用`CMAKE_`变量、`ENV`变量和特殊命令。例如，收集的信息可以用来支持跨平台脚本。这些机制允许我们避免使用可能不易移植或在不同环境中命名不同的平台特定shell命令。
- en: For performance-critical applications, it will be useful to know all the features
    of the destination platform (for example, instruction sets, CPU core count, and
    more). This information can then be passed to the compiled binaries so that they
    can be tuned to perfection (we'll learn how to do that in the next chapter). Let's
    see what information is available in CMake natively.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于性能关键的应用程序，了解目标平台的所有特性（例如，指令集、CPU核心数等）将很有用。然后可以将这些信息传递给编译后的二进制文件，以便它们可以被完美地调整（我们将在下一章学习如何做到这一点）。看看CMake中
    native 提供了哪些信息。
- en: Discovering the operating system
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现操作系统
- en: There are many occasions when it is useful to know what the target operating
    system is. Even as mundane a thing as a filesystem differs greatly between Windows
    and Unix in things such as case sensitivity, file path structures, the presence
    of extensions, privileges, and so on. Most commands present on one system won't
    be available on another, or they could be named differently (even if it's by a
    single letter – for example, the `ifconfig` and `ipconfig` commands).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多场合知道目标操作系统是有用的。即使是像文件系统这样平凡的东西，在Windows和Unix之间也有很大的不同，比如大小写敏感性、文件路径结构、扩展名的存在、权限等。在一个系统上大多数命令在另一个系统上可能不可用，或者它们可能命名不同（即使只是一个字母——例如，`ifconfig`和`ipconfig`命令）。
- en: 'If you ever need to support multiple target operating systems with a single
    CMake script, just check the `CMAKE_SYSTEM_NAME` variable so that you can act
    accordingly. Here''s a simple example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要用一个CMake脚本支持多个目标操作系统，只需检查`CMAKE_SYSTEM_NAME`变量，以便你可以相应地采取行动。这是一个简单的例子：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If needed, there''s a variable containing the operating system version: `CMAKE_SYSTEM_VERSION`.
    However, my recommendation is to try and make your solutions as system-agnostic
    as possible and use the built-in CMake cross-platform functionality. Especially
    for operations on filesystems, you should use the `file()` command described in
    the *Appendix* section.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，有一个包含操作系统版本的变量：`CMAKE_SYSTEM_VERSION`。然而，我的建议是尽量使你的解决方案尽可能系统无关，并使用内置的CMake跨平台功能。特别是在操作文件系统时，你应该使用*附录*部分描述的`file()`命令。
- en: Cross-compilation – what are host and target systems?
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交叉编译——什么是宿主和目标系统？
- en: Compiling code on one machine to be run on another is called *cross-compilation*.
    You can (with the right toolset) compile applications for Android by running CMake
    on a Windows machine. Cross-compilation isn't in the scope of this book, but it's
    important to understand how it impacts some parts of CMake.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在一台机器上编译代码，然后在另一台机器上运行，这被称为*交叉编译*。你可以（使用正确的工具集）在Windows机器上运行CMake来为Android编译应用程序。交叉编译不在本书的范围内，但了解它如何影响CMake的某些部分是非常重要的。
- en: One of the necessary steps to allow cross-compilation is setting the `CMAKE_SYSTEM_NAME`
    and `CMAKE_SYSTEM_VERSION` variables to the values appropriate for the operating
    system that you're compiling for targets (the CMake documentation refers to it
    as the **target system**). The operating system used to perform the build is called
    a **host system**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 允许交叉编译的必要步骤之一是将`CMAKE_SYSTEM_NAME`和`CMAKE_SYSTEM_VERSION`变量设置为目标操作系统（CMake文档中将其称为**目标系统**）的适当值。用于执行构建的操作系统称为**宿主系统**。
- en: 'Regardless of the configuration, the information on the host system is always
    accessible in variables with a `HOST` keyword in their name: `CMAKE_HOST_SYSTEM`,
    `CMAKE_HOST_SYSTEM_NAME`, `CMAKE_HOST_SYSTEM_PROCESSOR`, and `CMAKE_HOST_SYSTEM_VERSION`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 无论配置如何，宿主系统上的信息总是可以通过带有`HOST`关键词的变量访问：`CMAKE_HOST_SYSTEM`、`CMAKE_HOST_SYSTEM_NAME`、`CMAKE_HOST_SYSTEM_PROCESSOR`和`CMAKE_HOST_SYSTEM_VERSION`。
- en: There are a few more variables with a `HOST` keyword in their name, so just
    keep in mind that they're explicitly referencing the host system. Otherwise, all
    variables reference the target system (which normally is the host system anyway,
    unless we're cross-compiling).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些变量在其名称中带有`HOST`关键字，所以只需记住它们明确地引用了宿主系统。否则，所有变量都引用目标系统（通常是宿主系统，除非我们进行交叉编译）。
- en: If you're interested in reading more about cross-compilation, I suggest referencing
    the CMake documentation at [https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html](https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对交叉编译感兴趣，我建议参考CMake文档在[https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html](https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html)。
- en: Abbreviated variables
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩写变量
- en: 'CMake will predefine a few variables that will provide information about the
    host and target systems. If a specific system is used, an appropriate variable
    will be set to a non-false value (that is, `1` or `true`):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: CMake将预定义一些变量，提供关于宿主和目标系统的信息。如果使用特定的系统，相应的变量将被设置为非假值（即`1`或`true`）：
- en: '`ANDROID`, `APPLE`, `CYGWIN`, `UNIX`, `IOS`, `WIN32`, `WINCE`, `WINDOWS_PHONE`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANDROID`, `APPLE`, `CYGWIN`, `UNIX`, `IOS`, `WIN32`, `WINCE`, `WINDOWS_PHONE`'
- en: '`CMAKE_HOST_APPLE`, `CMAKE_HOST_SOLARIS`, `CMAKE_HOST_UNIX`, `CMAKE_HOST_WIN32`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_HOST_APPLE`, `CMAKE_HOST_SOLARIS`, `CMAKE_HOST_UNIX`, `CMAKE_HOST_WIN32`'
- en: The `WIN32` and `CMAKE_HOST_WIN32` variables will be `true` for 32- and 64-bit
    versions of Windows and MSYS (this value is kept for legacy reasons). Also, `UNIX`
    will be `true` for Linux, macOS, and Cygwin.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`WIN32`和`CMAKE_HOST_WIN32`变量对于32位和64位的Windows和MSYS版本以及为了遗留原因而保持为真。另外，`UNIX`对于Linux、macOS和Cygwin也为真。'
- en: Host system information
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宿主系统信息
- en: 'CMake could provide more variables, but to save time, it doesn''t query the
    environment for rarely needed information, such as *whether a processor supports
    MMX* or *what the total physical memory is*. That doesn''t mean this information
    isn''t available – you just need to ask for it explicitly with the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: CMake可以提供更多的变量，但为了节省时间，它不查询环境中的罕见信息，例如*处理器是否支持MMX*或*总物理内存是多少*。这并不意味着这些信息不可用——你只需要通过以下命令显式地请求它：
- en: '`cmake_host_system_information(RESULT <VARIABLE> QUERY <KEY>…)`'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmake_host_system_information(RESULT <VARIABLE> QUERY <KEY>…)`'
- en: 'We need to provide a target variable and a list of keys we''re interested in.
    If we provide just one key, the variable will contain a single value; otherwise,
    it will be a list of values. We can ask for many details about the environment
    and the OS:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供一个目标变量和我们要关注的键列表。如果我们只提供一个键，变量将包含一个值；否则，它将是一组值。我们可以询问许多关于环境和操作系统的详细信息：
- en: '![](img/table_01.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/table_01.jpg)'
- en: 'If needed, we can even query processor-specific information:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们甚至可以查询处理器特定信息：
- en: '![](img/table_02.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/table_02.jpg)'
- en: Does the platform have 32-bit or 64-bit architecture?
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台是否有32位或64位架构？
- en: In 64-bit architecture, memory addresses, processor registers, processor instructions,
    address busses, and data buses are 64 bits wide. While this is a simplified definition,
    it gives a rough idea of how 64-bit platforms are different from 32-bit platforms.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在64位架构中，内存地址、处理器寄存器、处理器指令、地址总线和数据总线都是64位的。虽然这是一个简化的定义，但它给出了64位平台与32位平台有何不同的粗略概念。
- en: 'In C++, different architectures mean different bit widths for some fundamental
    data types (`int` and `long`) and pointers. CMake utilizes the pointer size to
    gather information about the target machine. This information is available through
    the `CMAKE_SIZEOF_VOID_P` variable, and it will contain a value of `8` for 64
    bits (because a pointer is 8 bytes wide) and `4` for 32 bits (4 bytes):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，不同的架构意味着一些基本数据类型（`int`和`long`）和指针有不同的位宽。CMake利用指针大小来收集目标机器的信息。通过`CMAKE_SIZEOF_VOID_P`变量可获得此信息，对于64位该值为`8`（因为指针是8字节宽）和对于32位该值为`4`（4字节）：
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What is the endianness of the system?
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统的字节序是什么？
- en: Architectures can be **big-endian** or **little-endian**. **Endianness** is
    the order of bytes in a **word** or the natural unit of data for a processor.
    A big-endian system stores the most significant byte at the lowest memory address
    and the least significant byte at the highest memory address. A little-endian
    system is the opposite of this.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 架构可以是**大端**或**小端**。**字节序**是数据字中的字节顺序或处理器的自然数据单位。一个大端系统将最高有效字节存储在最低的内存地址，最低有效字节存储在最高的内存地址。一个小端系统与此相反。
- en: In most cases, endianness doesn't matter, but when you're writing bit-wise code
    that needs to be portable, CMake will provide you with a `BIG_ENDIAN` or `LITTLE_ENDIAN`
    value stored in the `CMAKE_<LANG>_BYTE_ORDER` variable, where `<LANG>` is `C`,
    `CXX`, `OBJC`, or `CUDA`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，字节顺序不影响，但当你编写需要可移植的位操作代码时，CMake 将提供 `BIG_ENDIAN` 或 `LITTLE_ENDIAN` 值，存储在
    `CMAKE_<LANG>_BYTE_ORDER` 变量中，其中 `<LANG>` 是 `C`、`CXX`、`OBJC` 或 `CUDA`。
- en: Now that we know how to query the environment, let's shift our focus to the
    key settings of the project.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何查询环境，让我们将重点转移到项目的主要设置上。
- en: Configuring the toolchain
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置工具链
- en: For CMake projects, a toolchain consists of all of the tools used in building
    and running the application – for example, the working environment, the generator,
    the CMake executable itself, and the compilers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 CMake 项目，工具链包括构建和运行应用程序的所有工具——例如，工作环境、生成器、CMake 执行文件本身以及编译器。
- en: Imagine what a less-experienced user feels when your build stops with some mysterious
    compilation and syntax errors. They have to dig into the source code and try to
    understand what happened. After an hour of debugging, they discover that the correct
    solution is to update their compiler. Could we provide a better experience for
    users and check if all of the required functions are present in the compiler before
    starting the build?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下一个经验较少的使用者在构建过程中遇到一些神秘的编译和语法错误时会感到怎样。他们不得不深入源代码试图了解发生了什么。经过一个小时的调试后，他们发现正确的解决方案是更新他们的编译器。我们能否为用户提供更好的体验，并在开始构建前检查编译器中是否包含了所有必需的功能？
- en: Sure! There are ways to specify these requirements. If the toolchain doesn't
    support all of the required features, CMake will stop early and show a clear message
    of what happened, asking the user to step in.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当然！有方法可以指定这些要求。如果工具链不支持所有必需的功能，CMake 将提前停止并显示发生了什么清晰的消息，要求用户介入。
- en: Setting the C++ standard
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 C++ 标准
- en: The first thing we might want to do is to set the C++ standard we require the
    compiler to support if the user wants to build our project. For new projects,
    this should be at least **C++14**, but preferably **C++17** or **C++20**. CMake
    also supports setting the standard to the experimental **C++23**, but that's just
    a draft version.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能首先想要做的是设置编译器需要支持的 C++ 标准，如果用户想要构建我们的项目的话。对于新项目，这至少应该是 **C++14**，但最好是 **C++17**
    或 **C++20**。CMake 还支持将标准设置为实验性的 **C++23**，但那只是一个草案版本。
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It has been 10 years since the official release of **C++11**, and it is no longer
    considered to be *the modern C++ standard*. It's not recommended to start projects
    with this version unless your target environment is very old.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 自 **C++11** 正式发布以来已经过去了 10 年，它不再被认为是*现代 C++ 标准*。除非你的目标环境非常老旧，否则不建议用这个版本开始项目。
- en: Another reason to stick to old standards is if you are building legacy targets
    that are too hard to upgrade. However, the C++ committee works very hard to keep
    C++ backward compatible, and in most cases, you won't have any problems bumping
    the standard to a higher version.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持旧标准的原因之一是因为你在构建太难升级的遗留目标。然而，C++ 委员会非常努力地保持 C++ 的向后兼容性，在大多数情况下，你将不会有任何问题将标准提升到更高版本。
- en: 'CMake supports setting the standard on a target-per-target basis, which means
    that you can have any granularity you like. I believe it''s better to converge
    to a single standard across the project. This can be done by setting the `CMAKE_CXX_STANDARD`
    variable to one of the following values: `98`, `11`, `14`, `17`, `20`, or `23`
    (since CMake 3.20). This will be a default value for all subsequently defined
    targets (so it''s best to set it close to the top of the root listfile). You can
    override it on a per-target basis if needed, like so:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 支持基于每个目标单独设置标准，这意味着你可以拥有任何粒度。我相信最好让整个项目统一到一个标准上。这可以通过将 `CMAKE_CXX_STANDARD`
    变量设置为以下值之一来实现：`98`、`11`、`14`、`17`、`20` 或 `23`（自 CMake 3.20 起）。这将作为所有随后定义的目标的默认值（所以最好在根列表文件的顶部附近设置它）。如果需要，你可以按每个目标单独覆盖它，像这样：
- en: '[PRE13]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Insisting on standard support
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 坚持标准支持
- en: The `CXX_STANDARD` property mentioned in the previous section won't stop CMake
    from continuing with the build, even if the compiler isn't supporting the desired
    version – it's treated as a preference. CMake doesn't know if our code actually
    uses the brand-new features that aren't available in the previous compilers, and
    it will try to work with what it has available.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上文提到的`CXX_STANDARD`属性即使编译器不支持期望的版本——它也被视为一个偏好。CMake不知道我们的代码实际上是否使用了在之前的编译器中不可用的全新特性，并且它会尝试利用可用的所有内容。
- en: 'If we know for certain that this won''t be successful, we can set another default
    flag (which is overridable in the same manner as the previous one) and explicitly
    require the standard we target:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确信这将不会成功，我们可以设置另一个默认标志（它可以通过与前一个相同的方式覆盖）并明确要求我们目标的标准：
- en: '[PRE14]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In that case, if the latest compiler isn''t present in the system (in this
    case, `GNU GCC 11`), the user will just see the following message and the build
    will stop:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果最新的编译器不在系统当中（在这个例子中，`GNU GCC 11`），用户将只看到以下消息，并且构建将停止：
- en: '[PRE15]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Asking for C++23 might be a bit excessive, even for a modern environment. But
    C++14 should be perfectly fine, as it has been fully supported in **GCC**/**Clang**
    since 2015.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要求C++23可能有点过分，即使在一个现代环境中。但C++14应该完全没问题，因为它自2015年以来已经在**GCC**/**Clang**中得到全面支持。
- en: Vendor-specific extensions
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 供应商特定的扩展
- en: Depending on the policy you implement in your organization, you might be interested
    in allowing or disabling vendor-specific extensions. What are these? Well, let's
    just say that the C++ standard is moving a bit slow for the needs of some compiler
    producers, so they decided to add their own enhancements to the language – *plugins*,
    if you like. To achieve this, CMake will add `-std=gnu++14` instead of `-std=c++14`
    to the compile line.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你在组织中实施的政策，你可能对允许或禁用供应商特定的扩展感兴趣。这些是什么？嗯，我们可以说C++标准对于一些编译器生产商来说进展得太慢，所以他们决定向语言添加他们自己的增强——如果你喜欢的话，就是*插件*。为了实现这一点，CMake将把`-std=gnu++14`添加到编译命令行中，而不是`-std=c++14`。
- en: On one hand, this may be desired, as it allows for some convenient functionality.
    But on the other, your code will fail to build if you switch to a different compiler
    (or if your users do!).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，这可能是想要的，因为它允许一些方便的功能。但另一方面，如果你的代码切换到不同的编译器（或者你的用户这样做！）构建将失败！
- en: 'This is also a per-target property for which there is a default variable, `CMAKE_CXX_EXTENSIONS`.
    CMake is more liberal here, and allows the extensions unless we specifically tell
    it not to:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个针对每个目标的属性，其有一个默认变量，`CMAKE_CXX_EXTENSIONS`。CMake在这里更加宽松，除非我们明确告诉它不要这样做，否则允许扩展：
- en: '[PRE16]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: I recommend doing so if possible, as this option will insist on having vendor-agnostic
    code. Such code won't impose any unnecessary requirements on the users. In a similar
    way, you can use `set_property()` to change this value on a per-target basis.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，我建议这样做，因为此选项将坚持拥有与供应商无关的代码。此类代码不会对用户施加任何不必要的要求。类似地，你可以使用`set_property()`按每个目标的基础更改此值。
- en: Interprocedural optimization
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨过程优化
- en: Usually, compilers optimize the code on the level of a single translation unit,
    which means that your `.cpp` file will be preprocessed, compiled, and then optimized.
    Later, these files will be passed to the linker to build a single binary. Modern
    compilers can perform optimization after linking (this is called *link time optimization*)
    so that all compilation units can be optimized as a single module.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，编译器在单个翻译单元的层面上优化代码，这意味着你的`.cpp`文件将被预处理、编译，然后优化。后来，这些文件将被链接器用来构建单一的二进制文件。现代编译器可以在链接后进行优化（这称为*链接时优化*），以便所有编译单元可以作为一个单一模块进行优化。
- en: 'If your compiler supports interprocedural optimization, it may be a good idea
    to use it. We''ll follow the same method as previously. The default variable for
    this setting is called `CMAKE_INTERPROCEDURAL_OPTIMIZATION`. But before we set
    it, we need to make sure it is supported to avoid errors:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的编译器支持跨过程优化，使用它可能是个好主意。我们将采用与之前相同的方法。此设置的默认变量称为`CMAKE_INTERPROCEDURAL_OPTIMIZATION`。但在设置之前，我们需要确保它被支持以避免错误：
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we had to include a built-in module to get access to the `check_ipo_supported()`
    command.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们不得不包含一个内置模块来获取`check_ipo_supported()`命令的访问权限。
- en: Checking for supported compiler features
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查支持的编译器功能
- en: 'As we discussed earlier, if our build is to fail, it''s best if it fails early,
    so we can provide a clear feedback message to the user. What we''re especially
    interested in is gauging which C++ features are supported (and which aren''t).
    CMake will question the compiler during the configuration stage and store a list
    of the available features in the `CMAKE_CXX_COMPILE_FEATURES` variable. We may
    write a very specific check and ask if a certain feature is available:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，如果我们的构建失败，最好是早点失败，这样我们就可以向用户提供一个清晰的反馈信息。我们特别感兴趣的是衡量哪些C++特性被支持（以及哪些不被支持）。CMake将在配置阶段询问编译器，并将可用特性的列表存储在`CMAKE_CXX_COMPILE_FEATURES`变量中。我们可以编写一个非常具体的检查，询问某个特性是否可用：
- en: chapter03/07-features/CMakeLists.txt
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03/07-features/CMakeLists.txt
- en: '[PRE18]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you may guess, writing one for every feature we use is a daunting task.
    Even the authors of CMake recommend to only check if certain high-level *meta-features*
    are present: `cxx_std_98`, `cxx_std_11`, `cxx_std_14`, `cxx_std_17`, `cxx_std_20`,
    and `cxx_std_23`. Each *meta-feature* indicates that the compiler supports a specific
    C++ standard. If you wish, you can use them exactly as we did in the previous
    example.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能猜到的，为每个使用特性编写一个测试文件是一项艰巨的任务。即使是CMake的作者也建议只检查某些高级*元特性*是否存在：`cxx_std_98`、`cxx_std_11`、`cxx_std_14`、`cxx_std_17`、`cxx_std_20`和`cxx_std_23`。每个*元特性*都表明编译器支持特定的C++标准。如果您愿意，您可以像前一个示例中那样使用它们。
- en: 'A full list of features known to CMake can be found in the documentation:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 已知于CMake的所有特性的完整列表可以在文档中找到：
- en: '[https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html](https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html](https://cmake.org/cmake/help/latest/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html)'
- en: Compiling a test file
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译测试文件
- en: One particularly interesting scenario occurred to me when I was compiling an
    application with GCC 4.7.x. I had manually confirmed in the compiler's reference
    that all of the C++11 features we were using were supported. However, the solution
    still didn't work correctly. The code silently ignored the call to the standard
    `<regex>` header. As it turned out, GCC 4.7.x had a bug and the regex library
    wasn't implemented.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我用GCC 4.7.x编译一个应用程序时，有一个特别有趣的场景出现在我面前。我已手动在编译器的参考资料中确认了我们使用的所有C++11特性都被支持。然而，解决方案仍然无法正确工作。代码默默地忽略了标准`<regex>`头文件的调用。结果证明，GCC
    4.7.x有一个bug，正则表达式库没有被实现。
- en: No single check can protect you from such bugs, but there's a chance to reduce
    such behavior by creating a test file that you can fill with all of the features
    that you'd like to check. CMake provides two configure-time commands, `try_compile()`
    and `try_run()`, to verify that everything you need is supported on the target
    platform.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个单一的检查能保护你免受此类bug的影响，但通过创建一个测试文件，你可以填入所有你想检查的特性，从而有机会减少这种行为。CMake提供了两个配置时间命令，`try_compile()`和`try_run()`，以验证您需要的所有内容在目标平台上是否支持。
- en: 'The second command gives you more freedom, as you can ensure that the code
    is not only compiling but that it is also executing correctly (you could potentially
    test if `regex` is working). Of course, this won''t work for cross-compilation
    scenarios (as the host won''t be able to run an executable built for a different
    target). Just remember that the aim of this check is to provide a quick piece
    of feedback to the user if the compilation is working, so it''s not meant to run
    any unit tests or anything complex – keep the file as basic as possible. For example,
    something like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令给您更多的自由，因为您可以确保代码不仅编译成功，而且执行也正确（您可以潜在地测试`regex`是否工作）。当然，这对于交叉编译场景不起作用（因为主机无法运行为不同目标构建的可执行文件）。只需记住，这个检查的目的是在编译成功时向用户提供一个快速的反馈，所以它并不是用来运行任何单元测试或其他复杂内容的——尽量保持文件尽可能简单。例如，像这样：
- en: chapter03/08-test_run/main.cpp
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03/08-test_run/main.cpp
- en: '[PRE19]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Calling `test_run()` isn''t very complicated at all. We start by setting the
    required standard, after which we call `test_run()` and print the collected information
    to the user:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`test_run()`其实并不复杂。我们首先设置所需的标准，然后调用`test_run()`，并将收集的信息打印给用户：
- en: chapter03/08-test_run/CMakeLists.txt
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03/08-test_run/CMakeLists.txt
- en: '[PRE20]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This command has a lot of optional fields to set, which may seem overwhelming
    at first, but as we read and compare it with the call made in the example, everything
    comes together:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令有很多可选字段需要设置，一开始可能会觉得有点复杂，但当我们阅读并与示例中的调用进行比较时，一切都会变得明朗起来：
- en: '[PRE21]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Only a few fields are required to compile and run a very basic test file. I
    also used the optional `RUN_OUTPUT_VARIABLE` keyword to collect the output from
    `stdout`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 只有几个字段是编译和运行一个非常基础的测试文件所必需的。我还使用了可选的`RUN_OUTPUT_VARIABLE`关键字来收集`stdout`的输出。
- en: The next step is to extend this simple file by using some of the more modern
    C++ features that we're going to use throughout the actual project – perhaps by
    adding a variadic template to see if the compiler on the target machine can digest
    it. Each time we introduce a new feature to the actual project, we can put a tiny
    sample of the same feature into the test file. But remember – keep it lean. We
    want to check if the compilation works in the shortest time possible.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用我们在实际项目中将要使用的更现代的C++特性来扩展这个简单的文件——也许通过添加一个可变模板来看目标机器上的编译器是否能消化它。每次我们在实际项目中引入一个新特性，我们可以在测试文件中放入这个特性的微小样本。但请记住——保持简洁。我们希望在最短的时间内检查编译是否成功。
- en: Finally, we can check in the conditional blocks if the collected output is meeting
    our expectations and `message(SEND_ERROR)` is printed when something isn't right.
    Remember that `SEND_ERROR` will continue through the configuration stage but won't
    start the generation. This is useful to show all of the encountered errors before
    aborting the build.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在条件块中检查收集的输出是否符合我们的期望，当有些不对劲时会打印`message(SEND_ERROR)`。记住`SEND_ERROR`会在配置阶段继续，但不会启动生成。这有助于在放弃构建之前显示所有遇到的错误。
- en: Disabling in-source builds
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用源内构建
- en: In [*Chapter 1*](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014), *First Steps
    with CMake*, we talked about in-source builds, and how it is recommended to always
    specify the build path to be out-of-source. This not only allows for a cleaner
    build tree and a simpler `.gitignore` file, but it also decreases the chances
    you'll accidentally overwrite or delete any source files.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第*1*章](B17205_01_Final_JC_ePub.xhtml#_idTextAnchor014)，《CMake的初步步骤》中，我们讨论了源内构建，以及建议始终指定为源外构建路径。这不仅允许更干净的构建树和更简单的`.gitignore`文件，而且还减少了你意外覆盖或删除任何源文件的可能性。
- en: 'Searching for the solution online, you may stumble on a StackOverflow thread
    that asks the same question: [https://stackoverflow.com/q/1208681/6659218](https://stackoverflow.com/q/1208681/6659218).
    Here, the author notices that no matter what you do, it seems like CMake will
    still create a `CMakeFiles/` directory and a `CMakeCache.txt` file. Some answers
    suggest using undocumented variables to make sure that the user can''t write in
    the source directory under any circumstances:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上搜索解决方案时，你可能会偶然发现一个StackOverflow帖子，提出了同样的问题：[https://stackoverflow.com/q/1208681/6659218](https://stackoverflow.com/q/1208681/6659218)。在这里，作者注意到不管你做什么，似乎CMake仍然会创建一个`CMakeFiles/`目录和一个`CMakeCache.txt`文件。一些答案建议使用未记录的变量，以确保用户在任何情况下都不能在源目录中写入：
- en: '[PRE22]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'I''d say to be cautious when using undocumented features of any software, as
    they may go away without warning. Setting the preceding variables in CMake 3.20
    terminates the build with a rather ugly error:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为在使用任何软件的未记录功能时要小心，因为它们可能会在没有警告的情况下消失。在CMake 3.20中设置前面的变量会导致构建失败，并出现相当丑陋的错误：
- en: '[PRE23]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, it still creates the mentioned files anyway! Therefore, my recommendation
    is to go with an older – but fully supported – mechanism:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它仍然创建了提到的文件！因此，我的建议是使用更旧的——但完全支持——机制：
- en: chapter03/09-in-source/CMakeLists.txt
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: chapter03/09-in-source/CMakeLists.txt
- en: '[PRE24]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If Kitware (company behind the CMake) ever decides to officially support `CMAKE_DISABLE_SOURCE_CHANGES`
    or `CMAKE_DISABLE_IN_SOURCE_BUILD`, then by all means, switch to that solution.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Kitware（CMake背后的公司）正式支持`CMAKE_DISABLE_SOURCE_CHANGES`或`CMAKE_DISABLE_IN_SOURCE_BUILD`，那么当然，切换到那个解决方案。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We introduced a lot of valuable concepts in this chapter that will give us a
    strong foundation to go forward and build hardened, future-proof projects. We
    discussed how to set the minimum CMake version and how to configure the key aspects
    of the project – that is, the name, languages, and metadata fields.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章引入了许多有价值的概念，它们将为我们打下坚实的基础，以便我们向前发展并构建坚固、未来proof的项目。我们讨论了如何设置最低的CMake版本以及如何配置项目的关键方面，即名称、语言和元数据字段。
- en: Laying good foundations will help ensure that our projects can grow quickly.
    This is why we discussed the partitioning of projects. We analyzed naïve code
    partitioning using `include()` and compared it with `add_subdirectory()`. At this
    point, we learned about the benefits of managing the directory scope of variables,
    and we explored the use of simpler paths and increased modularity. Having an option
    to create a nested project and build it separately is very useful when we need
    to slowly break code down into more independent units.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 打下良好的基础将有助于确保我们的项目能够快速成长。这就是我们讨论项目分区的理由。我们分析了使用`include()`的简单代码分区，并将其与`add_subdirectory()`进行了比较。在此过程中，我们了解了管理变量目录作用域的好处，并探讨了使用更简单的路径和增加的模块性的好处。当需要逐步将代码分解为更独立的单元时，创建嵌套项目和分别构建它是非常有用的。
- en: After an overview of the partitioning mechanisms we have at our disposal, we
    explored *how* we want to use them – for example, how to make transparent, resilient,
    and extensible project structures. Specifically, we analyzed how CMake will traverse
    the listfiles and the correct order of the different configuration steps.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在概览了我们可用的分区机制之后，我们探讨了*如何*使用它们——例如，如何创建透明、有弹性且可扩展的项目结构。具体来说，我们分析了CMake如何遍历列表文件以及不同配置步骤的正确顺序。
- en: Next, we studied how we can scope the environment of our target and host machines,
    what the differences are between them, and what kind of information about the
    platform and system is available through different queries.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们研究了如何作用域化我们目标和宿主机器的环境，它们之间的区别是什么，以及通过不同的查询可以获取关于平台和系统的哪些信息。
- en: Finally, we found out how to configure the toolchain – for example, how to specify
    the required C++ version, how to address the issue of vendor-specific compiler
    extensions, and how to enable important optimization. We wrapped up by discovering
    how to test our compiler for the required features and compile test files.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们发现了如何配置工具链——例如，如何指定所需的C++版本，如何解决特定编译器扩展的问题，以及如何启用重要的优化。我们最后了解了如何测试我们的编译器所需的特性以及编译测试文件。
- en: While this is all that a project technically requires, it's still not a very
    useful project. To change that, we need to introduce *targets*. So far, we've
    mentioned them here and there, but I tried to avoid the subject until we had learned
    more about some general concepts first. Now that's done, we'll look at them in
    detail.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从技术上讲，项目所有这些就足够了，但它仍然不是一个非常有用的项目。为了改变这一点，我们需要引入*目标*。到目前为止，我们在这里那里提到了它们，但我试图在我们先了解一些基本概念之前避免这个话题。现在我们已经做到了，我们将详细查看它们。
- en: Further reading
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章涵盖的议题的更多信息，你可以参考以下内容：
- en: '*Separation of concerns*: [https://nalexn.github.io/separation-of-concerns/](https://nalexn.github.io/separation-of-concerns/)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关注点分离*：[https://nalexn.github.io/separation-of-concerns/](https://nalexn.github.io/separation-of-concerns/)'
- en: '*Complete CMake Variable reference*: [https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CMake变量完整参考*：[https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html](https://cmake.org/cmake/help/latest/manual/cmake-variables.7.html)'
- en: '*Try compile and try run references*:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尝试编译和尝试运行的参考*：'
- en: '[https://cmake.org/cmake/help/latest/command/try_compile.html](https://cmake.org/cmake/help/latest/command/try_compile.html)'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cmake.org/cmake/help/latest/command/try_compile.html](https://cmake.org/cmake/help/latest/command/try_compile.html)'
- en: '[https://cmake.org/cmake/help/latest/command/try_run.html](https://cmake.org/cmake/help/latest/command/try_run.html)'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cmake.org/cmake/help/latest/command/try_run.html](https://cmake.org/cmake/help/latest/command/try_run.html)'
