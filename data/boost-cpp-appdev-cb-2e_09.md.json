["```cpp\n#include <vector>\n\nclass operation;\n\ntemplate <class T>\nvoid execute_operations(const T&);\n\nbool has_operation();\noperation get_operation();\n\nvoid process_transaction_1() {\n    std::vector<operation> ops;\n    ops.reserve(8); // TODO: Memory allocation. Not good!\n\n    while (has_operation()) {\n        ops.push_back(get_operation());\n    }\n\n    execute_operations(ops);\n    // ...\n}\n```", "```cpp\n#include <boost/container/small_vector.hpp>\n```", "```cpp\nvoid process_transaction_2() {\n    boost::container::small_vector<operation, 8> ops;\n\n    while (has_operation()) {\n        ops.push_back(get_operation());\n    }\n\n    execute_operations(ops);\n    // ...\n}\n```", "```cpp\nvoid execute_operations(\n    const boost::container::small_vector<operation, 4>&);\n\nvoid execute_operations(\n    const boost::container::small_vector<operation, 8>&);\n\nvoid execute_operations(\n    const boost::container::small_vector<operation, 16>&);\n```", "```cpp\nvoid execute_operations(\n    const boost::container::small_vector_base<operation>& ops\n);\n```", "```cpp\n#include <vector>\nstd::vector<event> get_events();\n```", "```cpp\n#include <boost/array.hpp>\nboost::array<event, 5> get_events();\n```", "```cpp\n#include <boost/container/small_vector.hpp>\nboost::container::small_vector<event, 5> get_events();\n```", "```cpp\n#include <boost/container/static_vector.hpp>\nboost::container::static_vector<event, 5> get_events();\n```", "```cpp\n#include <cassert>\n\nint main () {\n    boost::container::static_vector<event, 5> ev = get_events();\n    assert(ev.size() == 5);\n\n    boost::container::static_vector<int, 2> ints;\n    ints.push_back(1);\n    ints.push_back(2);\n    try {\n        // The following line always throws:\n        ints.push_back(3);\n    } catch (const std::bad_alloc& ) {\n        // ...\n    }\n}\n```", "```cpp\n#include <string>\n\ntemplate <class T>\nstd::size_t test_default() {\n    // Constants\n    const std::size_t ii_max = 200000;\n    const std::string s(\n        \"Long long long string that \"\n        \"will be used in tests to compare \"\n        \"speed of equality comparisons.\"\n    );\n\n    // Making some data, that will be \n    // used in comparisons.\n    const T data1[] = {\n        T(s),\n        T(s + s),\n        T(s + \". Whooohooo\"),\n        T(std::string(\"\"))\n    };\n\n    const T data2[] = {\n        T(s),\n        T(s + s),\n        T(s + \". Whooohooo\"),\n        T(std::string(\"\"))\n    };\n\n    const std::size_t data_dimensions = sizeof(data1) / sizeof(data1[0]);\n\n    std::size_t matches = 0u;\n    for (std::size_t ii = 0; ii < ii_max; ++ii) {\n        for (std::size_t i = 0; i < data_dimensions; ++i) {\n            for (std::size_t j = 0; j < data_dimensions; ++j) {\n                if (data1[i] == data2[j]) {\n                    ++ matches;\n                }\n            }\n        }\n    }\n\n    return matches;\n}\n```", "```cpp\n#include <boost/functional/hash.hpp>\n```", "```cpp\nstruct string_hash_fast {\n    typedef std::size_t comp_type;\n\n    const comp_type     comparison_;\n    const std::string   str_;\n\n    explicit string_hash_fast(const std::string& s)\n        : comparison_(\n            boost::hash<std::string>()(s)\n        )\n        , str_(s)\n    {}\n};\n```", "```cpp\ninline bool operator == (\n    const string_hash_fast& s1, const string_hash_fast& s2)\n{\n    return s1.comparison_ == s2.comparison_ && s1.str_ == s2.str_;\n}\n\ninline bool operator != (\n    const string_hash_fast& s1, const string_hash_fast& s2)\n{\n    return !(s1 == s2);\n}\n```", "```cpp\n#include <iostream> \n#include <iostream>\n#include <cassert>\n\nint main(int argc, char* argv[]) {\n    if (argc < 2) {\n        assert(\n            test_default<string_hash_fast>()\n            ==\n            test_default<std::string>()\n        );\n        return 0;\n    }\n\n    switch (argv[1][0]) {\n    case 'h':\n        std::cout << \"HASH matched: \"\n                  << test_default<string_hash_fast>();\n        break;\n\n    case 's':\n        std::cout << \"STD matched: \"\n                  << test_default<std::string>();\n        break;\n\n    default:\n        return 2;\n    }\n}\n```", "```cpp\n    boost::hash<std::string>()(s) \n```", "```cpp\n    return s1.comparison_ == s2.comparison_ && s1.str_ == s2.str_; \n```", "```cpp\n// Must be in the namespace of string_hash_fast class.\ninline std::size_t hash_value(const string_hash_fast& v) {\n    return v.comparison_;\n}\n```", "```cpp\n#include <boost/unordered_set.hpp>\n#include <string>\n#include <cassert>\n\nvoid example() {\n    boost::unordered_set<std::string> strings;\n\n    strings.insert(\"This\");\n    strings.insert(\"is\");\n    strings.insert(\"an\");\n    strings.insert(\"example\");\n\n    assert(strings.find(\"is\") != strings.cend());\n}\n```", "```cpp\ntemplate <class T>\nvoid output_example() {\n    T strings;\n\n    strings.insert(\"CZ\");\n    strings.insert(\"CD\");\n    strings.insert(\"A\");\n    strings.insert(\"B\");\n\n    std::copy(\n        strings.begin(),\n        strings.end(),\n        std::ostream_iterator<std::string>(std::cout, \"  \")\n    );\n}\n```", "```cpp\n boost::unordered_set<std::string> : B A CD CZ\n std::set<std::string> : A B CD CZ\n```", "```cpp\nFor 100 elements:\nBoost: map is 1.69954 slower than unordered map\nStd: map is 1.54316 slower than unordered map\n\nFor 1000 elements:\nBoost: map is 4.13714 slower than unordered map\nStd: map is 2.12495 slower than unordered map\n\nFor 10000 elements:\nBoost: map is 2.04475 slower than unordered map\nStd: map is 2.23285 slower than unordered map\n\nFor 100000 elements:\nBoost: map is 1.67128 slower than unordered map\nStd: map is 1.68169 slower than unordered map\n```", "```cpp\n    T map;\n\n    for (std::size_t ii = 0; ii < ii_max; ++ii) {\n        map[s + boost::lexical_cast<std::string>(ii)] = ii;\n    }\n\n    // Asserting.\n    for (std::size_t ii = 0; ii < ii_max; ++ii) {\n        assert(map[s + boost::lexical_cast<std::string>(ii)] == ii);\n    }\n```", "```cpp\nstruct my_type { \n    int         val1_; \n    std::string val2_; \n}; \n```", "```cpp\ninline bool operator == (const my_type& v1, const my_type& v2) {\n    return v1.val1_ == v2.val1_ && v1.val2_ == v2.val2_;\n} \n```", "```cpp\nstd::size_t hash_value(const my_type& v) { \n    std::size_t ret = 0u; \n\n    boost::hash_combine(ret, v.val1_); \n    boost::hash_combine(ret, v.val2_); \n    return ret; \n} \n```", "```cpp\ntemplate <class T> \ninline void hash_combine(std::size_t& seed, const T& v) \n{ \n    std::hash<T> hasher; \n    seed ^= hasher(v) + 0x9e3779b9 + (seed<<6) + (seed>>2); \n} \n```", "```cpp\n#include <iostream>\n#include <boost/bimap.hpp>\n#include <boost/bimap/multiset_of.hpp>\n```", "```cpp\nint main() {\n    typedef boost::bimap<\n        std::string,\n        boost::bimaps::multiset_of<std::size_t>\n    > name_id_type;\n\n    name_id_type name_id;\n```", "```cpp\n    // Inserting keys <-> values\n    name_id.insert(name_id_type::value_type(\n        \"John Snow\", 1\n    ));\n\n    name_id.insert(name_id_type::value_type(\n        \"Vasya Pupkin\", 2\n    ));\n\n    name_id.insert(name_id_type::value_type(\n        \"Antony Polukhin\", 3\n    ));\n\n    // Same person as \"Antony Polukhin\"\n    name_id.insert(name_id_type::value_type(\n        \"Anton Polukhin\", 3\n    ));\n```", "```cpp\n    std::cout << \"Left:\\n\";\n\n    typedef name_id_type::left_const_iterator left_const_iterator;\n    const left_const_iterator lend = name_id.left.end();\n\n    for (left_const_iterator it = name_id.left.begin();\n         it!= lend;\n         ++it)\n    {\n        std::cout << it->first << \" <=> \" << it->second << '\\n';\n    }\n```", "```cpp\n    std::cout << \"\\nRight:\\n\";\n\n    typedef name_id_type::right_const_iterator right_const_iterator;\n    const right_const_iterator rend = name_id.right.end();\n\n    for (right_const_iterator it = name_id.right.begin();\n         it!= rend;\n         ++it)\n    {\n        std::cout << it->first << \" <=> \" << it->second << '\\n';\n    }\n```", "```cpp\n    assert(\n        name_id.find(name_id_type::value_type(\n            \"Anton Polukhin\", 3\n        )) != name_id.end()\n    );\n} /* end of main() */\n```", "```cpp\n Left:\n Anton Polukhin <=> 3\n Antony Polukhin <=> 3\n John Snow <=> 1\n Vasya Pupkin <=> 2\n\n Right:\n 1 <=> John Snow\n 2 <=> Vasya Pupkin\n 3 <=> Antony Polukhin\n 3 <=> Anton Polukhin\n```", "```cpp\n    typedef boost::bimap< \n        std::string, \n        boost::bimaps::multiset_of<std::size_t> \n    > name_id_type; \n```", "```cpp\n#include <boost/bimap/unordered_set_of.hpp> \n#include <boost/bimap/unordered_multiset_of.hpp> \n\ntypedef boost::bimap< \n    boost::bimaps::unordered_set_of<std::string>,  \n    boost::bimaps::unordered_multiset_of<std::size_t>  \n> hash_name_id_type; \n```", "```cpp\n#include <boost/bimap/set_of.hpp> \n\ntypedef boost::bimap< \n    boost::bimaps::set_of<std::string>,  \n    boost::bimaps::multiset_of<std::size_t>  \n> name_id_type; \n```", "```cpp\n    std::map<std::string, std::size_t> key1;      // == name_id.left\n    std::multimap<std::size_t, std::string> key2; // == name_id.right\n```", "```cpp\nstruct person {\n    std::size_t     id_;\n    std::string     name_;\n    unsigned int    height_;\n    unsigned int    weight_;\n\n    person(std::size_t id, const std::string& name,\n                unsigned int height, unsigned int weight)\n        : id_(id)\n        , name_(name)\n        , height_(height)\n        , weight_(weight)\n    {}\n};\n\ninline bool operator < (const person& p1, const person& p2) {\n    return p1.name_ < p2.name_;\n}\n```", "```cpp\n#include <iostream>\n#include <boost/multi_index_container.hpp>\n#include <boost/multi_index/ordered_index.hpp>\n#include <boost/multi_index/hashed_index.hpp>\n#include <boost/multi_index/identity.hpp>\n#include <boost/multi_index/member.hpp>\n```", "```cpp\nvoid example_main() {\n    typedef boost::multi_index::multi_index_container<\n        person,\n        boost::multi_index::indexed_by<\n            // names are unique\n            boost::multi_index::ordered_unique<\n                boost::multi_index::identity<person>\n            >,\n\n            // IDs are not unique, but we do not need them ordered\n            boost::multi_index::hashed_non_unique<\n                boost::multi_index::member<\n                    person, std::size_t, &person::id_\n                >\n            >,\n\n            // Height may not be unique, but must be sorted\n            boost::multi_index::ordered_non_unique<\n                boost::multi_index::member<\n                    person, unsigned int, &person::height_\n                >\n            >,\n\n            // Weight may not be unique, but must be sorted\n            boost::multi_index::ordered_non_unique<\n                boost::multi_index::member<\n                    person, unsigned int, &person::weight_\n                >\n            >\n        > // closing for `boost::multi_index::indexed_by<`\n    > indexes_t;\n```", "```cpp\n    indexes_t persons;\n\n    // Inserting values:\n    persons.insert(person(1, \"John Snow\", 185, 80));\n    persons.insert(person(2, \"Vasya Pupkin\", 165, 60));\n    persons.insert(person(3, \"Antony Polukhin\", 183, 70));\n    // Same person as \"Antony Polukhin\".\n    persons.insert(person(3, \"Anton Polukhin\", 182, 70));\n```", "```cpp\ntemplate <std::size_t IndexNo, class Indexes>\nvoid print(const Indexes& persons) {\n    std::cout << IndexNo << \":\\n\";\n\n    typedef typename Indexes::template nth_index<\n            IndexNo\n    >::type::const_iterator const_iterator_t;\n\n    for (const_iterator_t it = persons.template get<IndexNo>().begin(),\n         iend = persons.template get<IndexNo>().end();\n         it != iend;\n         ++it)\n    {\n        const person& v = *it;\n        std::cout \n            << v.name_ << \", \" \n            << v.id_ << \", \" \n            << v.height_ << \", \" \n            << v.weight_ << '\\n'\n        ;\n    }\n\n    std::cout << '\\n';\n} \n```", "```cpp\n    print<0>(persons);\n    print<1>(persons);\n    print<2>(persons);\n    print<3>(persons);\n```", "```cpp\n    assert(persons.get<1>().find(2)->name_ == \"Vasya Pupkin\");\n    assert(\n        persons.find(person(\n            77, \"Anton Polukhin\", 0, 0\n        )) != persons.end()\n    );\n\n    // Won't compile:\n    //assert(persons.get<0>().find(\"John Snow\")->id_ == 1);\n```", "```cpp\n0:\nAnton Polukhin, 3, 182, 70\nAntony Polukhin, 3, 183, 70\nJohn Snow, 1, 185, 80\nVasya Pupkin, 2, 165, 60\n\n1:\nJohn Snow, 1, 185, 80\nVasya Pupkin, 2, 165, 60\nAnton Polukhin, 3, 182, 70\nAntony Polukhin, 3, 183, 70\n\n2:\nVasya Pupkin, 2, 165, 60\nAnton Polukhin, 3, 182, 70\nAntony Polukhin, 3, 183, 70\nJohn Snow, 1, 185, 80\n\n3:\nVasya Pupkin, 2, 165, 60\nAntony Polukhin, 3, 183, 70\nAnton Polukhin, 3, 182, 70\nJohn Snow, 1, 185, 80\n```", "```cpp\n            boost::multi_index::ordered_unique< \n                boost::multi_index::identity<person> \n            > \n```", "```cpp\n            boost::multi_index::hashed_non_unique< \n                boost::multi_index::member< \n                    person, std::size_t, &person::id_ \n                > \n            > \n```", "```cpp\n    typedef typename Indexes::template nth_index< \n            IndexNo \n    >::type::const_iterator const_iterator_t; \n```", "```cpp\ntypedef indexes_t::nth_index<0>::type::const_iterator const_iterator_t;\n```", "```cpp\nfor (const_iterator_t it = persons.template get<IndexNo>().begin(), \n         iend = persons.template get<IndexNo>().end(); \n         it != iend; \n         ++it) \n    { \n        const person& v = *it; \n        // ... \n```", "```cpp\n    for (const_iterator_t it = persons.get<0>().begin(), \n         iend = persons.get<0>().end(); \n         it != iend; \n         ++it) \n    { \n        const person& v = *it; \n        // ... \n```", "```cpp\n#include <boost/pool/pool_alloc.hpp>\n#include <boost/container/slist.hpp>\n#include <cassert>\n```", "```cpp\ntypedef boost::fast_pool_allocator<int> allocator_t;\ntypedef boost::container::slist<int, allocator_t> slist_t;\n```", "```cpp\ntemplate <class ListT>\nvoid test_lists() {\n    typedef ListT list_t;\n\n    // Inserting 1000000 zeros.\n    list_t  list(1000000, 0);\n\n    for (int i = 0; i < 1000; ++i) {\n        list.insert(list.begin(), i);\n    }\n\n    // Searching for some value.\n    typedef typename list_t::iterator iterator;\n    iterator it = std::find(list.begin(), list.end(), 777);\n    assert(it != list.end());\n\n    // Erasing some values.\n    for (int i = 0; i < 100; ++i) {\n        list.pop_front();\n    }\n\n    // Iterator is still valid and points to the same value.\n    assert(it != list.end());\n    assert(*it == 777);\n\n    // Inserting more values\n    for (int i = -100; i < 10; ++i) {\n        list.insert(list.begin(), i);\n    }\n\n    // Iterator is still valid and points to the same value\n    assert(it != list.end());\n    assert(*it == 777);\n}\n\nvoid test_slist() {\n    test_lists<slist_t>();\n}\n\nvoid test_list() {\n    test_lists<std::list<int> >();\n}\n```", "```cpp\nvoid list_specific(slist_t& list, slist_t::iterator it) {\n    typedef slist_t::iterator iterator;\n\n    // Erasing element 776\n    assert( *(++iterator(it)) == 776);\n    assert(*it == 777);\n\n    list.erase_after(it);\n\n    assert(*it == 777);\n    assert( *(++iterator(it)) == 775);\n```", "```cpp\n    // Freeing memory: slist rebinds allocator_t and allocates\n    // nodes of the slist, not just ints.\n\n    boost::singleton_pool<\n        boost::fast_pool_allocator_tag,\n        sizeof(slist_t::stored_allocator_type::value_type)\n    >::release_memory();\n} // end of list_specific function\n```", "```cpp\n    boost::singleton_pool<\n        boost::fast_pool_allocator_tag,\n        sizeof(slist_t::stored_allocator_type::value_type)\n    >::release_memory();\n```", "```cpp\n$ TIME=\"Runtime=%E RAM=%MKB\" time ./07_slist_and_pool l\nstd::list: Runtime=0:00.08 RAM=34224KB\n\n$ TIME=\"Runtime=%E RAM=%MKB\" time ./07_slist_and_pool s\nslist_t:   Runtime=0:00.04 RAM=19640KB\n```", "```cpp\n#include <boost/container/flat_set.hpp>\n```", "```cpp\n#include <algorithm>\n#include <cassert>\n\nint main() {\n    boost::container::flat_set<int> set;\n```", "```cpp\n    set.reserve(4096);\n```", "```cpp\n    for (int i = 0; i < 4000; ++i) {\n        set.insert(i);\n    }\n```", "```cpp\n    // 5.1\n    assert(set.lower_bound(500) - set.lower_bound(100) == 400);\n\n    // 5.2\n    set.erase(0);\n\n    // 5.3\n    set.erase(5000);\n\n    // 5.4\n    assert(std::lower_bound(set.cbegin(), set.cend(), 900000) == set.cend());\n\n    // 5.5\n    assert(\n        set.lower_bound(100) + 400 \n        == \n        set.find(500)\n    );\n} // end of main() function\n```"]