- en: Socket Programming Tips and Pitfalls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字编程技巧和陷阱
- en: This chapter builds on all the knowledge you've obtained throughout this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于你在本书中获得的全部知识。
- en: '**Socket programming** can be complicated. There are many pitfalls to avoid
    and subtle programming techniques to implement. In this chapter, we consider some
    nuanced details of network programming that are essential for writing robust programs.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**套接字编程**可能很复杂。有许多陷阱需要避免，以及需要实现的微妙编程技术。在本章中，我们考虑了一些对编写健壮程序至关重要的网络编程的细微细节。'
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Error handling and error descriptions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理和错误描述
- en: TCP handshakes and orderly release
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP握手和有序释放
- en: Timeout on `connect()`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect()`的超时'
- en: Preventing TCP deadlocks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止TCP死锁
- en: TCP flow control
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP流量控制
- en: Avoiding address-in-use errors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免地址已使用错误
- en: Preventing `SIGPIPE` crashes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止`SIGPIPE`崩溃
- en: Multiplexing limitations of `select()`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select()`的多路复用限制'
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Any modern C compiler can compile the example programs from this chapter. We
    recommend **MinGW** on Windows and **GCC** on Linux and macOS. See [Appendix B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml),
    *Setting Up Your C Compiler On Windows*, [Appendix C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml),
    *Setting Up Your C Compiler On Linux*, and [Appendix D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml),
    *Setting Up Your C Compiler On macOS*, for compiler setup.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 任何现代C编译器都可以编译本章的示例程序。我们建议在Windows上使用**MinGW**，在Linux和macOS上使用**GCC**。请参阅[附录B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml)，*在Windows上设置您的C编译器*，[附录C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml)，*在Linux上设置您的C编译器*，以及[附录D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml)，*在macOS上设置您的C编译器*，以了解编译器设置。
- en: 'The code for this book can be found at: [https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码可在以下位置找到：[https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C)。
- en: 'From the command line, you can download the code for this chapter with the
    following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，你可以使用以下命令下载本章的代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each example program in this chapter runs on Windows, Linux, and macOS. When
    compiling on Windows, each example program will require linking to the **Winsock**
    library. This can be accomplished by passing the `-lws2_32` option to `gcc`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的每个示例程序都可在Windows、Linux和macOS上运行。在Windows上编译时，每个示例程序都需要链接到**Winsock**库。这可以通过向`gcc`传递`-lws2_32`选项来实现。
- en: All of the example programs in this chapter require the same header files and
    C macros that we developed in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*. For brevity, we put these statements in a
    separate header file, `chap13.h`. For an explanation of these statements, please
    refer to [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml), *Getting to
    Grips with Socket APIs*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例程序都需要我们在[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握套接字API*中开发的相同头文件和C宏。为了简洁起见，我们将这些语句放在了一个单独的头文件`chap13.h`中。有关这些语句的解释，请参阅[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握套接字API*。
- en: 'The first part of `chap13.h` includes the needed networking headers for each
    platform. The code for that is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`chap13.h`的第一部分包含了每个平台所需的网络头文件。相应的代码如下：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also define some macros to make writing portable code easier, and we include
    the additional headers that our programs need:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一些宏，以便更容易编写可移植的代码，并包含了我们的程序需要的附加头文件：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That concludes `chap13.h`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`chap13.h`。
- en: Error handling
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: '**Error handling** can be a problematic topic in C as it does not "hold the
    programmer''s hand". Any memory or resources allocated must be manually released,
    and this can be tricky to get exactly right in every situation.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误处理**在C语言中可能是一个有问题的主题，因为它并不“手把手”地指导程序员。任何分配的内存或资源都必须手动释放，并且这在每种情况下都可能很棘手。'
- en: When a networked program encounters an error or unexpected situation, the normal
    program flow is interrupted. This is made doubly difficult when designing a multiplexed
    system that handles many connections concurrently.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个网络程序遇到错误或意外情况时，正常的程序流程会被中断。当设计一个处理多个并发连接的多路复用系统时，这会变得更加困难。
- en: The example programs in the book take a shortcut to error handling. Almost all
    of them simply terminate after an error is detected. While this is sometimes a
    valid strategy in real-world programs, real-world programs usually need more complicated
    error recovery.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 书中的示例程序在错误处理上采取了捷径。几乎所有的程序在检测到错误后都简单地终止。虽然这在现实世界的程序中有时是一个有效的策略，但现实世界的程序通常需要更复杂的错误恢复。
- en: Sometimes, you can get away with merely having your client program terminate
    after encountering an error. This behavior is often the correct response for simple
    command-line utilities. At other times, you may need to have your program automatically
    try again.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可以在遇到错误后仅让客户端程序终止。对于简单的命令行工具，这种行为通常是正确的响应。在其他时候，你可能需要让程序自动重试。
- en: Event-driven programming can provide the technique needed to simplify this logic
    a bit. Mainly, your program is structured so that a data structure is allocated
    to store information about each connection. Your program uses a main loop that
    checks for events, such as a readable or writable socket, and then handles those
    events. When structuring your program in this way, it is often easier to flag
    a connection as needing an action, rather than calling a function to process that
    action immediately.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动编程可以提供简化这种逻辑所需的技术。主要的是，你的程序结构是如此设计，以便分配一个数据结构来存储有关每个连接的信息。你的程序使用一个主循环来检查事件，例如可读或可写套接字，然后处理这些事件。以这种方式结构化你的程序时，通常更容易标记一个连接需要执行操作，而不是立即调用一个函数来处理该操作。
- en: With careful design, errors can be handled as a simple matter of course, instead
    of as exceptions to the normal program flow.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细设计，错误可以像常规事项一样处理，而不是作为正常程序流程的例外。
- en: Ultimately, error handling is a very specialized process, and careful care needs
    to be taken to consider application requirements. What's appropriate for one system
    is not necessarily correct for another.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，错误处理是一个非常专业的过程，需要仔细考虑应用需求。对某个系统合适的东西不一定对另一个系统正确。
- en: In any case, a robust program design dictates that you carefully consider how
    to handle errors. Many programmers focus only on the happy path. That is, they
    take care to design the program flow based on the assumption that everything goes
    correctly. For robust programs, this is a mistake. It is equally important to
    consider the program flow in cases where everything goes wrong.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，健壮的程序设计都要求你仔细考虑如何处理错误。许多程序员只关注成功的路径。也就是说，他们仔细设计程序流程，基于一切都会正确的假设。对于健壮的程序，这是一个错误。同样重要的是要考虑在一切出错的情况下的程序流程。
- en: Throughout the rest of this chapter, we touch on places where network programming
    can go wrong. Network programming can be subtle, and many of these failure modes
    are surprising. However, with proper consideration, they are all capable of being
    handled.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将讨论网络编程可能出错的地方。网络编程可能很微妙，许多这些故障模式都令人惊讶。然而，经过适当的考虑，它们都是可以处理的。
- en: Before diving into all the weird ways a connection can fail, let's first focus
    on making error logging a bit easier. In this book, so far, we've been dealing
    with numeric error codes. It is often more useful to obtain a text description
    of an error. We look at a method for this next.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨连接可能失败的所有奇怪方式之前，让我们首先关注使错误记录变得更容易一些。在这本书中，到目前为止，我们一直在处理数字错误代码。获取错误文本描述通常更有用。我们将在下一节中查看这种方法。
- en: Obtaining error descriptions
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取错误描述
- en: In [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml), *Getting to Grips
    with Socket APIs*,  we developed the `GETSOCKETERRNO()` macro as a cross-platform
    way to obtain the error code after a failed system call.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)“掌握套接字API”，我们开发了`GETSOCKETERRNO()`宏，作为一种跨平台的方法来获取系统调用失败后的错误代码。
- en: 'The `GETSOCKETERRNO()` macro is repeated here for your convenience:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了您的方便，这里重复了`GETSOCKETERRNO()`宏：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code has served us well throughout this book. It has the advantage
    of being short and simple.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在本章中一直为我们服务。它具有简短和简单的优点。
- en: In a real-world program, you may want to display a text-based error message
    in addition to the error code. Windows and Unix-based systems both provide functions
    for this purpose.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的程序中，你可能还想显示基于文本的错误消息，而不仅仅是错误代码。Windows和基于Unix的系统都提供了用于此目的的函数。
- en: 'We can build a simple function to return the last error message as a C string.
    The code for this function is the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建一个简单的函数来返回最后一个错误消息作为C字符串。此函数的代码如下：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding function formats the error as text using `FormatMessage()` on
    Windows and `strerror()` on other operating systems.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数使用 Windows 上的 `FormatMessage()` 和其他操作系统上的 `strerror()` 格式化错误为文本。
- en: Unix-based systems provide the `strerror()` function. This function takes the
    error code as its only parameter, and it returns a pointer to an error message
    string.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Unix的系统提供了 `strerror()` 函数。这个函数只接受错误代码作为其参数，并返回一个指向错误信息字符串的指针。
- en: Getting an error code description on Windows is a bit more involved. We use
    the `FormatMessage()` function to obtain the text description. This function has
    many options, but the parameters used in the preceding code snippet work well
    for our purposes. Note that Windows error descriptions are generally returned
    ending with a newline. Our function uses `strrchr()` to find the last line-feed
    character and truncate the description at that point.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上获取错误代码描述要复杂一些。我们使用 `FormatMessage()` 函数来获取文本描述。这个函数有很多选项，但前面代码片段中使用的参数对我们的目的来说效果很好。注意，Windows
    错误描述通常以换行符结束。我们的函数使用 `strrchr()` 来找到最后一个换行符字符，并在该点截断描述。
- en: 'This chapter''s code includes a program called `error_text.c` that demonstrates
    this method. This program calls the `socket()` function with invalid parameters,
    and then uses `get_error_text()` to display the error message:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包括一个名为 `error_text.c` 的程序，该程序演示了这种方法。该程序使用无效参数调用 `socket()` 函数，然后使用 `get_error_text()`
    显示错误信息：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that error codes and descriptions vary greatly between operating systems.
    The next two screenshots show the error message displayed by this program on both
    Windows and Linux.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，错误代码和描述在操作系统之间差异很大。接下来的两个截图显示了该程序在 Windows 和 Linux 上显示的错误信息。
- en: 'The following screenshot shows `error_text` running on Windows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了 `error_text` 在 Windows 上的运行情况：
- en: '![](img/29559741-e392-4d19-8382-f2028b1a5ee8.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29559741-e392-4d19-8382-f2028b1a5ee8.png)'
- en: 'The next screenshot shows `error_text` running on an Ubuntu Linux desktop:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图显示了 `error_text` 在 Ubuntu Linux 桌面上的运行情况：
- en: '![](img/447be4e8-cc7a-43db-8f1f-dc28fcb5816d.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/447be4e8-cc7a-43db-8f1f-dc28fcb5816d.png)'
- en: As you can see from the preceding two screenshots, different operating systems
    don't often report errors in the same way.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前两个截图所示，不同的操作系统通常不会以相同的方式报告错误。
- en: Now that we have a better way to investigate errors, let's move on to consider
    some ways that **TCP sockets** can fail.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了更好的方法来调查错误，让我们继续考虑一些可能导致 **TCP 套接字**失败的方式。
- en: TCP socket tips
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP 套接字技巧
- en: The **Transmission Control Protocol** (**TCP**) is a fantastic protocol, and
    TCP sockets provide a beautiful abstraction. They present discrete packets on
    an unreliable network as a reliable, continuous stream of data. To the programmer,
    sending and receiving data from a peer anywhere in the world is made nearly as
    easy as reading and writing to a file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输控制协议**（**TCP**）是一个出色的协议，TCP 套接字提供了一个美丽的抽象。它们将不可靠网络上的离散数据包呈现为可靠、连续的数据流。对于程序员来说，从世界任何地方的节点发送和接收数据几乎和读写文件一样简单。'
- en: TCP works very well to hide network shortcomings. When a flaky network drops
    a few packets, TCP faithfully sorts out the mess and retransmits as needed. The
    application using TCP receives the data in perfect order. The application doesn't
    even know there was a network problem, and it certainly doesn't need to address
    the problem.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 在隐藏网络缺陷方面表现得非常好。当不稳定网络丢失几个数据包时，TCP 会忠实地整理混乱并按需重新传输。使用 TCP 的应用程序以完美的顺序接收数据。应用程序甚至不知道存在网络问题，当然也不需要解决这个问题。
- en: With this abstraction, like all abstractions, comes some inherent risk. TCP
    tries very hard to make networks look reliable. It usually succeeds, but sometimes,
    abstractions leak. What happens if your network cable is cut? What happens if
    the application you are connected to crashes? TCP isn't magic. It can't fix these
    problems.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有抽象一样，这种抽象也带来了一些固有的风险。TCP 尽力使网络看起来是可靠的。它通常能成功，但有时，抽象会泄漏。如果你的网络电缆被切断会发生什么？如果你连接的应用程序崩溃会发生什么？TCP
    不是魔法。它不能修复这些问题。
- en: 'Of course, it''s evident that the abstraction must break when faced with severe
    problems such as a total network outage. However, sometimes, more subtle problems
    can arise from details thought to be abstracted away. For example, what happens
    when you try to send a lot of data, but the peer that you are connected to isn''t
    reading it? (Answer: the data gets backed up.)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当面对严重的网络中断等问题时，抽象必须打破。然而，有时，一些被认为被抽象掉的具体细节可能会引起更微妙的问题。例如，当你尝试发送大量数据，但连接到的对端没有读取它时会发生什么？（答案：数据会积压。）
- en: In this section, we look at TCP in a little more detail. We're especially interested
    in the behavior of TCP sockets in these edge cases.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们更详细地探讨TCP。我们特别关注这些边缘情况下TCP套接字的行为。
- en: 'A TCP connection lifespan can be divided into three distinct phases. They are
    as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: TCP连接的生命周期可以分为三个不同的阶段。具体如下：
- en: The setup phase
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置阶段
- en: The data-transfer phase
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据传输阶段
- en: The tear-down phase
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆除阶段
- en: Problems can arise in each step.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个步骤都可能存在问题。
- en: In the setup phase, we have to consider what happens if the target system doesn't
    respond. By default, `connect()` sometimes waits a long time, attempting to establish
    a TCP connection. Sometimes, that is what you want, but often it isn't.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置阶段，我们必须考虑如果目标系统没有响应会发生什么。默认情况下，`connect()`有时会等待很长时间，试图建立TCP连接。有时，你可能希望这样做，但通常并不是这样。
- en: For the data-transfer phase, we must be careful to prevent deadlocks. An awareness
    of TCP congestion control mechanisms can also help us to prevent degenerate cases
    where our connection becomes slow or uses a lot more bandwidth than necessary.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据传输阶段，我们必须小心防止死锁。了解TCP拥塞控制机制也可以帮助我们防止我们的连接变得缓慢或使用比必要的更多带宽的退化情况。
- en: Finally, knowing the details of the tear-down phase helps us to ensure that
    we haven't lost data at the end of a connection. Details of how sockets are terminated
    can also cause operating systems to hold on to half-dead connections long after
    they've disconnected. These lingering sockets can prevent new programs from binding
    to their local ports.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，了解拆除阶段的具体细节有助于我们确保在连接结束时没有丢失数据。套接字终止的细节也可能导致操作系统在断开连接后长时间保持半死不活的状态。这些挂起的套接字可能会阻止新的程序绑定到它们的本地端口。
- en: Let's begin with some information about the three-way handshake that establishes
    TCP connections and how to timeout a `connect()` call.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些关于建立TCP连接的三次握手的信息开始，以及如何超时`connect()`调用。
- en: Timeout on connect()
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`connect()`调用超时'
- en: Usually, when we call `connect()` on a TCP socket, `connect()` blocks until
    the connection is established.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们对一个TCP套接字调用`connect()`时，`connect()`会阻塞直到连接建立。
- en: 'The following diagram illustrates the TCP three-way handshake that establishes
    a typical TCP connection and how it relates to a standard, blocking `connect()`
    call:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了建立典型TCP连接的TCP三次握手以及它与标准阻塞`connect()`调用的关系：
- en: '![](img/dda38f05-7a0b-45f7-8dd0-83a423efd7e8.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dda38f05-7a0b-45f7-8dd0-83a423efd7e8.png)'
- en: The standard TCP three-way handshake consists of three parts. First, the **Client**
    sends a **Synchronize (SYN)** message to the **Server**. Then the **Server** responds
    with an **SYN Message** of its own, combined with an **Acknowledged** (**ACK**)
    message of the **Client**'s **SYN Message**. The **Client** then responds with
    an acknowledgment of the **Server**'s **SYN Message**. The connection is then
    open and ready for data transmission.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的TCP三次握手包括三个部分。首先，**客户端**向**服务器**发送一个**同步（SYN**）消息。然后，**服务器**响应一个自己的**SYN消息**，并结合一个对**客户端**的**SYN消息**的**确认（ACK**）消息。然后，**客户端**对**服务器**的**SYN消息**进行确认。此时，连接打开并准备好数据传输。
- en: When the `connect()` function is called on the **Client** side, the first **SYN
    Message** is sent, and the `connect()` function blocks until the **SYN+ACK Message**
    is received from the **Server**. After the **SYN+ACK Message** is received, `connect()`
    enqueues the final **ACK Message** and returns.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当在**客户端**侧调用`connect()`函数时，首先发送一个**SYN消息**，`connect()`函数会阻塞直到从**服务器**收到**SYN+ACK消息**。收到**SYN+ACK消息**后，`connect()`将最终**ACK消息**入队并返回。
- en: This means that `connect()` blocks for at least one round-trip network time.
    That is, it blocks from the time that its **SYN Message** is sent to the time
    that the **SYN+ACK Message** is received. While one round-trip network time is
    the best-case scenario, in the worst case, it could block for much longer. Consider
    what happens when an overloaded **Server** receives an **SYN Message**. The **Server**
    could take some time to reply with the **SYN+ACK Message**.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `connect()` 至少会阻塞一个往返网络时间。也就是说，它会从发送 **SYN 消息** 的时刻开始阻塞，直到接收到 **SYN+ACK
    消息** 的时刻。虽然一个往返网络时间是最佳情况，但在最坏的情况下，它可能会阻塞更长的时间。考虑一下当过载的 **服务器** 收到 **SYN 消息** 时会发生什么。服务器可能需要一些时间来回复
    **SYN+ACK 消息**。
- en: If `connect()` cannot establish a connection successfully (that is, **SYN+ACK
    Message** is never received), then the `connect()` call eventually times out.
    This timeout period is controlled by the operating system. The exact timeout period
    varies, but 20 seconds is about typical.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `connect()` 无法成功建立连接（即从未收到 **SYN+ACK 消息**），那么 `connect()` 调用最终会超时。这个超时时间由操作系统控制。确切的超时时间各不相同，但大约是
    20 秒。
- en: There is no standard way to extend the timeout period of `connect()`, but you
    can always call `connect()` again if you want to keep trying.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 没有标准的方法可以扩展 `connect()` 的超时时间，但如果你想要继续尝试，可以始终再次调用 `connect()`。
- en: There are a few ways to make `connect()` timeout early. One way is to use multiple
    processes and kill the child process if it doesn't connect in time. Another way
    is to use `SIGALARM` in Unix-based systems.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以使 `connect()` 提前超时。一种方法是通过多个进程，如果子进程没有及时连接，则终止它。另一种方法是在基于 Unix 的系统上使用
    `SIGALARM`。
- en: A cross-platform `connect()` timeout can be achieved by using `select()`. Recall
    from [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml), *An In-Depth Overview
    of TCP Connections*, that `select()` allows us to wait on a socket operation with
    a specified timeout.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `select()` 可以实现跨平台的 `connect()` 超时。回想一下 [第 3 章](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml)，*TCP
    连接的深入概述*，其中提到 `select()` 允许我们等待带有指定超时的套接字操作。
- en: '`select()` also has the additional benefit of allowing your program to do useful
    work while waiting for the TCP connection to be established. That is, `select()`
    can be used to wait on multiple `connect()` calls, and other socket events besides.
    It can work well for a client that needs to connect to several servers in parallel.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()` 还有一个额外的优点，就是允许程序在等待 TCP 连接建立的同时执行有用的操作。也就是说，`select()` 可以用来等待多个
    `connect()` 调用，以及其他套接字事件。这对于需要并行连接多个服务器的客户端来说可以很好地工作。'
- en: 'Using `select()` to timeout a `connect()` call involves a few steps. They are
    as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `select()` 超时 `connect()` 调用涉及几个步骤。具体如下：
- en: Set the socket to non-blocking operation. This is done using `fcntl(O_NONBLOCK)`
    on Unix-based systems and `ioctlsocket(FIONBIO)` on Windows.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将套接字设置为非阻塞操作。在基于 Unix 的系统上，这可以通过 `fcntl(O_NONBLOCK)` 实现，而在 Windows 上则是通过 `ioctlsocket(FIONBIO)`
    实现。
- en: Call `connect()`. This call returns immediately, provided that *step 1* was
    successful.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `connect()`。如果步骤 1 成功，这个调用会立即返回。
- en: Check the return code from `connect()`. A return value of zero indicates that
    the connection was successful, which probably indicates that non-blocking mode
    was set incorrectly. A non-zero return value from `connect()` means we should
    check the error code (that is, `WSAGetLastError()` on Windows and `errno` on other
    platforms). An error code of `EINPROGRESS` (`WSAEWOULDBLOCK` on Windows) indicates
    that the TCP connection is in progress. Any other value indicates an actual error.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `connect()` 的返回码。返回值为零表示连接成功，这通常表明非阻塞模式设置不正确。`connect()` 的非零返回值意味着我们应该检查错误码（在
    Windows 上是 `WSAGetLastError()`，在其他平台上是 `errno`）。错误码 `EINPROGRESS`（在 Windows 上是
    `WSAEWOULDBLOCK`）表示 TCP 连接正在进行中。任何其他值都表示实际错误。
- en: Set up and call `select()` with the desired timeout.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置并调用 `select()`，指定所需的超时时间。
- en: Set the socket back to blocking mode.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将套接字设置回阻塞模式。
- en: Check to see whether the socket connected successfully.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查套接字是否成功连接。
- en: '*Step 1*, setting the socket to non-blocking mode, can be accomplished with
    the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 1*，将套接字设置为非阻塞模式，可以通过以下代码实现：'
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code works a bit differently depending on whether it is running
    on Windows. On Windows, the `ioctlsocket()` function is used with the `FIONBIO`
    flag to indicate non-blocking socket operation. On non-Windows systems, the `fcntl()`
    function is used to set the `O_NONBLOCK` flag for the same purpose.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在Windows上运行时略有不同。在Windows上，使用带有`FIONBIO`标志的`ioctlsocket()`函数来指示非阻塞套接字操作。在非Windows系统上，使用`fcntl()`函数来设置`O_NONBLOCK`标志以实现相同的目的。
- en: In *step 2* and *step 3*, the call to `connect()` is done normally. The only
    difference is that you should expect an error code of `EINPROGRESS` on Unix-based
    systems and `WSAEWOULDBLOCK` on Windows.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*和*步骤 3*中，对`connect()`的调用是正常的。唯一的区别是，你应该在基于Unix的系统上预期`EINPROGRESS`错误代码，在Windows上预期`WSAEWOULDBLOCK`。
- en: 'In *step 4*, the setup for `select()` is straightforward. The `select()` function
    is used in the same way as described in previous chapters. For your convenience,
    the following code shows one way to use `select()` for this purpose:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 4*中，`select()`的设置非常简单。`select()`函数的使用方式与前面章节中描述的相同。为了方便起见，以下代码展示了使用`select()`实现此目的的一种方法：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice in the preceding code that we set a timeout of five seconds. Therefore,
    this `select()` call returns after either the connection is established, the connection
    has an error, or `5` seconds have elapsed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在上述代码中，我们设置了五秒的超时。因此，这个`select()`调用在连接建立、连接出现错误或经过5秒后返回。
- en: 'In *step 5*, setting the socket back to non-blocking mode is accomplished with
    the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 5*中，将套接字设置回非阻塞模式可以通过以下代码实现：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In *step 6*, we are looking to see whether the call to `select()` timed out,
    returned early from an error, or returned early because our socket has successfully
    connected.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 6*中，我们正在检查`select()`调用是否超时、因错误而提前返回，或者因为我们的套接字成功连接而提前返回。
- en: Surprisingly, there is no easy, robust, cross-platform way to check whether
    the socket is connected at this point. My advice is to simply assume that any
    socket marked by `select()` as writable has connected successfully. Just try to
    use the socket. Most TCP client programs will want to call `send()` after connecting,
    anyway. The return value from this first `send()` call indicates whether you have
    a problem.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，目前没有简单、健壮、跨平台的方法来检查套接字是否在此时刻已连接。我的建议是简单地假设任何被`select()`标记为可写的套接字已成功连接。只需尝试使用该套接字。大多数TCP客户端程序在连接后都会想要调用`send()`。这个第一次`send()`调用的返回值表明你是否存在问题。
- en: If you really do want to try and determine the socket state without resorting
    to `send()`, you should be aware of some differences in how `select()` signals
    in this situation. On Unix-based systems, `select()` signals a socket as writable
    once the connection is established. If an error has occurred, `select()` signals
    the socket as both writable and readable. However, if the socket has connected
    successfully and data has arrived from the remote peer, this also produces both
    the readable and writable situation. In that case, the `getsockopt()` function
    can be used to determine whether an error has occurred. On Windows, `select()`
    marks a socket as excepted if an error occurred.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想尝试确定套接字状态而不使用`send()`，你应该意识到在这种情况下`select()`信号的一些差异。在基于Unix的系统上，一旦连接建立，`select()`会将套接字标记为可写。如果发生错误，`select()`会将套接字标记为可读和可写。然而，如果套接字已成功连接并且从远程对等方接收到数据，这也会产生可读和可写的情况。在这种情况下，可以使用`getsockopt()`函数来确定是否发生错误。在Windows上，如果发生错误，`select()`会将套接字标记为excepted。
- en: Please refer to `connect_timeout.c` in this chapter's code repository for a
    working example of the `connect()` timeout method using `select()`. An additional
    example, `connect_blocking.c`, is also included for comparison.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考本章代码库中的`connect_timeout.c`，以获取使用`select()`实现`connect()`超时方法的示例。另外，还包括一个用于比较的示例，`connect_blocking.c`。
- en: Once a new connection is established, our concern moves to preventing data-transfer
    problems. In the worst case, our program could get deadlocked with its peer, preventing
    any data transfer. We'll consider this in more detail next.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了新的连接，我们的关注点就转向防止数据传输问题。在最坏的情况下，我们的程序可能会与对等方发生死锁，阻止任何数据传输。我们将在下一节中更详细地考虑这个问题。
- en: TCP flow control and avoiding deadlock
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP流量控制和避免死锁
- en: When designing application protocols and writing network code, we need to be
    careful to prevent a **deadlock** state. A deadlock is when both sides on a connection
    are waiting for the other side to do something. The worst-case scenario is when
    both sides end up waiting indefinitely.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计应用协议和编写网络代码时，我们需要小心防止**死锁**状态。死锁是指连接两端的双方都在等待对方做某事。最坏的情况是双方最终都无限期地等待。
- en: A trivial example of a deadlock is if both the client and server call `recv()`
    immediately after the connection is established. In that case, both sides wait
    forever for data that is never going to come.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的死锁例子是，如果客户端和服务器在连接建立后立即调用`recv()`。在这种情况下，双方将永远等待永远不会到来的数据。
- en: A less obvious deadlock situation can happen if both parties try to send data
    at the same time. Before we can consider this situation, we must first understand
    a few more details of how TCP connections operate.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果双方同时尝试发送数据，可能会出现一个不太明显的死锁情况。在我们考虑这种情况之前，我们必须首先了解TCP连接操作的一些更多细节。
- en: When data is sent over a TCP connection, this data is broken up into segments.
    A few segments are sent immediately, but additional segments aren't sent over
    the network until the first few segments are acknowledged as being received by
    the connected peer. This is part of TCP's **flow-control** scheme, and it helps
    to prevent a sender from transmitting data faster than a receiver can handle.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过TCP连接发送数据时，这些数据会被分成段。一些段会立即发送，但额外的段不会在网络中发送，直到前几个段被连接的对端确认已接收。这是TCP的**流量控制**方案的一部分，有助于防止发送者发送数据比接收者能处理的速度更快。
- en: 'Consider the following diagram:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图示：
- en: '![](img/d90cf010-182f-48da-8dc8-f225e1c62572.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d90cf010-182f-48da-8dc8-f225e1c62572.png)'
- en: In the preceding diagram, the **Client** sends three TCP segments of data to
    the **Server**. The **Client** has additional **DATA** ready to send, but it must
    wait until the already-sent data is acknowledged. Once the **ACK Message** is
    received, the **Client** resumes sending its remaining **DATA**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，**客户端**向**服务器**发送了三个TCP数据段。**客户端**还有额外的**数据**准备发送，但它必须等待已发送的数据被确认。一旦收到**确认消息**，**客户端**就继续发送其剩余的**数据**。
- en: This is the TCP flow-control mechanism that ensures that the sender isn't transmitting
    faster than the receiver can handle.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是确保发送者不会比接收者处理速度更快的TCP流量控制机制。
- en: Now, keeping in mind that a TCP socket can send only a limited amount of data before
    requiring acknowledgment of receipt, imagine what happens if both parties to a
    TCP connection try to send a bunch of data at the same time. In this case, both
    parties send the first few TCP segments. They both then wait until their peer
    acknowledges receipt before sending more. However, if neither party is reading
    data, then neither party acknowledges receiving data. This is a deadlock state.
    Both parties are stuck waiting forever.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑到TCP套接字在需要接收确认之前只能发送有限量的数据，想象一下如果TCP连接的双方都试图同时发送大量数据会发生什么。在这种情况下，双方都会发送前几个TCP段。然后他们都等待对方确认接收后再发送更多。然而，如果双方都没有读取数据，那么双方都不会确认接收数据。这是一个死锁状态。双方都卡在永远等待的状态中。
- en: Many application protocols prevent this problem by design. These protocols naturally
    alternate between sending and receiving data. For example, in HTTP, the client
    sends a request, and then the server sends a reply. The server only starts sending
    data after the client has finished sending.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用协议通过设计防止了这个问题。这些协议自然地在发送和接收数据之间交替。例如，在HTTP中，客户端发送一个请求，然后服务器发送一个回复。服务器仅在客户端完成发送后才开始发送数据。
- en: However, TCP is a full-duplex protocol. Applications that do need to send data
    in both directions simultaneously should take advantage of TCP's ability to do
    so.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，TCP是一个全双工协议。需要同时向两个方向发送数据的应用程序应该利用TCP的这一能力。
- en: As a motivating example, imagine implementing a file-transfer program where
    both peers to a TCP connection are sending large parts of a file at the same time.
    How do we prevent the deadlock condition?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 作为激励的例子，想象一下实现一个文件传输程序，其中TCP连接的双方都在同时发送文件的大块数据。我们如何防止死锁条件？
- en: The solution to this is straightforward. Both sides should alternate calls to
    `send()` with calls to `recv()`. The liberal use of `select()` will help us do
    this efficiently.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题很简单。双方应该交替调用`send()`和`recv()`。大量使用`select()`将有助于我们有效地做到这一点。
- en: Recall that `select()` indicates which sockets are ready to be read from and
    which sockets are ready to be written to. The `send()` function should be called
    only when you know that a socket is ready to be written to. Otherwise, you risk
    that `send()` may block. In the worst case, `send()` will block indefinitely.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`select()`指示哪些套接字已准备好读取，哪些套接字已准备好写入。只有在你知道套接字已准备好写入时，才应调用`send()`函数。否则，你可能会遇到`send()`阻塞的风险。在最坏的情况下，`send()`可能会无限期地阻塞。
- en: 'Thus, one procedure to send a large amount of data is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，发送大量数据的一个程序如下：
- en: Call `send()` with your remaining data.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用剩余数据调用`send()`。
- en: The return value of `send()` indicates how many bytes were actually consumed
    by `send()`. If fewer bytes were sent than you intended, then your next call to
    `send()` should be used to transmit the remainder.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`send()`的返回值指示`send()`实际消耗了多少字节。如果你发送的字节数少于预期，那么你的下一次`send()`调用应该用来传输剩余的数据。'
- en: Call `select()` with your socket in both the read and write sets.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在读取和写入集合中调用`select()`时使用你的套接字。
- en: If `select()` indicates that the socket is ready to be read from, call `recv()`
    on it and handle the received data as needed.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`select()`指示套接字已准备好读取，则在它上面调用`recv()`并按需处理接收到的数据。
- en: If `select()` indicates that the socket is ready to write to again, go to *step
    1* and call `send()` with the remaining data to be sent.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`select()`指示套接字已准备好再次写入，则回到*步骤1*并使用剩余要发送的数据调用`send()`。
- en: The important point is that calls to `send()` are interspersed with calls to
    `recv()`. In this way, we can be sure that no data is lost, and this deadlock
    condition does not occur.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，`send()`调用与`recv()`调用交织在一起。这样，我们可以确保没有数据丢失，并且不会发生死锁条件。
- en: This method also neatly extends to applications with many open sockets. Each
    socket is added to the `select()` call, and ready sockets are serviced as needed.
    Your application will need to keep track of which data is remaining to be sent
    for each connection.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法也很好地扩展到具有许多打开套接字的应用程序。每个套接字都添加到`select()`调用中，并根据需要服务就绪的套接字。你的应用程序需要跟踪每个连接剩余要发送的数据。
- en: It should also be noted that setting sockets to a non-blocking mode can simplify
    your program's logic in some cases. Even with non-blocking sockets, `select()`
    can still be used as a central blocking point to wait for socket events.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 还应注意的是，将套接字设置为非阻塞模式可以在某些情况下简化你的程序逻辑。即使是非阻塞套接字，`select()`仍然可以用作中央阻塞点来等待套接字事件。
- en: Two files are included with this chapter's code repository that can help to
    demonstrate the deadlock state and how `select()` can be used to prevent it. The
    first file, `server_ignore.c`, implements a simple TCP server that accepts connections
    and then ignores them. The second file, `big_send.c`, initiates a TCP connection
    and then attempts to send lots of data. By using the `big_send` program to connect
    to the `server_ignore` program, you can investigate the blocking behavior of `send()`
    for yourself.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码库中包含两个文件，可以帮助演示死锁状态以及如何使用`select()`来防止它。第一个文件是`server_ignore.c`，它实现了一个简单的TCP服务器，接受连接然后忽略它们。第二个文件是`big_send.c`，它初始化一个TCP连接然后尝试发送大量数据。通过使用`big_send`程序连接到`server_ignore`程序，你可以自己调查`send()`的阻塞行为。
- en: Deadlocks represent only one way a TCP connection can unexpectedly fail. While
    deadlocks can be very difficult to diagnose, they are preventable with careful
    programming. Besides the risk for deadlock, TCP also presents other data transfer
    pitfalls. Let's consider another common performance problem next.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁只是TCP连接意外失败的一种方式。虽然死锁可能非常难以诊断，但通过仔细的编程是可以预防的。除了死锁的风险之外，TCP还带来了其他数据传输的陷阱。接下来，让我们考虑另一个常见的性能问题。
- en: Congestion control
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列控制
- en: As we've just seen, TCP implements flow control to prevent a sender from overwhelming
    a receiver. This flow control works by allowing only a limited number of TCP segments
    to be sent before requiring an acknowledgment of receipt.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚看到的，TCP通过实现流量控制来防止发送方压倒接收方。这种流量控制通过只允许发送有限数量的TCP段，在需要接收确认之前进行工作。
- en: TCP also implements **congestion control** methods as part of a network **congestion-avoidance**
    scheme. While flow control is vital to prevent overwhelming the receiver, congestion
    control is essential to prevent overwhelming the network.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: TCP还实现了作为网络**拥塞避免**方案一部分的**拥塞控制**方法。虽然流量控制对于防止压倒接收方至关重要，但拥塞控制对于防止压倒网络同样关键。
- en: One way TCP congestion control works is by allowing only a limited amount of
    data to be sent before pausing to wait for an acknowledgment of receipt. This
    data limit is decreased when network congestion is detected. In this way, TCP
    doesn't try putting more data over the network than the network can handle.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: TCP拥塞控制的一种方式是在发送一定量的数据后暂停，等待接收到的确认。当检测到网络拥塞时，这个数据限制会减少。这样，TCP不会尝试在网络能够处理之前发送更多的数据。
- en: Another way TCP implements congestion control is through the **TCP slow start
    algorithm**. This method provides a way for TCP to ramp-up a connection to its
    full potential, instead of immediately dumping a lot of data on the network all
    at once.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种TCP实现拥塞控制的方式是通过**TCP慢启动算法**。这种方法为TCP提供了一种逐步提升连接至其最大潜力的方式，而不是一次性将大量数据倾倒到网络上。
- en: It works like this—when a new TCP connection is established, only a minimal
    amount of data is allowed to be sent unacknowledged. When this data is acknowledged,
    the limit is increased. Each time a new acknowledgment is received, the limit
    is increased further until packet loss happens or the limit reaches the desired
    maximum.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理是这样的——当一个新的TCP连接建立时，只允许发送最小量的未确认数据。当这些数据被确认后，限制会增加。每次收到新的确认，限制会进一步增加，直到发生数据包丢失或限制达到期望的最大值。
- en: 'The following diagram shows a TCP slow-start in action:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了TCP慢启动的实际操作：
- en: '![](img/41e61db5-bfc4-4436-8ef0-36829b4f3203.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41e61db5-bfc4-4436-8ef0-36829b4f3203.png)'
- en: In the preceding diagram, you can see that the **Client** starts by sending
    only a little data. Once that data is acknowledged, the **Client** is willing
    to send a larger amount of data before requiring another acknowledgment. Once
    that acknowledgment is received, the **Client** increases its limit again, and
    so on.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到**客户端**开始时只发送少量数据。一旦这些数据被确认，**客户端**愿意在需要另一个确认之前发送更多的数据。一旦收到确认，**客户端**再次增加其限制，依此类推。
- en: The slow-start algorithm can cause problems for short-lived connections. In
    practice, if a connection needs to send only a small amount of data, that connection
    won't ever reach its full potential. This has caused many protocols to be designed
    around keeping connections open for longer. For example, it used to be common
    for an HTTP connection to transmit only one resource. Now it is far more common
    for an HTTP connection to be held open for additional resources, one after another.
    This connection reuse avoids the overhead of the TCP three-way handshake and slow
    start.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 慢启动算法可能会对短暂连接造成问题。在实践中，如果一个连接只需要发送少量数据，那么这个连接永远不会达到其全部潜力。这导致许多协议被设计为保持连接更长时间。例如，过去HTTP连接通常只传输一个资源。现在，HTTP连接保持打开以传输额外资源的情况要普遍得多。这种连接重用避免了TCP三次握手和慢启动的开销。
- en: In addition to avoiding congestion, TCP also provides methods to increase bandwidth
    efficiency.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了避免拥塞外，TCP还提供了提高带宽效率的方法。
- en: The Nagle algorithm
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nagle算法
- en: One technique used by TCP increase efficiency is the **Nagle algorithm**. The
    Nagle algorithm works to make the sender pool small amounts of data together until
    it has enough to justify sending.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: TCP用来提高效率的一种技术是**Nagle算法**。Nagle算法的工作原理是将发送方的小量数据合并在一起，直到有足够的数据可以证明发送的合理性。
- en: Consider sending just one byte of data over a TCP connection. Each TCP segment
    uses 20 bytes to transmit TCP bookkeeping. An additional 20 bytes are needed for
    the IPv4 header. So, this 1 byte of application data becomes 41 bytes on the network.
    That's an overhead of 4,000%, and we are not even counting the overhead from lower
    layers (for example, the Ethernet frame overhead) yet!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在TCP连接上发送仅一个字节的数据。每个TCP段使用20字节来传输TCP记账信息。还需要额外的20字节用于IPv4头部。因此，这1字节的应用数据在网络中变成了41字节。这是4000%的额外开销，而且我们还没有计算来自低层（例如，以太网帧开销）的额外开销！
- en: The Nagle algorithm states that only one small, unacknowledged TCP segment may
    be outstanding at any given time. A small segment is considered any segment less
    than the **Maximum Segment Size** (**MSS**).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Nagle算法指出，在任何给定时间，只能有一个小的、未确认的TCP段是未完成的。任何小于**最大段大小**（**MSS**）的段都被认为是小的段。
- en: 'Let''s see how this applies to a program doing small writes. Consider the following
    code called on a connected, but otherwise idle, TCP socket:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这如何应用于执行小量写入的程序。考虑以下在已连接但其他方面处于空闲状态的TCP套接字上调用的代码：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After the first `send()` call, the `a` data is packed into a TCP message and
    sent off, along with its 40 bytes of TCP and IPv4 overhead.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次`send()`调用之后，`a`数据被封装进一个TCP消息并发送出去，同时附带其40字节的TCP和IPv4开销。
- en: The second `send()` call returns immediately, but the `b` data isn't actually
    sent immediately. The Nagle algorithm causes the `b` data to be queued-up by the
    operating system. It won't be sent until either the first TCP message is acknowledged
    or `send()` is called again with enough additional data to fill up an entire max-size
    TCP segment.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次`send()`调用会立即返回，但`b`数据实际上并不会立即发送。Nagle算法会导致操作系统将`b`数据排队。它不会发送，直到第一个TCP消息被确认或者再次调用`send()`并带有足够的数据来填满一个完整的最大TCP段。
- en: For both `a` and `b` to be received by the recipient, it will take the duration
    of one round-trip network time, plus an additional one-way network time.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让接收方接收到`a`和`b`，需要的时间是一个往返网络时间的持续时间，加上额外的单向网络时间。
- en: 'We can easily get this 1.5 round-trip network time down to 0.5 round-trip network
    time by just using the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下代码轻松地将1.5倍的往返网络时间缩短到0.5倍的往返网络时间：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For this reason, you should always prefer doing one large write to `send()`
    instead of many small ones, whenever possible. Doing one large write allows `ab`
    to be sent in the same TCP message, thereby sidestepping the Nagle algorithm altogether.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在可能的情况下，你应该始终优先选择一次进行大量写入到`send()`，而不是多次小量写入。一次大量写入允许`ab`在同一TCP消息中发送，从而完全绕过Nagle算法。
- en: In some applications, you really do need to send a small packet followed by
    another small packet immediately after. For example, in a real-time multiplayer
    video game, you can't queue up player commands; they must be sent continuously. In
    these cases, it makes sense to disable the Nagle algorithm for reduced latency,
    at the expense of decreased bandwidth efficiency.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用程序中，你确实需要在发送一个小数据包后立即发送另一个小数据包。例如，在实时多人在线视频游戏中，你不能排队存储玩家指令；它们必须连续发送。在这些情况下，为了减少延迟，牺牲带宽效率，禁用Nagle算法是有意义的。
- en: 'Disabling the Nagle algorithm can be done using the `setsockopt()` function.
    The following code shows this method in action:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`setsockopt()`函数来禁用Nagle算法。以下代码展示了这种方法的应用：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Be sure to consider all your options before disabling Nagle. When faced with
    a poorly performing network program, some programmers will disable the Nagle algorithm
    as a first step. In reality, the decision to disable the Nagle algorithm should
    be approached cautiously. Disabling the Nagle algorithm in real-time applications
    often makes sense. Disabling it in other contexts rarely does.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在禁用Nagle算法之前，务必考虑所有选项。当面对性能不佳的网络程序时，一些程序员会首先尝试禁用Nagle算法。实际上，禁用Nagle算法的决定应该谨慎对待。在实时应用程序中禁用Nagle算法通常是有意义的。在其他环境中很少这样做。
- en: For example, imagine that you've implemented an HTTP client. It seems a bit
    sluggish, and so you try disabling the Nagle algorithm. You do that and find that
    it runs much faster now. However, by disabling the Nagle algorithm, you've increased
    network overhead. You could have gotten the same improvement by simply pooling
    together your `send()` calls.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你已经实现了一个HTTP客户端。它似乎有点缓慢，所以你尝试禁用Nagle算法。你这样做后，发现它现在运行得快多了。然而，通过禁用Nagle算法，你增加了网络开销。你可以通过简单地合并你的`send()`调用来实现同样的改进。
- en: If you're implementing a real-time algorithm that does need to send small time-critical
    packets, using `TCP_NODELAY` may still not be the right method for you. TCP can
    introduce delays in many other ways. For example, if one TCP packet is lost over
    the network, no further data can be delivered until that packet is retransmitted.
    This can have the effect of delaying many packets because of one hold-up.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在实现一个确实需要发送小的时间敏感数据包的实时算法，使用`TCP_NODELAY`可能仍然不是适合你的方法。TCP可以通过许多其他方式引入延迟。例如，如果网络中丢失了一个TCP数据包，那么在重新传输该数据包之前，无法发送更多数据。这可能会因为一个数据包的延迟而延迟许多数据包。
- en: Many real-time applications prefer using UDP over TCP. Each UDP packet is entirely
    independent of any other packets sent before or after. Of course, the trade-off
    is that there is a lesser guarantee of reliable delivery; messages may arrive
    in a different order than they were set, and some messages may arrive twice. Nonetheless,
    many applications can tolerate this. Real-time video streaming, for example, can
    use UDP, where each packet stores a very short, time-stamped part of the video.
    If a packet is lost, there is no need to retransmit; the video stutters for a
    moment and resumes when the next packet arrives. Packets received late, or out
    of order, are safely ignored.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 许多实时应用程序更喜欢使用UDP而不是TCP。每个UDP数据包完全独立于之前或之后发送的任何其他数据包。当然，权衡是可靠性保证较低；消息可能以与设置不同的顺序到达，并且某些消息可能到达两次。尽管如此，许多应用程序可以容忍这种情况。例如，实时视频流可以使用UDP，其中每个数据包存储视频的一个非常短、带时间戳的部分。如果数据包丢失，不需要重新传输；视频会暂时卡顿，然后在下一个数据包到达时继续。接收到的晚到或顺序错误的数据包可以安全忽略。
- en: Although the Nagle algorithm often works well to improve network utilization,
    not understanding how it works can lead to problems. In addition to the Nagle
    algorithm, TCP implements many other methods to limit the needless waste of network
    resources. Sometimes, these other methods work poorly with one another. The **delayed
    ACK** is one such method that can work badly with the Nagle algorithm.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Nagle算法通常可以很好地提高网络利用率，但如果不了解它是如何工作的，可能会导致问题。除了Nagle算法之外，TCP还实现了许多其他方法来限制网络资源的无谓浪费。有时，这些其他方法之间工作得不好。**延迟ACK**就是这样一种可能和Nagle算法一起工作得不好的方法。
- en: Delayed acknowledgment
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟确认
- en: We've seen that many client-server protocols work by having the client send
    a request and then the server send a response. We've also seen that when a TCP
    peer reads data off the network, it sends an acknowledgment to let the sender
    know that the data was received successfully.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，许多客户端-服务器协议是通过客户端发送请求然后服务器发送响应来工作的。我们还看到，当TCP对等方从网络中读取数据时，它会发送一个确认，让发送者知道数据已成功接收。
- en: 'A typical client-server interchange might, therefore, look like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，典型的客户端-服务器交互可能看起来如下：
- en: '![](img/99e6e139-9d54-45e9-b163-fb05f28217f7.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/99e6e139-9d54-45e9-b163-fb05f28217f7.png)'
- en: In the preceding diagram, the **Client** first sends a request to the **Server**.
    The **Server** reads this request, and a TCP **ACK Message** is sent back to the
    **Client**. The **Server** then processes the request data and replies with its
    response.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，**客户端**首先向**服务器**发送一个请求。**服务器**读取这个请求，并向**客户端**发送一个TCP **ACK消息**。然后**服务器**处理请求数据，并回复其响应。
- en: Some TCP stacks implement a **delayed acknowledgment** method to reduce network
    congestion. This technique works by delaying the acknowledgment of received data.
    The hope is that the receiver is going to send a response very soon anyway, and
    that the acknowledgment can piggyback on this response. When it works, which is
    often, it conserves bandwidth.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一些TCP堆栈实现了一个**延迟确认**方法来减少网络拥塞。这种技术通过延迟接收数据的确认来实现。希望接收者很快就会发送一个响应，并且确认可以附加在这个响应上。当它起作用时，这通常是经常的，它可以节省带宽。
- en: If the receiver doesn't send a reply, the acknowledgment is sent after a short
    delay; 200 milliseconds is typical.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收者没有发送回复，确认将在短暂的延迟后发送；200毫秒是典型值。
- en: 'If the server from before implements delayed acknowledgment, the client-server
    interchange might look like the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前的服务器实现了延迟确认，客户端-服务器交互可能看起来如下：
- en: '![](img/34dd12d7-990d-43dd-896b-57572f2754b3.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34dd12d7-990d-43dd-896b-57572f2754b3.png)'
- en: This is when delayed acknowledgment works well.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是延迟确认工作得很好的时候。
- en: Now, consider combining the Nagle algorithm with delayed acknowledgment. If
    the client transmits its request in two small messages, then the sending channel
    is blocked for not only the round-trip time. It is also blocked for the additional
    acknowledgment delay time.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑将Nagle算法与延迟确认结合使用。如果客户端通过两个小消息发送其请求，那么发送通道不仅会因为往返时间而被阻塞，还会因为额外的确认延迟时间而被阻塞。
- en: 'This is illustrated in the following diagram:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下图中得到了说明：
- en: '![](img/9dbdd387-cc7c-4913-9c8b-226f395e6a51.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9dbdd387-cc7c-4913-9c8b-226f395e6a51.png)'
- en: In the preceding diagram, we see that the **Client** sent the first part of
    its request in a small packet. The Nagle algorithm prevents it from sending the
    second part of its request until it receives an acknowledgment from the **Server**.
    Meanwhile, the **Server** receives the request, but it delays acknowledgment in
    the hope that it can piggyback the **ACK Message** on the reply. The **Server**
    processes the first part of the request and sees that it doesn't have the full
    request yet, so it cannot send a reply. After the delay period elapses, the **Server**
    does eventually send an **ACK Message**. The **Client** receives this **ACK Message**
    and sends the rest of the reply. The **Server** replies with its response.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们看到**客户端**在小型数据包中发送了其请求的第一部分。Nagle算法阻止它发送请求的第二部分，直到它从**服务器**那里收到确认。同时，**服务器**收到了请求，但它延迟确认，希望能够在回复上附加**ACK消息**。**服务器**处理请求的第一部分，并看到它还没有完整的请求，因此不能发送回复。在延迟期过后，**服务器**最终发送了一个**ACK消息**。**客户端**收到这个**ACK消息**并发送剩余的回复。**服务器**回复其响应。
- en: In this degenerate case, the interaction of the Nagle algorithm and the delayed
    acknowledgment technique cased the **Client**-**Server** interaction to take two
    full round-trip network times plus the delayed acknowledgment time (which could
    itself be many round-trip times).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种退化情况下，Nagle算法和延迟确认技术的交互导致**客户端**-**服务器**交互需要两个完整的往返网络时间加上延迟确认时间（这本身可能需要很多往返时间）。
- en: Some programmers jump in these situations to disable the Nagle algorithm. Sometimes
    that is needed, but often it is the wrong solution.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员在这些情况下会跳出来禁用Nagle算法。有时这是必要的，但通常这不是正确的解决方案。
- en: In our example, merely passing larger data buffers to `send()` completely solves
    the degenerate interaction. Passing the entire request to `send()` in one call
    reduces the transaction time from two round-trips plus delay to one round-trip
    and no delay.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，仅仅将更大的数据缓冲区传递给`send()`就可以完全解决这种退化交互。在一次调用中将整个请求传递给`send()`可以将事务时间从两个往返加上延迟减少到一个往返和没有延迟。
- en: My advice is to prefer calling `send()` with one large write instead of multiple
    small writes, whenever possible. Of course, if you're implementing a real-time
    application with TCP, then you can't pool `send()` calls. In that case, disabling
    the Nagle algorithm can be the correct call.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是，在可能的情况下，最好使用一次大的写入调用`send()`，而不是多次小的写入。当然，如果你正在实现一个使用TCP的实时应用程序，那么你不能池化`send()`调用。在这种情况下，禁用Nagle算法可能是正确的选择。
- en: For the sake of completeness, it should be noted that a delayed ACK can usually
    be disabled. This is done by passing `TCP_QUICKACK` to `setsockopt()` on systems
    that support it. Again, this is not usually needed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，应该指出，延迟ACK通常可以禁用。这是通过在支持它的系统上向`setsockopt()`传递`TCP_QUICKACK`来完成的。再次强调，这通常不是必需的。
- en: Now that we've reviewed a few hidden problems that can crop up with active TCP
    connections, it's time to move on to connection teardown.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了一些可能出现在活动TCP连接中的隐藏问题，现在是时候转向连接断开操作了。
- en: Connection tear-down
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接断开
- en: The way a TCP connection transitions from an established connection to a closed
    one is nuanced. Let's consider this in more detail.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: TCP连接从建立连接过渡到关闭连接的过程是微妙的。让我们更详细地考虑这个问题。
- en: TCP connections are **full-duplex**. This means that the data being sent is
    independent of the data being received. Data is sent and received simultaneously.
    This also implies that the connection must be closed by both sides before it is
    truly disconnected.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: TCP连接是**全双工**的。这意味着发送的数据与接收的数据是独立的。数据同时发送和接收。这也意味着在真正断开连接之前，连接必须由双方关闭。
- en: To close a TCP connection, each side sends a **Finish** (**FIN**) message and
    receives an ACK message from their peer.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭TCP连接，每一方都会发送一个**结束**（**FIN**）消息，并从其对等方接收一个ACK消息。
- en: 'The exact tear-down process, from the perspective of each peer, depends on
    whether it sent a FIN first, or received a FIN first. There are three basic connection
    tear-down cases. They are as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从每个对等方的角度来看，确切的断开过程取决于它是首先发送FIN，还是首先收到FIN。有三种基本的连接断开情况。具体如下：
- en: You initiate the tear-down by sending the first FIN message
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你通过发送第一个FIN消息来启动断开操作
- en: You receive a FIN message from your connected peer
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你从你的连接对等方收到一个FIN消息
- en: You and your peer send FIN messages simultaneously
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你和你的对等方同时发送FIN消息
- en: In case 3, where both sides send a FIN message simultaneously, each side thinks
    that it is in case 1\. That is, each side thinks that it has sent the first FIN
    message, and each side tears down its socket as in case 1\. In practice, this
    is pretty rare, but certainly possible.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3种情况下，双方同时发送FIN消息，每一方都认为它处于第1种情况。也就是说，每一方都认为它已经发送了第一个FIN消息，并且每一方都像第1种情况一样断开它的套接字。在实践中，这种情况相当罕见，但确实可能发生。
- en: When a TCP socket is open for full-duplex communication, it is said to be in
    the `ESTABLISHED` state. The closing initiator sends a FIN message to its peer.
    The peer replies with an ACK. At this point, the connection is only half closed.
    The initiator can no longer send data, but it can still receive data. The peer
    has the option to continue to send more data to the closing initiator. When the
    peer is ready to finish closing the connection, it sends its own FIN message.
    The initiator then responds with the final ACK message, and the connection is
    fully closed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个TCP套接字用于全双工通信时，它处于`ESTABLISHED`状态。关闭的发起方向其对等方发送一个FIN消息。对等方回复一个ACK。在这个时候，连接只是半关闭。发起方不能再发送数据，但它仍然可以接收数据。对等方可以选择继续向关闭的发起方发送更多数据。当对等方准备好完成关闭连接时，它发送自己的FIN消息。然后发起方回复最终的ACK消息，连接就完全关闭了。
- en: The TCP connection state transitions on the initiator are `ESTABLISHED`, `FIN-WAIT-1`,
    `FIN-WAIT-2`, `TIME-WAIT`, and `CLOSED`. The TCP connection state transitions
    on the receiving peer are `ESTABLISHED`, `CLOSE-WAIT`, `LAST-ACK`, and `CLOSED`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在**发起方**上的TCP连接状态转换是`ESTABLISHED`、`FIN-WAIT-1`、`FIN-WAIT-2`、`TIME-WAIT`和`CLOSED`。在**接收方**上的TCP连接状态转换是`ESTABLISHED`、`CLOSE-WAIT`、`LAST-ACK`和`CLOSED`。
- en: 'The following diagram illustrations the normal TCP four-way closing handshake:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了正常的TCP四次关闭握手：
- en: '![](img/b0d1267f-37e2-4887-be22-f59535f917c2.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0d1267f-37e2-4887-be22-f59535f917c2.png)'
- en: It is sometimes possible for the **Peer** to combine its **ACK Message** and
    **FIN Message** into one message. In that case, the connection can be torn down
    with only three messages, instead of four.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，**对等方**可以将它的**ACK消息**和**FIN消息**合并成一个消息。在这种情况下，连接可以通过只有三个消息而不是四个消息来断开。
- en: In the case where both sides initiate the tear-down simultaneously, both sides
    follow the state transition of the **Initiator**. The messages sent and received
    are the same.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在双方同时发起断开连接的情况下，双方都遵循**发起方**的状态转换。发送和接收的消息是相同的。
- en: Networks are inherently unreliable, so there is a chance that the final **ACK
    Message** sent by the **Initiator** will be lost. In this case, the **Peer**,
    having not received an **ACK Message**, resends its **FIN Message**. If the **Initiator**
    had completely **CLOSED** its socket after sending the final **ACK Message**,
    then it would be impossible to reply to this resent **FIN Message**. For this
    reason, the **Initiator** enters a `TIME-WAIT` state after sending the last **ACK
    Message**. During this `TIME-WAIT` state, it responds to any retransmitted **FIN
    Message** from the **Peer** with an **ACK Message**. After a delay, the **Initiator**
    leaves the `TIME-WAIT` state and fully closes its socket.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 网络本质上是不可靠的，所以有可能**发起方**发送的最后一个**ACK消息**会丢失。在这种情况下，由于没有收到**ACK消息**，**对等方**会重发它的**FIN消息**。如果**发起方**在发送最后一个**ACK消息**后完全**关闭**了它的套接字，那么它将无法回复这个重发的**FIN消息**。因此，**发起方**在发送最后一个**ACK消息**后会进入`TIME-WAIT`状态。在这个`TIME-WAIT`状态下，它会用**ACK消息**回复**对等方**重传的任何**FIN消息**。经过一段延迟后，**发起方**离开`TIME-WAIT`状态并完全关闭它的套接字。
- en: The `TIME-WAIT` delay is usually on the order of one minute, but it could be
    configured for much longer.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIME-WAIT`延迟通常是一分钟左右的量级，但可以配置得更长。'
- en: In this book, we've used only the `close()` function (`closesocket()` on Windows)
    to disconnect a socket. This function, although simple to use, has the disadvantage
    of always fully closing a socket. That is, no data can be sent or received on
    a socket called with `close()`. The TCP teardown handshake does allow for data
    to be received after a FIN message has been sent. Let's next consider how to do
    this programmatically.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们只使用了`close()`函数（在Windows上是`closesocket()`）来断开套接字。这个函数虽然使用简单，但有一个缺点，就是总是完全关闭套接字。也就是说，在调用`close()`的套接字上无法发送或接收数据。TCP断开连接的握手过程确实允许在发送FIN消息后接收数据。接下来，让我们考虑如何通过程序来实现这一点。
- en: The shutdown() function
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`shutdown()`函数'
- en: As we've just seen, TCP connections are torn down in two steps. The first one
    side sends a FIN message, and then the other side does. However, each side is
    allowed to continue to send data until it has sent its own FIN message.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，TCP连接是通过两个步骤断开的。首先，一方发送一个FIN消息，然后另一方发送。然而，每一方都有权继续发送数据，直到它发送了自己的FIN消息。
- en: We've used the `close()` function (`closesocket()` on Windows) to disconnect
    sockets because of its simplicity. The `close()` function, however, closes both
    sides of a socket. If you use `close()` in your application, and the remote peer
    tries to send more data, it will cause an error. Your system will then transmit
    a **Reset** (**RST**) message to indicate to the peer that the connection was
    not closed in an orderly manner.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`close()`函数（在Windows上是`closesocket()`）来断开套接字，因为它很简单。然而，`close()`函数会关闭套接字的两个端。如果你在应用程序中使用`close()`，而远程对等方尝试发送更多数据，这将导致错误。然后，你的系统将发送一个**重置**（**RST**）消息，向对等方表明连接没有有序地关闭。
- en: If you want to close your sending channel, but still leave the option for receiving
    more data, you should use the `shutdown()` function instead. The `shutdown()`
    function takes two parameters. The first parameter is a socket, and the second
    is an `int` indicating how to shut down the socket.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要关闭你的发送通道，但仍然保留接收更多数据的选择，你应该使用`shutdown()`函数。`shutdown()`函数接受两个参数。第一个参数是一个套接字，第二个是一个`int`类型的参数，表示如何关闭套接字。
- en: In theory, `shutdown()` supports three options—closing the sending side of a
    connection, closing the receiving side, and closing both sides. However, the TCP
    protocol itself doesn't reflect these options, and it is rarely useful to use
    `shutdown()` for closing the receiving side.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，`shutdown()`支持三种选项——关闭连接的发送端、关闭接收端和关闭两端。然而，TCP协议本身并不反映这些选项，并且使用`shutdown()`来关闭接收端很少有用。
- en: There is a small portability issue about `shutdown()` functions parameters.
    Under windows, you want to call it with `SD_SEND`. On other systems, you should
    use `SHUT_WR`. Both values are defined as `1`, so you can also call it that way.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`shutdown()`函数的参数存在一个小的问题。在Windows下，你应该使用`SD_SEND`来调用它。在其他系统上，你应该使用`SHUT_WR`。这两个值都定义为`1`，因此你也可以这样调用它。
- en: 'The code to shutdown the sending channel of a socket in a cross-platform manner
    is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨平台方式下关闭套接字发送通道的代码如下：
- en: '[PRE12]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This use of `shutdown()` causes the TCP FIN message to be transmitted after
    the transmission queued is emptied.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用`shutdown()`的方式会导致TCP FIN消息在传输队列清空后传输。
- en: You may wonder, if you're receiving data from a peer, and `recv()` returns `0`,
    how you know whether your peer has called `shutdown()` or `close()`? Unfortunately,
    you can't know, except by prior agreement. If they have used `shutdown()` only
    to close their sending data channel, then they are still receptive to additional
    data. If they instead used `close()`, additional data will trigger an error state.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，如果你从对等方接收数据，并且`recv()`返回`0`，你如何知道你的对等方是调用了`shutdown()`还是`close()`？不幸的是，你无法知道，除非事先有协议。如果它们只使用`shutdown()`来关闭它们的发送数据通道，那么它们仍然可以接收额外的数据。如果它们使用`close()`，额外的数据将触发错误状态。
- en: Although half-closed connections have their uses, it is often easier to use
    an application protocol that clearly indicates the end of the transaction. For
    example, consider the HTTP protocol covered in [Chapter 6](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml),
    *Building a Simple Web Client*. With the HTTP protocol, the client indicates the
    end of its request with a blank line. The server knows it has the full request
    when it sees this blank line. The server then specifies how much data it will
    be sending with the `Content-Length` header. Once the client has received that
    much data, it knows that it hasn't missed anything. The client can then call `close()`
    and be confident that the server won't be sending additional data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然半关闭连接有其用途，但通常使用一个明确指示事务结束的应用协议更容易。例如，考虑第6章中介绍的HTTP协议，*构建简单的Web客户端*。使用HTTP协议，客户端通过一个空白行来指示其请求的结束。服务器在看到这个空白行时知道它已经收到了完整的请求。然后，服务器通过`Content-Length`头指定它将发送多少数据。一旦客户端收到了这么多数据，它就知道它没有错过任何东西。然后客户端可以调用`close()`，并确信服务器不会发送额外的数据。
- en: In many applications, knowing whether the shutdown was orderly isn't always
    useful. Consider the chat room program (`tcp_serve_chat.c`) from [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml),
    *An In-Depth Overview of TCP Connections*. This program has no real application
    protocol. That program simply sends messages from one client to every other client.
    When a client decides to disconnect, it isn't important that it continues to receive
    data from the server. Guaranteeing an orderly TCP release would provide no benefit.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用程序中，知道关闭是否有序并不总是有用的。考虑来自[第3章](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml)的聊天室程序(`tcp_serve_chat.c`)，*TCP连接的深入概述*。这个程序没有真正的应用程序协议。那个程序只是将消息从一位客户端发送到其他所有客户端。当一个客户端决定断开连接时，它继续从服务器接收数据并不重要。保证有序的TCP释放不会带来任何好处。
- en: So, when is `shutdown()` useful? Basically, a TCP orderly release is useful
    when the application protocol doesn't have a way to signal that it has finished
    sending data, and your application isn't tolerant of missed data. In that case,
    `shutdown()` is a useful signal.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当何时使用`shutdown()`呢？基本上，当应用程序协议没有方法来表示它已经完成发送数据，并且你的应用程序不能容忍丢失数据时，TCP有序释放是有用的。在这种情况下，`shutdown()`是一个有用的信号。
- en: Please note that if you're using threading or forking, there are additional
    differences to the behavior of `close()` versus `shutdown()` that must be considered.
    When `shutdown()` is called, it always affects the socket. The `close()` function,
    by contrast, has no effect if additional processes also hold handles to the socket.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你使用线程或进程创建，`close()`与`shutdown()`的行为会有额外的差异，必须考虑。当调用`shutdown()`时，它总是影响套接字。相比之下，如果还有其他进程也持有套接字的句柄，`close()`函数就没有效果。
- en: Finally, note that `close()` must still eventually be called on a socket closed
    with `shutdown()` in order to release associated system resources.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，即使使用`shutdown()`关闭套接字，也必须最终调用`close()`来释放相关的系统资源。
- en: Another issue that comes up around the TCP tear-down procedure is the long delay
    for the side that initiated the close to remain in the `TIME-WAIT` state. This
    can sometimes cause problems for TCP servers. Let's look at that next.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在TCP连接拆除过程中出现的一个问题是，发起关闭的一方在保持`TIME-WAIT`状态时会有较长的延迟。这有时会给TCP服务器带来问题。让我们接下来看看这个问题。
- en: Preventing address-in-use errors
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止地址已使用错误
- en: If you do TCP server programming for very long, you will eventually run into
    the following scenario—your TCP server has one or more open connections, and then
    you terminate it (or it crashes). You restart the server, but the call to `bind()`
    fails with an `EADDRINUSE` (`WSAEADDRINUSE` on Windows) error.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你长时间进行TCP服务器编程，你最终会遇到以下场景——你的TCP服务器有一个或多个打开的连接，然后你终止它（或它崩溃）。你重新启动服务器，但`bind()`调用失败，出现`EADDRINUSE`（Windows上的`WSAEADDRINUSE`）错误。
- en: When this happens, you can wait a few moments, try it again, and it works. What's
    going on here?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，你可以等待几分钟，再次尝试，然后它就会工作。这里发生了什么？
- en: Essentially, when an application initiates a TCP socket close (or causes the
    disconnection by crashing), that socket goes into the `TIME-WAIT` state. The operating
    system continues to keep track of this socket for some time, potentially minutes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当一个应用程序初始化TCP套接字关闭（或通过崩溃导致断开连接）时，该套接字进入`TIME-WAIT`状态。操作系统会持续跟踪这个套接字一段时间，可能是几分钟。
- en: An example program, `server_noreuse.c`, is included in this chapter's code repo.
    You can reproduce this address-in-use problem by running it, accepting a connection,
    and then terminating `server_noreuse`. To reproduce the problem, it is vital that
    the server is the one to terminate the open connection, not the client.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码库中包含了一个示例程序`server_noreuse.c`。你可以通过运行它、接受连接然后终止`server_noreuse`来重现地址已使用的问题。为了重现这个问题，服务器必须终止打开的连接，而不是客户端。
- en: If you immediately start `server_noreuse` again, you will see the `bind()` error.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你立即再次启动`server_noreuse`，你会看到`bind()`错误。
- en: 'The following screenshot shows this on a Linux desktop:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Linux桌面上的这一情况：
- en: '![](img/41a33bfe-17d9-4f2f-83fc-c8343bc0c0a0.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41a33bfe-17d9-4f2f-83fc-c8343bc0c0a0.png)'
- en: 'You can use the `netstat` command to see these half-dead connections that are
    preventing our server from starting. The following command shows which connections
    are stuck in the `TIME-WAIT` state on Linux:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`netstat`命令查看这些半死不活的连接，这些连接阻止了我们的服务器启动。以下命令显示了Linux上处于`TIME-WAIT`状态的连接：
- en: '[PRE13]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As long as one of these connections is hanging on, it prevents any new process
    from calling `bind()` on the same local port and address.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 只要这些连接中的任何一个挂起，它就会阻止任何新的进程在相同的本地端口和地址上调用`bind()`。
- en: This failure of the `bind()` call can be prevented by setting the `SO_REUSEADDR`
    flag on the server socket before calling `bind()`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在调用`bind()`之前在服务器套接字上设置`SO_REUSEADDR`标志，可以防止`bind()`调用失败。
- en: 'The following code demonstrates this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了这一点：
- en: '[PRE14]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once the `SO_REUSEADDR` flag is set, `bind()` succeeds even if a few `TIME-WAIT`
    connections are still hanging on to the same local port and address.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了`SO_REUSEADDR`标志，即使还有几个`TIME-WAIT`连接仍然挂在该本地端口和地址上，`bind()`也会成功。
- en: An example program, `server_reuse.c`, is included to demonstrate this technique.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了一个示例程序`server_reuse.c`，用于演示这项技术。
- en: I suggest that you always use `SO_REUSEADDR` for TCP servers because there are
    few downsides. The only real drawback is that using `SO_REUSEADDR` allows your
    program to bind to a specific interface even if another program has already bound
    to the wildcard address. Usually, this isn't a problem, but it is something to
    keep in mind.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您始终为TCP服务器使用`SO_REUSEADDR`，因为它的缺点很少。唯一的真正缺点是使用`SO_REUSEADDR`允许您的程序绑定到特定接口，即使另一个程序已经绑定了通配符地址。通常，这不会成为问题，但这是需要记住的事情。
- en: You may sometimes see programs that attempt to fix this issue by killing sockets
    in the `TIME-WAIT` state. This can be accomplished by setting the socket linger
    option. This is dangerous! The `TIME-WAIT` state is essential to TCP's reliability,
    and interfering with it can lead to severe problems.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您可能会看到尝试通过杀死`TIME-WAIT`状态中的套接字来修复此问题的程序。这可以通过设置套接字linger选项来实现。这是危险的！`TIME-WAIT`状态对于TCP的可靠性至关重要，干扰它可能会导致严重问题。
- en: Why is this address-in-use only a problem for servers and not clients? Because
    the problem manifests itself when calling `bind()`. Client programs don't usually
    call `bind()`. If they do, this can also be a problem on the client-side.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个地址已使用的问题只针对服务器而不是客户端？因为这个问题在调用`bind()`时显现出来。客户端程序通常不会调用`bind()`。如果他们这样做，这也会在客户端引起问题。
- en: While we are still on the topic of disconnected sockets, what happens when you
    try to send data to a peer that has already called `close()`? Let's consider that
    next.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们还在讨论断开连接的套接字时，当你尝试向已经调用`close()`的对等方发送数据时会发生什么？让我们考虑一下这个问题。
- en: Sending to a disconnected peer
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向断开连接的对等方发送数据
- en: 'There are three basic ways a TCP connection can fail. They are as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: TCP连接可能失败的基本方式有三种。如下所示：
- en: A network outage
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络中断
- en: The peer application crashes
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对等应用程序崩溃
- en: The peer's system crashes
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对等方的系统崩溃
- en: A network outage prevents data from reaching your peer. In this case, TCP tries
    to retransmit data. If connectivity is re-established, TCP simply picks back up
    where it left off. Otherwise, the connection eventually times out. This timeout
    can be on the order of 10 minutes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中断阻止数据到达您的对等方。在这种情况下，TCP会尝试重新传输数据。如果重新建立了连接，TCP将简单地从上次停止的地方继续。否则，连接最终会超时。这个超时可能长达10分钟。
- en: The second way a TCP connection can fail is if the connected peer application
    crashes. In this case, the peer's operating system sends a FIN message. This case
    is indistinguishable from the peer calling `close()` on their end. If your application
    continues to send data after having received the FIN message, the peer's system
    will send an RST message to indicate an error.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: TCP连接可能失败的第二种方式是对等的应用程序崩溃。在这种情况下，对等方的操作系统会发送一个FIN消息。这种情况与对等方在他们的端点调用`close()`无法区分。如果您的应用程序在收到FIN消息后继续发送数据，对等方的系统将发送一个RST消息来指示错误。
- en: Finally, a connection could fail because the peer's whole system has crashed.
    In this case, it won't be able to send a FIN message. This case looks the same
    as a network outage, and the TCP connection would eventually timeout. However,
    consider what happens if the crashed system reboots before the connection times
    out. In that case, the rebooted system will eventually receive a TCP message from
    the original connection. The rebooted system will not recognize the TCP connection
    and will send an RST message in response to indicate an error condition.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，连接可能会因为对等方的整个系统崩溃而失败。在这种情况下，它将无法发送一个FIN消息。这种情况看起来与网络中断相似，TCP连接最终会超时。然而，考虑一下如果崩溃的系统在连接超时之前重新启动会发生什么。在这种情况下，重新启动的系统最终会从原始连接接收到TCP消息。重新启动的系统将不会识别TCP连接，并将发送一个RST消息作为响应，以指示错误状态。
- en: To reiterate, if you use `send()` on a socket that your peer thinks is closed,
    that peer will respond with an RST message. This state is easily detected by the
    return value of `recv()`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果你在一个你认为已经关闭的套接字上使用 `send()`，那么对端会响应一个 RST 消息。这个状态可以通过 `recv()` 的返回值轻松检测到。
- en: A more serious issue to consider is what happens when `send()` is called on
    a socket that has already received an RST message from its peer. On Unix-based
    systems, the default is to send a `SIGPIPE` signal to your program. If you don't
    handle this signal, the operating system will terminate your program.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一个更严重的问题是，当在已经从对端收到 RST 消息的套接字上调用 `send()` 时会发生什么。在基于 Unix 的系统上，默认操作是向你的程序发送一个
    `SIGPIPE` 信号。如果你不处理这个信号，操作系统将终止你的程序。
- en: It is therefore essential for TCP servers to either handle or disable the `SIGPIPE`
    signal. Failure to handle this case means that a rude client could kill your server.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于 TCP 服务器来说，处理或禁用 `SIGPIPE` 信号是至关重要的。未能处理这种情况意味着一个粗鲁的客户端可能会杀死你的服务器。
- en: Signals are complicated. If you're already using signals in your program, you
    may want to handle `SIGPIPE`. Otherwise, I recommend you just disable it by setting
    the `SIGPIPE` handler to `SIG_IGN`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 信号很复杂。如果你已经在你的程序中使用了信号，你可能想处理 `SIGPIPE`。否则，我建议你通过将 `SIGPIPE` 处理程序设置为 `SIG_IGN`
    来禁用它。
- en: 'The following code disables `SIGPIPE` on Unix-based systems:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在基于 Unix 的系统上禁用 `SIGPIPE`：
- en: '[PRE15]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As an alternative, you can use `MSG_NOSIGNAL` with `send()` as shown in the
    following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种替代方法，你可以在 `send()` 中使用 `MSG_NOSIGNAL`，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the signal is ignored or `MSG_NOSIGNAL` is used, `send()` returns `-1` and
    sets `errno` to `EPIPE`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果忽略信号或使用 `MSG_NOSIGNAL`，`send()` 将返回 `-1` 并将 `errno` 设置为 `EPIPE`。
- en: On Windows, attempting to call `send()` on a closed socket generally results
    in `WSAGetLastError()` returning `WSAECONNRESET`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，尝试在已关闭的套接字上调用 `send()` 通常会导致 `WSAGetLastError()` 返回 `WSAECONNRESET`。
- en: An example program, `server_crash.c`, is included in this chapter's code repository.
    This program accepts TCP connections on port `8080`. It then waits for the client
    to disconnect, and then attempts two sends to that disconnected client. This program
    is useful as a tool to explore the return values, error codes, and function behavior
    in different scenarios.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码库中包含了一个示例程序，`server_crash.c`。该程序在端口 `8080` 上接受 TCP 连接。然后它等待客户端断开连接，然后尝试向该断开连接的客户端发送两次数据。这个程序作为一个工具，可以用来探索不同场景下的返回值、错误代码和函数行为。
- en: Socket's local address
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字的本地地址
- en: When implementing servers, for both TCP and UDP, it is important to bind the
    listening socket to a local address and port. If the socket isn't bound, then
    clients can't know where to connect.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现服务器时，无论是 TCP 还是 UDP，将监听套接字绑定到本地地址和端口都是非常重要的。如果套接字没有绑定，那么客户端将不知道如何连接。
- en: It is also possible to use `bind()` on the client side to associate a socket
    with a particular address and port. It is sometimes useful to use `bind()` in
    this manner on machines that have multiple network interfaces. The use of `bind()`
    can allow the selection of which network address to use for the outgoing connection.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在客户端使用 `bind()` 来将套接字与特定的地址和端口关联。在具有多个网络接口的机器上，有时使用 `bind()` 以这种方式是有用的。使用
    `bind()` 可以允许选择用于出站连接的网络地址。
- en: Sometimes, `bind()` is used to set the local port for an outgoing connection.
    This is usually a bad idea for a few reasons. First, it very seldom serves any
    purpose. The port number presented to the connected server is likely to be different
    because of network address translation regardless. Binding to a local port also
    invites the error of selecting a port that is already in use. Usually, the operating
    system takes care of selecting a free port. This use of `bind()` also raises the
    issue with `TIME-WAIT`, which would prevent a new connection from being established
    after a closed one without a substantial delay.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`bind()` 用于设置出站连接的本地端口。这通常有几个原因是不好的。首先，它很少有什么实际用途。无论网络地址转换如何，提供给连接服务器的端口号可能都会不同。绑定到本地端口还可能邀请选择一个已经被使用的端口号的错误。通常，操作系统会负责选择一个空闲的端口号。这种使用
    `bind()` 的方式还会引发 `TIME-WAIT` 的问题，这会导致在关闭一个连接后，没有显著延迟的情况下，无法建立新的连接。
- en: We have used `bind()` in this book mostly for binding servers to a particular
    port number. It can also be used to associate servers to a particular address.
    If a server has multiple network interfaces, it may be the case that you only
    care to listen on connections at one address. In this case, `bind()` can easily
    be used to limit the connections to that address. It can also be used to limit
    connections to the local machine by binding sockets to `127.0.0.1`. This can be
    an important security measure for some applications.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们主要使用`bind()`将服务器绑定到特定的端口号。它也可以用来将服务器关联到特定的地址。如果一个服务器有多个网络接口，可能你只关心在某个地址上监听连接。在这种情况下，`bind()`可以很容易地用来限制连接到该地址。它也可以用来通过将套接字绑定到`127.0.0.1`来限制连接到本地机器。这可能是一些应用程序的重要安全措施。
- en: We have employed the `select()` function for many purposes—timing out `connect()`,
    signaling when data is available, and preventing `send()` from blocking. However,
    `select()` is only suitable for monitoring a limited number of sockets. Let's
    look at this limitation, and how to circumvent it, next.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了`select()`函数来完成许多任务——超时`connect()`、在数据可用时发出信号以及防止`send()`阻塞。然而，`select()`只适用于监控有限数量的套接字。让我们看看这个限制，以及如何绕过它。
- en: Multiplexing with a large number of sockets
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用大量套接字进行多路复用
- en: We've used `select()` in this book to multiplex between open sockets. The `select()` function is
    great because it is available on many platforms. However, if you have a large
    number of open sockets, you can quickly run into the limitations of `select()`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用了`select()`在打开的套接字之间进行多路复用。`select()`函数很棒，因为它在许多平台上都可用。然而，如果你有大量的打开套接字，你可能会迅速遇到`select()`的限制。
- en: There is a maximum number of sockets you can pass to `select()`. This number
    is available through the `FD_SETSIZE` macro.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向`select()`传递的最大套接字数量。这个数字可以通过`FD_SETSIZE`宏获得。
- en: This chapter's code repository includes a program, `setsize.c`, which prints
    the value of `FD_SETSIZE`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码仓库包含一个程序，`setsize.c`，它打印出`FD_SETSIZE`的值。
- en: 'The following screenshot shows this program being compiled and run on Windows
    10:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了在Windows 10上编译和运行此程序：
- en: '![](img/3507d567-9997-464f-8647-8c1ced30825c.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3507d567-9997-464f-8647-8c1ced30825c.png)'
- en: The preceding screenshot shows `FD_SETSIZE` is `64` on this system. Although
    Windows's default size for `FD_SETSIZE` is quite low, it is common to see higher
    values on other systems. The default value of `FD_SETSIZE` on Linux is `1024`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示，在这个系统中`FD_SETSIZE`的值为`64`。尽管Windows中`FD_SETSIZE`的默认值相当低，但在其他系统中通常可以看到更高的值。Linux中`FD_SETSIZE`的默认值是`1024`。
- en: 'On Windows, it is possible to increase `FD_SETSIZE` easily. You only need to
    define `FD_SETSIZE` yourself before including the `winsock2.h` header. For example,
    the following code increases `FD_SETSIZE` to `1024` on Windows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，可以很容易地增加`FD_SETSIZE`。你只需要在包含`winsock2.h`头文件之前自己定义`FD_SETSIZE`。例如，以下代码将Windows上的`FD_SETSIZE`增加到`1024`：
- en: '[PRE17]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This works because Winsock uses `FD_SETSIZE` to build the `fd_set` type.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为Winsock使用`FD_SETSIZE`来构建`fd_set`类型。
- en: On Linux, this trick does not work. Linux defines `fd_set` as a bitmask, and
    it is not possible to increase its size without recompiling the kernel.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，这个技巧不起作用。Linux将`fd_set`定义为位掩码，并且在不重新编译内核的情况下无法增加其大小。
- en: 'There are possible workarounds to effectively cheat `select()` into accepting
    socket descriptors larger than `1023` on Linux. One trick that usually works is
    to allocate an array of `fd_set` variables. Setting a socket is then done like
    this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能的工作区可以有效地欺骗`select()`在Linux上接受大于`1023`的套接字描述符。通常有效的一个技巧是分配一个`fd_set`变量的数组。设置套接字的方式如下：
- en: '[PRE18]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: However, if you have to resort to a hack such as the preceding code, you may
    be better off avoiding `select()` and using a different multiplexing technique.
    The `poll()` function, for example, provides the functionality of `select()` without
    a limit on the number of file descriptors it can handle.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你不得不求助于像前面代码那样的黑客手段，你可能会更好地避免使用`select()`并使用不同的多路复用技术。例如，`poll()`函数提供了与`select()`相同的功能，但它没有处理文件描述符数量的限制。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We covered a lot of ground in this chapter. First, we reviewed error-handling
    methods, and then we implemented a function to obtain text descriptions for error
    codes.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容。首先，我们回顾了错误处理方法，然后实现了一个函数来获取错误代码的文本描述。
- en: We then jumped right into the hard details of TCP sockets. We saw how TCP sockets
    hide much complexity, and how it is sometimes necessary to understand that hidden
    state to get good application performance. We saw a method for an early timeout
    on a TCP `connect()` call, and we looked at how to terminate a connection with
    an orderly release.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后直接深入TCP套接字的复杂细节。我们看到了TCP套接字如何隐藏大量复杂性，以及有时理解这些隐藏状态对于获得良好的应用程序性能是必要的。我们看到了TCP
    `connect()`调用早期超时的一个方法，并探讨了如何通过有序释放来终止连接。
- en: We then took a closer look at the `bind()` function and how its usefulness differs
    between servers and clients. Finally, we discussed how the `select()` function
    limits the total number of sockets your program can handle, and how to work around
    it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后更详细地研究了`bind()`函数及其在服务器和客户端之间使用上的不同之处。最后，我们讨论了`select()`函数如何限制程序可以处理的套接字总数，以及如何绕过这一限制。
- en: So far, this book has been focused mainly on network code as it would pertain
    to personal computers and servers. In the next chapter, [Chapter 14](c8466f85-a6e3-4d33-beb7-0a9f38d35062.xhtml), *Web
    Programming for the Internet of Things*, we move our focus to the extending of
    internet access to everyday objects—that is, the **Internet of Things**.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书主要关注与个人电脑和服务器相关的网络代码。在下一章，[第14章](c8466f85-a6e3-4d33-beb7-0a9f38d35062.xhtml)，*物联网网络编程*中，我们将关注点转向将互联网接入日常对象——即，**物联网**。
- en: Questions
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge acquired from this chapter:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试你从本章获得的知识：
- en: Is it ever acceptable to just terminate a program if a network error is detected?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检测到网络错误时，是否可以仅终止程序？
- en: Which system functions are used to convert error codes into text descriptions?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些系统功能用于将错误代码转换为文本描述？
- en: How long does it take for a call to `connect()` to complete on a TCP socket?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在TCP套接字上，一个`connect()`调用完成需要多长时间？
- en: What happens if you call `send()` on a disconnected TCP socket?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在一个断开的TCP套接字上调用`send()`会发生什么？
- en: How can you ensure that the next call to `send()` won't block?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何确保下一次对`send()`的调用不会阻塞？
- en: What happens if both peers to a TCP connection try to send a large amount of
    data simultaneously?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果TCP连接的两个端点同时尝试发送大量数据会发生什么？
- en: Can you improve application performance by disabling the Nagle algorithm?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过禁用Nagle算法，你能提高应用程序的性能吗？
- en: How many connections can `select()` handle?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`select()`可以处理多少个连接？'
- en: The answers to these questions are found in [Appendix A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml),
    *Answers to Questions*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案可以在[附录A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml)，*问题解答*中找到。
