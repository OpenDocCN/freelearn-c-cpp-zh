- en: Learning to Program File Input/Output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习编程文件输入/输出
- en: File **input**/**output** (**I/O**) is an essential part of most system-level
    programs. It can be used for debugging, saving program states, handling user-specific
    data, and even interfacing with physical devices (thanks to POSIX block and character
    devices).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 文件输入/输出（I/O）是大多数系统级程序的重要部分。它可以用于调试、保存程序状态、处理特定于用户的数据，甚至与物理设备进行交互（由于POSIX块和字符设备）。
- en: Prior to C++17, working with file I/O was difficult, as filesystem management
    had to be handled using non-C++ APIs, which are often unsafe, platform-specific,
    or even incomplete.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17之前，处理文件I/O是困难的，因为文件系统管理必须使用非C++ API来处理，这些API通常不安全、特定于平台，甚至不完整。
- en: In this chapter, we will provide a hands-on review of how to open, read, and
    write to files, and work with paths, directories, and the filesystem. We will
    conclude by providing three different examples that demonstrate how to log to
    a file, tail an existing file, and benchmark the C++ file input/output APIs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将提供一个实际操作的回顾，介绍如何打开、读取和写入文件，以及处理路径、目录和文件系统。最后，我们将提供三个不同的示例，演示如何记录到文件、追踪现有文件和对C++文件输入/输出API进行基准测试。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Ways to open a file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开文件的方式
- en: Reading and writing to a file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入文件
- en: File utilities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件工具
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to compile and execute the examples in this chapter, the reader must
    have the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译和执行本章中的示例，读者必须具备以下条件：
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个能够编译和执行C++17的基于Linux的系统（例如，Ubuntu 17.10+）
- en: GCC 7+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GCC 7+
- en: CMake 3.6+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 3.6+
- en: An internet connection
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: To download all the code in this chapter, including the examples, and code snippets,
    see the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter08).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载本章中的所有代码，包括示例和代码片段，请参见以下链接：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter08)。
- en: Opening a file
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开文件
- en: There are many ways to open a file. We will discuss some of these in the following
    sections, and how to accomplish this using the `std::fstream` C++ APIs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件的多种方式。我们将在以下部分讨论其中一些，并介绍如何使用`std::fstream` C++ API来实现。
- en: Different ways to open a file
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开文件的不同方式
- en: 'Opening a file in C++ is as simple as providing a `std::fstream` object with
    the filename and path of the object you wish to open. This is shown as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中打开文件就像提供一个`std::fstream`对象和你想要打开的对象的文件名和路径一样简单。示例如下：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we open a file named `test.txt`, which we previously created
    using the POSIX `touch` command. This file is opened with read/write permissions
    (as that is the default mode).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们打开一个名为`test.txt`的文件，之前使用POSIX的`touch`命令创建过。这个文件以读/写权限打开（因为这是默认模式）。
- en: The file is stored in a variable named `file`, and it is checked to ensure it
    was properly opened using the bool operator overload that `std::fstream` provides.
    If this file is successfully opened, we output `success` to `stdout`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 文件存储在名为`file`的变量中，并使用`std::fstream`提供的bool运算符重载来确保它已经正确打开。如果文件成功打开，我们将`success`输出到`stdout`。
- en: 'The preceding example leverages the fact that a `std::fstream` object has an
    overloaded `bool` operator that returns true when the file is successfully opened.
    Another way to more explicitly perform this action is to use the `is_open()` function,
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子利用了`std::fstream`对象具有重载的`bool`运算符，当文件成功打开时返回true。更明确地执行此操作的另一种方法是使用`is_open()`函数，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this preceding example, instead of relying on the `bool` operator overload,
    we leverage C++17 to check whether the file is open using `is_open()` in the `if`
    statement. The preceding examples were further simplified by the use of the constructor
    to initialize the `std::fstream`, instead of explicitly calling `open()` as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们不是依赖于`bool`运算符重载，而是利用C++17在`if`语句中使用`is_open()`来检查文件是否打开。前面的例子通过使用构造函数初始化`std::fstream`来进一步简化，而不是显式调用`open()`，如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the `std::fstream` object is created with the default constructor,
    meaning no file has yet to be opened, allowing us to postpone opening the file
    until we are ready to do so. We then open the file using the `open()` function,
    and then, similar to the preceding example, we leverage C++17 to check to see
    if the file opened prior to outputting `success` to `stdout`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`std::fstream`对象是使用默认构造函数创建的，这意味着还没有打开文件，允许我们在准备好时再打开文件。然后我们使用`open()`函数打开文件，然后，类似于前面的例子，我们利用C++17来检查文件是否打开，然后将`success`输出到`stdout`。
- en: In all of the preceding examples, there was no need to call `close()` on the
    file. This is because, like other C++ classes such as `std::unique_ptr` that leverage
    RAII, `std::fstream` objects close the file automatically for you on destruction.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的例子中，不需要在文件上调用`close()`。这是因为，像其他C++类（如利用RAII的`std::unique_ptr`）一样，`std::fstream`对象在销毁时会自动关闭文件。
- en: 'It is possible, however, to close the file explicitly if so desired, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果需要的话，可以显式关闭文件，如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we open a text file and use `is_open()` to check whether the
    file is open. The first use of `is_open()` returns true, since the file was successfully
    opened. We then close the file explicitly using `close()`, and then check whether
    the file is open again using `is_open()`, which now returns false.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们打开一个文本文件并使用`is_open()`来检查文件是否打开。第一次使用`is_open()`返回true，因为文件成功打开。然后我们使用`close()`显式关闭文件，然后再次使用`is_open()`检查文件是否打开，现在返回false。
- en: Modes for opening a file
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开文件的模式
- en: 'Up until now, we have opened the file using the default mode. There are two
    modes that may be used to open a file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用默认模式打开文件。有两种模式可以用来打开文件：
- en: '`std::ios::in`: Opens the file for reading'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::ios::in`：打开文件以供读取'
- en: '`std::ios::out`: Opens the file for writing'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::ios::out`：打开文件以供写入'
- en: 'In addition, there are several other modes that may be used in conjunction
    with these two, to modify how a file is opened:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有几种其他模式可以与这两种模式结合使用，以修改文件的打开方式：
- en: '`std::ios::binary`: Opens the file for binary use. By default, `std::fstream`
    is in text mode, which applies specific rules about how a file is formatted using
    newline characters, and which types of character may be read/written to a file.
    These rules are usually appropriate for text files, but cause problems when you
    attempt to read/write binary data to a file. In this case, `std::ios::binary`
    should be added to your mode specifier.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::ios::binary`：以二进制方式打开文件。默认情况下，`std::fstream`处于文本模式，该模式适用于使用换行符格式化文件以及可以读取/写入文件的字符类型的特定规则。这些规则通常适用于文本文件，但在尝试向文件读取/写入二进制数据时会导致问题。在这种情况下，应将`std::ios::binary`添加到模式说明符中。'
- en: '`std::ios::app`: When this mode is used with `std::ios::out`, all writes to
    the file append to the end of the file.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::ios::app`：当此模式与`std::ios::out`一起使用时，对文件的所有写入都会追加到文件的末尾。'
- en: '`std::ios::ate`: When this mode is used with either `std::ios::in` or `std::ios::out`,
    the file is positioned at the end of the file once it has been successfully opened.
    That is, reads and writes to the file occur at the end of the file, even right
    after the file is opened.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::ios::ate`：当此模式与`std::ios::in`或`std::ios::out`一起使用时，文件在成功打开后定位在文件的末尾。也就是说，对文件的读取和写入发生在文件的末尾，即使在文件打开后立即进行。'
- en: '`std::ios::trunc`: When this mode is used with either `std::ios::in` or `std::ios::out`,
    the contents of the files are deleted prior to opening the file.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::ios::trunc`：当此模式与`std::ios::in`或`std::ios::out`一起使用时，打开文件之前会删除文件的内容。'
- en: 'To demonstrate these modes, the first example opens a file for reading in binary
    mode:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些模式，第一个示例以二进制模式打开文件进行读取：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'All of the modes are constant values, and for this reason, in the preceding
    example, `constexpr` is used to create a new constant called `mode` that represents
    opening a file in read-only, binary mode. To open a file for read-only in text
    mode instead of binary mode, simply remove the `std::ios::binary` mode, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模式都是常量值，因此在前面的示例中，使用`constexpr`创建了一个名为`mode`的新常量，表示以只读、二进制模式打开文件。要以文本模式而不是二进制模式打开文件进行只读，请简单地删除`std::ios::binary`模式，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding example, we open the file in read-only, text mode. The same
    logic may also be used for write-only, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们以只读、文本模式打开文件。相同的逻辑也可以用于只写，如下所示：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we open the file in write-only, binary mode. To open a file in write-only,
    test mode, use the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以只写、二进制模式打开文件。要以只写、文本模式打开文件，请使用以下方法：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once again, since `std::ios::binary` has been left out, this code opens the
    file in write-only, text mode.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于省略了`std::ios::binary`，这段代码以只写、文本模式打开文件。
- en: 'To open a file in write-only, binary mode at the end of the file (instead of
    the beginning of the file, which is the default), use the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要以只写、二进制模式在文件末尾（而不是默认的文件开头）打开文件，请使用以下方法：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we open the file in write-only, binary mode at the end of the
    file by adding `std::ios::ate` to the mode variable. This moves the output pointer
    in the file to the end of the file, but allows writing to occur at any place within
    the file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们通过将`std::ios::ate`添加到模式变量中，在只写、二进制模式下打开文件，将文件移动到文件末尾。这将文件中的输出指针移动到文件的末尾，但允许在文件中的任何位置进行写入。
- en: 'To ensure that the file is always appended to the end of the file, open the
    file using `std::ios::app` instead of `std::ios::ate`, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保文件始终追加到文件的末尾，使用`std::ios::app`而不是`std::ios::ate`来打开文件，如下所示：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, writes and additions to the file are always appended
    to the file as the file was opened using `std::ios::app`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，由于使用了`std::ios::app`，文件的写入和添加总是追加到文件中。
- en: It should be noted that in all of the previous examples that used `std::ios::out`,
    the file was opened using `std::ios::trunc`. This is due to the fact that truncate
    mode is the default when using `std::ios::out`, unless `std::ios::ate` or `std::ios::app`
    is used. The problem with this is that there is no way to open a file for write-only
    at the beginning of the file without truncating the file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，在所有先前使用`std::ios::out`的示例中，文件都是使用`std::ios::trunc`打开的。这是因为截断模式是在使用`std::ios::out`时的默认值，除非使用了`std::ios::ate`或`std::ios::app`。这样做的问题在于，没有办法在文件开头以只写模式打开文件而不截断文件。
- en: 'To overcome this issue, the following may be used:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，可以使用以下方法：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, we open the file in write-only, binary mode at the end of the
    file, and then we use `seekp()` (a function that will be explained later) to move
    the output position in the file to the beginning of the file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们以只写、二进制模式在文件末尾打开文件，然后我们使用`seekp()`（稍后将解释的函数）将文件中的输出位置移动到文件的开头。
- en: 'Although `std::ios::trunc` is the default when `std::ios::out` is used, if
    `std::ios::in` is also used (that is, read/write mode), you must explicitly add
    `std::ios::trunc` if you wish to clear the contents of the file prior to opening
    the file, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`std::ios::trunc`是在使用`std::ios::out`时的默认值，但如果还使用了`std::ios::in`（即读/写模式），则必须显式添加`std::ios::trunc`，如果您希望在打开文件之前清除文件的内容，如下所示：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the file is opened in read/write mode, and the contents of the file are
    deleted prior to opening the file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，文件以读/写模式打开，并且在打开文件之前删除了文件的内容。
- en: Reading and writing to a file
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入文件
- en: The following sections will help you to understand how to read and write to
    a file using the `std::fstream` C++ APIs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将帮助您了解如何使用`std::fstream` C++ API读取和写入文件。
- en: Reading from a file
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中读取
- en: C++ provides several different methods for reading a file, including by field,
    by line, and by number of bytes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了几种不同的方法来读取文件，包括按字段、按行和按字节数。
- en: Reading by field
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按字段读取
- en: 'The most type-safe method for reading from a file is by field, the code which
    is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件中读取的最安全的方法是按字段，代码如下：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we open a file for reading and writing (since that is the default
    mode). If the file is successfully opened, we read in two strings into two variables—`hello`
    and `world` respectively. To read the two strings, we use `>> operator()`, which
    behaves just like `std::cin` as discussed in [Chapter 6](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml),
    *Learning to Program Console Input/Output*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们打开一个文件进行读写（因为这是默认模式）。如果文件成功打开，我们将两个字符串分别读入两个变量——`hello`和`world`。要读取这两个字符串，我们使用`>>
    operator()`，它的行为就像[第6章](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml)中讨论的`std::cin`一样。
- en: 'For a string, the stream reads characters until the first whitespace or newline
    is discovered. As with `std::cin`, numeric variables can also be read, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串，流会读取字符，直到发现第一个空格或换行符。与`std::cin`一样，也可以读取数值变量，如下所示：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, we read in an integer instead of a string, and, just like
    a string, the stream reads in bytes until a whitespace or newline is discovered,
    and then interprets the input as a number. Of course, if the field being read
    is not a number, `0` is read, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们读取的是一个整数而不是一个字符串，就像读取字符串一样，流会读取字节，直到发现空格或换行符，然后将输入解释为一个数字。当然，如果被读取的字段不是一个数字，就会读取`0`，如下所示：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It should be noted that an error flag is set when this occurs, which we will
    discuss later in this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当发生这种情况时会设置一个错误标志，我们将在本章后面讨论。
- en: 'As with other C++ streams, `std::fstream` can be overloaded to provide support
    for user-defined types, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他C++流一样，`std::fstream`可以被重载以支持用户定义的类型，如下所示：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, we create a user-defined type called `myclass`. In the `main()`
    function, we open a file, and if the file is successfully opened, we create a
    `myclass{}` object, read the file into the `myclass{}` object, and then output
    the results of the `myclass{}` object to `stdout`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`myclass`的用户定义类型。在`main()`函数中，我们打开一个文件，如果文件成功打开，我们创建一个`myclass{}`对象，将文件读入`myclass{}`对象，然后将`myclass{}`对象的结果输出到`stdout`。
- en: To read the file into the `myclass{}` object, we overload `>> operator()` for
    `std::fstream{}` which reads in two strings, and stores the results in the `myclass{}`
    object. To output the `myclass{}` object to `stdout`, we build upon what we learned
    in [Chapter 6](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml), *Learning to Program
    Console Input/Output*, with respect to user-defined overloads of `std::ostream`,
    and provide a user-defined overload for our `myclass{}` object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将文件读入`myclass{}`对象中，我们重载了`std::fstream{}`的`>> operator()`，它读取两个字符串，并将结果存储在`myclass{}`对象中。要将`myclass{}`对象输出到`stdout`，我们将在[第6章](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml)中学到的内容进行扩展，即关于用户定义重载`std::ostream`的内容，并为我们的`myclass{}`对象提供用户定义的重载。
- en: The result is that `Hello World` is read from the file and output to `stdout`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是从文件中读取`Hello World`并输出到`stdout`。
- en: Reading bytes
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取字节
- en: 'In addition to reading fields from a file, C++ provides support for reading
    bytes directly from the file. To read a single byte from the stream, use the `get()`
    function, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从文件中读取字段外，C++还提供了直接从文件中读取字节的支持。要从流中读取一个字节，使用`get()`函数，如下所示：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Reading more than one byte in C++17 is still an unsafe operation, as there
    is no ability to read *x* number of bytes directly into a `std::string`. This
    means that a standard C-style buffer must be used instead, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中读取多个字节仍然是一种不安全的操作，因为没有能力直接将*x*个字节读入`std::string`。这意味着必须使用标准的C风格缓冲区，如下所示：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, we create a standard C-style character buffer called
    `buf`, and then read 11 bytes from the file into this character buffer. Finally,
    we output the results to `stdout`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个名为`buf`的标准C风格字符缓冲区，然后从文件中读取了11个字节到这个字符缓冲区中。最后，我们将结果输出到`stdout`。
- en: We need to ensure that the total number of bytes being read does not exceed
    the total size of the buffer itself—an operation that often leads to a coding
    error, generating hard-to-debug buffer overflows.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保被读取的字节数不超过缓冲区本身的总大小——这种操作通常会导致编码错误，产生难以调试的缓冲区溢出。
- en: 'The simple solution to this problem is to use a wrapper around the `read()`
    function that checks to make sure the requested number of bytes does not exceed
    the total size of the buffer, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的简单方法是使用一个包装器来包围`read()`函数，以确保请求的字节数不超过缓冲区的总大小，如下所示：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we create a template function called `myread()` that encodes
    the total size of the buffer into the function itself during compilation. Before
    a read occurs, the size of the buffer can be checked to ensure a buffer overflow
    will not occur.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`myread()`的模板函数，在编译期间将缓冲区的总大小编码到函数本身中。在读取发生之前，可以检查缓冲区的大小，以确保不会发生缓冲区溢出。
- en: It should be noted that this works well for arrays, but is problematic for dynamically-allocated
    arrays, as the total size of the buffer must also be passed to our wrapper function,
    potentially leading to hard-to-debug logic bugs (that is, not providing the proper
    size of the buffer, swapping the total number of bytes to read with the buffer
    size, and so on).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这对于数组来说效果很好，但对于动态分配的数组来说存在问题，因为缓冲区的总大小也必须传递给我们的包装器函数，可能会导致难以调试的逻辑错误（即未提供正确的缓冲区大小，交换要读取的字节数和缓冲区大小等）。
- en: To overcome these types of issues, `gsl::span` should be used instead.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些问题，应该使用`gsl::span`。
- en: 'When reading bytes instead of fields, it can be helpful to know from where
    in the file you are currently reading. As you read from a file stream, both a
    read and a write pointer are maintained internally within the stream. To get the
    current read position, use the `tellg()` function, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取字节而不是字段时，了解当前正在读取文件的位置可能会有所帮助。当您从文件流中读取时，流内部会维护一个读指针和一个写指针。要获取当前的读位置，使用`tellg()`函数，如下所示：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we open a file as usual and output the current read pointer, which as
    expected is `0`. We then read a single character from the file, and output the
    read pointer again. This time, the pointer is `1`, indicating we have successfully
    read a single byte.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们像往常一样打开一个文件并输出当前的读指针，预期的是`0`。然后我们从文件中读取一个字符，并再次输出读指针。这次，指针是`1`，表示我们已成功读取了一个字节。
- en: 'Another method for reading a single byte is to use the `peek` function, which
    functions similarly to `get()`, except that the internal read pointer is not incremented,
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种读取单个字节的方法是使用`peek`函数，它的功能类似于`get()`，只是内部读指针不会增加，如下所示：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This example is the same as the previous one, except that `peek()` is used instead
    of `get()`. As shown, the read pointer is `0` both before and after `peek()` is
    used to read a byte from the buffer, demonstrating that `peek()` doesn't increment
    the read pointer within the stream.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与前一个例子相同，只是使用了`peek()`而不是`get()`。如所示，在使用`peek()`从缓冲区中读取一个字节之前和之后，读指针都是`0`，表明`peek()`不会增加流中的读指针。
- en: 'The reverse is also provided by C++. Instead of reading a byte from the file
    without moving the read pointer, it is also possible to move the read pointer
    without reading bytes from the stream using the `ignore()` function, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: C++也提供了相反的操作。除了从文件中读取一个字节而不移动读指针之外，还可以使用`ignore()`函数移动读指针而不从流中读取字节，如下所示：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we move the read pointer in our file stream by a single byte,
    and use `tellg()` to verify that the read pointer has in fact been moved. The
    `ignore()` function increments the read pointer relative to the current read pointer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过一个字节移动文件流中的读指针，并使用`tellg()`来验证读指针是否实际上已经移动。`ignore()`函数相对于当前读指针增加读指针。
- en: 'C++ also provides the `seekg()` function, which sets the read pointer to an
    absolute position, shown as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: C++还提供了`seekg()`函数，它将读指针设置为绝对位置，如下所示：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, the `seekg()` function is used to set the read pointer
    to 1 byte into the file after reading, effectively rewinding, allowing us to read
    the file again.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`seekg()`函数用于在读取后将读指针设置为文件中的第1个字节，有效地倒带，使我们可以再次读取文件。
- en: Reading by line
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按行读取
- en: 'Finally, the last type of file read is by line, meaning that you read each
    line from the file, one at a time, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，文件读取的最后一种类型是按行读取，这意味着您每次从文件中读取一行，如下所示：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this example, we create a standard C character buffer, read a line from the
    file, and output the line to `stdout`. Unlike the `read()` function, `getline()`
    keeps reading until either the size of the buffer is reached (the second argument),
    or a delimiter is seen.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个标准的C字符缓冲区，从文件中读取一行，并将该行输出到`stdout`。与`read()`函数不同，`getline()`会一直读取，直到达到缓冲区的大小（第二个参数），或者看到一个分隔符。
- en: Since a line is defined differently depending on the OS you're using (although
    in this case, we will stick to Unix), the `getline()` function takes a delimiter
    argument, allowing you to define what the end of a line is.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于行的定义取决于您使用的操作系统（尽管在这种情况下，我们将坚持使用Unix），`getline()`函数接受一个分隔符参数，允许您定义行的结束位置。
- en: Like the `read()`, function, this operation is unsafe as it requires the user
    to ensure that the total buffer size given to `getline()` is, in fact, the total
    size of the buffer—providing a convenient mechanism to introduce hard-to-debug
    buffer overflows.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与`read()`函数一样，这个操作是不安全的，因为它要求用户确保传递给`getline()`的总缓冲区大小实际上是缓冲区的总大小，从而提供了一个方便的机制来引入难以调试的缓冲区溢出。
- en: 'Unlike the `read()` function, C++ provides a non-member version of `getline()`
    that accepts any stream type (including `std::cin`), and `std::string` instead
    of a standard C-style string, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与`read()`函数不同，C++提供了`getline()`的非成员版本，它接受任何流类型（包括`std::cin`）和`std::string`，而不是标准的C风格字符串，如下所示：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, instead of calling `file.getline()`, we instead call
    `std::getline()`, and provide the function with `std::string`, which can dynamically
    change its size depending on the number of bytes that need to be read—preventing
    possible buffer overflows.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们没有调用`file.getline()`，而是调用了`std::getline()`，并提供了`std::string`，它可以根据需要读取的字节数动态更改其大小，从而防止可能的缓冲区溢出。
- en: It should be noted that in order to achieve this, the `std::string` will perform
    a `new()` / `delete()` automatically for you—which (especially with respect to
    system programming) might introduce inefficiencies that are unacceptable. In this
    case, the `file.getline()` version should be used, with a wrapper class, similar
    to what we did with the `read()` function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，为了实现这一点，`std::string`将自动为您执行`new()`/`delete()`操作，这可能会引入不可接受的低效率（特别是在系统编程方面）。在这种情况下，应该使用`file.getline()`版本，使用一个包装类，类似于我们在`read()`函数中所做的。
- en: 'Finally, if changes are made to a file that has already been opened, the following
    will sync the current stream with these changes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果对已经打开的文件进行了更改，以下操作将使当前流与这些更改同步：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As shown in the preceding code, the `sync()` function may be used to resync
    an already open file with changes to the file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，`sync()`函数可以用于将已经打开的文件与文件的更改重新同步。
- en: Writing to a file
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入文件
- en: Symmetrically like `std::cin` and file reading, a file writing is also provided
    that behaves similarly to `std::cout`. Unlike reading, there are only two different
    modes of file writing—by field and by byte.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::cin`和文件读取一样，C++还提供了文件写入，其行为类似于`std::cout`。与读取不同，文件写入只有两种不同的模式——按字段和按字节。
- en: Writing by field
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按字段写入
- en: 'To write to a file by field, use `<< operator()`, similar to `std::cout`, as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要按字段写入文件，使用`<< operator()`，类似于`std::cout`，如下所示：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding example, we open a file as usual and then create two `std::string`
    objects with `hello` and `world` added to the strings respectively. Finally, these
    strings are written to the file. Note that there is no need to close or flush
    the file, as this is done for us on destruction of the file stream object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们像往常一样打开一个文件，然后创建了两个`std::string`对象，分别向这些字符串中添加了`hello`和`world`。最后，这些字符串被写入文件。请注意，不需要关闭或刷新文件，因为这在文件流对象销毁时会为我们完成。
- en: 'Like `std::cout`, C++ natively supports standard C character buffers and numeric
    types, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::cout`一样，C++本身支持标准C字符缓冲区和数字类型，如下所示：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding example, we write a standard C character buffer and an integer
    directly to the file. User-defined types are also supported with respect to writing,
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们直接向文件写入了一个标准C字符缓冲区和一个整数。对于写入，也支持用户定义的类型，如下所示：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, we open a file and write a `myclass{}` object to the file.
    The `myclass{}` object is a struct that contains two member variables initialized
    with `Hello` and `World`. A user-defined `<< operator()` overload is then provided
    that writes to a provided file stream the contents of the `myclass{}` object,
    resulting in `Hello World` being written to the file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们打开一个文件，并向文件写入一个`myclass{}`对象。`myclass{}`对象是一个包含两个成员变量的结构体，这两个成员变量被初始化为`Hello`和`World`。然后提供了一个用户定义的`<<
    operator()`重载，用于向提供的文件流写入`myclass{}`对象的内容，结果是将`Hello World`写入文件。
- en: Writing bytes
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入字节
- en: 'In addition to writing by field, writing a stream of bytes is also supported.
    In the following example, we write a single byte to the file (in addition to a
    newline) using the `put()` function, which is similar to `get()` but used for
    writing instead of reading:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了按字段写入，还支持写入一系列字节。在下面的例子中，我们使用`put()`函数向文件写入一个字节（以及一个换行符），该函数类似于`get()`，但用于写入而不是读取：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Multiple bytes can also be written using the `write()` function, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 多个字节也可以使用`write()`函数进行写入，如下所示：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding example, we write `12` bytes to the file (11 characters for
    the string `Hello World`, and one additional string for the newline).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们向文件写入了`12`字节（字符串`Hello World`的11个字符和一个额外的换行符）。
- en: 'Like the `read()` function, the `write()` function is unsafe and should be
    wrapped to ensure that the total number of bytes written to the file does not
    exceed the total size of the buffer (otherwise a buffer overflow would occur).
    To demonstrate how even standard C-style `const` character buffers are unsafe,
    see the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与`read()`函数一样，`write()`函数是不安全的，应该进行包装，以确保写入文件的总字节数不超过缓冲区的总大小（否则会发生缓冲区溢出）。为了演示即使标准C风格的`const`字符缓冲区也是不安全的，可以参考以下内容：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As shown in this example, attempting to write 100 bytes from a standard C `const`
    character buffer that is only `13` bytes in size (11 for `Hello World`, `1` for
    the new line, and `1` for the `\0` null termination), results in a buffer overflow.
    In this case, the buffer overflow results in corrupted bytes being written to
    the file, which, at best, leaks parts of the program, but could also generate
    instability, including hard-to-debug segmentation faults.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本例所示，尝试从大小仅为`13`字节的标准C `const`字符缓冲区中写入100个字节（`Hello World`的11个字节，`1`个换行符，`1`个`\0`空终止符），会导致缓冲区溢出。在这种情况下，缓冲区溢出会导致损坏的字节被写入文件，最好的情况下会泄漏程序的部分内容，但也可能导致不稳定性，包括难以调试的分段错误。
- en: 'To overcome this, a wrapper should be used whenever using these types of unsafe
    functions, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，无论何时使用这些不安全的函数，都应该使用一个包装器，如下所示：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, we create a wrapper around the `write()` function,
    similar to the `read()` function wrapper that we created previously. When we attempt
    to write more bytes than the total size of the standard C `const` character buffer,
    we generate an exception that can be used to trace the error to our attempt to
    write 100 bytes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个`write()`函数的包装器，类似于之前创建的`read()`函数包装器。当我们尝试写入的字节数超过了标准C `const`字符缓冲区的总大小时，我们会生成一个异常，该异常可用于跟踪错误，以确定我们尝试写入100个字节。
- en: 'It should be noted that this wrapper only works with standard C `const` character
    buffers that are generated by the compiler. It is possible to declare this type
    of buffer manually where this type of function will fail, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，这个包装器只适用于编译器生成的标准C `const`字符缓冲区。可以手动声明这种类型的缓冲区，这种类型的函数将失败，如下所示：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, we create two standard C `const` character buffers. The first
    buffer consists of the word `Hello` with a newline, and the second buffer consists
    of the word `World` with a newline. We then write `Hello` to the file, but instead
    of writing `6` characters, we write `12`. Finally, we write `World` to the file,
    and we provide the correct number of bytes, which is `6`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了两个标准的C `const` 字符缓冲区。第一个缓冲区由单词`Hello`和一个换行符组成，第二个缓冲区由单词`World`和一个换行符组成。然后我们向文件写入`Hello`，但是我们写入的不是`6`个字符，而是`12`个字符。最后，我们向文件写入`World`，并提供了正确的字节数，即`6`。
- en: The resulting output is `Hello World`, with `World` being written to the file
    twice. The reason for this is a carefully crafted buffer overflow. The first write
    to the file writes `Hello` to the buffer, but provides the `write()` function
    with `12` bytes instead of `6`. Our wrapper in this case is looking for a null
    terminator, which does not exist (as we have defined our standard C `const` character
    buffers manually, removing the null terminator).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出为`Hello World`，`World`被写入文件两次。这是因为精心设计的缓冲区溢出。向文件的第一次写入将`Hello`写入缓冲区，但是提供给`write()`函数的是`12`个字节，而不是`6`个字节。在这种情况下，我们的包装器正在寻找空终止符，但这个终止符不存在（因为我们手动定义了标准C
    `const`字符缓冲区，删除了空终止符）。
- en: As a result, the `mywrite()` function doesn't detect the overflow, and write
    both buffers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`mywrite()`函数无法检测到溢出，并写入了两个缓冲区。
- en: There is no safe way to overcome this type of problem (the `read()` function
    has similar issues) without the use of the guideline support library, diligence,
    and a static analyzer capable of detecting the use of a these types of buffers
    unsafely being used (which is not a trivial thing for a static analyzer to do).
    As a result, in general, functions such as `read()` and `write()` should be avoided
    in favor of by-field and by-line alternatives when possible.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 没有安全的方法可以克服这种问题（`read()`函数存在类似的问题），除非使用指导支持库、勤勉和能够检测到这些类型的缓冲区不安全使用的静态分析器（这对于静态分析器来说并不是一件微不足道的事情）。因此，通常情况下，应尽可能避免使用`read()`和`write()`等函数，而应使用按字段和按行的替代方法。
- en: 'Similar to `tellg()`, the write stream also has the ability to get the current
    write pointer position using the `tellp()` function, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与`tellg()`类似，写流也可以使用`tellp()`函数获取当前写指针位置，如下所示：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding example, `Hello World` is written to the file, and the `tellp()`
    function is used to output the write pointer position, which results in `0`, `5`,
    `6`, `11`, and `12`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，“Hello World”被写入文件，并且使用`tellp()`函数输出写指针位置，结果为`0`、`5`、`6`、`11`和`12`。
- en: 'It is also possible to move the write pointer to an absolute position within
    the file using the `seekp()` function, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`seekp()`函数将写指针移动到文件中的绝对位置，如下所示：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this example, we write `Hello World` to the file, and then move the write
    pointer within the stream back to the beginning of the file. We then write `The
    answer is: 42` to the file. Along the way, we use `tellp()` to output the location
    of the write pointer, showing how the write pointer moves as we perform these
    actions.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将“Hello World”写入文件，然后将流中的写指针移回文件的开头。然后我们将“答案是：42”写入文件。在此过程中，我们使用`tellp()`输出写指针的位置，显示了在执行这些操作时写指针的移动情况。
- en: 'As a result, the file consists of `The answer is: 42`, instead of `Hello World`,
    as `Hello World` is overwritten.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，文件包含“答案是：42”，而不是“Hello World”，因为“Hello World”被覆盖。
- en: 'Finally, as with the `sync()` function, the writes to a file can be flushed
    to the filesystem when desired using the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，与`sync()`函数一样，可以使用以下方法将文件的写入刷新到文件系统：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It should be noted that although you can flush the file manually (for example,
    if you know a change must hit the filesystem), the file will be closed and flushed
    to the filesystem automatically when the `std::fstream` object loses scope and
    is destroyed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，尽管可以手动刷新文件（例如，如果知道更改必须传输到文件系统），但是当`std::fstream`对象失去作用域并被销毁时，文件将自动关闭并刷新到文件系统。
- en: 'When reading and writing, it''s possible that different types of errors could
    occur. `std::fstream` provides four different functions for determining the state
    of the stream, as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取和写入时，可能会发生不同类型的错误。`std::fstream`提供了四个不同的函数来确定流的状态，如下所示：
- en: '`good()`: If this function returns `true`, no errors have occurred, and the
    stream has not reached the end of the file.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`good()`: 如果此函数返回`true`，则没有发生错误，流也没有到达文件的末尾。'
- en: '`eof()`: If this function returns `true`, the end of the file has been reached.
    Internal errors do not affect the result of this function.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eof()`: 如果此函数返回`true`，则已到达文件的末尾。内部错误不会影响此函数的结果。'
- en: '`fail()`: If this function returns `true`, an internal error has occurred,
    but the stream is still functional, for example, if a numerical conversion error
    occurs.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail()`: 如果此函数返回`true`，则发生了内部错误，但流仍然可用，例如，如果发生数字转换错误。'
- en: '`bad()`: If this function returns `true`, an error has occurred, and the stream
    is no longer functional, for example, if the stream fails to open a file.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bad()`: 如果此函数返回`true`，则发生了错误，流不再可用，例如，如果流无法打开文件。'
- en: 'When normal file operations occur, `good()` should return `true`, while the
    other three status functions should return `false`, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当正常的文件操作发生时，`good()`应该返回`true`，而其他三个状态函数应该返回`false`，如下所示：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding example, `Hello World` is written to a file successfully, resulting
    in `good()` returning `true`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，“Hello World”成功写入文件，导致`good()`返回`true`。
- en: 'In addition to using the `good()` function, `! operator()` can be used to detect
    whether an error has occurred, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`good()`函数外，可以使用`! operator()`来检测是否发生了错误，如下所示：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, `Hello World` is successfully written to the file, and as a result, the
    `good()` function returns `true`, which means `! operator()` returns `false`,
    resulting in the `failed` string never being output to `stdout`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，“Hello World”成功写入文件，因此`good()`函数返回`true`，这意味着`! operator()`返回`false`，导致“failed”字符串从未输出到`stdout`。
- en: 'Similarly, the `bool` operator can be used, which returns the same result as
    `good()`, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以使用`bool`运算符，其返回与`good()`相同的结果，如下所示：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding code, `Hello World` is successfully written to the file, resulting
    in the `bool` operator returning `true`; this means that the `good()` function
    would also return `true`, since they return the same result.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，“Hello World”成功写入文件，导致`bool`运算符返回`true`；这意味着`good()`函数也会返回`true`，因为它们返回相同的结果。
- en: 'If an error occurs, the error status remains triggered until the stream is
    closed, or until the `clear()` function is used, telling the stream that you have
    dealt with the error, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，错误状态将保持触发状态，直到流关闭，或者使用`clear()`函数告诉流已处理错误，如下所示：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding example, a string is written to a text file. This test file
    is opened for reading, and an integer is read. The problem is that the value written
    to the file is not actually a number, causing the file stream to report an error.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，将一个字符串写入文本文件。此测试文件被打开以进行读取，并读取一个整数。问题在于写入文件的值实际上不是一个数字，导致文件流报告错误。
- en: The `clear` function is then used to clear the error, after which the `good()`
    function continues to report `true`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`clear`函数清除错误，之后`good()`函数继续报告`true`。
- en: Understanding file utilities
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解文件实用程序
- en: All of the C++ APIs described in this chapter thus far were added prior to C++17\.
    Although C++ provided the ability to read and write a file, it didn't provide
    all of the other file operations that are needed to manage a filesystem, including
    file paths, directory management, and so on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在C++17之前添加的所有C++ API都提供了描述的功能。尽管C++提供了读写文件的能力，但它并没有提供管理文件系统所需的所有其他文件操作，包括文件路径、目录管理等。
- en: This section will focus on the `std::filesystem` additions in C++17 that address
    most of these shortcomings.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将重点介绍C++17中的`std::filesystem`增强功能，以解决这些缺陷中的大部分。
- en: Paths
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径
- en: A path is nothing more than a string that represents a node in a filesystem.
    On UNIX systems, this is usually a string consisting of a series of directory
    names, `/`, and a filename, usually with an extension. The purpose of a path is
    to represent the name and location of a file, which can then be used to perform
    an action on the file such as opening the file for reading and writing, changing
    the file's permissions, or even removing the file from the filesystem.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 路径只不过是表示文件系统中节点的字符串。在UNIX系统上，这通常是一个由一系列目录名、`/`和文件名组成的字符串，通常带有扩展名。路径的目的是表示文件的名称和位置，然后可以用来对文件执行操作，如打开文件进行读写、更改文件的权限，甚至从文件系统中删除文件。
- en: 'It should be noted that a path can represent many different types of nodes
    in a filesystem, including files, directories, links, devices, and so on. A more
    complete list will be presented later in this chapter. Consider the following
    example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，路径可以表示文件系统中许多不同类型的节点，包括文件、目录、链接、设备等。更完整的列表将在本章后面呈现。考虑以下例子：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is a path that refers to a directory named `user`, located in a root directory
    named `home`. Now consider the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个指向名为“user”的目录的路径，位于名为“home”的根目录中。现在考虑以下内容：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This refers to a file named `test.txt` in this same directory. The file's stem
    is `test`, while the file's extension is `.txt`. In addition, the file's root
    is `/` (which is the case on most UNIX systems).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这指的是在同一目录中名为`test.txt`的文件。文件的主干是`test`，而文件的扩展名是`.txt`。此外，文件的根目录是`/`（这在大多数UNIX系统上都是这样）。
- en: 'On UNIX systems, paths can take on different forms, including the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在UNIX系统上，路径可以采用不同的形式，包括以下内容：
- en: '**Block devices**: The path refers to a POSIX-style block device such as `/dev/sda`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块设备**：路径指向POSIX风格的块设备，如`/dev/sda`'
- en: '**Character devices**: The path refers to a POSIX-style character device such
    as `/dev/random`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符设备**：路径指向POSIX风格的字符设备，如`/dev/random`'
- en: '**Directories**: The path refers to a regular directory'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**：路径指向常规目录'
- en: '**Fifo**: The path refers to a pipe or other form of IPC'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fifo**：路径指向管道或其他形式的IPC'
- en: '**Socket**: The path refers to a POSIX socket'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字**：路径指向POSIX套接字'
- en: '**Symlink**: The path refers to a POSIX symlink'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**符号链接**：路径指向POSIX符号链接'
- en: '**Files**: The path refers to a regular file'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件**：路径指向常规文件'
- en: 'To determine what type a path is, C++17 provides the following test functions:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定路径的类型，C++17提供了以下测试函数：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As shown in the preceding example, `/dev/sda` is a block device, `/dev/random`
    is a character device, `/dev` is a directory that is not empty, and the `scratchpad.cpp`
    file that is used to compile all the examples in this chapter is a regular file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，“/dev/sda”是一个块设备，“/dev/random”是一个字符设备，“/dev”是一个非空目录，“scratchpad.cpp”文件用于编译本章中的所有示例，是一个常规文件。
- en: 'To determine if a path exists, C++17 provides the `exists()` function, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定路径是否存在，C++17提供了`exists（）`函数，如下所示：
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here the directory `/dev` exists, and so do the character device `/dev/random`
    and the regular file `scratchpad.cpp`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目录“/dev”存在，字符设备“/dev/random”和常规文件“scratchpad.cpp”也存在。
- en: 'Every program that executes must execute from a given directory. To determine
    this directory, C++17 provides the `current_path()` function, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 每个执行的程序都必须从给定的目录执行。要确定这个目录，C++17提供了`current_path（）`函数，如下所示：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In this example, `current_path()` is used to get the current directory that
    `a.out` is executing from. The path that was provided by `current_path()` is an
    absolute path. To turn an absolute path into a relative path, use the `relative()`
    function, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`current_path（）`用于获取`a.out`正在执行的当前目录。`current_path（）`提供的路径是绝对路径。要将绝对路径转换为相对路径，可以使用`relative（）`函数，如下所示：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As shown in this example, the relative path for the current path is simply (`.`).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如本例所示，当前路径的相对路径只是（`.`）。
- en: 'Similarly, to turn a relative path into an absolute path, C++17 provides the
    `canonical()` function:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要将相对路径转换为绝对路径，C++17提供了`canonical（）`函数：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this example, we use the `canonical()` function to convert a relative path
    to an absolute path. It should be noted that getting the absolute path of `.`
    is another way to return the same result of `current_path()`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`canonical（）`函数将相对路径转换为绝对路径。值得注意的是，获取`.`的绝对路径是返回`current_path（）`相同结果的另一种方法。
- en: 'Also note that the `canonical()` function returns the absolute path with all
    references to `../` and `./` resolved, reducing the absolute path to its minimal
    form. If this type of path is not desired, the `absolute()` function may be used
    instead, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`canonical（）`函数返回带有所有对`../`和`./`的引用解析的绝对路径，将绝对路径减少到其最小形式。如果不需要这种类型的路径，可以使用`absolute（）`函数，如下所示：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As shown in this example, the `../` is not removed by the `absolute()` function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如本例所示，“../”不会被“absolute（）”函数移除。
- en: 'Since there are different ways to represent the same path (that is, relative,
    canonical, and absolute), C++17 provides the `equivalent()` function, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有不同的表示相同路径的方式（即相对、规范和绝对），C++17提供了`equivalent（）`函数，如下所示：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: All the paths referenced in this example refer to the same directory, regardless
    of whether they are relative, canonical, or absolute.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中引用的所有路径都指向相同的目录，无论它们是相对的、规范的还是绝对的。
- en: 'If you wish to determine if two paths are lexically equal (containing the same
    exact characters), use `== operator()` instead, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要确定两个路径在词法上是否相等（包含完全相同的字符），请使用`== operator()`，如下所示：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The code here is the same as the preceding code, apart from the use of `== operator()`
    instead of the `equivalent()` function. The previous example returned `true` for
    all of the paths since they all refer to the same path, while the preceding example
    returns `false` because the same paths are not lexically equal, even though they
    are technically the same path.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码与前面的代码相同，只是使用了`== operator()`而不是`equivalent()`函数。前一个示例对所有路径返回`true`，因为它们都指向相同的路径，而前面的示例返回`false`，因为相同的路径在词法上不相等，即使它们在技术上是相同的路径。
- en: 'Note the use of `/ operator()` in these examples. C++17 provides different
    concatenation functions for paths that conveniently provide a clean, readable
    way of adding to an existing path: `/`, `/=`, and `+=`. `/ operator()` (and the
    self-modifying version `/= operator()`) concatenates two paths while adding a
    `/` for you, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这些示例中的`/ operator()`的使用。C++17为路径提供了不同的连接函数，方便地提供了一种清晰易读的方式来添加到现有路径中：`/`、`/=`和`+=`。`/
    operator()`（以及自修改版本`/= operator()`）将两个路径连接在一起，并为您添加`/`，如下所示：
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In this example, `scratchpad.cpp` is added to the path using `/= operator()`,
    and a `/` is added for us. If you wish to add the `/` yourself, or you do not
    wish for a `/` to be added at all, you can use `+= operator()`, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用`/= operator()`将`scratchpad.cpp`添加到路径中，并为我们添加了`/`。如果您希望自己添加`/`，或者根本不希望添加`/`，可以使用`+=
    operator()`，如下所示：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The result here is the same as in the previous example, with the difference
    being that `+= operator()` is used instead of `/= operator()`, and so the `/`
    needs to be added manually.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的结果与前一个示例中的结果相同，不同之处在于使用`+= operator()`而不是`/= operator()`，因此需要手动添加`/`。
- en: 'In addition to concatenation, C++17 provides some additional path modifiers.
    One such function is `remove_filename()`, which removes the filename from a path,
    as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 除了连接，C++17还提供了一些额外的路径修改器。其中一个函数是`remove_filename()`，它从路径中删除文件名，如下所示：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As shown, the `remove_filename()` function removes the filename from the path.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，`remove_filename()`函数从路径中删除了文件名。
- en: 'It is also possible to replace the filename with something else, instead of
    removing it, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以用其他东西替换文件名，而不是删除它，如下所示：
- en: '[PRE54]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As shown, the filename `scratchpad.cpp` was replaced with `test.cpp`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，文件名`scratchpad.cpp`被替换为`test.cpp`。
- en: 'As well as replacing the filename, it is also possible to replace the extension,
    as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 除了替换文件名，还可以替换扩展名，如下所示：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As shown, the extension for `scratchpad.cpp` was changed to `.txt`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，`scratchpad.cpp`的扩展名已更改为`.txt`。
- en: 'Finally, if you need to, it''s possible to clear a path using the `clear()`
    function, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果需要，可以使用`clear()`函数清除路径，如下所示：
- en: '[PRE56]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As shown in the preceding code, the `clear()` function deletes the contents
    of the path (as if it were default constructed).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，`clear()`函数删除了路径的内容（就像它是默认构造的一样）。
- en: 'As stated, a path consists of different parts including a root name, directory,
    stem, and extension. To dissect a path into these different components, C++17
    provides some helper functions, as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，路径由不同部分组成，包括根名称、目录、词干和扩展名。为了将路径分解为这些不同的组件，C++17提供了一些辅助函数，如下所示：
- en: '[PRE57]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this example, we dissect the path of the `scratchpad.cpp` file into its different
    parts. The parent path is `/home/user/Hands-On-System-Programming-with-CPP/Chapter08`,
    the filename is `scratchpad.cpp`, the stem is `scratchpad`, and the extension
    is `.cpp`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`scratchpad.cpp`文件的路径分解为不同的部分。父路径是`/home/user/Hands-On-System-Programming-with-CPP/Chapter08`，文件名是`scratchpad.cpp`，词干是`scratchpad`，扩展名是`.cpp`。
- en: Not all paths contain all the parts that a path could potentially contain. This
    can occur when a path points to a directory, or when it is ill-formed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有路径都包含路径可能包含的所有部分。当路径指向目录或格式不正确时，可能会发生这种情况。
- en: 'To figure out which parts a path contains, use the following helpers:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出路径包含的部分，使用以下辅助函数：
- en: '[PRE58]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As shown here, you can determine whether a path has a root path, root name,
    root directory, relative path, parent path, filename, stem, and extension. You
    can also determine whether the path is an absolute path or a relative path.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，您可以确定路径是否具有根路径、根名称、根目录、相对路径、父路径、文件名、词干和扩展名。您还可以确定路径是绝对路径还是相对路径。
- en: 'Finally, C++17 provides different mechanisms for managing paths on a filesystem,
    depending on the type of path you''re using. For example, if you wish to create
    a directory or delete a path (regardless of its type), use the `create_directory()`
    and `remove()` functions respectively, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，C++17提供了不同的机制来管理文件系统上的路径，具体取决于您使用的路径类型。例如，如果要创建目录或删除路径（无论其类型如何），可以分别使用`create_directory()`和`remove()`函数，如下所示：
- en: '[PRE59]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the preceding example, we use the `create_directory()` function to create
    a directory, and then we use the `remove()` function to delete it.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`create_directory()`函数创建一个目录，然后使用`remove()`函数删除它。
- en: 'We can also rename a path using the `rename()` function, as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`rename()`函数重命名路径，如下所示：
- en: '[PRE60]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this example, we create a directory using the `create_directory()` function.
    We rename the directory using the `rename()` function, and then delete both the
    old directory path and the new one. As shown, the attempt to delete the directory
    that has been renamed fails, as that path no longer exists, while attempting to
    delete the new directory succeeds, as that path does exist.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`create_directory()`函数创建一个目录。然后我们使用`rename()`函数重命名目录，然后删除旧目录路径和新目录路径。如图所示，尝试删除已重命名的目录失败，因为该路径不再存在，而尝试删除新目录成功，因为该路径确实存在。
- en: 'The `remove()` function will remove any path (assuming the program has the
    proper permissions), unless the path points to a directory that is not empty,
    in which case it will fail. To remove a directory that is not empty, use the `remove_all()`
    function, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`函数将删除任何路径（假设程序具有适当的权限），除非路径指向一个非空的目录，在这种情况下它将失败。要删除一个非空的目录，请使用`remove_all()`函数，如下所示：'
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As shown here, we create a directory and add some files to the directory using
    `std::fstream`. We then delete the newly created directory using `remove_all()`
    instead of `remove()`. If we used the `remove()` function, the program would throw
    an exception, as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，我们创建一个目录并使用`std::fstream`向目录添加一些文件。然后，我们使用`remove_all()`而不是`remove()`来删除新创建的目录。如果我们使用`remove()`函数，程序将抛出异常，如下所示：
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Another common operation to perform on a filesystem is to iterate over all
    of the files in a directory. To do this, C++17 provides a directory iterator,
    as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统上执行的另一个常见操作是遍历目录中的所有文件。为此，C++17提供了一个目录迭代器，如下所示：
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the preceding example, we create a directory using the `create_directory()`
    function, add some files to the directory, and then use a directory iterator to
    iterate over all the files.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`create_directory()`函数创建一个目录，向目录添加一些文件，然后使用目录迭代器来遍历所有文件。
- en: The directory iterator functions like any other iterator in C++, which means,
    as shown in the preceding example, that we can leverage the ranged for syntax.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 目录迭代器的功能与C++中的任何其他迭代器一样，这意味着，如前面的示例所示，我们可以利用范围for语法。
- en: 'Finally, C++17 provides a convenient function for determining the path to the
    temporary directory, which can be used to create temporary directories as needed
    for your program, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，C++17提供了一个方便的函数来确定临时目录的路径，可以用于根据需要为程序创建临时目录，如下所示：
- en: '[PRE64]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: It should be noted that on POSIX systems, the temporary directory is usually
    `/tmp`, as shown here. However, it's still prudent to use the `temp_directory_path()`
    instead of hard-coding this path.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，在POSIX系统上，临时目录通常是`/tmp`，如此所示。然而，最好还是使用`temp_directory_path()`而不是硬编码这个路径。
- en: Understanding the logger example
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解记录器示例
- en: In this section, we will extend the debugging example in [Chapter 6](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml), *Learning
    to Program Console Input/Output*, to include a rudimentary logger. The goal of
    this logger is to redirect additions to the `std::clog` stream to a log file in
    addition to the console.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将扩展[第6章](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml)中的调试示例，*学习编程控制台输入/输出*，以包括一个基本的记录器。这个记录器的目标是将对`std::clog`流的添加重定向到控制台之外的日志文件中。
- en: Just like the debugging functions in [Chapter 6](https://cdp.packtpub.com/hands_on_system_programming_with_c___/wp-admin/post.php?post=31&action=edit#post_29), *Learning
    to Program Console Input/Output*, we would like the logging functions to be compiled
    out if the debugging level is not sufficient, or if debugging has been disabled.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 就像[第6章](https://cdp.packtpub.com/hands_on_system_programming_with_c___/wp-admin/post.php?post=31&action=edit#post_29)中的调试函数一样，*学习编程控制台输入/输出*，如果调试级别不够，或者调试已被禁用，我们希望日志函数被编译出。
- en: To accomplish this, please see the following code: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/example1.cpp](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/example1.cpp).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，请参阅以下代码：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/example1.cpp](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/example1.cpp)。
- en: 'To start, we will need to create two constant expressions—one for the debug
    level, and one to enable or disable debugging outright, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建两个常量表达式——一个用于调试级别，一个用于启用或禁用调试，如下所示：
- en: '[PRE65]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, we will need to create a global variable, as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个全局变量，如下所示：
- en: '[PRE66]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The global variable is the log file stream. This will be used to write additions
    to the `std::clog` stream to a log file. Since this is a log file, we open it
    as write-only, append, meaning we can only write to the log, and all writes must
    append to the end of the file.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量是日志文件流。这将用于将对`std::clog`流的添加写入日志文件。由于这是一个日志文件，我们将其以只写、追加的方式打开，这意味着我们只能向日志文件写入，并且所有写入都必须追加到文件的末尾。
- en: Next, we will need to define the `log` function itself. This function needs
    to be able to output to both `std::clog` and to our log file stream without executing
    the debug logic more than once (as this could result in unexpected behavior).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义`log`函数本身。这个函数需要能够输出到`std::clog`和我们的日志文件流，而不会执行调试逻辑超过一次（因为这可能导致意外行为）。
- en: 'The following implements the `log` function with this goal in mind:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实现了具有这一目标的`log`函数：
- en: '[PRE67]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Like the debug functions in [Chapter 6](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml), *Learning
    to Program Console Input/Output*, this `log` function starts by wrapping the business
    logic of the function in a `constexpr` `if` statement (a feature new to C++17),
    providing the compiler with a means to compile out the code if debugging is disabled,
    or if the provided debug level is greater than the current debug level.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第6章](b7b0e871-3833-4c12-984d-fd6f86b7ea84.xhtml)中的调试函数一样，*学习编程控制台输入/输出*，这个`log`函数首先通过`constexpr`
    `if`语句（C++17的新特性）包装函数的业务逻辑，为编译器提供了一种在调试被禁用或者提供的调试级别大于当前调试级别时编译出代码的方法。
- en: If debugging should take place, the first step is to create a string stream,
    which behaves just like `std::clog` and the log file stream, but saves the results
    of any additions to the stream to a `std::string`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要进行调试，第一步是创建一个字符串流，它的行为就像`std::clog`和日志文件流一样，但是将流的任何添加结果保存到`std::string`中。
- en: The read buffer for `std::clog` is then saved, and the read buffer of the string
    stream is provided to `std::clog`. Any additions to the `std::clog` stream will
    be redirected to our string stream instead of `stderr`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后保存`std::clog`的读取缓冲区，并将字符串流的读取缓冲区提供给`std::clog`。对`std::clog`流的任何添加都将重定向到我们的字符串流，而不是`stderr`。
- en: Next, we execute the user-provided `debug` function, collecting the debug string
    and storing it in the string stream. Finally, the `read()` buffer for `std::clog`
    is restored to `stderr`, and we output the string stream to both `std::clog` and
    the log file stream.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行用户提供的`debug`函数，收集调试字符串并将其存储在字符串流中。最后，将`std::clog`的`read()`缓冲区恢复为`stderr`，并将字符串流输出到`std::clog`和日志文件流。
- en: 'The last step is to create our `protected_main ()` function that logs `Hello
    World`. Note that, for demonstration, we also add `Hello World` to `std::clog`
    manually, without the `log` function, to demonstrate that `std::clog` functions
    as normal and only logs to our log file when the `log` function is used. This
    is shown with the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建我们的`protected_main()`函数，记录`Hello World`。请注意，为了演示，我们还手动将`Hello World`添加到`std::clog`中，而不使用`log`函数，以演示`std::clog`在使用`log`函数时仍然正常工作，并且只在我们的日志文件中记录。下面的代码显示了这一点：
- en: '[PRE68]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译此代码，我们将利用我们一直在使用的相同的`CMakeLists.txt`文件：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt)。
- en: 'With this code in place, we can compile and execute this code using the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以使用以下方法编译和执行这段代码：
- en: '[PRE69]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Notice how both the `debug` statements are output to `stderr` (both the statement
    in the `log` function, and the statement manually executed without the `log` function).
    Yet, the log file only has a single statement in it, demonstrating the `log` function
    is responsible for redirecting additions to `std::clog` to both the log file and
    `stderr`, while leaving `std::clog` intact for future uses.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`debug`语句都输出到`stderr`（`log`函数中的语句和手动执行的没有`log`函数的语句）。然而，日志文件中只有一个语句，演示了`log`函数负责将对`std::clog`的添加重定向到日志文件和`stderr`，同时保持`std::clog`完好无损以供将来使用。
- en: Learning about the tail file example
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习关于tail文件的例子
- en: In this example, we will create a simple program to tail a file. The goal of
    this example is to mimic the behavior of `tail -f -n0`, which outputs new additions
    to a file. The `-f` argument tells the tail to follow the file and `-n0` tells
    tail to only output to `stdout` new additions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个简单的程序来tail一个文件。这个例子的目标是模仿`tail -f -n0`的行为，它输出文件的新添加。`-f`参数告诉tail跟踪文件，`-n0`告诉tail只将新添加输出到`stdout`。
- en: 'The first step is to define the mode we plan to use when opening the file we
    are tailing, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是定义我们打算在打开要tail的文件时使用的模式，如下所示：
- en: '[PRE70]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this case, we will open the file as read-only, and move the read pointer
    to the end of the file on open.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将以只读方式打开文件，并在打开时将读取指针移动到文件的末尾。
- en: 'The next step is to create a `tail` function that watches for changes to a
    file and outputs the changes to `stdout`, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个`tail`函数，用于监视文件的更改并将更改输出到`stdout`，如下所示：
- en: '[PRE71]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This `tail` function starts by telling the compiler that this function does
    not return, as the function is wrapped in a `while(true)` loop that never ends.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`tail`函数开始时告诉编译器这个函数不会返回，因为该函数包装在一个永不结束的`while(true)`循环中。
- en: Next, the function checks whether the end of the file has been reached by first
    peeking the file, and then checking the end-of-file bit using `eof()`. If it has,
    the program sleeps for a second, clears all status bits, resyncs with the filesystem
    to see if any new changes have been made, and then loops again.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，函数首先通过查看文件末尾来检查文件是否已到达末尾，然后使用`eof()`检查文件结束位。如果是，程序将休眠一秒钟，清除所有状态位，重新同步文件系统以查看是否有新的更改，然后再次循环。
- en: If the read pointer is not at the end of the file, its current position is read
    in case its position in the file needs to be restored. The next line in the file
    is read and stored in a buffer.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读取指针不在文件末尾，则需要读取其当前位置，以便在需要时恢复其在文件中的位置。然后读取文件中的下一行并将其存储在缓冲区中。
- en: It's possible that attempting to read the next line using `getline` will fail
    (for example, when the last character in a file is not a newline). If this occurs,
    the contents of the buffer should be ignored (as it is not a complete line), and
    the read pointer needs to be restored to its original position.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`getline`读取下一行可能会失败（例如，当文件中的最后一个字符不是换行符时）。如果发生这种情况，应忽略缓冲区的内容（因为它不是完整的一行），并且需要将读取指针恢复到其原始位置。
- en: If the next line is successfully read, it is output to `stdout`, and we loop
    again to see if more lines need to be read.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功读取了下一行，它将输出到`stdout`，然后我们再次循环以查看是否需要读取更多行。
- en: 'The last function in this example must parse the arguments provided to our
    program to get the file name to tail, open the file, and then call the `tail`
    function with the newly opened file, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的最后一个函数必须解析提供给我们程序的参数，以获取要tail的文件名，打开文件，然后使用新打开的文件调用`tail`函数，如下所示：
- en: '[PRE72]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As with previous examples, we parse the arguments using a `gsl::span` to ensure
    safety and remain compliant with C++ Core Guidelines. If no arguments are provided
    to the program, we wait for the user to provide the program with the filename
    to tail.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的例子一样，我们使用`gsl::span`解析参数，以确保安全并符合C++核心指南。如果没有为程序提供参数，我们将等待用户提供要tail的文件名。
- en: If a filename is provided, we open the file and call `tail()`. If the file cannot
    be opened, we throw an exception.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了文件名，我们将打开文件并调用`tail()`。如果文件无法打开，我们会抛出异常。
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译这段代码，我们利用了同样的`CMakeLists.txt`文件，这是我们在其他示例中一直在使用的：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt)。
- en: 'With this code in place, we can compile and execute this code using the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以使用以下方式编译和执行这段代码：
- en: '[PRE73]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'From another terminal, we can make changes to the file as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个终端，我们可以对文件进行更改，如下所示：
- en: '[PRE74]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This would result in the example program outputting the following to `stdout`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致示例程序将以下内容输出到`stdout`：
- en: '[PRE75]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To ensure the program is ignoring incomplete lines, we can add an incomplete
    line to the file, as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保程序忽略不完整的行，我们可以向文件中添加一个不完整的行，如下所示：
- en: '[PRE76]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This results in no output from the example program.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致示例程序没有输出。
- en: Comparing C++ versus mmap benchmark
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较C++与mmap基准测试
- en: In this example, we will benchmark the difference between reading the contents
    of a file using `std::fstream` and reading them using `mmap()`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将对使用`std::fstream`和`mmap()`读取文件内容的差异进行基准测试。
- en: It should be noted that the `mmap()` function leverages a system call to directly
    map a file into the program, and we expect `mmap()` to be faster than the C++
    APIs highlighted in this chapter. This is because the C++ APIs have to perform
    an additional memory copy, which is obviously slower.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`mmap()`函数利用系统调用直接将文件映射到程序中，我们期望`mmap()`比本章中突出的C++ API更快。这是因为C++ API需要执行额外的内存复制，显然更慢。
- en: 'We will start this example by defining the size of the file we plan to read,
    as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义我们打算读取的文件的大小开始，如下所示：
- en: '[PRE77]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Next, we must define a `benchmark` function to record how long it takes to
    perform an action:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义一个`benchmark`函数来记录执行操作所需的时间：
- en: '[PRE78]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In the preceding function, we leverage a high-resolution timer to record how
    long it takes to execute a user-provided function. It should be noted that this
    benchmark program is relatively generic, and can be used for a lot of non-trivial
    functions (as trivial functions are often difficult to benchmark, even with high-resolution
    timers).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们利用高分辨率计时器来记录执行用户提供的函数所需的时间。值得注意的是，这个基准测试程序相对通用，可以用于许多非平凡的函数（因为即使使用高分辨率计时器，通常也很难对平凡函数进行基准测试）。
- en: 'Finally, we need to create a file read, and then we need to read the file using
    `std::fstream` and `mmap()` as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建一个文件读取，然后我们需要使用`std::fstream`和`mmap()`来读取文件，如下所示：
- en: '[PRE79]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The first step in the `protected_main()` function is to create the file we
    plan to read, as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected_main()`函数中的第一步是创建我们打算读取的文件，如下所示：'
- en: '[PRE80]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: To do this, we open the file we plan to read using write-only, which also opens
    the file using `std::ios::trunc` by default, erasing the contents of the file
    for us just in case. Finally, we write `size` number of zeros to the file.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们以只写方式打开我们打算使用的文件，这也默认使用`std::ios::trunc`打开文件，以便在必要时为我们擦除文件的内容。最后，我们向文件写入`size`个零。
- en: 'The next step is to read the file using `std::fstream`, as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用`std::fstream`读取文件，如下所示：
- en: '[PRE81]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Before we read the file using `std::fstream`, we open the file using read-only,
    which opens the file at the beginning of the file. Our file read is then encapsulated
    in our benchmark function. The results of the benchmark are output to `stdout`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`std::fstream`读取文件之前，我们首先以只读方式打开文件，这将文件打开到文件的开头。我们的文件读取然后封装在我们的基准函数中。基准测试的结果输出到`stdout`。
- en: 'Finally, the last step is to do the same for `mmap()`, as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一步是对`mmap()`做同样的操作，如下所示：
- en: '[PRE82]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As with `std::fstream`, the file is opened first, and then the use of `mmap()`
    is encapsulated in our benchmark function.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 与`std::fstream`一样，首先打开文件，然后在我们的基准函数中封装`mmap()`的使用。
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译这段代码，我们利用了同样的`CMakeLists.txt`文件，这是我们在其他示例中一直在使用的：[https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter08/CMakeLists.txt)。
- en: 'With this code in place, we can compile and execute this code using the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以使用以下方式编译和执行这段代码：
- en: '[PRE83]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As shown, `mmap()` executes faster than `std::fstream`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，`mmap()`的执行速度比`std::fstream`快。
- en: Summary
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to open a file in different ways, depending
    on how we plan to use the file itself. Once opened, we learned how to read and
    write to the file using the `std::fstream` C++ APIs.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何以不同的方式打开文件，取决于我们打算如何使用文件本身。一旦打开，我们学习了如何使用`std::fstream` C++ API读取和写入文件。
- en: We learned the difference between fields and bytes, and the advantages and disadvantages
    of both methods of reading and writing, as well as common unsafe practices. In
    addition, we learned about support functions that provide the ability to move
    pointers within the `std::fstream` APIs to manipulate how a file is read and written.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了字段和字节之间的区别，以及读写两种方法的优缺点，以及常见的不安全实践。此外，我们学习了支持函数，这些函数提供了在`std::fstream`API中移动指针的能力，以操纵文件的读写方式。
- en: Furthermore, in this chapter, we gave an extensive overview of the new filesystem
    APIs added to C++17, including paths and their support functions for manipulating
    files and directories.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本章中，我们对C++17新增的新文件系统API进行了广泛的概述，包括路径及其支持函数，用于操作文件和目录。
- en: We concluded this chapter with three examples. In the first we wrote a logger
    to redirect the output of `std::clog` to a log file and `stdout`. The second example
    demonstrated how to rewrite the tail POSIX command using C++.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用三个示例结束了本章。在第一个示例中，我们编写了一个记录器，将`std::clog`的输出重定向到日志文件和`stdout`。第二个示例演示了如何使用C++重写tail
    POSIX命令。
- en: Finally, in the third example, we wrote some benchmarking code to compare the
    difference in performance of POSIX, C and C++. In the next chapter, we will cover
    C++ allocators including how to create stateful allocators such as a memory pool
    that can be used when system programming to improve memory performance and efficiency
    when applicable.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第三个示例中，我们编写了一些基准代码，以比较POSIX、C和C++性能的差异。在下一章中，我们将介绍C++分配器，包括如何创建有状态的分配器，例如在系统编程时可以提高内存性能和效率的内存池。
- en: Questions
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the name of the function used to see whether a file was successfully
    opened?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于查看文件是否成功打开的函数的名称是什么？
- en: What is the default mode for opening a file?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件的默认模式是什么？
- en: What happens if you attempt to read a non-numeric value into a numeric variable
    from a file?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尝试从文件中读取非数字值到数字变量中会发生什么？
- en: What types of error could occur if you unsafely use the `read()` or `write()`
    functions?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`read()`或`write()`函数时可能会发生什么类型的错误？
- en: Does `/= operator()` add a `/` to your path for you automatically?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/ = operator()`是否会自动为您的路径添加`/`？'
- en: What is the stem of the following path—`/home/user/test.txt`?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下路径的stem是什么—`/home/user/test.txt`？
- en: What is the parent directory of the following path—`/home/user/test.txt`?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下路径的父目录是什么—`/home/user/test.txt`？
- en: Further reading
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
