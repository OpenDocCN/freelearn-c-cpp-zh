- en: Intel Edison and IoT (Home Automation)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 英特尔爱迪生和物联网（家庭自动化）
- en: 'In [Chapter 2](bada9944-ec60-4e8f-8d88-0085dd1c8210.xhtml), *Weather Station
    (IoT)*, we dealt with transferring data from Edison to the cloud platform. Here,
    in this chapter, we''ll be doing just the opposite. We''ll be controlling devices
    using the Internet. When we talk about IoT, the first thing that usually comes
    to mind is home automation. Home automation is basically controlling and monitoring
    home electrical appliances using an interface, which may be a mobile application,
    a web interface, a wall touch unit, or more simply, your own voice. So, here in
    this chapter, we''ll be dealing with the various concepts of home automation using
    the MQTT protocol; then, we''ll be controlling an electrical load with an Android
    application and a **Windows Presentation Foundation** (**WPF**) application using
    the MQTT protocol. Some of the topics that we will discuss are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](bada9944-ec60-4e8f-8d88-0085dd1c8210.xhtml)，*气象站（物联网）*，我们处理了从爱迪生到云平台的数据传输。在这里，在本章中，我们将做相反的事情。我们将通过互联网控制设备。当我们谈论物联网时，通常首先想到的是家庭自动化。家庭自动化基本上是通过一个接口来控制和监控家用电器，这个接口可能是一个移动应用程序、一个网页界面、一个墙面触摸单元，或者更简单地说，是你的声音。因此，在本章中，我们将处理使用MQTT协议的家庭自动化的各种概念；然后，我们将使用Android应用程序和**Windows演示基础**（**WPF**）应用程序通过MQTT协议控制一个电负载。我们将讨论的一些主题包括：
- en: The various concepts of controlling devices using the Internet MQTT protocol
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互联网MQTT协议控制设备的各种概念
- en: Using Edison to push data and get data using the MQTT protocol
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用爱迪生通过MQTT协议推送数据和获取数据
- en: LED control using the MQTT protocol
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MQTT协议控制LED
- en: Home automation use cases using the MQTT protocol
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MQTT协议的家庭自动化用例
- en: The controller application in Android (MyMqtt) and in WPF (to be developed)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器应用在Android（MyMqtt）和WPF（待开发）
- en: 'This chapter will use a companion application named MyMqtt, which can be downloaded
    from the Play Store. Credit goes to the developer (Instant Solutions) for developing
    the application and uploading it to the Play Store for free. MyMqtt can be found
    here: [h](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[p](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[s](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[://p](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[l](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[a](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[y](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[.](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[g](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[o](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[o](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[g](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[l](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[e](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[.](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[c](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[o](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[m](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[/s](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[o](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[r](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[e](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[/a](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[p](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[p](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[s](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[/d](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[e](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[a](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[i](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[l](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[s](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[?i](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[d](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[=a](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[.](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[r](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[i](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[p](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[w](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[i](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[r](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[e](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[.](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[m](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[q](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[.](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[c](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[l](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[i](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[e](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[n](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[&h](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[l](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[=e](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[n](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用一个名为 MyMqtt 的配套应用程序，该应用程序可以从 Play 商店下载。感谢开发者（Instant Solutions）开发此应用程序并将其免费上传到
    Play 商店。MyMqtt 可以在这里找到：[h](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[p](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[s](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[://p](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[l](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[a](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[y](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[.](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[g](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[o](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[o](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[g](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[l](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[e](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[.](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[c](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[o](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[m](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[/s](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[o](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[r](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[e](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[/a](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[p](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[p](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[s](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[/d](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[e](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[a](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[i](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[l](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[s](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[?i](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[d](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[=a](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[.](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[r](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[i](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[p](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[w](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[i](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[r](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[e](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[.](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[m](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[q](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[.](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[c](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[l](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[i](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[e](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[n](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[t](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[&h](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[l](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[=e](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)[n](https://play.google.com/store/apps/details?id=at.tripwire.mqtt.client&hl=en)
- en: We are going to develop our own controller for PC as a WPF application that
    will implement the protocol and control your Edison.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发自己的控制器，作为 WPF 应用程序，以实现协议并控制你的 Edison。
- en: To develop the WPF application, we are going to use Microsoft Visual Studio.
    You can download it at [h](https://msdn.microsoft.com/)[t](https://msdn.microsoft.com/)[t](https://msdn.microsoft.com/)[p](https://msdn.microsoft.com/)[s](https://msdn.microsoft.com/)[://m](https://msdn.microsoft.com/)[s](https://msdn.microsoft.com/)[d](https://msdn.microsoft.com/)[n](https://msdn.microsoft.com/)[.](https://msdn.microsoft.com/)[m](https://msdn.microsoft.com/)[i](https://msdn.microsoft.com/)[c](https://msdn.microsoft.com/)[r](https://msdn.microsoft.com/)[o](https://msdn.microsoft.com/)[s](https://msdn.microsoft.com/)[o](https://msdn.microsoft.com/)[f](https://msdn.microsoft.com/)[t](https://msdn.microsoft.com/)[.](https://msdn.microsoft.com/)[c](https://msdn.microsoft.com/)[o](https://msdn.microsoft.com/)[m](https://msdn.microsoft.com/).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发 WPF 应用程序，我们将使用 Microsoft Visual Studio。您可以在[这里](https://msdn.microsoft.com/)下载它。
- en: Controlling devices using the Internet - concepts
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过互联网控制设备 - 概念
- en: When it comes to control devices using the Internet, some key factors come to
    play. Firstly, is the technique to be used. There are lot of techniques in this
    field. A quick workaround is the use of REST services, such as HTTP `GET` requests,
    where we get data from an existing database.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到通过互联网控制设备时，一些关键因素开始发挥作用。首先，是使用的技术。这个领域有很多技术。一种快速的解决方案是使用 REST 服务，例如 HTTP
    `GET` 请求，我们从现有的数据库中获取数据。
- en: Some of the workarounds are discussed here.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里讨论了一些解决方案。
- en: REST services
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST 服务
- en: One of the most commonly-used techniques for obtaining the desired data is by
    an HTTP `GET` call. Most of the IoT platforms that exist in the market have REST
    APIs exposed. There, we can send values from the device to the platform using
    an HTTP `POST` request, and at the same time get data by an HTTP `GET` request.
    Infact, in [Chapter 2](bada9944-ec60-4e8f-8d88-0085dd1c8210.xhtml), *Weather Station
    (IoT)*, where we used `dweet.io` to send data from a device, we used an SDK. Internally,
    the SDK also performs a similar HTTP `POST` call to send in data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 获取所需数据最常用的技术之一是通过 HTTP `GET` 调用。市场上大多数物联网平台都公开了 REST API。在那里，我们可以通过 HTTP `POST`
    请求从设备向平台发送值，同时通过 HTTP `GET` 请求获取数据。实际上，在[第 2 章](bada9944-ec60-4e8f-8d88-0085dd1c8210.xhtml)“气象站（物联网）”，我们使用
    `dweet.io` 从设备发送数据时，我们使用了 SDK。内部，SDK 也执行类似的 HTTP `POST` 调用来发送数据。
- en: Instructions or alerts (present on most IoT platforms)
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令或警报（存在于大多数物联网平台上）
- en: In certain IoT platforms, we have certain ready-made solutions where we just
    need to call a certain web service and the connection is established. Internally,
    it may use REST APIs, but for the benefit of the user, they have come up with
    their own SDK where we implement.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些物联网平台中，我们有一些现成的解决方案，我们只需要调用某个网络服务，连接就会建立。内部，它可能使用 REST API，但为了用户的便利，他们已经推出了自己的
    SDK，我们在其中实现。
- en: Internally, a platform may follow either a REST call, MQTT, or Web Sockets.
    However, we just use an SDK where we don't implement it directly, and by using
    the platform's SDK, we are able to establish a connection. It is entirely platform-specific.
    Here, we are discussing one of the workarounds,where we use the MQTT protocol
    to control our devices directly without the use of any IoT platforms.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，一个平台可能遵循 REST 调用、MQTT 或 Web Sockets。然而，我们只是使用 SDK，我们不直接实现它，通过使用平台的 SDK，我们能够建立连接。这完全取决于平台。在这里，我们讨论了一种解决方案，我们使用
    MQTT 协议直接控制我们的设备，而不使用任何物联网平台。
- en: Architecture
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: 'In a typical system, the IoT platform acts as a bridge between the user and
    the protocols to the controller, as shown in the following figure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的系统中，物联网平台充当用户和控制器协议之间的桥梁，如下面的图所示：
- en: '![](img/image001.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image001.jpg)'
- en: Architecture of the IoT system for controlling devices
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 控制设备的物联网系统架构
- en: The preceding image depicts a typical workflow or architecture of controlling
    devices using the Internet. It is to be noted that the user may directly control
    the controller without the use of an IoT platform, as we do here. However, normally
    a user will use the IoT platform, which also provides more enhanced security.
    The user may use any web interface, mobile application, or a wall control unit
    to control the device using any standard protocol. Here in the image, only REST,
    MQTT, and Web Sockets are included. However, there are more protocols that can
    be used, such as the AMQP protocol, the MODBUS protocol, and so on. The choice
    of the protocol depends mainly on how sensitive the system is and how stable the
    system needs to be.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像展示了使用互联网控制设备的典型工作流程或架构。需要注意的是，用户可以直接控制控制器，而无需使用物联网平台，就像我们在这里做的那样。然而，通常用户会使用物联网平台，它还提供了更高级别的安全性。用户可以使用任何网页界面、移动应用程序或墙面控制单元，通过任何标准协议来控制设备。在此图像中，只包括了
    REST、MQTT 和 Web Sockets。然而，还有更多可以使用的协议，例如 AMQP 协议、MODBUS 协议等。协议的选择主要取决于系统的敏感性和系统需要达到的稳定性。
- en: MQTT protocol overview
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MQTT 协议概述
- en: 'The MQTT protocol is based on the publish-subscribe architecture. It''s a very
    lightweight protocol, where message exchange happens asynchronously. The main
    usage of the MQTT protocol is in places of low bandwidth and low processing power.
    A small code footprint is required for establishing an MQTT connection. Every
    communication in the MQTT protocol happens through a medium called a broker. The
    broker is either subscribed or published. If you want the data to flow from Edison
    to a server, then you publish the data via the broker. A dashboard or an application subscribes
    to the broker with the channel credentials and provides the data. Similarly, when
    we control the device from any application, Edison will act as a subscriber and
    our application will act as a publisher. That''s how the entire system works out.
    The following screenshot explains the concept:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: MQTT 协议基于发布-订阅架构。它是一个非常轻量级的协议，其中消息交换是异步进行的。MQTT 协议的主要用途是在带宽和计算能力较低的地方。建立 MQTT
    连接需要较小的代码占用空间。MQTT 协议中的每条通信都通过一个称为代理的中介进行。代理可以是订阅者或发布者。如果你想从爱迪生向服务器发送数据，那么你将通过代理发布数据。仪表板或应用程序使用通道凭证订阅代理，并提供数据。同样，当我们从任何应用程序控制设备时，爱迪生将作为订阅者，而我们的应用程序将作为发布者。这就是整个系统的工作方式。下面的屏幕截图解释了这一概念：
- en: '![](img/image002.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image002.jpg)'
- en: Overflow where Edison acts as a publisher
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在爱迪生作为发布者的溢出情况
- en: 'In the preceding screenshot, we see Edison acting as a publisher. This is one
    type of use case, where we need to send data from Edison, as with a similar example
    shown in [Chapter 2](bada9944-ec60-4e8f-8d88-0085dd1c8210.xhtml), *Weather Station
    (IoT)*. The application will get the data and act as a publisher. The following
    screenshot depicts the use case that will be used in this chapter: the use of
    Edison as a subscriber:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，我们看到爱迪生作为发布者。这是一种使用案例，我们需要从爱迪生发送数据，就像在[第 2 章](bada9944-ec60-4e8f-8d88-0085dd1c8210.xhtml)中展示的类似示例，*气象站（物联网）*。应用程序将获取数据并作为发布者。下面的屏幕截图展示了本章将使用的使用案例：爱迪生作为订阅者的使用：
- en: '![](img/image003.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image003.jpg)'
- en: Overflow where Edison acts as a subscriber
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在爱迪生作为订阅者的溢出情况
- en: In the preceding case, we have some controls on the application. These controls
    send signals to Edison via the MQTT broker. Now, in this case, the application will
    act as a publisher and Edison acts as a subscriber.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的案例中，我们对应用程序有一些控制。这些控制通过 MQTT 代理向爱迪生发送信号。现在，在这种情况下，应用程序将作为发布者，而爱迪生作为订阅者。
- en: It is to be noted that in a single system, you can make the endpoint (device
    or application) act both as a publisher as well as a subscriber. This occurs when
    we want to get some data from the IoT device, such as the Intel Edison, and also
    control the device in emergency cases. The same may also occur when we need to
    control the home's electrical appliances, as well as monitor them remotely. Although
    most systems are deployed based on a closed loop feedback control, there is always
    room to monitor them remotely, and at the same time have control based on feedback
    received from the sensors.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在单个系统中，你可以使端点（设备或应用程序）同时作为发布者和订阅者。这种情况发生在我们想要从物联网设备（如英特尔爱迪生）获取数据，以及在紧急情况下控制设备时。同样，当我们需要控制家用电器的开关，以及远程监控它们时，也可能发生这种情况。尽管大多数系统是基于闭环反馈控制部署的，但总有远程监控的空间，同时根据从传感器接收到的反馈进行控制。
- en: To implement the MQTT protocol, we are not going to set our own server but use
    an existing one. [https://iot.eclipse.org/](https://iot.eclipse.org/) has provided
    a sandbox server which will be used for the upcoming projects. We're just going
    to set up our broker and then publish and subscribe to the broker. For the Intel
    Edison side, we are going for Node.js and its related libraries. For the application
    end, we are going to use an already available application named MyMqtt for Android.
    If anyone wants to develop his or her own application, then you need to import
    the `paho` library to set up MQTT. We are also developing a PC application, where
    we will again use MQTT to communicate.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 MQTT 协议，我们不会设置自己的服务器，而是使用现有的服务器。[https://iot.eclipse.org/](https://iot.eclipse.org/)
    提供了一个沙盒服务器，将用于即将到来的项目。我们只需设置我们的代理，然后发布和订阅代理。对于 Intel Edison 方面，我们将使用 Node.js 及其相关库。对于应用程序端，我们将使用名为
    MyMqtt 的现有 Android 应用程序。如果有人想开发自己的应用程序，则需要导入 `paho` 库来设置 MQTT。我们还在开发一个 PC 应用程序，其中我们将再次使用
    MQTT 进行通信。
- en: 'For details on the eclipse IoT project on MQTT and other standards, please
    refer to the following link:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Eclipse IoT 项目中 MQTT 和其他标准的详细信息，请参阅以下链接：
- en: '[https://iot.eclipse.org/standards/](https://iot.eclipse.org/standards/)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://iot.eclipse.org/standards/](https://iot.eclipse.org/standards/)'
- en: In the following section, we'll set up and configure Edison for our project
    and also set up the development environment for the WPF application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为我们的项目设置和配置 Edison，并为 WPF 应用程序设置开发环境。
- en: 'The paho project can be accessed through this link:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过此链接访问 paho 项目：
- en: '[https://eclipse.org/paho/](https://eclipse.org/paho/)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://eclipse.org/paho/](https://eclipse.org/paho/)'
- en: Using Intel Edison to push data by using the MQTT protocol
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Intel Edison 通过 MQTT 协议推送数据
- en: 'As previously mentioned, this short section will show users how to push data
    from Edison to an Android device using the MQTT protocol. The following screenshot
    depicts the workflow:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，本节将向用户展示如何使用 MQTT 协议从 Edison 推送数据到 Android 设备。以下截图显示了工作流程：
- en: '![](img/image004.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image004.jpg)'
- en: Workflow of pushing data from the Edison to the Android application
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Edison 推送数据到 Android 应用程序的流程
- en: From the preceding illustration, it is clear that we first obtain readings from
    the temperature sensor and then use the MQTT broker to push the readings to the
    Android application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示意图中可以看出，我们首先从温度传感器获取读数，然后使用 MQTT 代理将读数推送到 Android 应用程序。
- en: 'Firstly, we are going to connect the temperature sensor to Edison. Make a reference
    of the circuit from [Chapter 2](bada9944-ec60-4e8f-8d88-0085dd1c8210.xhtml), *Weather
    Station (IoT)*. After it is connected, fire up your editor to write the following
    Node.js code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将把温度传感器连接到 Edison。参考 [第 2 章](bada9944-ec60-4e8f-8d88-0085dd1c8210.xhtml)，*气象站（物联网）*
    中的电路图。连接完成后，启动您的编辑器编写以下 Node.js 代码：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code written here is similar to what we used in the [Chapter 2](bada9944-ec60-4e8f-8d88-0085dd1c8210.xhtml), *Weather
    Station (IoT)*. Here, the difference is that we are not sending it to `dweet.io`
    but to the MQTT broker. We're publishing the data obtained to a particular channel
    in the MQTT broker.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里编写的代码与我们之前在 [第 2 章](bada9944-ec60-4e8f-8d88-0085dd1c8210.xhtml)，*气象站（物联网）*
    中使用的代码类似。这里的区别是我们不是将其发送到 `dweet.io`，而是发送到 MQTT 代理。我们在 MQTT 代理的特定通道中发布获取到的数据。
- en: 'However, to execute this code, you must have the MQTT dependency installed
    via `npm`. Type in the following command in the PuTTY console:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要执行此代码，您必须通过 `npm` 安装 MQTT 依赖项。在 PuTTY 控制台中输入以下命令：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will install the MQTT dependency.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装 MQTT 依赖项。
- en: 'In the preceding code, we initially imported the required libraries or dependency.
    For this case, we need the `mraa` and the `mqtt` libraries:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们最初导入了所需的库或依赖项。在这种情况下，我们需要 `mraa` 和 `mqtt` 库：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, we need to initialize the analog pin to read the temperature. After that,
    we convert the raw readings to the standard value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要初始化模拟引脚以读取温度。之后，我们将原始读数转换为标准值。
- en: 'We declare the client variable, which will handle the MQTT publish operation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明客户端变量，该变量将处理 MQTT 发布操作：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, [https://iot.eclipse.org/](https://iot.eclipse.org/) is the free broker
    that we are using.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，[https://iot.eclipse.org/](https://iot.eclipse.org/) 是我们使用的免费代理。
- en: 'Next, in the `sendData` function, the initial temperature processing is computed
    before the data is published to the channel:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `sendData` 函数中，在将数据发布到通道之前，计算了初始的温度处理：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The name of the channel is `avirup/temperature`. Please note the type of `sendTemp`.
    The initial processed value is obtained in the variable temperature. Here in `client.publish`,
    the second parameter has to be a string. Thus, we store the temperature value
    as a string type in `sendTemp`. Finally, we print the temperature into the console.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 频道的名称是`avirup/temperature`。请注意`sendTemp`的类型。初始处理后的值存储在变量temperature中。在这里，在`client.publish`中，第二个参数必须是一个字符串。因此，我们将温度值存储为字符串类型在`sendTemp`中。最后，我们将温度打印到控制台。
- en: We have also provided a delay of 1 second. Now run this Node.js file using the
    `node` command.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一个1秒的延迟。现在使用`node`命令运行这个Node.js文件。
- en: 'The screenshot is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 截图如下：
- en: '![](img/6639_03_01.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_01.png)'
- en: Output console log
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出控制台日志
- en: As seen in the preceding screenshot, the log is displayed. Now we need to see
    this data in the Android MyMqtt application.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，日志被显示出来。现在我们需要在Android MyMqtt应用程序中看到这些数据。
- en: While carrying out this mini-project, as well as the later one to be discussed
    under MQTT, please change the channel name. One of my projects may be live and
    it could create an issue. One can go for the `NAME_OF_THE_USER/VARIABLE_NAME`
    convention.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行这个迷你项目以及随后在MQTT下讨论的项目时，请更改频道名称。我的一个项目可能是实时运行的，可能会引起问题。可以采用`NAME_OF_THE_USER/VARIABLE_NAME`约定。
- en: 'Open up the MyMqtt application in Android and browse to Settings. There, in
    the field of Broker URL, insert `iot.eclipse.org`. You will have used this on
    your Node.js snippet as well:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中打开MyMqtt应用程序并浏览到设置。在那里，在代理URL字段中插入`iot.eclipse.org`。你已经在你的Node.js片段中使用过这个了：
- en: '![](img/6639_03_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_02.jpg)'
- en: Screenshot of MyMqtt—1
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: MyMqtt—1的截图
- en: 'Next, go to the Subscribe option and enter your channel name based on your
    Node.js code. In our case, it was `avirup/temperature`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，转到“订阅”选项并输入基于你的Node.js代码的频道名称。在我们的例子中，它是`avirup/temperature`：
- en: '![](img/6639_03_03.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_03.jpg)'
- en: Screenshot of MyMqtt—2
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: MyMqtt—2的截图
- en: 'Click on Add to add the channel and then finally go to the dashboard to visualize
    your data:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 点击添加以添加频道，然后最终转到仪表板以可视化你的数据：
- en: '![](img/6639_03_04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_04.jpg)'
- en: Screenshot of MyMqtt—3
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: MyMqtt—3的截图
- en: If your code on the device is running in parallel to this, then you should get
    live data feed in this dashboard.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的设备上的代码与此并行运行，那么你应该在这个仪表板中获得实时数据流。
- en: So, now you can visualize the data that you are sending from Edison.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在你可以可视化从Edison发送的数据。
- en: Getting data to Edison by using MQTT
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过MQTT将数据发送到Edison
- en: We have been talking about home automation controlling electrical loads, but
    everything has a starting point. The most basic kick-starter is controlling Edison
    over the Internet—that's what it's all about.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在谈论家庭自动化控制电气负载，但每件事都有一个起点。最基本的启动器是控制通过互联网的Edison——这就是它的全部内容。
- en: 'When you have a device that is controllable over the Internet, we recommend
    controlling the electrical loads. In this other mini-project, we are going to
    control a simple LED that is already attached to pin `13` of Intel Edison. There
    is no need for any external hardware for this, as we are using an in-built functionality.
    Now, open your editor and type in the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个可以通过互联网控制的设备时，我们建议控制电气负载。在这个其他迷你项目中，我们将控制一个已经连接到Intel Edison的引脚`13`的简单LED。为此不需要任何外部硬件，因为我们使用的是内置功能。现在，打开你的编辑器并输入以下代码：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code will subscribe to the channel in the broker and wait for
    incoming signals.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将订阅代理中的频道并等待接收信号。
- en: 'Initially, we''ve declared the GPIO pin `13` as the output mode because the
    onboard LED is connected to this pin:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们将GPIO引脚`13`声明为输出模式，因为板载LED连接到这个引脚：
- en: '![](img/image009.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image009.jpg)'
- en: Onboard LED location
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 板载LED位置
- en: The location of the onboard LED is shown in the preceding image.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个图像显示了板载LED的位置。
- en: On having a close look at the code, we see that it initially imports the library
    and then sets the GPIO pin configuration. Then, we use a variable client to initiate
    the MQTT connection to the broker.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看代码，我们看到它最初导入库并设置GPIO引脚配置。然后，我们使用变量client初始化到代理的MQTT连接。
- en: After that, we move on to subscribe our device to the channel, which in this
    case is named as `avirup/control/#`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们继续将我们的设备订阅到频道，在这个例子中，该频道被命名为`avirup/control/#`。
- en: We have an event handler, `handleMessage()`. This event handler will deal with
    incoming messages. The incoming message will be stored in the packet variable.
    We've also implemented a callback method, `callback()`, which needs to be called
    from `handleMessage()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个事件处理器，`handleMessage()`。此事件处理器将处理传入的消息。传入的消息将存储在包变量中。我们还实现了一个回调方法，`callback()`，它需要在
    `handleMessage()` 中调用。
- en: This enables us to receive multiple messages. Also note that, unlike other Node.js
    snippets, we haven't implemented any loop. The functionality is actually handled
    by the `callback()` method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够接收多条消息。请注意，与 Node.js 的其他片段不同，我们没有实现任何循环。功能实际上是由 `callback()` 方法处理的。
- en: Finally, inside the function we obtain the payload, which is the message. It
    is then converted to a string and then condition checking is performed. We also
    print the value received to the console.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在函数内部，我们获取有效载荷，即消息。然后将其转换为字符串，并执行条件检查。我们还打印接收到的值到控制台。
- en: Now push this code to your Edison using FileZilla and run the code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将此代码通过 FileZilla 推送到您的 Edison 并运行代码。
- en: Once you run the code, you won't see anything in the console. The reason behind
    that is there is no message. Now, go to the Android application, MyMqtt, and browse
    to the Publish section of the application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行代码，您在控制台将看不到任何内容。原因是没有任何消息。现在，转到 Android 应用程序 MyMqtt，浏览到应用程序的发布部分。
- en: 'We need to insert the channel name here. In this case, it is `avirup/control`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这里插入通道名称。在这种情况下，它是 `avirup/control`：
- en: '![](img/6639_03_05.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_05.png)'
- en: Publish MyMqtt
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 发布 MyMqtt
- en: In the Topic section, enter the channel name, and in the Message section enter
    the message to be sent to Edison.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在主题部分，输入通道名称，在消息部分输入要发送给 Edison 的消息。
- en: Now, in parallel, run your Node.js code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，同时运行您的 Node.js 代码。
- en: 'Once your code is up and running, we will send a message. Type `ON` in the
    Message field and click Publish:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的代码运行起来，我们将发送一条消息。在消息字段中键入 `ON` 并点击发布：
- en: '![](img/6639_03_06.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_06.png)'
- en: Send control signals
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 发送控制信号
- en: 'Once you have published from the application, it should be reflected on the
    PuTTY console:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您从应用程序中发布，它应该会在 PuTTY 控制台中反映出来：
- en: '![](img/6639_03_07.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_07.png)'
- en: Message send and receive—MQTT
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 消息发送和接收——MQTT
- en: Now you should see that the LED is turned on.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该看到 LED 已经点亮。
- en: 'Similarly, send a message, `OFF`, to turn off the onboard LED:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，发送一条消息 `OFF` 来关闭板载 LED：
- en: '![](img/6639_03_08.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_08.png)'
- en: Message send and receive. The LED should turn off
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 消息发送和接收。LED 应该熄灭
- en: It's also worth noting that this will work even if Edison and the device aren't
    connected to the same network.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，即使 Edison 和设备没有连接到同一网络，这也会正常工作。
- en: Now you can control your Intel Edison with your Android application. Virtually
    speaking, you can now control your home. In the following section, we'll deep
    dive into the home automation scenario and also develop a WPF application to control.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用您的 Android 应用程序控制您的 Intel Edison。从虚拟的角度来看，您现在可以控制您的家了。在下一节中，我们将深入了解家庭自动化场景，并开发一个用于控制的
    WPF 应用程序。
- en: Home automation using Intel Edison, MQTT, Android, and WPF
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Intel Edison、MQTT、Android 和 WPF 进行家庭自动化
- en: 'Until now we have learned about the MQTT protocol and how to subscribe and
    publish data, both using the application and Edison. Now we will be dealing with
    a real use case where we''ll control an electrical load using Intel Edison, which
    again will be controlled by the Internet. Here is a quick introduction about what
    we will be dealing with:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了 MQTT 协议以及如何使用应用程序和 Edison 订阅和发布数据。现在我们将处理一个实际用例，我们将使用 Intel Edison
    控制一个电气负载，它再次将通过互联网控制。以下是关于我们将要处理的内容的简要介绍：
- en: Hardware components and circuits
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件组件和电路
- en: Developing a WPF application to control Intel Edison
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发用于控制 Intel Edison 的 WPF 应用程序
- en: Using MQTT to stitch everything together
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MQTT 将一切连接起来
- en: Since we've already seen how to control Edison using an Android application,
    this section won't concentrate on that; instead, it will mainly deal with the
    WPF application. This is just to give you a brief idea about how a PC can control
    IoT devices, not only in home automation, but also in various other use cases,
    both in simple proof of concept scenarios to industry standard solutions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经看到了如何使用 Android 应用程序控制 Edison，本节不会专注于这一点；相反，它将主要处理 WPF 应用程序。这只是为了给您一个简要的了解，了解一台
    PC 如何控制物联网设备，不仅限于家庭自动化，还包括各种其他用例，从简单的概念验证场景到行业标准解决方案。
- en: Hardware components and circuit
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件组件和电路
- en: 'When we are dealing with electrical load, we simply cannot directly connect
    it to Edison or any other boards, as it will end up frying. For dealing with these
    loads, an interfacing circuit is used called a relay. A relay in its crude form
    is a series of electromechanical switches. They operate on a DC voltage and control
    AC sources. Components that will be used are listed as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理电气负载时，我们绝对不能直接将其连接到爱迪生或其他任何板子上，因为这会导致烧毁。为了处理这些负载，我们使用一个称为继电器的接口电路。继电器在其原始形式上是一系列机电开关。它们在直流电压下工作，并控制交流电源。以下列出了将要使用的组件：
- en: Intel Edison
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英特尔爱迪生
- en: 5V relay module
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5V 继电器模块
- en: Electric bulb wires
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电灯泡电线
- en: 'Before going into the circuitry, we''ll discuss relays first:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入电路之前，我们首先讨论继电器：
- en: '![](img/6639_03_09.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_03_09.jpg)'
- en: 'Relay schematics. Picture credits: [h](http://www.phidgets.com/docs/3051_User_Guide)[t](http://www.phidgets.com/docs/3051_User_Guide)[t](http://www.phidgets.com/docs/3051_User_Guide)[p](http://www.phidgets.com/docs/3051_User_Guide)[://w](http://www.phidgets.com/docs/3051_User_Guide)[w](http://www.phidgets.com/docs/3051_User_Guide)[w](http://www.phidgets.com/docs/3051_User_Guide)[.](http://www.phidgets.com/docs/3051_User_Guide)[p](http://www.phidgets.com/docs/3051_User_Guide)[h](http://www.phidgets.com/docs/3051_User_Guide)[i](http://www.phidgets.com/docs/3051_User_Guide)[d](http://www.phidgets.com/docs/3051_User_Guide)[g](http://www.phidgets.com/docs/3051_User_Guide)[e](http://www.phidgets.com/docs/3051_User_Guide)[t](http://www.phidgets.com/docs/3051_User_Guide)[s](http://www.phidgets.com/docs/3051_User_Guide)[.](http://www.phidgets.com/docs/3051_User_Guide)[c](http://www.phidgets.com/docs/3051_User_Guide)[o](http://www.phidgets.com/docs/3051_User_Guide)[m](http://www.phidgets.com/docs/3051_User_Guide)[/d](http://www.phidgets.com/docs/3051_User_Guide)[o](http://www.phidgets.com/docs/3051_User_Guide)[c](http://www.phidgets.com/docs/3051_User_Guide)[s](http://www.phidgets.com/docs/3051_User_Guide)[/3051_](http://www.phidgets.com/docs/3051_User_Guide)[U](http://www.phidgets.com/docs/3051_User_Guide)[s](http://www.phidgets.com/docs/3051_User_Guide)[e](http://www.phidgets.com/docs/3051_User_Guide)[r](http://www.phidgets.com/docs/3051_User_Guide)[_](http://www.phidgets.com/docs/3051_User_Guide)[G](http://www.phidgets.com/docs/3051_User_Guide)[u](http://www.phidgets.com/docs/3051_User_Guide)[i](http://www.phidgets.com/docs/3051_User_Guide)[d](http://www.phidgets.com/docs/3051_User_Guide)[e](http://www.phidgets.com/docs/3051_User_Guide)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 继电器电路图。图片来源：[h](http://www.phidgets.com/docs/3051_User_Guide)[t](http://www.phidgets.com/docs/3051_User_Guide)[t](http://www.phidgets.com/docs/3051_User_Guide)[p](http://www.phidgets.com/docs/3051_User_Guide)[://w](http://www.phidgets.com/docs/3051_User_Guide)[w](http://www.phidgets.com/docs/3051_User_Guide)[w](http://www.phidgets.com/docs/3051_User_Guide)[.](http://www.phidgets.com/docs/3051_User_Guide)[p](http://www.phidgets.com/docs/3051_User_Guide)[h](http://www.phidgets.com/docs/3051_User_Guide)[i](http://www.phidgets.com/docs/3051_User_Guide)[d](http://www.phidgets.com/docs/3051_User_Guide)[g](http://www.phidgets.com/docs/3051_User_Guide)[e](http://www.phidgets.com/docs/3051_User_Guide)[t](http://www.phidgets.com/docs/3051_User_Guide)[s](http://www.phidgets.com/docs/3051_User_Guide)[.](http://www.phidgets.com/docs/3051_User_Guide)[c](http://www.phidgets.com/docs/3051_User_Guide)[o](http://www.phidgets.com/docs/3051_User_Guide)[m](http://www.phidgets.com/docs/3051_User_Guide)[/d](http://www.phidgets.com/docs/3051_User_Guide)[o](http://www.phidgets.com/docs/3051_User_Guide)[c](http://www.phidgets.com/docs/3051_User_Guide)[s](http://www.phidgets.com/docs/3051_User_Guide)[/3051_](http://www.phidgets.com/docs/3051_User_Guide)[U](http://www.phidgets.com/docs/3051_User_Guide)[s](http://www.phidgets.com/docs/3051_User_Guide)[e](http://www.phidgets.com/docs/3051_User_Guide)[r](http://www.phidgets.com/docs/3051_User_Guide)[_](http://www.phidgets.com/docs/3051_User_Guide)[G](http://www.phidgets.com/docs/3051_User_Guide)[u](http://www.phidgets.com/docs/3051_User_Guide)[i](http://www.phidgets.com/docs/3051_User_Guide)[d](http://www.phidgets.com/docs/3051_User_Guide)[e](http://www.phidgets.com/docs/3051_User_Guide)
- en: 'The red rectangular area represents the electromagnet. We excite the electromagnet
    with a DC voltage, and that triggers the mechanical switch. Having a closer look
    at the preceding image, we can see three ports where the AC load is connected:
    common, normally closed, and normally open. In default conditions, that is when
    the electromagnet is not excited, and the common and normally closed ports are
    connected. What we are interested in for now is the normally open port.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 红色矩形区域代表电磁铁。我们用直流电压激发电磁铁，这会触发机械开关。仔细观察前面的图像，我们可以看到三个连接交流负载的端口：公共端口、常闭端口和常开端口。在默认条件下，即当电磁铁未被激发时，公共端口和常闭端口是连接的。目前我们感兴趣的是常开端口。
- en: 'The image of the relay used is shown as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的继电器图像如下所示：
- en: '![](img/image015.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image015.jpg)'
- en: 'Relay unit. Picture credits: Seed Studio'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 继电器单元。图片来源：Seed Studio
- en: 'The electrical load will have a live and neutral wire. Connect either one according
    to the following circuit:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 电气负载将有一个火线和零线。根据以下电路连接其中之一：
- en: '![](img/image016.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image016.jpg)'
- en: Basic relay connection
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 基本继电器连接
- en: With reference to the preceding figure, **Vcc** and **Gnd** are connected to
    the controller. The AC source connects one end of the electrical load directly,
    while the other is via the relay. A part of it connects the common port, while
    the other may be in **normally closed** (**NC**) or **normally open** (**NO**).
    When you have the other end of the electrical load connected to the NC port, then
    by default without excitation of the electromagnet, the circuit is complete. Since
    we don't want the bulb to be operating when the electromagnet isn't excited, connect
    it to the **NO** port, rather than **NC**. Thus, when the electromagnet is operating
    by applying voltage on **Vcc** and **Gnd** as ground, the mechanical switch flips
    to the **NO** position, thus connecting it with the common port.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 参考前面的图示，**Vcc** 和 **Gnd** 连接到控制器。交流电源直接连接到电负载的一端，而另一端通过继电器连接。其中一部分连接到公共端口，而另一部分可能是**常闭**（**NC**）或**常开**（**NO**）。当你将电负载的另一端连接到NC端口时，那么默认情况下，在没有电磁铁激励的情况下，电路是完整的。由于我们不希望当电磁铁未激励时灯泡在运行，所以将其连接到**NO**端口，而不是**NC**。因此，当通过在**Vcc**和**Gnd**上施加电压来激励电磁铁时，机械开关翻转到**NO**位置，从而将其与公共端口连接。
- en: The whole idea behind the operation of a relay is the use of electromechanical
    switches to complete a circuit. However, it is worth noting that not all relays
    operate on the same principle; some relays use solid state devices to operate.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 交流继电器操作背后的整个想法是使用机电开关来完成电路。然而，值得注意的是，并非所有继电器都基于相同的原理运行；一些继电器使用固态器件来操作。
- en: '**Solid State Relays** (**SSRs**) don''t have any movable parts unlike that
    of electromechanical relays. SSRs uses photo-couplers to isolate the input and
    the output. They change electrical signals to optical signals, which propagates
    through space and thus isolates the entire circuit. The coupler on the receiving
    end is connected to any switching device, such as a MOSFET, to perform the switching
    action.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**固态继电器**（**SSR**）与机电继电器不同，没有可移动部件。SSR使用光电耦合器来隔离输入和输出。它们将电信号转换为光信号，这些信号通过空间传播，从而隔离整个电路。接收端的光耦合器连接到任何开关设备，例如MOSFET，以执行开关动作。'
- en: 'There are some advantages of using SSRs over electromechanical relays. They
    are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSR而不是机电继电器有一些优点。如下所示：
- en: They provide high speed, high frequency switching operations
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供高速、高频的开关操作
- en: There is failure of contact points
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接触点有故障
- en: They generate minimal noise
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们产生的噪音最小
- en: They don't generate operation noise
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不会产生操作噪音
- en: Although we will use electromechanical relays for now, if the use case deals
    with high frequency switching, then it's better to go with SSRs. It is also to
    be noted that when exposed to long usage, SSRs are known to heat up.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在将使用机电继电器，但如果用例涉及高频开关，则最好选择SSR。还应注意，当长时间使用时，SSR会变热。
- en: Final circuit
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终电路
- en: 'The entire connection is shown in the following figure:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 整个连接在以下图中显示：
- en: '![](img/image017.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image017.jpg)'
- en: Circuit diagram for home automation project
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 家庭自动化项目的电路图
- en: The circuit adds Intel Edison because the relay circuit will be controlled by
    the controller. The relay here just acts as an interfacing unit to the AC load.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 电路添加Intel Edison是因为继电器电路将由控制器控制。这里的继电器仅作为AC负载的接口单元。
- en: While the relay is being operated, please do not touch the underside of it or
    you may get an AC electric shock, which can be dangerous.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当继电器正在运行时，请不要触摸其底部，否则可能会遭受AC电击，这可能是危险的。
- en: 'To test whether the circuit is working or not, try out a simple program using
    the Arduino IDE:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试电路是否工作，请尝试使用Arduino IDE编写一个简单的程序：
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code should switch the position of the switch from the NC position to the
    NO position, thus completing the circuit, leading your bulb to glow. Don't forget
    to switch on the AC power supply.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应将开关的位置从NC位置切换到NO位置，从而完成电路，使你的灯泡发光。别忘了打开AC电源。
- en: Once you have the final circuit ready, we'll move forward with the development
    of the WPF application, which will control Edison.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好了最终电路，我们将继续进行WPF应用程序的开发，该应用程序将控制Edison。
- en: Android application for controlling Intel Edison using MQTT
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MQTT控制Intel Edison的Android应用程序
- en: In the previous section, we saw how an Android application can be used to subscribe
    and publish to a channel using a broker. Here, in this section, we'll develop
    our own Android application for controlling the device using MQTT. The section
    won't concentrate on the set up of the Android, but will concentrate on the development
    side of it. We're going to use the Android Studio IDE for the development of the
    application. Make sure it's configured with all the latest SDKs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何使用代理来订阅和发布到通道的Android应用程序。在本节中，我们将开发自己的Android应用程序，用于通过MQTT控制设备。本节不会集中讨论Android的设置，而是将集中在开发方面。我们将使用Android
    Studio IDE来开发应用程序。请确保它已配置了所有最新的SDK。
- en: 'Open your Android Studio:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的Android Studio：
- en: '![](img/6639_03_10.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_03_10.jpg)'
- en: Android Studio—1
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio—1
- en: 'Now, select Start a new Android Studio project:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择“开始一个新的Android Studio项目”：
- en: '![](img/6639_03_11.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_03_11.png)'
- en: Android Studio—set up application name
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio—设置应用程序名称
- en: 'Enter a name for your application; here, we''ve entered `MQTT`. Click on Next
    to continue:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的应用程序输入一个名称；在这里，我们输入了`MQTT`。点击“下一步”继续：
- en: '![](img/6639_03_12.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_03_12.png)'
- en: 'Android Studio: set API level'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio：设置API级别
- en: 'Now select the Minimum SDK version. Select API 23: Android 6.0 (Marshmallow).
    Now let''s select the type of activity:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在请选择最小SDK版本。选择API 23：Android 6.0（棉花糖）。现在让我们选择活动类型：
- en: '![](img/6639_03_13.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_03_13.png)'
- en: Set activity
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 设置活动
- en: 'Select Empty Activity and click on Next:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 选择“空活动”并点击“下一步”：
- en: '![](img/6639_03_14.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_03_14.png)'
- en: Set start-up activity name
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 设置启动活动名称
- en: 'Give a name to your activity and click on Finish. It may take a few minutes
    to set up your project. After it''s done, you may see a screen like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 给您的活动起一个名字并点击“完成”。设置项目可能需要几分钟时间。完成后，您可能会看到如下屏幕：
- en: '![](img/6639_03_15.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_03_15.jpg)'
- en: Design page. activity_name.xml
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 设计页面。activity_name.xml
- en: 'If you have a closer look over the project folder, you will notice that we
    have folders such as `java`, `res`, `values`, and so on. Let''s have a closer
    look at what these folders actually contain:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细查看项目文件夹，您会注意到我们有一些文件夹，如`java`、`res`、`values`等。让我们更仔细地看看这些文件夹实际上包含什么：
- en: '`java`: This contains all the `.java` source files for your project. The main
    activity, named as `MainActivity.java`, is also contained in this project.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java`: 这包含项目中所有的`.java`源文件。主活动，命名为`MainActivity.java`，也包含在这个项目中。'
- en: '`res/drawable`: This is a directory for drawable components for this project.
    It won''t be used for the moment.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res/drawable`: 这是一个用于此项目可绘制组件的目录。目前它不会被使用。'
- en: '`res/layout`: This contains all the files responsible for the applications
    UI.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res/layout`: 这包含所有负责应用程序UI的文件。'
- en: '`res/values`: This is a kind of directory for various other `xml` files that
    contain definitions of resources, such as string and color.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res/values`: 这是一个包含资源定义的`xml`文件的其他类型的目录，例如字符串和颜色。'
- en: '`AndroidManifest.xaml`: This is a manifest file that defines the application as
    well as the permissions required by the application.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndroidManifest.xaml`: 这是一个定义应用程序以及应用程序所需权限的清单文件。'
- en: '`build.gradle`: This is an auto-generated file that contains information such
    as `compileSdkVersion`, `buildToolsVersion`, `applicationID`, and so on.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build.gradle`: 这是一个自动生成的文件，其中包含诸如`compileSdkVersion`、`buildToolsVersion`、`applicationID`等信息。'
- en: In this application, we will be using a third-party resource or library known
    as the eclipse `paho` library for MQTT. These dependencies need to be added to
    `build.gradle`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们将使用一个名为eclipse `paho`库的第三方资源或库来处理MQTT。这些依赖项需要添加到`build.gradle`。
- en: 'There should be two `build.gradle` files. We need to add the dependencies in
    the `build.gradle(Module:app)` file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 应该有两个`build.gradle`文件。我们需要在`build.gradle(Module:app)`文件中添加依赖项：
- en: '[PRE7]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A dependency block should already exist, so you need not write the entire thing
    again. In that case, just write `compile(''org.eclipse.paho:org.eclipse.paho.android.service:1.0.3-SNAPSHOT'')
    { exclude module: ''support-v4''` in the already present dependency block. Immediately
    after you paste the code, Android Studio will ask you to sync gradle. It is necessary
    that you sync gradle before proceeding:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '应该已经存在一个依赖块，因此您不需要再次编写整个内容。在这种情况下，只需在现有的依赖块中写入`compile(''org.eclipse.paho:org.eclipse.paho.android.service:1.0.3-SNAPSHOT'')
    { exclude module: ''support-v4''`即可。粘贴代码后，Android Studio将要求您同步gradle。在继续之前同步gradle是必要的：'
- en: '![](img/6639_03_16.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_03_16.jpg)'
- en: Add dependencies
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 添加依赖项
- en: 'Now we need to add permissions and services to our project. Browse to `AndroidManifest.xml`
    and add the following permission and services:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要向我们的项目中添加权限和服务。浏览到`AndroidManifest.xml`并添加以下权限和服务：
- en: '[PRE8]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After this is done, we will move forward with the UI. The UI needs to be designed
    under the layout, in the `activity_main.xml` file.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们将继续进行UI设计。UI需要在`layout`下的`activity_main.xml`文件中进行设计。
- en: 'We''ll have the following UI components:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将拥有以下UI组件：
- en: '`EditText`: This is for the broker'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditText`：这是用于代理'
- en: '`URL EditText`: This is for the `EditText` port for the channel'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL EditText`：这是用于通道的`EditText`端口'
- en: 'Button to connect:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 连接按钮：
- en: On button to send the on signal
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮用于发送信号
- en: Off button to send the off signal
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭按钮用于发送关闭信号
- en: Drag and drop the previously mentioned components in the designer window. Alternatively,
    you can directly write it in the text view.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将之前提到的组件拖放到设计器窗口中。或者，你可以在文本视图中直接编写它。
- en: 'For your reference, the XML code of the final design is shown as follows. Write
    your code inside the relative layout tab:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你参考的最终设计的XML代码。请在相对布局选项卡中编写你的代码：
- en: '[PRE9]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now click on the Design view; you will see that a UI has been created, which
    should be somewhat similar to that of the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在单击设计视图；你会看到已经创建了一个UI，它应该与以下截图中的类似：
- en: '![](img/6639_03_17.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_03_17.png)'
- en: Application design
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序设计
- en: 'Now have a closer look at the preceding code to try to find out the properties
    that were used. Basic properties such as `height`, `width`, and `position` are
    set, which is understandable from the code. The main properties are `text`, `id `and
    `hint` of the `EditText`. Each component in the Android UI should have a unique
    ID. Beside that, we set a hint such that the user knows exactly what to enter
    in the text areas. For ease, we have defined the text such that while deploying,
    we don''t need to do that again. In the final application, remove the text properties.
    There is another option to get your values from `strings.xml`, which can be found
    under values for the texts or the hints:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在仔细查看前面的代码，尝试找出所使用的属性。基本的属性如`height`、`width`和`position`已设置，这从代码中可以理解。主要的属性是`EditText`的`text`、`id`和`hint`。Android
    UI中的每个组件都应该有一个唯一的ID。除此之外，我们还设置了一个提示，以便用户知道在文本区域中应该输入什么。为了方便，我们定义了文本，这样在部署时就不需要再次进行设置。在最终的应用程序中，移除文本属性。还有一个选项可以从`strings.xml`获取值，该文件位于文本或提示的`values`下：
- en: '[PRE10]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we have the UI ready, we need to implement our code that will use these
    UI components to interact with the device using the MQTT protocol. We also have
    the dependencies in place. The main Java code is written in `MainActivity.java`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了UI，我们需要实现使用这些UI组件通过MQTT协议与设备交互的代码。我们也有适当的依赖项。主要的Java代码写在`MainActivity.java`中。
- en: 'Before proceeding further with the `MainActivity.java` activity, let''s create
    a class that will handle the MQTT connection. This will make the code a lot easier
    to understand and more efficient. Have a look at the following screenshot to see
    the location of the `MainActivity.java` file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步进行`MainActivity.java`活动之前，让我们创建一个将处理MQTT连接的类。这将使代码更容易理解且更高效。查看以下截图以了解`MainActivity.java`文件的位置：
- en: '![](img/6639_03_18.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_03_18.png)'
- en: 'Right click on the highlighted folder and click on new | java class. This class
    will handle all the required data exchanges happening between the application and
    the MQTT broker:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击突出显示的文件夹，然后单击“新建 | Java类”。这个类将处理应用程序和MQTT代理之间发生的所有必要的数据交换：
- en: '[PRE11]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code that is pasted earlier may seem complicated at first glance, but it's
    actually very simple once you understand it. It is assumed that the reader has
    a basic understanding of object-oriented programming concepts.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 之前粘贴的代码乍一看可能很复杂，但一旦理解了它，实际上非常简单。假设读者对面向对象编程概念有基本的了解。
- en: The statements that import the packages are all done automatically. After creating
    the class, implement the `MqttCallback` interface. This will add the abstract
    methods that are required to be overridden.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 导入包的语句都是自动完成的。创建类后，实现`MqttCallback`接口。这将添加需要重写的抽象方法。
- en: 'Initially, we write a parameterized constructor for this class. We also create
    a global reference variable for the `MqttClient` and the `MqttCallback` classes.
    Three global variables are also created for `serverURI`, `port`, and `clientID`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们为这个类编写一个参数化构造函数。我们还创建了一个全局引用变量用于`MqttClient`和`MqttCallback`类。还创建了三个全局变量用于`serverURI`、`port`和`clientID`：
- en: '[PRE12]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The parameters are the broker `URI`, `port` number, and the `clientID`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是代理`URI`、`port`号码和`clientID`。
- en: 'Next, we have created three global variables that are set to the parameters.
    In the `MqttConnect` method, we initially form a string as we take input as just
    the server URI. Here, we append it with `tcp://` and the port number and also
    create an object for the `MemoryPersistence` class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了三个全局变量，并将它们设置为参数。在`MqttConnect`方法中，我们最初形成一个字符串，因为我们只接受服务器URI作为输入。在这里，我们将其与`tcp://`和端口号连接，并创建一个`MemoryPersistence`类的对象：
- en: '[PRE13]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we create the objects for the global reference variables using the `new`
    keyword:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`new`关键字为全局引用变量创建对象：
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Please note the parameters as well.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意参数。
- en: 'The preceding code is surrounded by a try catch block to handle exceptions.
    The catch block is shown as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码被try-catch块包围，以处理异常。catch块如下所示：
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The connection part is achieved. The next phase is to create the `publish` method
    that will publish the data to the broker.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 连接部分已完成。下一个阶段是创建将数据发布到代理的`publish`方法。
- en: 'The parameter is just the `message` of type string:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 参数只是字符串类型的`message`：
- en: '[PRE16]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`client.publish` is used to publish data. The parameter is a string which is
    the `clientID` or `channelID` and an object of type `MqttMessage`. `MqttMessage`
    contains our message. However, it doesn''t accept strings. It uses a byte array.
    In the try block, we first convert the string to a byte array and then publish
    the final message by using the `MqttMessage` class to the specific channel.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`client.publish`来发布数据。参数是一个字符串，它是`clientID`或`channelID`，以及一个`MqttMessage`类型的对象。`MqttMessage`包含我们的消息。然而，它不接受字符串。它使用一个字节数组。在try块中，我们首先将字符串转换为字节数组，然后使用`MqttMessage`类将最终消息发布到特定的频道。
- en: For this specific application, the overridden methods aren't required, so we
    leave it as is.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的应用程序，不需要重写的方法，所以我们保持原样。
- en: Now head back to the `MainActivity.java` class. We will use the `MqttClass`
    that we just created to do the publish action. The main task here is to get data
    from the UI and use it to connect to the broker using the class that we just wrote.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到`MainActivity.java`类。我们将使用我们刚刚创建的`MqttClass`来进行发布操作。这里的任务是获取UI中的数据，并使用我们刚刚编写的类连接到代理。
- en: 'The `MainActivity.java` will contain the following code by default:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`MainActivity.java`将包含以下代码：
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Whenever the application is opened, the `onCreate` method is triggered. On having
    a closer look at the activity life cycle, the concept will be clear.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每次应用程序打开时，`onCreate`方法都会被触发。仔细观察活动生命周期后，这个概念将变得清晰。
- en: 'The life cycle callbacks are:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期回调包括：
- en: '`onCreate()`'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onCreate()`'
- en: '`onStart()`'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onStart()`'
- en: '`onResume()`'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onResume()`'
- en: '`onPause()`'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onPause()`'
- en: '`onStop()`'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onStop()`'
- en: '`onDestroy()`'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onDestroy()`'
- en: 'More details on the life cycle can be obtained from:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于生命周期的细节可以从以下链接获取：
- en: '[https://developer.android.com/guide/components/activities/activity-lifecycle.html](https://developer.android.com/guide/components/activities/activity-lifecycle.html)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.android.com/guide/components/activities/activity-lifecycle.html](https://developer.android.com/guide/components/activities/activity-lifecycle.html)'
- en: Now we need to assign some reference variables to the UI components. We'll do
    that on a global level.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将一些引用变量分配给UI组件。我们将在全局级别上完成这个操作。
- en: 'Before the start of `onCreate` method, that is before the keyword override,
    add the following lines:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`方法开始之前，即在`override`关键字之前，添加以下行：
- en: '[PRE18]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, in the `onCreate` method, we need to assign the reference variables we
    just declared and explicitly typecast them to the class type:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`onCreate`方法中，我们需要分配我们刚刚声明的引用变量，并将它们显式转换为类类型：
- en: '[PRE19]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding lines, we have explicitly type-casted them to `EditText` and
    `Button`, and bound them to the UI components.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的行中，我们已将它们显式转换为`EditText`和`Button`，并将它们绑定到UI组件上。
- en: 'Now we will create a new event handler for the connect button:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为连接按钮创建一个新的事件处理器：
- en: '[PRE20]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding block is activated when we press the connect button. The block
    contains a method whose parameter is view. The code that needs to be executed
    when the button is pressed needs to be written inside the `onCLick(View v)` method.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按下连接按钮时，前面的块会被激活。该块包含一个参数为 view 的方法。当按钮被按下时需要执行的代码需要写入 `onCLick(View v)`
    方法中。
- en: 'Before that, create a global reference variable for the class that you created
    before:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，为之前创建的类创建一个全局引用变量：
- en: '[PRE21]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, inside the method, get the text from the edit boxes. Declare the global
    variables for those of the type string beforehand:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在方法内部，从编辑框中获取文本。事先声明那些类型为字符串的全局变量：
- en: '[PRE22]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, write the following code inside the `onClick` method:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `onClick` 方法中编写以下代码：
- en: '[PRE23]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once we get the data, we will create an object for the `MqttClass` class and
    pass the strings as parameters, and we will also invoke the `MqttConnect` method:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取了数据，我们将为 `MqttClass` 类创建一个对象，并将字符串作为参数传递，我们还将调用 `MqttConnect` 方法：
- en: '[PRE24]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now we''ll create similar cases for the `ON` and `OFF` methods:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为 `ON` 和 `OFF` 方法创建类似的案例：
- en: '[PRE25]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have used the `MqttPublish` method of `MqttClass`. The parameter is just
    a string and is based on the `onClick` method that when it is activated, it publishes
    the data.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `MqttClass` 的 `MqttPublish` 方法。参数只是一个字符串，基于当它被激活时发布数据的 `onClick` 方法。
- en: Now the application is ready and can be deployed on your device. You must turn
    on the developer mode on your Android device and to deploy it, connect your device
    to a PC and press the Run button. You should now have the application running
    on your device. To test your application, you can directly use Edison or just
    use the MyMqtt application.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序已准备就绪，可以部署到您的设备上。您必须在您的 Android 设备上开启开发者模式，并将设备连接到 PC，然后按下运行按钮。现在您应该在设备上运行应用程序。要测试您的应用程序，您可以直接使用
    Edison 或仅使用 MyMqtt 应用程序。
- en: Windows Presentation Foundation application for controlling using MQTT
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MQTT 控制的 Windows Presentation Foundation 应用程序
- en: WPF is a powerful UI framework for building Windows desktop client applications.
    It supports a broad spectrum of application features including models, controls,
    graphics layout, data binding, documents, and security. The programming is based
    on C# for the core logic and XAML for the UI.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 是一个强大的 UI 框架，用于构建 Windows 桌面客户端应用程序。它支持广泛的应用程序功能，包括模型、控件、图形布局、数据绑定、文档和安全。编程基于
    C# 的核心逻辑和 XAML 的 UI。
- en: Sample "Hello World" application in WPF
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WPF 中的“Hello World”示例应用程序
- en: Before moving on to the development of an application for controlling Intel
    Edison, let's have a brief look at how we can integrate certain basic features
    such as a button click event, handling displaying data, and so on. Open up your
    Visual Studio and select New Project.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始开发控制 Intel Edison 的应用程序之前，让我们简要看看我们如何集成某些基本功能，例如按钮点击事件、处理显示数据等。打开您的 Visual
    Studio 并选择新建项目。
- en: 'In PCs with low RAM, the installation of Visual Studio may take a while, as
    will opening Visual for the first time:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在低内存的 PC 上，安装 Visual Studio 可能需要一段时间，首次打开 Visual Studio 也是如此：
- en: 'The reason we are working with WPF is that it will be used in multiple topics,
    such as those in this chapter and in the upcoming chapters on robotics. In robotics,
    we''ll be developing software to control robots. It is also assumed that the reader
    has an understanding of Visual Studio. For detailed information about how to work
    with Visual Studio and WPF, refer to the following link:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 WPF 的原因是它将在多个主题中使用，例如本章以及即将到来的关于机器人的章节。在机器人领域，我们将开发用于控制机器人的软件。还假设读者对 Visual
    Studio 有一定的了解。有关如何使用 Visual Studio 和 WPF 的详细信息，请参阅以下链接：
- en: '[https://msdn.microsoft.com/en-us/library/aa970268(v%3Dvs.110).aspx](https://msdn.microsoft.com/en-us/library/aa970268(v%3Dvs.110).aspx)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://msdn.microsoft.com/en-us/library/aa970268(v%3Dvs.110).aspx](https://msdn.microsoft.com/en-us/library/aa970268(v%3Dvs.110).aspx)'
- en: '![](img/6639_03_19.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_03_19.jpg)'
- en: Create new project in WPF
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WPF 中创建新项目
- en: Click on New Project, then under the Visual C# section, click on WPF Application.
    Enter a name such as `Mqtt Controller` in the field of Name and click on OK.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 点击新建项目，然后在 Visual C# 部分，点击 WPF 应用程序。在名称字段中输入例如 `Mqtt Controller` 的名称，然后点击确定。
- en: 'Once you click OK, the project will be created:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您点击确定，项目将被创建：
- en: '![](img/6639_03_20.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6639_03_20.jpg)'
- en: WPF project created
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: WPF 项目已创建
- en: Once the project is created, you should get a display similar to this. If some
    display components are missing from your window, then go to View and select those.
    Now have a close look on the Solution Explorer, which is visible on the right-hand
    side of the image.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，您应该得到一个类似于下面的显示。如果窗口中缺少某些显示组件，请转到视图并选择它们。现在仔细查看解决方案浏览器，它在图像的右侧可见。
- en: 'There, have a look at the project structure:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，查看项目结构：
- en: '![](img/6639_03_21.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/6639_03_21.png)'
- en: Solution Explorer
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案浏览器
- en: An application has two main components. The first is the UI, which will be designed
    in `MainWindow.xaml`, and the second is the logic, which will be implemented in
    `MainWindow.xaml.cs`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有两个主要组件。第一个是UI，它将在`MainWindow.xaml`中设计，第二个是逻辑，它将在`MainWindow.xaml.cs`中实现。
- en: The UI is designed using XAML, while the logic is implemented in C#.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: UI使用XAML设计，而逻辑用C#实现。
- en: 'To start with, we''ll just have one button control: a field where the user
    will enter some text and an area where the entered text will be displayed. After
    we have a fair idea about handling events, we can move forward to the implementation
    of MQTT.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只有一个按钮控件：一个用户将输入文本的字段和一个显示输入文本的区域。在我们对事件处理有了足够的了解之后，我们可以继续实现MQTT。
- en: 'Initially, we''ll design the UI for the double click on `MainPage.xaml.cs`.
    It''s in this file that we''ll add the UI''s XAML components. The code is written
    in XAML and much of the work can be accomplished by the use of drag and drop feature.
    From the toolbox situated on the right-hand side of the application, look up the
    following items:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们将为`MainPage.xaml.cs`中的双击设计UI。这个文件是我们添加UI的XAML组件的地方。代码是用XAML编写的，大部分工作可以通过拖放功能完成。从应用右侧的工具箱中查找以下项：
- en: '`Button`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button`'
- en: '`TextBlock`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextBlock`'
- en: '`TextBox`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextBox`'
- en: There are two ways of adding the components. The first is to manually add the
    code in the XAML view of the page, while the second is to drag and drop from the
    components' toolbox. A few things to note are as follows.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 添加组件有两种方式。第一种是手动在页面的XAML视图中添加代码，第二种是从组件工具箱中拖放。以下是一些需要注意的事项。
- en: The Designer window can be edited according to your wishes. A quick workaround
    for this is to select the component you want to edit, which can be done in the
    Properties window.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 设计师窗口可以根据您的意愿进行编辑。一个快速的解决方案是选择您想要编辑的组件，这可以在属性窗口中完成。
- en: 'Properties can also be edited using XAML:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 属性也可以使用XAML进行编辑：
- en: '![](img/6639_03_22.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/6639_03_22.jpg)'
- en: Visual Studio layout
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio布局
- en: In the preceding screenshot, we've changed the background color and added the
    components. Note the properties window where the background color is highlighted.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们已更改了背景颜色并添加了组件。注意属性窗口中突出显示的背景颜色。
- en: 'The `TextBox` is the area where the user will enter the text and the `TextBlock`
    is the area where it will be displayed. Once you have the components placed on
    the design view and have edited their properties, mainly the names of the components,
    we''ll add the event handlers. For a shortcut of the design shown in the preceding
    screenshot, write the following XAML code within the `grid` tag:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextBox`是用户输入文本的区域，而`TextBlock`是显示文本的区域。一旦您在设计视图中放置了组件并编辑了它们的属性，主要是组件的名称，我们将添加事件处理器。为了快速实现前面截图中的设计，请在`grid`标签内编写以下XAML代码：'
- en: '[PRE26]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now in the Designer window, double click on the button to create an event handler
    for a click event. The events that are available can be viewed in the Properties
    window, as shown in the following screenshot:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在设计师窗口中，双击按钮以创建一个用于点击事件的处理器。可用的事件可以在属性窗口中查看，如下面的截图所示：
- en: '![](img/6639_03_23.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/6639_03_23.png)'
- en: Event properties of button
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的事件属性
- en: Once you have double clicked, you will automatically be redirected to `MainWindow.xaml.cs`
    along with a method self-generated for the event.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 双击后，您将自动重定向到`MainWindow.xaml.cs`，同时还有一个为该事件自动生成的函数。
- en: 'You will get a method something similar to the following code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到一个类似于以下代码的方法：
- en: '[PRE27]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we are going to implement the logic. Initially, we will read the data
    as written in the `TextBox`. If it''s empty, we''ll display a message saying that
    it cannot be empty. Then, we''ll just pass the message to the `TextBlock`. The
    following code does the same thing:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将实现逻辑。最初，我们将读取`TextBox`中写入的数据。如果它是空的，我们将显示一条消息，说明它不能为空。然后，我们将只将消息传递给`TextBlock`。以下代码执行相同的功能：
- en: '[PRE28]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code initially reads the data and then checks if it''s null or
    empty and then outputs the data into the `TextBlock`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码最初读取数据，然后检查它是否为null或空，然后将数据输出到`TextBlock`：
- en: '![](img/6639_03_24.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_24.jpg)'
- en: Application run—1
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行—1
- en: 'Press *F5* to run your application and then the preceding screens should appear.
    Next, delete the text in the TextBox and click on the Click me button:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 按*F5*运行您的应用程序，然后前面的屏幕应该出现。接下来，删除文本框中的文本，然后点击“点击我”按钮：
- en: '![](img/6639_03_25.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_25.png)'
- en: Empty text
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 空文本
- en: 'Now, enter any text in the TextBox and press the Click me button. Your entered
    text should be displayed following in the TextBlock:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在文本框中输入任何文本，然后点击“点击我”按钮。您输入的文本应该随后在文本块中显示：
- en: '![](img/6639_03_26.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_26.png)'
- en: WPF HelloWorld
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: WPF HelloWorld
- en: Now that we know how to make a simple WPF application, we are going to edit
    the application itself to implement the MQTT protocol. To implement the MQTT protocol,
    we have to use a library, which will be added using the nugget package manager.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何创建一个简单的WPF应用程序，我们将编辑应用程序本身以实现MQTT协议。要实现MQTT协议，我们必须使用一个库，该库将通过NuGet包管理器添加。
- en: 'Now browse to References and click on Manage Nugget Packages and add the `M2Mqtt`
    external library:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，浏览到“引用”并点击“管理NuGet包”，然后添加`M2Mqtt`外部库：
- en: '![](img/6639_03_27.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_27.jpg)'
- en: NuGet package manager
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: NuGet包管理器
- en: 'Once we have the packages, we can use them in our project. For this project,
    we''ll be using the following UI components in `MainWindow.xaml`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了包，我们就可以在项目中使用它们。对于这个项目，我们将在`MainWindow.xaml`中使用以下UI组件：
- en: A TextBox for entering the channel ID
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于输入频道ID的文本框
- en: A TextBlock to display the latest control command
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于显示最新控制命令的文本块
- en: A button to set the status as on
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于设置状态为开启的按钮
- en: A button to set the status as off
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个设置状态为关闭的按钮
- en: A button to Connect
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于连接的按钮
- en: 'Feel free to design the UI on your own:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 随意设计UI：
- en: '![](img/6639_03_28.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_28.jpg)'
- en: UI for controller application
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 控制应用程序的UI
- en: 'In the preceding screenshot, you will see that the design is updated and a
    button has also been added. The code for the preceding design is pasted as follows.
    The TextBox is the area where we''ll enter the channel ID, and then we will use
    the buttons to turn an LED on and off, and the Connect button to connect to the
    service. Now, as done previously, we will create event handlers for click events
    for the two buttons mentioned previously. To add click events, simply double click
    on each button:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，您将看到设计已更新，并且还添加了一个按钮。以下是将前面设计代码粘贴的代码。文本框是我们将输入频道ID的区域，然后我们将使用按钮来打开和关闭LED，以及使用连接按钮连接到服务。现在，像之前做的那样，我们将为前面提到的两个按钮创建点击事件的处理器。要添加点击事件，只需在每个按钮上双击即可：
- en: '[PRE29]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding code is mentioned in the grid tag.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在网格标签中提到。
- en: Now, once you have the design, move on to `MainWindow.xaml.cs` and write the
    main code. You will notice that a constructor and two event handler methods already
    exist.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一旦有了设计，就转到`MainWindow.xaml.cs`并编写主要代码。您会注意到已经存在一个构造函数和两个事件处理器方法。
- en: 'Add the following namespace to use the library using:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下命名空间以使用库：
- en: '[PRE30]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now create an instance of the `MqttClient` class and declare a global string
    variable:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建`MqttClient`类的实例并声明一个全局字符串变量：
- en: '[PRE31]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, in the event handler for the Connect button, connect it to the broker
    using the channel ID.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在连接按钮的事件处理器中，使用频道ID将其连接到代理。
- en: 'The entire code for the Connect button''s event handler is mentioned as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 连接按钮的事件处理器代码如下所示：
- en: '[PRE32]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding snippet, we read the data from the `textbox` that contains
    the channel ID. If it's null, we ask the user to enter it again. Then, finally,
    we connect it to the channel ID. Note that it is inside the `try catch` block.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们从包含频道ID的`textbox`中读取数据。如果它是null，我们会要求用户再次输入。然后，最后，我们将它连接到频道ID。请注意，它位于`try
    catch`块内。
- en: There are two more event handlers. We need to publish some value to the channel
    they are connected to.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另外两个事件处理器。我们需要向它们连接的频道发布一些值。
- en: 'In the `on` button''s event handler, insert the following code:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在“开启”按钮的事件处理器中，插入以下代码：
- en: '[PRE33]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As seen in the preceding code, the parameter for the `Publish` method is the
    topic, which is the `channelID` and a `byte[] array` which contains the message.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码所示，`Publish`方法的参数是主题，即`channelID`和一个包含消息的`byte[]`数组。
- en: 'Similarly, for the `off` method, we have:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于`off`方法，我们有：
- en: '[PRE34]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'That''s it. That''s the entire code for your MQTT controller for home automation.
    The entire code is pasted as follows for your reference:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了。这是您家庭自动化 MQTT 控制器的全部代码。以下代码已粘贴供您参考：
- en: '[PRE35]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Press the *F5* or the Start button to execute this code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *F5* 或启动按钮来执行此代码：
- en: '![](img/6639_03_29.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_29.jpg)'
- en: Application running
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序正在运行
- en: 'Next, in the TextBox, enter the `channelID`. Here, we''ll be entering it as
    `avirup/control` and then we will press the Connect button:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在文本框中输入 `channelID`。在这里，我们将输入 `avirup/control`，然后我们将按下连接按钮：
- en: '![](img/6639_03_30.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_30.jpg)'
- en: Application running—2
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序正在运行—2
- en: 'Now open your PuTTY console and log in to Intel Edison. Verify that the device
    is connected to the Internet using the `ifconfig` command. Next, just run the
    Node.js script. Next, press the `ON` button:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开您的 PuTTY 控制台并登录到英特尔爱迪生。使用 `ifconfig` 命令验证设备是否已连接到互联网。接下来，只需运行 Node.js 脚本。接下来，按下“开启”按钮：
- en: '![](img/6639_03_31.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_31.jpg)'
- en: MQTT controlled by WPF application
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 由 WPF 应用程序控制的 MQTT
- en: 'Similarly, on pressing the `OFF` button, you will see a screen similar to the
    following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，按下“关闭”按钮时，您将看到以下类似的屏幕：
- en: '![](img/6639_03_32.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6639_03_32.jpg)'
- en: MQTT controlled by WPF
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 由 WPF 控制的 MQTT
- en: 'Keep pressing `ON` and `OFF` and you will see the effect on Intel Edison. Now
    that we remember that we have connected the relay and the electric bulb, the effect
    should be visible by now. If the main switch of the AC power supply is turned
    off, then you won''t see the bulb getting turned on, but you will hear a `tick`
    sound. That suggest that the relay is now in the `ON` position. The image of the
    hardware setup is shown as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 持续按下“开启”和“关闭”，您将在英特尔爱迪生上看到效果。现在，我们记得我们已经连接了继电器和电灯泡，现在应该可以看到效果。如果将交流电源的主开关关闭，那么您将看不到灯泡被打开，但您会听到“滴答”声。这表明继电器现在处于“开启”位置。硬件设置的图片如下所示：
- en: '![](img/image039.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image039.jpg)'
- en: Hardware setup for home automation
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 家庭自动化的硬件设置
- en: Thus, you have a home automation setup ready and you can control it by the PC
    application or the Android application.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您已经准备好家庭自动化设置，您可以通过 PC 应用程序或 Android 应用程序来控制它。
- en: If you are in office network, then sometimes port `1883` is blocked. In those
    cases, it is recommended to use your own personal network.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在办公室网络中，那么有时端口 `1883` 可能被阻止。在这种情况下，建议使用您自己的个人网络。
- en: Open-ended task for the reader
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读者开放性任务
- en: Now, you may have got a brief idea about how things must work in home automation.
    We have covered multiple areas in this niche. The task that is left for the reader
    is not only to integrate a single control command, but multiple control commands.
    This will allow you to control multiple devices. Add more functionality in the
    Android and the WPF application and go with more string control commands. Connect
    more relay units to the device for interfacing.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能已经对家庭自动化中事物的工作方式有了大致的了解。我们在这一领域涵盖了多个方面。留给读者的任务不仅是集成单个控制命令，而是多个控制命令。这将使您能够控制多个设备。在
    Android 和 WPF 应用程序中添加更多功能，并使用更多的字符串控制命令。将更多继电器单元连接到设备进行接口。
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've learned about the idea of home automation in its crude
    form. We also learned about how we can control an electrical load using relays.
    Not only that, but also we learned how to develop a WPF application and implement
    the MQTT protocol. On the device end, we used a Node.js code to connect our device
    to the Internet and subscribe to certain channels using the broker and ultimately
    receive signals to control itself. In the Android side of the system, we have
    used an already available MyMqtt application and used it to both to get and publish
    data. However, we also covered the development of the Android application in detail
    and showcased the use of it in implementing the MQTT protocol to control devices.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了家庭自动化的基本概念。我们还学习了如何使用继电器控制电气负载。不仅如此，我们还学习了如何开发 WPF 应用程序并实现 MQTT 协议。在设备端，我们使用了
    Node.js 代码将我们的设备连接到互联网，并通过代理订阅某些频道，最终接收信号来自动控制。在系统的 Android 端，我们使用了现成的 MyMqtt
    应用程序，并使用它来获取和发布数据。然而，我们也详细介绍了 Android 应用程序的开发，并展示了如何使用它来实现 MQTT 协议来控制设备。
- en: In [Chapter 4](3fa86b30-3d51-4628-a827-db7b3e31f3e7.xhtml), *Intel Edison and
    Security System*, we are going to learn how to deal with image processing and
    speech processing applications using Intel Edison. [Chapter 4](3fa86b30-3d51-4628-a827-db7b3e31f3e7.xhtml),
    *Intel Edison and Security System*, will mainly deal with Python and the usage
    of some open source libraries.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](3fa86b30-3d51-4628-a827-db7b3e31f3e7.xhtml)，*英特尔爱迪生与安全系统*，我们将学习如何使用英特尔爱迪生处理图像处理和语音处理应用。[第4章](3fa86b30-3d51-4628-a827-db7b3e31f3e7.xhtml)，*英特尔爱迪生与安全系统*，将主要涉及Python编程以及一些开源库的使用。
