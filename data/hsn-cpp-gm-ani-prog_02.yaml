- en: '*Chapter 2*: Implementing Vectors'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：实现向量'
- en: In this chapter, you will learn the basics of vector math. Much of what you
    will code throughout the rest of this book relies on having a strong understanding
    of vectors. Vectors will be used to represent displacement and direction.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习向量数学的基础知识。本书的其余部分大部分编码都依赖于对向量有很好的理解。向量将用于表示位移和方向。
- en: By the end of this chapter, you will have implemented a robust vector library
    and will be able to perform a variety of vector operations, including component-wise
    and non-component-wise operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将实现一个强大的向量库，并能够执行各种向量操作，包括分量和非分量操作。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing vectors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入向量
- en: Creating a vector
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个向量
- en: Understanding component-wise operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解分量操作
- en: Understanding non-component-wise operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解非分量操作
- en: Interpolating vectors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值向量
- en: Comparing vectors
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较向量
- en: Exploring more vectors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索更多向量
- en: 'Important information:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息：
- en: In this chapter, you will learn how to implement vectors in an intuitive, visual
    way that relies on code more than math formulas. If you are interested in math
    formulas or want some interactive examples to try out, go to [https://gabormakesgames.com/vectors.html](https://gabormakesgames.com/vectors.html).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何以直观、可视的方式实现向量，这依赖于代码而不是数学公式。如果您对数学公式感兴趣，或者想尝试一些交互式示例，请访问[https://gabormakesgames.com/vectors.html](https://gabormakesgames.com/vectors.html)。
- en: Introducing vectors
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入向量
- en: What is a vector? A vector is an n-tuple of numbers. It represents a displacement
    measured as a magnitude and a direction. Each element of a vector is usually expressed
    as a subscript, such as *(V*0*, V*1*, V*2*, … V*N*)*. In the context of games,
    vectors usually have two, three, or four components.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是向量？向量是一个n元组的数字。它表示作为大小和方向测量的位移。向量的每个元素通常表示为下标，例如*(V*0*，V*1*，V*2*，… V*N*)*。在游戏的背景下，向量通常有两个、三个或四个分量。
- en: 'For example, a three-dimensional vector measures displacement on three unique
    axes: *x*, *y*, and *z*. Elements of vectors are often subscripted with the axis
    they represent, rather than an index. *(V*X*, V*Y*, V*Z*)* and *(V*0*, V*1*, V*2*)*
    are used interchangeably.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，三维向量测量三个独特轴上的位移：*x*、*y*和*z*。向量的元素通常用表示它们代表的轴的下标，而不是索引。*(V*X*，V*Y*，V*Z*)*和*(V*0*，V*1*，V*2*)*可以互换使用。
- en: When visualizing vectors, they are often drawn as arrows. The position of the
    base of an arrow does not matter because vectors measure displacement, not a position.
    The end of the arrow follows the displacement of the arrow on each axis.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在可视化向量时，它们通常被绘制为箭头。箭头的基部位置并不重要，因为向量测量的是位移，而不是位置。箭头的末端遵循每个轴上的位移。
- en: 'For example, all of the arrows in the following figure represent the same vector:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下图中的所有箭头代表相同的向量：
- en: '![Figure 2.1: Vector (2, 5) drawn in multiple locations'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1：在多个位置绘制的向量(2, 5)'
- en: '](img/Figure_2.1_B16191.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.1_B16191.jpg)'
- en: 'Figure 2.1: Vector (2, 5) drawn in multiple locations'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：在多个位置绘制的向量(2, 5)
- en: Each arrow has the same length and points in the same direction, regardless
    of where it is positioned. In the next section, you will start to implement the
    vector structure that will be used throughout the rest of this book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个箭头的长度相同，指向相同的方向，无论它们的位置如何。在下一节中，您将开始实现将在本书的其余部分中使用的向量结构。
- en: Creating a vector
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个向量
- en: Vectors will be implemented as structures, not classes. The vector struct will
    contain an anonymous union that allows the vector's components to be accessed
    as an array or as individual elements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 向量将被实现为结构，而不是类。向量结构将包含一个匿名联合，允许以数组或单独元素的形式访问向量的分量。
- en: 'To declare the `vec3` structure and the function headers, create a new file,
    `vec3.h`. Declare the new `vec3` structure in this file. The `vec3` struct needs
    three constructors—a default constructor, one that takes each component as an
    element, and one that takes a pointer to a float array:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明`vec3`结构和函数头，请创建一个新文件`vec3.h`。在此文件中声明新的`vec3`结构。`vec3`结构需要三个构造函数——一个默认构造函数，一个以每个分量作为元素的构造函数，以及一个以浮点数组指针作为参数的构造函数：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The anonymous union in the `vec3` struct allows data to be accessed using `.x`,
    `.y`, and `.z` notation, or as a contiguous array using `.v`. Before moving on
    to implementing functions that work on the `vec3` struct, you need to consider
    comparing floating point numbers and whether or not to use an epsilon value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec3`结构中的匿名联合允许使用`.x`、`.y`和`.z`表示法访问数据，或者使用`.v`表示法作为连续数组访问。在继续实现在`vec3`结构上工作的函数之前，您需要考虑比较浮点数以及是否使用epsilon值。'
- en: Epsilon
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Epsilon
- en: 'Comparing floating point numbers is difficult. Instead of comparing two floating
    point numbers directly, you need to compare them using an epsilon. An epsilon
    is an arbitrarily small positive number that is the minimum difference two numbers
    need to have to be considered different numbers. Declare an epsilon constant in
    `vec3.h`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 比较浮点数是困难的。您需要使用一个epsilon来比较两个浮点数，而不是直接比较它们。epsilon是一个任意小的正数，是两个数字需要具有的最小差异，才能被视为不同的数字。在`vec3.h`中声明一个epsilon常量：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Important note:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: You can learn more about floating point comparison at [https://bitbashing.io/comparing-floats.html](https://bitbashing.io/comparing-floats.html)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://bitbashing.io/comparing-floats.html](https://bitbashing.io/comparing-floats.html)了解更多关于浮点数比较的信息
- en: With the `vec3` structure created and the `vec3` epsilon defined, you are ready
    to start implementing some common vector operations. In the next section, you're
    going to start by learning and implementing several component-wise operations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建`vec3`结构和定义`vec3` epsilon，您已经准备好开始实现一些常见的向量操作。在下一节中，您将开始学习和实现几种分量操作。
- en: Understanding component-wise operations
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解分量操作
- en: 'Several vector operations are just component-wise operations. A component-wise
    operation is one that you perform on each component of a vector or on like components
    of two vectors. Like components are components that have the same subscript. The
    component-wise operations that you will implement are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 几个向量操作只是分量操作。分量操作是指对向量的每个分量或两个向量的相似分量进行的操作。相似的分量是具有相同下标的分量。您将要实现的分量操作如下：
- en: Vector addition
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量相加
- en: Vector subtraction
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量减法
- en: Vector scaling
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量缩放
- en: Multiplying vectors
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量相乘
- en: Dot product
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点积
- en: Let's look at each of these in more detail.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些。
- en: Vector addition
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量相加
- en: Adding two vectors together yields a third vector, which has the combined displacement
    of both input vectors. Vector addition is a component-wise operation; to perform
    it, you need to add like components.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个向量相加会产生一个第三个向量，它具有两个输入向量的合并位移。向量相加是一种分量操作；要执行它，您需要添加相似的分量。
- en: 'To visualize the addition of two vectors, draw the base of the second vector
    at the tip of the first vector. Next, draw an arrow from the base of the first
    vector to the tip of the second vector. This arrow represents the vector that
    is the result of the addition:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要可视化两个向量的相加，将第二个向量的基部放在第一个向量的尖端。接下来，从第一个向量的基部到第二个向量的尖端画一个箭头。这个箭头代表了相加的结果向量：
- en: '![](img/Figure_2.2_B16191.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_2.2_B16191.jpg)'
- en: 'Figure 2.2: Vector addition'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：向量相加
- en: 'To implement vector addition in code, add like components of the input vectors.
    Create a new file, `vec3.cpp`. This is where you will define functions related
    to the `vec3` struct. Don''t forget to include `vec3.h`. Overload the `+ operator`
    to perform vector addition. Don''t forget to add the function signature to `vec3.h`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中实现向量相加，添加输入向量的相似分量。创建一个新文件`vec3.cpp`。这是您将定义与`vec3`结构相关的函数的地方。不要忘记包含`vec3.h`。重载`+运算符`以执行向量相加。不要忘记将函数签名添加到`vec3.h`中：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When thinking about vector addition, remember that a vector represents a displacement.
    When adding two vectors, the result is the combined displacement of both input
    vectors.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑向量相加时，请记住向量表示位移。当添加两个向量时，结果是两个输入向量的合并位移。
- en: Vector subtraction
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量减法
- en: As with adding vectors, subtracting vectors is also a component-wise operation.
    You can think of subtracting vectors as adding the negative of the second vector
    to the first vector. When visualized as an arrow, subtraction points from the
    tip of the second vector to the tip of the first one.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与添加向量一样，减去向量也是一种分量操作。您可以将减去向量视为将第二个向量的负值添加到第一个向量。当可视化为箭头时，减法指向从第二个向量的尖端到第一个向量的尖端。
- en: 'To visually subtract vectors, place both vectors so they share the same origin.
    Draw a vector from the tip of the second arrow to the tip of the first one. The
    resulting arrow is the subtraction result vector:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了直观地减去向量，将两个向量放置在同一个起点。从第二个箭头的尖端到第一个箭头的尖端画一个向量。得到的箭头就是减法结果向量：
- en: '![Figure 2.3: Vector subtraction'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3：向量减法'
- en: '](img/Figure_2.3_B16191.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.3_B16191.jpg)'
- en: 'Figure 2.3: Vector subtraction'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：向量减法
- en: 'To implement vector subtraction, subtract like components. Implement the subtraction
    function by overloading the `-` operator in `vec3.cpp`. Don''t forget to add the
    function declaration to `vec3.h`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现向量减法，减去相似的分量。通过在`vec3.cpp`中重载`-`运算符来实现减法函数。不要忘记将函数声明添加到`vec3.h`中：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The steps and logic are very similar to vector addition. It might help to think
    of vector subtraction as adding a negative vector.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤和逻辑与向量相加非常相似。将向量减法视为添加一个负向量可能会有所帮助。
- en: Scaling vectors
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩放向量
- en: When a vector is scaled, it only changes in magnitude, not direction. As with
    addition and subtraction, scaling is a component-wise operation. Unlike addition
    and subtraction, a vector is scaled by a scalar, not another vector.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当向量被缩放时，它只在大小上改变，而不改变方向。与加法和减法一样，缩放是一种分量操作。与加法和减法不同，向量是由标量而不是另一个向量进行缩放的。
- en: 'Visually, a scaled vector points in the same direction as the original vector,
    but it has a different length. The following figure shows two vectors: *(2, 1)*
    and *(2, 4)*. Both vectors share the same direction, but the magnitude of the
    second vector is longer:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在视觉上，一个缩放的向量指向与原始向量相同的方向，但长度不同。下图显示了两个向量：*(2, 1)*和*(2, 4)*。两个向量具有相同的方向，但第二个向量的大小更长：
- en: '![Figure 2.4: Vector scaling'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4：向量缩放'
- en: '](img/Figure_2.4_B16191.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.4_B16191.jpg)'
- en: 'Figure 2.4: Vector scaling'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：向量缩放
- en: To implement vector scaling, multiply every component of the vector by the given
    scalar value.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现向量缩放，将向量的每个分量乘以给定的标量值。
- en: 'Implement the scale function by overloading the `*` operator in `vec3.cpp`.
    Don''t forget to add the function declaration to `vec3.h`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`vec3.cpp`中重载`*`运算符来实现缩放函数。不要忘记将函数声明添加到`vec3.h`中：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Negating a vector can be done by scaling the vector by *-1*. When negating a
    vector, the vector maintains its magnitude but changes its direction.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将向量缩放*-1*来对向量取反。当对向量取反时，向量保持其大小，但改变其方向。
- en: Multiplying vectors
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量相乘
- en: Vector multiplication can be considered a non-uniform scale. Instead of scaling
    every component of a vector by a scalar, to multiply two vectors, you scale every
    component of a vector by the like component of another vector.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 向量乘法可以被认为是一种非均匀缩放。与将向量的每个分量乘以标量不同，要将两个向量相乘，需要将向量的每个分量乘以另一个向量的相似分量。
- en: 'You can implement vector multiplication by overloading the `*` operator in
    `vec3.cpp`. Don''t forget to add the function declaration to `vec3.h`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`vec3.cpp`中重载`*`运算符来实现向量乘法。不要忘记将函数声明添加到`vec3.h`中：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The result generated by multiplying two vectors will have a different direction
    and magnitude.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将两个向量相乘生成的结果将具有不同的方向和大小。
- en: Dot product
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点积
- en: 'The dot product is used to measure how similar two vectors are. Given two vectors,
    the dot product returns a scalar value. The result of the dot product has the
    following properties:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 点积用于衡量两个向量的相似程度。给定两个向量，点积返回一个标量值。点积的结果具有以下属性：
- en: It is positive if the vectors point in the same direction.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果向量指向相同的方向，则为正。
- en: It is negative if the vectors point in opposite directions.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果向量指向相反的方向，则为负。
- en: It is *0* if the vectors are perpendicular.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果向量垂直，则为*0*。
- en: If both input vectors have a unit length (you will learn about unit length vectors
    in the *Normal vectors* section of this chapter), the dot product will have a
    range of *-1* to *1*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个输入向量都具有单位长度（您将在本章的*法向量*部分了解单位长度向量），点积将具有*-1*到*1*的范围。
- en: 'The dot product between two vectors, *A* and *B*, is equal to the length of
    *A* multiplied by the length of *B* multiplied by the cosine of the angle between
    the two vectors:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量*A*和*B*之间的点积等于*A*的长度乘以*B*的长度乘以两个向量之间的角的余弦：
- en: '![](img/Formula_02_001.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_02_001.jpg)'
- en: 'The easiest way to calculate the dot product is to sum the products of like
    components in the input vectors:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 计算点积的最简单方法是对输入向量中相似的分量进行求和：
- en: '*![](img/Formula_02_002.png)*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](img/Formula_02_002.png)*'
- en: 'Implement the `dot` function in `vec3.cpp`. Don''t forget to add the function
    definition to `vec3.h`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vec3.cpp`中实现`dot`函数。不要忘记将函数定义添加到`vec3.h`中：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The dot product is one of the most used operations for video games. It's often
    used to check angles and in lighting calculations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 点积是视频游戏中最常用的操作之一。它经常用于检查角度和光照计算。
- en: With the dot product, you have implemented the common component-wise operations
    of vectors. Next, you will learn about some of the non-component-wise operations
    that can be performed on vectors.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点积，您已经实现了向量的常见分量操作。接下来，您将了解一些可以在向量上执行的非分量操作。
- en: Understanding non-component-wise operations
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解非分量操作
- en: 'Not all vector operations are component-wise; some operations require more
    math. In this section, you are going to learn how to implement common vector operations
    that are not component-based. These operations are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有向量操作都是分量式的；一些操作需要更多的数学。在本节中，您将学习如何实现不基于分量的常见向量操作。这些操作如下：
- en: How to find the length of a vector
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何找到向量的长度
- en: What a normal vector is
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 法向量是什么
- en: How to normalize a vector
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何对向量进行归一化
- en: How to find the angle between two vectors
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何找到两个向量之间的角度
- en: How to project vectors and what rejection is
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何投影向量以及拒绝是什么
- en: How to reflect vectors
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何反射向量
- en: What the cross product is and how to implement it
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 叉积是什么以及如何实现它
- en: Let's take a look at each one in more detail.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看每一个。
- en: Vector length
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量长度
- en: 'Vectors represent a direction and a magnitude; the magnitude of a vector is
    its length. The formula for finding the length of a vector comes from trigonometry.
    In the following figure, a two-dimensional vector is broken down into parallel
    and perpendicular components. Notice how this forms a right triangle, with the
    vector being the hypotenuse:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 向量表示方向和大小；向量的大小是它的长度。找到向量长度的公式来自三角学。在下图中，一个二维向量被分解为平行和垂直分量。注意这如何形成一个直角三角形，向量是斜边：
- en: '![Figure 2.5: A vector broken down into parallel and perpendicular components'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5：一个向量分解为平行和垂直分量'
- en: '](img/Figure_2.5_B16191.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.5_B16191.jpg)'
- en: 'Figure 2.5: A vector broken down into parallel and perpendicular components'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：一个向量分解为平行和垂直分量
- en: The length of the hypotenuse of a right triangle can be found with the Pythagorean
    theorem, *A*2 *+ B*2 *= C*2\. This function extends to three dimensions by simply
    adding a *Z* component—*X*2 *+ Y*2 *+ Z*2 *= length*2\.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 直角三角形的斜边长度可以用毕达哥拉斯定理找到，*A*2 *+ B*2 *= C*2。通过简单地添加一个*Z*分量，这个函数可以扩展到三维—*X*2 *+
    Y*2 *+ Z*2 *= length*2\。
- en: 'You may have noticed a pattern here; the squared length of a vector equals
    the sum of its components. This could be expressed as a dot product—*Length*2*(A)
    = dot(A, A)*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了一个模式；一个向量的平方长度等于其分量的和。这可以表示为一个点积—*Length*2*(A) = dot(A, A)*：
- en: 'Important note:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明：
- en: Finding the length of a vector involves a square root operation, which should
    be avoided when possible. When checking the length of a vector, the check can
    be done in squared space to avoid the square root. For example, if you wanted
    to check if the length of vector *A* is less than *5*, that could be expressed
    as *(dot(A, A) < 5 * 5)*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 找到向量的长度涉及平方根运算，应尽量避免。在检查向量的长度时，可以在平方空间中进行检查以避免平方根。例如，如果您想要检查向量*A*的长度是否小于*5*，可以表示为*(dot(A,
    A) < 5 * 5)*。
- en: 'To implement the square length function, sum the result of squaring each component
    of the vector. Implement the `lenSq` function in `vec3.cpp`. Don''t forget to
    add the function declaration to `vec3.h`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现平方长度函数，求出向量的每个分量的平方的和。在`vec3.cpp`中实现`lenSq`函数。不要忘记将函数声明添加到`vec3.h`中：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To implement the length function, take the square root of the result of the
    square length function. Take care not to call `sqrtf` with `0`. Implement the
    `lenSq` function in `vec3.cpp`. Don''t forget to add the function declaration
    to `vec3.h`:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现长度函数，取平方长度函数的结果的平方根。注意不要用`sqrtf`调用`0`。在`vec3.cpp`中实现`lenSq`函数。不要忘记将函数声明添加到`vec3.h`中：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Important note:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明：
- en: You can find the distance between two vectors by taking the length of the difference
    between them. For example, *float distance = len(vec1 - vec2)*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过取它们之间的差的长度来找到两个向量之间的距离。例如，*float distance = len(vec1 - vec2)*。
- en: Normalizing vectors
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归一化向量
- en: A vector with a length of *1* is called a normal vector (or unit vector). Generally,
    unit vectors are used to represent a direction without a magnitude. The dot product
    of two unit vectors will always fall in the *-1* to *1* range.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 长度为*1*的向量称为法向量（或单位向量）。通常，单位向量用于表示没有大小的方向。两个单位向量的点积总是在*-1*到*1*的范围内。
- en: 'Aside from the *0* vector, any vector can be normalized by scaling the vector
    by the inverse of its length:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*0*向量外，任何向量都可以通过将向量按其长度的倒数进行缩放来归一化：
- en: 'Implement the `normalize` function in `vec3.cpp`. Don''t forget to add the
    function declaration to `vec3.h`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`vec3.cpp`中实现`normalize`函数。不要忘记将函数声明添加到`vec3.h`中：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement the `normalized` function in `vec3.cpp`. Don''t forget to add the
    function declaration to `vec3.h`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`vec3.cpp`中实现`normalized`函数。不要忘记将函数声明添加到`vec3.h`中：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `normalize` function takes a reference to a vector and normalizes it in
    place. The `normalized` function, on the other hand, takes a constant reference
    and does not modify the input vector. Instead, it returns a new vector.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`normalize`函数接受一个向量的引用并就地对其进行归一化。另一方面，`normalized`函数接受一个常量引用并不修改输入向量。相反，它返回一个新的向量。'
- en: The angle between vectors
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量之间的角度
- en: 'If two vectors are of unit length, the angle between them is the cosine of
    their dot product:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个向量是单位长度，它们之间的角度是它们的点积的余弦：
- en: '![](img/Formula_02_003.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_02_003.jpg)'
- en: 'If the two vectors are not normalized, the dot product needs to be divided
    by the product of the length of both vectors:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个向量未被归一化，则点积需要除以两个向量长度的乘积：
- en: '![](img/Formula_02_004.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_02_004.jpg)'
- en: 'To find the actual angle, not just the cosine of it, we need to take the inverse
    of the cosine on both sides, which is the arccosine function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到实际角度，而不仅仅是其余弦，我们需要在两侧取余弦的反函数，即反余弦函数：
- en: '![](img/Formula_02_005.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_02_005.jpg)'
- en: 'Implement the `angle` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vec3.cpp`中实现`angle`函数。不要忘记将函数声明添加到`vec3.h`中：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Important note:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明：
- en: The `acosf` function returns angles in radians. To convert radians to degrees,
    multiply by `57.2958f`. To convert degrees to radians, multiply by `0.0174533f`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`acosf`函数以弧度返回角度。要将弧度转换为度数，乘以`57.2958f`。要将度数转换为弧度，乘以`0.0174533f`。'
- en: Vector projection and rejection
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量投影和拒绝
- en: 'Projecting vector *A* onto vector *B* yields a new vector that has the length
    of *A* in the direction of *B*. A good way to visualize vector projection is to
    imagine that vector *A* is casting a shadow onto vector *B*, as shown:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将向量*A*投影到向量*B*上会产生一个新的向量，该向量在*B*的方向上具有*A*的长度。直观地理解向量投影的好方法是想象向量*A*投射到向量*B*上的阴影，如图所示：
- en: '![Figure 2.6: Vector A casting a shadow onto vector B'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6：向量A投射到向量B上的阴影'
- en: '](img/Figure_2.6_B16191.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.6_B16191.jpg)'
- en: 'Figure 2.6: Vector A casting a shadow onto vector B'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：向量A投射到向量B上的阴影
- en: 'To calculate the projection of *A* onto *B* (*proj*B *A*), vector *A* must
    be broken down into parallel and perpendicular components with respect to vector
    *B*. The parallel component is the length of *A* in the direction of *B*—this
    is the projection. The perpendicular component is the parallel component subtracted
    from *A*—this is the rejection:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算*A*在*B*上的投影(*proj*B *A*)，必须将向量*A*分解为相对于向量*B*的平行和垂直分量。平行分量是*A*在*B*方向上的长度，这就是投影。垂直分量是从*A*中减去平行分量，这就是拒绝：
- en: '![Figure 2.7: Vector projection and rejection showing parallel and perpendicular
    vectors'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7：向量投影和拒绝显示平行和垂直向量'
- en: '](img/Figure_2.7_B16191.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.7_B16191.jpg)'
- en: 'Figure 2.7: Vector projection and rejection showing parallel and perpendicular
    vectors'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：向量投影和拒绝显示平行和垂直向量
- en: If the vector that is being projected onto (in this example, vector *B*) is
    a normal vector, then finding the length of *A* in the direction of *B* is a simple
    dot product between *A* and *B*. However, if neither input vector is normalized,
    the dot product needs to be divided by the length of vector *B* (the vector being
    projected onto).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果被投影的向量（在这个例子中是向量*B*）是一个法向量，那么在*B*方向上的*A*的长度可以通过*A*和*B*的点积来简单计算。然而，如果两个输入向量都没有被归一化，点积需要除以向量*B*的长度（被投影的向量）。
- en: Now that the parallel component of *A* with respect to *B* is known, vector
    *B* can be scaled by this component. Again, if *B* wasn't of unit length, the
    result will need to be divided by the length of vector *B*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，相对于*B*的平行分量已知，向量*B*可以被这个分量缩放。同样，如果*B*不是单位长度，结果将需要除以向量*B*的长度。
- en: 'Rejection is the opposite of projection. To find the rejection of *A* onto
    *B*, subtract the projection of *A* onto *B* from vector *A*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 拒绝是投影的反面。要找到*A*在*B*上的拒绝，从向量*A*中减去*A*在*B*上的投影：
- en: 'Implement the `project` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`vec3.cpp`中实现`project`函数。不要忘记将函数声明添加到`vec3.h`中：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Implement the `reject` function in `vec3.cpp`. Don''t forget to declare this
    function in `vec3.h`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`vec3.cpp`中实现`reject`函数。不要忘记在`vec3.h`中声明这个函数：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Vector projection and rejection are generally used for gameplay programming.
    It is important that they are implemented in a robust vector library.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 向量投影和拒绝通常用于游戏编程。重要的是它们在一个健壮的向量库中得到实现。
- en: Vector reflection
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向量反射
- en: 'Vector reflection can mean one of two things: a mirror-like reflection or a
    bounce-like reflection. The following figure shows the different types of reflections:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 向量反射可以有两种意思：镜像反射或弹跳反射。以下图显示了不同类型的反射：
- en: '![Figure 2.8: A comparison of the mirror and bounce reflections'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8：镜像和反弹反射的比较'
- en: '](img/Figure_2.8_B16191.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.8_B16191.jpg)'
- en: 'Figure 2.8: A comparison of the mirror and bounce reflections'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：镜像和弹跳反射的比较
- en: 'The bounce reflection is more useful and intuitive than the mirror reflection.
    To make a bounce projection work, project vector *A* onto vector *B*. This will
    yield a vector that points in the opposite direction to the reflection. Negate
    this projection and subtract it twice from vector A. The following figure demonstrates
    this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 反弹反射比镜面反射更有用和直观。要使反弹投影起作用，将向量*A*投影到向量*B*上。这将产生一个指向反射相反方向的向量。对这个投影取反，并从向量A中减去两次。以下图演示了这一点：
- en: '![Figure 2.9: Visualizing a bounce reflection'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9：可视化反弹反射'
- en: '](img/Figure_2.9_B16191.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.9_B16191.jpg)'
- en: 'Figure 2.9: Visualizing a bounce reflection'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：可视化反弹反射
- en: 'Implement the `reflect` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vec3.cpp`中实现`reflect`函数。不要忘记将函数声明添加到`vec3.h`中：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Vector reflection is useful for physics and AI. We won't need to use reflection
    for animation, but it's good to have the function implemented in case it is needed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量反射对物理学和人工智能很有用。我们不需要用反射来进行动画，但是最好实现这个功能以防需要时使用。
- en: Cross product
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 叉积
- en: When given two input vectors, the cross product returns a third vector that
    is perpendicular to both input vectors. The length of the cross product equals
    the area of the parallelogram formed by the two vectors.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个输入向量，叉积返回一个垂直于两个输入向量的第三个向量。叉积的长度等于两个向量形成的平行四边形的面积。
- en: 'The following figure demonstrates what the cross product looks like visually.
    The input vectors don''t have to be 90 degrees apart, but it''s easier to visualize
    them this way:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了叉积在视觉上的样子。输入向量不一定要相隔90度，但以这种方式可更容易地将它们可视化：
- en: '![Figure 2.10: Visualizing the cross product'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.10：可视化叉积'
- en: '](img/Figure_2.10_B16191.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.10_B16191.jpg)'
- en: 'Figure 2.10: Visualizing the cross product'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：可视化叉积
- en: Finding the cross product involves some matrix math, which will be covered in
    more depth in the next chapter. For now, you need to create a 3x3 matrix, with
    the top row being the result vector. The second and third rows should be filled
    in with the input vectors. The value of each component of the result vector is
    the minor of that element in the matrix.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 找到叉积涉及一些矩阵运算，这将在下一章中更深入地介绍。现在，您需要创建一个3x3矩阵，其中顶行是结果向量。第二行和第三行应该填入输入向量。结果向量的每个分量的值是矩阵中该元素的次要。
- en: 'What exactly is the minor of an element in a 3x3 matrix? It''s the determinant
    of a smaller, 2x2 sub-matrix. Assuming you want to find the value of the first
    component, ignore the first row and column, which yields a smaller 2x2 sub-matrix.
    The following figure shows the smaller sub-matrix for each component:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 3x3矩阵中元素的次要是什么？它是较小的2x2子矩阵的行列式。假设你想要找到第一个分量的值，忽略第一行和第一列，得到一个较小的2x2子矩阵。以下图显示了每个分量的较小子矩阵：
- en: '![Figure 2.11: The submatrix for each component'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.11：每个分量的子矩阵'
- en: '](img/Figure_2.11_B16191.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.11_B16191.jpg)'
- en: 'Figure 2.11: The submatrix for each component'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11：每个分量的子矩阵
- en: 'To find the determinant of a 2x2 matrix, you need to cross multiply. Multiply
    the top-left and bottom-right elements, then subtract the product of the top-right
    and bottom-left elements. The following figure shows this for each element of
    the resulting vector:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到2x2矩阵的行列式，需要进行叉乘。将左上角和右下角的元素相乘，然后减去右上角和左下角元素的乘积。以下图显示了结果向量的每个元素的情况：
- en: '![Figure 2.12: The determinant of each component in the result vector'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.12：结果向量中每个分量的行列式'
- en: '](img/Figure_2.12_B16191.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.12_B16191.jpg)'
- en: 'Figure 2.12: The determinant of each component in the result vector'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12：结果向量中每个分量的行列式
- en: 'Implement the `cross` product in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vec3.cpp`中实现`cross`乘积。不要忘记将函数声明添加到`vec3.h`中：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The dot product has a relationship to the cosine of the angle between two vectors
    and the cross product has a relationship to the sine of the angle between the
    two vectors. The length of the cross product between the two vectors is the product
    of both vectors, lengths, scaled by the sine of the angle between them:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 点积与两个向量之间的夹角的余弦有关，而叉积与两个向量之间的正弦有关。两个向量之间的叉积的长度是两个向量的长度乘积，乘以它们之间的正弦值：
- en: '![](img/Formula_02_006.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_02_006.jpg)'
- en: In the next section, you will learn how to interpolate between vectors using
    three different techniques.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何使用三种不同的技术在向量之间进行插值。
- en: Interpolating vectors
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值向量
- en: 'Two vectors can be interpolated linearly by scaling the difference between
    the two vectors and adding the result back to the original vector. This linear
    interpolation is often abbreviated to `lerp`. The amount to `lerp` by is a normalized
    value between *0* and *1*; this normalized value is often represented by the letter
    *t*. The following figure shows `lerp` between two vectors with several values
    for *t*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量可以通过缩放两个向量之间的差异并将结果添加回原始向量来进行线性插值。这种线性插值通常缩写为`lerp`。`lerp`的量是介于*0*和*1*之间的归一化值；这个归一化值通常用字母*t*表示。以下图显示了两个向量之间的`lerp`，以及*
    t *的几个值：
- en: '![Figure 2.13: Linear interpolation'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.13：线性插值'
- en: '](img/Figure_2.13_B16191.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.13_B16191.jpg)'
- en: 'Figure 2.13: Linear interpolation'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13：线性插值
- en: When *t = 0*, the interpolated vector is the same as the starting vector. When
    *t = 1*, the interpolated vector is the same as the end vector.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当*t = 0*时，插值向量与起始向量相同。当*t = 1*时，插值向量与结束向量相同。
- en: 'Implement the `lerp` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vec3.cpp`中实现`lerp`函数。不要忘记将函数声明添加到`vec3.h`中：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Linearly interpolating between two vectors will always take the shortest path
    from one vector to another. Sometimes, the shortest path isn''t the best path;
    you may need to interpolate between two vectors along the shortest arc, instead.
    Interpolating on the shortest arc is called a spherical linear interpolation (`slerp`).
    The following figure shows the difference between the `slerp` and `lerp` processes
    for several values of *t*:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个向量之间进行线性插值将始终采用从一个向量到另一个向量的最短路径。有时，最短路径并不是最佳路径；您可能需要在最短弧线上插值两个向量。在最短弧线上插值被称为球面线性插值（`slerp`）。下图显示了几个*t*值的`slerp`和`lerp`过程之间的差异：
- en: '![Figure 2.14: Comparing slerp and lerp'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.14：比较slerp和lerp'
- en: '](img/Figure_2.14_B16191.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.14_B16191.jpg)'
- en: 'Figure 2.14: Comparing slerp and lerp'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14：比较slerp和lerp
- en: To implement `slerp`, find the angle between the two input vectors. Assuming
    the angle is known, the formula for `slerp` is as follows
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`slerp`，找到两个输入向量之间的角度。假设角度已知，则`slerp`的公式如下
- en: '![](img/Formula_02_007.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Formula_02_007.jpg)'
- en: 'Implement the `slerp` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`. Take care of when the value of *t* is close to *0*, as
    `slerp` will yield unexpected results. When the value of *t* is close to *0*,
    fall back on `lerp` or normalized lerp (`nlerp`) (which will be covered next):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vec3.cpp`中实现`slerp`函数。不要忘记将函数声明添加到`vec3.h`中。要注意当*t*的值接近*0*时，`slerp`会产生意外的结果。当*t*的值接近*0*时，可以退回到`lerp`或归一化的lerp（下一节将介绍）：
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The last interpolation method to cover is `nlerp`. `nlerp` approximates `slerp`.
    Unlike `slerp`, `nlerp` is not constant in velocity. `nlerp` is much faster than
    `slerp` and easier to implement; just normalize the result of `lerp`. The following
    figure compares `lerp`, `slerp`, and `nlerp`, where *t = 0.25*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要介绍的插值方法是`nlerp`。`nlerp`是对`slerp`的近似。与`slerp`不同，`nlerp`在速度上不是恒定的。`nlerp`比`slerp`快得多，实现起来更容易；只需对`lerp`的结果进行归一化。下图比较了`lerp`、`slerp`和`nlerp`，其中*t
    = 0.25*：
- en: '![Figure 2.15: Comparing lerp, slerp, and nlerp'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.15：比较lerp、slerp和nlerp'
- en: '](img/Figure_2.15_B16191.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.15_B16191.jpg)'
- en: 'Figure 2.15: Comparing lerp, slerp, and nlerp'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15：比较lerp、slerp和nlerp
- en: 'Implement the `nlerp` function in `vec3.cpp`. Don''t forget to add the function
    declaration to `vec3.h`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vec3.cpp`中实现`nlerp`函数。不要忘记将函数声明添加到`vec3.h`中：
- en: '[PRE18]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Generally, `nlerp` is a better choice than `slerp`. It's a very close approximation
    and much cheaper to calculate. The only time it makes sense to use `slerp` instead
    is if constant interpolation velocity is required. Throughout this book, you will
    be using `lerp` and `nlerp` to interpolate between vectors.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，`nlerp`比`slerp`更好。它是一个非常接近的近似，计算成本更低。唯一需要使用`slerp`的情况是如果需要恒定的插值速度。在本书中，您将使用`lerp`和`nlerp`来在向量之间进行插值。
- en: In the next section, you will learn how to use an epsilon value to compare vectors
    for equality and inequality.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何使用epsilon值来比较向量的相等和不相等。
- en: Comparing vectors
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较向量
- en: The last operation that needs to be implemented is vector comparison. Comparison
    is a component-wise operation; each element must be compared using an epsilon.
    Another way to measure whether two vectors are the same is to subtract them. If
    they were equal, subtracting them would yield a vector with no length.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 需要实现的最后一个操作是向量比较。比较是一个逐分量的操作；每个元素都必须使用一个epsilon进行比较。另一种衡量两个向量是否相同的方法是将它们相减。如果它们相等，相减将产生一个长度为零的向量。
- en: 'Overload the `==` and `!=` operators in `vec3.cpp`. Don''t forget to add the
    function declarations to `vec3.h`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vec3.cpp`中重载`==`和`!=`运算符。不要忘记将函数声明添加到`vec3.h`中：
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Important note:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Finding the right epsilon value to use for comparison operations is difficult.
    In this chapter, you declared `0.000001f` as the epsilon. This value is the result
    of some trial and error. To learn more about comparing floating point values,
    check out [https://bitbashing.io/comparing-floats.html](https://bitbashing.io/comparing-floats.html).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 找到用于比较操作的正确epsilon值是困难的。在本章中，您将`0.000001f`声明为epsilon。这个值是一些试验的结果。要了解更多关于比较浮点值的信息，请访问[https://bitbashing.io/comparing-floats.html](https://bitbashing.io/comparing-floats.html)。
- en: In the next section, you will implement vectors with two and four components.
    These vectors will only be used as a convenient way to store data; they won't
    actually need any math operations implemented on them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将实现具有两个和四个分量的向量。这些向量将仅用作存储数据的便捷方式；它们实际上不需要在其上实现任何数学操作。
- en: Exploring more vectors
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索更多向量
- en: At some point later on in this book, you will need to utilize two- and four-component
    vectors as well. The two- and four-component vectors don't need any mathematical
    functions defined as they will be used exclusively as containers used to pass
    data to the GPU.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面某个时候，您还需要使用两个和四个分量的向量。两个和四个分量的向量不需要定义任何数学函数，因为它们将被专门用作传递数据到GPU的容器。
- en: 'Unlike the three-component vector you have implemented, the two- and four-component
    vectors need to exist as both integer and floating point vectors. To avoid duplicating
    code, both structures will be implemented using a template:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与您实现的三分量向量不同，两个和四个分量的向量需要同时存在为整数和浮点向量。为了避免重复代码，将使用模板来实现这两种结构：
- en: 'Create a new file, `vec2.h`, and add the definition of the `vec2` struct. All
    the `vec2` constructors are inline; there is no need for a `cpp` file. The `TVec2`
    struct is templated and `typedef` is used to declare `vec2` and `ivec2`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`vec2.h`，并添加`vec2`结构的定义。所有`vec2`构造函数都是内联的；不需要`cpp`文件。`TVec2`结构是模板化的，使用`typedef`声明`vec2`和`ivec2`：
- en: '[PRE20]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Similarly, create a `vec4.h` file, which will hold the `vec4` structure:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，创建一个`vec4.h`文件，其中将保存`vec4`结构：
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The declaration of the `vec2`, `ivec2`, `vec4`, and `ivec4` structs are all
    very similar to the declaration of the `vec3` struct. All these structures can
    be accessed using component subscripts or as a pointer to a linear array of memory.
    They all have similar constructors, as well.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec2`，`ivec2`，`vec4`和`ivec4`结构的声明与`vec3`结构的声明非常相似。所有这些结构都可以使用组件下标或作为线性内存数组的指针来访问。它们的构造函数也非常相似。'
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned the vector math required to create a robust
    animation system. Animation is a math-heavy topic; the skills you have learned
    in this chapter are required to complete the rest of this book. You implemented
    all the common vector operations for three-component vectors. The `vec2` and `vec4`
    structures don't have a full implementation like `vec3`, but they are only used
    to send data to the GPU.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了创建强大动画系统所需的向量数学知识。动画是一个数学密集型的主题；本章中学到的技能是完成本书其余部分所必需的。您已经为三维向量实现了所有常见的向量运算。`vec2`和`vec4`结构没有像`vec3`那样的完整实现，但它们只用于将数据发送到GPU。
- en: In the next chapter, you will continue to learn more about game-related math
    by learning about matrices.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将继续学习关于游戏相关数学的知识，学习关于矩阵的知识。
