- en: '22'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '22'
- en: Parallel Algorithms with the STL
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 STL 的并行算法
- en: This chapter covers the topic of C++ parallelism, particularly with the tools
    and techniques introduced in C++17\. Starting with the foundations, the chapter
    unfolds the power of execution policies that allow developers to harness parallel
    processing in their C++ **Standard Template Library** (**STL**) algorithms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 C++ 并行性的主题，特别是 C++17 中引入的工具和技术。从基础开始，本章展开介绍了执行策略的力量，允许开发者利用并行处理在他们的 C++
    **标准模板库** (**STL**) 算法中。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Introduction to execution policies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行策略简介
- en: Incorporating execution policies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入执行策略
- en: The impact of `constexpr` on algorithms and containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constexpr` 对算法和容器的影响'
- en: Performance considerations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能考虑
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code in this chapter can be found on GitHub:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码可以在 GitHub 上找到：
- en: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL](https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL)'
- en: Introduction to execution policies
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行策略简介
- en: Processors have transitioned from focusing on increasing the speed of individual
    cores to incorporating multiple cores for enhanced performance. For developers,
    this means the potential to execute multiple instructions concurrently across
    these cores, improving application efficiency and responsiveness.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器已经从关注提高单个核心的速度转变为结合多个核心以增强性能。对于开发者来说，这意味着可以在这些核心上并发执行多个指令，从而提高应用程序的效率和响应速度。
- en: This move to multi-core configurations highlights the importance of integrating
    parallel programming techniques. With the advent of C++17, C++ made notable progress
    in this domain by introducing the `<``execution>` header.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转向多核配置突出了集成并行编程技术的重要性。随着 C++17 的出现，C++ 在这一领域取得了显著进展，通过引入 `<execution>` 头文件。
- en: The <execution> header– enabling parallelism in STL algorithms
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<execution>` 头文件–在 STL 算法中启用并行性'
- en: Before C++17, although the STL provided a comprehensive suite of algorithms,
    they were executed sequentially. This sequential operation meant that STL algorithms
    did not fully utilize the capabilities of multi-core processors.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++17 之前，尽管 STL 提供了一套全面的算法，但它们都是顺序执行的。这种顺序操作意味着 STL 算法没有充分利用多核处理器的功能。
- en: The `<execution>` header addresses this limitation. Instead of adding new algorithms,
    it enhances existing ones by incorporating parallelism by introducing execution
    policies.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`<execution>` 头文件解决了这一限制。它不是添加新算法，而是通过引入执行策略，通过结合并行性来增强现有算法。'
- en: 'Execution policies serve as directives, indicating to the STL algorithms the
    desired mode of operation: sequential, parallel, or vectorized. With the `<execution>`
    header, developers can specify these preferences.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 执行策略作为指令，指示 STL 算法所需的操作模式：顺序、并行或向量化。通过 `<execution>` 头文件，开发者可以指定这些偏好。
- en: 'The primary execution policies include the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的执行策略包括以下内容：
- en: '`std::execution::seq`: Dictates a sequential execution of the algorithm'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::execution::seq`: 规定算法的顺序执行'
- en: '`std::execution::par`: Facilitates parallel execution where feasible'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::execution::par`: 在可行的情况下促进并行执行'
- en: '`std::execution::par_unseq`: Supports both parallel and vectorized execution'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::execution::par_unseq`: 支持并行和向量化执行'
- en: Implementing parallel execution
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现并行执行
- en: 'Integrating parallelism into STL algorithms is straightforward. Consider the
    `std::sort` algorithm. Typically, it’s used in the following manner:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将并行性集成到 STL 算法中非常简单。以 `std::sort` 算法为例。通常，它被以下方式使用：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To employ parallel sorting with the `<execution>` header, the syntax is as
    follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `<execution>` 头文件进行并行排序，语法如下：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This modification equips the `sort` algorithm to leverage multiple cores, potentially
    enhancing the speed of the sorting process.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种修改使 `sort` 算法能够利用多个核心，从而可能提高排序过程的速度。
- en: Reflecting on the transition to parallel STL
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反思转向并行 STL 的过渡
- en: While introducing the `<execution>` header and its associated execution policies
    is a notable advancement, it’s essential to approach their usage with discernment.
    Parallelism does introduce overheads, such as thread context-switching and data
    coordination. These overheads can sometimes negate the benefits of parallelism,
    especially for tasks with smaller datasets.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然引入`<execution>`头文件及其相关的执行策略是一个显著的进步，但使用它们时必须谨慎。并行化确实引入了开销，如线程上下文切换和数据协调。这些开销有时会抵消并行化的好处，特别是对于数据集较小的任务。
- en: However, when used judiciously, the `<execution>` header can significantly enhance
    application performance. Subsequent sections will provide a more detailed exploration
    of execution policies, enabling developers to utilize them effectively.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当谨慎使用时，`<execution>`头文件可以显著提高应用程序的性能。后续章节将更详细地探讨执行策略，使开发者能够有效地利用它们。
- en: In summary, C++17’s `<execution>` header is a pivotal enhancement. Offering
    a mechanism to imbue existing STL algorithms with parallel capabilities equips
    developers with the tools to develop applications optimized for multi-core generation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，C++17的`<execution>`头文件是一个关键的增强。它提供了一种机制，将并行能力注入现有的STL算法中，使开发者能够开发针对多核生成优化的应用程序。
- en: Incorporating execution policies
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成执行策略
- en: The `<execution>` header, introduced in the C++17 standard, adds a significant
    layer of depth to C++ programming by furnishing a suite of tools designed for
    parallel computation. This header, when used in conjunction with the STL algorithms,
    allows developers to leverage the capabilities of concurrent computing effectively.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: C++17标准中引入的`<execution>`头文件，通过提供一套专为并行计算设计的工具，为C++编程增加了显著深度。当与STL算法结合使用时，这个头文件允许开发者有效地利用并发计算的能力。
- en: Execution policies, a key feature of the `<execution>` header, are instrumental
    in controlling the manner in which STL algorithms execute. By specifying an execution
    policy when invoking an STL algorithm, developers can dictate whether the algorithm
    should run sequentially, in parallel, or in parallel with vectorization. This
    level of control can lead to substantial performance improvements, particularly
    in applications that are computationally intensive or that operate on large datasets.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 执行策略是`<execution>`头文件的一个关键特性，对于控制STL算法的执行方式至关重要。通过在调用STL算法时指定执行策略，开发者可以指定算法是顺序运行、并行运行还是并行加向量化的运行。这种控制水平可以带来显著的性能提升，尤其是在计算密集型或处理大数据集的应用程序中。
- en: In essence, the `<execution>` header and its associated execution policies represent
    a powerful toolset for C++ developers. They provide a means to tap into the potential
    of modern multi-core processors and distributed computing environments, thereby
    enabling more efficient and faster code execution.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，`<execution>`头文件及其相关的执行策略为C++开发者提供了一套强大的工具集。它们提供了一种方式，可以挖掘现代多核处理器和分布式计算环境潜力，从而实现更高效和更快的代码执行。
- en: Integrating policies with standard algorithms
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将策略与标准算法集成
- en: Execution policies serve as directives for STL algorithms, indicating the preferred
    mode of operation. For those familiar with STL algorithms, integrating these policies
    requires minimal modification to existing code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 执行策略作为STL算法的指令，指示首选的操作模式。对于熟悉STL算法的开发者来说，集成这些策略需要对现有代码进行最小修改。
- en: 'Consider `std::for_each`, an algorithm that acts on each element in a collection.
    By default, it operates sequentially:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`std::for_each`算法，它作用于集合中的每个元素。默认情况下，它按顺序操作：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For large datasets or computationally demanding operations within the lambda
    function, parallel execution can be beneficial. This can be achieved by simply
    introducing an execution policy:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大数据集或lambda函数内的计算密集型操作，并行执行可能是有益的。这可以通过简单地引入一个执行策略来实现：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the inclusion of `std::execution::par`, the algorithm is now prepared for
    parallel execution.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了`std::execution::par`之后，该算法现在已准备好进行并行执行。
- en: Understanding parallel execution policies
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解并行执行策略
- en: 'There are two primary parallel execution policies:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要的并行执行策略：
- en: '`std::execution::par`: This indicates that an algorithm may be executed in
    parallel. It allows the implementation to decide on parallelism based on the specific
    context.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::execution::par`：这表示算法可以并行执行。它允许实现根据特定上下文来决定是否并行。'
- en: '`std::execution::par_unseq`: This goes further by suggesting parallelism and
    allowing for vectorization. This means that multiple loop iterations might execute
    concurrently on a single processor core when supported by the hardware.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::execution::par_unseq`：这进一步建议了并行性，并允许向量化。这意味着当硬件支持时，多个循环迭代可能在单个处理器核心上并发执行。'
- en: 'For instance, the `std::transform` algorithm, which applies a function to each
    collection element, can utilize these policies:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`std::transform`算法，它将函数应用于每个集合元素，可以利用这些策略：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each `vec` element is squared, and the result populates the output. The `std::execution::par_unseq`
    policy indicates the potential parallelization and vectorization of this operation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`vec`元素都被平方，结果填充到输出中。`std::execution::par_unseq`策略表明了此操作的潜在并行化和向量化。
- en: Selecting the appropriate execution policy
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择合适的执行策略
- en: While execution policies enhance parallel computation capabilities, they must
    be applied thoughtfully. Not every dataset or algorithm will gain from parallel
    execution, and sometimes, the overhead might negate the advantages for smaller
    datasets.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然执行策略增强了并行计算能力，但必须谨慎应用。并非每个数据集或算法都能从并行执行中获益，有时，开销可能会抵消小型数据集的优势。
- en: The `std::execution::seq` policy explicitly opts for sequential execution, ensuring
    the algorithm operates in a single-threaded mode. This is beneficial when parallelism
    introduces undue overhead or in contexts where parallel execution is not recommended.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::execution::seq`策略明确选择顺序执行，确保算法在单线程模式下运行。这在并行性引入不必要的开销或在不建议并行执行的环境中是有益的。'
- en: It’s also vital to be wary of potential issues when utilizing parallel policies
    with algorithms that possess side effects or necessitate synchronization.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用具有副作用或需要同步的算法的并行策略时，也要警惕潜在的问题。
- en: C++17’s execution policies facilitate straightforward access to parallelism.
    Pairing these with traditional STL algorithms allows developers to use multi-core
    processors optimally. Whether utilizing `std::transform` on a vast dataset, sorting
    large collections with `std::sort`, or filtering items using `std::remove_if`,
    execution policies provide an added performance dimension.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: C++17的执行策略简化了对并行性的访问。将这些策略与传统的STL算法配对，允许开发者最优地使用多核处理器。无论是使用`std::transform`处理大量数据集，还是使用`std::sort`对大型集合进行排序，或者使用`std::remove_if`过滤项目，执行策略都提供了额外的性能维度。
- en: However, always validate that parallel execution genuinely augments your application
    without ushering in unforeseen challenges or bottlenecks. It’s imperative to evaluate
    and test your code continually.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，始终要验证并行执行是否真正增强了您的应用程序，而没有带来不可预见的问题或瓶颈。不断地评估和测试您的代码是至关重要的。
- en: With this foundation, we’re poised to consider performance considerations in
    the upcoming section. Through discerning the application of parallelism, we can
    develop efficient C++ applications tailored to contemporary computational demands.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基础上，我们准备在下一节中考虑性能考虑因素。通过区分并行性的应用，我们可以开发出针对当代计算需求的效率高的C++应用程序。
- en: The impact of constexpr on algorithms and containers
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`constexpr`对算法和容器的影响'
- en: With the introduction of the `constexpr` specifier in C++11 and its enhancements
    in subsequent versions, compile-time computation in C++ has taken a significant
    leap. The ability for functions and constructors to operate at compile time via
    `constexpr` enables optimization and assurance of specific attributes before the
    code runs. This section examines the integration of `constexpr` within the STL,
    particularly concerning algorithms and containers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 随着C++11中`constexpr`指定符的引入及其在后续版本中的增强，C++中的编译时计算取得了重大飞跃。函数和构造函数通过`constexpr`在编译时操作的能力，使得优化和确保代码运行前的特定属性成为可能。本节探讨了`constexpr`在STL中的集成，特别是关于算法和容器。
- en: Evolution of constexpr
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`constexpr`的演变'
- en: In its infancy during C++11, `constexpr` was primarily for straightforward computations.
    The C++14 extension broadened its scope, embracing loops and conditional structures.
    By C++20, there was further augmentation allowing for `constexpr` allocations
    via `std::allocator`. This made containers such as `std::vector` and `std::string`
    usable with `constexpr`, though with certain restrictions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11的初期，`constexpr`主要用于简单的计算。C++14的扩展扩大了其范围，包括循环和条件结构。到C++20，进一步的增强允许通过`std::allocator`进行`constexpr`分配。这使得`std::vector`和`std::string`等容器可以在`constexpr`下使用，尽管存在某些限制。
- en: Algorithms and the role of constexpr
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法和`constexpr`的作用
- en: Originally, `constexpr` wasn’t widely applicable to STL algorithms due to their
    generic design and multifaceted requirements. However, with the C++20 standard,
    more STL algorithms became `constexpr`-compatible. This means that provided all
    inputs are constant expressions, it is possible to compute algorithmic outcomes
    at compile time.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，由于它们的泛型设计和多方面的要求，`constexpr`并不广泛适用于STL算法。然而，随着C++20标准的推出，更多的STL算法变得与`constexpr`兼容。这意味着，如果所有输入都是常量表达式，那么可以在编译时计算算法的结果。
- en: Take, for example, the `std::find` or `std::count` functions. When used on static
    data structures such as arrays or `std::array`, they can operate during the compilation
    phase. However, as of C++20, dynamic allocation remains mainly outside the domain
    of `constexpr`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以`std::find`或`std::count`函数为例。当用于静态数据结构，如数组或`std::array`时，它们可以在编译阶段执行。然而，截至C++20，动态分配仍然主要在`constexpr`的领域之外。
- en: 'The following code snippet uses `std::array` to highlight the use of `std::find`
    and `std::count` with `constexpr`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段使用`std::array`来突出`std::find`和`std::count`与`constexpr`的使用：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the example output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例输出：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `contains` and `countOccurrences` functions in the preceding code are evaluated
    at compile time because they operate on a `constexpr`-compatible `std::array`,
    and all their inputs are constant expressions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的`contains`和`countOccurrences`函数在编译时被评估，因为它们操作的是一个与`constexpr`兼容的`std::array`，并且它们的所有输入都是常量表达式。
- en: It’s worth noting that parallel algorithms using execution policies such as
    `std::execution::par` are not suitable for `constexpr` contexts due to their inherent
    reliance on runtime resources.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，使用如`std::execution::par`之类的执行策略的并行算法不适合`constexpr`上下文，因为它们固有的对运行时资源的依赖。
- en: Containers and constexpr integration
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器和`constexpr`集成
- en: C++20’s capability for compile-time allocations enabled specific STL containers
    to function within a `constexpr` environment. While `std::array` was always compatible,
    even some operations on `std::vector` and `std::string` became feasible. Nonetheless,
    any operation requiring dynamic memory or leading to undefined behavior will result
    in a compile-time error within a `constexpr` context.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: C++20的编译时分配能力使得特定的STL容器能够在`constexpr`环境中工作。虽然`std::array`始终兼容，甚至`std::vector`和`std::string`的一些操作也变得可行。不过，任何需要动态内存或导致未定义行为的操作，在`constexpr`上下文中都会导致编译时错误。
- en: The trajectory of `constexpr` indicates an evolving C++ environment where the
    lines between compile-time and runtime evaluation become increasingly indistinct.
    We might soon see more advanced algorithms and containers being evaluated entirely
    during compilation, optimizing performance and code safety.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`的发展轨迹表明，C++环境正在演变，编译时和运行时评估之间的界限变得越来越模糊。我们可能会很快看到更多高级算法和容器在编译时完全评估，从而优化性能和代码安全性。'
- en: However, the convergence of `constexpr` and parallel algorithms remains an uncertain
    prospect due to the fundamental runtime nature of parallelism.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于并行性的基本运行时特性，`constexpr`和并行算法的收敛仍然是一个不确定的前景。
- en: In summary, `constexpr` has undeniably reshaped C++ development. As it integrates
    more deeply into the STL, developers have more avenues to refine and solidify
    their applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`constexpr`无疑重塑了C++开发。随着它更深入地集成到STL中，开发者有了更多途径来精炼和巩固他们的应用程序。
- en: Performance considerations
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能考虑
- en: Parallel algorithms are a cornerstone in exploiting the capabilities of multi-core
    processors, aiming to enhance computational efficiency and performance. However,
    the journey from sequential to parallel programming is not straightforward. It
    requires a deep understanding of the inherent complexities and trade-offs. In
    this section, we will explore the various facets of parallel algorithms, including
    their potential for performance improvement, the challenges of parallel execution,
    optimal data sizing for parallelism, synchronization issues, and the subtleties
    of balancing workloads across threads. This comprehensive overview will provide
    a deeper insight into the effective utilization of parallel algorithms, underlining
    the importance of informed decision-making and profiling in achieving optimal
    performance in a parallel computing environment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 并行算法是利用多核处理器能力的基础，旨在提高计算效率和性能。然而，从顺序编程到并行编程的转变并不简单。它需要深入理解固有的复杂性和权衡。在本节中，我们将探讨并行算法的各个方面，包括其性能改进的潜力、并行执行挑战、并行化的最佳数据大小、同步问题和在线程间平衡工作负载的微妙之处。这个全面的概述将更深入地了解并行算法的有效利用，强调在并行计算环境中实现最佳性能时，信息决策和性能分析的重要性。
- en: Parallel algorithms present both opportunities and challenges for performance
    enhancement. While they offer the potential for faster computations in multi-core
    processing environments, their practical use requires careful consideration and
    decision-making.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 并行算法在性能增强方面既提供了机会也带来了挑战。虽然它们在多核处理环境中提供了更快计算的可能性，但它们的实际使用需要仔细考虑和决策。
- en: Parallelism overhead
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行开销
- en: As developers experiment with parallel solutions, it’s essential to understand
    that parallel execution doesn’t uniformly benefit all algorithms or scenarios.
    There can be overheads, such as those associated with initiating multiple threads
    and data synchronization. For example, for small datasets, the overhead of thread
    management can surpass the computation time, making parallelism less efficient.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发者对并行解决方案进行实验，了解并行执行并不均匀地有利于所有算法或场景至关重要。可能会有开销，例如与启动多个线程和数据同步相关的开销。例如，对于小数据集，线程管理的开销可能会超过计算时间，使得并行化效率较低。
- en: Determining optimal data size
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定最佳数据大小
- en: Parallel execution reveals its benefits beyond a specific data size threshold.
    This threshold is influenced by factors such as the algorithm employed, the computation’s
    nature, and the hardware specifications. A resource-intensive task with a large
    dataset is typically well-suited for parallelism, whereas smaller datasets might
    be more efficiently processed sequentially.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 并行执行在超过特定数据大小阈值时显示出其优势。这个阈值受所采用的算法、计算的特性和硬件规格等因素的影响。具有大量数据集的资源密集型任务通常非常适合并行化，而较小的数据集可能更有效地顺序处理。
- en: Understanding the data and computation type is critical to optimize performance.
    Profiling becomes invaluable, helping developers evaluate their code’s runtime
    behavior and decide when to employ parallelism.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 理解数据和计算类型对于优化性能至关重要。性能分析变得非常有价值，帮助开发者评估其代码的运行时行为，并决定何时采用并行化。
- en: Data access and synchronization challenges
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据访问和同步挑战
- en: Concurrency leads to scenarios where multiple threads access the same resources
    concurrently. Data contention can arise, especially with frequent shared data
    access. Implementing proper synchronization is vital to prevent data inconsistencies.
    However, synchronization has its associated overheads.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 并发可能导致多个线程同时访问相同的资源。数据竞争可能会出现，尤其是在频繁共享数据访问的情况下。实现适当的同步对于防止数据不一致至关重要。然而，同步也有其相关的开销。
- en: False sharing – a subtle performance issue
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪共享——一个微妙性能问题
- en: Even if threads access distinct data, false sharing can still occur. This happens
    when threads on different cores modify variables on the same cache line, leading
    to cache invalidations and potential performance degradation. It’s crucial to
    be mindful of data layout and aim for cache-optimized code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 即使线程访问不同的数据，仍然可能发生伪共享。这发生在不同核心上的线程修改同一缓存行中的变量时，导致缓存失效和潜在的性能下降。注意数据布局并力求编写缓存优化的代码至关重要。
- en: Load balancing
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负载均衡
- en: Different computational tasks may require varying processing times. If threads
    finish their tasks at different rates, it can result in resource underutilization.
    Practical parallel algorithms ensure that workloads are distributed uniformly
    across threads. Some advanced parallel techniques, such as work stealing, can
    dynamically reallocate tasks to maintain consistent thread engagement.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的计算任务可能需要不同的处理时间。如果线程以不同的速率完成任务，可能会导致资源利用率不足。实用的并行算法确保工作负载在线程之间均匀分布。一些高级并行技术，如工作窃取，可以动态重新分配任务，以保持一致的线程参与。
- en: The importance of profiling
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析的重要性
- en: A consistent theme in performance optimization is the essential role of profiling.
    Relying solely on assumptions is not advisable. Profiling tools such as `perf`
    and `gprof` and advanced tools such as Intel® VTune™ can identify performance
    bottlenecks, thread behaviors, and contention areas. These tools provide concrete
    data to fine-tune parallel strategies.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化的一个一致主题是分析的重要性。仅仅依赖假设是不可取的。如`perf`和`gprof`之类的分析工具以及如Intel® VTune™之类的先进工具可以识别性能瓶颈、线程行为和竞争区域。这些工具提供了具体数据，以微调并行策略。
- en: Throughout this section, we reviewed the performance considerations when working
    with parallel algorithms. We learned that while parallel algorithms can significantly
    enhance computational efficiency, their effective use requires a nuanced understanding
    of various factors. We discussed the potential overheads associated with parallel
    execution, such as thread initiation and data synchronization. We also highlighted
    the importance of determining the optimal data size for parallel execution, emphasizing
    that parallelism may not be beneficial for all scenarios, particularly those involving
    small datasets. We further explored the challenges of data access and synchronization
    in a concurrent environment, including the issue of false sharing. We also touched
    upon the concept of load balancing, explaining how uneven distribution of computational
    tasks can lead to resource underutilization. We discussed advanced techniques
    such as work stealing that can help maintain consistent thread engagement by dynamically
    reallocating tasks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了与并行算法一起工作时需要考虑的性能因素。我们了解到，虽然并行算法可以显著提高计算效率，但它们的有效使用需要细微地理解各种因素。我们讨论了与并行执行相关的潜在开销，例如线程初始化和数据同步。我们还强调了确定并行执行最佳数据大小的重要性，强调并行化可能并不适用于所有场景，尤其是涉及小数据集的场景。我们进一步探讨了在并发环境中数据访问和同步的挑战，包括假共享问题。我们还简要介绍了负载平衡的概念，解释了计算任务的不均匀分布如何导致资源利用率不足。我们讨论了如工作窃取等高级技术，这些技术可以通过动态重新分配任务来帮助保持一致的线程参与。
- en: The insights gained from this section are invaluable as they equip us with the
    knowledge to make informed decisions when implementing parallel algorithms. Understanding
    these performance considerations allows us to exploit the full potential of multi-core
    processors while avoiding common pitfalls. This knowledge is crucial in today’s
    multi-core processing environment, enabling us to write more efficient and performant
    code. It also sets the stage for our continued exploration of data structures
    and algorithms with the C++ STL, as we strive to deepen our understanding and
    enhance our programming skills.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节中获得的认识是无价的，因为它们为我们提供了在实现并行算法时做出明智决策的知识。理解这些性能考虑因素使我们能够充分利用多核处理器的全部潜力，同时避免常见的陷阱。在当今的多核处理环境中，这些知识至关重要，使我们能够编写更高效、性能更好的代码。它还为我们在C++
    STL中继续探索数据结构和算法奠定了基础，因为我们努力深化我们的理解并提高我们的编程技能。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced parallel algorithms within the STL. We began by acquainting
    ourselves with the `<execution>` header introduced in C++17, which has been pivotal
    in enabling parallelism in STL algorithms. This addition allows us to specify
    execution policies such as `std::execution::seq`, `std::execution::par`, and `std::execution::par_unseq`,
    thereby dictating the execution mode of STL algorithms.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了STL中的并行算法。我们首先熟悉了C++17中引入的`<execution>`头文件，它在使STL算法实现并行化方面发挥了关键作用。这一新增功能使我们能够指定执行策略，如`std::execution::seq`、`std::execution::par`和`std::execution::par_unseq`，从而规定STL算法的执行模式。
- en: We progressed to implementing these execution policies in standard algorithms,
    demonstrating the simplicity of transitioning from sequential to parallel execution.
    This was exemplified by adapting algorithms such as `std::sort` and `std::for_each`
    to run in parallel, thus harnessing the computational power of multiple cores.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些执行策略实施到标准算法中，展示了从顺序执行到并行执行的转换的简单性。这通过将算法如`std::sort`和`std::for_each`调整为并行运行来体现，从而利用了多核的计算能力。
- en: The chapter then focused on the `constexpr` specifier and its profound impact
    on STL algorithms and containers. We explored the evolution of `constexpr` from
    C++11 through C++20 and its role in enabling compile-time computations for algorithms
    such as `std::find` and `std::count`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 章节接着聚焦于`constexpr`指定符及其对STL算法和容器的深远影响。我们探讨了`constexpr`从C++11到C++20的演变及其在使算法如`std::find`和`std::count`的编译时计算成为可能中的作用。
- en: Performance considerations formed the crux of our final discussion, underscoring
    the benefits and potential pitfalls of employing parallel algorithms. We addressed
    the overheads associated with parallelism, the importance of determining optimal
    data size, and strategies for effective data access and synchronization to avoid
    issues such as false sharing and load imbalance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 性能考虑构成了我们最终讨论的核心，强调了使用并行算法的好处和潜在的风险。我们讨论了与并行性相关的开销，确定最佳数据大小的重要性，以及有效数据访问和同步的策略，以避免诸如伪共享和负载不平衡等问题。
- en: The information imparted in this chapter is invaluable for leveraging the STL’s
    capabilities in a multi-core processing environment. We can write more efficient
    and responsive code by understanding when and how to apply parallel algorithms.
    This deepened comprehension of parallel execution policies and the ability to
    optimize code with `constexpr` equips us to maximize performance and resource
    utilization.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本章传达的信息对于在多核处理环境中利用STL的能力是无价的。通过理解何时以及如何应用并行算法，我们可以编写更高效、响应更快的代码。对并行执行策略的深入理解以及使用`constexpr`优化代码的能力使我们能够最大化性能和资源利用率。
