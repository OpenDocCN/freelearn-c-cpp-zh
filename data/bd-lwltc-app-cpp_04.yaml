- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Building the C++ Building Blocks for Low Latency Applications
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建低延迟应用程序的C++构建块
- en: In the previous chapter, we had a detailed and highly technical discussion of
    how to approach developing low latency applications in C++. We also investigated
    the technical details of the C++ programming language as well as the GCC compiler.
    Now, we will move from a theoretical discussion to building some practical low
    latency C++ components ourselves.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们详细且技术性地讨论了如何在C++中开发低延迟应用程序的方法。我们还研究了C++编程语言的技术细节以及GCC编译器。现在，我们将从理论讨论转向自己构建一些实际的低延迟C++组件。
- en: We will build some relatively general components that can be used in a variety
    of different low latency applications, such as the ones we discussed in the previous
    chapters. As we build these basic building blocks in this chapter, we will learn
    about using C++ effectively to write highly performant C++ code. We will use these
    components in the rest of the book to demonstrate where these components fit into
    the electronic trading ecosystem that we will design and build.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一些相对通用的组件，这些组件可以用于各种不同的低延迟应用程序，例如我们在上一章中讨论的那些。在我们本章构建这些基本构建块时，我们将学习如何有效地使用C++编写高性能的C++代码。我们将在本书的其余部分使用这些组件来展示这些组件在我们设计和构建的电子交易生态系统中如何定位。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: C++ threading for multi-threaded low latency applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++多线程用于低延迟多线程应用程序
- en: Designing C++ memory pools to avoid dynamic memory allocations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计C++内存池以避免动态内存分配
- en: Transferring data using lock-free queues
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无锁队列传输数据
- en: Building a low latency logging framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建低延迟日志框架
- en: C++ network programming using sockets
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用套接字进行C++网络编程
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code for this book can be found in the GitHub repository for this book
    at [https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP).
    The source for this chapter is in the `Chapter4` directory in the repository.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有代码都可以在本书的GitHub仓库中找到，网址为[https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP](https://github.com/PacktPublishing/Building-Low-Latency-Applications-with-CPP)。本章的源代码位于仓库中的`Chapter4`目录。
- en: We expect you to have at least intermediate C++ programming experience, since
    we will assume you understand the widely used C++ programming features well. We
    also assume that you have some experience with network programming in C++, since
    network programming is a huge topic and cannot be covered in this book. For this
    book, starting with this chapter, we will use the CMake and Ninja build systems,
    so we expect you to either understand CMake, g++, Ninja, Make, or some such build
    system to be able to build the code samples for this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望您至少具备中级C++编程经验，因为我们假设您对广泛使用的C++编程特性有很好的理解。我们还假设您在C++网络编程方面有一些经验，因为网络编程是一个庞大的主题，无法在本书中涵盖。对于本书，从本章开始，我们将使用CMake和Ninja构建系统，因此我们期望您理解CMake、g++、Ninja、Make或其他类似的构建系统，以便能够构建本书的代码示例。
- en: 'The specifications of the environment in which the source code for this book
    was developed are shown here. We present the details of this environment since
    all the C++ code presented in this book is not necessarily portable and might
    require some minor changes to work in your environment:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书源代码开发环境的规格在此展示。我们提供此环境的详细信息，因为本书中展示的所有C++代码不一定可移植，可能需要在您的环境中进行一些小的修改才能工作：
- en: '`Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18
    17:40:00 UTC 2 x86_64 x86_64` `x86_64 GNU/Linux`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18
    17:40:00 UTC 2 x86_64 x86_64` `x86_64 GNU/Linux`'
- en: '`g++ (Ubuntu` `11.3.0-1ubuntu1~22.04.1) 11.3.0`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g++ (Ubuntu` `11.3.0-1ubuntu1~22.04.1) 11.3.0`'
- en: '`cmake` `version 3.23.2`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmake` `版本 3.23.2`'
- en: '`1.10.2`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.10.2`'
- en: C++ threading for multi-threaded low latency applications
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++多线程用于低延迟多线程应用程序
- en: The first component we will build is a very small one but still quite fundamental.
    This section will design and implement a method of creating and running threads
    of execution. These will be used in many different parts of a full low-latency
    system, depending on the design of the different sub-components in the system.
    Depending on the design of the system, different components might work together
    as a pipeline to facilitate parallel processing. We will use the multi-threading
    framework in exactly such a way in our electronic trading systems. Another use
    case is to pass off non-critical tasks such as logging onto disk, computing statistics,
    and so on to a background thread.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的第一个组件非常小，但仍然非常基础。本节将设计和实现创建和运行执行线程的方法。这些将在整个低延迟系统的许多不同部分中使用，具体取决于系统不同子组件的设计。根据系统设计，不同的组件可能作为一个流水线协同工作，以促进并行处理。我们将在我们的电子交易系统中以这种方式使用多线程框架。另一个用例是将非关键任务，如将日志记录到磁盘、计算统计数据等，传递给后台线程。
- en: Before we move on to the source code that creates and manipulates threads, let
    us first quickly define a few useful macros. We will use these functions in many
    places in the source code that we will be writing in this book, starting with
    this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到创建和操作线程的源代码之前，让我们首先快速定义一些有用的宏。我们将在本书中编写的源代码的许多地方使用这些函数，从本章开始。
- en: Defining some useful macros and functions
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一些有用的宏和函数
- en: Most low latency applications run on modern pipelined processors that pre-fetch
    instructions and data before they need to be executed. We discussed in the previous
    chapter that branch mispredictions are extremely expensive and stall the pipeline,
    introducing bubbles into it. Therefore, an important development practice for
    low latency applications is to have fewer branches. Since branches are unavoidable,
    it is also important to try and make them as predictable as possible.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数低延迟应用程序运行在现代流水线处理器上，这些处理器在需要执行之前预先获取指令和数据。我们在上一章讨论过，分支预测错误非常昂贵，会导致流水线停滞，向其中引入气泡。因此，低延迟应用程序的重要开发实践是减少分支的数量。由于分支不可避免，因此也很重要尽可能地使它们尽可能可预测。
- en: We have two simple macros that we will use to provide branching hints to the
    compiler. These use the `__builtin_expect` GCC built-in function that reorders
    the machine instructions generated by the compiler. Effectively, the compiler
    uses the branch prediction hints provided by the developer to generate machine
    code that is optimized under the assumption that a branch is more or less likely
    to be taken.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个简单的宏，我们将使用它们向编译器提供分支提示。这些宏使用了`__builtin_expect` GCC内置函数，该函数重新排序编译器生成的机器指令。实际上，编译器使用开发者提供的分支预测提示来生成机器代码，该代码在假设分支更有可能被采取的情况下进行了优化。
- en: Note that instruction reordering is only part of the full picture when it comes
    to branch prediction, since there is a hardware branch predictor that the processor
    uses when running instructions. Note that modern hardware branch predictors are
    extremely good at predicting branches and jumps, especially in cases where the
    same branch gets taken many times and even when there are at least easily predictable
    branching patterns.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当涉及到分支预测时，指令重排只是完整画面的一部分，因为处理器在运行指令时使用了一个硬件分支预测器。注意，现代硬件分支预测器在预测分支和跳转方面非常出色，尤其是在相同的分支被多次采取的情况下，甚至在至少有容易预测的分支模式的情况下。
- en: 'The two macros are the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个宏如下所示：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `LIKELY(x)` macro specifies that the condition specified by `x` is likely
    to be true, and the `UNLIKELY(x)` macro does the opposite. As an example of the
    usage, we will use the `UNLIKELY` macro shortly in the next set of functions.
    In C++20, this is standardized like the `[[likely]]` and `[[unlikely]]` attributes
    to perform the same function in a standard and portable manner.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIKELY(x)`宏指定由`x`指定的条件很可能为真，而`UNLIKELY(x)`宏则相反。作为一个使用示例，我们将在下一组函数中很快使用`UNLIKELY`宏。在C++20中，这像`[[likely]]`和`[[unlikely]]`属性一样被标准化，以标准且可移植的方式执行相同的功能。'
- en: 'We will define two additional functions next, but these are simply used for
    assertions in our code base. These should be pretty self-explanatory; `ASSERT`
    logs a message and exits if the condition it is provided evaluates to `false`,
    and `FATAL` simply logs a message and exits. Note the use of `UNLIKELY` here to
    specify that we do not expect the `!cond` condition to evaluate to `true`. Also
    note that using the `ASSERT` method on critical code paths is not free, mostly
    because of the if check. This is something that we will eventually change to be
    optimized out of our code for release builds, but for now, we will keep it, since
    it should be extremely cheap to use:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来将定义两个额外的函数，但它们只是在我们代码库中的断言中使用。这些应该相当直观；`ASSERT` 在条件评估为 `false` 时记录一条消息并退出，而
    `FATAL` 则简单地记录一条消息并退出。注意这里使用了 `UNLIKELY` 来指定我们并不期望 `!cond` 条件评估为 `true`。还请注意，在关键代码路径上使用
    `ASSERT` 方法并不是免费的，主要是因为 if 检查。这是我们最终将更改以从发布构建中优化出去的事情，但到目前为止，我们将保留它，因为它应该非常便宜：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The code discussed in this section can be found in the `Chapter4/macros.h`
    source file in the GitHub repository for this book. Note that the `macros.h` header
    file includes the following two header files:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中讨论的代码可以在本书 GitHub 仓库的 `Chapter4/macros.h` 源文件中找到。请注意，`macros.h` 头文件包含了以下两个头文件：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let us jump into thread creation and manipulation functionality in the
    next section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跳转到下一节，讨论线程创建和操作功能。
- en: Creating and launching a new thread
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和启动新线程
- en: 'The method defined in the following code block creates a new thread object,
    sets the thread affinity on the thread (more on this later), and forwards the
    function and related arguments that the thread will run during its execution.
    This is achieved in the `thread_body` lambda, which is passed to the constructor
    of `std::thread`. Note the use of *variadic template arguments* and *perfect forwarding*
    to allow this method to be used, running all kinds of functions, arbitrary types,
    and any number of arguments. After creating the thread, the method waits till
    the thread either starts running successfully or fails because it failed to set
    thread affinity, which is what the call to `t->join()` does. Ignore the call to
    `setThreadCore(core_id)` for now; we will discuss that in the next section:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块中定义的方法创建了一个新的线程对象，在线程上设置线程亲和性（稍后会有更多介绍），并将线程在执行期间将运行的函数和相关参数传递给线程。这是通过将
    `thread_body` lambda 传递给 `std::thread` 构造函数来实现的。注意使用了 *可变参数模板* 和 *完美转发* 来允许此方法使用，运行各种函数、任意类型和任意数量的参数。创建线程后，该方法会等待直到线程成功启动或失败，因为未能设置线程亲和性，这就是调用
    `t->join()` 的作用。现在忽略对 `setThreadCore(core_id)` 的调用；我们将在下一节中讨论它：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code discussed in this section can be found in the `Chapter4/thread_utils.h`
    source file in the GitHub repository for this book. Now, let us jump into the
    final section to set thread affinity in the `setThreadCore(core_id)` function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中讨论的代码可以在本书 GitHub 仓库的 `Chapter4/thread_utils.h` 源文件中找到。现在，让我们跳转到最后一节，在 `setThreadCore(core_id)`
    函数中设置线程亲和性。
- en: Setting thread affinity
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置线程亲和性
- en: Here, we will discuss the source code to set the thread affinity for the thread
    creation lambda we saw in the previous section. Before we discuss the source code,
    remember that if there is a lot of context-switching between threads, it adds
    a lot of overhead to thread performance. Threads jumping between CPU cores also
    hurts performance for similar reasons. Setting thread affinity for performance-critical
    threads is very important for low latency applications to avoid these issues.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论设置线程亲和性的源代码，这是我们在上一节中看到的线程创建 lambda 表达式的功能。在我们讨论源代码之前，请记住，如果线程之间有大量的上下文切换，这会给线程性能带来很多开销。线程在
    CPU 内核之间跳跃也会因为类似的原因损害性能。对于性能关键型线程设置线程亲和性对于低延迟应用来说非常重要，以避免这些问题。
- en: 'Now, let us look at how to set thread affinity in the `setThreadCore()` method.
    First, we use the `CPU_ZERO()` method to clear the `cpu_set_t` variable, which
    is just an array of flags. Then, we use the `CPU_SET()` method to enable entry
    for the `core_id` we are trying to pin the core to. Finally, we use the `pthread_setaffinity_np()`
    function to set the thread affinity and return `false` if that fails. Note the
    use of `pthread_self()` here to get the thread ID to use, which makes sense because
    this is called from within the `std::thread` instance we create in `createAndStartThread()`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在`setThreadCore()`方法中设置线程亲和性。首先，我们使用`CPU_ZERO()`方法清除`cpu_set_t`变量，它只是一个标志数组。然后，我们使用`CPU_SET()`方法启用我们想要将其核心固定的`core_id`的入口。最后，我们使用`pthread_setaffinity_np()`函数设置线程亲和性，如果失败则返回`false`。注意这里使用`pthread_self()`来获取要使用的线程ID，这是有意义的，因为这是在`createAndStartThread()`中从我们创建的`std::thread`实例中调用的：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code discussed in this section can be found in the `Chapter4/thread_utils.h`
    source file in the GitHub repository for this book. These code blocks belong in
    the `Common` namespace, as you will see when you look at the `thread_utils.h`
    source file in the GitHub repository.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的代码可以在本书GitHub仓库的`Chapter4/thread_utils.h`源文件中找到。这些代码块属于`Common`命名空间，当你查看GitHub仓库中的`thread_utils.h`源文件时，你会看到这一点。
- en: Building an example
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建示例
- en: Before we conclude this section, let us quickly look at a simple example that
    uses the thread utilities we just created. This example can be found in the `Chapter4/thread_example.cpp`
    source file in the GitHub repository for this book. Note that the library and
    all the examples for this chapter can be built using the `CMakeLists.txt` included
    in the `Chapter4` directory. We also provided two simple scripts, `build.sh` and
    `run_examples.sh`, to build and run these examples after setting the correct paths
    to the `cmake` and `ninja` binaries. Note that `cmake` and `ninja` are arbitrary
    build system choices here, and you can change the build system to be anything
    else if needed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本节之前，让我们快速看一下一个使用我们刚刚创建的线程工具的简单示例。这个示例可以在本书GitHub仓库的`Chapter4/thread_example.cpp`源文件中找到。请注意，本章的库和所有示例都可以使用包含在`Chapter4`目录中的`CMakeLists.txt`构建。我们还提供了两个简单的脚本，`build.sh`和`run_examples.sh`，在设置正确的`cmake`和`ninja`二进制文件路径后，用于构建和运行这些示例。请注意，这里的`cmake`和`ninja`是任意构建系统选择，如果需要，你可以将其更改为任何其他构建系统。
- en: 'The example should be quite self-explanatory – we create and launch two threads
    with a dummy task of adding the two arguments (`a` and `b`) passed to it. Then,
    we wait for the threads to finish execution before exiting the program:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例应该相当直观——我们创建并启动两个线程，执行一个模拟任务，即添加传递给它的两个参数（`a`和`b`）。然后，我们在退出程序之前等待线程完成执行：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running this example will output something like this as the program executes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序执行时，将输出类似以下内容：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let us move on to the next section, where we will discuss how to avoid dynamic
    memory allocations when objects need to be created and discarded during runtime.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到下一节，我们将讨论在运行时需要创建和丢弃对象时如何避免动态内存分配。
- en: Designing C++ memory pools to avoid dynamic memory allocations
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计C++内存池以避免动态内存分配
- en: We have had several discussions on dynamic memory allocation, the steps the
    OS needs to perform, and why dynamic memory allocation is slow. Dynamic memory
    allocation is so slow in fact that low latency applications actively try to avoid
    it as much as possible on the critical path. We cannot build useful applications
    without creating and deleting many objects at runtime, and dynamic memory allocation
    is too slow for low latency applications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经就动态内存分配、操作系统需要执行的步骤以及为什么动态内存分配速度慢进行了多次讨论。实际上，动态内存分配非常慢，以至于低延迟应用程序会尽可能在关键路径上避免它。没有创建和删除许多对象，我们就无法构建有用的应用程序，而动态内存分配对于低延迟应用程序来说太慢了。
- en: Understanding the definition of a memory pool
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解内存池的定义
- en: First, let us formally define what a memory pool is and why we need one. Many
    applications (including low latency applications) need to be able to handle many
    objects and an unknown number of objects. By an unknown number of objects, we
    mean that the expected count of objects cannot be determined ahead of time, and
    it cannot be ascertained what the maximum number of objects will be. Obviously,
    the maximum number of objects possible is what can fit inside the system’s memory.
    The traditional approach to handling these objects is to use dynamic memory allocations
    as needed. In such a case, the heap memory is considered the memory pool – that
    is, the pool of memory to allocate from and deallocate to. Unfortunately, these
    are slow, and we will control how the allocation and deallocation of memory happen
    in our system using our own custom memory pool. We define a memory pool as anything
    from which we can request additional memory or objects and return free memory
    or objects to. By building our own custom memory pool, we can leverage the usage
    patterns and control the allocation and deallocation mechanisms for optimal performance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们正式定义什么是内存池以及为什么我们需要它。许多应用程序（包括低延迟应用程序）需要能够处理许多对象以及未知数量的对象。通过未知数量的对象，我们指的是无法提前确定对象的预期数量，也无法确定对象的最大数量。显然，可能的最大对象数量是系统内存能够容纳的数量。处理这些对象的传统方法是在需要时使用动态内存分配。在这种情况下，堆内存被视为内存池——即从其中分配和释放内存的内存池。不幸的是，这些操作很慢，我们将通过使用我们自己的自定义内存池来控制系统中内存的分配和释放。我们定义内存池为任何我们可以从中请求额外内存或对象并将空闲内存或对象返回的地方。通过构建我们自己的自定义内存池，我们可以利用使用模式并控制分配和释放机制以实现最佳性能。
- en: Understanding the use cases of a memory pool
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解内存池的使用案例
- en: When the exact number of objects of a certain type that will be required is
    known ahead of time, you can decide to create exactly that number when needed.
    In practice, there are many cases where the exact number of objects is not known
    ahead of time. This means we need to create objects on the fly using dynamic memory
    allocation. As mentioned previously, dynamic memory allocation is a very slow
    process and a problem for low latency applications. We use the term *memory pool*
    to describe a pool of objects of a certain type, and that is what we will build
    in this section. We will use the memory pool in this book to allocate and deallocate
    objects that we cannot predict.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当提前知道将需要的特定类型对象的确切数量时，你可以决定在需要时创建正好那个数量的对象。在实践中，有许多情况下无法提前知道确切的对象数量。这意味着我们需要在运行时动态地创建对象。如前所述，动态内存分配是一个非常缓慢的过程，对于低延迟应用程序来说是一个问题。我们使用术语*内存池*来描述特定类型的对象池，这就是我们将在本节中构建的内容。我们将在这本书中使用内存池来分配和释放我们无法预测的对象。
- en: The solution we will use is to pre-allocate large blocks of memory at startup
    and serve out required amounts at runtime – that is, do the memory allocation
    and deallocation steps ourselves from this storage pool. This ends up performing
    significantly better for a lot of different reasons, such as being able to limit
    the memory pool usage to certain components in our system instead of all processes
    running on the server. We can also control the memory storage and allocation and
    deallocation algorithms, tuning them to perform optimally for our specific application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的解决方案是在启动时预分配大量内存块，并在运行时提供所需数量的内存——即，从这个存储池中自行执行内存分配和释放步骤。这最终在许多不同的原因上表现出显著的优势，例如，我们可以将内存池的使用限制在我们的系统中的某些组件上，而不是服务器上运行的所有进程。我们还可以控制内存存储和分配释放算法，调整它们以针对我们的特定应用程序进行优化。
- en: Let us start by first making some design decisions for our memory pool. All
    the source code for our memory pool is in the `Chapter4/mem_pool.h` source file
    in the GitHub repository for this book.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为我们的内存池做一些设计决策。我们内存池的所有源代码都存储在这本书的GitHub仓库中的`Chapter4/mem_pool.h`源文件中。
- en: Designing the memory pool storage
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计内存池存储
- en: First, we need to decide how to store the elements inside the memory pool. We
    have really two major choices here – store them on the stack using something like
    an old-style array (`T[N]`) or `std::array`, or store it on the heap using something
    like an old-style pointer (`T*`) or something like `std::vector`. Depending on
    the size of the memory pool, the usage frequency, usage patterns, and the application
    itself, one choice might be better than the other. For instance, it is possible
    that we expect to need a huge amount of memory in the memory pool, either because
    the objects it stores are large or there are many of them. For such a case, heap
    allocation would be the preferred choice to accommodate the large memory requirements
    without impacting the stack memory. If we expect very few objects or small objects,
    we should consider using the stack implementation instead. If we expect to access
    the objects rarely, putting them on the stack might encounter better cache performance,
    but for frequent access, either implementation should work equally well. As with
    a lot of other choices, these decisions are always made by measuring performance
    in practice. For our memory pool, we will use `std::vector` and heap allocation
    while noting that it is not thread-safe.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要决定如何在内存池内部存储元素。在这里，我们实际上有两个主要的选择——使用类似旧式数组（`T[N]`）或 `std::array` 在栈上存储它们，或者使用类似旧式指针（`T*`）或类似
    `std::vector` 的方式在堆上存储。根据内存池的大小、使用频率、使用模式和应用程序本身，一个选择可能比另一个更好。例如，我们可能预计在内存池中需要大量的内存，要么是因为存储的对象很大，要么是因为有很多这样的对象。在这种情况下，堆分配将是首选，以适应大量的内存需求，同时不影响栈内存。如果我们预计对象很少或对象很小，我们应该考虑使用栈实现。如果我们预计很少访问对象，将它们放在栈上可能会遇到更好的缓存性能，但对于频繁访问，两种实现都应该同样有效。就像很多其他选择一样，这些决策总是通过实际测量性能来做出的。对于我们的内存池，我们将使用
    `std::vector` 和堆分配，同时注意它不是线程安全的。
- en: 'We also need a variable to track which blocks are free or in use. Finally,
    we will need one last variable to track the location of the next free block to
    quickly serve allocation requests. One important thing to note here is that we
    have two choices:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个变量来跟踪哪些块是空闲的或正在使用的。最后，我们还需要一个变量来跟踪下一个空闲块的位置，以便快速处理分配请求。这里需要注意的一个重要事项是我们有两个选择：
- en: We use two vectors – one to track the objects and one to track the free or empty
    markers. This solution is presented in the following diagram; note that in this
    example, we assume that these two vectors are in very different memory locations.
    The point we are trying to make here is that accessing the free or empty marker
    and the object itself might cause cache misses because they are far away from
    each other.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用两个向量——一个用于跟踪对象，另一个用于跟踪空闲或空标记。这种解决方案在以下图中展示；请注意，在这个例子中，我们假设这两个向量位于非常不同的内存位置。我们试图说明的是，访问空闲或空标记和对象本身可能会引起缓存未命中，因为它们相距很远。
- en: '![Figure 4.1 – A memory pool implementation that uses two vectors to track
    objects and show which indices are free or in use](img/Figure_4.1_B19434.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 使用两个向量跟踪对象并显示哪些索引是空闲或正在使用的内存池实现](img/Figure_4.1_B19434.jpg)'
- en: Figure 4.1 – A memory pool implementation that uses two vectors to track objects
    and show which indices are free or in use
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 使用两个向量跟踪对象并显示哪些索引是空闲或正在使用的内存池实现
- en: We maintain a single vector of structures (a struct, a class, or primitive objects),
    and each structure stores both the object and variable to represent the free or
    empty flag.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们维护一个结构体（一个结构体、一个类或原始对象）的单个向量，每个结构体存储对象和变量来表示空闲或空标志。
- en: '![Figure 4.2 – A memory pool implementation that uses a single vector to track
    the object and see whether it is free or in use](img/Figure_4.2_B19434.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 使用单个向量跟踪对象并查看它是否空闲或正在使用的内存池实现](img/Figure_4.2_B19434.jpg)'
- en: Figure 4.2 – A memory pool implementation that uses a single vector to track
    the object and see whether it is free or in use
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 使用单个向量跟踪对象并查看它是否空闲或正在使用的内存池实现
- en: 'The second choice is better from a cache performance perspective, because accessing
    the object and free marker placed right after the object is better than accessing
    two different locations in two different vectors that might be potentially far
    away from each other in memory. This is also because, in almost all usage patterns,
    if we access the object, we access the free marker and vice versa:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从缓存性能的角度来看，第二个选择更好，因为访问紧接在对象之后放置的对象和空闲标记，比访问两个可能相距甚远的向量中的不同位置要好。这也是因为在几乎所有使用模式中，如果我们访问对象，我们也会访问空闲标记，反之亦然：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, we need to look at how we initialize this memory pool in the constructor
    and some boilerplate code for the construction and assignment tasks.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要看看如何在构造函数中初始化这个内存池，以及一些构造和赋值任务的样板代码。
- en: Initializing the memory pool
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化内存池
- en: 'Initializing our memory pool is quite straightforward – we simply accept a
    parameter that specifies the initial size of our memory pool and initialize the
    vector to be large enough to accommodate that many concurrently allocated objects.
    In our design, we will not add functionality to resize the memory pool past its
    initial size, but that is a relatively straightforward extension to add if needed.
    Note that this initial vector initialization is the only time the memory pool
    allocates memory dynamically, so the memory pool should be created before the
    execution of the critical path starts. One thing to note here is that we add an
    assertion to make sure that the actual object of type `T` is the first one in
    the `ObjectBlock` struct; we will see the reason for this requirement in the *Handling*
    *deallocations* section:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化我们的内存池相当简单——我们只需接受一个参数，指定我们的内存池的初始大小，并将向量初始化得足够大，以容纳这么多同时分配的对象。在我们的设计中，我们不会添加功能来调整内存池的大小超过其初始大小，但如果需要，这是一个相对简单的扩展来添加。请注意，这个初始向量初始化是内存池唯一一次动态分配内存的时间，因此内存池应该在关键路径执行开始之前创建。这里有一点需要注意，我们添加了一个断言来确保类型为
    `T` 的实际对象是 `ObjectBlock` 结构中的第一个；我们将在 *处理* *释放* 部分看到这个要求的原因：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now for some boilerplate code – we will delete the default constructor, the
    copy constructor, and the move constructor methods. We will do the same with the
    copy assignment operator and the move assignment operator. We do this so that
    these methods are not accidentally called without our knowledge. This is also
    the reason we made our constructor explicit – to prohibit implicit conversions
    where we do not expect them:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是一些样板代码——我们将删除默认构造函数、拷贝构造函数和移动构造函数方法。我们也会对拷贝赋值运算符和移动赋值运算符做同样处理。我们这样做是为了防止这些方法在没有我们意识的情况下被意外调用。这也是我们使构造函数显式化的原因——以禁止我们不期望的隐式转换：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, let us move on to the code to serve allocation requests by providing a
    free object of the `T`-type template parameter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续编写代码，通过提供 `T`-类型模板参数的空闲对象来处理分配请求。
- en: Serving new allocation requests
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理新的分配请求
- en: Serving allocation requests is a simple task of finding a block that is free
    in our memory pool storage, which we can do easily using the `next_free_index_`
    tracker. Then, we update the `is_free_` marker for that block, initialize the
    object block of type `T` using `placement new`, and then update `next_free_index_`
    to point to the next available free block.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 处理分配请求是一个简单的任务，即在我们的内存池存储中找到一个空闲的块，我们可以很容易地使用 `next_free_index_` 跟踪器来完成这个任务。然后，我们更新该块的
    `is_free_` 标记，使用 `placement new` 初始化类型为 `T` 的对象块，然后更新 `next_free_index_` 以指向下一个可用的空闲块。
- en: Note two things – the first is that we use `placement new` to return an object
    of type `T` instead of a memory block that is the same size as `T`. This is not
    strictly necessary and can be removed if the user of the memory pool wants to
    take responsibility for constructing the object from the memory block we return.
    `placement new` in most compiler implementations might add an extra `if` check
    to confirm that the memory block provided to it is not null.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两点——第一点是，我们使用 `placement new` 返回类型为 `T` 的对象，而不是与 `T` 大小相同的内存块。这并不是绝对必要的，如果内存池的使用者希望负责从我们返回的内存块中构建对象，则可以将其删除。在大多数编译器的实现中，`placement
    new` 可能会添加一个额外的 `if` 检查，以确认提供给它的内存块不是空的。
- en: 'The second thing, which is more of a design choice for us to make depending
    on the application, is that we call `updateNextFreeIndex()` to update `next_free_index_`
    to point to the next available free block, which can be implemented in different
    ways other than the provided here. To answer the question of which implementation
    is optimal is that it *depends* and needs to be measured in practice. Now, let
    us first look at the `allocate()` method where, again, we use variadic template
    arguments to allow arbitrary arguments to be forwarded to the constructor of `T`.
    Note that here we use the `placement new` operator to construct an object of type
    `T` with the given arguments from the memory block. Remember that `new` is an
    operator that can also be overridden if needed, and the `placement new` operator
    skips the step that allocates memory and uses the provided memory block instead:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二件事，这更多的是我们根据应用程序进行的设计选择，那就是我们调用 `updateNextFreeIndex()` 来更新 `next_free_index_`
    指向下一个可用的空闲块，这可以通过除了这里提供的方式以外的不同方式实现。要回答哪种实现是最佳的，那就是它 *取决于* 并需要在实践中进行测量。现在，让我们首先看看
    `allocate()` 方法，在这里，我们再次使用变长模板参数来允许将任意参数转发到 `T` 的构造函数。请注意，在这里我们使用 `placement new`
    操作符从内存块中构造具有给定参数的 `T` 类型的对象。记住，`new` 是一个可以如果需要被覆盖的操作符，而 `placement new` 操作符跳过了分配内存的步骤，而是使用提供的内存块：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let us look at the `updateNextFreeIndex()` method next. There are two things
    to note here – first, we have a branch for a case where the index wraps around
    the end. While this adds an `if` condition here, with the `UNLIKELY()` specification
    and the expectation of our hardware branch predictor to always predict that the
    branch isn’t taken, this should not hurt our performance in a meaningful way.
    We can, of course, break up the loop into two loops and remove that `if` condition
    if we really want to – that is, the first loop loops till `next_free_index_ ==
    store_.size()`, and the second loop loops from 0 onwards.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 `updateNextFreeIndex()` 方法。这里有两个需要注意的地方——首先，我们有一个分支用于处理索引绕到末尾的情况。虽然这在这里添加了一个
    `if` 条件，但有了 `UNLIKELY()` 规范和我们对硬件分支预测器的预期，即总是预测该分支不会被取，这不应该以有意义的方式损害我们的性能。当然，如果我们真的想的话，我们可以将循环分成两个循环并移除那个
    `if` 条件——也就是说，第一个循环一直循环到 `next_free_index_ == store_.size()`，第二个循环从 0 开始：
- en: 'Secondly, we added a check to detect and fail if there is ever a case where
    the memory pool is completely full. There are obviously better ways to handle
    this in practice that do not involve failures, but for the sake of brevity and
    to stay within the scope of this book, we will just fail when this happens for
    now:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们添加了一个检查来检测内存池完全满的情况，并在这种情况下失败。显然，在实践中有更好的处理方式，不需要失败，但为了简洁和保持在本书的范围内，我们现在将只在这种情况下失败：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The next section deals with handling deallocations or returning objects of type
    `T` back to the memory pool to reclaim them as free.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将处理处理释放或返回类型为 `T` 的对象回内存池以回收它们作为空闲资源的情况。
- en: Handling deallocations
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理释放
- en: 'Deallocations are a simple matter of finding the correct `ObjectBlock` in our
    internal `store_` that corresponds to the `T` object being deallocated and marking
    the `is_free_` marker for that block to be `true`. Here, we use `reinterpret_cast`
    to convert `T*` to `ObjectBlock*`, which is OK to do, since object `T` is the
    first member in `ObjectBlock`. This should now explain the assertion we added
    to the constructor in the *Initializing the memory pool* section. We also add
    an assertion here to make sure that the element that the user tries to deallocate
    belongs to this memory pool. Again, there can be more graceful handling of such
    error cases, but we will leave that up to you for the sake of brevity and to keep
    the discussion within the scope of this book:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 释放是一个简单的问题，就是找到我们内部 `store_` 中的正确 `ObjectBlock`，它与正在释放的 `T` 对象相对应，并将该块的 `is_free_`
    标记设置为 `true`。在这里，我们使用 `reinterpret_cast` 将 `T*` 转换为 `ObjectBlock*`，这是可以做的，因为对象
    `T` 是 `ObjectBlock` 的第一个成员。这应该现在解释了我们在 *初始化内存池* 部分中添加的断言。我们也在这里添加了一个断言，以确保用户尝试释放的元素属于这个内存池。当然，可以更优雅地处理这样的错误情况，但为了简洁和保持讨论在本书的范围内，我们将把这个留给你：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That concludes our design and implementation of memory pools. Let us look at
    a simple example.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对内存池的设计和实现。让我们来看一个简单的例子。
- en: Using the memory pool with an example
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用示例使用内存池
- en: 'Let us look at a simple and self-explanatory example of the memory pool we
    just created. This code is in the `Chapter4/mem_pool_example.cpp` file and can
    be built using the `CMake` file, as previously mentioned. It creates a memory
    pool of a primitive `double` type and another of a custom `MyStruct` type. Then,
    it allocates and deallocates some elements from this memory pool and prints out
    the values and memory locations:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们刚刚创建的内存池的一个简单且易于理解的示例。此代码位于`Chapter4/mem_pool_example.cpp`文件中，可以使用之前提到的`CMake`文件构建。它创建了一个原始`double`类型的内存池和另一个自定义`MyStruct`类型的内存池。然后，它从这个内存池中分配和释放一些元素，并打印出值和内存位置：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running this example using the following command should produce output similar
    to what is shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行此示例应产生与此处所示类似的输出：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the next section, we will build a very similar component – lock-free queues.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将构建一个非常类似的功能——无锁队列。
- en: Transferring data using lock-free queues
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用无锁队列传输数据
- en: In the *C++ threading for multi-threaded low latency applications* section,
    we hinted that one possible application of having multiple threads is to set up
    a pipelined system. Here, one component thread performs part of the processing
    and forwards the results to the next stage of the pipeline for further processing.
    We will be using such a design in our electronic trading system, but there’ll
    be more on that later.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在*多线程低延迟应用的C++线程*部分，我们暗示了拥有多个线程的一个可能应用是设置一个流水线系统。在这里，一个组件线程执行部分处理并将结果转发到流水线的下一阶段进行进一步处理。我们将在我们的电子交易系统中使用这种设计，但关于这一点，后面还会详细介绍。
- en: Communicating between threads and processes
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程和进程之间的通信
- en: There are a lot of options when it comes to transferring data between processes
    and/or threads. **Inter-Process Communication** (**IPC**), such as mutexes, semaphores,
    signals, memory-mapped files, and shared memory, can be used for these purposes.
    It also gets tricky when there is concurrent access to shared data and the important
    requirement is to avoid data corruption. Another important requirement is to make
    sure that the reader and writer have consistent views of the shared data. To transfer
    information from one thread to another (or from one process to another), the optimal
    way to do so is through a data queue that both threads have access to. Building
    a queue of data and using locks to synchronize in a concurrent access environment
    is an option here. Due to the concurrent access nature of this design, locks or
    mutexes or something similar has to be used to prevent errors. However, locks
    and mutexes are extremely inefficient and lead to context switches, which degrade
    performance tremendously for critical threads. So, what we need is a lock-free
    queue to facilitate communication between threads without the overhead of locks
    and context switches. Note that the lock-free queue we will build here is only
    to be used for **Single Producer Single Consumer** (**SPSC**) – that is, only
    one thread writes to the queue and only one thread consumes from the queue. More
    complex use cases for lock-free queues will require additional complexity, which
    is out of the scope of this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程和/或线程之间传输数据时有很多选项。**进程间通信**（**IPC**），例如互斥锁、信号量、信号、内存映射文件和共享内存，可以用于这些目的。当存在对共享数据的并发访问并且重要要求是避免数据损坏时，这也会变得复杂。另一个重要要求是确保读取器和写入者对共享数据有一致的视图。要从一个线程传输信息到另一个线程（或从一个进程传输到另一个进程），最佳方式是通过一个两个线程都可以访问的数据队列。在并发访问环境中构建数据队列并使用锁来同步是一个选项。由于这种设计具有并发访问的性质，因此必须使用锁或互斥锁或类似的东西来防止错误。然而，锁和互斥锁非常低效，会导致上下文切换，这会极大地降低关键线程的性能。因此，我们需要一个无锁队列来促进线程之间的通信，而不需要锁和上下文切换的开销。请注意，我们在这里构建的无锁队列仅用于**单生产者单消费者**（**SPSC**）——也就是说，只有一个线程向队列写入，只有一个线程从队列中消费。更复杂的无锁队列用例将需要额外的复杂性，这超出了本书的范围。
- en: Designing lock-free queue storage
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计无锁队列存储
- en: For lock-free queues, we again have the option of either having the storage
    allocated on the stack or the heap. Here, we will again choose `std::vector` and
    allocate memory on the heap. Additionally, we create two `std::atomic` variables
    – one called `next_write_index_` – to track what index the next write to the queue
    will go to.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无锁队列，我们再次有选择在栈上或堆上分配存储的选项。在这里，我们再次选择`std::vector`并在堆上分配内存。此外，我们创建两个`std::atomic`变量——一个称为`next_write_index_`——来跟踪下一个写入队列的索引。
- en: The second variable, called `next_read_index_`, is used to track what index
    the next unread element in the queue is located in. The implementation is relatively
    straightforward because of our assumption that a single thread writes to the queue
    and a single thread reads from it. Now, let us first design and implement the
    internal storage of the lock-free queue data structure. The source code discussed
    in this section can be found in the `Chapter4/lf_queue.h` source file in the GitHub
    repository for this book.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变量，称为`next_read_index_`，用于跟踪队列中下一个未读元素的位置。由于我们假设只有一个线程向队列写入，只有一个线程从队列读取，因此实现相对简单。现在，让我们首先设计和实现无锁队列数据结构的内部存储。本节讨论的源代码可以在本书GitHub仓库的`Chapter4/lf_queue.h`源文件中找到。
- en: A quick word on `std::atomic` – it is a modern C++ construct that allows thread-safe
    operations. It lets us read, update, and write variables on a shared variable
    without using locks or mutexes, and it does so while preserving the order of operations.
    A detailed discussion of `std::atomic` and memory ordering is outside the scope
    of this book, but you can find a reference in our other book *Developing High-Frequency*
    *Trading Systems*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`std::atomic`的简要说明——它是一种现代C++构造，允许线程安全的操作。它让我们可以在不使用锁或互斥锁的情况下读取、更新和写入共享变量，并且在保持操作顺序的同时完成这些操作。关于`std::atomic`和内存排序的详细讨论超出了本书的范围，但您可以在我们另一本书《开发高频交易系统》中找到参考资料。
- en: 'First, let us define the data members for this class in the following code
    snippet:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在以下代码片段中定义这个类的数据成员：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This class holds a `std::vector` object `store_` of a `T` template object type,
    which is the actual queue of data. A `std::atomic<size_t> next_write_index_` variable
    tracks the index in this vector, where the next element will be written to. Similarly,
    a `std::atomic<size_t> next_read_index_` variable tracks the index in this vector,
    where the next element to be read or consumed is available. These need to be the
    `std::atomic<>` type, since the reading and writing operations are performed from
    different threads.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含一个`std::vector`对象`store_`，它是一个`T`模板对象类型的实际数据队列。一个`std::atomic<size_t> next_write_index_`变量跟踪这个向量中的索引，下一个元素将被写入的位置。同样，一个`std::atomic<size_t>
    next_read_index_`变量跟踪这个向量中的索引，下一个要读取或消费的元素可用的位置。这些变量需要是`std::atomic<>`类型，因为读写操作是从不同的线程执行的。
- en: Initializing the lock-free queue
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化无锁队列
- en: 'The constructor for our lock-free queue is very similar to the constructor
    of the memory pool we saw earlier. We dynamically allocate the memory for the
    entire vector in the constructor. We can extend this design to allow the lock-free
    queue to be resized at runtime, but for now, we will stick to a fixed-size queue:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的无锁队列构造函数与之前看到的内存池构造函数非常相似。我们在构造函数中动态分配整个向量的内存。我们可以扩展这个设计，允许无锁队列在运行时调整大小，但到目前为止，我们将坚持使用固定大小的队列：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We have similar boilerplate code here with regards to the default constructor,
    copy and move constructors, and assignment operators. These are deleted for the
    reasons we discussed before:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有关于默认构造函数、拷贝构造函数和移动构造函数以及赋值运算符的类似样板代码。这些代码被删除的原因是我们之前讨论过的：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, we will look at the code to add new elements to the queue.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看添加新元素到队列的代码。
- en: Adding elements to the queue
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向队列中添加元素
- en: 'The code to add new elements to the queue is implemented in two parts; the
    first part, `getNextToWriteTo()`, returns a pointer to the next element to write
    new data to. The second part, `updateWriteIndex()`, increments the write index,
    `next_write_index_`, once the element has been written to the slot provided. We
    designed it in such a way that, instead of having a single `write()` function,
    we provide the user with a pointer to the element and if the objects are quite
    large then not all of it needs to be updated or overwritten. Additionally, this
    design makes it much easier to deal with race conditions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 向队列中添加新元素的代码分为两部分；第一部分，`getNextToWriteTo()`，返回一个指向下一个要写入新数据的元素的指针。第二部分，`updateWriteIndex()`，在元素被写入提供的槽位后，增加写索引`next_write_index_`。我们设计它是这样的，而不是只有一个`write()`函数，我们提供给用户一个指向元素的指针，如果对象相当大，那么不需要更新或覆盖所有内容。此外，这种设计使得处理竞争条件变得容易得多：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the next section, we will use a very similar design to consume elements from
    the queue.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用一个非常类似的设计来消费队列中的元素。
- en: Consuming elements from the queue
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从队列中消费元素
- en: 'To consume elements from the queue, we do the opposite of what we did to add
    elements to the queue. Like the design we have where we split `write()` into two
    parts, we will have two parts to consume an element from the queue. We have a
    `getNextToRead()` method that returns a pointer to the next element to be consumed
    but does not update the read index. This method will return `nullptr` if there
    is no element to be consumed. The second part, `updateReadIndex()`, just updates
    the read index after the element is consumed:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要从队列中消费元素，我们做的是向队列中添加元素的反操作。就像我们设计的那样，将`write()`分成两部分，我们将消费队列中的元素也分成两部分。我们有一个`getNextToRead()`方法，它返回要消费的下一个元素的指针，但不更新读取索引。如果没有任何元素要消费，此方法将返回`nullptr`。第二部分是`updateReadIndex()`，它在元素被消费后仅更新读取索引：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We also define another simple method to return the number of elements in the
    queue:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了另一种简单的方法来返回队列中的元素数量：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: wThis finishes our design and implementation of lock-free queues for the SPSC
    use case. Let us look at an example that uses this component in the next sub-section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了针对SPSC用例的无锁队列的设计和实现。让我们在下一小节中看看一个使用此组件的示例。
- en: Using the lock-free queue
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用无锁队列
- en: 'This example of how to use the lock-free data queue can be found in the `Chapter4/lf_queue_example.cpp`
    file and built as previously mentioned. This example creates a consumer thread
    and provides it with a lock-free queue instance. The producer then generates and
    adds some elements to that queue, and the consumer thread checks the queue and
    consumes the queue elements till the queue is empty. Both threads of execution
    – producer and consumer – wait for short periods of time between generating an
    element and consuming it:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用无锁数据队列的示例可以在`Chapter4/lf_queue_example.cpp`文件中找到，并按照之前提到的方式进行构建。此示例创建了一个消费者线程，并向它提供了一个无锁队列实例。然后，生产者生成并添加一些元素到该队列中，消费者线程检查队列并消费队列元素，直到队列为空。执行的两个线程——生产者和消费者——在生成一个元素和消费它之间等待很短的时间：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of running this example program is provided as follows, which is
    just the producer and the consumer writing to and reading from the lock-free queue:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例程序的输出如下，其中仅包括生产者和消费者对无锁队列的写入和读取操作：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, we will build a low latency logging framework using some of the components
    we just built – threads and lock-free queues.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用我们刚刚构建的一些组件——线程和无锁队列——构建一个低延迟日志框架。
- en: Building a low latency logging framework
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建低延迟日志框架
- en: Now, we will build a low latency logging framework using some of the components
    we just built in the previous sections. Logging is an important part of any application,
    whether it is logging general application behavior, warnings, errors, or even
    performance statistics. However, a lot of important logging output is actually
    from performance-critical components that are on a critical path.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用之前几节中构建的一些组件构建一个低延迟日志框架。日志是任何应用程序的重要组成部分，无论是记录一般的应用行为、警告、错误，甚至是性能统计信息。然而，许多重要的日志输出实际上来自性能关键组件，这些组件位于关键路径上。
- en: A naïve logging approach would be to output to the screen, while a slightly
    better approach would be for logs to be saved to one or more log files. However,
    here we have a few problems – disk I/O is extremely slow and unpredictable, and
    string operations and formatting themselves are slow. For these reasons, performing
    these operations on a performance-critical thread is a terrible idea, so we will
    build a solution in this section to alleviate the downsides while preserving the
    ability to output logs as needed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的日志方法是将输出到屏幕，而一种稍微好一点的方法是将日志保存到一个或多个日志文件中。然而，这里我们有一些问题——磁盘I/O非常慢且不可预测，字符串操作和格式化本身也很慢。出于这些原因，在性能关键线程上执行这些操作是一个糟糕的想法，因此在本节中，我们将构建一个解决方案来减轻这些缺点，同时保留按需输出日志的能力。
- en: Before we jump into the logger class, we will define a few utility methods to
    fetch the current system time as well as convert them to strings for logging purposes.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳入日志类之前，我们将定义一些实用方法来获取当前系统时间以及将它们转换为字符串以供日志记录使用。
- en: Designing utility methods for time
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计时间相关的实用方法
- en: 'We will define a simple utility function to fetch the current system time and
    some constants to make conversions from different units easier. The code for the
    time utilities can be found in `Chapter4/time_utils.h` in the GitHub repository
    for this book:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个简单的实用函数来获取当前系统时间以及一些常数，以便于不同单位之间的转换。时间实用函数的代码可以在本书GitHub仓库的`Chapter4/time_utils.h`中找到：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, let us design the logger class itself, starting with the next section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设计日志类本身，从下一节开始。
- en: Designing the low latency logger
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计低延迟日志
- en: To build this low latency logging framework, we will create a background logging
    thread whose only task is to write log lines to a log file on disk. The idea here
    is to offload the slow disk I/O operations as well as the string formatting operations
    away from the main performance-critical thread onto this background thread. One
    thing to understand is that logging to disk does not have to be instantaneous
    – that is, most systems can tolerate some delay between an event happening and
    information pertinent to that event being logged to disk. We will use the multi-threading
    function we created in the first section of this chapter to create this logger
    thread and assign it the task of writing to the log file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这个低延迟日志框架，我们将创建一个后台日志线程，其唯一任务是向磁盘上的日志文件写入日志行。这里的想法是将慢速磁盘I/O操作以及字符串格式化操作从主性能关键线程卸载到这个后台线程。有一点需要理解的是，将日志写入磁盘不必是瞬时的——也就是说，大多数系统可以容忍事件发生和相关信息被写入磁盘之间的某些延迟。我们将使用本章第一部分创建的多线程函数来创建这个日志线程，并分配给它的任务是写入日志文件。
- en: To publish data that needs to be logged from the main performance-critical thread
    to this logging thread, we will use the lock-free data queue we created in the
    previous section. The way the logger will work is that instead of writing information
    directly to the disk, the performance-sensitive threads will simply push the information
    to this lock-free queue. As we discussed before, a logger thread will consume
    from the other end of this queue and write to the disk. The source code for this
    component is available in the `logging.h` and `logging.cpp` files in the `Chapter4`
    directory in the GitHub repository for this book.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从主性能关键线程将需要记录的数据发布到这个日志线程，我们将使用我们在上一节中创建的无锁数据队列。日志的工作方式是，性能敏感的线程不会直接将信息写入磁盘，而是简单地将信息推送到这个无锁队列。正如我们之前讨论的，日志线程将从这个队列的另一端消费并写入磁盘。这个组件的源代码可以在本书GitHub仓库的`Chapter4`目录下的`logging.h`和`logging.cpp`文件中找到。
- en: Defining some logger structures
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一些日志结构
- en: 'Before we start designing the logger itself, we will first define the basic
    block of information that will be transferred across the lock-free queue from
    the performance-sensitive thread to the logger thread. In this design, we simply
    create a structure capable of holding the different types that we will log. First,
    let us define an enumeration that specifies the type of value the structure it
    is pointing to; we will call this enumeration `LogType`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始设计日志本身之前，我们将首先定义将跨无锁队列从性能敏感线程传输到日志线程的基本信息块。在这个设计中，我们简单地创建一个能够保存我们将要记录的不同类型的结构。首先，让我们定义一个枚举，它指定了指向的结构所指向的值的类型；我们将把这个枚举称为`LogType`：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we can define the `LogElement` structure that will hold the next value
    to push to the queue and, eventually, write logs to the file from the logger thread.
    This structure contains a member of type `LogType` to specify the type of value
    it holds. The other member in this structure is a union of the different possible
    primitive types. This would have been a good place to use `std::variant`, since
    it is a type-safe union in modern C++ with the `LogType type_`, which specifies
    what the union contains) built into it. However, `std::variant` has worse runtime
    performance; hence, we choose to move forward with the old-style union here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义一个`LogElement`结构，它将保存要推送到队列的下一个值，并最终从日志线程将日志写入文件。这个结构包含一个类型为`LogType`的成员，用于指定它持有的值的类型。这个结构中的另一个成员是不同可能的基本类型的联合。这本来是使用`std::variant`的好地方，因为它是现代C++中内置了`LogType
    type_`（指定联合包含的内容）的类型安全的联合。然而，`std::variant`的运行时性能较差；因此，我们选择在这里继续使用旧式的联合：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With the definition of the `LogElement` structure out of the way, let us move
    on to defining data in the logger class.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`LogElement`结构之后，让我们继续定义日志类中的数据。
- en: Initializing the logger data structures
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化日志数据结构
- en: 'Our logger will contain a few important objects. Firstly, a `std::ofstream`
    file object is the log file that data is written to. Secondly, an `LFQueue<LogElement>`
    object is the lock-free queue to transfer data from the main thread to the logger
    thread. Next, `std::atomic<bool>` stops the logger thread’s processing when needed,
    and a `std::thread` object which is the logger thread. Finally, `std::string`
    is the filename, which we provide purely for informational purposes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的日志记录器将包含几个重要的对象。首先，一个`std::ofstream`文件对象是数据写入的日志文件。其次，一个`LFQueue<LogElement>`对象是用于从主线程向日志线程传输数据的无锁队列。接下来，`std::atomic<bool>`在需要时停止日志线程的处理，以及一个`std::thread`对象，即日志线程。最后，`std::string`是文件名，我们仅提供此信息：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, let us move on to constructing our logger, the logger queue, and the logger
    thread.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续构建我们的日志记录器、日志记录器队列和日志记录器线程。
- en: Creating the logger and launching the logger thread
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建日志记录器和启动日志记录线程
- en: 'In the logger constructor, we will initialize the logger queue with an appropriate
    size, save `file_name_` for informational purposes, open the output log file object,
    and create and launch the logger thread. Note that here we will exit if we are
    unable to open the output log file or unable to create and launch the logger thread.
    As we’ve mentioned before, there are obviously more forgiving and more graceful
    ways to handle these failures, but we will not explore those in this book. Note
    here that we set the `core_id` parameter in `createAndStartThread()` to –1, to
    not set affinity on the thread right now. We will revisit the design of how to
    assign each thread to a CPU core later in the book once we understand the design
    of the full ecosystem, and we will tune it for performance:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志记录器构造函数中，我们将使用适当的大小初始化日志记录器队列，保存`file_name_`用于信息目的，打开输出日志文件对象，并创建和启动日志记录线程。请注意，如果我们无法打开输出日志文件或无法创建和启动日志记录线程，我们将退出。正如我们之前提到的，显然有更多宽容和优雅的方式来处理这些失败，但我们将不会在本书中探讨这些方法。请注意，在这里我们将`createAndStartThread()`中的`core_id`参数设置为-1，以当前不设置线程的亲和性。一旦我们理解了整个生态系统的设计，我们将在本书的后面部分重新审视如何将每个线程分配给CPU核心的设计，并将对其进行性能调优：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We pass a method called `flushQueue()` that this logger thread will run. As
    the name suggests, and in line with what we discussed, this thread will empty
    the queue of log data and write the data to the file; we will look at that next.
    The implementation of `flushQueue()` is simple. If the atomic `running_` Boolean
    is `true`, it runs in a loop, performing the following steps: it consumes any
    new elements pushed to the lock-free queue, `queue_`, and writes them to the `file_`
    object we created. It unpacks the `LogElement` objects in the queue and writes
    the correct member of the union to the file, depending on the type. The thread
    sleeps for a millisecond when the lock-free queue is empty and then checks again
    to see whether there are new elements to be written to disk:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递一个名为`flushQueue()`的方法，这个日志记录线程将运行。正如其名所示，并且与我们之前讨论的一致，这个线程将清空日志数据的队列并将数据写入文件；我们将在下一节中查看。`flushQueue()`的实现很简单。如果原子的`running_`布尔值为`true`，它将在循环中运行，执行以下步骤：它消费任何推送到无锁队列`queue_`的新元素，并将它们写入我们创建的`file_`对象。它解包队列中的`LogElement`对象，并根据类型将联合的正确成员写入文件。当无锁队列为空时，线程将休眠一毫秒，然后再次检查是否有新的元素要写入磁盘：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The destructor for our logger class is important, so let us look at what cleanup
    tasks it needs to perform. First, the destructor waits for the lock-free queue
    to be consumed by the logger thread, so it waits till it is empty. Once it is
    empty, it sets the `running_` flag to be `false` so that the logger thread can
    finish its execution. To wait for the logger thread to finish execution – that
    is, return from the `flushQueue()` method, it calls the `std::thread::join()`
    method on the logger thread. Finally, it closes the `file_` object, which writes
    any buffered data onto the disk, and then we are done:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们日志记录器类的析构函数很重要，因此让我们看看它需要执行哪些清理任务。首先，析构函数等待日志线程消耗无锁队列，因此它等待直到队列为空。一旦队列为空，它将`running_`标志设置为`false`，以便日志线程可以完成其执行。为了等待日志线程完成执行——即从`flushQueue()`方法返回，它调用日志线程上的`std::thread::join()`方法。最后，它关闭`file_`对象，将任何缓冲数据写入磁盘，然后我们完成：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we will add the usual boilerplate code we discussed multiple times
    before regarding the constructors and assignment operators:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加之前多次讨论的关于构造函数和赋值运算符的常规样板代码：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this section, we saw the portion of the component that consumes from the
    queue and writes it to disk. In the next section, we will see how data gets added
    to the lock-free queue as part of the logging process from the performance-critical
    thread.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了组件从队列中读取并写入磁盘的部分。在下一节中，我们将看到数据如何作为性能关键线程的日志过程的一部分添加到无锁队列中。
- en: Pushing data to the logger queue
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据推送到日志队列
- en: To push data to the logger queue, we will define a couple of overloaded `pushValue()`
    methods that handle different types of arguments. Each method does the same thing,
    which is to push values one by one onto the queue. One thing worthy of note here
    is that there are more efficient implementations for what we are about to discuss;
    however, they involve additional complexity, and we left them out for the sake
    of brevity and to limit the scope of what we can cover in this book. We will point
    out the areas of potential improvement when we discuss them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据推送到日志队列，我们将定义几个重载的 `pushValue()` 方法来处理不同类型的参数。每个方法都做同样的事情，即逐个将值推送到队列中。这里值得注意的一点是，对于我们将要讨论的内容，存在更有效的实现；然而，它们涉及额外的复杂性，我们为了简洁和限制本书的覆盖范围而省略了它们。当我们讨论它们时，我们将指出潜在的改进区域。
- en: 'First, we create a variant of `pushValue()` to push objects of type `LogElement`,
    which will get called from the other `pushValue()` functions we will define shortly.
    It basically writes to the next location in the lock-free queue and increments
    the write index:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个 `pushValue()` 的变体来推送类型为 `LogElement` 的对象，它将从我们即将定义的其他 `pushValue()`
    函数中被调用。它基本上写入无锁队列的下一个位置并增加写索引：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The next simple variant of `pushValue()` is for a single char value, which
    basically just creates an object of type `LogElement`, calls the `pushValue()`
    method we just discussed, and passes the `LogElement` object:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushValue()` 的下一个简单变体是针对单个字符值，它基本上只是创建一个类型为 `LogElement` 的对象，调用我们刚才讨论的 `pushValue()`
    方法，并将 `LogElement` 对象传递给它：'
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we create a variant of `pushValue()` for `const char*` – that is, a collection
    of chars. This implementation loops through the characters one at a time and calls
    the `pushValue()` we implemented previously. This is an area of potential improvement,
    where we could use a single `memcpy()` to copy over all the characters in the
    array instead of looping through them. There are some edge cases we would need
    to handle around the wrapping of the indices at the end of the queue, but we will
    leave it up to you to explore further:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为 `const char*` 创建 `pushValue()` 的一个变体——即字符集合。这个实现逐个遍历字符并调用我们之前实现的 `pushValue()`。这是一个潜在的改进区域，我们可以使用单个
    `memcpy()` 来复制数组中的所有字符，而不是逐个遍历它们。我们还需要处理队列末尾索引环绕的一些边缘情况，但我们将把它留给您进一步探索：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we create another variant of `pushValue()` for `const std::string&`,
    which is quite straightforward and uses `pushValue()`, which we created previously:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为 `const std::string&` 创建 `pushValue()` 的另一个变体，这相当直接，并使用我们之前创建的 `pushValue()`：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we need to add variants of `pushValue()` for the different primitive
    types. They are very similar to the one we built for a single char value and are
    shown here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为不同的原始类型添加 `pushValue()` 的变体。它们与我们为单个字符值构建的非常相似，如下所示：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: At this point, we have achieved two goals – moved the disk output operation
    to the background logger thread and moved the task of formatting the primitive
    values into string format to the background thread. Next, we will add functionality
    for the performance-sensitive thread to use to push data to the lock-free queue,
    using the `pushValue()` methods we just built.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了两个目标——将磁盘输出操作移动到后台日志线程，并将将原始值格式化为字符串格式的任务移动到后台线程。接下来，我们将添加性能敏感线程使用
    `pushValue()` 方法将数据推送到无锁队列的功能。
- en: Adding a useful and generic log function
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个有用且通用的日志函数
- en: 'We will define a `log()` method, which is very similar to the `printf()` function
    but slightly simpler. It is simpler in the sense that the format specifier is
    just a `%` character that is used to substitute all the different primitive types.
    This method uses variadic template arguments to support an arbitrary number and
    types of arguments. It looks for the `%` character and then substitutes the next
    value in its place, calling one of the overloaded `pushValue()` methods we defined
    in the last section. After that, it calls itself recursively, except this time,
    the value points to the first argument in the template parameter pack:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个`log()`方法，它与`printf()`函数非常相似，但稍微简单一些。它之所以简单，是因为格式说明符只是一个用于替换所有不同原始类型的`%`字符。此方法使用变长模板参数来支持任意数量和类型的参数。它寻找`%`字符，然后在其位置替换下一个值，调用我们在上一节中定义的其中一个重载的`pushValue()`方法。之后，它递归地调用自身，但这次，值指向模板参数包中的第一个参数：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This method is meant to be called using something like this example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法应使用类似以下示例的方式进行调用：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `log()` method we built here cannot handle a case where there are no arguments
    passed to it. Therefore, we need an extra overloaded `log()` method to handle
    the case, where a simple `const char *` is passed to it. We add an extra check
    here to make sure that extra arguments were not passed to this method or the aforementioned
    `log()` method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里构建的`log()`方法无法处理没有传递参数给它的情况。因此，我们需要一个额外的重载`log()`方法来处理将简单的`const char *`传递给它的情况。我们在这里添加了一个额外的检查，以确保没有将额外的参数传递给此方法或上述`log()`方法：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This finishes the design and implementation of our low latency logging framework.
    Using our multi-threading routine and our lock-free queue, we created a framework
    where the performance-critical thread offloads the string formatting and disk
    file write tasks to the background logger thread. Now, let us look at a good example
    of how to create, configure, and use the logger we just created.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们低延迟日志框架的设计和实现。使用我们的多线程例程和无锁队列，我们创建了一个框架，其中性能关键线程将字符串格式化和磁盘文件写入任务卸载到后台记录器线程。现在，让我们看看如何创建、配置和使用我们刚刚创建的记录器的一个好例子。
- en: Learning how to use the logger with an example
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用示例学习如何使用记录器
- en: 'We will present a basic example that creates a `Logger` object and configures
    it to write the logs to `logging_example.log`. Then, it logs a few different data
    types to the file through the logger. This source for this can be found in the
    `Chapter4/logging_example.cpp` file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供一个基本示例，创建一个`Logger`对象，并将其配置为将日志写入`logging_example.log`文件。然后，通过记录器将该文件中记录了几种不同的数据类型。此示例的源代码可以在`Chapter4/logging_example.cpp`文件中找到：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output of running this can be viewed by outputting the contents of the
    `logging_example.log` file in the current directory, as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码的输出可以通过查看当前目录下`logging_example.log`文件的 内容来查看，如下所示：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this framework, the only overhead that a call to `log()` invokes is the overhead
    of iterating through the characters in the string and pushing the characters and
    values onto the lock-free queue. Now, we will move our discussion to network programming
    and the use of sockets, which we will be using later on to facilitate communication
    between different processes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在此框架中，调用`log()`方法产生的唯一开销是遍历字符串中的字符并将字符和值推送到无锁队列的开销。现在，我们将讨论网络编程和套接字的使用，我们将在以后使用它们来促进不同进程之间的通信。
- en: C++ network programming using sockets
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用套接字进行C++网络编程
- en: In this final section, we will build the last of our basic building blocks –
    a framework to handle network programming using Unix sockets. We will use this
    framework to build a server that listens for incoming TCP connections and a client
    that is capable of establishing a TCP connection to such a server. We will also
    use this framework to publish UDP traffic and consume from a stream of multicast
    traffic. Note that to limit the scope of this discussion, we will only discuss
    Unix sockets without any kernel bypass capabilities. Using kernel bypass and leveraging
    the kernel bypass API provided by the **Network Interface Cards** (**NICs**) that
    support it is outside the scope of this book. Note also that we expect you to
    have some basic knowledge or experience with network sockets and, ideally, programming
    network sockets in C++.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，我们将构建我们基本构建块中的最后一个——一个使用Unix套接字进行网络编程的框架。我们将使用这个框架来构建一个监听传入TCP连接的服务器和一个能够与这样的服务器建立TCP连接的客户端。我们还将使用这个框架来发布UDP流量并从多播流中消费。请注意，为了限制讨论的范围，我们只将讨论Unix套接字，而不涉及任何内核绕过能力。使用内核绕过并利用支持它的**网络接口卡**（**NICs**）提供的内核绕过API超出了本书的范围。另外，我们期望你有一些基本的网络套接字知识或经验，理想情况下，使用C++编程网络套接字。
- en: Building a basic socket API
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建基本的套接字API
- en: 'Our goal here is to create a mechanism to create a network socket and initialize
    it with the correct parameters. This method will be used to create listener, receiver,
    and sender sockets to communicate over UDP and TCP protocols. Before we jump into
    the routine that creates the socket itself, let us first define a bunch of utility
    methods that we will use in our final method. All the code for the basic socket
    API is in `Chapter4/socket_utils.cpp` in the GitHub repository for this book.
    Note that before we investigate the implementation of the functionality, we will
    present the `Chapter4/socket_utils.h` header file, which contains all the `include`
    files and function signatures we will implement:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们的目标是创建一个机制来创建网络套接字，并用正确的参数初始化它。这个方法将被用来创建监听器、接收器和发送器套接字，以通过UDP和TCP协议进行通信。在我们深入到创建套接字本身的例程之前，让我们首先定义一些我们将要在最终方法中使用到的实用方法。所有基本套接字API的代码都位于GitHub仓库中这本书的`Chapter4/socket_utils.cpp`文件中。注意，在我们调查功能实现之前，我们将展示`Chapter4/socket_utils.h`头文件，它包含了我们将要实现的全部`include`文件和函数签名：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, let us start with the implementation of these methods, starting with the
    next section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从这些方法的实现开始，从下一节开始。
- en: Getting interface information
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取接口信息
- en: 'The first utility method we need to build is to convert network interfaces
    represented in string form to a form that can be used by the lower-level socket
    routines we will use. We call this `getIfaceIP()`, and we will need this when
    we specify what network interfaces to listen to, connect from, or send through.
    We use the `getifaddrs()` method to fetch information about all the interfaces,
    which returns a linked list structure, `ifaddrs`, containing this information.
    Finally, it uses the `getnameinfo()` information to get the final name to be used
    with the rest of the methods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建的第一个实用方法是转换以字符串形式表示的网络接口，使其能够被我们将要使用的底层套接字例程使用。我们称之为`getIfaceIP()`，当我们指定要监听、连接或通过的网络接口时，我们将需要这个方法。我们使用`getifaddrs()`方法来获取所有接口的信息，它返回一个包含这些信息的链表结构，`ifaddrs`。最后，它使用`getnameinfo()`信息来获取其余方法中要使用的最终名称：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For instance, on my system with the following network interfaces, we have the
    following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我的系统中，以下网络接口如下所示：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`getIfaceIP` (`"lo"`) returns `127.0.0.1`, and `getIfaceIP` (`"wlp4s0"`) returns
    `192.168.10.104`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`getIfaceIP` (`"lo"`) 返回 `127.0.0.1`，而 `getIfaceIP` (`"wlp4s0"`) 返回 `192.168.10.104`。'
- en: Next, we will move on to the next important utility function we need, and this
    one affects the performance of applications that need network sockets.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续到下一个重要的实用函数，这个函数会影响需要网络套接字的应用程序的性能。
- en: Setting sockets to be non-blocking
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将套接字设置为非阻塞模式
- en: The next utility function we will build is one that sets sockets as non-blocking.
    A blocking socket is one where a call that is read on it will block indefinitely
    till data is available. This is generally not a good design for extremely low
    latency applications for many reasons. One of the main reasons is that blocking
    sockets are implemented using switches between the user space and the kernel space,
    and that is highly inefficient. When the socket needs to be *woken up* or unblocked,
    there needs to be an interrupt, an interrupt handler, and so on from the kernel
    space to the user space to handle the event. Additionally, the performance-critical
    thread that gets blocked would incur context-switching costs, which, as already
    discussed, are detrimental to performance.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的下一个实用函数是设置套接字为非阻塞的。一个阻塞套接字是指在其上进行的读取调用将无限期地阻塞，直到有数据可用。由于许多原因，这通常不是极低延迟应用的理想设计。主要原因之一是阻塞套接字是通过用户空间和内核空间之间的切换实现的，这非常低效。当套接字需要被*唤醒*或解除阻塞时，需要从内核空间到用户空间进行中断、中断处理程序等操作来处理事件。此外，被阻塞的性能关键线程将产生上下文切换开销，正如已经讨论过的，这对性能有害。
- en: 'The following `setNonBlocking()` method uses the `fcntl()` routine with `F_GETFL`
    to first check a socket file descriptor, seeing whether it is already non-blocking.
    If it is not already non-blocking, then it uses the `fcntl()` routine again but
    this time with `F_SETFL` to add the non-blocking bit, which is set on the file
    descriptor. It returns `true` if the socket file descriptor was already non-blocking
    or the method was able to successfully make it non-blocking:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`setNonBlocking()`方法使用`fcntl()`例程与`F_GETFL`来首先检查套接字文件描述符，看它是否已经是非阻塞的。如果不是非阻塞的，那么它将再次使用`fcntl()`例程，但这次使用`F_SETFL`来添加非阻塞位，该位设置在文件描述符上。如果套接字文件描述符已经是非阻塞的或者该方法能够成功将其设置为非阻塞，则返回`true`：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Next, we will enable another important optimization for TCP sockets by disabling
    **Nagle’s algorithm**.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过禁用**Nagle算法**来启用TCP套接字的另一个重要优化。
- en: Disabling Nagle’s algorithm
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用Nagle算法
- en: Without diving into too many details, Nagle’s algorithm is used to improve buffering
    in TCP sockets and prevent overhead associated with guaranteeing reliability on
    the TCP socket. This is achieved by delaying some packets instead of sending them
    out immediately. For many applications, it is a good feature to have, but for
    low latency applications, disabling the latency associated with sending packets
    out is imperative.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入太多细节，Nagle算法用于改善TCP套接字的缓冲区，并防止与在TCP套接字上保证可靠性相关的开销。这是通过延迟一些数据包而不是立即发送它们来实现的。对于许多应用来说，这是一个很好的特性，但对于低延迟应用，禁发送数据包的延迟是必不可少的。
- en: 'Fortunately, disabling Nagle’s algorithm is a simple matter of setting a socket
    option, `TCP_NODELAY`, using the `setsockopt()` routine, as shown here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，禁用Nagle算法只需通过设置套接字选项`TCP_NODELAY`，使用`setsockopt()`例程即可，如下所示：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We will define a few more routines to set optional and/or additional functionality
    in the next section, before we finally implement the functionality to create a
    socket.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最终实现创建套接字的功能之前，我们将在下一节定义几个额外的例程来设置可选的和/或附加功能。
- en: Setting up additional parameters
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置附加参数
- en: 'First, we will define a simple method to check whether a socket operation would
    block or not. This is a simple check of the global `errno` error variable against
    two possible values, `EWOULDBLOCK` and `EINPROGRESS`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个简单的方法来检查套接字操作是否会阻塞。这是一个简单的检查全局`errno`错误变量与两个可能值`EWOULDBLOCK`和`EINPROGRESS`的对比：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we define a method to set the `IP_TTL` socket options for non-multicast
    sockets and `IP_MULTICAST_TTL` for multicast sockets, using the `setsockopt()`
    routine, as shown here:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个方法来设置非多播套接字的`IP_TTL`套接字选项和多播套接字的`IP_MULTICAST_TTL`，使用`setsockopt()`例程，如下所示：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we define one last method that will allow us to generate software
    timestamps when network packets hit the network socket. Note that if we had specialized
    hardware (NICs) that support hardware timestamping, we would enable and use those
    here. However, to limit the scope of this book, we will assume that you do not
    have any special hardware and can only set the `SO_TIMESTAMP` option, using the
    `setsockopt()` method, to enable software timestamping:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义最后一个方法，它将允许我们在网络数据包击中网络套接字时生成软件时间戳。注意，如果我们有支持硬件时间戳的特殊硬件（如NICs），我们将在这里启用并使用它们。然而，为了限制本书的范围，我们将假设您没有特殊硬件，只能使用`setsockopt()`方法设置`SO_TIMESTAMP`选项来启用软件时间戳：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This completes our discussion of socket-related utility functions, and now,
    we can move on to finally implementing the functionality to create generic Unix
    sockets.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对套接字相关实用函数的讨论，现在我们可以继续最终实现创建通用Unix套接字的功能。
- en: Creating the socket
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建套接字
- en: 'In the first section of the `createSocket()` method, we first check whether
    a non-empty `t_ip` has been provided, which represents the interface IP, such
    as `192.168.10.104`, and if not, we fetch one from the interface name provided
    using the `getIfaceIP()` method we built previously. We also need to populate
    the `addrinfo` struct, based on the arguments passed in, because we will need
    to pass it to the `getaddrinfo()` routine, which will return a linked list that
    will finally be used to build the actual socket. Note that in the `createSocket()`
    method, anytime we fail to create the socket or initialize it with the correct
    parameters, we return –1 to signify the failure:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createSocket()`方法的第一个部分，我们首先检查是否提供了一个非空的`t_ip`，它表示接口IP，例如`192.168.10.104`，如果没有，我们将使用之前构建的`getIfaceIP()`方法从提供的接口名称中获取一个。我们还需要根据传入的参数填充`addrinfo`结构，因为我们需要将其传递给`getaddrinfo()`例程，该例程将返回一个链表，最终将用于构建实际的套接字。注意，在`createSocket()`方法中，每次我们无法创建套接字或用正确的参数初始化它时，我们返回-1以表示失败：
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The next section then checks the parameters passed to the `createSocket()` method
    and uses all the methods we built previously to set the correct socket parameters
    as needed. Note that we use the `addrinfo *` result object returned from `getaddrinfo()`
    to create the socket through the `socket()` routine.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将检查传递给`createSocket()`方法的参数，并使用我们之前构建的所有方法来设置所需的正确套接字参数。注意，我们使用`getaddrinfo()`返回的`addrinfo
    *`结果对象通过`socket()`例程创建套接字。
- en: 'First, we make the actual function call to create the socket:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实际调用创建套接字的功能：
- en: '[PRE50]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Next, we set it to be non-blocking and disable Nagle’s algorithm using the
    methods we defined previously:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用之前定义的方法将其设置为非阻塞模式并禁用Nagle算法：
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we connect the socket to the target address if it is not a listening
    socket:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果套接字不是监听套接字，接下来我们将套接字连接到目标地址：
- en: '[PRE52]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, if we want to create a socket that listens for incoming connections,
    we set the correct parameters and bind the socket to a specific address that the
    client will try to connect to. We also need to call the `listen()` routine for
    such a socket configuration. Note that we reference a `MaxTCPServerBacklog` parameter
    here, which is defined as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们想创建一个监听传入连接的套接字，我们需要设置正确的参数并将套接字绑定到客户端尝试连接的特定地址。我们还需要为这种套接字配置调用`listen()`例程。注意，这里我们引用了一个`MaxTCPServerBacklog`参数，其定义如下：
- en: '[PRE53]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, let us look at the code to make the socket a listening socket:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将套接字设置为监听套接字：
- en: '[PRE54]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, we set the TTL value for the socket we just created and return the
    socket. We will also set the ability to fetch the data receipt timestamps from
    incoming packets using the `setSOTimestamp()` method we created before:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为刚刚创建的套接字设置TTL值并返回套接字。我们还将使用之前创建的`setSOTimestamp()`方法设置从传入数据包中获取数据接收时间戳的能力：
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now that we have discussed and implemented the details of our lower-level socket
    method, we can move on to the next section and build a slightly higher-level abstraction
    that builds on top of this method.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论并实现了我们低级套接字方法的细节，我们可以继续到下一节，构建一个稍微高级一点的抽象，它建立在上述方法之上。
- en: Implementing a sender/receiver TCP socket
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现发送/接收TCP套接字
- en: Now that we have finished our design and implementation of basic methods to
    create sockets and set different parameters on them, we can start using them.
    First, we will implement a `TCPSocket` structure that builds on top of the socket
    utilities we created in the previous section. `TCPSocket` can be used to both
    send and receive data, so it will be used both within TCP socket servers and clients.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了创建套接字和设置它们不同参数的基本方法的设计和实现，我们可以开始使用它们了。首先，我们将实现一个 `TCPSocket` 结构，它建立在上一节中创建的套接字工具之上。`TCPSocket`
    可以用于发送和接收数据，因此它将在 TCP 套接字服务器和客户端中都被使用。
- en: Defining the data members of the TCP socket
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 TCP 套接字的数据成员
- en: 'Let us jump into our implementation of the `TCPSocket` structure, starting
    with the data members we need. Since this socket will be used to send and receive
    data, we will create two buffers – one to store data to be sent out and one to
    store data that was just read in. We will also store the file descriptor corresponding
    to our TCP socket in the `fd_` variable. We also create two flags: one to track
    if the send socket is connected and another to check whether the receive socket
    is connected. We will also save a reference to a `Logger` object, purely for logging
    purposes. Finally, we will store a `std::function` object, which we will use to
    dispatch callbacks to components that want to read data from this socket when
    there is new data available to be consumed. The code for this section is in `Chapter4/tcp_socket.h`
    and `Chapter4/tcp_socket.cpp` in the GitHub repository for this book:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳入我们对 `TCPSocket` 结构的实现，从我们需要的数据成员开始。由于这个套接字将用于发送和接收数据，我们将创建两个缓冲区——一个用于存储要发送的数据，另一个用于存储刚刚读取的数据。我们还将把对应于我们的
    TCP 套接字的文件描述符存储在 `fd_` 变量中。我们还将创建两个标志：一个用于跟踪发送套接字是否已连接，另一个用于检查接收套接字是否已连接。我们还将保存一个
    `Logger` 对象的引用，纯粹是为了记录目的。最后，我们将存储一个 `std::function` 对象，我们将使用它来将回调分发给想要从该套接字读取数据的组件，当有新数据可供消费时。本节的代码位于本书
    GitHub 仓库的 `Chapter4/tcp_socket.h` 和 `Chapter4/tcp_socket.cpp` 中：
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We define a default receive callback we will use to initialize the `recv_callback_`
    data member. This method simply logs information that confirms that the callback
    was invoked:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个默认的接收回调，我们将使用它来初始化 `recv_callback_` 数据成员。这个方法只是记录确认回调被调用的信息：
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Next, let us look at the constructor for the `TCPSocket` structure.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `TCPSocket` 结构的构造函数。
- en: Constructing and destroying the TCP socket
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造和销毁 TCP 套接字
- en: 'For the constructor, we will create the `send_buffer_` and `rcv_buffer_` `char
    *` storage on the heap and assign the `defaultRecvCallback()` method to the `recv_callback_`
    member variable through a lambda method. Note that we set the socket’s receive
    and send buffers to be of size `TCPBufferSize`, as defined here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构造函数，我们将在堆上创建 `send_buffer_` 和 `rcv_buffer_` `char *` 存储空间，并通过 lambda 方法将
    `defaultRecvCallback()` 方法分配给 `recv_callback_` 成员变量。请注意，我们将套接字的接收和发送缓冲区的大小设置为
    `TCPBufferSize`，如此处定义：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We then create `destroy()` and a destructor to perform straightforward cleanup
    tasks. We will close the socket file descriptor and destroy the receive and send
    buffers we created in the constructor:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建 `destroy()` 和析构函数来执行直接的清理任务。我们将关闭套接字文件描述符，并销毁在构造函数中创建的接收和发送缓冲区：
- en: '[PRE59]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We define the boilerplate code we saw previously to prevent accidental or unintentional
    constructions, copies, or assignments:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了之前看到的样板代码，以防止意外的或非故意的构造、复制或赋值：
- en: '[PRE60]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Next, let us try to perform one key operation on this socket – establishing
    TCP connections.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试对这个套接字执行一个关键操作——建立 TCP 连接。
- en: Establishing TCP connections
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建立TCP连接
- en: 'For this structure, we will define a `connect()` method, which is basically
    what creates, initializes, and connects `TCPSocket`. We will use the `createSocket()`
    method we created in the previous section with the correct parameters to achieve
    this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个结构，我们将定义一个 `connect()` 方法，它基本上是创建、初始化和连接 `TCPSocket` 的过程。我们将使用上一节中创建的 `createSocket()`
    方法，并使用正确的参数来实现这一点：
- en: '[PRE61]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Next, we will move on to the next critical functionality in our socket – sending
    and receiving data.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将继续到我们套接字中的下一个关键功能——发送和接收数据。
- en: Sending and receiving data
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送和接收数据
- en: 'We mentioned in our discussion that when new data is available, the interested
    listener will be notified through the `recv_callback_` `std::function` mechanism.
    Therefore, we just need to provide a `send()` method for the users of this structure
    to send data out. Note that this `send()` method simply copies the provided data
    into the outgoing buffer, and the actual write to the wire will be done in the
    `sendAndRecv()` method we will see shortly:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在讨论中提到，当有新数据可用时，感兴趣的监听者将通过`recv_callback_` `std::function`机制得到通知。因此，我们只需要为这个结构的使用者提供一个`send()`方法来发送数据。请注意，这个`send()`方法只是简单地将提供的数据复制到输出缓冲区，而实际的写入操作将在我们即将看到的`sendAndRecv()`方法中完成：
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Finally, we have the most important method for the `TCPSocket` structure, `sendAndRecv()`,
    which reads available data into `rcv_buffer_`, increments the counters, and dispatches
    `recv_callback_` if there is some amount of data that was read. The second half
    of this method does the opposite – it tries to write out data in `send_buffer_`
    using the `send()` routine and updates the index tracker variables:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们拥有了`TCPSocket`结构体最重要的方法，即`sendAndRecv()`方法，它将可用的数据读取到`rcv_buffer_`中，增加计数器，并在读取到一些数据时调度`recv_callback_`。该方法的后半部分执行相反的操作——尝试使用`send()`例程将数据写入`send_buffer_`，并更新索引跟踪变量：
- en: '[PRE63]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This concludes our discussion of the `TCPSocket` class. Next, we will build
    a class that encapsulates and manages `TCPSocket` objects. It will be used to
    implement functionality for TCP servers in components that act as servers.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对`TCPSocket`类的讨论。接下来，我们将构建一个封装并管理`TCPSocket`对象的类。它将被用于实现充当服务器的组件中的TCP服务器功能。
- en: Building a TCP server component
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建TCP服务器组件
- en: We built a `TCPSocket` class in the previous section that can be used by components
    that need to connect to TCP connections and send as well as receive data. In this
    section, we will build a `TCPServer` component that manages several such `TCPSocket`
    objects internally. It also manages tasks, such as listening for, accepting, and
    tracking new incoming connections and sending and receiving data on this collection
    of sockets. All the source code for the `TCPServer` component is in the `Chapter4/tcp_server.h`
    and `Chapter4/tcp_server.cpp` files in the GitHub repository for this book.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们构建了一个`TCPSocket`类，它可以被需要连接到TCP连接并发送和接收数据的组件使用。在本节中，我们将构建一个`TCPServer`组件，该组件内部管理多个这样的`TCPSocket`对象。它还管理诸如监听、接受和跟踪新传入连接以及在此套接字集合上发送和接收数据等任务。`TCPServer`组件的所有源代码都包含在GitHub仓库中本书的`Chapter4/tcp_server.h`和`Chapter4/tcp_server.cpp`文件中。
- en: Defining the data members of the TCP server
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义TCP服务器的数据成员
- en: First, we will define and describe the data members that the `TCPServer` class
    will contain. It needs a file descriptor, `efd_`, and a corresponding `TCPSocket
    listener_socket_` to represent the socket on which it will be listening for new
    incoming connections from clients. It maintains an array of `epoll_event events_`,
    which will be used to monitor the listening socket file descriptor, along with
    socket descriptors for connected clients. It will have a few `std::vectors` of
    socket objects – sockets that we expect to receive data from, sockets we expect
    to send data on, and sockets that are disconnected. We will see how these are
    used shortly.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义并描述`TCPServer`类将包含的数据成员。它需要一个文件描述符`efd_`和一个相应的`TCPSocket listener_socket_`来表示它将监听新传入客户端连接的套接字。它维护一个`epoll_event
    events_`数组，该数组将用于监控监听套接字的文件描述符，以及连接客户端的套接字描述符。它将有几个`std::vectors`套接字对象——我们期望从中接收数据的套接字，我们期望在其上发送数据的套接字，以及断开连接的套接字。我们很快就会看到这些是如何被使用的。
- en: 'This class has two `std::function` objects – one used to dispatch callbacks
    when new data is received and another one that is dispatched after all callbacks
    in the current round of polling the sockets are completed. To explain this better,
    we will first use the `epoll` call to find all the sockets that have data to read,
    dispatch `recv_callback_` for each socket that has data, and finally, when all
    sockets have been notified, dispatch `recv_finished_callback_`. One more thing
    to note here is that the `recv_callback_` provides `TCPSocket` on which the data
    was received, as well as `Nanos rx_time` to specify the software receive time
    of the data on that socket. The receive timestamps are used to process the TCP
    packets in the exact order in which they were received, since the TCP server monitors
    and reads from many different client TCP sockets:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有两个 `std::function` 对象 – 一个用于在接收到新数据时分发回调，另一个在当前轮次轮询套接字的所有回调完成后分发。为了更好地解释这一点，我们将首先使用
    `epoll` 调用来找到所有有数据要读取的套接字，为每个有数据的套接字分发 `recv_callback_`，最后，当所有套接字都得到通知时，分发 `recv_finished_callback_`。这里还有一个需要注意的事项，即
    `recv_callback_` 提供了 `TCPSocket`，这是数据接收的套接字，以及 `Nanos rx_time` 来指定该套接字上数据的软件接收时间。接收时间戳用于按接收的确切顺序处理
    TCP 数据包，因为 TCP 服务器监控并从许多不同的客户端 TCP 套接字中读取：
- en: '[PRE64]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the next section, we will look at the code to initialize these fields and
    de-initialize the TCP server.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看初始化这些字段和反初始化 TCP 服务器的代码。
- en: Initializing and destroying the TCP server
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化和销毁 TCP 服务器
- en: 'The constructor for `TCPServer` is straightforward – it initializes `listener_socket_`
    and `logger_` and sets the default callback receivers, as we did with `TCPSocket`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCPServer` 的构造函数很简单 – 它初始化 `listener_socket_` 和 `logger_`，并设置默认的回调接收者，就像我们之前对
    `TCPSocket` 所做的那样：'
- en: '[PRE65]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We define the default receive callback methods here, which do not do anything
    except log that the callback was received. These are placeholders anyway, since
    we will set different ones in real applications:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义默认的接收回调方法，这些方法除了记录回调已被接收外不做任何事情。这些方法无论如何都是占位符，因为我们将在实际应用中设置不同的方法：
- en: '[PRE66]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The code to destroy the sockets is quite simple as well – we close the file
    descriptor and destroy `TCPSocket listener_socket_`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁套接字的代码同样简单 – 我们关闭文件描述符并销毁 `TCPSocket listener_socket_`：
- en: '[PRE67]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Finally, we present the boilerplate code that we saw previously for this class:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们展示了之前为这个类看到的样板代码：
- en: '[PRE68]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Next, let us understand the code that initializes the listener socket.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解初始化监听套接字的代码。
- en: Starting up and listening for new connections
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动并监听新的连接
- en: 'The method `TCPServer::listen()`, first creates a new `epoll` instance, using
    the `epoll_create()` Linux system call, and then saves it in the `efd_` variable.
    It uses the `TCPSocket::connect()` method we built earlier to initialize `listener_socket_`,
    but here, the important part is that we set the `listening` argument to be `true`.
    Finally, we add `listener_socket_` to the list of sockets to be monitored using
    the `epoll_add()` method, since initially, this is the only socket to monitor.
    We will look at this `epoll_add()` method in the next section:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`TCPServer::listen()` 方法首先创建一个新的 `epoll` 实例，使用 `epoll_create()` Linux 系统调用，并将其保存在
    `efd_` 变量中。它使用我们之前构建的 `TCPSocket::connect()` 方法来初始化 `listener_socket_`，但这里，重要的是我们将
    `listening` 参数设置为 `true`。最后，我们使用 `epoll_add()` 方法将 `listener_socket_` 添加到要监控的套接字列表中，因为最初，这是唯一需要监控的套接字。我们将在下一节中查看这个
    `epoll_add()` 方法：'
- en: '[PRE69]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, let us look at how the `epoll_add()` and the complementary `epoll_del()`
    methods are built in the next subsection.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在下一小节中构建 `epoll_add()` 和相应的 `epoll_del()` 方法。
- en: Adding and removing monitored sockets
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加和删除监控套接字
- en: 'The `epoll_add()` method is used to add `TCPSocket` to the list of sockets
    to be monitored. It uses the `epoll_ctl()` system call with the `EPOLL_CTL_ADD`
    parameter to add the provided file descriptor of the socket to the `efd_` epoll
    class member. `EPOLLET` enabled the *edge-triggered epoll* option, which in simple
    terms means you are notified only once when data needs to be read instead of constant
    reminders. In this mode, it is up to the application developer to read the data
    when they want. `EPOLLIN` is used for notification once data is available to be
    read:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`epoll_add()` 方法用于将 `TCPSocket` 添加到要监控的套接字列表中。它使用 `epoll_ctl()` 系统调用和 `EPOLL_CTL_ADD`
    参数将提供的套接字文件描述符添加到 `efd_` epoll 类成员中。`EPOLLET` 启用了 *边缘触发式 epoll* 选项，简单来说就是当需要读取数据时你只会被通知一次，而不是持续的提醒。在这种模式下，何时读取数据取决于应用程序的开发者。`EPOLLIN`
    用于在数据可读时进行通知：'
- en: '[PRE70]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `epoll_del()` does the opposite of `epoll_add()` – `epoll_ctl()` is still
    used, but this time, the `EPOLL_CTL_DEL` parameter removes `TCPSocket` from the
    list of sockets being monitored:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`epoll_del()`与`epoll_add()`相反——仍然使用`epoll_ctl()`，但这次，`EPOLL_CTL_DEL`参数从被监控的套接字列表中移除`TCPSocket`：'
- en: '[PRE71]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `del()` method we will build here removes `TCPSocket` from the list of
    sockets being monitored, as well as the different data member containers of the
    sockets:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里构建的`del()`方法将从被监控的套接字列表以及套接字的不同数据成员容器中移除`TCPSocket`：
- en: '[PRE72]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, we can look at the most important method in this subsection – `TCPServer::poll()`,
    which will be used to perform a few tasks, as listed here:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看看这个子节中最重要的方法——`TCPServer::poll()`，它将用于执行以下列出的几个任务：
- en: Call `epoll_wait()`, detect whether there are any new incoming connections,
    and if so, add them to our containers
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`epoll_wait()`，检测是否有任何新的传入连接，如果有，就将它们添加到我们的容器中
- en: From the call to `epoll_wait()`, detect sockets that have disconnected from
    the client’s side and remove them from our containers
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`epoll_wait()`的调用中检测已从客户端断开的套接字，并将它们从我们的容器中移除
- en: From the call to `epoll_wait()`, check to see whether there are sockets with
    data ready to be read or with outgoing data
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`epoll_wait()`的调用中检查是否有套接字准备好读取数据或有传出数据
- en: 'Let us break down the entire method into a few blocks – first, the block that
    calls the `epoll_wait()` method, with the `epoll` instance and the maximum number
    of events being the total number of sockets in our containers, with no timeout:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将整个方法分解成几个块——首先，是调用`epoll_wait()`方法的块，其中`epoll`实例和最大事件数等于我们容器中套接字的总数，没有超时：
- en: '[PRE73]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Next, we iterate through the `events_` array populated by the call to `epoll_wait()`
    if it returns a value of `n` greater than 0\. For each `epoll_event` in the `events_`
    array, we use the `event.data.ptr` object and cast it to `TCPSocket*`, since that
    is how we set up the `events_` array in the `epoll_add()` method:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果`epoll_wait()`返回的值大于0，我们就遍历由`epoll_wait()`调用填充的`events_`数组。对于`events_`数组中的每个`epoll_event`，我们使用`event.data.ptr`对象并将其强制转换为`TCPSocket*`，因为这是我们如何在`epoll_add()`方法中设置`events_`数组的方式：
- en: '[PRE74]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'For each `epoll_event` entry, we check whether the `EPOLLIN` flag is set on
    the events flag, which would signify that there is a new socket with data to read
    from. If this socket happens to be `listener_socket_`, which is `TCPServer`’s
    primary socket that we configured to listen for connections on, we can see that
    we have a new connection to add. If this is a socket different from `listener_socket_`,
    then we add it to the list of `receive_sockets_` vectors if it does not already
    exist in the list:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个`epoll_event`条目，我们检查事件标志上是否设置了`EPOLLIN`标志，这将表示有一个新的套接字可以从中读取数据。如果这个套接字恰好是`listener_socket_`，即我们配置为监听连接的`TCPServer`的主套接字，我们可以看到我们有一个新的连接要添加。如果这是一个不同于`listener_socket_`的套接字，那么如果它尚未存在于列表中，我们就将其添加到`receive_sockets_`向量中：
- en: '[PRE75]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Similarly, we check for the `EPOLLOUT` flag, which signifies there is a socket
    that we can send data to, and add it to the `send_sockets_` vector if it does
    not already exist:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们检查`EPOLLOUT`标志，这表示有一个我们可以向其发送数据的套接字，如果它尚未存在于`send_sockets_`向量中，我们就将其添加进去：
- en: '[PRE76]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, we check whether the `EPOLLERR` or `EPOLLHUP` flags are set, which
    indicate an error or indicate that the socket was closed (signal `hang up`) from
    the other end. In this case, we add this socket to the `disconnected_sockets_`
    vector to be removed:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查是否设置了`EPOLLERR`或`EPOLLHUP`标志，这表示有错误或表示套接字从另一端关闭（挂起信号）。在这种情况下，我们将这个套接字添加到`disconnected_sockets_`向量中以便移除：
- en: '[PRE77]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Finally, in this method, we need to accept the new connection if we detected
    one in the previous code block. We use the `accept()` system call with the `listener_socket_`
    file descriptor to achieve this and fetch the file descriptor for this new socket.
    We also set the socket to be non-blocking and disable Nagle’s algorithm, using
    the `setNonBlocking()` and `setNoDelay()` methods we built before:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个方法中，如果我们之前在代码块中检测到了新的连接，我们需要接受这个新的连接。我们使用带有`listener_socket_`文件描述符的`accept()`系统调用来实现这一点，并获取这个新套接字的文件描述符。我们还使用之前构建的`setNonBlocking()`和`setNoDelay()`方法将套接字设置为非阻塞并禁用Nagle算法：
- en: '[PRE78]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Finally, we create a new `TCPSocket` object using this file descriptor and
    add the `TCPSocket` object to the `sockets_` and `receive_sockets_` containers:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用这个文件描述符创建一个新的`TCPSocket`对象，并将`TCPSocket`对象添加到`sockets_`和`receive_sockets_`容器中：
- en: '[PRE79]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This concludes all the functionality we need to look for new connections and
    dead connections, as well as monitor existing connections to see whether there
    is data to be read. The next sub-section concludes our `TCPServer` class by demonstrating
    how to send and receive data from a list of sockets that have data to be read
    or sent out.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们查找新连接和断开连接的所有功能，以及监控现有连接以查看是否有可读数据的功能的结束。下一个子节通过演示如何从有可读或发送数据的套接字列表中发送和接收数据来结束我们的`TCPServer`类的讨论。
- en: Sending and receiving data
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送和接收数据
- en: 'The code to send and receive data on a list of sockets with incoming or outgoing
    data is shown here. The implementation is very straightforward – it simply calls
    the `TCPSocket::sendAndRecv()` method on each of the sockets in `receive_sockets_`
    and `send_sockets_`. For incoming data, the call to `TCPSocket::sendAndRecv()`
    dispatches the `recv_callback_` method. One thing we need to do here is to check
    whether there was any data that was read this time around, and if so, we dispatch
    `recv_finished_callback_` after all the `recv_callback_` calls are dispatched:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中展示了在具有传入或传出数据的套接字列表上发送和接收数据的代码。实现非常直接——它只是简单地调用`receive_sockets_`和`send_sockets_`中每个套接字的`TCPSocket::sendAndRecv()`方法。对于传入数据，对`TCPSocket::sendAndRecv()`的调用调度`recv_callback_`方法。在这里我们需要做的一件事是检查这次是否读取了任何数据，如果是，则在所有`recv_callback_`调用调度之后调度`recv_finished_callback_`：
- en: '[PRE80]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This concludes our implementation of the `TCPServer` class, let us wrap up our
    network programming discussion with a simple example of everything we built in
    this section.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们`TCPServer`类的实现完成，让我们用一个简单的示例来总结本节中构建的所有内容，以结束我们的网络编程讨论。
- en: Building an example of the TCP server and clients
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建TCP服务器和客户端的示例
- en: In this section, we will build an example and use the `TCPSocket` and `TCPServer`
    classes we implemented in this section. This example can be found in the `Chapter4/socket_example.cpp`
    source file. This simple example creates `TCPServer`, which listens for incoming
    connections on the `lo` interface, the loopback `127.0.0.1` IP, and the listening
    port, `12345`. The `TCPServer` class receives data from the clients, which connect
    to it using the `tcpServerRecvCallback()` lambda method, and the `TCPServer` responds
    back to the clients with a simple response. We then create five clients using
    the `TCPSocket` class, each of which connects to this `TCPServer`. Finally, they
    each send some data to the server, which sends responses back, each of the clients
    repeatedly calling `sendAndRecv()` to send and receive data. `TCPServer` calls
    `poll()` and `sendAndRecv()` to look for connections and data and reads it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个示例，并使用在本节中实现的`TCPSocket`和`TCPServer`类。这个示例可以在`Chapter4/socket_example.cpp`源文件中找到。这个简单的示例创建了一个`TCPServer`，它在`lo`接口上监听进入的连接，回环`127.0.0.1`
    IP，以及监听端口`12345`。`TCPServer`类通过使用`tcpServerRecvCallback()` lambda方法连接到它的客户端接收数据，并且`TCPServer`通过一个简单的响应回应对客户端进行响应。然后，我们使用`TCPSocket`类创建了五个客户端，每个客户端都连接到这个`TCPServer`。最后，它们各自向服务器发送一些数据，服务器回送响应，每个客户端反复调用`sendAndRecv()`来发送和接收数据。`TCPServer`通过调用`poll()`和`sendAndRecv()`来查找连接和数据，并读取它。
- en: 'First, the code that sets up the callback lambdas is presented here:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，展示设置回调lambda的代码：
- en: '[PRE81]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then, we create, initialize, and connect the server and the clients, as shown
    here:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建、初始化并连接服务器和客户端，如下所示：
- en: '[PRE82]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, we have the clients send data and call the appropriate polling and
    sending/receiving methods on the clients and the server, as shown here:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有客户端发送数据，并在客户端和服务器上调用适当的轮询和发送/接收方法，如下所示：
- en: '[PRE83]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Running this example, as shown here, will output something similar to what
    is shown here in the log file:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例，如以下所示，将在日志文件中输出类似以下内容：
- en: '[PRE84]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This concludes our discussion of C++ network programming with sockets. We covered
    a lot regarding the basic low-level details of socket programming. We also designed
    and implemented slightly higher-level abstractions for TCP and UDP communication,
    both from a server’s and a client’s perspective.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们关于使用套接字的C++网络编程讨论的结束。我们涵盖了关于套接字编程的基本底层细节的很多内容。我们还从服务器和客户端的角度设计了实现了一些稍微高级的抽象，用于TCP和UDP通信。
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we jumped into the world of low latency application C++ development.
    We built some relatively fundamental but extremely useful building blocks that
    can be used for a variety of low latency application purposes. We put into practice
    a lot of the theoretical discussions related to using C++ and computer architecture
    features effectively to build low latency and highly performant applications.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们进入了低延迟应用程序C++开发的领域。我们构建了一些相对基础但极其有用的构建块，可用于各种低延迟应用程序目的。我们将许多与有效使用C++和计算机架构特性相关的理论讨论付诸实践，以构建低延迟和高性能的应用程序。
- en: The first component was used to create new threads of execution and run the
    functions that different components might require. One important functionality
    here is being able to control the CPU core that the newly created thread gets
    pinned to by setting the thread affinity.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个组件用于创建新的执行线程，并运行不同组件可能需要的函数。这里的一个重要功能是能够通过设置线程亲和性来控制新创建的线程被固定到的CPU核心。
- en: The second component we built was meant to avoid dynamic memory allocation on
    the critical code path. We reiterated the inefficiencies associated with dynamic
    memory allocation and designed a memory pool to be used to pre-allocate memory
    from the heap when constructed. Then, we added utility to the component to allow
    the allocation and deallocation of objects at runtime without relying on dynamic
    memory allocation.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的第二个组件旨在避免在关键代码路径上进行动态内存分配。我们重申了与动态内存分配相关的低效性，并设计了一个内存池，用于在构建时从堆中预分配内存。然后，我们向组件添加了实用工具，允许在运行时分配和释放对象，而不依赖于动态内存分配。
- en: Next, we built a lock-free, **First In First Out** (**FIFO**)-style queue to
    communicate between threads in an SPSC setup. The important requirement here was
    that a single reader and a single writer are able to access the shared data in
    the queue without using any locks or mutexes. The absence of locks and mutexes
    means the absence of context switches, which, as discussed, are a major source
    of inefficiencies and latencies in multi-threaded applications.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们构建了一个无锁的、**先进先出**（**FIFO**）风格的队列，用于在SPSC设置中线程间通信。这里的一个重要要求是，单个读者和单个写者能够无锁或互斥锁地访问队列中的共享数据。锁和互斥锁的缺失意味着上下文切换的缺失，正如讨论的那样，这是多线程应用程序中低效性和延迟的主要来源。
- en: The fourth component on our list was a framework to facilitate efficient logging
    for latency-sensitive applications. Logging is a very important if not mandatory
    component of all applications, including low latency applications. However, due
    to issues such as disk I/O, slow string formatting, and so on, traditional logging
    mechanisms such as writing to a log file on disk is impractical for use with low
    latency applications. To build this component, we used the multi-threading mechanism
    we built, as well as the lock-free FIFO queue.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的第四个组件是一个框架，旨在为对延迟敏感的应用程序提供高效的日志记录。日志记录对于所有应用程序来说都是非常重要的，如果不是强制性的话，包括低延迟应用程序。然而，由于磁盘I/O、慢速字符串格式化等问题，传统的日志机制，如将日志写入磁盘上的日志文件，对于低延迟应用程序来说是不切实际的。为了构建这个组件，我们使用了我们构建的多线程机制，以及无锁的FIFO队列。
- en: Finally, we had an in-depth discussion about designing our network stack – how
    to create network sockets, how to use them to create TCP servers and clients,
    and how to use them to publish and consume multicast traffic. We have not used
    this last component yet, but we will use this component in subsequent chapters
    to facilitate communication between our electronic trading exchange and different
    market participants.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们深入讨论了设计我们的网络栈——如何创建网络套接字，如何使用它们创建TCP服务器和客户端，以及如何使用它们发布和消费多播流量。我们尚未使用这个最后一个组件，但在后续章节中，我们将使用这个组件来促进我们的电子交易交易所与不同市场参与者之间的通信。
- en: Now, we will move on to a case study project, which we will build in the rest
    of this book – our electronic trading ecosystem. In the next chapter, we will
    first focus on designing and understanding the higher-level design of the various
    components in our system. We will understand the purpose of these components,
    the motivation behind their design choices, and how the flow of information occurs
    in the system. The next chapter will also see us designing the higher-level C++
    interfaces that we will implement in the rest of this book.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续进行一个案例研究项目，该项目我们将在本书的剩余部分构建——我们的电子交易生态系统。在下一章中，我们将首先关注设计和理解我们系统中各个组件的高级设计。我们将了解这些组件的目的、它们设计选择背后的动机以及信息在系统中的流动方式。下一章还将展示我们将在本书的其余部分实现的高级C++接口的设计。
- en: Part 2:Building a Live Trading Exchange in C++
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：使用C++构建实时交易交易所
- en: In this part, we will describe and design the trading applications that make
    up our ecosystem, which we will be building from scratch in this book – electronic
    trading exchanges, exchange market data dissemination, order gateways, client
    market data decoders, and client trading algorithm frameworks. We will implement
    the matching engine that tracks client orders and performs matching between them.
    We will also build the components that publish market data for all participants
    and how it handles client connections and order requests. The focus will be on
    very low-latency reaction times and high throughput since modern electronic exchanges
    have thousands of participants and a huge amount of order flow flowing through
    it.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本部分中，我们将描述和设计构成我们生态系统的交易应用，这些应用我们将从本书的起点开始构建——电子交易交易所、交易所市场数据发布、订单网关、客户端市场数据解码器和客户端交易算法框架。我们将实现跟踪客户订单并执行它们之间匹配的匹配引擎。我们还将构建发布市场数据供所有参与者使用的组件，以及它如何处理客户端连接和订单请求。由于现代电子交易所拥有数千名参与者以及巨大的订单流通过，因此重点关注非常低的延迟反应时间和高吞吐量。
- en: 'This part contains the following chapters:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B19434_05.xhtml#_idTextAnchor134)*, Designing Our Trading Ecosystem*'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B19434_05.xhtml#_idTextAnchor134)*，设计我们的交易生态系统*'
- en: '[*Chapter 6*](B19434_06.xhtml#_idTextAnchor166)*, Building the C++ Matching
    Engine*'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19434_06.xhtml#_idTextAnchor166)*，构建C++匹配引擎*'
- en: '[*Chapter 7*](B19434_07.xhtml#_idTextAnchor186)*, Communicating with Market
    Participants*'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19434_07.xhtml#_idTextAnchor186)*，与市场参与者沟通*'
