- en: '*Chapter 10*: JIT Compilation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：JIT编译'
- en: The LLVM core libraries come with the **ExecutionEngine** component, which allows
    the compilation and execution of IR code in memory. Using this component, we can
    build **just in time** (**JIT**) compilers, which allow the direct execution of
    IR code. A JIT compiler works more like an interpreter, in the sense that no object
    code needs to be stored on secondary storage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM核心库配备了**ExecutionEngine**组件，允许在内存中编译和执行IR代码。使用这个组件，我们可以构建**即时**（**JIT**）编译器，允许直接执行IR代码。JIT编译器更像解释器，因为不需要在辅助存储上存储目标代码。
- en: In this chapter, you will learn about applications for JIT compilers, and how
    the LLVM JIT compiler works in principle. You will explore the LLVM dynamic compiler
    and interpreter, and you will also learn how to implement a JIT compiler tool
    on your own. You will also see how to make use of a JIT compiler as part of a
    static compiler, and the challenges associated with it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解JIT编译器的应用程序，以及LLVM JIT编译器的工作原理。您将探索LLVM动态编译器和解释器，还将学习如何自己实现JIT编译器工具。您还将了解如何在静态编译器中使用JIT编译器，以及相关的挑战。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Getting an overview of LLVM's JIT implementation and use cases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取LLVM的JIT实现和用例概述
- en: Using JIT compilation for direct execution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JIT编译进行直接执行
- en: Utilizing a JIT compiler for code evaluation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用JIT编译器进行代码评估
- en: By the end of the chapter, you will know how to develop a JIT compiler, either
    using a preconfigured class, or a customized version fitting your needs. You will
    also acquire the knowledge to make use of a JIT compiler inside a traditional
    static compiler.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解如何开发JIT编译器，无论是使用预配置的类还是符合您需求的定制版本。您还将获得使用静态编译器内部的JIT编译器的知识。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter10](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter10)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在[https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter10](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter10)找到
- en: You can find the code in action videos at [https://bit.ly/3nllhED](https://bit.ly/3nllhED)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://bit.ly/3nllhED](https://bit.ly/3nllhED)找到代码的实际操作视频
- en: Getting an overview of LLVM's JIT implementation and use cases
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取LLVM的JIT实现和用例概述
- en: 'So far, we have only looked at **ahead of time** (**AOT**) compilers. These
    compilers compile the whole application. Only once the compilation is finished
    can the application run. If the compilation is performed at the runtime of the
    application, then the compiler is a JIT compiler. A JIT compiler has interesting
    use cases:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看过**提前**（**AOT**）编译器。这些编译器编译整个应用程序。只有在编译完成后，应用程序才能运行。如果在应用程序运行时进行编译，则编译器是JIT编译器。JIT编译器有一些有趣的用例：
- en: '**Implementation of a virtual machine**: A programming language can be translated
    to byte code with an AOT compiler. At runtime, a JIT compiler is used to compile
    the byte code to machine code. The advantage of this approach is that the byte
    code is hardware-independent, and thanks to the JIT compiler, there is no performance
    penalty compared to an AOT compiler. Java and C# use this model today, but the
    idea is really old: the USCD Pascal compiler from 1977 already used a similar
    approach.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟机的实现**：编程语言可以使用AOT编译器将其转换为字节码。在运行时，JIT编译器用于将字节码编译为机器代码。这种方法的优势在于字节码是与硬件无关的，并且由于JIT编译器，与AOT编译器相比没有性能损失。如今，Java和C#使用这种模型，但这个想法实际上很古老：1977年的USCD
    Pascal编译器已经使用了类似的方法。'
- en: '**Expression evaluation**: A spreadsheet application can compile often-executed
    expressions with a JIT compiler. This can speed up the financial simulations,
    for example. The LLVM debugger LLDB uses the approach to evaluate a source expression
    at debug time.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表达式评估**：电子表格应用程序可以使用JIT编译器编译经常执行的表达式。例如，这可以加速财务模拟。LLVM调试器LLDB使用这种方法在调试时评估源表达式。'
- en: '**Database queries**: A database creates an execution plan from a database
    query. The execution plan describes the operations on tables and columns, which
    leads to the query answer when executed. A JIT compiler can be used to translate
    the execution plan into machine code, thereby speeding up the execution of the
    query.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库查询**：数据库从数据库查询创建执行计划。执行计划描述了对表和列的操作，这导致了查询执行时的结果。JIT编译器可以用于将执行计划转换为机器代码，从而加速查询的执行。'
- en: The static compilation model of LLVM is not as far away from the JIT model as
    you may think. The LLVM static compiler, `llc`, compiles LLVM IR into machine
    code and saves the result as an object file on disk. If the object file is not
    stored on disk but in memory, would the code be executable? Not directly, because
    references to global functions and global data use relocations instead of absolute
    addresses.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM的静态编译模型并不像你想象的那样远离JIT模型。LLVM静态编译器`llc`将LLVM IR编译成机器代码，并将结果保存为磁盘上的目标文件。如果目标文件不是存储在磁盘上而是存储在内存中，那么代码是否可以执行？不直接执行，因为对全局函数和全局数据的引用使用重定位而不是绝对地址。
- en: Conceptually, a relocation describes how to calculate the address, for example,
    as an offset to a known address. If we resolve the relocations into addresses,
    like the linker and dynamic loader do, then we can execute the object code. Running
    the static compiler to compile IR code into an object file in memory, performing
    a link step on the in-memory object file, and then running the code gives us a
    JIT compiler. The JIT implementation in the LLVM core libraries is based on this
    idea.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 概念上，重定位描述了如何计算地址，例如，作为已知地址的偏移量。如果我们解析重定位为地址，就像链接器和动态加载器所做的那样，那么我们就可以执行目标代码。运行静态编译器将IR代码编译成内存中的目标文件，对内存中的目标文件进行链接步骤，然后运行代码，这就给我们了一个JIT编译器。LLVM核心库中的JIT实现就是基于这个想法的。
- en: 'During the development history of LLVM, there were several JIT implementations,
    with different feature sets. The latest JIT API is the **on request compilation**
    (**ORC**) engine. In case you were wondering about the acronym: it was the lead
    developer''s intention to invent yet another acronym based on Tolkien''s universe,
    after the **ELF** (**Executable and Linking Format**) and the **DWARF** (**Debugging
    Standard**) were already there.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在LLVM的开发历史中，有几个不同功能集的JIT实现。最新的JIT API是**按需编译**（**ORC**）引擎。如果你想知道这个首字母缩略词的含义：这是首席开发人员的意图，在托尔金的宇宙基础上发明另一个首字母缩略词，之前已经有了**ELF**（**可执行和链接格式**）和**DWARF**（**调试标准**）。
- en: 'The ORC engine builds on, and extends, the idea of using the static compiler
    and a dynamic linker on the in-memory object file. The implementation uses a *layered*
    approach. The two basic levels are the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ORC引擎建立在使用静态编译器和动态链接器在内存中的对象文件上的想法之上，并对其进行了扩展。实现采用了*分层*方法。两个基本级别如下：
- en: Compile layer
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译层
- en: Link layer
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链接层
- en: On top of the compile layer can sit a layer providing support for *lazy compilation*.
    A **transformation layer** can be stacked on top or below the lazy compilation
    layer, allowing the developer to add arbitrary transformation, or simply be notified
    of certain events. This layered approach has the advantage that the JIT engine
    is *customizable for diverse requirements*. For example, a high-performance virtual
    machine may choose to compile everything upfront and make no use of the lazy compilation
    layer. Other virtual machines will emphasize start up time and responsiveness
    to the user, and achieve this with the help of the lazy compilation layer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译层之上可以放置一个提供对*延迟编译*的支持的层。**转换层**可以堆叠在延迟编译层的上方或下方，允许开发人员添加任意的转换，或者只是在某些事件发生时得到通知。这种分层方法的优势在于JIT引擎可以*根据不同的需求进行定制*。例如，高性能虚拟机可能会选择预先编译所有内容，并且不使用延迟编译层。其他虚拟机将强调启动时间和对用户的响应性，并通过延迟编译层的帮助来实现这一点。
- en: The older MCJIT engine is still available. The API is derived from an even older,
    already removed, JIT engine. Over time, the API became a bit bloated, and it lacks
    the flexibility of the ORC API. The goal is to remove this implementation, as
    the ORC engine now provides all the functionality of the MCJIT engine. New developments
    should use the ORC API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧的MCJIT引擎仍然可用。API源自一个更早的、已经删除的JIT引擎。随着时间的推移，API变得有点臃肿，并且缺乏ORC API的灵活性。目标是删除这个实现，因为ORC引擎现在提供了MCJIT引擎的所有功能。新的开发应该使用ORC
    API。
- en: In the next section, we look at `lli`, the LLVM interpreter and dynamic compiler,
    before we dive into implementing a JIT compiler.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将先看看`lli`，LLVM解释器和动态编译器，然后再深入实现JIT编译器。
- en: Using JIT compilation for direct execution
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JIT编译进行直接执行
- en: Running LLVM IR directly is the first idea that comes to mind when thinking
    about a JIT compiler. This is what the `lli` tool, the LLVM interpreter, and the
    dynamic compiler do. We will explore the `lli` tool in the next section, and subsequently
    implement a similar tool on our own.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 直接运行LLVM IR是在考虑JIT编译器时首先想到的想法。这就是`lli`工具，LLVM解释器和动态编译器所做的。我们将在下一节中探索`lli`工具，并随后自己实现类似的工具。
- en: Exploring the lli tool
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索lli工具
- en: 'Let''s try the `lli` tool with a very simple example. Store the following source
    as a `hello.ll` file. It is the equivalent of a C hello world application. It
    declares the prototype for the `printf()` function from the C library. The `hellostr`
    constant contains the message to be printed. Inside the `main()` function, a pointer
    to the first character of the message is calculated via the `getelementptr` instruction,
    and this value is passed to the `printf()` function. The application always returns
    `0`. The complete source code is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用`lli`工具进行一个非常简单的示例。将以下源代码存储为`hello.ll`文件。这相当于一个C语言的hello world应用程序。它声明了C库中`printf()`函数的原型。`hellostr`常量包含要打印的消息。在`main()`函数内部，通过`getelementptr`指令计算出消息的第一个字符的指针，并将该值传递给`printf()`函数。该应用程序始终返回`0`。完整的源代码如下：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This LLVM IR file is generic enough that it is valid for all platforms. We
    can directly execute the IR with the `lli` tool with the help of the following
    command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个LLVM IR文件足够通用，适用于所有平台。我们可以直接使用以下命令在`lli`工具中执行IR：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The interesting point here is how the `printf()` function is found. The IR code
    is compiled to machine code, and a lookup for the `printf` symbol is triggered.
    This symbol is not found in the IR, so the current process is searched for it.
    The `lli` tool dynamically links against the C library, and the symbol is found
    there.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的一点是如何找到`printf()`函数。IR代码被编译成机器代码，并触发了对`printf`符号的查找。在IR中找不到这个符号，所以当前进程会在其中搜索。`lli`工具动态链接到C库，并在那里找到了该符号。
- en: 'Of course, the `lli` tool does not link against libraries you created. To enable
    the use of such functions, the `lli` tool supports the loading of shared libraries
    and objects. The following C source just prints a friendly message:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`lli`工具不会链接到您创建的库。为了启用这些函数的使用，`lli`工具支持加载共享库和对象。以下C源代码只是打印一个友好的消息：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Stored in the `greetings.c` file, we use this to explore the loading of objects
    with the `lli` tool. Compile this source into a shared library. The `–fPIC` option
    instructs clang to generate position-independent code, which is required for shared
    libraries. With the `–shared` option given, the compiler creates the `greetings.so`
    shared library:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在`greetings.c`文件中，我们将用它来探索使用`lli`工具加载对象。将此源代码编译成共享库。`-fPIC`选项指示clang生成位置无关的代码，这对于共享库是必需的。给定`-shared`选项后，编译器将创建`greetings.so`共享库：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also compile the file into a `greetings.o` object file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将文件编译成`greetings.o`对象文件：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We now have two files, the `greetings.so` shared library and the `greetings.o`
    object file, which we will load into the `lli` tool.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个文件，`greetings.so`共享库和`greetings.o`对象文件，我们将它们加载到`lli`工具中。
- en: 'We also need an LLVM IR file, which calls the `greetings()` function. For this,
    create the `main.ll` file, which contains a single call to the function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个LLVM IR文件，其中调用`greetings()`函数。为此，请创建包含对该函数的单个调用的`main.ll`文件：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you try to execute the IR as before, then the `lli` tool is not able to
    locate the greetings symbol and will simply crash:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试像以前一样执行IR，则`lli`工具无法找到`greetings`符号，将简单崩溃：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `greetings()` function is defined in an external file, and to fix the crash,
    we have to tell the `lli` tool which additional file needs to be loaded. In order
    to use the shared library, you have to use the `–load` option, which takes the
    path to the shared library as an argument:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`greetings()`函数在外部文件中定义，为了修复崩溃，我们必须告诉`lli`工具需要加载哪个附加文件。为了使用共享库，您必须使用`–load`选项，该选项以共享库的路径作为参数：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is important to specify the path to the shared library, if the directory
    containing the shared library is not in the search path for the dynamic loader.
    If omitted, then the library will not be found.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包含共享库的目录不在动态加载器的搜索路径中，则重要的是指定共享库的路径。如果省略，则将无法找到库。
- en: 'Alternatively, we can instruct the `lli` tool to load the object file with
    the `–extra-object` option:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以指示`lli`工具使用`–extra-object`选项加载对象文件：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Other supported options are `–extra-archive`, which loads an archive, and `–extra-module`,
    which loads another bitcode file. Both options require the path to the file as
    an argument.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 其他支持的选项是`–extra-archive`，它加载存档，以及`–extra-module`，它加载另一个位代码文件。这两个选项都需要文件的路径作为参数。
- en: You now know how you can use the `lli` tool to directly execute LLVM IR. In
    the next section, we will implement our own JIT tool.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何使用`lli`工具直接执行LLVM IR。在下一节中，我们将实现自己的JIT工具。
- en: Implementing our own JIT compiler with LLJIT
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LLJIT实现我们自己的JIT编译器
- en: The `lli` tool is nothing more than a thin wrapper around LLVM APIs. In the
    first section, we learned that the ORC engine uses a layered approach. The `ExecutionSession`
    class represents a running JIT program. Besides other items, this class holds
    the used `JITDylib` instances. A `JITDylib` instance is a symbol table, which
    maps symbol names to addresses. For example, this can be the symbols defined in
    an LLVM IR file, or the symbols of a loaded shared library.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`lli`工具只是LLVM API周围的薄包装器。在第一节中，我们了解到ORC引擎使用分层方法。`ExecutionSession`类表示正在运行的JIT程序。除其他项目外，此类还保存了使用的`JITDylib`实例。`JITDylib`实例是一个符号表，将符号名称映射到地址。例如，这可以是LLVM
    IR文件中定义的符号，或者是加载的共享库的符号。'
- en: To execute LLVM IR, we do not need to create a JIT stack on our own. The utility
    `LLJIT` class provides this functionality. You can also make use of this class
    when migrating from the older MCJIT implementation. This class essentially provides
    the same functionality. We begin the implementation with the initialization of
    the JIT engine in the next subsection.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行LLVM IR，我们不需要自己创建JIT堆栈。实用程序`LLJIT`类提供此功能。当从较旧的MCJIT实现迁移时，您也可以使用此类。该类基本上提供了相同的功能。我们将在下一小节中开始实现JIT引擎的初始化。
- en: Initializing the JIT engine for compiling LLVM IR
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化用于编译LLVM IR的JIT引擎
- en: 'We first implement the function that sets up the JIT engine, compiles an LLVM
    IR module, and executes the `main()` function in this module. Later, we use this
    core functionality to build a small JIT tool. This is the `jitmain()` function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先实现设置JIT引擎，编译LLVM IR模块并在此模块中执行`main()`函数的函数。稍后，我们将使用此核心功能构建一个小型JIT工具。这是`jitmain()`函数：
- en: 'The function needs the LLVM module with the IR to execute. Also needed is the
    LLVM context class used for this module, because the context class holds important
    type information. The goal is to call the `main()` function, so we also pass the
    usual `argc` and `argv` parameters:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数需要执行LLVM模块的LLVM IR。还需要用于此模块的LLVM上下文类，因为上下文类保存重要的类型信息。目标是调用`main()`函数，因此我们还传递通常的`argc`和`argv`参数：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We use the `LLJITBuilder` class to create an `LLJIT` instance. If an error
    occurs, then we return the error. A possible source for an error is that the platform
    does not yet support JIT compilation:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`LLJITBuilder`类创建`LLJIT`实例。如果发生错误，则返回错误。错误的可能来源是平台尚不支持JIT编译：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we add the module to the main `JITDylib` instance. If configured, then
    JIT compilation utilizes multiple threads. Therefore, we need to wrap the module
    and the context in a `ThreadSafeModule` instance. If an error occurs, then we
    return the error:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将模块添加到主`JITDylib`实例中。如果配置，则JIT编译将利用多个线程。因此，我们需要将模块和上下文包装在`ThreadSafeModule`实例中。如果发生错误，则返回错误：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Like the `lli` tool, we also support the symbols from the C library. The `DefinitionGenerator`
    class exposes symbols, and the `DynamicLibrarySearchGenerator` subclass exposes
    the names found in the shared library. The class provides two factory methods.
    The `Load()` method can be used to load a shared library, while the `GetForCurrentProcess()`
    method exposes the symbols of the current process. We use the latter function.
    The symbol names can have a prefix, depending on the platform. We retrieve the
    data layout and pass the prefix to the `GetForCurrentprocess()` function. The
    symbol names are then treated in the right way, and we do not need to care about
    it. As usual, we return from the function in case an error occurs:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`lli`工具一样，我们还支持C库中的符号。`DefinitionGenerator`类公开符号，`DynamicLibrarySearchGenerator`子类公开共享库中找到的名称。该类提供了两个工厂方法。`Load()`方法可用于加载共享库，而`GetForCurrentProcess()`方法公开当前进程的符号。我们使用后者功能。符号名称可以具有前缀，取决于平台。我们检索数据布局并将前缀传递给`GetForCurrentprocess()`函数。然后符号名称将以正确的方式处理，我们不需要关心它。通常情况下，如果发生错误，我们会从函数中返回：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We then add the generator to the main `JITDylib` instance. In case a symbol
    needs to be looked up, the symbols from the loaded shared library are also searched:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将生成器添加到主`JITDylib`实例中。如果需要查找符号，则还会搜索加载的共享库中的符号：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we look up the `main` symbol. This symbol must be in the IR module given
    on the command line. The lookup triggers compilation of that IR module. If other
    symbols are referenced inside the IR module, then they are resolved using the
    generator added in the previous step. The result is of the `JITEvaluatedSymbol`
    class:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们查找`main`符号。该符号必须在命令行给出的IR模块中。查找触发了该IR模块的编译。如果IR模块内引用了其他符号，则使用前一步添加的生成器进行解析。结果是`JITEvaluatedSymbol`类的实例：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We ask the returned JIT symbol for the address of the function. We cast this
    address to the prototype of the C `main()` function:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们询问返回的JIT符号函数的地址。我们将此地址转换为C `main()`函数的原型：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can call the `main()` function in the IR module, and pass the `argc`
    and `argv` parameters, which the function expects. We ignore the return value:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在IR模块中调用`main()`函数，并传递函数期望的`argc`和`argv`参数。我们忽略返回值：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We report success following execution of the function:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数执行后报告成功：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This demonstrates how easy it is to use JIT compilation. There is a bunch of
    other possibilities to expose names, besides exposing the symbols for the current
    process or from a shared library. The `StaticLibraryDefinitionGenerator` class
    exposes the symbols found in a static archive, and can be used in the same way
    as the `DynamicLibrarySearchGenerator` class. The `LLJIT` class also has an `addObjectFile()`
    method to expose the symbols of an object file. You can also provide your own
    `DefinitionGenerator` implementation if the existing implementations do not fit
    your needs. In the next subsection, you extend the implementation into a JIT compiler.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这演示了使用JIT编译是多么容易。除了暴露当前进程或共享库中的符号之外，还有许多其他可能性。`StaticLibraryDefinitionGenerator`类暴露了静态存档中找到的符号，并且可以像`DynamicLibrarySearchGenerator`类一样使用。`LLJIT`类还有一个`addObjectFile()`方法来暴露对象文件的符号。如果现有的实现不符合您的需求，您还可以提供自己的`DefinitionGenerator`实现。在下一小节中，您将把实现扩展为JIT编译器。
- en: Creating the JIT compiler utility
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建JIT编译器实用程序
- en: 'The `jitmain()` function is easily extended into a small tool, which we do
    next. The source is saved in a `JIT.cpp` file and is a simple JIT compiler:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`jitmain()`函数很容易扩展为一个小工具，我们接下来就这样做。源代码保存在`JIT.cpp`文件中，是一个简单的JIT编译器：'
- en: 'We must include several header files. The `LLJIT.h` header defines the `LLJIT`
    class, and the core classes of the ORC API. We include the `IRReader.h` header
    because it defines a function to read LLVM IR files. The `CommandLine.h` header
    allows us to parse the command-line options in the LLVM style. Finally, the `InitLLVM.h`
    header is required for basic initialization of the tool, and the `TargetSelect.h`
    header for the initialization of the native target:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须包含几个头文件。`LLJIT.h`头文件定义了`LLJIT`类和ORC API的核心类。我们包含`IRReader.h`头文件，因为它定义了一个用于读取LLVM
    IR文件的函数。`CommandLine.h`头文件允许我们以LLVM风格解析命令行选项。最后，`InitLLVM.h`头文件用于工具的基本初始化，`TargetSelect.h`头文件用于本机目标的初始化：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We add the `llvm` namespace to the current scope:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`llvm`命名空间添加到当前作用域中：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Our JIT tool expects exactly one input file on the command line, which we declare
    with the `cl::opt<>` class:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的JIT工具在命令行上期望有一个输入文件，我们使用`cl::opt<>`类声明这个文件：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To read the IR file, we call the `parseIRFile()` function. The file can be
    the textual IR representation, or a bitcode file. The function returns a pointer
    to the created module. Error handling is a bit different because a textual IR
    file can be parsed, which is not necessarily syntactical correct. The `SMDiagnostic`
    instance holds the error information in case of a syntax error. The error message
    is printed, and the application is exited:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要读取IR文件，我们调用`parseIRFile()`函数。文件可以是文本IR表示，也可以是位码文件。该函数返回指向创建的模块的指针。错误处理有点不同，因为可以解析文本IR文件，这不一定是语法正确的。`SMDiagnostic`实例在语法错误时保存错误信息。错误消息被打印，应用程序退出：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `jitmain()` function is placed here:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`jitmain()`函数放在这里：'
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then we add the `main()` function, which initializes the tool and the native
    target, and parses the command line:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们添加`main()`函数，该函数初始化工具和本机目标，并解析命令行：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, the LLVM context class is initialized:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，初始化LLVM上下文类：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then we load the IR module named on the command line:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们加载命令行上命名的IR模块：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then we can call the `jitmain()` function. To handle errors, we use the `ExitOnError`
    utility class. This class prints an error message and exits the application when
    an error occurred. We also set a banner with the name of the application, which
    is printed before the error message:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以调用`jitmain()`函数。为了处理错误，我们使用`ExitOnError`实用类。当发生错误时，该类打印错误消息并退出应用程序。我们还设置了一个横幅，显示应用程序的名称，该横幅会在错误消息之前打印：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the control flow reaches this point, then the IR was successfully executed.
    We return `0` to indicate success:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果控制流到达这一点，那么IR已成功执行。我们返回`0`表示成功：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is already the complete implementation! We only need to add the build description,
    which is the topic of the next subsection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是完整的实现了！我们只需要添加构建描述，这是下一小节的主题。
- en: Adding the CMake build description
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加CMake构建描述
- en: 'In order to compile this source file, we also need to create a `CMakeLists.txt`
    file with the build description, saved besides the `JIT.cpp` file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译这个源文件，我们还需要创建一个`CMakeLists.txt`文件，其中包含构建描述，保存在`JIT.cpp`文件旁边：
- en: 'We set the minimal required CMake version to the number required by LLVM and
    give the project the name `jit`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将最小要求的CMake版本设置为LLVM所需的版本号，并给项目命名为`jit`：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The LLVM package needs to be loaded, and we add the directory of the CMake
    modules provided by LLVM to the search path. Then we include the `ChooseMSVCCRT`
    module, which makes sure that the same C runtime is used as by LLVM:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLVM包需要被加载，我们将LLVM提供的CMake模块目录添加到搜索路径中。然后我们包含`ChooseMSVCCRT`模块，以确保与LLVM使用相同的C运行时：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We also need to add the definitions and the include path from LLVM. The LLVM
    components used are mapped to the library names with a function call:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要添加LLVM的定义和包含路径。使用的LLVM组件通过函数调用映射到库名称：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lastly, we define the name of the executable, the source files to compile,
    and the library to link against:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义可执行文件的名称，要编译的源文件以及要链接的库：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'That is everything that is required for the JIT tool. Create and change into
    a build directory, and then run the following command to create and compile the
    application:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是JIT工具所需的一切。创建并切换到构建目录，然后运行以下命令来创建和编译应用程序：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This compiles the `JIT` tool. You can check the functionality with the `hello.ll`
    file from the beginning of the chapter:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译`JIT`工具。您可以使用本章开头的`hello.ll`文件检查功能：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Creating a JIT compiler is surprisingly easy!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 创建JIT编译器非常容易！
- en: The example used LLVM IR as input, but this is not a requirement. The `LLJIT`
    class uses the `IRCompileLayer` class, which is responsible for compiling IR to
    machine code. You can define your own layer, which accepts the input you need,
    for example, Java byte code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 示例使用LLVM IR作为输入，但这不是必需的。`LLJIT`类使用`IRCompileLayer`类，负责将IR编译为机器代码。您可以定义自己的层，接受您需要的输入，例如Java字节码。
- en: Using the predefined LLJIT class is handy, but limits our flexibility. In the
    next section, we will look at how to implement a JIT compiler using the layers
    provided by the ORC API.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预定义的LLJIT类很方便，但限制了我们的灵活性。在下一节中，我们将看看如何使用ORC API提供的层来实现JIT编译器。
- en: Building a JIT compiler class from scratch
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从头开始构建JIT编译器类
- en: Using the layered approach of ORC, it is very easy to build a JIT compiler customized
    for the requirements. There is no one-size-fits-all JIT compiler, and the first
    section of this chapter gave some examples. Let's have a look at how to set up
    a JIT compiler.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ORC的分层方法，非常容易构建符合要求的JIT编译器。没有一种通用的JIT编译器，本章的第一部分给出了一些例子。让我们看看如何设置JIT编译器。
- en: The ORC API uses layers, which are stacked together. The lowest level is the
    object linking layer, represented by the `llvm::orc::RTDyldObjectLinkingLayer`
    class. It is responsible for linking in-memory objects and turning them into executable
    code. The memory required for this task is managed by an instance of the `MemoryManager`
    interface. There is a default implementation, but we can also use a custom version
    if we need to.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ORC API使用堆叠在一起的层。最低级别是对象链接层，由`llvm::orc::RTDyldObjectLinkingLayer`类表示。它负责链接内存对象并将其转换为可执行代码。此任务所需的内存由`MemoryManager`接口的实例管理。有一个默认实现，但如果需要，我们也可以使用自定义版本。
- en: Above the object linking layer is the compile layer, which is responsible for
    creating an in-memory object file. The `llvm::orc::IRCompileLayer` class takes
    an IR module as input, and compiles it to an object file. The `IRCompileLayer`
    class is a subclass of the `IRLayer` class, which is a generic class for layer
    implementations accepting LLVM IR.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对象链接层上面是编译层，负责创建内存中的目标文件。`llvm::orc::IRCompileLayer`类以IR模块作为输入，并将其编译为目标文件。`IRCompileLayer`类是`IRLayer`类的子类，后者是接受LLVM
    IR的层实现的通用类。
- en: These two layers already form the core of a JIT compiler. They add an LLVM IR
    module as input, which is compiled and linked in-memory. To add more functionality,
    we can add more layers on top of these both. For example, the `CompileOnDemandLayer`
    class splits a module, so that only the requested functions are compiled. This
    can be used to implement lazy compilation. The `CompileOnDemandLayer` class is
    also a subclass of the `IRLayer` class. In a very generic way, the `IRTransformLayer`
    class, also a subclass of the `IRLayer` class, allows us to apply a transformation
    to the module.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个层已经构成了JIT编译器的核心。它们将LLVM IR模块作为输入，编译并链接到内存中。要添加更多功能，我们可以在这两个层之上添加更多层。例如，`CompileOnDemandLayer`类将模块拆分，以便仅编译请求的函数。这可以用于实现延迟编译。`CompileOnDemandLayer`类也是`IRLayer`类的子类。以非常通用的方式，`IRTransformLayer`类，也是`IRLayer`类的子类，允许我们对模块应用转换。
- en: Another important class is the `ExecutionSession` class. This class represents
    a running JIT program. Basically, this means that the class manages the `JITDylib`
    symbol tables, provides lookup functionality for symbols, and keeps track of the
    resource managers used.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的类是`ExecutionSession`类。这个类表示正在运行的JIT程序。基本上，这意味着该类管理`JITDylib`符号表，为符号提供查找功能，并跟踪使用的资源管理器。
- en: 'The generic recipe for a JIT compiler is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: JIT编译器的通用配方如下：
- en: Initialize an instance of the `ExecutionSession` class.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化`ExecutionSession`类的一个实例。
- en: Initialize the layer, at least consisting of the `RTDyldObjectLinkingLayer`
    class and the `IRCompileLayer` class.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化层，至少包括`RTDyldObjectLinkingLayer`类和`IRCompileLayer`类。
- en: Create the first `JITDylib` symbol table, usually with `main` or a similar name.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第一个`JITDylib`符号表，通常使用`main`或类似的名称。
- en: 'The usage is very similar to the `LLJIT` class from the previous section:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法与上一节的`LLJIT`类非常相似：
- en: Add an IR module to the symbol table.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将IR模块添加到符号表中。
- en: Look up a symbol, the triggered compilation of the associated function, and
    possibly the whole module.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找符号，触发相关函数的编译，可能是整个模块。
- en: Execute the function.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行函数。
- en: In the next subsection, we will implement a JIT compiler class based on the
    generic recipe.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将基于通用配方实现一个JIT编译器类。
- en: Creating a JIT compiler class
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个JIT编译器类
- en: 'To keep the implementation of the JIT compiler class simple, we put everything
    into the `JIT.h` header file. The initialization of the class is a bit more complex.
    Due to the handling of possible errors, we need a factory method to create some
    objects upfront before we can call the constructor. The steps to create the class
    are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持JIT编译器类的实现简单，我们将所有内容放入`JIT.h`头文件中。类的初始化有点复杂。由于需要处理可能的错误，我们需要一个工厂方法在调用构造函数之前创建一些对象。创建类的步骤如下：
- en: 'We begin by guarding the header file against multiple inclusion with the `JIT_H`
    preprocessor definition:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先使用`JIT_H`预处理器定义保护头文件免受多次包含的影响：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A bunch of include files is required. Most of them provide a class with the
    same name as the header file. The `Core.h` header provides a couple of basic classes,
    including the `ExecutionSession` class. The `ExecutionUtils.h` header provides
    the `DynamicLibrarySearchGenerator` class to search libraries for symbols, which
    we already used in the *Implementing our own JIT compiler with LLJIT* section.
    The `CompileUtils.h` header provides the `ConcurrentIRCompiler` class:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要一堆包含文件。其中大多数提供与头文件同名的类。`Core.h`头文件提供了一些基本类，包括`ExecutionSession`类。`ExecutionUtils.h`头文件提供了`DynamicLibrarySearchGenerator`类来搜索库中的符号，我们已经在*使用LLJIT实现我们自己的JIT编译器*部分中使用过。`CompileUtils.h`头文件提供了`ConcurrentIRCompiler`类：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our new class is the `JIT` class:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新类是`JIT`类：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The private data members reflect the ORC layers and a helper class. The `ExecutionSession`,
    `ObjectLinkingLayer`, `CompileLayer`, `OptIRLayer`, and `MainJITDylib` instances
    represent the running JIT program, the layers, and the symbol table, as already
    described. The `TargetProcessControl` instance is used for interaction with the
    JIT target process. This can be the same process, another process on the same
    machine, or a remote process on a different machine, possible with a different
    architecture. The `DataLayout` and `MangleAndInterner` classes are required to
    mangle the symbols names in the correct way. The symbol names are internalized,
    which means that all equal names have the same address. To check whether two symbol
    names are equal, it is then sufficient to compare the addresses, which is a very
    fast operation:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私有数据成员反映了ORC层和一个辅助类。 `ExecutionSession`，`ObjectLinkingLayer`，`CompileLayer`，`OptIRLayer`和`MainJITDylib`实例代表了运行中的JIT程序，层和符号表，如前所述。
    `TargetProcessControl`实例用于与JIT目标进程进行交互。这可以是相同的进程，同一台机器上的另一个进程，或者是不同机器上的远程进程，可能具有不同的架构。
    `DataLayout`和`MangleAndInterner`类需要以正确的方式操纵符号名称。符号名称是内部化的，这意味着所有相等的名称具有相同的地址。要检查两个符号名称是否相等，只需比较地址，这是一个非常快速的操作：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The initialization is split into three parts. In C++, a constructor cannot return
    an error. The simple and recommended solution is to create a static factory method,
    which can do the error handling prior to constructing the object. The initialization
    of the layers is more complex, so we introduce factory methods for them, too.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化分为三个部分。在C++中，构造函数不能返回错误。简单且推荐的解决方案是创建一个静态工厂方法，在构造对象之前进行错误处理。层的初始化更复杂，因此我们也为它们引入了工厂方法。
- en: In the `create()` factory method, we first create a `SymbolStringPool` instance,
    which is used to implement string internalization and is shared by several classes.
    To take control of the current process, we create a `SelfTargetProcessControl`
    instance. If we want to target a different process, then we need to change this
    instance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`create()`工厂方法中，我们首先创建一个`SymbolStringPool`实例，用于实现字符串内部化，并由几个类共享。为了控制当前进程，我们创建一个`SelfTargetProcessControl`实例。如果我们想要针对不同的进程，则需要更改此实例。
- en: 'Then we construct a `JITTargetMachineBuilder` instance, for which we need to
    know the target triple of the JIT process. Next, we query the target machine builder
    for the data layout. This step can fail if the builder is not able to instantiate
    the target machine based on the triple provided, for example, because support
    for this target is not compiled into the LLVM libraries:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构造了一个`JITTargetMachineBuilder`实例，我们需要知道JIT进程的目标三元组。接下来，我们查询目标机器生成器以获取数据布局。如果生成器无法根据提供的三元组实例化目标机器，例如，因为对此目标的支持未编译到LLVM库中，这一步可能会失败：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At this point, we have handled all the calls that could potentially fail. We
    are now able to initialize the `ExecutionSession` instance. Finally, the constructor
    of the `JIT` class is called with all instantiated objects, and the result is
    returned to the caller:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经处理了所有可能失败的调用。我们现在能够初始化`ExecutionSession`实例。最后，调用`JIT`类的构造函数，并将结果返回给调用者：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The constructor of the `JIT` class moves the passed parameters to the private
    data members. The layer objects are constructed with a call to a static factory
    name with the `create` prefix. Each `layer` factory method requires a reference
    to the `ExecutionSession` instance, connecting the layer to the running JIT session.
    Except for the object linking layer, which is at the bottom of the layer stack,
    each layer also requires a reference to the previous layer, illustrating the stacking
    order:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JIT`类的构造函数将传递的参数移动到私有数据成员。通过调用带有`create`前缀的静态工厂名称构造层对象。每个`layer`工厂方法都需要引用`ExecutionSession`实例，将层连接到运行中的JIT会话。除了对象链接层位于层堆栈的底部之外，每个层还需要引用上一个层，说明了堆叠顺序：'
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the body of the constructor, we add the generator to search the current
    process for symbols. The `GetForCurrentProcess()` method is special, because the
    return value is wrapped in an `Expected<>` template, indicating that an `Error`
    object can also be returned. But we know that no error can occur – the current
    process will eventually run! Therefore, we unwrap the result with the `cantFail()`
    function, which terminates the application if an error occurred anyway:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数的主体中，我们添加了生成器来搜索当前进程的符号。`GetForCurrentProcess()`方法是特殊的，因为返回值包装在`Expected<>`模板中，表示也可以返回`Error`对象。但我们知道不会发生错误-当前进程最终会运行！因此，我们使用`cantFail()`函数解包结果，如果发生错误，它将终止应用程序：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To create the object linking layer, we need to provide a memory manager. We
    stick here to the default `SectionMemoryManager` class, but we could also provide
    a different implementation if needed:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建对象链接层，我们需要提供一个内存管理器。我们在这里坚持使用默认的`SectionMemoryManager`类，但如果需要，我们也可以提供不同的实现：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'A slight complication exists for the COFF object file format, which is used
    on Windows. This file format does not allow functions to be marked as exported.
    This subsequently leads to failures in checks inside the object linking layer:
    the flags stored in the symbol are compared with the flags from IR, which leads
    to a mismatch because of the missing export marker. The solution is to override
    the flags only for this file format. This finishes construction of the object
    layer, and the object is returned to the caller:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于在Windows上使用的COFF目标文件格式存在一个小复杂性。这种文件格式不允许将函数标记为导出。这随后导致在对象链接层内部的检查失败：存储在符号中的标志与IR中的标志进行比较，由于缺少导出标记而导致不匹配。解决方案是仅针对这种文件格式覆盖标志。这完成了对象层的构建，并将对象返回给调用者：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To initialize the compiler layer, an `IRCompiler` instance is needed. The `IRCompiler`
    instance is responsible for compiling an IR module into an object file. If our
    JIT compiler does not use threads, then we can use the `SimpleCompiler` class,
    which compiles the IR module using a given target machine. The `TargetMachine`
    class is not thread-safe, likewise the `SimpleCompiler` class, too. To support
    compilation with multiple threads, we use the `ConcurrentIRCompiler` class, which
    creates a new `TargetMachine` instance for each module to compile. This approach
    solves the problem with multiple threads:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要初始化编译器层，需要一个`IRCompiler`实例。`IRCompiler`实例负责将IR模块编译成目标文件。如果我们的JIT编译器不使用线程，那么我们可以使用`SimpleCompiler`类，它使用给定的目标机器编译IR模块。`TargetMachine`类不是线程安全的，同样`SimpleCompiler`类也不是。为了支持多线程编译，我们使用`ConcurrentIRCompiler`类，它为每个要编译的模块创建一个新的`TargetMachine`实例。这种方法解决了多线程的问题：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Instead of compiling the IR module directly to machine code, we install a layer
    that optimizes the IR first. This is a deliberate design decision: We turn our
    JIT compiler into an optimizing JIT compiler, which produces faster code that
    takes longer to produce, meaning a delay for the user. We do not add lazy compilation,
    so entire modules are compiled when just a symbol is looked up. This can add up
    to a significant time before the user sees the code executing.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不直接将IR模块编译成机器代码，而是安装一个优化IR的层。这是一个有意的设计决定：我们将我们的JIT编译器转变为一个优化的JIT编译器，它产生更快的代码，但需要更长的时间来生成，这对用户来说会有延迟。我们不添加延迟编译，所以当查找一个符号时，整个模块都会被编译。这可能会导致用户在看到代码执行之前花费相当长的时间。
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `optimizeModule()` function is an example of a transformation on an IR
    module. The function gets the module to transform as parameter, and returns the
    transformed one. Because the JIT can potentially run with multiple threads, the
    IR module is wrapped in a `ThreadSafeModule` instance:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`optimizeModule()`函数是对IR模块进行转换的一个示例。该函数以要转换的模块作为参数，并返回转换后的模块。由于JIT可能会使用多个线程，IR模块被包装在一个`ThreadSafeModule`实例中：'
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To optimize the IR, we recall some information from [*Chapter 8*](B15647_08_ePub_RK.xhtml#_idTextAnchor126),
    *Optimizing IR*, in the *Adding an optimization pipeline to your compiler* section.
    We require a `PassBuilder` instance to create an optimization pipeline. First,
    we define a couple of analysis managers, and register them afterward at the pass
    builder. Then we populate a `ModulePassManager` instance with the default optimization
    pipeline for the `O2` level. This is again a design decision: the `O2` level produces
    fast machine code already, but does this faster still than the `O3` level. Afterward,
    we run the pipeline on the module. Finally, the optimized module is returned to
    the caller:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了优化IR，我们回顾一些来自[*第8章*](B15647_08_ePub_RK.xhtml#_idTextAnchor126)的信息，*优化IR*，在*向编译器添加优化流水线*部分。我们需要一个`PassBuilder`实例来创建一个优化流水线。首先，我们定义了一些分析管理器，并在通行构建器中注册它们。然后，我们使用默认的优化流水线填充了一个`ModulePassManager`实例，用于`O2`级别。这再次是一个设计决定：`O2`级别已经产生了快速的机器代码，但比`O3`级别更快。之后，我们在模块上运行流水线。最后，优化后的模块返回给调用者：
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The client of the `JIT` class needs a way to add an IR module, which we provide
    with the `addIRModule()` function. Remember the layer stack we created: we must
    add the IR module to the top layer, otherwise we would accidently bypass some
    layers. This would be a programming error that is not easily spotted: if the `OptIRLayer`
    member is replaced by a `CompileLayer` member, then our `JIT` class still works,
    but not as an optimizing JIT because we have bypassed this layer. This is no cause
    for concern as regards this small implementation, but in a large JIT optimization,
    we would introduce a function to return the top-level layer:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JIT`类的客户端需要一种添加IR模块的方法，我们使用`addIRModule()`函数提供这种方法。记住我们创建的层栈：我们必须将IR模块添加到顶层，否则我们可能会意外地绕过一些层。这将是一个不容易发现的编程错误：如果`OptIRLayer`成员被`CompileLayer`成员替换，那么我们的`JIT`类仍然可以工作，但不作为一个优化的JIT，因为我们已经绕过了这一层。这在这个小实现中并不值得担心，但在一个大的JIT优化中，我们会引入一个函数来返回顶层层次：'
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Likewise, a client of our JIT class needs a way to look up a symbol. We delegate
    this to the `ExecutionSession` instance, passing in a reference to the main symbol
    table and the mangled and internalized name of the requested symbol:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们的JIT类的客户端需要一种查找符号的方法。我们将这个任务委托给`ExecutionSession`实例，传入主符号表的引用以及所请求符号的mangled和internalized名称：
- en: '[PRE49]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Putting the JIT compiler together was quite easy. Initializing the class is
    a bit tricky, as it involves a factory method and a constructor call for the `JIT`
    class, and factory methods for each layer. This distribution is caused by limitations
    in C++, although the code itself is simple.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将JIT编译器组合在一起相当容易。初始化这个类有点棘手，因为它涉及到`JIT`类的一个工厂方法和构造函数调用，以及每个层的工厂方法。这种分布是由于C++的限制，尽管代码本身很简单。
- en: In the next subsection, we are using our new JIT compiler class to implement
    a command-line utility.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将使用我们的新JIT编译器类来实现一个命令行实用程序。
- en: Using our new JIT compiler class
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用我们的新JIT编译器类
- en: 'The interface of our new JIT compiler class resembles the `LLJIT` class used
    in the *Implementing our own JIT compiler with LLJIT* section. To test our new
    implementation, we copy the `LIT.cpp` class from the previous section and make
    the following changes:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新JIT编译器类的接口类似于*使用LLJIT实现我们自己的JIT编译器*部分中使用的`LLJIT`类。为了测试我们的新实现，我们从上一节中复制`LIT.cpp`类，并进行以下更改：
- en: To be able to use our new class, we include the `JIT.h` header file. This replaces
    the `llvm/ExecutionEngine/Orc/LLJIT.h` header file, which is no longer required
    because we are no longer using the LLJIT class.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够使用我们的新类，我们包含`JIT.h`头文件。这取代了`llvm/ExecutionEngine/Orc/LLJIT.h`头文件，因为我们不再使用LLJIT类，所以它不再需要。
- en: Inside the `jitmain()` function, we replace the call to `orc::LLJITBuilder().create()`
    with a call to our new `JIT::create()` method.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jitmain()`函数中，我们用对我们的新`JIT::create()`方法的调用替换了对`orc::LLJITBuilder().create()`的调用。
- en: Again, in the `jitmain()` function, we remove the code to add the `DynamicLibrarySearchGenerator`
    class. Precisely this generator is integrated in the JIT class.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在`jitmain()`函数中，我们删除了添加`DynamicLibrarySearchGenerator`类的代码。这个生成器已经集成在JIT类中。
- en: This is already everything that needs to be changed! We can compile and run
    the changed application as in the previous section, with the same result. Under
    the hood, the new class uses a fixed optimization level, so with sufficiently
    large modules, we can note the differences in startup and runtime.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是需要改变的一切了！我们可以像在上一节中一样编译和运行更改后的应用程序，得到相同的结果。在底层，新类使用了固定的优化级别，因此对于足够大的模块，我们可以注意到启动和运行时的差异。
- en: Having a JIT compiler at hand can stimulate new ideas. In the next section,
    we will look at how we can use the JIT compiler as part of a static compiler to
    evaluate code at compile time.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有JIT编译器可以激发新的想法。在下一节中，我们将看看如何将JIT编译器作为静态编译器的一部分来评估编译时的代码。
- en: Utilizing a JIT compiler for code evaluation
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用JIT编译器进行代码评估
- en: Compiler writers make a great effort to produce optimal code. A simple, yet
    effective, optimization is to replace an arithmetic operation on two constants
    by the result value of this operation. To be able to perform the computation,
    an interpreter for constant expressions is embedded. And to arrive at the same
    result, the interpreter has to implement the same rules as the generated machine
    code! Of course, this can be the source of subtle errors.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器编写者付出了巨大的努力来生成最佳代码。一个简单而有效的优化是用两个常量替换算术运算的结果值。为了能够执行计算，嵌入了一个常量表达式的解释器。为了得到相同的结果，解释器必须实现与生成的机器代码相同的规则！当然，这可能是微妙错误的源泉。
- en: A different approach would be to compile the constant expression to IR using
    the same code generations methods, and then have JIT compile and execute the IR.
    This idea can even be taken a step further. In mathematics, a function always
    produces the same result for the same input. For functions in computer languages,
    this is not true. A good example is the `rand()` function, which returns a random
    value for each call. A function in computer languages, which has the same characteristic
    as a function in mathematics, is called a **pure function**. During the optimization
    of expressions, we could JIT-compile and execute pure functions, which only have
    constant parameters, and replace the call to the function with the result returned
    from JIT execution. Effectively, we move the execution of the function from runtime
    to compile time!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用相同的代码生成方法将常量表达式编译为IR，然后让JIT编译和执行IR。这个想法甚至可以进一步发展。在数学中，函数对于相同的输入总是产生相同的结果。对于计算机语言中的函数，这并不成立。一个很好的例子是`rand()`函数，它每次调用都返回一个随机值。在计算机语言中，具有与数学函数相同特性的函数称为**纯函数**。在表达式优化期间，我们可以JIT编译和执行只有常量参数的纯函数，并用JIT执行返回的结果替换对函数的调用。实际上，我们将函数的执行从运行时移到了编译时！
- en: Think about cross-compilation
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑交叉编译
- en: Using a JIT compiler as part of a static compiler is an interesting option.
    However, if the compiler were to support cross-compilation, then this approach
    should be well thought-out. The usual candidates causing trouble are floating-point
    types. The precision of the `long double` type in C often depends on the hardware
    and the operation system. Some systems use 128-bit floating points, while others
    only use 64-bit floating points. The 80-bit floating point type is only available
    on the x86 platform, and usually only used on Windows. Performing the same floating-point
    operation with different precision can result in huge differences. Evaluation
    through JIT compilation cannot be used in such cases.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态编译器中使用JIT编译器是一个有趣的选择。然而，如果编译器支持交叉编译，那么这种方法应该经过深思熟虑。通常会引起麻烦的候选者是浮点类型。C语言中`long
    double`类型的精度通常取决于硬件和操作系统。一些系统使用128位浮点数，而其他系统只使用64位浮点数。80位浮点类型仅在x86平台上可用，并且通常仅在Windows上使用。使用不同精度进行相同的浮点运算可能会导致巨大差异。在这种情况下，无法使用JIT编译进行评估。
- en: It cannot easily be decided whether a function is pure. The common solution
    is to apply a heuristic. If a function does not read or write into heap memory,
    either through pointers or indirectly with the use of aggregate types, and only
    calls other pure functions, then it is a pure function. The developer can aid
    the compiler, and mark pure functions, for example, with a special keyword or
    symbol. In the semantic analysis phase, the compiler can then check for violations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 很难确定一个函数是否是纯函数。常见的解决方案是应用一种启发式方法。如果一个函数既不通过指针也不通过聚合类型间接地读取或写入堆内存，并且只调用其他纯函数，那么它就是一个纯函数。开发人员可以帮助编译器，例如，用特殊的关键字或符号标记纯函数。在语义分析阶段，编译器可以检查违规情况。
- en: In the next subsection, we will take a closer look at the implications for language
    semantics when trying to JIT-execute a function at compile time.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将更仔细地看一下在编译时尝试对函数进行JIT执行时对语言语义的影响。
- en: Identifying the language semantics
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别语言语义
- en: The difficult part is indeed to decide at the language semantics level which
    parts of the language are suitable for evaluation at compile time. Excluding access
    to heap memory is very restrictive. In general terms, it rules out string handling,
    for example. Using heap memory becomes problematic when the allocated memory survives
    the lifetime of the JIT-executed function. This is a program state, which can
    influence other results, and is therefore dangerous. On the other hand, if there
    are matched calls to `malloc()` and `free()` functions, then the memory is only
    used for internal calculation. In this case, the use of heap memory would be safe.
    But precisely this condition is not easy to proof.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 困难的部分确实是在语言语义层面决定哪些语言部分适合在编译时进行评估。排除对堆内存的访问是非常限制性的。一般来说，这排除了字符串处理，例如。当分配的内存的生存周期超过JIT执行的函数的生存周期时，使用堆内存就会变得棘手。这是一个程序状态，可能会影响其他结果，因此是危险的。另一方面，如果`malloc()`和`free()`函数有匹配的调用，那么内存只用于内部计算。在这种情况下，使用堆内存是安全的。但要证明这种条件并不容易。
- en: At a similar level, an infinite loop inside the JIT-executed function can freeze
    the compiler. Alan Turing showed in 1936 that no machine can decide whether a
    function will produce a result or whether it is stuck in an endless loop. Some
    precautions must be taken to avoid this situation, for example, a runtime limit
    after which the JIT-executed function is terminated.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的层面上，JIT执行函数中的无限循环可能会使编译器冻结。艾伦·图灵在1936年表明，没有机器可以决定一个函数是否会产生结果，或者它是否陷入无休止的循环。必须采取一些预防措施来避免这种情况，例如，在JIT执行的函数被终止之前设置一个运行时限制。
- en: 'And last, the more that functionality is allowed, the more thoughts must be
    put into security, because the compiler now executes code written by someone else.
    Just imagine that this code downloads and runs files from the internet or tries
    to erase the hard disk: with too much state allowed for JIT-executed functions,
    we also need to think about such scenarios.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，允许更多功能，就必须更多地考虑安全性，因为编译器现在执行的是其他人编写的代码。想象一下，这段代码从互联网下载并运行文件，或者试图擦除硬盘：如果允许JIT执行函数有太多状态，我们也需要考虑这样的情况。
- en: The idea is not new. The D programming language has a feature called **compile-time
    function execution**. The reference compiler **dmd** implements this feature by
    interpretation of the functions at the AST level. The LLVM-based LDC compiler
    has an experimental feature to use the LLVM JIT engine for it. You can find out
    more about the language and the compilers at https://dlang.org/.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法并不新鲜。D编程语言有一个名为**编译时函数执行**的功能。参考编译器**dmd**通过在AST级别解释函数来实现这一功能。基于LLVM的LDC编译器具有一个试验性的功能，可以使用LLVM
    JIT引擎。您可以在https://dlang.org/了解更多关于该语言和编译器的信息。
- en: 'Ignoring the semantic challenges, the implementation is not that difficult.
    In the *Building a JIT compiler class from scratch* section, we developed a JIT
    compiler with the `JIT` class. We feed an IR module in the class, and we can look
    up and execute a function from this module. Looking at the `tinylang` compiler
    implementation, we can clearly identify access to constants, because there is
    a `ConstantAccess` node in the AST. For example, there is code like the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略语义上的挑战，实现并不那么困难。在“从头开始构建JIT编译器类”部分，我们使用`JIT`类开发了一个JIT编译器。我们在类中输入一个IR模块，然后可以查找并执行该模块中的函数。通过查看`tinylang`编译器的实现，我们可以清楚地识别对常量的访问，因为AST中有一个`ConstantAccess`节点。例如，有如下代码：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Instead of interpreting the operations in the expression to derive the value
    of the constant, we can do the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与其解释表达式中的操作以推导常量的值，我们可以做如下操作：
- en: Create a new IR module.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的IR模块。
- en: Create an IR function in the module, returning a value of the expected type.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块中创建一个IR函数，返回预期类型的值。
- en: Use the existing `emitExpr()` function to create the IR for the expression and
    return the calculated value with the last instruction.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用现有的`emitExpr()`函数为表达式创建IR，并使用最后一条指令返回计算出的值。
- en: JIT-execute the function to calculate the value.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JIT执行函数以计算值。
- en: Is this worth implementing? LLVM performs constant propagation and function
    inlining as part of the optimization pipeline. A simple expression such as 4 +
    5 is already replaced during IR construction with the result. Small functions
    such as calculation of the greatest common divisor are inlined. If all parameters
    are constant values, then the inlined code gets replaced by the result of the
    calculation through constant propagation.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这值得实现吗？LLVM在优化管道中执行常量传播和函数内联。例如，一个简单的表达式如4 + 5在IR构造过程中已经被替换为结果。像最大公约数的计算这样的小函数会被内联。如果所有参数都是常量值，那么内联的代码会通过常量传播的计算结果被替换。
- en: Based on this observation, an implementation of this approach is only useful
    if enough language features are available for execution at compile time. If this
    is the case, then it is fairly easily implemented using the given sketch.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一观察，这种方法的实现只有在编译时有足够的语言特性可供执行时才有用。如果是这种情况，那么使用给定的草图实现起来是相当容易的。
- en: Knowing how to utilize the JIT compiler component of LLVM enables you to use
    LLVM in whole new ways. Besides implementing a JIT compiler like the Java VM,
    the JIT compiler can also be embedded in other applications. This allows creative
    approaches, such as its use inside a static compiler, which you looked at in this
    section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用LLVM的JIT编译器组件使您能够以全新的方式使用LLVM。除了实现类似Java虚拟机的JIT编译器之外，JIT编译器还可以嵌入到其他应用程序中。这允许创造性的方法，比如在本节中所看到的将其用于静态编译器。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to develop a JIT compiler. You began with possible
    applications of JIT compilers, and you explored `lli`, the LLVM dynamic compiler
    and interpreter. Using the predefined `LLJIT` class, you built a tool similar
    to `lli` on your own. To be able to take advantage of the layered structure of
    the ORC API, you implemented an optimizing `JIT` class. Having acquired all this
    knowledge, you explored the possibility of using a JIT compiler inside a static
    compiler, a feature from which some languages can benefit.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何开发JIT编译器。您从JIT编译器的可能应用开始，并探索了LLVM动态编译器和解释器`lli`。使用预定义的`LLJIT`类，您自己构建了类似于`lli`的工具。为了能够利用ORC
    API的分层结构，您实现了一个优化的`JIT`类。在获得了所有这些知识之后，您探讨了在静态编译器内部使用JIT编译器的可能性，这是一些语言可以受益的特性。
- en: In the next chapter, you will examine how to add a backend for a new CPU architecture
    to LLVM.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何为新的CPU架构向LLVM添加后端。
