- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Coroutines and Lazy Generators
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程和惰性生成器
- en: Computing has become a world of waiting, and we need support in our programming
    languages to be able to express *wait*. The general idea is to suspend (temporarily
    pause) the current flow and hand execution over to some other flow, whenever it
    reaches a point where we know that we might have to wait for something. This *something*
    that we need to wait for could be a network request, a click from a user, a database
    operation, or even a memory access that is taking too long for us to block at.
    Instead, we say in our code that we will wait, continue some other flow, and then
    come back when ready. Coroutines allow us to do that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算已经成为一个等待的世界，我们需要编程语言的支持来表达*等待*。一般的想法是在当前流到达我们知道可能需要等待某些东西的点时，暂停（暂时暂停）当前流，并将执行交给其他流。我们需要等待的*某些东西*可能是网络请求、用户的点击、数据库操作，甚至是花费太长时间的内存访问。相反，我们在代码中说我们会等待，继续一些其他流，然后在准备好时回来。协程允许我们这样做。
- en: In this chapter, we're mainly going to focus on coroutines added to C++20\.
    You will learn what they are, how to use them, and their performance characteristics.
    But we will also spend some time looking at coroutines in a broader sense, since
    the concept is apparent in many other languages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们主要将关注添加到C++20中的协程。您将学习它们是什么，如何使用它们以及它们的性能特征。但我们也将花一些时间来更广泛地看待协程，因为这个概念在许多其他语言中都是明显的。
- en: C++ coroutines come with very little support from the standard library. Adding
    standard library support for coroutines is a high-priority feature for the C++23
    release. In order to use coroutines effectively in our day-to-day code, we need
    to implement some general abstractions. This book will show you how to implement
    these abstractions for the purpose of learning C++ coroutines rather than providing
    you with production-ready code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: C++协程在标准库中的支持非常有限。为C++23发布添加协程的标准库支持是一个高优先级的功能。为了在日常代码中有效地使用协程，我们需要实现一些通用的抽象。本书将向您展示如何实现这些抽象，以便学习C++协程，而不是为您提供生产就绪的代码。
- en: It's also important to understand the various types of coroutines that exist,
    what coroutines can be used for, and what motivated C++ to add new language features
    to support coroutines.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 了解存在的各种类型的协程，协程可以用于什么，以及是什么促使C++添加新的语言特性来支持协程。
- en: 'This chapter covers a lot of ground. The next chapter is also about coroutines
    but with a focus on asynchronous applications. In summary, this chapter will guide
    you through:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了很多内容。下一章也是关于协程，但重点是异步应用程序。总之，本章将引导您完成：
- en: General theory about coroutines, including the difference between stackful and
    stackless coroutines, and how they are transformed by the compiler and executed
    on a computer.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于协程的一般理论，包括有栈和无栈协程之间的区别，以及编译器如何转换它们并在计算机上执行。
- en: An introduction to stackless coroutines in C++. The new language support for
    coroutines in C++20 using `co_await`, `co_yield`, and `co_return` will be discussed
    and demonstrated.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍C++中无栈协程。将讨论和演示C++20对协程的新语言支持，包括`co_await`、`co_yield`和`co_return`。
- en: The abstractions that are needed for using C++20 coroutines as generators.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++20协程作为生成器所需的抽象。
- en: A few real-world examples that show the benefits in terms of readability and
    simplicity of using coroutines and how we can write composable components that
    will evaluate lazily by using coroutines.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些真实世界的例子展示了使用协程的可读性和简单性的好处，以及我们如何通过使用协程编写可组合的组件，以便进行惰性评估。
- en: 'If you have been working with coroutines in other languages, you need to be
    prepared for two things before reading the rest of this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经在其他语言中使用协程，那么在阅读本章的其余部分之前，您需要做好两件事：
- en: Some content may feel basic to you. Although the details about how C++ coroutines
    work are far from trivial, the usage examples might feel trivial to you.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对您来说，一些内容可能感觉很基础。尽管C++协程的工作原理的细节远非微不足道，但使用示例可能对您来说感觉微不足道。
- en: Some terms we will use in this chapter (coroutines, generators, tasks, and so
    forth) might not align with your current view of what these are.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中我们将使用的一些术语（协程、生成器、任务等）可能与您当前对这些内容的看法不一致。
- en: On the other hand, if you are completely new to coroutines, parts of this chapter
    may very well look like magic and take some time to grasp. I will therefore begin
    by showing you a few examples of how C++ code can look when using coroutines.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您对协程完全不熟悉，本章的部分内容可能看起来像魔术一样，需要一些时间来理解。因此，我将首先向您展示一些使用协程时C++代码的例子。
- en: A few motivating examples
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些激励性的例子
- en: Coroutines are one of those features, similar to lambda expressions, that offer
    a way to completely change the way we write and think about C++ code. The concept
    is very general and can be applied in many different ways. To give you a taste
    of how C++ can look when using coroutines, we will here look briefly at two examples.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是一种类似于lambda表达式的功能，它提供了一种完全改变我们编写和思考C++代码的方式。这个概念非常普遍，可以以许多不同的方式应用。为了让您了解使用协程时C++的样子，我们将在这里简要地看两个例子。
- en: 'Yield-expressions can be used for implementing generators—objects that produce
    sequences of values lazily. In this example, we will use the keywords `co_yield`
    and `co_return` to control the flow:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用yield表达式来实现生成器——产生值序列的对象。在这个例子中，我们将使用关键字`co_yield`和`co_return`来控制流程：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, `iota()` and `take_until()` are coroutines. `iota()`
    generates a sequence of integers and `take_until()` yields values until it finds
    the specified value. The `Generator` template is a custom type that I will show
    you how to design and implement later on in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`iota()`和`take_until()`是协程。`iota()`生成一个整数序列，`take_until()`在找到指定值之前产生值。`Generator`模板是一种自定义类型，我将在本章后面向您展示如何设计和实现它。
- en: 'Building generators is one common use case for coroutines, another one is implementing
    asynchronous tasks. The next example will demonstrate how we can use the operator
    `co_await` to wait for something without blocking the currently executing thread:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 构建生成器是协程的一个常见用例，另一个是实现异步任务。下一个示例将演示我们如何使用操作符`co_await`来等待某些内容，而不会阻塞当前执行的线程：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Instead of blocking, `co_await` suspends the execution until it gets resumed
    and the asynchronous read and write functions have completed. The example presented
    here is incomplete because we don't know what `Task`, `socket`, `buffer`, and
    the asynchronous I/O functions are. But we will get there in the next chapter
    when focusing on asynchronous tasks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`co_await`不会阻塞，而是在异步读写函数完成并恢复执行之前暂停执行。这里介绍的示例是不完整的，因为我们不知道`Task`、`socket`、`buffer`和异步I/O函数是什么。但是在下一章中，当我们专注于异步任务时，我们会了解到这些内容。'
- en: Don't worry if it is not clear how these examples work at this point—we will
    spend a lot of time delving into the details later on in this chapter. The examples
    are here to give you a hint about what coroutines allow us to do if you have never
    encountered them before.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目前还不清楚这些示例是如何工作的，不要担心——我们将在本章后面花费大量时间深入了解细节。这些示例是为了给你一个关于协程允许我们做什么的提示，如果你以前从未遇到过它们。
- en: Before digging into C++20 coroutines, we need to discuss some terminology and
    common foundational ground to better understand the design and motivation for
    adding a rather complicated language feature to C++ in 2020.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究C++20协程之前，我们需要讨论一些术语和共同的基础知识，以更好地理解为什么在2020年向C++中添加一个相当复杂的语言特性的设计和动机。
- en: The coroutine abstraction
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程抽象
- en: We will now take a step back and talk about coroutines in general and not just
    focus on the coroutines added to C++20\. This will give you a better understanding
    of why coroutines are useful but also what types of coroutines there are and how
    they differ. If you are already familiar with stackful and stackless coroutines
    and how they are executed, you can skip this section and jump right to the next
    section, *Coroutines in C++*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将退后一步，谈论一般的协程，而不仅仅是专注于添加到C++20的协程。这将让你更好地理解为什么协程是有用的，以及有哪些类型的协程以及它们之间的区别。如果你已经熟悉了有栈和无栈协程以及它们是如何执行的，你可以跳过这一部分，直接转到下一部分，*C++中的协程*。
- en: The coroutine abstraction has been around for more than 60 years and many languages
    have adopted some sort of coroutines into their syntax or standard libraries.
    This means that coroutines can denote slightly different things in different languages
    and environments. Since this is a book about C++, I will use the terminology used
    in the C++ standard.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 协程抽象已经存在了60多年，许多语言已经将某种形式的协程纳入其语法或标准库中。这意味着协程在不同的语言和环境中可能表示不同的东西。由于这是一本关于C++的书，我将使用C++标准中使用的术语。
- en: Coroutines are very similar to subroutines. In C++, we don't have anything explicitly
    called subroutines; instead, we write functions (free functions or member functions,
    for example) to create subroutines. I will use the terms **ordinary functions**
    and **subroutines** interchangeably.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 协程与子例程非常相似。在C++中，我们没有明确称为子例程的东西；相反，我们编写函数（例如自由函数或成员函数）来创建子例程。我将交替使用术语**普通函数**和**子例程**。
- en: Subroutines and coroutines
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子例程和协程
- en: 'To understand the difference between coroutines and subroutines (ordinary functions),
    we will here focus on the most basic properties of subroutines and coroutines,
    namely, how to start, stop, pause, and resume them. A subroutine is started when
    some other part of our program calls it. When the subroutine returns back to the
    caller, the subroutine stops:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解协程和子例程（普通函数）之间的区别，我们将在这里专注于子例程和协程的最基本属性，即如何启动、停止、暂停和恢复它们。当程序的其他部分调用子例程时，子例程就会启动。当子例程返回到调用者时，子例程就会停止：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The call chain of subroutines is strictly nested. In the diagram that follows,
    subroutine `f()` cannot return to `main()` until subroutine `g()` has returned:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 子例程的调用链是严格嵌套的。在接下来的图表中，子例程`f()`在子例程`g()`返回之前无法返回到`main()`：
- en: '![](img/B15619_12_01.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_01.png)'
- en: 'Figure 12.1: A chain of subroutine calls and returns'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：子例程调用和返回的链
- en: 'Coroutines can also be started and stopped just like subroutines, but they
    can also be **suspended** (paused) and **resumed**. If you haven''t worked with
    coroutines before, this may seem very strange at first. The point where a coroutine
    is suspended and resumed is called a **suspend/resume point**. Some suspend points
    are implicit whereas others are explicitly marked in the code in one way or another.
    The following pseudo code shows three explicit suspend/resume points marked using
    `await` and `yield`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 协程也可以像子例程一样启动和停止，但它们也可以被**挂起**（暂停）和**恢复**。如果你以前没有使用过协程，这一点可能一开始看起来很奇怪。协程被挂起和恢复的地方称为**挂起/恢复点**。有些挂起点是隐式的，而其他挂起点则以某种方式在代码中明确标记。以下伪代码显示了使用`await`和`yield`标记的三个显式挂起/恢复点：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In C++, the explicit suspend points are marked using the keywords `co_await`
    and `co_yield`. The diagram that follows shows how a coroutine is invoked (called)
    from one subroutine and then later resumed from different parts of the code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，使用关键字`co_await`和`co_yield`标记显式的挂起点。下面的图表显示了协程如何从一个子例程中调用，然后稍后从代码的不同部分恢复：
- en: '![](img/B15619_12_02.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_02.png)'
- en: 'Figure 12.2: An invocation of a coroutine can suspend and resume. The coroutine
    invocation maintains its internal state while being suspended.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：协程的调用可以挂起和恢复。协程调用在被挂起时保持其内部状态。
- en: The states of local variables inside a coroutine are preserved while the coroutine
    is suspended. The states belong to a certain invocation of a coroutine. That is,
    they are not like static local variables, which are globally shared among all
    invocations of a function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 协程被挂起时，协程内部的局部变量状态会被保留。这些状态属于协程的某次调用。也就是说，它们不像静态局部变量那样，静态局部变量在函数的所有调用之间是全局共享的。
- en: To summarize, coroutines are subroutines that also can be suspended and resumed.
    Another way to look at it is to say that subroutines are a specialization of coroutines
    that cannot be suspended or resumed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，协程是可以被挂起和恢复的子例程。另一种看待它的方式是说，子例程是无法被挂起或恢复的协程的一种特例。
- en: From now on, I will be very strict when distinguishing between *call* and *resume*,
    and *suspend* and *return*. They mean completely different things. Calling a coroutine
    creates a new instance of a coroutine that can be suspended and resumed. Returning
    from a coroutine destroys the coroutine instance and it can no longer be resumed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我将在区分*调用*和*恢复*，以及*挂起*和*返回*时非常严格。它们意味着完全不同的事情。调用协程会创建一个可以被挂起和恢复的协程的新实例。从协程返回会销毁协程实例，它将无法再恢复。
- en: To really understand how coroutines can help us write efficient programs, you
    need to be aware of some low-level details about how functions in C++ are usually
    transformed to machine code and then executed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解协程如何帮助我们编写高效的程序，您需要了解一些关于C++函数通常如何转换为机器代码然后执行的低级细节。
- en: Executing subroutines and coroutines on the CPU
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在CPU上执行子例程和协程
- en: We have talked about memory hierarchies, caches, virtual memory, scheduling
    of threads, and other hardware and operating system concepts in this book. But
    we haven't really talked about how instructions are being executed on the CPU
    using CPU registers and the stack. These concepts are important to understand
    when comparing subroutines with various flavors of coroutines.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经讨论了内存层次结构、缓存、虚拟内存、线程调度和其他硬件和操作系统概念。但我们并没有真正讨论指令是如何使用CPU寄存器和堆栈在CPU上执行的。当比较子例程与各种协程时，了解这些概念是很重要的。
- en: CPU registers, instructions, and the stack
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPU寄存器、指令和堆栈
- en: This section will provide a very simplified model of a CPU for the purpose of
    understanding context switching, function calls, and a few more details regarding
    the call stack. When I say CPUs in this context, I refer to some CPUs that are
    similar to the x86 family of CPUs equipped with multiple general-purpose registers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将提供一个非常简化的CPU模型，以便理解上下文切换、函数调用以及关于调用堆栈的更多细节。在这种情况下，当我提到CPU时，我指的是一些类似于带有多个通用寄存器的x86系列CPU的CPU。
- en: A program contains a sequence of instructions that the CPU executes. The sequence
    of instructions is stored somewhere in the memory of the computer. The CPU keeps
    track of the address of the currently executing instruction in a register called
    a **program counter**. In that way, the CPU knows what instruction to execute
    next.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 程序包含CPU执行的一系列指令。指令序列存储在计算机的某个地方的内存中。CPU通过一个称为**程序计数器**的寄存器跟踪当前执行指令的地址。这样，CPU就知道下一个要执行的指令是什么。
- en: The CPU contains a fixed number of registers. A register is similar to a variable
    with a predefined name that can store a value or a memory address. Registers are
    the fastest data storage available on a computer and sit closest to the CPU. When
    the CPU manipulates data, it uses the registers. Some of the registers have a
    special meaning to the CPU, whereas other registers can be used more freely by
    the currently executing program.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: CPU包含固定数量的寄存器。寄存器类似于具有预定义名称的变量，可以存储值或内存地址。寄存器是计算机上最快的数据存储器，并且最接近CPU。当CPU操作数据时，它使用寄存器。一些寄存器对CPU具有特殊意义，而其他寄存器可以由当前执行的程序更自由地使用。
- en: 'Two very important registers that have a special meaning to the CPU are:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对CPU具有特殊意义的两个非常重要的寄存器是：
- en: '**Program counter** (**PC**): The register that stores the memory address of
    the currently executing instruction. This value is automatically incremented whenever
    an instruction is executed. Sometimes it is also called an *instruction pointer*.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序计数器**（**PC**）：存储当前执行指令的内存地址的寄存器。每当执行一条指令时，该值会自动递增。有时它也被称为*指令指针*。'
- en: '**Stack pointer** (**SP**): It stores the address of the top of the currently
    used call stack. Allocating and deallocating stack memory is a matter of changing
    the value stored in this single register.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆栈指针**（**SP**）：它存储当前使用的调用堆栈顶部的地址。分配和释放堆栈内存只是改变这个单个寄存器中存储的值的问题。'
- en: '![](img/B15619_12_03.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_03.png)'
- en: 'Figure 12.3: A CPU with registers'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：带有寄存器的CPU
- en: 'Assume that the registers are called **R0**, **R1**, **R2**, and **R3** as
    in the preceding diagram. A typical arithmetic instruction could then look like
    this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设寄存器被称为**R0**、**R1**、**R2**和**R3**，如前图所示。典型的算术指令可能如下所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Data can also be copied between registers and memory:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 数据也可以在寄存器和内存之间复制：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A set of instructions refers implicitly to the call stack. The CPU knows where
    the top of the call stack is through the stack pointer. Allocating memory on the
    stack is only a matter of updating the stack pointer. The value increases or decreases
    depending on whether the stack grows towards higher or lower addresses.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一组指令隐含地指向调用堆栈。CPU通过堆栈指针知道调用堆栈的顶部在哪里。在堆栈上分配内存只是更新堆栈指针的问题。该值增加或减少取决于堆栈是向更高地址还是更低地址增长。
- en: 'The following instruction uses the stack:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令使用了堆栈：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The push instruction copies the value in the register to the place in memory
    pointed at by the stack pointer *and* increments (or decrements) the stack pointer.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: push指令将寄存器中的值复制到由堆栈指针指向的内存位置，并递增（或递减）堆栈指针。
- en: 'We can also pop values from the stack by using the `pop` instruction, which
    also reads and updates the stack pointer:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`pop`指令从堆栈中弹出值，并读取和更新堆栈指针：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Whenever an instruction is executed, the CPU automatically increments the program
    counter. But the program counter can also be explicitly updated through instructions,
    for example, the `jump` instruction:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每当执行一条指令时，CPU会自动递增程序计数器。但程序计数器也可以通过指令明确更新，例如`jump`指令：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The CPU can operate in two modes: user mode or kernel mode. The CPU registers
    are used differently when running in user mode and kernel mode. When the CPU is
    executing in user mode, it runs with restricted privileges that cannot access
    hardware. The operating system provides system calls that run in kernel mode.
    A C++ library function such as `std::puts()`, which prints values to `stdout`,
    must therefore make a system call to complete its task, forcing the CPU to switch
    between user mode and kernel mode.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: CPU可以以两种模式运行：用户模式或内核模式。当CPU在用户模式下运行时，它以不同的方式使用CPU寄存器。当CPU在用户模式下执行时，它以无法访问硬件的受限权限运行。操作系统提供在内核模式下运行的系统调用。因此，C++库函数（例如`std::puts()`）必须进行系统调用才能完成其任务，迫使CPU在用户模式和内核模式之间切换。
- en: Transitioning between user and kernel mode is expensive. To understand why,
    let's think about our schematic CPU again. The CPU operates efficiently by using
    its registers and therefore avoids spilling values onto the stack unnecessarily.
    But the CPU is a shared resource among all user processes and the operating system,
    and whenever we need to switch between tasks (for example, when entering kernel
    mode), the state of the processor, including all of its registers, needs to be
    saved in memory so that it can be resumed later on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户模式和内核模式之间转换是昂贵的。要理解原因，让我们再次考虑我们的示意CPU。CPU通过使用其寄存器高效运行，因此避免不必要地将值溢出到堆栈上。但是CPU是所有用户进程和操作系统之间共享的资源，每当我们需要在任务之间切换时（例如，进入内核模式时），处理器的状态，包括其所有寄存器，都需要保存在内存中，以便以后可以恢复。
- en: Call and return
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用和返回
- en: Now that you have a basic understanding of how the CPU uses registers and the
    stack, we can discuss subroutine invocations. There are a lot of mechanisms involved
    when calling and returning from a subroutine that we might take for granted. Our
    compilers are doing an excellent job when they transform a C++ function to highly
    optimized machine code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经基本了解了CPU如何使用寄存器和堆栈，我们可以讨论子例程调用。在调用和返回子例程时涉及许多机制，我们可能会认为这是理所当然的。当编译器将C++函数转换为高度优化的机器代码时，它们的工作非常出色。
- en: 'The following list shows the aspects that need to be considered when calling,
    executing, and returning from a subroutine:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了调用、执行和从子例程返回时需要考虑的方面：
- en: Calling and returning (jumping between points in the code).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用和返回（在代码中跳转）。
- en: Passing parameters—parameters can be passed through registers or on the stack,
    or both.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递参数——参数可以通过寄存器或堆栈传递，也可以两者兼而有之。
- en: Allocating storage for local variables on the stack.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆栈上为局部变量分配存储空间。
- en: Returning a value—the value returned from a subroutine needs to be stored in
    a place where the caller can find it. Typically, this is a dedicated CPU register.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值——从子例程返回的值需要存储在调用者可以找到的地方。通常，这是一个专用的CPU寄存器。
- en: Using registers without interfering with other functions—the registers that
    a subroutine uses need to be restored to the state they were in before the subroutine
    was called.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不干扰其他函数的情况下使用寄存器——子例程使用的寄存器需要在调用子例程之前恢复到其调用之前的状态。
- en: The exact details about how function calls are carried out are specified by
    something called **calling conventions**. They provide a protocol for the caller/callee
    to agree on who is responsible for which parts. Calling conventions differ among
    CPU architectures and compilers and are one of the major parts that constitutes
    an **application binary interface** (**ABI**).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何执行函数调用的确切细节由称为**调用约定**的东西指定。它们为调用者/被调用者提供了一个协议，以便双方就谁负责哪些部分达成一致。调用约定在CPU架构和编译器之间不同，并且是构成**应用程序二进制接口**（**ABI**）的主要部分之一。
- en: 'When a function is being called, a **call frame** (or activation frame) for
    that function is being created. The call frame contains:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，该函数的**调用帧**（或激活帧）被创建。调用帧包含：
- en: The *parameters* passed to the function.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给函数的*参数*。
- en: The *local variables* of the function.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的*局部变量*。
- en: A *snapshot of the registers* that we intend to use and therefore need to restore
    before returning.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们打算使用的寄存器的*快照*，因此需要在返回之前恢复。
- en: A *return address* that links back to the place in memory where the caller invoked
    the function from.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*返回地址*，它链接回调用者从中调用函数的内存位置。'
- en: An optional *frame pointer* that points back to the top of the caller's call
    frame. Frame pointers are useful for debuggers when inspecting the stack. We will
    not discuss frame pointers further in this book.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的*帧指针*，指向调用者的调用帧顶部。在检查堆栈时，帧指针对调试器很有用。我们在本书中不会进一步讨论帧指针。
- en: Thanks to the strictly nested nature of subroutines, we can save the call frames
    of the subroutines on the stack to support nested calls very efficiently. A call
    frame stored on the stack is usually called a **stack frame**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于子例程的严格嵌套性质，我们可以将子例程的调用帧有效地保存在堆栈上，以支持嵌套调用。存储在堆栈上的调用帧通常称为**堆栈帧**。
- en: 'The following diagram shows multiple call frames on a call stack and highlights
    the contents of a single call frame:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了调用堆栈上的多个调用帧，并突出显示了单个调用帧的内容：
- en: '![](img/B15619_12_04.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_04.png)'
- en: 'Figure 12.4: A call stack with multiple call frames. The call frame on the
    right-hand side is a zoomed-in version of a single call frame.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：具有多个调用帧的调用堆栈。右侧的调用帧是单个调用帧的放大版本。
- en: When a subroutine returns back to its caller, it uses the return address to
    know where to jump, restores the registers it has mutated, and pops (deallocates)
    the entire call frame off the stack. In this way, both the stack and the registers
    are restored to the states they were in before the call of the subroutine was
    invoked. However, there are two exceptions. Firstly, the program counter (PC)
    has moved to the instruction after the call. Secondly, a subroutine that returns
    a value back to its caller usually stores that value in a dedicated register where
    the caller knows where to find it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当子程序返回给调用者时，它使用返回地址来知道要跳转到哪里，恢复它已经改变的寄存器，并弹出（释放）整个调用帧。通过这种方式，堆栈和寄存器都恢复到调用子程序被调用之前的状态。但是，有两个例外。首先，程序计数器（PC）已经移动到调用后的指令。其次，将值返回给其调用者的子程序通常将该值存储在一个专用寄存器中，调用者知道在哪里找到它。
- en: After understanding how a subroutine is executed by temporarily using the stack
    and then restoring the CPU registers before returning control back to its caller,
    we can now start to look at how it's possible to suspend and resume coroutines.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了子程序是如何通过临时使用堆栈来执行，然后在将控制返回给调用者之前恢复CPU寄存器，我们现在可以开始看看如何挂起和恢复协程。
- en: Suspend and resume
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂起和恢复
- en: 'Consider the following pseudo code that defines a coroutine with multiple suspend/resume
    points:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下伪代码，定义了一个具有多个挂起/恢复点的协程：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When `coroutine()` suspends, we can no longer remove the call frame as we do
    when a subroutine returns back to its caller. Why? Because we need to keep the
    current value of the variable, `x`, and also remember *where* in the coroutine
    we should continue executing the next time the coroutine is resumed. This information
    is placed into something called a **coroutine frame**. The coroutine frame contains
    all the information that is needed in order to resume a paused coroutine. This
    raises several new questions, though:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当`coroutine()`挂起时，我们无法像子程序返回给调用者时那样删除调用帧。为什么？因为我们需要保留变量`x`的当前值，并且还需要记住在协程中应该在*何处*继续执行下次协程恢复时。这些信息被放入一个称为**协程帧**的东西中。协程帧包含恢复暂停协程所需的所有信息。然而，这引发了一些新问题：
- en: Where is the coroutine frame stored?
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程帧存储在哪里？
- en: How big is the coroutine frame?
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程帧有多大？
- en: When a coroutine calls a subroutine, it needs a stack to manage the nested call
    frames. What happens if we try to resume from within a nested call frame? Then
    we would need to restore the entire stack when the coroutine resumes.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当协程调用子程序时，它需要一个堆栈来管理嵌套的调用帧。如果我们尝试从嵌套的调用帧内恢复会发生什么？那么当协程恢复时，我们需要恢复整个堆栈。
- en: What is the runtime overhead of calling and returning from a coroutine?
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用和从协程返回的运行时开销是多少？
- en: What is the runtime overhead of suspending and resuming a coroutine?
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂起和恢复协程的运行时开销是多少？
- en: 'The short answer to these questions is that it depends on what type of coroutine
    we are discussing: stackless or stackful coroutines.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些问题的简短回答是，这取决于我们讨论的协程类型：无堆栈或有堆栈的协程。
- en: 'Stackful coroutines have a separate side stack (similar to a thread) that contains
    the coroutine frame and the nested call frames. This makes it possible to suspend
    from nested call frames:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有堆栈的协程有一个单独的侧堆栈（类似于线程），其中包含协程帧和嵌套的调用帧。这使得可以从嵌套的调用帧中挂起：
- en: '![](img/B15619_12_05.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_05.png)'
- en: 'Figure 12.5: Each call to a stackful coroutine creates a separate side stack
    with a unique stack pointer'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：对堆栈协程的每次调用都会创建一个具有唯一堆栈指针的单独侧堆栈
- en: Suspending and resuming stackless coroutines
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挂起和恢复无堆栈协程
- en: Stackless coroutines need to store the coroutine frame somewhere else (typically
    on the heap) and then use the stack of the currently executing thread to store
    nested call frames.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 无堆栈协程需要在其他地方（通常在堆上）存储协程帧，然后使用当前执行线程的堆栈来存储嵌套调用帧。
- en: 'But this is not the entire truth. The caller is the one responsible for creating
    the call frame, saving the return address (current value of the program counter),
    and the parameters on the stack. The caller doesn''t know that it is calling a
    coroutine that will suspend and resume. Therefore, the coroutine itself needs
    to create the coroutine frame and copy the parameters and registers from the call
    frame to the coroutine frame when it is called:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是全部真相。调用者负责创建调用帧，保存返回地址（程序计数器的当前值）和堆栈上的参数。调用者不知道自己正在调用一个会挂起和恢复的协程。因此，协程本身在被调用时需要创建协程帧，并将参数和寄存器从调用帧复制到协程帧中：
- en: '![](img/B15619_12_06.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_06.png)'
- en: 'Figure 12.6: A stackless coroutine has a separate coroutine frame (usually
    on the heap) that contains the state necessary for resuming the coroutine'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：无堆栈协程具有单独的协程帧（通常在堆上），其中包含恢复协程所需的状态
- en: 'When a coroutine initially suspends, the stack frame for the coroutine is popped
    from the stack, but the coroutine frame continues to live on. A memory address
    (handle/pointer) to the coroutine frame is returned back to the caller:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当协程最初挂起时，协程的堆栈帧从堆栈中弹出，但协程帧继续存在。协程帧的内存地址（句柄/指针）被返回给调用者：
- en: '![](img/B15619_12_07.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_07.png)'
- en: 'Figure 12.7: A suspended coroutine. The coroutine frame contains all the information
    required for resuming the coroutine.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：挂起的协程。协程帧包含恢复协程所需的所有信息。
- en: 'To resume a coroutine, the caller uses the handle it received earlier and calls
    a resume function and passes the coroutine handle as a parameter. The resume function
    uses the suspend/resume point stored in the coroutine frame to continue executing
    the coroutine. The call to the resume function is also an ordinary function call
    that will generate a stack frame as illustrated in the following diagram:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复协程，调用者使用先前收到的句柄，并调用一个恢复函数，并将协程句柄作为参数传递。恢复函数使用存储在协程帧中的挂起/恢复点来继续执行协程。对恢复函数的调用也是一个普通的函数调用，将生成一个堆栈帧，如下图所示：
- en: '![](img/B15619_12_08.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_08.png)'
- en: 'Figure 12.8: Resuming a coroutine creates a new call frame for the resume call.
    The resume function uses the handle to the coroutine state to resume from the
    right suspend point.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：恢复协程为恢复调用创建一个新的调用帧。恢复函数使用协程状态的句柄从正确的挂起点恢复。
- en: 'Finally, when a coroutine returns, it is usually suspended and eventually deallocated.
    The state of the stack is shown in the following diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当协程返回时，通常会被挂起并最终被释放。堆栈的状态如下图所示：
- en: '![](img/B15619_12_09.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_09.png)'
- en: 'Figure 12.9: The coroutine frame is deallocated when it returns'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：协程帧在返回时被释放
- en: An important consequence of not having a separate side stack per coroutine invocation
    is that when a stackless coroutine is suspended, it cannot have any nested call
    frames left on the stack. Remember, when the control is transferred back to the
    caller, the caller's call frame must be on the top of the stack.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 没有为每个协程调用分配单独的侧边堆栈的一个重要后果是，当无堆栈协程被挂起时，它不能在堆栈上留下任何嵌套调用帧。记住，当控制权转回调用者时，调用者的调用帧必须位于堆栈顶部。
- en: As a final note, it should also be mentioned that the memory needed for the
    coroutine frame could be allocated *within* the call frame of the caller under
    some circumstances. We will discuss that in more detail when looking at C++20
    coroutines.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要提到的是，在某些情况下，协程帧所需的内存可以在调用者的调用帧内分配。当我们查看C++20协程时，我们将更详细地讨论这一点。
- en: Stackless versus stackful coroutines
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无堆栈与有堆栈协程
- en: As stated in the previous section, stackless coroutines use the stack of the
    currently running thread to handle nested function calls. The effect of this is
    that a stackless coroutine can never suspend from a nested call frame.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一节所述，无堆栈协程使用当前运行线程的堆栈来处理嵌套函数调用。这样做的效果是无堆栈协程永远不会从嵌套调用帧中挂起。
- en: 'Stackful coroutines are sometimes called **fibers**, and in the programming
    language Go, they are called **goroutines**. Stackful coroutines remind us of
    threads, where each thread manages its own stack. There are two big differences
    between stackful coroutines (or fibers) and OS threads, though:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时堆栈式协程被称为**纤程**，在Go编程语言中被称为**goroutines**。堆栈式协程让我们想起线程，每个线程管理自己的堆栈。然而，堆栈式协程（或纤程）与操作系统线程之间有两个重大区别：
- en: OS threads are scheduled by the kernel and switching between two threads is
    a kernel mode operation.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统线程由内核调度，并在两个线程之间进行切换是内核模式操作。
- en: Most OSes switch OS threads **preemptively** (the thread is interrupted by the
    scheduler), whereas a switch between two fibers happens **cooperatively**. A running
    fiber keeps running until it passes control over to some manager that can then
    schedule another fiber.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数操作系统**抢占式**地切换操作系统线程（线程被调度程序中断），而两个纤程之间的切换是**合作**的。运行中的纤程会一直运行，直到将控制权交给可以调度另一个纤程的管理器。
- en: There is also a category of threads called **user-level threads** or **green
    threads**. These are lightweight threads that don't involve kernel mode switching
    (because they run in user mode and are therefore unknown to the kernel). Fibers
    are one example of user-level threads. But it is also possible for user-level
    threads to be scheduled preemptively by a user library or by a virtual machine.
    Java threads are one example of preemptive user-level threads.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一类称为**用户级线程**或**绿色线程**的线程。这些是轻量级线程，不涉及内核模式切换（因为它们在用户模式下运行，因此内核不知道）。纤程是用户级线程的一个例子。但用户级线程也可以由用户库或虚拟机抢占地调度。Java线程是抢占式用户级线程的一个例子。
- en: Stackless coroutines also allow us to write and compose multiple concurrently
    running tasks but without the need for an individual side stack per flow. Stackless
    coroutines and state machines are tightly related. It's possible to transform
    a state machine into a coroutine and vice versa. Why is this useful to know? Firstly,
    it gives you a better understanding of what stackless coroutines are. Secondly,
    if you are already good at identifying problems that can be solved using state
    machines, you can more easily see where coroutines might fit in as an appropriate
    solution. State machines are very general abstractions and can be applied to a
    great variety of problems. However, some areas where state machines are usually
    applied are parsing, gesture recognition, and I/O multiplexing, to mention a few.
    These are all areas where stackless coroutine can really shine both in terms of
    expressiveness and performance.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 无堆栈协程还允许我们编写和组合多个并发运行的任务，但不需要每个流程单独的侧边堆栈。无堆栈协程和状态机密切相关。可以将状态机转换为协程，反之亦然。为什么了解这一点很有用？首先，这让你更好地理解无堆栈协程是什么。其次，如果你已经擅长识别可以使用状态机解决的问题，你可以更容易地看到协程可能适合作为适当解决方案的地方。状态机是非常通用的抽象，可以应用于各种问题。然而，状态机通常应用的一些领域包括解析、手势识别和I/O多路复用等。这些都是无堆栈协程在表达和性能方面真正闪耀的领域。
- en: Performance cost
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能成本
- en: 'Coroutines are an abstraction that allow us to write lazy evaluated code and
    asynchronous programs in a clear and concise way. But there is a performance cost
    related to creating and destroying coroutines as well as suspending and resuming
    coroutines. When comparing the performance cost of stackless and stackful coroutines,
    two main aspects need to be addressed: *memory footprint* and *context switching*.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是一种抽象，使我们能够以清晰简洁的方式编写惰性评估代码和异步程序。但是，创建和销毁协程以及挂起和恢复协程都会带来性能成本。在比较无堆栈和有堆栈协程的性能成本时，需要解决两个主要方面：*内存占用*和*上下文切换*。
- en: Memory footprint
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存占用
- en: 'Stackful coroutines need a separate call stack in order to handle suspension
    from within nested call frames. When calling a coroutine, we therefore need to
    dynamically allocate a chunk of memory for this new side stack. This immediately
    raises the question: how big a stack do we need to allocate? Unless we have some
    policy regarding how much stack a coroutine and its nested call frames can consume,
    we probably need to have a stack of approximately the same size as a normal call
    stack of a thread.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有栈协程需要一个单独的调用栈来处理来自嵌套调用帧的挂起。因此，在调用协程时，我们需要动态分配一块内存来存储这个新的侧栈。这立即引发了一个问题：我们需要分配多大的栈？除非我们有关于协程及其嵌套调用帧可以消耗多少栈的一些策略，否则我们可能需要一个大约与线程的正常调用栈大小相同的栈。
- en: Some implementations have experimented with a segmented stack, which would allow
    the stack to grow if necessary. Another alternative is to start with a small contiguous
    stack and then copy the stack to a bigger newly allocated memory region when needed
    (similar to how `std::vector` grows). The coroutine implementation in Go (goroutines)
    has switched from using a segmented stack to a dynamically growing contiguous
    stack.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实现已经尝试使用分段栈，这将允许栈在必要时增长。另一种选择是从一个小的连续栈开始，然后在需要时将栈复制到一个更大的新分配的内存区域（类似于`std::vector`的增长）。Go语言中的协程实现（goroutines）已经从使用分段栈切换到了动态增长的连续栈。
- en: Stackless coroutines do not need to allocate memory for a separate side stack.
    Instead, they need a single allocation for storing each coroutine frame in order
    to support suspend and resume. This allocation happens when the coroutine is called
    (but not on suspend/resume). The call frame is deallocated when the coroutine
    returns.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 无栈协程不需要为单独的侧栈分配内存。相反，它们需要为每个协程帧分配一个单独的内存以支持挂起和恢复。这种分配发生在调用协程时（但不是在挂起/恢复时）。当协程返回时，调用帧被释放。
- en: 'In summary, stackful coroutines demand a big initial memory allocation for
    the coroutine frame and the side stack, or need to support a growing stack. Stackless
    coroutines only need to allocate memory for the coroutine frame. The memory footprint
    of calling a coroutine can be summarized as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，有栈协程需要为协程帧和侧栈进行大量的初始内存分配，或者需要支持一个增长的栈。无栈协程只需要为协程帧分配内存。调用协程的内存占用可以总结如下：
- en: 'Stackless: Coroutine frame'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无栈：协程帧
- en: 'Stackful: Coroutine frame + call stack'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有栈：协程帧+调用栈
- en: The next aspect of performance cost relates to suspending and resuming coroutines.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 性能成本的下一个方面与挂起和恢复协程有关。
- en: Context switching
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文切换
- en: Context switching can occur at different levels. In general, a context switch
    happens when we need the CPU to switch between two or many ongoing tasks. The
    task that is about to be paused needs to save the entire state of the CPU so that
    it can be restored at a later stage.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文切换可以发生在不同的级别。一般来说，当我们需要CPU在两个或多个正在进行的任务之间切换时，就会发生上下文切换。即将暂停的任务需要保存CPU的整个状态，以便在以后恢复时可以恢复。
- en: Switching between different processes and OS threads are fairly expensive operations
    that involve system calls, requiring the CPU to enter kernel mode. Memory caches
    are invalidated and, for process switching, the tables that contain the mappings
    between the virtual memory and physical memory need to be replaced.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同进程和操作系统线程之间切换是相当昂贵的操作，涉及系统调用，需要CPU进入内核模式。内存缓存被使无效，对于进程切换，包含虚拟内存和物理内存映射的表需要被替换。
- en: Suspending and resuming coroutines is also a kind of context switch because
    we are switching between multiple concurrent flows. Switching between coroutines
    is substantially faster than switching between processes and OS threads, partly
    because it doesn't involve any system calls that require the CPU to run in kernel
    mode.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 挂起和恢复协程也是一种上下文切换，因为我们在多个并发流之间切换。在协程之间切换比在进程和操作系统线程之间切换要快得多，部分原因是它不涉及需要CPU在内核模式下运行的任何系统调用。
- en: However, there is still a difference when switching between stackful coroutines
    and switching between stackless coroutines. The relative runtime performance of
    the context switches of stackful versus stackless coroutines can depend on the
    call patterns. But, in general, a stackful coroutine has a more expensive context
    switch operation since it has more information to save and restore during suspend
    and resume compared to a stackless coroutine. Resuming a stackless coroutine is
    comparable to a normal function call.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当在有栈协程和无栈协程之间切换时仍然存在差异。有栈协程和无栈协程的上下文切换的相对运行时性能可能取决于调用模式。但总的来说，有栈协程的上下文切换操作更昂贵，因为在挂起和恢复时需要保存和恢复更多的信息，而无栈协程的恢复类似于正常的函数调用。
- en: The stackless versus stackful debate has been going on in the C++ community
    for quite a few years now and I will do my best to stay away from the debate by
    concluding that they both have valid use cases—some use cases will favor stackful
    coroutines and other use cases will favor stackless coroutines.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关于有栈与无栈的辩论在C++社区已经进行了好几年，我会尽力避开这场辩论，总结它们都有有效的用例——有些用例会偏向有栈协程，而其他用例会偏向无栈协程。
- en: This section took a little detour for the purpose of you having a better understanding
    of how coroutines execute and perform. Let's have a short recap of what you have
    learned.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你更好地理解协程的执行和性能，这一部分稍微偏离了一下。让我们简要回顾一下你学到的内容。
- en: What you have learned so far
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到目前为止你学到的内容
- en: Coroutines are functions that can be suspended and resumed. An ordinary function
    does not have this ability, which makes it possible to remove the call frame of
    a function that returns. However, a coroutine that is suspended needs to keep
    the call frame alive to be able to restore the state of the coroutine once it
    gets resumed. Coroutines are more powerful than subroutines and involve more bookkeeping
    in the generated machine code. However, thanks to the close relationship between
    coroutines and ordinary functions, the compilers of today are very good at optimizing
    stackless coroutines.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是可以挂起和恢复的函数。普通函数没有这种能力，这使得可以删除返回的函数的调用帧。然而，一个被挂起的协程需要保持调用帧活动，以便在恢复时能够恢复协程的状态。协程比子例程更强大，并且在生成的机器代码中涉及更多的簿记工作。然而，由于协程与普通函数之间的密切关系，今天的编译器非常擅长优化无堆栈协程。
- en: Stackful coroutines can be seen as non-preemptive user-level threads, whereas
    stackless coroutines offer a way to write state machines in a direct imperative
    fashion using the keywords `await` and `yield` to specify the suspend points.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈式协程可以看作是非抢占式用户级线程，而无堆栈协程提供了一种以直接命令方式编写状态机的方法，使用关键字`await`和`yield`来指定挂起点。
- en: After this introduction to the general coroutine abstraction, it's now time
    to understand how stackless coroutines are implemented in C++.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在对协程的一般抽象介绍之后，现在是时候了解C++中如何实现无堆栈协程。
- en: Coroutines in C++
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的协程
- en: The coroutines added to C++20 are stackless coroutines. There are options to
    use stackful coroutines in C++ as well by using third-party libraries. The most
    well-known cross-platform library is Boost.Fiber. C++20 stackless coroutines introduce
    new language constructs, while Boost.Fiber is a library that can be used with
    C++11 and onward. We will not discuss stackful coroutines any further in this
    book but will instead focus on the stackless coroutines that have been standardized
    in C++20\.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: C++20中添加的协程是无堆栈协程。也有使用第三方库在C++中使用堆栈式协程的选项。最知名的跨平台库是Boost.Fiber。C++20无堆栈协程引入了新的语言构造，而Boost.Fiber是一个可以在C++11及以后版本中使用的库。在本书中我们不会进一步讨论堆栈式协程，而是专注于C++20中标准化的无堆栈协程。
- en: 'The stackless coroutines in C++20 were designed with the following goals:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: C++20中的无堆栈协程设计有以下目标：
- en: Scalable in the sense that they add very little memory overhead. This makes
    it possible to have many more coroutines alive compared to the possible number
    of threads or stackful coroutines alive.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内存开销方面可扩展，这使得可以有更多的协程同时存在，与可能存在的线程或堆栈式协程数量相比。
- en: Efficient context switching, which means that suspending and resuming a coroutine
    should be about as cheap as an ordinary function call.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效的上下文切换，这意味着挂起和恢复协程应该与普通函数调用一样廉价。
- en: Highly flexible. C++ coroutines have more than 15 customization points, which
    gives application developers and library writers a lot of freedom to configure
    and shape coroutines as they like. Decisions about how coroutines are supposed
    to work can be determined by us developers rather than being hardcoded in a language
    specification. One example is whether a coroutine should be suspended directly
    after being called or continue executing to the first explicit suspend point.
    Such questions are usually hard-coded in other languages, but in C++ we can customize
    this behavior using customization points.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度灵活。C++协程有15多个自定义点，这为应用程序开发人员和库编写人员提供了很大的自由度，可以根据自己的喜好配置和塑造协程。关于协程应该如何工作的决定可以由我们开发人员确定，而不是硬编码在语言规范中。一个例子是协程在被调用后是否应该直接挂起，还是继续执行到第一个显式挂起点。在其他语言中，这些问题通常是硬编码的，但在C++中，我们可以使用自定义点来定制这种行为。
- en: Do not require C++ exceptions to handle errors. This means that you can use
    coroutines in environments where exceptions are turned off. Remember that coroutines
    are a low-level feature comparable to ordinary functions, which can be highly
    useful in embedded environments and systems with real-time requirements.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要求C++异常来处理错误。这意味着您可以在关闭异常的环境中使用协程。请记住，协程是一种低级功能，类似于普通函数，在嵌入式环境和具有实时要求的系统中非常有用。
- en: With these goals in mind, it's probably not a surprise that C++ coroutines can
    be a bit complicated to grasp at first.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些目标，C++协程可能一开始会有点复杂。
- en: What's included in standard C++ (and what's not)?
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准C++中包含了什么（以及不包含什么）？
- en: Some C++ features are pure library features (such as the Ranges library) whereas
    other features are pure language features (such as type inference with the help
    of the `auto` keyword). However, some features require additions to both the core
    language and the standard library. C++ coroutines are one of those features; they
    introduce new keywords to the language, but also add new types to the standard
    library.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一些C++特性是纯库特性（例如Ranges库），而其他特性是纯语言特性（例如使用`auto`关键字进行类型推断）。然而，有些特性需要对核心语言和标准库进行补充。C++协程就是其中之一；它们为语言引入了新的关键字，同时也向标准库添加了新的类型。
- en: 'On the language side, to recap, we have the following keywords related to coroutines:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在语言方面，总结一下，我们有以下与协程相关的关键字：
- en: '`co_await`: An operator that suspends the current coroutine'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_await`：挂起当前协程的运算符'
- en: '`co_yield`: Returns a value to the caller and suspends the coroutine'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_yield`：向调用者返回一个值并挂起协程'
- en: '`co_return`: Completes the execution of a coroutine and can, optionally, return
    a value'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`co_return`：完成协程的执行，并且可以选择返回一个值'
- en: 'On the library side, there is a new `<coroutine>` header including the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在库方面，有一个新的`<coroutine>`头文件，其中包括以下内容：
- en: '`std::coroutine_handle`: A template class that refers to the coroutine state,
    enabling the suspending and resuming of the coroutine'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::coroutine_handle`：引用协程状态的模板类，使协程能够挂起和恢复'
- en: '`std::suspend_never`: A trivial awaitable type that never suspends'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::suspend_never`：一个从不挂起的平凡等待类型'
- en: '`std::suspend_always`: A trivial awaitable type that always suspends'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::suspend_always`：一个始终暂停的平凡等待类型'
- en: '`std::coroutine_traits`: Used to define the promise type of a coroutine'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::coroutine_traits`：用于定义协程的承诺类型'
- en: The library types that comes with C++20 are the absolute minimum. For example,
    the infrastructure for communicating between the coroutine and the caller is not
    part of the C++ standard. Some of the types and functions that we need in order
    to use coroutines effectively in our application code have already been suggested
    in new C++ proposals, for example the template classes `task` and `generator`
    and the functions `sync_wait()` and `when_all()`. The library part of C++ coroutines
    will most likely be complemented in C++23.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: C++20附带的库类型是绝对最低限度的。例如，用于协程和调用者之间通信的基础设施不是C++标准的一部分。为了有效地在应用程序代码中使用协程，我们需要的一些类型和函数已经在新的C++提案中提出，例如模板类`task`和`generator`以及函数`sync_wait()`和`when_all()`。C++协程的库部分很可能会在C++23中得到补充。
- en: In this book, I will provide some simplified types for filling this gap instead
    of using a third-party library. By implementing those types, you will get a deep
    understanding of how C++ coroutines work. However, designing robust library components
    that can be used with coroutines is hard to get right without introducing lifetime
    issues. So, if you are planning to use coroutines in your current project, using
    a third-party library may be a better alternative to implementing them from scratch.
    At the time of writing, the **CppCoro** library is the de facto standard for these
    general-purpose primitives. The library was created by Lewis Baker and is available
    at [https://github.com/lewissbaker/cppcoro](https://github.com/lewissbaker/cppcoro).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我将提供一些简化的类型来填补这一空白，而不是使用第三方库。通过实现这些类型，您将深入了解C++协程的工作原理。然而，设计可以与协程一起使用的健壮库组件很难在不引入生命周期问题的情况下正确实现。因此，如果您计划在当前项目中使用协程，使用第三方库可能是比从头开始实现更好的选择。在撰写本文时，**CppCoro**库是这些通用原语的事实标准。该库由Lewis
    Baker创建，可在[https://github.com/lewissbaker/cppcoro](https://github.com/lewissbaker/cppcoro)上找到。
- en: What makes a C++ function a coroutine?
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么使C++函数成为协程？
- en: A C++ function is a coroutine if it contains any of the keywords `co_await`,
    `co_yield`, or `co_return`. In addition, the compiler puts special requirements
    on the return type of a coroutine. But, nevertheless, we need to inspect the definition
    (the body) and not only the declaration to know whether we are facing a coroutine
    or an ordinary function. This means that the caller of a coroutine doesn't need
    to know whether it calls a coroutine or an ordinary function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果C++函数包含关键字`co_await`、`co_yield`或`co_return`，则它是一个协程。此外，编译器对协程的返回类型也有特殊要求。但是，我们需要检查定义（主体）而不仅仅是声明，才能知道我们是否面对的是协程还是普通函数。这意味着协程的调用者不需要知道它调用的是协程还是普通函数。
- en: 'Compared to ordinary functions, a coroutine also has the following restrictions:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通函数相比，协程还有以下限制：
- en: A coroutine cannot use variadic arguments like `f(const char*...)`
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程不能使用像`f(const char*...)`这样的可变参数
- en: 'A coroutine cannot return `auto` or a concept type: `auto f()`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程不能返回`auto`或概念类型：`auto f()`
- en: A coroutine cannot be declared `constexpr`
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程不能声明为`constexpr`
- en: Constructors and destructors cannot be coroutines
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数和析构函数不能是协程
- en: The `main()` function cannot be a coroutine
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()`函数不能是协程'
- en: 'Once the compiler has decided that a function is a coroutine, it associates
    the coroutine with a number of types for making the coroutine machinery work.
    The following diagram highlights the different components that are involved when
    a *caller* uses a *coroutine*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译器确定一个函数是协程，它就会将协程与多种类型关联起来，以使协程机制工作。以下图表突出显示了在*调用者*使用*协程*时涉及的不同组件：
- en: '![](img/B15619_12_10.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_10.png)'
- en: 'Figure 12.10: Relationship between a coroutine and its caller'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：协程与其调用者之间的关系
- en: The caller and the coroutine are the actual functions we will normally implement
    in our application code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者和协程是我们通常在应用程序代码中实现的实际函数。
- en: The **Return Object** is the type that the coroutine returns and is typically
    a general class template designed for some specific use case, for example, *generators*
    or *asynchronous tasks*. The *caller* interacts with the return object to resume
    the coroutine and to get values emitted from the coroutine. The return object
    usually delegates all its calls to the coroutine handle.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回对象**是协程返回的类型，通常是为某个特定用例设计的通用类模板，例如*生成器*或*异步任务*。*调用者*与返回对象交互以恢复协程并获取从协程中发出的值。返回对象通常将其所有调用委托给协程句柄。'
- en: The **Coroutine Handle** is a non-owning handle to the **Coroutine State**.
    Through the coroutine handle we can resume and destroy the coroutine state.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**协程句柄**是对**协程状态**的非拥有句柄。通过协程句柄，我们可以恢复和销毁协程状态。'
- en: The *coroutine state* is what I have previously referred to as the coroutine
    frame. It's an opaque object, which means that we don't know its size and we cannot
    access it in any other way than through the handle. The coroutine state stores
    everything necessary in order to resume the coroutine where it was last suspended.
    The coroutine state also contains the **Promise**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**协程状态**是我之前所说的协程帧。它是一个不透明的对象，这意味着我们不知道它的大小，也不能以其他方式访问它，而只能通过句柄。协程状态存储了恢复协程的一切必要条件。协程状态还包含**Promise**。'
- en: The promise object is what the coroutine itself communicates with indirectly
    through the keywords `co_await`, `co_yield`, and `co_return`. If values or errors
    are submitted from the coroutine, they will first reach the promise object. The
    promise object acts like a channel between the coroutine and the caller, but neither
    of them have direct access to the promise.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺对象是协程本身间接通过关键字`co_await`、`co_yield`和`co_return`进行通信的。如果从协程提交值或错误，它们将首先到达承诺对象。承诺对象充当协程和调用者之间的通道，但它们都无法直接访问承诺。
- en: Admittedly, this can look pretty dense at first sight. A complete but minimal
    example will help you understand the different parts a little better.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，乍一看这可能看起来相当密集。一个完整但简单的例子将帮助你更好地理解不同的部分。
- en: A minimal but complete example
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单但完整的例子
- en: 'Let''s start with a minimal example for the purpose of understanding how coroutines
    work. Firstly, we implement a small *coroutine* that is suspended and resumed
    before it returns:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个最小的例子开始，以便理解协程的工作原理。首先，我们实现一个小的*协程*，在返回之前被挂起和恢复：
- en: '[PRE10]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Secondly, we create the *caller* of the coroutine. Pay attention to the output
    and the control flow of this program. Here it is:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们创建协程的*调用者*。注意程序的输出和控制流。这里是：
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Thirdly, the return object of the coroutine, `Resumable`, needs to be defined:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，协程的返回对象`Resumable`需要被定义：
- en: '[PRE12]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, the promise type is implemented as a nested class inside the `Resumable`,
    like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，承诺类型被实现为`Resumable`内部的嵌套类，如下所示：
- en: '[PRE13]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This example is minimal, but walks through a lot of things that are worth paying
    attention to and need to be understood:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很简单，但涉及了很多值得注意和需要理解的东西：
- en: The function `coroutine()` is a coroutine because it contains the explicit suspend/resume
    point using `co_await`
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coroutine()`函数是一个协程，因为它包含了使用`co_await`的显式挂起/恢复点'
- en: The coroutine doesn't yield any values but still needs to return a type (the
    `Resumable`) with certain constraints so that the caller can resume the coroutine
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程不会产生任何值，但仍然需要返回一个类型（`Resumable`），具有一定的约束，以便调用者可以恢复协程。
- en: We are using an *awaitable type* called `std::suspend_always`
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用一个名为`std::suspend_always`的*可等待类型*。
- en: The `resume()` function of the `resumable` object resumes the coroutine from
    the point it was suspended
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resumable`对象的`resume()`函数从协程被挂起的地方恢复协程'
- en: The `Resumable` is the owner of the coroutine state. When the `Resumable` object
    is destructed, it destroys the coroutine using the `coroutine_handle`
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Resumable`是协程状态的所有者。当`Resumable`对象被销毁时，它使用`coroutine_handle`销毁协程'
- en: 'The relationship between the caller, the coroutine, the coroutine handle, the
    promise, and the resumable is illustrated in the following diagram:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者、协程、协程句柄、承诺和可恢复之间的关系如下图所示：
- en: '![](img/B15619_12_11.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_11.png)'
- en: 'Figure 12.11: Relationship between the functions/coroutines and objects involved
    in the resumable example'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：可恢复示例中涉及的函数/协程和对象之间的关系
- en: Now it's time to look a little closer at each part. We'll begin with the `Resumable`
    type.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候仔细看看每个部分了。我们将从`Resumable`类型开始。
- en: The coroutine return object
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协程返回对象
- en: 'Our coroutine returns an object of type `Resumable`. This `Resumable` class
    is very simple. This is the object that the coroutine returns and which the caller
    can use in order to resume and destroy the coroutine. Here is the complete definition
    again for your convenience:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的协程返回一个`Resumable`类型的对象。这个`Resumable`类非常简单。这是协程返回的对象，调用者可以使用它来恢复和销毁协程。以下是完整的定义，以供您方便查看：
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`Resumable` is a move-only type that is the owner of the coroutine handle (and
    therefore controls the lifetime of the coroutine). The move constructor ensures
    that the coroutine handle is cleared in the source object by using `std::exchange()`.
    When a `Resumable` object is destructed, it destroys the coroutine if it still
    owns it.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resumable`是一个移动类型，它是协程句柄的所有者（因此控制协程的生命周期）。移动构造函数确保通过使用`std::exchange()`在源对象中清除协程句柄。当`Resumable`对象被销毁时，如果仍然拥有它，它将销毁协程。'
- en: The `resume()` member function delegates the resume call to the coroutine handle
    if the coroutine is still alive.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`resume()`成员函数将恢复调用委托给协程句柄，如果协程仍然存活。'
- en: Why do we need the member type alias `promise_type = Promise` inside `Resumable`?
    With each coroutine there is also an associated promise object. When the compiler
    sees a coroutine (by inspecting the body of a function), it needs to figure out
    the associated promise type. For that, the compiler uses the `std::coroutine_traits<T>`
    template, where `T` is the return type of your coroutine. You can provide a template
    specialization of `std::coroutine_traits<T>` or exploit the fact that the default
    implementation of `std::coroutine_traits` will look for a `public` member type
    or alias named `promise_type` in the return type `T` of the coroutine. In our
    case, the `Resumable::promise_type` is an alias for `Promise`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要在`Resumable`内部有成员类型别名`promise_type = Promise`？对于每个协程，还有一个关联的承诺对象。当编译器看到一个协程（通过检查函数体），它需要找出关联的承诺类型。为此，编译器使用`std::coroutine_traits<T>`模板，其中`T`是您的协程的返回类型。您可以提供`std::coroutine_traits<T>`的模板特化，或者利用`std::coroutine_traits`的默认实现将在协程的返回类型`T`中查找名为`promise_type`的`public`成员类型或别名。在我们的情况下，`Resumable::promise_type`是`Promise`的别名。
- en: The promise type
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 承诺类型
- en: 'The promise type controls the behavior of the coroutine. Again, here is the
    full definition reproduced for convenience:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺类型控制协程的行为。以下是完整的定义，以供您方便查看：
- en: '[PRE15]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We should not call these functions directly; instead, the compiler inserts
    calls to the promise objects when it transforms a coroutine into machine code.
    If we don''t provide these member functions, the compiler doesn''t know how to
    generate code for us. You can think about the promise as a coroutine controller
    object that is responsible for:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应直接调用这些函数；相反，编译器在将协程转换为机器代码时会插入对promise对象的调用。如果我们不提供这些成员函数，编译器就不知道如何为我们生成代码。您可以将promise视为协程控制器对象，负责：
- en: Producing the value returned from the invocation of the coroutine. This is handled
    by the function `get_return_object()`.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产生从协程调用返回的值。这由函数`get_return_object()`处理。
- en: Defining the behavior when the coroutine is created and before it gets destroyed
    by implementing the functions `initial_suspend()` and `final_supsend()`. In our
    `Promise` type, we say that the coroutine should be suspended at these points
    by returning `std::suspend_always` (see the next section).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现函数`initial_suspend()`和`final_supsend()`定义协程创建时和销毁前的行为。在我们的`Promise`类型中，我们通过返回`std::suspend_always`（见下一节）来表示协程应在这些点挂起。
- en: Customizing the behavior when the coroutine finally returns. If a coroutine
    uses a `co_return` with an expression that evaluates to a value of type `T`, the
    promise must define a member function named `return_value(T)`. Our coroutine returns
    no value, but the C++ standard requires us to provide the customization point
    called `return_void()`, which we leave empty here.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义协程最终返回时的行为。如果协程使用带有类型`T`的值的表达式的`co_return`，则promise必须定义一个名为`return_value(T)`的成员函数。我们的协程不返回任何值，但C++标准要求我们提供称为`return_void()`的定制点，我们在这里留空。
- en: Handling exceptions that are not handled inside the coroutine body. In the function
    `unhandled_exception()`, we simply call `std::terminate()`, but we will handle
    it more gracefully in later examples.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理在协程体内未处理的异常。在函数`unhandled_exception()`中，我们只是调用`std::terminate()`，但在后面的示例中我们将更优雅地处理它。
- en: There are some final pieces of the code that require some more attention, namely
    the `co_await` expression and awaitable types.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些代码的最后部分需要更多的关注，即`co_await`表达式和可等待类型。
- en: Awaitable types
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可等待类型
- en: 'We added one explicit suspend point in our code using `co_await` and passed
    it an instance of the awaitable type, `std::suspend_always`. The implementation
    of `std::suspend_always` looks something like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中使用`co_await`添加了一个显式的挂起点，并传递了一个可等待类型`std::suspend_always`的实例。`std::suspend_always`的实现大致如下：
- en: '[PRE16]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`std::suspend_always` is called a trivial awaitable type because it will always
    make a coroutine suspend by saying that it is never ready. There is another trivial
    awaitable type that always reports that it is ready, called `std::suspend_never`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::suspend_always`被称为微不足道的可等待类型，因为它总是使协程挂起，说它永远不会准备好。还有另一种微不足道的可等待类型，总是报告自己准备好的，称为`std::suspend_never`：'
- en: '[PRE17]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We could create our own awaitable types, which we will cover in the next chapter,
    but for now we can manage with those two trivial standard types.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自己的可等待类型，这将在下一章中介绍，但现在我们可以使用这两种微不足道的标准类型。
- en: This completes the example. But we can do some more experimenting when we have
    the `Promise` and the `Resumable` types in place. Let's see what we can do with
    a started coroutine.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了示例。但是当我们有了`Promise`和`Resumable`类型时，我们可以进行更多的实验。让我们看看在启动的协程中我们能做些什么。
- en: Passing our coroutine around
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递我们的协程
- en: 'Once the `Resumable` object is created, we can pass it to other function and
    resume it from there. We can even pass the coroutine to another thread. The following
    example shows some of this flexibility:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Resumable`对象被创建，我们可以将它传递给其他函数，并从那里恢复它。我们甚至可以将协程传递给另一个线程。下面的示例展示了一些这种灵活性：
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding example demonstrates that once we have called our coroutine and
    have got a handle to it, we can move it around just like any other moveable type.
    This ability to pass it to other threads is actually very useful in situations
    where we need to avoid the possible heap allocation of the coroutine state on
    a specific thread.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例表明，一旦我们调用了我们的协程并获得了对它的句柄，我们就可以像任何其他可移动类型一样移动它。将它传递给其他线程的能力实际上在需要避免在特定线程上对协程状态进行可能的堆分配的情况下非常有用。
- en: Allocating the coroutine state
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配协程状态
- en: The coroutine state, or the coroutine frame, is where the coroutine stores its
    state while it is suspended. The lifetime of the coroutine state starts when the
    coroutine is invoked by a call, and is destroyed when the coroutine executes a
    `co_return` statement (or the control flows off the end of the coroutine body),
    unless it was destroyed earlier through the coroutine handle.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 协程状态，或协程帧，是协程在挂起时存储其状态的地方。协程状态的生命周期始于协程被调用时，并在协程执行`co_return`语句（或控制流离开协程体的末尾）时被销毁，除非它在此之前通过协程句柄被销毁。
- en: The coroutine state is normally allocated on the heap. A separate heap allocation
    is inserted by the compiler. In some cases, though, this separate heap allocation
    can be elided by inlining the coroutine state into the frame of the caller (which
    could be an ordinary stack frame or another coroutine frame). Unfortunately, there
    is never any guarantee of this elision of the heap allocation.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 协程状态通常在堆上分配。编译器会插入一个单独的堆分配。然而，在某些情况下，可以通过将协程状态内联到调用者的帧中（可以是普通的堆栈帧或另一个协程帧）来省略这个单独的堆分配。不幸的是，永远不能保证省略堆分配。
- en: For the compiler to be able to elide the heap allocation, the complete lifetime
    of the coroutine state must be strictly nested within the lifetime of the caller.
    In addition, the compiler needs to figure out the total size of the coroutine
    state and generally needs to have visibility of the body of the called coroutine
    so that parts of it can be inlined. Situations like virtual function calls, and
    calls to functions in other translation units or shared libraries, typically make
    this impossible. If the compiler is missing the information it needs, it will
    insert a heap allocation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使编译器能够省略堆分配，协程状态的完整生存期必须严格嵌套在调用者的生存期内。此外，编译器需要找出协程状态的总大小，并且通常需要能够看到被调用协程的主体，以便其中的部分可以内联。像虚函数调用和调用其他翻译单元或共享库中的函数的情况通常会使这种情况变得不可能。如果编译器缺少所需的信息，它将插入堆分配。
- en: 'The heap allocation of the coroutine state is performed using `operator` `new`.
    It is possible to provide a custom class-level `operator new` on the promise type,
    which will then be used instead of global `operator new`. It''s therefore possible
    to check whether the heap allocation was elided or not. And if it wasn''t, we
    can find out how much memory is needed for the coroutine state. Here is an example
    using the `Promise` type we defined earlier:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 协程状态的堆分配是使用`operator new`执行的。可以在promise类型上提供自定义的类级`operator new`，然后将其用于全局`operator
    new`。因此，可以检查堆分配是否被省略。如果没有，我们可以找出协程状态需要多少内存。以下是使用我们之前定义的`Promise`类型的示例：
- en: '[PRE19]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Another trick to verify that the heap allocations are completely elided for
    all coroutines using some specific promise type would be to declare `operator
    new` and `operator delete` but leave out their definitions. If the compiler then
    inserts calls to these operators, the program will fail to link due to unresolved
    symbols.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个验证使用特定promise类型的所有协程完全省略了堆分配的技巧是声明`operator new`和`operator delete`，但不包括它们的定义。如果编译器插入了对这些操作符的调用，程序将由于未解析的符号而无法链接。
- en: Avoiding dangling references
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免悬空引用
- en: The fact that a coroutine can be passed around in our code means that we need
    to be very careful about the lifetime of parameters we pass to a coroutine to
    avoid dangling references. The coroutine frame contains copies of the objects
    that normally live on the stack, such as local variables and parameters passed
    to the coroutine. If a coroutine accepts an argument by reference, the *reference*
    is copied, not the object. This means that we can easily end up with dangling
    references when following the usual guidelines for function parameters; that is,
    pass objects that are expensive to copy by reference to `const`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 协程可以在我们的代码中传递，这意味着我们需要非常小心地处理传递给协程的参数的生存期，以避免悬空引用。协程帧包含通常存储在堆栈上的对象的副本，例如局部变量和传递给协程的参数。如果协程通过引用接受参数，则*引用*被复制，而不是对象。这意味着当遵循函数参数的通常指导方针时，即通过引用传递`const`对象，我们很容易遇到悬空引用。
- en: Passing parameters to coroutines
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向协程传递参数
- en: 'The following coroutine uses a reference to a `const std::string`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下协程使用了对`const std::string`的引用：
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Suppose we have a factory function that creates and returns the coroutine,
    like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个创建并返回协程的工厂函数，就像这样：
- en: '[PRE21]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And finally, a `main()` function that uses the coroutine:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个使用协程的`main()`函数：
- en: '[PRE22]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code exhibits undefined behavior as the `std::string` object containing
    the string `"ABC"` is no longer alive when the coroutine tries to access it. Hopefully,
    this doesn''t come as a surprise to you. This problem is similar to having a lambda
    capture a variable by reference, and then passing the lambda to some other code
    without keeping the referenced object alive. A similar example can be achieved
    when passing around a lambda capturing variables by reference:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码表现出未定义的行为，因为包含字符串“ABC”的`std::string`对象在协程尝试访问它时已经不再存在。希望这对你来说不是什么意外。这个问题类似于让lambda通过引用捕获变量，然后将lambda传递给其他代码而不保持引用对象的生存。当传递捕获变量的lambda时也可以实现类似的例子：
- en: '[PRE23]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, the same problem can happen with lambdas. In *Chapter 2*, *Essential
    C++ Techniques*, I warned you about capturing references with lambdas, and it
    is usually better to avoid this by capturing by value instead.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用lambda也可能出现相同的问题。在*第2章*，*基本的C++技术*中，我警告过你使用lambda捕获引用的问题，通常最好通过值捕获来避免这个问题。
- en: 'The solution to avoid dangling references with coroutines is similar: avoid
    passing parameters by reference when using coroutines. Instead, use pass by value,
    and the entire parameter object will be placed safely in the coroutine frame:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 避免悬空引用的解决方案与协程类似：在使用协程时避免通过引用传递参数。而是使用按值传递，整个参数对象将安全地放置在协程帧中：
- en: '[PRE24]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Parameters are an important and common source of lifetime issues when using
    coroutines, but they are not the only source. Now we will explore some other pitfalls
    related to coroutines and dangling references.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是使用协程时生存期问题的一个重要且常见的来源，但并不是唯一的来源。现在我们将探讨一些与协程和悬空引用相关的其他陷阱。
- en: Member functions that are coroutines
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为协程的成员函数
- en: 'A member function can also be a coroutine. For example, there is nothing that
    stops us from using `co_await` inside a member function, as in the following example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 成员函数也可以是协程。例如，我们可以在成员函数中使用`co_await`，就像下面的例子一样：
- en: '[PRE25]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It's important to understand that it's the responsibility of the caller of `coroutine()`
    (in this case, `main()`) to ensure that the `Widget` object, `w`, is kept alive
    during the entire lifetime of the coroutine. The coroutine is accessing data members
    from the object it belongs to, but the `Widget` object itself is *not* kept alive
    by the coroutine. This can easily become a problem if we pass the coroutine to
    some other part of the program.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，调用者`coroutine()`（在这种情况下是`main()`）有责任确保`Widget`对象`w`在整个协程的生命周期内保持存活。协程正在访问所属对象的数据成员，但`Widget`对象本身*不*由协程保持存活。如果我们将协程传递给程序的其他部分，这很容易成为一个问题。
- en: 'Let''s say we are using some coroutine factory function as demonstrated earlier,
    but instead return a member function coroutine:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在使用一些协程工厂函数，就像之前演示的那样，但是返回一个成员函数协程：
- en: '[PRE26]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code exhibits undefined behavior because we now have a dangling reference
    from the coroutine to the `Widget` object created and destructed in the `widget_coro_factory()`
    function. In other words, we end up with two objects with distinct lifetimes,
    whereas one of the objects references the other but without any explicit ownership.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码表现出未定义的行为，因为我们现在有一个从协程到在`widget_coro_factory()`函数中创建和销毁的`Widget`对象的悬空引用。换句话说，我们最终得到了两个具有不同生命周期的对象，其中一个对象引用另一个对象，但没有明确的所有权。
- en: Lambdas that are coroutines
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为协程的lambda
- en: Not only member functions can become coroutines. It's also possible to create
    coroutines using lambda expressions by inserting `co_await`, `co_return`, and/or
    `co_yield` in the body of a lambda.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅成员函数可以成为协程。还可以通过在lambda的主体中插入`co_await`、`co_return`和/或`co_yield`来使用lambda表达式创建协程。
- en: Coroutine lambdas can be a little extra tricky to deal with. One way to understand
    the most common lifetime issue with coroutine lambdas is to think about function
    objects. Recall from *Chapter 2*, *Essential C++ Techniques*, that a lambda expression
    is transformed into a function object by the compiler. The type of this object
    is a class with the call operator implemented. Now, let's say we use `co_return`
    inside the body of a lambda; it means that the call operator `operator()()` becomes
    a coroutine.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 协程lambda可能会有一些额外的棘手问题。更好地理解协程lambda最常见的生命周期问题的一种方法是考虑函数对象。回想一下*第2章*，*Essential
    C++ Techniques*，lambda表达式被编译器转换为函数对象。这个对象的类型是一个实现了调用运算符的类。现在，假设我们在lambda的主体中使用`co_return`；这意味着调用运算符`operator()()`变成了一个协程。
- en: 'Consider the following code using a lambda:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下使用lambda的代码：
- en: '[PRE27]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The type that the lambda corresponds to looks something like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: lambda对应的类型看起来像这样：
- en: '[PRE28]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The important thing to note here is that the actual coroutine is a *member
    function*, namely the call operator `operator()()`. The previous section already
    demonstrated the pitfalls of having coroutine member functions: we need to keep
    the object alive during the lifetime of the coroutine. In the preceding example,
    it means we need to keep the function object named `lambda` alive as long as the
    coroutine frame is alive.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要事情是，实际的协程是一个*成员函数*，即调用运算符`operator()()`。前面的部分已经展示了拥有协程成员函数的陷阱：我们需要在协程的生命周期内保持对象的存活。在前面的例子中，这意味着我们需要在协程帧存活期间保持名为`lambda`的函数对象存活。
- en: 'Some usages of lambdas make it really easy to accidentally destruct the function
    object before the coroutine frame is destroyed. For example, by using an *immediately
    invoked lambda*, we can easily get into trouble:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一些lambda的用法很容易在协程帧被销毁之前意外销毁函数对象。例如，通过使用*立即调用lambda*，我们很容易陷入麻烦：
- en: '[PRE29]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code looks innocent; the lambda is not capturing anything by reference.
    However, the function object created by the lambda expression is a temporary object
    that will be destructed once it has been invoked and the coroutine captures a
    reference to it. When the coroutine is resumed, the program will likely crash
    or produce garbage.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来无害；lambda没有通过引用捕获任何东西。然而，lambda表达式创建的函数对象是一个临时对象，一旦被调用并且协程捕获了对它的引用，它将被销毁。当协程恢复时，程序很可能会崩溃或产生垃圾。
- en: 'Again, a way to understand this better is to transform the lambda to an ordinary
    class with `operator()` defined:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，更好地理解这一点的方法是将lambda转换为具有定义的`operator()`的普通类：
- en: '[PRE30]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now you can see that this is very similar to the case where we had a member
    function that was a coroutine. The function object is not kept alive by the coroutine
    frame.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到，这与我们有一个成员函数是协程的情况非常相似。函数对象不会被协程帧保持存活。
- en: Guidelines to prevent dangling references
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止悬空引用的指导方针
- en: Unless you have good reasons for accepting arguments by reference, choose to
    accept arguments by value if you are writing a coroutine. The coroutine frame
    will then keep a full copy of the object you pass to it, and the object is guaranteed
    to live as long as the coroutine frame.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你有接受引用参数的充分理由，如果你正在编写一个协程，选择通过值接受参数。协程帧将保持你传递给它的对象的完整副本，并且保证对象在协程帧存活期间存活。
- en: If you are using lambdas or member functions that are coroutines, pay special
    attention to the lifetime of the object that the coroutine belongs to. Remember
    that the object (or function object) is *not* stored in the coroutine frame. It's
    the responsibility of the caller of the coroutine to keep it alive.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用lambda或成员函数作为协程，特别注意协程所属对象的生命周期。记住对象（或函数对象）*不*存储在协程帧中。调用协程的责任是保持其存活。
- en: Handling errors
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: There are different ways to transfer errors from a coroutine back to the part
    of the code that called it or resumed it. We are not forced to use exceptions
    for signaling errors. Instead, we can customize error handling as we want.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的方法将错误从协程传递回调用它或恢复它的代码部分。我们不必使用异常来标志错误。相反，我们可以根据需要自定义错误处理。
- en: A coroutine can pass an error back to the client using the coroutine by either
    throwing an exception or returning an error code when the client gets a value
    back from the coroutine (when the coroutine yields or returns).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 协程可以通过抛出异常或在客户端从协程获取值时返回错误代码，将错误传递回客户端。
- en: If we are using exceptions and an exception is propagated out of the body of
    the coroutine, the function `unhandled_exception()` of the promise object is called.
    This call happens inside a catch block inserted by the compiler, so that it is
    possible to use `std::current_exception()` to get hold of the exception that was
    thrown. The result from `std::current_exception()` can then be stored in the coroutine
    as a `std::exception_ptr` and rethrown later on. You will see examples of this
    in the next chapter when using asynchronous coroutines.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用异常并且异常从协程体中传播出来，那么承诺对象的函数`unhandled_exception()`就会被调用。这个调用发生在编译器插入的catch块内部，因此可以使用`std::current_exception()`来获取抛出的异常。然后可以将`std::current_exception()`的结果存储在协程中作为`std::exception_ptr`，并在以后重新抛出。在下一章中使用异步协程时，您将看到这方面的例子。
- en: Customization points
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制点
- en: 'You have already seen many customization points, and I think a valid question
    is: why so many customization points?'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了许多定制点，我认为一个有效的问题是：为什么有这么多定制点？
- en: '**Generality**: The customization points make it possible to use coroutines
    in various ways. There are very few assumptions about how to use the C++ coroutines.
    Library writers can customize the behavior of `co_await`, `co_yield`, and `co_return`.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用性**：定制点使得可以以各种方式使用协程。对于如何使用C++协程，几乎没有什么假设。库编写者可以定制`co_await`、`co_yield`和`co_return`的行为。'
- en: '**Efficiency**: Some of the customization points are there for enabling possible
    optimizations depending on use cases. One example is `await_ready()`, which can
    return `true` to avoid an unnecessary suspension if a value is already computed.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：一些定制点是为了根据使用情况启用可能的优化。一个例子是`await_ready()`，如果值已经计算出来，它可以返回`true`以避免不必要的暂停。'
- en: It should also be said that we are exposed to these customization points because
    the C++ standard doesn't provide any types (except for the `std::coroutine_handle`)
    to communicate with a coroutine. Once they are in place, we can reuse those types
    and not worry too much about some of those customization points. Nevertheless,
    knowing the customization points is valuable in order to fully understand how
    to use C++ coroutines efficiently.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 还应该说的是，我们暴露于这些定制点，是因为C++标准没有提供任何类型（除了`std::coroutine_handle`）来与协程通信。一旦它们就位，我们就可以重用这些类型，而不用太担心其中一些定制点。然而，了解定制点对于充分理解如何有效使用C++协程是有价值的。
- en: Generators
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: A generator is a type of coroutine that yields values back to its caller. For
    example, at the beginning of this chapter, I demonstrated how the generator `iota()`
    yielded increasing integer values. By implementing a general-purpose generator
    type that can act as an iterator, we can simplify the work of implementing iterators
    that are compatible with range-based `for`-loops, standard library algorithms,
    and ranges. Once we have a generator template class in place, we can reuse it.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是一种向其调用者产生值的协程类型。例如，在本章开头，我演示了生成器`iota()`产生递增的整数值。通过实现一个通用的生成器类型，它可以充当迭代器，我们可以简化实现与基于范围的`for`循环、标准库算法和范围兼容的迭代器的工作。一旦我们有了生成器模板类，我们就可以重用它。
- en: So far in this book, you have mostly seen iterators in the context of accessing
    container elements and when using standard library algorithms. However, an iterator
    does not have to be tied to a container. It's possible to write iterators that
    produce values.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，您大多数时候看到的是在访问容器元素和使用标准库算法时的迭代器。然而，迭代器不一定要与容器绑定。可以编写产生值的迭代器。
- en: Implementing a generator
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现生成器
- en: 'The generator we are about to implement is based on the generator from the
    CppCoro library. The generator template is intended to be used as a return type
    for coroutines that produces a sequence of values. It should be possible to use
    objects of this type together with a range-based `for` - loop and standard algorithms
    that accept iterators and ranges. To make this possible, we will implement three
    components:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将实现的生成器是基于CppCoro库中的生成器。生成器模板旨在用作协程的返回类型，用于生成一系列值。应该可以将此类型的对象与基于范围的`for`循环和接受迭代器和范围的标准算法一起使用。为了实现这一点，我们将实现三个组件：
- en: The `Generator`, which is the return object
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Generator`，这是返回对象'
- en: The `Promise`, which acts as the coroutine controller
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise`，作为协程控制器'
- en: The `Iterator`, which is the interface between the client and the `Promise`
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterator`，是客户端和`Promise`之间的接口'
- en: 'These three types are tightly coupled and the relationships between them and
    the coroutine state are presented in the following diagram:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种类型紧密耦合，它们与协程状态之间的关系在下图中呈现：
- en: '![](img/B15619_12_12.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_12.png)'
- en: 'Figure 12.12: The relationships between the Iterator, Generator, Promise, and
    the coroutine state'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：迭代器、生成器、Promise和协程状态之间的关系
- en: 'The return object, in this case the `Generator` class, is tightly coupled with
    the `Promise` type; the `Promise` type is responsible for creating the `Generator`
    object, and the `Generator` type is responsible for exposing the correct `promise_type`
    to the compiler. Here is the implementation of `Generator`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 返回对象，这种情况下是`Generator`类，与`Promise`类型紧密耦合；`Promise`类型负责创建`Generator`对象，而`Generator`类型负责向编译器公开正确的`promise_type`。这是`Generator`的实现：
- en: '[PRE31]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The implementation of `Promise` and `Iterator` will follow soon. The `Generator`
    is not that different from the `Resumable` class we defined earlier. The `Generator`
    is the return object of the coroutine and the owner of the `std::coroutine_handle`.
    The generator is a moveable type. When being moved, the coroutine handle is transferred
    to the newly constructed `Generator` object. When a generator that owns a coroutine
    handle is destructed, it destroys the coroutine state by calling `destroy` on
    the coroutine handle.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise`和`Iterator`的实现将很快跟进。`Generator`与我们之前定义的`Resumable`类并没有太大的不同。`Generator`是协程的返回对象，也是`std::coroutine_handle`的所有者。生成器是可移动类型。在移动时，协程句柄被转移到新构造的`Generator`对象。当拥有协程句柄的生成器被销毁时，它通过在协程句柄上调用`destroy`来销毁协程状态。'
- en: 'The `begin()` and `end()` functions make it possible to use this generator
    in range-based `for`-loops and algorithms that accept ranges. The `Sentinel` type
    is empty—it''s a dummy type—and the `Sentinel` instance is there to be able to
    pass something to the comparison operators of the `Iterator` class. The implementation
    of the `Iterator` looks like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`begin()`和`end()`函数使得可以在基于范围的`for`循环和接受范围的算法中使用这个生成器。`Sentinel`类型是空的——它是一个虚拟类型——`Sentinel`实例是为了能够将某些东西传递给`Iterator`类的比较运算符。`Iterator`的实现如下：'
- en: '[PRE32]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The iterator needs to store the coroutine handle in a data member so that it
    can delegate the calls to the coroutine handle and the promise object:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器需要在数据成员中存储协程句柄，以便它可以将调用委托给协程句柄和promise对象：
- en: When the iterator is dereferenced, it returns the current value held by the
    promise
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当迭代器被解引用时，它返回由promise持有的当前值
- en: When the iterator is incremented, it resumes the coroutine
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当迭代器递增时，它恢复协程
- en: When the iterator is compared with the sentinel value, the iterator ignores
    the sentinel and delegates the call to the coroutine handle, which knows whether
    there are more elements to be generated
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当迭代器与哨兵值进行比较时，迭代器会忽略哨兵并将调用委托给协程句柄，协程句柄知道是否还有更多元素要生成
- en: 'Now there is only the `Promise` type left for us to implement. The complete
    definition of `Promise` looks like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下`Promise`类型需要我们实现。`Promise`的完整定义如下：
- en: '[PRE33]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The promise object for our generator is responsible for:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的生成器的promise对象负责：
- en: Creating the `Generator` object
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`Generator`对象
- en: Defining the behavior when the initial and final suspend points are reached
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义初始和最终挂起点达到时的行为
- en: Keeping track of the last value that was yielded from the coroutine
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪从协程中产生的最后一个值
- en: Handling exceptions thrown by the coroutine body
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理协程主体抛出的异常
- en: 'That''s it! We now have all the pieces in place. A coroutine that returns some
    `Generator<T>` type can now yield values lazily using `co_yield`. The caller of
    the coroutine interacts with the `Generator` and `Iterator` objects to retrieve
    values. The interaction between the objects is illustrated next:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们现在已经把所有的部分都放在了一起。一个返回某种`Generator<T>`类型的协程现在可以使用`co_yield`来懒惰地产生值。协程的调用者与`Generator`和`Iterator`对象交互以检索值。对象之间的交互如下所示：
- en: '![](img/B15619_12_13.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_13.png)'
- en: 'Figure 12.13: The caller communicates with the Generator and Iterator objects
    to retrieve values from the coroutine'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：调用者与生成器和迭代器对象通信，以从协程中检索值
- en: Now, let's see how we can use the new `Generator` template and how it can simplify
    the implementation of various iterators.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用新的`Generator`模板以及它如何简化各种迭代器的实现。
- en: Using the Generator class
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`Generator`类
- en: 'This example is inspired from the talk *C++ Coroutines: Under the covers*,
    by Gor Nishanov at CppCon 2016 ([https://sched.co/7nKt](https://sched.co/7nKt)).
    It clearly demonstrates how we can benefit from the generator types we just implemented.
    Small composable generators can now be implemented like this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '这个例子受到了Gor Nishanov在CppCon 2016上的讲座*C++ Coroutines: Under the covers*的启发([https://sched.co/7nKt](https://sched.co/7nKt))。它清楚地演示了我们如何从刚刚实现的生成器类型中受益。现在可以像这样实现小型可组合的生成器：'
- en: '[PRE34]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A small usage example demonstrates that we can pass our generators to range-based
    `for`-loops:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小的使用示例演示了我们可以将生成器传递给基于范围的`for`循环：
- en: '[PRE35]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The generators are lazily evaluated. No values are produced until the program
    reaches the `for`-loop, which pulls the values out from the chain of generators.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是惰性评估的。直到程序达到`for`循环时，才会产生值，从生成器链中拉取值。
- en: 'Another interesting aspect of this program is that when I compile it using
    Clang 10 with optimizations turned on, the assembly code for the *entire* program
    looks like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的另一个有趣之处是，当我使用启用优化的Clang 10编译它时，*整个*程序的汇编代码看起来像这样：
- en: '[PRE36]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Amazing! The program simply defines a main function that returns the value `75`.
    In other words, the compiler optimizer has been able to completely evaluate the
    chain of generators at compile time and come up with the single value `75`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！程序简单地定义了一个返回值为`75`的主函数。换句话说，编译器优化器能够在编译时完全评估生成器链，并得出单个值`75`。
- en: 'Our `Generator` class can also be used with range algorithms. In the following
    example we use the algorithm `includes()` to see if the sequence `{5,6,7}` is
    a subrange of the numbers produced by the generator:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Generator`类也可以与范围算法一起使用。在下面的示例中，我们使用算法`includes()`来查看序列`{5,6,7}`是否是生成器产生的数字的子序列：
- en: '[PRE37]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With the `Generator` template implemented, we can reuse it for all sorts of
    generator functions. We have implemented a general and highly useful library component
    that application code can benefit from in a great many places when building lazy
    generators.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现`Generator`模板，我们可以重用它来实现各种生成器函数。我们已经实现了一个通用且非常有用的库组件，应用代码可以在构建惰性生成器时从中受益。
- en: Solving generator problems
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决生成器问题
- en: I will now present a small problem and we will try to solve it using different
    techniques for the purpose of understanding which programming idioms we can potentially
    replace with generators. We are about to write a small utility for generating
    linearly spaced sequences between a start value and a stop value.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将提出一个小问题，我们将尝试使用不同的技术来解决它，以了解我们可以用生成器替换哪些编程习惯。我们即将编写一个小型实用程序，用于在起始值和停止值之间生成线性间隔序列。
- en: If you have been using MATLAB/Octave or Python NumPy, you might recognize this
    way of generating evenly (linearly) spaced numbers using a function called `linspace()`.
    It's a handy utility that can be used in various contexts with arbitrary ranges.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直在使用MATLAB/Octave或Python NumPy，您可能会认识到使用名为`linspace()`的函数生成均匀（线性）间隔数字的方式。这是一个方便的实用程序，可以在各种上下文中使用任意范围。
- en: 'We will call our generator `lin_space()`. Here is a usage example of generating
    five equally spaced values between `2.0` and `3.0`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称我们的生成器为`lin_space()`。以下是一个使用示例，在`2.0`和`3.0`之间生成五个等间距值：
- en: '[PRE38]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When generating floating-point values, we have to be a little bit cautious because
    we cannot simply compute the size of each step (0.25 in the preceding example)
    and accumulate it, since the step size might not be possible to represent exactly
    using a floating-point data type. The possible rounding error will add up at each
    iteration and eventually we may end up with completely nonsensical values. What
    we instead need to do is to calculate a number between the start and stop value
    at a specific increment using linear interpolation.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成浮点值时，我们必须要小心，因为我们不能简单地计算每个步骤的大小（在前面的示例中为0.25）并累积它，因为步长可能无法使用浮点数据类型精确表示。可能的舍入误差将在每次迭代中累积，最终我们可能会得到完全荒谬的值。相反，我们需要做的是使用线性插值在特定增量上计算开始和停止值之间的数字。
- en: 'C++20 added a handy utility to `<cmath>` called `std::lerp()`, which computes
    the linear interpolation between two values with a specified amount. In our case,
    the amount will be a value between 0.0 and 1.0; an amount of 0 returns the `start`
    value and a value of 1.0 returns the `stop` value. Here are a few examples of
    using `std::lerp()`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: C++20在`<cmath>`中添加了一个方便的实用程序，称为`std::lerp()`，它计算两个值之间的线性插值，并指定一个特定的量。在我们的情况下，量将是0.0到1.0之间的值；量为0返回`start`值，量为1.0返回`stop`值。以下是使用`std::lerp()`的几个示例：
- en: '[PRE39]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `lin_space()` functions we are about to write will all use the following
    small utility function template:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将编写的`lin_space()`函数将全部使用以下小型实用函数模板：
- en: '[PRE40]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The function returns a value in the linear sequence in the range [`start`, `stop`].
    The `index` parameter is the current number in the sequence of the `n` total numbers
    we are about to generate.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回范围[`start`，`stop`]中线性序列中的一个值。`index`参数是我们即将生成的`n`个总数中的当前数字。
- en: 'With the `lin_value()` helper in place, we can now easily implement the `lin_space()`
    generator. Before seeing a solution using a coroutine, we will examine other common
    techniques. The sections to follow will explore the following different approaches
    when implementing `lin_space()`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`lin_value()`辅助程序，我们现在可以轻松实现`lin_space()`生成器。在看到使用协程的解决方案之前，我们将研究其他常见技术。接下来的部分将探讨在实现`lin_space()`时使用的不同方法：
- en: Eagerly generate and return all values
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 急切地生成并返回所有值
- en: Using a callback (lazy)
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用回调（惰性）
- en: Using a custom iterator (lazy)
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义迭代器（惰性）
- en: Using the Ranges library (lazy)
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ranges库（惰性）
- en: Using coroutines with our `Generator` class (lazy)
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的`Generator`类的协程（惰性）
- en: For each example, there will be a short reflection of the strengths and weaknesses
    of each approach.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个示例，都将简要反映每种方法的优缺点。
- en: An eager linear range
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个急切的线性范围
- en: 'We''ll begin by implementing a simple eager version that computes all the values
    in the range and returns a vector with all values:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现一个简单的急切版本，计算范围内的所有值并返回一个包含所有值的向量：
- en: '[PRE41]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since this version returns a standard container, it''s possible to use the
    return value with range-based `for`-loops and other standard algorithms:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个版本返回一个标准容器，所以可以将返回值与基于范围的`for`循环和其他标准算法一起使用：
- en: '[PRE42]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This version is straightforward, and fairly easy to read. The downside is that
    we need to allocate a vector and fill it with *all* values, although the caller
    is not necessarily interested in all values. This version also lacks composability
    as there is no way to filter out elements in the middle without first generating
    all values.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本很直接，而且相当容易阅读。缺点是我们需要分配一个向量并填充*所有*值，尽管调用者不一定对所有值感兴趣。这个版本也缺乏可组合性，因为没有办法在首先生成所有值之前过滤中间的元素。
- en: Now let's try to implement a lazy version of the `lin_space()` generator.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试实现`lin_space()`生成器的惰性版本。
- en: A lazy version using a callback
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用回调的惰性版本
- en: 'In *Chapter 10,* *Proxy Objects and Lazy Evaluation*, we concluded that lazy
    evaluation can be accomplished by using callback functions. The lazy version we
    will implement will be based on passing a callback to `lin_space()` and invoking
    the callback function when emitting values:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第10章* *代理对象和惰性求值*中，我们得出结论，可以通过使用回调函数来实现惰性求值。我们将要实现的惰性版本将基于将回调传递给`lin_space()`并在发出值时调用回调函数：
- en: '[PRE43]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we want to print the values produced by the generator, we can call this
    function like this:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想打印生成器产生的值，可以这样调用该函数：
- en: '[PRE44]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The iteration now take places within the `lin_space()` function. There is no
    way to cancel the generator, but with some changes we could have the callback
    function return a `bool` to indicate whether it wants more elements to be generated.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在迭代发生在`lin_space()`函数内部。无法取消生成器，但通过一些更改，我们可以让回调函数返回一个`bool`来指示是否希望生成更多元素。
- en: This approach works but is not very elegant. The problem with this design becomes
    more apparent when trying to compose generators. If we wanted to add a filter
    that would select some special values, we would end up having nested callback
    functions.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有效，但不太优雅。这种设计的问题在尝试组合生成器时变得更加明显。如果我们想要添加一个选择一些特殊值的过滤器，我们最终会有嵌套的回调函数。
- en: We will now move on to see how we can implement an iterator-based solution to
    our problem.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续看如何实现基于迭代器的解决方案。
- en: An iterator implementation
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代器实现
- en: 'Another alternative is to implement a type that conforms to the range concept
    by exposing the `begin()` and `end()` iterators. The class template `LinSpace`,
    defined here, makes it possible to iterate over the linear range of values:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是实现一个符合范围概念的类型，通过暴露`begin()`和`end()`迭代器。在这里定义的类模板`LinSpace`使得可以迭代线性值的范围：
- en: '[PRE45]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This implementation is very efficient. However, it is afflicted with a lot
    of boilerplate code and the small algorithm we are trying to encapsulate is now
    spread out into different parts: the `LinSpace` constructor implements the initial
    work of setting up the start and stop values, whereas the work needed for computing
    the values ends up in the member functions of the `Iterator` class. This makes
    the implementation of the algorithm harder to understand compared with the other
    versions we have looked at.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现非常高效。然而，它受到大量样板代码的困扰，我们试图封装的小算法现在分散在不同的部分：`LinSpace`构造函数实现了设置起始和停止值的初始工作，而计算值所需的工作最终在`Iterator`类的成员函数中完成。与我们看到的其他版本相比，这使得算法的实现更难理解。
- en: A solution using the Ranges library
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Ranges库的解决方案
- en: 'Yet another alternative is to compose our algorithm using building blocks from
    the Ranges library (C++20), as shown here:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用Ranges库（C++20）中的构建模块来组合我们的算法，如下所示：
- en: '[PRE46]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here we have the entire algorithm encapsulated inside a small function. We are
    using `std::views::iota` to generate the indexes for us. Converting an index to
    a linear value is a simple transformation that can be chained after the `iota`
    view.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将整个算法封装在一个小函数中。我们使用`std::views::iota`为我们生成索引。将索引转换为线性值是一个简单的转换，可以在`iota`视图之后链接。
- en: This version is efficient and composable. The object returned from `lin_space()`
    is a random-access range of type `std::ranges::view`, which can be iterated over
    using range-based `for`-loops or passed to other algorithms.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本高效且可组合。从`lin_space()`返回的对象是`std::ranges::view`类型的随机访问范围，可以使用基于范围的`for`循环进行迭代，或者传递给其他算法。
- en: Finally, it's time to use our `Generator` class to implement our algorithm as
    a coroutine.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候使用我们的`Generator`类来将我们的算法实现为一个协程。
- en: A solution using a coroutine
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用协程的解决方案
- en: 'After looking at no less than four versions of this very same problem, we have
    now reached the last solution. Here I will present a version that uses the general
    `Generator` class template implemented earlier:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在看了不少于四个版本的同一个问题之后，我们现在已经达到了最后的解决方案。在这里，我将呈现一个使用之前实现的通用`Generator`类模板的版本：
- en: '[PRE47]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It's compact, straightforward, and easy to understand. By using `co_yield`,
    we can write the code in such a way that it looks similar to the simple eager
    version, but without the need for collecting all the values in a container. It's
    possible to chain multiple generators based on coroutines, as you will see at
    the end of this chapter.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 它紧凑、简单明了。通过使用`co_yield`，我们可以以类似于简单的急切版本的方式编写代码，但不需要收集所有值到一个容器中。可以基于协程链式多个生成器，正如你将在本章末尾看到的那样。
- en: This version is also compatible with range-based `for`-loops and standard algorithms.
    However, this version exposes an input range, so it's not possible to skip ahead
    arbitrary number of elements, which is possible with the version using the Ranges
    library.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本也兼容基于范围的`for`循环和标准算法。然而，这个版本暴露了一个输入范围，所以不可能跳过任意数量的元素，而使用Ranges库的版本是可以的。
- en: Conclusion
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: Obviously, there is more than one way to do it. But why did I show all these
    approaches?
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，有多种方法可以做到这一点。但为什么我展示了所有这些方法呢？
- en: Firstly, if you are new to coroutines, you will hopefully start to see the patterns
    where it can be advantageous to use coroutines.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你是新手协程，希望你能开始看到在哪些情况下使用协程是有利的。
- en: Secondly, the `Generator` template and the use of `co_yield` allows us to implement
    lazy generators in a very clear and concise way. This becomes obvious when we
    compare the solution with other versions.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`Generator`模板和使用`co_yield`允许我们以非常清晰简洁的方式实现惰性生成器。当我们将解决方案与其他版本进行比较时，这一点变得很明显。
- en: Lastly, some approaches might look very contrived for this example problem but
    are frequently being used in other contexts. C++ is by default an eager language,
    and many (myself included) have become accustomed to creating code similar to
    the eager version. The version using a callback might look very strange but is
    a commonly used pattern in asynchronous code, where coroutines can wrap or replace
    those callback-based APIs.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些方法在这个例子问题中可能看起来很牵强，但在其他情境中经常被使用。C++默认是一种急切的语言，许多人（包括我自己）已经习惯于创建类似急切版本的代码。使用回调的版本可能看起来很奇怪，但在异步代码中是一个常用的模式，协程可以包装或替代那些基于回调的API。
- en: The generator type we implemented is partly based on the synchronous generator
    template from the CppCoro library. CppCoro also provides an `async_generator`
    template, which makes it possible to use the `co_await` operator within the generator
    coroutine. I provided the `Generator` template in this chapter for the purpose
    of demonstrating how a generator can be implemented and how we can interact with
    coroutines. But if you plan to start using generators in your code, consider using
    a third-party library.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的生成器类型部分基于CppCoro库中的同步生成器模板。CppCoro还提供了一个`async_generator`模板，它使得可以在生成器协程中使用`co_await`运算符。我在本章中提供了`Generator`模板，以演示如何实现生成器以及如何与协程交互。但是，如果您计划在代码中开始使用生成器，请考虑使用第三方库。
- en: A real-world example using generators
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用生成器的真实世界示例
- en: Using coroutines for simplifying iterators really shines when the examples are
    a little bit more advanced. Using `co_yield` with the `Generator` class allows
    us to implement and combine small algorithms efficiently and without the need
    for boilerplate code to glue it all together. This next example will try to prove
    that.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当示例稍微复杂时，使用协程简化迭代器的示例效果非常好。使用`Generator`类的`co_yield`允许我们高效地实现和组合小算法，而无需编写大量模板代码来将它们粘合在一起。下一个示例将尝试证明这一点。
- en: The problem
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题
- en: We will here go through an example of how we can use our `Generator` class to
    implement a compression algorithm that can be used in search engines to compress
    the search index typically stored on disk. The example is thoroughly described
    in the book *Introduction to Information Retrieval* by Manning et al, which is
    freely available at [https://nlp.stanford.edu/IR-book/](https://nlp.stanford.edu/IR-book/).
    Here follows a brief background and a short description of the problem.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里通过一个示例来演示如何使用我们的`Generator`类来实现一个压缩算法，该算法可以用于搜索引擎中压缩通常存储在磁盘上的搜索索引。该示例在Manning等人的书籍《信息检索导论》中有详细描述，该书可以在[https://nlp.stanford.edu/IR-book/](https://nlp.stanford.edu/IR-book/)免费获取。以下是简要背景和问题的简要描述。
- en: Search engines use some variant of a data structure called an **inverted index**.
    It is like an index at the end of a book. Using the index, we can find all pages
    that contain the terms we are searching for.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索引擎使用称为**倒排索引**的数据结构的某种变体。它类似于书末的索引。使用该索引，我们可以找到包含我们正在搜索的术语的所有页面。
- en: 'Now imagine that we have a database full of recipes and that we build an inverted
    index for this database. Parts of this index might look something like this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们有一个充满食谱的数据库，并且我们为该数据库构建了一个倒排索引。该索引的部分可能看起来像这样：
- en: '![](img/B15619_12_14.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_14.png)'
- en: 'Figure 12.14: An inverted index with three terms and their corresponding lists
    of document references'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：具有三个术语及其相应的文档引用列表的倒排索引
- en: 'Each term is associated with a sorted list of document identifiers. (For example,
    the term **apple** is included in the recipes with IDs **4**, **9**, **67**, and
    **89**.) If we want to find recipes that contain both **beans** *and* **chili**,
    we can run a merge-like algorithm to find the intersection of the lists for **beans**
    and **chili**:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 每个术语都与一个排序的文档标识符列表相关联。（例如，术语**苹果**包含在ID为**4**、**9**、**67**和**89**的食谱中。）如果我们想要查找同时包含**豆子**和**辣椒**的食谱，我们可以运行类似合并的算法来找到**豆子**和**辣椒**列表的交集：
- en: '![](img/B15619_12_15.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_15.png)'
- en: Figure 12.15 Intersection of the document lists for the terms "beans" and "chili"
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：“豆子”和“辣椒”术语的文档列表的交集
- en: Now imagine that we have a big database and we choose to represent the document
    identifier with a 32-bit integer. The lists of document identifiers can become
    very long for terms that appear in many documents and therefore we need to compress
    those lists. One possible way to do that is to use delta encoding combined with
    a variable byte encoding scheme.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们有一个大型数据库，并且我们选择用32位整数表示文档标识符。对于出现在许多文档中的术语，文档标识符列表可能会变得非常长，因此我们需要压缩这些列表。其中一种可能的方法是使用增量编码结合可变字节编码方案。
- en: Delta encoding
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增量编码
- en: 'Since the lists are sorted, we could, instead of saving the document identifiers,
    store the **gap** between two adjacent elements. This technique is called **delta
    encoding** or **gap encoding**. The following diagram shows an example using document
    IDs and gaps:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表是排序的，我们可以不保存文档标识符，而是存储两个相邻元素之间的**间隔**。这种技术称为**增量编码**或**间隔编码**。以下图表显示了使用文档ID和间隔的示例：
- en: '![](img/B15619_12_16.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_16.png)'
- en: 'Figure 12.16: Gap encoding stores the gap between two adjacent elements in
    a list'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：间隔编码存储列表中两个相邻元素之间的间隔
- en: Gap encoding is well-suited for this type of data; frequently used terms will
    consequently have many small gaps. The really long lists will only contain very
    small gaps. After the lists have been gap encoded, we can use a variable byte
    encoding scheme to actually compress the lists by using fewer bytes for smaller
    gaps.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 间隔编码非常适合这种类型的数据；因此经常使用的术语将具有许多小间隔。真正长的列表将只包含非常小的间隔。在列表进行间隔编码之后，我们可以使用可变字节编码方案来实际压缩列表，通过使用较少的字节来表示较小的间隔。
- en: 'But first, let''s start implementing the gap encoding functionality. We will
    begin by writing two small coroutines that will do the gap encoding/decoding.
    The encoder transforms a sorted sequence of integers to a sequence of gaps:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们开始实现间隔编码功能。我们将首先编写两个小协程，用于执行间隔编码/解码。编码器将排序的整数序列转换为间隔序列：
- en: '[PRE48]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: By using `co_yield`, there is no need to eagerly pass a complete list of numbers
    and allocate a big output list of gaps. Instead, the coroutine lazily handles
    one number at a time. Note how the function `gap_encode()` contains everything
    that there is to know about how to convert document IDs to gaps. Implementing
    this as a traditional iterator would be possible, but this would have logic spread
    out in constructors and operators on iterators.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`co_yield`，我们无需急切地传递完整的数字列表并分配一个大的输出间隔列表。相反，协程会懒惰地处理一个数字。请注意，函数`gap_encode()`包含了有关如何将文档ID转换为间隔的所有信息。将其实现为传统的迭代器是可能的，但这将使逻辑分散在构造函数和迭代器操作符中。
- en: 'We can build a small program to test our gap encoder:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个小程序来测试我们的间隔编码器：
- en: '[PRE49]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The decoder does the opposite; it takes as input a range of gaps and transforms
    it to the list of ordered numbers:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 解码器则相反；它以间隔的范围作为输入，并将其转换为有序数字列表：
- en: '[PRE50]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'By using gap encoding, we will on average, store much smaller numbers. But
    since we are still using `int` values for storing the small gaps, we haven''t
    really gained anything if we save these gaps to disk. Unfortunately, we cannot
    just use a smaller fixed-size data type, because there is still a possibility
    that we will encounter a really big gap that would require a full 32-bit `int`.
    What we want is a way to store small gaps using fewer bits, as illustrated in
    the following diagram:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用间隔编码，我们平均可以存储更小的数字。但由于我们仍然使用`int`值来存储小间隔，如果将这些间隔保存到磁盘上，我们并没有真正获得任何好处。不幸的是，我们不能只使用较小的固定大小数据类型，因为仍然有可能遇到需要完整32位`int`的非常大的间隔。我们希望的是以更少的位数存储小间隔，如下图所示：
- en: '![](img/B15619_12_17.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_17.png)'
- en: 'Figure 12.17: Small numbers should use fewer bytes'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：小数字应该使用更少的字节
- en: In order to make this list physically smaller, we can use **variable byte encoding**
    so that small gaps are encoded with fewer bytes than bigger gaps, as illustrated
    in the preceding diagram.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个列表在物理上更小，我们可以使用**可变字节编码**，这样小间隔可以用比大间隔更少的字节进行编码，如前图所示。
- en: Variable byte encoding
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可变字节编码
- en: 'Variable byte encoding is a very common compression technique. UTF-8 and MIDI
    message are some of the well-known encodings that uses this technique. In order
    to use a variable number of bytes when encoding, we use 7-bits of each byte for
    the actual payload. The first bit of each byte represents a **continuation bit**.
    It is set to `0` if there are more bytes to read, or `1` for the last byte of
    the encoded number. The encoding scheme is exemplified in the following diagram:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 可变字节编码是一种非常常见的压缩技术。UTF-8和MIDI消息是一些使用这种技术的众所周知的编码。为了在编码时使用可变数量的字节，我们使用每个字节的7位作为实际有效载荷。每个字节的第一位表示**续位**。如果还有更多字节要读取，则设置为`0`，如果是编码数字的最后一个字节，则设置为`1`。编码方案在下图中有例示：
- en: '![](img/B15619_12_18.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_12_18.png)'
- en: 'Figure 12.18: Using variable byte encoding, only one byte is required to store
    the decimal value 3 and two bytes for encoding the decimal value 1025'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18：使用可变字节编码，只需要一个字节来存储十进制值3，而需要两个字节来编码十进制值1025
- en: 'Now we are ready to implement the variable byte encoding and decoding scheme.
    This is a little bit more complicated than delta encoding. The encoder should
    transform a number into a sequence of one or multiple bytes:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备实现可变字节编码和解码方案。这比增量编码要复杂一些。编码器应该将一个数字转换为一个或多个字节的序列：
- en: '[PRE51]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The continuation bit, named `cont` in the code, is either 0 or 128, which corresponds
    to the bit sequence 10000000\. The details in this example are not that important
    to understand, but to make the encoding easier, the bytes are generated in reverse
    order so that the least significant byte comes first. This is not a problem since
    we can handle that easily during the decoding.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 续位，代码中称为`cont`，要么是0，要么是128，对应的位序列是10000000。这个例子中的细节并不重要，但为了使编码更容易，字节是以相反的顺序生成的，这样最不重要的字节首先出现并不是问题，因为我们可以在解码过程中轻松处理这个问题。
- en: 'With the number encoder in place, it''s easy to encode a sequence of numbers
    and transform them into a sequence of bytes:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 有了数字编码器，就可以轻松地对一系列数字进行编码，并将它们转换为一系列字节：
- en: '[PRE52]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The decoder is probably the most complicated part. But again, it is fully encapsulated
    into one single function with a clean interface:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 解码器可能是最复杂的部分。但同样，它完全封装在一个单一函数中，并具有清晰的接口：
- en: '[PRE53]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, there is very little boilerplate code needed in this code. Each
    coroutine encapsulates all states and describes clearly how to process one piece
    at a time.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这段代码中几乎没有需要的样板代码。每个协程封装了所有状态，并清楚地描述了如何一次处理一个部分。
- en: 'The last piece we need is to combine the gap encoder with the variable byte
    encoder in order to compress our sorted list of document identifiers:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将间隔编码器与可变字节编码器结合起来，以压缩我们的文档标识符排序列表：
- en: '[PRE54]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Decompress is a simple chaining of `vb_decode()` followed by `gap_decode()`:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 解压缩是`vb_decode()`后跟`gap_decode()`的简单链接：
- en: '[PRE55]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Since the `Generator` class exposes iterators, we can take this example even
    further and easily stream the values to and from disk using iostreams. (Although,
    a more realistic approach would be to use memory-mapped I/O for better performance.)
    Here are two small functions that writes and reads the compressed data to and
    from disk:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Generator`类公开了迭代器，我们甚至可以进一步使用iostreams将值流式传输到磁盘上。 （尽管更现实的方法是使用内存映射I/O以获得更好的性能。）以下是两个将压缩数据写入磁盘并从磁盘读取的小函数：
- en: '[PRE56]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'A small test program will wrap this example up:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小的测试程序将结束这个例子：
- en: '[PRE57]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This example aims to show that we can divide lazy programs into small encapsulated
    coroutines. The low overhead of C++ coroutines makes them suitable for building
    efficient generators. The `Generator` we implemented initially is a fully reusable
    class that helps us with minimizing the amount of boilerplate code in examples
    like this.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子旨在表明我们可以将惰性程序分成小的封装协程。C++协程的低开销使它们适合构建高效的生成器。我们最初实现的`Generator`是一个完全可重用的类，可以帮助我们最小化这类示例中的样板代码量。
- en: This ends the section about generators. We will now move on to discuss some
    general performance considerations when using coroutines.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了关于生成器的部分。我们现在将继续讨论在使用协程时的一些一般性能考虑。
- en: Performance
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: Each time a coroutine is created (when it is first called) a coroutine frame
    is allocated to hold the coroutine state. The frame can be allocated on the heap,
    or on the stack in some circumstances. However, there are no guarantees to completely
    avoid the heap allocation. If you are in a situation where heap allocations are
    forbidden (for example, in a real-time context) the coroutine can be created and
    immediately suspended in a different thread, and then passed to the part of the
    program that needs to actually use the coroutine. Suspend and resume are guaranteed
    to not allocate any memory and have a cost comparable with an ordinary function
    call.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建协程（首次调用时），都会分配一个协程帧来保存协程状态。帧可以在堆上分配，或者在某些情况下在堆栈上分配。但是，并没有完全避免堆分配的保证。如果您处于禁止堆分配的情况（例如，在实时环境中），协程可以在不同的线程中创建并立即挂起，然后传递给实际需要使用协程的程序部分。挂起和恢复保证不会分配任何内存，并且具有与普通函数调用相当的成本。
- en: At the time of writing this book, compilers have experimental support for coroutines.
    Small experiments have shown promising results related to performance, showing
    that coroutines are friendly to the optimizer. However, I will not provide you
    with any benchmarks of coroutines in this book. Instead, I have shown you how
    stackless coroutines are evaluated and how it's possible for coroutines to be
    implemented with minimal overheads.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，编译器对协程有实验性支持。小型实验显示了与性能相关的有希望的结果，表明协程对优化器友好。但是，我不会在本书中为您提供任何协程的基准测试。相反，我向您展示了无栈协程是如何评估的，以及如何可能以最小的开销实现协程。
- en: The generator example demonstrated that coroutines can potentially be very friendly
    to the compiler. The chain of generators we wrote in that example was completely
    evaluated at runtime. In practice, this is a very good property of C++ coroutines.
    They allow us to write code that is easy for both compilers and human beings to
    understand. C++ coroutines usually produce clean code that is easy to optimize.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器示例表明，协程可能对编译器非常友好。我们在该示例中编写的生成器链是在运行时完全评估的。实际上，这是C++协程的一个非常好的特性。它们使我们能够编写对编译器和人类都易于理解的代码。C++协程通常会产生易于优化的干净代码。
- en: Coroutines that execute on the same thread can share state without using any
    locking primitives and can therefore avoid the performance overhead incurred by
    synchronizing multiple threads. This will be demonstrated in the next chapter.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一线程上执行的协程可以共享状态，而无需使用任何锁原语，因此可以避免同步多个线程所产生的性能开销。这将在下一章中进行演示。
- en: Summary
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have seen how to use C++ coroutines for building generators
    using the keywords `co_yield` and `co_return`. To better understand how C++ stackless
    coroutines differ from stackful coroutines, we compared the two and also looked
    at the customization points that C++ coroutines offer. This gave you a deep understanding
    of how flexible C++ coroutines are, as well as how they can be used to achieve
    efficiency. Stackless coroutines are closely related to state machines. By rewriting
    a traditionally implemented state machine into code that uses coroutines, we explored
    this relationship and you saw how well compilers can transform and optimize our
    coroutines to machine language.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了如何使用C++协程来使用关键字`co_yield`和`co_return`构建生成器。为了更好地理解C++无栈协程与有栈协程的区别，我们对两者进行了比较，并查看了C++协程提供的定制点。这使您深刻了解了C++协程的灵活性，以及它们如何实现效率。无栈协程与状态机密切相关。通过将传统实现的状态机重写为使用协程的代码，我们探索了这种关系，您看到编译器如何将我们的协程转换和优化为机器语言。
- en: In the next chapter, we will continue to discuss coroutines by focusing on asynchronous
    programming and will deepen your understanding of the `co_await` keyword.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论协程，重点放在异步编程上，并加深您对`co_await`关键字的理解。
