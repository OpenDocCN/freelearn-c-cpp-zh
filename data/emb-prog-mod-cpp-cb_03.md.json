["```cpp\n#include <iostream>\n\nvoid SendDataToDevice(void* buffer, uint32_t size) {\n  // This is a stub function to send data pointer by\n  // buffer.\n  std::cout << \"Sending data chunk of size \" << size << std::endl;\n}\n\nint main() {\n  char buffer[] = \"Hello, world!\";\n  uint32_t size = sizeof(buffer);\n  SendDataToDevice(&size, sizeof(size));\n  SendDataToDevice(buffer, size);\n  return 0;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(fixed_types)\nadd_executable(fixed_types fixed_types.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n\n```", "```cpp\n  uint32_t size = sizeof(buffer);\n```", "```cpp\n  SendDataToDevice(&size, sizeof(size));\n```", "```cpp\n  Sending data chunk of size 4\n```", "```cpp\n  int size = sizeof(buffer);\n```", "```cpp\n#include <iostream>\n\nvoid StoreData(const char* buffer, size_t size) {\n  std::cout << \"Store \" << size << \" bytes of data\" << std::endl;\n}\n\nint main() {\n  char data[] = \"Hello,\\x1b\\a\\x03world!\";\n  const char *buffer = data;\n  std::cout << \"Size of buffer pointer is \" << sizeof(buffer) << std::endl;\n  std::cout << \"Size of int is \" << sizeof(int) << std::endl;\n  std::cout << \"Size of size_t is \" << sizeof(size_t) << std::endl;\n  StoreData(data, sizeof(data));\n  return 0;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(sizet)\nadd_executable(sizet sizet.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n\n```", "```cpp\nvoid StoreData(const char* buffer, size_t size) {\n```", "```cpp\nvoid *memset(void *b, int c, size_t len);\n```", "```cpp\n#include <iostream>\n\nint main() {\n  union {\n    uint32_t i;\n    uint8_t c[4];\n  } data;\n  data.i = 0x01020304;\n  if (data.c[0] == 0x01) {\n    std::cout << \"Big-endian\" << std::endl;\n  } else {\n    std::cout << \"Little-endian\" << std::endl;\n  }\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(endianness)\nadd_executable(endianness endianness.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n\n```", "```cpp\n  union {\n    uint32_t i;\n    uint8_t c[4];\n  } data\n```", "```cpp\n#include <stdexcept>\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <stdint.h>\n#include <string.h>\n#include <unistd.h>\n```", "```cpp\nvoid WriteData(int fd, const void* ptr, size_t size) {\n  size_t offset =0;\n  while (size) {\n    const char *buffer = (const char*)ptr + offset;\n    int written = write(fd, buffer, size);\n    if (written < 0) {\n      throw std::runtime_error(\"Can not write to file\");\n    }\n    offset += written;\n    size -= written;\n  }\n  }\n```", "```cpp\nvoid WriteMessage(int fd, const char* str) {\n  uint32_t size = strlen(str);\n  uint32_t encoded_size = htonl(size);\n  WriteData(fd, &encoded_size, sizeof(encoded_size));\n  WriteData(fd, str, size);\n}\n\nint main(int argc, char** argv) {\n  int fd = open(\"envconv.data\", \n                 O_WRONLY|O_APPEND|O_CREAT, 0666);\n  for (int i = 1; i < argc; i++) {\n    WriteMessage(fd, argv[i]);\n  }\n}\n```", "```cpp\n#include <stdexcept>\n#include <arpa/inet.h>\n#include <fcntl.h>\n#include <stdint.h>\n#include <string.h>\n#include <unistd.h>\n```", "```cpp\nvoid ReadData(int fd, void* ptr, size_t size) {\n  size_t offset =0;\n  while (size) {\n    char *buffer = (char*)ptr + offset;\n    int received = read(fd, buffer, size);\n    if (received < 0) {\n      throw std::runtime_error(\"Can not read from file\");\n    } else if (received == 0) {\n      throw std::runtime_error(\"No more data\");\n    }\n    offset += received;\n    size -= received;\n  }\n  }\n```", "```cpp\nstd::string ReadMessage(int fd) {\n  uint32_t encoded_size = 0;\n  ReadData(fd, &encoded_size, sizeof(encoded_size));\n  uint32_t size = ntohl(encoded_size);\n  auto data = std::make_unique<char[]>(size);\n  ReadData(fd, data.get(), size);\n  return std::string(data.get(), size);\n}\n\nint main(void) {\n  int fd = open(\"envconv.data\", O_RDONLY, 0666);\n  while(true) {\n    try {\n      auto s = ReadMessage(fd);\n      std::cout << \"Read: \" << s << std::endl;\n    } catch(const std::runtime_error& e) {\n      std::cout << e.what() << std::endl;\n      break;\n    }\n  }\n }\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(conv)\nadd_executable(sender sender.cpp)\nadd_executable(receiver receiver.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++14\")\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n\n```", "```cpp\n$ xxd envconv.data \n0000000: 0000 0005 4865 6c6c 6f00 0000 0557 6f72 ....Hello....Wor\n0000010: 6c64 ld\n```", "```cpp\n  uint32_t encoded_size = htonl(size);\n```", "```cpp\n  WriteData(fd, &encoded_size, sizeof(encoded_size));\n```", "```cpp\n  WriteData(fd, str, size);\n```", "```cpp\n uint32_t encoded_size = 0;\n ReadData(fd, &encoded_size, sizeof(encoded_size));\n```", "```cpp\n uint32_t size = ntohl(encoded_size);\n```", "```cpp\n auto data = std::make_unique<char[]>(size);\n ReadData(fd, data.get(), size);\n```", "```cpp\nCompilers align data automatically. When it comes to structures, the result may be surprising for developers who are not aware of alignment.\nstruct {\n    uint8_t c;\n    uint32_t i;\n} a = {1, 1};\n\nstd::cout << sizeof(a) << std::endl;\n```", "```cpp\nstruct {\n    uint8_t c;\n uint8_t cc;\n    uint32_t i;\n} a = {1, 1};\n\nstd::cout << sizeof(a) << std::endl;\n```", "```cpp\n#include <iostream>\nenum class Category: uint8_t {\n  file, directory, socket\n};\nstruct ObjectMetadata1 {\n  uint8_t access_flags;\n  uint32_t size;\n  uint32_t owner_id;\n  Category category;\n};\n\n```", "```cpp\nstruct ObjectMetadata2 {\n  uint32_t size;\n  uint32_t owner_id;\n  uint8_t access_flags;\n  Category category;\n};\n\nint main() {\n  ObjectMetadata1 object_pool1[1000];\n  ObjectMetadata2 object_pool2[1000];\n  std::cout << \"Poorly aligned:\" << sizeof(object_pool1) << std::endl;\n  std::cout << \"Well aligned:\" << sizeof(object_pool2) << std::endl;\n  return 0;\n}\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(alignment)\nadd_executable(alignment alignment.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"--std=c++11\")\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n\n```", "```cpp\nenum class Category: uint8_t {\n```", "```cpp\nstruct ObjectMetadata1 {\n  uint8_t access_flags;\n  uint32_t size;\n  uint32_t owner_id;\n  Category category;\n} __attribute__((packed));\n\nstruct ObjectMetadata2 {\n  uint32_t size;\n  uint32_t owner_id;\n  uint8_t access_flags;\n  Category category;\n} __attribute__((packed));\n```", "```cpp\n} __attribute__((packed));\n```", "```cpp\n#include <stdlib.h>\n#include <stdio.h>\n\nconstexpr int kAlignSize = 128;\nconstexpr int kAllocBytes = 128;\n\nconstexpr int overlap(void* ptr) {\n  size_t addr = (size_t)ptr;\n  return addr & (kAlignSize - 1);\n }\n```", "```cpp\nint main() {\n  char static_buffer[kAllocBytes];\n  char* dynamic_buffer = new char[kAllocBytes];\n\n  alignas(kAlignSize) char aligned_static_buffer[kAllocBytes];\n  char* aligned_dynamic_buffer = nullptr;\n  if (posix_memalign((void**)&aligned_dynamic_buffer,\n      kAlignSize, kAllocBytes)) {\n    printf(\"Failed to allocate aligned memory buffer\\n\");\n  }\n\n```", "```cpp\n  printf(\"Static buffer address: %p (%d)\\n\", static_buffer,\n         overlap(static_buffer));\n  printf(\"Dynamic buffer address: %p (%d)\\n\", dynamic_buffer,\n         overlap(dynamic_buffer));\n  printf(\"Aligned static buffer address: %p (%d)\\n\", aligned_static_buffer,\n         overlap(aligned_static_buffer));\n  printf(\"Aligned dynamic buffer address: %p (%d)\\n\", aligned_dynamic_buffer,\n         overlap(aligned_dynamic_buffer));\n  delete[] dynamic_buffer;\n  free(aligned_dynamic_buffer);\n  return 0;\n  }\n```", "```cpp\ncmake_minimum_required(VERSION 3.5.1)\nproject(cache_align)\nadd_executable(cache_align cache_align.cpp)\n\nset(CMAKE_SYSTEM_NAME Linux)\nset(CMAKE_SYSTEM_PROCESSOR arm)\n\nSET(CMAKE_CXX_FLAGS \"-std=c++11\")\nset(CMAKE_CXX_COMPILER /usr/bin/arm-linux-gnueabi-g++)\n```", "```cpp\n  char static_buffer[kAllocBytes];\n```", "```cpp\n  char* dynamic_buffer = new char[kAllocBytes];\n```", "```cpp\n alignas(kAlignSize) char aligned_static_buffer[kAllocBytes];\n```", "```cpp\n  if (posix_memalign((void**)&aligned_dynamic_buffer,\n kAlignSize, kAllocBytes)) {\n```", "```cpp\n  size_t addr = (size_t)ptr;\n  return addr & (kAlignSize - 1);\n```"]