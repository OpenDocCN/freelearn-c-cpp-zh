- en: STL Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL容器
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Using the erase-remove idiom on `std::vector`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`std::vector`上使用擦除-删除习惯用法
- en: Deleting items from an unsorted `std::vector` in *O(1)* time
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*O(1)*时间内从未排序的`std::vector`中删除项目
- en: Accessing `std::vector` instances the fast or the safe way
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以快速或安全的方式访问`std::vector`实例
- en: Keeping `std::vector` instances sorted
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持`std::vector`实例排序
- en: Inserting items efficiently and conditionally into `std::map`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地和有条件地将项目插入`std::map`
- en: Knowing the new insertion hint semantics of `std::map::insert`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解`std::map::insert`的新插入提示语义
- en: Efficiently modifying the keys of `std::map` items
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地修改`std::map`项的键
- en: Using `std::unordered_map` with custom types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::unordered_map`与自定义类型
- en: Filtering duplicates from user input and printing them in alphabetical order
    with `std::set`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::set`从用户输入中过滤重复项并按字母顺序打印它们
- en: Implementing a simple RPN calculator with `std::stack`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::stack`实现简单的逆波兰计算器
- en: Implementing a word frequency counter with `std::map`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::map`实现词频计数器
- en: Implementing a writing style helper tool for finding very long sentences in
    texts with `std::set`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::set`实现用于在文本中查找非常长的句子的写作风格辅助工具
- en: Implementing a personal to-do list using `std::priority_queue`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::priority_queue`实现个人待办事项列表
- en: Using the erase-remove idiom on std::vector
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在`std::vector`上使用擦除-删除习惯用法
- en: A lot of novice C++ programmers learn about `std::vector`, that it basically
    works like an *automatically growing array*, and stop right there. Later, they
    only lookup its documentation in order to see how to do very specific things,
    for example, *removing* items. Using STL containers like this will only scratch
    the surface of how much they help writing *clean*, *maintainable,* and *fast*
    code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 许多初学者C++程序员了解`std::vector`，它基本上就像一个*自动增长的数组*，然后就停在那里。后来，他们只查找它的文档，以了解如何做非常具体的事情，例如*删除*项目。像这样使用STL容器只会触及它们帮助编写*清晰*、*可维护*和*快速*代码的表面。
- en: This section is all about removing items from in-between a vector instance. When
    an item disappears from a vector, and sits somewhere in the middle *between* other
    items, then all items right from it must *move* one slot to the *left* (which
    gives this task a runtime cost within *O(n)*). Many novice programmers will do
    that using a *loop*, since it is also not really a hard thing to do. Unfortunately,
    they will potentially ignore a lot of optimization potential while doing that.
    And in the end, a hand crafted loop is neither *faster*, nor *prettier* to read
    than the STL way, which we will see next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点是从向量实例中间删除项目。当一个项目从向量中消失，并且坐在其他项目的中间*之间*时，那么右边的所有项目都必须向*左*移动一个插槽（这使得这个任务的运行成本在*O(n)*内）。许多初学者程序员会使用*循环*来做到这一点，因为这也不是一件很难做的事情。不幸的是，他们在这样做的过程中可能会忽略很多优化潜力。最后，手工制作的循环既不如STL方式*快*，也不如*美观*，我们将在下面看到。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we are filling an `std::vector` instance with some example
    integers, and then prune some specific items away from it. The way we are doing
    it is considered the *correct* way of removing multiple items from a vector.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们正在用一些示例整数填充`std::vector`实例，然后从中删除一些特定的项目。我们正在做的方式被认为是从向量中删除多个项目的*正确*方式。
- en: Of course we need to include some headers before we do anything.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，在我们做任何事情之前，我们需要包括一些头文件。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then we declare that we are using namespace `std` to spare us some typing.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们声明我们正在使用`std`命名空间，以节省一些输入。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we create us a vector of integers and fill it with some example items.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个整数向量，并用一些示例项目填充它。
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The next step is to remove the items. What do we remove? There are multiple
    `2` values. Let's remove them.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是删除项目。我们要删除什么？有多个`2`值。让我们把它们删除。
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Interestingly, that was only one of the two steps. The vector still has the
    same size. The next line makes it actually shorter.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有趣的是，这只是两步中的一步。向量仍然具有相同的大小。下一行使它实际上更短。
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's stop by here in order to print the vector's content to the terminal, and
    then continue.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在这里停下来，以便将向量的内容打印到终端，然后继续。
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, let's remove a whole *class* of items, instead of specific *values*. In
    order to do that, we define a predicate function first, which accepts a number
    as parameter, and returns `true`, if it is an *odd* number.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们删除整个*类*的项目，而不是特定的*值*。为了做到这一点，我们首先定义一个谓词函数，它接受一个数字作为参数，并在它是*奇数*时返回`true`。
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we use the `remove_if` function and feed it with the predicate function.
    Instead of removing in two steps as we did before, we do it in one.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用`remove_if`函数，并将其与谓词函数一起使用。与之前的两步删除不同，我们现在只需一步。
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All odd items are gone now, but the vector's *capacity* is still at the old
    10 elements. In a last step, we reduce that also to the actual *current* size
    of the vector. Note that this might lead the vector code to allocate a new chunk
    of memory that fits and moves all items from the old chunk to the new one.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所有奇数项都消失了，但向量的*容量*仍然是旧的10个元素。在最后一步中，我们还将其减少到向量的实际*当前*大小。请注意，这可能导致向量代码分配一个适合的新内存块，并将所有项目从旧内存块移动到新内存块。
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, let's print the content after the second run of removing items and that's
    it.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在第二次删除项目后打印内容，就这样。
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Compiling and running the program yields the following two output lines from
    the two item removing approaches.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生了两种删除项目方法的以下两行输出。
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: What became obvious in the recipe is that when removing items from the middle
    of a vector, they first need to be *removed* and then *erased*. At least the functions
    we used have names like this. This is admittedly confusing, but let's have a closer
    look at it to make sense of these steps.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方中显而易见的是，当从向量中间删除项目时，它们首先需要被*删除*，然后*擦除*。至少我们使用的函数有这样的名称。这显然令人困惑，但让我们仔细看看它，以理解这些步骤。
- en: 'The code which removes all values of `2` from the vector, looked like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从向量中删除所有值为`2`的代码如下：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `std::begin` and `std::end` functions both accept a vector instance as parameter,
    and return us iterators, which point to the *first* item, and *past the last*
    item, just as sketched in the upcoming diagram.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::begin`和`std::end`函数都接受一个向量实例作为参数，并返回指向*第一个*项目和*最后一个*项目之后的迭代器，就像即将出现的图表中所示的那样。'
- en: After feeding these and the value `2` to the `std::remove` function, it will
    move the non-`2` values forward, just like we could do that with a manually programmed
    loop. The algorithm will strictly preserve the order of all non-`2` values while
    doing that. A quick look at the illustration might be a bit confusing. In step
    2, there still is a value of `2`, and the vector should have become shorter, as
    there were four values of `2`, which all ought to be removed. Instead, the `4`
    and the `8` which were in the initial array, are duplicated. What's that?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在将这些值和值`2`传递给`std::remove`函数后，它将将非`2`值向前移动，就像我们可以使用手动编程的循环来做的那样。该算法将严格保留所有非`2`值的顺序。快速查看插图可能有点令人困惑。在第2步中，仍然有一个值为`2`，而且向量应该变得更短，因为有四个值为`2`，它们都应该被移除。相反，初始数组中的`4`和`8`被复制了。这是怎么回事？
- en: '![](img/31fad71f-4671-4aae-8626-ff3f3785f7d1.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31fad71f-4671-4aae-8626-ff3f3785f7d1.png)'
- en: Let's only take a look at all the items, which are within the range and which
    spans from the `begin` iterator on the illustration, to the `new_end` iterator.
    The item, to which the `new_end` iterator points, is the *first item past* the
    range, so it's not included. Just concentrating on that region (these are only
    the items from `1` to including `8`), we realize that *this* is the *correct*
    range from which all values of `2` are removed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们只看看所有在范围内的项目，从插图上的`begin`迭代器到`new_end`迭代器。`new_end`迭代器指向的项目是范围之外的*第一个项目，因此不包括在内。只集中在这个区域（这些只是从`1`到包括`8`的项目），我们意识到*这*是从中删除所有`2`值的*正确*范围。
- en: 'This is where the `erase` call comes into play: We must tell the vector that
    it shall not consider all items from `new_end` to `end` to be items of the vector
    any longer. This order is easy to follow for the vector, as it can just point
    its `end` iterator to the position of `new_end` and it''s done. Note that `new_end`
    was the return value of the `std::remove` call, so we can just use that.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`erase`调用发挥作用的地方：我们必须告诉向量，它不再应该认为从`new_end`到`end`的所有项目是向量的项目。这个顺序对于向量来说很容易遵循，因为它只需将其`end`迭代器指向`new_end`的位置，就完成了。请注意，`new_end`是`std::remove`调用的返回值，所以我们可以直接使用它。
- en: Note that the vector did more magic than just moving an internal pointer. If
    that vector was a vector of more complicated objects, it would have called all
    the destructors of the to-be-removed items.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，向量所做的不仅仅是移动内部指针。如果该向量是更复杂对象的向量，它将调用所有要删除的项目的析构函数。
- en: 'Afterward, the vector looks like in step 3 of the diagram: it''s considered
    *smaller* now. The old items which are now out of the range, are *still in memory*.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，向量看起来像图表中的第3步：它现在被认为是*更小*的。现在超出范围的旧项目仍然在内存中。
- en: In order to make the vector occupy only as much memory as it needs, we make
    the `shrink_to_fit` call in the end. During that call, it allocates exactly as
    much memory as needed, moves over all the items and deletes the larger chunk we
    don't need any longer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使向量只占用所需的内存，我们在最后进行`shrink_to_fit`调用。在该调用期间，它将分配所需的内存，移动所有项目并删除我们不再需要的较大块。
- en: In step 8, we define a *predicate* function and use it with `std::remove_if`
    in only one step. This works, because whatever iterator the remove function returns,
    it is safe to be used in the vector's erase function. Even if *no odd item* was
    found, the `std::remove_if` function will do just *nothing*, and return the `end`
    iterator. Then, a call like `v.erase(end, end);` also does nothing, hence it is
    harmless.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8步中，我们定义了一个*谓词*函数，并在一步中使用它与`std::remove_if`一起使用。这是有效的，因为无论删除函数返回什么迭代器，都可以安全地在向量的erase函数中使用。即使*没有找到奇数项*，`std::remove_if`函数也将*什么也不做*，并返回`end`迭代器。然后，像`v.erase(end,
    end);`这样的调用也不会做任何事情，因此它是无害的。
- en: There's more...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `std::remove` function also works on other containers. When used with `std::array`,
     note that it does not support the second step of calling `erase`, because they
    do not have automatic size handling. Just because `std::remove` effectively only
    moves items around and does not perform their actual deletion, it can also be
    used on data structures such as arrays that do not support resizing. In the array
    case, one could overwrite the values past the new end iterator with sentinel values
    such as `''` for strings, for example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::remove`函数也适用于其他容器。当与`std::array`一起使用时，请注意它不支持调用`erase`的第二步，因为它们没有自动大小处理。仅仅因为`std::remove`有效地只是移动项目而不执行它们的实际删除，它也可以用于不支持调整大小的数据结构，例如数组。在数组的情况下，可以使用类似于字符串的哨兵值（例如`''''`）覆盖新的结束迭代器之后的值。'
- en: Deleting items from an unsorted std::vector in O(1) time
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在O(1)时间内从未排序的std::vector中删除项目
- en: Deleting items from somewhere in the middle of an `std::vector` takes *O(n)*
    time. This is because the resulting gap from removing an item must be filled by
    moving all the items which come after the gap one slot to the left.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从`std::vector`中间某处删除项目需要*O(n)*时间。这是因为删除项目后产生的间隙必须由将在间隙后面的所有项目向左移动一个插槽来填充。
- en: While moving items around like this, which might be expensive if they are complex
    and/or very large and include many items, we preserve their order. If preserving
    the order is not important, we can optimize this, as this section shows.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在像这样移动项目的过程中，如果它们是复杂的和/或非常大的，并包括许多项目，这可能是昂贵的，我们保留它们的顺序。如果保留顺序不重要，我们可以优化这一点，正如本节所示。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will fill an `std::vector` instance with some example numbers,
    and implement a quick remove function, which removes any item from a vector in
    *O(1)* time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一些示例数字填充一个`std::vector`实例，并实现一个快速删除函数，它可以在*O(1)*时间内从向量中删除任何项目。
- en: First, we need to include the required header files.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要包含所需的头文件。
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Then, we define a main function where we instantiate a vector with example numbers.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义一个主函数，在其中实例化一个包含示例数字的向量。
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The next step is to delete the value at index `2` (counting from zero of course,
    so it's the third number `789`). The function we will use for that task is not
    implemented yet. We do that some steps later. Afterward, we print the vector's
    content.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是删除索引为`2`的值（当然是从零开始计数，所以是第三个数字`789`）。我们将使用的函数还没有实现。我们稍后再做。之后，我们打印向量的内容。
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, we will delete another item. It will be the value `123`, and let's say
    we don't know its index. Therefore, we will use the `std::find` function, which
    accepts a range (the vector), and a value, and then searches for the value's position.
    Afterward, it returns us an *iterator* pointing to the `123` value. We will use the
    same `quick_remove_at` function, but this is an *overloaded* version of the *previous*
    one which accepts *iterators*. It is also not implemented, yet.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将删除另一个项目。它将是值为`123`，假设我们不知道它的索引。因此，我们将使用`std::find`函数，它接受一个范围（向量）和一个值，然后搜索该值的位置。然后，它会返回一个指向`123`值的*迭代器*。我们将使用相同的`quick_remove_at`函数，但这是*先前*接受*迭代器*的*重载*版本。它也还没有实现。
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Apart from the two `quick_remove_at` functions, we are done. So let's implement
    these. (Note that they should be at least declared before the main function. So
    let's just define them there.)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了两个`quick_remove_at`函数，我们已经完成了。所以让我们来实现这些。（请注意，它们应该至少在主函数之前被声明。所以让我们在那里定义它们。）
- en: 'Both the functions accept a reference to a vector of *something* (in our case,
    its `int` values), so we leave that open what kind of vector the user will come
    up with. For us, it''s a vector of `T` values. The first `quick_remove_at` function
    we used accepts *index* values, which are *numbers*, so the interface looks like
    the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都接受一个*something*（在我们的例子中是`int`值）的向量的引用，所以我们不确定用户会使用什么样的向量。对我们来说，它是一个`T`值的向量。我们使用的第一个`quick_remove_at`函数接受*索引*值，这些值是*数字*，所以接口看起来像下面这样：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now comes the meat of the recipe--how do we remove the item quickly without
    moving too many others? First, we simply take the value of the last item in the
    vector and use it to overwrite the item which shall be deleted. Second, we cut
    off the last item of the vector. These are the two steps. We surround this code
    with a little sanity check. If the index value is obviously out of the vector
    range, we do nothing. Otherwise, the code would, for example, crash on an empty
    vector.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在来到食谱的核心部分——我们如何快速删除项目而不移动太多其他项目？首先，我们简单地取出向量中最后一个项目的值，并用它来覆盖将要删除的项目。其次，我们切断向量的最后一个项目。这就是两个步骤。我们在这段代码周围加上了一些健全性检查。如果索引值显然超出了向量范围，我们就什么也不做。否则，例如在空向量上，代码会崩溃。
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The other implementation of `quick_remove_at` works similar. Instead of accepting
    a numeric index, it accepts an iterator for `std::vector<T>`. Obtaining its type
    in a generic manner is not complicated because STL containers already define such
    types.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`quick_remove_at`的另一个实现方式类似。它不是接受一个数字索引，而是接受`std::vector<T>`的迭代器。以通用方式获取其类型并不复杂，因为STL容器已经定义了这样的类型。'
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we will access the value, at which the iterator is pointing. Just as in
    the other function, we will overwrite it by the last element in the vector. Because
    we are handling not a numeric index, but an iterator this time, we need to check
    a bit differently if the iterator position is sane. If it points to the artificial
    end position, we are not allowed to dereference it.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将访问迭代器指向的值。就像在另一个函数中一样，我们将用向量中的最后一个元素来覆盖它。因为这次我们处理的不是数字索引，而是迭代器，所以我们需要以稍有不同的方式检查迭代器的位置是否合理。如果它指向人为结束的位置，我们就不能对其进行解引用。
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Within that if block, we do the same thing as before--we overwrite the item
    to be removed with the value of the item from the last position--then we cut off
    the last element from the vector:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个if块中，我们做的事情和之前一样——我们用最后一个位置的项目的值来覆盖要删除的项目，然后我们从向量中切断最后一个元素：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'That''s it. Compiling and running the program leads to the following output:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样。编译和运行程序会产生以下输出：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `quick_remove_at` function removes items pretty quickly without touching
    too many other items. It does this in a relatively creative way: It kind of *swaps*
    the *actual item, * which shall be removed with the *last* item in the vector.
    Although the last item has *no connection* to the actually selected item, it is
    in a *special position*: Removing the last item is *cheap*! The vector''s size
    just needs to be shrunk down by one slot, and that''s it. No items are moved during
    that step. Have a look at the following diagram which helps imaging how this happens:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`quick_remove_at`函数可以快速删除项目，而不会触及太多其他项目。它以相对创造性的方式做到这一点：它在某种程度上*交换*了*实际项目*，即将被删除的项目和向量中的*最后一个*项目。尽管最后一个项目与实际选择的项目*没有关联*，但它处于*特殊位置*：删除最后一个项目是*便宜的*！向量的大小只需要减少一个位置，就完成了。在这一步中没有移动任何项目。看一下下面的图表，它有助于想象这是如何发生的：'
- en: '![](img/91627e22-fdaf-41d9-a683-6c96f788f8b8.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91627e22-fdaf-41d9-a683-6c96f788f8b8.png)'
- en: 'Both the steps in the recipe code look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱代码中的两个步骤看起来像这样：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is the iterator version, which looks nearly identical:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是迭代器版本，看起来几乎一样：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Logically, we *swap* the selected item and the last one. But the code does not
    swap items, it *moves* the last one over the first one. Why? If we swapped the
    items, then we would have to store the selected item in a *temporary* variable,
    move the last item to the selected item, and then store the temporary value in
    the last slot again. This seems *useless*, as we are just about to *delete* the
    last item anyway.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑上，我们*交换*所选项目和最后一个项目。但代码并不交换项目，而是将最后一个项目移动到第一个项目上。为什么？如果我们交换项目，那么我们将不得不将所选项目存储在一个*临时*变量中，将最后一个项目移动到所选项目上，然后再将临时值存储在最后一个位置上。这似乎是*无用*的，因为我们正要*删除*最后一个项目。
- en: Ok, fine, so the swap is useless, and a one-way overwrite is a better thing
    to do. Having seen that, we can argue that this step could also be performed with
    a simple `*it = v.back();`, right? Yes, this would be completely *correct*, but
    imagine we stored some very large strings in every slot, or even another vector
    or map--in that situation, that little assignment would lead to a very expensive
    copy. The `std::move` call in between is just an *optimization:* In the example
    case of *strings*, the string item internally points to a large string in the
    *heap*. We do not need to copy that. Instead, when *moving* a string, the destination
    of the move gets to *point at the string data of the other*. The move source item
    is left intact, but in a useless state, which is fine because we are removing
    it anyway.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，交换是没有用的，一次性覆盖是更好的选择。看到这一点，我们可以说这一步也可以用简单的`*it = v.back();`来完成，对吗？是的，这完全是*正确*的，但是想象一下，我们在每个槽中存储了一些非常大的字符串，甚至是另一个向量或映射--在这种情况下，这个小赋值将导致非常昂贵的复制。中间的`std::move`调用只是一个*优化:*在*字符串*的示例情况下，字符串项内部指向*堆*中的一个大字符串。我们不需要复制它。相反，当*移动*一个字符串时，移动的目标指向另一个字符串的数据。移动源项目保持不变，但处于无用状态，这没关系，因为我们无论如何都要删除它。
- en: Accessing std::vector instances the fast or the safe way
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以快速或安全的方式访问std::vector实例
- en: The `std::vector` is probably the most widely used container in the STL, because
    it holds data just like an array, and adds a lot of comfort around that representation.
    However, wrong access to a vector can still be dangerous. If a vector contains
    100 elements, and by accident our code tries to access an element at index 123,
    this is obviously bad. Such a program could just crash, which might be the best
    case, because that behavior would make it very obvious that there is a bug! If
    it does not crash, we might observe that the program just behaves *strangely* from
    time to time, which could lead to even more headaches than a crashing program.
    The experienced programmer might add some checks before any directly indexed vector
    access. Such checks do not increase the readability of the code, and many people
    do not know that `std::vector` already has built-in bound checks!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector` 可能是STL中使用最广泛的容器，因为它像数组一样保存数据，并在该表示周围添加了很多便利。然而，对向量的错误访问仍然可能是危险的。如果一个向量包含100个元素，并且我们的代码意外地尝试访问索引123处的元素，这显然是不好的。这样的程序可能会崩溃，这可能是最好的情况，因为这种行为会非常明显地表明存在错误！如果它没有崩溃，我们可能会观察到程序偶尔表现得*奇怪*，这可能会比崩溃的程序带来更多的头痛。有经验的程序员可能会在任何直接索引的向量访问之前添加一些检查。这些检查不会增加代码的可读性，而且很多人不知道`std::vector`已经内置了边界检查！'
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will use the two different ways to access an `std::vector`,
    and then see how we can utilize them to write safer programs without decreasing
    readability.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用两种不同的方式来访问`std::vector`，然后看看如何利用它们来编写更安全的程序而不降低可读性。
- en: 'Let''s include all the needed header files, and fill an example vector with
    `1000` times the value `123`, so we have something we can access:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们包括所有需要的头文件，并用`123`的值填充一个示例向量`1000`次，这样我们就有了可以访问的东西：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we access the vector out of bounds using the `[]` operator:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`[]`运算符越界访问向量：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we access it out of bounds using the `at` function:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`at`函数越界访问它：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's run the program and see what happens. The error message is GCC specific.
    Other compilers would emit different but similar error messages. The first read
    succeeds in a strange way. It doesn't lead the program to crash, but it's a completely
    different *value* than `123`. We can't see the output line of the other access
    because it purposefully crashed the whole program. If that out of bounds access
    was an accident, we would catch it much earlier!
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行程序看看会发生什么。错误消息是特定于GCC的。其他编译器会发出不同但类似的错误消息。第一次读取以一种奇怪的方式成功了。它没有导致程序崩溃，但它是一个完全不同的*值*，而不是`123`。我们看不到其他访问的输出行，因为它故意崩溃了整个程序。如果那个越界访问是一个意外，我们会更早地捕捉到它！
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::vector` provides the `[]` operator and the `at` function, and they
    basically do exactly the same job. The `at` function, however, performs additional
    bounds checks and throws an *exception* if the vector bounds are exceeded. This
    is super useful in situations like ours, but also makes the program a little bit
    *slower*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::vector`提供了`[]`运算符和`at`函数，它们基本上做的工作是一样的。然而，`at`函数执行额外的边界检查，并且如果超出向量边界，则抛出*异常*。这在我们这种情况下非常有用，但也会使程序变得稍微*慢*一些。'
- en: Especially when doing numeric computations with indexed members which need to
    be really fast, it is advantageous to stick to `[]` indexed access. In any other
    situation, the `at` function helps uncovering bugs with usually negligible performance
    loss.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是在进行需要非常快速的索引成员的数值计算时，最好坚持使用`[]`索引访问。在任何其他情况下，`at`函数有助于发现通常可以忽略的性能损失的错误。
- en: It is good practice to use the `at` function by default. If the resulting code
    is too slow but has proven to be bug-free, the `[]` operator can be used in performance-sensitive
    sections instead.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下使用`at`函数是一个好习惯。如果生成的代码太慢但已经被证明没有错误，那么在性能敏感的部分可以使用`[]`运算符。
- en: There's more...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Of course, we can *handle* out of bounds accesses, instead of letting the whole
    app *crash*. In order to handle it, we *catch* the exception, in case it was thrown
    by the `at` function. Catching such an exception is simple. We just surround the
    `at` call with a `try` block and define the error handling in a `catch` block.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以*处理*越界访问，而不是让整个应用程序*崩溃*。为了处理它，我们*捕获*异常，以防它被`at`函数抛出。捕获这样的异常很简单。我们只需用`try`块包围`at`调用，并在`catch`块中定义错误处理。
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By the way, `std::array` also provides an `at` function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，`std::array`也提供了`at`函数。
- en: Keeping std::vector instances sorted
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持std::vector实例排序
- en: Arrays and vectors do not sort their payload objects themselves. But if we need
    that, this does not mean that we always have to switch to data structures, which
    were designed to do that automatically. If an `std::vector` is perfect for our
    use case, it is still very simple and practical to add items to it in a *sorting
    manner*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和向量本身不会对它们的有效负载对象进行排序。但是如果我们需要这样做，并不意味着我们总是必须切换到自动执行排序的数据结构。如果`std::vector`非常适合我们的用例，那么以*排序方式*向其中添加项目仍然非常简单和实用。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: In this section, we will fill an `std::vector` with random words, sort it, and
    then insert more words while keeping the vector's sorted word order intact.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将用随机单词填充一个`std::vector`，对其进行排序，然后在保持向量排序单词顺序不变的同时插入更多单词。
- en: Let's first include all headers we're going to need.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先包含我们将需要的所有头文件。
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We also declare that we are using namespace `std` in order to spare us some
    `std::` prefixes:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还声明我们正在使用`std`命名空间，以避免一些`std::`前缀：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then we write a little main function, which fills a vector with some random
    strings.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们编写一个小的主函数，用一些随机字符串填充一个向量。
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The next thing we do is *sorting* that vector. Let's do that with some assertions
    and the `is_sorted` function from the STL before, which shows that the vector
    really was *not* sorted before, but *is* sorted afterward.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们要做的是对该向量进行*排序*。在此之前，让我们使用STL的`is_sorted`函数和一些断言来检查向量在之前确实*没有*排序，但之后*已经*排序。
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we finally add some random words into the sorted vector using a new `insert_sorted`
    function, which we still need to implement afterward. These words shall be put
    at the right spot so that the vector is still sorted afterward:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们最终使用一个新的`insert_sorted`函数将一些随机单词添加到排序后的向量中，之后我们仍然需要实现这个函数。这些单词应该放在正确的位置，以便向量在之后仍然是排序的：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: So, let's now implement `insert_sorted` a little earlier in the source file.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们现在在源文件中稍早实现`insert_sorted`。
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, back in the main function where we stopped, we can now continue printing
    the vector and see that the insert procedure works:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在回到我们停下的主函数中，我们现在可以继续打印向量，并看到插入过程的工作情况：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Compiling and running the program yields the following nicely sorted output:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会产生以下很好排序的输出：
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The whole program is constructed around the `insert_sorted` function, which
    does what this section is about: For any new string, it locates the position in
    the sorted vector, at which it must be inserted, in order to *preserve* the order
    of the strings in the vector. However, we assume that the vector was sorted before.
    Otherwise, this would not work.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 整个程序围绕`insert_sorted`函数构建，该函数执行本节所述的操作：对于任何新字符串，它定位排序向量中的位置，必须将其插入以*保持*向量中字符串的顺序。但是，我们假设向量在之前已经排序。否则，这将无法工作。
- en: The locating step is done by the STL function `lower_bound`, which accepts three arguments.
    The first two denote *beginning* and *end* of the underlying range. The range
    is our vector of words in this case. The third argument is the word, which shall
    be inserted. The function then finds the first item in the range, which is *greater
    than or equal* to that third parameter and returns an iterator pointing to it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 定位步骤由STL函数`lower_bound`完成，该函数接受三个参数。前两个参数表示底层范围的*开始*和*结束*。在这种情况下，范围是我们的单词向量。第三个参数是要插入的单词。然后函数找到范围中第一个*大于或等于*第三个参数的项目，并返回指向它的迭代器。
- en: Having the right position at hand, we gave it to the `std::vector` member method
    `insert`, which accepts just two arguments. The first argument is an iterator,
    which points to the position in the vector, at which the second parameter shall
    be inserted. It appears very handy that we can use the same iterator, which just
    dropped out of the `lower_bound` function. The second argument is, of course,
    the item to be inserted.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有了正确的位置，我们将其提供给`std::vector`成员方法`insert`，该方法只接受两个参数。第一个参数是一个迭代器，指向向量中应插入第二个参数的位置。我们可以使用刚刚从`lower_bound`函数中获得的相同迭代器，这似乎非常方便。第二个参数当然是要插入的项目。
- en: There's more...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `insert_sorted` function is pretty generic. If we generalize the types of
    its parameters, it will also work on other container payload types, and even on
    other containers such as `std::set`, `std::deque`, `std::list`, and so on! (Note
    that set has its own `lower_bound` member function that does the same as `std::lower_bound`,
    but is more efficient because it is specialized for sets.)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert_sorted`函数非常通用。如果我们泛化其参数的类型，它也将适用于其他容器有效负载类型，甚至适用于其他容器，例如`std::set`、`std::deque`、`std::list`等等！（请注意，set有自己的`lower_bound`成员函数，执行与`std::lower_bound`相同的操作，但效率更高，因为它专门为集合进行了优化。）'
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When trying to switch the type of the vector in the recipe from `std::vector`
    to something else, note that not all containers support `std::sort`. That algorithm
    requires random access containers, which `std::list`, for example, does not fulfill.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试从`std::vector`切换到其他类型的容器时，请注意并非所有容器都支持`std::sort`。该算法需要随机访问容器，例如`std::list`就不满足这个要求。
- en: Inserting items efficiently and conditionally into std::map
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效地和有条件地向std::map中插入项目
- en: 'Sometimes we want to fill a map with key-value pairs and while filling the
    map up, we might run into two different cases:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想要用键值对填充一个映射，并且在填充映射的过程中，可能会遇到两种不同的情况：
- en: The key does not exist yet. Create a *fresh* key-value pair.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关键尚不存在。创建一个*全新*的键值对。
- en: The key does exist already. Take the *existing* item and *modify* it.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关键已经存在。获取*现有*项目并*修改*它。
- en: We could just naively use the `insert` or `emplace` methods of `map` and see
    if they succeed. If it doesn't, we have case 2 and modify the existing item. In
    both cases, insert and emplace create the item which we try to insert, and in
    case 2 the freshly created item is dropped. We get a useless constructor call
    in both cases.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地使用`map`的`insert`或`emplace`方法，并查看它们是否成功。如果不成功，我们就会遇到第二种情况，并修改现有的项目。在这两种情况下，insert和emplace都会创建我们尝试插入的项目，而在第二种情况下，新创建的项目会被丢弃。在这两种情况下，我们都会得到一个无用的构造函数调用。
- en: Since C++17, there is the `try_emplace` function, which enables us to create
    items only conditionally upon insertion. Let's implement a program that takes
    a list of billionaires and constructs a map that tells us the number of billionaires
    per country. In addition to that, it stores the wealthiest person in every country.
    Our example will not contain expensive to create items, but whenever we find ourselves
    in such a situation in real-life projects, we know how to master it with `try_emplace`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++17以来，有`try_emplace`函数，它使我们能够仅在插入时有条件地创建项目。让我们实现一个程序，该程序获取亿万富翁名单并构造一个告诉我们每个国家的亿万富翁数量的映射。除此之外，它还存储每个国家最富有的人。我们的示例不包含昂贵的创建项目，但是每当我们在现实项目中遇到这种情况时，我们都知道如何使用`try_emplace`来掌握它。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will implement an application that creates a map from a
    list of billionaires. The map maps from each country to a reference to the wealthiest
    person in that country and a counter that tells how many billionaires that country
    has.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个应用程序，该应用程序从亿万富翁名单中创建一个映射。该映射将每个国家映射到该国最富有的人的引用以及告诉该国有多少亿万富翁的计数器。
- en: As always, we need to include some headers first and we declare that we use
    namespace `std` by default.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们首先需要包含一些头文件，并声明我们默认使用`std`命名空间。
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let's define a structure that represents billionaire items for our list.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个代表我们名单上亿万富翁物品的结构。
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the main function, we first define the list of billionaires. There are *many*
    billionaires in the world, so let's construct a limited list with just some of
    the richest persons in some countries. This list is already ordered. The rankings
    are actually taken from the Forbes 2017 list *The World's Billionaires* at [https://www.forbes.com/billionaires/list/:](https://www.forbes.com/billionaires/list/)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们首先定义亿万富翁名单。世界上有*很多*亿万富翁，所以让我们构建一个有限的名单，其中只包含一些国家中最富有的人。这个名单已经排序。排名实际上来自《福布斯》2017年《世界亿万富翁》名单[https://www.forbes.com/billionaires/list/:](https://www.forbes.com/billionaires/list/)
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, let's define the map. It maps from the country string to a pair. The pair
    contains a (`const`) copy of the first billionaire of every country from our list.
    That is automatically the richest billionaire per country. The other variable
    in the pair is a counter, which we will increment for every following billionaire
    in that country.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义映射。它将国家字符串映射到一对。该对包含我们名单中每个国家的第一个亿万富翁的（`const`）副本。这自动是每个国家最富有的亿万富翁。对中的另一个变量是一个计数器，我们将为该国家的每个后续亿万富翁递增。
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, let's go through the list and try to emplace a new payload pair for every
    country. The pair contains a reference to the billionaire we are currently looking
    at and a counter value of `1`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们遍历列表，并尝试为每个国家插入一个新的有效负载对。该对包含我们当前正在查看的亿万富翁的引用和计数器值`1`。
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If that step was successful, then we don't need to do anything else. The pair
    for which we provided the constructor arguments `b, 1` has been constructed and
    inserted into the map. If the insertion was *not* successful because the country
    key exists already, then the pair was not constructed. If our billionaire structure
    was very large, this would have saved us the runtime cost of copying it.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该步骤成功，那么我们就不需要做其他任何事情了。我们提供了构造函数参数`b, 1`的对已经被构造并插入到映射中。如果插入*不*成功，因为国家键已经存在，那么这对就不会被构造。如果我们的亿万富翁结构非常庞大，这将为我们节省复制它的运行时成本。
- en: However, in the nonsuccessful case, we still need to increment the counter for
    this country.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在不成功的情况下，我们仍然需要递增该国家的计数器。
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Ok, that's it. We can now print how many billionaires there are per country,
    and who is the wealthiest one in each country.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，就是这样。我们现在可以打印每个国家有多少亿万富翁，以及每个国家最富有的人是谁。
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Compiling and running the program yields the following output. (Of course, the
    output is limited, because we limited our input map.)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生以下输出。（当然，输出是有限的，因为我们限制了输入映射。）
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The whole recipe revolves around the `try_emplace` function of `std::map`,
    which is a new C++17 addition. It has the following signature:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 整个配方围绕着`std::map`的`try_emplace`函数展开，这是C++17的新功能。它具有以下签名：
- en: '[PRE46]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Thus, the key being inserted is parameter `k` and the associated value is constructed
    from the parameter pack `args`. If we succeed in inserting the item, then the
    function returns an *iterator*, which points to the new node in the map, *paired*
    with a Boolean value being set to `true`. If the insertion was *not* successful,
    the Boolean value in the return pair is set to `false`, and the iterator points
    to the item with which the new item would clash.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，被插入的键是参数`k`，关联的值是从参数包`args`构造的。如果我们成功插入该项，那么函数将返回一个*迭代器*，该迭代器指向映射中的新节点，并与设置为`true`的布尔值*配对*。如果插入*不*成功，则返回对中的布尔值设置为`false`，并且迭代器指向新项将与之冲突的项。
- en: 'This characteristic is very useful in our case--when we see a billionaire from
    a specific country for the first time, then this country is not a key in the map
    yet. In that case, we must *insert* it, accompanied with a new counter being set
    to `1`. If we *did* see a billionaire from a specific country already, we have
    to get a reference to its existing counter, in order to increment it. This is
    exactly what happened in step 6:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特征在我们的情况下非常有用--当我们第一次看到来自特定国家的亿万富翁时，那么这个国家在映射中还不是一个键。在这种情况下，我们必须*插入*它，并附带将新计数器设置为`1`。如果我们已经看到来自特定国家的亿万富翁，我们必须获取对其现有计数器的引用，以便对其进行递增。这正是第6步发生的事情：
- en: '[PRE47]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that both the `insert` and `emplace` functions of `std::map` work exactly
    the same way. A crucial difference is that `try_emplace` will *not* construct
    the object associated with the key if the key already exists. This boosts the
    performance in case objects of that type are expensive to create.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`std::map`的`insert`和`emplace`函数的工作方式完全相同。一个关键的区别是，如果键已经存在，`try_emplace`将*不*构造与键关联的对象。这在类型的对象昂贵创建时提高了性能。
- en: There's more...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The whole program still works if we switch the type of the map from `std::map`
    to `std::unordered_map`. This way, we can simply switch from one implementation
    to another, which has different performance characteristics. In this recipe, the
    only observable difference is that the billionaire map is not printed in alphabetical
    order any longer, because hash maps do not order their objects the same way as
    search trees do.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将地图的类型从`std::map`切换到`std::unordered_map`，整个程序仍然可以工作。这样，我们可以从一种实现简单地切换到另一种实现，它们具有不同的性能特征。在这个示例中，唯一可观察到的区别是，亿万富翁地图不再按字母顺序打印，因为哈希映射不像搜索树那样对对象进行排序。
- en: Knowing the new insertion hint semantics of std::map::insert
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解std::map::insert的新插入提示语义。
- en: Looking up items in an `std::map` takes *O(log(n))* time. This is the same for
    inserting new items, because the position where to insert them must be looked
    up. Naive insertion of *M* new items would thus take *O(M * log(n))* time.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`std::map`中查找项目需要*O(log(n))*时间。对于插入新项目也是一样，因为必须查找插入它们的位置。因此，天真地插入*M*个新项目将需要*O(M
    * log(n))*的时间。
- en: In order to make this more efficient, `std::map` insertion functions accept
    an optional *insertion hint* parameter. The insertion hint is basically an iterator,
    which points near the future position of the item that is to be inserted. If the
    hint is correct, then we get *amortized* *O(1)* insertion time.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这更有效，`std::map`插入函数接受一个可选的*插入提示*参数。插入提示基本上是一个迭代器，它指向即将插入的项目的未来位置附近。如果提示是正确的，那么我们就会得到*摊销*的*O(1)*插入时间。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will insert multiple items into an `std::map`, and use insertion
    hints for that, in order to reduce the number of lookups.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向`std::map`中插入多个项目，并为此使用插入提示，以减少查找次数。
- en: We are mapping strings to numbers, so we need the header files included for
    `std::map` and `std::string`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将字符串映射到数字，因此需要包含`std::map`和`std::string`的头文件。
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The next step is to instantiate a map, which already contains some example characters.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是实例化一个地图，其中已经包含了一些示例字符。
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We will insert multiple items now, and for each item we will use an insertion
    hint. Since we have no hint in the beginning to start with, we will just do the
    first insertion pointing to the `end` iterator of the map.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将插入多个项目，并且对于每个项目，我们将使用插入提示。由于一开始我们没有提示可以使用，我们将首先插入指向地图的`end`迭代器。
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We will now insert items from the alphabet backward while always using the iterator
    hint we have, and then reinitialize it to the return value of the `insert` function.
    The next item will be inserted just *before* the hint.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将按字母表的顺序向地图中插入项目，始终使用我们拥有的迭代器提示，然后将其重新初始化为`insert`函数的返回值。下一个项目将被插入到提示的*前面*。
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: And just for the sake of showing how it is *not* done, we insert a string which
    will be put at the leftmost position in the map, but give it a completely *wrong*
    hint, which points to the rightmost position in the map--the `end`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了展示*不*应该这样做，我们插入一个字符串，它将被放在地图中最左边的位置，但给它一个完全*错误*的提示，它指向地图中最右边的位置——`end`。
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Finally, we just print what we have.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们只是打印我们拥有的东西。
- en: '[PRE53]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: And this is the output we get when we compile and run the program. Obviously,
    the wrong insertion hint did not hurt too much, as the map ordering is still correct.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们编译和运行程序时，这是我们得到的输出。显然，错误的插入提示并没有造成太大的伤害，因为地图的顺序仍然是正确的。
- en: '[PRE54]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The only difference to normal map insertions in this recipe was the additional
    hint iterator. And we spoke about *correct* and *wrong* hints.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，与普通地图插入的唯一区别是额外的提示迭代器。我们谈到了*正确*和*错误*的提示。
- en: A *correct* hint will point to an existing element, which is *greater* than
    the element to be inserted so that the newly inserted key will be just *before*
    the hint. If this does not apply for the hint the user provided during an insertion,
    the insert function will fall back to a nonoptimized insertion, yielding *O(log(n))*
    performance again.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*正确*的提示将指向一个现有元素，该元素*大于*要插入的元素，以便新插入的键将刚好在提示*之前*。如果这不适用于用户在插入时提供的提示，插入函数将退回到非优化的插入，再次产生*O(log(n))*的性能。'
- en: For the first insertion, we got the `end` iterator of the map, because we had
    no better hint to start with. After installing a "z" in the tree, we knew that
    installing "y" will insert a new item just in front of the "z", which qualified
    it to be a correct hint. This applies to "x" as well, if put into the tree after
    inserting the "y", and so on. This is why it is possible to use the iterator,
    which was returned by the *last* insertion for the *next* insertion.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次插入，我们得到了地图的`end`迭代器，因为我们没有更好的提示可以使用。在树中安装了一个“z”之后，我们知道安装“y”将在“z”的前面插入一个新项目，这使它成为一个正确的提示。如果在插入“y”之后将“x”放入树中，也是如此。这就是为什么可以使用由*上次*插入返回的迭代器进行*下次*插入。
- en: It is important to know, that before C++11, insertion hints were considered
    correct when they pointed *before* the position of the newly inserted item.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，在C++11之前，插入提示被认为是正确的，当它们指向新插入的项目的位置*之前*时。
- en: There's more...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Interestingly, a wrong hint does not even destroy or disturb the order of the
    items in the map, so how does that even work, and what did that mean, that the
    insertion time is amortized *O(1)*?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，错误的提示甚至不会破坏或干扰地图中项目的顺序，那么这是如何工作的，这意味着什么，插入时间是摊销*O(1)*吗？
- en: The `std::map` is usually implemented using a binary search tree. When inserting
    a new key into a search tree, it is compared against the keys of the other nodes,
    beginning from the top. If the key is smaller or larger than the key of one node,
    then the search algorithm branches left or right to go down to the next deeper
    node. While doing that, the search algorithm will stop at the point where it reached
    the maximum depth of the current tree, where it will put the new node with its
    key. It is possible that this step destroyed the tree's balance, so it will also
    correct that using a re-balancing algorithm afterward as a housekeeping task.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::map`通常使用二叉搜索树实现。将新键插入搜索树时，将其与其他节点的键进行比较，从顶部开始。如果键比一个节点的键小或大，那么搜索算法将向左或向右分支，以进入下一个更深的节点。在这样做的同时，搜索算法将在达到当前树的最大深度的地方停止，在那里将新节点与其键放置。这一步可能破坏了树的平衡，因此之后也会使用重新平衡算法来纠正这一点，作为一项日常任务。'
- en: When we insert items into a tree with key values which are direct neighbors
    of each other (just as the integer `1` is a neighbor of the integer `2`, because
    no other integer fits between them), they can *often* also be inserted just next
    to each other in the tree, too. It can easily be checked if this is true for a
    certain key and an accompanying hint. And if this situation applies, the search
    algorithm step can be omitted, which spares some crucial runtime. Afterward, the
    re-balancing algorithm might nevertheless have to be run.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将具有直接相邻键值的项目插入树中时（就像整数`1`是整数`2`的邻居一样，因为它们之间没有其他整数），它们通常也可以被插入到树中的相邻位置。可以轻松检查某个键和相应提示是否适用这种情况。如果适用，搜索算法步骤可以省略，这可以节省一些关键的运行时间。之后，重新平衡算法可能仍然需要运行。
- en: When such an optimization can *often* be done, but not *always*, this can still
    lead to an *average* performance gain. It is possible to show a *resulting* runtime
    complexity which settles down after *multiple* insertions, and then it's called
    **amortized complexity**.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当这样的优化通常可以完成，但并非总是如此时，这仍然可能导致平均性能提升。可以展示出在多次插入后稳定下来的*结果*运行时复杂度，然后称之为**摊销复杂度**。
- en: '![](img/ba7cd62b-4541-4793-9475-24b490c8929b.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba7cd62b-4541-4793-9475-24b490c8929b.png)'
- en: If the insertion hint is wrong, the insertion function will simply *waive* the
    hint and start over using the search algorithm. This works correctly but is obviously
    *slower*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插入提示错误，插入函数将简单地放弃提示，并重新使用搜索算法开始。这样做是正确的，但显然会更慢。
- en: Efficiently modifying the keys of std::map items
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效地修改std::map项的键
- en: Since the `std::map` data structure maps from keys to values in a way that the
    keys are always unique and sorted, it is of crucial value that users cannot modify
    the keys of map nodes that are already inserted. In order to prevent the user
    from modifying the key items of perfectly sorted map nodes, the `const` qualifier
    is added to the key type.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`std::map`数据结构以一种使键始终唯一且排序的方式映射到值，因此用户无法修改已插入的地图节点的键是至关重要的。为了防止用户修改完全排序的地图节点的键项，将`const`限定符添加到键类型中。
- en: This kind of restriction is perfectly sane because it makes it harder for the
    user to use `std::map` the wrong way. But what shall we do if we really need to
    change the keys of some map items?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制是完全合理的，因为它使用户更难以错误使用`std::map`。但是，如果我们真的需要更改一些映射项的键，我们该怎么办呢？
- en: Prior to C++17, we had to remove the items of which we need to change the key
    value from the tree, in order to reinsert them. The downside of this approach
    is that this always needlessly reallocates some memory, which sounds bad in terms
    of performance.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17之前，我们必须从树中删除需要更改键值的项目，然后重新插入它们。这种方法的缺点是这总是不必要地重新分配一些内存，这在性能方面听起来很糟糕。
- en: Since C++17, we can remove and reinsert map nodes *without* any reallocation
    of memory. We will see how that works in this recipe.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 自C++17以来，我们可以删除和重新插入地图节点而不进行任何内存重新分配。我们将在本教程中看到它是如何工作的。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: We implement a little application that orders the placement of drivers in a
    fictional race in an `std::map` structure. While drivers pass each other during
    the race, we need to change their placement keys, which we do the new C++17 way.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个小应用程序，它以`std::map`结构对虚构比赛中的驾驶员的位置进行排序。在比赛中，当驾驶员相互超越时，我们需要更改他们的位置键，这是我们以新的C++17方式做的。
- en: Let's first include the necessary headers and declare that we use namespace
    `std`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先包括必要的头文件，并声明我们使用`std`命名空间。
- en: '[PRE55]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We will print the race placements before and after manipulating the map structure,
    so let's implement a little helper function for that.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在操纵地图结构之前和之后打印比赛名次，因此让我们为此实现一个小助手函数。
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the main function, we instantiate and initialize a map that maps from integer
    values that denote the driver's place to strings that contain the driver's name.
    We also print the map because we will modify it in the next steps.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们实例化和初始化一个映射，将整数值映射到包含驾驶员姓名的字符串。我们还打印地图，因为我们将在接下来的步骤中对其进行修改。
- en: '[PRE57]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Let's say that during one race lap, Bowser had a little accident and dropped
    to the last place and Donkey Kong Jr. took the chance to jump from the last place
    to the third place. In that case, we first need to extract their map nodes from
    the map because this is the only way to manipulate their keys. The `extract` function
    is a new C++17 feature. It removes items from a map without any allocation-related
    side effects. Let's also open a new scope for this task.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设在一圈比赛中，鲍泽发生了一点小事故，掉到了最后一名，唐克·孔·朱尼尔趁机从最后一名跳到第三名。在这种情况下，我们首先需要从地图中提取它们的地图节点，因为这是操纵它们的键的唯一方法。`extract`函数是C++17的新功能。它可以从地图中删除项目而不产生任何与分配相关的副作用。让我们为这个任务打开一个新的范围。
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now we can swap Bowser's and Donkey Kong Jr.'s keys. While the keys of map nodes
    are usually not mutable because they are declared `const`, we can modify the keys
    of items which we extracted using the `extract` method.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以交换Bowser和Donkey Kong Jr.的键。虽然地图节点的键通常是不可变的，因为它们被声明为`const`，但我们可以修改使用`extract`方法提取的项目的键。
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`std::map`''s `insert` method got a new overload in C++17 that accepts the
    handles of extracted nodes, in order to insert them without touching the allocator.'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C++17中，`std::map`的`insert`方法得到了一个新的重载，可以接受提取节点的句柄，以便在不触及分配器的情况下插入它们。
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: After leaving the scope, we're done. We print the new race placement and let
    the application terminate.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 离开作用域后，我们完成了。我们打印新的比赛排名，然后让应用程序终止。
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Compiling and running the program yields the following output. We see the race
    placement in the fresh map instance first, and then we see it again after swapping
    Bowser's and Donkey Kong Jr.'s positions.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生以下输出。我们首先在新的地图实例中看到了比赛排名，然后在交换Bowser和Donkey Kong Jr.的位置后再次看到它。
- en: '[PRE62]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In C++17, `std::map` got a new member function extract. It comes in two flavors:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，`std::map`获得了一个新的成员函数extract。它有两种形式：
- en: '[PRE63]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this recipe, we used the second one, which accepts a key and then finds and
    extracts the map node that matches the key parameter. The first one accepts an
    iterator, which implies that it is *faster* because it doesn't need to search
    for the item.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们使用了第二种方法，它接受一个键，然后查找并提取与键参数匹配的地图节点。第一个方法接受一个迭代器，这意味着它*更快*，因为它不需要搜索项目。
- en: If we try to extract an item that doesn't exist with the second method (the
    one that searches using a key), it returns an *empty* `node_type` instance. The `empty()`
    member method returns us a Boolean value that tells whether a `node_type` instance
    is empty or not. Accessing any other method on an empty instance leads to undefined
    behavior.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用第二种方法（使用键进行搜索）提取不存在的项目，则会返回一个*空*的`node_type`实例。`empty()`成员方法返回一个布尔值，告诉我们`node_type`实例是否为空。访问空实例上的任何其他方法会导致未定义的行为。
- en: After extracting nodes, we were able to modify their keys using the `key()`
    method, which gives us nonconst access to the key, although keys are usually const.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在提取节点之后，我们能够使用`key()`方法修改它们的键，这为我们提供了对键的非const访问，尽管键通常是const的。
- en: Note that in order to reinsert the nodes into the map again, we had to *move*
    them into the `insert` function. This makes sense because `extract` is all about
    avoiding unnecessary copies and allocations. Note that while we move a `node_type`
    instance, this does not result in actual moves of any of the container values.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了重新将节点插入地图中，我们必须将它们*移动*到`insert`函数中。这是有道理的，因为`extract`的目的是避免不必要的复制和分配。请注意，虽然我们移动了一个`node_type`实例，但这并不会导致任何容器值的实际移动。
- en: There's more...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Map nodes that have been extracted using the extract method are actually very
    versatile. We can extract nodes from a `map` instance and insert it into any other
    `map` or even `multimap` instance. It does also work between `unordered_map` and
    `unordered_multimap` instances, as well as with `set`/`multiset` and respective
    `unordered_set`/`unordered_multiset`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提取方法提取的地图节点实际上非常灵活。我们可以从`map`实例中提取节点并将其插入到任何其他`map`甚至`multimap`实例中。它也可以在`unordered_map`和`unordered_multimap`实例之间，以及`set`/`multiset`和相应的`unordered_set`/`unordered_multiset`之间工作。
- en: In order to move items between different map/set structures, the types of key,
    value, and allocator need to be identical. Note that even if that is the case,
    we cannot move nodes from a `map` to an `unordered_map`, or from a `set` to an
    `unordered_set`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不同的地图/集合结构之间移动项目，键、值和分配器的类型需要相同。请注意，即使是这种情况，我们也不能从`map`移动节点到`unordered_map`，或者从`set`移动节点到`unordered_set`。
- en: Using std::unordered_map with custom types
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义类型的std::unordered_map
- en: If we use `std::unordered_map` instead of `std::map`, we have a different degree
    of freedom for the choice of the key type which shall be used. `std::map` demands
    that there is a natural order between all key items. This way, items can be sorted.
    But what if we want, for example, mathematical vectors as a key type? There is
    no *meaning* in a *smaller* `<` relation for such types, as a vector `(0, 1)`
    is not *smaller* or *larger* than `(1, 0)`. They just point in different directions.
    This is completely fine for `std::unordered_map` because it will not distinguish
    items via their smaller/greater ordering relationship but via *hash values*. The
    only thing we need to do is to implement a *hash function* for our own type, and
    an *equal to* `==` operator implementation, which tells whether two objects are
    identical. This section will demonstrate this in an example.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`std::unordered_map`而不是`std::map`，我们可以对要使用的键类型进行不同程度的自由选择。`std::map`要求所有键项之间存在自然顺序。这样，项目可以排序。但是，如果我们想要，例如，将数学向量作为键类型呢？对于这种类型，没有*较小*`<`关系是没有*意义*的，因为向量`(0,
    1)`不比`(1, 0)`*小*或*大*。它们只是指向不同的方向。这对于`std::unordered_map`来说完全没问题，因为它不会通过它们的较小/较大的顺序关系来区分项目，而是通过*哈希值*。我们唯一需要做的就是为我们自己的类型实现一个*哈希函数*，以及一个*相等*的`==`运算符实现，告诉我们两个对象是否相同。本节将通过一个示例来演示这一点。
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will define a simple `coord` struct, which has no *default*
    hash function, so we need to define it ourselves. Then we put it to use by mapping
    `coord` values to numbers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将定义一个简单的`coord`结构，它没有*默认*哈希函数，因此我们需要自己定义它。然后我们通过将`coord`值映射到数字来使用它。
- en: We first include what's needed in order to print and use `std::unordered_map`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先包含了打印和使用`std::unordered_map`所需的内容。
- en: '[PRE64]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then we define our own custom struct, which is not trivially hashable by *existing*
    hash functions:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义了我们自己的自定义结构，它不是通过*现有*哈希函数轻松哈希的：
- en: '[PRE65]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We do not only need a hash function in order to use the structure as a key
    for a hash map, it also needs a comparison operator implementation:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不仅需要一个哈希函数才能将结构用作哈希映射的键，它还需要一个比较运算符的实现：
- en: '[PRE66]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In order to extend the STL's own hashing capabilities, we will open the `std`
    namespace and create our own `std::hash` template struct specialization. It contains
    the same `using` type alias clauses as other hash specializations.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了扩展STL自己的哈希能力，我们将打开`std`命名空间，并创建我们自己的`std::hash`模板结构专门化。它包含与其他哈希专门化相同的`using`类型别名子句。
- en: '[PRE67]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The meat of this `struct` is the `operator()` definition. We are just adding
    the numeric member values of `struct coord`, which is a poor hashing technique,
    but for the sake of showing how to implement it, it's good enough. A good hash
    function tries to distribute values as evenly over the whole value range as possible,
    in order to reduce the amount of *hash collisions*.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`struct`的核心是`operator()`的定义。我们只是添加了`struct coord`的数值成员值，这是一种较差的哈希技术，但为了展示如何实现它，这已经足够了。一个好的哈希函数试图尽可能均匀地分布值在整个值范围内，以减少*哈希冲突*的数量。
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can now instantiate a new `std::unordered_map` instance, which accepts `struct
    coord` instances as a key, and maps it to arbitrary values. As this recipe is
    about enabling our own types for `std::unordered_map`, this is pretty much it
    already. Let''s instantiate a hash-based map with our own type, fill it with some
    items, and print its :'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以实例化一个新的`std::unordered_map`实例，它接受`struct coord`实例作为键，并将其映射到任意值。由于这个方法是关于使我们自己的类型适用于`std::unordered_map`，这已经足够了。让我们用我们自己的类型实例化一个基于哈希的映射，填充它一些项目，并打印它的：
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Compiling and running the program yields the following output:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生了以下输出：
- en: '[PRE70]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Usually, when we instantiate a hash-based map implementation like `std::unordered_map`,
    we write:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们实例化一个基于哈希的映射实现，比如`std::unordered_map`时，我们会写：
- en: '[PRE71]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'It is not too obvious that there happens a lot of magic in the background when
    the compiler creates our `std::unordered_map` specialization. So, let''s have
    a look at the complete template-type definition of it:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器创建我们的`std::unordered_map`专门化时，背后发生了很多魔法，这并不太明显。因此，让我们来看一下它的完整模板类型定义：
- en: '[PRE72]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The first two template types are those we filled with `coord` and `int`, which
    is the simple and obvious part. The other three template types are optional, as
    they are automatically filled with existing standard template classes, which themselves
    take template types. Those are fed with our choice for the first two parameters
    as default values.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个模板类型是我们用`coord`和`int`填充的，这是简单和明显的部分。另外三个模板类型是可选的，因为它们会自动填充现有的标准模板类，这些类本身采用模板类型。这些类以我们对前两个参数的选择作为默认值。
- en: 'Regarding this recipe, the `class Hash` template parameter is the interesting
    one: when we do not explicitly define anything else, it is going to be specialized
    on `std::hash<key_type>`. The STL already contains `std::hash` specializations
    for a lot of types such as `std::hash<std::string>`, `std::hash<int>`, `std::hash<unique_ptr>`,
    and many more. These classes know how to deal with such specific types in order
    to calculate optimal hash values from them.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个方法，`class Hash`模板参数是有趣的：当我们没有明确定义其他任何东西时，它将专门化为`std::hash<key_type>`。STL已经包含了许多类型的`std::hash`专门化，比如`std::hash<std::string>`，`std::hash<int>`，`std::hash<unique_ptr>`等等。这些类知道如何处理这些特定类型，以计算出最佳的哈希值。
- en: However, the STL does not know how to calculate a hash value from our `struct
    coord`, yet. So what we did was to just define *another* specialization, which
    knows how to deal with it. The compiler can now go through the list of all `std::hash`
    specializations it knows, and will find our implementation to match it with the
    type we provided as key type.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，STL并不知道如何从我们的`struct coord`计算哈希值。因此，我们所做的是定义*另一个*专门化，它知道如何处理它。编译器现在可以遍历它所知道的所有`std::hash`专门化列表，并找到我们的实现来匹配我们提供的键类型。
- en: 'If we did not add a new `std::hash<coord>` specialization, and named it `my_hash_type`
    instead, we could still use it with the following instantiation line:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有添加一个新的`std::hash<coord>`专门化，并将其命名为`my_hash_type`，我们仍然可以使用以下实例化行：
- en: '[PRE73]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: That is obviously more to type, and not as nice to read as when the compiler
    finds the right hashing implementation itself.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然需要输入更多的内容，而且不像编译器自己找到正确的哈希实现那样容易阅读。
- en: Filtering duplicates from user input and printing them in alphabetical order
    with std::set
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从用户输入中过滤重复项并按字母顺序打印它们与std::set
- en: '`std::set` is a strange container: It kind of works like `std::map`, but it
    contains only keys as values, no key-value pairs. So it can hardly be used as
    a way to map values of one type to the other. Seemingly, just because there are
    less obvious use cases for it, a lot of developers do not even know about its
    existence. Then they start to implement things themselves, although `std::set`
    would be of great help in some of these situations.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::set`是一个奇怪的容器：它的工作方式有点像`std::map`，但它只包含键作为值，没有键值对。因此，它几乎不能用作将一种类型的值映射到另一种类型的值。看起来，只是因为它的用例不太明显，很多开发人员甚至不知道它的存在。然后他们开始自己实现东西，尽管`std::set`在其中的一些情况下会非常有帮助。'
- en: This section shows how to put `std::set` to use in an example where we collect
    potentially many different items, in order to *filter* them and output a selection
    of the *unique* ones.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分展示了如何在一个示例中使用`std::set`，在这个示例中，我们收集了许多不同的项目，以*过滤*它们并输出*唯一*的选择。
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will read a stream of words from the standard input. All
    *unique* words are put into an `std::set` instance. This way we can then enumerate
    all unique words from the stream.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将从标准输入中读取一系列单词。所有*唯一*的单词都被放入一个`std::set`实例中。这样我们就可以列举出流中的所有唯一单词。
- en: We will use several different STL types, for which we need to include multiple
    headers.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用多种不同的STL类型，因此需要包含多个头文件。
- en: '[PRE74]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In order to spare us some typing, we will declare that we are using namespace
    `std`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了节省一些输入，我们将声明我们正在使用`std`命名空间：
- en: '[PRE75]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now we're already writing the actual program, which begins with the `main` function
    instantiating an `std::set` which stores strings.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经开始编写实际的程序，它以`main`函数实例化一个存储字符串的`std::set`开始。
- en: '[PRE76]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The next thing to do is to get the user input. We're just reading from standard
    input, and do that using the handy `istream_iterator`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来要做的事情是获取用户输入。我们只需从标准输入读取，并使用方便的`istream_iterator`。
- en: '[PRE77]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Having a pair of `begin` and `end` iterators, which represent the user input,
    we can just fill the set from it using an `std::inserter`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拥有一对`begin`和`end`迭代器，代表用户输入，我们可以使用`std::inserter`从中填充集合。
- en: '[PRE78]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: That's already it. In order to see what *unique* words we got from standard
    input, we just print the content of our set.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样。为了看到我们从标准输入得到的*独特*单词，我们只需打印我们集合的内容。
- en: '[PRE79]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Let's compile and run our program with the following input. We get the following
    output for the preceding input, where all duplicates are stripped out, and the
    words which were unique, are sorted alphabetically.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用以下输入编译和运行我们的程序。对于前面的输入，我们得到以下输出，其中所有重复项都被剔除，而独特的单词按字母顺序排序。
- en: '[PRE80]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This program consists of two interesting parts. The first part is using `std::istream_iterator`
    to access the user input, and the second part is to combine this with our `std::set`
    instance using the `std::copy` algorithm, after we wrapped it into an `std::inserter`
    instance! It might look surprising that there is only one line of code which does
    all the work of *tokenizing* the input, *putting* it into the alphabetically *sorted*
    set, and *dropping* all duplicates.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序由两个有趣的部分组成。第一部分是使用`std::istream_iterator`来访问用户输入，第二部分是将其与我们的`std::set`实例结合起来，使用`std::copy`算法，然后将其包装成`std::inserter`实例！也许令人惊讶的是，只有一行代码就可以完成*标记化*输入、将其放入按字母顺序*排序*的集合中，并*删除*所有重复项的所有工作。
- en: std::istream_iterator
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::istream_iterator
- en: 'This class is really interesting in cases where we want to process masses of
    data of the *same* type from a stream, which is exactly the case in this recipe:
    we parse the whole input word by word and put it into the set in the form of `std::string`
    instances.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在我们想要从流中处理大量*相同*类型的数据时非常有趣，这正是这个示例的情况：我们逐个单词解析整个输入，并将其以`std::string`实例的形式放入集合中。
- en: The `std::istream_iterator` takes one template parameter. That is the type of
    the input we want to have. We chose `std::string` because we assume text words,
    but it could also have been `float` numbers, for example. It can basically be
    every type for which it is possible to write `cin >> var;`. The constructor accepts
    an `istream` instance. The standard input is represented by the global input stream
    object `std::cin`, which is an acceptable `istream` parameter in this case.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::istream_iterator`接受一个模板参数。那就是我们想要的输入类型。我们选择了`std::string`，因为我们假设是文本单词，但也可以是`float`数字，例如。基本上可以是任何可以写成`cin
    >> var;`的类型。构造函数接受一个`istream`实例。标准输入由全局输入流对象`std::cin`表示，在这种情况下是一个可接受的`istream`参数。'
- en: '[PRE81]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The input stream iterator `it` which we have instantiated, is able to do two
    things: when it is dereferenced (`*it`), it yields the current input symbol. As
    we have typed the iterator to `std::string` via its template parameter, that symbol
    will be a string containing one word.  When it is incremented (`++it`), it will
    jump to the next word, which we can access by dereferencing again.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实例化的输入流迭代器`it`能够做两件事：当它被解引用(`*it`)时，它会产生当前的输入符号。由于我们通过模板参数将迭代器类型化为`std::string`，所以该符号将是一个包含一个单词的字符串。当它被增加(`++it`)时，它将跳到下一个单词，我们可以通过再次解引用来访问它。
- en: But wait, we need to be careful after every increment before we dereference
    it again. If the standard input ran *empty*, the iterator must *not* be dereferenced
    again. Instead, we should terminate the loop in which we dereference the iterator
    to get at every word. The abort condition, which lets us know that the iterator
    became invalid, is a comparison with the `end` iterator. If `it == end` holds,
    we are past the end of the input.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，在我们再次解引用之前，我们需要在每次增量之后小心。如果标准输入为空，迭代器就不应该再次被解引用。相反，我们应该终止我们解引用迭代器以获取每个单词的循环。让我们知道迭代器变得无效的中止条件是与`end`迭代器的比较。如果`it
    == end`成立，我们就超出了输入的末尾。
- en: 'We create the end iterator by creating an `std::istream_iterator` instance
    with its parameterless standard constructor. It has the purpose of being the counterpart
    of the comparison which shall act as the abort condition in every iteration:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用其无参数标准构造函数创建`std::istream_iterator`实例来创建结束迭代器。它的目的是作为每次迭代中的中止条件的对应物：
- en: '[PRE82]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As soon as `std::cin` runs empty, our `it` iterator instance will *notice* that
    and make a comparison with `end` returning `true`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`std::cin`为空，我们的`it`迭代器实例将*注意到*并与`end`进行比较，返回`true`。
- en: std::inserter
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: std::inserter
- en: We used the `it` and `end` pair as *input* iterators in the `std::copy` call.
    The third parameter must be an *output* iterator. For that, we cannot just take
    `s.begin()` or `s.end()`. In an empty set, both are the same, so we are not even
    allowed to *dereference* it, regardless if that is for reading from it or assigning
    to it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`std::copy`调用中使用`it`和`end`对作为*输入*迭代器。第三个参数必须是一个*输出*迭代器。对于这一点，我们不能只取`s.begin()`或`s.end()`。在一个空集合中，两者是相同的，所以我们甚至不能*解引用*它，无论是用于从中读取还是分配给它。
- en: This is where `std::inserter` comes into play. It is a function which returns
    an `std::insert_iterator` that behaves like an iterator but does something else
    than what usual iterators do. When we increment it, it does nothing. When we dereference
    it and assign something to it, it will take the container it is attached to, and
    *insert* that value as a *new* item into it!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`std::inserter`发挥作用的地方。它是一个返回`std::insert_iterator`的函数，它的行为类似于迭代器，但做的事情与通常的迭代器不同。当我们增加它时，它什么也不做。当我们解引用它并将某物赋给它时，它将取得它所附属的容器，并将该值作为*新*项插入其中！
- en: 'When instantiating an `std::insert_iterator` via `std::inserter`, two parameters
    are needed:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`std::inserter`实例化`std::insert_iterator`需要两个参数：
- en: '[PRE83]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `s` is our set, and `s.end()` is an iterator that points to where the new
    item shall be inserted. For an empty set which we start with, this makes as much
    sense as `s.begin()`. When used for other data structures as vectors or lists,
    that second parameter is crucial for defining where the insert iterator shall
    insert new items.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`s`是我们的集合，`s.end()`是一个迭代器，指向新项应该插入的位置。对于我们开始的空集合，这和`s.begin()`一样有意义。当用于其他数据结构如向量或列表时，第二个参数对于定义插入迭代器应该插入新项的位置至关重要。'
- en: Putting it together
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将它放在一起
- en: 'In the end, *all* the action happens during the `std::copy` call:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*所有*的操作都发生在`std::copy`调用期间：
- en: '[PRE84]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This call pulls the next word token out of `std::cin` via the input iterator
    and pushes it into our `std::set`. Afterward, it increments both iterators, and
    checks whether the input iterator is equal to the input end iterator counterpart.
    If it is not, then there are still words left in the standard input, so it will
    *repeat*.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用从`std::cin`中通过输入迭代器取出下一个单词标记，并将其推入我们的`std::set`中。然后，它递增两个迭代器，并检查输入迭代器是否等于输入结束迭代器的对应项。如果不相等，那么标准输入中仍然有单词，所以它将*重复*。
- en: Duplicate words are automatically dropped. If the set already contains a specific
    word, adding it again has *no effect*. This would be different in an `std::multiset` as,
    in contrast, it would accept duplicates.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 重复的单词会自动被丢弃。如果集合已经包含特定单词，再次添加它将*没有效果*。这在`std::multiset`中是不同的，因为它会接受重复项。
- en: Implementing a simple RPN calculator with std::stack
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::stack实现一个简单的逆波兰表示法计算器
- en: The `std::stack` is an adapter class which lets the user push objects *onto*
    it like on a real stack of objects, and pop objects *down from* it again. In this
    section, we construct a reverse polish notation (RPN) calculator around that data
    structure, in order to show how to use it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::stack`是一个适配器类，它允许用户像在真正的对象堆栈上一样将对象推入它，然后再从中弹出对象。在这一部分，我们围绕这个数据结构构建了一个逆波兰表示法（RPN）计算器，以展示如何使用它。'
- en: The RPN is a notation that can be used to express mathematical expressions in
    a way that is really simple to parse. In RPN, `1 + 2` is `1 2 +`. Operands first,
    then the operation. Another example: `(1 + 2) * 3` would be `1 2 + 3 *` in RPN
    and that already shows why it is easier to parse, as we do not need *parentheses*
    to define subexpressions.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 逆波兰表示法是一种可以用来以非常简单的方式解析数学表达式的表示法。在逆波兰表示法中，`1 + 2`表示为`1 2 +`。首先是操作数，然后是操作符。另一个例子：`(1
    + 2) * 3`在逆波兰表示法中是`1 2 + 3 *`，这已经显示了为什么它更容易解析，因为我们不需要使用括号来定义子表达式。
- en: '![](img/c5365787-5e7f-4fab-afe2-ad3ae977ddb5.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5365787-5e7f-4fab-afe2-ad3ae977ddb5.jpg)'
- en: How to do it...
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will read a mathematical expression in RPN from the standard
    input, and then feed it into a function that evaluates it. In the end, we print
    the numeric result back to the user.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将从标准输入中读取一个逆波兰表示法的数学表达式，然后将其传递给一个评估函数。最后，我们将数值结果打印回给用户。
- en: 'We will use a lot of helpers from the STL, so there are a few includes:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用STL中的许多辅助函数，所以有一些包含：
- en: '[PRE85]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: And we do also declare that we are using namespace `std` in order to spare us
    some typing.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还声明我们使用`std`命名空间，以节省一些输入。
- en: '[PRE86]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Then, we immediately start implementing our RPN parser. It will accept an iterator
    pair, which denotes the beginning and end of a mathematical expression in string
    form, which will be consumed token by token.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们立即开始实现我们的逆波兰表示法解析器。它将接受一个迭代器对，表示以字符串形式的数学表达式的开始和结束，这将逐个标记消耗掉。
- en: '[PRE87]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: While we iterate through the tokens, we need to memorize all *operands* on the
    way until we see an *operation*. This is where we need a stack. All the numbers
    will be parsed and saved in double precision floating point, so it's going to
    be a stack of `double` values.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们遍历标记时，我们需要记住一路上的所有*操作数*，直到看到一个*操作符*。这就是我们需要一个堆栈的地方。所有的数字都将被解析并保存为双精度浮点数，所以它将是一个`double`值的堆栈。
- en: '[PRE88]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In order to comfortably access elements on the stack, we implement a helper.
    It modifies the stack by pulling the highest item from it and then returns that
    item. This way we can perform this task in one single step later.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便地访问堆栈上的元素，我们实现了一个辅助函数。它通过从堆栈中取出最高项来修改堆栈，然后返回该项。这样我们可以在以后的一个步骤中执行这个任务。
- en: '[PRE89]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Another preparation is to define all the supported mathematical operations.
    We save them in a map, which associates every operation token with the actual
    operation. The operations are represented by callable lambdas, which take two
    operands, add or multiply them, for example, and then return the result.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个准备工作是定义所有支持的数学运算。我们将它们保存在一个映射中，将每个操作标记与实际操作关联起来。这些操作由可调用的lambda表示，它们接受两个操作数，例如相加或相乘，然后返回结果。
- en: '[PRE90]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Now we can finally iterate through the input. Assuming that the input iterators
    give us strings, we feed a new `std::stringstream` per token, because it can parse
    numbers.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们终于可以遍历输入了。假设输入迭代器给我们的是字符串，我们为每个标记提供一个新的`std::stringstream`，因为它可以解析数字。
- en: '[PRE91]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Now with every token, we try to get a `double` value out of it. If that succeeds,
    we have an *operand*, which we push on the stack.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在对于每个标记，我们尝试从中获取一个`double`值。如果成功，我们就有了*操作数*，我们将其推入堆栈。
- en: '[PRE92]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: If it does *not* succeed, it must be something other than an operator; in that
    case, it can only be an *operand*. Knowing that all the operations we support
    are *binary*, we need to pop the last *two* operands from the stack.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它*不*成功，那么它必须是其他东西而不是操作符；在这种情况下，它只能是*操作数*。知道我们支持的所有操作都是*二元*的，我们需要从堆栈中弹出最后的*两个*操作数。
- en: '[PRE93]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Now we get the operand from dereferencing the iterator `it`, which already emits
    strings. By querying the `ops` map, we get a lambda object which accepts the two
    operands `l` and `r` as parameters.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们从解引用迭代器`it`中获取操作数，它已经发出了字符串。通过查询`ops`映射，我们得到一个接受两个操作数`l`和`r`作为参数的lambda对象。
- en: '[PRE94]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We surrounded the application of the math part with a `try` clause, so we can
    catch possibly occurring exceptions. The `at` call of the map will throw an `out_of_range`
    exception in case the user provides a mathematical operation we don't know of.
    In that case, we will rethrow a different exception, which says `invalid argument` and
    carries the operation string which was unknown to us.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用`try`子句包围了数学部分的应用，这样我们就可以捕获可能发生的异常。映射的`at`调用将在用户提供我们不知道的数学操作时抛出`out_of_range`异常。在这种情况下，我们将重新抛出一个不同的异常，该异常说`invalid
    argument`并携带了我们不知道的操作字符串。
- en: '[PRE95]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: That's already it. As soon as the loop terminates, we have the final result
    on the stack. So we return just that. (At this point, we could assert if the stack
    size is 1\. If it wasn't, then there would be missing operations.)
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是全部。一旦循环终止，我们就在堆栈上得到了最终结果。所以我们就返回那个。 （在这一点上，我们可以断言堆栈大小是否为1。如果不是，那么就会缺少操作。）
- en: '[PRE96]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now we can use our little RPN parser. In order to do this, we wrap the standard
    input into an `std::istream_iterator` pair, and feed that into the RPN parser
    function. Finally, we print the result:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用我们的小RPN解析器。为了做到这一点，我们将标准输入包装成一个`std::istream_iterator`对，并将其传递给RPN解析器函数。最后，我们打印结果：
- en: '[PRE97]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We do again have that line wrapped into a `try` clause because there''s still
    the possibility that the user input contains operations we did not implement.
    In that case, we must catch the exception which we throw in such cases, and print
    an error message:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次将该行包装到`try`子句中，因为仍然有可能用户输入包含我们没有实现的操作。在这种情况下，我们必须捕获我们在这种情况下抛出的异常，并打印错误消息：
- en: '[PRE98]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'After compiling the program, we can play around with it. The input `"3 1 2
    + * 2 /"` represents the expression `( 3 * (1 + 2) ) / 2` and yields the correct
    result:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序后，我们可以尝试一下。输入`"3 1 2 + * 2 /"`代表表达式`( 3 * (1 + 2) ) / 2`，并产生了正确的结果：
- en: '[PRE99]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: How it works...
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The whole recipe revolves around pushing operands onto the stack until we see
    an operation in the input. In that situation, we pop the last two operands from
    the stack again, apply the operation to them, and push the result onto the stack
    again. In order to understand all of the code in this recipe, it is important
    to understand how we distinguish *operands* and *operations* from the input, how
    we handle our stack, and how we select and apply the right mathematical operation.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 整个算法围绕着将操作数推送到堆栈上直到我们在输入中看到一个操作。在这种情况下，我们再次从堆栈中弹出最后两个操作数，对它们应用操作，然后再次将结果推送到堆栈上。为了理解这个算法中的所有代码，重要的是要理解我们如何从输入中区分*操作数*和*操作*，如何处理我们的堆栈，以及如何选择和应用正确的数学操作。
- en: Stack handling
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈处理
- en: 'We push items onto the stack, simply using the `push` function of `std::stack`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将项目推送到堆栈上，只需使用`std::stack`的`push`函数：
- en: '[PRE100]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Popping values from it looks a bit more complicated because we implemented
    a lambda for that, which captures a reference to the `val_stack` object. Let''s
    look at the same code, enhanced with some more comments:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 从中弹出值看起来有点复杂，因为我们为此实现了一个lambda，它捕获了对`val_stack`对象的引用。让我们看看相同的代码，增加一些注释：
- en: '[PRE101]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'This lambda is necessary to get the top value of the stack and *remove* it
    from there in *one* step. The interface of `std::stack` is not designed in a way
    which would allow doing that in a *single* call. However, defining a lambda is
    quick and easy, so we can now get values like this:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这个lambda是必要的，以便一步获取堆栈的顶部值并从中*删除*它。`std::stack`的接口设计并不允许在*单个*调用中执行此操作。但是，定义一个lambda很快很容易，所以我们现在可以这样获取值：
- en: '[PRE102]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Distinguishing operands from operations from user input
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从用户输入中区分操作数和操作
- en: In the main loop of `evaluate_rpn`, we take the current string token from the
    iterator and then see whether it is an operand or not. If the string can be parsed
    into a `double` variable, then it is a number, and hence also an operand. We consider
    everything which is not easily parseable as a number (such as `"+"`, for example)
    to be an *operation*.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在`evaluate_rpn`的主循环中，我们从迭代器中获取当前的字符串标记，然后查看它是否是操作数。如果字符串可以解析为`double`变量，那么它就是一个数字，因此也是一个操作数。我们认为所有不能轻松解析为数字的东西（例如`"+"`）都是*操作*。
- en: 'The naked code skeleton for exactly this task is as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 用于这个任务的裸代码框架如下：
- en: '[PRE103]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The stream operator `>>` tells us if it is a number. First, we wrapped the string
    into an `std::stringstream`. Then we use the `stringstream` object's capability
    to stream from an `std::string` into a `double` variable, which involves parsing.
    If the parsing *fails*, we know that it does so, because we asked it to parse
    something into a number, which is *no number*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 流操作符`>>`告诉我们它是否是一个数字。首先，我们将字符串包装到`std::stringstream`中。然后我们使用`stringstream`对象的能力从`std::string`流到`double`变量，这涉及解析。如果解析*失败*，我们知道它是因为我们要求它将某些东西解析为一个数字，而这不是一个数字。
- en: Selecting and applying the right mathematical operation
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择和应用正确的数学操作
- en: After we realize that the current user input token is not a number, we just
    assume that it is an operation, such as `+` or `*`. Then we query our map, which
    we called `ops`, to look that operation up and return us a function, which accepts
    two operands, and returns the sum, or the product, or whatever is appropriate.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们意识到当前用户输入标记不是一个数字之后，我们只是假设它是一个操作，比如`+`或`*`。然后我们查询我们称为`ops`的映射，查找该操作并返回一个函数，该函数接受两个操作数，并返回总和，或乘积，或适当的其他内容。
- en: 'The type of the map itself looks relatively complicated:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 映射本身的类型看起来相对复杂：
- en: '[PRE104]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: It maps from `string` to `double (*)(double, double)`. What does the latter
    mean? This type description shall read "*pointer to a function which takes two
    doubles, and returns a double*". Imagine that the `(*)` part is the name of the
    function, such as in `double sum(double, double)`, which is immediately easier to
    read. The trick here is that our lambda `[](double, double) { return /* some double
    */ }` is convertible to a function pointer that actually matches that pointer
    description. Lambdas that *don't capture* anything are generally convertible to
    function pointers.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 它从`string`映射到`double (*)(double, double)`。后者是什么意思？这种类型描述应该读作“*指向一个接受两个double并返回一个double的函数的指针*”。想象一下，`(*)`部分就是函数的名称，比如`double
    sum(double, double)`，这样就更容易阅读。这里的技巧是，我们的lambda `[](double, double) { return /*
    some double */ }` 可以转换为实际匹配该指针描述的函数指针。通常不捕获任何内容的lambda都可以转换为函数指针。
- en: 'This way, we can conveniently ask the map for the correct operation:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以方便地向映射询问正确的操作：
- en: '[PRE105]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The map implicitly does another job for us: If we say `ops.at("foo")`, then
    `"foo"` is a valid key value, but we did not store any operation named like this.
    In such a case, the map will throw an exception, which we catch in the recipe.
    We rethrow a different exception whenever we catch it, in order to provide a descriptive
    meaning of this error case. The user will know better what an `invalid argument` exception
    means, compared to an `out of range` exception. Note that the user of the `evaluate_rpn`
    function might not have read its implementation, hence it might be unknown that
    we are using a map inside at all.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 映射隐式地为我们做了另一项工作：如果我们说`ops.at("foo")`，那么`"foo"`是一个有效的键值，但我们没有存储任何名为这样的操作。在这种情况下，映射将抛出一个异常，我们在配方中捕获它。每当我们捕获它时，我们重新抛出一个不同的异常，以便提供对这种错误情况的描述性含义。用户将更清楚地知道`无效参数`异常意味着什么，而不是`超出范围`异常。请注意，`evaluate_rpn`函数的用户可能没有阅读其实现，因此可能不知道我们根本在内部使用映射。
- en: There's more...
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As the `evaluate_rpn` function accepts iterators, it is very easy to feed it
    with different inputs than the standard input stream. This makes it very easy
    to test, or to adapt to different sources of user input.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`evaluate_rpn`函数接受迭代器，因此很容易用不同于标准输入流的输入来提供输入。这使得测试或适应不同的用户输入来源非常容易。
- en: 'Feeding it with iterators from a string stream or from a string vector, for
    example, looks like the following code, for which `evaluate_rpn` does not have
    to be changed at all:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过从字符串流或字符串向量中使用迭代器进行输入，看起来像以下代码，`evaluate_rpn`根本不需要更改：
- en: '[PRE106]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Use iterators wherever it makes sense. This makes your code very composable
    and reusable.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在合适的地方使用迭代器。这样可以使您的代码非常可组合和可重用。
- en: Implementing a word frequency counter with std::map
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`std::map`实现单词频率计数器
- en: The `std::map` is very useful when categorizing something in order to collect
    statistics about that data. By attaching modifiable payload objects to every key
    which represents an object category, it is pretty simple to implement a histogram
    of word frequencies for example. This is what we will do in this section.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::map`在对数据进行统计时非常有用。通过将可修改的有效负载对象附加到表示对象类别的每个键上，可以很容易地实现例如单词频率的直方图。这就是我们将在本节中做的事情。'
- en: How to do it...
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: In this section, we will read all user input from standard input, which might,
    for example, be a text file containing an essay. We tokenize the input to words,
    in order to count which word occurs how often.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将从标准输入中读取所有用户输入，例如可能是包含文章的文本文件。我们将输入标记化为单词，以便统计每个单词出现的次数。
- en: As always, we need to include all the headers from the data structures we are
    going to use.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们需要包括我们将要使用的数据结构的所有头文件。
- en: '[PRE107]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: To spare us some typing, we declare that we use namespace `std`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了节省一些输入，我们声明使用`std`命名空间。
- en: '[PRE108]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: We will use one helper function in order to crop possibly appended commas, dots,
    or colons from words.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个辅助函数来裁剪可能附加的逗号、句号或冒号。
- en: '[PRE109]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Now we start with the actual program. We will collect a map that associates
    every word we see with a counter of that word's frequency. Additionally, we maintain
    a variable which records the size of the longest word we've seen so far, so we
    can indent the word frequency table nicely when we print it at the end of the
    program.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们开始实际的程序。我们将收集一个映射，将我们看到的每个单词与该单词频率的计数器关联起来。此外，我们还维护一个记录迄今为止我们见过的最长单词的大小的变量，这样当我们在程序结束时打印单词频率表时，我们可以很好地缩进它。
- en: '[PRE110]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: When we stream from `std::cin` into an `std::string` variable, the input stream
    will cut out white space on the way. This way we get the input word by word.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们从`std::cin`流入一个`std::string`变量时，输入流会在途中去除空格。这样我们就可以逐个单词获取输入。
- en: '[PRE111]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The word which we have now, could contain a comma, dots,  or a colon, because
    it might be at the end of a sentence or similar. We filter that out with the helper
    function we defined before.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们所拥有的单词，可能包含逗号、句号或冒号，因为它可能出现在句子的结尾或类似位置。我们使用之前定义的辅助函数来过滤掉这些。
- en: '[PRE112]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: In case this word is the longest word so far, we need to update the `max_word_len`
    variable.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个单词是迄今为止最长的单词，我们需要更新`max_word_len`变量。
- en: '[PRE113]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Now we will increment the counter value of the word in our `words` map. If it
    occurs for the first time, it is implicitly created before we increment it.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将增加`words`映射中该单词的计数值。如果它是第一次出现，我们会在增加之前隐式地创建它。
- en: '[PRE114]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: After the loop terminated, we know that we saved all unique words from the input
    stream in the `words` map, paired with a counter denoting every word's frequency.
    The map uses words as keys and is sorted by their *alphabetical* order. What we
    want is to print all words sorted by their *frequency*, so the words with the
    highest frequency shall come first. In order to get that, we will first instantiate
    a vector where all these word-frequency pairs fit in and move them from the map
    to the vector.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环结束后，我们知道我们已经在`words`映射中保存了输入流中的所有唯一单词，并与表示每个单词频率的计数器配对。映射使用单词作为键，并按它们的*字母*顺序排序。我们想要的是按*频率*排序打印所有单词，因此频率最高的单词应该首先出现。为了实现这一点，我们首先实例化一个向量，将所有这些单词频率对放入其中，并将它们从映射移动到向量中。
- en: '[PRE115]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The vector does now still contain all word-frequency pairs in the same order
    as the `words` map maintained them. Now we sort it again, in order to have the
    most frequent words at the beginning, and the least frequent ones at the end.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在向量仍然以与`words`映射维护它们相同的顺序包含所有单词频率对。现在我们再次对其进行排序，以便将最频繁出现的单词放在开头，将最不频繁的单词放在末尾。
- en: '[PRE116]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: All data is in order now, so we push it out to the user terminal. Using the
    `std::setw` stream manipulator, we format the data in a nicely indented format,
    so it looks kind of like a table.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在所有数据都已经排序好了，所以我们将其推送到用户终端。使用`std::setw`流操作符，我们以漂亮的缩进格式格式化数据，使其看起来有点像表格。
- en: '[PRE117]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: After compiling the program, we can pipe any text file into it in order to get
    a frequency table.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序后，我们可以将任何文本文件输入到其中以获得频率表。
- en: '[PRE118]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: How it works...
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe concentrates on collecting all words in an `std::map` and then shoves
    all items out of the map and into an `std::vector`, which is then sorted differently,
    in order to print the data. Why?
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法集中在收集所有单词到`std::map`中，然后将所有项目从映射中推出并放入`std::vector`中，然后以不同的方式进行排序，以便打印数据。为什么？
- en: 'Let''s look at an example. When we count the word frequency in the string `"a
    a b c b b b d c c"`, we would get the following map content:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。当我们统计字符串`"a a b c b b b d c c"`中的单词频率时，我们会得到以下的映射内容：
- en: '[PRE119]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: However, that is not the order which we want to present to the user. The program
    should print `b` first because it has the highest frequency. Then `c`, then `a`,
    then `d`. Unfortunately, we cannot request the map to give us the "*key with the
    highest associated value*", then the "*key with the second highest associated
    value*", and so on.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不是我们想要向用户展示的顺序。程序应该首先打印`b`，因为它的频率最高。然后是`c`，然后是`a`，最后是`d`。不幸的是，我们无法要求映射给我们“*具有最高关联值的键*”，然后是“*具有第二高关联值的键*”，依此类推。
- en: Here, the vector comes into play. We typed the vector to contain pairs of strings
    and counter values. This way it can hold items exactly in the form as they drop
    out of the map.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，向量就派上用场了。我们将向量定义为包含字符串和计数器值对的对。这样它可以以与映射中的形式完全相同的形式保存项目。
- en: '[PRE120]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Then we fill the vector using the word-frequency pairs using the `std::move`
    algorithm. This has the advantage that the part of the strings which is maintained
    on the heap will not be duplicated, but will be moved over from the map to the
    vector. This way we can avoid a lot of copies.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`std::move`算法填充向量，使用单词频率对。这样做的好处是，保存在堆上的字符串部分不会被复制，而是从映射移动到向量中。这样我们就可以避免大量的复制。
- en: '[PRE121]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Some STL implementations use short string optimization--if the string is not
    too long, it will *not* be allocated on the heap and stored in the string object
    directly instead. In that case, a move is not faster. But moves are also never
    slower!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 一些STL实现使用了短字符串优化--如果字符串不太长，它将*不会*被分配到堆上，而是直接存储在字符串对象中。在这种情况下，移动并不更快。但移动也永远不会更慢！
- en: 'The next interesting step is the sort operation, which uses a lambda as a custom
    comparison operator:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个有趣的步骤是排序操作，它使用lambda作为自定义比较运算符：
- en: '[PRE122]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The sort algorithm will take items pairwise, and compare them, which is what
    sort algorithms do. By providing that lambda function, the comparison does not
    just compare if `a` is smaller than `b` (which is the default implementation),
    but also compares if `a.second` is larger than `b.second`. Note that all objects
    are *pairs* of strings and their counter values, and by writing `a.second` we
    access the word's counter value. This way we move all high-frequency words toward
    the beginning of the vector, and the low-frequency ones to the back.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 排序算法将成对地取出项目，并进行比较，这就是排序算法的工作原理。通过提供lambda函数，比较不仅仅是比较`a`是否小于`b`（这是默认实现），还比较`a.second`是否大于`b.second`。请注意，所有对象都是*字符串*和它们的计数器值的对，通过写`a.second`我们可以访问单词的计数器值。这样我们就将所有高频单词移动到向量的开头，将低频单词移动到向量的末尾。
- en: Implement a writing style helper tool for finding very long sentences in text
    with std::multimap
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个写作风格辅助工具，用于在文本中查找非常长的句子，使用std::multimap
- en: Whenever a lot of items shall be stored in a sorted manner, and the key by which
    they are sorted can occur multiple times, `std::multimap` is a good choice.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 每当需要以排序方式存储大量项目，并且它们按照键进行排序的时候，`std::multimap`是一个不错的选择。
- en: 'Let''s find an example use case: When writing text in German, it is okay to
    use very long sentences. When writing texts in English, it is *not*. We will implement
    a tool that helps German authors to analyze their English text files, focusing
    on the length of all sentences. In order to help the author in improving the text
    style, it will group the sentences by their length. This way the author can pick
    the longest ones and break them down.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找一个例子使用情况：在德语写作中，使用非常长的句子是可以的。但在英语写作中，是*不可以*的。我们将实现一个工具，帮助德语作者分析他们的英语文本文件，重点关注所有句子的长度。为了帮助作者改进文本风格，它将根据句子的长度对句子进行分组。这样作者就可以选择最长的句子并将其拆分。
- en: How to do it...
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will read all user input from standard input, which we will
    tokenize by whole sentences, and not words. Then we will collect all sentences
    in an `std::multimap` paired with a variable carrying their length. Afterward,
    we output all sentences, sorted by their length, back to the user.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从标准输入中读取所有用户输入，我们将通过整个句子而不是单词对其进行标记化。然后我们将所有句子收集到一个`std::multimap`中，并与其长度一起输出给用户。然后，我们将所有句子按其长度排序后返回给用户。
- en: As usual, we need to include all needed headers. `std::multimap` comes from
    the same header as `std::map`.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，我们需要包括所有需要的头文件。`std::multimap`来自与`std::map`相同的头文件。
- en: '[PRE123]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: We use a lot of functions from namespace `std`, so we declare its use automatically.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了很多来自`std`命名空间的函数，因此我们自动声明其使用。
- en: '[PRE124]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: When we tokenize strings by extracting what's between dot characters in the
    text, we will get text sentences surrounded by white space such as spaces, new
    line symbols, and so on. These would increase their size in a wrong way, so we
    filter them out using a helper function, which we now define.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们通过提取文本中句号之间的内容来对字符串进行标记化时，我们将得到由空格（如空格、换行符等）包围的文本句子。这些会以错误的方式增加它们的大小，因此我们使用一个辅助函数来过滤它们，现在我们定义它。
- en: '[PRE125]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The actual sentence length counting function shall take a giant string containing
    all the text, and then return an `std::multimap`, which maps sorted sentence lengths
    to the sentences.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际的句子长度计数函数应该接受一个包含所有文本的巨大字符串，然后返回一个`std::multimap`，将排序后的句子长度映射到句子。
- en: '[PRE126]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: We begin by declaring the `multimap` structure, which is intended to be the
    return value, and some iterators. As we will have a loop, we need an `end` iterator.
    Then we use two iterators in order to point to consecutive dots within the text.
    Everything between is a text sentence.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先声明`multimap`结构，这是预期的返回值，以及一些迭代器。由于我们将有一个循环，我们需要一个`end`迭代器。然后我们使用两个迭代器来指向文本中连续的句号。两者之间的所有内容都是一个文本句子。
- en: '[PRE127]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The `it2` will be always one dot further than `it1`. As long as `it1` did not
    reach the end of the text, we are fine. The second condition checks whether `it2`
    is really at least some characters further. If that was not the case, there would
    be no characters left to read between them.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`it2`始终比`it1`多一个句号。只要`it1`没有到达文本的末尾，我们就没问题。第二个条件检查`it2`是否真的至少有一些字符。如果不是这样，它们之间就没有字符可读了。'
- en: '[PRE128]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: We create a string from all characters between the iterators, and filter all
    white space from its beginning and end, in order to count the length of the pure
    sentence.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从迭代器之间的所有字符创建一个字符串，并过滤掉其开头和结尾的所有空格，以便计算纯句子的长度。
- en: '[PRE129]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: It's possible that the sentence does not contain anything other than white space.
    In that case, we simply drop it. Otherwise, we count its length by determining
    how many words there are. This is easy, as there are single spaces between all
    words. Then we save the word count together with the sentence in the `multimap`.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能句子中除了空格以外什么都没有。在这种情况下，我们只是丢弃它。否则，我们通过确定有多少个单词来计算其长度。这很容易，因为所有单词之间都有单个空格。然后我们将单词计数与句子一起保存在`multimap`中。
- en: '[PRE130]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: For the next loop iteration, we put the leading iterator `it1` on the next sentence's
    dot character. The following iterator `it2` is put one character after the *old*
    position of the leading iterator.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于下一个循环迭代，我们将主迭代器`it1`放在下一个句子的句号字符上。接下来的迭代器`it2`放在主迭代器的*旧*位置之后一个字符。
- en: '[PRE131]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: After the loop is terminated, the `multimap` contains all sentences paired with
    their word count and can be returned.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环结束后，`multimap`包含所有句子及其单词计数，并且可以返回。
- en: '[PRE132]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Now we put the function to use. First, we tell `std::cin` to not skip white
    space, as we want sentences with spaces in one piece. In order to read the whole
    file, we initialize an `std::string` from input stream iterators which encapsulate
    `std::cin`.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们开始使用该函数。首先，我们告诉`std::cin`不要跳过空格，因为我们希望句子中的空格保持完整。为了读取整个文件，我们从输入流迭代器初始化一个`std::string`，它封装了`std::cin`。
- en: '[PRE133]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: As we only need the `multimap` result for printing, we put the `get_sentence_stats`
    call directly in the loop and feed it with our string. In the loop body, we print
    the items line by line.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们只需要`multimap`的结果进行打印，我们直接在循环中调用`get_sentence_stats`并将其与我们的字符串一起使用。在循环体中，我们逐行打印项目。
- en: '[PRE134]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: After compiling the code, we can feed the app with text from any text file. An
    example Lorem Ipsum text yields the following output. As the output is very long
    for long text with many sentences, it prints the shortest sentences first and
    the longest last. This way we see the longest sentences first as terminals usually
    scroll to the end of the output automatically.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码后，我们可以从任何文本文件中输入文本到应用程序中。例如Lorem Ipsum文本产生以下输出。由于长文本有很多句子，输出非常长，因此它首先打印最短的句子，最后打印最长的句子。这样我们就可以先看到最长的句子，因为终端通常会自动滚动到输出的末尾。
- en: '[PRE135]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: How it works...
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The whole recipe concentrates on breaking down a large string into sentences
    of text, which are assessed for their length, and then ordered in a `multimap`.
    Because `std::multimap` itself is so easy to use, the complex part of the program
    is the loop, which iterates over the sentences:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程集中在将一个大字符串分解为文本句子，对其长度进行评估，然后在`multimap`中排序。因为`std::multimap`本身非常容易使用，程序的复杂部分是循环，它遍历句子：
- en: '[PRE136]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Let''s look at the code with the following diagram in mind, which consists
    of three sentences:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在看下面的代码时，考虑以下图表，其中包含三个句子：
- en: '![](img/18c1c74b-9f55-4b94-b150-f5f08f678583.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18c1c74b-9f55-4b94-b150-f5f08f678583.png)'
- en: The `it1` and `it2` are always moved forward through the string together. This
    way they always point to the beginning and end of *one* sentence. The `std::find`
    algorithm helps us a lot in that regard because it works like "*start at the current
    position and then return an iterator to the next dot character. If there is none,
    return the end iterator*."
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`it1`和`it2`始终一起向前移动。这样它们总是指向*一个*句子的开头和结尾。`std::find`算法在这方面帮助了我们很多，因为它的工作方式是“*从当前位置开始，然后返回到下一个句号字符的迭代器。如果没有，返回结束迭代器*。”'
- en: After we extract a sentence string, we determine how many words it contains,
    so we can insert it into the `multimap.` We are using the *number of words* as
    the *key* for the map nodes, and the string itself as the payload object associated
    with it. There can easily be multiple sentences which have the same length. This
    would render us unable to insert them all into one `std::map`. But since we use
    `std::multimap`, this is no problem, because it can easily handle multiple keys
    of the same value. It will keep them all *ordered* in line, which is what we need
    to enumerate all sentences by their length and output them to the user.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在提取句子字符串后，我们确定它包含多少个单词，以便将其插入`multimap`中。我们使用*单词数*作为映射节点的*键*，并将字符串本身作为与之关联的有效负载对象。很容易有多个长度相同的句子。这将使我们无法将它们全部插入一个`std::map`中。但由于我们使用`std::multimap`，这不是问题，因为它可以轻松处理相同值的多个键。它将保持它们全部*有序*，这正是我们需要通过它们的长度枚举所有句子并将它们输出给用户。
- en: There's more...
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: After having read the whole file into one large string, we iterate through the
    string and create copies of every sentence again. This is not necessary, as we
    also could have used `std::string_view`, which will be covered later in this book.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在将整个文件读入一个大字符串后，我们遍历字符串并再次创建每个句子的副本。这是不必要的，因为我们也可以使用`std::string_view`，这将在本书的后面介绍。
- en: Another way to iteratively get the strings between two consecutive dots is `std::regex_iterator`,
    which will also be covered in a later chapter of this book.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种迭代获取两个连续点之间的字符串的方法是`std::regex_iterator`，这也将在本书的后面章节中介绍。
- en: Implementing a personal to-do list using std::priority_queue
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::priority_queue实现个人待办事项列表
- en: The `std::priority_queue` is another container adapter class, such as `std::stack`.
    It is a wrapper around another data structure (`std::vector` by default) and provides
    a queue-like interface for it. This means that items can stepwise be pushed into
    it, and stepwise be popped out of it again. What is pushed into it *first*, will
    be popped out of it *first*. This is usually also abbreviated as a **first in,
    first out** (**FIFO**) queue. This is the opposite of a stack, where the *last*
    item pushed onto it is popped out of it *first*.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::priority_queue`是另一个容器适配器类，例如`std::stack`。它是另一个数据结构（默认情况下为`std::vector`）的包装器，并为其提供了类似队列的接口。这意味着可以逐步将项目推入其中，然后逐步将其弹出。被推入其中的东西*先*被弹出。这通常也被缩写为**先进先出**（**FIFO**）队列。这与堆栈相反，堆栈中*最后*推入的项目会*先*弹出。'
- en: While we just described the behavior of `std::queue`, this section shows how
    `std::priority_queue` works. That adapter is special, as it does not only take
    FIFO characteristics into account but also mixes it with priorities. This means
    that the FIFO principle is kind of broken down into sub-FIFO queues, which are
    ordered by the priorities their items have.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们刚刚描述了`std::queue`的行为，但本节展示了`std::priority_queue`的工作原理。该适配器很特别，因为它不仅考虑FIFO特性，还将其与优先级混合在一起。这意味着FIFO原则被分解为具有优先级的子FIFO队列。
- en: How to do it...
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will set up a cheap *to-do list organizing* structure. We
    do not parse user input in order to keep this program short and concentrate on
    `std::priority_queue`. So we're just filling an unordered list of to-do items
    with priorities and descriptions into a priority queue, and then read them out
    like from a FIFO queue data structure, but grouped by the priorities of the individual
    items.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将建立一个便宜的*待办事项列表组织*结构。我们不解析用户输入，以便使程序简短并集中在`std::priority_queue`上。因此，我们只是将待办事项的无序列表与优先级和描述一起填充到优先级队列中，然后像从FIFO队列数据结构中读取一样，但是根据各个项目的优先级进行分组。
- en: We need to include some headers first. `std::priority_queue` is in the header
    file `<queue>`.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要包含一些头文件。`std::priority_queue`在头文件`<queue>`中。
- en: '[PRE137]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: How do we store to-do items in the priority queue? The thing is, we cannot add
    items and additionally attach a priority to them. The priority queue will try
    to use the *natural order* of all items in the queue. We could now implement our
    own `struct todo_item`, and give it a priority number, and a string to-do description,
    and then implement the comparison operator `<` in order to make them orderable.
    Alternatively, we can just take `std::pair`, which enables us to aggregate two things
    in one type and implements comparison for us automatically.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将待办事项存储在优先级队列中？问题是，我们不能添加项目并额外附加优先级。优先级队列将尝试使用队列中所有项目的*自然顺序*。我们现在可以实现自己的`struct
    todo_item`，并给它一个优先级数字和一个待办描述字符串，然后实现比较运算符`<`以使它们可排序。或者，我们可以使用`std::pair`，它使我们能够将两个东西聚合在一个类型中，并为我们自动实现比较。
- en: '[PRE138]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: We now have a new type `item_type`, which consists of an integer priority and
    a string description. So, let's instantiate a priority queue, which maintains
    such items.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在有了一个新类型`item_type`，它由整数优先级和字符串描述组成。因此，让我们实例化一个优先级队列，其中包含这样的项目。
- en: '[PRE139]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: We will now fill the priority queue with different items which have different
    priorities. The goal is to provide an *unstructured* list, and then the priority
    queue tells us *what* to do in *which order*. If there are comics to read, and
    homework to do, of course, the homework must be done first. Unfortunately, `std::priority_queue`
    has no constructor, which accepts the initializer lists, which we can use to fill
    the queue from the beginning on. (With a vector or a normal list, it would have
    worked that way.) So we first define the list and insert it in the next step.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将用不同优先级的不同项目填充优先级队列。目标是提供一个*无结构*的列表，然后优先级队列告诉我们以*哪种顺序*做*什么*。如果有漫画要读，还有作业要做，当然，作业必须先做。不幸的是，`std::priority_queue`没有接受初始化列表的构造函数，我们可以用它来从一开始就填充队列。（使用向量或普通列表，它会按照这种方式工作。）所以我们首先定义列表，然后在下一步中插入它。
- en: '[PRE140]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: We can now comfortably iterate through the unordered list of to-do items and
    insert them step by step using the `push` function.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以舒适地遍历待办事项的无序列表，并使用`push`函数逐步插入它们。
- en: '[PRE141]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: All items are implicitly sorted, and therefore we have a queue which gives us
    out items with the highest priority.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有项目都被隐式排序，因此我们有一个队列，它给我们最高优先级的项目。
- en: '[PRE142]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Let's compile and run our program. Indeed, it tells us, to do our homework first,
    and after washing the dishes, we can finally watch TV and read comics.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译并运行我们的程序。确实，它告诉我们，首先做家庭作业，洗完碗后，我们最终可以看电视和看漫画。
- en: '[PRE143]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: How it works...
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `std::priority` list is very easy to use. We have only used three functions:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::priority`列表非常容易使用。我们只使用了三个函数：'
- en: The `q.push(item)` pushes an item into the queue.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`q.push(item)`将项目推入队列。'
- en: The `q.top()` returns a reference to the item which is coming out of the queue
    first.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`q.top()`返回队列中首先出队的项目的引用。'
- en: The `q.pop()` removes the frontmost item in the queue.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`q.pop()`移除队列中最前面的项目。'
- en: But how did the item ordering work? We grouped a priority integer and a to-do
    item description string into an `std::pair` and got automatic ordering. If we
    have an `std::pair<int, std::string>` instance `p`, we can write `p.first` to
    access the *integer* part, and `p.second` to access the *string* part. We did
    that in the loop which prints out all to-do items.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 但是项目的排序是如何工作的？我们将优先级整数和待办事项描述字符串分组到一个`std::pair`中，并获得自动排序。如果我们有一个`std::pair<int,
    std::string>`实例`p`，我们可以写`p.first`来访问*整数*部分，`p.second`来访问*字符串*部分。我们在循环中做到了这一点，打印出所有的待办事项。
- en: But how did the priority queue infer that `{2, "do homework"}` is *more important*
    than `{0, "watch tv"}`, without us telling it to compare the numeric part?
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，优先队列是如何推断出`{2, "做家庭作业"}`比`{0, "看电视"}`更重要的，而不是我们告诉它比较数字部分？
- en: The comparison operator `<` handles different cases. Let's assume we compare
    `left < right` and `left` and `right` are pairs.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符`<`处理不同的情况。假设我们比较`left < right`，`left`和`right`是一对。
- en: The `left.first != right.first`, then it returns `left.first < right.first`.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`left.first != right.first`，然后返回`left.first < right.first`。'
- en: The `left.first == right.first`, then it returns `left.second < right.second`.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`left.first == right.first`，然后返回`left.second < right.second`。'
- en: This way, we can order the items as we need. The only important thing is that
    the priority is the *first* member of the pair, and the description is the *second*
    member of the pair. Otherwise, `std::priority_queue` would order the items in
    a way where it looks like the alphabetic order of the items is more important
    than their priorities. (In that case, *watch TV* would be suggested as the *first*
    thing to do, and *do homework* some time *later*. That would at least be great
    for those of us who are lazy!)
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以按需订购物品。唯一重要的是，优先级是对的成员，描述是对的*第二*成员。否则，`std::priority_queue`会以一种看起来字母顺序比优先级更重要的方式对项目进行排序。（在这种情况下，*看电视*会被建议作为*第一*件事情做，*做家庭作业*稍后一些时间。这对于我们这些懒惰的人来说至少是很好的！）
