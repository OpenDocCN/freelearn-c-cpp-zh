["```cpp\n#pragma once \n#include <SDL/SDL.h> \n#include <GL/glew.h> \n#include <string> \n```", "```cpp\nnamespace BookEngine\n{ \n  enum WindowFlags //Used for bitwise passing  \n  { \n    INVISIBLE = 0x1, \n    FULLSCREEN = 0x2, \n    BORDERLESS = 0x4 \n  }; \n```", "```cpp\nclass Window \n  { \n  public: \n    Window(); \n    ~Window(); \n```", "```cpp\nint Create(std::string windowName, int screenWidth, int \nscreenHeight, unsigned int currentFlags);\n```", "```cpp\nint GetScreenWidth() { return m_screenWidth; } \nint GetScreenHeight() { return m_screenHeight; } \n```", "```cpp\nvoid SwapBuffer(); \n```", "```cpp\nprivate: \n    SDL_Window* m_SDL_Window; \n    int m_screenWidth; \n    int m_screenHeight; \n  }; \n} \n```", "```cpp\n#include \"\"Window.h\"\" \n#include \"\"Exception.h\"\" \n#include \"\"Logger.h\"\" \nnamespace BookEngine \n{ \n  Window::Window() \n  { \n  } \n  Window::~Window() \n  { \n  } \n```", "```cpp\n  int Window::Create(std::string windowName, int screenWidth, int \n screenHeight, unsigned int currentFlags) \n  { \n    Uint32 flags = SDL_WINDOW_OPENGL; \n    if (currentFlags & INVISIBLE) \n    { \n      flags |= SDL_WINDOW_HIDDEN; \n    } \n    if (currentFlags & FULLSCREEN) \n    { \n      flags |= SDL_WINDOW_FULLSCREEN_DESKTOP; \n    } \n    if (currentFlags & BORDERLESS) \n    { \n      flags |= SDL_WINDOW_BORDERLESS; \n    } \n```", "```cpp\ntry { \n      //Open an SDL window \n      m_SDL_Window = SDL_CreateWindow(windowName.c_str(), \n              SDL_WINDOWPOS_CENTERED, \n              SDL_WINDOWPOS_CENTERED, \n              screenWidth, \n              screenHeight, \n              flags); \n```", "```cpp\nif (m_SDL_Window == nullptr) \n    throw Exception(\"\"SDL Window could not be created!\"\"); \n```", "```cpp\n//Set up our OpenGL context \nSDL_GLContext glContext = SDL_GL_CreateContext(m_SDL_Window); \n   if (glContext == nullptr) \n     throw Exception(\"\"SDL_GL context could not be created!\"\"); \n```", "```cpp\n//Set up GLEW (optional) \nGLenum error = glewInit(); \n  if (error != GLEW_OK) \n    throw Exception(\"\"Could not initialize glew!\"\"); \n```", "```cpp\n//print some log info \nstd::string versionNumber = (const \nchar*)glGetString(GL_VERSION);      \nWriteLog(LogType::RUN, \"\"*** OpenGL Version: \"\" + \nversionNumber + \"\"***\"\");\n```", "```cpp\n//Set the background color to blue \nglClearColor(0.0f, 0.0f, 1.0f, 1.0f); \n```", "```cpp\n//Enable VSYNC \nSDL_GL_SetSwapInterval(1);\n```", "```cpp\n //Enable alpha blend \n glEnable(GL_BLEND); \n glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); \n} \n```", "```cpp\ncatch (Exception e) \n { \n    //Write Log \n    WriteLog(LogType::ERROR, e.reason); \n  } \n  } \n```", "```cpp\nvoid Window::SwapBuffer() \n { \n   SDL_GL_SwapWindow(m_SDL_Window); \n } \n} \n```", "```cpp\n#pragma once \n#include <unordered_map> \n#include <glm/glm.hpp> \nnamespace BookEngine { \n  class InputManager \n  { \n  public: \n    InputManager(); \n    ~InputManager(); \n```", "```cpp\nvoid Update(); \nvoid KeyPress(unsigned int keyID);  \nvoid KeyRelease(unsigned int keyID);\n```", "```cpp\n bool isKeyDown(unsigned int keyID); //Returns true if key is \n held    bool isKeyPressed(unsigned int keyID); //Returns true if key \n was pressed this update\n```", "```cpp\nvoid SetMouseCoords(float x, float y); \nglm::vec2 GetMouseCoords() const { return m_mouseCoords; }; \n```", "```cpp\nprivate: \n   bool WasKeyDown(unsigned int keyID); \nstd::unordered_map<unsigned int, bool> m_keyMap; \n   std::unordered_map<unsigned int, bool> m_previousKeyMap; \n   glm::vec2 m_mouseCoords;\n}; \n```", "```cpp\nnamespace BookEngine \n{ \n  InputManager::InputManager() : m_mouseCoords(0.0f) \n  { \n  } \n  InputManager::~InputManager() \n  { \n  } \n```", "```cpp\nvoid InputManager::Update() \n { \n   for (auto& iter : m_keyMap) \n   { \n     m_previousKeyMap[iter.first] = iter.second;  \n   } \n } \n```", "```cpp\nvoid InputManager::KeyPress(unsigned int keyID) \n { \n   m_keyMap[keyID] = true; \n } \n. We do the same for the KeyRelease function below. \n void InputManager::KeyRelease(unsigned int keyID) \n { \n   m_keyMap[keyID] = false; \n  } \n```", "```cpp\nbool InputManager::isKeyDown(unsigned int keyID) \n { \n   auto key = m_keyMap.find(keyID); \n   if (key != m_keyMap.end()) \n     return key->second;   // Found the key \n   return false; \n }\n```", "```cpp\nbool InputManager::isKeyPressed(unsigned int keyID) \n { \n   if(isKeyDown(keyID) && !m_wasKeyDown(keyID)) \n   { \n     return true; \n   } \n   return false; \n } \n```", "```cpp\nbool InputManager::WasKeyDown(unsigned int keyID) \n { \n   auto key = m_previousKeyMap.find(keyID); \n   if (key != m_previousKeyMap.end()) \n     return key->second;   // Found the key \n   return false; \n} \n```", "```cpp\nvoid InputManager::SetMouseCoords(float x, float y) \n { \n   m_mouseCoords.x = x; \n   m_mouseCoords.y = y; \n } \n}\n```", "```cpp\n#pragma once \n#include <memory> \n#include \"\"BookEngine.h\"\" \n#include \"\"Window.h\"\" \n#include \"\"InputManager.h\"\" \n#include \"\"ScreenList.h\"\" \nnamespace BookEngine \n{ \n```", "```cpp\nclass IGame \n  { \n  public: \n    IGame(); \n    virtual ~IGame(); \n```", "```cpp\n    void Run(); \n    void ExitGame(); \n```", "```cpp\n    virtual void OnInit() = 0; \n    virtual void OnExit() = 0; \n    virtual void AddScreens() = 0; \n```", "```cpp\nvoid OnSDLEvent(SDL_Event& event);\n```", "```cpp\nconst float GetFPS() const { return m_fps; } \n```", "```cpp\nprotected: \n   bool Init(); \n   virtual void Update(); \n   virtual void Draw(); \n```", "```cpp\n    std::unique_ptr<ScreenList> m_screenList = nullptr; \n    IGameScreen* m_currentScreen = nullptr; \n    Window m_window; \n    InputManager m_inputManager; \n    bool m_isRunning = false; \n    float m_fps = 0.0f; \n  }; \n} \n```", "```cpp\n#include \"\"IGame.h\"\" \n#include \"\"IScreen.h\"\" \n#include \"\"ScreenList.h\"\" \n#include \"\"Timing.h\"\" \nnamespace BookEngine \n{ \n  IGame::IGame() \n  { \n    m_screenList = std::make_unique<ScreenList>(this); \n  } \n\n  IGame::~IGame() \n  { \n  } \n```", "```cpp\nvoid IGame::Run() \n  { \n    if (!Init()) \n      return; \n    FPSLimiter fpsLimiter; \n    fpsLimiter.SetMaxFPS(60.0f); \n    m_isRunning = true; \n```", "```cpp\n///Game Loop \n    while (m_isRunning) \n    { \n      fpsLimiter.Begin(); \n      m_inputManager.Update(); \n      Update(); \n      Draw(); \n      m_fps = fpsLimiter.End(); \n      m_window.SwapBuffer(); \n    } \n  } \n```", "```cpp\nvoid IGame::ExitGame() \n { \n   m_currentScreen->OnExit(); \n   if (m_screenList) \n   { \n     m_screenList->Destroy(); \n     m_screenList.reset(); //Free memory \n   } \n   m_isRunning = false; \n } \n```", "```cpp\n  bool IGame::Init() \n  { \n    BookEngine::Init(); \n    SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1); \n    m_window.Create(\"\"BookEngine\"\", 1024, 780, 0); \n    OnInit(); \n    AddScreens(); \n    m_currentScreen = m_screenList->GetCurrentScreen(); \n    m_currentScreen->OnEntry();     \n    m_currentScreen->Run(); \n    return true; \n}\n```", "```cpp\nvoid IGame::Update() \n  { \n    if (m_currentScreen) \n    { \n      switch (m_currentScreen->GetScreenState()) \n      { \n      case ScreenState::RUNNING: \n        m_currentScreen->Update(); \n        break; \n      case ScreenState::CHANGE_NEXT: \n        m_currentScreen->OnExit(); \n        m_currentScreen = m_screenList->MoveToNextScreen(); \n        if (m_currentScreen) \n        { \n          m_currentScreen->Run(); \n          m_currentScreen->OnEntry(); \n        } \n        break; \n      case ScreenState::CHANGE_PREVIOUS: \n        m_currentScreen->OnExit(); \n        m_currentScreen = m_screenList->MoveToPreviousScreen(); \n        if (m_currentScreen) \n        { \n          m_currentScreen->Run(); \n          m_currentScreen->OnEntry(); \n        } \n        break; \n      case ScreenState::EXIT_APP: \n          ExitGame(); \n          break; \n      default: \n          break; \n      } \n    } \n    else \n    { \n      //we have no screen so exit \n      ExitGame(); \n    } \n  }\n```", "```cpp\nvoid IGame::Draw() \n  { \n    //For safety \n    glViewport(0, 0, m_window.GetScreenWidth(), m_window.GetScreenHeight()); \n\n    //Check if we have a screen and that the screen is running \n    if (m_currentScreen && \n      m_currentScreen->GetScreenState() == ScreenState::RUNNING) \n    { \n      m_currentScreen->Draw(); \n    } \n  } \n```", "```cpp\n  void IGame::OnSDLEvent(SDL_Event & event) \n  { \n    switch (event.type) { \n    case SDL_QUIT: \n      m_isRunning = false; \n      break; \n    case SDL_MOUSEMOTION: \n      m_inputManager.SetMouseCoords((float)event.motion.x, \n(float)event.motion.y); \n      break; \n    case SDL_KEYDOWN: \n      m_inputManager.KeyPress(event.key.keysym.sym); \n      break; \n    case SDL_KEYUP: \n      m_inputManager.KeyRelease(event.key.keysym.sym); \n      break; \n    case SDL_MOUSEBUTTONDOWN: \n      m_inputManager.KeyPress(event.button.button); \n      break; \n    case SDL_MOUSEBUTTONUP: \n      m_inputManager.KeyRelease(event.button.button); \n      break; \n    } \n  } \n}\n```", "```cpp\n#pragma once \n#include <BookEngine/IGame.h> \n#include \"\"GamePlayScreen.h\"\" \nclass App : public BookEngine::IGame \n{ \npublic: \n  App(); \n  ~App(); \n  virtual void OnInit() override; \n  virtual void OnExit() override; \n  virtual void AddScreens() override; \nprivate: \n  std::unique_ptr<GameplayScreen> m_gameplayScreen = nullptr; \n}; \n```", "```cpp\n#include <BookEngine/IGame.h> \n#include \"\"App.h\"\" \nint main(int argc, char** argv) \n{ \n  App app; \n  app.Run(); \n  return 0; \n} \n```"]