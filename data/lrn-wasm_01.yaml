- en: What is WebAssembly?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是WebAssembly？
- en: '**WebAssembly** (**Wasm**) represents an important stepping stone for the web
    platform. Enabling a developer to run compiled code on the web without a plugin
    or browser lock-in presents many new opportunities. Some confusion exists about
    what WebAssembly is, as does some skepticism about its staying power.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebAssembly**（**Wasm**）代表了Web平台的一个重要里程碑。使开发人员能够在Web上运行编译后的代码，而无需插件或浏览器锁定，带来了许多新的机会。关于WebAssembly是什么以及对其持续能力的一些怀疑，存在一些混淆。'
- en: In this chapter, we will discuss how WebAssembly came to be, what WebAssembly
    is with regard to the official definition, and the technologies it encompasses. The
    potential use cases, supported languages, and limitations will be covered, as
    well as where to find additional information.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论WebAssembly的产生过程，WebAssembly在官方定义方面的含义以及它所涵盖的技术。将涵盖潜在的用例、支持的语言和局限性，以及如何找到额外的信息。
- en: 'Our goal for this chapter is to understand the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章的目标是了解以下内容：
- en: The technologies that led the way for WebAssembly
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为WebAssembly铺平道路的技术
- en: What WebAssembly is and some of its potential use cases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly是什么以及它的一些潜在用例
- en: Which programming languages can be used with WebAssembly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以与WebAssembly一起使用的编程语言
- en: The current limitations of WebAssembly
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly的当前局限性
- en: How WebAssembly relates to Emscripten and asm.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly与Emscripten和asm.js的关系
- en: The road to WebAssembly
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通往WebAssembly的道路
- en: Web development has had an interesting history, to say the least. Several (failed)
    attempts have been made to expand the platform to support different languages. Clunky
    solutions such as plugins failed to stand the test of time, and limiting a user
    to a single browser is a recipe for disaster.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，Web开发有一个有趣的历史。已经进行了几次（失败的）尝试来扩展平台以支持不同的语言。诸如插件之类的笨拙解决方案未能经受住时间的考验，而将用户限制在单个浏览器上则是一种灾难的预兆。
- en: 'WebAssembly was developed as an elegant solution to a problem that has existed
    since browsers were first able to execute code: *If you want to develop for the
    web, you have to use JavaScript*. Fortunately, using JavaScript doesn''t have
    the same negative connotations it had back in the early 2000s, but it continues
    to have certain limitations as a programming language. In this section, we''re
    going to discuss the technologies that led to WebAssembly to get a better grasp
    of why this new technology is needed.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly作为一个优雅的解决方案，解决了自从浏览器能够执行代码以来一直存在的问题：*如果你想为Web开发，你必须使用JavaScript*。幸运的是，使用JavaScript并没有像在2000年代初那样带有负面含义，但它作为一种编程语言仍然有一定的局限性。在本节中，我们将讨论导致WebAssembly出现的技术，以更好地理解为什么需要这种新技术。
- en: The evolution of JavaScript
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript的演变
- en: JavaScript was created by Brendan Eich in just 10 days back in 1995\. Originally
    seen as a *toy* language by programmers, it was used primarily to make buttons
    flash or banners appear on a web page. The last decade has seen JavaScript evolve
    from a toy to a platform with profound capabilities and a massive following.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是由Brendan Eich在1995年的短短10天内创建的。最初被程序员视为一种*玩具*语言，主要用于在网页上制作按钮闪烁或横幅出现。过去的十年里，JavaScript已经从一个玩具演变成了一个具有深远能力和庞大追随者的平台。
- en: 'In 2008 heavy competition in the browser market resulted in the addition of
    **just-in-time** (**JIT**) compilers, which increased the execution speed of JavaScript
    by a factor of 10\. Node.js debuted in 2009 and represented a paradigm shift in
    web development. Ryan Dahl combined Google''s V8 JavaScript engine, an event loop,
    and a low-level I/O API to build a platform that allowed for the use of JavaScript
    across the server and client side. Node.js led to `npm`, a package manager that
    allowed for the development of libraries to be used within the Node.js ecosystem.
    As of the time of writing, there are over 600,000 packages available with hundreds
    being added every day:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年，浏览器市场的激烈竞争导致了**即时**（**JIT**）编译器的添加，这提高了JavaScript的执行速度10倍。Node.js于2009年首次亮相，代表了Web开发的范式转变。Ryan
    Dahl结合了谷歌的V8 JavaScript引擎、事件循环和低级I/O API，构建了一个平台，允许在服务器和客户端使用JavaScript。Node.js导致了`npm`，这是一个允许在Node.js生态系统内使用的库的包管理器。截至撰写本文时，有超过60万个可用的包，每天都有数百个包被添加：
- en: '![](img/d473abb9-dda2-4db0-acfb-0a63607c8190.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d473abb9-dda2-4db0-acfb-0a63607c8190.png)'
- en: Package count growth on npm since 2012, taken from Modulecounts
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 自2012年以来npm包数量的增长，来自Modulecounts
- en: It's not just the Node.js ecosystem that is growing; JavaScript itself is being
    actively developed. The ECMA **Technical Committee 39** (**TC39**), which dictates
    the standards for JavaScript and oversees the addition of new language features,
    releases *yearly* updates to JavaScript with a community-driven proposal process.
    Between its wealth of libraries and tooling, constant improvements to the language,
    and possessing one of the largest communities of programmers, JavaScript has become
    a force to be reckoned with.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅是Node.js生态系统在增长；JavaScript本身也在积极发展。ECMA **技术委员会39**（**TC39**）规定了JavaScript的标准，并监督新语言特性的添加，每年发布一次JavaScript的更新，采用社区驱动的提案流程。凭借其丰富的库和工具、对语言的不断改进以及拥有最庞大的程序员社区之一，JavaScript已经成为一个不可忽视的力量。
- en: 'But the language does have some shortcomings:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这种语言确实有一些缺点：
- en: Up until recently, JavaScript only included 64-bit floating point numbers. This
    can cause issues with very large or very small numbers. `BigInt`, a new numeric
    primitive that can alleviate some of these issues, is in the the process of being
    added to the ECMAScript specification, but it may take some time until it's fully
    supported in browsers.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直到最近，JavaScript只包括64位浮点数。这可能会导致非常大或非常小的数字出现问题。`BigInt`是一种新的数值原语，可以缓解一些这些问题，正在被添加到ECMAScript规范中，但可能需要一些时间才能在浏览器中得到完全支持。
- en: JavaScript is weakly typed, which adds to its flexibility, but can cause confusion
    and bugs. It essentially gives you enough rope to hang yourself.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript是弱类型的，这增加了它的灵活性，但可能会导致混淆和错误。它基本上给了你足够的绳子来绞死自己。
- en: JavaScript isn't as performant as compiled languages despite the best efforts
    of the browser vendors.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管浏览器供应商尽最大努力，但JavaScript并不像编译语言那样高效。
- en: If a developer wants to create a web application, they need to learn JavaScript—whether
    they like it or not.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果开发人员想要创建Web应用程序，他们需要学习JavaScript——不管他们喜不喜欢。
- en: To avoid having to write more than a few lines of JavaScript, some developers
    built **transpilers** to convert other languages to JavaScript. Transpilers (or
    source-to-source compilers) are types of compilers that convert source code in
    one programming language to equivalent source code in another programming language.
    TypeScript, which is a popular tool for frontend JavaScript development, transpiles
    TypeScript to valid JavaScript targeted for browsers or Node.js. Pick any programming
    language and there's a good chance that someone created a JavaScript transpiler
    for it. For example, if you prefer to write Python, you have about 15 different
    tools that you can use to generate JavaScript. In the end, though, it's still
    JavaScript, so you're still subject to the idiosyncrasies of the language.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免编写超过几行JavaScript，一些开发人员构建了**转译器**，将其他语言转换为JavaScript。转译器（或源到源编译器）是一种将一种编程语言的源代码转换为另一种编程语言等效源代码的编译器。TypeScript是前端JavaScript开发的流行工具，将TypeScript转译为针对浏览器或Node.js的有效JavaScript。选择任何编程语言，都有很大可能有人为其创建了JavaScript转译器。例如，如果你喜欢编写Python，你有大约15种不同的工具可以用来生成JavaScript。但最终，它仍然是JavaScript，因此你仍然受到该语言的特殊性的影响。
- en: As the web evolved into a valid platform for building and distributing applications,
    more and more complex and resource-intensive applications were created. In order
    to meet the demands of these applications, browser vendors began working on new
    technologies to integrate into their software without disrupting the normal course
    of web development. Google and Mozilla, creators of Chrome and Firefox, respectively,
    took two different paths to achieve this goal, culminating in the creation of
    WebAssembly.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Web逐渐成为构建和分发应用程序的有效平台，越来越复杂和资源密集型的应用程序被创建。为了满足这些应用程序的需求，浏览器供应商开始研发新技术，将其集成到软件中，而不会干扰Web开发的正常进程。谷歌和Mozilla分别是Chrome和Firefox的创建者，他们采取了两种不同的路径来实现这一目标，最终形成了WebAssembly。
- en: Google and Native Client
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谷歌和Native Client
- en: Google developed **Native Client** (**NaCl**) with the intent to safely run
    native code within a web browser. The executable code would run in a **sandbox**
    and offered the performance advantages of native code execution.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌开发了**Native Client**（**NaCl**），旨在安全地在Web浏览器中运行本机代码。可执行代码将在**沙盒**中运行，并提供本机代码执行的性能优势。
- en: In the context of software development, a sandbox is an environment that prevents
    executable code from interacting with other parts of your system. It is intended
    to prevent the spread of malicious code and place restrictions on what software
    can do.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的背景下，沙盒是一个环境，防止可执行代码与系统的其他部分进行交互。它旨在防止恶意代码的传播，并对软件的操作进行限制。
- en: 'NaCl was tied to a specific architecture, while **Portable Native Client**
    (**PNaCl**) was an architecture-independent version of NaCl developed to run on
    any platform. The technology consisted of two elements:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: NaCl与特定架构相关，而**Portable Native Client**（**PNaCl**）是NaCl的独立于架构的版本，可在任何平台上运行。该技术由两个元素组成：
- en: Toolchains which could transform C/C++ code to NaCl modules
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将C/C++代码转换为NaCl模块的工具链
- en: 'Runtime components which were components embedded in the browser that allowed
    execution of NaCl modules:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时组件是嵌入在浏览器中的组件，允许执行NaCl模块：
- en: '![](img/ee7ab5c5-f671-4caa-8073-2c3ef941c399.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee7ab5c5-f671-4caa-8073-2c3ef941c399.png)'
- en: The Native Client toolchains and their outputs
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本机客户端工具链及其输出
- en: 'NaCl''s architecture-specific executable (`nexe`) was limited to applications
    and extensions that were installed from Google''s Chrome Web Store, but PNaCl
    executables (`pexe`) can be freely distributed on the web and embedded in web
    applications. Portability was made possible with Pepper, an open source API for
    creating NaCl modules, and its corresponding plugin API (PPAPI). Pepper enabled
    communication between NaCl modules and the hosting browser, and allowed for access
    to system-level functions in a safe and portable way. Applications could be easily
    distributed by including a manifest file and a compiled module (`pexe`) with the
    corresponding HTML, CSS, and JavaScript:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: NaCl的特定架构可执行文件（`nexe`）仅限于从谷歌Chrome Web商店安装的应用程序和扩展，但PNaCl可执行文件（`pexe`）可以在Web上自由分发并嵌入Web应用程序中。Pepper使得可移植性成为可能，Pepper是用于创建NaCl模块的开源API，以及其相应的插件API（PPAPI）。Pepper实现了NaCl模块与托管浏览器之间的通信，并以安全和可移植的方式访问系统级功能。通过包含清单文件和已编译模块（`pexe`）以及相应的HTML、CSS和JavaScript，应用程序可以轻松分发：
- en: '![](img/0a230248-b946-4f66-b811-ff2530fc48d1.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a230248-b946-4f66-b811-ff2530fc48d1.png)'
- en: Pepper's role in a Native Client application
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Pepper在本机客户端应用程序中的作用
- en: NaCl offered promising opportunities to overcome the performance limitations
    of the web, but it had some drawbacks. Although Chrome had built-in support for
    PNaCl executables and Pepper, other major browser did not. Detractors of the technology
    took issue with the black-box nature of the applications as well as the potential
    security risks and complexity.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: NaCl提供了克服Web性能限制的有希望的机会，但也有一些缺点。尽管Chrome内置支持PNaCl可执行文件和Pepper，其他主要浏览器却没有。技术的反对者对应用程序的黑盒性质以及潜在的安全风险和复杂性表示了异议。
- en: Mozilla focused its efforts on improving the performance of JavaScript with
    `asm.js`. They wouldn't add support for Pepper to Firefox due to the incompleteness
    of its API specification and limited documentation. In the end, NaCl was deprecated
    in May, 2017, in favor of WebAssembly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla致力于改进JavaScript的性能，使用`asm.js`。由于API规范的不完整和文档有限，他们不会为Firefox添加对Pepper的支持。最终，NaCl于2017年5月被弃用，改为支持WebAssembly。
- en: Mozilla and asm.js
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mozilla和asm.js
- en: Mozilla debuted `asm.js` in 2013 and provided a way for developers to translate
    their C and C++ source code to JavaScript. The official specification for `asm.js`
    defines it as a strict subset of JavaScript that can be used as a low-level, efficient
    target language for compilers. It's still valid JavaScript, but the language features
    are limited to those that are amenable to **ahead-of-time** (**AOT**) optimization. AOT is
    a technique that the browser's JavaScript engine uses to execute code more efficiently
    by compiling it down to native machine code. `asm.js` achieves these performance
    gains by having 100% type consistency and manual memory management.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla于2013年推出了`asm.js`，并为开发人员提供了一种将其C和C++源代码转换为JavaScript的方法。`asm.js`的官方规范将其定义为JavaScript的严格子集，可用作编译器的低级高效目标语言。它仍然是有效的JavaScript，但语言特性仅限于适合**提前**（**AOT**）优化的特性。AOT是浏览器的JavaScript引擎用来通过将其编译为本机机器代码来更有效地执行代码的技术。`asm.js`通过具有100%类型一致性和手动内存管理来实现这些性能增益。
- en: Using a tool such as Emscripten, C/C++ code can be transpiled down to `asm.js`
    and easily distributed using the same means as normal JavaScript. Accessing the
    functions in an `asm.js` module requires **linking**, which involves calling its
    function to obtain an object with the module's exports.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Emscripten等工具，C/C++代码可以被转译成`asm.js`，并且可以使用与普通JavaScript相同的方式进行分发。访问`asm.js`模块中的函数需要**链接**，这涉及调用其函数以获取具有模块导出的对象。
- en: '`asm.js` is incredibly flexible, however, certain interactions with the module
    can cause a loss of performance. For example, if an `asm.js` module is given access
    to a custom JavaScript function that fails dynamic or static validation, the code
    can''t take advantage of AOT and falls back to the interpreter:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`asm.js`非常灵活，但是与模块的某些交互可能会导致性能损失。例如，如果`asm.js`模块被赋予访问自定义JavaScript函数的权限，而该函数未通过动态或静态验证，代码就无法利用AOT并会退回到解释器：'
- en: '![](img/3b40bcf8-0a50-4ed5-806e-3f3a5f64679a.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b40bcf8-0a50-4ed5-806e-3f3a5f64679a.png)'
- en: The asm.js AOT compilation workflow
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`asm.js`的AOT编译工作流程'
- en: '`asm.js` isn''t just a stepping stone. It forms the basis for WebAssembly''s
    **Minimum Viable Product** (**MVP**). The official WebAssembly site explicitly
    mentions `asm.js` in the section entitled *WebAssembly High-Level Goals*.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`asm.js`不仅仅是一个过渡阶段。它构成了WebAssembly的**最小可行产品**（**MVP**）的基础。官方WebAssembly网站在标题为*WebAssembly高级目标*的部分明确提到了`asm.js`。'
- en: So why create WebAssembly when you could use `asm.js`? Aside from the potential
    performance loss, an `asm.js` module is a text file that must be transferred over
    the network before any compilation can take place. A WebAssembly module is in
    a binary format, which makes it much more efficient to transfer due to its smaller
    size.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么要创建WebAssembly而不使用`asm.js`呢？除了潜在的性能损失外，`asm.js`模块是一个必须在编译之前通过网络传输的文本文件。WebAssembly模块是以二进制格式，这使得由于其较小的大小而更加高效地传输。
- en: WebAssembly modules use a promise-based approach to instantiation, which takes
    advantage of modern JavaScript and eliminates the need for any *is this loaded*
    *yet?* code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly模块使用基于promise的实例化方法，利用现代JavaScript并消除了任何*这个加载了吗*的代码。
- en: WebAssembly is born
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly的诞生
- en: The **World Wide Web Consortium** (**W3C**), an international community built
    to develop web standards, formed the WebAssembly Working Group in April, 2015,
    to standardize WebAssembly and oversee the specification and proposal process. Since
    then, the *Core Specification* and corresponding *JavaScript API* and *Web API*
    have been released. The initial implementation of WebAssembly support in browsers
    was based on the feature set of `asm.js`. WebAssembly's binary format and corresponding
    `.wasm` file combined facets of `asm.js` output with PNaCl's concept of a distributed
    executable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**万维网联盟**（**W3C**）是一个致力于制定Web标准的国际社区，于2015年4月成立了WebAssembly工作组，以标准化WebAssembly并监督规范和提案过程。自那时起，*核心规范*和相应的*JavaScript
    API*和*Web API*已经发布。浏览器中对WebAssembly支持的初始实现是基于`asm.js`的功能集。WebAssembly的二进制格式和相应的`.wasm`文件结合了`asm.js`输出的特征和PNaCl的分布式可执行概念。'
- en: 'So how will WebAssembly succeed where NaCl failed? According to Dr. Axel Rauschmayer,
    there are three reasons detailed at [http://2ality.com/2015/06/web-assembly.html#what-is-different-this-time](http://2ality.com/2015/06/web-assembly.html#what-is-different-this-time):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么WebAssembly将如何成功，而NaCl失败了呢？根据Axel Rauschmayer博士的说法，详细原因在[http://2ality.com/2015/06/web-assembly.html#what-is-different-this-time](http://2ality.com/2015/06/web-assembly.html#what-is-different-this-time)中有三个原因。
- en: '"First, this is a collaborative effort, no single company goes it alone. At
    the moment, the following projects are involved: Firefox, Chromium, Edge and WebKit.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: “首先，这是一个协作努力，没有任何一家公司单独进行。目前，涉及的项目有：Firefox，Chromium，Edge和WebKit。
- en: Second, the interoperability with the web platform and JavaScript is excellent.
    Using WebAssembly code from JavaScript will be as simple as importing a module.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，与Web平台和JavaScript的互操作性非常出色。从JavaScript中使用WebAssembly代码将像导入模块一样简单。
- en: Third, this is not about replacing JavaScript engines, it is more about adding
    a new feature to them. That greatly reduces the amount of work to implement WebAssembly
    and should help with getting the support of the web development community."
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，这不是要取代JavaScript引擎，而是要为它们增加一个新功能。这大大减少了实现WebAssembly的工作量，并有助于获得Web开发社区的支持。”
- en: - Dr. Axel Rauschmayer
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '- Dr. Axel Rauschmayer'
- en: What exactly is WebAssembly and where can I use it?
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly到底是什么，我在哪里可以使用它？
- en: WebAssembly has a succinct and descriptive definition on the official site,
    but it's only a piece of the puzzle. There are several other components that fall
    under the umbrella of WebAssembly. Understanding the role each component plays
    will give you a better understanding of the technology as a whole. In this section,
    we will provide a detailed breakdown of WebAssembly's definition and describe
    potential use cases.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly在官方网站上有一个简明扼要的定义，但这只是一个部分。WebAssembly还有其他几个组件。了解每个组件的作用将让您更好地理解整个技术。在本节中，我们将详细解释WebAssembly的定义，并描述潜在的用例。
- en: Official definition
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 官方定义
- en: 'The official WebAssembly website ([https://webassembly.org](https://webassembly.org))
    offers this definition:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的WebAssembly网站（[https://webassembly.org](https://webassembly.org)）提供了这个定义：
- en: Wasm is a binary instruction format for a stack-based virtual machine. Wasm
    is designed as a portable target for compilation of high-level languages like
    C/C++/Rust, enabling deployment on the web for client and server applications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Wasm是一种基于堆栈的虚拟机的二进制指令格式。Wasm被设计为高级语言（如C/C++/Rust）的可移植编译目标，从而可以在Web上部署客户端和服务器应用程序。
- en: Let's break that definition down into parts to add some clarification.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个定义分解成几个部分，以便更清楚地解释。
- en: Binary instruction format
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制指令格式
- en: WebAssembly actually encompasses several elements—a binary format and text format,
    which are documented in the *Core Specification*, the corresponding APIs (JavaScript
    and web), and a compilation target. The binary and text format both map to a common
    structure in the form of an **abstract syntax**. To better understand abstract
    syntax, it can be explained in the context of an **abstract syntax tree** (**AST**). An
    AST is a tree representation of the structure of source code for a programming
    language. Tools such as ESLint use JavaScript's AST to find linting errors. The
    following example contains a function and the corresponding AST for JavaScript
    (taken from [https://astexplorer.net](https://astexplorer.net)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly实际上包括几个元素——二进制格式和文本格式，这些都在*核心规范*中有文档记录，对应的API（JavaScript和Web），以及一个编译目标。二进制和文本格式都映射到一个公共结构，以**抽象语法**的形式存在。为了更好地理解抽象语法，可以在**抽象语法树**（**AST**）的上下文中解释。AST是编程语言源代码结构的树形表示。诸如ESLint之类的工具使用JavaScript的AST来查找linting错误。以下示例包含JavaScript的函数和相应的AST（来自[https://astexplorer.net](https://astexplorer.net)）。
- en: 'A simple JavaScript function follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的JavaScript函数如下：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The corresponding AST is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的AST如下：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An AST may be verbose, but it does an excellent job at describing the components
    of a program. Representing source code in an AST makes verification and compilation
    simple and efficient. WebAssembly code in text format is serialized into an AST
    and compiled to the binary format (as a `.wasm` file), which is fetched, loaded,
    and utilized by a web page. When the module is loaded, the browser's JavaScript
    engine utilizes a **decoding stack** to decode the `.wasm` file into an AST, perform
    type checking, and interpret it to execute functions. WebAssembly started as a
    binary instruction format for an AST. Due to the performance implications of verifying
    Wasm expressions that return `void`, the binary instruction format was updated
    to target a **stack machine**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: AST可能会很冗长，但它在描述程序的组件方面做得很好。在AST中表示源代码使得验证和编译变得简单高效。WebAssembly文本格式的代码被序列化为AST，然后编译为二进制格式（作为`.wasm`文件），然后被网页获取、加载和利用。模块加载时，浏览器的JavaScript引擎利用**解码堆栈**将`.wasm`文件解码为AST，执行类型检查，并解释执行函数。WebAssembly最初是用于AST的二进制指令格式。由于验证返回`void`的Wasm表达式的性能影响，二进制指令格式已更新为针对**堆栈机**。
- en: 'A stack machine consists of two elements: a stack and instructions. A stack
    is a data structure with two operations: *push* and *pop*. Items are pushed onto
    the stack and subsequently popped from the stack in **last in, first out** (**LIFO**)
    order. A stack also includes a **pointer**, which points to the item at the top
    of the stack. Instructions represent actions to perform on the items in the stack.
    For example, an `ADD` instruction might pop the top two items from the stack (the
    values `100` and `10`), and push a single item with the sum back onto the stack
    (the value `110`):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈机由两个元素组成：堆栈和指令。堆栈是一个具有两个操作的数据结构：*push*和*pop*。项目被推送到堆栈上，然后按照**后进先出**（**LIFO**）的顺序从堆栈中弹出。堆栈还包括一个**指针**，指向堆栈顶部的项目。指令表示对堆栈中项目执行的操作。例如，一个`ADD`指令可能从堆栈中弹出顶部的两个项目（值为`100`和`10`），并将总和推回到堆栈上（值为`110`）：
- en: '![](img/1e2d75b9-2021-4486-8049-726f6134410d.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e2d75b9-2021-4486-8049-726f6134410d.png)'
- en: A simple stack machine
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的堆栈机
- en: WebAssembly's stack machine operates in the same way. A program counter (pointer)
    maintains the execution position within the code and a virtual control stack keeps
    track of `blocks` and `if` constructs as they are entered (pushed) and exited
    (popped). The instructions are executed with no reference to an AST. Thus, the
    **binary instruction format** portion of the definition refers to a binary representation
    of instructions that are in a format readable by the decoding stack in the browser.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly的堆栈机操作方式相同。程序计数器（指针）维护代码中的执行位置，虚拟控制堆栈跟踪`blocks`和`if`结构的进入（推入）和退出（弹出）。指令执行时不涉及AST。因此，定义中的**二进制指令格式**部分指的是一种二进制表示的指令，这些指令可以被浏览器中的解码堆栈读取。
- en: Portable target for compilation
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可移植的编译目标
- en: WebAssembly was designed from the beginning with portability in mind. Portability
    in this context means that WebAssembly's binary format can be executed efficiently
    on a variety of operating systems and instruction set architectures, on and off
    the web. The specification for WebAssembly defines portability in the context
    of an execution environment. WebAssembly was designed to run efficiently in environments
    that meet certain characteristics, most of which are related to memory. WebAssembly's
    portability can also be attributed to the absence of a specific API around the
    core technologies. Instead, it defines an `import` mechanism where the set of
    available imports is defined by the host environment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 从一开始就考虑了可移植性。在这个上下文中，可移植性意味着 WebAssembly 的二进制格式可以在各种操作系统和指令集架构上高效地执行，无论是在
    Web 上还是离线。WebAssembly 的规范定义了执行环境中的可移植性。WebAssembly 被设计为在符合某些特征的环境中高效运行，其中大部分与内存有关。WebAssembly
    的可移植性也可以归因于核心技术周围缺乏特定的 API。相反，它定义了一个 `import` 机制，其中可用的导入集由宿主环境定义。
- en: In a nutshell, this means that WebAssembly isn't tied to a specific environment,
    such as the web or desktop. The WebAssembly Working Group has defined a *Web API*,
    but that's separate from the *Core Specification*. The *Web API* caters to WebAssembly,
    not the other way around.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这意味着 WebAssembly 不与特定环境绑定，比如 Web 或桌面。WebAssembly 工作组已经定义了一个 *Web API*，但这与
    *核心规范* 是分开的。*Web API* 适用于 WebAssembly，而不是反过来。
- en: The **compilation** aspect of the definition indicates that WebAssembly will
    be simple to compile down to its binary format from source code written in high-level
    languages. The MVP focuses on two languages, C and C++, but Rust can also be used
    given its similarities to C++. Compilation will be achieved through the use of
    a Clang/LLVM backend, although we'll be using Emscripten in this book to generate
    our Wasm modules. The plan is to eventually add support for other languages and
    compilers (such as GCC), but the MVP is focused on LLVM.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 定义中的**编译**方面表明，WebAssembly 从高级语言编写的源代码编译成其二进制格式将会很简单。MVP 关注两种语言，C 和 C++，但由于
    Rust 与 C++ 相似，也可以使用。编译将通过使用 Clang/LLVM 后端来实现，尽管在本书中我们将使用 Emscripten 生成我们的 Wasm
    模块。计划最终支持其他语言和编译器（比如 GCC），但 MVP 专注于 LLVM。
- en: The core specification
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心规范
- en: 'The official definition gives some high-level insight into the overall technology,
    but for the sake of completeness, it''s worth digging a little deeper. WebAssembly''s
    *Core Specification* is the official document to reference if you want to understand
    WebAssembly at a very granular level. If you''re interested in learning about
    the characteristics of the runtime structure with regard to the execution environment,
    check out section 4: *Execution*. We won''t cover that here, but understanding
    where the *Core Specification* fits in will help in establishing a complete definition
    of WebAssembly.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 官方定义为我们提供了对整体技术的高层洞察，但为了完整起见，值得深入挖掘一下。WebAssembly 的 *核心规范* 是官方文档，如果你想深入了解 WebAssembly，可以参考这个文档。如果你对运行时结构的特征感兴趣，可以查看第
    4 节：*执行*。我们在这里不会涉及这一点，但了解 *核心规范* 的位置将有助于建立对 WebAssembly 的完整定义。
- en: Language concepts
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语言概念
- en: 'The *Core Specification* states WebAssembly encodes a low-level, assembly-like
    programming language. The specification defines the structure, execution, and
    validation of this language as well as the details of the binary and text formats.
    The language itself is structured around the following concepts:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*核心规范* 表明 WebAssembly 编码了一种低级的、类似汇编的编程语言。规范定义了这种语言的结构、执行和验证，以及二进制和文本格式的细节。语言本身围绕以下概念构建：'
- en: '**Values**, or rather value types that WebAssembly provides'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**，或者说 WebAssembly 提供的值类型'
- en: '**Instructions** that are executed within the stack machine'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在堆栈机器内执行的**指令**
- en: '**Traps** produced under error conditions and abort execution'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在错误条件下产生的**陷阱**并中止执行
- en: '**Functions **into which code is organized, each of which takes a sequence
    of values as parameters and returns a sequence of values as a result'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**，代码组织成的函数，每个函数都以一系列值作为参数，并返回一系列值作为结果'
- en: '**Tables**, which are arrays of values of a particular element type (such as
    function references) that are selectable by the executing program'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表**，这是特定元素类型（比如函数引用）的值数组，可以被执行程序选择'
- en: '**Linear Memory**, which is an array of raw bytes that can be used to store
    and load values'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性内存**，这是一个原始字节的数组，可以用来存储和加载值'
- en: '**Modules**, WebAssembly binary (`.wasm` file) that contains function, tables,
    and linear memories'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块**，WebAssembly 二进制（`.wasm` 文件）包含函数、表和线性内存'
- en: '**Embedder**, the mechanism by which WebAssembly can be executed in a host
    environment, such as a web browser'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌入器**，WebAssembly 可以在宿主环境（比如 Web 浏览器）中执行的机制'
- en: 'Functions, tables, memory, and modules have direct correlations with the *JavaScript
    API* and are important to be aware of. These concepts describe the underlying
    structure of the language itself and how to write or encode WebAssembly. With
    regard to usage, understanding the corresponding semantic phases of WebAssembly
    provides a complete definition of the technology:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 函数、表、内存和模块与 *JavaScript API* 直接相关，对此有所了解是很重要的。这些概念描述了语言本身的基本结构以及如何编写或编码 WebAssembly。就使用而言，理解
    WebAssembly 对应的语义阶段提供了对该技术的完整定义：
- en: '![](img/52382cbb-fa93-4206-adde-c38848bf1429.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52382cbb-fa93-4206-adde-c38848bf1429.png)'
- en: Language concepts and their relationship
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 语言概念及其关系
- en: Semantic phases
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义阶段
- en: 'The *Core Specification* describes the different phases an encoded module (`.wasm`
    file) undergoes when it is being utilized in a host environment (such as a web
    browser). This aspect of the specification represents how the output is handled
    and executed:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*核心规范* 描述了编码模块（`.wasm` 文件）在宿主环境（比如 Web 浏览器）中被利用时经历的不同阶段。规范的这一方面代表了输出是如何处理和执行的：'
- en: '**Decoding**: The binary format is converted into a module'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解码**：将二进制格式转换为模块'
- en: '**Validation**: The decoded module undergoes validation checks (such as type
    checking) to ensure the module is well formed and safe'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：解码模块经过验证检查（例如类型检查），以确保模块形式良好且安全'
- en: '**Execution, Part 1: Instantiation**: A module instance, which is the dynamic
    representation of the module, is instantiated by initializing the **Globals**,
    **Memories**, and **Tables**, and invokes the module''s `start()` function'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行，第1部分：实例化**：通过初始化**全局变量**、**内存**和**表**来实例化模块实例，然后调用模块的`start()`函数'
- en: '**Execution, Part 2: Invocation**: Exported functions are called from the module
    instance:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行，第2部分：调用**：从模块实例调用导出的函数：'
- en: 'The following diagram provides a visual representation of the semantic phases:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表提供了语义阶段的可视化表示：
- en: '![](img/51755ca6-f4c7-43b3-93d3-81575523ae30.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51755ca6-f4c7-43b3-93d3-81575523ae30.png)'
- en: Semantic phases of module use
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 模块使用的语义阶段
- en: The JavaScript and Web APIs
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript和Web API
- en: The WebAssembly Working Group also released API specifications for interacting
    with JavaScript and the web, which qualifies them for inclusion in the WebAssembly
    technology space. The *JavaScript API* is scoped to the JavaScript language itself,
    without being specifically tied to an environment (for example, web browsers or
    Node.js). It defines classes, methods, and objects for interacting with WebAssembly
    and managing the compilation and instantiation processes. The *Web API* is an
    extension of the *JavaScript API* that defines functionality specific to web browsers.
    The *Web API* specification currently only defines two methods, `compileStreaming`
    and `instantiateStreaming`, which are convenience methods that simplify the use
    of Wasm modules in the browser. These will be covered in greater detail in [Chapter
    2](0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml), *Elements of WebAssembly - Wat,
    Wasm, and the JavaScript API*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly工作组还发布了与JavaScript和Web交互的API规范，使它们有资格被纳入WebAssembly技术领域。*JavaScript
    API*的范围仅限于JavaScript语言本身，而不是特定于环境（例如Web浏览器或Node.js）。它定义了用于与WebAssembly交互和管理编译和实例化过程的类、方法和对象。*Web
    API*是*JavaScript API*的扩展，定义了特定于Web浏览器的功能。*Web API*规范目前仅定义了两种方法，`compileStreaming`和`instantiateStreaming`，这些是简化在浏览器中使用Wasm模块的便利方法。这些将在[第2章](0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml)中更详细地介绍，*WebAssembly的要素
    - Wat、Wasm和JavaScript API*。
- en: So will it replace JavaScript?
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么它会取代JavaScript吗？
- en: WebAssembly's ultimate goal is not to replace JavaScript, but rather to complement
    it. JavaScript's rich ecosystem and flexibility still makes it the ideal language
    for the web. WebAssembly's JavaScript API makes interoperability between the two
    technologies relatively simple. So will you be able to build a web application
    using just WebAssembly? One of the explicit goals of WebAssembly is portability,
    and replicating all of JavaScript's functionality could inhibit that goal. However,
    the official site includes a goal to execute and integrate well with the existing
    web platform, so only time will tell. It may not be practical to write the entire
    code base in a language that compiles down to WebAssembly, but moving some of
    the application logic to Wasm modules could be beneficial in terms of performance
    and load times.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly的最终目标不是取代JavaScript，而是补充它。JavaScript丰富的生态系统和灵活性仍然使其成为Web的理想语言。WebAssembly的JavaScript
    API使得两种技术之间的互操作性相对简单。那么你是否能够只使用WebAssembly构建Web应用程序？WebAssembly的一个明确目标是可移植性，复制JavaScript的所有功能可能会阻碍该目标。然而，官方网站包括一个目标，即执行并与现有Web平台很好地集成，所以只有时间能告诉我们。在一种编译为WebAssembly的语言中编写整个代码库可能并不实际，但将一些应用程序逻辑移动到Wasm模块可能在性能和加载时间方面有益。
- en: Where can I use it?
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我可以在哪里使用它？
- en: 'WebAssembly''s official site has an extensive list of potential use cases.
    I''m not going to cover them all here, but there are several that represent significant
    enhancements to the capabilities of the web platform:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly的官方网站列出了大量潜在的用例。我不打算在这里覆盖它们所有，但有几个代表了对Web平台功能的重大增强：
- en: Image/video editing
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像/视频编辑
- en: Games
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏
- en: Music applications (streaming, caching)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音乐应用程序（流媒体、缓存）
- en: Image recognition
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像识别
- en: Live video augmentation
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时视频增强
- en: VR and augmented reality
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟现实和增强现实
- en: Although some of these use cases are technically feasible with JavaScript, HTML,
    and CSS, using WebAssembly can offer significant performance gains. Serving up
    a binary file (instead of a single JavaScript file) can greatly reduce the bundle
    size, and instantiating the Wasm module on page load speeds up code execution.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一些用例在技术上可以使用JavaScript、HTML和CSS实现，但使用WebAssembly可以带来显著的性能提升。提供一个二进制文件（而不是单个JavaScript文件）可以大大减少捆绑包大小，并且在页面加载时实例化Wasm模块可以加快代码执行速度。
- en: WebAssembly isn't just limited to the browser. Outside the browser, you could
    use it to build hybrid native apps on mobile devices or perform server-side computations
    of untrusted code. Using Wasm modules for phone apps could be incredibly beneficial
    in terms of power usage and performance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly不仅仅局限于浏览器。在浏览器之外，您可以使用它来构建移动设备上的混合本机应用程序，或者执行不受信任代码的服务器端计算。在手机应用程序中使用Wasm模块可能在功耗和性能方面非常有益。
- en: WebAssembly also offers flexibility with regard to how it can be used. You can
    write your entire code base in WebAssembly, although this may not be practical
    in its current form or in the context of a web application. Given WebAssembly's
    robust JavaScript API, you could write the UI in JavaScript/HTML and use Wasm
    modules for functionality that doesn't directly access the DOM. Once additional
    languages are supported, objects can be easily passed between the Wasm module
    and JavaScript code, which will greatly simplify integration and increase developer
    adoption.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly在使用上也提供了灵活性。你可以在WebAssembly中编写整个代码库，尽管在当前形式或Web应用程序的上下文中可能不太实际。鉴于WebAssembly的强大JavaScript
    API，你可以在JavaScript/HTML中编写UI，并使用Wasm模块来实现不直接访问DOM的功能。一旦支持了其他语言，对象就可以在Wasm模块和JavaScript代码之间轻松传递，这将大大简化集成并增加开发者的采用率。
- en: What languages are supported?
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持哪些语言？
- en: WebAssembly's high-level goals for their MVP was to provide roughly the same
    functionality as `asm.js`. The two technologies are very closely related. C, C++,
    and Rust are very popular languages that support manual memory allocation, which
    made them ideal candidates for the initial implementation. In this section, we're
    going to provide a brief overview of each programming language.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly的MVP的高级目标是提供与`asm.js`大致相同的功能。这两种技术非常相关。C、C++和Rust是非常受欢迎的支持手动内存分配的语言，这使它们成为最初实现的理想候选。在本节中，我们将简要概述每种编程语言。
- en: C and C++
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C和C++
- en: C and C++ are low-level programming languages that have been around for over
    30 years. C is procedural and doesn't inherently support object-oriented programming
    concepts such as classes and inheritance, but it's fast, portable, and widely
    used.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++是已经存在30多年的低级编程语言。C是过程化的，不本质上支持类和继承等面向对象编程概念，但它快速、可移植且被广泛使用。
- en: 'C++ was built to fill the gaps in C by adding features such as operator overloading
    and improved type checking. Both languages consistently rank in the top 10 most
    popular programming languages, which make them ideally suited for the MVP:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: C++是为了填补C的不足而构建的，它添加了诸如运算符重载和改进的类型检查等功能。这两种语言一直稳居前10最受欢迎的编程语言之列，这使它们非常适合MVP：
- en: '![](img/049542c7-ebe1-4b35-b4a1-de0ec95a532c.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/049542c7-ebe1-4b35-b4a1-de0ec95a532c.png)'
- en: TIOBE Very Long Term History of the top 10 programming languages
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: TIOBE长期历史上前10种编程语言的排名
- en: C and C++ support is also baked into Emscripten, so in addition to simplifying
    the compilation process, it allows you to take advantage of WebAssembly's full
    capabilities. It is also possible to compile C/C++ code down to a `.wasm` file
    using LLVM. LLVM is a collection of modular and reusable compiler and toolchain
    technologies. In a nutshell, it's a framework that simplifies the configuration
    of a compilation process from source code to machine code. If you made your own
    programming language and would like to build a compiler, LLVM has tools to simplify
    the process. I'll cover how to compile C/C++ into `.wasm` files using LLVM in
    [Chapter 10](93d51e00-521f-4908-ae9d-eeaecb58a01d.xhtml), *Advanced Tools and
    Upcoming Features*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++的支持也内置在Emscripten中，因此除了简化编译过程，它还允许你充分利用WebAssembly的功能。还可以使用LLVM将C/C++代码编译成`.wasm`文件。LLVM是一组模块化和可重用的编译器和工具链技术。简而言之，它是一个简化从源代码到机器代码的编译过程配置的框架。如果你想制作自己的编程语言并且想要构建编译器，LLVM有工具来简化这个过程。我将在[第10章](93d51e00-521f-4908-ae9d-eeaecb58a01d.xhtml)中介绍如何使用LLVM将C/C++编译成`.wasm`文件，*高级工具和即将推出的功能*。
- en: 'The following snippet demonstrates how to print `Hello World!` to the console
    using C++:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段演示了如何使用C++将“Hello World！”打印到控制台：
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Rust
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rust
- en: C and C++ were intended to be the primary languages used for WebAssembly, but
    Rust is a perfectly suitable substitute. Rust is a systems programming language
    that is syntactically similar to C++. It was designed with memory safety in mind,
    but still retains the performance advantages of C and C++. The current nightly
    build of Rust's compiler can generate `.wasm` files from Rust source code, so
    if you prefer Rust and are familiar with C++, you should be able to use Rust for
    most of the examples in this book.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: C和C++原本是WebAssembly的主要使用语言，但Rust也是一个完全合适的替代品。Rust是一种系统编程语言，语法与C++类似。它设计时考虑了内存安全性，但仍保留了C和C++的性能优势。Rust当前的夜间构建版本的编译器可以从Rust源代码生成`.wasm`文件，因此如果你更喜欢Rust并且熟悉C++，你应该能够在本书的大多数示例中使用Rust。
- en: 'The following snippet demonstrates how to print `Hello World!` to the console
    using Rust:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段演示了如何使用Rust将“Hello World！”打印到控制台：
- en: '[PRE3]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Other languages
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他语言
- en: 'Various tooling exists to enable the use of WebAssembly with some of the other
    popular programming languages, although they are mostly experimental:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在各种工具，可以使其他流行的编程语言与WebAssembly一起使用，尽管它们大多是实验性的：
- en: C# via Blazor
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Blazor的C#
- en: Haxe via WebIDL
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过WebIDL的Haxe
- en: Java via TeaVM or Bytecoder
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过TeaVM或Bytecoder的Java
- en: Kotlin via TeaVM
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过TeaVM的Kotlin
- en: TypeScript via AssemblyScript
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过AssemblyScript的TypeScript
- en: It is also technically possible to transpile a language to C and consequently
    compile that to a Wasm module, but the success of compilation is contingent on
    the output of the transpiler. More than likely, you'd have to make significant
    changes to the code to get it to work.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上也可以将一种语言转译为C，然后将其编译为Wasm模块，但编译的成功取决于转译器的输出。很可能你需要对代码进行重大更改才能使其正常工作。
- en: What are the limitations?
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有哪些限制？
- en: Admittedly, WebAssembly is not without its limitations. New features are being
    actively developed and the technology is constantly evolving, but the MVP functionality
    represents only a portion of WebAssembly's capabilities. In this section, we'll
    cover some of these limitations and how they impact the development process.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，WebAssembly并非没有局限性。新功能正在积极开发，技术不断发展，但MVP功能仅代表了WebAssembly功能的一部分。在本节中，我们将介绍其中一些限制以及它们对开发过程的影响。
- en: No garbage collection
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有垃圾回收
- en: WebAssembly supports a flat linear memory, which isn't a limitation per se,
    but requires some understanding of how to explicitly allocate memory to execute
    code. C and C++ were logical choices for the MVP because memory management is
    built into the language. The reason why some of the more popular high-level languages
    such as Java weren't included initially is due to something called **garbage collection**
    (**GC**).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly支持平面线性内存，这本身并不是一个限制，但需要一些了解如何显式分配内存以执行代码。C和C++是MVP的逻辑选择，因为内存管理内置于语言中。一开始没有包括一些更流行的高级语言，比如Java，原因是**垃圾回收**（**GC**）。
- en: GC is a form of automated memory management wherein memory occupied by objects
    that are no longer in use by the program is reclaimed automatically. GC is analogous
    to an automatic transmission on a car. It has been heavily optimized by skilled
    engineers to operate as efficiently as possible, but limits the amount of control
    the driver has. Manually allocating memory is like driving a car with a manual
    transmission. It affords greater control over speed and torque, but misuse or
    lack of experience can leave you stranded with a severely damaged car. Part of
    C and C++'s excellent performance and speed can be attributed to the manual allocation
    of memory.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: GC是一种自动内存管理形式，程序不再使用的对象占用的内存会被自动回收。GC类似于汽车上的自动变速器。经过熟练工程师的大力优化，它可以尽可能高效地运行，但限制了驾驶员的控制量。手动分配内存就像驾驶手动变速器的汽车。它可以更好地控制速度和扭矩，但错误使用或缺乏经验可能会导致汽车严重损坏。C和C++的出色性能和速度部分归功于手动分配内存。
- en: GC languages allow you to program without having to worry about memory availability
    or allocation. JavaScript is an example of a GC language. The browser engine employs
    something called a mark-and-sweep algorithm to collect unreachable objects and
    free up the corresponding memory. Support for GC languages is currently being
    worked on in WebAssembly, but it's hard to say exactly when it will be completed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: GC语言允许您编程而无需担心内存可用性或分配。JavaScript就是一个GC语言的例子。浏览器引擎采用一种称为标记-清除算法来收集不可达对象并释放相应的内存。WebAssembly目前正在努力支持GC语言，但很难准确说出何时会完成。
- en: No direct DOM access
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有直接的DOM访问
- en: WebAssembly is unable to access the DOM, so any DOM manipulation needs to be
    done indirectly through JavaScript or using a tool such as Emscripten. There are
    plans to add the ability to reference DOM and other Web API objects directly,
    but that's still in the proposal phase. DOM manipulation will likely go hand in
    hand with GC languages, since it will allow the seamless passing of objects between
    WebAssembly and JavaScript code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly无法访问DOM，因此任何DOM操作都需要间接通过JavaScript或使用诸如Emscripten之类的工具来完成。有计划添加引用DOM和其他Web
    API对象的能力，但目前仍处于提案阶段。DOM操作可能会与GC语言紧密相关，因为它将允许在WebAssembly和JavaScript代码之间无缝传递对象。
- en: No support in older browsers
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旧版浏览器不支持
- en: Older browsers don't have the global `WebAssembly` object available to instantiate
    and load Wasm modules. There are experimental polyfills that utilize `asm.js`
    if the object isn't found, but the WebAssembly Working Group currently has no
    plans to create one. Since `asm.js` and WebAssembly are closely related, simply
    serving up an `asm.js` file if the `WebAssembly` object is unavailable will still
    offer performance gains while accommodating for backward compatibility. You can
    see which browsers currently support WebAssembly at [https://caniuse.com/#feat=wasm](https://caniuse.com/#feat=wasm).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版浏览器没有全局的`WebAssembly`对象可用来实例化和加载Wasm模块。如果找不到该对象，有一些实验性的polyfills会使用`asm.js`，但WebAssembly工作组目前没有创建的计划。由于`asm.js`和WebAssembly密切相关，如果`WebAssembly`对象不可用，简单地提供一个`asm.js`文件仍然可以提供性能增益，同时适应向后兼容性。您可以在[https://caniuse.com/#feat=wasm](https://caniuse.com/#feat=wasm)上查看当前支持WebAssembly的浏览器。
- en: How does it relate to Emscripten?
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它与Emscripten有什么关系？
- en: Emscripten is the source-to-source compiler that can generate `asm.js` from
    C and C++ source code. We'll use it as a build tool to generate the Wasm modules.
    In this section, we'll quickly review how Emscripten relates to WebAssembly.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten是可以从C和C++源代码生成`asm.js`的源到源编译器。我们将使用它作为一个构建工具来生成Wasm模块。在本节中，我们将快速回顾Emscripten与WebAssembly的关系。
- en: Emscripten's role
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Emscripten的作用
- en: 'Emscripten is an LLVM-to-JavaScript compiler, which means it takes LLVM bitcode
    output of a compiler such as Clang (for C and C++), and converts that to JavaScript.
    It isn''t one specific technology, but rather a combination of technologies that
    work together to build, compile, and run `asm.js`. To generate Wasm modules, we''ll
    use the **Emscripten SDK** (**EMSDK**)  Manager:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Emscripten是一个LLVM到JavaScript的编译器，这意味着它接受诸如Clang（用于C和C++）的编译器的LLVM位码输出，并将其转换为JavaScript。它不是一个特定的技术，而是一组技术的组合，它们一起构建、编译和运行`asm.js`。为了生成Wasm模块，我们将使用**Emscripten
    SDK**（**EMSDK**）管理器：
- en: '![](img/4d92b3fc-da38-44bc-97b4-e1be3b1fc6a3.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d92b3fc-da38-44bc-97b4-e1be3b1fc6a3.png)'
- en: Wasm module generation with the EMSDK
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用EMSDK生成Wasm模块
- en: The EMSDK and Binaryen
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EMSDK和Binaryen
- en: In [Chapter 4](d03f5dbf-8b6e-49aa-96be-9bb64681be24.xhtml), *Installing the
    Required Dependencies*, we'll install the EMSDK and use it to manage the dependencies
    required to compile C and C++ to Wasm modules. Emscripten uses Binaryen's `asm2wasm`
    tool to compile the `asm.js` output by Emscripten to a `.wasm` file. Binaryen
    is a compiler and toolchain infrastructure library that includes tools to compile
    various formats to WebAssembly modules and vice versa. Understanding the inner
    workings of Binaryen isn't required to use WebAssembly, but it is important to
    be aware of the underlying technologies and how they work together. By passing
    certain flags into the compile command for Emscripten (`emcc`), we can pipe the
    resultant `asm.js` code to Binaryen to output our `.wasm` file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](d03f5dbf-8b6e-49aa-96be-9bb64681be24.xhtml)中，*安装所需的依赖项*，我们将安装 EMSDK 并使用它来管理编译
    C 和 C++ 到 Wasm 模块所需的依赖项。Emscripten 使用 Binaryen 的 `asm2wasm` 工具将 Emscripten 输出的
    `asm.js` 编译成 `.wasm` 文件。Binaryen 是一个编译器和工具链基础库，包括将各种格式编译成 WebAssembly 模块以及反之的工具。了解
    Binaryen 的内部工作对于使用 WebAssembly 并不是必需的，但重要的是要意识到底层技术以及它们如何协同工作。通过将某些标志传递给 Emscripten
    的编译命令 (`emcc`)，我们可以将结果的 `asm.js` 代码传递给 Binaryen 以输出我们的 `.wasm` 文件。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the history of WebAssembly with regard to the
    technologies that led to its creation. A detailed overview of the definition of
    WebAssembly was provided to allow for a greater understanding of the underlying
    technologies involved.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了与 WebAssembly 的历史相关的技术，以及导致其创建的技术。提供了对 WebAssembly 定义的详细概述，以便更好地理解涉及的底层技术。
- en: The *Core Specificati*on, *JavaScript API*, and *Web API* were presented as
    important elements of WebAssembly and demonstrate how the technology will evolve.
    We also reviewed potentials use cases, currently supported languages, and tools
    that enable the use of non-supported languages.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*核心规范*、*JavaScript API* 和 *Web API* 被提出为 WebAssembly 的重要元素，并展示了技术将如何发展。我们还审查了潜在的用例、当前支持的语言以及使非支持语言可用的工具。'
- en: The limitations of WebAssembly are the absence of GC, the inability to communicate
    directly with the DOM, and the lack of support for older browsers. These were
    discussed to convey the newness of the technology and shed light on some of its
    shortcomings. Finally, we discussed Emscripten's role in the development process
    and where it fits into the WebAssembly development workflow.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly 的局限性是缺乏 GC、无法直接与 DOM 通信以及不支持旧版浏览器。这些都是为了传达技术的新颖性并揭示其中一些缺点而进行讨论的。最后，我们讨论了
    Emscripten 在开发过程中的作用以及它在 WebAssembly 开发工作流程中的位置。
- en: 'In [Chapter 2](0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml), *Elements of WebAssembly
    - Wat, Wasm*, and *the JavaScript API*, we''ll be diving deeper into the elements
    that make up WebAssembly: the **WebAssembly text format** (**Wat**), binary format
    (Wasm), JavaScript, and Web APIs.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml)中，*WebAssembly 元素 - Wat、Wasm
    和 JavaScript API*，我们将更深入地探讨构成 WebAssembly 的元素：**WebAssembly 文本格式**（**Wat**）、二进制格式（Wasm）、JavaScript
    和 Web API。
- en: Questions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which two technologies influenced the creation of WebAssembly?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪两种技术影响了 WebAssembly 的创建？
- en: What is a stack machine and how does it relate to WebAssembly?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是堆栈机器，它与 WebAssembly 有什么关系？
- en: In what ways does WebAssembly complement JavaScript?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WebAssembly 如何补充 JavaScript？
- en: Which three programming languages can be compiled to Wasm modules?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪三种编程语言可以编译成 Wasm 模块？
- en: What role does LLVM play with regard to WebAssembly?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLVM 在 WebAssembly 方面扮演什么角色？
- en: What are three potential use cases for WebAssembly?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: WebAssembly 有哪三个潜在的用例？
- en: How are DOM access and GC related?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DOM 访问和 GC 有什么关系？
- en: What tool does Emscripten use to generate Wasm modules?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Emscripten 使用什么工具来生成 Wasm 模块？
- en: Further reading
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Official WebAssembly site: [https://webassembly.org](https://webassembly.org)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 WebAssembly 网站：[https://webassembly.org](https://webassembly.org)
- en: 'Native Client technical overview: [https://developer.chrome.com/native-client/overview](https://developer.chrome.com/native-client/overview)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生客户端技术概述：[https://developer.chrome.com/native-client/overview](https://developer.chrome.com/native-client/overview)
- en: 'The LLVM Compiler Infrastructure Project: [https://llvm.org](https://llvm.org)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LLVM 编译器基础设施项目：[https://llvm.org](https://llvm.org)
- en: 'About Emscripten: [http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html](http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Emscripten：[http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html](http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html)
- en: 'asm.js specification: [http://asmjs.org/spec/latest](http://asmjs.org/spec/latest)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: asm.js 规范：[http://asmjs.org/spec/latest](http://asmjs.org/spec/latest)
