- en: '*Chapter 9*: Instruction Selection'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：指令选择'
- en: 'The LLVM IR used so far still needs to be turned into machine instructions.
    This is called **instruction selection**, often abbreviated to **ISel**. Instruction
    selection is an important part of the target backend, and LLVM has three different
    approaches for selecting instructions: the selection DAG, fast instruction selection,
    and global instruction selection.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止使用的LLVM IR仍然需要转换为机器指令。这称为**指令选择**，通常缩写为**ISel**。指令选择是目标后端的重要部分，LLVM有三种不同的选择指令的方法：选择DAG，快速指令选择和全局指令选择。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Understanding the LLVM target backend structure, which introduces you to the
    task performed by the target backend, and you examine the machine passes to run.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解LLVM目标后端结构，介绍了目标后端执行的任务，并检查了要运行的机器传递。
- en: Using the **machine IR** (**MIR**) to test and debug the backend, which helps
    you to output MIR after a specified pass and run a pass on the MIR file.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**机器IR**（**MIR**）来测试和调试后端，这有助于在指定的传递后输出MIR并在MIR文件上运行传递。
- en: How instruction selection works, in which you learn about the different ways
    LLVM performs instruction selection.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令选择的工作方式，您将了解LLVM执行指令选择的不同方式。
- en: Supporting new machine instructions, in which you add a new machine instruction
    and make it available to the instruction selection.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持新的机器指令，其中您添加一个新的机器指令并使其可用于指令选择。
- en: By the end of the chapter, you will know how the target backends are structured
    and how instruction selection works. You will also acquire the knowledge to add
    currently unsupported machine instructions to the assembler and the instruction
    selection, and how to test your addition.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将了解目标后端的结构以及指令选择的工作方式。您还将获得向汇编程序和指令选择中添加当前不受支持的机器指令的知识，以及如何测试您的添加。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To see the graph visualization, you must install the **Graphviz** software,
    which can be downloaded from [https://graphviz.org/](https://graphviz.org/). The
    source code is available at [http://gitlab.com/graphviz/graphviz/](http://gitlab.com/graphviz/graphviz/).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看图形可视化，您必须安装**Graphviz**软件，可从[https://graphviz.org/](https://graphviz.org/)下载。源代码可在[http://gitlab.com/graphviz/graphviz/](http://gitlab.com/graphviz/graphviz/)上找到。
- en: The source code for this chapter is available at [https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter09](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter09)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可在[https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter09](https://github.com/PacktPublishing/Learn-LLVM-12/tree/master/Chapter09)上找到
- en: You can find the code in action videos at [https://bit.ly/3nllhED](https://bit.ly/3nllhED)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://bit.ly/3nllhED](https://bit.ly/3nllhED)上找到代码演示视频
- en: Understanding the LLVM target backend structure
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解LLVM目标后端结构
- en: 'After the LLVM IR is optimized, the selected LLVM target is used to generate
    the machine code from it. Among others, the following tasks are performed in the
    target backend:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化了LLVM IR之后，选择的LLVM目标用于从中生成机器代码。在目标后端中执行以下任务，包括：
- en: The **directed acyclic graph** (**DAG**) used for instruction selection, usually
    referred to as the **SelectionDAG**, is constructed.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于指令选择的**有向无环图**（**DAG**），通常称为**SelectionDAG**，被构建。
- en: Machine instructions corresponding to the IR code are selected.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择与IR代码对应的机器指令。
- en: The selected machine instructions are ordered in an optimal sequence.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择的机器指令按最佳顺序排列。
- en: Virtual registers are replaced with machine registers.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟寄存器被机器寄存器替换。
- en: Prologue and epilogue code is added to functions.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向函数添加序言和尾声代码。
- en: Basic blocks are ordered in an optimal sequence.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本块按最佳顺序排列。
- en: Target-specific passes are run.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行特定于目标的传递。
- en: Object code or assembly is emitted.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出目标代码或汇编。
- en: All these steps are implemented as machine function passes, derived from the
    `MachineFunctionPass` class. This is a subclass of the `FunctionPass` class, one
    of the base classes used by the old pass manager. As of LLVM 12, the conversion
    of machine function passes to the new pass manager is still a work in progress.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些步骤都被实现为机器函数传递，派生自`MachineFunctionPass`类。这是`FunctionPass`类的子类，是旧的pass管理器使用的基类之一。截至LLVM
    12，将机器函数传递转换为新的pass管理器仍然是一个正在进行中的工作。
- en: During all these steps, an LLVM instruction undergoes a transformation. At the
    code level, an LLVM IR instruction is represented by an instance of the `Instruction`
    class. During the instruction selection phase, it is transformed into a `MachineInstr`
    instance. This is a representation much nearer to the actual machine level. It
    already contains the instructions that are valid for the target, but still operates
    on virtual registers (up to register allocation) and also can contain certain
    pseudo instructions. The passes after the instruction selection refine this, and
    in the end, an instance of `MCInstr` is created, which is a representation of
    the real machine instruction. The `MCInstr` instance can be written into an object
    file or printed as assembly code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些步骤中，LLVM指令都会经历转换。在代码级别，LLVM IR指令由`Instruction`类的实例表示。在指令选择阶段，它被转换为`MachineInstr`实例。这是一个更接近实际机器级别的表示。它已经包含了对目标有效的指令，但仍然在虚拟寄存器上运行（直到寄存器分配），并且还可以包含某些伪指令。指令选择后的传递会对此进行细化，最终创建一个`MCInstr`实例，这是真实机器指令的表示。`MCInstr`实例可以写入对象文件或打印为汇编代码。
- en: 'To explore the backend passes, you can create a small IR file with the following
    content:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索后端传递，您可以创建一个包含以下内容的小型IR文件：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Save this code as `sum.ll`. Compile it for the MIPS architecture using `llc`,
    the LLVM static compiler. This tool compiles LLVM IR into assembly text or an
    object file. The target platform compile for can be overridden on the command
    line with the `–mtriple` option. Invoke the `llc` tool with the `–debug-pass=Structure`
    option:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码保存为`sum.ll`。使用LLVM静态编译器`llc`为MIPS架构编译它。这个工具将LLVM IR编译成汇编文本或目标文件。可以使用`–mtriple`选项在命令行上覆盖目标平台的编译。使用`–debug-pass=Structure`选项调用`llc`工具：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Besides the generated assembly code, you will see a long list of machine passes
    to run. Among them, the `MIPS DAG->DAG Pattern Instruction Selection` pass performs
    the instruction selection, the `Mips Delay Slot Filler` is a target-specific pass,
    and the last pass before cleanup, `Mips Assembly Printer`, is responsible for
    printing the assembly code. Of all of these passes, the instruction selection
    pass is the most interesting one, and we look at it in detail in the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了生成的汇编代码，你还会看到一个要运行的机器pass的长列表。其中，`MIPS DAG->DAG Pattern Instruction Selection`
    pass执行指令选择，`Mips Delay Slot Filler`是一个特定于目标的pass，而在清理之前的最后一个pass，`Mips Assembly
    Printer`，负责打印汇编代码。在所有这些pass中，指令选择pass是最有趣的，我们将在下一节详细讨论。
- en: Using MIR to test and debug the backend
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MIR测试和调试后端
- en: You saw in the previous section that many passes are run in the target backend.
    However, most of these passes do not operate on LLVM IR, but on MIR. This is a
    target-dependent representation of the instructions, and therefore more low-level
    than LLVM IR. It can still contain references to virtual registers, so it is not
    yet the pure instruction of the target CPU.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你在前面的部分看到目标后端运行了许多pass。然而，这些pass中的大多数并不是在LLVM IR上运行的，而是在MIR上运行的。这是指令的一个与目标相关的表示，因此比LLVM
    IR更低级。它仍然可以包含对虚拟寄存器的引用，因此它还不是目标CPU的纯指令。
- en: To see the optimizations on the IR level, you can, for example, tell `llc` to
    dump the IR after each pass. This does not work with the machine passes in the
    backend, because they do not work on IR. Instead, MIR serves a similar purpose.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看IR级别的优化，例如，可以告诉`llc`在每个pass之后转储IR。这在后端的机器pass中不起作用，因为它们不在IR上工作。相反，MIR起到了类似的作用。
- en: MIR is a textual representation of the current state of the machine instructions
    in the current module. It utilizes the YAML format, which allows for serialization
    and deserialization. The basic idea is that you can stop the pass pipeline at
    a point and inspect the state in YAML format. You can also modify the YAML file,
    or create your own, and pass on it, and inspect the result. This allows for easy
    debugging and testing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: MIR是当前模块中机器指令当前状态的文本表示。它利用了YAML格式，允许序列化和反序列化。基本思想是你可以在某个点停止pass管道并以YAML格式检查状态。你也可以修改YAML文件，或者创建你自己的文件，并传递它，并检查结果。这样可以方便地进行调试和测试。
- en: 'Let''s have a look at MIR. Run the `llc` tool with the `--stop-after=finalize-isel`
    option and the test input file we used earlier:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看MIR。使用`llc`工具和`--stop-after=finalize-isel`选项以及之前使用的测试输入文件运行：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This instructs `llc` to dump MIR after instruction selection is complete. The
    shortened output looks like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示`llc`在指令选择完成后转储MIR。缩短的输出看起来像这样：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are several properties you immediately note. First, there is a mix of
    virtual registers such as `%0` and real machine registers such as `$a0`. The reason
    for this comes from ABI lowering. To be portable across different compilers and
    languages, functions adhere to a calling convention, which is part of the `$a0`.
    Because the MIR output was generated after the instruction selection but before
    register allocation, you still see the use of virtual registers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个属性你立即注意到。首先，有一些虚拟寄存器，比如`%0`和实际的机器寄存器，比如`$a0`。这是由ABI降级引起的。为了在不同的编译器和语言之间具有可移植性，函数遵循调用约定的一部分，这是`$a0`的一部分。因为MIR输出是在指令选择之后但是在寄存器分配之前生成的，所以你仍然可以看到虚拟寄存器的使用。
- en: Instead of the `add` instruction from LLVM IR, the machine instruction `ADDu`
    is used in the MIR file. You can also see that the virtual registers have a register
    call attached, in this case, `gpr32`. There are no 16-bit registers on the MIPS
    architecture, and therefore 32-bit registers must be used.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在LLVM IR中的`add`指令，MIR文件中使用的是机器指令`ADDu`。你还可以看到虚拟寄存器有一个寄存器调用附加，这种情况下是`gpr32`。在MIPS架构上没有16位寄存器，因此必须使用32位寄存器。
- en: The `bb.0` label refers to the first basic block, and the indented content after
    the label is part of the basic blocks. The first statement specifies the registers
    that are live on entry to the basic block. After that, the instructions follow.
    In this case, only `$a0`, and `$a1`, both parameters, are live on entry.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`bb.0`标签指的是第一个基本块，标签后面的缩进内容是基本块的一部分。第一条语句指定了进入基本块时活跃的寄存器。之后是指令。在这种情况下，只有`$a0`和`$a1`，两个参数，在进入时是活跃的。'
- en: There are a lot of other details in the MIR file. You can read about them in
    the LLVM MIR documentation at [https://llvm.org/docs/MIRLangRef.html](https://llvm.org/docs/MIRLangRef.html).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: MIR文件中还有很多其他细节。你可以在LLVM MIR文档中阅读有关它们的内容[https://llvm.org/docs/MIRLangRef.html](https://llvm.org/docs/MIRLangRef.html)。
- en: One problem you encounter is how to find out the name of a pass, especially
    if you just need to examine the output after that pass without actively working
    on it. When using the `-debug-pass=Structure` option with `llc`, the options that
    activate the passes are printed on the top. For example, if you want to stop before
    the `Mips Delay Slot Filler` pass, then you need to look at the printed list,
    and hopefully find the `-mips-delay-slot-filler` option, which also gives you
    the name of the pass.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你遇到的一个问题是如何找出一个pass的名称，特别是如果你只需要检查该pass之后的输出而不是积极地在其上工作。当使用`-debug-pass=Structure`选项与`llc`一起时，激活pass的选项被打印在顶部。例如，如果你想在`Mips
    Delay Slot Filler` pass之前停止，那么你需要查看打印出的列表，并希望找到`-mips-delay-slot-filler`选项，这也会给出pass的名称。
- en: The main application of the MIR file format is to aid in testing machine passes
    in the target backend. Using `llc` with the `--stop-after option`, you get the
    MIR after the specified pass. Usually, you will use this as the base for your
    intended test case. The first thing you note is that the MIR output is very verbose.
    For example, many fields are empty. To reduce this clutter, you can add the `-simplify-mir`
    option to the `llc` command line.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: MIR文件格式的主要应用是帮助测试目标后端中的机器传递。使用`llc`和`--stop-after`选项，您可以在指定的传递之后获得MIR。通常，您将使用这个作为您打算测试用例的基础。您首先注意到的是MIR输出非常冗长。例如，许多字段是空的。为了减少这种混乱，您可以在`llc`命令行中添加`-simplify-mir`选项。
- en: 'You save and change the MIR as needed for your test case. The `llc` tool can
    run a single pass, and this is a perfect match for testing with the MIR file.
    Let''s assume you like to test the `MIPS Delay Slot Filler` pass. The delay slot
    is a special property of RISC architectures such as MIPS or SPARC: the next instruction
    after a jump is always executed. Therefore, the compiler must make sure that there
    is a suitable instruction after each jump, and this pass performs this duty.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要保存和更改MIR以进行测试。`llc`工具可以运行单个传递，这非常适合使用MIR文件进行测试。假设您想要测试`MIPS Delay Slot
    Filler`传递。延迟槽是RISC架构（如MIPS或SPARC）的一个特殊属性：跳转后的下一条指令总是被执行。因此，编译器必须确保每次跳转后都有一个合适的指令，这个传递就是执行这个任务的。
- en: 'We generate the MIR before running the pass:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在运行传递之前生成MIR：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is much smaller because we used the `-simplify-mir` option. The
    body of the function is now the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出要小得多，因为我们使用了`-simplify-mir`选项。函数的主体现在是以下内容：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Most notably, you will see the `ADDu` instruction, followed by apseudo instruction
    for the return.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，您将看到`ADDu`指令，后面是返回的伪指令。
- en: 'With the `delay.ll` file as input, we now run the delay slot filler pass:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`delay.ll`文件作为输入，我们现在运行延迟槽填充器传递：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now compare the function in the output with the earlier one:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将输出中的函数与之前的函数进行比较：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You see that `ADDu` and the pseudo instruction for the return have changed
    order, and the `ADDu` instruction is now nested inside the return: the pass identified
    the `ADDu` instruction as suitable for the delay slot.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到`ADDu`和返回的伪指令的顺序已经改变，`ADDu`指令现在嵌套在返回内部：传递将`ADDu`指令标识为适合延迟槽的指令。
- en: 'In case the delay slot concept is new to you, you will also want to have a
    look at the generated assembly, which you easily generate with `llc`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果延迟槽的概念对您来说是新的，您还会想要查看生成的汇编代码，您可以使用`llc`轻松生成：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output contains a lot of details, but with the help of the `bb.0` name
    of the basic block, you can easily locate the generated assembly code for it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出包含很多细节，但是通过基本块的`bb.0`名称的帮助，您可以轻松地定位生成的汇编代码：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Indeed, the order of the instructions changed!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，指令的顺序改变了！
- en: Equipped with this knowledge, we take a look at the heart of the target backend
    and examine how machine instruction selection is performed in LLVM.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了这些知识，我们来看一下目标后端的核心，并检查LLVM中如何执行机器指令选择。
- en: How instruction selection works
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令选择的工作原理
- en: The task of an LLVM backend is to create machine instructions from the LLVM
    IR. This process is called **instruction selection** or **lowering**. Motivated
    by the idea to automate this task as much as possible, the LLVM developers invented
    the TableGen language to capture all the details of a target description. We first
    look at this language before diving into the instruction selection algorithms.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM后端的任务是从LLVM IR创建机器指令。这个过程称为**指令选择**或**降低**。受到尽可能自动化这项任务的想法的启发，LLVM开发人员发明了TableGen语言来捕获目标描述的所有细节。我们首先看一下这种语言，然后再深入研究指令选择算法。
- en: Specifying the target description in the TableGen language
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在TableGen语言中指定目标描述
- en: 'A machine instruction has a lot of properties: a mnemonic used by the assembler
    and disassembler, a bit pattern to represent the instruction in memory, input
    and output operands, and so on. The LLVM developers decided to capture all this
    information in a single place, the `.td` suffix.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 机器指令有很多属性：汇编器和反汇编器使用的助记符、在内存中表示指令的位模式、输入和输出操作数等。LLVM开发人员决定将所有这些信息都捕获在一个地方，即`.td`后缀。
- en: 'In principle, the TableGen language is very simple. All you can do is define
    records. A `Register` class defines the common properties of a register, and you
    can define a concrete record for register `R0`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，TableGen语言非常简单。您所能做的就是定义记录。`Register`类定义了寄存器的共同属性，您可以为寄存器`R0`定义一个具体的记录：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You use the `let` keyword to override a value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`let`关键字来覆盖一个值。
- en: 'The TableGen language has a lot of syntactic sugar to make dealing with records
    easier. A class can have a template argument, for example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: TableGen语言有很多语法糖，使处理记录变得更容易。例如，一个类可以有一个模板参数：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The TableGen language is statically typed, and you have to specify the type
    of each value. Some of the supported types are the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: TableGen语言是静态类型的，您必须指定每个值的类型。一些支持的类型如下：
- en: '`bit`: A single bit'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`位`：一个单独的位'
- en: '`int`: A 64-bit integer value'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：64位整数值'
- en: '`bits<n>`: An integral type consisting of *n* bits'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bits<n>`：由*n*位组成的整数类型'
- en: '`string`: A character string'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`：一个字符字符串'
- en: '`list<t>`: A list of elements of type `t`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list<t>`：类型为`t`的元素列表'
- en: '`dag`: A **directed acyclic graph** (**DAG**; used by the instruction selection)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dag`：**有向无环图**（**DAG**；指令选择使用）'
- en: The name of a class can also be used as a type. For example, `list<Register>`
    specifies a list of elements of the `Register` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 类的名称也可以用作类型。例如，`list<Register>`指定了`Register`类的元素列表。
- en: The language allows the inclusion of other files with the `include` keyword.
    For conditional compiling, the preprocessor directives `#define`, `#ifdef`, and
    `#ifndef` are supported.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该语言允许使用`include`关键字包含其他文件。对于条件编译，支持预处理指令`#define`、`#ifdef`和`#ifndef`。
- en: The TableGen library in LLVM can parse files written in the TableGen language
    and create an in-memory representation of the records. You can use this library
    to create your own generator.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM中的TableGen库可以解析用TableGen语言编写的文件，并创建记录的内存表示。您可以使用这个库来创建自己的生成器。
- en: LLVM comes with its own generator tool called `llvm-tblgen` and some `.td` files.
    The target description of a backend includes the `llvm/Target/Target.td` file
    first. This file defines classes such as `Register`, `Target`, or `Processor`.
    The `llvm-tblgen` tool knows about these classes and generates C++ code from the
    defined records.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM自带了一个名为`llvm-tblgen`的生成器工具和一些`.td`文件。后端的目标描述首先包括`llvm/Target/Target.td`文件。该文件定义了诸如`Register`、`Target`或`Processor`之类的类。`llvm-tblgen`工具了解这些类，并从定义的记录生成C++代码。
- en: 'Let''s have a look at the MIPS backend as an example. The target description
    is in the `Mips.td` file in the `llvm/lib/Target/Mips` folder. This file includes
    the `Target.td` file mentioned first. It also defines target features, for example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以MIPS后端为例来看一下。目标描述在`llvm/lib/Target/Mips`文件夹中的`Mips.td`文件中。该文件包括了最初提到的`Target.td`文件。它还定义了目标特性，例如：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Such features are later used to define CPU models, for example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特性后来被用来定义CPU模型，例如：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Other files that define registers, instructions, scheduling models, and so on
    are also included.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 其他定义寄存器、指令、调度模型等的文件也包括在内。
- en: 'The `llvm-tblgen` tool can show you the records defined by this target description.
    If you are in the `build` directory, then the following command will print the
    records to the console:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm-tblgen`工具可以显示由目标描述定义的记录。如果你在`build`目录中，那么以下命令将在控制台上打印记录：'
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Like with Clang, the `–I` option adds a directory to search when including
    files. To see the records can be helpful for debugging. The real purpose of the
    tool is to generate C++ code from the records. For example, with the `-gen-subtarget`
    option, the data necessary to parse the `–mcpu=` and `–mtarget=` option of `llc`
    is emitted to the console:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与Clang一样，`-I`选项会在包含文件时添加一个目录进行搜索。查看记录对于调试很有帮助。该工具的真正目的是从记录生成C++代码。例如，使用`-gen-subtarget`选项，将向控制台发出解析`llc`的`-mcpu=`和`-mtarget=`选项所需的数据：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Save the generated code from that command in a file and explore how the feature
    and the CPU are used in generated code!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将该命令生成的代码保存到一个文件中，并探索特性和CPU在生成的代码中的使用方式！
- en: 'The encoding of instructions usually follows a handful of patterns. Therefore,
    the definition of instructions is split into classes defining the bit encoding
    and the concrete definition of instruction. The encoding for the MIPS instructions
    is in the file `llvm/Target/Mips/MipsInstrFormats.td`. Let''s have a look at the
    definition of the `ADD_FM` format:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 指令的编码通常遵循一些模式。因此，指令的定义被分成了定义位编码和指令具体定义的类。MIPS指令的编码在文件`llvm/Target/Mips/MipsInstrFormats.td`中。让我们来看一下`ADD_FM`格式的定义：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the record body, several new bit fields are defined: `rd`, `rs`, and so
    on. They are used to override portions of the `Inst` field, which holds the bit
    pattern for the instruction. The `rd`, `rs`, and `rt` bit fields encode the registers
    the instruction operates on, and the `op` and `funct` parameters denote the opcode
    and a function number. The `StdArch` superclass only adds a field stating that
    this format follows a standard encoding.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录主体中，定义了几个新的位字段：`rd`、`rs`等。它们用于覆盖`Inst`字段的部分内容，该字段保存指令的位模式。`rd`、`rs`和`rt`位字段编码了指令操作的寄存器，而`op`和`funct`参数表示操作码和函数编号。`StdArch`超类只添加了一个字段，说明该格式遵循标准编码。
- en: 'Most instruction encoding in the MIPS target does not refer to the DAG nodes
    and do not specify the assembly mnemonic. A separate class is defined for that.
    One of the instructions in the MIPS architecture is the `nor` instruction, which
    computes the bitwise or of the first and second input register, inverts the bits
    of the result, and assigns the result to the output register. There are several
    variants of this instruction, and the following `LogicNOR` class helps with avoiding
    the same definitions multiple times:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: MIPS目标中的大多数指令编码不涉及DAG节点，也不指定汇编助记符。为此定义了一个单独的类。MIPS架构中的一条指令是`nor`指令，它计算第一个和第二个输入寄存器的按位或，反转结果的位，并将结果赋给输出寄存器。这条指令有几个变体，以下的`LogicNOR`类有助于避免多次重复相同的定义：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Wow, the simple concept of records now looks complicated. Let''s dissect that
    definition. The class derives from the `InstSE` class, which is always used for
    instructions with standard encoding. If you follow the superclass hierarchy further,
    then you see that this class derives from `Instruction` class, which is the predefined
    class denoting an instruction of a target. The `(outs RO:$rd)` parameter defines
    the result of the final instruction as a DAG node. The `RO` part refers to the
    parameter of the same name of the `LogicNOR` class and denotes a register operand.
    The `$rd` is the register to use. This is the value that will be put later into
    the instruction encoding, in the `rd` field. The second parameter defines the
    values the instruction will operate on. In summary, this class is for an instruction
    that operates on three registers. The `!strconcat(opstr, "\t$rd, $rs, $rt")` parameter
    assembles the textual representation of the instruction. The `!strconcat` operator
    is a predefined functionality from TableGen, which concatenates two strings. You
    can look up all predefined operators in the TableGen programmer''s guide at: [https://llvm.org/docs/TableGen/ProgRef.html](https://llvm.org/docs/TableGen/ProgRef.html).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，记录这个简单的概念现在看起来很复杂。让我们剖析一下这个定义。这个类派生自`InstSE`类，这个类总是用于具有标准编码的指令。如果你继续跟踪超类层次结构，你会看到这个类派生自`Instruction`类，这是一个预定义的类，表示目标的指令。`(outs
    RO:$rd)`参数将最终指令的结果定义为DAG节点。`RO`部分是指`LogicNOR`类的同名参数，表示寄存器操作数。`$rd`是要使用的寄存器。这是稍后将放入指令编码中的值，在`rd`字段中。第二个参数定义了指令将操作的值。总之，这个类是用于操作三个寄存器的指令。`!strconcat(opstr,
    "\t$rd, $rs, $rt")`参数组装了指令的文本表示。`!strconcat`操作符是TableGen中预定义的功能，用于连接两个字符串。你可以在TableGen程序员指南中查找所有预定义的操作符：[https://llvm.org/docs/TableGen/ProgRef.html](https://llvm.org/docs/TableGen/ProgRef.html)。
- en: It follows a pattern definition, which resembles the textual description of
    the `nor` instruction and describes the computation of this instruction. The first
    element of the pattern is the operation, which is followed by a comma-separated
    list of operands. The operands refer to the register names in the DAG parameters
    and also specify an LLVM IR value type. LLVM has a set of predefined operators,
    such as `add` and `and`, which can be used in patterns. The operators are of the
    `SDNode` class, and can also be used as parameters. You can look up the predefined
    operators in the file `llvm/Target/TargetSelectionDAG.td`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它遵循一个模式定义，类似于`nor`指令的文本描述，并描述了这个指令的计算。模式的第一个元素是操作，后面是一个逗号分隔的操作数列表。操作数指的是DAG参数中的寄存器名称，并且还指定了LLVM
    IR值类型。LLVM有一组预定义的操作符，比如`add`和`and`，可以在模式中使用。这些操作符属于`SDNode`类，也可以用作参数。你可以在文件`llvm/Target/TargetSelectionDAG.td`中查找预定义的操作符。
- en: 'The `II_NOR` parameter specifies the itinerary class used in the scheduling
    model, and the `FrmR` parameter is a value defined to identify this instruction
    format. Finally, the `opstr` mnemonic is passed to the superclass. The body of
    this class is quite simple: it just specifies that the `nor` operation is commutative,
    which means that the order of the operands can be swapped.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`II_NOR`参数指定了调度模型中使用的行程类别，`FrmR`参数是一个定义的值，用于识别此指令格式。最后，`opstr`助记符被传递给超类。这个类的主体非常简单：它只是指定`nor`操作是可交换的，这意味着操作数的顺序可以交换。'
- en: 'Finally, this class is used to define a record for an instruction, as an example,
    for the `nor` instruction in 64-bit mode:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个类用于定义一个指令的记录，例如，用于64位模式下的`nor`指令：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is the final definition, recognizable from the `def` keyword. It uses the
    `LogicNOR` class to define the DAG operands and pattern, and the `ADD_FM` class
    to specify the binary instruction encoding. The additional `GPR_64` predicate
    makes sure that this instruction is only used if 64-bit registers are available.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终的定义，可以从`def`关键字中识别出来。它使用`LogicNOR`类来定义DAG操作数和模式，使用`ADD_FM`类来指定二进制指令编码。额外的`GPR_64`谓词确保只有在64位寄存器可用时才使用这个指令。
- en: The developers try hard to not repeat definitions multiple times, and one often-used
    approach is the use of `multiclass` classes. A `multiclass` class can define multiple
    records at once.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员努力避免多次重复定义，一个经常使用的方法是使用`multiclass`类。`multiclass`类可以一次定义多个记录。
- en: 'For example, the floating point unit of a MIPS CPU can perform addition with
    single- or double-precision floating point values. The definition of both instructions
    is very similar, therefore a `multiclass` class is defined to create two instructions
    at once:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，MIPS CPU的浮点单元可以执行单精度或双精度浮点值的加法。这两个指令的定义非常相似，因此定义了一个`multiclass`类，一次创建两个指令：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `ADDS_FT` class defines the instruction format, similar to the `LogicNOR`
    class. The `FGR_32` and `FGR_64` predicates are used to decide at compile time
    which instruction can be used. The important part is the definition of `_D32`
    and `_D64` records. These are the templates for the records. The instruction records
    are then defined with the `defm` keyword:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADDS_FT`类定义了指令格式，类似于`LogicNOR`类。`FGR_32`和`FGR_64`谓词用于在编译时决定可以使用哪个指令。重要的部分是定义了`_D32`和`_D64`记录。这些是记录的模板。然后使用`defm`关键字定义指令记录：'
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This defines the two records from the multiclass at once and assigns the names
    `FADD_D32` and `FADD_D64` to them. This is a very powerful way to avoid code repetition,
    and it is often used in the target descriptions, but combined with the other TableGen
    features it can lead to very cryptic definitions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次同时定义了多类中的两个记录，并为它们分配了名称`FADD_D32`和`FADD_D64`。这是避免代码重复的一种非常强大的方式，它经常在目标描述中使用，但结合其他TableGen功能，可能会导致非常晦涩的定义。
- en: With the knowledge of how the target description is organized, we can now explore
    the instruction selection in the next section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有了目标描述组织的知识，我们现在可以在下一节中探索指令选择。
- en: Instruction selection with the selection DAG
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用选择DAG进行指令选择
- en: 'The standard way LLVM converts the IR to machine instructions is via a DAG.
    Using pattern matching with the patterns provided in the target description and
    using custom code, the IR instructions are transformed into machine instructions.
    This approach is not as straightforward as it sounds: the IR is mostly target-independent
    and can contain data types that are not supported on the target. For example,
    the `i1` type representing a single bit is not a valid type on most targets.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM将IR转换为机器指令的标准方式是通过DAG。使用目标描述中提供的模式匹配和自定义代码，IR指令被转换为机器指令。这种方法并不像听起来那么简单：IR大多是与目标无关的，并且可能包含目标不支持的数据类型。例如，代表单个位的`i1`类型在大多数目标上都不是有效的类型。
- en: The selectionDAG consists of nodes of `SDNode` type, defined in the file `llvm/CodeGen/SelectionDAGNodes.h`.
    The operation the node represents is called `OpCode`, and the target-independent
    codes are defined in the file `llvm/CodeGen/ISDOpcodes.h`. Besides the operation,
    the node stores the operands and the value it produces.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: selectionDAG由`SDNode`类型的节点组成，在文件`llvm/CodeGen/SelectionDAGNodes.h`中定义。节点表示的操作称为`OpCode`，目标独立代码在文件`llvm/CodeGen/ISDOpcodes.h`中定义。除了操作，节点还存储操作数和它产生的值。
- en: The values and operands of a node form a data flow dependency. A control flow
    dependency is represented by chain edges, which have the special type `MVT::Other`.
    This makes it possible to keep the order of instructions with side effects, for
    example, a load instruction.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的值和操作数形成数据流依赖关系。控制流依赖由链边表示，具有特殊类型`MVT::Other`。这使得可以保持具有副作用的指令的顺序，例如，加载指令。
- en: 'Instruction selection using the selection DAG is performed with the following
    steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用选择DAG进行指令选择的步骤如下：
- en: The DAG is constructed.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何跟踪指令选择过程
- en: The DAG is optimized.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DAG被优化了。
- en: The types in the DAG are legalized.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DAG中的类型被合法化了。
- en: The DAG is optimized.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指令被选择了。
- en: The operations in the DAG are legalized.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DAG中的操作被合法化了。
- en: The DAG is optimized.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DAG被优化了。
- en: The instructions are selected.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指令被排序了。
- en: The instructions are ordered.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像上一节的MIR输出中一样，您在这里看到`CopyFromReg`指令，它们将ABI使用的寄存器的内容传输到虚拟节点。由于示例使用16位值，但MIPS架构仅对32位值有本机支持，因此需要`truncate`节点。`add`操作是在16位虚拟寄存器上执行的，并且结果被扩展并返回给调用者。对于上述每个步骤，都会打印这样的部分。
- en: Let's examine how we can follow the changes each of the steps makes to the selection
    DAG.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何跟踪每个步骤对选择DAG的更改。
- en: How to follow the instruction selection process
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '![图9.1 - 为sum.ll文件构建的选择DAG'
- en: 'You can see the work of the instruction selection in two different ways. If
    you pass the `–debug-only=isel` option to the `llc` tool, then the result of each
    step is printed in textual format. This is a great help if you need to investigate
    why a machine instruction was selected. For example, run the following command
    to see the output for the `sum.ll` file from the *Understanding the LLVM target
    backend structure* section:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以两种不同的方式看到指令选择的工作。如果将`-debug-only=isel`选项传递给`llc`工具，则每个步骤的结果将以文本格式打印出来。如果您需要调查为什么选择了机器指令，这将是一个很大的帮助。例如，运行以下命令以查看“Understanding
    the LLVM target backend structure”部分的`sum.ll`文件的输出：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This prints a lot of information. At the top of the output, you see the description
    of the initial created DAG for the input:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这打印了大量信息。在输出顶部，您可以看到输入的初始创建的DAG的描述：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Like in the MIR output from the last section, you see here `CopyFromReg` instructions,
    which transfer the content of registers used by the ABI to virtual nodes. The
    `truncate` nodes are required because the example uses 16-bit values, but the
    MIPS architectures have only native support for 32-bit values. The `add` operation
    is performed on 16-bit virtual registers, and the result is extended and returned
    to the caller. Such a section is printed for each of the steps mentioned above.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: DAG被构建了。
- en: 'LLVM can also generate a visualization of the selection DAG with the help of
    the *Graphviz* software. If you pass the `–view-dag-combine1-dags` option to the
    `llc` tool, then a window opens showing the constructed DAG. For example, run
    `llc` with the small file from the preceding:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM还可以借助*Graphviz*软件生成选择DAG的可视化。如果将`–view-dag-combine1-dags`选项传递给`llc`工具，则会打开一个窗口显示构建的DAG。例如，使用前面的小文件运行`llc`：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Running on a Windows PC, you then see the DAG:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: DAG被优化了。
- en: '![Figure 9.1 – Constructed selection DAG for the sum.ll file'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows PC上运行，您将看到DAG：
- en: '](img/Figure_9.1_B15647.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows PC上运行，您将看到DAG：
- en: Figure 9.1 – Constructed selection DAG for the sum.ll file
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 - 为sum.ll文件构建的选择DAG
- en: 'Be sure to compare that the textual representation and this graph contain the
    same information. The `EntryToken` is the start of the DAG, and the `GraphRoot`
    is the final node. The chain for the control flow is marked with the blue dashed
    arrows. The black arrows denote the data flow. The red arrows glue nodes together,
    preventing reordering them. The graph can get really big even for moderately sized
    functions. It does not contain more or other information than the textual output
    with the `–debug-only=isel` option, only the presentation is more comfortable.
    You can also generate the graph at other points in time, for example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 确保文本表示和此图包含相同的信息。`EntryToken`是DAG的起点，`GraphRoot`是最终节点。控制流的链用蓝色虚线箭头标记。黑色箭头表示数据流。红色箭头将节点粘合在一起，防止重新排序。即使对于中等大小的函数，图可能会变得非常大。它不包含比带有`-debug-only=isel`选项的文本输出更多或其他信息，只是呈现更加舒适。您还可以在其他时间生成图，例如：
- en: Add the `--view-legalize-types-dags` option to see the DAG before type legalization.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`--view-legalize-types-dags`选项添加到类型合法化之前查看DAG。
- en: Add the `–view-isel-dags` option to see the selection instructions.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`–view-isel-dags`选项以查看选择指令。
- en: You can see all available options to view the DAG using the `--help-hidden`
    option. Because the DAG can get large and confusing, you can limit the rendering
    to one basic block using the `-filter-view-dags` option.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`--help-hidden`选项查看查看DAG的所有可用选项。由于DAG可能变得庞大和混乱，您可以使用`-filter-view-dags`选项将渲染限制为一个基本块。
- en: Examining the instruction selection
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查指令选择
- en: Knowing how to visualize the DAG, we can now dive into the details. The selection
    DAG is constructed from the IR. For each function in the IR, an instance of the
    `SelectionDAG` class is populated by the `SelectionDAGBuilder` class. There are
    no special optimizations done at this step. Nevertheless, a target needs to provide
    some functions to lower calls, argument handling, return jumps, and so on. To
    do so, the target has to implement the `TargetLowering` interface. Inside the
    folder of a target, the source is usually in the `XXXISelLowering.h` and `XXXISelLowering.cpp`
    files. The implementation of the `TargetLowering` interface provides all the information
    needed for the instruction process, for example, which data types and which operations
    are supported on the target.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何可视化DAG后，我们现在可以深入了解细节。选择DAG是从IR构建的。对于IR中的每个函数，`SelectionDAGBuilder`类通过`SelectionDAGBuilder`类填充`SelectionDAG`类的实例。在此步骤中没有进行特殊优化。尽管如此，目标需要提供一些函数来降低调用、参数处理、返回跳转等。为此，目标必须实现`TargetLowering`接口。在目标的文件夹中，源代码通常在`XXXISelLowering.h`和`XXXISelLowering.cpp`文件中。`TargetLowering`接口的实现提供了指令过程所需的所有信息，例如目标上支持的数据类型和操作。
- en: The optimization step is run several times. The optimizer performs simple optimization,
    for example identifying rotates on targets that support these operations. The
    rationale here is that a cleaned-up DAG is produced, which simplifies the other
    steps.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 优化步骤会运行多次。优化器执行简单的优化，例如识别支持这些操作的目标上的旋转。这里的原理是产生一个清理过的DAG，从而简化其他步骤。
- en: 'During the type legalization step, types that are not supported on the target
    are replaced with supported ones. For example, if a target natively supports only
    32-bit-wide integers, then smaller values must be converted to 32-bit through
    sign or zero extension. This is called `TargetLowering` interface. After type
    legalization, the selection DAG has this textual representation for the `sum.ll`
    file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型合法化步骤中，目标不支持的类型将被替换为支持的类型。例如，如果目标本机只支持32位宽整数，则较小的值必须通过符号或零扩展转换为32位。这称为`TargetLowering`接口。类型合法化后，选择DAG对`sum.ll`文件具有以下文本表示：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you compare this with the initial constructed DAG, then here only 32-bit
    registers are used. The 16-bit values were promoted, because only 32-bit values
    are supported natively.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将此与最初构建的DAG进行比较，那么这里只使用了32位寄存器。16位值被提升，因为本机只支持32位值。
- en: Operation legalization is similar to type legalization. This step is necessary
    because not all operations may be supported by a target, or even if a type is
    natively supported on a target, it may not valid for all operations. For example,
    not all targets have a native instruction for population count. In such cases,
    the operation is replaced by a sequence of operations to implement the functionality.
    If the type does not fit for the operation, then promoting the type to a larger
    one could be done. It is also possible for a backend author to provide custom
    code. If the legalization action is set to `Custom`, then the `LowerOperation()`
    method in the `TargetLowering` class is called for these operations. The method
    must create a legal version of the operation then. In the `sum.ll` example, the
    `add` operation is already legal, because addition of two 23-bit registers is
    supported on the platform, and nothing changed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 操作合法化类似于类型合法化。这一步是必要的，因为并非所有操作都可能被目标支持，或者即使目标本机支持某种类型，也可能并非所有操作都有效。例如，并非所有目标都有用于人口统计的本机指令。在这种情况下，该操作将被一系列操作替换以实现功能。如果类型不适合操作，则可以将类型提升为更大的类型。后端作者还可以提供自定义代码。如果合法化操作设置为`Custom`，则将为这些操作调用`TargetLowering`类中的`LowerOperation()`方法。该方法必须创建操作的合法版本。在`sum.ll`示例中，`add`操作已经是合法的，因为平台支持两个23位寄存器的加法，而且没有改变。
- en: After types and operations are legalized, the instruction selection happens.
    A large part of the selection is automated. Remember from the previous section
    that you provided a pattern in the description of an instruction. From these descriptions,
    a pattern matcher is generated by the `llvm-tblgen` tool. Basically, the pattern
    matcher tries to find a pattern that matches the current DAG node. The instruction
    associated with the pattern will then be selected. The pattern matcher is implemented
    as a bytecode interpreter. The available codes for the interpreter are defined
    in the `llvm/CodeGen/SelectionDAGISel.h` header file. The `XXXISelDAGToDAG` class
    implements the instruction selection for a target. The `Select()` method is called
    for each DAG node. The default is to call the generated matcher, but you can also
    add code for cases not handled by it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型和操作被合法化之后，指令选择就会发生。选择的大部分部分是自动化的。请记住前一节中，您在指令描述中提供了一个模式。从这些描述中，`llvm-tblgen`工具生成了一个模式匹配器。基本上，模式匹配器试图找到与当前DAG节点匹配的模式。然后选择与该模式相关联的指令。模式匹配器被实现为字节码解释器。解释器的可用代码在`llvm/CodeGen/SelectionDAGISel.h`头文件中定义。`XXXISelDAGToDAG`类实现了目标的指令选择。对于每个DAG节点，都会调用`Select()`方法。默认情况下会调用生成的匹配器，但您也可以为它未处理的情况添加代码。
- en: 'It is noteworthy that there is no one-to-one relationship between a selection
    DAG node and the selected instructions. A DAG node can expand into several instructions,
    and several DAG nodes can collapse into a single instruction. An example of the
    former is synthesizing immediate values. Especially on RISC architectures, the
    bit length of immediate values is restricted. A 32-bit target may only support
    an embedded immediate value of 16-bit length. To perform an operation that requires
    a 32-bit constant value, you usually split it into two 16-bit values and then
    generate two or more instructions that use the 16-bit values instead. Among others,
    you find patterns for this in the MIPS target. Bit-field instructions are a common
    example for the latter case: combinations of `and`, `or`, and `shift` DAG nodes
    can often be matched to special bit-field instructions, resulting in just one
    instruction for two or more DAG nodes.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，选择DAG节点与所选指令之间没有一对一的关系。DAG节点可以扩展为多条指令，而多个DAG节点可以合并为单条指令。前者的一个例子是合成立即值。特别是在RISC架构上，立即值的位长度受限。32位目标可能仅支持16位长度的嵌入式立即值。要执行需要32位常量值的操作，通常会将其拆分为两个16位值，然后生成使用这两个16位值的两个或更多指令。在MIPS目标中，您会发现这方面的模式。位域指令是后一种情况的常见例子：`and`，`or`和`shift`
    DAG节点的组合通常可以匹配到特殊的位域指令，从而只需一条指令即可处理两个或更多DAG节点。
- en: Usually, you specify a pattern in the target description to combine two or more
    DAG nodes. For more complex cases, which are not easily handled with a pattern,
    you can mark the operation of the top node to require special DAG combine treatment.
    For these nodes, the `PerformDAGCombine()` method in the `XXXISelLowering` class
    is called. You can then check arbitrary complex patterns, and if you find your
    match, then you can return the operation representing the combined DAG nodes.
    This method is called before the generated matcher is run for the DAG node.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可以在目标描述中指定一个模式，以组合两个或多个DAG节点。对于更复杂的情况，这些情况不容易用模式处理，您可以标记顶部节点的操作，需要特殊的DAG组合处理。对于这些节点，在`XXXISelLowering`类中调用`PerformDAGCombine（）`方法。然后，您可以检查任意复杂的模式，如果找到匹配，那么您可以返回表示组合DAG节点的操作。在运行DAG节点的生成匹配器之前调用此方法。
- en: 'You can follow the instruction selection process in the printed output for
    the `sum.ll` file. For the `add` operation, you find there the following lines:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`sum.ll`文件的打印输出中跟踪指令选择过程。对于`add`操作，您会在那里找到以下行：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The index numbers point into the array of the generated matcher. The start is
    at index `27835` (an arbitrary value that can change from release to release),
    and after some steps, the `ADDu` instruction is selected.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 索引号指向生成匹配器的数组。起始索引为`27835`（一个可以在发布版本之间更改的任意值），经过一些步骤后，选择了`ADDu`指令。
- en: Following the pattern matching
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循模式匹配
- en: If you encounter a problem with a pattern, then you can also retrace the matching
    by reading the generated bytecode. You find the source in the `lib/Target/XXX/XXXGenDAGIsel.inc`
    file in the `build` directory. You open the file in a text editor and search for
    the index in the preceding output. Each line is prefixed with the index number,
    so you can easily find the right place in the array. The used predicates are also
    printed as comments, so they can help you to understand why a certain pattern
    was not selected.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到模式问题，您还可以通过阅读生成的字节码来追踪匹配过程。您可以在`build`目录中的`lib/Target/XXX/XXXGenDAGIsel.inc`文件中找到源代码。您可以在文本编辑器中打开文件，并在先前的输出中搜索索引。每行都以索引号为前缀，因此您可以轻松找到数组中的正确位置。使用的谓词也会以注释的形式打印出来，因此它们可以帮助您理解为什么某个特定的模式未被选择。
- en: Turning the DAG into instruction sequences
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将DAG转换为指令序列
- en: After instruction selection, the code is still a graph. This data structure
    needs to be flattened, which means that the instructions must be sequentially
    ordered. The graph contains data and control flow dependencies, but there are
    always several possibilities to order the instructions in such a way that these
    dependencies are fulfilled. What we want is an order that best utilizes the hardware.
    Modern hardware can issue several instructions in parallel, but restrictions always
    apply. A simple example of such a restriction is one instruction requiring the
    result of another instruction. In such a case, the hardware may not be able to
    issue both instructions and instead executes the instructions in sequence.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在指令选择之后，代码仍然是一个图。这种数据结构需要被展平，这意味着指令必须按顺序排列。图包含数据和控制流依赖关系，但总是有几种可能的方式来安排指令，以满足这些依赖关系。我们希望的是一种最大程度利用硬件的顺序。现代硬件可以并行发出多条指令，但总是有限制。这种限制的一个简单例子是一个指令需要另一个指令的结果。在这种情况下，硬件可能无法发出两条指令，而是按顺序执行指令。
- en: You can add a scheduling model to the target description, which describes the
    available units and their properties. For example, if a CPU has two integer arithmetic
    units, then this information is captured in the model. For each instruction, it
    is necessary to know which part of the model is used. There are different ways
    to do this. The newer, recommended approach is to define a scheduling model using
    the so-called machine-instruction scheduler. To do so, you need to define a `SchedMachineModel`
    record for each subtarget in the target description. Basically, the model consists
    of definitions for the input and output operands of instructions and processor
    resources. Both definitions are then associated together with latency values.
    You can look up the predefined types for this model in the `llvm/Target/TargetSched.td`
    file. Look at the Lanai target for a very simple model and in the SystemZ target
    for a complex scheduling model.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向目标描述添加调度模型，描述可用的单元及其属性。例如，如果CPU有两个整数算术单元，那么这些信息就被捕捉在模型中。对于每个指令，有必要知道模型的哪个部分被使用。有不同的方法来做到这一点。较新的、推荐的方法是使用所谓的机器指令调度器来定义调度模型。为此，您需要为目标描述中的每个子目标定义一个`SchedMachineModel`记录。基本上，模型由指令和处理器资源的输入和输出操作数的定义组成。然后，这两个定义与延迟值一起关联。您可以在`llvm/Target/TargetSched.td`文件中查找此模型的预定义类型。查看Lanai目标以获取一个非常简单的模型，并在SystemZ目标中获取一个复杂的调度模型。
- en: There is also an older model based on so-called itineraries. With this model,
    you define processor units as `FuncUnit` records. A step using such a unit is
    defined as an `InstrStage` record. Each instruction is associated with an itinerary
    class. For each itinerary class, the used processor pipeline composed of `InstrStage`
    records is defined, together with the number of processor cycles required for
    execution. You can find the predefined types for the itinerary model in the `llvm/Target/TargetItinerary.td`
    file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个基于所谓行程的较旧模型。使用这个模型，您将处理器单元定义为`FuncUnit`记录。使用这样一个单元的步骤被定义为`InstrStage`记录。每个指令都与一个行程类相关联。对于每个行程类，定义了使用的处理器流水线由`InstrStage`记录组成，以及执行所需的处理器周期数。您可以在`llvm/Target/TargetItinerary.td`文件中找到行程模型的预定义类型。
- en: Some targets use both models. One reason is due to development history. The
    itinerary-based model was the first one added to LLVM, and targets began using
    this model. When the new machine-instruction scheduler was added more than 5 years
    later, nobody cared enough to migrate the already existing models. Another reason
    is that with the itinerary model, you can not only model an instruction that uses
    multiple processor units, but you can also specify during which cycles the units
    are used. However, this detail level is rarely needed, and if it is needed, then
    you can refer to the machine-instruction scheduler model to the defined itineraries,
    basically pulling this information into the new model too.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一些目标同时使用这两种模型。一个原因是由于开发历史。基于行程的模型是最早添加到LLVM中的，目标开始使用这个模型。当新的机器指令调度器在5年多以后添加时，没有人关心足够迁移已经存在的模型。另一个原因是，使用行程模型不仅可以对使用多个处理器单元的指令进行建模，还可以指定在哪些周期使用这些单元。然而，这种细节级别很少需要，如果需要，那么可以参考机器指令调度器模型来定义行程，基本上将这些信息也引入到新模型中。
- en: If present, the scheduling model is used to order the instructions in an optimal
    way. After this step, the DAG is not needed anymore and is destroyed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在，调度模型用于以最佳方式排序指令。在这一步之后，DAG不再需要，并被销毁。
- en: Performing instruction selection with the selection DAG produces almost optimal
    results, but it comes at a cost in terms of runtime and memory usage. Therefore,
    alternative approaches were developed, which we examine next. In the next section,
    we look at the fast instruction selection approach.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用选择DAG进行指令选择几乎可以得到最佳结果，但在运行时和内存使用方面会付出代价。因此，开发了替代方法，我们将在下一节中进行讨论。在下一节中，我们将看一下快速指令选择方法。
- en: Fast instruction selection – FastISel
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速指令选择 - FastISel
- en: Using the selection DAG for instruction selection costs compile time. If you
    are developing an application, then the runtime of the compiler matters. You also
    do not care about the generated code so much, because it is more important that
    complete debug information is emitted. Because of these reasons, the LLVM developers
    decided to implement a special instruction selector that has a fast runtime but
    produces less optimal code, and which is used only for `–O0` optimization level.
    This component is called fast instruction selection, or **FastIsel** for short.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用选择DAG进行指令选择会消耗编译时间。如果您正在开发一个应用程序，那么编译器的运行时很重要。您也不太关心生成的代码，因为更重要的是发出完整的调试信息。因此，LLVM开发人员决定实现一个特殊的指令选择器，它具有快速的运行时，但生成的代码不太优化，并且仅用于`-O0`优化级别。这个组件称为快速指令选择，简称**FastIsel**。
- en: 'The implementation is in the `XXXFastISel` classes. Not every target supports
    this instruction selection method, in which case the selection DAG approach is
    used for `–O0`, too. The implementation is straightforward: a target-specific
    class is derived from a `FastISel` class and has to implement a couple of methods.
    The TableGen tool generates most of the required code from the target description.
    Nevertheless, there is some effort needed to implement this instruction selector.
    One of the root causes is that you need to get the calling convention right, which
    is usually complex.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 实现在`XXXFastISel`类中。并非每个目标都支持这种指令选择方法，如果是这种情况，选择DAG方法也用于`-O0`。实现很简单：从`FastISel`类派生一个特定于目标的类，并实现一些方法。TableGen工具从目标描述中生成了大部分所需的代码。然而，需要一些工作来实现这个指令选择器。一个根本原因是你需要正确地获取调用约定，这通常是复杂的。
- en: 'The MIPS target features an implementation of fast instruction selection. You
    can enable use of fast instruction selection by passing the `–fast-isel` option
    to `llc` tool. Using the `sum.ll` example file from first section, an invocation
    looks like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: MIPS目标具有快速指令选择的实现。您可以通过向`llc`工具传递`-fast-isel`选项来启用快速指令选择。使用第一节中的`sum.ll`示例文件，调用如下：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Fast instruction selection runs very quickly, but it is a completely different
    code path. Some LLVM developers decided to look for a solution that runs quickly
    but can also produce good code, with the goal to replace both the selection `dag`
    and the fast instruction selector in the future. We look at this approach in the
    next section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 快速指令选择运行非常快，但它是一条完全不同的代码路径。一些LLVM开发人员决定寻找一个既能快速运行又能产生良好代码的解决方案，目标是在未来替换选择`dag`和快速指令选择器。我们将在下一节讨论这种方法。
- en: The new global instruction selection – GlobalISel
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的全局指令选择 - GlobalISel
- en: Using the selection DAG, we can generate pretty good machine code. The drawback
    is that it is a very complex piece of software. This means that it is hard to
    develop, test, and maintain. The FastISel instruction selection works quickly
    and is less complex, but does not produce good code. Both approaches do not share
    much code, except for the code generated by TableGen.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用选择dag，我们可以生成相当不错的机器代码。缺点是它是一个非常复杂的软件。这意味着它很难开发、测试和维护。快速指令选择工作迅速，复杂性较低，但不能产生良好的代码。除了由TableGen生成的代码外，这两种方法几乎没有共享代码。
- en: Can we have the best of both worlds? One instruction selection algorithm, which
    is fast, easy to implement, and which produces good code? That is the motivation
    for adding another instruction selection algorithm, the global instruction selection,
    to the LLVM framework. The short-term goal is to replace FastISel first, and in
    the long term the selection DAG, too.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否兼得两全？一种指令选择算法，既快速，易于实现，又能产生良好的代码？这就是向LLVM框架添加另一种指令选择算法 - 全局指令选择的动机。短期目标是首先替换FastISel，长期目标是替换选择dag。
- en: The approach taken by global instruction selection is to build on the existing
    infrastructure. The whole task is broken down into a sequence of machine function
    passes. Another major design decision is to not introduce another intermediate
    representation but instead use the existing `MachineInstr` class. However, new
    generic opcodes are added.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 全局指令选择采用的方法是建立在现有基础设施之上。整个任务被分解为一系列机器函数传递。另一个主要的设计决定是不引入另一种中间表示，而是使用现有的`MachineInstr`类。但是，会添加新的通用操作码。
- en: 'The current sequence of steps is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的步骤顺序如下：
- en: The `IRTranslator` pass builds the initial machine instructions using the generic
    opcodes.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IRTranslator` pass使用通用操作码构建初始机器指令。'
- en: The `Legalizer` pass legalizes types and operations in one step. This is different
    from the selection DAG, which uses two different steps for it. Real CPU architectures
    are sometimes weird, and it is possible that a certain data type is only supported
    with one instruction. This case is not handled well by the selection DAG, but
    it's easy to handle this in the combined step in the global instruction selection.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Legalizer` pass在一步中使类型和操作合法化。这与选择dag不同，后者需要两个不同的步骤。真实的CPU架构有时很奇怪，可能只支持某种数据类型的一条指令。选择dag处理这种情况不好，但在全局指令选择的组合步骤中很容易处理。'
- en: The generated machine instructions still operate on virtual registers. In the
    `RegBankSelect` pass, a register bank is selected. A register bank represents
    a type of registers on the CPU, for example, general-purpose registers. This is
    more coarse-grained than the register definitions in the target description. The
    important point is that it associates type information with the instruction. The
    type information is based on the types available in the target, so this is already
    lower than the generic type in LLVM IR.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的机器指令仍然在虚拟寄存器上操作。在`RegBankSelect` pass中，选择了一个寄存器组。寄存器组代表CPU上的寄存器类型，例如通用寄存器。这比目标描述中的寄存器定义更粗粒度。重要的是它将类型信息与指令关联起来。类型信息基于目标中可用的类型，因此这已经低于LLVM
    IR中的通用类型。
- en: At this point, the types and operations are known to be legal for the target,
    and type information is associated with each instruction. The following `InstructionSelect`
    pass can then easily replace the generic instructions with the machine ones.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，已知类型和操作对于目标是合法的，并且每条指令都与类型信息相关联。接下来的`InstructionSelect` pass可以轻松地用机器指令替换通用指令。
- en: After the global instruction selection, the usual backend passes such as instruction
    scheduling, register allocation, and basic block placement are run.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 全局指令选择后，通常会运行后端传递，如指令调度、寄存器分配和基本块放置。
- en: Global instruction selection is compiled into LLVM, but it is not enabled by
    default. If you want to use it, you need to give the `–global-isel` option to
    `llc` or `–mllvm global-isel` to `clang`. You can control what happens if an IR
    construct cannot be handled by global instruction selection. When you give the
    `-global-isel-abort=0` option to `llc`, then the selection DAG is used as fallback.
    With `=1`, the application is terminated. To prevent this, you can give the `-global-isel-abort=0`
    option to `llc`. And with `=2`, the selection DAG is used as fallback, and a diagnostic
    message is printed to inform you about the problem.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 全局指令选择已编译到LLVM中，但默认情况下未启用。如果要使用它，需要给`llc`传递`-global-isel`选项，或者给`clang`传递`-mllvm
    global-isel`选项。您可以控制全局指令选择无法处理IR构造时的处理方式。当您给`llc`传递`-global-isel-abort=0`选项时，选择dag将作为后备。使用`=1`时，应用程序将终止。为了防止这种情况，您可以给`llc`传递`-global-isel-abort=0`选项。使用`=2`时，选择dag将作为后备，并打印诊断消息以通知您有关问题。
- en: To add global instruction selection to a target, you only need to override the
    corresponding functions in the `TargetPassConfig` class of your target. This class
    is instantiated by the `XXXTargetMachine` class, and the implementation is usually
    found in the same file. For example, you override the `addIRTranslator()` method
    to add the `IRTranslator` pass to the machine passes of your target.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要将全局指令选择添加到目标，您只需要重写目标的`TargetPassConfig`类中的相应函数。这个类由`XXXTargetMachine`类实例化，并且实现通常可以在同一个文件中找到。例如，您可以重写`addIRTranslator()`方法，将`IRTranslator`
    pass添加到目标的机器pass中。
- en: The development happens mainly on the AArch64 target, which currently has the
    best support for global instruction selection. Many other targets, including x86
    and Power, have also added support for global instruction selection. One challenge
    here is that not that much code is generated from the table description, so there
    is still an amount of manual coding you have to do. Another challenge is that
    big-endian targets are currently not supported, so pure big-endian targets such
    as SystemZ cannot use global instruction selection as of today. Both will certainly
    improve over time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 开发主要发生在AArch64目标上，目前该目标对全局指令选择有最好的支持。许多其他目标，包括x86和Power，也已经添加了对全局指令选择的支持。一个挑战是从表描述中生成的代码并不多，所以仍然有一定量的手动编码需要完成。另一个挑战是目前不支持大端目标，因此纯大端目标（如SystemZ）目前无法使用全局指令选择。这两个问题肯定会随着时间的推移得到改善。
- en: 'The Mips target features an implementation of global instruction selection,
    with the mentioned limitation that it can only be used for little-endian targets.
    You can enable use of global instruction selection by passing the `–global-isel`
    option to the `llc` tool. Using the `sum.ll` example file from first section,
    an invocation looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Mips目标具有全局指令选择的实现，但有一个限制，即它只能用于小端目标。您可以通过向`llc`工具传递`–global-isel`选项来启用全局指令选择。使用第一节的`sum.ll`示例文件，调用如下：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Please note that the target `mipsel-linux-gnu` is the little-endian target.
    Using the big-endian `mips-linux-gnu` target results in an error message.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目标`mipsel-linux-gnu`是小端目标。使用大端`mips-linux-gnu`目标会导致错误消息。
- en: The global instruction selector works much quicker than the selection DAG, and
    already produces higher code quality than fast instruction selection.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 全局指令选择器比选择DAG快得多，并且已经产生了比快速指令选择更高的代码质量。
- en: Supporting new machine instructions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持新的机器指令
- en: The CPU you are targeting may have machine instructions not yet supported by
    LLVM. For example, manufacturers using the MIPS architecture often add special
    instructions to the core MIPS instruction set. The specification of the RISC-V
    instruction set explicitly allows manufacturers to add new instructions. Or you
    are adding a completely new backend, and then you must add the instructions of
    the CPU. In the next section, we will add assembler support for a single, new
    machine instruction to an LLVM backend.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您的目标CPU可能具有LLVM尚不支持的机器指令。例如，使用MIPS架构的制造商经常向核心MIPS指令集添加特殊指令。RISC-V指令集的规范明确允许制造商添加新指令。或者您正在添加一个全新的后端，那么您必须添加CPU的指令。在下一节中，我们将为LLVM后端的单个新机器指令添加汇编器支持。
- en: Adding a new instruction to the assembler and code generation
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加汇编和代码生成的新指令
- en: New machine instructions are usually tied to a certain CPU feature. Then the
    new instruction is only recognized if the user has selected the feature using
    the `--mattr=` option to `llc`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 新的机器指令通常与特定的CPU特性相关联。然后，只有在用户使用`--mattr=`选项选择了该特性时，新指令才会被识别。
- en: 'As an example, we will add a new machine instruction to the MIPS backend. The
    imaginary, new machine instruction first squares the value of the two input registers
    `$2` and `$3` and assigns the sum of both squares to the output register `$1`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将在MIPS后端添加一个新的机器指令。这个虚构的新机器指令首先将两个输入寄存器`$2`和`$3`的值平方，然后将两个平方的和赋给输出寄存器`$1`：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The name of the instruction is `sqsumu`, derived from the square and summation
    operation. The last `u` in the name indicates that the instruction works on unsigned
    integers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 指令的名称是`sqsumu`，源自平方和求和操作。名称中的最后一个`u`表示该指令适用于无符号整数。
- en: The CPU feature we are adding first is called `sqsum`. This will allow us to
    call `llc` with the `--mattr=+sqsum` option to enable recognition of the new instruction.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要添加的CPU特性称为`sqsum`。这将允许我们使用`--mattr=+sqsum`选项调用`llc`来启用对新指令的识别。
- en: 'Most of the code we will add is in the `llvm/lib/Target/Mips` folder. The top-level
    file is `Mips.td`. Look at the file and locate the section in which the various
    features are defined. Here you add the definition of our new feature:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加的大部分代码位于`llvm/lib/Target/Mips`文件夹中。顶层文件是`Mips.td`。查看该文件，并找到定义各种特性的部分。在这里，您添加我们新特性的定义：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `SubtargetFeature` class takes four template parameters. The first, `sqsum`,
    is the name of the feature, for use on the command line. The second parameter,
    `HasSQSum`, is the name of the attribute in the `Subtarget` class representing
    this feature. The next parameters are the default value and the description of
    the feature, used for providing help on the command line. TableGen generates the
    base class for the `MipsSubtarget` class, defined in `MipsSubtarget.h` file. In
    this file, we add the new attribute in the private part of the class, where all
    the other attributes are defined:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`SubtargetFeature`类有四个模板参数。第一个`sqsum`是特性的名称，用于命令行。第二个参数`HasSQSum`是`Subtarget`类中表示此特性的属性的名称。接下来的参数是特性的默认值和描述，用于在命令行上提供帮助。TableGen会为`MipsSubtarget`类生成基类，该类在`MipsSubtarget.h`文件中定义。在这个文件中，我们在类的私有部分添加新属性，其中定义了所有其他属性：'
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the public part, we also a method to retrieve the value of the attribute.
    We need this method for the next addition:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共部分，我们还添加了一个方法来检索属性的值。我们需要这个方法来进行下一个添加：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With these additions, we are already able to set the `sqsum` feature on the
    command line, albeit without effect.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些添加，我们已经能够在命令行上设置`sqsum`功能，尽管没有效果。
- en: 'To tie the new instruction to the `sqsum` feature, we need to define a predicate
    that indicates whether the feature is selected or not. We add this to the `MipsInstrInfo.td`
    file, either in the section where all the other predicates are defined or simply
    at the end:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将新指令与`sqsum`功能关联起来，我们需要定义一个谓词，指示是否选择了该功能。我们将其添加到`MipsInstrInfo.td`文件中，可以是在定义所有其他谓词的部分，也可以简单地添加到末尾：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The predicate uses the `hasSQSum()` method defined earlier. Additionally, the
    `AssemblerPredicate` template specifies the condition used when generating the
    source code for the assembler. We simply refer to the previously defined feature.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 该谓词使用先前定义的`hasSQSum()`方法。此外，`AssemblerPredicate`模板指定了在为汇编器生成源代码时使用的条件。我们只需引用先前定义的功能。
- en: 'We also need to update the scheduling model. The MIPS target uses both the
    itinerary and the machine-instruction scheduler. For the itinerary model, an `InstrItinClass`
    record is defined for each instruction in the `MipsSchedule.td` file. Simply add
    the following line in this file in the section where all the itineraries are defined:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新调度模型。MIPS目标使用行程表和机器指令调度器。对于行程表模型，在`MipsSchedule.td`文件中为每条指令定义了一个`InstrItinClass`记录。只需在此文件的所有行程表都被定义的部分添加以下行：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We also need to give details about the instruction costs. Usually, you find
    this information in the documentation for the CPU. For our instruction, we optimistically
    assume that it just takes one cycle in the ALU. This information is added to the
    `MipsGenericItineraries` definition in the same file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要提供有关指令成本的详细信息。通常，您可以在CPU的文档中找到这些信息。对于我们的指令，我们乐观地假设它只需要在ALU中一个周期。这些信息被添加到同一文件中的`MipsGenericItineraries`定义中：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With this, the update to the itinerary-based scheduling model is complete.
    The MIPS target also defines a generic scheduling model based on the machine-instruction
    scheduler model in the `MipsScheduleGeneric.td` file. Because this is a complete
    model covering all instructions, we also need to add our instruction add. As it
    is based on multiplication, we simply extend the existing definition for the `MULT`
    and `MULTu` instructions:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，基于行程表的调度模型的更新就完成了。MIPS目标还在`MipsScheduleGeneric.td`文件中定义了一个基于机器指令调度器模型的通用调度模型。因为这是一个涵盖所有指令的完整模型，我们还需要添加我们的指令。由于它是基于乘法的，我们只需扩展`MULT`和`MULTu`指令的现有定义：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The MIPS target also defines a scheduling model for the P5600 CPU in the `MipsScheduleP5600.td`
    file. Our new instruction is obviously not supported on this target, so we add
    it to the list of unsupported features:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: MIPS目标还在`MipsScheduleP5600.td`文件中为P5600 CPU定义了一个调度模型。显然，我们的新指令在这个目标上不受支持，所以我们将其添加到不支持的功能列表中：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we are ready to add the new instruction at the end of the `Mips64InstrInfo.td`
    file. TableGen definitions are always terse, therefore we dissect them. The definition
    uses some predefined classes from the MIPS target descriptions. Our new instruction
    is an arithmetic instruction, and by design, it fits the `ArithLogicR` class.
    The first parameter, `"sqsumu"`, specifies the assembler mnemonic of the instruction.
    The next parameter, `GPR64Opnd`, states that the instructions use 64-bit registers
    as operands and the following `1` parameter indicates that the operands are commutative.
    Last, an itinerary is given for the instruction. The `ADD_FM` class is given to
    specify the binary encoding of the instruction. For a real instruction, the parameters
    must be chosen according to the documentation. Then follows the `ISA_MIPS64` predicate,
    which indicates for which instruction set the instruction is valid. And last,
    our `SQSUM` predicate states that the instruction is only valid when our feature
    is enabled. The complete definition is as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备在`Mips64InstrInfo.td`文件的末尾添加新指令。TableGen定义总是简洁的，因此我们对其进行分解。该定义使用MIPS目标描述中的一些预定义类。我们的新指令是一个算术指令，并且按设计，它适用于`ArithLogicR`类。第一个参数`"sqsumu"`指定了指令的汇编助记符。下一个参数`GPR64Opnd`表示指令使用64位寄存器作为操作数，接下来的`1`参数表示操作数是可交换的。最后，为指令给出了一个行程表。`ADD_FM`类用于指定指令的二进制编码。对于真实的指令，必须根据文档选择参数。然后是`ISA_MIPS64`谓词，指示指令适用于哪个指令集。最后，我们的`SQSUM`谓词表示只有在启用我们的功能时指令才有效。完整的定义如下：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you only aim to support the new instruction, then this definition is enough.
    Be sure to finish the definition with `;` in this case. With the addition of a
    selection DAG pattern, you make the instruction available to the code generator.
    The instruction uses the two operand registers `$rs` and `$rt` and the destination
    register `$rd`, all three defined by the `ADD_FM` binary format class. In theory,
    the pattern to match is then simple: the value of each register is squared using
    the `mul` multiplication operator, and then the two products are added using the
    `add` operator and assigned to the destination register `$rd`. The pattern gets
    a bit more complicated because, with the MIPS instruction set, the result of a
    multiplication is stored in a special register pair. To be usable, the result
    must be moved to a general-purpose register. During legalization of operations,
    the generic `mul` operator is replaced with the MIPS-specific `MipsMult` operation
    for the multiplication and the `MipsMFLO` operation to move the lower part of
    the result into a general-purpose register. We must take this into account when
    writing the pattern, which looks as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想支持新指令，那么这个定义就足够了。在这种情况下，请确保用 `;` 结束定义。通过添加选择DAG模式，您可以使指令可用于代码生成器。该指令使用两个操作寄存器
    `$rs` 和 `$rt`，以及目标寄存器 `$rd`，这三个寄存器都由 `ADD_FM` 二进制格式类定义。理论上，要匹配的模式很简单：使用 `mul`
    乘法运算符对每个寄存器的值进行平方，然后使用 `add` 运算符将两个乘积相加，并赋值给目标寄存器 `$rd`。模式变得有点复杂，因为在MIPS指令集中，乘法的结果存储在一个特殊的寄存器对中。为了可用，结果必须移动到通用寄存器中。在操作合法化期间，通用的
    `mul` 运算符被替换为MIPS特定的 `MipsMult` 操作进行乘法，以及 `MipsMFLO` 操作将结果的低位部分移动到通用寄存器中。在编写模式时，我们必须考虑到这一点，模式如下所示：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As described in the *Instruction selection with the selection DAG* section,
    if this pattern matches the current DAG node, then our new instruction is selected.
    Because of the `SQSUM` predicate, this only happens when the `sqsum` feature is
    activated. Let's check it with a test!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如*使用选择DAG进行指令选择*部分所述，如果此模式与当前DAG节点匹配，则会选择我们的新指令。由于 `SQSUM` 谓词，只有在激活 `sqsum`
    功能时才会发生这种情况。让我们用一个测试来检查一下！
- en: Testing the new instruction
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试新指令
- en: If you extend LLVM, then it is good practice to verify it with automated tests.
    Especially if you want to contribute your extension to the LLVM project, then
    good tests are required.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您扩展了LLVM，那么最好的做法是使用自动化测试来验证。特别是如果您想将您的扩展贡献给LLVM项目，那么就需要良好的测试。
- en: 'After adding a new machine instruction as we did in the last section, we must
    check two different aspects:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中添加了一个新的机器指令后，我们必须检查两个不同的方面：
- en: First, we have to verify that the instruction encoding is correct.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们必须验证指令编码是否正确。
- en: Second, we must make sure that the code generation works as expected.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们必须确保代码生成按预期工作。
- en: 'The LLVM projects use `llvm-mc` tool. Besides other tasks, this tool can show
    the encoding of an instruction. For an ad hoc check, you can run the following
    command to show the instruction encoding:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM项目使用 `llvm-mc` 工具。除了其他任务，此工具可以显示指令的编码。为了进行临时检查，您可以运行以下命令来显示指令的编码：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This already shows part of the input and the command to run in an automated
    test case. To verify the result, you use the `FileCheck` tool. The output of `llvm-mc`
    is piped into this tool. Additionally, `FileCheck` reads the test case file. The
    test case file contains lines marked with the `CHECK:` keyword, after which the
    expected output follows. `FileCheck` tries to match these lines against the data
    piped into it. If no match is found, then an error is displayed. Place the `sqsumu.s`
    test case file with the following content into the `llvm/test/MC/Mips` directory:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经显示了部分输入和在自动化测试用例中运行的命令。为了验证结果，您可以使用 `FileCheck` 工具。`llvm-mc` 的输出被传送到这个工具中。此外，`FileCheck`
    会读取测试用例文件。测试用例文件包含了以 `CHECK:` 关键字标记的行，之后是预期的输出。`FileCheck` 会尝试将这些行与传送到它的数据进行匹配。如果没有找到匹配项，则会显示错误。将以下内容的
    `sqsumu.s` 测试用例文件放入 `llvm/test/MC/Mips` 目录中：
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you are inside the `llvm/test/Mips/MC` folder, then you can run the test
    with the following command, which reports success at the end:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 `llvm/test/Mips/MC` 文件夹中，可以使用以下命令运行测试，最后会报告成功：
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The LIT tool interprets the `RUN:` line, replacing `%s` with the current filename.
    The `FileCheck` tool reads the file, parses the `CHECK:` lines, and tries to match
    the input from the pipe. This is a very effective way of testing.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: LIT 工具解释 `RUN:` 行，将 `%s` 替换为当前的文件名。`FileCheck` 工具读取文件，解析 `CHECK:` 行，并尝试匹配来自管道的输入。这是一种非常有效的测试方法。
- en: 'If you are in the `build` directory, you can invoke the LLVM tests with this
    command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在 `build` 目录中，可以使用以下命令调用LLVM测试：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can also run the tests contained in one folder, by adding the folder name
    separated by a dash. To run the tests in the `llvm/test/Mips/MC` folder, you type
    the following command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以运行一个文件夹中包含的测试，只需添加以破折号分隔的文件夹名称。要运行 `llvm/test/Mips/MC` 文件夹中的测试，可以输入以下命令：
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To construct a test case for the code generation, you follow the same strategy.
    The following `sqsum.ll` file contains LLVM IR code to calculate the hypotenuse
    square:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要为代码生成构建一个测试用例，您可以遵循相同的策略。以下的 `sqsum.ll` 文件包含了用于计算斜边平方的LLVM IR代码：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To see the generated assembly code, you use the `llc` tool:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看生成的汇编代码，您可以使用 `llc` 工具：
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Convince yourself that you see our new `sqsum` instruction in the output. Please
    also check that the instruction is not generated if you remove the `–mattr=+sqsum`
    option.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您在输出中看到我们的新 `sqsum` 指令。还请检查，如果删除 `–mattr=+sqsum` 选项，则不会生成该指令。
- en: 'Equipped with this knowledge, you can construct the test case. This time, we
    use two `RUN:` lines: one to check that our new instruction is generated, and
    one to check that it is not. We can do both with one test case file because we
    can tell the `FileCheck` tool to look for a different label than `CHECK:`. Put
    the test case file `sqsum.ll` with the following content into the `llvm/test/CodeGen/Mips`
    folder:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了这些知识，您可以构建测试用例。这次，我们使用两个`RUN：`行：一个用于检查我们是否生成了新指令，另一个用于检查是否没有生成。我们可以在一个测试用例文件中执行这两个操作，因为我们可以告诉`FileCheck`工具查找的标签与`CHECK：`不同。将以下内容的测试用例文件`sqsum.ll`放入`llvm/test/CodeGen/Mips`文件夹中：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As with the other test, you can run the test alone in the folder with the following
    command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他测试一样，您可以使用以下命令在文件夹中单独运行测试：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Alternatively, you can run it from the build directory with the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下命令从构建目录运行它：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With these steps, you enhanced the LLVM assembler with a new instruction, enabled
    the instruction selection to use this new instruction, and verified that the encoding
    is correct and the code generation works as expected.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，您增强了LLVM汇编器的功能，使其支持新指令，启用了指令选择以使用这个新指令，并验证了编码是否正确，代码生成是否按预期工作。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how the backend of an LLVM target is structured.
    You used the MIR to examine the state after a pass and you used machine IR to
    run a single pass. With this knowledge, you can investigate problems in backend
    passes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了LLVM目标的后端结构。您使用MIR来检查通过后的状态，并使用机器IR来运行单个通过。有了这些知识，您可以调查后端通过中的问题。
- en: You learned how instruction selection with the help of the selection DAG is
    implemented in LLVM, and you also were introduced to alternative methods for instruction
    selection with FastISel and GlobalISel, which helps in deciding which algorithm
    to choose if your platform offers all of them.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您学习了LLVM中如何使用选择DAG来实现指令选择，并且还介绍了使用FastISel和GlobalISel进行指令选择的替代方法，这有助于决定如果您的平台提供所有这些算法，则选择哪种算法。
- en: You extended LLVM to support a new machine instruction in the assembler and
    in the instruction selection, helping you to add support for currently unsupported
    CPU features. To validate the extension, you developed automated test cases for
    it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您扩展了LLVM以支持汇编器中的新机器指令和指令选择，帮助您添加对当前不支持的CPU功能的支持。为了验证扩展，您为其开发了自动化测试用例。
- en: 'In the next chapter, we examine another unique feature of LLVM: generating
    and executing code in one step, also known as **Just-In-Time** (**JIT**) compilation.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究LLVM的另一个独特特性：一步生成和执行代码，也称为**即时**（**JIT**）编译。
