- en: Wrapping Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we will mop up a couple of subjects that didn''t quite make
    it into the earlier chapters. We’ll make our application more testable by moving
    object creation into an object factory. We’ll make our UI even more dynamic by
    adding scaling capabilities. `EnumeratorDecorator` properties get their own UI
    components, and we’ll put them to use when we add contact management. Finally,
    we’ll wrap everything up by packaging and deploying our application. We will cover
    the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将总结一些在之前章节中没有完全涉及的主题。我们将通过将对象创建移动到对象工厂来使我们的应用程序更具可测试性。我们将通过添加缩放功能使我们的UI更加动态。`EnumeratorDecorator`属性将拥有自己的UI组件，并且当我们添加联系人管理时，我们将利用它们。最后，我们将通过打包和部署我们的应用程序来总结一切。我们将涵盖以下主题：
- en: Object factories
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象工厂
- en: Dynamic UI scaling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态UI缩放
- en: Adding an image to the Dashboard
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像添加到仪表板
- en: Enumerator selectors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举选择器
- en: Managing Contacts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理联系人
- en: Deployment and installation of our application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和安装我们的应用程序
- en: Object factory
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象工厂
- en: In a larger system with more comprehensive `MasterController` tests in place,
    having all of that object creation hard-coded inside the private implementation
    will cause problems because of the tight coupling between the `MasterController`
    and its dependencies. One option will be to create all the other objects in `main()`
    instead and inject them into the `MasterController` constructor as we have done
    with the other controllers. This will mean injecting a lot of constructor parameters,
    and it is handy to be able to keep the `MasterController` instance as the parent
    of all the other objects, so we will inject a single object factory that the controller
    can use for all of its object creation needs instead.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更大的系统中，如果`MasterController`测试更全面，那么将所有这些对象创建硬编码在私有实现中将会导致问题，因为`MasterController`与其依赖之间的紧密耦合。一个选择是在`main()`中创建所有其他对象，并将它们注入到`MasterController`构造函数中，就像我们对其他控制器所做的那样。这将意味着注入大量的构造函数参数，而且能够将`MasterController`实例作为所有其他对象的父对象是很方便的，因此我们将注入一个单一的对象工厂，控制器可以使用它来满足其所有对象创建需求。
- en: 'The critical part of this factory pattern is to hide everything behind interfaces,
    so when testing `MasterController`, you can pass in a mock factory and control
    all the object creation. In `cm-lib`, create a new `i-object-factory.h` header
    file in `source/framework`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工厂模式的关键部分是将所有内容隐藏在接口后面，因此在测试`MasterController`时，您可以传入一个模拟工厂并控制所有对象的创建。在`cm-lib`中，在`source/framework`中创建一个新的`i-object-factory.h`头文件：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All the objects we will create will be moved behind interfaces apart from the
    models. This is because they are essentially just data containers, and we can
    easily create real instances in a test scenario with no side effects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模型之外，我们将创建的所有对象都将被移动到接口后面。这是因为它们本质上只是数据容器，我们可以在测试场景中轻松创建真实实例，而不会产生任何副作用。
- en: We will skip that exercise here for brevity and leave it as an exercise for
    the reader. Use `IDatabaseController` as an example or refer to the code samples.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 出于简洁起见，我们将跳过这个练习，并将其留给读者自己练习。使用`IDatabaseController`作为示例或参考代码示例。
- en: 'With the factory interface available, change the `MasterController` constructor
    to take an instance as a dependency:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有了工厂接口可用，将`MasterController`构造函数更改为接受一个实例作为依赖项：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We pass the object through to `Implementation` and store it in a private member
    variable as we have done numerous times before. With the factory available, we
    can now move all the `new` based object creation statements into a concrete implementation
    of the `IObjectFactory` interface (the `ObjectFactory` class) and replace those
    statements in `MasterController` with something more abstract and testable:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对象传递给`Implementation`并将其存储在一个私有成员变量中，就像以前做过的那样。有了工厂可用，我们现在可以将所有基于`new`的对象创建语句移动到`IObjectFactory`接口的具体实现（`ObjectFactory`类）中，并用更抽象和可测试的内容替换`MasterController`中的这些语句：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, when testing `MasterController`, we can pass in a mock implementation
    of the `IObjectFactory` interface and control the creation of objects. In addition
    to implementing `ObjectFactory` and passing it to `MasterController` when we instantiate
    it, one further change is that in `main.cpp`, we now need to register the interfaces
    to `NavigationController` and `CommandController`, rather than the concrete implementations. 
    We do this by simply swapping out the `qmlRegisterType` statements with the `qmlRegisterUncreatableType`
    companion:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在测试`MasterController`时，我们可以传入`IObjectFactory`接口的模拟实现，并控制对象的创建。除了实现`ObjectFactory`并在实例化`MasterController`时将其传递给它之外，另一个变化是在`main.cpp`中，我们现在需要注册接口到`NavigationController`和`CommandController`，而不是具体的实现。我们可以通过简单地用`qmlRegisterUncreatableType`的伴随语句替换`qmlRegisterType`语句来实现这一点：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: UI scaling
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UI缩放
- en: We’ve focused a lot on responsive UI in this book, using anchors and relative
    positioning where possible so that when the user resizes the window, the contents
    scale and adjust themselves appropriately. We’ve also pulled all the “hard-coded”
    properties like sizes and colors into a centralized Style object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们非常关注响应式UI，尽可能使用锚点和相对定位，以便当用户调整窗口大小时，内容可以按比例缩放和适当调整。我们还将所有“硬编码”的属性，如大小和颜色，都放入了一个集中的样式对象中。
- en: If we pick a property concerned with sizing, for example, `sizeScreenMargin`,
    it currently has a fixed value of `20`. If we decide to increase the starting
    size of our **Window** element in `MasterView`, this screen margin size will remain
    the same. Now, it’s really easy to increase the screen margin too, thanks to the
    Style object, but it would be nice if all the hard-coded properties could scale
    up and down dynamically along with our **Window** element. That way, we can try
    out different window sizes without having to update Style each time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择一个与大小有关的属性，例如`sizeScreenMargin`，它目前具有固定值`20`。如果我们决定增加`MasterView`中**Window**元素的起始大小，这个屏幕边距大小将保持不变。现在，由于样式对象，增加屏幕边距也非常容易，但如果所有硬编码的属性都可以随着**Window**元素的动态缩放而动态地放大和缩小，那将是很好的。这样，我们可以尝试不同的窗口大小，而无需每次更新样式。
- en: As we’ve already seen, the flexibility of QML is extended even further with
    the built-in JavaScript support, and we can do just that.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，QML的灵活性通过内置的JavaScript支持得到了进一步扩展，我们可以做到这一点。
- en: 'First, let’s create new width and height properties for the window in Style:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在Style中为窗口创建新的宽度和高度属性：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Use these new properties in `MasterView`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MasterView`中使用这些新属性：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'All the size properties in Style that we’ve created so far are relevant to
    this window size of 1920 x 1080, so let’s record that as new properties in Style:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在Style中创建的所有尺寸属性都与1920 x 1080的窗口尺寸相关，因此让我们将其记录为Style中的新属性：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can then use the reference sizes and the actual sizes to calculate scaling
    factors in the horizontal and vertical axes. So in simple terms, if we design
    everything with a window width of 1,000 in mind and then we set the window to
    be 2,000 wide, we want everything to scale horizontally by a factor of 2\. Add
    the following functions to Style:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用参考尺寸和实际尺寸来计算水平和垂直轴上的缩放因子。因此，简单来说，如果我们设计时考虑到窗口宽度为1,000，然后我们将窗口设置为2,000宽，我们希望一切在水平方向上按2的比例缩放。在Style中添加以下函数：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `hscale` and `vscale` functions calculate the horizontal and vertical scaling
    factors respectively. For certain size properties like pixel size for fonts, there
    is no independent width and height, so we can calculate an average of the horizontal
    and vertical scales using the `tscale` function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`hscale`和`vscale`函数分别计算水平和垂直缩放因子。对于像字体像素大小这样的特定尺寸属性，没有独立的宽度和高度，因此我们可以使用`tscale`函数计算水平和垂直缩放的平均值。'
- en: 'We can then wrap any properties we want to scale in the appropriate function.
    For example, our screen margin can use the `tscale` function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将我们想要缩放的任何属性包装在适当的函数中。例如，我们的屏幕边距可以使用`tscale`函数：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, not only can you increase the initial size of the window in Style, but
    your selected properties will automatically scale to the new size.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不仅可以在Style中增加窗口的初始大小，而且所选的属性将自动按比例缩放到新的大小。
- en: A really useful module you can add to help with sizing is `QtQuick.Window`.
    We already added this to `MasterView` in order to access the Window element. There
    is another object in that module, Screen, which makes available information regarding
    the user’s display. It contains properties for things like the width and height
    of the screen, and orientation and pixel density, which can be useful if you’re
    working with high DPI displays such as the Microsoft Surface or Macbook. You can
    use these values in conjunction with your Style properties to do things such as
    making your window fullscreen, or make it 50% of the screen size and positioning
    it in the center of the display.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常有用的模块，可以帮助调整大小是`QtQuick.Window`。我们已经将其添加到`MasterView`中，以便访问Window元素。该模块中还有另一个对象Screen，它提供有关用户显示的信息。它包含诸如屏幕宽度和高度、方向和像素密度等属性，如果您正在使用高DPI显示器（如Microsoft
    Surface或Macbook），这些属性可能会很有用。您可以将这些值与您的样式属性结合使用，以执行诸如使窗口全屏或使其占据屏幕大小的50%并将其定位在显示器中心等操作。
- en: Dashboard
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪表板
- en: A Dashboard or “home page” is a great place to welcome users and present the
    current state of play. Daily messages, facts and figures, performance charts,
    or simply some company branding can all help orient and focus the user. Let’s
    jazz up our Dashboard view a little and demonstrate how to display images to boot.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板或“主页”是欢迎用户并展示当前状态的好地方。每日消息、事实和数据、性能图表，或者简单地一些公司品牌都可以帮助定位和聚焦用户。让我们稍微改进一下我们的仪表板视图，并演示如何显示图像。
- en: 'Grab an image of your choice that has a 1:1 aspect ratio, which means that
    the width is the same as the height. It’s not necessary to be square, it’s just
    simpler to manage the scaling for the purposes of this example. I have picked
    the **Packt** logo, which is 500 x 500 pixels, and which I have saved as `packt-logo-500x500.jpg`.
    Save it to `cm/cm-ui/assets` and add it to our `assets.qrc` resources:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一张宽高比为1:1的图片，这意味着宽度和高度相同。不一定要是正方形，只是为了简化本例中的缩放管理。我选择了**Packt**的标志，尺寸为500 x
    500像素，保存为`packt-logo-500x500.jpg`。保存到`cm/cm-ui/assets`并将其添加到我们的`assets.qrc`资源中：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add some new Style properties, leveraging our new scaling capabilities:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一些新的Style属性，利用我们的新的缩放能力：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we can add our image to `DashboardView`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将我们的图像添加到`DashboardView`中：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, when we go to the Dashboard, we can see something a bit more stimulating:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们转到仪表板时，可以看到更有刺激性的东西：
- en: '![](img/4badcae8-575c-4c7b-b610-e366d5579693.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4badcae8-575c-4c7b-b610-e366d5579693.png)'
- en: Enumerator selectors
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举选择器
- en: Back in [Chapter 5](d1169ccb-4e46-49f4-b41b-2aaf896337ad.xhtml), *Data*, we
    created a Contact model where we implemented a `ContactType` property with an
    `EnumeratorDecorator`. For the other string-based properties we’ve worked with
    in the book, a simple textbox is a fine solution for capturing data, but how can
    we capture an enumerated value? The user can’t be expected to know the underlying
    integer values of the enumerator, and asking them to type in a string representation
    of the option they want is asking for trouble. What we really want is a drop-down
    list that somehow utilizes the `contactTypeMapper` container we added to the class.
    We’d like to present the string descriptions to the user to pick from but then
    store the integer value in the `EnumeratorDecorator` object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第5章](d1169ccb-4e46-49f4-b41b-2aaf896337ad.xhtml)，*数据*，我们创建了一个联系人模型，其中实现了一个带有`EnumeratorDecorator`的`ContactType`属性。对于本书中使用的其他基于字符串的属性，简单的文本框是捕获数据的良好解决方案，但是如何捕获枚举值呢？用户不应该知道枚举器的基础整数值，并要求他们输入所需选项的字符串表示形式是在寻找麻烦。我们真正想要的是一个下拉列表，以某种方式利用我们添加到类中的`contactTypeMapper`容器。我们希望向用户呈现字符串描述供其选择，然后将整数值存储在`EnumeratorDecorator`对象中。
- en: Desktop applications generally present drop-down lists in a particular way,
    with some kind of selector you press that then pops out (or more accurately, drops
    down!) a scrollable list of options to choose from. However, QML is geared toward
    not only cross-platform, but cross-device applications, too. Many laptops have
    touch capable screens, and more and more hybrid devices are appearing in the market
    that act as both laptops and tablets. As such, it’s important to consider how
    “finger friendly” our application is, even if we’re not planning on building the
    next big thing for the mobile stores, and the classic drop-down list can be difficult
    to work with on a touch screen. Let’s instead use a button-based approach as used
    on mobile devices.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面应用程序通常以特定方式呈现下拉列表，其中有一种选择器，您按下它然后弹出（或更准确地说，下拉！）一个可滚动的选项列表供选择。然而，QML不仅面向跨平台，而且面向跨设备应用程序。许多笔记本电脑具有触摸屏功能，而且市场上出现了越来越多的混合设备，它们既可以作为笔记本电脑，也可以作为平板电脑。因此，即使我们不打算为移动商店构建下一个大型应用程序，考虑我们的应用程序在“手指友好”方面是很重要的，经典的下拉列表在触摸屏上可能很难使用。让我们改用移动设备上使用的基于按钮的方法。
- en: Unfortunately, we can’t really work directly with our existing `std::map` in
    QML, so we will need to add a few new classes to bridge the gap for us. We’ll
    represent each key/value pair as a `DropDownValue` and hold a collection of these
    objects in a `DropDown` object. A `DropDown` object should take a `std::map<int,
    QString>` in its constructor and create the `DropDownValue` collection for us.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法直接在QML中使用现有的`std::map`，因此我们需要添加一些新的类来为我们构建桥梁。我们将把每个键/值对表示为`DropDownValue`，并在`DropDown`对象中保存这些对象的集合。`DropDown`对象应该在其构造函数中接受一个`std::map<int,
    QString>`，并为我们创建`DropDownValue`集合。
- en: Create the `DropDownValue` class first in `cm-lib/source/data`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在`cm-lib/source/data`中创建`DropDownValue`类。
- en: '`dropdown-value.h`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropdown-value.h`：'
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`dropdown-value.cpp`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropdown-value.cpp`：'
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There's nothing complicated here, it’s just a QML friendly wrapper for an integer
    value and associated string description.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么复杂的东西，只是一个整数值和相关字符串描述的QML友好封装。
- en: Next, create the `DropDown` class, again in `cm-lib/source/data`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`cm-lib/source/data`中再次创建`DropDown`类。
- en: '`dropdown.h`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropdown.h`：'
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`dropdown.cpp`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropdown.cpp`：'
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As discussed, we implement a constructor that takes the same kind of `std::map`
    that we use in our `EnumeratorDecorator` class and create a collection of `DropDownValue`
    objects based on it. The UI can then access that collection via the `ui_values`
    property. The other capability we provide for the UI is via the `findDescriptionForDropdownValue`
    public slot, and this allows the UI to take a selected integer value from an `EnumeratorDecorator`
    and get the corresponding text description. If there is no current selection (that
    is, the description is an empty string), then we will return `Select >` to denote
    to the user that they need to make a selection.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如讨论的，我们实现一个构造函数，它接受我们在`EnumeratorDecorator`类中使用的相同类型的`std::map`，并基于它创建一个`DropDownValue`对象集合。然后UI可以通过`ui_values`属性访问该集合。我们为UI提供的另一个功能是通过`findDescriptionForDropdownValue`公共槽，这允许UI从`EnumeratorDecorator`中获取所选整数值并获取相应的文本描述。如果没有当前选择（即，描述是空字符串），那么我们将返回`Select
    >`，以提示用户他们需要进行选择。
- en: 'As we will use these new types in QML, we need to register them in `main.cpp`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在QML中使用这些新类型，因此需要在`main.cpp`中注册它们：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add a new `DropDown` property to the Contact named `ui_contactTypeDropDown` and
    in the constructor, instantiate the member variable with the `contactTypeMapper`.
    Now, whenever a Contact is presented in the UI, the associated `DropDown` will
    be available. This can quite easily go into a dedicated component like a drop-down
    manager instead, if you wanted to reuse drop-downs throughout the application,
    but for this example, let’s avoid the additional complexity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Contact中添加一个新的`DropDown`属性，名为`ui_contactTypeDropDown`，并在构造函数中使用`contactTypeMapper`实例化成员变量。现在，每当在UI中呈现联系人时，相关的`DropDown`将可用。如果您想要在整个应用程序中重用下拉列表，这可以很容易地放入一个专用组件，比如下拉管理器，但是对于这个例子，让我们避免额外的复杂性。
- en: 'We will also need to be able to add a new contact object from the UI, so add
    a new public slot to `Client`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要能够从UI中添加一个新的联系人对象，因此在`Client`中添加一个新的公共槽：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the C++ done, we can move on to the UI implementation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 完成C++后，我们可以继续进行UI实现。
- en: We will need a couple of components for the dropdown selection. When presenting
    an `EnumeratorDecorator` property, we want to display the currently selected value,
    just as we do with our string editor. Visually, it will resemble a button with
    the associated string description as its label and when pressed, the user will
    be transitioned to the second component that is essentially a view. This subview
    will take up the whole of the content frame and present a list of all the available
    enumerated options, again represented as buttons. When the user makes their selection
    by pressing one of the buttons, they will be transitioned back to the original
    view, and their selection will be updated in the original component.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些组件来进行下拉选择。当呈现`EnumeratorDecorator`属性时，我们希望显示当前选定的值，就像我们在字符串编辑器中所做的那样。在视觉上，它将类似于一个按钮，其关联的字符串描述作为其标签，当按下时，用户将转换到第二个组件，这实质上是一个视图。这个子视图将占据整个内容框架，并呈现所有可用的枚举选项的列表，再次表示为按钮。当用户通过按下其中一个按钮进行选择时，他们将转换回原始视图，并且他们的选择将在原始组件中更新。
- en: 'First, we’ll create the view the user will transition to, which will list all
    the available options. To support this, we need a few additional properties in
    Style:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建用户将要转换到的视图，其中将列出所有可用选项。为了支持这一点，我们需要在Style中添加一些额外的属性：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create `EnumeratorSelectorView.qml` in `cm-ui/components`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cm-ui/components`中创建`EnumeratorSelectorView.qml`：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we use a **Repeater** element for the first time. A Repeater instantiates
    the QML element defined in its delegate property for each item it finds in its
    model property. We pass it the collection of `DropDownValue` objects as its model
    and create a delegate inline. The delegate is essentially another button with
    some selection code. We can create a new custom component and use that for the
    delegate instead to keep the code cleaner, but we’ll skip that here for brevity.
    The key parts of this component are the `Binding` element that gives us the two-way
    binding to the supplied `EnumeratorDecorator`, and the `onClicked` event delegate
    in the `MouseArea`, which performs the update and pops this component off the
    stack, returning us to whichever view we came from.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们第一次使用**Repeater**元素。Repeater为其模型属性中找到的每个项目实例化其代理属性中定义的QML元素。我们将其模型设置为`DropDownValue`对象的集合，并创建内联代理。代理本质上是另一个带有一些选择代码的按钮。我们可以创建一个新的自定义组件，并将其用于代理，以保持代码更清晰，但出于简洁起见，我们将在这里跳过。此组件的关键部分是`Binding`元素，它为我们提供了与提供的`EnumeratorDecorator`的双向绑定，以及`MouseArea`中的`onClicked`事件代理，它执行更新并将此组件弹出堆栈，将我们返回到我们来自的任何视图。
- en: 'Create a new `EnumeratorSelector.qml` in `cm-ui/components`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cm-ui/components`中创建一个新的`EnumeratorSelector.qml`：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This component has a lot of similarities to `StringEditorSingleLine` in its
    layout, but it replaces the Text element with a button representation. We grab
    the value from the bound `EnumeratorDecorator` and pass that to the slot we created
    on the `DropDown` class to get the string description for the currently selected
    value. When the user presses the button, the `onClicked` event of the `MouseArea`
    performs the same kind of view transition we’ve seen in `MasterView`, taking the
    user to the new `EnumeratorSelectorView`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件在布局上与`StringEditorSingleLine`有很多相似之处，但它用按钮表示替换了文本元素。我们从绑定的`EnumeratorDecorator`中获取值，并将其传递给我们在`DropDown`类上创建的插槽，以获取当前选定值的字符串描述。当用户按下按钮时，`MouseArea`的`onClicked`事件执行与我们在`MasterView`中看到的相同类型的视图转换，将用户带到新的`EnumeratorSelectorView`。
- en: We’re cheating a bit here in that we are directly referencing the `StackView`
    in `MasterView` by its `contentFrame` ID. At design time, Qt Creator can’t know
    what `contentFrame` is as it is in a totally different file, so it may flag it
    as an error, and you certainly won’t get auto-completion. At runtime, however,
    this component will be part of the same QML hierarchy as `MasterView`, so it will
    be able to find it. This is a risky approach, because if another element in the
    hierarchy is also called `contentFrame`, then bad things may happen. A safer way
    to do this is to pass `contentFrame` all the way down through the QML hierarchy
    from `MasterView` as a `QtObject` property.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有点作弊，因为我们直接通过其`contentFrame` ID在`MasterView`中引用`StackView`。在设计时，Qt Creator无法知道`contentFrame`是什么，因为它在一个完全不同的文件中，所以它可能会标记为错误，而且您肯定不会得到自动完成。然而，在运行时，这个组件将成为与`MasterView`相同的QML层次结构的一部分，因此它将能够找到它。这是一种风险的方法，因为如果层次结构中的另一个元素也被称为`contentFrame`，那么可能会发生糟糕的事情。更安全的方法是通过`MasterView`从`QtObject`属性作为`contentFrame`将`contentFrame`一直传递到QML层次结构的底部。
- en: When we add or edit a Client, we currently ignore contacts and always have an
    empty collection. Let’s take a look at how we can add objects to a collection
    and put our shiny new `EnumeratorSelector` to use while we’re at it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加或编辑客户时，我们目前忽略联系人，并始终有一个空集合。让我们看看如何向集合添加对象，并在此过程中使用我们闪亮的新`EnumeratorSelector`。
- en: Contacts
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联系人
- en: We will need a handful of new UI components to manage our contacts. We’ve previously
    worked with an `AddressEditor` to look after our address details, so we’ll continue
    in that mold and create a `ContactEditor` component. This component will display
    our collection of contacts, each of which will be represented by a `ContactDelegate`.
    Upon initially creating a new Client object, there won’t be any contacts, so we
    also need some way for the user to add a new one. We’ll enable that with a button
    press, and we’ll create a new component for buttons we can add to a content view.
    Let’s do that first.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一些新的UI组件来管理我们的联系人。我们之前使用过`AddressEditor`来管理我们的地址详细信息，所以我们将继续在那个模式下创建一个`ContactEditor`组件。该组件将显示我们的联系人集合，每个联系人都将由`ContactDelegate`表示。在最初创建新的客户对象时，不会有任何联系人，因此我们还需要一种让用户添加新联系人的方式。我们将通过按钮按下来实现这一点，并创建一个可以添加到内容视图的新组件。让我们先做这个。
- en: 'To support this new component, as usual, we’ll go ahead and add some properties
    to Style:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这个新组件，像往常一样，我们将在Style中添加一些属性：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create `FormButton.qml` in `cm-ui/components`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cm-ui/components`中创建`FormButton.qml`：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we combine aspects of the `NavigationButton` and `CommandButton` controls
    we wrote earlier in the book. The only real difference is that it is intended
    for more free-form use in the main content frame rather than being constrained
    to one of the toolbars.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们结合了我们在本书中早期编写的`NavigationButton`和`CommandButton`控件的方面。唯一的真正区别是它旨在更自由地在主内容框架中使用，而不是被限制在其中一个工具栏中。
- en: 'Next, let’s add the component we’ll use to display/edit a single Contact object.
    Create `ContactDelegate.qml` in `cm-ui/components`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加我们将用于显示/编辑单个联系人对象的组件。在`cm-ui/components`中创建`ContactDelegate.qml`：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is much the same as the `RssItemDelegate` we added in [Chapter 8](d04b2aa4-cbbe-4826-b27f-5f00ea4cfb07.xhtml),
    *Web Requests*. We add our new `EnumeratorSelector` and bind it to the `ui_contactType`
    property, using `ui_contactTypeDropDown` to provide the control with the drop-down
    information it needs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在[第8章](d04b2aa4-cbbe-4826-b27f-5f00ea4cfb07.xhtml)中添加的`RssItemDelegate`几乎相同，*Web请求*。我们添加了新的`EnumeratorSelector`并将其绑定到`ui_contactType`属性，使用`ui_contactTypeDropDown`为控件提供下拉信息。
- en: 'Create `ContactsEditor.qml` in `cm-ui/components`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cm-ui/components`中创建`ContactsEditor.qml`：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We’ve already done all the hard work in our `ContactDelegate` and `FormButton`
    controls, so this is really short and sweet. We add everything to a `Panel` so
    that the look and feel will be consistent with the rest of the views. We use another
    `Repeater` so that we can spin up a `ContactDelegate` for every contact in the
    collection and immediately after the contacts, we display a button to add a new
    contact to the list. In order to do this, we call the `addContact()` method we
    added earlier in this chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`ContactDelegate`和`FormButton`控件中完成了所有的艰苦工作，所以这部分非常简短。我们将所有内容添加到`Panel`中，以便外观和感觉与其他视图保持一致。我们使用另一个`Repeater`，以便为集合中的每个联系人启动一个`ContactDelegate`，并在联系人之后立即显示一个按钮，以将新联系人添加到列表中。为了做到这一点，我们调用了本章前面添加的`addContact()`方法。
- en: 'Now, we just need to add instances of our `ContactsEditor` to the `CreateClientView`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将我们的`ContactsEditor`实例添加到`CreateClientView`中：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also use the same component in `EditClientView`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`EditClientView`中使用相同的组件：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That’s it. Build and Run, and you can add and edit contacts to your heart’s
    content:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。构建和运行，您可以尽情添加和编辑联系人：
- en: '![](img/c1b86286-e84d-43b7-9f18-ba51c1a8023a.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1b86286-e84d-43b7-9f18-ba51c1a8023a.png)'
- en: 'Once you save a new client, if you take a look at the database, you will see
    that the contacts array has been updated accordingly, as highlighted in the following
    screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦保存了新的客户端，如果查看数据库，您会看到联系人数组已经相应地更新，如下面的屏幕截图所示：
- en: '![](img/cf2f77a9-4754-4ab2-9509-63d059de3288.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf2f77a9-4754-4ab2-9509-63d059de3288.png)'
- en: All that’s left now is the appointments collection, and we’ve already covered
    all the skills you need to tackle that, so we’ll leave that as an exercise for
    the reader and move on to the final topic—deploying our application to our end
    users.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是约会集合，我们已经涵盖了您需要处理的所有技能，所以我们将把它作为读者的练习，并继续进行最后一个话题 - 将我们的应用部署到最终用户。
- en: Deployment preparation
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署准备
- en: The center piece of our application is the `cm-ui` executable. This is the file
    that gets launched by the end user and that opens graphical windows and orchestrates
    all the fancy stuff we’ve written. When we run the `cm-ui` project in Qt Creator,
    it opens the executable file for us and everything works perfectly. However, distributing
    our application to another user is unfortunately more complicated than simply
    plonking a copy of the executable on their machine and launching it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的核心是`cm-ui`可执行文件。这是最终用户启动并打开图形窗口并编排我们编写的所有花哨东西的文件。当我们在Qt Creator中运行`cm-ui`项目时，它会为我们打开可执行文件，一切都能正常工作。然而，将我们的应用程序分发给其他用户比简单地在他们的机器上放置可执行文件的副本并启动它要复杂得多。
- en: Our executable has a variety of dependencies that need to be in place in order
    for it to run. A prime example of a dependency is our very own `cm-lib` library.
    Pretty much all of our business logic is hidden away in there, and without that
    functionality, our UI can’t do much. The implementation details for dependency
    resolution across the various operating systems are complex and well beyond the
    scope of this book. However, the fundamental requirements of our application are
    the same, irrespective of the platform.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可执行文件有各种依赖关系，需要放置在适当位置才能运行。一个依赖关系的典型例子是我们自己的`cm-lib`库。几乎所有的业务逻辑都隐藏在那里，没有这个功能，我们的UI就无法做太多事情。跨各种操作系统的依赖关系解析的实现细节非常复杂，远远超出了本书的范围。然而，我们的应用程序的基本要求是相同的，无论平台如何。
- en: 'There are four categories of dependency that we need to consider and ensure
    that they are in place on our target user’s machine in order for our application
    to function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有四类依赖关系需要考虑，并确保它们在我们目标用户的机器上，以便我们的应用程序能够正常运行：
- en: 'Item 1: Custom libraries we’ve written or added to our solution manually. In
    this case, it is only the `cm-lib` library that we need to worry about.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1项：我们编写或手动添加到解决方案中的自定义库。在这种情况下，我们只需要担心`cm-lib`库。
- en: 'Item 2: The parts of the Qt framework that our application links to, both directly
    and indirectly. We already know some of these through the modules we’ve added
    to our `.pro` files, for example, the `qml` and quick modules require the `QtQml`
    and `QtQuick` components.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2项：我们的应用程序直接或间接链接到的Qt框架的部分。通过我们在`.pro`文件中添加的模块，我们已经了解了其中一些，例如，`qml`和`quick`模块需要`QtQml`和`QtQuick`组件。
- en: 'Item 3: Any internal dependencies of the Qt framework itself. This includes
    platform-specific files, resources for the QML subsystem, and third-party libraries
    such as `sqlite` or `openssl`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3项：Qt框架本身的任何内部依赖关系。这包括特定于平台的文件，QML子系统的资源以及诸如`sqlite`或`openssl`之类的第三方库。
- en: 'Item 4: Any libraries required by the C++ compiler we have built the application
    with.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4项：我们用C++编译器构建应用程序所需的任何库。
- en: We’ve already worked extensively with item 1, back in [Chapter 2](ed8edd43-9e54-4b4c-907e-349764f26c55.xhtml),
    *Project Structure*, we put a lot of work into controlling exactly where that
    output goes. We haven’t really needed to worry about items 2 and 3, because we
    have a full installation of the Qt Framework in our development machine and that
    takes care of everything for us. Similarly, item 4 is dictated by the kit we use,
    and if we have a compiler available on our machine, it follows that we have the
    libraries it needs too.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经在[第2章](ed8edd43-9e54-4b4c-907e-349764f26c55.xhtml)中广泛使用了第1项，*项目结构*，我们在控制输出的确切位置方面付出了很多工作。我们并不需要担心第2和第3项，因为我们在开发机器上有完整的Qt框架安装，它为我们处理了一切。同样，第4项由我们使用的工具包决定，如果我们的机器上有编译器可用，那么它需要的库也是有的。 '
- en: Identifying exactly what we need to copy for our end users (who more than likely
    don’t have Qt or other development tools installed) can be an excruciating exercise.
    Even once we’ve done that, packaging everything up into a neat package or installer
    that is simple for the user to run can be a project in itself. Fortunately, Qt
    offers us some help in the form of bundled tools.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 确定我们需要为最终用户复制的内容（很可能他们没有安装Qt或其他开发工具）可能是一项痛苦的工作。即使我们做到了这一点，将所有东西打包成一个整洁的包或安装程序，让用户轻松运行，也可能是一个项目。幸运的是，Qt以捆绑工具的形式为我们提供了一些帮助。
- en: Linux and macOS X have a concept of application packages, whereby the application
    executable and all dependencies can be rolled up together into a single file that
    can then be easily distributed and launched at the click of a button. Windows
    is a bit more freestyle and if we want to bundle all of our files into a single
    installable file, we need to do a bit more work, but again, Qt comes to the rescue
    and comes with the fantastic Qt Installer Framework that simplifies it for us.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Linux和macOS X有应用程序包的概念，应用程序可执行文件和所有依赖项可以一起打包成一个单个文件，然后可以轻松分发和点击按钮启动。Windows则更加自由，如果我们想将所有文件捆绑到一个可安装文件中，我们需要做更多的工作，但是Qt再次拯救了我们，并提供了出色的Qt安装程序框架，为我们简化了这个过程。
- en: Let’s take a look at each operating system in turn and produce an application
    package or installer for each.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次查看每个操作系统，并为每个操作系统生成一个应用程序包或安装程序。
- en: OS X
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OS X
- en: 'First, build the solution using the kit of your choice in the Release mode.
    You already know that if we press the Run button in Qt Creator, our app launches
    and all is well. However, navigate to the `cm-ui.app` file in Finder and try and
    launch it directly; with this, things aren’t quite so rosy:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用您选择的套件在发布模式下构建解决方案。您已经知道，如果我们在Qt Creator中按下运行按钮，我们的应用程序会启动，一切都很顺利。但是，导航到Finder中的`cm-ui.app`文件，尝试直接启动它；在这方面，情况就不那么美好了：
- en: '![](img/57963241-c098-441c-84b2-01a504c479a6.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57963241-c098-441c-84b2-01a504c479a6.png)'
- en: The problem here is missing dependencies. We can use **otool** to take a look
    at what those dependencies are. First, copy the `cm-ui.app` package to a new directory—`cm/installer/osx`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于缺少依赖项。我们可以使用**otool**来查看这些依赖项是什么。首先，将`cm-ui.app`包复制到一个新目录——`cm/installer/osx`。
- en: This isn’t strictly necessary, but I like to keep build and deployment files
    separate. This way, if we make a code change and rebuild the solution, we will
    only update the app in the binaries folder, and our deployment files remain untouched.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是绝对必要的，但我喜欢将构建和部署文件分开。这样，如果我们进行代码更改并重新构建解决方案，我们只会更新二进制文件夹中的应用程序，而我们的部署文件则保持不变。
- en: Next, have a poke around inside the app package and see what we’re working with.
    In Finder, *Ctrl* and click on the `cm-ui.app` we just copied to the installer
    folder and select Show Package Contents. The bit we’re interested in is the `Contents/MacOS`
    folder. In there, you will find our `cm-ui` application executable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，查看应用程序包内部，看看我们正在处理什么。在Finder中，*Ctrl*点击我们刚刚复制到安装程序文件夹的`cm-ui.app`，然后选择显示包内容。我们感兴趣的部分是`Contents/MacOS`文件夹。在那里，你会找到我们的`cm-ui`应用程序可执行文件。
- en: 'With that identified, open up a command terminal, navigate to `cm/installer/osx`,
    and run `otool` on the executable:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个识别，打开一个命令终端，导航到`cm/installer/osx`，并在可执行文件上运行`otool`：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will see an output the same as (or similar to) the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个与以下内容相同或类似的输出：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s remind ourselves of the dependencies we need to consider and look at
    how they relate to the output we’ve just seen:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们提醒自己需要考虑的依赖关系，并看看它们与我们刚刚看到的输出有什么关系：
- en: Custom libraries we’ve written or added to our solution manually (`cm-lib`).
    This is the `libcm-lib.1.dylib` reference. The fact that there is no path component
    suggests that the tool isn’t quite sure where this file is located. Should it
    be in the same folder as the executable itself? Should it be in the standard `/usr/lib/`
    folder? Fortunately, we can specify the location of this file when we package
    our app.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们手动编写或添加到解决方案中的自定义库（`cm-lib`）。这是`libcm-lib.1.dylib`的引用。没有路径组件的事实表明工具不太确定这个文件的位置。它应该在可执行文件本身的相同文件夹中吗？它应该在标准的`/usr/lib/`文件夹中吗？幸运的是，我们可以在打包应用程序时指定这个文件的位置。
- en: The parts of the Qt framework that our application links to. `QtQuick`, `QtQml`,
    and such are all the framework modules we directly reference in our `cm-ui` code.
    Some of them are explicitly brought in via the QT variable in our `cm-ui.pro`
    file and others are implicitly included using things like QML.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的应用程序链接到的Qt框架的部分。`QtQuick`、`QtQml`等都是我们在`cm-ui`代码中直接引用的框架模块。其中一些是通过我们的`cm-ui.pro`文件中的QT变量明确引入的，而其他一些则是使用QML等隐式包含的。
- en: Any internal dependencies of the Qt framework itself. We don’t see those listed
    earlier, but if we were to run otool against the `QtQuick` module, you would see
    that it is dependent on `QtQml`, `QtNetwork`, `QtGui`, and `QtCore`. There are
    also several system level libraries required, such as OpenGL, which we haven’t
    explicitly coded against but are used by Qt.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt框架本身的任何内部依赖项。我们之前没有看到这些列出来，但如果我们对`QtQuick`模块运行otool，你会看到它依赖于`QtQml`、`QtNetwork`、`QtGui`和`QtCore`。还有一些系统级别的库是必需的，比如OpenGL，虽然我们没有明确针对它们编码，但Qt使用了它们。
- en: Any libraries required by the C++ compiler we have built the application with;
    `libc++.1.dylib` stands out here.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由我们构建应用程序的C++编译器所需的任何库；这里特别突出的是`libc++.1.dylib`。
- en: To bundle all of our dependencies manually, we can copy them all inside the
    app package and then perform some reconfiguration steps to update the location
    metadata we saw from otool.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了手动捆绑所有的依赖项，我们可以将它们全部复制到应用程序包中，然后执行一些重新配置步骤，以更新我们从otool中看到的位置元数据。
- en: Let’s pick one of the framework dependencies—`QtQuick`—and quickly work through
    what we will have to do to achieve this, and then we’ll move on to the really
    handy tool that does all of this very unpleasant grunt work for us.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择一个框架依赖项——`QtQuick`——并快速浏览一下我们需要做什么才能实现这一点，然后我们将转向真正方便的工具，它可以为我们完成所有这些非常不愉快的繁重工作。
- en: 'First, we will create a `Frameworks` directory where the system will search
    for the bundled dependencies:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个`Frameworks`目录，系统将在其中搜索捆绑的依赖项：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we will physically copy the referenced file to that new directory. We
    know where to look for the existing file on our development machine, thanks to
    the preceding `LC_RPATH` entry, in this case `/Users/<Your Username>/Qt5.9.1/5.9.1/clang_64/lib`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将物理地将引用的文件复制到新目录。由于前面的`LC_RPATH`条目，我们知道在我们的开发机器上查找现有文件的位置，即`/Users/<Your
    Username>/Qt5.9.1/5.9.1/clang_64/lib`：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We then need to change the shared library identification name for the copied
    library file using `install_name_tool`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使用`install_name_tool`更改复制的库文件的共享库标识名称：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The syntax here is `install_name_tool -id [New name] [Shared library file]`.
    To get to the library file (not the framework package, which is what we copied),
    we drill down to `Versions/5/QtQuick`. We set the ID of that binary to where the
    executable will look to find it, which, in this case, is in the `Frameworks` folder
    a level up (`../`) from the executable file itself.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的语法是`install_name_tool -id [新名称] [共享库文件]`。要到达库文件（而不是我们复制的框架包），我们要深入到`Versions/5/QtQuick`。我们将该二进制文件的ID设置为可执行文件将查找到的位置，即在这种情况下，是在与可执行文件本身相同级别的`Frameworks`文件夹中（`../`）。
- en: 'Next, we also need to update the executable’s list of dependencies to look
    in the correct place for this new file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还需要更新可执行文件的依赖项列表，以便在正确的位置查找这个新文件：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The syntax here is `install_name_tool -change [old value] [new value] [executable
    file]`. We want to change the old `@rpath` entry for `QtQuick` to be the new Frameworks
    path we’ve just added. Again, we use the `@executable_path` variable so that the
    dependencies are always located in the same place relative to the executable.
    Now, the metadata in the executable and the shared library both match each other
    and relate to the `Frameworks` folder, which we have now added to our app package.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的语法是`install_name_tool -change [旧值] [新值] [可执行文件]`。我们要将旧的`@rpath`条目更改为我们刚刚添加的新Frameworks路径。同样，我们使用`@executable_path`变量，以便依赖项始终位于相对于可执行文件的相同位置。现在，可执行文件和共享库中的元数据都相互匹配，并与我们现在添加到应用程序包中的`Frameworks`文件夹相关联。
- en: Remember, that’s not all, because `QtQuick` itself has dependencies, so we will
    need to copy and reconfigure all of those files too and then check their dependencies.
    Once we’ve exhausted the whole dependency tree for our `cm-ui` executable, we
    also need to repeat the process for our `cm-lib` library. As you can imagine,
    this gets tedious very quickly.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这还不是全部，因为`QtQuick`本身也有依赖项，所以我们需要复制和重新配置所有这些文件，然后检查它们的依赖项。一旦我们耗尽了`cm-ui`可执行文件的整个依赖树，我们还需要为`cm-lib`库重复这个过程。正如你所想象的那样，这很快就会变得乏味。
- en: Fortunately, the `macdeployqt` Qt Mac Deployment Tool is just what we need here.
    It scans an executable file for Qt dependencies and copies them across to our
    app package for us as well as for handling the reconfiguration work. The tool
    is located in the `bin` folder of the installed kit you have built the application
    with, for example, `/Qt/5.9.1/5.9.1/clang_64/bin`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`macdeployqt` Qt Mac部署工具正是我们需要的。它会扫描可执行文件的Qt依赖项，并将它们复制到我们的应用程序包中，同时处理重新配置工作。该工具位于您构建应用程序的已安装工具包的`bin`文件夹中，例如`/Qt/5.9.1/5.9.1/clang_64/bin`。
- en: 'In a command terminal, execute `macdeployqt` as follows (assuming that you
    are in the `cm/installer/osx` directory):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令终端中，执行`macdeployqt`如下（假设你在`cm/installer/osx`目录中）：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Remember to replace the parameters in angle brackets with the full paths on
    your system (or add the executable paths to your system PATH variable).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 记得用尖括号中的参数替换你系统上的完整路径（或将可执行文件路径添加到系统的PATH变量中）。
- en: The `qmldir` flag tells the tool where to scan for QML imports and is set to
    our UI project folder. The `libpath` flag is used to specify where our compiled
    `cm-lib` file lives.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`qmldir`标志告诉工具在哪里扫描QML导入，并设置为我们的UI项目文件夹。`libpath`标志用于指定我们编译的`cm-lib`文件所在的位置。'
- en: 'The output of this operation will be as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作的输出将如下所示：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Qt is a bit quirky with the SQL module, whereby if you use one SQL driver, it
    will try and package them all; however, we know that we are only using SQLite
    and don’t need MySQL or PostgreSQL, so we can safely ignore those errors.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Qt在SQL模块上有点古怪，如果你使用一个SQL驱动程序，它会尝试打包所有的驱动程序；然而，我们知道我们只使用SQLite，不需要MySQL或PostgreSQL，所以我们可以安全地忽略这些错误。
- en: 'Once executed, you should be able to Show Package Contents  again in Finder
    and see all the dependencies ready and waiting for deployment, as illustrated:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完毕后，你应该能够在Finder中再次查看包内容，并看到所有准备好等待部署的依赖项，如下所示：
- en: '![](img/ded5936e-733d-4c71-8b31-9786ceda7e81.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ded5936e-733d-4c71-8b31-9786ceda7e81.png)'
- en: What a huge timesaver! It has created the appropriate file structure and copied
    all the Qt modules and plugins for us, along with our `cm-lib` shared library.
    Try and execute the `cm-ui.app` file now, and it should successfully launch the
    application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 多么巨大的时间节省者！它已经为我们创建了适当的文件结构，并复制了所有的Qt模块和插件，以及我们的`cm-lib`共享库。现在尝试执行`cm-ui.app`文件，它应该成功启动应用程序。
- en: Linux
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux
- en: Linux packaging and deployment is broadly similar to OS X, and we won’t cover
    it in the same level of detail, so at least skim the OS X section first if you
    haven’t already. As with all platforms, the first thing to do is build the solution
    using the kit of your choice in the **Release** mode in order to generate the
    binaries.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的打包和部署与OS X大致相似，我们不会以相同的细节水平进行覆盖，所以如果你还没有这样做，至少先略读一下OS X部分。与所有平台一样，首先要做的是使用你选择的工具包在**Release**模式下构建解决方案，以生成二进制文件。
- en: 'When building in Release mode for the first time, I received the “cannot find
    -lGL” error. This was because the `dev` libraries for OpenGL were not installed
    on my system. One way of obtaining these libraries is to install FreeGlut:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次以Release模式构建时，我收到了“无法找到-lGL”错误。这是因为OpenGL的`dev`库没有安装在我的系统上。获取这些库的一种方法是安装FreeGlut：
- en: '`$ sudo apt-get update`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ sudo apt-get update`'
- en: '`$ sudo apt-get install build-essential`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ sudo apt-get install build-essential`'
- en: '`$ sudo apt-get install freeglut3-dev`'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ sudo apt-get install freeglut3-dev`'
- en: Once compiled, copy the `cm-ui` binary to a new `cm/installer/linux` directory.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后，将`cm-ui`二进制文件复制到新的`cm/installer/linux`目录中。
- en: 'Next, we can take a look at what dependencies our application has. In a command
    terminal, change to the `cm/installer/linux` folder and run `ldd`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以查看我们的应用程序有哪些依赖项。在命令终端中，切换到`cm/installer/linux`文件夹并运行`ldd`：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You will see an output similar to the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似以下的输出：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'That’s some list of dependencies! Crucially, note the dependency on our `cm-lib`
    library:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些依赖项的列表！关键是要注意我们的`cm-lib`库的依赖关系：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This shows that the executable will look for our library in the `/usr/lib`
    folder, so let’s ensure that it’s available there before we move on by copying
    `libcm-lib.so.1` to `/usr/lib`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明可执行文件将在`/usr/lib`文件夹中查找我们的库，因此在继续之前，让我们确保它在那里可用，将`libcm-lib.so.1`复制到`/usr/lib`中：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can already guess what a nightmare managing all these dependencies manually
    will be, having discussed the OS X process and seen how many dependencies there
    are, so there must be a tool in our Kit’s `bin` folder that does it all for us,
    right? Well, yes and no. There is no official Qt tool we get out of the box to
    do this for us like there is for OS X and Windows. Fortunately, a fantastic member
    of the Qt community `probonopd` has come to the rescue and plugged the gap with
    `linuxdeployqt`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经可以猜到手动管理所有这些依赖项将是一场噩梦，讨论了OS X的过程并看到了有多少依赖项，所以我们的Kit的`bin`文件夹中一定有一个工具可以为我们完成所有工作，对吗？嗯，是和不是。与OS
    X和Windows一样，我们没有官方的Qt工具可以为我们完成这项工作。幸运的是，Qt社区的出色成员`probonopd`已经挺身而出，用`linuxdeployqt`填补了这一空白。
- en: 'You can get a `linuxdeployqt` app image from the releases page of the GitHub
    project at [https://github.com/probonopd/linuxdeployqt](https://github.com/probonopd/linuxdeployqt).
    Download the file (`linuxdeployqt-continuous-x86_64.AppImage`) and then make it
    executable:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub项目的发布页面[https://github.com/probonopd/linuxdeployqt](https://github.com/probonopd/linuxdeployqt)获取`linuxdeployqt`应用程序映像。下载文件（`linuxdeployqt-continuous-x86_64.AppImage`），然后将其设置为可执行文件：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can then execute it and have it work its dependency-based magic for us.
    Change the directory to `cm/installer/linux` first:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以执行它，并让它按照依赖关系进行操作。首先将目录更改为`cm/installer/linux`：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `qmldir` flag tells the tool where to scan for QML imports and is set to
    our UI project folder. The `appimage` flag is used to get the tool to create an
    application image file for us, which is a single file with everything bundled
    inside.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`qmldir`标志告诉工具在哪里扫描QML导入，并设置为我们的UI项目文件夹。`appimage`标志用于让工具为我们创建一个应用程序映像文件，这是一个包含所有内容的单个文件。'
- en: 'Things may not work perfectly the first time. Your output may look as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次可能不会完全正常工作。您的输出可能如下所示：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The first two errors are just because we haven’t provided a desktop file or
    icon and defaults have been generated for us; we can ignore those. The rest are
    because `linuxdeployqt` doesn''t know where `qmake` is. We can either provide
    the path as an extra parameter (`-qmake=<PATH>`), or to save us having to do it
    every time, we can add it to our PATH environment variable:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个错误只是因为我们没有提供桌面文件或图标，系统已经为我们生成了默认值；我们可以忽略这些。其余的是因为`linuxdeployqt`不知道`qmake`在哪里。我们可以提供路径作为额外参数（`-qmake=<PATH>`），或者为了节省我们每次都要这样做，我们可以将其添加到我们的PATH环境变量中：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can then check whether qmake can be found by trying to retrieve the version
    information:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以检查是否可以找到qmake，尝试检索版本信息：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If it is happy, you will see the version information:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它正常，您将看到版本信息：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With that fixed, we can now try running the `linuxdeployqt` command again.
    However, we’ve fixed one problem, but now experience another:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 修复后，我们现在可以尝试再次运行`linuxdeployqt`命令。但是，我们解决了一个问题，现在又遇到了另一个问题：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Ignore the first two errors again. Now it can''t find MySQL drivers, which
    is annoying, because we aren’t even MySQL and it is the same Qt SQL quirk we saw
    on OS X. As a workaround, let''s effectively "hide" the SQL drivers we don''t
    want from the tool by temporarily renaming them:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 再次忽略前两个错误。现在它找不到MySQL驱动程序，这很烦人，因为我们甚至不是MySQL，这与我们在OS X上看到的相同的Qt SQL问题。作为解决方法，让我们通过临时重命名来有效地“隐藏”我们不想要的SQL驱动程序：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the `linuxdeployqt` command again. You will get lots of output this time,
    culminating in a success message, including the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`linuxdeployqt`命令。这次会有大量输出，最终会出现成功消息，包括以下内容：
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is telling us that our app image has been named as `Application-x86_64.AppImage`,
    which it saves to the `Downloads` folder.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，我们的应用程序映像已命名为`Application-x86_64.AppImage`，它保存在`Downloads`文件夹中。
- en: 'Take a look in file manager, and you will see that it has added various files
    and directories alongside our executable:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件管理器中查看，您会看到它已经在我们的可执行文件旁边添加了各种文件和目录：
- en: '![](img/12883b0f-bef0-4b40-b640-55dda2680b47.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12883b0f-bef0-4b40-b640-55dda2680b47.png)'
- en: 'It has also deposited the `Application-x86_64.AppImage` file in the `Downloads`
    folder that is a single self-contained executable package with all dependencies.
    However, if you head over to `Downloads` and try and launch the `AppImage`, you
    may get an error (execute it via a Terminal command to see the error message):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 它还将`Application-x86_64.AppImage`文件放在了`Downloads`文件夹中，这是一个包含所有依赖项的单个自包含可执行文件包。但是，如果您前往`Downloads`并尝试启动`AppImage`，可能会出现错误（通过终端命令执行它以查看错误消息）：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This appears to be an issue with `linuxdeployqt` missing some dependencies,
    but for some reason, running the tool a second time magically picks them up. Execute
    the `linuxdeployqt` command again, and hey presto, the `AppImage` now works correctly.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是`linuxdeployqt`缺少一些依赖项的问题，但由于某种原因，再次运行该工具会神奇地解决这些问题。再次执行`linuxdeployqt`命令，嘿，`AppImage`现在可以正常工作了。
- en: Windows
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows
- en: First, build the solution using the kit of your choice in the **Release** mode.
    Once complete, copy the `cm-ui.exe` and `cm-lib.dll` application binaries to a
    new `cm/installer/windows/packages/com.packtpub.cm/data` directory. This strange
    directory structure will be explained in the next section—Qt Installer Framework—and
    we are simply saving ourselves some additional copying later.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用您选择的套件在**Release**模式下构建解决方案。完成后，将`cm-ui.exe`和`cm-lib.dll`应用程序二进制文件复制到新的`cm/installer/windows/packages/com.packtpub.cm/data`目录。这种奇怪的目录结构将在下一节—Qt安装程序框架中解释，我们只是在简化后续的额外复制。
- en: 'Next, let’s remind ourselves of the dependencies we need to consider:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾一下我们需要考虑的依赖关系：
- en: 'Item 1: Custom libraries we’ve written or added to our solution manually (`cm-lib`)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条款1：我们已经编写或手动添加到解决方案中的自定义库（`cm-lib`）
- en: 'Item 2: The parts of the Qt framework that our application links to'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条款2：我们的应用程序链接到的Qt框架的部分
- en: 'Item 3: Any internal dependencies of the Qt framework itself'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条款3：Qt框架本身的任何内部依赖项
- en: 'Item 4: Any libraries required by the C++ compiler we have built the application
    with'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条款4：C++编译器所需的任何库
- en: The good news is that item 1 is already done! Windows will look for the dependencies
    of an executable in the same folder that the executable is in. This is really
    helpful and by simply copying the DLL to the same folder as the executable, we’ve
    already taken care of that dependency. The Qt Installer framework takes all the
    files from a given folder and deploys them to the target machine in the same place
    relative to each other, so we know this will be preserved after deployment too.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是第1项已经完成了！Windows将在与可执行文件相同的文件夹中查找可执行文件的依赖项。这真的很有帮助，通过简单地将DLL复制到与可执行文件相同的文件夹中，我们已经解决了这个依赖关系。Qt安装程序框架会将给定文件夹中的所有文件部署到目标机器上的相同位置，因此我们知道这在部署后也会被保留。
- en: The bad news is that the remaining steps are a bit of a nightmare to manage
    manually. We can have a decent first stab at what parts of Qt we need by reviewing
    the modules we’ve explicitly added to our `*.pro` files. This will be `qml`, `quick`, and
    `xml` from `cm-ui` and `sql`, and network and `xml` from `cm-lib` core is also
    included by default. In File Explorer, navigate to `<Qt Installation Folder>/5.9.1/<Kit>/bin`.
    In there, you can find all the binaries relating to these modules, for example,
    `Qt5Qml.dll` for the `qml` module.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 坏消息是剩下的步骤手动管理有点噩梦。我们可以通过查看我们明确添加到`*.pro`文件的模块来初步确定我们需要Qt的哪些部分。这将是从`cm-ui`和`cm-lib`中添加的`qml`、`quick`和`xml`，以及默认包括的`core`中的`sql`、`network`和`xml`。
- en: We can use the approach that we did for `cm-lib.dll` and simply manually copy
    each of the Qt DLL files across to the data folder too. This will fulfil item
    2 and while deeply tedious, it’s fairly straightforward. However, item 3 is a
    painful exercise that we really don’t want to do ourselves.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们为`cm-lib.dll`所做的方法，简单地手动将每个Qt DLL文件复制到数据文件夹中。这将满足第2项，虽然非常乏味，但相当简单。然而，第3项是一个痛苦的练习，我们真的不想自己做。
- en: Fortunately, the `windeployqt` Qt Windows Deployment Tool is just what we need
    here. It scans an `.exe` file for Qt dependencies and copies them across to our
    installer folder for us. The tool is located in the `bin` folder of the installed
    kit you have built the application with, for example, `/Qt/5.9.1/mingw32/bin`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`windeployqt` Qt Windows部署工具正是我们需要的。它会扫描一个`.exe`文件以查找Qt依赖项，并将它们复制到我们的安装程序文件夹中。该工具位于您使用的已安装套件的`bin`文件夹中，例如`/Qt/5.9.1/mingw32/bin`。
- en: 'In a command terminal, execute `windeployqt` as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令终端中，执行以下命令`windeployqt`：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Remember to replace the parameters in angle brackets with the full paths on
    your system (or add the executable paths to your system PATH variable).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，用尖括号中的参数替换您系统上的完整路径（或将可执行文件路径添加到系统的PATH变量中）。
- en: The `qmldir` flag tells the tool where to scan for QML imports and is set to
    our UI project folder. After we tell the tool which `.exe` to scan for dependencies,
    the `compiler-runtime` flag denotes that we want the compiler runtime files too,
    so it even takes care of item 4 for us as a bonus!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`qmldir`标志告诉工具在哪里扫描QML导入，并设置为我们的UI项目文件夹。告诉工具要扫描哪个`.exe`文件的后，`compiler-runtime`标志表示我们也想要编译器运行时文件，所以它甚至为我们处理了第4项作为奖励！'
- en: By default, found dependencies will subsequently be copied to the same folder
    as the executable being scanned. This is a good reason to copy the compiled binaries
    to a dedicated installer folder first so that development project output and content
    for deployment remain separate.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，找到的依赖项随后将被复制到与被扫描的可执行文件相同的文件夹中。这是将编译后的二进制文件首先复制到专用安装程序文件夹的一个很好的理由，以便开发项目输出和部署内容保持分开。
- en: Once executed, you should see a large block of output. Although it’s tempting
    to think “oh, that’s done stuff so everything must be ok”, it’s a good idea to
    scan through the output, even if you’re not sure what it’s doing as you can sometimes
    pick up obvious issues that you can can take action to resolve.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，您应该看到大量的输出。虽然诱人地认为“哦，那做了一些事情，所以一切都应该没问题”，但浏览输出是一个好主意，即使您不确定它在做什么，因为有时您可以发现明显的问题，可以采取行动来解决。
- en: 'For example, when first deploying a MinGW kit build, I encountered the given
    line:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当首次部署MinGW套件构建时，我遇到了给定的行：
- en: '[PRE50]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Although the command had executed successfully, and I can see a whole bunch
    of Qt dependencies in the installer folder, I was actually missing the GCC dependencies.
    It was a simple fix to follow the instructions and add `<Qt Installation path>/Tools/mingw530_32/bin`
    to the PATH variable in my system environment variables. After restarting the
    command terminal and running the `windeployqt` command again, it subsequently
    completed successfully without the warning, and the GCC files were present as
    expected in data alongside all the Qt binaries. Without picking up on this quiet
    little warning, I would have proceeded with some potentially critical missing
    files.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管命令已成功执行，我可以在安装程序文件夹中看到一大堆Qt依赖项，但我实际上缺少了GCC依赖项。按照说明并将`<Qt Installation path>/Tools/mingw530_32/bin`添加到系统环境变量的PATH变量中是一个简单的修复方法。重新启动命令终端并再次运行`windeployqt`命令后，它随后成功完成，没有警告，并且GCC文件如预期地出现在数据文件夹中，与所有Qt二进制文件一起。如果没有注意到这个安静的小警告，我可能会继续进行一些潜在的关键文件缺失。
- en: 'As you can see, `windeployqt` is a huge time saver, but unfortunately, it isn’t
    a silver bullet and sometimes misses the required files. Tools like Dependency
    Walker exist, which can help analyze the dependency tree in detail, but a good
    starting point is to just manually launch the `cm-ui` executable from the data
    folder and see what happens. In our case, it is this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`windeployqt`是一个巨大的时间节省器，但不幸的是，它并不是一个万能解决方案，有时会漏掉所需的文件。存在诸如Dependency
    Walker之类的工具，可以帮助详细分析依赖树，但一个很好的起点就是手动从数据文件夹启动`cm-ui`可执行文件并查看发生了什么。在我们的情况下，是这样的：
- en: '![](img/9705df93-43d7-4d61-a747-23ea31e54225.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9705df93-43d7-4d61-a747-23ea31e54225.png)'
- en: The bad news is that it doesn’t work, but the good news is that at least it
    clearly tells us why it doesn’t work—it is missing the `Qt5Sql.dll` dependency.
    We know that we do indeed have a dependency there, because we had to add the `sql`
    module to our `.pro` files when we started doing database work. However, wait,
    we’ve just executed a command that should pull in all the Qt dependencies for
    us, right? Right, I don’t know why the tool misses out some dependencies that
    it really should know about, but it does. I don’t know if it’s a bug, an oversight,
    or a licensing restriction related to the underlying third-party SQLite implementation,
    but in any case, the simple solution is that we just need to copy it ourselves.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 坏消息是它不起作用，但好消息是至少它清楚地告诉我们为什么它不起作用——它缺少`Qt5Sql.dll`依赖项。我们知道我们确实在那里有一个依赖项，因为当我们开始进行数据库工作时，我们不得不在`.pro`文件中添加`sql`模块。然而，等等，我们刚刚执行了一个应该为我们拉取所有Qt依赖项的命令，对吧？对，我不知道为什么这个工具会漏掉一些它真的应该知道的依赖项，但它确实漏掉了。我不知道这是一个错误、一个疏忽，还是与底层第三方SQLite实现相关的许可限制，但无论如何，简单的解决方案是我们只需要自己复制它。
- en: Head over to `<Qt Installation>/5.9.1/<kit>/bin` and copy `Qt5Sql.dll` over
    to our data folder. Launch the `cm-ui.exe` again and hurrah, it opens successfully!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`<Qt Installation>/5.9.1/<kit>/bin`，将`Qt5Sql.dll`复制到我们的数据文件夹中。再次启动`cm-ui.exe`，哇，它成功打开了！
- en: 'One other thing to look out for apart from missing `.dll` files from the bin
    directory is missing files/folders from the plugins directory. You will see in
    our case that several folders have been copied successfully (bearer, iconengines,
    and such), but sometimes they don’t, and can be very difficult to figure out as
    you don’t get a helpful error message like we did with the missing DLL. I can
    only recommend three things in that situation: trial, error, and the internet.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从bin目录中缺少`.dll`文件之外，还要注意来自插件目录的缺少文件/文件夹。在我们的情况下，您将看到已成功复制了几个文件夹（bearer、iconengines等），但有时它们不会复制，并且很难弄清楚，因为您不会像我们在缺少DLL时那样得到有用的错误消息。在这种情况下，我只能推荐三件事：试验、错误和互联网。
- en: So, we now have a folder containing our lovely application binaries and a whole
    bunch of similarly lovely other files and folders. What now? Well, we can simply
    copy the folder wholesale onto our users' machines and get them to launch the
    executable as we did. However, a neater and more professional solution is to bundle
    up everything into a pretty installation package, and that is where the Qt Installer
    Framework tool comes in.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们有一个包含我们可爱的应用程序二进制文件和一大堆同样可爱的其他文件和文件夹的文件夹。现在呢？嗯，我们可以简单地将整个文件夹复制到用户的计算机上，并让他们像我们一样启动可执行文件。然而，一个更整洁和更专业的解决方案是将所有内容打包成一个漂亮的安装包，这就是Qt
    Installer Framework工具的用武之地。
- en: Qt Installer framework
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Installer框架
- en: Let's edit our Qt installation and grab the Qt Installer framework.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编辑我们的Qt安装并获取Qt Installer框架。
- en: 'Launch the MaintenanceTool application from your Qt installation directory,
    and you will be presented with a wizard virtually identical to the one we saw
    when we first installed Qt. To add Qt Installer Framework to your existing installation,
    follow these steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的Qt安装目录启动MaintenanceTool应用程序，您将看到一个与我们第一次安装Qt时看到的几乎相同的向导。要将Qt Installer Framework添加到您现有的安装中，请按照以下步骤操作：
- en: Either log in to your Qt Account or Skip
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要么登录到您的Qt帐户，要么跳过
- en: Select Add or remove components and click on Next
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择添加或删除组件，然后点击下一步
- en: On the Select Components dialog, check Tools > Qt Installer Framework 3.0 and
    click on Next
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择组件对话框中，勾选工具 > Qt Installer Framework 3.0，然后点击下一步
- en: Begin the installation by clicking on Update
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击更新开始安装
- en: Once complete, you can find the installed tools in `Qt/Tools/QtInstallerFramework/3.0`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以在`Qt/Tools/QtInstallerFramework/3.0`中找到已安装的工具。
- en: You can add further modules, kits, and such in exactly the same way. Any components
    you already have installed will be unaffected unless you actively deselect them.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以完全相同的方式添加更多的模块、工具包等。除非您主动取消选择，否则您已安装的任何组件都不会受到影响。
- en: 'The Qt Installer Framework requires two specific directories to be present:
    config and packages. Config is a singular piece of configuration that describes
    the installer as a whole, whereas you can bundle multiple packages (or components)
    together in the same installation package. Each component has its own subdirectory
    within the packages folder, with a data folder containing all the items to be
    installed for that component and a meta folder where configuration data for the
    package is held.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Installer Framework需要存在两个特定目录：config和packages。Config是描述整个安装程序的单一配置，而您可以将多个包（或组件）捆绑在同一个安装包中。每个组件在packages文件夹内有自己的子目录，其中包含一个数据文件夹，其中包含该组件要安装的所有项目，以及一个meta文件夹，其中包含包的配置数据。
- en: In our case, although we have two projects (`cm-lib` and `cm-ui`), it makes
    no sense to distribute one without the other, so we will aggregate the files together
    into one package. A common naming convention for packages is `com.<publisher>.<component>`,
    so we’ll name ours `com.packtpub.cm.` We already created the required data folder
    in the previous section (yay for forward planning!) and `windeployqt` stuffed
    it full of files for us.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，虽然我们有两个项目（`cm-lib`和`cm-ui`），但将一个项目分发而不包括另一个是没有意义的，因此我们将文件聚合到一个包中。包的常见命名约定是`com.<publisher>.<component>`，所以我们将命名为`com.packtpub.cm.`我们已经在上一节创建了所需的数据文件夹（为前瞻性规划欢呼！），并且`windeployqt`已经为我们填充了文件。
- en: There is no required naming convention here, so feel free to name the package
    something else if you wish. If we wanted to bundle an additional, optional component
    with our application, we would do so by simply creating an additional package
    folder (for example, `com.packtpub.amazingcomponent`) containing the relevant
    data and meta files, including a separate `package.xml` to configure that component.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有必需的命名约定，所以如果愿意，可以随意为包命名其他名称。如果我们想要将一个额外的可选组件与我们的应用程序捆绑在一起，只需创建一个额外的包文件夹（例如，`com.packtpub.amazingcomponent`），其中包含相关的数据和元数据文件，包括一个单独的`package.xml`来配置该组件。
- en: 'Create any missing folders so that you end up with the following folder structure
    inside `cm/installer/windows`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 创建任何缺失的文件夹，以便在`cm/installer/windows`内部得到以下文件夹结构：
- en: '![](img/08e3a715-ebf8-4bec-acb8-bab8f8b1c958.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08e3a715-ebf8-4bec-acb8-bab8f8b1c958.png)'
- en: To compliment these folders, we also need to provide two XML configuration files.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了补充这些文件夹，我们还需要提供两个XML配置文件。
- en: 'Create `config.xml` in the config subfolder:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在config子文件夹中创建`config.xml`：
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This configuration file customizes the behavior of the installer. The properties
    we have specified here are as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置文件自定义了安装程序的行为。我们在这里指定的属性如下：
- en: '| Property | Purpose |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 目的 |'
- en: '| `Name` | The application name |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `Name` | 应用程序名称 |'
- en: '| `Version` | The application version |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `Version` | 应用程序版本 |'
- en: '| `Title` | The installer name displayed in the title bar |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `Title` | 标题栏中显示的安装程序名称 |'
- en: '| `Publisher` | The publisher of the software |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `Publisher` | 软件的发布者 |'
- en: '| `StartMenuDir` | The default program group in the Windows Start menu |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `StartMenuDir` | Windows开始菜单中的默认程序组 |'
- en: '| `TargetDir` | The default target directory for the application installation
    |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `TargetDir` | 应用程序安装的默认目标目录 |'
- en: You will note strange @ symbols in the `TargetDir` property, and they define
    a predefined variable `HomeDir` that allows us to dynamically obtain a path to
    the end user’s home directory. You can also access the values of other properties
    in the same way, for example, `@ProductName@` will return “Client Management”.
    Further information is available at [http://doc.qt.io/qtinstallerframework/scripting.html#predefined-variables](http://doc.qt.io/qtinstallerframework/scripting.html#predefined-variables).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TargetDir`属性中，您会注意到奇怪的@符号，它们定义了一个预定义变量`HomeDir`，允许我们动态获取到最终用户的主目录路径。您也可以以同样的方式访问其他属性的值，例如，`@ProductName@`将返回“Client
    Management”。更多信息请参阅[http://doc.qt.io/qtinstallerframework/scripting.html#predefined-variables](http://doc.qt.io/qtinstallerframework/scripting.html#predefined-variables)。
- en: 'Next, create `package.xml` in the `packages/com.packtpub.cm/meta` subfolder:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`packages/com.packtpub.cm/meta`子文件夹中创建`package.xml`：
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This file configures the `com.packtpub.cm` package (our Client Management application)
    with the following properties:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件配置了`com.packtpub.cm`包（我们的Client Management应用程序）的以下属性：
- en: '| Property | Purpose |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 目的 |'
- en: '| `DisplayName` | The name of the component. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `DisplayName` | 组件的名称。|'
- en: '| `Description` | The text displayed when the component is selected. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `Description` | 选择组件时显示的文本。|'
- en: '| `Version` | The version of the component (used to promote component updates).
    |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `Version` | 组件的版本（用于推广组件更新）。|'
- en: '| `ReleaseDate` | The date the component was released. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `ReleaseDate` | 组件发布的日期。|'
- en: '| `Licenses` | A collection of licenses that must be agreed to in order to
    install the package. The text for the license agreement is obtained from the specified
    file that must be alongside the configuration file in the meta folder. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `Licenses` | 必须同意才能安装包的许可证集合。许可协议的文本是从meta文件夹中的指定文件中获取的。|'
- en: '| `Default` | Boolean flag denoting whether the component is selected by default.
    |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `Default` | 表示组件是否默认选中的布尔标志。|'
- en: You will also need to create `license.txt` in the meta folder; the content doesn’t
    matter in this case as it’s just for demonstration, so write any old nonsense
    in there.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在meta文件夹中创建`license.txt`；在这种情况下，内容并不重要，因为这只是用于演示，所以可以在里面写任何无关紧要的东西。
- en: 'With all the binaries, dependencies, and configuration in place, we can now
    run the Qt Framework Installer in a command terminal to generate our installation
    package. First, change directory to the `cm/installer/windows` folder and then
    execute `binarycreator`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有的二进制文件、依赖项和配置都就绪后，我们现在可以在命令终端中运行Qt Framework Installer来生成我们的安装包。首先，切换到`cm/installer/windows`文件夹，然后执行`binarycreator`：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `-c` flag tells the tool where the `config.xml` file resides and `-p` where
    all the packages are. The final parameter is the name you want to give the resulting
    installer.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`-c`标志告诉工具`config.xml`文件的位置，`-p`告诉工具所有包的位置。最后一个参数是您想要给结果安装程序的名称。'
- en: With our application neatly packaged up into a single installer file, `ClientManagementInstaller.exe`,
    we can now easily distribute it to our end users for installation.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的应用程序整齐地打包成一个单独的安装程序文件`ClientManagementInstaller.exe`后，我们现在可以轻松地将其分发给最终用户进行安装。
- en: Installation
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'Upon launching the installer, you will be presented with a welcome dialog,
    the content of which is derived from our `config.xml` file:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 启动安装程序后，您将看到一个欢迎对话框，其内容源自我们的`config.xml`文件：
- en: '![](img/3f37cf0b-bffa-4217-aa87-6b2ae057355f.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f37cf0b-bffa-4217-aa87-6b2ae057355f.png)'
- en: 'We are then prompted to specify the target directory for the installation and
    what we expect is that after installation, this folder will contain all the files
    and folders we pulled together in the data folder:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们被提示指定安装的目标目录，我们期望的是安装后，该文件夹将包含我们在数据文件夹中汇总的所有文件和文件夹：
- en: '![](img/205b591a-cfc4-4cf2-ba78-58238f6a3a10.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/205b591a-cfc4-4cf2-ba78-58238f6a3a10.png)'
- en: 'We are then presented with a list of all the components we defined via the
    packages directory, which in this case is simply the application and dependencies
    in the `com.packtpub.cm` folder:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将看到我们通过包目录定义的所有组件的列表，这种情况下只是`com.packtpub.cm`文件夹中的应用程序和依赖项：
- en: '![](img/01881dcf-369b-463f-b905-267d30053ea9.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01881dcf-369b-463f-b905-267d30053ea9.png)'
- en: 'Next, we are presented with any licenses we defined in `packages.xml`, including
    the license information provided in the text files:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到我们在`packages.xml`中定义的任何许可证，包括文本文件中提供的许可证信息：
- en: '![](img/ccff9ba7-834c-4e72-8ce1-0a5d5ac24cf5.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccff9ba7-834c-4e72-8ce1-0a5d5ac24cf5.png)'
- en: 'We are then prompted for the Start Menu shortcuts, with the default provided
    by `config.xml`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们被提示设置开始菜单快捷方式，默认情况下由`config.xml`提供：
- en: '![](img/058b12dd-aa3e-4869-9137-3904578bf55e.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/058b12dd-aa3e-4869-9137-3904578bf55e.png)'
- en: 'We’re ready to install now and are provided with disk usage stats before we
    confirm:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好安装了，并在确认之前提供了磁盘使用情况统计信息：
- en: '![](img/7af94f05-a95f-48d5-a092-0d683ae56cfc.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7af94f05-a95f-48d5-a092-0d683ae56cfc.png)'
- en: 'After a brief wait while the installation completes, we are presented with
    a final confirmation dialog:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装完成时稍等片刻后，我们将看到最终确认对话框：
- en: '![](img/16c6a965-1105-4705-bf3a-4487e1f71473.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16c6a965-1105-4705-bf3a-4487e1f71473.png)'
- en: You should see a new `ClientManagement` folder in the target directory containing
    our installed application!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在目标目录中看到一个新的`ClientManagement`文件夹，其中包含我们安装的应用程序！
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we made our application even more testable by introducing our
    first object factory. They are a really useful layer of abstraction that make
    unit testing so much easier, and on larger projects, it's common to end up with
    several factories. We then made our UI even more dynamic by having Style properties
    that can scale along with the Window.  `EnumeratorDecorators` got some love and
    an editor component of their own, fully finger-friendly to boot. We then put that
    editor to use and implemented Contact management, showing how collections of objects
    can easily be viewed and edited.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们通过引入第一个对象工厂，使我们的应用程序更具可测试性。它们是一个非常有用的抽象层，使单元测试变得更加容易，在更大的项目中，通常会出现几个工厂。然后，我们通过具有可以随着窗口缩放的样式属性，使我们的UI更加动态。`EnumeratorDecorators`得到了一些关注，并且有了自己的编辑组件，完全适合手指操作。然后我们利用该编辑器实现了联系人管理，展示了如何轻松查看和编辑对象集合。
- en: With our application more fleshed out, we then took a look at how to get our
    shiny new work of genius into the hands of our end users. Different operating
    systems each have their own take on things, and you will undoubtedly discover
    quirks and encounter challenges in your own particular environment, but hopefully,
    you now have the tools you need to be able to work through them.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序更加完善，我们看了一下如何将我们闪亮的新作品交到最终用户手中。不同的操作系统都有自己的看法，您无疑会在自己的特定环境中发现怪癖并遇到挑战，但希望您现在有了解决它们所需的工具。
- en: That sentiment goes not just for deployment, but for the whole project life
    cycle.  The goal of this book was not to discuss theoretical problems that while
    interesting, will never come up in your day-to-day role as a developer.  The goal
    was to present solutions to real-world problems. We have developed a functional
    Line of Business application from start to finish, working through common tasks
    that you will encounter on a daily basis, whether working on an initiative at
    work or on a personal project at home.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情绪不仅适用于部署，还适用于整个项目生命周期。本书的目标不是讨论理论问题，虽然有趣，但在您作为开发人员的日常角色中永远不会出现。目标是提出解决实际问题的解决方案。我们从头到尾开发了一个功能性的业务应用程序，通过常见任务，您将在日常工作中遇到，无论是在工作中进行倡议还是在家中进行个人项目。
- en: I hope that some of the approaches detailed in this book prove useful to you
    and that you go on to enjoy working with Qt as much as I do.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望本书中详细介绍的一些方法对您有所帮助，并且您将继续享受与Qt一起工作的乐趣，就像我一样。
