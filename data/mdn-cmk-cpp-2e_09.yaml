- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Managing Dependencies in CMake
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CMake中管理依赖项
- en: 'It doesn’t really matter if your solution is large or small; as it grows, you’ll
    likely choose to rely on other projects. Avoiding the effort of creating and maintaining
    boilerplate code is crucial. This frees up your time for what truly matters: the
    business logic. External dependencies serve multiple purposes. They offer frameworks
    and features, solve complex issues, and play a key role in building and ensuring
    code quality. These dependencies can vary, ranging from specialized compilers
    like **Protocol Buffers** (**Protobuf**) to testing frameworks like Google Test.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案的大小无关紧要；随着项目的增长，你很可能会选择依赖其他项目。避免创建和维护模板代码的工作至关重要，这样可以腾出时间专注于真正重要的事情：业务逻辑。外部依赖有多种用途。它们提供框架和功能，解决复杂问题，并在构建和确保代码质量方面发挥关键作用。这些依赖项可以有所不同，从像**Protocol
    Buffers**（**Protobuf**）这样的专用编译器到像Google Test这样的测试框架。
- en: When working with open-source projects or in-house code, managing external dependencies
    efficiently is essential. Doing this manually would require a lot of setup time
    and ongoing support. Luckily, CMake excels at handling various approaches to dependency
    management while staying current with industry standards.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理开源项目或内部代码时，高效管理外部依赖项至关重要。手动进行这些管理将需要大量的设置时间和持续的支持。幸运的是，CMake在处理各种依赖管理方法方面表现出色，同时能够保持与行业标准的同步。
- en: 'We will first learn how to identify and utilize dependencies already present
    on the host system, thereby avoiding unnecessary downloads and extended compilation
    times. This task is relatively straightforward, as many packages are either CMake-compatible
    or supported by CMake right out of the box. We’ll also explore how to instruct
    CMake to locate and include dependencies that lack this native support. For legacy
    packages, an alternative approach can be beneficial in specific situations: we
    can employ the once-popular `pkg-config` tool to handle the more cumbersome tasks.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习如何识别和利用主机系统上已有的依赖项，从而避免不必要的下载和延长的编译时间。这项任务相对简单，因为许多包要么与CMake兼容，要么CMake自带对其的支持。我们还将探索如何指示CMake查找并包含那些没有本地支持的依赖项。对于旧版包，某些情况下采用替代方法可能会更有效：我们可以使用曾经流行的
    `pkg-config` 工具来处理更繁琐的任务。
- en: 'Additionally, we will delve into managing dependencies that are available online
    but not yet installed on the system. We’ll examine how to fetch these from HTTP
    servers, Git, and other types of repositories. We will also discuss how to choose
    the optimal approach: first, searching within the system and then resorting to
    fetching if the package is not found. Finally, we’ll review an older technique
    for downloading external projects that may be applicable in special cases.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将深入探讨如何管理尚未安装在系统上的在线可用依赖项。我们将研究如何从HTTP服务器、Git和其他类型的仓库中获取这些依赖项。我们还将讨论如何选择最佳方法：首先在系统内搜索，如果未找到包，则转而获取。最后，我们将回顾一种较旧的技术，用于下载外部项目，这在某些特殊情况下可能仍然适用。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Using already installed dependencies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用已安装的依赖项
- en: Using dependencies not present in the system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用系统中未安装的依赖项
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files that are present in this chapter on GitHub at [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch09](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch09).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章中的代码文件，链接为 [https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch09](https://github.com/PacktPublishing/Modern-CMake-for-Cpp-2E/tree/main/examples/ch09)。
- en: 'To build the examples provided in this book, always use the recommended commands:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建本书中提供的示例，始终使用推荐的命令：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Be sure to replace the `<build tree>` and `<source tree>` placeholders with
    appropriate paths. As a reminder: **build tree** is the path to the target/output
    directory and **source tree** is the path at which your source code is located.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 `<build tree>` 和 `<source tree>` 占位符替换为适当的路径。提醒一下：**build tree** 是目标/输出目录的路径，**source
    tree** 是你的源代码所在的路径。
- en: Using already installed dependencies
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用已安装的依赖项
- en: When our project depends on a popular library, it’s likely that the operating
    system already has the right package installed. We just have to connect it to
    our project’s build process. How do we do that? We need to find out where the
    package is on the system so CMake can use its files. Doing this by hand is possible,
    but every environment is a little different. A path that works on one system might
    not work on another. So, we should automatically find these paths when building.
    There are different ways to do this, but the best method is usually CMake’s built-in
    `find_package()` command, which knows how to find many commonly used packages.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的项目依赖于一个流行的库时，操作系统很可能已经安装了正确的包。我们只需要将它连接到项目的构建过程中。我们该怎么做呢？我们需要找到包在系统中的位置，以便
    CMake 能够使用它的文件。手动完成这一过程是可行的，但每个环境都有些不同。在一个系统上有效的路径可能在另一个系统上无效。因此，我们应该在构建时自动找到这些路径。有多种方法可以实现这一点，但通常最好的方法是
    CMake 内置的`find_package()`命令，它知道如何找到许多常用的包。
- en: 'If our package isn’t supported, we have two options:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的包不受支持，我们有两个选择：
- en: We can write a small plugin called a `find-module` to help `find_package()`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写一个小插件，称为`find-module`，来帮助`find_package()`。
- en: We can use an older method called `pkg-config`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用一种较旧的方法，叫做`pkg-config`。
- en: Let’s start with the recommended option first.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从推荐的选项开始。
- en: Finding packages with CMake’s find_package()
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CMake 的`find_package()`查找包。
- en: 'Let’s start by looking at the following scenario: you want to improve the way
    you’re doing network communication or data storage. Simple plain-text files or
    open-text formats like JSON and XML are too verbose in terms of size. Using a
    binary format would help things, and a well-known library like Google’s Protobuf
    looks like the answer.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看以下场景：你想改进网络通信或数据存储的方式。简单的纯文本文件或像 JSON 和 XML 这样的开放文本格式在大小上过于冗长。使用二进制格式会有所帮助，而像谷歌的
    Protobuf 这样的知名库看起来是答案。
- en: You’ve read the instructions and installed what you need on your system. Now
    what? How do you get CMake’s `find_package()` to find and use this new library?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经阅读了说明并在系统上安装了所需的内容。现在该怎么办呢？如何让 CMake 的`find_package()`找到并使用这个新库？
- en: To execute this example, we have to install the dependencies we want to use
    because the `find_package()` command only looks for packages that are already
    on your system. It assumes you’ve got everything installed, or that users know
    how to install what’s needed if they’re told to. If you want to handle other situations,
    you’ll need a backup plan. You can find more about this in the *Using dependencies
    not present in the system* section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这个示例，我们必须安装我们想使用的依赖项，因为`find_package()`命令只会查找已经安装在系统中的包。它假设你已经安装了所有必要的包，或者用户知道如何安装所需的包。如果你想处理其他情况，你需要一个备用计划。你可以在*使用系统中不存在的依赖项*部分找到更多信息。
- en: 'In the case of Protobuf, the situation is fairly straightforward: you can either
    download, compile, and install the library yourself from the official repository
    ([https://github.com/protocolbuffers/protobuf](https://github.com/protocolbuffers/protobuf))
    or use the package manager in your operating system. If you’re following these
    examples using the Docker image mentioned in *Chapter 1*, *First Steps with CMake*,
    your dependencies are already installed and you don’t need to do anything. However,
    if you’d like to try installing by yourself, the commands to install the Protobuf
    library and compiler for Debian Linux are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Protobuf，情况相对简单：你可以从官方仓库（[https://github.com/protocolbuffers/protobuf](https://github.com/protocolbuffers/protobuf)）下载、编译并安装库，或者使用操作系统中的包管理器。如果你按照*第一章：CMake的第一步*中提到的
    Docker 镜像进行操作，你的依赖项已经安装好了，你无需做任何事情。然而，如果你想自己尝试安装，Debian Linux 上安装 Protobuf 库和编译器的命令如下：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Many projects these days choose to support CMake. They do this by creating a
    **config file** and putting it in the appropriate system directory during installation.
    Config files are an inherent part of projects opting in to support CMake.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目前很多项目选择支持 CMake。它们通过创建一个**配置文件**并在安装过程中将其放入合适的系统目录来实现这一点。配置文件是选择支持 CMake 的项目中不可或缺的一部分。
- en: If you want to use a library that doesn’t have a config file, don’t worry. CMake
    supports an external mechanism to find such libraries called **find modules**.
    Unlike config files, find modules are not part of the project they’re helping
    to locate. In fact, CMake itself often comes with these find modules for many
    popular libraries.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用一个没有配置文件的库，别担心。CMake支持一种外部机制来查找此类库，称为**查找模块**。与配置文件不同，查找模块不是它们帮助定位的项目的一部分。实际上，CMake本身通常会为许多流行的库提供这些查找模块。
- en: 'If you’re stuck and without either a config file or a find module, you have
    other choices:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你卡住了，既没有配置文件也没有查找模块，你还有其他选择：
- en: Write your own find modules for the specific package and include them in your
    project
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为特定包编写自己的查找模块并将其包含到你的项目中
- en: Use a FindPkgConfig module to leverage legacy Unix package definition files
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FindPkgConfig模块来利用传统的Unix包定义文件
- en: Write a config file and ask package maintainers to include it
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写配置文件并请求包维护者将其包含进来
- en: You might think that you’re not quite ready to create such merge requests yourself.
    That’s okay because you most likely won’t have to. CMake comes with over 150 find
    modules that can find libraries such as Boost, bzip2, curl, curses, GIF, GTK,
    iconv, ImageMagick, JPEG, Lua, OpenGL, OpenSSL, PNG, PostgreSQL, Qt, SDL, Threads,
    XML-RPC, X11, and zlib, as well as the Protobuf file that we’re going to use in
    this example. A full list is available in the CMake documentation (see the *Further
    reading* section).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为自己还没准备好创建这样的合并请求。没关系，因为你很可能不需要这么做。CMake自带了超过150个查找模块，可以找到如Boost、bzip2、curl、curses、GIF、GTK、iconv、ImageMagick、JPEG、Lua、OpenGL、OpenSSL、PNG、PostgreSQL、Qt、SDL、Threads、XML-RPC、X11和zlib等库，也包括我们在本例中将使用的Protobuf文件。完整列表可以在CMake文档中找到（请参见*进一步阅读*部分）。
- en: 'Both find modules and config files can be used with CMake’s `find_package()`
    command. CMake starts by checking its built-in find modules. If it doesn’t find
    what it needs, it moves on to checking the config files provided by different
    packages. CMake scans paths where packages are usually installed (depending on
    the operating system). It looks for files that match these patterns:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: CMake的`find_package()`命令可以使用查找模块和配置文件。CMake首先检查其内建的查找模块。如果没有找到需要的模块，它会继续检查不同包提供的配置文件。CMake会扫描通常安装包的路径（取决于操作系统）。它会寻找与这些模式匹配的文件：
- en: '`<CamelCasePackageName>Config.cmake`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<CamelCasePackageName>Config.cmake`'
- en: '`<kebab-case-package-name>-config.cmake`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<kebab-case-package-name>-config.cmake`'
- en: If you want to add external find modules to your project, set the `CMAKE_MODULE_PATH`
    variable. CMake will scan this directory first.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将外部查找模块添加到你的项目中，设置`CMAKE_MODULE_PATH`变量。CMake会首先扫描这个目录。
- en: 'Going back to our example, the goal is simple: I want to show that I can build
    a project that uses Protobuf effectively. Don’t worry, you don’t need to know
    Protobuf to understand what happens. In basic terms, Protobuf is a library that
    saves data in a specific binary format. This makes it easy to write and read C++
    objects to and from files or over a network. To set this up, we use a `.proto`
    file to give Protobuf the data structure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的示例，目标很简单：我想展示我可以构建一个有效使用Protobuf的项目。别担心，你不需要了解Protobuf就能理解发生了什么。简单来说，Protobuf是一个将数据以特定二进制格式保存的库。这使得将C++对象读写到文件或通过网络传输变得容易。为了设置这个，我们使用一个`.proto`文件来给Protobuf定义数据结构：
- en: '**ch09/01-find-package-variables/message.proto**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/01-find-package-variables/message.proto**'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code is a simple schema definition that includes a single 32-bit integer.
    The Protobuf package comes with a binary that will compile these `.proto` files
    into C++ sources and headers that our application can use. We’ll need to add this
    compilation step to our build process, but we’ll get back to that later. For now,
    let’s see how our `main.cpp` file uses the output generated by Protobuf:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是一个简单的模式定义，包含了一个32位整数。Protobuf包自带一个二进制文件，该文件会将这些`.proto`文件编译成C++源文件和头文件，我们的应用程序可以使用这些文件。我们需要将这个编译步骤加入到构建过程中，但稍后我们会回到这个话题。现在，让我们看看`main.cpp`文件如何使用Protobuf生成的输出：
- en: '**ch09/01-find-package-variables/main.cpp**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/01-find-package-variables/main.cpp**'
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I’ve included a `message.pb.h` header that I expect Protobuf to generate. This
    header will have the definition for the `Message` object, as configured in `message.proto`.
    In the `main()` function, I’m creating a simple `Message` object. I set its `id`
    field to `123` as a random example and then print its debug information to the
    standard output. Next, a binary version of this object is written to the file
    stream. This is the most basic use case for a serialization library like Protobuf.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经包含了一个 `message.pb.h` 头文件，我期望 Protobuf 会生成这个文件。这个头文件将包含在 `message.proto` 中配置的
    `Message` 对象的定义。在 `main()` 函数中，我创建了一个简单的 `Message` 对象。我将其 `id` 字段设置为 `123`，作为一个随机示例，然后将其调试信息打印到标准输出。接下来，该对象的二进制版本被写入文件流中。这是类似
    Protobuf 这样的序列化库的最基本用例。
- en: The `message.pb.h` header has to be generated before `main.cpp` is compiled.
    This is done by `protoc`, the Protobuf compiler, which takes `message.proto` as
    input. Managing this process sounds complicated, but it’s really not!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`message.pb.h` 头文件必须在编译 `main.cpp` 之前生成。这是通过 Protobuf 编译器 `protoc` 完成的，它将 `message.proto`
    作为输入。管理这个过程听起来很复杂，但其实并不复杂！'
- en: 'This is where the CMake magic happens:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 CMake 魔法发生的地方：
- en: '**ch09/01-find-package-variables/CMakeLists.txt**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/01-find-package-variables/CMakeLists.txt**'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s break this down:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来逐步解析：
- en: 'The first two lines are straightforward: they set up the project and specify
    that it will use the C++ language.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两行是直接的：它们设置了项目并指定将使用 C++ 语言。
- en: '`find_package(Protobuf REQUIRED)` tells CMake to find the Protobuf library
    (by executing the bundled `FindProtobuf.cmake` find module) and prepare it for
    use in our project. If it can’t find the library, the build will stop because
    we used the `REQUIRED` keyword.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find_package(Protobuf REQUIRED)` 告诉 CMake 查找 Protobuf 库（通过执行捆绑的 `FindProtobuf.cmake`
    查找模块），并为我们的项目做好准备。如果找不到库，构建将停止，因为我们使用了 `REQUIRED` 关键字。'
- en: '`protobuf_generate_cpp` is a custom function defined in the Protobuf find module.
    It automates the process of invoking the `protoc` compiler. After successful compilation,
    it will store paths to the generated sources in variables provided as the first
    two arguments: `GENERATED_SRC` and `GENERATED_HEADER`. All subsequent arguments
    will be treated as a list of files to compile (`message.proto`).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protobuf_generate_cpp` 是在 Protobuf 查找模块中定义的自定义函数。它自动化了调用 `protoc` 编译器的过程。成功编译后，它会将生成的源文件路径存储在作为前两个参数提供的变量中：`GENERATED_SRC`
    和 `GENERATED_HEADER`。所有后续的参数将被视为需要编译的文件列表（`message.proto`）。'
- en: '`add_executable` creates our executable using `main.cpp` and Protobuf-generated
    files.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_executable` 使用 `main.cpp` 和 Protobuf 生成的文件创建我们的可执行文件。'
- en: '`target_link_libraries` tells CMake to link the Protobuf libraries to our executable.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_link_libraries` 告诉 CMake 将 Protobuf 库链接到我们的可执行文件。'
- en: '`target_include_directories()` adds to `include` paths the necessary `INCLUDE_DIRS`
    provided by the package and `CMAKE_CURRENT_BINARY_DIR`. The latter tells the compiler
    where to find the `message.pb.h` header.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_include_directories()` 将包提供的必要 `INCLUDE_DIRS` 和 `CMAKE_CURRENT_BINARY_DIR`
    添加到 `include` 路径。后者告诉编译器在哪里找到 `message.pb.h` 头文件。'
- en: 'The Protobuf find module provides the following functionalities:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 查找模块提供以下功能：
- en: It finds the Protobuf library and its compiler.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它查找 Protobuf 库及其编译器。
- en: It provides helper functions to compile the `.proto` files.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了帮助函数来编译 `.proto` 文件。
- en: It sets variables with paths for inclusion and linking.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它设置了包含和链接的路径变量。
- en: 'While not every module comes with convenient helper functions like Protobuf,
    most modules do set up a few key variables for you. These are useful for managing
    the dependency in your project. Whether you’re using a built-in find module or
    a config file, after the package is successfully found, you can expect some or
    all of the following variables to be set:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并非每个模块都提供像 Protobuf 这样的方便助手函数，但大多数模块都会为你设置一些关键变量。这些变量对于管理项目中的依赖关系非常有用。无论你是使用内置的查找模块还是配置文件，在包成功找到之后，你可以期望以下一些或所有变量被设置：
- en: '`<PKG_NAME>_FOUND`: This indicates whether the package was successfully found.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<PKG_NAME>_FOUND`：指示包是否成功找到。'
- en: '`<PKG_NAME>_INCLUDE_DIRS` or `<PKG_NAME>_INCLUDES`: This points to the directories
    where the package’s header files are located.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<PKG_NAME>_INCLUDE_DIRS` 或 `<PKG_NAME>_INCLUDES`：指向包含包头文件的目录。'
- en: '`<PKG_NAME>_LIBRARIES` or `<PKG_NAME>_LIBS`: These are lists of libraries that
    you’ll need to link against.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<PKG_NAME>_LIBRARIES` 或 `<PKG_NAME>_LIBS`：这些是你需要链接的库列表。'
- en: '`<PKG_NAME>_DEFINITIONS`: This contains any compiler definitions needed for
    the package.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<PKG_NAME>_DEFINITIONS`：包含包所需的任何编译器定义。'
- en: After running `find_package()`, you can immediately check the `<PKG_NAME>_FOUND`
    variable to see whether CMake was successful in locating the package.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `find_package()` 后，你可以立即检查 `<PKG_NAME>_FOUND` 变量，看看 CMake 是否成功找到了该包。
- en: If a package module is written for CMake 3.10 or newer, it will also likely
    provide target definitions. These targets will be designated as `IMPORTED` targets
    to distinguish them as originating from an external dependency.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个包模块是为 CMake 3.10 或更高版本编写的，它也很可能提供目标定义。这些目标将被标记为 `IMPORTED` 目标，以区分它们来自外部依赖项。
- en: 'Protobuf is a great example to explore when learning about dependencies in
    CMake, as it defines module-specific variables and `IMPORTED` targets. Such targets
    allow us to write even more concise code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 是学习 CMake 中依赖项的一个很好的示例，它定义了模块特定的变量和 `IMPORTED` 目标。这样的目标让我们能够编写更加简洁的代码：
- en: '**ch09/02-find-package-targets/CMakeLists.txt**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/02-find-package-targets/CMakeLists.txt**'
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Look at how the highlighted code compares with the previous version of this
    example: instead of using variables that listfiles and directories, it’s a good
    idea to use `IMPORTED` targets. This approach simplifies the listfile. It also
    automatically takes care of transient usage requirements, or propagated properties,
    as illustrated here with `protobuf::libprotobuf` target.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 看看高亮代码与此示例的前一个版本有何不同：与使用列出文件和目录的变量相比，使用 `IMPORTED` 目标是个好主意。这种方法简化了列表文件。它还自动处理了瞬态使用要求或传递的属性，如这里的
    `protobuf::libprotobuf` 目标所示。
- en: 'If you want to know exactly what a specific find module provides, your best
    resource is its online documentation. For example, you can find detailed information
    for Protobuf on the CMake official website at this link: [https://cmake.org/cmake/help/latest/module/FindProtobuf.html](https://cmake.org/cmake/help/latest/module/FindProtobuf.html).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想确切知道某个特定的 find 模块提供了什么，最好的资源就是它的在线文档。例如，你可以通过以下链接在 CMake 官方网站上找到 Protobuf
    的详细信息：[https://cmake.org/cmake/help/latest/module/FindProtobuf.html](https://cmake.org/cmake/help/latest/module/FindProtobuf.html)。
- en: To keep things simple, examples in this section will simply fail if the Protobuf
    library is not found in the user’s system. But a really robust solution should
    verify the `Protobuf_FOUND` variable, and present a clear diagnostic message for
    the user (so they can install it) or perform the installation automatically. We’ll
    learn how to do this later in this chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化示例，本节中的例子将直接在找不到 Protobuf 库时失败。但一个真正稳健的解决方案应该验证 `Protobuf_FOUND` 变量，并为用户提供明确的诊断信息（以便他们可以安装它），或者自动执行安装。我们将在本章稍后学习如何做到这一点。
- en: 'The `find_package()` command has several arguments you can use. While there’s
    a longer list of them, we’ll focus on the key ones here. The basic format of the
    command is:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_package()` 命令有几个可以使用的参数。虽然它们的列表较长，但我们这里将重点介绍关键参数。该命令的基本格式是：'
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s break down what each of these optional arguments means:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来逐一解释这些可选参数的含义：
- en: '`[version]` This specifies the minimum version of the package you need in the
    `major.minor.patch.tweak` format (such as `1.22`). You can also specify a range,
    like `1.22...1.40.1`, using three dots as a separator.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[version]` 这指定了你所需的最小版本号，格式为 `major.minor.patch.tweak`（例如 `1.22`）。你还可以指定一个范围，例如
    `1.22...1.40.1`，使用三个点作为分隔符。'
- en: '`EXACT`: Use this with a non-range `[version]` to tell CMake you want an exact
    version and not a newer one.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXACT`：与非范围型的 `[version]` 一起使用，告诉 CMake 你需要一个精确版本，而不是更高版本。'
- en: '`QUIET`: This suppresses all messages about whether the package was found or
    not.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QUIET`：这会抑制所有关于包是否被找到的消息。'
- en: '`REQUIRED`: This will stop the build if a package is not found and a diagnostic
    message will be shown even if `QUIET` is used.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REQUIRED`：如果未找到包，构建将停止并显示诊断信息，即使使用了 `QUIET` 参数。'
- en: 'If you’re pretty sure that a package should be on your system but `find_package()`
    isn’t locating it, there’s a way to dig deeper. Starting with CMake 3.24, you
    can run the configure stage in `debug` mode to get more information. Use the following
    command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确定一个包应该在你的系统上，但 `find_package()` 无法找到它，你可以深入挖掘。 从 CMake 3.24 开始，你可以在 `debug`
    模式下运行配置阶段以获取更多信息。使用以下命令：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Be cautious with this command. Make sure you type the package name exactly as
    it is because it’s case-sensitive.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令时要小心。确保你准确输入包名，因为它是区分大小写的。
- en: 'More information on the `find_package()` command can be found on the documentation
    page here: [https://cmake.org/cmake/help/latest/command/find_package.html](https://cmake.org/cmake/help/latest/command/find_package.html).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`find_package()`命令的更多信息可以在文档页面找到：[https://cmake.org/cmake/help/latest/command/find_package.html](https://cmake.org/cmake/help/latest/command/find_package.html)。
- en: Find modules are meant as a very convenient way of providing CMake with information
    on installed dependencies. Most popular libraries are widely supported by CMake
    on all major platforms. What can we do, though, when we want to use a third-party
    library that doesn’t have a dedicated find module yet?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 查找模块是为CMake提供已安装依赖项信息的非常便捷的方式。大多数流行的库都在所有主要平台上得到CMake的广泛支持。但是，当我们想要使用一个还没有专门查找模块的第三方库时，该怎么办呢？
- en: Writing your own find modules
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写自己的查找模块
- en: On a rare occasion, the library that you really want to use in your project
    doesn’t provide a config file and there’s no find module readily available in
    CMake yet. You can then write a custom find module for that library and ship it
    with your project. This situation is not ideal, but in the interest of taking
    care of the users of your project, it has to be done.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，你想在项目中使用的库没有提供配置文件，并且CMake中也没有现成的查找模块。你可以为该库编写一个自定义的查找模块，并将其随项目一起分发。虽然这种情况并不理想，但为了照顾项目的用户，还是必须这么做。
- en: 'We can try writing a custom find module for the `libpqxx` library, a client
    for the PostgreSQL database. `libpqxx` is preinstalled in the Docker image for
    this book, so there’s no need to worry if you’re using that. Debian users can
    install it using the `libpqxx-dev` package (other operating systems may require
    different commands):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试为`libpqxx`库编写一个自定义的查找模块，`libpqxx`是PostgreSQL数据库的客户端。`libpqxx`已经预安装在本书的Docker镜像中，因此如果你使用的是该镜像，就不必担心。Debian用户可以通过`libpqxx-dev`包安装它（其他操作系统可能需要不同的命令）：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We’ll begin by writing a new file named `FindPQXX.cmake` and storing it in
    the `cmake/module` directory within our project’s source tree. To ensure that
    CMake discovers this find module when `find_package()` is called, we’ll add its
    path to the `CMAKE_MODULE_PATH` variable in our `CMakeLists.txt` using `list(APPEND)`.
    Just a quick reminder: CMake will first check the directories listed in `CMAKE_MODULE_PATH`
    to find the find modules before searching in other locations. Your complete listfile
    should look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写一个名为`FindPQXX.cmake`的新文件，并将其存储在项目源树中的`cmake/module`目录下。为了确保CMake在调用`find_package()`时能够找到这个查找模块，我们将在`CMakeLists.txt`中使用`list(APPEND)`将该路径添加到`CMAKE_MODULE_PATH`变量中。简单提醒一下：CMake会首先检查`CMAKE_MODULE_PATH`中列出的目录，以查找查找模块，然后才会在其他位置进行搜索。你完整的listfile应如下所示：
- en: '**ch09/03-find-package-custom/CMakeLists.txt**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/03-find-package-custom/CMakeLists.txt**'
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With that in place, let’s move on to writing the actual find module. If the
    `FindPQXX.cmake` file is empty, CMake won’t raise any errors, even if you use
    `find_package()` with `REQUIRED`. It’s the responsibility of the find module’s
    author to set the correct variables and follow best practices (like raising errors).
    According to CMake’s guidelines, here are some key points to note:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们将继续编写实际的查找模块。如果`FindPQXX.cmake`文件为空，即使使用`find_package()`并加上`REQUIRED`选项，CMake也不会报错。查找模块的作者需要负责设置正确的变量并遵循最佳实践（例如引发错误）。根据CMake的指南，以下是一些关键点：
- en: When `find_package(<PKG_NAME> REQUIRED)` is called, CMake sets a `<PKG_NAME>_FIND_REQUIRED`
    variable to `1`. The find module should then use `message(FATAL_ERROR)` if the
    library isn’t found.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用`find_package(<PKG_NAME> REQUIRED)`时，CMake会将`<PKG_NAME>_FIND_REQUIRED`变量设置为`1`。如果找不到库，查找模块应使用`message(FATAL_ERROR)`。
- en: When `find_package(<PKG_NAME> QUIET)` is used, CMake sets `<PKG_NAME>_FIND_QUIETLY`
    to `1`. The find module should avoid displaying any extra messages.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用`find_package(<PKG_NAME> QUIET)`时，CMake会将`<PKG_NAME>_FIND_QUIETLY`设置为`1`。此时，查找模块应避免显示任何额外的消息。
- en: CMake sets a `<PKG_NAME>_FIND_VERSION` variable to the version specified in
    the listfiles. If the find module can’t locate the right version, it should trigger
    a `FATAL_ERROR`.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake会将`<PKG_NAME>_FIND_VERSION`变量设置为listfiles中指定的版本。如果查找模块无法找到正确的版本，应该触发`FATAL_ERROR`。
- en: Of course, it’s best to follow the preceding rules for consistency with other
    find modules.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最好遵循上述规则，以确保与其他查找模块的一致性。
- en: 'To create an elegant find module for `PQXX`, let’s follow these steps:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`PQXX`创建一个优雅的查找模块，按照以下步骤操作：
- en: If the paths to the library and headers are already known (supplied by the user
    or retrieved from the cache of a previous run), use these paths to create an `IMPORTED`
    target. If this is done, you can stop here.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果库和头文件的路径已经知道（由用户提供或从上次运行的缓存中检索），则使用这些路径创建`IMPORTED`目标。如果完成此操作，您可以停止这里。
- en: If the paths are not known, begin by finding the library and headers for the
    underlying dependency, which, in this case, is PostgreSQL.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果路径未知，首先找到底层依赖（在本例中是PostgreSQL）的库和头文件。
- en: Next, search the well-known paths to locate the binary version of the PostgreSQL
    client library.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，搜索常见路径以查找PostgreSQL客户端库的二进制版本。
- en: Similarly, scan the known paths to find the PostgreSQL client’s `include` headers.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，扫描已知路径以找到PostgreSQL客户端的`include`头文件。
- en: Finally, confirm whether both the library and include headers are located. If
    they are, create an `IMPORTED` target.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，确认是否找到了库和头文件。如果找到了，就创建一个`IMPORTED`目标。
- en: To create a robust find module for `PQXX`, let’s focus on a couple of important
    tasks. First, the creation of an `IMPORTED` target can happen in two scenarios
    – either the user specifies the library’s paths or the paths are automatically
    detected. To keep our code clean and avoid duplication, we’ll write a function
    that manages the outcome of our search process.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`PQXX`创建一个强大的查找模块，让我们专注于几个重要任务。首先，`IMPORTED`目标的创建有两种情况——要么用户指定了库的路径，要么路径是自动检测的。为了保持代码的简洁并避免重复，我们将编写一个函数来管理搜索过程的结果。
- en: Defining IMPORTED targets
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义IMPORTED目标
- en: To set up an `IMPORTED` target, all we really need is a library defined with
    the `IMPORTED` keyword. This will enable us to use the `target_link_libraries()`
    command in the calling `CMakeLists.txt` listfile. We need to specify the type
    of the library, and for simplicity, we’ll mark it as `UNKNOWN`. This means we’re
    not concerned about whether the library is static or dynamic; we just want to
    pass an argument to the linker.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个`IMPORTED`目标，我们实际上只需要定义一个带有`IMPORTED`关键字的库。这样，我们就可以在调用的`CMakeLists.txt`列表文件中使用`target_link_libraries()`命令。我们需要指定库的类型，为了简化，我们将其标记为`UNKNOWN`。这意味着我们不关心库是静态的还是动态的，我们只需要将一个参数传递给链接器。
- en: Next, we set the essential properties for our target – namely, `IMPORTED_LOCATION`
    and `INTERFACE_INCLUDE_DIRECTORIES`. We use the arguments provided to the function
    for these settings. It’s possible to specify additional properties like `COMPILE_DEFINITIONS`,
    but they are not needed for `PQXX`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为目标设置必要的属性——即`IMPORTED_LOCATION`和`INTERFACE_INCLUDE_DIRECTORIES`。我们使用传递给函数的参数来进行这些设置。虽然可以指定其他属性，如`COMPILE_DEFINITIONS`，但`PQXX`并不需要这些属性。
- en: After that, to make our find module more efficient, we’ll store the found paths
    in cache variables. This way, we won’t have to repeat the search in future runs.
    It’s worth noting that we explicitly set `PQXX_FOUND` in the cache, making it
    globally accessible and allowing the user’s `CMakeLists.txt` to reference it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，为了提高查找模块的效率，我们将在缓存变量中存储找到的路径。这样，我们在未来的运行中就不需要重复搜索了。值得注意的是，我们在缓存中显式设置了`PQXX_FOUND`，使其全局可访问，并允许用户的`CMakeLists.txt`进行引用。
- en: Finally, we mark these cache variables as `advanced`, hiding them in the CMake
    GUI unless the `advanced` option is activated. This is a common best practice
    that we’ll also adopt.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将这些缓存变量标记为`advanced`，在CMake GUI中隐藏它们，除非激活了`advanced`选项。这是一个常见的最佳实践，我们也会采用这种做法。
- en: 'Here’s how the code looks for these operations:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些操作的代码示例：
- en: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake**'
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we’ll discuss how to use custom or previously stored paths for quicker
    setup.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来讨论如何使用自定义或以前存储的路径来加速设置过程。
- en: Accepting user-provided paths and reusing cached values
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接受用户提供的路径并重用缓存值
- en: 'Let’s address the situation where a user has installed `PQXX` in a non-standard
    location and provides the needed paths via command-line arguments using `-D`.
    If that’s the case, we immediately call the function we defined earlier and stop
    the search by using `return()`. We assume that the user has provided accurate
    paths to both the library and its dependencies, like PostgreSQL:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们处理一下用户将`PQXX`安装在非标准位置，并通过命令行参数`-D`提供所需路径的情况。如果是这样，我们立即调用之前定义的函数，并使用`return()`停止搜索。我们假设用户已提供了库及其依赖项（如PostgreSQL）的准确路径：
- en: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake (continued)**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake（续）**'
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This condition will hold true if a configuration was carried out previously,
    as the variables `PQXX_LIBRARIES` and `PQXX_INCLUDES` are stored in the cache.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果先前已进行过配置，这个条件将成立，因为变量 `PQXX_LIBRARIES` 和 `PQXX_INCLUDES` 已存储在缓存中。
- en: It’s time to see how to handle finding the additional libraries that `PQXX`
    relies on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何处理查找 `PQXX` 依赖的附加库。
- en: Searching for nested dependencies
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索嵌套依赖
- en: 'To utilize `PQXX`, the host system must also have PostgreSQL installed. While
    it’s perfectly fine to use another find module within our current find module,
    we should pass along the `REQUIRED` and `QUIET` flags to ensure consistent behavior
    between the nested search and the main search. To do so, we’ll set two helper
    variables to store the keywords we need to pass and fill them according to arguments
    received from CMake: `PQXX_FIND_QUIETLY` and `PQXX_FIND_REQUIRED`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `PQXX`，主机系统必须安装 PostgreSQL。虽然在当前的查找模块中使用其他查找模块是完全可以的，但我们应该传递 `REQUIRED`
    和 `QUIET` 标志，以确保嵌套搜索和主搜索之间的一致行为。为此，我们将设置两个辅助变量来存储需要传递的关键字，并根据 CMake 接收到的参数填充它们：`PQXX_FIND_QUIETLY`
    和 `PQXX_FIND_REQUIRED`。
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Having this done, we’ll dive into the specifics of pinpointing where the `PQXX`
    library resides in the operating system.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，我们将深入探讨如何精准定位 `PQXX` 库在操作系统中的位置。
- en: Searching for library files
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索库文件
- en: 'CMake offers the `find_library()` command to help find library files. This
    command will accept the filenames to look for and a list of possible paths, formatted
    in CMake’s path style:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 提供了 `find_library()` 命令来帮助查找库文件。该命令将接受要查找的文件名和可能的路径列表，路径格式为 CMake 的路径样式：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <VAR_NAME>will serve as the name for variables that store the command’s output.
    If a matching file is found, its path will be stored in the `<VAR_NAME>` variable.
    Otherwise, the `<VAR_NAME>-NOTFOUND` variable will be set to `1`. We’ll use `PQXX_LIBRARY_PATH`
    as our `VAR_NAME`, so we’ll end up with either a path in `PQXX_LIBRARY_PATH` or
    `1` in `PQXX_LIBRARY_PATH-NOTFOUND`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`<VAR_NAME>` 将作为存储命令输出的变量名。如果找到匹配的文件，其路径将存储在 `<VAR_NAME>` 变量中。如果未找到，则 `<VAR_NAME>-NOTFOUND`
    变量将被设置为 `1`。我们将使用 `PQXX_LIBRARY_PATH` 作为我们的 `VAR_NAME`，因此我们最终会得到 `PQXX_LIBRARY_PATH`
    中的路径或 `PQXX_LIBRARY_PATH-NOTFOUND` 中的 `1`。'
- en: 'The `PQXX` library often exports its location to an `$ENV{PQXX_DIR}` environment
    variable, meaning the system may already know its whereabouts. We can include
    this path in our search by first formatting it using `file(TO_CMAKE_PATH)`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`PQXX` 库通常会将其位置导出到 `$ENV{PQXX_DIR}` 环境变量中，这意味着系统可能已经知道它的位置。我们可以通过先使用 `file(TO_CMAKE_PATH)`
    格式化它，然后将此路径包含在我们的搜索中：'
- en: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake (continued)**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake（续）**'
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `NO_DEFAULT_PATH` keyword instructs CMake to bypass its standard list of
    search paths. While you generally wouldn’t want to do this (since the default
    paths are often correct), using `NO_DEFAULT_PATH` allows you to explicitly specify
    your own search locations if needed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`NO_DEFAULT_PATH` 关键字指示 CMake 绕过其标准的搜索路径列表。虽然通常不建议这样做（因为默认路径通常是正确的），但使用 `NO_DEFAULT_PATH`
    可以让你在需要时明确指定自己的搜索位置。'
- en: Let’s move on to finding the required header files that can be included by users
    of the library.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们来查找可以被库用户包含的必需头文件。
- en: Searching for header files
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索头文件
- en: To search for all known header files, we’ll use the `find_path()` command, which
    works very similarly to `find_library()`. The main difference is that `find_library()`
    automatically appends system-specific extensions for libraries, whereas with `find_path()`,
    we need to specify exact names.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查找所有已知的头文件，我们将使用 `find_path()` 命令，它的工作方式与 `find_library()` 非常相似。主要区别在于 `find_library()`
    会自动为库添加系统特定的扩展，而使用 `find_path()` 时，我们需要指定确切的名称。
- en: 'Also, don’t get confused here with `pqxx/pqxx`. It’s an actual header file,
    but its extension was intentionally left off by the library creators to align
    with C++ `#include` directives. This allows it to be used with angle brackets,
    like so: `#include <pqxx/pqxx>`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，别把 `pqxx/pqxx` 弄混了。它是一个实际的头文件，但其扩展名被库创建者故意省略，以便与 C++ 的 `#include` 指令对齐。这样，它就可以像这样使用尖括号：`#include
    <pqxx/pqxx>`。
- en: 'Here’s the snippet:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码片段：
- en: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake (continued)**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake（续）**'
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we’ll look at how to finalize the search process, handle any missing paths,
    and call the function defining `imported` targets.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何完成搜索过程，处理任何缺失的路径，并调用定义 `imported` 目标的函数。
- en: Returning the final results
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 返回最终结果
- en: Now, it’s time to check whether we have any `PQXX_LIBRARY_PATH-NOTFOUND` or
    `PQXX_HEADER_PATH-NOTFOUND` variables set. We can either manually print diagnostic
    messages and halt the build, or we can use the `find_package_handle_standard_args()`
    helper function from CMake. This function sets the `<PKG_NAME>_FOUND` variable
    to `1` if the path variables are correctly filled. It also provides appropriate
    diagnostic messages (it will respect the `QUIET` keyword) and will halt execution
    with a `FATAL_ERROR` if a `REQUIRED` keyword is provided in the `find_package()`
    invocation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，到了检查我们是否设置了任何`PQXX_LIBRARY_PATH-NOTFOUND`或`PQXX_HEADER_PATH-NOTFOUND`变量的时间。我们可以手动打印诊断消息并停止构建，也可以使用
    CMake 的`find_package_handle_standard_args()`帮助函数。这个函数会将`<PKG_NAME>_FOUND`变量设置为`1`，如果路径变量正确填充。它还会提供适当的诊断消息（它会尊重`QUIET`关键字），如果在`find_package()`调用中提供了`REQUIRED`关键字，它将以`FATAL_ERROR`终止执行。
- en: 'If a library is found, we’ll call the function we wrote earlier to define the
    `IMPORTED` targets and store the paths in the cache:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到了库，我们将调用之前写的函数来定义`IMPORTED`目标并将路径存储在缓存中：
- en: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake (continued)**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/03-find-package-custom/cmake/module/FindPQXX.cmake（续）**'
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That’s it! This find module will find `PQXX` and create the appropriate `PQXX::PQXX`
    targets. The complete file is available in the book’s `examples` repository.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！这个查找模块会找到`PQXX`并创建适当的`PQXX::PQXX`目标。完整文件可以在书籍的`examples`代码库中找到。
- en: For libraries that are well supported and likely already installed, this method
    is very effective. But what if you’re dealing with older, less-supported packages?
    Unix-like systems have a tool called `pkg-config`, and CMake has a useful wrapper
    module to support it as well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些支持良好且很可能已经安装的库，这种方法非常有效。但如果你正在处理旧的、支持较差的包呢？类 Unix 系统有一个叫做`pkg-config`的工具，CMake
    也有一个有用的包装模块来支持它。
- en: Discovering legacy packages with FindPkgConfig
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 FindPkgConfig 发现遗留包
- en: Managing dependencies and figuring out the necessary compile flags is a challenge
    as old as C++ libraries themselves. Various tools have been developed to tackle
    this issue, from simple mechanisms to comprehensive solutions integrated into
    buildsystems and IDEs. PkgConfig ([freedesktop.org/wiki/Software/pkg-config](http://freedesktop.org/wiki/Software/pkg-config))
    is one such tool, once very popular and commonly found on Unix-like systems, although
    it’s also available on macOS and Windows.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 管理依赖关系并弄清楚必要的编译标志是一个与 C++ 库本身一样古老的挑战。为了解决这个问题，开发了各种工具，从简单的机制到集成到构建系统和 IDE 中的全面解决方案。PkgConfig（[freedesktop.org/wiki/Software/pkg-config](http://freedesktop.org/wiki/Software/pkg-config)）就是其中一种工具，它曾经非常流行，通常可以在类
    Unix 系统中找到，虽然它也可以在 macOS 和 Windows 上使用。
- en: 'However, PkgConfig is gradually being replaced by more modern solutions. So,
    should you still consider supporting it? Chances are, you probably don’t need
    to. Here’s why:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，PkgConfig 正在逐渐被更现代的解决方案所取代。那么，你还应该考虑支持它吗？很可能，你不需要。以下是原因：
- en: If your library doesn’t provide the `.pc` PkgConfig files, there’s little value
    in writing definition files for an aging tool; opt for newer alternatives instead
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的库没有提供`.pc` PkgConfig 文件，那么为一个过时的工具编写定义文件的价值不大；最好选择更新的替代方案
- en: If you can pick a newer version of the library that supports CMake (we’ll discuss
    how to download dependencies from the internet later in this chapter)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你能选择一个支持 CMake 的较新版本的库（我们将在本章后面讨论如何从互联网下载依赖项）
- en: If the package is widely used, the latest version of CMake might already include
    a find module for it
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果这个包被广泛使用，CMake 的最新版本可能已经包含了它的查找模块
- en: If a community-created find module is available online and its license allows
    you to use it, that’s another good option
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果网上有社区创建的查找模块，并且它的许可证允许你使用它，那也是一个不错的选择
- en: If you can write and maintain a find module yourself
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你能自己编写并维护一个查找模块
- en: Use PkgConfig only if you’re working with a library version that already provides
    a PkgConfig `.pc` file, and no config module or find module is available. Also,
    there should be a strong reason why creating a find module yourself isn’t a viable
    option. If you’re convinced that you don’t need PkgConfig, go ahead and skip this
    section.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在你正在使用的库版本已经提供了 PkgConfig `.pc` 文件，并且没有可用的配置模块或查找模块时，才使用 PkgConfig。此外，应该有充分的理由说明为什么自己创建一个查找模块不可行。如果你确信不需要
    PkgConfig，可以跳过这一节。
- en: 'Sadly, not all environments can be quickly updated to the latest versions of
    a library. Many companies are still using legacy systems in production, which
    are no longer receiving the latest packages. If you have a `.pc` file for a specific
    library in your system, it will look something like the one for `foobar` shown
    here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并非所有环境都能迅速更新到最新版本的库。许多公司仍在生产中使用老旧系统，这些系统不再接收最新的包。如果您的系统中有某个库的 `.pc` 文件，它可能看起来像这里显示的
    `foobar` 文件：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The format of PkgConfig is simple, and many developers familiar with this tool
    prefer using it out of habit over learning more advanced systems like CMake. Despite
    its simplicity, PkgConfig can check whether a specific library and its version
    are available, and it can also get linking flags and directory information for
    the library.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: PkgConfig 的格式简单，许多熟悉这个工具的开发者出于习惯，倾向于使用它，而不是学习更复杂的系统，如 CMake。尽管它很简单，PkgConfig
    仍然能够检查特定的库及其版本是否可用，还能获取库的链接标志和目录信息。
- en: To use it with CMake, you need to find the `pkg-config` tool on your system,
    run specific commands, and then store the results for later use by the compiler.
    Doing all these steps each time you use PkgConfig can feel like a lot of work.
    Luckily, CMake provides a FindPkgConfig find module. If PkgConfig is found, `PKG_CONFIG_FOUND`
    will be set. We can then use `pkg_check_modules()` to look for the package we
    need.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 CMake 中使用它，您需要在系统中找到 `pkg-config` 工具，运行特定的命令，然后存储结果以便编译器后续使用。每次使用 PkgConfig
    时都做这些步骤可能会觉得很繁琐。幸运的是，CMake 提供了一个 FindPkgConfig 查找模块。如果找到了 PkgConfig，`PKG_CONFIG_FOUND`
    将被设置。然后，我们可以使用 `pkg_check_modules()` 查找所需的包。
- en: 'We have already become familiar with `libpqxx` in the previous section, and
    since it offers a `.pc` file, let’s try and find it using PkgConfig. To put this
    in action, let’s write a simple `main.cpp` file, which utilizes a placeholder
    connection class:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中已经熟悉了 `libpqxx`，并且它提供了一个 `.pc` 文件，接下来我们将尝试使用 PkgConfig 查找它。为了实现这一点，让我们编写一个简单的
    `main.cpp` 文件，使用一个占位符连接类：
- en: '**ch09/04-find-pkg-config/main.cpp**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/04-find-pkg-config/main.cpp**'
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In a typical listfile, we usually start with the `find_package()` function and
    switch to PkgConfig if the library isn’t detected. This approach is useful when
    the environment gets updated, as we can keep using the `main` method without altering
    the code. We’ll skip this part for this example to keep it short.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的列表文件中，我们通常会先使用 `find_package()` 函数，如果未检测到库，再切换到 PkgConfig。这种方法在环境更新时很有用，因为我们可以继续使用
    `main` 方法，而无需修改代码。为了简洁起见，本示例将跳过这一部分。
- en: '**ch09/04-find-pkg-config/CMakeLists.txt**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/04-find-pkg-config/CMakeLists.txt**'
- en: '[PRE19]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s break down what happens:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下发生了什么：
- en: The `find_package()` command is used to locate PkgConfig. If `pkg-config` is
    missing, the process stops due to the `REQUIRED` keyword.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`find_package()` 命令用于查找 PkgConfig。如果 `pkg-config` 丢失，过程将因 `REQUIRED` 关键字而停止。'
- en: The `pkg_check_modules()` custom macro from the `FindPkgConfig` find module
    sets up a new `IMPORTED` target named `PQXX`. The find module looks for a `libpqxx`
    dependency and will fail if it’s not there, again because of the `REQUIRED` keyword.
    The `IMPORTED_TARGET` keyword is crucial; otherwise, we’d need to define the target
    manually.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FindPkgConfig` 查找模块中的 `pkg_check_modules()` 自定义宏设置了一个名为 `PQXX` 的新 `IMPORTED`
    目标。查找模块会查找 `libpqxx` 依赖项，如果找不到它，查找过程会失败，这又是由于 `REQUIRED` 关键字的作用。`IMPORTED_TARGET`
    关键字至关重要；否则，我们将需要手动定义目标。'
- en: We validate the setup with a `message()` function, displaying `PQXX_FOUND`.
    If we hadn’t used `REQUIRED` earlier, this is where we could check whether the
    variable was set, maybe to activate other fallbacks.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过 `message()` 函数验证设置，显示 `PQXX_FOUND`。如果我们之前没有使用 `REQUIRED`，这里就是检查变量是否已设置的地方，可能用于激活其他回退方案。
- en: The `main` executable is declared with `add_executable()`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main` 可执行文件通过 `add_executable()` 声明。'
- en: Finally, we use `target_link_libraries()` to link the `PkgConfig::PQXX` target,
    imported by `pkg_check_modules()`. Note that `PkgConfig::` is a fixed prefix and
    `PQXX` is derived from the first argument we passed to the macro.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用 `target_link_libraries()` 将由 `pkg_check_modules()` 导入的 `PkgConfig::PQXX`
    目标进行链接。请注意，`PkgConfig::` 是固定的前缀，`PQXX` 是我们传递给宏的第一个参数派生出来的。
- en: Using this option is faster than creating a find module for dependencies that
    don’t have CMake support. However, it does come with some downsides. One issue
    is that it relies on the older `pkg-config` tool, which may not be available in
    the operating system that builds the project. Additionally, this approach creates
    a special case that needs to be maintained differently from other methods.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个选项比为没有 CMake 支持的依赖项创建查找模块更快。然而，它也有一些缺点。一个问题是，它依赖于较旧的`pkg-config`工具，这在构建项目的操作系统中可能不可用。此外，这种方法会创建一个特殊情况，需要与其他方法不同的维护方式。
- en: We’ve discussed how to work with dependencies that are already installed on
    your computer. However, that’s only part of the story. Many times, your project
    will go to users who might not have all the required dependencies on their systems.
    Let’s see how to handle this situation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何处理已安装在计算机上的依赖项。然而，这只是故事的一部分。很多时候，你的项目会交给那些可能没有系统上所有必需依赖项的用户。让我们看看如何处理这种情况。
- en: Using dependencies not present in the system
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用系统中不存在的依赖项
- en: 'CMake excels at managing dependencies, particularly when they’re not already
    installed on the system. There are several approaches you can take. If you’re
    using CMake version 3.14 or newer, the `FetchContent` module is your best choice
    for managing dependencies. Essentially, `FetchContent` is a user-friendly wrapper
    around another module called `ExternalProject`. It not only simplifies the process
    but also adds some extra features. We’ll dive deeper into `ExternalProject` later
    in this chapter. For now, just know that the main difference between the two is
    the order of execution:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 在管理依赖项方面表现出色，特别是当依赖项尚未安装在系统中时。你可以采取几种方法。如果你使用的是 CMake 版本 3.14 或更新版本，那么`FetchContent`模块是管理依赖项的最佳选择。基本上，`FetchContent`是对另一个模块`ExternalProject`的用户友好封装。它不仅简化了过程，还增加了一些额外的功能。我们将在本章后面深入探讨`ExternalProject`。现在，只需知道这两者之间的主要区别是执行顺序：
- en: '`FetchContent` brings dependencies in during the *configuration stage*.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FetchContent`会在*配置阶段*引入依赖项。'
- en: '`ExternalProject` brings dependencies in during the *build stage*.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExternalProject`会在*构建阶段*引入依赖项。'
- en: This order is significant, as targets defined by `FetchContent` during the configuration
    stage will be in the same namespace, and as such can be easily used by our project.
    We can link them with other targets, just as if we had defined them ourselves.
    There are rare cases when this is not desirable, and that’s when `ExternalProject`
    is the necessary choice.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顺序很重要，因为在配置阶段，由`FetchContent`定义的目标将处于相同的命名空间中，因此可以轻松地在项目中使用它们。我们可以将它们与其他目标链接，就像我们自己定义的一样。有些情况下这样做并不合适，那时`ExternalProject`是必须的选择。
- en: Let’s see how to deal with the majority of the cases first.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何处理大多数情况。
- en: FetchContent
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FetchContent
- en: 'The `FetchContent` module is extremely useful; it offers the following features:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchContent`模块非常有用，它提供了以下功能：'
- en: Management of directory structure for an external project
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部项目的目录结构管理
- en: Downloading of sources from a URL (and extracting from archives if needed)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 URL 下载源代码（并在需要时从归档中提取）
- en: Support for Git, Subversion, Mercurial, and CVS (Concurrent Versions System)
    repositories
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 Git、Subversion、Mercurial 和 CVS（并行版本系统）仓库
- en: Fetching updates if needed
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，获取更新
- en: Configuring and building the project with CMake, Make, or with a user-specified
    tool
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CMake、Make 或用户指定的工具配置并构建项目
- en: Providing nested dependencies on other targets
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供其他目标的嵌套依赖项
- en: 'The usage of the `FetchContent` module involves three main steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FetchContent`模块涉及三个主要步骤：
- en: Add the module to your project with `include(FetchContent)`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`include(FetchContent)`将模块添加到项目中。
- en: Configure the dependencies with the `FetchContent_Declare()` command. This will
    instruct FetchContent where the dependencies are and which version should be used.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`FetchContent_Declare()`命令配置依赖项。这将指示`FetchContent`依赖项的位置及使用的版本。
- en: Complete the dependency setup using the `FetchContent_MakeAvailable()` command.
    This will download, build, install, and add the listfiles to your main project
    for parsing.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`FetchContent_MakeAvailable()`命令完成依赖项设置。这将下载、构建、安装并将列表文件添加到主项目中以供解析。
- en: 'You might wonder why *steps 2* and *3* are separate. The reason is to allow
    for **configuration overrides** in multi-layered projects. For example, consider
    a project that depends on external libraries, A and B. Library A also depends
    on B, but its authors are using an older version that differs from the parent
    project’s version (*Figure 9.1*):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么*步骤 2*和*步骤 3*是分开的。原因是为了在多层项目中允许**配置覆盖**。例如，考虑一个依赖于外部库A和B的项目。库A也依赖于B，但它的作者使用的是一个较旧版本，这个版本与父项目的版本不同（*图
    9.1*）：
- en: '![](img/B19844_09_01.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19844_09_01.png)'
- en: 'Figure 9.1: The hierarchical project'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：层次化项目
- en: If configuration and download were to occur in the same command, the parent
    project wouldn’t be able to use a newer version, even if it’s backward compatible,
    because the dependency has already configured the *imported targets* for the older
    version introducing conflicts to target names and files of the library.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置和下载在同一个命令中进行，父项目将无法使用更新版本，即使它向后兼容，因为依赖已经为旧版本配置了*导入目标*，这会引起库的目标名称和文件的冲突。
- en: To specify what version is needed, the top-most project has to call the `FetchContent_Declare()`
    command and provide overridden configuration for B, before library A is fully
    set up. The subsequent call to `FetchContent_Declare()` in A will be ignored,
    as the B dependency was already configured.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定需要的版本，最顶层的项目必须调用`FetchContent_Declare()`命令并提供B的覆盖配置，然后库A才会完全设置。随后在A中调用`FetchContent_Declare()`将被忽略，因为B的依赖已经配置好了。
- en: 'Let’s take a look at the signature of the `FetchContent_Declare()` command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`FetchContent_Declare()`命令的签名：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `depName` is a unique identifier of the dependency and will be later used
    by the `FetchContent_MakeAvailable()` command.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`depName`是依赖项的唯一标识符，稍后将由`FetchContent_MakeAvailable()`命令使用。'
- en: The `contentOptions` provides a detailed configuration of the dependency, which
    can get quite complex. It’s important to realize that, under the hood, `FetchContent_Declare()`
    uses the older `ExternalProject_Add()` command. As a matter of fact, many arguments
    provided to `FetchContent_Declare` are directly forwarded to that internal call.
    Before explaining all the arguments in detail, let’s see a working example that
    downloads a dependency from GitHub.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`contentOptions`提供了依赖项的详细配置，可能会变得相当复杂。重要的是要意识到，`FetchContent_Declare()`在后台使用的是较老的`ExternalProject_Add()`命令。实际上，许多传递给`FetchContent_Declare`的参数都会直接转发到该内部调用。在详细解释所有参数之前，让我们看看一个实际示例，它从GitHub下载依赖项。'
- en: Basic example with a YAML reader
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用YAML读取器的基本示例
- en: I’ve written a tiny program that reads a username from a YAML file and prints
    it out in a welcome message. YAML is a great, simple format to store human-readable
    configuration, but it’s quite complex to parse by machines. I’ve found a neat,
    small project that solves this problem called `yaml-cpp` by Jesse Beder ([https://github.com/jbeder/yaml-cpp](https://github.com/jbeder/yaml-cpp)).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我写了一个小程序，它从YAML文件中读取用户名并在欢迎信息中打印出来。YAML是一个很好的简单格式，可以存储人类可读的配置，但机器解析起来相当复杂。我发现了一个很棒的小项目，解决了这个问题，它叫做`yaml-cpp`，由Jesse
    Beder开发（[https://github.com/jbeder/yaml-cpp](https://github.com/jbeder/yaml-cpp)）。
- en: 'The example is fairly straightforward. It’s a greeting program that prints
    a `Welcome <name>` message. The default value of `name` will be `Guest`, but we
    can specify a different name in a YAML configuration file. Here’s the C++ code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例相当直接。它是一个问候程序，打印出`Welcome <name>`信息。`name`的默认值为`Guest`，但我们可以在YAML配置文件中指定一个不同的名字。以下是C++代码：
- en: '**ch09/05-fetch-content/main.cpp**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/05-fetch-content/main.cpp**'
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The configuration file for this example is just a single line:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的配置文件只有一行：
- en: '**ch09/05-fetch-content/config.yaml**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/05-fetch-content/config.yaml**'
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We’ll reuse this example in other sections, so take a second to understand
    how it works. Now that we have the code ready, let’s see how we can build it and
    get the dependency in:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在其他部分重用这个示例，所以请花点时间理解它的工作原理。现在代码已经准备好了，我们来看一下如何构建它并获取依赖：
- en: '**ch09/05-fetch-content/CMakeLists.txt**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/05-fetch-content/CMakeLists.txt**'
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can explicitly access the targets created by the `yaml-cpp` library. To
    prove it, we’ll use a `CMakePrintHelpers` helper module:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以显式访问由`yaml-cpp`库创建的目标。为了证明这一点，我们将使用`CMakePrintHelpers`帮助模块：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we build such a project, the configuration stage will print the following
    output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建这样的项目时，配置阶段将打印以下输出：
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This tells us that the target defined by the `external-yaml-cpp` dependency
    exists; it’s a static library, and its source directory resides inside the build
    tree. This printout isn’t necessary for real-life projects, but it helps to debug
    things if you’re not sure how to correctly include an imported target.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，由 `external-yaml-cpp` 依赖项定义的目标存在，它是一个静态库，并且其源目录位于构建树内。这个输出对于实际项目来说不是必需的，但如果你不确定如何正确包含一个导入的目标，它有助于调试。
- en: 'Since we already copied the `.yaml` file to the output with the `configure_file()`
    command, we can run the program:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经通过 `configure_file()` 命令将 `.yaml` 文件复制到输出目录，我们可以运行该程序：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Everything works like a charm! With hardly any work, we have introduced an external
    dependency and used it in our project.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一切顺利！几乎没有任何工作，我们就引入了一个外部依赖，并在项目中使用了它。
- en: 'If we need more than one dependency, we should write multiple calls to the
    `FetchContent_Declare()` command, each time selecting a unique identifier. But
    there’s no need to call `FetchContent_MakeAvailable()` more than once because
    it supports multiple identifiers (these are case-insensitive):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要多个依赖项，我们应编写多个 `FetchContent_Declare()` 命令，每次选择一个唯一的标识符。但不需要多次调用 `FetchContent_MakeAvailable()`，因为它支持多个标识符（这些标识符不区分大小写）：
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, we’ll learn how to write declarations of dependencies.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何编写依赖声明。
- en: Downloading the dependencies
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载依赖
- en: 'The `FetchContent_Declare()` command offers a wide range of options, which
    come from the `ExternalProject` module. Essentially, you can perform three main
    actions:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchContent_Declare()` 命令提供了多种选项，这些选项来自于 `ExternalProject` 模块。基本上，你可以执行三种主要操作：'
- en: Downloading dependencies
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载依赖
- en: Updating dependencies
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新依赖
- en: Patching dependencies
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补丁依赖
- en: 'Let’s begin by looking at the most common scenario: fetching files from the
    internet. There are many download sources supported by CMake:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最常见的场景开始：从互联网获取文件。CMake 支持许多下载源：
- en: HTTP Server (URL)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 服务器（URL）
- en: Git
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Subversion
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subversion
- en: Mercurial
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mercurial
- en: CVS
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CVS
- en: Going from the top of the list, we’ll first explore how to download dependencies
    from URLs and customize the process to fit our needs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表顶部开始，我们首先探索如何从 URL 下载依赖，并根据需要定制此过程。
- en: Downloading from a URL
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 URL 下载
- en: We can provide a list of URLs to be scanned in sequence until a download succeeds.
    CMake will recognize whether the downloaded file is an archive and will unpack
    it by default.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供一个 URL 列表，按顺序扫描，直到下载成功为止。CMake 会识别下载的文件是否为压缩包，并默认解压它。
- en: 'Basic declaration:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 基本声明：
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here are some additional options to further customize this method:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些额外的选项，可以进一步定制此方法：
- en: '`URL_HASH <algo>=<hashValue>`: This checks whether a downloaded file’s checksum
    generated by `<algo>` matches the provided `<hashValue>`. It is recommended to
    guarantee the integrity of downloads. The following algorithms are supported:
    `MD5`, `SHA1`, `SHA224`, `SHA256`, `SHA384`, `SHA512`, `SHA3_224`, `SHA3_256`,
    `SHA3_384`, and `SHA3_512`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`URL_HASH <algo>=<hashValue>`：此项检查通过`<algo>`生成的下载文件的校验和是否与提供的`<hashValue>`匹配。建议使用此方法来确保下载文件的完整性。支持的算法包括：`MD5`、`SHA1`、`SHA224`、`SHA256`、`SHA384`、`SHA512`、`SHA3_224`、`SHA3_256`、`SHA3_384`和`SHA3_512`。'
- en: '`DOWNLOAD_NO_EXTRACT <bool>`: This explicitly disables extraction after downloading.
    We may consume the filename of downloaded files in the follow-up steps by accessing
    the `<DOWNLOADED_FILE>` variable.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOWNLOAD_NO_EXTRACT <bool>`：此项明确禁用下载后解压缩。我们可以在后续步骤中通过访问 `<DOWNLOADED_FILE>`
    变量来使用下载文件的文件名。'
- en: '`DOWNLOAD_NO_PROGRESS <bool>`: This explicitly disables logging of the download
    progress.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOWNLOAD_NO_PROGRESS <bool>`：此项明确禁用下载进度的日志记录。'
- en: '`TIMEOUT <seconds>` and `INACTIVITY_TIMEOUT <seconds>`: These set timeouts
    to terminate the download after a fixed total time or period of inactivity.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMEOUT <seconds>` 和 `INACTIVITY_TIMEOUT <seconds>`：这些设置超时，以便在固定的总时间或不活动时间后终止下载。'
- en: '`HTTP_USERNAME <username>` and `HTTP_PASSWORD <password>`: These configure
    HTTP authentication. Be cautious not to hardcode credentials.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_USERNAME <username>` 和 `HTTP_PASSWORD <password>`：这些配置 HTTP 身份验证。请小心不要硬编码凭证。'
- en: '`HTTP_HEADER <header1> [<header2>...]`: This adds extra headers to your HTTP
    request, which is useful for AWS or custom tokens.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP_HEADER <header1> [<header2>...]`：这会向你的 HTTP 请求添加额外的头部，对于 AWS 或自定义令牌非常有用。'
- en: '`TLS_VERIFY <bool>`: This verifies the SSL certificate. If this is not set,
    CMake will read this setting from the `CMAKE_TLS_VERIFY` variable, which is set
    to `false` by default. Skipping TLS verification is an unsafe, bad practice and
    should be avoided, especially in production environments.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TLS_VERIFY <bool>`：验证 SSL 证书。如果未设置此项，CMake 将从 `CMAKE_TLS_VERIFY` 变量中读取此设置，该变量默认设置为
    `false`。跳过 TLS 验证是不安全且不推荐的做法，尤其是在生产环境中应避免。'
- en: '`TLS_CAINFO <file>`: This provides a path to the authority file; if it isn’t
    specified, CMake will read this setting from the `CMAKE_TLS_CAINFO` variable.
    It is useful if your company is issuing self-signed SSL certificates.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TLS_CAINFO <file>`：提供一个权限文件的路径；如果没有指定，CMake 会从 `CMAKE_TLS_CAINFO` 变量中读取此设置。如果你的公司发行的是自签名的
    SSL 证书，则此选项很有用。'
- en: The majority of programmers will refer to online repositories like GitHub to
    grab the latest versions of libraries. Here’s how.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员会参考像 GitHub 这样的在线仓库来获取库的最新版本。以下是操作方法。
- en: Downloading from Git
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 Git 下载
- en: 'To download dependencies from Git, ensure that the host system has Git version
    1.6.5 or later. The following options are essential for cloning the project from
    Git:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Git 下载依赖项，确保主机系统上安装了 Git 版本 1.6.5 或更高版本。以下选项对于从 Git 克隆项目至关重要：
- en: '[PRE29]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Both `<url>` and `<tag>` should be compatible with the `git` command. In a production
    environment, it’s advisable to use a specific `git` hash (rather than tag) to
    ensure traceability of the produced binaries and to avoid unnecessary `git` `fetch`
    operations. If you prefer using a branch, stick to remote names such as `origin/main`.
    This ensures the proper synchronization of the local clone.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`<url>` 和 `<tag>` 都应与 `git` 命令兼容。在生产环境中，建议使用特定的 `git` 哈希（而非标签），以确保生产的二进制文件可追溯，并避免不必要的
    `git` `fetch` 操作。如果你更喜欢使用分支，可以使用类似 `origin/main` 的远程名称。这可以确保本地克隆的正确同步。'
- en: 'Additional options include:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选项包括：
- en: '`GIT_REMOTE_NAME <name>`: This sets the remote name (`origin` is the default).'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GIT_REMOTE_NAME <name>`：设置远程名称（`origin` 是默认值）。'
- en: '`GIT_SUBMODULES <module>...`: This specifies which submodules to update; since
    3.16, this value defaults to `none` (previously, all submodules were updated).'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GIT_SUBMODULES <module>...`：指定要更新的子模块；从 3.16 版本开始，此值默认为 `none`（之前会更新所有子模块）。'
- en: '`GIT_SUBMODULES_RECURSE 1`: This enables the recursive updating of submodules.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GIT_SUBMODULES_RECURSE 1`：启用递归更新子模块。'
- en: '`GIT_SHALLOW 1`: This performs a shallow clone, which is faster as it skips
    downloading historical commits.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GIT_SHALLOW 1`：这将执行浅克隆，因为它跳过了下载历史提交，因此速度更快。'
- en: '`TLS_VERIFY <bool>`: This verifies the SSL certificate. If this is not set,
    CMake will read this setting from the `CMAKE_TLS_VERIFY` variable, which is set
    to `false` by default; skipping TLS verification is an unsafe, bad practice and
    should be avoided, especially in production environments.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TLS_VERIFY <bool>`：验证 SSL 证书。如果未设置此项，CMake 将从 `CMAKE_TLS_VERIFY` 变量中读取此设置，该变量默认设置为
    `false`；跳过 TLS 验证是不安全且不推荐的做法，尤其是在生产环境中应避免。'
- en: If your dependency is stored in Subversion, you can also fetch it with CMake.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的依赖项存储在 Subversion 中，你也可以通过 CMake 获取它。
- en: Downloading from Subversion
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 Subversion 下载
- en: 'To download from Subversion, we should specify the following options:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Subversion 下载，我们需要指定以下选项：
- en: '[PRE30]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Additionally, we may provide the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以提供以下内容：
- en: '`SVN_USERNAME <user>` and `SVN_PASSWORD <password>`: These provide credentials
    for checkout and update. Avoid hardcoding these in your projects.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SVN_USERNAME <user>` 和 `SVN_PASSWORD <password>`：这些提供了用于检出和更新的凭据。避免在项目中硬编码这些信息。'
- en: '`SVN_TRUST_CERT <bool>`: This skips the verification of the Subversion server
    site certificate. Use this option only if the network path to the server and its
    integrity are trustworthy.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SVN_TRUST_CERT <bool>`：跳过 Subversion 服务器站点证书的验证。仅在网络路径和服务器的完整性是可信的情况下使用此选项。'
- en: Subversion is very easy to use with CMake. So is Mercurial.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Subversion 与 CMake 配合使用非常简单，Mercurial 也是如此。
- en: Downloading from Mercurial
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 Mercurial 下载
- en: 'This mode is very straightforward. We need to provide two arguments and we’re
    done:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式非常简单，我们只需提供两个参数，就可以完成：
- en: '[PRE31]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Lastly, we can use CVS to provide dependencies.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 CVS 提供依赖项。
- en: Downloading from CVS
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 CVS 下载
- en: 'To check out modules from CVS, we need to provide the following three arguments:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 CVS 检出模块，我们需要提供以下三个参数：
- en: '[PRE32]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With that, we covered all the download options for `FetchContent_Declare()`.
    CMake supports additional steps that can be executed after a successful download.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们已经涵盖了`FetchContent_Declare()`的所有下载选项。CMake 支持在成功下载后执行的附加步骤。
- en: Updating and patching
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新和修补
- en: 'By default, the `update` step will re-download the external project’s files
    if the download method supports updates, for example, if we configure the Git
    dependency pointing to the `main` or `master` branch. We can override this behavior
    in two ways:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果下载方法支持更新，例如，如果我们配置了指向`main`或`master`分支的 Git 依赖项，则`update`步骤会重新下载外部项目的文件。我们可以通过两种方式覆盖这种行为：
- en: Provide a custom command to be executed during the update with `UPDATE_COMMAND
    <cmd>`.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供在更新过程中执行的自定义命令，使用`UPDATE_COMMAND <cmd>`。
- en: Completely disable the `update` step (to allow building with a disconnected
    network) – `UPDATE_DISCONNECTED <bool>`. Do note that dependency will still be
    downloaded during the first build.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全禁用`update`步骤（以便在没有网络的情况下构建）– `UPDATE_DISCONNECTED <bool>`。请注意，依赖项仍然会在第一次构建时被下载。
- en: '`Patch`, on the other hand, is an optional step that will execute after the
    update is fetched. To enable it, we need to specify the exact command we want
    to execute with `PATCH_COMMAND <cmd>`.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`Patch`是一个可选步骤，会在更新后执行。要启用它，我们需要使用`PATCH_COMMAND <cmd>`指定要执行的精确命令。'
- en: CMake documentation warns that some patches may be more “sticky” than others.
    For example, in Git, changed files don’t get restored to the original state during
    the update, and we need to be careful to avoid incorrectly patching the file twice.
    Ideally, the `patch` command should be robust and idempotent.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 文档警告说，有些补丁可能比其他补丁“更粘”。例如，在 Git 中，更新时修改的文件不会恢复到原始状态，我们需要小心避免错误地将文件补丁两次。理想情况下，`patch`命令应当是健壮且幂等的。
- en: 'You can chain `update` and `patch` commands:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`update`和`patch`命令串联起来：
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Downloading dependencies is helpful when they’re not already on the system.
    But what if they are? How can we use the local version instead?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 下载依赖项在系统上没有时是有帮助的。但如果它们已经存在呢？我们如何使用本地版本呢？
- en: Using the installed dependency where possible
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尽可能使用已安装的依赖项
- en: 'Starting with version 3.24, CMake introduced a feature that allows `FetchContent`
    to skip downloading if the dependencies are already available locally. To enable
    this, simply add the `FIND_PACKAGE_ARGS` keyword to your declaration:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 3.24 开始，CMake 引入了一个功能，允许`FetchContent`跳过下载，如果依赖项已经在本地可用。要启用此功能，只需在声明中添加`FIND_PACKAGE_ARGS`关键字：
- en: '[PRE34]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can guess, this keyword instructs the `FetchContent` module to use the
    `find_package()` function before initiating any downloads. If the package is found
    locally, it will be used, and no download or build will occur. Note that this
    keyword should be the last one in the command, as it will consume all subsequent
    arguments.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所猜测的，这个关键字指示`FetchContent`模块在启动任何下载之前使用`find_package()`函数。如果在本地找到该包，则将使用它，不会发生下载或构建。请注意，这个关键字应当是命令中的最后一个，因为它会消耗后续的所有参数。
- en: 'Here’s how to update the previous example:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何更新之前的示例：
- en: '**ch09/06-fetch-content-find-package/CMakeLists.txt**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**ch09/06-fetch-content-find-package/CMakeLists.txt**'
- en: '[PRE35]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We made two key changes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了两个关键的更改：
- en: We added `FIND_PACKAGE_ARGS` with the `NAMES` keyword to specify that we’re
    looking for the `yaml-cpp` package. Without `NAMES`, CMake would default to using
    the `dependency-id`, which, in this case, is `external-yaml-cpp`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了`FIND_PACKAGE_ARGS`和`NAMES`关键字，用来指定我们要查找`yaml-cpp`包。如果没有`NAMES`，CMake 将默认使用`dependency-id`，在这个例子中是`external-yaml-cpp`。
- en: We added `INTERFACE_INCLUDE_DIRECTORIES` in the printed properties. This is
    a one-off check so we can manually verify whether we’re using the installed package
    or if a new one was downloaded.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在打印的属性中添加了`INTERFACE_INCLUDE_DIRECTORIES`。这是一次性检查，以便我们手动验证是否使用了已安装的包，还是下载了一个新的包。
- en: 'Before testing, make sure the package is actually installed on your system.
    If it’s not, you can install it using the following commands:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试之前，请确保包已经实际安装在您的系统上。如果没有，您可以使用以下命令安装它：
- en: '[PRE36]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With this setup, we can now build our project. If all goes well, you should
    see debug output from the `cmake_print_properties()` command. This will indicate
    that we’re using the local version, as shown in the `INTERFACE_INCLUDE_DIRECTORIES`
    property. Keep in mind that this output is specific to your environment, your
    mileage may vary.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个设置，我们现在可以构建我们的项目。如果一切顺利，你应该能看到来自`cmake_print_properties()`命令的调试输出。这将表明我们正在使用本地版本，如`INTERFACE_INCLUDE_DIRECTORIES`属性中所示。请记住，这些输出是特定于你的环境的，结果可能因环境不同而有所不同。
- en: '[PRE37]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you’re not using CMake 3.24, or if you want to support users with older
    versions, you might consider running the `find_package()` command manually. This
    way, you’ll only download packages that aren’t already installed:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用CMake 3.24，或者希望支持使用旧版本的用户，你可能会考虑手动运行`find_package()`命令。这样，你只会下载那些未安装的包：
- en: '[PRE38]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Whichever method you choose, trying to use the local version first and downloading
    only if the dependency isn’t found is a thoughtful approach that offers the best
    user experience.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种方法，首先尝试使用本地版本，只有在找不到依赖项时才下载，是一种非常周到的做法，可以提供最佳的用户体验。
- en: Before the introduction of `FetchContent`, CMake had a simpler module called
    `ExternalProject`. Although `FetchContent` is the recommended choice for most
    situations, `ExternalProject` still has its own set of advantages and can be useful
    in certain cases.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入`FetchContent`之前，CMake有一个更简单的模块，名为`ExternalProject`。虽然`FetchContent`是大多数情况下的推荐选择，但`ExternalProject`仍然有其自身的一些优点，在某些情况下可能会非常有用。
- en: ExternalProject
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ExternalProject
- en: 'As mentioned, before `FetchContent` was introduced to CMake, another module
    was serving a similar purpose: `ExternalProject` (added in 3.0.0). As you can
    guess, it was used to fetch external projects from online repositories. Over the
    years, the module was gradually extended for different needs, resulting in quite
    a complicated command: `ExternalProject_Add()`.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在`FetchContent`引入到CMake之前，另一个模块曾经承担类似的功能：`ExternalProject`（在3.0.0版本中添加）。顾名思义，它用于从在线仓库获取外部项目。多年来，该模块逐渐扩展以满足不同的需求，最终形成了一个相当复杂的命令：`ExternalProject_Add()`。
- en: The `ExternalProject` module populates the dependencies during the build stage.
    That’s quite different from `FetchContent`, which executes in the configuration
    stage. Because of this difference, `ExternalProject` cannot import targets into
    the project like `FetchContent` does. On the other hand, `ExternalProject` can
    install dependencies directly into the system, execute their tests, and do other
    interesting things, like overriding the commands used for configuration and the
    build.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExternalProject`模块在构建阶段填充依赖项。这与`FetchContent`在配置阶段执行的方式有很大不同。因此，`ExternalProject`不能像`FetchContent`那样将目标导入项目。另一方面，`ExternalProject`可以直接将依赖项安装到系统中，执行它们的测试，并做其他有趣的事情，比如覆盖配置和构建过程中使用的命令。'
- en: There is a small set of use cases where this may be necessary. Since there’s
    a lot of overhead needed to use this legacy module effectively, treat it as a
    curiosity. We’re mostly introducing it here to show how the current method evolved
    from it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些少数的使用场景可能需要使用它。由于要有效地使用这个遗留模块需要较高的开销，因此可以将其视为一种好奇心。我们主要在此介绍它，是为了展示当前方法如何从它演变而来。
- en: '`ExternalProject` offers an `ExternalProject_Add` command that configures the
    dependency. Here’s an example:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExternalProject`提供了一个`ExternalProject_Add`命令，用于配置依赖项。以下是一个示例：'
- en: '[PRE39]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As mentioned, it closely resembles the `FetchContent_Declare` from `FetchContent`.
    You’ll notice that there are two additional keywords in the example: `INSTALL_COMMAND`
    and `TEST_COMMAND`. In this case, they are used to suppress the installation and
    tests of the dependency, as they would normally execute during the build. `ExternalProject`
    executes many steps that are deeply configurable, and they execute in the following
    order:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，它与`FetchContent`中的`FetchContent_Declare`非常相似。你会注意到示例中有两个额外的关键词：`INSTALL_COMMAND`和`TEST_COMMAND`。在这个例子中，它们用于抑制依赖项的安装和测试，因为这些操作通常会在构建过程中执行。`ExternalProject`执行许多可深度配置的步骤，并且这些步骤按以下顺序执行：
- en: '`mkdir`: Create a subdirectory for the external project.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mkdir`: 为外部项目创建子目录。'
- en: '`download`: Download the project files from a repository or URL.'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`download`: 从仓库或URL下载项目文件。'
- en: '`update`: Download updates if supported by the `fetch` method.'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update`: 如果`fetch`方法支持，下载更新。'
- en: '`patch` : Execute a `patch` command that alters downloaded files.'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`patch`: 执行一个`patch`命令，修改下载的文件。'
- en: '`configure`: Execute the configure stage.'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`configure`: 执行配置阶段。'
- en: '`build`: Perform the build stage for CMake projects.'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`build`: 执行CMake项目的构建阶段。'
- en: '`install`: Install CMake projects.'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`install`：安装 CMake 项目。'
- en: '`test`: Execute the tests.'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`test`：执行测试。'
- en: For each of the steps, excluding `mkdir`, you can override the default behavior
    by adding a `<STEP>_COMMAND` keyword. There are plenty of other options – please
    refer to the online documentation for the full reference. If, for some reason,
    you’d like to use this method over the recommended `FetchContent`, there’s an
    ugly hack that can be applied to import the targets anyway by executing CMake
    within CMake. For more details, check out the `ch09/05-external-project` code
    example in the repository for this book.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个步骤（排除 `mkdir` 外），你可以通过添加 `<STEP>_COMMAND` 关键字来覆盖默认行为。还有很多其他选项 – 请参考在线文档以获取完整参考。如果出于某种原因，你想使用这种方法而非推荐的
    `FetchContent`，可以通过在 CMake 中执行 CMake 来应用一个不太优雅的黑客方式导入目标。更多细节，请查看本书仓库中的 `ch09/05-external-project`
    代码示例。
- en: Typically, we would rely on the library being available in the system. If it’s
    not, we’d resort to `FetchContent`, an approach that is particularly suitable
    for dependencies that are small and quick to compile.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会依赖系统中已存在的库。如果库不存在，我们会使用 `FetchContent`，这是一种特别适合小型且编译速度较快的依赖项的方法。
- en: However, for more substantial libraries like Qt, this method could be time consuming.
    In such cases, package managers offering precompiled libraries tailored to the
    user’s environment become advisable. While tools like Apt or Conan provide solutions,
    they are either too system-specific or complex to be covered in this book. The
    good news is that most users can install the dependencies your project may require,
    as long as clear installation instructions are provided.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于像 Qt 这样的大型库，这种方法可能比较耗时。在这种情况下，提供预编译库的包管理器，能根据用户环境量身定制库，成为一个明智的选择。尽管像 Apt
    或 Conan 这样的工具提供了解决方案，但它们要么过于系统特定，要么复杂，无法在本书中详细介绍。好消息是，大多数用户只要提供明确的安装说明，就能安装你项目可能需要的依赖项。
- en: Summary
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has equipped you with the knowledge to identify system-installed
    packages using CMake’s find modules and how to utilize the config files that come
    with the library. For older libraries that don’t support CMake but include `.pc`
    files, the PkgConfig tool and CMake’s bundled `FindPkgConfig` find module can
    be used.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经为你提供了如何使用 CMake 的查找模块识别系统安装的包，并且如何利用随库一起提供的配置文件的知识。对于不支持 CMake 但包含 `.pc`
    文件的旧版库，可以使用 PkgConfig 工具和 CMake 内置的 `FindPkgConfig` 查找模块。
- en: We also explored the capabilities of the `FetchContent` module. This module
    allows us to download dependencies from various sources while configuring CMake
    to first scan the system, thereby avoiding unnecessary downloads. We touched upon
    the historical context of these modules and discussed the option of using the
    `ExternalProject` module for special cases.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了 `FetchContent` 模块的功能。该模块允许我们从各种来源下载依赖项，同时配置 CMake 首先扫描系统，从而避免不必要的下载。我们还简要讨论了这些模块的历史背景，并讨论了在特殊情况下使用
    `ExternalProject` 模块的选项。
- en: CMake is designed to automatically generate build targets when a library is
    located through most of the methods we’ve discussed. This adds a layer of convenience
    and elegance to the process. With this foundation in place, you’re ready to incorporate
    standard libraries into your projects.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: CMake 设计的目的是在通过我们讨论的多数方法找到库时，自动生成构建目标。这为过程增加了方便性和优雅性。有了这个基础，你就可以将标准库集成到你的项目中了。
- en: In the next chapter, we’ll learn how to provide reusable code on a smaller scale
    with C++20 modules.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 C++20 模块在更小的范围内提供可重用的代码。
- en: Further reading
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on the topics covered in this chapter, you can refer to
    the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 若要获取本章所涉及主题的更多信息，可以参考以下内容：
- en: CMake documentation – provided find modules:[https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#find
    modules](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#findmodules)
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 文档 – 提供的查找模块：[https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#find
    modules](https://cmake.org/cmake/help/latest/manual/cmake-modules.7.html#findmodules)
- en: CMake documentation – *Using Dependencies Guide*:[https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html)
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 文档 – *使用依赖项指南*：[https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html](https://cmake.org/cmake/help/latest/guide/using-dependencies/index.html)
- en: '*CMake and using git-submodule for dependence projects*:[https://stackoverflow.com/questions/43761594/](https://stackoverflow.com/questions/43761594/)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CMake 和使用 git-submodule 处理依赖项目*：[https://stackoverflow.com/questions/43761594/](https://stackoverflow.com/questions/43761594/)'
- en: Piggybacking on PkgConfig:[https://gitlab.kitware.com/cmake/community/-/wikis/doc/tutorials/How-To-Find-Libraries#piggybacking-on-pkg-config](https://gitlab.kitware.com/cmake/community/-/wikis/doc/tutorials/How-To-Find-Libraries#piggybacking-on-pkg-config)
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 PkgConfig：[https://gitlab.kitware.com/cmake/community/-/wikis/doc/tutorials/How-To-Find-Libraries#piggybacking-on-pkg-config](https://gitlab.kitware.com/cmake/community/-/wikis/doc/tutorials/How-To-Find-Libraries#piggybacking-on-pkg-config)
- en: How to use ExternalProject:[https://www.jwlawson.co.uk/interest/2020/02/23/cmake-external-project.html](https://www.jwlawson.co.uk/interest/2020/02/23/cmake-external-project.html)
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 ExternalProject：[https://www.jwlawson.co.uk/interest/2020/02/23/cmake-external-project.html](https://www.jwlawson.co.uk/interest/2020/02/23/cmake-external-project.html)
- en: '*CMake FetchContent vs. ExternalProject*:[https://www.scivision.dev/cmake-fetchcontent-vs-external-project/](https://www.scivision.dev/cmake-fetchcontent-vs-external-project/)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CMake FetchContent 与 ExternalProject*：[https://www.scivision.dev/cmake-fetchcontent-vs-external-project/](https://www.scivision.dev/cmake-fetchcontent-vs-external-project/)'
- en: '*Using CMake with External Projects*:[http://www.saoe.net/blog/using-cmake-with-external-projects/](http://www.saoe.net/blog/using-cmake-with-external-projects/)'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 CMake 进行 External Projects*：[http://www.saoe.net/blog/using-cmake-with-external-projects/](http://www.saoe.net/blog/using-cmake-with-external-projects/)'
- en: Join our community on Discord
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们在 Discord 上的社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者及其他读者进行讨论：
- en: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/vXN53A7ZcA](https://discord.com/invite/vXN53A7ZcA)'
- en: '![](img/QR_Code94081075213645359.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code94081075213645359.png)'
