- en: Using Mutexes, Semaphores, and Condition Variables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用互斥锁、信号量和条件变量
- en: This chapter will focus on the most common mechanisms you can use to synchronize
    access to a shared resource. The synchronization mechanisms we will look at prevent
    a critical section (the program segment responsible for a resource) from being
    executed concurrently from two or more processes or threads. In this chapter,
    you'll learn how to use both POSIX and C++ standard library synchronization building
    blocks such as mutexes, `std::condition_variable`, `std::promise`, and `std::future`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍您可以使用的最常见机制，以同步对共享资源的访问。我们将研究的同步机制可以防止临界区域（负责资源的程序段）在两个或多个进程或线程中同时执行。在本章中，您将学习如何使用POSIX和C++标准库同步构建块，如互斥锁、`std::condition_variable`、`std::promise`和`std::future`。
- en: 'This chapter will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下示例：
- en: Using POSIX mutexes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用POSIX互斥锁
- en: Using POSIX semaphores
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用POSIX信号量
- en: POSIX semaphores advanced usage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX信号量的高级用法
- en: Synchronization building blocks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步构建块
- en: Learning inter-thread communication with simple events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用简单事件进行线程间通信
- en: Learning inter-thread communication with condition variables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用条件变量进行线程间通信
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: So that you can try out all the programs in this chapter immediately, we've
    set up a Docker image that contains all the tools and libraries we'll need throughout
    this book. It is based on Ubuntu 19.04.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您可以立即尝试本章中的所有程序，我们已经设置了一个Docker镜像，其中包含本书中将需要的所有工具和库。它基于Ubuntu 19.04。
- en: 'In order to set it up, follow these steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置它，按照以下步骤进行：
- en: Download and install the Docker Engine from [www.docker.com](http://www.docker.com).
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[www.docker.com](http://www.docker.com)下载并安装Docker Engine。
- en: Pull the image from Docker Hub: `docker pull kasperondocker/system_programming_cookbook:latest`.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Docker Hub拉取镜像：`docker pull kasperondocker/system_programming_cookbook:latest`。
- en: The image should now be available. Type in the `docker images` command to view
    the image.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 镜像现在应该可用。输入`docker images`命令查看镜像。
- en: You should have the following image: `kasperondocker/system_programming_cookbook`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该有以下镜像：`kasperondocker/system_programming_cookbook`。
- en: Run the Docker image with an interactive shell using the `docker run -it --cap-add
    sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash` command.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest
    /bin/bash`命令以交互式shell运行Docker镜像。
- en: The shell on the running container is now available. Use `root@39a5a8934370/#
    cd /BOOK/` to get all the programs that will be developed in this book.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '正在运行的容器上的shell现在可用。使用`root@39a5a8934370/# cd /BOOK/`获取本书中将开发的所有程序。 '
- en: The `--cap-add sys_ptrace` argument is needed to allow GDB to set breakpoints.
    Docker doesn't allow this by default.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`--cap-add sys_ptrace`参数是为了允许GDB设置断点。Docker默认情况下不允许这样做。'
- en: Using POSIX mutexes
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用POSIX互斥锁
- en: This recipe will teach you how to use POSIX mutexes to synchronize access to
    a resource from multiple threads. We'll do this by developing a program that contains
    a method (the critical section) that will perform a task that cannot run concurrently.
    We'll use the `pthread_mutex_lock`, `pthread_mutex_unlock`, and `pthread_mutex_init`
    POSIX methods to synchronize the threads' access to it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将教你如何使用POSIX互斥锁来同步多个线程对资源的访问。我们将通过开发一个包含一个方法（临界区域）的程序来实现这一点，该方法将执行一个不能并发运行的任务。我们将使用`pthread_mutex_lock`、`pthread_mutex_unlock`和`pthread_mutex_init`
    POSIX方法来同步线程对其的访问。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll create a multi-threaded program just to increment an
    integer to `200000`. To do this, we''ll develop the critical section that''s responsible
    for incrementing the counter, which must be protected. Then, we''ll develop the
    main section, which will create the two threads and manage the coordination between
    them. Let''s proceed:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个多线程程序，只需将一个整数增加到`200000`。为此，我们将开发负责增加计数器的临界区域，必须对其进行保护。然后，我们将开发主要部分，该部分将创建两个线程并管理它们之间的协调。让我们继续：
- en: 'Open a new file called `posixMutex.cpp` and develop its structure and critical
    section method:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个名为`posixMutex.cpp`的新文件，并开发其结构和临界区域方法：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, in the `main` section, add the `init` method for the lock that''s needed
    for synchronization between threads:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`main`部分，添加所需的用于线程同步的锁的`init`方法：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have the method that will execute the `increment` (that is, the
    critical section to protect) and the lock that will manage the synchronization
    between threads, let''s create the threads:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了将执行`increment`（即需要保护的临界区域）的方法和将管理线程之间同步的锁，让我们创建线程：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we have to wait for the threads to complete the tasks:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要等待线程完成任务：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This program (available in the Docker image under the `/BOOK/Chapter05/` folder)
    showed us how to use the POSIX mutex interfaces to synchronize the use of a shared
    resource – a counter, in this case – between threads. We will explain this process
    in detail in the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序（在Docker镜像的`/BOOK/Chapter05/`文件夹下可用）向我们展示了如何使用POSIX互斥锁接口来同步多个线程对共享资源（在本例中是计数器）的使用。我们将在下一节中详细解释这个过程。
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In the first step, we created the `struct` that was needed to pass the parameters
    to the threads: `struct ThreadInfo`. In this `struct`, we put the lock that''s
    needed to protect the resource `counter` and the counter itself. Then, we developed
    the `increment` feature. `increment`, logically, needs to lock the `pthread_mutex_lock(&info->lock);` resource,
    increment the counter (or any other action needed by the critical section), and
    unlock the `pthread_mutex_unlock(&info->lock);` resource to let the other threads
    do the same.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们创建了传递参数给线程所需的`struct`：`struct ThreadInfo`。在这个`struct`中，我们放置了保护资源`counter`所需的锁和计数器本身。然后，我们开发了`increment`功能。`increment`逻辑上需要锁定`pthread_mutex_lock(&info->lock);`资源，增加计数器（或者临界区域需要的其他操作），然后解锁`pthread_mutex_unlock(&info->lock);`资源，以便其他线程执行相同的操作。
- en: In the second step, we started developing the `main` method. The first thing
    we did is initialize the lock mutex with `pthread_mutex_init`. Here, we need to
    pass a pointer to the locally allocated resource.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们开始开发`main`方法。我们做的第一件事是使用`pthread_mutex_init`初始化锁互斥锁。在这里，我们需要传递指向本地分配资源的指针。
- en: In the third step, we created two threads, `th1` and `th2`. These are responsible
    for running the `increment` method concurrently. The two threads are created with
    the `pthread_create` POSIX API by passing the address of `thInfo` that was allocated
    in *step 2*. If the thread is created successfully, it starts the elaboration
    immediately.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们创建了两个线程`th1`和`th2`。它们负责同时运行`increment`方法。这两个线程是使用`pthread_create` POSIX
    API创建的，通过传递在*步骤2*中分配的`thInfo`的地址。如果线程成功创建，它将立即开始处理。
- en: 'In the fourth and last step, we waited for both `th1` and `th2` to finish printing
    the value of the counter to the standard output, which we expect to be `200000`.
    By compiling `g++ posixMutex.cpp -lpthread` and running the `./a.out` program,
    we get the following output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四步和最后一步中，我们等待`th1`和`th2`都完成将计数器的值打印到标准输出，我们期望的值是`200000`。通过编译`g++ posixMutex.cpp
    -lpthread`并运行`./a.out`程序，我们得到以下输出：
- en: '![](img/5918fefd-5ad2-4e38-80ca-a057d0b440b7.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5918fefd-5ad2-4e38-80ca-a057d0b440b7.png)'
- en: As we can see, the two threads never overlap the execution. Thus, the counter
    resource in the critical section is managed properly and the output is what we
    expected.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这两个线程从未重叠执行。因此，关键部分的计数器资源得到了正确管理，输出结果符合我们的预期。
- en: There's more...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we used `pthread_create` for the sake of completeness. The exact
    same goal could have been achieved by using `std::thread` and `std::async` from
    the C++ standard library.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，为了完整起见，我们使用了`pthread_create`。完全相同的目标可以通过使用C++标准库中的`std::thread`和`std::async`来实现。
- en: The `pthread_mutex_lock()` function locks the mutex. If the mutex is already
    locked, the calling thread will be blocked until the mutex becomes available.
    The `pthread_mutex_unlock` function unlocks the mutex if the current thread holds
    the lock on a mutex; otherwise, it results in undefined behavior.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`pthread_mutex_lock()`函数锁定互斥锁。如果互斥锁已经被锁定，调用线程将被阻塞，直到互斥锁变为可用。`pthread_mutex_unlock`函数如果当前线程持有互斥锁，则解锁互斥锁；否则，将导致未定义的行为。'
- en: See also
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You are invited to modify this program and use `pthread_mutex_lock` and `pthread_mutex_unlock`
    in conjunction with `std::thread` or `std::async` from the C++ standard library.
    See [Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml), *Revisiting C++*, to
    refresh yourself on this topic.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎您修改此程序，并使用`std::thread`或`std::async`与C++标准库中的`pthread_mutex_lock`和`pthread_mutex_unlock`结合使用。请参阅[第2章](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml)，*重温C++*，以便在这个主题上进行刷新。
- en: Using POSIX semaphores
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用POSIX信号量
- en: POSIX mutexes are clearly not the only mechanism you can use to synchronize
    access to a shared resource. This recipe will show you how to use another POSIX
    tool to achieve the same result. Semaphores are different from mutexes, and this
    recipe will teach you their basic usage, while the next will show you more advanced
    ones. A semaphore is a notification mechanism between threads and/or processes.
    As a rule of the thumb, try to use a mutex as a synchronization mechanism and
    semaphores as a notification mechanism. In this recipe, we'll develop a program
    that's similar to the one we built in the *Using POSIX mutexes* recipe, but this
    time, we'll protect the critical section with semaphores.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX互斥锁显然不是您可以用来同步访问共享资源的唯一机制。这个示例将向您展示如何使用另一个POSIX工具来实现相同的结果。信号量与互斥锁不同，这个示例将教会您它们的基本用法，而下一个示例将向您展示更高级的用法。信号量是线程和/或进程之间的通知机制。作为一个经验法则，尝试使用互斥锁作为同步机制，使用信号量作为通知机制。在这个示例中，我们将开发一个类似于我们在*使用POSIX互斥锁*示例中构建的程序，但这次，我们将使用信号量来保护关键部分。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll create a multi-threaded program to increment an integer
    until it reaches `200000`. Again, the code section that takes care of the increments
    must be protected and we''ll use POSIX semaphores. The `main` method will create
    the two threads and ensure that the resources are destroyed correctly. Let''s
    get started:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个多线程程序，以增加一个整数直到达到`200000`。同样，负责增量的代码部分必须受到保护，我们将使用POSIX信号量。`main`方法将创建两个线程，并确保正确销毁资源。让我们开始吧：
- en: 'Let''s open a new file called `posixSemaphore.cpp` and develop the structure
    and the critical section method:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开一个名为`posixSemaphore.cpp`的新文件，并开发结构和关键部分方法：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, in the `main` section, add the `init` method for the lock that''s needed
    for the synchronization between threads:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`main`部分，添加用于线程之间同步所需的锁的`init`方法：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that the `init` section is complete, let''s write the code that will start
    the two threads:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`init`部分已经完成，让我们编写将启动两个线程的代码：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, here''s the closing part:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这是结束部分：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The same program we used for POSIX mutexes now runs with POSIX semaphores. As
    you can see, the program's design doesn't change – what really changes is the
    APIs we used to protect the critical section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在使用POSIX信号量运行与POSIX互斥锁相同的程序。正如您所看到的，程序的设计并没有改变-真正改变的是我们用来保护关键部分的API。
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The first section contains the structure that''s used to communicate with the
    `increment` method and the definition of the method itself. The main difference,
    compared to the mutex version of the program, is that we now include the `#include
    <semaphore.h>` headers so that we can use the POSIX semaphores APIs. Then, in
    the structure, we use the `sem_t` type, which is the actual semaphore that is
    going to protect the critical section. The `increment` method has two barriers
    to protect the actual logic: `sem_wait(&info->sem);` and `sem_post(&info->sem);`.
    All these two methods do is atomically decrement and increment the `sem` counter,
    respectively. `sem_wait(&info->sem);` acquires the lock by decrementing the counter
    by `1`. If the value of the counter is greater than 0, then the lock is acquired
    and the thread can enter the critical region. `sem_post(&info->sem);` just increments
    the counter by one while exiting the critical region.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分包含用于与`increment`方法通信的结构以及方法本身的定义。与程序的互斥版本相比，主要区别在于我们现在包括了`#include <semaphore.h>`头文件，以便我们可以使用POSIX信号量API。然后，在结构中，我们使用`sem_t`类型，这是实际将保护临界区的信号量。`increment`方法有两个屏障来保护实际逻辑：`sem_wait(&info->sem);`和`sem_post(&info->sem);`。这两种方法都是原子地分别减少和增加`sem`计数器。`sem_wait(&info->sem);`通过将计数器减少`1`来获取锁。如果计数器的值大于0，则获取锁，并且线程可以进入临界区。`sem_post(&info->sem);`在退出临界区时只是将计数器增加1。
- en: 'In the second step, we initialize the semaphore by calling the `sem_init` API.
    Here, we passed three parameters:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们通过调用`sem_init` API来初始化信号量。在这里，我们传递了三个参数：
- en: The semaphore to initialize.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要初始化的信号量。
- en: The `pshared` argument. This indicates whether the semaphore is to be shared
    between the threads of a process or between processes. `0` indicates the first
    option.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pshared`参数。这表明信号量是在进程的线程之间共享还是在进程之间共享。`0`表示第一个选项。'
- en: The last parameter indicates the initial value of the semaphore. By passing
    `1` to `sem_init`, we are asking the semaphore to protect one resource. The semaphore,
    through `sem_wait` and `sem_post`, will internally increase and decrease that
    counter automatically, letting each thread enter the critical section one at a
    time.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数表示信号量的初始值。通过将`1`传递给`sem_init`，我们要求信号量保护一个资源。通过`sem_wait`和`sem_post`，信号量将在内部自动增加和减少该计数器，让每个线程一次进入临界区。
- en: In the third step, we created the two threads that use the `increment` method.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们创建了使用`increment`方法的两个线程。
- en: In the last step, we waited for the two threads to finish the elaboration with
    `pthread_join` and, most relevant in this section, we destroyed the semaphore
    structure with `sem_destroy` by passing the semaphore structure we've used so
    far.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，我们等待两个线程完成处理`pthread_join`，并且在本节中最重要的是，我们通过传递到目前为止使用的信号量结构来销毁信号量结构`sem_destroy`。
- en: 'Let''s compile and execute the program: `g++ posixSemaphore.cpp -lpthread`.
    Even in this case, we need to link the program with the `libpthread.a` by passing
    the `-lpthread` option to g++ as we use `pthreads`. The output of doing this is
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译并执行程序：`g++ posixSemaphore.cpp -lpthread`。即使在这种情况下，我们也需要通过将`-lpthread`选项传递给g++来将程序链接到`libpthread.a`，因为我们使用了`pthreads`。这样做的输出如下：
- en: '![](img/6b0aabdc-b066-4e25-b9fc-5300752d41a4.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b0aabdc-b066-4e25-b9fc-5300752d41a4.png)'
- en: As expected, the output shows the counter at `200000`. It also shows that the
    two threads are not overlapping.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，输出显示计数器为`200000`。它还显示两个线程没有重叠。
- en: There's more...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We used `sem_t` as a binary semaphore by passing the value `1` to the `sem_init`
    method. Semaphores can be used as *counting semaphores*, which means passing a
    value greater than 1 to the `init` method. In this case, it means that the critical
    section will be accessed concurrently by *N* threads.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向`sem_init`方法传递值`1`，将`sem_t`用作二进制信号量。信号量可以用作*计数信号量*，这意味着将一个大于1的值传递给`init`方法。在这种情况下，这意味着临界区将被*N*个线程同时访问。
- en: For more information on the GNU/Linux man pages, type `man sem_init` in a shell.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有关GNU/Linux man页面的更多信息，请在shell中键入`man sem_init`。
- en: See also
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can find out more about *counting semaphores* in the next recipe, where
    we'll learn about the difference between mutexes and semaphores.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在下一个配方中了解有关*计数信号量*的更多信息，那里我们将学习互斥锁和信号量之间的区别。
- en: You are invited to modify this program and use `pthread_mutex_lock` and `pthread_mutex_unlock` in
    conjunction with `std::thread` or `std::async` from the C++ standard library.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以修改此程序，并使用`pthread_mutex_lock`和`pthread_mutex_unlock`与C++标准库中的`std::thread`或`std::async`结合使用。
- en: POSIX semaphores advanced usage
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POSIX信号量高级用法
- en: The *Using POSIX semaphores *recipe showed us how to use POSIX semaphores to
    protect a critical region. In this recipe, you'll learn how to use it as a counting
    semaphore and notification mechanism. We'll do this by developing a classical
    publish-subscriber program where there is one publisher thread and one consumer
    thread. The challenge here is that we want to limit the maximum number of items
    in the queue to a defined value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用POSIX信号量*配方向我们展示了如何使用POSIX信号量来保护临界区。在这个配方中，您将学习如何将其用作计数信号量和通知机制。我们将通过开发一个经典的发布-订阅程序来实现这一点，其中有一个发布者线程和一个消费者线程。这里的挑战是我们希望将队列中的最大项目数限制为一个定义的值。'
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll write a program representing a typical use case for
    a counting semaphore – a producer-consumer problem in which we want to limit the
    number of items in the queue to a certain number. Let''s get started:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将编写一个代表计数信号量的典型用例的程序 - 一个生产者-消费者问题，我们希望将队列中的项目数限制为某个数字。让我们开始吧：
- en: 'Let''s open a new file called `producerConsumer.cpp` and code the structure
    we''ll need in the two threads:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开一个名为`producerConsumer.cpp`的新文件，并编写我们在两个线程中需要的结构：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s write the code for `producer`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为`producer`编写代码：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We do the same for `consumer`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对`consumer`做同样的操作：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we need to code the `main` method in order to initialize the resources
    (for example, semaphores):'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要编写`main`方法，以便初始化资源（例如信号量）：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we need to code the section that will release the resources:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要编写释放资源的部分：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This program, which is the typical implementation of a consumer-producer problem
    based on semaphores, shows how to limit the use of a resource to *N* (in our case, `MAX_ITEM_IN_QUEUE`).
    This concept can be applied to other problems, including how to limit the number
    of connections to a database, and so on. What would happen if, instead of one
    producer, we started two producer threads?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序是基于信号量的典型消费者-生产者问题的实现，演示了如何将对资源的使用限制为*N*（在我们的例子中为`MAX_ITEM_IN_QUEUE`）。这个概念可以应用于其他问题，包括如何限制对数据库的连接数等。如果我们不是启动一个生产者，而是启动两个生产者线程，会发生什么？
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the first step of the program, we defined `struct` that''s needed to let
    the two threads communicate. It contains the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的第一步中，我们定义了`struct`，这是让两个线程进行通信所需的。它包含以下内容：
- en: 'A `full` semaphore (counting semaphore): This semaphore is set to `MAX_ITEM_IN_QUEUE`.
    This limits the number of the item on the queue.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`full`信号量（计数信号量）：此信号量设置为`MAX_ITEM_IN_QUEUE`。这限制了队列中项目的数量。
- en: 'An `empty` semaphore (counting semaphore): This semaphore notifies the process
    when the queue is empty.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`empty`信号量（计数信号量）：此信号量在队列为空时通知进程。
- en: 'A `mutex` semaphore (binary semaphore): This is a mutex that''s implemented
    with semaphores and is needed to provide mutual exclusion on the queue''s access.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`mutex`信号量（二进制信号量）：这是一个使用信号量实现的互斥锁，用于提供对队列访问的互斥排他。
- en: 'Queue: Implemented with `std::vector`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列：使用`std::vector`实现。
- en: In the second step, we implemented the `producer` method. The core part of the
    method is the `for` loop implementation. The producer goal is to push items into
    the queue with no more than `MAX_ITEM_IN_QUEUE` items at the same time so that
    the producer tries to enter the critical region by decrementing the `full` semaphore
    (which we initialized to `MAX_ITEM_IN_QUEUE` in `sem_init`), then push the item
    into the queue and increment the empty semaphore (this gives the consumer permission
    to go on and read from the queue). Why do we need to notify that the consumer
    can read an item? In other words, why do we need to call `sem_post(&info->empty);` in
    the producer? If we didn't, the consumer thread would read items continuously
    and would keep incrementing the `full` semaphore to values greater than `MAX_ITEM_IN_QUEUE` with
    the effect of more than `MAX_ITEM_IN_QUEUE` item in the queue.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们实现了`producer`方法。该方法的核心部分是`for`循环的实现。生产者的目标是将项目推送到队列中，同时不超过`MAX_ITEM_IN_QUEUE`个项目，因此生产者尝试通过递减`full`信号量（我们在`sem_init`中初始化为`MAX_ITEM_IN_QUEUE`）进入临界区，然后将项目推送到队列并递增空信号量（这允许消费者继续从队列中读取）。我们为什么需要通知消费者可以读取项目？换句话说，为什么我们需要在生产者中调用`sem_post(&info->empty);`？如果我们不这样做，消费者线程将不断读取项目，并且会将`full`信号量增加到大于`MAX_ITEM_IN_QUEUE`的值，导致队列中的项目超过`MAX_ITEM_IN_QUEUE`。
- en: 'In the third step, we implemented the `consumer` method. This is specular to `producer`.
    What the consumer does is wait for the notification to read an item from the queue
    with `sem_wait(&info->empty);`, reads from the queue, and then increments the
    `full` semaphore. This last step can be read like so: I''ve just consumed one
    item from the queue.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，我们实现了`consumer`方法。这与`producer`相似。消费者所做的是等待通知以从队列中读取项目（使用`sem_wait(&info->empty);`），然后从队列中读取，并递增`full`信号量。这最后一步可以理解为：我刚刚从队列中消费了一个项目。
- en: The fourth step is where we started the two threads and initialized the three
    semaphores.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步是我们启动了两个线程并初始化了三个信号量。
- en: The fifth step is the closing section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第五步是结束部分。
- en: If we start more producers, the code would still work as the `full` and `empty`
    semaphores would ensure the behavior we described previously and the `mutex` on
    the queue ensures that just one item at a time writes/read on it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动更多的生产者，代码仍然可以工作，因为`full`和`empty`信号量将确保我们之前描述的行为，而队列上的`mutex`确保每次只有一个项目写入/读取。
- en: 'Both POSIX mutexes and semaphores can be used among threads and processes.
    To make a semaphore working among processes, we just need to pass a value different
    from 0 in the second parameter of `sem_init`. For mutexes, we need to pass the
    `PTHREAD_PROCESS_SHARED` flag when calling `pthread_mutexattr_setpshared`. By
    building and running the program we''d have output like the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX互斥锁和信号量都可以在线程和进程之间使用。要使信号量在进程之间工作，我们只需要在`sem_init`方法的第二个参数中传递一个不为0的值。对于互斥锁，我们需要在调用`pthread_mutexattr_setpshared`时传递`PTHREAD_PROCESS_SHARED`标志。通过构建和运行程序，我们将得到以下输出：
- en: '![](img/df663e70-e7d1-4142-85b6-54910957bcbb.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df663e70-e7d1-4142-85b6-54910957bcbb.png)'
- en: Let's see something more about this recipe in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们在下一节中了解更多关于这个示例。 '
- en: There's more...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It''s worth highlighting that a semaphore can be initialized (the third parameter
    of the `sem_init` method) to three possible values:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，信号量可以初始化为三种可能的值（`sem_init`方法的第三个参数）：
- en: 'To `1`: In this case, we''re using the semaphore as a mutex.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`1`：在这种情况下，我们将信号量用作互斥锁。
- en: 'To `N`: In this case, we''re using the semaphore as a *counting semaphore*.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`N`：在这种情况下，我们将信号量用作*计数信号量*。
- en: 'To `0`: We''re using the semaphore like a notification mechanism (see the `empty` semaphore
    example previously).'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`0`：我们将信号量用作通知机制（参见前面的`empty`信号量示例）。
- en: In general, semaphores must be seen as a notification mechanism between threads
    or processes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，信号量必须被视为线程或进程之间的通知机制。
- en: When should we use POSIX semaphores and POSIX mutexes? Try to use a mutex as
    a synchronization mechanism and semaphores as a notification mechanism. Furthermore,
    consider that POSIX mutexes are generally faster than POSIX semaphores in Linux
    kernels.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 何时应该使用POSIX信号量和POSIX互斥锁？尝试使用互斥锁作为同步机制，使用信号量作为通知机制。此外，要考虑到在Linux内核中，POSIX互斥锁通常比POSIX信号量更快。
- en: 'One last thing: remember that both POSIX mutexes and semaphores make the tasks
    go to sleep, as opposed to spinlocks, which don''t. Indeed, when a mutex or semaphore
    is locked, the Linux scheduler puts the task in the waiting queue.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事：请记住，POSIX互斥锁和信号量都会使任务进入休眠状态，而自旋锁则不会。实际上，当互斥锁或信号量被锁定时，Linux调度程序会将任务放入等待队列中。
- en: See also
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Please have look at the following list for further information:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下列表以获取更多信息：
- en: The *Using POSIX mutexes* recipe in this chapter to learn how to program POSIX
    mutexes
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用POSIX互斥锁*配方，以了解如何编写POSIX互斥锁
- en: The *Using POSIX semaphores* recipe in this chapter to learn how to program
    POSIX mutexes
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*使用POSIX信号量*配方，以了解如何编写POSIX互斥锁
- en: '*Linux Kernel Development*, by Robert Love'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux内核开发*，作者Robert Love'
- en: Synchronization building blocks
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步构建模块
- en: From this recipe and the next two, we'll be back in the C++ world. In this recipe,
    we'll learn about the C++ synchronization building blocks. Specifically, we'll
    look at using `std::lock_guard` and `std::unique_lock` in combination with **Resource
    Acquisition Is Initialization** (**RAII**), an object-oriented programming idiom
    that makes the code more robust and readable. `std::lock_guard` and `std::unique_lock` wrap the
    C++ concept of mutexes around two classes with the RAII concept. `std::lock_guard`
    is the simplest and smallest guard, while `std::unique_lock` adds some functionality
    on top of it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个配方和接下来的两个配方开始，我们将回到C++世界。在这个配方中，我们将学习关于C++同步构建模块。具体来说，我们将学习如何结合**资源获取即初始化**（**RAII**）的概念，使用`std::lock_guard`和`std::unique_lock`，这是一种使代码更健壮和可读的面向对象编程习惯。`std::lock_guard`和`std::unique_lock`将C++互斥锁的概念封装在两个具有RAII概念的类中。`std::lock_guard`是最简单和最小的保护，而`std::unique_lock`在其上添加了一些功能。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll develop two programs in order to learn how to use `std::unique_lock`
    and `std::lock_guard`. Let''s get started:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将开发两个程序，以便学习如何使用`std::unique_lock`和`std::lock_guard`。让我们开始吧：
- en: 'From a shell, create a new file called `lock_guard.cpp`. Then, write the code
    for the `ThreadInfo` structure and the `increment` (thread) method:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从shell中创建一个名为`lock_guard.cpp`的新文件。然后，编写`ThreadInfo`结构和`increment`（线程）方法的代码：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, write the code for the `main` method, as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按照以下方式编写`main`方法的代码：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s write the same program for `std::unique_lock`. From a shell, create
    a new file called `unique_lock.cpp` and write the code for the `ThreadInfo` structure
    and the `increment` (thread) method:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为`std::unique_lock`编写相同的程序。从shell中创建一个名为`unique_lock.cpp`的新文件，并编写`ThreadInfo`结构和`increment`（线程）方法的代码：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Regarding the `main` method, there are no differences here to what we saw in
    the *Using POSIX mutexes* recipe:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于`main`方法，在这里与我们在*使用POSIX互斥锁*配方中看到的没有区别：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These two programs are the C++ versions of the one we wrote in the *Using POSIX
    mutexes* recipe. Note the conciseness of the code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个程序是我们在*使用POSIX互斥锁*配方中编写的C++版本。请注意代码的简洁性。
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '*Step 1* of the `lock_guard.cpp` program defines the `ThreadInfo` struct and
    the `increment` method that''s needed. The first thing we can see is the use of `std::mutex`
    as a protection mechanism for the critical section. The `increment` method is
    now simplified with fewer headaches for the developer. Note that we have the `std::lock_guard<std::mutex> lock(info.mutex);`
    variable definition. As we can see in the method, there is no `unlock()` call
    at the end – why is this? Let''s see how `std::lock_guard` works: its constructor
    locks the mutex. Since `std::lock_guard` is a class, when the object goes out
    of scope (at the end of the method, in this case), the destructor is called. The
    unlock of the `std::mutex` object is called in the `std::lock_guard` destructor.
    This means that whatever happens to the `increment` method, the constructor is
    called so there''s no risk of a deadlock and the developer doesn''t have to take
    care of the `unlock()`. What we described here is the RAII C++ technique, which
    binds the life cycle of the `info.mutex` object with the lifetime of the `lock`
    variable.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock_guard.cpp`程序的*步骤1*定义了所需的`ThreadInfo`结构和`increment`方法。我们首先看到的是使用`std::mutex`作为关键部分的保护机制。现在，`increment`方法简化了，开发人员的头疼减少了。请注意，我们有`std::lock_guard<std::mutex>
    lock(info.mutex);`变量定义。正如我们在方法中看到的那样，在最后没有`unlock()`调用-为什么？让我们看看`std::lock_guard`的工作原理：它的构造函数锁定互斥锁。由于`std::lock_guard`是一个类，当对象超出范围时（在这种情况下是在方法的末尾），析构函数被调用。`std::lock_guard`析构函数中调用`std::mutex`对象的解锁。这意味着无论`increment`方法发生什么，构造函数都会被调用，因此不存在死锁的风险，开发人员不必关心`unlock()`。我们在这里描述的是RAII
    C++技术，它将`info.mutex`对象的生命周期与`lock`变量的生命周期绑定在一起。'
- en: '*Step 2* contains the main code that''s used to manage the two threads. In
    this case, C++ has a much cleaner and simpler interface. A thread is created with
    `std::thread t1 (increment, std::ref(thInfo));`. Here, `std::thread` accepts two
    parameters: the first is the method that the thread will call, while the second
    is the `ThreadInfo` that''s passed to the increment method.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤2*包含用于管理两个线程的主要代码。在这种情况下，C++具有更清晰和简单的接口。线程是用`std::thread t1 (increment,
    std::ref(thInfo));`创建的。在这里，`std::thread`接受两个参数：第一个是线程将调用的方法，而第二个是传递给增量方法的`ThreadInfo`。'
- en: The `unique_lock.cpp` program is the version of the `lock_guard` we've described
    so far. The main difference is that `std::unique_lock` gives the developer more
    freedom. In this case, we've modified the `increment` method to simulate the needs
    of the mutex unlock for the `if (info.counter < 0)` case. With the use of `std::unique_lock`,
    we are able to `unlock()` the mutex and return from the method. We wouldn't be
    able to do the same on the `std::lock_guard` class. Of course, the `lock_guard`
    would unlock at the end of the scope no matter what, but what we want to highlight
    here is that with `std::unique_lock`, the developer has the freedom to unlock
    the mutex manually, at any time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique_lock.cpp`程序是我们迄今为止描述的`lock_guard`的版本。主要区别在于`std::unique_lock`给开发者更多的自由。在这种情况下，我们修改了`increment`方法，以模拟互斥体对`if
    (info.counter < 0)`情况的解锁需求。使用`std::unique_lock`，我们能够在任何时候手动`unlock()`互斥体并从方法中返回。我们无法在`std::lock_guard`类上做同样的事情。当然，`lock_guard`无论如何都会在作用域结束时解锁，但我们想要强调的是，使用`std::unique_lock`，开发者有自由在任何时候手动解锁互斥体。'
- en: 'By compiling `lock_guard.cpp`: `g++ lock_guard.cpp -lpthread` and running the
    generated executable, we get the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编译`lock_guard.cpp`：`g++ lock_guard.cpp -lpthread`并运行生成的可执行文件，我们得到以下输出：
- en: '![](img/bd008ce4-2587-419a-b206-6f98ee10173c.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd008ce4-2587-419a-b206-6f98ee10173c.png)'
- en: 'The same happens for `unique_lock.cpp`: `g++ unique_lock.cpp -lpthread`, the
    output is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`unique_lock.cpp`也是一样：`g++ unique_lock.cpp -lpthread`，输出如下：
- en: '![](img/113fd27c-e7a5-4481-9a8f-49d066070a57.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/113fd27c-e7a5-4481-9a8f-49d066070a57.png)'
- en: As expected, both outputs are exactly the same, with the advantage that the
    code that uses `lock_guard` looks cleaner and definitely more safe from the developer's
    point of view.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，两个输出完全相同，使用`lock_guard`的代码更清晰，从开发者的角度来看，肯定更安全。
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As we''ve seen in this recipe, `std::lock_guard` and `std::unique_lock` are
    template classes that we used with the `std::mutex` `object.lock_guard`. `unique_lock`
    can be defined with other mutex objects, such as **`std::timed_mutex`**, which
    allows us to get a lock for a specific amount of time:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这个食谱中看到的，`std::lock_guard`和`std::unique_lock`是我们与`std::mutex`一起使用的模板类。`unique_lock`可以与其他互斥体对象一起定义，例如**`std::timed_mutex`**，它允许我们在特定时间内获取锁：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `lock` object will try to acquire the lock for `5` milliseconds. We have
    to be careful when adding `std::defer_lock`, which will not lock the mutex automatically
    on construction. This will only happen when `try_lock_for` succeeds.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`lock`对象将尝试在`5`毫秒内获取锁。当添加`std::defer_lock`时，我们必须小心，它不会在构造时自动锁定互斥体。这只会在`try_lock_for`成功时发生。'
- en: See also
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here is a list of references you may refer to:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是您可以参考的参考资料列表：
- en: '*Linux Kernel Development*, by Robert Love'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux内核开发*，作者Robert Love'
- en: The *Using POSIX mutexes* recipe in this chapter
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*使用POSIX互斥体*食谱
- en: The *Using POSIX semaphores* recipe in this chapter
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的*使用POSIX信号量*食谱
- en: '[Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml), *Revisiting C++*,
    for a refresher on C++'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第2章](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml)，*重温C++*，进行C++的复习'
- en: Learning inter-thread communication with simple events
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用简单事件学习线程间通信
- en: So far, we know how to use both POSIX and C++ standard library mechanisms to
    synchronize a critical section. There are use cases where we don't need to explicitly
    use locks; instead, we can use more simple communication mechanisms. `std::promise`
    and `std::future` can be used to allow two threads to communicate without the
    hassle of the synchronization.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道如何使用POSIX和C++标准库机制来同步关键部分。有一些用例不需要显式使用锁；相反，我们可以使用更简单的通信机制。`std::promise`和`std::future`可用于允许两个线程进行通信，而无需同步的麻烦。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will write a program that splits a problem into two parts:
    thread 1 will run a highly intensive computation and will send the result to thread
    2, which is the consumer of the results. We''ll do this by using `std::promise`
    and `std::future`. Let''s get started:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将编写一个程序，将问题分成两部分：线程1将运行一个高强度的计算，并将结果发送给线程2，线程2是结果的消费者。我们将使用`std::promise`和`std::future`来实现这一点。让我们开始吧：
- en: 'Open a new file called `promiseFuture.cpp` and type the following code into
    it:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个名为`promiseFuture.cpp`的新文件，并将以下代码输入其中：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Write the `main` method:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`main`方法：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The consumer is responsible for getting the result through `std::future` and
    using it:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消费者负责通过`std::future`获取结果并使用它：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The producer performs an elaboration to get the item and sends it to the waiting
    consumer:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生产者执行处理以获取项目并将其发送给等待的消费者：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This program shows the typical use case for `std::promise` and `std::future`,
    where a mutex or semaphore is not needed for a one-shot form of communication.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序展示了`std::promise`和`std::future`的典型用例，其中不需要互斥体或信号量进行一次性通信。
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1*, we defined the `struct Item` to use between the producer and the
    consumer and declared the two method's prototypes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们定义了`struct Item`以在生产者和消费者之间使用，并声明了两个方法的原型。
- en: In *step 2*, we defined two tasks using `std::async` by passing the defined
    promise and future.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们使用`std::async`定义了两个任务，通过传递定义的promise和future。
- en: In *step 3*, the `asyncConsumer` method waits for the result of the elaboration
    with the `fut.get()` method, which is a blocking call.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，`asyncConsumer`方法使用`fut.get()`方法等待处理结果，这是一个阻塞调用。
- en: In *step 4*, we implemented the `asyncProducer` method. This method is simple –
    it just returns a canned answer. In a real scenario, the producer performs a highly
    intensive elaboration.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，我们实现了`asyncProducer`方法。这个方法很简单，只是返回一个预定义的答案。在实际情况下，生产者执行高强度的处理。
- en: This simple program showed us how to simply decouple a problem from the producer
    of the information (promise) and the consumer of the information without taking
    care of the synchronization between threads. This solution of using `std::promise`
    and `std::future` only works for a one-shot type of communication (that is, we
    cannot have loops in the two threads sending and getting items).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的程序向我们展示了如何简单地将问题从信息的生产者（promise）和信息的消费者中解耦，而不必关心线程之间的同步。这种使用`std::promise`和`std::future`的解决方案只适用于一次性通信（也就是说，我们不能在两个线程中发送和获取项目时进行循环）。
- en: There's more...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`std::promise` and `std::future` are just concurrency tools offered by the
    C++ standard library. The C++ standard library also provides `std::shared_future`
    in addition to `std::future`. In this recipe, we had one information producer
    and one information consumer, but what if we have more consumers? `std::shared_future` allows
    multiple threads to wait for the same information (coming from `std::promise`).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::promise`和`std::future`只是C++标准库提供的并发工具。除了`std::future`之外，C++标准库还提供了`std::shared_future`。在这个配方中，我们有一个信息生产者和一个信息消费者，但如果有更多的消费者呢？`std::shared_future`允许多个线程等待相同的信息（来自`std::promise`）。'
- en: See also
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming Language* by Bjarne
    Stroustrup cover these topics in great detail.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Scott Meyers的书*Effective Modern C++*和Bjarne Stroustrup的书*The C++ Programming
    Language*详细介绍了这些主题。
- en: 'You''re also invited to read more about concurrency through the C++ Core Guideline
    in the *CP: Concurrency and parallelism* ([https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#cp-concurrency-and-parallelism](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#cp-concurrency-and-parallelism)) section.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过C++核心指南中的*CP:并发和并行*（[https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#cp-concurrency-and-parallelism](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#cp-concurrency-and-parallelism)）部分了解更多关于并发的内容。
- en: Learning inter-thread communication with condition variables
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习使用条件变量进行线程间通信
- en: In this recipe, you'll learn about another C++ tool that's available in the
    standard library that allows multiple threads to communicate. We'll be using `std::condition_variable`
    and `std::mutex` to develop a producer-consumer program.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，您将了解到标准库中提供的另一个C++工具，它允许多个线程进行通信。我们将使用`std::condition_variable`和`std::mutex`来开发一个生产者-消费者程序。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The program in this recipe will use `std::mutex` to protect the queue from
    concurrent access and `std::condition_variable` to notify the consumer that an
    item has been pushed to the queue. Let''s get started:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中的程序将使用`std::mutex`来保护队列免受并发访问，并使用`std::condition_variable`来通知消费者队列中已经推送了一个项目。让我们开始吧：
- en: 'Open a new file called `conditionVariable.cpp` and type the following code
    into it:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个名为`conditionVariable.cpp`的新文件，并将以下代码输入其中：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s write the `main` method, which creates the threads for the consumer
    and the producer:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写`main`方法，为消费者和生产者创建线程：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s define the `consumer` method:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义`consumer`方法：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, let''s define the `producer` method:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们定义`producer`方法：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Although the program we've developed solves the typical producer-consumer problem
    we saw in the previous recipe, the code is more idiomatic, easy to read, and less
    error-prone.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们开发的程序解决了我们在上一个配方中看到的典型的生产者-消费者问题，但代码更符合惯用法，易于阅读，且更少出错。
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first step, we defined `struct Item` that we need to pass from the producer
    to the consumer. The interesting point in this step is the definition of the `std::queue`
    variable; it uses a mutex that synchronizes access to the queue and `std::condition_variable`
    to communicate an event to the consumer from the producer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们定义了需要从生产者传递给消费者的`struct Item`。这一步中有趣的一点是`std::queue`变量的定义；它使用一个互斥量来同步对队列的访问，并使用`std::condition_variable`来从生产者向消费者通信一个事件。
- en: In the second step, we defined the producer and consumer threads and called
    the `join()` method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，我们定义了生产者和消费者线程，并调用了`join()`方法。
- en: 'In the third step, the consumer method does essentially four things: acquires
    the lock to read the item from the queue, waits for a notification from the producer
    with the condition variable, `cond`, pops an item from the queue, and then releases
    the lock. Interestingly, the condition variable uses `std::unique_lock` and not
    `std::lock_guard` for one simple reason: as soon as the `wait()` method on the
    condition variable is called, the lock is (internally) released so that the producer
    isn''t blocked. When the producer calls the `notify_one` method, the `cond` variable
    on the consumer gets woken up and locks the mutex again. This allows it to safely
    pop an item from the queue and release the lock again at the end with `lck.unlock()`.
    Immediately after `cond.wait()` (the commented out code), there is an alternative
    way of calling `wait()` by passing a second parameter, a predicate, which will
    wait further if the second parameter returns false. In our case, the consumer will
    not wait if the queue isn''t empty.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三步中，消费者方法基本上做了四件事：获取锁以从队列中读取项目，等待生产者通过条件变量`cond`发出通知，从队列中弹出一个项目，然后释放锁。有趣的是，条件变量使用`std::unique_lock`而不是`std::lock_guard`，原因很简单：一旦在条件变量上调用`wait()`方法，锁就会（在内部）被释放，以便生产者不被阻塞。当生产者调用`notify_one`方法时，消费者上的`cond`变量会被唤醒并再次锁定互斥量。这使得它可以安全地从队列中弹出一个项目，并在最后再次释放锁`lck.unlock()`。在`cond.wait()`之后（注释掉的代码），还有一种通过传递第二个参数，谓词来调用`wait()`的替代方法，如果第二个参数返回false，它将继续等待。在我们的情况下，如果队列不为空，消费者将不会等待。
- en: 'The last step is quite simple: we create an item, lock it with `lock_guard`
    on a mutex, and push it onto the queue. Note that by using `std::lock_guard`,
    we don''t need to call unlock; the destructor of the `lock` variable will take
    care of that. The last thing we need to do before ending the current loop is notify
    the consumer with the `notify_one` method.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步非常简单：我们创建一个项目，用互斥锁`lock_guard`锁定它，并将其推送到队列中。请注意，通过使用`std::lock_guard`，我们不需要调用unlock；`lock`变量的析构函数会处理这个问题。在结束当前循环之前，我们需要做的最后一件事是用`notify_one`方法通知消费者。
- en: 'The `g++ conditionVariable.cpp -lpthread` compilation and the execution of
    the `./a.out` program will produce the following output:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`g++ conditionVariable.cpp -lpthread`的编译和`./a.out`程序的执行将产生以下输出：'
- en: '![](img/726a088f-c4c0-4c67-8d11-ddca1550ff4b.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/726a088f-c4c0-4c67-8d11-ddca1550ff4b.png)'
- en: Note that since the producer is way faster than the consumer due to the `condition_variable`,
    which is asynchronous, there is a latency to pay. As you may have noticed, the
    producer and the consumer run infinitely, so you have to stop the process manually
    (*Ctrl* + *C*).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于`condition_variable`是异步的，生产者比消费者快得多，因此需要支付一定的延迟。正如您可能已经注意到的，生产者和消费者会无限运行，因此您必须手动停止进程（*Ctrl*
    + *C*）。
- en: There's more...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we used the `notify_one` method on the `condition_variable`
    in the producer. An alternative method is to use `notify_all`, which notifies
    all the waiting threads.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们在生产者中使用了`condition_variable`的`notify_one`方法。另一种方法是使用`notify_all`，它会通知所有等待的线程。
- en: Another important aspect to highlight is that condition variables are best used
    when the producer wants to notify one of the waiting thread about an event occurred
    in the computation so that the consumer can take action. For example, let's say
    that the producer notifies the consumer that a special item has been pushed or
    that the producer notifies a queue manager that the queue is full so that another
    consumer has to be spawned.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要强调的重要方面是，当生产者希望通知等待的线程之一发生在计算中的事件，以便消费者可以采取行动时，最好使用条件变量。例如，假设生产者通知消费者已经推送了一个特殊项目，或者生产者通知队列管理器队列已满，因此必须生成另一个消费者。
- en: See also
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a new thread* recipe in [Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml), *Revisiting
    C++*, to find out more or refresh yourself on threading in C++.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml)的*创建新线程*一节，*重温C++*，以了解更多信息或刷新自己关于C++中的线程。
- en: '*C++ Programming Language*, by Bjarne Stroustrup, covers these topics in great
    detail.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《C++编程语言》，作者Bjarne Stroustrup，详细介绍了这些主题。
