- en: Actors and Pawns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员和兵
- en: 'Now, we will really delve into UE4 code. At first, it is going to look daunting.
    The UE4 class framework is massive, but don''t worry: the framework is massive
    so your code doesn''t have to be. You will find that you can get a lot done and
    a lot onto the screen using a lot less code. This is because the UE4 engine code
    is so extensive and well-programmed that they have made it possible to accomplish
    almost any game-related task easily. Just call the right functions and voila,
    what you want to see will appear on the screen. The entire notion of a framework
    is that it is designed to let you get the gameplay you want, without having to
    spend a lot of time sweating out the details.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将真正深入UE4代码。起初，它看起来会让人望而生畏。UE4类框架非常庞大，但不用担心：框架很大，所以你的代码不必如此。你会发现，你可以用更少的代码完成更多的工作并将更多内容显示在屏幕上。这是因为UE4引擎代码如此广泛和精心编写，以至于他们使得几乎任何与游戏相关的任务都变得容易。只需调用正确的函数，你想要看到的东西就会出现在屏幕上。整个框架的概念是设计让你获得想要的游戏体验，而不必花费大量时间来处理细节。
- en: 'The learning outcomes from this chapters are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的学习成果如下：
- en: Actors versus pawns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员与兵
- en: Creating a world to put your actors in
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个放置演员的世界
- en: The UE4 editor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UE4编辑器
- en: Starting from scratch
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始
- en: Adding an actor to the scene
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向场景添加一个演员
- en: Creating a player entity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个玩家实体
- en: Writing C++ code that controls the game's character
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写控制游戏角色的C++代码
- en: Creating non-player character entities
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建非玩家角色实体
- en: Displaying a quote from each NPC dialog box
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示每个NPC对话框中的引用
- en: Actors versus pawns
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员与兵
- en: In this chapter, we will discuss actors and pawns. Although it sounds as if
    pawns will be a more basic class than actors, it is actually the other way around.
    A UE4 actor (the `Actor` class) object is the basic type of the things that can
    be placed in the UE4 game world. In order to place anything in the UE4 world,
    you must derive from the `Actor` class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论演员和兵。虽然听起来兵会比演员更基本，但实际情况恰恰相反。UE4演员（`Actor`类）对象是可以放置在UE4游戏世界中的基本类型。为了在UE4世界中放置任何东西，你必须从`Actor`类派生。
- en: A `Pawn` is an object that represents something that you or the computer's **Artificial
    Intelligence** (**AI**) can control on the screen. The `Pawn` class derives from
    the `Actor` class, with the additional ability to be controlled by the player
    directly or by an AI script. When a pawn or actor is controlled by a controller
    or AI, it is said to be possessed by that controller or AI.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 兵是一个代表你或计算机的**人工智能**（**AI**）可以在屏幕上控制的对象。`Pawn`类派生自`Actor`类，具有直接由玩家或AI脚本控制的额外能力。当一个兵或演员被控制器或AI控制时，就说它被该控制器或AI所控制。
- en: Think of the `Actor` class as a character in a play (although it could also
    be a prop in a play). Your game world is going to be composed of a bunch of *actors*,
    all acting together to make the gameplay work. The game characters, **Non-Player
    Characters** (**NPC**s), and even treasure chests will be actors.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 把`Actor`类想象成一个戏剧中的角色（尽管它也可以是戏剧中的道具）。你的游戏世界将由一堆*演员*组成，它们一起行动以使游戏运行。游戏角色、**非玩家角色**（**NPC**）甚至宝箱都将是演员。
- en: Creating a world to put your actors in
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个放置演员的世界
- en: 'Here, we will start from scratch and create a basic level into which we can
    put our game characters. The UE4 team has already done a great job of presenting
    how the world editor can be used to create a world in UE4\. I want you to take
    a moment to create your own world by performing the following steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从头开始创建一个基本的关卡，然后把我们的游戏角色放进去。UE4团队已经很好地展示了世界编辑器如何用于创建UE4中的世界。我希望你花点时间按照以下步骤创建自己的世界：
- en: 'Create a new, blank UE4 project to get started. To do this, in the Unreal Launcher,
    click on the Launch button beside your most recent engine installation, as shown
    in the following screenshot:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空白UE4项目以开始。要做到这一点，在虚幻启动器中，点击最近的引擎安装旁边的启动按钮，如下截图所示：
- en: '![](img/3d0f9dc1-a80e-4e54-9c15-0c8881dad25a.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d0f9dc1-a80e-4e54-9c15-0c8881dad25a.png)'
- en: That will launch the Unreal Editor. The Unreal Editor is used to visually edit
    your game world. You're going to spend a lot of time in the Unreal Editor, so
    please take some time to experiment and play around with it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动虚幻编辑器。虚幻编辑器用于可视化编辑你的游戏世界。你将花费大量时间在虚幻编辑器中，所以请花些时间进行实验和尝试。
- en: I will only cover the basics of how to work with the UE4 editor. You will need
    to let your creative juices flow, however, and invest some time in order to become
    familiar with the editor.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我只会介绍如何使用UE4编辑器的基础知识。然而，你需要让你的创造力流淌，并投入一些时间来熟悉编辑器。
- en: 'To learn more about the UE4 editor, take a look at the *Getting Started: Introduction
    to the UE4 Editor* playlist, which is available at [https://www.youtube.com/playlist?list=PLZlv_N0_O1gasd4IcOe9Cx9wHoBB7rxFl](https://www.youtube.com/playlist?list=PLZlv_N0_O1gasd4IcOe9Cx9wHoBB7rxFl).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于UE4编辑器的信息，请查看*入门：UE4编辑器简介*播放列表，网址为[https://www.youtube.com/playlist?list=PLZlv_N0_O1gasd4IcOe9Cx9wHoBB7rxFl](https://www.youtube.com/playlist?list=PLZlv_N0_O1gasd4IcOe9Cx9wHoBB7rxFl)。
- en: 'You will be presented with the Projects dialog. The following screenshot shows
    the steps to be performed with numbers corresponding to the order in which they
    need to be performed:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到项目对话框。以下截图显示了需要执行的步骤，数字对应着需要执行的顺序：
- en: '![](img/a610e410-863d-4628-888b-504b78722746.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a610e410-863d-4628-888b-504b78722746.png)'
- en: 'Perform the following steps to create a project:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下步骤创建一个项目：
- en: Select the New Project tab at the top of the screen.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕顶部选择新项目标签。
- en: Click on the C++ tab (the second sub-tab).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击C++标签（第二个子标签）。
- en: Select Basic Code from the available projects listing.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用项目列表中选择基本代码。
- en: Set the directory where your project is located (mine is Y:Unreal Projects).
    Choose a hard disk location with a lot of space (the final project will be around
    1.5 GB).
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置项目所在的目录（我的是Y:Unreal Projects）。选择一个有很多空间的硬盘位置（最终项目大小约为1.5GB）。
- en: Name your project. I called mine GoldenEgg.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名您的项目。我把我的称为GoldenEgg。
- en: Click on Create Project to finalize project creation.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“创建项目”以完成项目创建。
- en: Once you've done this, the UE4 launcher will launch Visual Studio (or Xcode).
    This could take a while, and the progress bar could wind up behind other windows.
    There will only be a couple of source files available, but we're not going to
    touch those now.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，UE4启动器将启动Visual Studio（或Xcode）。这可能需要一段时间，进度条可能会出现在其他窗口后面。只有几个源文件可用，但我们现在不会去碰它们。
- en: 'Make sure that Development Editor is selected from the Configuration Manager
    dropdown at the top of the screen, as shown in the following screenshot:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保从屏幕顶部的配置管理器下拉菜单中选择“开发编辑器”，如下截图所示：
- en: '![](img/6107dc53-907d-420b-bfdb-9b37e848dcdf.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6107dc53-907d-420b-bfdb-9b37e848dcdf.png)'
- en: 'The Unreal Editor will also have been launched, as shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，虚幻编辑器也已启动：
- en: '![](img/0c5ccf1d-cd4b-4fb6-8595-b3376e98bdab.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c5ccf1d-cd4b-4fb6-8595-b3376e98bdab.png)'
- en: The UE4 editor
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UE4编辑器
- en: We will explore the UE4 editor here. We'll start with the controls since it
    is important to know how to navigate in Unreal.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里探索UE4编辑器。我们将从控件开始，因为了解如何在虚幻中导航很重要。
- en: Editor controls
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑器控件
- en: 'If you''ve never used a 3D editor before, the controls can be quite hard to
    learn. These are the basic navigation controls while in edit mode:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前从未使用过3D编辑器，那么在编辑模式下，控件可能会很难学习。这些是在编辑模式下的基本导航控件：
- en: Use the arrow keys to move around in the scene
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用箭头键在场景中移动
- en: Press *Page Up* or *Page Down* to go up and down vertically
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按*Page Up*或*Page Down*垂直上下移动
- en: Left mouse click + drag it left or right to change the direction you are facing
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左键单击+向左或向右拖动以更改您所面对的方向
- en: Left mouse click + drag it up or down to *dolly* (move the camera forward and
    backward, same as pressing up/down arrow keys)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左键单击+向上或向下拖动以*移动*（将相机向前或向后移动，与按上/下箭头键相同）
- en: Right mouse click + drag to change the direction you are facing
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右键单击+拖动以更改您所面对的方向
- en: Middle mouse click + drag to pan the view
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中键单击+拖动以平移视图
- en: Right mouse click and the *W*, *A*, *S*, and *D* keys to move around the scene
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右键单击和*W*、*A*、*S*和*D*键用于在场景中移动
- en: Play mode controls
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放模式控制
- en: 'Click on the Play button in the bar at the top, as shown in the following screenshot.
    This will launch play mode:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 单击顶部工具栏中的播放按钮，如下截图所示。这将启动播放模式：
- en: '![](img/9110d2aa-8a04-46d7-b1b4-f6520d6fdf75.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9110d2aa-8a04-46d7-b1b4-f6520d6fdf75.png)'
- en: 'Once you click on the Play button, the controls change. In play mode, the controls
    are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“播放”按钮后，控件会改变。在播放模式下，控件如下：
- en: The *W*, *A*, *S*, and *D* keys for movement
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*W*、*A*、*S*和*D*键用于移动'
- en: The left or right arrow keys to look toward the left or right, respectively
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用左右箭头键分别向左或向右查看
- en: The mouse's motion to change the direction in which you look
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标的移动以改变您所看的方向
- en: The *Esc* key to exit play mode and return to edit mode
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按*Esc*键退出播放模式并返回编辑模式
- en: At this point, I suggest you try to add a bunch of shapes and objects to the
    scene and try to color them with different *materials*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我建议您尝试向场景中添加一堆形状和对象，并尝试用不同的*材料*着色它们。
- en: Adding objects to the scene
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向场景添加对象
- en: 'Adding objects to the scene is as easy as dragging and dropping them in from
    the Content Browser tab, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 向场景添加对象就像从内容浏览器选项卡中拖放它们一样简单，如下所示：
- en: 'The Content Browser tab appears, by default, docked at the bottom of the window.
    If it isn''t seen, simply select Window and navigate to Content Browser in order
    to make it appear:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内容浏览器选项卡默认情况下停靠在窗口底部。如果看不到它，只需选择“窗口”，然后导航到“内容浏览器”即可使其出现：
- en: '![](img/807f76e7-3dcc-47e5-8257-83ad5a5ef5e2.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/807f76e7-3dcc-47e5-8257-83ad5a5ef5e2.png)'
- en: Make sure that the Content Browser is visible in order to add objects to your
    level
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 确保内容浏览器可见，以便向您的级别添加对象
- en: Double-click on the `StarterContent` folder to open it.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击“StarterContent”文件夹以打开它。
- en: Double-click the `Props` folder to find objects you can drag into your scene.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击“道具”文件夹以查找可以拖放到场景中的对象。
- en: 'Drag and drop things from the Content Browser into your game world:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从内容浏览器中拖放物品到游戏世界中：
- en: '![](img/836a4d4e-0f9a-4ba5-99cf-4934c60f92ed.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/836a4d4e-0f9a-4ba5-99cf-4934c60f92ed.png)'
- en: 'To resize an object, press *R* on your keyboard (hit *W* to move it again,
    or *E* to rotate the object). The manipulators around the object will appear as
    boxes, which denotes resize mode:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要调整对象的大小，请在键盘上按*R*（再次按*W*移动它，或按*E*旋转对象）。对象周围的操作器将显示为方框，表示调整大小模式：
- en: '![](img/a2034959-5072-4e20-ba52-d6b7d91e2461.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2034959-5072-4e20-ba52-d6b7d91e2461.png)'
- en: 'To change the material that is used to paint the object, simply drag and drop
    a new material from the Content Browser window inside the Materials folder:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更改用于绘制对象的材料，只需从内容浏览器窗口中的材料文件夹内拖放新材料即可：
- en: '![](img/7eb693d2-dcc1-4c9c-a3ba-6236a1ae129f.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb693d2-dcc1-4c9c-a3ba-6236a1ae129f.png)'
- en: Materials are like paints. You can coat an object with any material you want
    by simply dragging and dropping the material you desire onto the object you desire
    it to be painted on. Materials are only skin deep; they don't change the other
    properties of an object (such as weight).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 材料就像油漆。您可以通过简单地将所需的材料拖放到要涂抹的对象上，为对象涂上任何您想要的材料。材料只是表面深度；它们不会改变对象的其他属性（如重量）。
- en: Starting a new level
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始一个新级别
- en: 'If you want to start creating a level from scratch, perform the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要从头开始创建级别，请执行以下步骤：
- en: 'Click on File and navigate to New Level..., as shown here:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“文件”，导航到“新建级别...”，如下所示：
- en: '![](img/13852d6b-750d-4e72-a365-ac1071e21140.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/13852d6b-750d-4e72-a365-ac1071e21140.png)'
- en: 'You can then select between Default, VR-Basic, and Empty Level. I think selecting
    Empty Level is a good idea:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后可以在默认、VR-Basic和空级别之间进行选择。我认为选择空级别是个好主意：
- en: '![](img/b38499e3-8b1e-46f2-a2d1-92f421a87646.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b38499e3-8b1e-46f2-a2d1-92f421a87646.png)'
- en: The new level will be completely black to start with. Try dragging and dropping
    some objects from the Content Browser tab again.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的级别一开始会完全黑暗。尝试再次从内容浏览器选项卡中拖放一些对象。
- en: This time, I added a resized shapes/shape_plane for the ground plane (don't
    use the regular plane under modes or you'll fall through it once you add the player)
    and textured it with T_ground_Moss_D, a couple of Props / SM_Rocks, and Particles
    / P_Fire.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我为地面添加了一个调整大小的形状/shape_plane（不要使用模式下的常规平面，一旦添加了玩家，你会穿过它），并用T_ground_Moss_D进行了纹理处理，还有一些道具/SM_Rocks和粒子/P_Fire。
- en: 'Be sure to save your map. Here''s a snapshot of my map (how does yours look?):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要保存你的地图。这是我的地图快照（你的是什么样子？）：
- en: '![](img/f1d1b823-1c5e-422e-9501-3c2afa46821f.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1d1b823-1c5e-422e-9501-3c2afa46821f.png)'
- en: 'If you want to change the default level that opens when you launch the editor,
    go to Edit | Project Settings | Maps & Modes; then, you will see a Game Default
    Map and Editor Startup Map setting, as shown in the following screenshot:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要更改编辑器启动时打开的默认级别，转到编辑 | 项目设置 | 地图和模式；然后，你会看到一个游戏默认地图和编辑器启动地图设置，如下面的截图所示：
- en: '![](img/f5069206-46dc-4fd0-af8c-7e63d548efa0.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5069206-46dc-4fd0-af8c-7e63d548efa0.png)'
- en: Just make sure you save the current scene first!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要确保你先保存当前场景！
- en: Adding light sources
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加光源
- en: Note that your scene may appear completely (or mostly) black when you try to
    run it. This is because you haven't put a light source in it yet!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当你尝试运行时，你的场景可能会完全（或大部分）黑暗。这是因为你还没有在其中放置光源！
- en: 'In the previous scene, the P_Fire particle emitter acts as a light source,
    but it only emits a small amount of light. To make sure that everything appears
    well lit in your scene, you should add a light source, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的场景中，P_Fire粒子发射器充当光源，但它只发出少量光线。为了确保你的场景中的一切都看起来被照亮，你应该添加一个光源，如下所示：
- en: 'Go to Window and then click on Modes to ensure that the light sources panel
    is shown:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到窗口，然后点击模式，确保灯光面板显示出来：
- en: '![](img/536b5a94-2f3d-4d35-b2b3-4c7399e8ad5e.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/536b5a94-2f3d-4d35-b2b3-4c7399e8ad5e.png)'
- en: 'From the Modes panel, drag one of the Lights objects into the scene:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从模式面板中，将一个灯光对象拖入场景中：
- en: '![](img/9e64a618-4720-4acc-a369-83b053f2b03c.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e64a618-4720-4acc-a369-83b053f2b03c.png)'
- en: Select the Lightbulb and box icon (it looks like a mushroom, but it isn't).
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择灯泡和盒子图标（看起来像蘑菇，但实际上不是）。
- en: Click on Lights in the left-hand panel.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧面板中的灯光。
- en: Select the type of light you want and just pull it into your scene.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要的灯光类型，然后将其拖入你的场景中。
- en: If you don't have a light source, your scene will appear completely black when
    you try to run it (or if there are just no objects in the scene).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有光源，当你尝试运行时（或者场景中没有物体时），你的场景将完全黑暗。
- en: Collision volumes
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞体积
- en: You might have noticed that, so far, the camera just passes through at least
    some of the scene geometry, even in play mode. That's not good. Let's make it
    so that the player can't just walk through the rocks in our scene.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经注意到，相机在播放模式下至少穿过了一些场景几何体。这不好。让我们让玩家不能只是在我们的场景中走过岩石。
- en: There are a few different types of collision volumes. Generally, perfect mesh-mesh
    collisions are way too expensive to do at runtime. Instead, we use an approximation
    (a bounding volume) to guess the collision volume.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同类型的碰撞体积。通常，完美的网格-网格碰撞在运行时成本太高。相反，我们使用一个近似值（边界体积）来猜测碰撞体积。
- en: A mesh is the actual geometry of an object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 网格是对象的实际几何形状。
- en: Adding collision volumes
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加碰撞体积
- en: The first thing we have to do is associate a collision volume with each of the
    rocks in the scene.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是将碰撞体积与场景中的每个岩石关联起来。
- en: 'We can do this from the UE4 editor as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从UE4编辑器中这样做：
- en: Click on an object in the scene for which you want to add a collision volume.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击场景中要添加碰撞体积的对象。
- en: 'Right-click on this object in the World Outliner tab (the default appears on
    the right-hand side of the screen) and select edit, as shown in the following
    screenshot:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在世界大纲选项卡中右键单击此对象（默认显示在屏幕右侧），然后选择编辑，如下面的截图所示：
- en: '![](img/cfd4d03d-80a9-4853-9685-7727f7d73ab6.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfd4d03d-80a9-4853-9685-7727f7d73ab6.png)'
- en: You will find yourself in the mesh editor.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现自己在网格编辑器中。
- en: 'Go to the Collision menu and then click on Add Capsule Simplified Collision:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到碰撞菜单，然后点击添加简化碰撞胶囊：
- en: '![](img/934c27c4-7f97-421e-8b25-4cbdb7f064d6.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/934c27c4-7f97-421e-8b25-4cbdb7f064d6.png)'
- en: 'The collision volume, when added successfully, will appear as a bunch of lines
    surrounding the object, as shown in the following screenshot:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功添加碰撞体积后，碰撞体积将显示为一堆围绕对象的线，如下面的截图所示：
- en: '![](img/ddf3cd4b-6b70-4b18-8664-c32c781dae5b.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ddf3cd4b-6b70-4b18-8664-c32c781dae5b.png)'
- en: The default collision capsule (left) and manually resized versions (right)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 默认碰撞胶囊（左）和手动调整大小的版本（右）
- en: You can resize (R), rotate (E), move (W), and change the collision volume as
    you wish, the same way you would manipulate an object in the UE4 editor.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以调整（R）大小，旋转（E），移动（W），并根据需要更改碰撞体积，就像你在UE4编辑器中操作对象一样。
- en: When you're done adding collision meshes, save and go back to the main editor
    window and click on Play; you will notice that you can no longer pass through
    your collidable objects.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你添加完碰撞网格后，保存并返回到主编辑器窗口，然后点击播放；你会注意到你再也不能穿过你的可碰撞对象了。
- en: Adding the player to the scene
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将玩家添加到场景中
- en: Now that we have a scene up and running, we need to add an actor to the scene.
    Let's first add an avatar for the player, complete with a collision volume. To
    do this, we'll have to inherit from a class from the UE4 `GameFramework` such
    as `Actor` or `Character`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个运行中的场景，我们需要向场景中添加一个角色。让我们首先为玩家添加一个角色，包括碰撞体积。为此，我们将不得不从UE4的`GameFramework`类中继承，比如`Actor`或`Character`。
- en: In order to create an onscreen representation of the player, we'll need to derive
    from the `ACharacter` class in Unreal.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建玩家的屏幕表示，我们需要从虚幻中的`ACharacter`类派生。
- en: Inheriting from UE4 GameFramework classes
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从UE4 GameFramework类继承
- en: 'UE4 makes it easy to inherit from the base framework classes. All you have
    to do is perform the following steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: UE4使得从基础框架类继承变得容易。你只需要执行以下步骤：
- en: Open your project in the UE4 editor.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UE4编辑器中打开你的项目。
- en: 'Go to File and then select New C++ Class...:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到文件，然后选择新的C++类...：
- en: '![](img/88ecd03a-96b4-48a8-a5b5-fc45d6c067d7.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88ecd03a-96b4-48a8-a5b5-fc45d6c067d7.png)'
- en: Navigating to File | New C++ Class... will allow you to derive from any of the
    UE4 GameFramework classes
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到文件|新的C++类...将允许你从任何UE4 GameFramework类中派生
- en: 'Choose the base class you want to derive from. You have Character, Pawn, Actor,
    and so on, but for now, we will derive from Character:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要派生的基类。你有Character、Pawn、Actor等，但现在我们将从Character派生：
- en: '![](img/b2bf7b68-86ba-4a8a-a4ad-7c0c2cb7fee1.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2bf7b68-86ba-4a8a-a4ad-7c0c2cb7fee1.png)'
- en: Select the UE4 class you want to derive from.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想要派生的UE4类。
- en: 'Click on Next to get this dialog box, where you name the class. I named my
    player class `Avatar`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一步，会弹出对话框，你可以在其中命名类。我将我的玩家类命名为`Avatar`：
- en: '![](img/72788a9d-a226-4aed-aac5-033641857c8d.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72788a9d-a226-4aed-aac5-033641857c8d.png)'
- en: Click on Create Class to create the class in code, as shown in the preceding
    screenshot.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Create Class在代码中创建类，如前面的截图所示。
- en: Let UE4 refresh your Visual Studio or Xcode project if it asks you. Open the
    new `Avatar.h` file from the Solution Explorer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，让UE4刷新你的Visual Studio或Xcode项目。从解决方案资源管理器中打开新的`Avatar.h`文件。
- en: The code that UE4 generates will look a little weird. Remember the macros that
    I suggested you avoid in [Chapter 5](b03d850b-1687-48a9-83a0-412526247bed.xhtml),
    *Functions and Macros*? The UE4 code uses macros extensively. These macros are
    used to copy and paste boilerplate starter code that lets your code integrate
    with the UE4 editor.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: UE4生成的代码看起来有点奇怪。记得我在[第5章](b03d850b-1687-48a9-83a0-412526247bed.xhtml)中建议你避免的宏吗，*函数和宏*？UE4代码广泛使用宏。这些宏用于复制和粘贴样板启动代码，让你的代码与UE4编辑器集成。
- en: 'The contents of the `Avatar.h` file are shown in the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Avatar.h`文件的内容如下所示：'
- en: '[PRE0]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's talk about macros for a moment.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈宏。
- en: The `UCLASS()` macro basically makes your C++ code class available in the UE4
    editor. The `GENERATED_BODY()` macro copies and pastes code that UE4 needs to
    make your class function properly as a UE4 class.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`UCLASS()`宏基本上使你的C++代码类在UE4编辑器中可用。`GENERATED_BODY()`宏复制并粘贴了UE4需要的代码，以使你的类作为UE4类正常运行。'
- en: For `UCLASS()` and `GENERATED_BODY()`, you don't truly need to understand how
    UE4 works its magic. You just need to make sure that they are present at the right
    spot (where they were when you generated the class).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`UCLASS()`和`GENERATED_BODY()`，你不需要真正理解UE4是如何运作的。你只需要确保它们出现在正确的位置（在生成类时它们所在的位置）。
- en: Associating a model with the Avatar class
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模型与Avatar类关联
- en: Now, we need to associate a model with our character object. To do this, we
    need a model to play with. Fortunately, there is a whole pack of sample models
    available from the UE4 marketplace for free.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将模型与我们的角色对象关联起来。为此，我们需要一个模型来操作。幸运的是，UE4市场上有一整套免费的示例模型可供使用。
- en: Downloading free models
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载免费模型
- en: 'To create the player object, perform the following steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建玩家对象，请执行以下步骤：
- en: 'Download the Animation Starter Pack file (which is free) from the Marketplace
    tab. The easiest way to find it is to search for it:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从市场选项卡下载Animation Starter Pack文件（免费）。找到它的最简单方法是搜索它：
- en: '![](img/f1073a42-b50b-4964-8013-2a20e849d90f.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1073a42-b50b-4964-8013-2a20e849d90f.png)'
- en: From the Unreal Launcher, click on Marketplace and search for Animation Starter
    Pack, which is free at the time of writing this book.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Unreal Launcher中，点击市场，搜索Animation Starter Pack，在撰写本书时是免费的。
- en: 'Once you''ve downloaded the Animation Starter Pack file, you will be able to
    add it to any of the projects you''ve previously created, as shown in the following
    screenshot:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你下载了Animation Starter Pack文件，你就可以将它添加到之前创建的任何项目中，如下图所示：
- en: '![](img/113956d6-bf7c-4cb6-95dd-efc546c88354.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/113956d6-bf7c-4cb6-95dd-efc546c88354.png)'
- en: 'When you click on Add to project under Animation Starter Pack, you will get
    this popup, asking which project to add the pack to:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你点击Animation Starter Pack下的Add to project时，会弹出这个窗口，询问要将包添加到哪个项目中：
- en: '![](img/66f17733-1221-4546-92b5-0ed1c9e04730.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66f17733-1221-4546-92b5-0ed1c9e04730.png)'
- en: Simply select your project and the new artwork will be available in your Content
    Browser.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需选择你的项目，新的艺术作品将在你的内容浏览器中可用。
- en: Loading the mesh
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载网格
- en: In general, it is considered a bad practice to hardcode your assets (or objects
    used in-game) into the game. Hardcoding means that you write C++ code that specifies
    the asset to load. However, hardcoding means the loaded asset is part of the final
    executable, which will mean that changing the asset that is loaded wouldn't be
    modifiable at runtime. This is a bad practice. It is much better to be able to
    change the asset loaded during runtime.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，将你的资产（或游戏中使用的对象）硬编码到游戏中被认为是一种不好的做法。硬编码意味着你编写C++代码来指定要加载的资产。然而，硬编码意味着加载的资产是最终可执行文件的一部分，这意味着在运行时更改加载的资产是不可修改的。这是一种不好的做法。最好能够在运行时更改加载的资产。
- en: For this reason, we're going to use the UE4 blueprints feature to set up the
    model mesh and collision capsule of our `Avatar` class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用UE4蓝图功能来设置我们的`Avatar`类的模型网格和碰撞胶囊。
- en: Creating a blueprint from our C++ class
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从我们的C++类创建蓝图
- en: 'Let''s go ahead and create a blueprint—it''s really easy:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个蓝图，这很容易：
- en: 'Open the Class Viewer tab by navigating to Window | Developer Tools and then
    clicking on Class Viewer, as shown here:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到窗口|开发者工具，然后点击Class Viewer来打开Class Viewer选项卡，如下所示：
- en: '![](img/40fa53a9-8873-4867-b9c1-e5646dffd0d8.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40fa53a9-8873-4867-b9c1-e5646dffd0d8.png)'
- en: 'In the Class Viewer dialog, start typing in the name of your C++ class. If
    you have properly created and exported the class from your C++ code, it will appear,
    as shown in the following screenshot:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“类查看器”对话框中，开始输入你的C++类的名称。如果你已经正确地从C++代码中创建并导出了这个类，它将会出现，就像下面的截图所示：
- en: '![](img/b5a0efe8-efa9-4f15-b014-92c290522a84.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a0efe8-efa9-4f15-b014-92c290522a84.png)'
- en: If your `Avatar` class does not show up, close the editor and compile/run the
    C++ project in Visual Studio or Xcode again.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的“Avatar”类没有显示出来，关闭编辑器，然后在Visual Studio或Xcode中重新编译/运行C++项目。
- en: Right-click on the class that you want to create a blueprint of (in my case,
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击你想要创建蓝图的类（在我的例子中，是Avatar类），然后选择“创建蓝图类...”。
- en: it's my Avatar class) and choose Create Blueprint Class....
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的Avatar类），然后选择“创建蓝图类...”。
- en: Name your blueprint something unique. I called my blueprint BP_Avatar. BP_ identifies
    it as a blueprint and makes it easier to search for later.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给你的蓝图起一个独特的名字。我把我的蓝图叫做BP_Avatar。BP_标识它是一个蓝图，这样以后搜索起来更容易。
- en: 'The new blueprint should open automatically for editing. If it doesn''t, open
    it by double-clicking on BP_Avatar (it will appear in the Class Viewer tab after
    you add it, just under Avatar), as shown in the following screenshot:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的蓝图应该会自动打开以供编辑。如果没有，双击BP_Avatar打开它（在你添加它之后，它会出现在“类查看器”选项卡下的Avatar之下），就像下面的截图所示：
- en: '![](img/3354a828-7007-4665-9e70-bfa050b3bdd7.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3354a828-7007-4665-9e70-bfa050b3bdd7.png)'
- en: 'You will be presented with the blueprints window for your new BP_Avatar object,
    as shown here (make sure to select the Event Graph tab):'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将会看到新的BP_Avatar对象的蓝图窗口，就像这样（确保选择“事件图”选项卡）：
- en: '![](img/ba5ad46c-4b2b-4838-a0d3-5e2a09809db5.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba5ad46c-4b2b-4838-a0d3-5e2a09809db5.png)'
- en: From this window, you can attach a model to the `Avatar` class visually. Again,
    this is the recommended pattern since artists will typically be the ones setting
    up their assets for game designers to play with.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个窗口，你可以在视觉上将模型附加到“Avatar”类。同样，这是推荐的模式，因为通常是艺术家设置他们的资产供游戏设计师使用。
- en: 'Your blueprint will have already inherited a default skeletal mesh. To see
    the options for it, click on Mesh (Inherited) under CapsuleComponent on the left:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的蓝图已经继承了一个默认的骨骼网格。要查看它的选项，点击左侧的CapsuleComponent下的Mesh（Inherited）：
- en: '![](img/82e63e31-ade0-4cf5-9b21-8e1a16aad62b.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82e63e31-ade0-4cf5-9b21-8e1a16aad62b.png)'
- en: 'Click on the dropdown and select SK_Mannequin for your mesh:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下拉菜单，为你的模型选择SK_Mannequin：
- en: '![](img/5ee928d3-2f02-432c-b73f-8d9336092d2a.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ee928d3-2f02-432c-b73f-8d9336092d2a.png)'
- en: If SK_Mannequin doesn't appear in the dropdown, make sure that you download
    and add the Animation Starter Pack to your project.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果SK_Mannequin没有出现在下拉菜单中，请确保你下载并将动画起始包添加到你的项目中。
- en: What about the collision volume? You already have one called CapsuleComponent.
    If your capsule doesn't encapsulate your model, adjust the model so that it fits.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 碰撞体积呢？你已经有一个叫做CapsuleComponent的了。如果你的胶囊没有包裹住你的模型，调整模型使其合适。
- en: If your model ended up like mine, the capsule is off the mark! We need to adjust
    it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模型最终像我的一样，胶囊位置不对！我们需要调整它。
- en: '![](img/ccef727b-a32d-4679-aa96-364d28b76c57.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ccef727b-a32d-4679-aa96-364d28b76c57.png)'
- en: 'Click on the Avatar model and then click and hold the blue arrow pointing up,
    as shown in the preceding screenshot. Move him down until he fits inside the capsule.
    If the capsule isn''t big enough, you can adjust its size in the Details tab under
    Capsule Half-Height and Capsule Radius:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击Avatar模型，然后点击并按住向上的蓝色箭头，就像前面的截图所示。将他移动到合适的位置以适应胶囊。如果胶囊不够大，你可以在详细信息选项卡下调整它的大小，包括Capsule
    Half-Height和Capsule Radius：
- en: '![](img/6e2931d1-ffbc-460d-9b34-4cdfc41d572a.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e2931d1-ffbc-460d-9b34-4cdfc41d572a.png)'
- en: You can stretch your capsule by adjusting the Capsule Half-Height property
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调整Capsule Half-Height属性来拉伸你的胶囊。
- en: 'Let''s add this avatar to the game world. Click and drag your BP_Avatar model
    from the Class Viewer tab to your scene in the UE4 editor:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把这个Avatar添加到游戏世界中。在UE4编辑器中，从“类查看器”选项卡中将BP_Avatar模型拖放到场景中：
- en: '![](img/47722d4b-ab9b-4455-9466-c5c85c77e8c4.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47722d4b-ab9b-4455-9466-c5c85c77e8c4.png)'
- en: Our Avatar class added to the scene
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Avatar类已经添加到场景中
- en: 'The pose of Avatar is the default pose. You want him animated, you say! Well,
    that''s easy, just perform the following steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Avatar的姿势是默认的姿势。你想要他动起来，是吧！好吧，那很容易，只需按照以下步骤进行：
- en: 'Click on your Mesh in the Blueprint editor and you will see Animation under
    Details on the right. Note: if you closed the blueprint for any reason and reopen
    it you won''t see the full blueprint. If that happens, click the link to open
    the full blueprint editor.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图编辑器中点击你的Mesh，你会在右侧的详细信息下看到Animation。注意：如果你因为任何原因关闭了蓝图并重新打开它，你将看不到完整的蓝图。如果发生这种情况，点击链接打开完整的蓝图编辑器。
- en: 'You can now use a blueprint for the animation. This way, an artist can properly
    set the animation based on what the character is doing. If you select UE4ASP_HeroTPP_AnimBlueprint
    from the `AnimClass` drop-down menu, the animation will be adjusted by the blueprint
    (which would have been done by an artist) as the character moves:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以使用蓝图来进行动画。这样，艺术家可以根据角色的动作来正确设置动画。如果你从“AnimClass”下拉菜单中选择UE4ASP_HeroTPP_AnimBlueprint，动画将会被蓝图（通常是由艺术家完成的）调整，以适应角色的移动：
- en: '![](img/0904ac8d-0a09-4db4-aa81-d78268b3ed59.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0904ac8d-0a09-4db4-aa81-d78268b3ed59.png)'
- en: If you save and compile the blueprint and hit play in the main game window,
    you will see the idle animation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你保存并编译蓝图，并在主游戏窗口中点击播放，你将会看到空闲动画。
- en: We can't cover everything here. Animation blueprints are covered in [Chapter
    11](1bee5b28-fd5d-4d05-8347-f8b2886cf011.xhtml), *Monsters*. If you're really
    interested in animation, it wouldn't be a bad idea to sit through a couple of
    Gnomon Workshop tutorials on IK, animation, and rigging, which can be found at
    [gnomonworkshop.com/tutorials](http://gnomonworkshop.com/tutorials).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在这里覆盖所有内容。动画蓝图在[第11章](1bee5b28-fd5d-4d05-8347-f8b2886cf011.xhtml)中有介绍，*怪物*。如果你对动画真的感兴趣，不妨花点时间观看一些Gnomon
    Workshop关于IK、动画和绑定的教程，可以在[gnomonworkshop.com/tutorials](http://gnomonworkshop.com/tutorials)找到。
- en: 'One more thing: let''s make the camera for the Avatar appear behind it. This
    will give you a third-person point of view, which will allow you to see the whole
    character, shown in the following screenshot, with the corresponding steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事：让Avatar的相机出现在其后面。这将为您提供第三人称视角，使您可以看到整个角色，如下截图所示，以及相应的步骤：
- en: In the BP_Avatar blueprint editor, select BP_Avatar (Self) and click on Add
    Component.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在BP_Avatar蓝图编辑器中，选择BP_Avatar（Self）并单击添加组件。
- en: Scroll down to choose to add a Camera.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下滚动以选择添加相机。
- en: 'A camera will appear in the viewport. You can click on the camera and move
    it around. Position the camera so that it is somewhere behind the player. Make
    sure that the blue arrow on the player is facing the same direction as the camera.
    If it isn''t, rotate the Avatar model mesh so that it faces the same direction
    as its blue-colored arrow:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 视口中将出现一个相机。您可以单击相机并移动它。将相机定位在玩家的后方某处。确保玩家身上的蓝色箭头面向相机的方向。如果不是，请旋转Avatar模型网格，使其面向与其蓝色箭头相同的方向：
- en: '![](img/98e53d3b-5ffa-429f-842b-32dbd53351ec.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98e53d3b-5ffa-429f-842b-32dbd53351ec.png)'
- en: The blue-colored arrow on your model mesh indicates the forward direction for
    the model mesh. Make sure that the camera's opening faces the same direction as
    the character's forward vector.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 模型网格上的蓝色箭头表示模型网格的前进方向。确保相机的开口面向与角色的前向矢量相同的方向。
- en: Writing C++ code that controls the game's character
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写控制游戏角色的C++代码
- en: When you launch your UE4 game, you might notice that the camera hasn't changed.
    What we will do now is make the starting character an instance of our `Avatar`
    class and control our character using the keyboard.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启动UE4游戏时，您可能会注意到相机没有改变。现在我们要做的是使起始角色成为我们`Avatar`类的实例，并使用键盘控制我们的角色。
- en: Making the player an instance of the Avatar class
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使玩家成为Avatar类的实例
- en: 'Let''s take a look at how we go about this. In the Unreal Editor, perform the
    following steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何做到这一点。在虚幻编辑器中，执行以下步骤：
- en: 'Create a subclass of Game Mode by navigating to File | New C++ Class... and
    selecting Game Mode Base. I named mine `GameModeGoldenEgg`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到 文件 | 新建C++类... 并选择Game Mode Base 来创建Game Mode的子类。我命名为`GameModeGoldenEgg`：
- en: '![](img/23a322b6-c022-43ea-97fb-9807874a5637.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23a322b6-c022-43ea-97fb-9807874a5637.png)'
- en: The UE4 GameMode contains the rule of the game and describes how the game is
    played to the engine. We will work more with our `GameMode` class later. For now,
    we need to subclass it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: UE4 GameMode包含游戏规则，并描述了游戏如何在引擎中进行。我们稍后将更多地使用我们的`GameMode`类。现在，我们需要对其进行子类化。
- en: It should automatically compile your C++ code after you create the class, so
    you can create a `GameModeGoldenEgg` blueprint.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 创建类后，它应该自动编译您的C++代码，因此您可以创建`GameModeGoldenEgg`蓝图。
- en: 'Create the GameMode blueprint by going to the Blueprints icon in the menu bar
    at the top, clicking on GameMode New, and then selecting + Create | GameModeGoldenEgg
    (or whatever you named your GameMode subclass in step 1):'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到顶部的菜单栏中的蓝图图标，单击GameMode New，然后选择+ Create | GameModeGoldenEgg（或者您在步骤1中命名的GameMode子类）来创建GameMode蓝图：
- en: '![](img/2f3f5cc3-d6a3-453a-831f-420ff6bfba75.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f3f5cc3-d6a3-453a-831f-420ff6bfba75.png)'
- en: 'Name your blueprint; I called mine `BP_GameModeGoldenEgg`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名您的蓝图；我称之为`BP_GameModeGoldenEgg`：
- en: '![](img/7a38f985-9ad1-419a-98be-5946eb81ea29.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a38f985-9ad1-419a-98be-5946eb81ea29.png)'
- en: Your newly created blueprint will open in the blueprint editor. If it doesn't,
    you can open the BP_GameModeGoldenEgg class from the Class Viewer tab.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您新创建的蓝图将在蓝图编辑器中打开。如果没有打开，您可以从类查看器选项卡中打开BP_GameModeGoldenEgg类。
- en: 'Select your BP_Avatar class from the Default Pawn Class panel, as shown in
    the following screenshot. The Default Pawn Class panel is the type of object that
    will be used for the player:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从默认Pawn Class面板中选择BP_Avatar类，如下截图所示。默认Pawn Class面板是将用于玩家的对象类型：
- en: '![](img/23295e1f-cf29-4e40-bc83-a00c8eef7b91.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23295e1f-cf29-4e40-bc83-a00c8eef7b91.png)'
- en: 'Launch your game. You can see a back view as the camera is placed behind the
    player:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的游戏。您可以看到一个背面视图，因为相机放置在玩家后面：
- en: '![](img/09b890d9-96b0-43e7-bec8-5e0ef4b8b9a2.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09b890d9-96b0-43e7-bec8-5e0ef4b8b9a2.png)'
- en: You'll notice that you can't move. Why is that? The answer is because we haven't
    set up the controller input yet. The following section will teach you exactly
    how to go about doing it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到您无法移动。为什么呢？答案是因为我们还没有设置控制器输入。接下来的部分将教您如何准确地进行操作。
- en: Setting up controller input
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置控制器输入
- en: 'Here are the steps to set up input:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是设置输入的步骤：
- en: 'To set up controller input, go to Settings | Project Settings...:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置控制器输入，转到 设置 | 项目设置...：
- en: '![](img/a408251e-921d-4c48-b3aa-f05828af46dc.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a408251e-921d-4c48-b3aa-f05828af46dc.png)'
- en: 'In the left-hand panel, scroll down until you see Input under Engine:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧面板中，向下滚动直到在引擎下看到输入：
- en: '![](img/513f595b-2dbe-4f82-88dc-f9881ae1a587.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](img/513f595b-2dbe-4f82-88dc-f9881ae1a587.png)'
- en: On the right-hand side, you can set up some Bindings. Click + to add a new binding
    and then click on the small arrow next to Axis Mappings in order to expand it.
    Add just two axis mappings to start, one called Forward (connected to the keyboard
    letter *W*) and one called Strafe (connected to the keyboard letter *D*). Remember
    the names that you set; we will look them up in C++ code in just a moment.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧，您可以设置一些绑定。单击+以添加新的绑定，然后单击Axis Mappings旁边的小箭头以展开它。开始添加两个轴映射，一个称为Forward（连接到键盘字母*W*），另一个称为Strafe（连接到键盘字母*D*）。记住您设置的名称；我们将在C++代码中查找它们。
- en: 'Close the Project Settings dialog. Open your C++ code. In the `Avatar.h` constructor,
    you need to add two member function declarations, as shown here:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭项目设置对话框。打开您的C++代码。在`Avatar.h`构造函数中，您需要添加两个成员函数声明，如下所示：
- en: '[PRE1]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice how the existing functions, `SetupPlayerInputComponent` and `Tick`, are
    overrides of virtual functions. `SetupPlayerInputComponent` is a virtual function
    in the `APawn` base class. We will also be adding code to this function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现有的函数`SetupPlayerInputComponent`和`Tick`是虚函数的重写。`SetupPlayerInputComponent`是`APawn`基类中的虚函数。我们还将向这个函数添加代码。
- en: 'In the `Avatar.cpp` file, you need to add the function bodies. Inside `SetupPlayerInputComponent`
    under `Super::SetupPlayerInputComponent(PlayerInputComponent);`, add the following
    lines:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Avatar.cpp`文件中，您需要添加函数主体。在`Super::SetupPlayerInputComponent(PlayerInputComponent);`下面的`SetupPlayerInputComponent`中，添加以下行：
- en: '[PRE2]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This member function looks up the Forward and Strafe axis bindings that we
    just created in Unreal Editor and connects them to the member functions inside
    the `this` class. Which member functions should we connect to? Why, we should
    connect to `AAvatar::MoveForward` and `AAvatar::MoveRight`. Here are the member
    function definitions for these two functions:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个成员函数查找我们刚刚在虚幻编辑器中创建的前进和横向轴绑定，并将它们连接到`this`类内部的成员函数。我们应该连接到哪些成员函数呢？为什么，我们应该连接到`AAvatar::MoveForward`和`AAvatar::MoveRight`。以下是这两个函数的成员函数定义：
- en: '[PRE3]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Controller` object and the `AddMovementInput` function are defined in the
    `APawn` base class. Since the `Avatar` class derives from `ACharacter`, which
    in turn derives from `APawn`, we get free use of all the member functions in the `APawn` base
    class. Now, do you see the beauty of inheritance and code reuse?    If you test
    this out, make sure you click inside the game window, because otherwise the game
    won't receive keyboard events.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Controller`对象和`AddMovementInput`函数在`APawn`基类中定义。由于`Avatar`类派生自`ACharacter`，而`ACharacter`又派生自`APawn`，因此我们可以免费使用`APawn`基类中的所有成员函数。现在，您看到了继承和代码重用的美丽之处了吗？如果您测试这个功能，请确保您点击游戏窗口内部，否则游戏将无法接收键盘事件。'
- en: Exercise
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Add axis bindings and C++ functions to move the player to the left and back.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 添加轴绑定和C++函数以将玩家向左和向后移动。
- en: 'Here''s a hint: you only need to add axis bindings if you realize going backward
    is simply the negative of going forward.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有个提示：如果你意识到向后走实际上就是向前走的负数，那么你只需要添加轴绑定。
- en: Solution
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Enter two extra axis bindings by navigating to Settings | Project Settings...
    | Input, as shown here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到设置|项目设置...|输入，添加两个额外的轴绑定，如下所示：
- en: '![](img/90c0f3a9-20ee-4edf-a119-0de485d653cc.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90c0f3a9-20ee-4edf-a119-0de485d653cc.png)'
- en: Scale the S and A input by -1.0\. This will invert the axis, so pressing the
    *S* key in the game will move the player forward. Try it!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将S和A输入乘以-1.0来缩放。这将反转轴，因此在游戏中按下*S*键将使玩家向前移动。试试看！
- en: 'Alternatively, you can define two completely separate member functions in your
    `AAvatar` class, as follows, and bind the *A* and *S* keys to `AAvatar::MoveLeft`
    and `AAvatar::MoveBack`, respectively (and make sure to add the bindings for these
    to `AAvatar::SetupPlayerInputComponent`):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在`AAvatar`类中定义两个完全独立的成员函数，如下所示，并将*A*和*S*键分别绑定到`AAvatar::MoveLeft`和`AAvatar::MoveBack`（并确保为这些函数添加绑定到`AAvatar::SetupPlayerInputComponent`）：
- en: '[PRE4]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Yaw and pitch
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 偏航和俯仰
- en: 'We can change the direction in which the player looks by setting the yaw and
    pitch of the controller. Check out the following steps:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置控制器的偏航和俯仰来改变玩家的朝向。请查看以下步骤：
- en: 'Add new axis bindings for the mouse, as shown in the following screenshot:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下截图所示，为鼠标添加新的轴绑定：
- en: '![](img/92087a57-27cd-4228-ade9-ae57c6b78825.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92087a57-27cd-4228-ade9-ae57c6b78825.png)'
- en: 'From C++, add two new member function declarations to `AAvatar.h`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从C++中，向`AAvatar.h`添加两个新的成员函数声明：
- en: '[PRE5]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The bodies of these member functions will go in the `AAvatar.cpp` file:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成员函数的主体将放在`AAvatar.cpp`文件中：
- en: '[PRE6]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add two lines to `SetupPlayerInputComponent`:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SetupPlayerInputComponent`中添加两行：
- en: '[PRE7]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, notice how I've multiplied the `amount` values in the `Yaw` and `Pitch`
    functions by 200\. This number represents the mouse's sensitivity. You can (should)
    add a `float` member to the `AAvatar` class in order to avoid hardcoding this
    sensitivity number.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，注意我如何将`Yaw`和`Pitch`函数中的`amount`值乘以200。这个数字代表鼠标的灵敏度。您可以（应该）在`AAvatar`类中添加一个`float`成员，以避免硬编码这个灵敏度数字。
- en: '`GetWorld()->GetDeltaSeconds()` gives you the amount of time that passed between
    the last frame and this frame. It isn''t a lot; `GetDeltaSeconds()` should be
    around 16 milliseconds (0.016 s) most of the time (if your game is running at
    60 fps).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetWorld()->GetDeltaSeconds()`给出了上一帧和这一帧之间经过的时间。这不是很多；`GetDeltaSeconds()`大多数时候应该在16毫秒左右（如果您的游戏以60fps运行）。'
- en: 'Note: you may notice that right now Pitch doesn''t actually work. This is because
    you''re using a third-person camera. While it might not make sense for this camera,
    you can get it working by going into BP_Avatar, selecting the camera, and checking
    Use Pawn Control Rotation under Camera Options:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可能会注意到现在俯仰实际上并不起作用。这是因为您正在使用第三人称摄像头。虽然对于这个摄像头可能没有意义，但您可以通过进入BP_Avatar，选择摄像头，并在摄像头选项下勾选使用Pawn控制旋转来使其起作用：
- en: '![](img/18534c33-1564-4a99-aab9-28422d145e3c.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18534c33-1564-4a99-aab9-28422d145e3c.png)'
- en: 'So, now we have player input and control. To add new functionality to your
    Avatar, this is all that you have to do:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们有了玩家输入和控制。要为您的Avatar添加新功能，您只需要做到这一点：
- en: Bind your key or mouse actions by going to Settings | Project Settings | Input.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到设置|项目设置|输入，绑定您的键盘或鼠标操作。
- en: Add a member function to run when that key is pressed.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个在按下该键时运行的成员函数。
- en: Add a line to `SetupPlayerInputComponent`, connecting the name of the bound
    input to the member function we want to run when that key is pushed.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SetupPlayerInputComponent`中添加一行，将绑定输入的名称连接到我们希望在按下该键时运行的成员函数。
- en: Creating non-player character entities
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建非玩家角色实体
- en: 'So, we need to create a few **NPC** (**non-playable characters**). NPCs are
    characters in the game that help the player. Some offer special items, some are
    shop vendors, and some have information to give to the player. In this game, they
    will react to the player as he gets near. Let''s program in some of this behavior:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要创建一些**NPC**（**非玩家角色**）。NPC是游戏中帮助玩家的角色。一些提供特殊物品，一些是商店供应商，一些有信息要提供给玩家。在这个游戏中，他们将在玩家靠近时做出反应。让我们在一些行为中编程：
- en: Create another subclass of Character. In the UE4 Editor, go to File | New C++
    Class... and choose the Character class from which you can make a subclass. Name
    your subclass `NPC`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个Character的子类。在UE4编辑器中，转到文件 | 新建C++类...，并选择可以创建子类的Character类。将您的子类命名为`NPC`。
- en: Edit your code in Visual Studio. Each NPC will have a message to tell the player,
    so we add in a `UPROPERTY() FString` property to the `NPC` class.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中编辑您的代码。每个NPC都会有一条消息告诉玩家，因此我们在`NPC`类中添加了一个`UPROPERTY() FString`属性。
- en: '`FString` is UE4''s version of C++''s `<string>` type. When programming in
    UE4, you should use `FString` objects over C++ STL''s `string` objects. In general,
    you should use UE4''s built-in types, as they guarantee cross-platform compatibility.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`FString`是UE4中C++的`<string>`类型。在UE4中编程时，应该使用`FString`对象而不是C++ STL的`string`对象。一般来说，应该使用UE4的内置类型，因为它们保证跨平台兼容性。'
- en: 'Here''s how to add the `UPROPERTY() FString` property to the `NPC` class:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是如何向`NPC`类添加`UPROPERTY() FString`属性：
- en: '[PRE8]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we put the `EditAnywhere` and `BlueprintReadWrite` properties into
    the `UPROPERTY` macro. This will make `NpcMessage` editable in blueprints.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`EditAnywhere`和`BlueprintReadWrite`属性放入了`UPROPERTY`宏中。这将使`NpcMessage`在蓝图中可编辑。
- en: Full descriptions of all the UE4 property specifiers are available at [https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/index.html](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/index.html).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 所有UE4属性说明符的完整描述可在[https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/index.html](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/index.html)上找到。
- en: Recompile your project (as we did for the `Avatar` class). Then, go to the Class
    Viewer, right-click on your `NPC` class, and create a blueprint class from it.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编译您的项目（就像我们为`Avatar`类所做的那样）。然后，转到类查看器，在您的`NPC`类上右键单击，并从中创建蓝图类。
- en: 'Each NPC character you want to create can be a blueprint based off of the `NPC`
    class. Name each blueprint something unique, as we''ll be selecting a different
    model mesh and message for each NPC that appears, as shown in the following screenshot:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您想要创建的每个NPC角色都可以是基于`NPC`类的蓝图。为每个蓝图命名一个独特的名称，因为我们将为每个出现的NPC选择不同的模型网格和消息，如下面的屏幕截图所示：
- en: '![](img/4e56443b-06bf-4682-ba59-640982763c4a.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e56443b-06bf-4682-ba59-640982763c4a.png)'
- en: 'Open the blueprint and select Mesh (Inherited). You can then change the material
    of your new character in the Skeletal Mesh dropdown so that it looks different
    from the player:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开蓝图并选择Mesh（继承）。然后，您可以在骨骼网格下拉菜单中更改您的新角色的材质，使其看起来与玩家不同：
- en: '![](img/6539c287-1585-4a05-a469-3b448b3fa947.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6539c287-1585-4a05-a469-3b448b3fa947.png)'
- en: Change the material of your character in your mesh's properties by selecting
    from the dropdown for each element available
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从下拉菜单中选择每个元素，更改您的角色在网格属性中的材质
- en: 'In the Details tab with the blueprint name (self) selected in the Components
    tab, look for the `NpcMessage` property. This is our connection between C++ code
    and blueprints; because we entered a `UPROPERTY()` function on the `FString NpcMessage`
    variable, that property appears editable in UE4, as shown in the following screenshot:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件选项卡中选择蓝图名称（self），在详细信息选项卡中查找`NpcMessage`属性。这是我们在C++代码和蓝图之间的连接；因为我们在`FString
    NpcMessage`变量上输入了`UPROPERTY()`函数，该属性在UE4中显示为可编辑，如下面的屏幕截图所示：
- en: '![](img/a1b93490-aa67-4b8b-bc38-7d39feb6f7e1.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1b93490-aa67-4b8b-bc38-7d39feb6f7e1.png)'
- en: 'Drag BP_NPC_Owen into the scene. You can create a second or third character
    as well, and be sure to give them unique names, appearances, and messages:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将BP_NPC_Owen拖入场景中。您也可以创建第二个或第三个角色，并确保为它们提供独特的名称、外观和消息：
- en: '![](img/369f6e1e-e458-4bdd-b7ff-dcdc3605201d.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/369f6e1e-e458-4bdd-b7ff-dcdc3605201d.png)'
- en: 'I''ve created two blueprints for NPCs based on the NPC base classes: BP_NPC_Jonathan
    and BP_NPC_Owen. They have different appearances and different messages for the
    player:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为基于NPC基类的NPC创建了两个蓝图：BP_NPC_Jonathan和BP_NPC_Owen。它们对玩家有不同的外观和不同的消息：
- en: '![](img/fc0b7f35-74e7-42fe-b77a-6cb51e93f894.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc0b7f35-74e7-42fe-b77a-6cb51e93f894.png)'
- en: Jonathan and Owen in the scene
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中的Jonathan和Owen
- en: Displaying a quote from each NPC dialog box
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示每个NPC对话框中的引用
- en: To display a dialog box, we need a custom **heads-up display** (**HUD**). In
    the UE4 editor, go to File | New C++ Class... and choose the `HUD` class from
    which the subclass is created (you'll need to scroll down to find it). Name your
    subclass as you wish; I've named mine `MyHUD`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示对话框，我们需要一个自定义的**悬浮显示**（**HUD**）。在UE4编辑器中，转到文件 | 新建C++类...，并选择从中创建子类的`HUD`类（您需要向下滚动以找到它）。按您的意愿命名您的子类；我命名为`MyHUD`。
- en: After you have created the `MyHUD` class, let Visual Studio reload. We will
    make some code edits.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`MyHUD`类后，让Visual Studio重新加载。我们将进行一些代码编辑。
- en: Displaying messages on the HUD
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在HUD上显示消息
- en: 'Inside the `AMyHUD` class, we need to implement the `DrawHUD()` function in
    order to draw our messages to the HUD and to initialize a font draw to the HUD
    with, as shown in the following code in `MyHUD.h`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AMyHUD`类中，我们需要实现`DrawHUD()`函数，以便将我们的消息绘制到HUD上，并使用以下`MyHUD.h`中的代码初始化HUD的字体绘制：
- en: '[PRE9]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The HUD font will be set in a blueprinted version of the `AMyHUD` class. The
    `DrawHUD()` function runs once per frame. In order to draw within the frame, add
    a function to the `AMyHUD.cpp` file:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: HUD字体将在`AMyHUD`类的蓝图版本中设置。`DrawHUD()`函数每帧运行一次。为了在帧内绘制，将一个函数添加到`AMyHUD.cpp`文件中：
- en: '[PRE10]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Wait! We haven''t initialized our font yet. Let''s do that now:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！我们还没有初始化我们的字体。让我们现在做这个：
- en: 'Set it up in blueprints. Compile your Visual Studio project in the editor,
    then go to the Blueprints menu at the top and navigate to GameMode | HUD | + Create
    | MyHUD:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在蓝图中设置它。在编辑器中编译您的Visual Studio项目，然后转到顶部的蓝图菜单，导航到GameMode | HUD | + Create |
    MyHUD:'
- en: '![](img/e7338fbe-3349-4835-9170-23c3c8b968d2.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7338fbe-3349-4835-9170-23c3c8b968d2.png)'
- en: Creating a blueprint of the MyHUD class
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 创建MyHUD类的蓝图
- en: 'I called mine `BP_MyHUD`.  Find `Hud Font`, select the dropdown, and create
    a new Font asset. I named mine `MyHUDFont`:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我称我的为`BP_MyHUD`。找到`Hud Font`，选择下拉菜单，并创建一个新的字体资源。我命名为`MyHUDFont`：
- en: '![](img/7da1c1a0-5e0a-4be6-a077-10aed0bd1e75.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7da1c1a0-5e0a-4be6-a077-10aed0bd1e75.png)'
- en: 'Locate MyHUDFont in the content browser and double-click on it to edit it:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中找到MyHUDFont并双击以编辑它：
- en: '![](img/032d326f-aa66-45f5-bc40-e85bd4610b06.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/032d326f-aa66-45f5-bc40-e85bd4610b06.png)'
- en: In the window that follows, you can click on where it says `+ Add Font` to create
    a new Default Font Family. You can name it what you like and click the folder
    icon to choose a font from your hard drive (you can find .TTF or TrueType Fonts
    online for free at many sites – I used a Blazed font I found); When you import
    a font, it will ask you to save the Font Face. You will also want to change the
    Legacy Font Size in MyHUDFont to a much bigger size (I used 36).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的窗口中，您可以点击`+ Add Font`创建一个新的默认字体系列。您可以自行命名并单击文件夹图标选择硬盘上的字体（您可以在许多网站免费找到.TTF或TrueType字体
    - 我使用了找到的Blazed字体）；当您导入字体时，它将要求您保存字体。您还需要将MyHUDFont中的Legacy Font Size更改为更大的大小（我使用了36）。
- en: 'Edit your Game Mode blueprint (BP_GameModeGoldenEgg) and select your new `BP_MyHUD`
    (not `MyHUD`) class for the HUD Class panel:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑您的游戏模式蓝图（BP_GameModeGoldenEgg）并选择您的新`BP_MyHUD`（而不是`MyHUD`）类作为HUD Class面板：
- en: '![](img/cf43dd26-ad50-423c-be6f-7bff4f073942.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf43dd26-ad50-423c-be6f-7bff4f073942.png)'
- en: 'Compile and test your program by running it! You should see text printed on
    the screen:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并测试您的程序！您应该在屏幕上看到打印的文本：
- en: '![](img/f46ba1db-4910-4069-a458-cde7dad072cd.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f46ba1db-4910-4069-a458-cde7dad072cd.png)'
- en: Exercise
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: You can see that the text isn't fully centered. That's because the position
    is based on the top-left corner of the text, not the middle.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到文本并没有完全居中。这是因为位置是基于文本的左上角而不是中间的。
- en: 'See whether you can fix that. Here''s a hint: get the width and height of the
    text and subtract half of that from the viewport width and height/2 you''re already
    using. You''ll want to use something similar to the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你能否修复它。这里有一个提示：获取文本的宽度和高度，然后从视口宽度和高度/2中减去一半。您将需要使用类似以下的内容：
- en: '[PRE11]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using TArray<Message>
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TArray<Message>
- en: 'Each message we want to display for the player will have a few properties:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要显示给玩家的每条消息都将有一些属性：
- en: An `FString` variable for the message
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于消息的`FString`变量
- en: A `float` variable for the time to display it
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于显示消息的时间的`float`变量
- en: An `FColor` variable for the color of the message
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于消息颜色的`FColor`变量
- en: So, it makes sense for us to write a little `struct` function to contain all
    this information.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对我们来说，写一个小的`struct`函数来包含所有这些信息是有意义的。
- en: 'At the top of `MyHUD.h`, insert the following `struct` declaration:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MyHUD.h`的顶部，插入以下`struct`声明：
- en: '[PRE12]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, inside the `AMyHUD` class, we want to add a `TArray` of these messages.
    `TArray` is a UE4-defined special type of dynamically-growable C++ array. We will
    cover the detailed use of `TArray` in [Chapter 9](8f0cd854-e496-4f99-a30a-185ef8078e04.xhtml), *Templates
    and Commonly-Used Containers*, but this simple use of `TArray` should be a nice
    introduction to garner your interest in the usefulness of arrays in games. This
    will be declared as `TArray<Message>`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`AMyHUD`类内，我们要添加一个这些消息的`TArray`。`TArray`是UE4定义的一种特殊类型的动态增长的C++数组。我们将在[第9章](8f0cd854-e496-4f99-a30a-185ef8078e04.xhtml)中详细介绍`TArray`的使用，但这种简单的`TArray`使用应该是对游戏中数组的有用性的一个很好的介绍。这将被声明为`TArray<Message>`：
- en: '[PRE13]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Also add ** `#include "CoreMinimal.h"`** *to the top of the file*.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 还要在文件顶部添加**`#include "CoreMinimal.h"`**。
- en: Now, whenever the NPC has a message to display, we just need to call `AMyHud::addMessage()`
    with our message. The message will be added to the `TArray` of the messages to
    be displayed. When a message expires (after a certain amount of time), it will
    be removed from the HUD.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当NPC有消息要显示时，我们只需要调用`AMyHud::addMessage()`并传入我们的消息。消息将被添加到要显示的消息的`TArray`中。当消息过期（在一定时间后），它将从HUD中移除。
- en: 'Inside the `AMyHUD.cpp` file,  add the following code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AMyHUD.cpp`文件内，添加以下代码：
- en: '[PRE14]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `AMyHUD::DrawHUD()` function now draws all the messages in the `messages`
    array, and arranges each message in the `messages` array by the amount of time
    that passed since the last frame. Expired messages are removed from the `messages`
    collection once their `time` value drops below 0.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`AMyHUD::DrawHUD()`函数现在绘制`messages`数组中的所有消息，并根据自上一帧以来经过的时间对`messages`数组中的每条消息进行排列。一旦消息的`time`值降至0以下，过期的消息将从`messages`集合中移除。'
- en: Exercise
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Refactor the `DrawHUD()` function so that the code that draws the messages to
    the screen is in a separate function, called `DrawMessages()`. You will probably
    want to create at least one sample message object and call `addMessage` with it
    so you can see it.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 重构`DrawHUD()`函数，使将消息绘制到屏幕的代码放在一个名为`DrawMessages()`的单独函数中。您可能希望创建至少一个样本消息对象，并调用`addMessage`以便您可以看到它。
- en: The `Canvas` variable is only available in `DrawHUD()`, so you will have to
    save `Canvas->SizeX` and `Canvas->SizeY` in class-level variables.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`变量仅在`DrawHUD()`中可用，因此您将不得不将`Canvas->SizeX`和`Canvas->SizeY`保存在类级变量中。'
- en: Refactoring means changing the way code works internally so that it is more
    organized or easier to read but still has the same apparent result to the user
    running the program. Refactoring often is a good practice. The reason why refactoring
    occurs is because nobody knows exactly what the final code should look like when
    they start writing it.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 重构意味着改变代码的内部工作方式，使其更有组织或更容易阅读，但对于运行程序的用户来说，结果看起来是一样的。重构通常是一个好的实践。重构发生的原因是因为没有人在开始编写代码时确切地知道最终的代码应该是什么样子。
- en: Triggering an event when the player is near an NPC
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当玩家靠近NPC时触发事件
- en: 'To trigger an event near the NPC, we need to set an additional collision detection
    volume that is a bit wider than the default capsule shape. The additional collision
    detection volume will be a sphere around each NPC. When the player steps into
    the NPC sphere, the NPC (shown as follows) reacts and displays a message:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 要在NPC附近触发事件，我们需要设置一个额外的碰撞检测体积，它比默认的胶囊形状稍宽。额外的碰撞检测体积将是每个NPC周围的一个球体。当玩家走进NPC的球体时，NPC（如下所示）会做出反应并显示一条消息：
- en: '![](img/492972ff-87a2-4db4-a813-5aa37fd55b3f.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/492972ff-87a2-4db4-a813-5aa37fd55b3f.png)'
- en: We're going to add the dark red sphere to the NPC so that it can tell when the
    player is nearby.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向NPC添加深红色的球体，以便它可以知道玩家是否附近。
- en: 'Inside your `NPC.h` class file, add `#include "Components/SphereComponent.h"`
    at the top and the following code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NPC.h`类文件中，添加`#include "Components/SphereComponent.h"`到顶部，并添加以下代码：
- en: '[PRE15]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This looks a bit messy, but it is actually not that complicated. Here, we declare
    an extra bounding sphere volume called `ProxSphere`, which detects when the player
    is near the NPC.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点凌乱，但实际上并不复杂。在这里，我们声明了一个额外的边界球体积，称为`ProxSphere`，它可以检测玩家是否靠近NPC。
- en: 'In the `NPC.cpp` file, we need to add the following code in order to complete
    the proximity detection:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NPC.cpp`文件中，我们需要添加以下代码以完成接近检测：
- en: '[PRE16]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Making the NPC display something to the HUD when the player is nearby
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当玩家附近的NPC向HUD显示内容
- en: When the player is near the NPC sphere-collision volume, display a message to
    the HUD that alerts the player about what the NPC is saying.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家靠近NPC的球体碰撞体积时，向HUD显示一条消息，提醒玩家NPC在说什么。
- en: 'This is the complete implementation of `ANPC::Prox_Implementation`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`ANPC::Prox_Implementation`的完整实现：
- en: '[PRE17]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Also, make sure you add the following at the top of the file:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保在文件顶部添加以下内容：
- en: '[PRE18]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first thing we do in this function is cast `OtherActor` (the thing that
    came near the NPC) to `AAvatar`. The cast succeeds (and is not `nullptr`) when
    `OtherActor` is an `AAvatar` object. We get the HUD object (which happens to be
    attached to the player controller) and pass a message from the NPC to the HUD.
    The message is displayed whenever the player is within the red bounding sphere
    surrounding the NPC:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先将`OtherActor`（靠近NPC的物体）转换为`AAvatar`。当`OtherActor`是`AAvatar`对象时，转换成功（且不为`nullptr`）。我们获取HUD对象（它恰好附加到玩家控制器上），并将NPC的消息传递给HUD。每当玩家在NPC周围的红色边界球体内时，消息就会显示出来：
- en: '![](img/92ceff6f-a598-4b30-8c21-855ab81441b3.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92ceff6f-a598-4b30-8c21-855ab81441b3.png)'
- en: Jonathan's greeting
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 乔纳森的问候
- en: Exercises
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try these out for more practice:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些以进行更多练习：
- en: Add a `UPROPERTY` function name for the NPC's name so that the name of the NPC
    is editable in blueprints, similar to the message that the NPC has for the player.
    Show the NPC's name in the output.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为NPC的名称添加一个`UPROPERTY`函数名称，以便在蓝图中可编辑NPC的名称，类似于NPC对玩家的消息。在输出中显示NPC的名称。
- en: Add a `UPROPERTY` function (type `UTexture2D*`) for the NPC's face texture.
    Draw the NPC's face beside its message in the output.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为NPC的面部纹理添加一个`UPROPERTY`函数（类型为`UTexture2D*`）。在输出中，将NPC的面部显示在其消息旁边。
- en: Render the player's HP as a bar (filled rectangle).
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将玩家的HP渲染为一条条形图（填充矩形）。
- en: Solutions
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add the following property to the `ANPC` class:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下属性添加到`ANPC`类中：
- en: '[PRE19]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, in `ANPC::Prox_Implementation`, change the string passed to the HUD to
    this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`ANPC::Prox_Implementation`中，将传递给HUD的字符串更改为这样：
- en: '[PRE20]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This way, the NPC's name will be attached to the message.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，NPC的名称将附加到消息上。
- en: 'Add the `this` property to the `ANPC` class:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为`ANPC`类添加`this`属性：
- en: '[PRE21]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then, you can select face icons to be attached to the NPC's face in blueprints.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在蓝图中选择要附加到NPC面部的面部图标。
- en: 'Attach a texture to your `struct Message`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 将纹理附加到您的`struct Message`：
- en: '[PRE22]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To render these icons, you need to add a call to `DrawTexture()` with the right
    texture passed in to it:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染这些图标，您需要添加一个调用`DrawTexture()`，并传入正确的纹理：
- en: '[PRE23]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Be sure to check whether the texture is valid before you render it. The icons
    should look similar to what is shown here, at the top of the screen:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染之前，请确保检查纹理是否有效。图标应该看起来与屏幕顶部所示的类似：
- en: '![](img/945c32ed-8d00-47bf-84c0-c8ed6a4f0b24.png)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![](img/945c32ed-8d00-47bf-84c0-c8ed6a4f0b24.png)'
- en: 'This is how a function to draw the player''s remaining health in a bar will
    look:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是绘制玩家剩余健康值的条形图的函数：
- en: '[PRE24]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You also need to add `Hp` and `MaxHp` to the Avatar class (you can just set
    default values for now for testing), and add the following to the top of the file:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要将`Hp`和`MaxHp`添加到Avatar类中（现在可以为测试设置默认值），并将以下内容添加到文件顶部：
- en: '[PRE25]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Summary
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went through a lot of material. We showed you how to create
    a character and display it on the screen, control your character with axis bindings,
    and create and display NPCs that can post messages to the HUD. It may seem daunting
    now, but it'll make sense once you get more practice.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们涉及了很多材料。我们向您展示了如何创建一个角色并在屏幕上显示它，如何使用轴绑定来控制您的角色，以及如何创建和显示可以向HUD发布消息的NPC。现在可能看起来令人生畏，但一旦您多练习就会明白。
- en: In the upcoming chapters, we will develop our game further by adding an inventory
    system and pickup items, as well as the code and the concept to account for what
    the player is carrying. Before we do that, though, in the next chapter we will
    perform an in-depth exploration of some of the UE4 container types.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过添加库存系统和拾取物品来进一步开发我们的游戏，以及为玩家携带物品的代码和概念。不过，在做这些之前，下一章我们将深入探讨一些UE4容器类型。
