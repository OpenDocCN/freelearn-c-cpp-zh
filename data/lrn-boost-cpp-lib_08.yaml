- en: Chapter 8. Date and Time Libraries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。日期和时间库
- en: This is a short chapter that shows you how to use different Boost libraries
    for performing basic date and time calculations. Most practical software use date
    and time measurements in some form. Applications compute current date and time
    to produce chronological logs of application activity. Specialized programs compute
    schedules for jobs based on complex scheduling policies, and wait for specific
    points in time, or time intervals to elapse. Sometimes, applications even monitor
    their own performance and speed of execution, taking remedial steps as needed
    or raising notifications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简短的章节，向您展示如何使用不同的Boost库执行基本的日期和时间计算。大多数实际软件都以某种形式使用日期和时间测量。应用程序计算当前日期和时间，以生成应用程序活动的时间日志。专门的程序根据复杂的调度策略计算作业的时间表，并等待特定的时间点或时间间隔过去。有时，应用程序甚至会监视自己的性能和执行速度，并在需要时采取补救措施或发出通知。
- en: 'In this chapter, we look at Boost libraries for performing date and time calculations,
    and measuring code performance. These topics are divided into the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍使用Boost库进行日期和时间计算以及测量代码性能。这些主题分为以下几个部分：
- en: Date and time calculations with Boost `Date Time`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost `Date Time`进行日期和时间计算
- en: Using Boost Chrono to measure time
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost Chrono测量时间
- en: Measuring program performance using Boost Timer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Boost Timer测量程序性能
- en: Date and time calculations with Boost Date Time
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost Date Time进行日期和时间计算
- en: Date and time calculations are important in many software applications, yet
    C++03 had limited support for manipulating dates and performing calculations with
    them. The Boost `Date Time` library provides a set of intuitive interfaces for
    representing dates, timestamps, durations, and time intervals. By allowing simple
    arithmetic operations involving dates, timestamps, durations, and supplementing
    them with a set of useful date/time algorithms, it enables fairly sophisticated
    time and calendar calculations using little code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间计算在许多软件应用程序中都很重要，但是C++03对于操作日期和执行计算的支持有限。Boost `Date Time`库提供了一组直观的接口，用于表示日期、时间戳、持续时间和时间间隔。通过允许涉及日期、时间戳、持续时间的简单算术运算，并补充一组有用的日期/时间算法，它可以使用很少的代码进行相当复杂的时间和日历计算。
- en: Dates from the Gregorian calendar
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公历中的日期
- en: 'The Gregorian calendar, also known as the Christian calendar, was introduced
    by Pope Gregory XIII in February 1582 and over the next few centuries, replaced
    the Julian calendar in the vast majority of the western world. The `Date_Time`
    library provides a set of types for representing dates and related quantities:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 公历，也称为基督教历，由教皇格里高利十三世于1582年2月引入，并在接下来的几个世纪内取代了儒略历在绝大多数西方世界的使用。`Date_Time`库提供了一组用于表示日期和相关数量的类型：
- en: '`boost::gregorian::date`: We use this type to represent a date in the Gregorian
    calendar.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::gregorian::date`：我们使用这种类型来表示公历中的日期。'
- en: '`boost::gregorian::date_duration`: In addition to dates, we also need to represent
    durations—the length of time between two given dates in the calendar—in the unit
    of days. For this, we use the type `boost::gregorian::date_duration`. It refers
    to the same type as `boost::gregorian::days`.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::gregorian::date_duration`：除了日期，我们还需要表示日期间的持续时间——以天为单位的两个给定日期之间的时间长度。为此，我们使用`boost::gregorian::date_duration`类型。它指的是与`boost::gregorian::days`相同的类型。'
- en: '`boost::date_period`: A fixed date period of the calendar starting at a given
    date and extending for a specific duration is represented using the type `boost::date_period`.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::date_period`：使用`boost::date_period`类型表示日历中从给定日期开始并延续一段特定持续时间的固定日期周期。'
- en: Creating date objects
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建日期对象
- en: 'We can create objects of type `boost::gregorian::date` using constituent parts
    of a date, namely the year, month, and day of the month. In addition, there are
    a number of factory functions that parse date strings in different formats to
    create objects of `date`. In the following example, we illustrate the different
    ways of creating `date` objects:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用日期的组成部分，即年份、月份和日期，创建`boost::gregorian::date`类型的对象。此外，还有许多工厂函数可以解析不同格式的日期字符串，以创建`date`对象。在下面的示例中，我们演示了创建`date`对象的不同方法：
- en: '**Listing 8.1: Using boost::gregorian::date**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单8.1：使用boost::gregorian::date**'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A default-constructed date represents an invalid date (line 7); the `is_not_a_date`
    member predicate returns true for such dates (line 8). We can construct dates
    from its constituent parts: year, month, and day. Months can be indicated using
    `enum` values named `Jan`, `Feb`, `Mar`, `Apr`, `May`, `Jun`, `Jul`, `Aug`, `Sep`,
    `Oct`, `Nov`, and `Dec`, which are abbreviated English names of the months of
    the year. Using special factory functions, dates can be constructed from other
    standard representations. We use the `boost::gregorian::from_uk_string` function
    to construct a `date` object from a string in the DD/MM/YYYY format, which is
    standard in UK (line 14). The `boost::gregorian::from_us_string` function is used
    to construct a `date` from a string in the MM/DD/YYYY format used in the US (line
    17). The function `boost::gregorian::from_simple_string` is used to construct
    a `date` from a string in the ISO 8601 YYYY-MM-DD format (line 15), and its undelimited
    form YYYYMMDD can be converted into a `date` object, using the `boost::gregorian::from_undelimited_string`
    function (line 16).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造的日期表示无效日期（第7行）；`is_not_a_date`成员谓词对于这样的日期返回true（第8行）。我们可以从其组成部分构造日期：年、月和日。月份可以使用名为`Jan`、`Feb`、`Mar`、`Apr`、`May`、`Jun`、`Jul`、`Aug`、`Sep`、`Oct`、`Nov`和`Dec`的`enum`值来表示，这些是年份的英文缩写。使用特殊的工厂函数，可以从其他标准表示中构造日期。我们使用`boost::gregorian::from_uk_string`函数从DD/MM/YYYY格式的字符串中构造一个`date`对象，这是英国的标准格式（第14行）。`boost::gregorian::from_us_string`函数用于从美国使用的MM/DD/YYYY格式的字符串中构造一个`date`（第17行）。`boost::gregorian::from_simple_string`函数用于从ISO
    8601 YYYY-MM-DD格式的字符串中构造一个`date`（第15行），并且其无分隔形式YYYYMMDD可以使用`boost::gregorian::from_undelimited_string`函数转换为`date`对象（第16行）。
- en: '**Clocks** provide a way to retrieve the current date and time on a system.
    Boost provides a couple of clocks for this purpose. The `day_clock` type provides
    the `local_day` (line 20) and `universal_day` (line 21) functions, which return
    the current date in the local and UTC time zones, which could be same or differ
    by a day, depending on the time zone and time of the day.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**时钟**提供了一种在系统上检索当前日期和时间的方法。Boost为此提供了几个时钟。`day_clock`类型提供了`local_day`（第20行）和`universal_day`（第21行）函数，它们返回本地和UTC时区的当前日期，这两者可能相同，也可能相差一天，这取决于时区和时间。'
- en: Using convenient accessor member functions like `day`, `month`, `year`, and
    `day_of_week`, we can get at parts of a `date` (lines 24-25).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方便的访问器成员函数，如`day`，`month`，`year`和`day_of_week`，我们可以获取`date`的部分（第24-25行）。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `Date_Time` library is not a header-only library, and in order to run examples
    in this section, they must be linked to the `libboost_date_time` library. On Unix,
    with g++, you can use the following command line to compile and link examples
    involving Boost Date Time:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date_Time`库不是一个仅包含头文件的库，为了在本节中运行示例，它们必须链接到`libboost_date_time`库。在Unix上，使用g++，您可以使用以下命令行来编译和链接涉及Boost
    Date Time的示例：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: See [Chapter 1](ch01.html "Chapter 1. Introducing Boost"), *Introducing Boost*,
    for more details.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参见[第1章](ch01.html "第1章。介绍Boost")*介绍Boost*。
- en: Handling date durations
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理日期持续时间
- en: 'The duration of time between two dates is represented by `boost::gregorian::date_duration`.
    In the following example, we compute time durations between dates, and add durations
    to dates or subtract durations from dates to derive new dates:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 两个日期之间的时间持续时间由`boost::gregorian::date_duration`表示。在下面的示例中，我们计算日期之间的时间持续时间，并将持续时间添加到日期或从日期中减去以得到新的日期。
- en: '**Listing 8.2: Basic date arithmetic**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单8.2：基本日期算术**'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We compute durations (which can be negative) as the difference of two dates
    (line 9), and print it in the unit of days (line 10). The `date_duration` object
    internally represents durations in unit of days. We can also use the types `boost::gregorian::weeks`,
    `boost::gregorian::months`, and `boost::gregorian::years` to construct `date_duration`
    objects in units of weeks, months, or years. Note that `boost::gregorian::days`
    and `boost::gregorian::date_duration` refer to the same types. We get new dates
    by adding durations to or subtracting them from dates (lines 13, 16).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算持续时间（可以是负数）作为两个日期的差异（第9行），并以天为单位打印出来（第10行）。`date_duration`对象在内部以天为单位表示持续时间。我们还可以使用类型`boost::gregorian::weeks`，`boost::gregorian::months`和`boost::gregorian::years`来构造以周、月或年为单位的`date_duration`对象。请注意，`boost::gregorian::days`和`boost::gregorian::date_duration`指的是相同的类型。我们通过将持续时间添加到日期或从日期中减去它们（第13、16行）来获得新的日期。
- en: Date periods
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期周期
- en: A period starting at a fixed date is represented by the type `boost::gregorian::date_period`.
    In the following example, we construct two date periods, a calendar year, and
    a US fiscal year. We calculate their overlap period, and then determine the date
    of the last Friday of each month in the overlapping period.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以固定日期开始的周期由类型`boost::gregorian::date_period`表示。在下面的示例中，我们构造了两个日期周期，一个是日历年，一个是美国财政年。我们计算它们的重叠期，然后确定重叠期内每个月的最后一个星期五的日期。
- en: '**Listing 8.3: Date periods and calendar calculations**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单8.3：日期周期和日历计算**'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We define date periods in terms of a start and an end date (lines 13, 14). We
    can check whether two periods overlap using the `intersects` member function of
    `date_period` (line 19), and obtain the overlap period using the `intersection`
    member function (line 20). We iterate over a period by creating a `month_iterator`
    at the start date (line 21) and iterating till the end date (line 23) using the
    preincrement operator (line 28). There are different kinds of iterators with different
    periods of iteration. We use `boost::gregorian::month_iterator` to iterate over
    successive months in the period. The `month_iterator` advances the date by a month,
    each time it is incremented. You can also use other iterators like `year_iterator`,
    `week_iterator`, and `day_iterator`, which increment the iterator by a year, a
    week, or a day at a time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据开始日期和结束日期定义日期周期（第13、14行）。我们可以使用`date_period`的`intersects`成员函数（第19行）检查两个周期是否重叠，并使用`intersection`成员函数（第20行）获取重叠期。我们通过在开始日期处创建一个`month_iterator`（第21行），并使用预增量运算符（第28行）迭代到结束日期（第23行）来遍历一个周期。有不同类型的迭代器，具有不同的迭代周期。我们使用`boost::gregorian::month_iterator`来迭代周期内连续的月份。`month_iterator`每次递增时都会将日期提前一个月。您还可以使用其他迭代器，如`year_iterator`，`week_iterator`和`day_iterator`，它们分别以年、周或天为单位递增迭代器。
- en: For each month in the period, we want to find the date of the last Friday in
    that month. The `Date Time` library has some interesting algorithm classes for
    calendar calculations of this sort. We use the `boost::gregorian::last_day_of_the_week_in_month`
    algorithm for performing such calculations as the date of the last Friday of a
    month. We construct an object of `last_day_of_the_week_in_month`, the constructor
    arguments being the day of the week (Friday) and the month (lines 24, 25). We
    then call its `get_date` member function, passing to it the particular year for
    which we want the date (line 26).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于周期中的每个月，我们想要找到该月的最后一个星期五的日期。`Date Time`库具有一些有趣的算法类，用于此类日历计算。我们使用`boost::gregorian::last_day_of_the_week_in_month`算法来执行这样的计算，以确定月份的最后一个星期五的日期。我们构造了一个`last_day_of_the_week_in_month`对象，构造函数参数是星期几（星期五）和月份（第24、25行）。然后我们调用它的`get_date`成员函数，将特定年份传递给它（第26行）。
- en: Posix time
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Posix时间
- en: The `Date_Time` library also provides a set of types for representing time points,
    durations, and periods.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date_Time`库还提供了一组类型，用于表示时间点、持续时间和周期。'
- en: '`boost::posix_time::ptime`: A specific point in time, or a **time point**,
    is represented by the type `boost::posix_time::ptime`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::posix_time::ptime`：特定的时间点，或者**时间点**，由类型`boost::posix_time::ptime`表示。'
- en: '`boost::posix_time::time_duration`: Like date durations, the length of time
    between two time points is called a **time duration** and is represented by the
    type `boost::posix_time::time_duration`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::posix_time::time_duration`：与日期持续时间一样，两个时间点之间的时间长度称为**时间持续时间**，并由类型`boost::posix_time::time_duration`表示。'
- en: '`boost::posix_time::time_period`: A fixed interval starting at a specific time
    point and ending at another is called a **time period** and is represented by
    the type `boost::posix_time::time_period`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::posix_time::time_period`：从特定时间点开始的固定间隔，到另一个时间点结束，称为**时间段**，由类型`boost::posix_time::time_period`表示。'
- en: These types and the operations on them together define a **time system**. Posix
    Time uses `boost::gregorian::date` to represent the date part of time points.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型及其上的操作一起定义了一个**时间系统**。Posix Time使用`boost::gregorian::date`来表示时间点的日期部分。
- en: Constructing time points and durations
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造时间点和持续时间
- en: 'We can create an instance of `boost::posix_time::ptime` from its constituent
    parts, that is, date, hours, minutes, seconds, and so on or use factory functions
    that parse timestamp strings. In the following example, we show different ways
    in which we can create `ptime` objects:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从其组成部分，即日期、小时、分钟、秒等创建`boost::posix_time::ptime`的实例，或者使用解析时间戳字符串的工厂函数。在以下示例中，我们展示了创建`ptime`对象的不同方式：
- en: '**Listing 8.4: Using boost::posix_time**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 清单8.4：使用boost::posix_time
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Just as with date objects, a default-constructed `ptime` object (line 9) is
    not a valid time point (line 10). There are clocks that can be used to derive
    the current time of the day, for example, `second_clock` and `microsec_clock`,
    which give the time with second or microsecond units. Calling the `local_time`
    and `universal_time` functions (line 13) on these clocks returns the current date
    and time in the local and UTC time zones respectively.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就像日期对象一样，默认构造的`ptime`对象（第9行）不是一个有效的时间点（第10行）。有时钟可以用来推导一天中的当前时间，例如，`second_clock`和`microsec_clock`，它们分别以秒或微秒单位给出时间。在这些时钟上调用`local_time`和`universal_time`函数（第13行）将返回本地和UTC时区中的当前日期和时间。
- en: The `from_time_t` factory function is passed the Unix time, which is the number
    of seconds elapsed since the Unix epoch (January 1, 1970 00:00:00 UTC), and constructs
    a `ptime` object representing that point in time (line 14). The C library function
    `time`, when passed 0, returns the current Unix time in UTC time zone.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`from_time_t`工厂函数传递Unix时间，即自Unix纪元（1970年1月1日00:00:00 UTC）以来经过的秒数，并构造一个表示该时间点的`ptime`对象（第14行）。当传递0时，C库函数`time`返回UTC时区中的当前Unix时间。'
- en: The duration between two time points, which can be negative, is computed as
    the difference between two time points (line 24). It can be streamed to an output
    stream for printing the duration, by default, in terms of hours, minutes, seconds,
    and fractional seconds. Using accessor functions `hours`, `minutes`, `seconds`,
    and `fractional_seconds`, we can get the relevant parts of a duration. Or we can
    convert the entire duration to a second or subsecond unit using the accessors
    `total_seconds`, `total_milliseconds`, `total_microseconds`, and `total_nanoseconds`
    (line 26).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 两个时间点之间的持续时间，可以是负数，是通过计算两个时间点之间的差值来计算的（第24行）。它可以被流式传输到输出流中，以默认方式打印持续时间，以小时、分钟、秒和小数秒为单位。使用访问器函数`hours`、`minutes`、`seconds`和`fractional_seconds`，我们可以获取持续时间的相关部分。或者我们可以使用访问器`total_seconds`、`total_milliseconds`、`total_microseconds`和`total_nanoseconds`将整个持续时间转换为秒或亚秒单位（第26行）。
- en: We can create a `ptime` object from a Gregorian date and a duration of type
    `boost::posix_time::time_duration` (lines 18-20). We can use the shim types `hours`,
    `minutes`, `seconds`, `microseconds`, and so on in the `boost::posix_time` namespace
    to generate durations of type `boost::posix_time::time_duration` in appropriate
    units and combine them using `operator+`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一个公历日期和一个类型为`boost::posix_time::time_duration`的持续时间对象创建一个`ptime`对象（第18-20行）。我们可以在`boost::posix_time`命名空间中使用shim类型`hours`、`minutes`、`seconds`、`microseconds`等来生成适当单位的`boost::posix_time::time_duration`类型的持续时间，并使用`operator+`将它们组合起来。
- en: We can construct a `ptime` object from just a `boost::gregorian::date` object
    (line 28). This represents the time at midnight on the given date. We can use
    factory functions to create `ptime` objects from different string representations
    (lines 29-30). The function `time_from_string` is used to construct an instance
    of `ptime` from a timestamp string in "YYYY-MM-DD hh:mm:ss.xxx…" format, in which
    the date and time parts are separated by a whitespace (line 29). The function
    `from_iso_string` is used to construct a `ptime` instance from a non-delimited
    string in the "YYYYMMDDThhmmss.xxx…" format, where an uppercase T separates the
    date and time parts (line 30). In both cases, the minutes, seconds, and fractional
    seconds are optional and are taken to be zero if not specified. The fractional
    seconds can follow the seconds, separated by a decimal point. These formats are
    locale dependent. For example, in several European locales, a comma is used instead
    of the decimal point.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以仅从一个`boost::gregorian::date`对象构造一个`ptime`对象（第28行）。这代表了给定日期的午夜时间。我们可以使用工厂函数从不同的字符串表示中创建`ptime`对象（第29-30行）。函数`time_from_string`用于从“YYYY-MM-DD
    hh:mm:ss.xxx…”格式的时间戳字符串构造一个`ptime`实例，在该格式中，日期和时间部分由空格分隔（第29行）。函数`from_iso_string`用于从“YYYYMMDDThhmmss.xxx…”格式的无分隔字符串构造一个`ptime`实例，其中大写T分隔日期和时间部分（第30行）。在这两种情况下，分钟、秒和小数秒是可选的，如果未指定，则被视为零。小数秒可以跟在秒后，用小数点分隔。这些格式是与地区相关的。例如，在几个欧洲地区，使用逗号代替小数点。
- en: We can stream `ptime` objects to output streams like `std::cout` (line 32).
    We can also convert `ptime` instances to `string` using conversion functions like
    `to_simple_string` and `to_iso_string` (lines 32-33). In English locales, the
    `to_simple_string` function converts it to the "YYYY-MM-DD hh:mm:ss.xxx…" format.
    Notice that this is the same format expected by `time_from_string` and is also
    the format used when `ptime` is streamed. The `to_iso_string` function converts
    it to the "YYYYMMDDThhmmss.xxx…" format, same as that expected by `from_iso_string`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`ptime`对象流式输出到输出流，比如`std::cout`（第32行）。我们还可以使用转换函数，比如`to_simple_string`和`to_iso_string`（第32-33行），将`ptime`实例转换为`string`。在英文环境中，`to_simple_string`函数将其转换为"YYYY-MM-DD
    hh:mm:ss.xxx…"格式。请注意，这是`time_from_string`预期的相同格式，也是在流式输出`ptime`时使用的格式。`to_iso_string`函数将其转换为"YYYYMMDDThhmmss.xxx…"格式，与`from_iso_string`预期的格式相同。
- en: Resolution
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分辨率
- en: 'The smallest duration that can be represented using a time system is called
    its resolution. The precision with which time can be represented on a particular
    system, and therefore, the number of digits of the fractional seconds that are
    significant, depends on the resolution of the time system. The default resolution
    used by Posix Time is microsecond (10^(-6) seconds), that is, it cannot represent
    durations shorter than a microsecond and therefore cannot differentiate between
    two time points less than a microsecond apart. The following example demonstrates
    how to obtain and interpret the resolution of a time system:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 时间系统可以表示的最小持续时间称为其分辨率。时间在特定系统上表示的精度，因此，有效的小数秒数取决于时间系统的分辨率。Posix时间使用的默认分辨率是微秒（10^(-6)秒），也就是说，它不能表示比微秒更短的持续时间，因此不能区分相隔不到一微秒的两个时间点。以下示例演示了如何获取和解释时间系统的分辨率：
- en: '**Listing 8.5: Time ticks and resolution**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单8.5：时间刻度和分辨率**'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `resolution` static function of the `time_duration` class returns the resolution
    as an enumerated constant (line 7); we interpret this `enum` and print a string
    to indicate the resolution (lines 7-32).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`time_duration`类的`resolution`静态函数返回一个枚举常量作为分辨率（第7行）；我们解释这个`enum`并打印一个字符串来指示分辨率（第7-32行）。'
- en: The `num_fractional_digits` static function returns the number of significant
    digits of the fractional second (line 33); on a system with microsecond resolution,
    this would be 6, and on a system with nanosecond resolution, this would be 9\.
    The `ticks_per_second` static function converts 1 second to the smallest representable
    time unit on the system (line 35); on a system with microsecond resolution, this
    would be 106, and on a system with nanosecond resolution, this would be 109.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`num_fractional_digits`静态函数返回小数秒的有效数字位数（第33行）；在具有微秒分辨率的系统上，这将是6，在具有纳秒分辨率的系统上，这将是9。`ticks_per_second`静态函数将1秒转换为系统上最小可表示的时间单位（第35行）；在具有微秒分辨率的系统上，这将是10^6，在具有纳秒分辨率的系统上，这将是10^9。'
- en: Time periods
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间段
- en: 'Just as with dates, we can represent fixed time periods using `boost::posix_time::time_period`.
    Here is a short example that shows how you can create time periods and compare
    different time periods:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与日期一样，我们可以使用`boost::posix_time::time_period`表示固定的时间段。以下是一个简短的示例，演示了如何创建时间段并比较不同的时间段：
- en: '**Listing 8.6: Using time periods**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单8.6：使用时间段**'
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We create a time period called `starts_now` that starts at the current instant
    and extends for 2 hours into the future. For this, we use the two-argument constructor
    of `time_period`, passing it the current timestamp and a duration of 2 hours (line
    11). Using the `length` member function of `time_period`, we verify that the length
    of the period is indeed 2 hours (line 13).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`starts_now`的时间段，它从当前时刻开始，持续2小时。为此，我们使用了`time_period`的两个参数构造函数，传递了当前时间戳和2小时的持续时间（第11行）。使用`time_period`的`length`成员函数，我们验证了该时间段的长度确实为2小时（第13行）。
- en: 'We create two more time periods: `starts_in_1` that starts 1 hour later and
    extends for a duration of 3 hours (line 16), and `starts_in_3` that starts 3 hours
    later and extends for 1 hour (line 20). The member functions `begin` and `last`
    of `time_period` return the first and last time points in the period (lines 26-27).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了另外两个时间段：`starts_in_1`从1小时后开始，持续3小时（第16行），`starts_in_3`从3小时后开始，持续1小时（第20行）。`time_period`的`begin`和`last`成员函数返回时间段中的第一个和最后一个时间点（第26-27行）。
- en: We express the relationships between the three time periods, `starts_now`, `starts_in_1`,
    and `starts_in_3`, using relational operators and two member functions called
    `intersects` and `contains`. Clearly, the first hour of `starts_in_1` overlaps
    with the last hour of `starts_now`, so we assert that `starts_now` and `starts_in_1`
    intersect with each other (line 35). The last hour of `starts_in_1` coincides
    with the entire period `starts_in_3`, so we assert that `starts_in_1` contains
    `starts_in_3` (line 37). But `starts_now` and `starts_in_3` do not overlap; therefore,
    we assert that `starts_now` and `starts_in_3` do not intersect (line 32).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用关系运算符和称为`intersects`和`contains`的两个成员函数来表示三个时间段`starts_now`，`starts_in_1`和`starts_in_3`之间的关系。显然，`starts_in_1`的第一个小时与`starts_now`的最后一个小时重叠，因此我们断言`starts_now`和`starts_in_1`相交（第35行）。`starts_in_1`的最后一个小时与整个时间段`starts_in_3`重合，因此我们断言`starts_in_1`包含`starts_in_3`（第37行）。但是`starts_now`和`starts_in_3`不重叠；因此，我们断言`starts_now`和`starts_in_3`不相交（第32行）。
- en: The relational `operator<` is defined such that for two time periods `tp1` and
    `tp2`, the condition `tp1 < tp2` holds if and only if `tp1.last() < tp2.begin()`.
    Likewise, `operator>` is defined such that the condition `tp1 > tp2` holds if
    and only if `tp1.begin() > tp2.last()`. These definitions imply that `tp1` and
    `tp2` are disjoint. Thus, for the disjoint `time_period`s `starts_now` and `starts_in_3`,
    the relation `starts_now < starts_in_3` holds (line 31). These relations do not
    make sense for overlapping time periods.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符`operator<`被定义为对于两个时间段`tp1`和`tp2`，条件`tp1 < tp2`成立当且仅当`tp1.last() < tp2.begin()`。同样，`operator>`被定义为条件`tp1
    > tp2`成立当且仅当`tp1.begin() > tp2.last()`。这些定义意味着`tp1`和`tp2`是不相交的。因此，对于不相交的`time_period`
    `starts_now`和`starts_in_3`，关系`starts_now < starts_in_3`成立（第31行）。这些关系对于重叠的时间段是没有意义的。
- en: Time iterator
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间迭代器
- en: 'We can iterate over a time period using `boost::posix_time::time_iterator`,
    not unlike how we used `boost::gregorian::date_iterator`. The following example
    shows this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`boost::posix_time::time_iterator`来遍历一个时间段，类似于我们使用`boost::gregorian::date_iterator`的方式。下面的例子展示了这一点：
- en: '**Listing 8.7: Iterating over a time period**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单8.7：遍历一个时间段**'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding example prints the timestamp for each completed hour in the current
    day. We instantiate a `time_iterator` (line 12), passing it the time point from
    where to begin the iteration (`start_of_day`) and the duration added for each
    increment of the iterator (1 hour). We iterate till the current time, incrementing
    printing the timestamp obtained by dereferencing the iterator (line 15) and incrementing
    the iterator (line 13). Notice that in the expression `iter < now`, we compare
    the iterator with a time point to decide when to stop iteration—a peculiar property
    of `posix_time::time_iterator`, which is not shared with other iterators.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子打印了当天每个完成的小时的时间戳。我们实例化了一个`time_iterator`（第12行），将开始迭代的时间点(`start_of_day`)和迭代器每次增加的持续时间（1小时）传递给它。我们迭代直到当前时间，通过解引用迭代器获得时间戳（第15行）并增加迭代器（第13行）。请注意，在表达式`iter
    < now`中，我们将迭代器与时间点进行比较，以决定何时停止迭代——这是`posix_time::time_iterator`的一个特殊属性，与其他迭代器不同。
- en: Using Chrono to measure time
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Chrono来测量时间
- en: Boost Chrono is a library for time calculations having some overlapping functionality
    with the Posix Time part of the `Date Time` library. Like Posix Time, Chrono too
    uses the notion of time points and durations. Chrono does not deal with dates.
    It is a newer library than `Date Time`, and implements the facilities proposed
    in a paper from the C++ Standards Committee working group (WG21). Parts of that
    proposal made it to the C++11 Standard Library as the `Chrono` library, and much
    of the discussion on Boost Chrono also applies to Chrono Standard Library (`std::chrono`).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Chrono是一个用于时间计算的库，与`Date Time`库的Posix Time部分有一些重叠的功能。与Posix Time一样，Chrono也使用时间点和持续时间的概念。Chrono不处理日期。它比`Date
    Time`库更新，实现了C++标准委员会工作组(WG21)的一份提案中提出的设施。该提案的部分内容成为了C++11标准库的一部分，即`Chrono`库，Boost
    Chrono上的许多讨论也适用于Chrono标准库(`std::chrono`)。
- en: Durations
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续时间
- en: 'A duration represents an interval of time. The duration has a numeric magnitude
    and must be expressed in units of time. The `boost::chrono::duration` template
    is used to represent any such duration and is declared as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间表示一段时间间隔。持续时间具有数值大小，并且必须用时间单位表示。`boost::chrono::duration`模板用于表示任何这样的持续时间，并声明如下：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Representation` type parameter identifies the underlying arithmetic type
    used for the magnitude of durations. The `Period` type parameter identifies tick
    period, which is the magnitude of one unit of time used to measure the duration.
    The period is usually expressed as a ratio or fraction of 1 second, using a template
    called `boost::ratio`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Representation`类型参数标识用于持续时间大小的基础算术类型。`Period`类型参数标识滴答周期，即用于测量持续时间的一个时间单位的大小。该周期通常表示为1秒的比例或分数，使用一个名为`boost::ratio`的模板。'
- en: 'Thus, if we want to express a duration in hundredths of seconds (centiseconds),
    we can use `int64_t` as the underlying type, and the tick period can be represented
    using the ratio (1/100) because the tick period is a hundredth of a second. Using
    `boost::ratio`, we can specialize `duration` to express centisecond intervals
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想要以百分之一秒（centiseconds）表示持续时间，我们可以使用`int64_t`作为基础类型，并且可以使用比例(1/100)来表示滴答周期，因为滴答周期是一百分之一秒。使用`boost::ratio`，我们可以特化`duration`来表示百分之一秒的间隔，如下所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We create a `typedef` called `centiseconds` and pass `1000`, which is the number
    of centiseconds in the duration, as a constructor argument. `1000` centiseconds
    amounts to (1/100)*1000 seconds, that is, 10 seconds.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`centiseconds`的`typedef`，并将`1000`作为构造函数参数传递进去，这是持续时间中的百分之一秒的数量。`1000`百分之一秒相当于(1/100)*1000秒，也就是10秒。
- en: The `boost::ratio` template is used to construct a type representing a rational
    number, that is, a ratio of two integers. We specialize `ratio` by passing the
    numerator and denominator of our rational number as its two non-type template
    arguments, in that order. The second argument defaults to 1; therefore, to express
    an integer, say 100, we can simply write `boost::ratio<100>` instead of `boost::ratio<100,
    1>`. The expression `boost::ratio<100>` does not represent a value 100 but a type
    encapsulating the rational number 100.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::ratio`模板用于构造表示有理数的类型，即两个整数的比例。我们通过将我们的有理数的分子和分母作为两个非类型模板参数来特化`ratio`，按照这个顺序。第二个参数默认为1；因此，要表示一个整数，比如100，我们可以简单地写成`boost::ratio<100>`，而不是`boost::ratio<100,
    1>`。表达式`boost::ratio<100>`并不代表值100，而是封装了有理数100的类型。'
- en: 'The `Chrono` library already provides a set of predefined specializations of
    `duration` for constructing durations expressed in commonly used time units. These
    are:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chrono`库已经提供了一组预定义的`duration`的特化，用于构造以常用时间单位表示的持续时间。这些包括：'
- en: '`boost::chrono::hours` (tick period = `boost::ratio<3600>`)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::chrono::hours`（滴答周期=`boost::ratio<3600>`）'
- en: '`boost::chrono::minutes` (tick period = `boost::ratio<60>`)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::chrono::minutes`（滴答周期=`boost::ratio<60>`）'
- en: '`boost::chrono::seconds` (tick period = `boost::ratio<1>`)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::chrono::seconds`（滴答周期 = `boost::ratio<1>`）'
- en: '`boost::chrono::milliseconds` (tick period = `boost::ratio<1, 1000>`)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::chrono::milliseconds`（滴答周期 = `boost::ratio<1, 1000>`）'
- en: '`boost::chrono::microseconds` (tick period = `boost::ratio<1, 1000000>`)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::chrono::microseconds`（滴答周期 = `boost::ratio<1, 1000000>`）'
- en: '`boost::chrono::nanoseconds` (tick period = `boost::ratio<1, 1000000000>`)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boost::chrono::nanoseconds`（滴答周期 = `boost::ratio<1, 1000000000>`）'
- en: Duration arithmetic
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持续时间算术
- en: 'Durations can be added and subtracted, and durations in different units can
    be combined to form other durations. Durations in larger units can be implicitly
    converted to durations in smaller units. Implicit conversion from smaller to larger
    units is only possible if you are using a floating point representation; with
    integral representations, such conversions would incur a loss of precision. To
    handle this, we must use a function akin to a casting operator for explicit conversions
    from smaller to larger units with integral representations:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间可以相加和相减，并且不同单位的持续时间可以组合成其他持续时间。较大单位的持续时间可以隐式转换为较小单位的持续时间。如果使用浮点表示，从较小单位到较大单位的隐式转换是可能的；对于整数表示，这样的转换会导致精度损失。为了处理这个问题，我们必须使用类似于强制转换运算符的函数，进行从较小单位到较大单位的显式转换：
- en: '**Listing 8.8: Using chrono durations**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单8.8：使用chrono持续时间**'
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This example illustrates the different operations you can perform with durations.
    The `boost/chrono/chrono.hpp` header includes most of the Boost Chrono facilities
    we need (line 1). We first create a `duration` of 10 centiseconds (line 9). The
    `count` member function returns the tick count of the duration, that is, the number
    of time units in the duration in the chosen unit, centiseconds (line 10). We can
    directly stream a duration to an output stream (line 11) but need to include the
    additional header `boost/chrono/chrono_io.hpp` for accessing these operators (line
    2). Streaming `csec` prints the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了您可以执行的不同操作与持续时间。`boost/chrono/chrono.hpp`头文件包括了我们需要的大部分Boost Chrono设施（第1行）。我们首先创建一个10厘秒的`duration`（第9行）。`count`成员函数返回持续时间的滴答计数，即持续时间中所选单位的时间单位数，厘秒（第10行）。我们可以直接将持续时间流式传输到输出流（第11行），但需要包含额外的头文件`boost/chrono/chrono_io.hpp`来访问这些操作符（第2行）。流式传输`csec`打印如下：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Boost Ratio provides the appropriate SI unit prefixes based on the time unit
    used by the duration, and these are used to intelligently print the appropriate
    SI prefix. This is not available in the C++11 Standard Library Chrono implementation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Ratio根据持续时间使用的时间单位提供适当的SI单位前缀，并用于智能打印适当的SI前缀。这在C++11标准库Chrono实现中不可用。
- en: We create second and millisecond durations using the appropriate duration specializations,
    and compute their sum using an overloaded `operator+` (lines 13, 14). The sum
    of a second and a millisecond duration is a millisecond duration. Implicit conversion
    of a duration in milliseconds to a duration in a larger unit like seconds would
    involve loss of precision when the representation of the larger type is an integral
    type. Hence, such implicit conversions are not supported (line 15). For example,
    10 seconds + 20 milliseconds would be computed as 10020 milliseconds. The `boost:::chrono::seconds`
    `typedef` uses a signed integral type representation, and to express 10020 milliseconds
    in seconds, the 20 milliseconds would need to be implicitly rounded off.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用适当的持续时间特化创建秒和毫秒持续时间，并使用重载的`operator+`计算它们的和（第13、14行）。秒和毫秒持续时间的和是毫秒持续时间。毫秒持续时间隐式转换为秒单位的持续时间会导致精度损失，因为较大类型的表示是整数类型。因此，不支持这种隐式转换（第15行）。例如，10秒+20毫秒将计算为10020毫秒。`boost:::chrono::seconds`
    `typedef`使用带符号整数类型表示，要将10020毫秒表示为秒，20毫秒需要被隐式四舍五入。
- en: We use the `duration_cast` function template, akin to C++ cast operators, to
    perform this conversion (lines 20-21), making the intent explicit. The `duration_cast`
    will effect the rounding off. On the other hand, a duration in seconds can always
    be implicitly converted to a duration in milliseconds, as there is no loss in
    precision (line 17).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`duration_cast`函数模板，类似于C++转换运算符，执行这种转换（第20-21行），使意图明确。`duration_cast`将进行四舍五入。另一方面，秒单位的持续时间总是可以隐式转换为毫秒单位的持续时间，因为没有精度损失（第17行）。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `Chrono` library is a separately-built library, which also depends on Boost
    System library. Thus, we must link the examples in this section to `libboost_system`.
    On Unix with g++, you can use the following command line to compile and link examples
    involving Boost Chrono:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chrono`库是一个单独构建的库，也依赖于Boost System库。因此，我们必须将本节中的示例链接到`libboost_system`。在Unix上使用g++，您可以使用以下命令行来编译和链接涉及Boost
    Chrono的示例：'
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For Boost libraries installed at nonstandard locations, refer to [Chapter 1](ch01.html
    "Chapter 1. Introducing Boost"), *Introducing Boost*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非标准位置安装的Boost库，请参阅[第1章](ch01.html "第1章。介绍Boost")*介绍Boost*。
- en: 'If we specialized the duration to represent seconds using a `double` instead
    of a signed integer, then things will be different. The following code will compile
    because the `double` representation would be able to accommodate fractional parts:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将持续时间专门化为使用`double`表示秒，而不是带符号整数，那么情况将会有所不同。以下代码将编译，因为`double`表示将能够容纳小数部分：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We do not cover Boost Ratio in detail in this book, but this chapter introduces
    enough details needed for the purposes of dealing with Boost Chrono. Additionally,
    you can get at the parts of a ratio and print a ratio as a rational number or
    an SI prefix, where that makes sense. The following code illustrates this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中没有详细介绍Boost Ratio，但本章介绍了处理Boost Chrono所需的足够细节。此外，您可以访问比率的部分，并将比率打印为有理数或SI前缀，如果有意义的话。以下代码说明了这一点：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note how we use the `ratio_string` template and its prefix member function
    to print SI prefixes. The code prints the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用`ratio_string`模板及其前缀成员函数来打印SI前缀。代码打印如下：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `std::ratio` template in the C++11 Standard Library corresponds to Boost
    Ratio and is used by `std::chrono`. There is no `ratio_string` in the Standard
    Library and therefore, SI prefix printing is absent.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: C++11标准库中的`std::ratio`模板对应于Boost Ratio，并被`std::chrono`使用。标准库中没有`ratio_string`，因此缺少SI前缀打印。
- en: Clocks and time points
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时钟和时间点
- en: A time point is a fixed point in time as opposed to a duration. Given a time
    point, we can add or subtract a duration from it to derive another time point.
    An epoch is a reference time point in some time system that can be combined with
    durations to define other time points. The most famous epoch is the Unix or POSIX
    epoch January 1, 1970 00:00:00 UTC.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 时间点是时间的固定点，而不是持续时间。给定一个时间点，我们可以从中添加或减去一个持续时间，以得到另一个时间点。时代是某个时间系统中的参考时间点，可以与持续时间结合，以定义其他时间点。最著名的时代是Unix或POSIX时代，即1970年1月1日00:00:00
    UTC。
- en: 'Boost Chrono provides several clocks for the purpose of measuring time in different
    contexts. A clock has the following associated members:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Chrono提供了几种时钟，用于在不同的上下文中测量时间。时钟具有以下关联成员：
- en: A typedef called `duration`, which represents the smallest duration that can
    be expressed using the clock
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`duration`的typedef，表示使用该时钟可以表示的最小持续时间
- en: A typedef called `time_point`, which is the type used to represent time points
    for that clock
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`time_point`的typedef，用于表示该时钟的时间点
- en: A static member function `now`, which returns the current time point
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个静态成员函数`now`，返回当前时间点
- en: 'Boost Chrono defines several clocks, some of which may or may not be available
    on your system:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Chrono定义了几种时钟，其中一些可能在您的系统上可用，也可能不可用：
- en: The `system_clock` type represents the wall clock or system time.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system_clock`类型表示壁钟或系统时间。'
- en: The `steady_clock` type represents a monotonic time system, which means that
    if the `now` function is called twice serially, the second call will always return
    a time point later than what the first call returned. This is not guaranteed for
    `system_clock`. The `steady_clock` type is available if and only if the `BOOST_CHRONO_HAS_STEADY_CLOCK`
    preprocessor macro is defined.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`steady_clock`类型表示一个单调时间系统，这意味着如果连续调用`now`函数，第二次调用将始终返回比第一次调用返回的时间点晚的时间点。这对于`system_clock`不能保证。只有在定义了`BOOST_CHRONO_HAS_STEADY_CLOCK`预处理宏时，才可用`steady_clock`类型。'
- en: The `high_resolution_clock` type is defined to be a `steady_clock` if it is
    available or else it is defined to be a `system_clock`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可用，`high_resolution_clock`类型被定义为`steady_clock`，否则被定义为`system_clock`。
- en: 'The preceding clocks are available as part of `std::chrono` as well. They use
    an implementation-defined epoch and provide functions to convert between `time_point`
    and Unix time (`std::time_t`). The following example illustrates how clocks and
    time points are used:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的时钟也可以作为`std::chrono`的一部分使用。它们使用一个实现定义的时代，并提供了在`time_point`和Unix时间(`std::time_t`)之间转换的函数。以下示例说明了时钟和时间点的使用方式：
- en: '**Listing 8.9: Using chrono system_clock**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单8.9：使用chrono system_clock**'
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, we first print the tick period of the duration associated with
    `system_clock`. The `system_clock::period` is a typedef for `system_clock::duration::period`
    and is the `boost::ratio` type representing the tick period of the duration associated
    with `system_clock` (line 8). We pass it to `boost::ratio_string`, and use the
    `prefix` member function to print the correct SI prefix (lines 9-10).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先打印与`system_clock`关联的持续时间的滴答周期。`system_clock::period`是`system_clock::duration::period`的一个typedef，表示与`system_clock`关联的持续时间的滴答周期（第8行）。我们将其传递给`boost::ratio_string`，并使用`prefix`成员函数打印正确的SI前缀（第9-10行）。
- en: 'It constructs two time points: a default-constructed time point for `system_clock`
    that represents the epoch of the clock (line 12), and the current time returned
    by the `now` function provided by the `system_clock` (lines 13-14). We then print
    the epoch (line 16), followed by the current time (line 17). Time points are printed
    as the number of time units since the epoch. Note that we use the `time_point_cast`
    function to convert the current time to hours since the epoch. The preceding code
    prints the following on my system:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它构造了两个时间点：一个用于`system_clock`的默认构造时间点，表示时钟的时代（第12行），以及由`system_clock`提供的`now`函数返回的当前时间（第13-14行）。然后我们打印时代（第16行），然后是当前时间（第17行）。时间点被打印为自时代以来的时间单位数。请注意，我们使用`time_point_cast`函数将当前时间转换为自时代以来的小时数。前面的代码在我的系统上打印如下：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Boost Chrono also provides the following clocks, none of which are available
    as part of the C++ Standard Library Chrono:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Boost Chrono还提供了以下时钟，这些时钟都不作为C++标准库Chrono的一部分：
- en: The `process_real_cpu_clock` type for measuring the total time since a program
    started.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process_real_cpu_clock`类型用于测量程序启动以来的总时间。'
- en: The `process_user_cpu_clock` type for measuring the time a program runs for
    in the user space.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process_user_cpu_clock`类型用于测量程序在用户空间运行的时间。'
- en: The `process_system_cpu` type for measuring the time the kernel runs some code
    on behalf of the program.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process_system_cpu`类型用于测量内核代表程序运行某些代码的时间。'
- en: The `thread_clock` type for measuring the total time for which a particular
    thread is scheduled. This clock is available if and only if the `BOOST_CHRONO_HAS_THREAD_CLOCK`
    preprocessor macro is defined.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread_clock`类型用于测量特定线程调度的总时间。只有在定义了`BOOST_CHRONO_HAS_THREAD_CLOCK`预处理宏时才可用此时钟。'
- en: The process clocks are available if and only if the `BOOST_CHRONO_HAS_PROCESS_CLOCKS`
    preprocessor macro is defined. These clocks can be used akin to the system clocks
    but their epochs are at program start-up for CPU clocks, or thread start-up for
    the thread clocks.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在定义了`BOOST_CHRONO_HAS_PROCESS_CLOCKS`预处理宏时，才可用处理时钟。这些时钟可以类似于系统时钟使用，但它们的时代是CPU时钟的程序启动时，或者线程时钟的线程启动时。
- en: Measuring program performance using Boost Timer
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Boost Timer测量程序性能
- en: As programmers, we often need to measure performance of a section of code. While
    there are several excellent profiling tools available for this purpose, sometimes,
    being able to instrument our own code is both simple and more precise. The Boost
    Timer library provides an easy-to-use, portable interface for measuring the execution
    times and reporting them by instrumenting your code. It is a separately compiled
    library, not header-only, and internally uses Boost Chrono.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们经常需要测量代码段的性能。虽然有几种出色的性能分析工具可用于此目的，但有时，能够对我们自己的代码进行仪器化既简单又更精确。Boost Timer库提供了一个易于使用的、可移植的接口，用于通过仪器化代码来测量执行时间并报告它们。它是一个单独编译的库，不是仅头文件，并且在内部使用Boost
    Chrono。
- en: cpu_timer
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cpu_timer
- en: The `boost::timer::cpu_timer` class is used to measure the execution time of
    a section of code. In the following example, we write a function that reads the
    contents of a file and returns it in a dynamic array wrapped in a `unique_ptr`
    (see [Chapter 3](ch03.html "Chapter 3. Memory Management and Exception Safety"),
    *Memory Management and Exception Safety*). It also calculates and prints the time
    taken to read the file using `cpu_timer`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::timer::cpu_timer`类用于测量代码段的执行时间。在下面的示例中，我们编写一个函数，该函数读取文件的内容并将其包装在`unique_ptr`中返回（参见[第3章](ch03.html
    "第3章。内存管理和异常安全")*内存管理和异常安全*）。它还使用`cpu_timer`计算并打印读取文件所用的时间。'
- en: '**Listing 8.10: Using cpu_timer**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单8.10：使用cpu_timer**'
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We create an instance of `cpu_timer` at the start of the section of code (line
    20), which starts the timer. At the end of the section, we call the `stop` member
    function on the `cpu_timer` object (line 22), which stops the timer. We call the
    `format` member function to obtain a readable representation of the elapsed time
    and print it to the standard error (line 25). Calling this function with a file
    name, prints the following to the standard input:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码段的开始处创建一个`cpu_timer`实例（第20行），它启动计时器。在代码段结束时，我们在`cpu_timer`对象上调用`stop`成员函数（第22行），它停止计时器。我们调用`format`成员函数以获得可读的经过时间表示，并将其打印到标准错误（第25行）。使用文件名调用此函数，将以下内容打印到标准输入：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This indicates that the call to the `read` member function of `fstream` (line
    21) was blocked for 0.111945 seconds. This is the wall clock time, that is, the
    total elapsed time measured by the timer. 0.000000 seconds were spent by the CPU
    in user mode, and 0.060000 seconds were spent by the CPU in the kernel mode (that
    is, in system calls). Note that the read happened entirely in kernel mode, which
    is expected, because it involves invoking system calls (like read on Unix) to
    read the content of the file from the disk. The percentage of elapsed time spent
    by the CPU executing this code is 53.6\. It is computed as the sum of the durations
    spent in user mode and in kernel mode, divided by the total elapsed time, that
    is, (0.0 + 0.06)/0.111945, which is around 0.536.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明对`fstream`的`read`成员函数的调用（第21行）被阻塞了0.111945秒。这是挂钟时间，即计时器测量的总经过时间。CPU在用户模式下花费了0.000000秒，在内核模式下花费了0.060000秒（即在系统调用中）。请注意，读取完全在内核模式下进行，这是预期的，因为它涉及调用系统调用（例如在Unix上的读取）来从磁盘中读取文件的内容。CPU在执行此代码时花费的经过时间的百分比为53.6。它是作为在用户模式和内核模式中花费的持续时间之和除以总经过时间计算的，即（0.0
    + 0.06）/ 0.111945，约为0.536。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Code using Boost Timer must link with `libboost_timer` and `libboost_system`.
    To build examples involving Boost Timer with g++ on a POSIX system, use the following
    command line:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Boost Timer的代码必须链接`libboost_timer`和`libboost_system`。要在POSIX系统上使用g++构建涉及Boost
    Timer的示例，使用以下命令行：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For Boost libraries installed at nonstandard locations, refer to [Chapter 1](ch01.html
    "Chapter 1. Introducing Boost"), *Introducing Boost*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于安装在非标准位置的Boost库，请参阅[第1章](ch01.html "第1章。介绍Boost")*介绍Boost*。
- en: If we want to measure the cumulative time taken to open the file, read from
    it and close the file, then we can use a single timer to measure the execution
    times of multiple sections, stopping and resuming the timer as needed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要测量打开文件、从文件中读取并关闭文件所花费的累积时间，那么我们可以使用单个计时器来测量多个部分的执行时间，根据需要停止和恢复计时器。
- en: 'The following snippet illustrates this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段说明了这一点：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `resume` member function is called on a stopped timer and it restarts the
    timer, adding to any previous measurements. In the preceding snippet, we stop
    the timer before allocating heap memory (line 19), and resume it immediately afterwards
    (line 22).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在停止的计时器上调用`resume`成员函数会重新启动计时器，并添加到任何先前的测量中。在前面的代码片段中，我们在分配堆内存之前停止计时器（第19行），然后立即恢复计时器（第22行）。
- en: There is also a `start` member function, which is called inside the `cpu_timer`
    constructor to start measurements. Calling `start` instead of `resume` on a stopped
    timer would wipe out any previous measurements and effectively reset the timer.
    You can also check whether the timer has stopped using the `is_stopped` member
    function, which returns `true` if the timer has stopped and `false` otherwise.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`start`成员函数，它在`cpu_timer`构造函数内部调用以开始测量。在停止的计时器上调用`start`而不是`resume`会清除任何先前的测量，并有效地重置计时器。您还可以使用`is_stopped`成员函数检查计时器是否已停止，如果计时器已停止，则返回`true`，否则返回`false`。
- en: 'We can get at the elapsed time (wall clock time), CPU time spent in user mode,
    and CPU time spent in kernel mode in nanoseconds by calling the `elapsed` member
    function of `cpu_timer`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`cpu_timer`的`elapsed`成员函数获取经过的时间（挂钟时间）、在用户模式下花费的CPU时间和在内核模式下花费的CPU时间（以纳秒为单位）：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `elapsed` member function returns an object of type `cpu_times` (line 25),
    which contains three fields called `wall`, `user`, and `system` that carry the
    appropriate durations in units of nanoseconds (10^(-9) seconds).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`elapsed`成员函数返回一个`cpu_times`类型的对象（第25行），其中包含三个字段，分别称为`wall`、`user`和`system`，它们以纳秒（10^(-9)秒）为单位包含适当的持续时间。'
- en: auto_cpu_timer
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动CPU计时器
- en: 'The `boost::timer::auto_cpu_timer` is a subclass of `cpu_timer` that automatically
    stops the counter at the end of its enclosing scope and writes the measured execution
    time to the standard output or another output stream provided by the user. You
    cannot stop and resume it. When you need to measure the execution of a section
    of code till the end of a scope, you can use just one line of code using `auto_cpu_timer`,
    as shown in the following snippet adapted from listing 8.10:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::timer::auto_cpu_timer`是`cpu_timer`的子类，它会在其封闭作用域结束时自动停止计数器，并将测量的执行时间写入标准输出或用户提供的另一个输出流。您无法停止和恢复它。当您需要测量代码段的执行时间直到作用域结束时，您可以使用`auto_cpu_timer`，只需使用一行代码，如下面从列表8.10调整的片段所示：'
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will print the measured execution time in the familiar format to the standard
    output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以熟悉的格式将测量的执行时间打印到标准输出：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To print it to a different output stream, we would need to pass the stream as
    a constructor argument to `timer`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其打印到不同的输出流，我们需要将流作为构造函数参数传递给`timer`。
- en: 'To measure the time taken to read the file, we simply declare the `auto_cpu_timer`
    instance before the call to `read` (line 22). If the call to read was not the
    last statement in the scope, and we did not want to measure the execution time
    of what followed, then this would not have worked. Then, we could either use `cpu_timer`
    instead of `auto_cpu_timer`, or put only the statements that we are interested
    in a nested scope with an `auto_cpu_timer` instance created at the start:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要测量读取文件所需的时间，我们只需在调用`read`之前声明`auto_cpu_timer`实例（第22行）。如果调用read不是作用域中的最后一条语句，并且我们不想测量后续内容的执行时间，那么这将不起作用。然后，我们可以使用`cpu_timer`而不是`auto_cpu_timer`，或者只将我们感兴趣的语句放在一个嵌套作用域中，并在开始时创建一个`auto_cpu_timer`实例：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding example, we create a new scope (lines 22-25) to isolate the
    section of code to measure, using `auto_cpu_timer`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们创建了一个新的作用域（第22-25行），使用`auto_cpu_timer`来隔离要测量的代码部分。
- en: Self-test questions
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'For multiple choice questions, choose all options that apply:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多项选择题，选择所有适用的选项：
- en: Which of the following lines of code is/are not well-formed? Assume that the
    symbols are from the `boost::chrono` namespace.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码行哪个/哪些是不正确的？假设符号来自`boost::chrono`命名空间。
- en: a. `milliseconds ms = milliseconds(5) + microseconds(10);`
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: a. `milliseconds ms = milliseconds(5) + microseconds(10);`
- en: b. `nanoseconds ns = milliseconds(5) + microseconds(10);`
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: b. `nanoseconds ns = milliseconds(5) + microseconds(10);`
- en: c. `microseconds us = milliseconds(5) + microseconds(10);`
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: c. `microseconds us = milliseconds(5) + microseconds(10);`
- en: d. `seconds s = minutes(5) + microseconds(10);`
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: d. `seconds s = minutes(5) + microseconds(10);`
- en: What does the type `boost::chrono::duration<std::intmax_t, boost::ratio<1, 1000000>>`
    represent?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`boost::chrono::duration<std::intmax_t, boost::ratio<1, 1000000>>`代表什么类型？'
- en: a. A millisecond duration with integral representation
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: a. 以整数表示的毫秒持续时间
- en: b. A microsecond duration with integral representation
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: b. 以整数表示的微秒持续时间
- en: c. A millisecond duration with floating point representation
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: c. 以浮点表示的毫秒持续时间
- en: d. A nanosecond duration with integral representation
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: d. 以整数表示的纳秒持续时间
- en: What are the differences between `boost::timer::cpu_timer` and `boost::timer::auto_cpu_timer`?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`boost::timer::cpu_timer`和`boost::timer::auto_cpu_timer`之间有什么区别？'
- en: a. `auto_cpu_timer` calls `start` in the constructor, `cpu_timer` does not
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: a. `auto_cpu_timer`在构造函数中调用`start`，`cpu_timer`不会
- en: b. `auto_cpu_timer` cannot be stopped and resumed
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: b. `auto_cpu_timer` 无法停止和恢复
- en: c. `auto_cpu_timer` writes to an output stream at the end of a scope, `cpu_timer`
    does not
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: c. `auto_cpu_timer`在作用域结束时写入输出流，`cpu_timer`不会
- en: d. You can extract the wall, user, and system time from `cpu_timer`, but not
    `auto_cpu_timer`
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: d. 你可以从`cpu_timer`中提取墙壁时间、用户时间和系统时间，但不能从`auto_cpu_timer`中提取
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced libraries for measuring time and calculating dates.
    This chapter gets you up and running with the basics of date and time calculations,
    without covering the intricate details about sophisticated calendar calculations,
    time zone awareness, and custom and locale-specific formatting. The Boost online
    documentation is an excellent source for these details.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了用于测量时间和计算日期的库。本章让您快速了解了日期和时间计算的基础知识，而不涉及复杂的日历计算、时区意识和自定义和特定区域设置的格式。Boost在线文档是这些细节的绝佳来源。
- en: References
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考
- en: '*The C++ Standard Library: A Tutorial and Reference Guide (2/e)*, *Nicolai
    M. Josuttis*, *Addison Wesley Professional*'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《C++标准库：教程和参考指南（第二版）》，《Nicolai M. Josuttis》，《Addison Wesley Professional》
- en: '*A Foundation to Sleep On*: *Howard E. Hinnant*, *Walter E. Brown*, *Jeff Garland*,
    and *Marc Paterno* ([http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm))'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*睡眠的基础*：*Howard E. Hinnant*，*Walter E. Brown*，*Jeff Garland*和*Marc Paterno*（[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm)）'
