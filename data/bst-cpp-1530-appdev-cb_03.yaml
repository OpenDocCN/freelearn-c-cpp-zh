- en: Chapter 3. Managing Resources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。管理资源
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖：
- en: Managing pointers to classes that do not leave scope
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理未离开作用域的类的指针
- en: Reference counting of pointers to classes used across methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法间引用计数类指针
- en: Managing pointers to arrays that do not leave scope
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理未离开作用域的数组指针
- en: Reference counting pointers to arrays used across methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法间引用计数数组指针
- en: Storing any functional objects in a variable
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在变量中存储任何函数对象
- en: Passing a function pointer in a variable
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在变量中传递函数指针
- en: Passing C++11 lambda functions in a variable
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在变量中传递 C++11 lambda 函数
- en: Containers of pointers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指针容器
- en: Doing something at scope exit
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在作用域退出时执行某些操作
- en: Initializing the base class by a member of the derived class
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过派生类的成员初始化基类
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we'll continue to deal with datatypes, introduced by the Boost
    libraries, mostly focusing on working with pointers. We'll see how to easily manage
    resources, and how to use a datatype capable of storing any functional objects,
    functions, and lambda expressions. After reading this chapter, your code will
    become more reliable, and memory leaks will become history.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续处理由 Boost 库引入的数据类型，主要关注指针的使用。我们将了解如何轻松管理资源，以及如何使用一种能够存储任何函数对象、函数和
    lambda 表达式的数据类型。阅读本章后，你的代码将变得更加可靠，内存泄漏将成为历史。
- en: Managing pointers to classes that do not leave scope
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理未离开作用域的类的指针
- en: 'There are situations where we are required to dynamically allocate memory and
    construct a class in that memory. And, that''s where the troubles start. Have
    a look at the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要在内存中动态分配内存并构造一个类，麻烦就从这里开始了。看看下面的代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code looks correct at first glance. But, what if `some_function1()` or
    `some_function2()` throws an exception? In that case, `p` won''t be deleted. Let''s
    fix it in the following way:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码乍一看似乎是正确的。但是，如果 `some_function1()` 或 `some_function2()` 抛出异常怎么办？在这种情况下，`p`
    不会被删除。让我们以下面的方式修复它：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now the code is ugly and hard to read but is correct. Maybe we can do better
    than this.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码看起来很丑陋且难以阅读，但却是正确的。也许我们可以做得更好。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ and code behavior during exceptions is required.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 需要具备基本的 C++ 知识和异常期间代码的行为。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s take a look at the `Boost.SmartPtr` library. There is a `boost::scoped_ptr`
    class that may help you out:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Boost.SmartPtr` 库。这里有一个 `boost::scoped_ptr` 类，可能对你有所帮助：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, there is no chance that the resource will leak, and the source code is
    much clearer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，资源泄漏的可能性已经不存在了，源代码也变得更加清晰。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you have control over `some_function1()` and `some_function2()`, you may
    wish to rewrite them so they will take a reference to `scoped_ptr<foo_class>`
    (or just a reference) instead of a pointer to `foo_class`. Such an interface will
    be more intuitive.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你控制 `some_function1()` 和 `some_function2()`，你可能希望重新编写它们，以便它们接受 `scoped_ptr<foo_class>`（或只是一个引用）的引用，而不是
    `foo_class` 的指针。这样的接口将更加直观。
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the destructor, `boost::scoped_ptr<T>` will call `delete` for a pointer that
    it stores. When an exception is thrown, the stack is unwound, and the destructor
    of `scoped_ptr` is called.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在析构函数中，`boost::scoped_ptr<T>` 将为其存储的指针调用 `delete`。当抛出异常时，堆栈回溯，并调用 `scoped_ptr`
    的析构函数。
- en: The `scoped_ptr<T>` class template is not copyable; it stores only a pointer
    to the class and does not require `T` to be of a complete type (it can be forward
    declared). Some compilers do not warn when an incomplete type is being deleted,
    which may lead to errors that are hard to detect, but `scoped_ptr` (and all the
    classes in `Boost.SmartPtr`) has a specific compile-time assert for such cases.
    That makes `scoped_ptr` perfect for implementing the `Pimpl` idiom.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoped_ptr<T>` 类模板是不可复制的；它只存储指向类的指针，并且不需要 `T` 是一个完整类型（它可以被前置声明）。一些编译器在删除不完整类型时不会发出警告，这可能导致难以检测的错误，但
    `scoped_ptr`（以及 `Boost.SmartPtr` 中的所有类）具有针对此类情况的特定编译时断言。这使得 `scoped_ptr` 完美地实现了
    `Pimpl` 习惯用法。'
- en: The `boost::scoped_ptr<T>` function is equal to `const std::auto_ptr<T>`, but
    it also has the `reset()` function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::scoped_ptr<T>` 函数等同于 `const std::auto_ptr<T>`，但它还有一个 `reset()` 函数。'
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This class is extremely fast. In most cases, the compiler will optimize the
    code that uses `scoped_ptr` to the machine code, which is close to our handwritten
    version (and sometimes even better if the compiler detects that some functions
    do not throw exceptions).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常快。在大多数情况下，编译器会将使用 `scoped_ptr` 的代码优化成接近我们手写的机器代码（如果编译器检测到某些函数不抛出异常，有时甚至更好）。
- en: See also
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The documentation of the `Boost.SmartPtr` library contains lots of examples
    and other useful information about all the smart pointers' classes. You can read
    about it at [http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm](http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.SmartPtr` 库的文档包含了许多示例以及关于所有智能指针类的其他有用信息。您可以在[http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm](http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm)上阅读它。'
- en: Reference counting of pointers to classes used across methods
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在方法间使用类指针的引用计数
- en: 'Imagine that you have some dynamically allocated structure containing data,
    and you want to process it in different execution threads. The code to do this
    is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一些包含数据的动态分配的结构，你想要在不同的执行线程中处理它。执行此操作的代码如下：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We cannot deallocate `p` at the end of the `while` loop because it can still
    be used by threads that run process functions. Process functions cannot delete
    `p` because they do not know that other threads are not using it anymore.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在 `while` 循环的末尾释放 `p`，因为它可能仍然被运行进程函数的线程使用。进程函数不能删除 `p`，因为它们不知道其他线程已经不再使用它了。
- en: Getting ready
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses the `Boost.Thread` library, which is not a header-only library,
    so your program will need to link against the `libboost_thread` and `libboost_system`
    libraries. Make sure that you understand the concept of threads before reading
    further. Refer to the *See also* section for references on recipes that use threads.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方使用了 `Boost.Thread` 库，它不是一个仅包含头文件的库，因此你的程序需要链接到 `libboost_thread` 和 `libboost_system`
    库。在继续阅读之前，请确保你理解了线程的概念。有关使用线程的配方，请参阅 *参见* 部分。
- en: You'll also need some basic knowledge on `boost::bind` or `std::bind`, which
    is almost the same.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一些关于 `boost::bind` 或 `std::bind` 的基本知识，它们几乎是相同的。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As you may have guessed, there is a class in Boost (and C++11) that will help
    you to deal with it. It is called `boost::shared_ptr`, and it can be used as:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，在 Boost（和 C++11）中有一个类可以帮助你处理这个问题。它被称为 `boost::shared_ptr`，它可以被用作：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Another example of this is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这方面的另一个例子如下：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `shared_ptr` class has an atomic reference counter inside. When you copy
    it, the reference counter is incremented, and when its destructor is called, the
    reference counter is decremented. When the reference counter equals zero, `delete`
    is called for the object pointed by `shared_ptr`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr` 类内部有一个原子引用计数器。当你复制它时，引用计数器会增加，当其析构函数被调用时，引用计数器会减少。当引用计数器等于零时，`delete`
    会调用 `shared_ptr` 指向的对象。'
- en: Now, let's find out what's happening in the case of `boost::thread` (`boost::bind(&process_sp1,
    p)`). The function `process_sp1` takes a parameter as a reference, so why is it
    not deallocated when we get out of the `while` loop? The answer is simple. The
    functional object returned by `bind()` contains a copy of the shared pointer,
    and that means that the data pointed by `p` won't be deallocated until the functional
    object is destroyed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们找出在 `boost::thread` (`boost::bind(&process_sp1, p)`) 的情况下发生了什么。`process_sp1`
    函数接受一个引用作为参数，那么为什么我们在退出 `while` 循环时它没有被释放呢？答案是简单的。`bind()` 返回的功能对象包含共享指针的一个副本，这意味着指向
    `p` 的数据不会在功能对象被销毁之前被释放。
- en: 'Getting back to `boost::make_shared`, let''s take a look at `shared_ptr<std::string>
    ps(new int(0))`. In this case, we have two calls to `new`: firstly while constructing
    a pointer to an integer, and secondly when constructing a `shared_ptr` class (it
    allocates an atomic counter on heap using call `new`). But, when we construct
    `shared_ptr` using `make_shared`, only one call to `new` will be made. It will
    allocate a single piece of memory and will construct an atomic counter and the
    `int` object in that piece.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 `boost::make_shared`，让我们看看 `shared_ptr<std::string> ps(new int(0))`。在这种情况下，我们有两个
    `new` 调用：首先是在构造一个指向整数的指针时，其次是在构造 `shared_ptr` 类（它使用 `new` 调用在堆上分配一个原子计数器）。但是，当我们使用
    `make_shared` 构造 `shared_ptr` 时，只有一个 `new` 调用会被执行。它将分配一块内存，并在其中构造一个原子计数器和 `int`
    对象。
- en: There's more...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The atomic reference counter guarantees the correct behavior of `shared_ptr`
    across the threads, but you must remember that atomic operations are not as fast
    as nonatomic. On C++11 compatible compilers, you may reduce the atomic operations'
    count using `std::move` (move the constructor of the shared pointer in such a
    way that the atomic counter is neither incremented nor decremented).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 原子引用计数器保证了`shared_ptr`在多线程中的正确行为，但您必须记住，原子操作并不像非原子操作那样快。在C++11兼容的编译器上，您可以使用`std::move`（以这种方式移动共享指针的构造函数，使得原子计数器既不增加也不减少）来减少原子操作的次数。
- en: The `shared_ptr` and `make_shared` classes are part of C++11, and they are declared
    in the header `<memory>` in `std::` namespace.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`shared_ptr`和`make_shared`类是C++11的一部分，并在`std::`命名空间中的头文件`<memory>`中声明。'
- en: See also
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: Refer to [Chapter 5](ch05.html "Chapter 5. Multithreading"), *Multithreading*,
    for more information about `Boost.Thread` and atomic operations.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第5章](ch05.html "第5章。多线程")，*多线程*，以获取有关`Boost.Thread`和原子操作更多信息。
- en: Refer to the *Reordering the parameters of function* recipe in [Chapter 1](ch01.html
    "Chapter 1. Starting to Write Your Application"), *Starting to Write Your Application*,
    for more information about `Boost.Bind`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第1章](ch01.html "第1章。开始编写您的应用程序")中的*重新排序函数参数*配方，*开始编写您的应用程序*，以获取有关`Boost.Bind`更多信息。
- en: Refer to the *Binding a value as a function parameter* recipe in [Chapter 1](ch01.html
    "Chapter 1. Starting to Write Your Application"), *Starting to Write Your Application*,
    for more information about `Boost.Bind`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第1章](ch01.html "第1章。开始编写您的应用程序")中的*将值绑定为函数参数*配方，*开始编写您的应用程序*，以获取有关`Boost.Bind`更多信息。
- en: The documentation of the `Boost.SmartPtr` library contains lots of examples
    and other useful information about all the smart pointers' classes. You can read
    about it at [http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm](http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.SmartPtr`库的文档包含了许多关于所有智能指针类的示例和其他有用信息。您可以在[http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm](http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm)上阅读它。'
- en: Managing pointers to arrays that do not leave scope
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理未离开作用域的数组指针
- en: 'We already saw how to manage pointers to a resource in the *Managing pointers
    to classes that do not leave scope* recipe. But, when we deal with arrays, we
    need to call `delete[]` instead of a simple `delete`, otherwise there will be
    a memory leak. Have a look at the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在*管理未离开作用域的类的指针*配方中看到了如何管理资源指针。但是，当我们处理数组时，我们需要调用`delete[]`而不是简单的`delete`，否则将会有内存泄漏。请看以下代码：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Knowledge of C++ exceptions and templates are required for this recipe.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，需要了解C++异常和模板。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The `Boost.SmartPointer` library has not only the `scoped_ptr<>` class but also
    a `scoped_array<>` class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.SmartPointer`库不仅包含`scoped_ptr<>`类，还包含`scoped_array<>`类。'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It works just like a `scoped_ptr<>` class but calls `delete[]` instead of `delete`
    in the destructor.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式就像一个`scoped_ptr<>`类，但在析构函数中调用`delete[]`而不是`delete`。
- en: There's more...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `scoped_array<>` class has the same guarantees and design as `scoped_ptr<>`.
    It has neither additional memory allocations nor virtual functions' call. It cannot
    be copied and is not a part of C++11.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoped_array<>`类具有与`scoped_ptr<>`相同的安全性和设计。它没有额外的内存分配，也没有虚拟函数调用。它不能被复制，也不是C++11的一部分。'
- en: See also
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: The documentation of the `Boost.SmartPtr` library contains lots of examples
    and other useful information about all the smart pointers' classes. You can read
    about it at [http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm](http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.SmartPtr`库的文档包含了许多关于所有智能指针类的示例和其他有用信息。您可以在[http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm](http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm)上阅读它。'
- en: Reference counting pointers to arrays used across methods
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在方法间使用数组指针的引用计数
- en: 'We continue coping with pointers, and our next task is to reference count an
    array. Let''s take a look at a program that gets some data from the stream and
    processes it in different threads. The code to do this is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续处理指针，我们的下一个任务是引用计数一个数组。让我们看看一个从流中获取一些数据并在不同线程中处理它的程序。执行此操作的代码如下：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Just the same problem that occurred in the *Reference counting of pointers to
    classes used across methods* recipe.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与*在方法间使用指针的引用计数*配方中出现的相同问题。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe uses the `Boost.Thread` library, which is not a header-only library,
    so your program will need to link against the `libboost_thread` and `libboost_system`
    libraries. Make sure that you understand the concept of threads before reading
    further.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方使用 `Boost.Thread` 库，它不是一个仅包含头文件的库，因此您的程序需要链接到 `libboost_thread` 和 `libboost_system`
    库。在继续阅读之前，请确保您理解线程的概念。
- en: You'll also need some basic knowledge on `boost::bind` or `std::bind`, which
    is almost the same.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要了解一些关于 `boost::bind` 或 `std::bind` 的基础知识，它们几乎相同。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'There are three solutions. The main difference between them is of type and
    construction of the `data_cpy` variable. Each of these solutions does exactly
    the same things that are described in the beginning of this recipe but without
    memory leaks. The solutions are:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种解决方案。它们之间的主要区别在于 `data_cpy` 变量的类型和构造。这些解决方案都做了与配方开头描述的完全相同的事情，但没有内存泄漏。解决方案如下：
- en: 'The first solution:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种解决方案：
- en: '[PRE9]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The second solution:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种解决方案：
- en: 'Since Boost 1.53 `shared_ptr` itself can take care of arrays:'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自从 Boost 1.53 以来，`shared_ptr` 本身就可以处理数组：
- en: '[PRE10]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The third solution:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种解决方案：
- en: '[PRE11]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In each of these examples, shared classes count references and call `delete[]`
    for a pointer when the reference count becomes equal to zero. The first and second
    examples are trivial. In the third example, we provide a `deleter` object for
    a shared pointer. The `deleter` object will be called instead of the default call
    to `delete`. This `deleter` is the same as used in C++11 in `std::unique_ptr`
    and `std::shared_ptr`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中的每一个，共享类都会计算引用数，并在引用数变为零时调用 `delete[]`。前两个示例是微不足道的。在第三个示例中，我们为共享指针提供了一个
    `deleter` 对象。这个 `deleter` 对象将代替默认的 `delete` 调用。这个 `deleter` 与 C++11 中的 `std::unique_ptr`
    和 `std::shared_ptr` 中使用的相同。
- en: There's more...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The first solution is traditional to Boost; prior to Boost 1.53, the functionality
    of the second solution was not implemented in `shared_ptr`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种解决方案是传统的 Boost；在 Boost 1.53 之前，第二种解决方案的功能并未在 `shared_ptr` 中实现。
- en: The second solution is the fastest one (it uses fewer calls to `new`), but it
    can be used only with Boost 1.53 and higher.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种解决方案是最快的（它使用的 `new` 调用较少），但它只能与 Boost 1.53 及更高版本一起使用。
- en: The third solution is the most portable one. It can be used with older versions
    of Boost and with C++11 STL's `shared_ptr<>` (just don't forget to change `boost::checked_array_deleter<T>()`
    to `std::default_delete<T[]>()`).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种解决方案是最便携的。它可以与较老的 Boost 版本以及 C++11 STL 的 `shared_ptr<>`（只需别忘了将 `boost::checked_array_deleter<T>()`
    改为 `std::default_delete<T[]>()`）一起使用。
- en: See also
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The documentation of the `Boost.SmartPtr` library contains lots of examples
    and other useful information about all the smart pointers' classes. You can read
    about it at [http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm](http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.SmartPtr` 库的文档包含了许多示例和其他关于所有智能指针类的有用信息。您可以在 [http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm](http://www.boost.org/doc/libs/1_53_0/libs/smart_ptr/smart_ptr.htm)
    中了解它。'
- en: Storing any functional objects in a variable
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在变量中存储任何功能对象
- en: 'C++ has a syntax to work with pointers to functions and member functions''
    pointers. And, that is good! However, this mechanism is hard to use with functional
    objects. Consider the situation when you are developing a library that has its
    API declared in the header files and implementation in the source files. This
    library shall have a function that accepts any functional objects. How would you
    pass a functional object to it? Have a look at the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 有一种语法可以处理函数指针和成员函数指针。而且，这很好！然而，这个机制很难与功能对象一起使用。考虑当你正在开发一个库，其 API 在头文件中声明，实现则在源文件中。这个库应该有一个接受任何功能对象的函数。你将如何传递一个功能对象给它？看看下面的代码：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Reading the *Storing any value in a container/variable* recipe in [Chapter 1](ch01.html
    "Chapter 1. Starting to Write Your Application"), *Starting to Write Your Application*,
    is recommended before starting this recipe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始此配方之前，建议阅读 [第 1 章](ch01.html "第 1 章。开始编写您的应用程序") 中关于 *在容器/变量中存储任何值* 的配方。
- en: You'll also need some basic knowledge on `boost::bind` or `std::bind`, which
    is almost the same.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要了解一些关于 `boost::bind` 或 `std::bind` 的基础知识，它们几乎相同。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how to fix the example and make `process_integers` accept functional
    objects:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何修复示例，并使 `process_integers` 接受功能对象：
- en: 'There is a solution, and it is called a `Boost.Function` library. It allows
    you to store any function, a member function, or a functional object if its signature
    is a match to the one described in a template argument:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个解决方案，它被称为 `Boost.Function` 库。它允许你存储任何函数、成员函数或功能对象，如果其签名与模板参数中描述的匹配：
- en: '[PRE13]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `boost::function` class has a default constructor and has an empty state.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`boost::function` 类有一个默认构造函数，并且处于空状态。'
- en: 'Checking for an empty/default constructed state can be done like this:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查空/默认构造状态可以这样做：
- en: '[PRE14]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `fobject_t` method stores in itself data from functional objects and erases
    their exact type. It is safe to use the `boost::function` objects such as the
    following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`fobject_t` 方法在其自身中存储功能对象的 数据并擦除它们的精确类型。使用以下代码中的 `boost::function` 对象是安全的：'
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Does it remind you of the `boost::any` class? It uses the same technique—type
    erasure for storing any function objects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你想起了 `boost::any` 类吗？它使用相同的技巧——类型擦除来存储任何函数对象。
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Boost.Function` library has an insane amount of optimizations; it may store
    small functional objects without additional memory allocations and has optimized
    move assignment operators. It is accepted as a part of C++11 STL library and is
    defined in the `<functional>` header in the `std::` namespace.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Function` 库有大量的优化；它可能在不进行额外内存分配的情况下存储小的函数对象，并且有优化的移动赋值运算符。它被视为 C++11
    STL 库的一部分，并在 `std::` 命名空间中的 `<functional>` 头文件中定义。'
- en: 'But, remember that `boost::function` implies an optimization barrier for the
    compiler. It means that:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，记住 `boost::function` 对编译器意味着一个优化障碍。这意味着：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: will be better optimized by the compiler than
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将被编译器优化得更好
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is why you should try to avoid using `Boost.Function` when its usage is
    not really required. In some cases, the C++11 `auto` keyword can be handy instead:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么你应该尽量避免在实际上不需要时使用 `Boost.Function`。在某些情况下，C++11 的 `auto` 关键字可能更方便：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See also
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official documentation of `Boost.Function` contains more examples, performance
    measures, and class reference documentation. You can read about it at [http://www.boost.org/doc/libs/1_53_0/doc/html/function.html](http://www.boost.org/doc/libs/1_53_0/doc/html/function.html).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Function` 的官方文档包含更多示例、性能指标和类参考文档。你可以在 [http://www.boost.org/doc/libs/1_53_0/doc/html/function.html](http://www.boost.org/doc/libs/1_53_0/doc/html/function.html)
    了解相关信息。'
- en: The *Passing a function pointer in a variable* recipe.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在变量中传递函数指针* 的配方。'
- en: The *Passing C++11 lambda functions in a variable* recipe.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在变量中传递 C++11 lambda 函数* 的配方。'
- en: Passing a function pointer in a variable
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在变量中传递函数指针
- en: We are continuing with the previous example, and now we want to pass a pointer
    to a function in our `process_integeres()` method. Shall we add an overload for
    just function pointers, or is there a more elegant way?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在继续之前的示例，现在我们想在 `process_integeres()` 方法中传递一个函数指针。我们应该只为函数指针添加重载，还是有一个更优雅的方法？
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is continuing the previous one. You must read the previous recipe
    first.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是继续之前的配方。你必须先阅读之前的配方。
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Nothing needs to be done as `boost::function<>` is also constructible from
    the function pointers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `boost::function<>` 也可以从函数指针构造，因此无需进行任何操作：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A pointer to `my_ints_function` will be stored inside the `boost::function`
    class, and calls to `boost::function` will be forwarded to the stored pointer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `my_ints_function` 的指针存储在 `boost::function` 类中，并且对 `boost::function` 的调用将被转发到存储的指针。
- en: There's more...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Boost.Function` library provides good performance for pointers to functions,
    and it will not allocate memory on heap. However, whatever you store in `boost::function`,
    it will use an RTTI. If you disable RTTI, it will continue to work but will dramatically
    increase the size of a compiled binary.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Function` 库为函数指针提供了良好的性能，并且它不会在堆上分配内存。然而，无论你在 `boost::function` 中存储什么，它都会使用
    RTTI。如果你禁用 RTTI，它将继续工作，但会显著增加编译二进制文件的大小。'
- en: See also
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official documentation of `Boost.Function` contains more examples, performance
    measures, and class reference documentation. You can read about it at [http://www.boost.org/doc/libs/1_53_0/doc/html/function.html](http://www.boost.org/doc/libs/1_53_0/doc/html/function.html).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Function` 的官方文档包含更多示例、性能指标和类参考文档。你可以在 [http://www.boost.org/doc/libs/1_53_0/doc/html/function.html](http://www.boost.org/doc/libs/1_53_0/doc/html/function.html)
    了解相关信息。'
- en: The *Passing C++11 lambda functions in a variable* recipe.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*在变量中传递 C++11 lambda 函数*` 配方。'
- en: Passing C++11 lambda functions in a variable
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在变量中传递 C++11 lambda 函数
- en: We are continuing with the previous example, and now we want to use a lambda
    function with our `process_integers()` method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用上一个示例，现在我们想要在我们的 `process_integers()` 方法中使用一个 lambda 函数。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is continuing the series of the previous two. You must read them
    first. You will also need a C++11 compatible compiler or at least a compiler with
    C++11 lambda support.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是延续前两个配方的系列。您必须先阅读它们。您还需要一个兼容 C++11 的编译器或至少一个具有 C++11 lambda 支持的编译器。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Nothing needs to be done as `boost::function<>` is also usable with lambda
    functions of any difficulty:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `boost::function<>` 也可以与任何难度的 lambda 函数一起使用，因此无需进行任何操作：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There's more...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Performance of the lambda function storage in `Boost.Functional` is the same
    as in other cases. While the functional object produced by the lambda expression
    is small enough to fit in an instance of `boost::function`, no dynamic memory
    allocation will be performed. Calling an object stored in `boost::function` is
    close to the speed of calling a function by a pointer. Copying of an object is
    close to the speed of constructing `boost::function` and will exactly use a dynamic
    memory allocation in similar cases. Moving objects won't allocate and deallocate
    memory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Functional` 中 lambda 函数存储的性能与其他情况相同。当 lambda 表达式产生的功能对象足够小，可以放入 `boost::function`
    的实例中时，不会执行动态内存分配。调用存储在 `boost::function` 中的对象的速度接近通过指针调用函数的速度。对象的复制速度接近构造 `boost::function`
    的速度，并在类似情况下将精确地使用动态内存分配。移动对象不会分配和释放内存。'
- en: See also
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: Additional information about performance and `Boost.Function` can be found on
    the official documentation page at [http://www.boost.org/doc/libs/1_53_0/doc/html/function.html](http://www.boost.org/doc/libs/1_53_0/doc/html/function.html)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于性能和 `Boost.Function` 的更多信息可以在官方文档页面上找到：[http://www.boost.org/doc/libs/1_53_0/doc/html/function.html](http://www.boost.org/doc/libs/1_53_0/doc/html/function.html)
- en: Containers of pointers
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针容器
- en: 'There are such cases when we need to store pointers in the container. The examples
    are: storing polymorphic data in containers, forcing fast copy of data in containers,
    and strict exception requirements for operations with data in containers. In such
    cases, the C++ programmer has the following choices:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要在容器中存储指针。例如：在容器中存储多态数据，强制容器中数据的快速复制，以及容器中操作数据的严格异常要求。在这种情况下，C++程序员有以下选择：
- en: 'Store pointers in containers and take care of their destructions using the
    operator `delete`:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中存储指针并使用运算符 `delete` 处理它们的销毁：
- en: '[PRE21]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Such an approach is error prone and requires a lot of writing
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法容易出错，并且需要大量编写
- en: 'Store smart pointers in containers:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中存储智能指针：
- en: 'For the C++03 version:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 C++03 版本：
- en: '[PRE22]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `std::auto_ptr` method is deprecated, and it is not recommended to use it
    in containers. Moreover, this example will not compile with C++11.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`std::auto_ptr` 方法已被弃用，不建议在容器中使用。此外，此示例在 C++11 中无法编译。'
- en: 'For the C++11 version:'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 C++11 版本：
- en: '[PRE23]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This solution is a good one, but it cannot be used in C++03, and you still need
    to write a comparator functional object
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种解决方案是一个好方案，但不能用于 C++03，并且您仍然需要编写一个比较器功能对象
- en: 'Use `Boost.SmartPtr` in the container:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中使用 `Boost.SmartPtr`：
- en: '[PRE24]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This solution is portable, but you still need to write comparators, and it adds
    performance penalties (an atomic counter requires additional memory, and its increments/decrements
    are not as fast as nonatomic operations)
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种解决方案是可移植的，但您仍然需要编写比较器，并且它增加了性能惩罚（原子计数器需要额外的内存，其增加/减少操作不如非原子操作快）
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Knowledge of STL containers is required for better understanding of this recipe.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个配方，需要了解 STL 容器。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The `Boost.PointerContainer` library provides a good and portable solution:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.PointerContainer` 库提供了一个良好且可移植的解决方案：'
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Boost.PointerContainer` library has classes `ptr_array`, `ptr_vector`,
    `ptr_set`, `ptr_multimap`, and others. All these containers simplify your life.
    When dealing with pointers, they will be deallocating pointers in destructors
    and simplifying access to data pointed by the pointer (no need for additional
    dereference in `assert(*s.begin() == 0);`).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.PointerContainer` 库包含 `ptr_array`、`ptr_vector`、`ptr_set`、`ptr_multimap`
    等类。所有这些容器都能简化你的生活。当处理指针时，它们将在析构函数中释放指针，并简化对指针所指向数据的访问（无需在 `assert(*s.begin() ==
    0);` 中进行额外的解引用）。'
- en: There's more...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Previous examples were not cloning pointer data, but when we want to clone
    some data, all we need to do is to just define a freestanding function such as
    `new_clone()` in the namespace of the object to be cloned. Moreover, you may use
    the default `T* new_clone( const T& r )` implementation if you include the header
    file `<boost/ptr_container/clone_allocator.hpp>` as shown in the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例并没有克隆指针数据，但当我们想要克隆一些数据时，我们只需要在要克隆的对象的命名空间中定义一个独立的函数，例如 `new_clone()`。此外，如果你包含了
    `<boost/ptr_container/clone_allocator.hpp>` 头文件，你可以使用默认的 `T* new_clone( const
    T& r )` 实现，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See also
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official documentation contains detailed reference for each class, and you
    may read about it at [http://www.boost.org/doc/libs/1_53_0/libs/ptr_container/doc/ptr_container.html](http://www.boost.org/doc/libs/1_53_0/libs/ptr_container/doc/ptr_container.html)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档包含了每个类的详细参考，你可以在 [http://www.boost.org/doc/libs/1_53_0/libs/ptr_container/doc/ptr_container.html](http://www.boost.org/doc/libs/1_53_0/libs/ptr_container/doc/ptr_container.html)
    上阅读相关信息。
- en: The first four recipes of this chapter will give you some examples of smart
    pointers' usage
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的前四个示例将为你提供一些智能指针使用的例子
- en: Doing something at scope exit
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在作用域退出时执行某些操作
- en: If you were dealing with languages such as Java, C#, or Delphi, you were obviously
    using the `try{} finally{}` construction or `scope(exit)` in the D programming
    language. Let me briefly describe to you what do these language constructions
    do.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你处理的是像 Java、C# 或 Delphi 这样的语言，你显然使用了 `try{} finally{}` 构造或 D 语言的 `scope(exit)`。让我简要地描述一下这些语言构造的功能。
- en: 'When a program leaves the current scope via return or exception, code in the
    `finally` or `scope(exit)` blocks is executed. This mechanism is perfect for implementing
    the **RAII** pattern as shown in the following code snippet:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序通过返回或异常离开当前作用域时，`finally` 或 `scope(exit)` 块中的代码将被执行。这种机制非常适合实现如以下代码片段所示的
    **RAII** 模式：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Is there a way to do such a thing in C++?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中有办法做这样的事情吗？
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic C++ knowledge is required for this recipe. Knowledge of code behavior
    during thrown exceptions will be useful.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 需要基本的 C++ 知识来完成这个示例。了解抛出异常时的代码行为将很有用。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The `Boost.ScopeExit` library was designed to solve such problems:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.ScopeExit` 库被设计用来解决这类问题：'
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The variable `f` is passed by value via `BOOST_SCOPE_EXIT(f)`. When the program
    leaves the scope of execution, the code between `BOOST_SCOPE_EXIT(f) {` and `}
    BOOST_SCOPE_EXIT_END` will be executed. If we wish to pass the value by reference,
    use the `&` symbol in the `BOOST_SCOPE_EXIT` macro. If we wish to pass multiple
    values, just separate them using a comma.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `f` 通过 `BOOST_SCOPE_EXIT(f)` 以值的方式传递。当程序离开执行范围时，`BOOST_SCOPE_EXIT(f) {` 和
    `} BOOST_SCOPE_EXIT_END` 之间的代码将被执行。如果我们希望通过引用传递值，请在 `BOOST_SCOPE_EXIT` 宏中使用 `&`
    符号。如果我们希望传递多个值，只需用逗号将它们分开。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Passing references to a pointer does not work well on some compilers. The `BOOST_SCOPE_EXIT(&f)`
    macro cannot be compiled there, which is why we do not capture it by reference
    in the example.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些编译器上，对指针的传递引用效果不佳。`BOOST_SCOPE_EXIT(&f)` 宏无法在那里编译，这就是为什么我们在示例中没有通过引用捕获它的原因。
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'To capture this inside a member function, we use a special symbol `this_`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要在成员函数内部捕获它，我们使用一个特殊的符号 `this_`：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `Boost.ScopeExit` library allocates no additional memory on heap and does
    not use virtual functions. Use the default syntax and do not define `BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS`
    because otherwise scope exit will be implemented using `boost::function`, which
    may allocate additional memory and imply the optimization barrier.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.ScopeExit` 库在堆上不分配额外的内存，也不使用虚函数。使用默认语法，不要定义 `BOOST_SCOPE_EXIT_CONFIG_USE_LAMBDAS`，因为否则作用域退出将使用
    `boost::function` 实现，这可能会分配额外的内存并引入优化屏障。'
- en: See also
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official documentation contains more examples and use cases. You can read
    about it at [http://www.boost.org/doc/libs/1_53_0/libs/scope_exit/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/scope_exit/doc/html/index.html).
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方文档包含了更多示例和用例。你可以在 [http://www.boost.org/doc/libs/1_53_0/libs/scope_exit/doc/html/index.html](http://www.boost.org/doc/libs/1_53_0/libs/scope_exit/doc/html/index.html)
    了解相关信息。
- en: Initializing the base class by a member of the derived class
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过派生类的成员初始化基类
- en: 'Let''s take a look at the following example. We have some base class that has
    virtual functions and must be initialized with reference to the `std::ostream`
    object:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例。我们有一个具有虚函数并且必须使用对 `std::ostream` 对象的引用进行初始化的基类：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also have a derived class that has a `std::ostream` object and implements
    the `do_process()` function:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个具有 `std::ostream` 对象并实现 `do_process()` 函数的派生类：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is not a very common case in programming, but when such mistakes happen,
    it is not always simple to get the idea of bypassing it. Some people try to bypass
    it by changing the order of `logger_` and the base type initialization:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，这种情况并不常见，但当这种错误发生时，并不总是简单就能想到绕过它的方法。有些人试图通过改变 `logger_` 和基类初始化的顺序来绕过它：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It won't work as they expect because direct base classes are initialized before
    nonstatic data members, regardless of the order of the member initializers.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会像他们预期的那样工作，因为直接基类在非静态数据成员之前初始化，无论成员初始化器的顺序如何。
- en: Getting ready
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ is required for this recipe.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 需要具备基本的 C++ 知识才能使用此配方。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The `Boost.Utility` library provides a quick solution for such cases; it is
    called the `boost::base_from_member` template. To use it, you need to carry out
    the following steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Utility` 库为这类情况提供了一个快速解决方案；它被称为 `boost::base_from_member` 模板。要使用它，你需要执行以下步骤：'
- en: 'Include the `base_from_member.hpp` header:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 `base_from_member.hpp` 头文件：
- en: '[PRE33]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Derive your class from `boost::base_from_member<T>` where `T` is a type that
    must be initialized before the base (take care about the order of the base classes;
    `boost::base_from_member<T>` must be placed before the class that uses `T`):'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `boost::base_from_member<T>` 派生你的类，其中 `T` 是必须在基类之前初始化的类型（注意基类的顺序；`boost::base_from_member<T>`
    必须放在使用 `T` 的类之前）：
- en: '[PRE34]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Correctly write the constructor as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确编写构造函数如下：
- en: '[PRE35]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If direct base classes are initialized before nonstatic data members, and if
    direct base classes would be initialized in declaration order as they appear in
    the base-specifier-list, we need to somehow make a base class our nonstatic data
    member. Or make a base class that has a member field with the required member:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果直接基类在非静态数据成员之前初始化，并且如果直接基类会按照它们在基类指定列表中出现的声明顺序初始化，我们需要以某种方式使基类成为我们的非静态数据成员。或者创建一个具有所需成员的成员字段的基类：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There's more...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As you may see, `base_from_member` has an integer as a second template argument.
    This is done for cases when we need multiple `base_from_member` classes of the
    same type:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`base_from_member` 有一个整数作为第二个模板参数。这是为了处理我们需要多个相同类型的 `base_from_member`
    类的情况：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `boost::base_from_member` class neither applies additional dynamic memory
    allocations nor has virtual functions. The current implementation does not support
    C++11 features (such as perfect forwarding and variadic templates), but in Boost's
    trunk branch, there is an implementation that can use all the benefits of C++11\.
    It possibly will be merged to release a branch in the nearest future.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`boost::base_from_member` 类既不应用额外的动态内存分配，也没有虚函数。当前的实现不支持 C++11 特性（如完美转发和变长模板），但在
    Boost 的 trunk 分支中，有一个可以充分利用 C++11 优势的实现。它可能将在最近的未来合并到发布分支中。'
- en: See also
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `Boost.Utility` library contains many helpful classes and methods; documentation
    for getting more information about it is at [http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm](http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boost.Utility` 库包含了许多有用的类和方法；有关获取更多信息，请参阅 [http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm](http://www.boost.org/doc/libs/1_53_0/libs/utility/utility.htm)。'
- en: The *Making a noncopyable class* recipe in [Chapter 1](ch01.html "Chapter 1. Starting
    to Write Your Application"), *Starting to Write Your Application*, contains more
    examples of classes from `Boost.Utility`
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章。开始编写您的应用程序") 的 *Making a noncopyable class* 配方中，*Starting
    to Write Your Application*，包含了 `Boost.Utility` 中类的更多示例。
- en: Also, the *Using the C++11 move emulation* recipe in [Chapter 1](ch01.html "Chapter 1. Starting
    to Write Your Application"), *Starting to Write Your Application*, contains more
    examples of classes from `Boost.Utility`
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，[第1章](ch01.html "第1章。开始编写您的应用程序")中的*使用C++11移动模拟*配方包含来自`Boost.Utility`类的更多示例。
