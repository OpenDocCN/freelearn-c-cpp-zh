- en: Chapter 12. Abstraction and Code Management – Making Better Use of OOP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。抽象和代码管理——更好地利用OOP
- en: In this chapter, we will take a first look at the final project of the book.
    The project will have advanced features such as directional sound, which comes
    out of the speakers relative to the position of the player. It will also have
    split screen cooperative gameplay. In addition, this project will introduce the
    concept of **Shaders**, which are programs written in another language that run
    directly on the graphics card. By the end of [Chapter 16](ch16.html "Chapter 16. 
    Extending SFML Classes, Particle Systems, and Shaders"), *Extending SFML Classes,
    Particle Systems, and Shaders*, you will have a fully functioning multiplayer
    platform game built in the style of the hit classic **Thomas Was Alone**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首次查看本书的最终项目。该项目将具有高级功能，如方向性声音，根据玩家位置从扬声器发出。它还将具有分屏合作游戏。此外，该项目将引入**着色器**的概念，这是用另一种语言编写的程序，直接在图形卡上运行。到[第16章](ch16.html
    "第16章。扩展SFML类、粒子系统和着色器")结束时，您将拥有一个完全功能的多人平台游戏，以命中经典**Thomas Was Alone**的风格构建。
- en: 'This chapter''s main focus will be getting the project started—in particular,
    exploring how the code will be structured to make better use of OOP. The following
    topics will be covered:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要重点将是启动项目，特别是探讨如何构建代码以更好地利用OOP。将涵盖以下主题：
- en: An introduction to the final project, **Thomas Was Late**, including the gameplay
    features and project assets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍最终项目**Thomas Was Late**，包括游戏特点和项目资产
- en: A detailed discussion of how we will improve the structure of the code compared
    to previous projects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与以前的项目相比，我们将讨论如何改进代码结构
- en: Coding the Thomas Was Late game engine
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Thomas Was Late游戏引擎
- en: Implementing split screen functionality
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现分屏功能
- en: The Thomas Was Late game
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Thomas Was Late游戏
- en: At this point, if you haven't already, I would suggest you go and watch a video
    of Thomas Was Alone at [http://store.steampowered.com/app/220780/](http://store.steampowered.com/app/220780/). Notice
    the really simple but aesthetically excellent graphics. The video also shows a
    variety of gameplay challenges such as using the character's different attributes
    (height, jump, power, and so on). To keep our game simple without losing the challenge,
    we will have fewer puzzle features than Thomas Was Alone, but will have the additional
    challenge of creating the need for two players to play cooperatively. Just to
    make sure the game is not too easy, we will also make the players race against
    the clock, hence why the name of our game is Thomas Was Late.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果您还没有，我建议您去观看Thomas Was Alone的视频[http://store.steampowered.com/app/220780/](http://store.steampowered.com/app/220780/)。请注意其简单但美观的图形。视频还展示了各种游戏挑战，例如使用角色的不同属性（高度、跳跃、力量等）。为了保持我们的游戏简单而不失挑战，我们将比Thomas
    Was Alone少一些谜题特色，但将增加两名玩家合作游戏的挑战。为了确保游戏不会太容易，我们还将让玩家与时间赛跑，这就是我们的游戏名为Thomas Was
    Late的原因。
- en: Features of Thomas Was Late
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Thomas Was Late的特点
- en: 'Our game will not be nearly as advanced as the masterpiece that we are attempting
    to emulate, but it will have a good selection of exciting gameplay features:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏不会像我们试图模仿的杰作那样先进，但它将具有一系列令人兴奋的游戏特色：
- en: A clock that count downs from a time appropriate to the challenge of the level.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个从与关卡挑战相适应的时间开始倒计时的时钟。
- en: Fire pits that emit a roar relative to the position of the player and re-spawn
    the player at the start if they fall in. Water pits have the same effect but without
    the directional sound effects.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发射火坑会根据玩家位置发出咆哮声，并在玩家掉下去时重新开始。水坑也有相同的效果，但没有方向性声音效果。
- en: Cooperative gameplay—both the players will have to get their characters to the
    goal within the allotted time. They will frequently need to work together, for
    example the shorter, lower-jumping Bob will need to stand on his friend's (Thomas's)
    head.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合作游戏——两名玩家必须在规定时间内将他们的角色带到目标处。他们经常需要合作，例如身材较矮、跳跃较低的Bob需要站在他朋友（Thomas）的头上。
- en: The player will have the option of switching between full and split screen,
    so he can attempt to control both characters himself.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家将有选择在全屏和分屏之间切换，这样他可以尝试自己控制两个角色。
- en: Each level will be designed in and loaded from a text file. This will make it
    really easy to design varied and numerous levels.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个关卡将设计并从文本文件中加载。这将使设计各种各样的关卡变得非常容易。
- en: 'Take a look at this annotated screenshot of the game to see some of the features
    in action and the components/assets that make up the game:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下游戏的注释截图，看看一些功能的运行和组件/资产组成游戏：
- en: '![Features of Thomas Was Late](img/B05523_12_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Thomas Was Late的特点](img/B05523_12_01.jpg)'
- en: 'Let''s look at each of those features and describe a few more:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些特点，并描述一些更多的特点：
- en: The screenshot shows a simple HUD that details the level number and the number
    of seconds remaining until the players fail and have to restart the level.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 截图显示了一个简单的HUD，详细说明了关卡编号和玩家失败并重新开始关卡之前剩余的秒数。
- en: You can also clearly see the split screen co-op in action. Remember that this
    is optional. A single player can take on the game, fullscreen, while switching
    the camera focus between Thomas and Bob.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以清楚地看到分屏合作游戏的运行情况。请记住这是可选的。单人可以全屏玩游戏，同时在Thomas和Bob之间切换摄像头焦点。
- en: It is not very clear in the screenshot (especially in print), but when a character
    dies, he will explode in a starburst/firework-like particle effect.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在截图中并不太清楚（尤其是在打印品中），但当角色死亡时，他将爆炸成星花/烟火般的粒子效果。
- en: The water and fire tiles can be strategically placed to make the level fun and
    force cooperation between the characters. More on this in [Chapter 14](ch14.html
    "Chapter 14. Building Playable Levels and Collision Detection"), *Building Playable
    Levels and Collision Detection*.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水和火砖可以被策略性地放置，使关卡变得有趣，并迫使角色之间合作。更多内容请参阅[第14章](ch14.html "第14章。构建可玩关卡和碰撞检测"),
    *构建可玩关卡和碰撞检测*。
- en: Notice Thomas and Bob—not only are they different in heights, but they also
    have significantly different jumping abilities. This means that Bob is dependent
    upon Thomas for big jumps, and levels can be designed to force Thomas to take
    a route that avoids him banging his head.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意托马斯和鲍勃——他们不仅身高不同，而且跳跃能力也有很大差异。这意味着鲍勃依赖于托马斯进行大跳跃，关卡可以设计成迫使托马斯选择避免碰头的路线。
- en: In addition, the fire tiles will emit a roaring sound. These will be relative
    to the position of Thomas. Not only will they be directional and come from either
    the left or right speaker, they will also get louder and quieter as Thomas moves
    closer or further away from the source.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，火砖将发出隆隆的声音。这些声音将与托马斯的位置相关。它们不仅是定向的，而且会从左侧或右侧扬声器发出，随着托马斯靠近或远离源头，声音会变得越来越大或越来越小。
- en: Finally, in the annotated screenshot, you can see the background. If you compare
    how that looks to the `background.png` file (shown later in this chapter), you
    will see it is quite different. We will use OpenGL shader effects in [Chapter
    16](ch16.html "Chapter 16.  Extending SFML Classes, Particle Systems, and Shaders"), *Extending
    SFML Classes, Particle Systems, and Shaders*, to achieve the moving—almost bubbling—effect
    in the background.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在带注释的截图中，您可以看到背景。如果您将其与`background.png`文件（本章后面显示）进行比较，您会发现它们是完全不同的。我们将在[第16章](ch16.html
    "第16章。扩展SFML类、粒子系统和着色器"), *扩展SFML类、粒子系统和着色器*中使用OpenGL着色器效果来实现背景中移动的——几乎是冒泡的——效果。
- en: All those features warrant a few more screenshots so we can keep the finished
    product in mind as we write the C++ code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特点都值得再多拍几张截图，这样我们在编写C++代码时可以记住最终成品。
- en: 'The following screenshot shows Thomas and Bob arriving at a fire pit that Bob
    has no chance of jumping over without help:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了托马斯和鲍勃到达一个火坑，鲍勃没有机会跳过去：
- en: '![Features of Thomas Was Late](img/image_12_002.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![《托马斯迟到的特点》](img/image_12_002.jpg)'
- en: 'The following screenshot shows Bob and Thomas collaborating to clear a precarious
    jump:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了鲍勃和托马斯合作清除一个危险的跳跃：
- en: '![Features of Thomas Was Late](img/image_12_003.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![《托马斯迟到的特点》](img/image_12_003.jpg)'
- en: 'The following screenshot shows how we can design puzzles where a "leap of faith"
    is required in order to reach the goal:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们如何设计需要“信仰之跃”才能达到目标的谜题：
- en: '![Features of Thomas Was Late](img/image_12_004.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![《托马斯迟到的特点》](img/image_12_004.jpg)'
- en: 'The following screenshot demonstrates how we can design oppressive cave systems
    of almost any size. We can also devise levels where Bob and Thomas are forced
    to split up and go different routes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了我们如何设计几乎任何大小的压抑洞穴系统。我们还可以设计需要鲍勃和托马斯分开并走不同路线的关卡：
- en: '![Features of Thomas Was Late](img/image_12_005.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![《托马斯迟到的特点》](img/image_12_005.jpg)'
- en: Creating a project from the template
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从模板创建项目
- en: 'Creating the Thomas Was Late project is the same as the other two projects.
    Just follow these straightforward steps in Visual Studio:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建《托马斯迟到》项目与其他两个项目相同。只需在Visual Studio中按照以下简单步骤进行操作：
- en: Select **File** | **New Project** from the main menu.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单中选择**文件** | **新建项目**。
- en: Make sure that **Visual C++** is selected in the left-hand menu and then select
    **HelloSFML** from the list of presented options. The following screenshot should
    make this clear:![Creating a project from the template](img/image_12_006.jpg)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在左侧菜单中选择了**Visual C++**，然后从所呈现的选项列表中选择**HelloSFML**。以下截图应该能清楚地说明这一点：![从模板创建项目](img/image_12_006.jpg)
- en: In the **Name:** field, type `TWL` and also make sure that the **Create directory
    for solution** option is checked. Now click **OK**.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**名称：**字段中，键入`TWL`，并确保选中**为解决方案创建目录**选项。现在点击**确定**。
- en: Now we need to copy the SFML `.dll` files into the main project directory. My
    main project directory is `D:\Visual Studio Stuff\Projects\ TWL\TWL`. This folder
    was created by Visual Studio in the previous step. If you put your `Projects`
    folder somewhere else, perform this step there instead. The files we need to copy
    into the `project` folder are located in your `SFML\bin` folder. Open a window
    for each of the two locations and highlight the required `.dll` files.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要将SFML的`.dll`文件复制到主项目目录中。我的主项目目录是`D:\Visual Studio Stuff\Projects\ TWL\TWL`。这个文件夹是在上一步中由Visual
    Studio创建的。如果您将`Projects`文件夹放在其他地方，请在那里执行此步骤。我们需要复制到`project`文件夹中的文件位于您的`SFML\bin`文件夹中。为每个位置打开一个窗口，并突出显示所需的`.dll`文件。
- en: Now copy and paste the highlighted files into the project.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将突出显示的文件复制并粘贴到项目中。
- en: The project is now set up and ready to go.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 项目现在已经设置好，准备就绪。
- en: The project assets
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目资产
- en: The assets in this project are even more numerous and diverse than the Zombie
    Arena game. As usual, the assets include a font for the writing on the screen,
    sound effects for different actions such as jumping, reaching the goal, or the
    distant roar of fire, and, of course, graphics for Thomas and Bob as well as a
    sprite sheet for all the background tiles.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的资产比僵尸竞技场游戏的资产更多样化和丰富。通常情况下，资产包括屏幕上的文字字体、不同动作的声音效果（如跳跃、达到目标或远处火焰的咆哮）以及托马斯和鲍勃的图形以及所有背景瓷砖的精灵表。
- en: All the assets required for the game are included in the download bundle. They
    can be found in the `Chapter 12/graphics` and `Chapter 12/sound` folders, respectively.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏所需的所有资产都包含在下载包中。它们分别位于`第12章/graphics`和`第12章/sound`文件夹中。
- en: The font that is required has not been supplied. This is because I wanted to
    avoid any possible ambiguity regarding the license. This will not cause a problem
    though, as I will show you exactly where and how to choose and download fonts
    for yourself.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的字体没有提供。这是因为我想避免任何可能的许可歧义。不过这不会造成问题，因为我会准确地告诉你在哪里以及如何为自己选择和下载字体。
- en: Although I will provide either the assets themselves or information on where
    to get them, you might like to create and acquire them for yourself.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我会提供资产本身或者获取它们的信息，但你可能想要自己创建和获取它们。
- en: In addition to the graphics, sound, and fonts that we have come to expect, this
    game has two new asset types. They are level design files and GLSL shader programs.
    Let's find out about each of them next.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们期望的图形、声音和字体之外，这款游戏还有两种新的资产类型。它们是关卡设计文件和GLSL着色器程序。让我们接下来了解一下它们各自的情况。
- en: Game level designs
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏关卡设计
- en: Levels are all created in a text file. By using the numbers 0 through 3, we
    can build level designs to challenge players. All the level designs are in the
    levels folder in the same directory as the other assets. Feel free to take a peek
    at one now, but we will look at them in detail in [Chapter 14](ch14.html "Chapter 14. Building
    Playable Levels and Collision Detection"), *Building Playable Levels and Collision
    Detection*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的关卡都是在一个文本文件中创建的。通过使用数字0到3，我们可以构建挑战玩家的关卡设计。所有的关卡设计都在levels文件夹中，与其他资产在同一个目录中。现在可以随意偷看一下，但我们将在第14章《构建可玩关卡和碰撞检测》中详细讨论它们。
- en: In addition to these level design assets, we have a special type of graphical
    asset, called shaders.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些关卡设计资产，我们还有一种特殊类型的图形资产，称为着色器。
- en: GLSL Shaders
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GLSL着色器
- en: Shaders are programs written in **GLSL** (**Graphics Library Shading Language**).
    Don't worry about having to learn another language, as we don't need to get too
    in-depth to take advantage of shaders. Shaders are special, as they are entire
    programs, separate from our C++ code, which are executed by the GPU each and every
    frame. In fact, some of these shader programs are run every frame, for every pixel!
    We will find out more details in [Chapter 16](ch16.html "Chapter 16.  Extending
    SFML Classes, Particle Systems, and Shaders"), *Extending SFML Classes, Particle
    Systems, and Shaders*. If you can't wait that long, take a look at the files in
    the `Chapter 12/shaders` folder of the download bundle.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器是用**GLSL**（图形库着色语言）编写的程序。不用担心必须学习另一种语言，因为我们不需要深入学习就能利用着色器。着色器很特殊，因为它们是完整的程序，与我们的C++代码分开，由GPU每一帧执行。事实上，一些着色器程序每一帧都会运行，对于每一个像素！我们将在第16章《扩展SFML类、粒子系统和着色器》中了解更多细节。如果你等不及，可以看一下下载包的`Chapter
    12/shaders`文件夹中的文件。
- en: The graphical assets close-up
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图形资产的近距离
- en: 'The graphical assets make up the parts of the scene of our game. Take a look
    at the graphical assets and it should be clear where in our game they will be
    used:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的场景由图形资产组成。看一下图形资产，就可以清楚地知道它们在游戏中将被用在哪里：
- en: '![The graphical assets close-up](img/image_12_007.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: 图形资产的近距离
- en: If the tiles on the `tiles_sheet` graphic look a little different to the screenshots
    of the game, this is because they are partly transparent and the background showing
    through changes them a little. If the background graphic looks totally different
    to the actual background in the game screenshots, that is because the shader programs
    we will write will manipulate each and every pixel, each and every frame, to create
    a kind of "molten" effect.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`tiles_sheet`图形上的瓷砖看起来和游戏截图中的有些不同，这是因为它们部分透明，透过的背景会使它们有些变化。如果背景图看起来和游戏截图中的实际背景完全不同，那是因为我们将编写的着色器程序将操纵每一个像素，每一帧，以创建一种"熔岩"效果。
- en: The sound assets close-up
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声音资产的近距离
- en: 'The sound files are all `.wav` format. These are files that contain the sound
    effects we will play at certain events throughout the game. They are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 声音文件都是`.wav`格式。这些文件包含了我们在游戏中特定事件中播放的声音效果。它们如下：
- en: '`fallinfire.wav`: A sound that will be played when the player''s head goes
    into fire and the player has no chance of escape.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fallinfire.wav`：当玩家的头进入火焰并且玩家没有逃脱的机会时，会播放这个声音。'
- en: '`fallinwater.wav`: Water has the same end effect as fire: death. This sound
    effect notifies the player they need to start from the beginning of the level.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fallinwater.wav`：水和火有相同的效果：死亡。这个声音效果通知玩家他们需要从关卡的开始处重新开始。'
- en: '`fire1.wav`: This sound effect is recorded in mono. It will be played at different
    volumes based on the player''s distance from fire tiles, and from different speakers
    based on whether the player is to the left or the right of the fire tile. Clearly,
    we will need to learn a few more tricks to implement this functionality.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fire1.wav`：这个声音效果是单声道录制的。它将根据玩家距离火砖的距离和不同的扬声器播放不同的音量，根据玩家是在火砖的左侧还是右侧播放。显然，我们需要学习一些更多的技巧来实现这个功能。'
- en: '`jump.wav`: A pleasing (slightly predictable) whooping sound for when the player
    jumps.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jump.wav`：当玩家跳跃时，会发出一种愉悦（略显可预测）的欢呼声。'
- en: '`reachgoal.wav`: A pleasing victory sound for when the player (or players)
    gets both characters (Thomas and Bob) to the goal tile.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reachgoal.wav`：当玩家（或玩家们）将两个角色（Thomas和Bob）都带到目标砖时，会发出一种愉悦的胜利声音。'
- en: The sound effects are very straightforward and you can easily create your own.
    If you intend to replace the `fire1.wav` file, be sure to save your sound in a
    mono (not stereo) format. The reasons for this will be explained in [Chapter 15](ch15.html
    "Chapter 15. Sound Spatialization and HUD"), *Sound Spacialization and HUD*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 声音效果非常简单，你可以很容易地创建自己的声音。如果你打算替换`fire1.wav`文件，请确保将你的声音保存为单声道（而不是立体声）格式。这个原因将在第15章《声音空间化和HUD》中解释。
- en: Adding the assets to the project
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将资产添加到项目中
- en: Once you have decided which assets you will use, it is time to add them to the
    project. The following instructions will assume you are using all the assets supplied
    in the book's download bundle.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定使用哪些资产，就该将它们添加到项目中了。以下说明将假定您使用了书籍下载包中提供的所有资产。
- en: 'Where you are using your own, simply replace the appropriate sound or graphic
    file with your chosen file, using exactly the same filename:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用自己的资产，只需用您选择的文件替换相应的声音或图形文件，文件名完全相同即可：
- en: Browse to the Visual `D:\Visual Studio Stuff\Projects\TWL\TWL` directory.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到Visual `D:\Visual Studio Stuff\Projects\TWL\TWL`目录。
- en: Create five new folders within this folder and name them as `graphics`, `sound`,
    `fonts`, `shaders`, and `levels`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中创建五个新文件夹，并将它们命名为`graphics`、`sound`、`fonts`、`shaders`和`levels`。
- en: From the download bundle, copy the entire contents of `Chapter 12/graphics`
    into the `D:\Visual Studio Stuff\Projects\TWL\TWL\graphics` folder.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将`第12章/图形`文件夹中的所有内容复制到`D:\Visual Studio Stuff\Projects\TWL\TWL\graphics`文件夹中。
- en: From the download bundle, copy the entire contents of `Chapter 12/sound` into
    the `D:\Visual Studio Stuff\Projects\TWL\TWL\sound` folder.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将`第12章/声音`文件夹中的所有内容复制到`D:\Visual Studio Stuff\Projects\TWL\TWL\sound`文件夹中。
- en: Now visit [http://www.dafont.com/roboto.font](http://www.dafont.com/roboto.font)
    in your web browser and download the **Roboto Light** font.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在您的网络浏览器中访问[http://www.dafont.com/roboto.font](http://www.dafont.com/roboto.font)，并下载**Roboto
    Light**字体。
- en: Extract the contents of the zipped download and add the `Roboto-Light.ttf` file
    to the `D:\Visual Studio Stuff\Projects\TWL\TWL\fonts` folder.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压缩下载的内容，并将`Roboto-Light.ttf`文件添加到`D:\Visual Studio Stuff\Projects\TWL\TWL\fonts`文件夹中。
- en: From the download bundle, copy the entire contents of `Chapter 12/levels` into
    the `D:\Visual Studio Stuff\Projects\TWL\TWL\levels` folder.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将`第12章/关卡`文件夹中的所有内容复制到`D:\Visual Studio Stuff\Projects\TWL\TWL\levels`文件夹中。
- en: From the download bundle, copy the entire contents of `Chapter 12/shaders` into
    the `D:\Visual Studio Stuff\Projects\TWL\TWL\shaders` folder.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将`第12章/着色器`文件夹中的所有内容复制到`D:\Visual Studio Stuff\Projects\TWL\TWL\shaders`文件夹中。
- en: Now that we have a new project, along with all the assets we will need for the
    entire project, we can talk about how we will structure the game engine code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个新项目，以及整个项目所需的所有资产，我们可以讨论如何构建游戏引擎代码。
- en: Structuring the Thomas Was Late code
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化Thomas Was Late代码
- en: One of the problems that has been quite pronounced in both projects so far is
    how long and unwieldy the code gets. OOP allows us to break our projects up into
    logical and manageable chunks called classes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，两个项目中都存在一个问题，那就是代码变得越来越长和难以控制。面向对象编程允许我们将项目分解为称为类的逻辑和可管理的块。
- en: We will make a big improvement to the manageability of the code in this project
    with the introduction of an **Engine class**. Among other functions, the Engine
    class will have three private functions. They are `input`, `update`, and `draw`.
    This should sound very familiar. Each of these functions will hold a chunk of
    the code that was previously all in the `main` function. Each of these functions
    will be in a code file of its own, `Input.cpp`, `Update.cpp`, and `Draw.cpp` respectively.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入**Engine类**，我们将在这个项目中大大改善代码的可管理性。除其他功能外，Engine类将有三个私有函数。它们是`input`、`update`和`draw`。这应该听起来很熟悉。这些函数中的每一个将包含以前全部在`main`函数中的代码块。这些函数将分别在自己的代码文件中，`Input.cpp`、`Update.cpp`和`Draw.cpp`中。
- en: 'There will also be one public function in the `Engine` class, which can be
    called with an instance of `Engine`. This function is `run` and will be responsible
    for calling `input`, `update`, and `draw`, once for each frame of the game:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Engine`类中还将有一个公共函数，可以使用`Engine`的实例调用。这个函数是`run`，将负责调用`input`、`update`和`draw`，每帧游戏调用一次：'
- en: '![Structuring the Thomas Was Late code](img/image_12_008.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![结构化Thomas Was Late代码](img/image_12_008.jpg)'
- en: 'Furthermore, because we have abstracted the major parts of the game engine
    to the `Engine` class, we can also move many of the variables from `main` and
    make them members of `Engine`. All we need to do to get our game engine fired
    up is create an instance of `Engine` and call its `run` function. Here is a sneak
    preview of the super-simple main function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们已经将游戏引擎的主要部分抽象到了`Engine`类中，我们还可以将`main`中的许多变量移到`Engine`的成员中。我们只需要创建一个`Engine`的实例并调用它的`run`函数，就可以启动我们的游戏引擎。以下是一个简单的`main`函数的预览：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't add the preceding code just yet.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时不要添加前面的代码。
- en: To make our code even more manageable and readable, we will also abstract responsibility
    for big tasks, such as loading a level and collision detection, to separate functions
    (in separate code files). These two functions are `loadLevel` and `detectCollisions`.
    We will also code other functions to handle some of the new features of the Thomas
    Was Late project. We will cover them in detail as and when they occur.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的代码更易于管理和阅读，我们还将抽象出一些大任务的责任，例如加载关卡和碰撞检测，放到单独的函数中（在单独的代码文件中）。这两个函数是`loadLevel`和`detectCollisions`。我们还将编写其他函数来处理Thomas
    Was Late项目的一些新功能。我们将在出现时详细介绍它们。
- en: To further take advantage of OOP, we will delegate responsibility for particular
    areas of the game entirely to new classes. You probably remember that the sound
    and HUD code was quite lengthy in previous projects. We will build a `SoundManager`
    and `HUD` class to handle these aspects in a cleaner manner. Exactly how they
    work will be explored in depth when we implement them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地利用面向对象编程，我们将完全将游戏特定领域的责任委托给新的类。您可能还记得以前项目中的声音和HUD代码非常冗长。我们将构建`SoundManager`和`HUD`类来更清晰地处理这些方面。当我们实现它们时，将深入探讨它们的工作原理。
- en: The game levels themselves are much more in-depth than previous games, so we
    will also code a `LevelManager` class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏关卡本身比以前的游戏更加深入，因此我们还将编写一个`LevelManager`类。
- en: As you would expect, the playable characters will be made with classes as well.
    For this project, however, we will learn some more C++ and implement a `PlayableCharacter`
    class with all the common functionality of Thomas and Bob, and then `Thomas` and
    `Bob` classes, which will inherit this common functionality as well as implement
    their own unique functions and abilities. This, perhaps unsurprisingly, is called
    **inheritance**. I will go into more detail about inheritance in the following
    [Chapter 13](ch13.html "Chapter 13. Advanced OOP – Inheritance and Polymorphism"), *Advanced
    OOP, Inheritance, and Polymorphism*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的，可玩角色也将使用类制作。但是，对于这个项目，我们将学习更多的C++并实现一个`PlayableCharacter`类，其中包含Thomas和Bob的所有常见功能，然后`Thomas`和`Bob`类，它们将继承这些常见功能，并实现自己的独特功能和能力。这可能并不奇怪，被称为**继承**。我将在接下来的[第13章](ch13.html
    "第13章。高级面向对象编程-继承和多态")，“高级面向对象编程，继承和多态”中更详细地介绍继承。
- en: We will also implement a number of other classes to perform specific responsibilities.
    For example, we will make some neat explosions using particle systems. You might
    be able to guess that to do this, we will code a `Particle` class and a `ParticleSystem`
    class. All of these classes will have instances that are members of the `Engine`
    class. Doing things this way will make all the features of the game accessible
    from the game engine, but encapsulate the details into appropriate classes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现一些其他类来执行特定的职责。例如，我们将使用粒子系统制作一些漂亮的爆炸效果。您可能能够猜到，为了做到这一点，我们将编写一个`Particle`类和一个`ParticleSystem`类。所有这些类都将作为`Engine`类的成员实例。以这种方式做事将使游戏的所有功能都可以从游戏引擎中访问，但将细节封装到适当的类中。
- en: The last thing to mention before we move on to see the actual code that will
    make the Engine class is that we will reuse, without any changes whatsoever, the
    `TextureHolder` class, which we discussed and coded for the Zombie Arena game.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续查看将创建引擎类的实际代码之前，要提到的最后一件事是，我们将重用在僵尸竞技场游戏中讨论和编写的`TextureHolder`类，而且不会有任何改变。
- en: Building the game engine
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建游戏引擎
- en: As suggested in the previous discussion, we will code a class called `Engine`
    that will control and bind together the different parts of the Thomas Was Late
    game.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面讨论所建议的，我们将编写一个名为`Engine`的类，它将控制并绑定Thomas Was Late游戏的不同部分。
- en: The first thing we will do is make the `TextureHolder` class from the previous
    project available in this one.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是使上一个项目中的`TextureHolder`类在这个项目中可用。
- en: Reusing the TextureHolder class
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重用TextureHolder类
- en: The `TextureHolder` class that we discussed and coded for the Zombie Arena game
    will also be useful in this project. While it is possible to add the files (`TextureHolder.h`
    and `TextureHolder.cpp`) directly from the previous project without recoding them
    or recreating the files, I don't want to make the assumption that you haven't
    jumped straight to this project. What follows is very brief instructions, along
    with the complete code listing to create the `TextureHolder` class. If you want
    the class or the code explained, please see [Chapter 8](ch08.html "Chapter 8. Pointers,
    the Standard Template Library, and Texture Management"), *Pointers, Standard Template
    Library, and Texture Management*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论并为僵尸竞技场游戏编写的`TextureHolder`类在这个项目中也会很有用。虽然可以直接从上一个项目添加文件（`TextureHolder.h`和`TextureHolder.cpp`）而不需要重新编码或重新创建文件，但我不想假设你没有直接跳到这个项目。接下来是非常简要的说明，以及创建`TextureHolder`类的完整代码清单。如果您想要解释这个类或代码，请参阅[第8章](ch08.html
    "第8章。指针、标准模板库和纹理管理")，“指针、标准模板库和纹理管理”。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you did complete the previous project and you *do* want to add the class
    from the Zombie Arena project, simply do the following: in the **Solution Explorer**
    window, right-click **Header Files** and select **Add** | **Existing Item...**.
    Browse to `TextureHolder.h` from the previous project and select it. In the **Solution
    Explorer** window, right-click on **Source Files** and select **Add** | **Existing
    Item...**. Browse to `TextureHolder.cpp` from the previous project and select
    it. You can now use the `TextureHolder` class in this project. Note that the files
    are shared between projects and any changes will take effect in both projects.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您完成了上一个项目，并且*确实*想要从僵尸竞技场项目中添加类，只需执行以下操作：在**解决方案资源管理器**窗口中，右键单击**头文件**，然后选择**添加**
    | **现有项...**。浏览到上一个项目的`TextureHolder.h`并选择它。在**解决方案资源管理器**窗口中，右键单击**源文件**，然后选择**添加**
    | **现有项...**。浏览到上一个项目的`TextureHolder.cpp`并选择它。现在您可以在这个项目中使用`TextureHolder`类。请注意，文件在项目之间共享，任何更改都将在两个项目中生效。
- en: To create the `TextureHolder` class from scratch, right-click **Header Files**
    in the **Solution Explorer** and select **Add** | **New Item...**. In the **Add
    New Item** window, highlight (by left-clicking) **Header File (.h)** and then
    in the **Name** field, type `TextureHolder.h`. Finally, click the **Add** button.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要从头开始创建`TextureHolder`类，请在**解决方案资源管理器**中右键单击**头文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**头文件（.h）**，然后在**名称**字段中键入`TextureHolder.h`。最后，单击**添加**按钮。
- en: 'Add the following code to `TextureHolder.h`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`TextureHolder.h`：
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then, in the **Name** field, type `TextureHolder.cpp`.
    Finally, click the **Add** button.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**C++文件（**
    `.cpp` **）**，然后在**名称**字段中键入`TextureHolder.cpp`。最后，单击**添加**按钮。
- en: 'Add the following code to `TextureHolder.cpp`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`TextureHolder.cpp`：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can now get on with our new `Engine` class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以继续使用我们的新`Engine`类。
- en: Coding Engine.h
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Engine.h
- en: As usual, we will start with the header file, which holds the function declarations
    and member variables. Note that we will revisit this file throughout the project
    to add more functions and member variables. For now, we will add just the code
    that is necessary at this stage.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们将从头文件开始，其中包含函数声明和成员变量。请注意，我们将在整个项目中重新访问此文件，以添加更多函数和成员变量。目前，我们将只添加在此阶段必要的代码。
- en: Right-click **Header Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **Header File (** `.h` **)** and then in the **Name** field, type `Engine.h`.
    Finally, click the **Add** button. We are now ready to code the header file for
    the `Engine` class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**头文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**头文件（**`.h`**）**，然后在**名称**字段中输入`Engine.h`。最后，单击**添加**按钮。现在我们准备为`Engine`类编写头文件。
- en: 'Add the following member variables as well as the function declarations. Many
    of them we have seen before in the other projects, and some of them we discussed
    in the *Structuring the Thomas Was Late* code section. Take note of the function
    and variable names, as well as whether they are private or public. Add the following
    code to the `Engine.h` file, and then we will talk about it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下成员变量以及函数声明。其中许多我们在其他项目中已经见过，有些我们在*Structuring the Thomas Was Late*代码部分讨论过。请注意函数和变量的名称，以及它们是私有的还是公共的。添加以下代码到`Engine.h`文件，然后我们将讨论它：
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is a complete run-down of all the private variables and functions. Where
    appropriate, I spend a little longer on the explanation:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有私有变量和函数的完整说明。在适当的情况下，我会更详细地解释一下：
- en: '`TextureHolder th`: The one and only instance of the `TextureHolder` class.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextureHolder th`：`TextureHolder` 类的唯一实例。'
- en: '`TILE_SIZE`: A useful constant to remind us that each tile in the sprite sheet
    is fifty pixels wide and fifty pixels high.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TILE_SIZE`：一个有用的常量，提醒我们精灵表中的每个瓷砖都是50像素宽和50像素高。'
- en: '`VERTS_IN_QUAD`: A useful constant to make our manipulation of a `VertexArray`
    less error prone. There are, in fact, four vertices in a quad. Now we can''t forget
    it.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VERTS_IN_QUAD`：一个有用的常量，使我们对 `VertexArray` 的操作不那么容易出错。事实上，一个四边形中有四个顶点。现在我们不会忘记它了。'
- en: '`GRAVITY`: A constant `int` value representing the number of pixels by which
    the game characters will be pushed downward each second. This is quite a fun value
    to play with once the game is done. We initialize it to `300`, as this works well
    for our initial level designs.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GRAVITY`：一个表示游戏角色每秒向下推动的像素数的常量`int`值。一旦游戏完成，这个值就变得非常有趣。我们将其初始化为`300`，因为这对我们最初的关卡设计效果很好。'
- en: '`m_Window`: The usual `RenderWindow` object, like we have had in all our projects.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_Window`：通常的 `RenderWindow` 对象，就像我们在所有项目中都有的那样。'
- en: 'The SFML `View` objects, `m_MainView`, `m_LeftView`, `m_RightView`, `m_BGMainView`,
    `m_BGLeftView`, `m_BGRightView`, and `m_HudView`: The first three `View` objects
    are for the fullscreen view, and left and right split screen views of the game.
    We also have a separate SFML `View` object for each of those three, which will
    draw the background behind. The last `View` object, `m_HudView`, will be drawn
    on top of the appropriate combination of the other six views to display the score,
    the remaining time, and any messages to the players. Having seven different `View`
    objects might imply complexity, but when you see how we deal with them as the
    chapter progresses, you will see they are quite straightforward. We will have
    the whole split screen/fullscreen conundrum sorted out by the end of this chapter.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SFML `View` 对象，`m_MainView`，`m_LeftView`，`m_RightView`，`m_BGMainView`，`m_BGLeftView`，`m_BGRightView`
    和 `m_HudView`：前三个 `View` 对象用于全屏视图，左右分屏游戏视图。我们还为这三个视图中的每一个单独创建了一个SFML `View` 对象，用于绘制背景。最后一个
    `View` 对象 `m_HudView` 将在其他六个视图的适当组合上方绘制，以显示得分、剩余时间和向玩家发送的任何消息。有七个不同的 `View` 对象可能意味着复杂性，但当您在本章的进展中看到我们如何处理它们时，您会发现它们非常简单。我们将在本章结束时解决整个分屏/全屏问题。
- en: '`Sprite m_BackgroundSprite` and `Texture m_BackgroundTexture`: Somewhat predictably,
    this combination of SFML `Sprite` and `Texture` will be for showing and holding
    the background graphic from the graphics assets folder.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite m_BackgroundSprite` 和 `Texture m_BackgroundTexture`：可以预料到，这对SFML `Sprite`
    和 `Texture` 将用于显示和保存来自图形资产文件夹的背景图形。'
- en: '`m_Playing`: This Boolean will keep the game engine informed about whether
    the level has started yet (by pressing the ***Enter*** key). The player does not
    have the option to pause the game once they have started it.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_Playing`：这个布尔值将让游戏引擎知道关卡是否已经开始（通过按下***Enter***键）。一旦玩家开始游戏，他们就没有暂停游戏的选项。'
- en: '`m_Character1`: When the screen is fullscreen, should it center on Thomas (m_Character1
    = true), or Bob (m_Character1 = false)? Initially, it is initialized to true,
    to center on Thomas.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_Character1`：当屏幕全屏时，它应该居中显示Thomas（m_Character1 = true），还是Bob（m_Character1
    = false）？最初，它被初始化为true，以便居中显示Thomas。'
- en: '`m_SplitScreen`: Is the game currently being played in split screen mode or
    not? We will use this variable to decide how exactly to use all the View objects
    we declared a few steps ago.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_SplitScreen`：游戏当前是否以分屏模式进行？我们将使用这个变量来决定如何使用我们之前声明的所有 `View` 对象。'
- en: '`m_TimeRemaining` variable: This `float` variable holds how much time is remaining
    to get to the goal of the current level. In the previous code, it is set to `10`
    for the purposes of testing, until we actually get to set a specific time for
    each level.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_TimeRemaining` 变量：这个 `float` 变量保存当前关卡剩余的时间。在之前的代码中，为了测试目的，它被设置为`10`，直到我们真正为每个关卡设置特定的时间。'
- en: '`m_GameTimeTotal` variable: This variable is an SFML Time object. It keeps
    track of how long the game has been played for.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_GameTimeTotal` 变量：这个变量是一个SFML Time对象。它跟踪游戏已经进行了多长时间。'
- en: '`m_NewLevelRequired` Boolean variable: This variable keeps a check on whether
    the player has just completed or failed a level. We can then use it to trigger
    the loading of the next level or the restarting of the current level.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m_NewLevelRequired`布尔变量：此变量检查玩家是否刚刚完成或失败了一个级别。然后我们可以使用它来触发加载下一个级别或重新启动当前级别。'
- en: 'The `input` function: This function will handle all of the player''s input,
    which in this game is entirely from the keyboard. At first glance, it would appear
    that it handles all the keyboard input directly. In this game, however, we will
    be handling keyboard input that directly affects Thomas or Bob within the `Thomas`
    and `Bob` classes directly. We will call the `input` function, and this function
    will directly handle keyboard inputs such as quitting, switching to split screen,
    and any other keyboard input.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input`函数：此函数将处理玩家的所有输入，这在本游戏中完全来自键盘。乍一看，似乎它直接处理所有键盘输入。然而，在这个游戏中，我们将直接处理影响`Thomas`和`Bob`类中的Thomas或Bob的键盘输入。我们将调用`input`函数，而这个函数将直接处理键盘输入，例如退出、切换到分屏以及其他任何键盘输入。'
- en: 'The `update` function: This function will do all the work that we previously
    did in the update section of the `main` function. We will also call some other
    functions from the `update` function in order to keep the code organized. If you
    look back at the code, you will see that it receives a `float` parameter, which
    will hold the fraction of a second that has passed since the previous frame. This,
    of course, is just what we need to update all our game objects.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`函数：此函数将执行我们以前在`main`函数的更新部分中执行的所有工作。我们还将从`update`函数中调用一些其他函数，以便保持代码组织良好。如果您回顾代码，您将看到它接收一个`float`参数，该参数将保存自上一帧以来经过的秒数的分数。当然，这正是我们需要更新所有游戏对象的内容。'
- en: 'The `draw` function: This function will hold all the code that used to go in
    the drawing section of the main function in previous projects. We will, however,
    have some drawing code that is not kept in this function when we look at other
    ways to draw with SFML. We will see this new code when we learn about particle
    systems in [Chapter 16](ch16.html "Chapter 16.  Extending SFML Classes, Particle
    Systems, and Shaders"), *Extending SFML Classes, Particle Systems, and Shaders*.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw`函数：此函数将包含以前项目的主函数中绘图部分中的所有代码。然而，当我们学习使用SFML进行其他绘图方式时，将有一些绘图代码不在此函数中。当我们学习[第16章](ch16.html
    "第16章。扩展SFML类、粒子系统和着色器")中的粒子系统时，我们将看到这些新代码，*扩展SFML类、粒子系统和着色器*。'
- en: 'Now let''s run through all the public functions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们逐一运行所有公共函数：
- en: 'The `Engine` constructor function: As we have come to expect, this function
    will be called when we first declare an instance of `Engine`. It will do all the
    setup and initialization of the class. We will see exactly what when we code the
    `Engine.cpp` file shortly.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Engine`构造函数：正如我们所期望的那样，当我们首次声明`Engine`的实例时，将调用此函数。它将对类进行所有设置和初始化。我们将很快在编写`Engine.cpp`文件时看到确切的情况。'
- en: 'The `run` function: This is the only public function that we need to call.
    It will trigger the execution of input, update, and draw, which will do all the
    work.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`函数：这是我们需要调用的唯一公共函数。它将触发输入、更新和绘制的执行，这将完成所有工作。'
- en: Next, we will see the definition of all these functions and some of the variables
    in action.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到所有这些函数的定义以及一些变量的作用。
- en: Coding Engine.cpp
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Engine.cpp
- en: In all our previous classes, we have put all the function definitions into the
    `.cpp` file, prefixed with the class name. As our aim for this project is to make
    the code more manageable, we are doing things a little differently.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的所有类中，我们将所有函数定义放入`.cpp`文件中，并以类名为前缀。由于我们这个项目的目标是使代码更易管理，我们正在以稍有不同的方式进行操作。
- en: In the `Engine.cpp` file, we will put the constructor (`Engine`) and the public
    `run` function. All the rest of the functions will go in their own `.cpp` file,
    with a name that makes it clear what function goes where. This will not be a problem
    for the compiler as long as we add the appropriate include directive (`#include
    "Engine.h"`) at the top of all the files that contain function definitions from
    the `Engine` class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Engine.cpp`文件中，我们将放置构造函数（`Engine`）和公共`run`函数。所有其他函数将放在自己的`.cpp`文件中，文件名清楚地说明了哪个函数放在哪里。只要我们在包含`Engine`类函数定义的所有文件顶部添加适当的包含指令（`#include
    "Engine.h"`），这对编译器来说不会是问题。
- en: Let's get started by coding `Engine` and run it in `Engine.cpp`. Right-click
    **Source Files** in the **Solution Explorer** and select **Add** | **New Item...**.
    In the **Add New Item** window, highlight (by left-clicking) **C++ File (.cpp)**
    and then in the **Name** field, type `Engine.cpp`. Finally, click the **Add**
    button. We are now ready to code the `.cpp` file for the `Engine` class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写`Engine`并在`Engine.cpp`中运行它。在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加** | **新建项...**。在**添加新项**窗口中，通过左键单击**C++文件（.cpp）**，然后在**名称**字段中键入`Engine.cpp`。最后，单击**添加**按钮。现在我们准备好为`Engine`类编写`.cpp`文件。
- en: Coding the Engine class constructor definition
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写Engine类构造函数定义
- en: The code for this function will go in the `Engine.cpp` file we have recently
    created.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的代码将放在我们最近创建的`Engine.cpp`文件中。
- en: 'Add the following code and then we can discuss it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码，然后我们可以讨论它：
- en: '[PRE4]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Much of the code we have seen before. For example, there are the usual lines
    of code to get the screen resolution as well as to create a `RenderWindow`. At
    the end of the previous code we use the now familiar code to load a texture and
    assign it to a Sprite. In this case we are loading the `background.png` texture
    and assigning it to `m_BackgroundSprite`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前见过很多代码。例如，有通常的代码行来获取屏幕分辨率以及创建`RenderWindow`。在前面的代码末尾，我们使用了现在熟悉的代码来加载纹理并将其分配给Sprite。在这种情况下，我们正在加载`background.png`纹理并将其分配给`m_BackgroundSprite`。
- en: It is the code in between, the four calls to the `setViewport` function, that
    needs some explanation. The `setViewport` function assigns a portion of the screen
    to an SFML `View` object. It doesn't work using pixel coordinates, however. It
    works using a ratio. Where "1" is the entire screen (width or height), the first
    two values in each call to `setViewport` are the starting position (horizontally,
    then vertically) and the last two are the ending position.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在四次调用`setViewport`函数之间的代码需要一些解释。`setViewport`函数将屏幕的一部分分配给SFML`View`对象。但它不使用像素坐标，而是使用比例。其中“1”是整个屏幕（宽度或高度），每次调用`setViewport`的前两个值是起始位置（水平，然后垂直），最后两个值是结束位置。
- en: Notice that the `m_LeftView` and `m_BGLeftView` are placed in exactly the same
    place, starting at virtually the far left (0.001) of the screen, and ending two
    1,000ths from the center (0.498).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`m_LeftView`和`m_BGLeftView`放置在完全相同的位置，从屏幕的几乎最左边（0.001）开始，到离中心的两千分之一（0.498）结束。
- en: The `m_RightView` and `m_BGRightView` are also in exactly the same position,
    starting just left of the previous two `View` objects (0.5) and extending to almost
    the far right-hand side (0.998) of the screen.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_RightView`和`m_BGRightView`也处于完全相同的位置，从前两个`View`对象的左侧开始（0.5），延伸到屏幕的几乎最右侧（0.998）。'
- en: Furthermore, all the views leave a tiny sliver of a gap at the top and bottom
    of the screen. When we draw these `View` objects on the screen on top of a white
    background, it will have the effect of splitting the screen with a thin white
    line between the two sides of the screen, as well as a thin white border around
    the edges.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有视图在屏幕的顶部和底部留下一小片空隙。当我们在白色背景上绘制这些`View`对象时，它将产生在屏幕的两侧之间有一条细白线以及边缘周围有一条细白边框的效果。
- en: 'I have tried to represent this effect in the following diagram:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经尝试在以下图表中表示这种效果：
- en: '![Coding the Engine class constructor definition](img/image_12_009.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![编写引擎类构造函数定义](img/image_12_009.jpg)'
- en: The best way to understand it is to finish this chapter, run the code, and see
    it in action.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 理解它的最佳方法是完成本章，运行代码，并看到它的实际效果。
- en: Coding the run function definition
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写运行函数定义
- en: The code for this function will go in the `Engine.cpp` file we have recently
    created.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的代码将放在我们最近创建的`Engine.cpp`文件中。
- en: 'Add the following code immediately after the previous constructor code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个构造函数代码之后立即添加以下代码：
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The run function is the center of our engine—it initiates all the other parts.
    First, we declare a Clock object. Next, we have the familiar `while(window.isOpen())`
    loop, which creates the game loop. Inside this while loop, we do the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行函数是我们引擎的中心-它启动所有其他部分。首先，我们声明一个Clock对象。接下来，我们有熟悉的`while(window.isOpen())`循环，它创建游戏循环。在这个while循环内，我们做以下事情：
- en: Restart `clock` and save the time that the previous loop took in `dt`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动`clock`并保存上一个循环中所花费的时间`dt`。
- en: Keep track of the total time elapsed in `m_GameTimeTotal`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`m_GameTimeTotal`中跟踪总经过时间。
- en: Declare and initialize a `float` to represent the fraction of a second that
    elapsed during the previous frame.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并初始化一个`float`来表示上一帧经过的秒数。
- en: Call `input`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`input`。
- en: Call `update` passing in the elapsed time (`dtAsSeconds`).
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`update`并传入经过的时间（`dtAsSeconds`）。
- en: Call `draw`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`draw`。
- en: All of this should look very familiar. What is new is that it is wrapped in
    the `run` function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都应该看起来非常熟悉。新的是它包含在`run`函数中。
- en: Coding the input function definition
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写输入函数定义
- en: As explained previously, the code for this function will go in its own file
    because it is more extensive than the constructor or the `run` function. We will
    use `#include "Engine.h"` and prefix the function signature with `Engine::` to
    make sure the compiler is aware of our intentions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此函数的代码将放在自己的文件中，因为它比构造函数或`run`函数更加复杂。我们将使用`#include "Engine.h"`并在函数签名前加上`Engine::`以确保编译器知道我们的意图。
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `Input.cpp`.
    Finally, click the **Add** button. We are now ready to code the `input` function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加** | **新项目...**。在**添加新项目**窗口中，通过左键单击突出显示（单击）**C++文件（**`.cpp`**）**，然后在**名称**字段中键入`Input.cpp`。最后，单击**添加**按钮。现在我们准备编写`input`函数。
- en: 'Add the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE6]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As with both of the previous projects, we check the `RenderWindow` event queue
    each frame. Also, as we have done before, we detect specific keyboard keys using
    `if (Keyboard::isKeyPressed(Keyboard::E))`. What is most relevant in the code
    we just added is what the keys actually do:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的两个项目一样，我们每帧都会检查`RenderWindow`事件队列。同样，我们之前所做的一样，使用`if (Keyboard::isKeyPressed(Keyboard::E))`来检测特定的键。我们刚刚添加的代码中最重要的是这些键实际上做了什么：
- en: As usual, the ***Esc*** key closes the window and the game will quit.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，***Esc***键关闭窗口，游戏将退出。
- en: The ***Enter*** key sets `m_Playing` to true, and eventually, this will have
    the effect of starting the level.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Enter***键将`m_Playing`设置为true，最终，这将导致开始关卡。'
- en: The ***Q*** key alternates the value of `m_Character1` between `true` and `false`.
    This key only has an effect in fullscreen mode. It will switch between Thomas
    and Bob being the center of the main `View`.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Q***键在全屏模式下在`m_Character1`的值之间切换`true`和`false`。它将在主`View`的Thomas和Bob之间切换。'
- en: The ***E*** key switches `m_SplitScreen` between `true` and `false`. This will
    have the effect of switching between fullscreen and split screen views.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***E***键在`m_SplitScreen`之间切换`true`和`false`。这将导致在全屏和分屏视图之间切换。'
- en: The majority of this keyboard functionality will be fully working by the end
    of the chapter. We are getting close to being able to run our game engine. Next,
    let's code the `update` function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分键盘功能将在本章结束时完全可用。我们即将能够运行我们的游戏引擎。接下来，让我们编写`update`函数。
- en: Coding the update function definition
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写更新函数定义
- en: As explained previously, the code for this function will go in its own file
    because it is more extensive than the constructor or the `run` function. We will
    use `#include "Engine.h"` and prefix the function signature with `Engine::` to
    make sure the compiler is aware of our intentions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此函数的代码将放在自己的文件中，因为它比构造函数或`run`函数更加复杂。我们将使用`#include "Engine.h"`并在函数签名前加上`Engine::`以确保编译器了解我们的意图。
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `Update.cpp`.
    Finally, click the **Add** button. We are now ready to write some code for the
    `update` function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加** | **新建项目...**。在**添加新项目**窗口中，通过左键单击选择**C++文件（**`.cpp`
    **）**，然后在**名称**字段中键入`Update.cpp`。最后，单击**添加**按钮。现在我们准备为`update`函数编写一些代码。
- en: 'Add the following code to the `Update.cpp` file to implement the `update` function:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Update.cpp`文件中以实现`update`函数：
- en: '[PRE7]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First of all, notice that the `update` function receives the time the previous
    frame took as a parameter. This, of course, will be essential for the update function
    to fulfill its role.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，`update`函数接收上一帧所用时间作为参数。这当然对于`update`函数履行其职责至关重要。
- en: The preceding code doesn't achieve anything visible at this stage. It does put
    in the structure that we will require for future chapters. It subtracts the time
    the previous frame took from `m_TimeRemaining`. It checks whether time has run
    out, and if it has, it sets `m_NewLevelRequired` to `true`. All this code is wrapped
    in an `if` statement that only executes when `m_Playing` is `true`. The reason
    for this is because, as with the previous projects, we don't want time advancing
    and objects updating when the game has not started.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，上述代码并没有实现任何可见的效果。它为我们将来的章节提供了所需的结构。它从`m_TimeRemaining`中减去了上一帧所用的时间。它检查时间是否已经用完，如果是，则将`m_NewLevelRequired`设置为`true`。所有这些代码都包裹在一个`if`语句中，只有当`m_Playing`为`true`时才执行。原因是，与以前的项目一样，我们不希望在游戏尚未开始时时间推移和对象更新。
- en: We will build on this code as the project continues.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的继续，我们将在此基础上构建代码。
- en: Coding the draw function definition
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写绘制函数定义
- en: As explained previously, the code for this function will go in its own file,
    because it is more extensive than the constructor or the `run` function. We will
    use `#include "Engine.h"` and prefix the function signature with `Engine::` to
    make sure the compiler is aware of our intentions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此函数的代码将放在自己的文件中，因为它比构造函数或`run`函数更加复杂。我们将使用`#include "Engine.h"`并在函数签名前加上`Engine::`以确保编译器了解我们的意图。
- en: Right-click **Source Files** in the **Solution Explorer** and select **Add**
    | **New Item...**. In the **Add New Item** window, highlight (by left-clicking)
    **C++ File (** `.cpp` **)** and then in the **Name** field, type `Draw.cpp`. Finally,
    click the **Add** button. We are now ready to add some code to the `draw` function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在**解决方案资源管理器**中右键单击**源文件**，然后选择**添加** | **新建项目...**。在**添加新项目**窗口中，通过左键单击选择**C++文件（**`.cpp`
    **）**，然后在**名称**字段中键入`Draw.cpp`。最后，单击**添加**按钮。现在我们准备为`draw`函数添加一些代码。
- en: 'Add the following code to the `Draw.cpp` file to implement the `draw` function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Draw.cpp`文件中以实现`draw`函数：
- en: '[PRE8]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding code, there is nothing we haven''t seen before. The code starts,
    as usual, by clearing the screen. In this project, we clear the screen with white.
    What is new is the way the different drawing options are separated by a condition,
    which checks whether the screen is currently split or full:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，没有什么是我们以前没有见过的。代码通常从清除屏幕开始。在这个项目中，我们用白色清除屏幕。新的是不同的绘制选项是如何通过条件分隔的，检查屏幕当前是分割还是全屏：
- en: '[PRE9]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the screen is not split, we draw the background sprite in the background
    `View` (`m_BGView`) and then switch to the main fullscreen `View` (`m_MainView`).
    Note that at the moment, we don't actually do any drawing in `m_MainView`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果屏幕没有分割，我们在背景`View`（`m_BGView`）中绘制背景精灵，然后切换到主全屏`View`（`m_MainView`）。请注意，目前我们实际上并没有在`m_MainView`中进行任何绘制。
- en: If, on the other hand, the screen is split, the code in the `else` block is
    executed and we draw `m_BGLeftView` with the background sprite on the left of
    the screen, followed by switching to `m_LeftView`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果屏幕被分割，将执行`else`块中的代码，并在屏幕左侧绘制`m_BGLeftView`上的背景精灵，然后切换到`m_LeftView`。
- en: Then, still in the `else` block, we draw `m_BGRightView` with the background
    sprite on the right of the screen, followed by switching to `m_RightView`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`else`块中，我们绘制`m_BGRightView`上的背景精灵，然后切换到`m_RightView`。
- en: Outside of the `if…else` structure just described, we switch to  `m_HUDView`.
    At this stage, we are not actually drawing anything in `m_HUDView`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚才描述的`if...else`结构之外，我们切换到`m_HUDView`。在这个阶段，我们实际上并没有在`m_HUDView`中绘制任何东西。
- en: As with the other two (`input`, `update`) of the three most significant functions,
    we will be back here at the `draw` function often. We will add new elements of
    our game that need to be drawn. You will notice that each time we do, we will
    add code into each of the main, left, and right sections.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与另外两个（`input`，`update`）最重要的函数一样，我们经常会回到`draw`函数。我们将添加需要绘制的游戏新元素。您会注意到，每次我们这样做时，我们都会在主要、左侧和右侧的每个部分中添加代码。
- en: Let's quickly recap the `Engine` class and then we can fire it up.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下`Engine`类，然后我们可以启动它。
- en: The Engine class so far
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到目前为止的Engine类
- en: What we have achieved is the abstraction of all the code that used to be in
    the `main` function into the `input`, `update`, and `draw` functions. The continuous
    looping of these functions, as well as the timing, is handled by the `run` function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是将以前在`main`函数中的所有代码抽象成`input`，`update`和`draw`函数。这些函数的连续循环以及时间控制由`run`函数处理。
- en: 'Consider leaving the **Input.cpp**, **Update.cpp**, and **Draw.cpp** tabs open
    in Visual Studio, perhaps organized in order, as shown in the following screenshot:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在Visual Studio中保持**Input.cpp**、**Update.cpp**和**Draw.cpp**标签页打开，可能按顺序组织，如下截图所示：
- en: '![The Engine class so far](img/image_12_010.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![到目前为止的Engine类](img/image_12_010.jpg)'
- en: We will revisit each of these functions throughout the course of the project
    to add more code. Now that we have the basic structure and functionality of the
    `Engine` class, we can create an instance of it in the `main` function and see
    it in action.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的过程中，我们将重新审视这些函数，添加更多的代码。现在我们已经有了`Engine`类的基本结构和功能，我们可以在`main`函数中创建一个实例，并看到它的运行情况。
- en: Coding the main function
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写主函数
- en: Let's rename the `HelloSFML.cpp` file as `Main.cpp`. Right-click on the `HelloSFML`
    file in the **Solution Explorer** and select **Rename**. Change the name to `Main.cpp`.
    This will be the file that contains our `main` function and the code that instantiates
    the `Engine` class.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`HelloSFML.cpp`文件重命名为`Main.cpp`。在**解决方案资源管理器**中右键单击`HelloSFML`文件，然后选择**重命名**。将名称更改为`Main.cpp`。这将是包含我们的`main`函数和实例化`Engine`类的代码的文件。
- en: 'Add the following code to `Main.cpp`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Main.cpp`中：
- en: '[PRE10]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All we do is add an include directive for the `Engine` class, declare an instance
    of `Engine`, then call its `run` function. Everything will be handled by the `Engine`
    class until the player quits and the execution returns to `main` and the `return
    0` statement.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的就是为`Engine`类添加一个包含指令，声明一个`Engine`的实例，然后调用它的`run`函数。直到玩家退出并且执行返回到`main`和`return
    0`语句之前，所有的事情都将由`Engine`类处理。
- en: That was easy. Now we can run the game and see the empty background, either
    fullscreen or split screen, which will eventually contain all the action.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易。现在我们可以运行游戏，看到空的背景，无论是全屏还是分屏，最终将包含所有动作。
- en: 'Here is the game so far, in fullscreen mode, showing just the background:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，游戏是全屏模式，只显示背景：
- en: '![Coding the main function](img/image_12_011.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![编写主函数](img/image_12_011.jpg)'
- en: 'Now tap the ***E*** key, and you will be able to see the screen neatly partitioned
    into two halves, ready for split screen co-op gameplay:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按下***E***键，您将能够看到屏幕被整齐地分成两半，准备进行分屏合作游戏：
- en: '![Coding the main function](img/image_12_012.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![编写主函数](img/image_12_012.jpg)'
- en: Here are some questions that might be on your mind.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可能会让您感到困惑的问题。
- en: FAQ
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: Q) I don't fully understand the structure of the code files.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 我并不完全理解代码文件的结构。
- en: A) It is true that abstraction can make the structure of our code less clear,
    but the actual code itself becomes so much easier. Instead of cramming everything
    into the main function as we did in previous projects, we will split the code
    up into `Input.cpp`, `Update.cpp`, and `Draw.cpp`. Furthermore, we will use more
    classes to group together related code as we proceed. Study the Structuring the
    Thomas Was Late code section again, especially the diagrams.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: A) 抽象确实可以使我们的代码结构变得不太清晰，但实际的代码本身变得更容易。与我们在以前的项目中将所有内容塞进主函数不同，我们将把代码分成`Input.cpp`、`Update.cpp`和`Draw.cpp`。此外，随着我们的进行，我们将使用更多的类来将相关代码分组。再次研究《构建Thomas
    Was Late代码》部分，特别是图表。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced the Thomas Was Late game and laid the foundations
    of understanding, as well as the code structure, for the rest of the project.
    It is certainly true that there are a lot of files in the Solution Explorer, but
    as long as we understand the purpose of each we will find the implementation of
    the rest of the project much more easy going.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Thomas Was Late游戏，并为项目的其余部分奠定了理解和代码结构的基础。解决方案资源管理器中确实有很多文件，但只要我们理解每个文件的目的，我们会发现项目的实现变得更加容易。
- en: In the following chapter, we will learn two more fundamental C++ topics, inheritance
    and polymorphism. We will also begin to put them to use, building three classes
    to represent two playable characters.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习另外两个基本的C++主题，继承和多态。我们还将开始利用它们，构建三个类来代表两个可玩角色。
