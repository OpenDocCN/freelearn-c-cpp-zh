- en: Details of Object-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程的细节
- en: The difficulty of designing, implementing, and maintaining a software project
    arises with respect to the complexity of the project. A simple calculator could
    be written using the procedural approach (that is, the procedural programming
    paradigm), while a bank account management system would be too complex to implement
    using the same approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设计、实现和维护软件项目的难度取决于项目的复杂性。一个简单的计算器可以使用过程化方法（即过程式编程范式）编写，而使用相同方法实现银行账户管理系统将会太复杂。
- en: 'C++ supports **Object-Oriented programming (OOP)**, a paradigm that is built
    upon dissecting entities into objects that exist in a web of close intercommunication.
    Imagine a simple scenario in the real world when you take the remote to change
    the TV channel. At least three different objects take part in this action: the
    remote, the TV, and, most importantly, you. To express the real-world objects
    and their relationship using a programming language, we aren''t forced to use
    classes, class inheritance, abstract classes, interfaces, virtual functions, and
    so on. The mentioned features and concepts make the process of designing and coding
    a lot easier as they allow us to express and share ideas in an elegant manner,
    but they are not mandatory. As the creator of C++, Bjarne Stroustrup, says, "Not
    every program should be object-oriented." To understand high-level concepts and
    features of the OOP paradigm, we will try to look behind the scenes. Throughout
    this book, we will dive into the design of object-oriented programs. Understanding
    the essence of objects and their relationship, and then using them to design object-oriented
    programs, is one of the goals of this book.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: C++支持**面向对象编程（OOP）**，这是一种建立在将实体分解为存在于紧密互联网中的对象的范式。想象一下现实世界中的一个简单场景，当你拿遥控器换电视频道时。至少有三个不同的对象参与了这个动作：遥控器，电视，还有最重要的，你。为了用编程语言表达现实世界的对象及其关系，我们并不强制使用类，类继承，抽象类，接口，虚函数等。提到的特性和概念使得设计和编码过程变得更加容易，因为它们允许我们以一种优雅的方式表达和分享想法，但它们并不是强制性的。正如C++的创造者Bjarne
    Stroustrup所说，“并非每个程序都应该是面向对象的。”为了理解面向对象编程范式的高级概念和特性，我们将尝试看看幕后发生了什么。在本书中，我们将深入探讨面向对象程序的设计。理解对象及其关系的本质，然后使用它们来设计面向对象的程序，是本书的目标之一。
- en: 'In this chapter, we''ll learn about the following topics in detail:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细了解以下主题：
- en: Introduction to OOP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程简介
- en: The C++ object model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++对象模型
- en: Class relationships, including inheritance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类关系，包括继承
- en: Polymorphism
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Useful design patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的设计模式
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The g++ compiler with the `-std=c++2a` option is used to compile the examples
    throughout this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用带有`-std=c++2a`选项的g++编译器来编译示例。
- en: You can find the source files for this chapter at[ https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)找到本章的源文件。
- en: Understanding objects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解对象
- en: 'Most of the time, we operate with a collection of data grouped under a certain
    name, thus making an **abstraction**. Variables such as `is_military`, `speed`,
    and `seats` don''t make much sense if they''re perceived separately. Grouping
    them under the name with `spaceship` changes the way we perceive the data stored
    in the variables. We now refer to the many variables packed as one single object.
    To do so, we use abstraction; that is, we collect the individual properties of
    a real-world object from the perspective of the observer. An abstraction is a
    key tool in the programmer''s toolchain as it allows them to deal with complexity.
    The C language introduced the `struct` as a way to aggregate data, as shown in
    the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们操作的是以某个名称分组的数据集合，从而形成了**抽象**。例如`is_military`，`speed`和`seats`等变量如果单独看并没有太多意义。将它们组合在`spaceship`这个名称下，改变了我们感知变量中存储的数据的方式。现在我们将许多变量打包成一个单一对象。为此，我们使用抽象；也就是说，我们从观察者的角度收集现实世界对象的各个属性。抽象是程序员工具链中的关键工具，因为它允许他们处理复杂性。C语言引入了`struct`作为一种聚合数据的方式，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Grouping data is somewhat necessary for object-oriented programming. Each group
    of data is referred to as an object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于面向对象编程来说，对数据进行分组是有必要的。每组数据都被称为一个对象。
- en: Low-level details of objects
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的低级细节
- en: 'C++ does its best to support compatibility with the C language. While C structs
    are just a tool that allows us to aggregate data, C++ makes them equal to classes,
    allowing them to have constructors, virtual functions, inherit others structs,
    and so on. The only difference between a `struct` and a `class` is the default
    visibility modifier: `public` for structs and `private` for classes. There is
    usually no difference in using structs over classes or vice versa. OOP requires
    more than just a data aggregation. To fully understand OOP, let''s find out how
    we would we incorporate the OOP paradigm if we have only simple structs providing
    data aggregation and nothing more.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: C++尽其所能支持与C语言的兼容性。虽然C结构体只是一种允许我们聚合数据的工具，但C++使它们等同于类，允许它们拥有构造函数、虚函数、继承其他结构体等。`struct`和`class`之间唯一的区别是默认的可见性修饰符：结构体是`public`，类是`private`。通常使用结构体和类没有太大区别。面向对象编程需要的不仅仅是数据聚合。为了充分理解面向对象编程，让我们看看如果我们只有简单的结构体提供数据聚合而没有其他东西，我们如何将面向对象编程范式融入其中。
- en: 'A central entity of an e-commerce marketplace such as Amazon or Alibaba is
    the `Product`, which we represent in the following way:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 像亚马逊或阿里巴巴这样的电子商务市场的中心实体是`Product`，我们以以下方式表示它：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will add more members to the `Product` if necessary. The memory layout of
    an object of the `Product` type can be pictured like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们将向`Product`添加更多成员。`Product`类型的对象的内存布局可以像这样：
- en: '![](img/07ae95a7-5342-466b-84d1-60c5ffccb2a6.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07ae95a7-5342-466b-84d1-60c5ffccb2a6.png)'
- en: 'Declaring a `Product` object takes `sizeof(Product)` space in memory, while
    declaring a pointer or a reference to the object takes the space required to store
    the address (usually 4 or 8 bytes). See the following code block:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 声明`Product`对象在内存中占用`sizeof(Product)`的空间，而声明对象的指针或引用占用存储地址的空间（通常为4或8个字节）。请参阅以下代码块：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can picture the preceding code as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将上述代码描述如下：
- en: '![](img/67e1849e-5135-4c27-ad35-ab9ef1638cfa.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67e1849e-5135-4c27-ad35-ab9ef1638cfa.png)'
- en: Let's start with the space the `Product` object takes in memory. We can calculate
    the size of the `Product` object summing up the sizes of its member variables.
    The size of a `boolean` variable is 1 byte. The exact size of the `double` or
    the `int` is not specified in the C++ standard. In 64-bit machines, a `double` variable
    usually takes 8 bytes and an `int` variable takes 4 bytes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Product`对象在内存中占用的空间开始。我们可以通过总结其成员变量的大小来计算`Product`对象的大小。`boolean`变量的大小为1个字节。在C++标准中没有明确规定`double`或`int`的确切大小。在64位机器上，`double`变量通常占用8个字节，`int`变量占用4个字节。
- en: 'The implementation of `std::string` is not specified in the standard, so its
    size depends on the library implementation. `string` stores a pointer to a character
    array, but it also might store the number of allocated characters to efficiently
    return it when `size()` is called. Some implementations of `std::string` take
    8, 24, or 32 bytes of memory, but we will stick to 24 bytes in our example. By
    summing it up, the size of the `Product` will be as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::string`的实现在标准中没有指定，因此其大小取决于库的实现。`string`存储指向字符数组的指针，但也可能存储分配的字符数，以便在调用`size()`时高效返回。`std::string`的一些实现占用8、24或32个字节的内存，但我们将在示例中坚持使用24个字节。总结一下，`Product`的大小如下：'
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Printing the size of the `Product` outputs a different value:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`Product`的大小会输出不同的值：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It outputs `40` instead of the calculated 37 bytes. The reason behind the redundant
    bytes is the padding of the struct, a technique practiced by the compiler to optimize
    the access to individual members of the object. The **Central Processing Unit
    (CPU)** reads the memory in fixed-size words. The size of the word is defined
    by the CPU (usually, it's 32 or 64 bits long). The CPU is able to access the data
    at once if it's starting from a word-aligned address. For example, the `boolean`
    data member of the `Product` requires 1 byte of memory and can be placed right
    after the rating member. As it turns out, the compiler aligns the data for faster
    access. Let's suppose the word size is 4 bytes. This means that the CPU will access
    a variable without redundant steps if the variable starts from an address that's
    divisible by 4\. The compiler augments the struct earlier with additional bytes
    to align the members to word-boundary addresses.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它输出`40`而不是计算出的37个字节。冗余字节背后的原因是结构的填充，这是编译器为了优化对对象的各个成员的访问而实践的一种技术。**中央处理单元（CPU）**以固定大小的字读取内存。字的大小由CPU定义（通常为32位或64位）。如果数据从与字对齐的地址开始，CPU可以一次访问数据。例如，`Product`的`boolean`数据成员需要1个字节的内存，可以直接放在评级成员后面。事实证明，编译器对数据进行了对齐以加快访问速度。假设字大小为4个字节。这意味着如果变量从可被4整除的地址开始，CPU将无需冗余步骤即可访问变量。编译器会提前用额外的字节来对齐结构的成员到字边界地址。
- en: High-level details of objects
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的高级细节
- en: 'We deal with objects as entities representing the result of abstraction. We
    have already mentioned the role of the observer, that is, the programmer who defines
    the object based on the problem domain. The way the programmer defines this represents
    the process of abstraction. Let''s take an example of an e-commerce marketplace
    and its products. Two different teams of programmers might have different views
    of the same product. The team that implements the website cares about the properties
    of the object that are essential to website visitors: buyers. The properties that
    we showed earlier in the `Product` struct are mostly meant for website visitors,
    such as the selling price, the rating of the product, and so on. Programmers that
    implement the website touch the problem domain and verify the properties that
    are essential to defining a `Product` object.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对象视为代表抽象结果的实体。我们已经提到了观察者的角色，即根据问题域定义对象的程序员。程序员定义这个过程代表了抽象的过程。让我们以电子商务市场及其产品为例。两个不同的程序员团队可能对同一产品有不同的看法。实现网站的团队关心对象的属性，这些属性对网站访问者：购买者至关重要。我们在`Product`结构中显示的属性主要是为网站访问者而设，比如销售价格、产品评级等。实现网站的程序员接触问题域，并验证定义`Product`对象所必需的属性。
- en: 'The team that implements the online tools that help manage the products in
    the warehouse cares about the properties of the object that are essential in terms
    of product placement, quality control, and shipment. This team shouldn''t actually
    care about the **rating** of the product or even its **price**. This team mostly
    cares about the **weight**, **dimensions**, and **conditions** of the product. The
    following illustration shows the properties of interest:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 负责实现帮助管理仓库中产品的在线工具的团队关心对象的属性，这些属性在产品放置、质量控制和装运方面至关重要。这个团队实际上不应该关心产品的**评级**甚至**价格**。这个团队主要关心产品的**重量**、**尺寸**和**状态**。以下插图显示了感兴趣的属性：
- en: '![](img/d45f90f5-f11f-41e0-8392-1f11fd254d95.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d45f90f5-f11f-41e0-8392-1f11fd254d95.png)'
- en: 'The first thing that programmers should do when starting the project is to
    analyze the problem and gather the requirements. In other words, they should get
    familiar with the *problem domain* and define the *project requirements*. The
    process of analyzing leads to defining objects and their types, such as the `Product` we
    discussed earlier. To get proper results from analyzing, we should think in objects,
    and, by thinking in objects, we mean considering the three main properties of
    objects: **state**, **behavior**, and **identity**.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员在开始项目时应该做的第一件事是分析问题并收集需求。换句话说，他们应该熟悉*问题域*并定义*项目需求*。分析的过程导致定义对象及其类型，比如我们之前讨论的`Product`。为了从分析中得到正确的结果，我们应该以对象的方式思考，而通过以对象的方式思考，我们指的是考虑对象的三个主要属性：**状态**、**行为**和**身份**。
- en: State
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: 'Each object has a state that may or may not differ from the state of other
    objects. We''ve already introduced the `Product` struct, which represents an abstraction
    of a physical (or digital) product. All the members of a `product` object collectively
    represent the state of the object. For example, the `Product` contains members
    such as `available`, which is a Boolean; it equals `true` if the product is in
    stock. The values of the member variables define the state of the object. If you
    assign new values to the object member, its state will change:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都有一个状态，可能与其他对象的状态相同也可能不同。我们已经介绍了`Product`结构，它代表了一个物理（或数字）产品的抽象。`product`对象的所有成员共同代表了对象的状态。例如，`Product`包含诸如`available`之类的成员，它是一个布尔值；如果产品有库存，则等于`true`。成员变量的值定义了对象的状态。如果给对象成员分配新值，它的状态将会改变：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The state of the object is the combination of all of its properties and values.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的状态是其所有属性和值的组合。
- en: Identity
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份
- en: 'Identity is what differentiates one object from another. Even if we try to
    declare two physically indistinguishable objects, they will still have different
    names for their variables, that is, different identities:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 身份是区分一个对象与另一个对象的特征。即使我们试图声明两个在物理上无法区分的对象，它们仍然会有不同的变量名称，也就是不同的身份：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The objects in the preceding example have the same state, but they differ by
    the names we refer to them by, that is, `book1` and `book2`. Let''s say we had
    the ability to somehow create objects with the same name, as shown in the following
    code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面例子中的对象具有相同的状态，但它们的名称不同，即`book1`和`book2`。假设我们有能力以某种方式创建具有相同名称的对象，就像下面的代码所示：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If this was the case, they would still have different addresses in memory:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样的话，它们在内存中仍然会有不同的地址：
- en: '![](img/a53517c2-6eb7-46a1-80ba-806d57324296.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a53517c2-6eb7-46a1-80ba-806d57324296.png)'
- en: 'Identity is a fundamental property of the object and is one of the reasons
    why we can''t create *empty* objects, such as the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 身份是对象的基本属性，也是我们无法创建*空*对象的原因之一，比如下面的情况：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code will not output `0` as expected. The size of an empty object
    is not specified in the standard; compiler developers tend to allocate 1 byte
    for such objects, though you might encounter 4 or 8 as well. Two or more instances
    of `Empty` should have different addresses in memory, so the compiler must make
    sure objects will take up at least 1 byte of memory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码不会像预期的那样输出`0`。空对象的大小在标准中没有指定；编译器开发人员倾向于为这样的对象分配1个字节，尽管您可能也会遇到4或8。两个或更多个`Empty`的实例在内存中应该有不同的地址，因此编译器必须确保对象至少占用1个字节的内存。
- en: Behavior
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为
- en: 'In previous examples, we assigned `5` and then `4` to the `rating` member variable.
    We can easily make things unexpectedly wrong by assigning invalid values to the
    object, like so:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们将`5`和`4`分配给了`rating`成员变量。通过给对象分配无效的值，我们可以很容易地使事情出乎意料地出错，就像这样：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`-12` is invalid in terms of the rating of a product and will confuse users,
    if allowed to. We can control the behavior of the changes made to the object by
    providing **setter** functions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`-12`在产品评级方面是无效的，如果允许的话会使用户感到困惑。我们可以通过提供**setter**函数来控制对对象所做更改的行为：'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An object acts and reacts to the requests from other objects. The requests are
    performed via function calls, which otherwise are called **messages**: an object
    passes a message to another. In the preceding example, the object that passed
    the corresponding `set_rating` message to the `cpp_book` object represents the
    object that we call the `set_rating()` function in. In this case, we suppose that
    we call the function from `main()`, which doesn't actually represent any object
    at all. We could say it's the global object, the one that operates the `main()`
    function, though there is not an entity like that in C++.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对象对来自其他对象的请求作出反应。请求是通过函数调用执行的，否则称为**消息**：一个对象向另一个对象传递消息。在前面的例子中，将相应的`set_rating`消息传递给`cpp_book`对象的对象代表我们调用`set_rating()`函数的对象。在这种情况下，我们假设从`main()`中调用函数，实际上`main()`并不代表任何对象。我们可以说它是全局对象，操作`main()`函数的对象，尽管在C++中并没有这样的实体。
- en: 'We distinguish the objects conceptually rather than physically. That''s the
    main point of thinking in objects. The physical implementation of some concepts
    of object-oriented programming is not standardized, so we can name the `Product` struct
    as a class and claim that `cpp_book` is an **instance** of the `Product` ,and
    that it has a member function called `set_rating()`. The C++ implementation almost
    does the same: it provides syntactically convenient structures (classes, visibility
    modifiers, inheritance, and so on) and translates them into simple structs with
    global functions such as `set_rating()` in the preceding example. Now, let''s
    dive into the details of the C++ object model.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在概念上区分对象，而不是在物理上。这是以对象思考的主要观点。面向对象编程的一些概念的物理实现并不是标准化的，所以我们可以将`Product`结构命名为类，并声称`cpp_book`是`Product`的**实例**，并且它有一个名为`set_rating()`的成员函数。C++的实现几乎是一样的：它提供了语法上方便的结构（类、可见性修饰符、继承等），并将它们转换为简单的结构，例如前面例子中的`set_rating()`全局函数。现在，让我们深入了解C++对象模型的细节。
- en: Mimicking a class
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟类
- en: 'A struct allows us to group variables, name them, and create objects. The idea
    of a class is to include the corresponding operations in the object, grouping
    both data and operations that are applicable to that particular data. For example,
    for the object of the `Product` type, it will be natural to call the `set_rating()` function
    on the object directly, rather than having a separate global function that takes
    a `Product` object via a pointer and modifies it. However, as we agreed to use
    structs in the C manner, we can''t afford it to have member functions. To mimic
    a class using a C struct, we have to declare functions that work with the `Product`
    object as global functions, as shown in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体允许我们将变量分组，命名它们，并创建对象。类的概念是在对象中包含相应的操作，将适用于该特定数据的数据和操作分组在一起。例如，对于`Product`类型的对象，直接在对象上调用`set_rating()`函数将是很自然的，而不是使用一个单独的接受`Product`对象指针并修改它的全局函数。然而，由于我们同意以C方式使用结构体，我们无法负担得起拥有成员函数。为了使用C结构体模拟类，我们必须声明与`Product`对象一起工作的函数作为全局函数，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To use the struct as a class, we should manually call the functions in the
    proper order. For example, to use the object with properly initialized default
    values, we have to call the `initialize()` function first:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要将结构体用作类，我们应该按正确的顺序手动调用函数。例如，要使用具有正确初始化默认值的对象，我们必须首先调用`initialize()`函数：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This seems doable, but the preceding code will quickly turn into an unorganized
    mess if new types are added. For example, consider the `Warehouse` struct that
    keeps track of products:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '这似乎是可行的，但如果添加新类型，前面的代码将很快变成一个无组织的混乱。例如，考虑跟踪产品的`Warehouse`结构体： '
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first obvious issue is the naming of functions. We had to name the initializer
    function of the `Warehouse` `initialize_warehouse` to avoid conflict with the
    already declared `initialize()` function for the `Product`. We might consider
    renaming the functions for the `Product` type to avoid possible conflicts in the
    future. Next comes the mess with functions. Now, we have a bunch of global functions,
    which will increase in number as we add new types. It will be even more unmanageable
    if we add some hierarchy of types.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先明显的问题是函数的命名。我们不得不将`Warehouse`的初始化函数命名为`initialize_warehouse`，以避免与已声明的`Product`的`initialize()`函数发生冲突。我们可能会考虑重命名`Product`类型的函数，以避免将来可能的冲突。接下来是函数的混乱。现在，我们有一堆全局函数，随着我们添加新类型，这些函数的数量将增加。如果我们添加一些类型的层次结构，它将变得更加难以管理。
- en: Though compilers tend to translate classes into structs with global functions,
    as we showed earlier, C++ and other high-level programming languages solve these
    and other issues that had not been mentioned by, introducing classes with smooth
    mechanisms of organizing them into hierarchies. Conceptually, keywords (`class`,
    `public`, or `private`) and mechanisms (inheritance and polymorphism) are there
    for developers to conveniently organize their code, but won't make the life of
    the compiler any easier.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管编译器倾向于将类翻译为具有全局函数的结构体，正如我们之前展示的那样，但C++和其他高级编程语言解决了这些问题以及其他未提及的问题，引入了将它们组织成层次结构的平滑机制。从概念上讲，关键字（`class`，`public`或`private`）和机制（继承和多态）是为了方便开发人员组织他们的代码，但不会使编译器的生活变得更容易。
- en: Working with classes
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类进行工作
- en: 'Classes make things a lot easier when dealing with objects. They do the simplest
    necessary thing in OOP: they combine data with functions for manipulating data.
    Let''s rewrite the example of the `Product` struct using a class and its powerful
    features:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理对象时，类使事情变得更容易。它们在面向对象编程中做了最简单必要的事情：将数据与操作数据的函数结合在一起。让我们使用类及其强大的特性重写`Product`结构体的示例：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The class declaration seems more organized, even though it exposes more functions
    than we use to define a similar struct. Here''s how we should illustrate the class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明似乎更有组织性，尽管它公开的函数比我们用来定义类似结构体的函数更多。这是我们应该如何说明这个类的方式：
- en: '![](img/c8a27344-1681-4f83-97ea-90d8f78dda1a.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8a27344-1681-4f83-97ea-90d8f78dda1a.png)'
- en: 'The preceding image is somewhat special. As you can see, it has organized sections,
    signs before the names of functions, and so on. This type of diagram is called
    a **Unified Modeling Language (UML)** class diagram. UML is a way to standardize
    the process of illustrating classes and their relationship. The first section
    is the name of the class (in bold), next comes the section for member variables,
    and then the section for member functions. The `+` (plus) sign in front of a function
    name means that the function is public. Member variables are usually private,
    but, if you need to emphasize this, you can use the `-` (minus) sign. We can omit
    all the details by simply illustrating the class, as shown in the following UML
    diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像有些特殊。正如你所看到的，它有组织良好的部分，在函数名称之前有标志等。这种类型的图表被称为**统一建模语言（UML）**类图。UML是一种标准化说明类及其关系的方式。第一部分是类的名称（粗体），接下来是成员变量部分，然后是成员函数部分。函数名称前的`+`（加号）表示该函数是公共的。成员变量通常是私有的，但如果需要强调这一点，可以使用`-`（减号）。我们可以通过简单地说明类来省略所有细节，如下面的UML图所示：
- en: '![](img/24e54100-c4fb-4c79-af94-8085e241f878.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24e54100-c4fb-4c79-af94-8085e241f878.png)'
- en: We will use UML diagrams throughout this book and will introduce new types of
    diagrams as needed. Before dealing with initializing, copying, moving, default
    and deleted functions, and, of course, operator overloading, let's clear a couple
    of things up.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中使用UML图表，并根据需要引入新类型的图表。在处理初始化、复制、移动、默认和删除函数以及运算符重载之前，让我们先澄清一些事情。
- en: Classes from the compiler perspective
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从编译器的角度看待类
- en: 'First of all, no matter how monstrous the class from earlier may seem in comparison
    to the previously introduced struct, the compiler will translate it into the following
    code (we slightly modified it for the sake of simplicity):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，无论与之前的类相比，类似怪物的类看起来多么庞大，编译器都会将其转换为以下代码（我们稍微修改了它以简化）：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Basically, the compiler generates the same code that we introduced earlier as
    a way to mimic class behavior using a simple struct. Though compilers vary in
    techniques and methods of implementing the C++ object model, the preceding example
    is one of the popular approaches practiced by compiler developers. It balances
    the space and time efficiency in accessing object members (including member functions).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，编译器生成了与我们之前介绍的相同的代码，以模仿使用简单结构体来实现类行为的方式。尽管编译器在实现C++对象模型的技术和方法上有所不同，但前面的例子是编译器开发人员实践的流行方法之一。它在访问对象成员（包括成员函数）的空间和时间效率之间取得了平衡。
- en: 'Next, we should consider that the compiler edits our code by augmenting and
    modifying it. The following code declares the global `create_apple()` function,
    which creates and returns a `Product` object with values specific to an apple.
    It also declares a book object in the `main()` function:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该考虑编译器通过增加和修改来编辑我们的代码。下面的代码声明了全局`create_apple()`函数，它创建并返回一个具有特定苹果值的`Product`对象。它还在`main()`函数中声明了一个书对象：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We already know that the compiler modifies the class to translate it into a
    struct and moves member functions to the global scope, each of which takes the
    reference (or a pointer) to the class as its first parameter. To support those
    modifications in the client code, it should also modify all access to the objects.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道编译器修改类以将其转换为结构体，并将成员函数移动到全局范围，每个成员函数都以类的引用（或指针）作为其第一个参数。为了支持客户端代码中的这些修改，它还应该修改对所有对象的访问。
- en: A line or lines of code that declare or use already declared class objects are
    referred to as **client code**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码是声明或使用已声明的类对象的一行或多行代码。
- en: 'Here''s how we will assume the compiler modifies the preceding code  (we used
    the word *assume* because we''re trying to introduce a compiler-abstract rather
    than a compiler-specific approach):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们假设编译器修改了前面代码的方式（我们使用了“假设”这个词，因为我们试图引入一个编译器抽象而不是特定于编译器的方法）：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The compiler also optimized the call to the `create_apple()` function to avoid
    temporary object creation. We will discuss the invisible temporaries that were
    generated by the compiler later in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器还优化了对`create_apple()`函数的调用，以避免临时对象的创建。我们将在本章后面讨论编译器生成的隐式临时对象。
- en: Initialization and destruction
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化和销毁
- en: 'As shown previously, the creation of an object is a two-step process: memory
    allocation and initialization. Memory allocation is a result of an object declaration.
    C++ doesn''t care about the initialization of variables; it allocates the memory
    (whether it is automatic or manual) and it''s done. The actual initialization
    should be done by the programmer, which is why we have a constructor in the first
    place.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所示，对象的创建是一个两步过程：内存分配和初始化。内存分配是对象声明的结果。C++不关心变量的初始化；它分配内存（无论是自动还是手动）就完成了。实际的初始化应该由程序员完成，这就是我们首先需要构造函数的原因。
- en: 'The same logic follows for the destructor. If we skip the declarations of the
    default constructor or destructor, the compiler should generate them implicitly,
    which it would also remove in case they are empty (to eliminate redundant calls
    to empty functions). The default constructor will not be generated by the compiler
    if any constructor with parameters is declared, including the copy constructor.
    We can force the compiler to implicitly generate the default constructor:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数也是同样的逻辑。如果我们跳过默认构造函数或析构函数的声明，编译器应该会隐式生成它们，如果它们是空的话也会移除它们（以消除对空函数的冗余调用）。如果声明了带参数的构造函数，包括拷贝构造函数，编译器就不会生成默认构造函数。我们可以强制编译器隐式生成默认构造函数：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also can force it not to generate the compiler by using the `delete` specifier,
    as shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用`delete`修饰符来强制不生成编译器，如下所示：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will prohibit default-initialized object declarations, that is, `Product
    p`; won't compile.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将禁止默认初始化对象的声明，也就是说，`Product p`; 不会编译。
- en: Destructors are called in the order opposite to object declarations because
    the automatic memory allocation is managed by a stack and the stack, is a data
    structure adapter that follows the **last in, first out (****LIFO) **rule.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数的调用顺序与对象声明的顺序相反，因为自动内存分配由堆栈管理，而堆栈是遵循**后进先出（LIFO）**规则的数据结构适配器。
- en: 'Object initialization happens on its creation. Destruction usually happens
    when the object is no longer accessible. The latter may be tricky when the object
    is allocated on the heap. Take a look at the following code; it declares four
    `Product` objects in different scopes and segments of memory:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对象初始化发生在对象创建时。销毁通常发生在对象不再可访问时。当对象在堆上分配时，后者可能会有些棘手。看一下下面的代码；它在不同的作用域和内存段中声明了四个`Product`对象：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`global_prod` has a static storage duration and is placed in the global/static
    section of the program; it is initialized before `main()` is called. When `main()`
    starts, `stack_prod` is allocated on the stack and will be destroyed when `main()`
    ends (the closing curly brace of the function is considered as its end). Though
    the conditional expression looks weird and too artificial, it''s a good way to
    express the block scope.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`global_prod`具有静态存储期，并且放置在程序的全局/静态部分；它在调用`main()`之前被初始化。当`main()`开始时，`stack_prod`被分配在堆栈上，并且在`main()`结束时被销毁（函数的闭合大括号被视为其结束）。虽然条件表达式看起来很奇怪和太人为，但这是一种表达块作用域的好方法。'
- en: 'The `tmp` object will also be allocated on the stack, but its storage duration
    is limited to the scope it has been declared in: it will be automatically destroyed
    when the execution leaves the `if` block. That''s why variables on the stack have
    *automatic storage duration*. Finally, when the `foo()` function is called, it
    declares the `heap_prod` pointer, which points to the address of the `Product`
    object allocated on the heap.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmp`对象也将分配在堆栈上，但其存储持续时间限制在其声明的范围内：当执行离开`if`块时，它将被自动销毁。这就是为什么堆栈上的变量具有*自动存储持续时间*。最后，当调用`foo()`函数时，它声明了`heap_prod`指针，该指针指向在堆上分配的`Product`对象的地址。'
- en: 'The preceding code contains a memory leak because the `heap_prod` pointer (which
    itself has an automatic storage duration) will be destroyed when the execution
    reaches the end of `foo()`, while the object allocated on the heap won''t be affected.
    Don''t mix the pointer and the actual object it points to: the pointer just contains
    the value of the object, but it doesn''t represent the object.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包含内存泄漏，因为`heap_prod`指针（它本身具有自动存储持续时间）将在执行到达`foo()`末尾时被销毁，而在堆上分配的对象不会受到影响。不要混淆指针和它指向的实际对象：指针只包含对象的值，但它并不代表对象。
- en: Don't forget to deallocate the memory that's dynamically allocated on the heap,
    either by manually calling the delete operator or using smart pointers. Smart
    pointers will be discussed in [Chapter 5](2b708ddc-255e-490e-bd4c-e783ccae5f9e.xhtml), *Memory
    Management and Smart Pointers.*
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记释放在堆上动态分配的内存，可以通过手动调用删除运算符或使用智能指针来实现。智能指针将在[第5章](2b708ddc-255e-490e-bd4c-e783ccae5f9e.xhtml)中讨论，*内存管理和智能指针*。
- en: When the function ends, the memory for its arguments and local variables allocated
    on the stack will be freed, but `global_prod` will be destroyed when the program
    ends, that is, after the `main()` function finishes. The destructor will be called
    when the object is about to be destroyed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数结束时，分配在堆栈上的参数和局部变量的内存将被释放，但`global_prod`将在程序结束时被销毁，也就是在`main()`函数结束后。当对象即将被销毁时，析构函数将被调用。
- en: Copying objects
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制对象
- en: 'There are two kinds of copying: a *deep* copy and a *shallow* copy of objects. The
    language allows us to manage copy-initialization and the assignment of objects
    with the **copy constructor** and the **assignment operator**. This is a necessary
    feature for programmers because we can control the semantics of copying. Take
    a look at the following example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种复制方式：对象的*深*复制和*浅*复制。语言允许我们使用**复制构造函数**和**赋值运算符**来管理对象的复制初始化和赋值。这对程序员来说是一个必要的特性，因为我们可以控制复制的语义。看下面的例子：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The line `p1 = p2;` is a call to the assignment operator, while the last line
    is a call to the copy constructor. The equals sign shouldn't confuse you regarding
    whether it's an assignment or a copy constructor call. Each time you see a declaration
    followed by an assignment, consider it a copy construction. The same applies to
    the new initializer syntax (`Product p3{p2};`).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`p1 = p2;`这一行是对赋值运算符的调用，而最后一行是对复制构造函数的调用。等号不应该让你困惑，无论是赋值还是复制构造函数调用。每当看到声明后面跟着一个赋值时，都可以将其视为复制构造。新的初始化程序语法(`Product
    p3{p2};`)也是如此。'
- en: 'The compiler will generate the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将生成以下代码：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The default implementation of the copy constructor (and assignment operator)
    performs a member-wise copy of objects, as shown in the following diagram:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数（和赋值运算符）的默认实现执行对象的成员逐个复制，如下图所示：
- en: '![](img/4a801266-0db0-4ca7-81e1-afa9b2da53a0.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a801266-0db0-4ca7-81e1-afa9b2da53a0.png)'
- en: 'Custom implementation is required in case the member-wise copy produces invalid
    copies. For example, consider the following copy of `Warehouse` objects:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成员逐个复制产生无效副本，则需要自定义实现。例如，考虑以下`Warehouse`对象的复制：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code declares two `Warehouse` objects, and two different products
    are then added to the warehouses. Though this example is somewhat unnatural, it
    shows the dangers of the default implementation of copying. The following illustration
    shows us what went wrong in the code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码声明了两个`Warehouse`对象，然后向仓库添加了两种不同的产品。虽然这个例子有些不自然，但它展示了默认复制实现的危险。以下插图展示了代码中出现的问题：
- en: '![](img/9cb93f9f-29a1-4e3d-a0df-d9b226e141d9.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9cb93f9f-29a1-4e3d-a0df-d9b226e141d9.png)'
- en: 'Assigning **w1** to **w2** leads to the following structure:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将**w1**赋给**w2**会导致以下结构：
- en: '![](img/57f8bc17-d88a-4fd8-b03b-8263a6b20b2d.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57f8bc17-d88a-4fd8-b03b-8263a6b20b2d.png)'
- en: The default implementation simply copies each member of `w1` to `w2`. After
    copying, both `products_` members of `w1` and `w2` point to the same location
    on the heap. When we add a new product to `w2`, the array pointed to by `w1` is
    affected. It's a logical error that could lead to undefined behavior in the program.
    We need a *deep* rather than a *shallow* copy; that is, we need to actually create
    a new array of products that has a copy of w1's array.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 默认实现只是将`w1`的每个成员复制到`w2`。复制后，`w1`和`w2`的`products_`成员都指向堆上的相同位置。当我们向`w2`添加新产品时，`w1`指向的数组会受到影响。这是一个逻辑错误，可能导致程序中的未定义行为。我们需要进行*深*复制而不是*浅*复制；也就是说，我们需要实际创建一个包含w1数组副本的新产品数组。
- en: 'A custom implementation of the copy constructor and the assignment operator
    solves this issue of *shallow* copying:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义实现复制构造函数和赋值运算符解决了*浅*复制的问题：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The custom implementation of the copy constructor creates a new array. Then,
    it copies the source objects' array elements one by one, this way eliminating
    the `product_` pointer from pointing to a wrong memory address. In other words,
    we implemented a deep copy of `Warehouse` objects by creating a new array.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数的自定义实现创建一个新数组。然后，它逐个复制源对象的数组元素，从而消除了`product_`指针指向错误的内存地址。换句话说，我们通过创建一个新数组实现了`Warehouse`对象的深复制。
- en: Moving objects
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动对象
- en: 'Temporary objects are everywhere in code. Most of the time, they are required
    to make the code work as expected. For example, when we add two objects together,
    a temporary object is created to hold the return value of `operator+`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 临时对象在代码中随处可见。大多数情况下，它们是必需的，以使代码按预期工作。例如，当我们将两个对象相加时，会创建一个临时对象来保存`operator+`的返回值：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s take a look at the implementation of the global `operator+()` for `Warehouse`
    objects:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`Warehouse`对象的全局`operator+()`的实现：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding implementation declares a temporary object and returns it after
    filling it with necessary data. The call in the previous example could be translated
    into the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实现声明了一个临时对象，并在填充必要数据后返回它。在前面的示例中，调用可以被翻译成以下内容：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The *move semantics*, which was introduced in C++11, allows us to skip the
    temporary creation by *moving* the return value into the `Warehouse` object. To
    do so, we should declare a **move constructor** for the `Warehouse`, which can
    *distinguish* between temporaries and treat them efficiently:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*移动语义*，它在C++11中引入，允许我们通过*移动*返回值到`Warehouse`对象中来跳过临时创建。为此，我们应该为`Warehouse`声明一个**移动构造函数**，它可以*区分*临时对象并有效地处理它们：'
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The parameter of the move constructor is an **rvalue reference** (**&&**).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 移动构造函数的参数是**rvalue引用**（**&&**）。
- en: Lvalue references
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lvalue引用
- en: 'Before understanding why rvalue references were introduced in the first place,
    let''s clear things up regarding `lvalues`, `references`, and `lvalue-references`.
    When a variable is an lvalue, it can be addressed, it can be pointed to, and it
    has a scoped storage duration:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解为什么首先引入rvalue引用之前，让我们澄清一下关于`lvalues`、`references`和`lvalue-references`的事情。当一个变量是lvalue时，它可以被寻址，可以被指向，并且具有作用域存储期：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`ref` is an `lvalue reference`, a synonym for a variable that can be treated
    as a `const` pointer:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ref`是一个`lvalue`引用，相当于可以被视为`const`指针的变量：'
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Besides the ability to modify the objects by a reference, we pass heavy objects
    to functions by reference in order to optimize and avoid redundant object copies.
    For example, the `operator+` for the `Warehouse` takes two objects *by reference*,
    thus making it copy addresses of objects rather than full objects.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过引用修改对象的能力，我们还通过引用将重型对象传递给函数，以便优化和避免冗余对象的复制。例如，`Warehouse`的`operator+`接受两个对象的*引用*，因此它复制对象的地址而不是完整对象。
- en: '`Lvalue` references optimize the code in terms of function calls, but, to optimize
    temporaries, we should move on to rvalue references.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lvalue`引用在函数调用方面优化了代码，但是为了优化临时对象，我们应该转向rvalue引用。'
- en: Rvalue references
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rvalue引用
- en: 'We cannot bind `lvalue` references to temporaries. The following code won''t
    compile:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能将`lvalue`引用绑定到临时对象。以下代码将无法编译：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We need to declare an `rvalue` reference to be able to bind to temporaries
    (including literal values):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要声明一个`rvalue`引用，以便能够绑定到临时对象（包括文字值）：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`Rvalue` references allow us to skip the generation of temporaries as much
    as possible. For example, a function that takes the result as an rvalue reference
    runs faster by eliminating temporary objects:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rvalue`引用允许我们尽可能地跳过临时对象的生成。例如，以rvalue引用接受结果的函数通过消除临时对象而运行得更快：'
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To imagine the effect of moving, imagine that the preceding code will be translated
    into the following (just to get the full idea of moving):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了想象移动的效果，想象一下前面的代码将被翻译成以下内容（只是为了完全理解移动）：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Before moving was introduced, the preceding code would look like this (with
    some compiler optimization):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入移动之前，前面的代码看起来像这样（带有一些编译器优化）：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The move constructor, along with the move operator, `=()`, has the effect of
    copying without actually carrying out a copy operation when the input argument
    represents an `rvalue`. That''s why we should also implement these new functions
    in the class: so that we can optimize the code wherever it makes sense. The move
    constructor can grab the source object instead of copying it, as shown here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 移动构造函数和移动操作符`=()`一起，当输入参数表示一个`rvalue`时，具有复制而不实际执行复制操作的效果。这就是为什么我们应该在类中实现这些新函数：这样我们就可以在任何有意义的地方优化代码。移动构造函数可以获取源对象而不是复制它，如下所示：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Instead of creating a new array of `capacity_` size and then copying each element
    of the `products_` array, we just grabbed the pointer to the array. We know that
    the `src` object is an rvalue and that it will soon be destroyed, which means
    the destructor will be called and the destructor will delete the allocated array.
    Now, we point to the allocated array from the newly created `Warehouse` object,
    which is why we cannot let the destructor delete the source array. Due to this,
    we assign `nullptr` to it to make sure the destructor will miss the allocated
    object. So, the following code will be optimized because of the move constructor:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是创建一个`capacity_`大小的新数组，然后复制`products_`数组的每个元素，而是直接获取了数组的指针。我们知道`src`对象是一个rvalue，并且它很快就会被销毁，这意味着析构函数将被调用，并且析构函数将删除分配的数组。现在，我们指向新创建的`Warehouse`对象的分配数组，这就是为什么我们不能让析构函数删除源数组。因此，我们将`nullptr`赋给它，以确保析构函数不会错过分配的对象。因此，由于移动构造函数，以下代码将被优化：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The result of `+` operator will be moved rather than copied. Take a look at
    the following diagram:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`操作符的结果将被移动而不是复制。看一下下面的图表：'
- en: '![](img/d7d0904d-6549-4c3c-aadd-6bb1785dfa17.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7d0904d-6549-4c3c-aadd-6bb1785dfa17.png)'
- en: The preceding diagram demonstrates how the temporary is being moved to the large
    object.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表演示了临时对象如何被移动到大对象中。
- en: Notes on operator overloading
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符重载的注意事项
- en: 'C++ provides a powerful mechanism for overloading operators for custom types.
    It''s much better to calculate the sum of two objects using the `+` operator,
    rather than calling a member function. Calling a member function also involves
    remembering its name before calling it. It might be `add`, `calculateSum`, `calculate_sum`,
    or something else. Operator overloading allows for a consistent approach in class
    design. On the other hand, overloading operators increases unnecessary verbosity
    in the code. The following snippet represents a list of comparison operators being
    overloaded, along with addition and subtraction for the `Money` class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: C++为自定义类型提供了强大的运算符重载机制。使用`+`运算符计算两个对象的和要比调用成员函数好得多。调用成员函数还涉及在调用之前记住它的名称。它可能是`add`，`calculateSum`，`calculate_sum`或其他名称。运算符重载允许在类设计中采用一致的方法。另一方面，运算符重载会增加代码中不必要的冗长。以下代码片段表示对`Money`类进行了比较运算符的重载，以及加法和减法：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see, most of the preceding functions directly access the value member
    of the `Money` instance. To make it work, we should declare them as friends for
    `Money`. Here''s what `Money` will look like:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，前面大部分函数直接访问了`Money`实例的值成员。为了使其工作，我们应该将它们声明为`Money`的友元。`Money`将如下所示：
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The class looks monstrous. C++20 introduces the spaceship operator, which allows
    us to skip the definition of comparison operators. `operator<=>()`, also known
    as the three-way comparison operator, requests the compiler to generate relational
    operators. For the `Money` class, we can use the default `operator<=>()`, as shown
    here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类看起来很庞大。C++20引入了太空船操作符，它允许我们跳过比较运算符的定义。`operator<=>()`，也被称为三路比较运算符，请求编译器生成关系运算符。对于`Money`类，我们可以使用默认的`operator<=>()`，如下所示：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The compiler will generate the `==`, `!=`, `<`, `>`, `<=`, `>=` operators.
    The `spaceship` operator reduces the redundant definitions for operators and also
    provides a way to implement a generic behavior for all the generated operators.
    When implementing a custom behavior for the `spaceship` operator, we should note
    the return value type of the operator. It can be one of the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将生成`==`，`!=`，`<`，`>`，`<=`，`>=`运算符。`太空船`运算符减少了运算符的冗余定义，并提供了一种为所有生成的运算符实现通用行为的方法。在为`太空船`运算符实现自定义行为时，我们应该注意运算符的返回值类型。它可以是以下之一：
- en: '`std::strong_ordering`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::strong_ordering`'
- en: '`std::weak_ordering`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::weak_ordering`'
- en: '`std::partial_ordering`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::partial_ordering`'
- en: '`std::strong_equality`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::strong_equality`'
- en: '`std::weak_equality`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::weak_equality`'
- en: All of them are defined in the `<compare>` header. The compiler generates operators
    based on the return type of the three-way operator.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都在`<compare>`头文件中定义。编译器根据三路运算符的返回类型生成运算符。
- en: Encapsulation and the public interface
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装和公共接口
- en: '**Encapsulation** is a key concept in object-oriented programming. It allows
    us to hide the implementation details of objects from the client code. Take, for
    example, a computer keyboard; it has keys for letters, numbers, and symbols, each
    of which acts if we press on them. Its usage is simple and intuitive, and it hides
    a lot of low-level details that only a person familiar with electronics would
    be able to handle. Imagine a keyboard without keys— one that has a bare board
    with unlabeled pins. You would have to guess which one to press to achieve the
    desired key combination or text input. Now, imagine a keyboard without pins— you
    have to send proper signals to the corresponding sockets to get the key *pressed*
    event of a particular symbol. Users could be confused by the absence of labels
    and they also could use it incorrectly by pressing or sending signals to invalid
    sockets. The keyboard as we know it solves this issue by encapsulating the implementation
    details – the same way programmers encapsulate objects so that they don''t load
    the user with redundant members and to make sure users won''t use the object in
    the wrong way.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装**是面向对象编程中的一个关键概念。它允许我们隐藏对象的实现细节，使其对客户端代码不可见。以计算机键盘为例；它有用于字母、数字和符号的按键，每个按键在按下时都会起作用。它的使用简单直观，并隐藏了许多只有熟悉电子设备的人才能处理的低级细节。想象一下一个没有按键的键盘——一个只有裸板和未标记引脚的键盘。你将不得不猜测要按下哪个键才能实现所需的按键组合或文本输入。现在，想象一个没有引脚的键盘——你必须向相应的插座发送正确的信号才能获得特定符号的按键*按下*事件。用户可能会因为缺少标签而感到困惑，他们也可能会错误地按下或向无效的插座发送信号。我们所知道的键盘通过封装实现了这一点——程序员也通过封装对象来确保用户不会因为冗余成员而负担过重，以及确保用户不会以错误的方式使用对象。'
- en: 'Visibility modifiers serve that purpose in the class by allowing us to define
    the accessibility level of any member. The `private` modifier prohibits any use
    of the `private` member from the client code. This allows us to control the modification
    of the `private` member by providing corresponding member functions. A `mutator`
    function, familiar to many as a setter function, modifies the value of a `private`
    member after testing the value against specified rules for that particular class.
    An example of this can be seen in the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中，可见性修饰符通过允许我们定义任何成员的可访问级别来实现这一目的。`private`修饰符禁止客户端代码使用`private`成员，这使我们能够通过提供相应的成员函数来控制`private`成员的修改。一个`mutator`函数，对许多人来说是一个设置函数，会在测试该特定类的值是否符合指定规则后修改`private`成员的值。以下代码中可以看到这一点的例子：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Modifying a data member through a `mutator` function allows us to control its
    value. The actual data member is private, which makes it inaccessible from the
    client code, while the class itself provides public functions to update or read
    the contents of its private members. These functions, along with the constructors,
    are often referred to as the *public interface* of the class. Programmers strive
    to make the class' public interface user-friendly.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`mutator`函数修改数据成员允许我们控制其值。实际数据成员是私有的，这使得它无法从客户端代码访问，而类本身提供了公共函数来更新或读取其私有成员的内容。这些函数以及构造函数通常被称为类的*公共接口*。程序员们努力使类的公共接口用户友好。
- en: 'Take a look at the following class, which represents a quadratic equation solver:
    an equation of the form `ax² + bx + c = 0`. One of the solutions is finding a
    discriminant using the formula `D  = b2 - 4ac` and then calculating the value
    of `x` based on the value of the discriminant (D). The following class provides
    five functions, that is, for setting the values of `a`, `b`, and `c`, respectively,
    to find the discriminant, and to solve and return the value of `x`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的类，它表示一个二次方程求解器：一个形式为`ax² + bx + c = 0`的方程。找到判别式并根据判别式（D）的值计算`x`的值是解决方案之一。以下类提供了五个函数，分别用于设置`a`、`b`和`c`的值，找到判别式，解决并返回`x`的值：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The public interface includes the previously mentioned four functions and the
    default constructor. To solve the equation *2x² + 5x - 8 = 0*, we should use `QuadraticSolver`
    like so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 公共接口包括前面提到的四个函数和默认构造函数。要解决方程*2x² + 5x - 8 = 0*，我们应该这样使用`QuadraticSolver`：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The public interface of the class should be designed wisely; the preceding
    example shows signs of bad design. The user must know the protocol, that is, the
    exact order to call the functions in. If the user misses the call to `find_discriminant()`,
    the result will be undefined or invalid. The public interface forces the user
    to learn the protocol and to call functions in the proper order, that is, setting
    values of `a`, `b`, and `c`, then calling the `find_discriminant()` function,
    and, finally, calling the `solve()` function to get the desired value of `x`.
    A good design should provide an intuitively easy public interface. We can overwrite
    `QuadraticSolver` so that it only has one function that takes all the necessary
    input values, calculates the discriminant itself, and returns the solution:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 类的公共接口应该被明智地设计；前面的例子显示了糟糕设计的迹象。用户必须知道协议，也就是确切的调用函数的顺序。如果用户忽略了对`find_discriminant()`的调用，结果将是未定义或无效的。公共接口强迫用户学习协议，并按正确的顺序调用函数，即设置`a`、`b`和`c`的值，然后调用`find_discriminant()`函数，最后调用`solve()`函数以获得`x`的期望值。一个好的设计应该提供一个直观易用的公共接口。我们可以重写`QuadraticSolver`，使其只有一个函数，接受所有必要的输入值，计算判别式本身，并返回解决方案：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding design is more intuitive than the previous one. The following
    code demonstrates the usage of `QuadraticSolver` to find the solution to the equation, *2x2 +
    5x - 8 = 0*:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的设计比之前的更直观。以下代码演示了如何使用`QuadraticSolver`来找到方程*2x2 + 5x - 8 = 0*的解：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The last thing to consider here is the idea that a quadratic equation can be
    solved in more than one way. The one we introduced is done by finding the discriminant.
    We should consider that, in the future, we could add further implementation methods
    to the class. Changing the name of the function may increase the readability of
    the public interface and secure the future updates to the class. We should also
    note that the `solve()` function in the preceding example takes `a`, `b`, and
    `c` as arguments, and we don't need to store them in the class since the solution
    is calculated directly in the function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要考虑的最后一件事是，二次方程可以有多种解法。我们介绍的方法是通过找到判别式来解决的。我们应该考虑，将来我们可能会为这个类添加更多的实现方法。改变函数的名称可能会增加公共接口的可读性，并确保对类的未来更新。我们还应该注意，在前面的例子中，`solve()`函数接受`a`、`b`和`c`作为参数，我们不需要在类中存储它们，因为解决方案是直接在函数中计算的。
- en: 'It''s obvious that declaring an object of the `QuadraticSolver` just to be
    able to access the `solve()` function seems to be a redundant step. The final
    design of the class will look like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，声明一个`QuadraticSolver`的对象只是为了能够访问`solve()`函数似乎是一个多余的步骤。类的最终设计将如下所示：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We renamed the `solve()` function to `solve_by_discriminant()`, which also
    exposes the underneath method of the solution. We also made the function *static*,
    thus making it available to the user without declaring an instance of the class.
    However, we also marked the default constructor *deleted*, which, again, forces
    the user not to declare an object:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`solve()`函数重命名为`solve_by_discriminant()`，这也暴露了解决方案的底层方法。我们还将函数设为*static*，这样用户就可以在不声明类的实例的情况下使用它。然而，我们还将默认构造函数标记为*deleted*，这再次强制用户不要声明对象：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The client code now spends less effort using the class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码现在使用该类的工作量更少。
- en: Structs in C++
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的结构体
- en: 'Structs are almost the same as classes in C++. They have all the features of
    classes, and you can inherit a class from a structure and vice versa. The only
    difference between a `class` and a `struct` is the default visibility. For structs,
    the default visibility modifier is public. It relates to inheritance as well.
    For example, when you inherit a class from another class without using a modifier,
    it inherits privately. The following class inherits from `Base` privately:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，结构体和类几乎是相同的。它们具有类的所有特性，你可以从结构体继承一个类，反之亦然。`class`和`struct`之间唯一的区别是默认可见性。对于结构体，默认可见性修饰符是公共的。它也与继承有关。例如，当你从另一个类继承一个类而不使用修饰符时，它会私有继承。以下类私有地继承自`Base`：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Following the same logic, the following struct inherits the `Base` publicly:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的逻辑，以下结构体公开继承`Base`：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The same relates to the class that inherits from a struct. For example, the
    `Derived` class inherits from `Base` privately if not specified directly:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与继承自结构体的类相关。例如，如果没有直接指定，`Derived`类会私有地继承`Base`：
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In C++, structs and classes are interchangeable, but most programmers prefer
    to use structs for simple types. The C++ standard gives a better definition of
    simple types and calls them **aggregates**. A class (struct) is an aggregate if
    it conforms to the following rules:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，结构体和类是可以互换的，但大多数程序员更喜欢使用结构体来表示简单类型。C++标准对简单类型给出了更好的定义，并称它们为**聚合**。如果一个类（结构体）符合以下规则，则它是一个聚合：
- en: No private or protected non-static data members
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有私有或受保护的非静态数据成员
- en: No user-declared or inherited constructors
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有用户声明或继承的构造函数
- en: No virtual, private, or protected base classes
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有虚拟、私有或受保护的基类
- en: No virtual member functions
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有虚成员函数
- en: 'Most of these rules will be a lot clearer after you finish this chapter. The
    following struct is an example of an aggregate:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章后，大多数规则会更加清晰。以下结构是一个聚合的例子：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Before diving into inheritance and virtual functions, let''s see what benefits
    aggregates bring when initializing. We can initialize `Person` objects in the
    following way:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究继承和虚函数之前，让我们看看聚合在初始化时带来了什么好处。我们可以以以下方式初始化`Person`对象：
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'C++20 provides even more fancy ways to initialize aggregates:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: C++20提供了更多初始化聚合的新方法：
- en: '[PRE53]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note how we mixed the initialization of members by designators.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何通过指示符混合初始化成员。
- en: 'Structured binding allows us to declare variables bound to aggregate members,
    as shown in the following code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化绑定允许我们声明绑定到聚合成员的变量，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Structured binding is also applicable to arrays.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化绑定也适用于数组。
- en: Class relationships
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类关系
- en: 'Object intercommunication is at the heart of object-oriented systems. The relationship
    is the logical link between objects. The way we can distinguish or set up a proper
    relationship between classes of objects defines both the performance and quality
    of the system design overall. Consider the `Product` and `Warehouse` classes;
    they are in a relationship called aggregation because the `Warehouse` contains
    `Products`, that is, the `Warehouse` aggregates `Products`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对象间通信是面向对象系统的核心。关系是对象之间的逻辑链接。我们如何区分或建立类对象之间的适当关系，定义了系统设计的性能和质量。考虑`Product`和`Warehouse`类；它们处于一种称为聚合的关系，因为`Warehouse`包含`Products`，也就是说，`Warehouse`聚合了`Products`：
- en: '![](img/76b956c9-22ba-4ee7-af40-f4edc84ae8ca.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76b956c9-22ba-4ee7-af40-f4edc84ae8ca.png)'
- en: There are several kinds of relationships in terms of pure OOP, such as association,
    aggregation, composition, instantiation, generalization, and others.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯面向对象编程中有几种关系，比如关联、聚合、组合、实例化、泛化等。
- en: Aggregation and composition
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合和组合
- en: We encountered aggregation in the example of the `Warehouse` class. The `Warehouse`
    class stores an array of Products. In more general terms, it can be called an
    *association*, but to strongly emphasize the exact containment, we use the term *aggregation*
    or *composition*. In the case of aggregation, the class that contains an instance
    or instances of other classes could be instantiated without the aggregate. This
    means that we can create and use a `Warehouse` object without necessarily creating
    `Product` objects contained in the `Warehouse`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Warehouse`类的例子中遇到了聚合。`Warehouse`类存储了一个产品数组。更一般的说，它可以被称为*关联*，但为了强调确切的包含性，我们使用*聚合*或*组合*这个术语。在聚合的情况下，包含其他类的类可以在没有聚合的情况下实例化。这意味着我们可以创建和使用`Warehouse`对象，而不一定要创建`Warehouse`中包含的`Product`对象。
- en: 'Another example of aggregation is the `Car` and the `Person`. A `Car` can contain
    a `Person` object (as a driver or passenger) since they are associated with each
    other, but the containment is not strong. We can create a `Car` object without
    a `Driver` in it, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合的另一个例子是`Car`和`Person`。`Car`可以包含一个`Person`对象（作为驾驶员或乘客），因为它们彼此相关，但包含性不强。我们可以创建一个没有`Driver`的`Car`对象，如下所示：
- en: '[PRE55]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The strong containment is expressed by **composition**. For the `Car` example,
    an object of the `Engine` class is required to make a complete `Car` object. In
    this physical representation, the `Engine` member is automatically created when
    a `Car` is created.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的包含性由**组合**来表达。以`Car`为例，需要一个`Engine`类的对象才能组成一个完整的`Car`对象。在这种物理表示中，当创建一个`Car`时，`Engine`成员会自动创建。
- en: 'The following is the UML representation of aggregation and composition:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是聚合和组合的UML表示：
- en: '![](img/7e185cb8-02eb-4899-9520-8ca23b59015c.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e185cb8-02eb-4899-9520-8ca23b59015c.png)'
- en: When designing classes, we have to decide on their relationship. The best way
    to define the composition between the two classes is the *has-a* relationship
    test. A `Car` has-a `Engine`, because a car has an engine. Any time you can't
    decide whether the relationship should be expressed in terms of composition, ask
    the *has-a* question. Aggregation and composition are somewhat similar; they just
    describe the strength of the connection. For aggregation, the proper question
    would be *can have a*; for example, a `Car` can have a driver (of the `Person` type);
    that is, the containment is weak.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计类时，我们必须决定它们的关系。定义两个类之间的组合关系的最佳方法是*有一个*关系测试。`Car` 有一个 `Engine`，因为汽车有发动机。每当你不能确定关系是否应该以组合的方式表达时，问一下*有一个*的问题。聚合和组合有些相似；它们只是描述了连接的强度。对于聚合，适当的问题应该是*可以有一个*；例如，一个`Car`可以有一个驾驶员（类型为`Person`）；也就是说，包含性是弱的。
- en: Inheritance
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: '**Inheritance** is a programming concept that allows us to reuse classes. Programming
    languages provide different implementations of inheritance, but the general rule
    always stands: the class relationship should answer the *is-a* question. For example,
    a `Car` is-a `Vehicle`, which allows us to inherit the `Car` from the `Vehicle`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**是一种允许我们重用类的编程概念。编程语言提供了不同的继承实现，但总的规则始终是：类关系应该回答*是一个*的问题。例如，`Car`是一个`Vehicle`，这使我们可以从`Vehicle`继承`Car`：'
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `Car` now has the `move()` member function derived from the `Vehicle`. Inheritance
    itself represents a generalization/specialization relationship, where the parent
    class (`Vehicle`) is the generalization and the child class (`Car`) is the specialization.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car`现在有了从`Vehicle`继承而来的`move()`成员函数。继承本身代表了一种泛化/特化的关系，其中父类（`Vehicle`）是泛化，子类（`Car`）是特化。'
- en: The parent class could be referred to as the base class or the superclass, while
    the child class could be referred to as the derived class or the subclass, respectively.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 父类可以被称为基类或超类，而子类可以被称为派生类或子类。
- en: 'You should only consider using inheritance if it is absolutely necessary. As
    we mentioned earlier, classes should satisfy the *is-a* relationship, and sometimes,
    this is a bit tricky. Consider the `Square` and `Rectangle` classes. The following
    code declares the `Rectangle` class in its simplest possible form:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在绝对必要的情况下才应考虑使用继承。正如我们之前提到的，类应该满足*是一个*的关系，有时这有点棘手。考虑`Square`和`Rectangle`类。以下代码以可能的最简形式声明了`Rectangle`类：
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `Square` *is-a *`Rectangle`, so we could easily inherit it from the `Rectangle`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Square` *是一个* `Rectangle`，所以我们可以很容易地从`Rectangle`继承它：'
- en: '[PRE58]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `Square` extends the `Rectangle` by adding a new data member, `area_`,
    and overwriting the `area()` member function with its own implementation. In practice,
    the `area_` and the way we calculate its value are redundant; we did this to demonstrate
    a bad class design and to make the `Square` extend its parent to some extent.
    Soon, we will conclude that the inheritance, in this case, is a bad design choice.
    `Square` is a `Rectangle`, so it should be used as a `Rectangle` wherever the
    `Rectangle` is used, as shown here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Square`通过添加一个新的数据成员`area_`并覆盖`area()`成员函数的实现来扩展`Rectangle`。在实践中，`area_`及其计算方式是多余的；我们这样做是为了演示一个糟糕的类设计，并使`Square`在一定程度上扩展其父类。很快，我们将得出结论，即在这种情况下，继承是一个糟糕的设计选择。`Square`是一个`Rectangle`，所以应该在`Rectangle`使用的任何地方使用`Rectangle`，如下所示：'
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `make_big_rectangle()` function takes a reference to the `Rectangle` and
    the `Square` inherits it, so it's totally fine to send a `Square` object to the
    `make_big_rectangle()` function; the `Square` *is-a* a `Rectangle`. This example
    of the successful substitution of a type with its subtype is known as the **Liskov
    Substitution Principle**. Let's find out why this substitution works in practice
    and then decide if we made a design mistake by inheriting the `Square` from the
    `Rectangle` (yes, we did).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`make_big_rectangle()`函数接受`Rectangle`的引用，而`Square`继承了它，所以将`Square`对象发送到`make_big_rectangle()`函数是完全可以的；`Square`
    *是一个* `Rectangle`。这种成功用其子类型替换类型的示例被称为**Liskov替换原则**。让我们找出为什么这种替换在实践中有效，然后决定我们是否通过从`Rectangle`继承`Square`而犯了设计错误（是的，我们犯了）。'
- en: Inheritance from the compiler perspective
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从编译器的角度来看继承
- en: 'We can picture the `Rectangle` class we declared earlier in the following way:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样描述我们之前声明的`Rectangle`类：
- en: '![](img/d6008180-4ca7-4fb1-9983-255e24f7972d.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6008180-4ca7-4fb1-9983-255e24f7972d.png)'
- en: 'When we declare the `rect` object in the `main()` function, the space that''s
    required for the local objects of the function is allocated in the stack. The
    same logic follows for the `make_big_rectangle()` function when it''s called.
    It doesn''t have local arguments; instead, it has an argument of the `Rectangle&` type,
    which behaves in a similar fashion to a pointer: it takes the memory space required
    to store a memory address (4 or 8 bytes in 32- and 64-bit systems, respectively).
    The `rect` object is passed to `make_big_rectangle()` by reference, which means
    the `ref` argument refers to the local object in `main()`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`main()`函数中声明`rect`对象时，函数的本地对象所需的空间被分配在堆栈中。当调用`make_big_rectangle()`函数时，遵循相同的逻辑。它没有本地参数；相反，它有一个`Rectangle&`类型的参数，其行为类似于指针：它占用存储内存地址所需的内存空间（在32位和64位系统中分别为4或8字节）。`rect`对象通过引用传递给`make_big_rectangle()`，这意味着`ref`参数指的是`main()`中的本地对象：
- en: '![](img/e4df863f-4b4a-4a28-ae69-dffaab6c6b0a.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4df863f-4b4a-4a28-ae69-dffaab6c6b0a.png)'
- en: 'Here is an illustration of the `Square` class:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Square`类的示例：
- en: '![](img/6d479be2-8fce-47b9-937f-062bbb09e7af.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d479be2-8fce-47b9-937f-062bbb09e7af.png)'
- en: As shown in the preceding diagram, the `Square` object contains a **subobject**
    of `Rectangle`; it partially represents a `Rectangle`. In this particular example,
    the `Square` class doesn't extend the rectangle with new data members.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`Square`对象包含`Rectangle`的**子对象**；它部分代表了`Rectangle`。在这个特定的例子中，`Square`类没有用新的数据成员扩展矩形。
- en: 'The `Square` object is passed to `make_big_rectangle()`, though the latter
    takes an argument of the `Rectangle&` type. We know that the type of the pointer
    (reference) is required when accessing the underlying object. The type defines
    how many bytes should be read from the starting address pointed to by the pointer.
    In this case, `ref` stores the copy of the starting address of the local `rect` object
    declared in `main()`. When `make_big_rectangle()` accesses the member functions
    via `ref`, it actually calls global functions that take a `Rectangle` reference
    as its first parameter. The function is translated into the following (again,
    we slightly modified it for the sake of simplicity):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`Square`对象被传递给`make_big_rectangle()`，尽管后者需要一个`Rectangle&`类型的参数。我们知道在访问底层对象时需要指针（引用）的类型。类型定义了应该从指针指向的起始地址读取多少字节。在这种情况下，`ref`存储了在`main()`中声明的本地`rect`对象的起始地址的副本。当`make_big_rectangle()`通过`ref`访问成员函数时，实际上调用的是以`Rectangle`引用作为第一个参数的全局函数。该函数被转换为以下形式（再次，为了简单起见，我们稍作修改）：'
- en: '[PRE60]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Dereferencing `ref` implies reading `sizeof(Rectangle)` bytes, starting from
    the memory location pointed to by `ref`. When we pass a `Square` object to `make_big_rectangle()`,
    we assign the starting address of `sq` (the `Square` object) to `ref`. This will
    work fine because the `Square` object actually contains a `Rectangle` subobject.
    When the `make_big_rectangle()` function dereferences `ref`, it is only able to
    access the `sizeof(Rectangle)` bytes of the object and doesn''t *see* the additional
    bytes of the actual `Square` object. The following diagram illustrates the part
    of the subobject `ref` points to:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 解引用`ref`意味着从`ref`指向的内存位置开始读取`sizeof(Rectangle)`字节。当我们将`Square`对象传递给`make_big_rectangle()`时，我们将`sq`（`Square`对象）的起始地址分配给`ref`。这将正常工作，因为`Square`对象实际上包含一个`Rectangle`子对象。当`make_big_rectangle()`函数解引用`ref`时，它只能访问对象的`sizeof(Rectangle)`字节，并且看不到实际`Square`对象的附加字节。以下图示了`ref`指向的子对象的部分：
- en: '![](img/e80a6dd3-39ba-4f60-9d03-d5eb016642aa.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e80a6dd3-39ba-4f60-9d03-d5eb016642aa.png)'
- en: 'Inheriting the `Square` from the `Rectangle` is almost the same as declaring
    two structs, one of which (the child) contains the other (the parent):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Rectangle`继承`Square`几乎与声明两个结构体相同，其中一个（子类）包含另一个（父类）：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The preceding code demonstrates the compiler's way of supporting inheritance.
    Take a look at the commented lines of code for the `Square_set_side` and `Square_area` functions.
    We don't actually insist on this implementation, but it expresses the full idea
    of how the compiler processes OOP code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码演示了编译器支持继承的方式。看一下`Square_set_side`和`Square_area`函数的注释代码。我们实际上并不坚持这种实现，但它表达了编译器处理面向对象编程代码的完整思想。
- en: Composition versus inheritance
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合与继承
- en: 'The C++ language provides us with convenient and OOP-friendly syntax so that
    we can express the inheritance relationship, but the way the compiler processes
    it resembles composition rather than inheritance. It''s actually even better to
    use composition instead of inheritance wherever it is applicable. The `Square` class
    and its relationship with the `Rectangle` was claimed to be a bad design choice.
    One of the reasons was the subtype substitution principle, which allowed us to
    use the `Square` the wrong way: pass it to a function that modifies it as a `Rectangle`
    rather than a `Square`. This tells us that the *is-a* relationship is not correct
    because the `Square` is not a `Rectangle` after all. It is an adaptation of a
    `Rectangle` rather than a `Rectangle` itself, which means it doesn''t actually represent
    a `Rectangle`; it uses it to provide limited functionality to class users.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言为我们提供了方便和面向对象的语法，以便我们可以表达继承关系，但编译器处理它的方式更像是组合而不是继承。实际上，在适用的地方使用组合而不是继承甚至更好。`Square`类及其与`Rectangle`的关系被认为是一个糟糕的设计选择。其中一个原因是子类型替换原则，它允许我们以错误的方式使用`Square`：将其传递给一个将其作为`Rectangle`而不是`Square`修改的函数。这告诉我们*是一个*关系并不正确，因为`Square`毕竟不是`Rectangle`。它是`Rectangle`的一种适应，而不是`Rectangle`本身，这意味着它实际上并不代表`Rectangle`；它使用`Rectangle`来为类用户提供有限的功能。
- en: 'Users of the `Square` shouldn''t know that it can be used as a `Rectangle`;
    otherwise, at some point, they would send invalid or unsupported messages to `Square`
    instances. Examples of invalid messages are the calls to the `set_width` or `set_height` function.
    The `Square` shouldn''t actually support two different member functions to modify
    its sides separately, but it can''t hide this because it announced that it''s
    inherited from the `Rectangle`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`Square`的用户不应该知道它可以被用作`Rectangle`；否则，在某个时候，他们会向`Square`实例发送无效或不支持的消息。无效消息的例子是调用`set_width`或`set_height`函数。`Square`实际上不应该支持两个不同的成员函数来分别修改它的边，但它不能隐藏这一点，因为它宣布它是从`Rectangle`继承而来的：'
- en: '[PRE62]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'What if we change the modifier from public to private? Well, C++ supports both
    public and private inheritance types. It also supports protected inheritance as
    well. When inheriting privately from a class, the subclass intends to use the
    parent class and has access to its public interface. However, the client code
    is not aware that it deals with a derived class. Furthermore, the public interface
    that''s inherited from the parent class becomes private for users of the child
    class. It seems like the `Square` transforms inheritance into a composition:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将修饰符从public改为private会怎么样？嗯，C++支持公有和私有继承类型。它还支持受保护的继承。当从类私有继承时，子类打算使用父类并且可以访问其公共接口。然而，客户端代码并不知道它正在处理一个派生类。此外，从父类继承的公共接口对于子类的用户来说变成了私有的。似乎`Square`将继承转化为组合：
- en: '[PRE63]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The client code cannot access members inherited from the `Rectangle`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码无法访问从`Rectangle`继承的成员：
- en: '[PRE64]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The same can be achieved by declaring a `Rectangle` member in the private section
    of the `Square`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`Square`的私有部分声明一个`Rectangle`成员也可以实现相同的效果：
- en: '[PRE65]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: You should carefully analyze usage scenarios and completely answer the *is-a*
    question in order to use inheritance without a doubt. Every time you encounter
    a choice between composition and inheritance, choose composition.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该仔细分析使用场景，并完全回答*是一个*问题，以便毫无疑问地使用继承。每当你在组合和继承之间做出选择时，选择组合。
- en: 'We can omit the modifier when inheriting privately. The default access modifier
    for classes is private, so `class Square : private Rectangle {};` is the same
    as `class Square : Rectangle {};`. On the contrary, the default modifier for structs
    is public.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '在私有继承时，我们可以省略修饰符。类的默认访问修饰符是private，所以`class Square : private Rectangle {};`和`class
    Square : Rectangle {};`是一样的。相反，结构体的默认修饰符是public。'
- en: Protected inheritance
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受保护的继承
- en: Finally, we have the **protected** access modifier. It specifies the access
    level of the class members if they're used in the class body. Protected members
    are private to the class users, but are public to derived classes. If the modifier
    is used to specify the type of inheritance, it behaves similarly to the private
    inheritance for derived class users. While private inheritance hides the public
    interface of the base class from all the derived class users, protected inheritance
    makes it accessible to descendants of the derived class.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有**protected**访问修饰符。它指定了类成员在类体中使用时的访问级别。受保护成员对于类的用户来说是私有的，但对于派生类来说是公共的。如果该修饰符用于指定继承的类型，它对于派生类的用户的行为类似于私有继承。私有继承隐藏了基类的公共接口，而受保护继承使其对派生类的后代可访问。
- en: It's hard to imagine a scenario where you would need protected inheritance,
    but you should consider it as a tool that might be useful in unexpectedly obvious
    designs. Let's suppose we need to design a stack data structure adapter. The stack
    is usually implemented based on a vector (one-dimensional array), a linked list,
    or a dequeue.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象一个需要受保护继承的场景，但你应该将其视为一个可能在意料之外的明显设计中有用的工具。假设我们需要设计一个栈数据结构适配器。栈通常是基于向量（一维数组）、链表或双端队列实现的。
- en: The stack conforms to the LIFO rule, which states that the last element inserted
    into the stack will be accessed first. Similarly, the first element inserted into
    the stack will be accessed last. We will discuss data structures and data structure
    adapters in more detail in [Chapter 6](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml), *Digging
    into Data Structures and Algorithms in STL*
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 栈符合LIFO规则，即最后插入栈的元素将首先被访问。同样，首先插入栈的元素将最后被访问。我们将在[第6章](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml)中更详细地讨论数据结构和STL中的数据结构适配器和算法
- en: 'The stack itself doesn''t represent a data structure; it *sits* on top of a
    data structure and adapts its usage by limiting, modifying, or extending its functions.
    The following is a simple declaration of the `Vector` class representing a one-dimensional
    array of integers:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 栈本身并不代表一个数据结构；它*位于*数据结构的顶部，并通过限制、修改或扩展其功能来适应其使用。以下是表示整数一维数组的`Vector`类的简单声明：
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The preceding `Vector` is not an STL-compatible container with random access
    iterator support; it contains the bare minimum for a dynamically increasing array.
    It can be declared and used in the following way:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`Vector`不是一个具有随机访问迭代器支持的STL兼容容器；它只包含动态增长数组的最低限度。可以这样声明和使用它：
- en: '[PRE67]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'While the `Vector` class provides `operator[]`, which allows us to access any
    of its items randomly, the `Stack` prohibits random accesses. The `Stack` provides
    `push` and `pop` operations so that we can insert a value into its underlying
    data structure and fetch the value, respectively:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vector`类提供`operator[]`，允许我们随机访问其中的任何项，而`Stack`禁止随机访问。`Stack`提供`push`和`pop`操作，以便我们可以插入值到其底层数据结构中，并分别获取该值：'
- en: '[PRE68]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `Stack` can be used in the following way:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack`可以以以下方式使用：'
- en: '[PRE69]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The stack *adapts* the `Vector` and provides two member functions so that we
    can access it. Private inheritance allows us to use the full capabilities of the
    `Vector` and hide the inheritance information from the `Stack` users. What if
    we want to inherit the `Stack` to create an advanced version of it? Let's say
    the `AdvancedStack` class provides the `min()` function, which returns the minimum
    value contained in the stack in constant time.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 栈*适配*`Vector`并提供两个成员函数，以便我们可以访问它。私有继承允许我们使用`Vector`的全部功能，并且隐藏继承信息，不让`Stack`的用户知道。如果我们想要继承`Stack`来创建其高级版本怎么办？假设`AdvancedStack`类提供了`min()`函数，以常数时间返回栈中包含的最小值。
- en: 'The private inheritance prohibits the `AdvancedStack` so that it uses the public
    interface of the `Vector`, so we need a way to allow the `Stack` subclasses to
    use its base class, but hide the base class'' existence from class users. Protected
    inheritance serves that goal, as shown in the following coe:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 私有继承禁止`AdvancedStack`使用`Vector`的公共接口，因此我们需要一种方法来允许`Stack`的子类使用其基类，但是隐藏基类的存在。受保护的继承可以实现这一目标，如下所示：
- en: '[PRE70]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: By inheriting the `Stack` from the `Vector`, we allow the subclass of the `Stack`
    to use the `Vector` public interface. But the users of both the `Stack` and `AdvancedStack`
    won't be able to access them as a `Vector`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从`Vector`继承`Stack`，我们允许`Stack`的子类使用`Vector`的公共接口。但是`Stack`和`AdvancedStack`的用户将无法将它们视为`Vector`。
- en: Polymorphism
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: '**Polymorphism** is another key concept in object-oriented programming. It
    allows subclasses to have their own implementation for the functions that are
    derived from the base class. Let''s suppose we have the `Musician` class, which
    has the `play()` member function:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**多态**是面向对象编程中的另一个关键概念。它允许子类对从基类派生的函数进行自己的实现。假设我们有`Musician`类，它有`play()`成员函数：'
- en: '[PRE71]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, let''s declare the `Guitarist` class, which has the `play_guitar()` function:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们声明`Guitarist`类，它有`play_guitar()`函数：
- en: '[PRE72]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This is the obvious case of using inheritance because the `Guitarist` just
    screams that it *is-a* `Musician`. It would be natural for the `Guitarist` to
    not extend the `Musician` by adding a new function (such as `play_guitar()`);
    instead, it should provide its own implementation of the `play()` function derived
    from the `Musician`. To accomplish this, we use **virtual functions**:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这是继承的明显案例，因为`Guitarist`明显表明它*是一个*`Musician`。`Guitarist`自然不应该通过添加新函数（如`play_guitar()`）来扩展`Musician`；相反，它应该提供其自己从`Musician`派生的`play()`函数的实现。为了实现这一点，我们使用**虚函数**：
- en: '[PRE73]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, it''s obviously simple that the `Guitarist` class provides its own implementation
    to the `play()` function and that the client code can access it by just using
    the pointer to the base class:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，显然`Guitarist`类提供了`play()`函数的自己的实现，客户端代码可以通过使用指向基类的指针来访问它：
- en: '[PRE74]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The preceding example shows polymorphism in action. While the use of virtual
    functions comes naturally, it actually doesn''t make much sense unless we use
    it properly. First of all, the `play()` function of the `Musician` should not
    have any implementation at all. The reason for this is simple: a musician should
    be able to play on a concrete instrument as they cannot play on more than one
    instrument simultaneously. To get rid of the implementation, we set the function
    as a **pure virtual function** by assigning `0` to it:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子展示了多态的实际应用。虚函数的使用虽然很自然，但实际上除非我们正确使用它，否则并没有太多意义。首先，`Musician`的`play()`函数根本不应该有任何实现。原因很简单：音乐家应该能够在具体的乐器上演奏，因为他们不能同时演奏多个乐器。为了摆脱实现，我们通过将`0`赋值给它将函数设置为**纯虚函数**：
- en: '[PRE75]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This leads to a compile error when the client code tries to declare an instance
    of the `Musician`. And, of course, it must lead to a compile error, because you
    shouldn''t be able to create an object that has an *undefined* function. The `Musician`
    serves a single purpose: it must only be inherited by other classes. The class
    that exists to be inherited is called an **abstract class**. Actually, the `Musician`
    is called an **interface** rather than an abstract class. An abstract class is
    a semi-interface semi-class that can have both types of functions: with and without
    implementation.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端代码尝试声明`Musician`的实例时，会导致编译错误。当然，这必须导致编译错误，因为不应该能够创建具有*未定义*函数的对象。`Musician`只有一个目的：它必须只能被其他类继承。存在供继承的类称为**抽象类**。实际上，`Musician`被称为**接口**而不是抽象类。抽象类是半接口半类，可以具有有和无实现的函数。
- en: 'Getting back to our example, let''s add the `Pianist` class, which also implements
    the `Musician` interface:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，让我们添加`Pianist`类，它也实现了`Musician`接口：
- en: '[PRE76]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To express the full power of polymorphism, let''s suppose that we have a function
    declared somewhere that returns a collection of musicians, either guitarist or
    pianists:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表达多态性的全部功能，假设我们在某处声明了一个函数，返回吉他手或钢琴家的集合：
- en: '[PRE77]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'From the perspective of the client code, it will be hard to dissect the return
    value of the `get_musicians()` function and find out what the actual subtype of
    the object is. It could be either `Guitarist` or `Pianist`, or even a pure `Musician`.
    The point is that the client shouldn''t really care about the actual type of objects
    as it knows that the collection contains Musicians and a `Musician` object has
    the `play()` function. So, to get them in action, the client can just iterate
    through the collection and make each musician play its instrument (each object
    calls its implementation):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端代码的角度来看，很难解析`get_musicians()`函数的返回值，并找出对象的实际子类型是什么。它可能是`吉他手`或`钢琴家`，甚至是纯粹的`音乐家`。关键是客户端不应该真正关心对象的实际类型，因为它知道集合包含音乐家，而`音乐家`对象具有`play()`函数。因此，为了让它们发挥作用，客户端只需遍历集合，并让每个音乐家演奏其乐器（每个对象调用其实现）：
- en: '[PRE78]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The preceding code expresses the full power of polymorphism. Now, let's understand
    how the language supports polymorphism at a low level.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码表达了多态性的全部功能。现在，让我们了解语言如何在低级别上支持多态性。
- en: Virtual functions under the hood
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 底层的虚函数
- en: Although polymorphism is not limited to virtual functions, we will discuss them
    in more detail because dynamic polymorphism is the most popular form of polymorphism
    in C++. And again, the best way to better understand a concept or technology is
    by implementing it on your own. Whether we declare a virtual member function in
    a class or it has a base class with virtual functions, the compiler augments the
    class with an additional pointer. The pointer points to a table that's usually
    referred to as a virtual functions table, or simply a *virtual table*. We also
    refer to the pointer as the *virtual table pointer*.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然多态性不限于虚函数，但我们将更详细地讨论它们，因为动态多态性是C++中最流行的多态性形式。而且，更好地理解一个概念或技术的最佳方法是自己实现它。无论我们在类中声明虚成员函数还是它具有具有虚函数的基类，编译器都会用额外的指针增强类。指针指向的表通常被称为虚函数表，或者简称为*虚表*。我们还将指针称为*虚表指针*。
- en: 'Let''s suppose we are implementing a class subsystem for a bank customer account
    management. Let''s say that the bank asks us to implement cashing out based on
    the account type. For example, a savings account allows cashing out money once
    a year, while the checking account allows cashing out money whenever the customer
    wants. Without diving into any unnecessary details about the `Account` class,
    let''s declare the bare minimum that will help us understand virtual member functions.
    Let''s look at the `Account` class definition:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在为银行客户账户管理实现一个类子系统。假设银行要求我们根据账户类型实现取款。例如，储蓄账户允许每年取款一次，而支票账户允许客户随时取款。不涉及`Account`类的任何不必要的细节，让我们声明最少的内容，以便理解虚拟成员函数。让我们看一下`Account`类的定义：
- en: '[PRE79]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The compiler transforms the `Account` class into a structure that has a pointer
    to the virtual functions table. The following code represents pseudocode, explaining
    what happens when we declare virtual functions in the class. As always, note that
    we provide a general explanation rather than a compiler-specific implementation
    (the name mangling is also in a generic form; for example, we rename `cash_out`
    `Account_cash_out`):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将`Account`类转换为一个具有指向虚函数表的指针的结构。以下代码表示伪代码，解释了在类中声明虚函数时发生的情况。与往常一样，请注意，我们提供的是一般性的解释，而不是特定于编译器的实现（名称修饰也是以通用形式进行的；例如，我们将`cash_out`重命名为`Account_cash_out`）：
- en: '[PRE80]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Take a good look at the preceding pseudocode. The `Account` struct has `__vptr`
    as its first member. Since the previously declared `Account` class has two virtual
    functions, we can imagine the virtual table as an array with two pointers to virtual
    member functions. See the following representation:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看前面的伪代码。`Account`结构的第一个成员是`__vptr`。由于先前声明的`Account`类有两个虚函数，我们可以将虚表想象为一个数组，其中有两个指向虚成员函数的指针。请参阅以下表示：
- en: '[PRE81]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'With our previous presumptions at hand, let''s find out what code the compiler
    will generate when we call a virtual function on an object:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们之前的假设，让我们找出当我们在对象上调用虚函数时编译器将生成什么代码：
- en: '[PRE82]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here''s what we can imagine the compiler''s generated code to be like for the
    preceding code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以想象编译器为前面的代码生成的代码：
- en: '[PRE83]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Virtual functions show their power when they''re used in hierarchies. `SavingsAccount`
    inherits from the `Account` class like so:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 虚函数在层次结构中使用时显示其功能。`SavingsAccount`从`Account`类继承如下：
- en: '[PRE84]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'When we call `cash_out()` via a pointer (or a reference), the virtual function
    is invoked based on the target object that the pointer points to. For example,
    suppose `get_savings_account()` returns a `SavingsAccount` as `Account*`. The
    following code will call the `SavingsAccount` implementation of `cash_out()`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过指针（或引用）调用`cash_out()`时，虚函数是根据指针指向的目标对象调用的。例如，假设`get_savings_account()`将`SavingsAccount`作为`Account*`返回。以下代码将调用`SavingsAccount`的`cash_out()`实现：
- en: '[PRE85]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Here''s what the compiler generates for `SavingsClass`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编译器为`SavingsClass`生成的内容：
- en: '[PRE86]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'So, we have two different tables of virtual functions. When we create an object
    of the `Account` type, its `__vptr` points to `Account_VTable`, while the object
    of the `SavingsAccount` type has its `__vptr` pointing to `SavingsAccount_VTable`.
    Let''s take a look at the following code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有两个不同的虚拟函数表。当我们创建一个`Account`类型的对象时，它的`__vptr`指向`Account_VTable`，而`SavingsAccount`类型的对象的`__vptr`指向`SavingsAccount_VTable`。让我们看一下以下代码：
- en: '[PRE87]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The preceding code translates into this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码转换成了这样：
- en: '[PRE88]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Now, it's obvious that `__vptr[0]` resolves to the correct function because
    it is read via the `p` pointer.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很明显，`__vptr[0]`解析为正确的函数，因为它是通过`p`指针读取的。
- en: 'What if `SavingsAccount` doesn''t override the `cash_out()` function? In that
    case, the compiler just places the address of the base class implementation in
    the same slot as `SavingsAccount_VTable`, as shown here:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`SavingsAccount`没有覆盖`cash_out()`函数会怎么样？在这种情况下，编译器会将基类实现的地址放在与`SavingsAccount_VTable`相同的位置，如下所示：
- en: '[PRE89]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Compilers implement the virtual functions' representation and management differently.
    Some implementations use even different models, rather than the one we introduced
    earlier. We brought a popular approach and represented it in a generic way for
    the sake of simplicity. Now, we will take a look at what is going on under the
    hood of the code that incorporates dynamic polymorphism.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器以不同的方式实现和管理虚拟函数的表示。一些实现甚至使用不同的模型，而不是我们之前介绍的模型。我们采用了一种流行的方法，并以通用的方式表示，以简化起见。现在，我们将看看在包含动态多态性的代码底层发生了什么。
- en: Design patterns
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: Design patterns are one of the most expressive tools for programmers. They allow
    us to solve design problems in an elegant and well-tested way. When you are struggling
    to provide the best possible design of your classes and their relationship, a
    well-known design pattern may come to the rescue.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是程序员最具表现力的工具之一。它们使我们能够以一种优雅和经过充分测试的方式解决设计问题。当您努力提供最佳的类设计和它们的关系时，一个众所周知的设计模式可能会挽救局面。
- en: 'The simplest example of a design pattern is a **Singleton**. It provides us
    with a way to declare and use only one instance of the class. For example, suppose
    that the e-commerce platform has only one `Warehouse`. To access the `Warehouse`
    class, the project may require that we include and use it in many source files.
    To keep things in sync, we should make the `Warehouse` a Singleton:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式的最简单示例是**单例**。它为我们提供了一种声明和使用类的唯一实例的方法。例如，假设电子商务平台只有一个`Warehouse`。要访问`Warehouse`类，项目可能需要在许多源文件中包含并使用它。为了保持同步，我们应该将`Warehouse`设置为单例：
- en: '[PRE90]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We declared a static `Warehouse` object and two static functions for creating
    and destroying the corresponding instance. The private constructor leads to a
    compile error each time the user tries to declare a `Warehouse` object in the
    old way. To be able to use the `Warehouse`, the client code has to call the `create_instance()`
    function:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个静态的`Warehouse`对象和两个静态函数来创建和销毁相应的实例。私有构造函数导致每次用户尝试以旧的方式声明`Warehouse`对象时都会产生编译错误。为了能够使用`Warehouse`，客户端代码必须调用`create_instance()`函数。
- en: '[PRE91]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The singleton implementation of the `Warehouse` is not complete and is just
    an example to introduce design patterns. We will introduce more design patterns
    throughout this book.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`Warehouse`的单例实现并不完整，只是一个引入设计模式的示例。我们将在本书中介绍更多的设计模式。'
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the fundamental concepts of object-oriented programming.
    We touched on the low-level details of classes and the compiler implementation
    of the C++ object model. Knowing how to design and implement classes without actually
    having classes helps a lot in using the classes the right way.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了面向对象编程的基本概念。我们涉及了类的低级细节和C++对象模型的编译器实现。知道如何设计和实现类，而实际上没有类，有助于正确使用类。
- en: 'We also discussed the need for inheritance and tried to employ composition
    instead of inheritance wherever it might be applicable. C++ supports three types
    of inheritance: public, private, and protected. All of these types have their
    applications in particular class designs. Finally, we understood the use and power
    of polymorphism by bringing an example that drastically increases the convenience
    of the client code.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了继承的必要性，并尝试在可能适用的地方使用组合而不是继承。C++支持三种类型的继承：公有、私有和保护。所有这些类型都在特定的类设计中有它们的应用。最后，我们通过一个大大增加客户端代码便利性的例子理解了多态性的用途和力量。
- en: In the next chapter, we will learn more about templates and template metaprogramming,
    which we will use as the basis to dive into a new C++20 feature called concepts.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于模板和模板元编程的知识，这将成为我们深入研究名为概念的新C++20特性的基础。
- en: Questions
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the three properties of objects?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的三个属性是什么？
- en: What's the advantage of moving objects instead of copying them?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象移动而不是复制它们有什么优势？
- en: What's the difference between structs and classes in C++?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++中结构体和类有什么区别？
- en: What's the difference between aggregation and composition relations?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 聚合和组合关系之间有什么区别？
- en: What's the difference between private and protected inheritance?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 私有继承和保护继承有什么区别？
- en: How is the size of the class affected if we define a virtual function in it?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在类中定义了虚函数，类的大小会受到影响吗？
- en: What's the point of using the Singleton design pattern?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单例设计模式有什么意义？
- en: Further reading
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, refer to:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参考：
- en: Grady Booch, *Object-Oriented Analysis and Design* ([https://www.amazon.com/Object-Oriented-Analysis-Design-Applications-3rd/dp/020189551X/](https://www.amazon.com/Object-Oriented-Analysis-Design-Applications-3rd/dp/020189551X/))
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grady Booch，《面向对象的分析与设计》（[https://www.amazon.com/Object-Oriented-Analysis-Design-Applications-3rd/dp/020189551X/](https://www.amazon.com/Object-Oriented-Analysis-Design-Applications-3rd/dp/020189551X/)）
- en: Stanley Lippman, *Inside the C++ Object Model* ([https://www.amazon.com/Inside-Object-Model-Stanley-Lippman/dp/0201834545/](https://www.amazon.com/Inside-Object-Model-Stanley-Lippman/dp/0201834545/))
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stanley Lippman，《C++对象模型内部》（[https://www.amazon.com/Inside-Object-Model-Stanley-Lippman/dp/0201834545/](https://www.amazon.com/Inside-Object-Model-Stanley-Lippman/dp/0201834545/)）
