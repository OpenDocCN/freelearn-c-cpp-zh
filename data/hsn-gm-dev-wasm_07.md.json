["```cpp\nclass Collider {\n    public:\n        double m_X;\n        double m_Y;\n        double m_Radius;\n\n        Collider(double radius);\n\n        bool HitTest( Collider *collider );\n};\n```", "```cpp\n#include \"game.hpp\"\nCollider::Collider(double radius) {\n    m_Radius = radius;\n}\n\nbool Collider::HitTest( Collider *collider ) {\n    double dist_x = m_X - collider->m_X;\n    double dist_y = m_Y - collider->m_Y;\n    double radius = m_Radius + collider->m_Radius;\n\n    if( dist_x * dist_x + dist_y * dist_y <= radius * radius ) {\n        return true;\n    }\n    return false;\n}\n```", "```cpp\nclass Ship: public Collider {\n    public:\n        Uint32 m_LastLaunchTime;\n        const int c_Width = 16;\n        const int c_Height = 16;\n        SDL_Texture *m_SpriteTexture;\n        Ship();\n        float m_Rotation;\n        float m_DX;\n        float m_DY;\n        float m_VX;\n        float m_VY;\n\n        void RotateLeft();\n        void RotateRight();\n        void Accelerate();\n        void Decelerate();\n        void CapVelocity();\n\n        virtual void Move() = 0;\n        void Render();\n};\n```", "```cpp\nclass PlayerShip: public Ship {\n    public:\n        const char* c_SpriteFile = \"sprites/Franchise.png\";\n        const Uint32 c_MinLaunchTime = 300;\n        PlayerShip();\n        void Move();\n};\n\nclass EnemyShip: public Ship {\n    public:\n        const char* c_SpriteFile = \"sprites/BirdOfAnger.png\";\n        const Uint32 c_MinLaunchTime = 300;\n        const int c_AIStateTime = 2000;\n        FSM_STUB m_AIState;\n        int m_AIStateTTL;\n\n        EnemyShip();\n        void AIStub();\n        void Move();\n};\n```", "```cpp\n#include \"game.hpp\"\n\nShip::Ship() : Collider(8.0) {\n    m_Rotation = PI;\n    m_DX = 0.0;\n    m_DY = 1.0;\n    m_VX = 0.0;\n    m_VY = 0.0;\n    m_LastLaunchTime = current_time;\n}\n\nvoid Ship::RotateLeft() {\n    m_Rotation -= delta_time;\n\n    if( m_Rotation < 0.0 ) {\n        m_Rotation += TWO_PI;\n    }\n    m_DX = sin(m_Rotation);\n    m_DY = -cos(m_Rotation);\n}\n\nvoid Ship::RotateRight() {\n    m_Rotation += delta_time;\n\n    if( m_Rotation >= TWO_PI ) {\n        m_Rotation -= TWO_PI;\n    }\n    m_DX = sin(m_Rotation);\n    m_DY = -cos(m_Rotation);\n}\n\nvoid Ship::Accelerate() {\n    m_VX += m_DX * delta_time;\n    m_VY += m_DY * delta_time;\n}\n\nvoid Ship::Decelerate() {\n    m_VX -= (m_DX * delta_time) / 2.0;\n    m_VY -= (m_DY * delta_time) / 2.0;\n}\nvoid Ship::CapVelocity() {\n    double vel = sqrt( m_VX * m_VX + m_VY * m_VY );\n\n    if( vel > MAX_VELOCITY ) {\n        m_VX /= vel;\n        m_VY /= vel;\n\n        m_VX *= MAX_VELOCITY;\n        m_VY *= MAX_VELOCITY;\n    }\n}\nvoid Ship::Render() {\n    dest.x = (int)m_X;\n    dest.y = (int)m_Y;\n    dest.w = c_Width;\n    dest.h = c_Height;\n\n    double degrees = (m_Rotation / PI) * 180.0;\n\n    int return_code = SDL_RenderCopyEx( renderer, m_SpriteTexture,\n                                        NULL, &dest,\n                                        degrees, NULL, SDL_FLIP_NONE );\n\n    if( return_code != 0 ) {\n        printf(\"failed to render image: %s\\n\", IMG_GetError() );\n    }\n}\n```", "```cpp\n#include \"game.hpp\"\n\nEnemyShip::EnemyShip() {\n    m_X = 60.0;\n    m_Y = 50.0;\n    m_Rotation = PI;\n    m_DX = 0.0;\n    m_DY = 1.0;\n    m_VX = 0.0;\n    m_VY = 0.0;\n    m_LastLaunchTime = current_time;\n\n    SDL_Surface *temp_surface = IMG_Load( c_SpriteFile );\n\n    if( !temp_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return;\n    }\n    else {\n        printf(\"success creating enemy ship surface\\n\");\n    }\n    m_SpriteTexture = SDL_CreateTextureFromSurface( renderer, \n    temp_surface );\n\n    if( !m_SpriteTexture ) {\n        printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n        return;\n    }\n    else {\n        printf(\"success creating enemy ship texture\\n\");\n    }\n\n    SDL_FreeSurface( temp_surface );\n}\n\n```", "```cpp\nvoid EnemyShip::Move() {\n    AIStub();\n\n    if( m_AIState == TURN_LEFT ) {\n        RotateLeft();\n    }\n\n    if( m_AIState == TURN_RIGHT ) {\n        RotateRight();\n    }\n\n    if( m_AIState == ACCELERATE ) {\n        Accelerate();\n    }\n\n    if( m_AIState == DECELERATE ) {\n        Decelerate();\n    }\n\n    CapVelocity();\n    m_X += m_VX;\n\n    if( m_X > 320 ) {\n        m_X = -16;\n    }\n    else if( m_X < -16 ) {\n        m_X = 320;\n    }\n\n    m_Y += m_VY;\n\n    if( m_Y > 200 ) {\n        m_Y = -16;\n    }\n    else if( m_Y < -16 ) {\n        m_Y = 200;\n    }\n\n    if( m_AIState == SHOOT ) {\n        Projectile* projectile;\n\n        if( current_time - m_LastLaunchTime >= c_MinLaunchTime ) {\n            m_LastLaunchTime = current_time;\n            projectile = projectile_pool->GetFreeProjectile();\n\n            if( projectile != NULL ) {\n                projectile->Launch( m_X, m_Y, m_DX, m_DY );\n            }\n        }\n    }\n}\n\nvoid EnemyShip::AIStub() {\n    m_AIStateTTL -= diff_time;\n\n    if( m_AIStateTTL <= 0 ) {\n        // for now get a random AI state.\n        m_AIState = (FSM_STUB)(rand() % 5);\n        m_AIStateTTL = c_AIStateTime;\n    }\n}\n```", "```cpp\n#include \"game.hpp\"\nPlayerShip::PlayerShip() {\n    m_X = 160.0;\n    m_Y = 100.0;\n    SDL_Surface *temp_surface = IMG_Load( c_SpriteFile );\n\n    if( !temp_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return;\n    }\n\n    m_SpriteTexture = SDL_CreateTextureFromSurface( renderer, \n    temp_surface );\n\n    if( !m_SpriteTexture ) {\n        printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n        return;\n    }\n\n    SDL_FreeSurface( temp_surface );\n}\n\nvoid PlayerShip::Move() {\n    current_time = SDL_GetTicks();\n    diff_time = current_time - last_time;\n    delta_time = (double)diff_time / 1000.0;\n    last_time = current_time;\n\n    if( left_key_down ) {\n        RotateLeft();\n    }\n\n    if( right_key_down ) {\n        RotateRight();\n    }\n\n    if( up_key_down ) {\n        Accelerate();\n    }\n\n    if( down_key_down ) {\n        Decelerate();\n    }\n\n    CapVelocity();\n    m_X += m_VX;\n\n    if( m_X > 320 ) {\n        m_X = -16;\n    }\n    else if( m_X < -16 ) {\n        m_X = 320;\n    }\n\n    m_Y += m_VY;\n\n    if( m_Y > 200 ) {\n        m_Y = -16;\n    }\n    else if( m_Y < -16 ) {\n        m_Y = 200;\n    }\n\n    if( space_key_down ) {\n        Projectile* projectile;\n\n        if( current_time - m_LastLaunchTime >= c_MinLaunchTime ) {\n            m_LastLaunchTime = current_time;\n            projectile = projectile_pool->GetFreeProjectile();\n            if( projectile != NULL ) {\n                projectile->Launch( m_X, m_Y, m_DX, m_DY );\n            }\n        }\n    }\n}\n```", "```cpp\nvoid ProjectilePool::MoveProjectiles() {\n    Projectile* projectile;\n    std::vector<Projectile*>::iterator it;\n    for( it = m_ProjectileList.begin(); it != m_ProjectileList.end(); \n        it++ ) {\n        projectile = *it;\n        if( projectile->m_Active ) {\n            projectile->Move();\n            if( projectile->HitTest( player ) ) {\n                printf(\"hit player\\n\");\n            }\n            if( projectile->HitTest( enemy ) ) {\n                printf(\"hit enemy\\n\");\n            }\n        }\n    }\n}\n```", "```cpp\nvoid Projectile::Launch(double x, double y, double dx, double dy) {\n    m_X = x + dx * 9;\n    m_Y = y + dy * 9;\n    m_VX = velocity * dx;\n    m_VY = velocity * dy;\n    m_TTL = alive_time;\n    m_Active = true;\n}\n```", "```cpp\ncurrent_time = SDL_GetTicks();\ndiff_time = current_time - last_time;\ndelta_time = (double)diff_time / 1000.0;\nlast_time = current_time;\n```", "```cpp\nvoid game_loop() {\n    current_time = SDL_GetTicks();\n    diff_time = current_time - last_time;\n    delta_time = (double)diff_time / 1000.0;\n    last_time = current_time;\n    input();\n    move();\n    render();\n}\n```", "```cpp\nclass Projectile: public Collider {\n    public:\n        const char* c_SpriteFile = \"sprites/ProjectileExp.png\";\n        const int c_Width = 16;\n        const int c_Height = 16;\n        const double velocity = 6.0;\n        const double alive_time = 2000;\n        SDL_Texture *m_SpriteTexture;\n        SDL_Rect src = {.x = 0, .y = 0, .w = 16, .h = 16 };\n        Uint32 m_CurrentFrame = 0;\n        int m_NextFrameTime;\n        bool m_Active;\n\n        float m_TTL;\n        float m_VX;\n        float m_VY;\n\n        Projectile();\n        void Move();\n        void Render();\n        void Launch(float x, float y, float dx, float dy);\n};\n```", "```cpp\nvoid Projectile::Move() {\n    if( m_CurrentFrame > 0 ) {\n        m_NextFrameTime -= diff_time;\n        if( m_NextFrameTime <= 0 ) {\n            ++m_CurrentFrame;\n            m_NextFrameTime = ms_per_frame;\n            if( m_CurrentFrame >= 4 ) {\n                m_Active = false;\n                m_CurrentFrame = 0;\n                return;\n            }\n        }\n        return;\n    }\n    m_X += m_VX;\n    m_Y += m_VY;\n    m_TTL -= diff_time;\n    if( m_TTL < 0 ) {\n        m_Active = false;\n        m_TTL = 0;\n    }\n}\n```", "```cpp\nvoid Projectile::Render() {\n    dest.x = m_X + 8;\n    dest.y = m_Y + 8;\n    dest.w = c_Width;\n    dest.h = c_Height;\n    src.x = 16 * m_CurrentFrame;\n    int return_val = SDL_RenderCopy( renderer, m_SpriteTexture,\n                                    &src, &dest );\n    if( return_val != 0 ) {\n        printf(\"SDL_Init failed: %s\\n\", SDL_GetError());\n    }\n}\n```", "```cpp\nclass Ship: public Collider {\n    public:\n        Uint32 m_LastLaunchTime;\n        const int c_Width = 32;\n        const int c_Height = 32;\n\n        SDL_Texture *m_SpriteTexture;\n        SDL_Rect src = {.x = 0, .y = 0, .w = 32, .h = 32 };\n        bool m_Alive = true;\n        Uint32 m_CurrentFrame = 0;\n        int m_NextFrameTime;\n\n        float m_Rotation;\n        float m_DX;\n        float m_DY;\n        float m_VX;\n        float m_VY;\n\n        void RotateLeft();\n        void RotateRight();\n        void Accelerate();\n        void Decelerate();\n        void CapVelocity();\n\n        virtual void Move() = 0;\n        Ship();\n        void Render();\n};\n```", "```cpp\nvoid Ship::Render() {\n    if( m_Alive == false ) {\n        return;\n    }\n    dest.x = (int)m_X;\n    dest.y = (int)m_Y;\n    dest.w = c_Width;\n    dest.h = c_Height;\n\n    src.x = 32 * m_CurrentFrame;\n    float degrees = (m_Rotation / PI) * 180.0;\n    int return_code = SDL_RenderCopyEx( renderer, m_SpriteTexture,\n                                    &src, &dest,\n                                    degrees, NULL, SDL_FLIP_NONE );\n    if( return_code != 0 ) {\n        printf(\"failed to render image: %s\\n\", IMG_GetError() );\n    }\n}\n```", "```cpp\nclass PlayerShip: public Ship {\n    public:\n        const char* c_SpriteFile = \"sprites/FranchiseExp.png\";\n        const Uint32 c_MinLaunchTime = 300;\n        PlayerShip();\n        void Move();\n};\n\nclass EnemyShip: public Ship {\n    public:\n        const char* c_SpriteFile = \"sprites/BirdOfAngerExp.png\";\n        const Uint32 c_MinLaunchTime = 300;\n        const int c_AIStateTime = 2000;\n\n        FSM_STUB m_AIState;\n        int m_AIStateTTL;\n\n        EnemyShip();\n        void AIStub();\n        void Move();\n};\n```", "```cpp\nvoid EnemyShip::Move() {\n    if( m_Alive == false ) {\n        return;\n    }\n    AIStub();\n\n    if( m_AIState == TURN_LEFT ) {\n        RotateLeft();\n    }\n    if( m_AIState == TURN_RIGHT ) {\n        RotateRight();\n    }\n    if( m_AIState == ACCELERATE ) {\n        Accelerate();\n    }\n    if( m_AIState == DECELERATE ) {\n        Decelerate();\n    }\n\n    if( m_CurrentFrame > 0 ) {\n        m_NextFrameTime -= diff_time;\n\n        if( m_NextFrameTime <= 0 ) {\n            m_NextFrameTime = ms_per_frame;\n            if( ++m_CurrentFrame >= 8 ) {\n                m_Alive = false;\n                return;\n            }\n        }\n    }\n    CapVelocity();\n\n    m_X += m_VX;\n\n    if( m_X > 320 ) {\n        m_X = -16;\n    }\n    else if( m_X < -16 ) {\n        m_X = 320;\n    }\n\n    m_Y += m_VY;\n\n    if( m_Y > 200 ) {\n        m_Y = -16;\n    }\n    else if( m_Y < -16 ) {\n        m_Y = 200;\n    }\n\n    if( m_AIState == SHOOT ) {\n        Projectile* projectile;\n        if( current_time - m_LastLaunchTime >= c_MinLaunchTime ) {\n            m_LastLaunchTime = current_time;\n            projectile = projectile_pool->GetFreeProjectile();\n\n            if( projectile != NULL ) {\n                projectile->Launch( m_X, m_Y, m_DX, m_DY );\n            }\n        }\n    }\n}\n```", "```cpp\nif( m_Alive == false ) {\n    return;\n}\n```", "```cpp\nif( m_CurrentFrame > 0 ) {\n    m_NextFrameTime -= diff_time;\n    if( m_NextFrameTime <= 0 ) {\n        m_NextFrameTime = ms_per_frame;\n        if( ++m_CurrentFrame >= 8 ) {\n            m_Alive = false;\n            return;\n        }\n    }\n}\n```", "```cpp\nvoid PlayerShip::Move() {\n    if( m_Alive == false ) {\n        return;\n    }\n    if( left_key_down ) {\n        RotateLeft();\n    }\n    if( right_key_down ) {\n        RotateRight();\n    }\n    if( up_key_down ) {\n        Accelerate();\n    }\n    if( down_key_down ) {\n        Decelerate();\n    }\n    if( m_CurrentFrame > 0 ) {\n        m_NextFrameTime -= diff_time;\n        if( m_NextFrameTime <= 0 ) {\n            m_NextFrameTime = ms_per_frame;\n            if( ++m_CurrentFrame >= 8 ) {\n                m_Alive = false;\n                return;\n            }\n        }\n    }\n    CapVelocity();\n    m_X += m_VX;\n\n    if( m_X > 320 ) {\n        m_X = -16;\n    }\n    else if( m_X < -16 ) {\n        m_X = 320;\n    }\n\n    m_Y += m_VY;\n\n    if( m_Y > 200 ) {\n        m_Y = -16;\n    }\n    else if( m_Y < -16 ) {\n        m_Y = 200;\n    }\n\n    if( space_key_down ) {\n        Projectile* projectile;\n        if( current_time - m_LastLaunchTime >= c_MinLaunchTime ) {\n            m_LastLaunchTime = current_time;\n            projectile = projectile_pool->GetFreeProjectile();\n            if( projectile != NULL ) {\n                projectile->Launch( m_X, m_Y, m_DX, m_DY );\n            }\n        }\n    }\n}\n```", "```cpp\nif( m_Alive == false ) {\n    return;\n}\n```", "```cpp\nif( m_CurrentFrame > 0 ) {\n    m_NextFrameTime -= diff_time;\n    if( m_NextFrameTime <= 0 ) {\n        m_NextFrameTime = ms_per_frame;\n        if( ++m_CurrentFrame >= 8 ) {\n            m_Alive = false;\n            return;\n        }\n    }\n}\n```", "```cpp\nvoid ProjectilePool::MoveProjectiles() {\n    Projectile* projectile;\n    std::vector<Projectile*>::iterator it;\n    for( it = m_ProjectileList.begin(); it != m_ProjectileList.end(); it++ ) {\n        projectile = *it;\n        if( projectile->m_Active ) {\n            projectile->Move();\n            if( projectile->m_CurrentFrame == 0 &&\n                player->m_CurrentFrame == 0 &&\n                projectile->HitTest( player ) ) {\n\n                player->m_CurrentFrame = 1;\n                player->m_NextFrameTime = ms_per_frame;\n                projectile->m_CurrentFrame = 1;\n                projectile->m_NextFrameTime = ms_per_frame;\n            }\n            if( projectile->m_CurrentFrame == 0 &&\n                enemy->m_CurrentFrame == 0 &&\n                projectile->HitTest( enemy ) ) {\n\n                enemy->m_CurrentFrame = 1;\n                enemy->m_NextFrameTime = ms_per_frame;\n                projectile->m_CurrentFrame = 1;\n                projectile->m_NextFrameTime = ms_per_frame;\n            }\n        }\n    }\n}\n```", "```cpp\nint VAR1 = 1;\nint* POINTER = &VAR1;\n```", "```cpp\n*POINTER = 2;\n printf(\"VAR1=%d\\n\", VAR1); // prints out \"VAR1=2\"\n```", "```cpp\nclass Collider {\n    public:\n        float* m_ParentRotation;\n        float* m_ParentX;\n        float* m_ParentY;\n        float m_X;\n        float m_Y;\n        float m_Radius;\n\n        bool CCHitTest( Collider* collider );\n        void SetParentInformation( double* rotation, double* x, double* \n                                   y );\n        Collider(double radius);\n        bool HitTest( Collider *collider );\n};\n```", "```cpp\nCollider::Collider(double radius) {\n    m_ParentRotation = NULL;\n    m_ParentX = NULL;\n    m_ParentY = NULL;\n    m_Radius = radius;\n}\n```", "```cpp\nbool Collider::CCHitTest( Collider* collider ) {\n    float sine = sin(*m_ParentRotation);\n    float cosine = cos(*m_ParentRotation);\n    float rx = m_X * cosine - m_Y * sine;\n    float ry = m_X * sine + m_Y * cosine;\n    float dist_x = (*m_ParentX + rx) - collider->m_X;\n    float dist_y = (*m_ParentY + ry) - collider->m_Y;\n    float radius = m_Radius + collider->m_Radius;\n\n    if( dist_x * dist_x + dist_y * dist_y <= radius * radius ) {\n        return true;\n    }\n    return false;\n}\n```", "```cpp\nbool Collider::HitTest( Collider *collider ) {\n    if( m_ParentRotation != NULL && m_ParentX != NULL && m_ParentY !=         NULL ) {\n        return CCHitTest( collider );\n    }\n\n    float dist_x = m_X - collider->m_X;\n    float dist_y = m_Y - collider->m_Y;\n    float radius = m_Radius + collider->m_Radius;\n\n    if( dist_x * dist_x + dist_y * dist_y <= radius * radius ) {\n        return true;\n    }\n    return false;\n}\n```", "```cpp\nvoid Collider::SetParentInformation( float* rotation, float* x, float* y ) {\n    m_ParentRotation = rotation;\n    m_ParentX = x;\n    m_ParentY = y;\n}\n```", "```cpp\nclass Ship : public Collider {\n    public:\n        Uint32 m_LastLaunchTime;\n        const int c_Width = 32;\n        const int c_Height = 32;\n\n        SDL_Texture *m_SpriteTexture;\n        SDL_Rect src = {.x = 0, .y = 0, .w = 32, .h = 32 };\n        std::vector<Collider*> m_Colliders;\n        bool m_Alive = true;\n        Uint32 m_CurrentFrame = 0;\n\n        int m_NextFrameTime;\n        float m_Rotation;\n        float m_DX;\n        float m_DY;\n        float m_VX;\n        float m_VY;\n\n        void RotateLeft();\n        void RotateRight();\n        void Accelerate();\n        void Decelerate();\n        void CapVelocity();\n        virtual void Move() = 0;\n        Ship();\n        void Render();\n        bool CompoundHitTest( Collider* collider );\n};\n```", "```cpp\n std::vector<Collider*> m_Colliders;\n```", "```cpp\nbool CompoundHitTest( Collider* collider );\n```", "```cpp\nbool Ship::CompoundHitTest( Collider* collider ) {\n    Collider* col;\n    std::vector<Collider*>::iterator it;\n    for( it = m_Colliders.begin(); it != m_Colliders.end(); it++ ) {\n        col = *it;\n        if( col->HitTest(collider) ) {\n            return true;\n        }\n    }\n    return false;\n}\n```", "```cpp\nEnemyShip::EnemyShip() {\n    m_X = 60.0;\n    m_Y = 50.0;\n    m_Rotation = PI;\n    m_DX = 0.0;\n    m_DY = 1.0;\n    m_VX = 0.0;\n    m_VY = 0.0;\n    m_AIStateTTL = c_AIStateTime;\n    m_Alive = true;\n    m_LastLaunchTime = current_time;\n\n    Collider* temp_collider = new Collider(2.0);\n    temp_collider->SetParentInformation( &(this->m_Rotation),\n                                         &(this->m_X), &(this->m_Y) );\n    temp_collider->m_X = -6.0;\n    temp_collider->m_Y = -6.0;\n    m_Colliders.push_back( temp_collider );\n    temp_collider = new Collider(2.0);\n    temp_collider->SetParentInformation( &(this->m_Rotation),\n                                         &(this->m_X), &(this->m_Y) );\n    temp_collider->m_X = 6.0;\n    temp_collider->m_Y = -6.0;\n    m_Colliders.push_back( temp_collider );\n\n    SDL_Surface *temp_surface = IMG_Load( c_SpriteFile );\n\n    if( !temp_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return;\n    }\n    else {\n        printf(\"success creating enemy ship surface\\n\");\n    }\n    m_SpriteTexture = SDL_CreateTextureFromSurface( renderer, \n    temp_surface );\n    if( !m_SpriteTexture ) {\n        printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n        return;\n    }\n    else {\n        printf(\"success creating enemy ship texture\\n\");\n    }\n    SDL_FreeSurface( temp_surface );\n}\n```", "```cpp\nCollider* temp_collider = new Collider(2.0);\ntemp_collider->SetParentInformation( &(this->m_Rotation),\n                                     &(this->m_X), &(this->m_Y) );\ntemp_collider->m_X = -6.0;\ntemp_collider->m_Y = -6.0;\nm_Colliders.push_back( temp_collider );\ntemp_collider = new Collider(2.0);\ntemp_collider->SetParentInformation( &(this->m_Rotation),\n                                     &(this->m_X), &(this->m_Y) );\ntemp_collider->m_X = 6.0;\ntemp_collider->m_Y = -6.0;\nm_Colliders.push_back( temp_collider );\n```", "```cpp\nPlayerShip::PlayerShip() {\n    m_X = 160.0;\n    m_Y = 100.0;\n    SDL_Surface *temp_surface = IMG_Load( c_SpriteFile );\n\n    Collider* temp_collider = new Collider(3.0);\n    temp_collider->SetParentInformation( &(this->m_Rotation),\n                                         &(this->m_X), &(this->m_Y) );\n    temp_collider->m_X = -6.0;\n    temp_collider->m_Y = 6.0;\n    m_Colliders.push_back( temp_collider );\n    temp_collider = new Collider(3.0);\n    temp_collider->SetParentInformation( &(this->m_Rotation),\n                                         &(this->m_X), &(this->m_Y) );\n    temp_collider->m_X = 6.0;\n    temp_collider->m_Y = 6.0;\n    m_Colliders.push_back( temp_collider );\n\n    if( !temp_surface ) {\n        printf(\"failed to load image: %s\\n\", IMG_GetError() );\n        return;\n    }\n    m_SpriteTexture = SDL_CreateTextureFromSurface( renderer, \n    temp_surface );\n\n    if( !m_SpriteTexture ) {\n        printf(\"failed to create texture: %s\\n\", IMG_GetError() );\n        return;\n    }\n    SDL_FreeSurface( temp_surface );\n}\n```", "```cpp\nvoid ProjectilePool::MoveProjectiles() {\n    Projectile* projectile;\n    std::vector<Projectile*>::iterator it;\n\n    for( it = m_ProjectileList.begin(); it != m_ProjectileList.end(); \n         it++ ) {\n        projectile = *it;\n        if( projectile->m_Active ) {\n            projectile->Move();\n            if( projectile->m_CurrentFrame == 0 &&\n                player->m_CurrentFrame == 0 &&\n                ( projectile->HitTest( player ) ||\n                  player->CompoundHitTest( projectile ) ) ) {\n                player->m_CurrentFrame = 1;\n                player->m_NextFrameTime = ms_per_frame;\n                projectile->m_CurrentFrame = 1;\n                projectile->m_NextFrameTime = ms_per_frame;\n            }\n            if( projectile->m_CurrentFrame == 0 &&\n                enemy->m_CurrentFrame == 0 &&\n                ( projectile->HitTest( enemy ) ||\n                  enemy->CompoundHitTest( projectile ) ) ) {\n                enemy->m_CurrentFrame = 1;\n                enemy->m_NextFrameTime = ms_per_frame;\n                projectile->m_CurrentFrame = 1;\n                projectile->m_NextFrameTime = ms_per_frame;\n            }\n        }\n    }\n}\n```", "```cpp\nem++ main.cpp collider.cpp ship.cpp enemy_ship.cpp player_ship.cpp projectile.cpp projectile_pool.cpp -std=c++17 --preload-file sprites -s USE_WEBGL2=1 -s USE_SDL=2 -s USE_SDL_IMAGE=2 -s SDL2_IMAGE_FORMATS=[\"png\"] -o collider.html\n```"]