["```cpp\n#include <iostream>\n#include <limits>\n\nint main ()\n {\n    // integral types section\n    std::cout << \"char \" << int(std::numeric_limits<char>::min())\n              << \"-\" << int(std::numeric_limits<char>::max())\n              << \" size (Byte) =\" << sizeof (char) << std::endl;\n    std::cout << \"wchar_t \" << std::numeric_limits<wchar_t>::min()\n              << \"-\" <<  std::numeric_limits<wchar_t>::max()\n              << \" size (Byte) =\"\n              << sizeof (wchar_t) << std::endl;\n    std::cout << \"int \" << std::numeric_limits<int>::min() << \"-\"\n              << std::numeric_limits<int>::max() << \" size\n                  (Byte) =\"\n              << sizeof (int) << std::endl;\n    std::cout << \"bool \" << std::numeric_limits<bool>::min() << \"-\"\n              << std::numeric_limits<bool>::max() << \"\n                  size (Byte) =\"\n              << sizeof (bool) << std::endl;\n\n    // floating point types\n    std::cout << \"float \" << std::numeric_limits<float>::min() <<    \n                  \"-\"\n              << std::numeric_limits<float>::max() << \" size\n                  (Byte) =\"\n              << sizeof (float) << std::endl;\n    std::cout << \"double \" << std::numeric_limits<double>::min()\n                  << \"-\"\n              << std::numeric_limits<double>::max() << \" size\n                  (Byte) =\"\n              << sizeof (double) << std::endl;\n    return 0;\n }\n```", "```cpp\nroot@453eb8a8d60a:~# uname -a\n Linux 453eb8a8d60a 4.9.125-linuxkit #1 SMP Fri Sep 7 08:20:28 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n```", "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\nint main ()\n{\n    std::vector<int> v {1, 2, 3, 4, 5, 6};\n    for_each (begin(v), end(v), [](int x) {std::cout << x\n        << std::endl;});\n    return 0;\n}\n```", "```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\nint main ()\n{\n    std::vector<int> v {1, 2, 3, 4, 5, 6};\n    std::string prefix (\"0\");\n    for_each (begin(v), end(v), [&prefix](int x) {std::cout\n        << prefix << x << std::endl;});\n    return 0;\n}\n```", "```cpp\n[](int x) -> std::vector<int>{\n             if (x%2)\n                 return {1, 2};\n             else\n                 return {3, 4};\n });\n```", "```cpp\nstd::map<int, std::string> payslips;\n// ... \nfor (std::map<int, \n     std::string>::const_iterator iter = payslips.begin(); \n     iter !=payslips.end(); ++iter) \n{\n // ... \n}\n```", "```cpp\nstd::map<int, std::string> payslips;\n// ... \nfor (auto iter = payslips.begin(); iter !=payslips.end(); ++iter) \n{\n    // ... \n}\n```", "```cpp\nauto speed = 123;         // speed is an int\nauto height = calculate ();    // height will be of the\n                         // type returned by calculate()\n```", "```cpp\ndecltype(a) y = x + 1;  // deducing the type of a\ndecltype(str->x) y;     // deducing the type of str->x, where str is \n                        // a struct and x \n                        // an int element of that struct\n```", "```cpp\nauto fuelLevel {0, 1, 2, 3, 4, 5};\n```", "```cpp\nstd::atomic<int> speed (0);         // Other threads have access to the speed variable\nauto currentSpeed = speed.load();   // default memory order: memory_order_seq_cst\n```", "```cpp\n#include <iostream>\n#include <utility>\n#include <atomic>\nstruct MyArray { int z[50]; };\nstruct MyStr { int a, b; };\nint main()\n{\n     std::atomic<MyArray> myArray;\n     std::atomic<MyStr> myStr;\n     std::cout << std::boolalpha\n               << \"std::atomic<myArray> is lock free? \"\n               << std::atomic_is_lock_free(&myArray) << std::endl\n               << \"std::atomic<myStr> is lock free? \"\n               << std::atomic_is_lock_free(&myStr) << std::endl;\n}               \n```", "```cpp\nbool speedUp (int speed);\nbool speedUp (char* speed);\nint main()  \n{\n    bool ok = speedUp (NULL);\n}\n```", "```cpp\nbool speedUp (int speed);\nbool speedUp (char* speed);\nint main()  \n{\n    bool ok = speedUp (nullptr);\n}\n```", "```cpp\nint* p = nullptr;\n```", "```cpp\nif (x == nullptr) \n{\n    // ...\\\n}\n```", "```cpp\n#include <iostream>\n#include <memory>\nclass CruiseControl\n{\npublic:\n    CruiseControl()\n    {\n        std::cout << \"CruiseControl object created\" << std::endl;\n    };\n    ~CruiseControl()\n    {\n        std::cout << \"CruiseControl object destroyed\" << std::endl;\n    }\n    void increaseSpeedTo(int speed)\n    {\n        std::cout << \"Speed at \" << speed << std::endl;\n    };\n};\n```", "```cpp\nint main ()\n{\n    std::cout << \"unique_ptr test started\" << std::endl;\n    std::unique_ptr<CruiseControl> cruiseControl =\n    std::make_unique<CruiseControl>();\n    cruiseControl->increaseSpeedTo(12);\n    std::cout << \"unique_ptr test finished\" << std::endl;\n}\n```", "```cpp\nint main ()\n{\n    std::cout << \"unique_ptr test started\" << std::endl;\n    std::unique_ptr<CruiseControl[]> cruiseControl = \n        std::make_unique<CruiseControl[]>(3);\n    cruiseControl[1].increaseSpeedTo(12); \n    std::cout << \"unique_ptr test finished\" << std::endl;\n}\n```", "```cpp\n#include <iostream>\n #include <memory>\nclass CruiseControl\n{\npublic:\n    CruiseControl()\n    {\n        std::cout << \"CruiseControl object created\" << std::endl;\n    };\n    ~CruiseControl()\n    {\n        std::cout << \"CruiseControl object destroyed\" << std::endl;\n    }\n    void increaseSpeedTo(int speed)\n    {\n        std::cout << \"Speed at \" << speed << std::endl;\n    };\n};\n```", "```cpp\nint main ()\n{\n    std::cout << \"shared_ptr test started\" << std::endl;\n    std::shared_ptr<CruiseControl> cruiseControlMaster(nullptr);\n    {\n        std::shared_ptr<CruiseControl> cruiseControlSlave = \n           std::make_shared<CruiseControl>();\n        cruiseControlMaster = cruiseControlSlave;\n    }\n    std::cout << \"shared_ptr test finished\" << std::endl;\n}\n```", "```cpp\n#include <iostream>\n#include <vector>\nint main () \n{\n    std::vector<int> a = {1, 2, 3, 4, 5};\n    auto b = std::move(a);\n    std::cout << \"a: \" << a.size() << std::endl;\n    std::cout << \"b: \" << b.size() << std::endl;\n}\n```", "```cpp\n#include <iostream>\n#include <vector>\nvoid print (std::string &&s)\n{\n    std::cout << \"print (std::string &&s)\" << std::endl;\n    std::string str (std::move(s));\n    std::cout << \"universal reference ==> str = \" << str\n              << std::endl;\n    std::cout << \"universal reference ==> s = \" << s << std::endl;\n}\nvoid print (std::string &s)\n{\n    std::cout << \"print (std::string &s)\" << std::endl;\n}\nint main()\n{\n    std::string str (\"this is a string\");\n    print (str);\n    std::cout << \"==> str = \" << str << std::endl;\n    return 0;\n}\n```", "```cpp\n#include <iostream>\nvoid print (std::string &&s)\n{\n    std::cout << \"print (std::string &&s)\" << std::endl;\n    std::string str (std::move(s));\n    std::cout << \"universal reference ==> str = \" << str\n              << std::endl;\n    std::cout << \"universal reference ==> s = \" << s << std::endl;\n}\nvoid print (std::string &s)\n{\n    std::cout << \"print (std::string &s)\" << std::endl;\n}\nint main()\n{\n    print (\"this is a string\");\n    return 0;\n}\n```", "```cpp\n#include <iostream>\n#include <thread>\nvoid threadFunction1 ();\nint main()\n{\n    std::thread t1 {threadFunction1};\n    t1.join();\n    return 0;\n}\nvoid threadFunction1 ()\n{\n    std::cout << \"starting thread 1 ... \" << std::endl;\n    std::cout << \"end thread 1 ... \" << std::endl;\n}\n```", "```cpp\n#include <iostream>\n#include <thread>\n#include <vector>\n#include <algorithm>\nvoid threadFunction (std::vector<int> &speeds, int& res);\nint main()\n{\n    std::vector<int> speeds = {1, 2, 3, 4, 5};\n    int result = 0;\n    std::thread t1 (threadFunction, std::ref(speeds), \n                    std::ref(result));\n    t1.join();\n    std::cout << \"Result = \" << result << std::endl;\n    return 0;\n}\nvoid threadFunction (std::vector<int> &speeds, int& res)\n{\n    std::cout << \"starting thread 1 ... \" << std::endl;\n    for_each(begin(speeds), end(speeds), [](int speed) \n    {\n        std::cout << \"speed is \" << speed << std::endl;\n    });\n    res = 10;\n    std::cout << \"end thread 1 ... \" << std::endl;\n}\n```", "```cpp\nroot@b6e74d5cf049:/Chapter2# cat concurrency_03.cpp\n#include <iostream>\n#include <future>\nint asyncFunction ();\nint main()\n{\n    std::future<int> fut = std::async(asyncFunction);\n    std::cout << \"max = \" << fut.get() << std::endl;\n    return 0;\n}\nint asyncFunction()\n{\n    std::cout << \"starting asyncFunction ... \" << std::endl;\n    int max = 0;\n    for (int i = 0; i < 100000; ++i)\n    {\n        max += i;\n    }\n    std::cout << \" Finished asyncFunction ...\" << std::endl;\n    return max;\n}\n```", "```cpp\ng++ concurrency_03.cpp -lpthread\n```", "```cpp\n#include <iostream>\n#include <future>\nvoid asyncProducer(std::promise<int> &prom);\nvoid asyncConsumer(std::future<int> &fut);\nint main()\n{\n    std::promise<int> prom;\n    std::future<int> fut = prom.get_future();\n    std::async(asyncProducer, std::ref(prom));\n    std::async(asyncConsumer, std::ref(fut));\n    std::cout << \"Async Producer-Consumer ended!\" << std::endl;\n    return 0;\n}\nvoid asyncConsumer(std::future<int> &fut)\n{\n    std::cout << \"Got \" << fut.get() << \" from the producer ... \"\n        << std::endl;\n}\nvoid asyncProducer(std::promise<int> &prom)\n{\n    std::cout << \" sending 5 to the consumer ... \" << std::endl;\n    prom.set_value (5);\n}\n```", "```cpp\nstruct threadFunction \n{\n    int speed;\n    void operator ()();\n}\nstd::thread t(threadFunction);\n```", "```cpp\n#include <iostream>\n#include <filesystem>\nint main()\n{\n    for(auto& p: std::filesystem::directory_iterator(\"/\"))\n    std::cout << p << std::endl;\n}\n```", "```cpp\n#include <iostream>\n#include <filesystem>\n#include <fstream>\nint main()\n{\n    std::filesystem::create_directories(\"test/src/config\");\n    std::ofstream(\"test/src/file.txt\") << \"This is an example!\"\n                                       << std::endl;\n}\n```", "```cpp\n#include <algorithm>\n#include <concepts>\n\nnamespace sp\n{\n    template<typename T>\n        requires Sortable<T>\n    void sort(T& container)\n    {\n        std::sort (begin(container), end(container));\n    };\n}\n```", "```cpp\nint main()\n{\n    std::vector<int> myVec {2,1,4,3};\n    sp::sort(vec);\n\n    return 0;\n}\n```", "```cpp\ntemplate<typename T>\nvoid sort(T& container) requires Sortable<T>;\n```", "```cpp\ntemplate<Sortable T>\nvoid sort(T& container)\n```", "```cpp\ntemplate<typename T>\n requires Sortable<T> && Integral<T>\nvoid sort(T& container)\n{\n    std::sort (begin(container), end(container));\n}; \n```", "```cpp\ntemplate <typename T>\nconcept bool SignedSwappable() \n{\n    return SignedIntegral<T>() && Swappable<T>();\n}\n\n```", "```cpp\ntemplate<typename T>\n requires SignedSwappable<T>\nvoid sort(T& container)\n{\n    std::sort (begin(container), end(container));\n}; \n```", "```cpp\n#include <iostream>\n#include <vector>\n#include <array>\n#include <span>\n\nvoid print(std::span<int> container)\n{\n    for(const auto &c : container) \n        std::cout << c << \"-\";\n}\n```", "```cpp\nint main()\n{\n    int elems[]{4, 2, 43, 12};\n    print(elems);\n\n    std::vector vElems{4, 2, 43, 12};\n    print(vElems);\n}\n```", "```cpp\ntemplate <typename T>\nvoid print(std::span<T> container)\n{\n    for(const auto &c : container) \n        std::cout << c << \"-\";\n}\n```", "```cpp\ntemplate <typename T>\n    requires Integral<T>\nvoid print(std::span<T> container)\n{\n    for(const auto &c : container) \n        std::cout << c << \"-\";\n}\n```", "```cpp\n#include <vector>\n#include <iostream>\n#include <ranges>\n\nint main()\n{\n    auto temperatures{28, 25, -8, -3, 15, 21, -1};\n    auto minus = [](int i){ return i <= 0; };\n    auto toFahrenheit = [](int i) { return (i*(9/5)) + 32; };\n    for (int t : temperatures | std::views::filter(minus) \n                              | std::views::transform(toFahrenheit)) \n        std::cout << t << ' ';  // 82.4 77 59 69.8\n}\n```", "```cpp\ntemplate<ranges::input_range V,                  std::indirect_unary_predicate<ranges::iterator_t<V>> Pred >\n    requires ranges::view<V> && std::is_object_v<Pred>\nclass filter_view : public ranges::view_interface<filter_view<V, Pred>>\n```", "```cpp\nexport module temperature_engine;\nimport std.core\n#include <ranges>\n\nexport \nstd::vector<int> toFahrenheitFromCelsius(std::vector<int>& celsius)\n{\n    std::vector<int> fahrenheit;\n    auto toFahrenheit = [](int i) { return (i*(9/5)) + 32; };\n    for (int t : celsius | std::views::transform(toFahrenheit)) \n        fahrenheit.push_back(t);\n\n    return fahrenheit;\n}\n```", "```cpp\nimport temperature_engine;\nimport std.core;  // instead of iostream, containers \n                  // (vector, etc) and algorithm\nint main()\n{ \n    auto celsius = {28, 25, -8, -3, 15, 21, -1};\n    auto fahrenheit = toFahrenheitFromCelsius(celsius);\n    std::for_each(begin(fahrenheit), end(fahrenheit),\n        [&fahrenheit](int i)\n    {\n        std::cout << i << \";\";\n    });\n}\n```", "```cpp\nexport module temperature_engine;\nimport std.core\n#include <ranges>\n\nexport struct ConversionFactors;  //exported as incomplete type\n\nexport \nvoid myMethod(ConversionFactors& factors)\n{\n    // ...\n}\n\nmodule: private;\nstruct ConversionFactors\n{\n    int toFahrenheit;\n    int toCelsius;\n};\n```"]