- en: '*Chapter 10*: Mesh Skinning'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：网格皮肤'
- en: 'Deforming a mesh to match an animated pose is called skinning. In order to
    implement skinning, you first need to declare a mesh class. Once you have declared
    a mesh class, it can be deformed using a shader (GPU skinning) or just with C++
    code (CPU skinning). Both of these skinning methods are covered in this chapter.
    By the end of this chapter, you should be able to do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 将网格变形以匹配动画姿势称为皮肤。为了实现皮肤，首先需要声明一个网格类。一旦声明了网格类，就可以使用着色器（GPU皮肤）或仅使用C++代码（CPU皮肤）对其进行变形。本章涵盖了这两种皮肤方法。在本章结束时，您应该能够做到以下事情：
- en: Understand how a skinned mesh is different from a non-skinned mesh
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解有皮肤的网格与无皮肤的网格有何不同
- en: Understand the entire skinning pipeline
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解整个皮肤管道
- en: Implement a skeleton class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现骨架类
- en: Load the bind pose of a skeleton from a glTF file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从glTF文件加载骨架的绑定姿势
- en: Implement a skinned mesh class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个有皮肤的网格类
- en: Load skinned meshes from a gLTF file
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从glTF文件加载有皮肤的网格
- en: Implement CPU skinning
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现CPU皮肤
- en: Implement GPU skinning
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现GPU皮肤
- en: Exploring meshes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索网格
- en: 'A mesh is made up of several vertices. Normally, each vertex has at least a
    position, a normal, and maybe a texture coordinate. This is the definition of
    a vertex for a simple static mesh. This definition has the following vertex components:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网格由多个顶点组成。通常，每个顶点至少有一个位置、一个法线，也许还有一个纹理坐标。这是一个简单静态网格的顶点定义。这个定义有以下顶点组件：
- en: The position (`vec3`)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置（`vec3`）
- en: The normal (`vec3`)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 法线（`vec3`）
- en: The texture coordinate (`vec2`)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理坐标（`vec2`）
- en: 'Important information:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息：
- en: The model used to demonstrate skinning in this chapter is the Godot mannequin
    from GDQuest. It's an MIT-licensed model and you can find it on GitHub a[t https://github.com/GDQuest/godot-3d-mannequ](https://github.com/GDQuest/godot-3d-mannequin)in.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中用于演示皮肤的模型是来自GDQuest的Godot模特。这是一个MIT许可的模型，您可以在GitHub上找到它[a t https://github.com/GDQuest/godot-3d-mannequ](https://github.com/GDQuest/godot-3d-mannequin)in。
- en: 'When a mesh is modeled, it''s modeled in a certain pose. For characters, this
    is often a *T* pose or an *A* pose. The modeled mesh is static. The following
    figure shows the *T* pose for the Godot mannequin:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个网格被建模时，它是在特定的姿势中建模的。对于角色来说，这通常是*T*形或*A*形。建模的网格是静态的。下图显示了Godot模特的*T*形姿势：
- en: '![Figure 10.1: The Godot mannequin''s T pose'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1：Godot模特的T形姿势'
- en: '](img/Figure_10.1_B16191.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.1_B16191.jpg)'
- en: 'Figure 10.1: The Godot mannequin''s T pose'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：Godot模特的T形姿势
- en: Once a mesh is modeled, a skeleton is created in the mesh. Each vertex in the
    mesh is assigned to one or more bones of the skeleton. This process is called
    rigging. The skeleton is created in a pose that fits inside the mesh; this is
    the **bind pose** of the model.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个网格被建模时，骨架被创建在网格中。网格中的每个顶点都分配给骨架的一个或多个骨骼。这个过程称为装配。骨架是在适合网格内的姿势中创建的；这是模型的**绑定姿势**。
- en: '![Figure 10.2: Visualizing the bind pose of the mesh and skeleton'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2：可视化网格和骨架的绑定姿势'
- en: '](img/Figure_10.2_B16191.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.2_B16191.jpg)'
- en: 'Figure 10.2: Visualizing the bind pose of the mesh and skeleton'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：可视化网格和骨架的绑定姿势
- en: The bind pose and the rest pose are usually the same, but that is not always
    the case. In this book, we will treat the two as separate poses. The preceding
    figure shows the bind pose of the skeleton rendered on top of the character mesh.
    In the next section, you will explore how a mesh such as this can be skinned.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定姿势和静止姿势通常是相同的，但并非总是如此。在本书中，我们将把这两者视为不同的姿势。前面的图显示了骨架的绑定姿势渲染在角色网格的顶部。在下一节中，您将探索如何对这样的网格进行皮肤处理。
- en: Understanding skinning
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解皮肤
- en: Skinning is the process of specifying which vertex should be deformed by which
    bone. One vertex can be influenced by multiple bones. Rigid skinning refers to
    associating each vertex with exactly one bone. Smooth skinning associates vertices
    with multiple bones.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 皮肤是指定哪个顶点应该由哪个骨骼变形的过程。一个顶点可以受到多个骨骼的影响。刚性皮肤是指将每个顶点与一个骨骼关联。平滑皮肤将顶点与多个骨骼关联。
- en: Typically, the vertex-to-bone mapping is done per vertex. This means each vertex
    knows which bones it belongs to. Some file formats, store this relationship in
    reverse, where each bone contains a list of vertices it affects. Both approaches
    are valid; throughout the rest of this book, the mapping is done per vertex.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，顶点到骨骼的映射是按顶点进行的。这意味着每个顶点都知道它属于哪些骨骼。一些文件格式以相反的方式存储这种关系，其中每个骨骼包含它影响的顶点列表。这两种方法都是有效的；在本书的其余部分，映射是按顶点进行的。
- en: 'To (rigid) skin a mesh, assign each vertex to a bone. To assign a joint to
    a vertex in code, add a new attribute to each vertex. This attribute is just an
    integer that holds the index of the bone that deforms the vertex. In the following
    figure, all the triangles that should be assigned to the lower-left arm bone are
    colored darker than the rest of the mesh:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了（刚性）皮肤一个网格，将每个顶点分配给一个骨骼。要在代码中为顶点分配关节，需要为每个顶点添加一个新属性。这个属性只是一个保存着变形顶点的骨骼索引的整数。在下图中，所有应该分配给左下臂骨骼的三角形都比网格的其余部分颜色更深：
- en: '![Figure 10.3: Isolating the lower arm'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3：隔离下臂'
- en: '](img/Figure_10.3_B16191.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.3_B16191.jpg)'
- en: 'Figure 10.3: Isolating the lower arm'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：隔离下臂
- en: 'Let''s take a second to review the vertex transformation pipeline in a little
    more detail. Here, the concept of **space** is introduced. Space refers to transforming
    a vertex by a matrix. For example, if you have a projection matrix, it would transform
    a vertex into NDC space. The vertex transformation pipeline is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间更详细地审查一下顶点变换管道。在这里，引入了**空间**的概念。空间指的是通过矩阵对顶点进行变换。例如，如果有一个投影矩阵，它会将一个顶点变换为NDC空间。顶点变换管道如下：
- en: When a mesh is created, all its vertices are in what is called model space.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个网格被创建时，它的所有顶点都处于所谓的模型空间中。
- en: A model space vertex is multiplied by the model matrix, which puts it into world
    space.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型空间顶点乘以模型矩阵，将其放入世界空间中。
- en: A world space vertex is multiplied by the view matrix to put it into camera
    space.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 世界空间顶点乘以视图矩阵，将其放入相机空间。
- en: A camera space vertex is multiplied by the projection matrix to move it into
    NDC space.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相机空间顶点乘以投影矩阵，将其移动到NDC空间。
- en: To skin a mesh, a new skinning step needs to be added to the vertex transformation
    pipeline. The skinning step moves the vertex from skin space to model space. This
    means the new step comes before any other steps in the transformation pipeline.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要对网格进行蒙皮，需要在顶点变换流程中添加一个新的蒙皮步骤。蒙皮步骤将顶点从皮肤空间移动到模型空间。这意味着新步骤在变换流程中位于任何其他步骤之前。
- en: 'Skin space vertices can be moved back into model space if they are multiplied
    by the current animation pose. This transformation is covered in detail in the
    *Implementing CPU skinning* section of this chapter. Once the vertex is back in
    model space, it should already be animated. The animation pose matrix transformation
    does the actual animation. An animated vertex transformation pipeline works like
    this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将皮肤空间顶点乘以当前动画姿势，则可以将其移回模型空间。这个转换在本章的*实现CPU蒙皮*部分中有详细介绍。一旦顶点回到模型空间，它应该已经被动画化。动画姿势矩阵转换实际上进行了动画。动画化顶点转换流程如下：
- en: A mesh is loaded—all of its vertices are in model space.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载一个网格，所有顶点都在模型空间中。
- en: A model space vertex is multiplied by the skin matrix to move it into skin space.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型空间顶点乘以皮肤矩阵，将其移动到皮肤空间。
- en: A kin space vertex is multiplied by the pose matrix to move it back into model
    space.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 皮肤空间顶点乘以姿势矩阵，将其移回模型空间。
- en: A model space vertex is multiplied by the model matrix, which puts it into world
    space.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型空间顶点乘以模型矩阵，将其放入世界空间。
- en: A world space vertex is multiplied by the view matrix to put it into camera
    space.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 世界空间顶点乘以视图矩阵，将其放入相机空间。
- en: A camera space vertex is multiplied by the projection matrix to move it into
    NDC space.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相机空间顶点乘以投影矩阵，将其移动到NDC空间。
- en: To skin a mesh, each vertex needs to be transformed into skin space. When a
    vertex in skin space is transformed by the world transform of the joint it belongs
    to, the vertex should end up in model space, assuming the pose that is used is
    the bind pose.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要对网格进行蒙皮，需要将每个顶点转换为皮肤空间。当皮肤空间中的顶点通过其所属关节的世界变换进行变换时，假设使用的姿势是绑定姿势，顶点应该最终位于模型空间中。
- en: In the following section, you will explore the skinning pipeline with practical
    examples.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，您将通过实际示例探索蒙皮流程。
- en: Exploring rigid skinning
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索刚性蒙皮
- en: To skin a mesh, each vertex needs to be multiplied by the inverse bind pose
    transform of the joint it belongs to. To find the inverse bind pose transform
    of a joint, find the world transform of the joint, then invert it. When a matrix
    (or transform) is multiplied by its inverse, the result is always identity.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要对网格进行蒙皮，需要将每个顶点乘以其所属关节的逆绑定姿势变换。要找到关节的逆绑定姿势变换，需要找到关节的世界变换，然后对其求逆。当矩阵（或变换）乘以其逆时，结果总是单位矩阵。
- en: Multiplying the vertices of a skin space mesh by the world space transformation
    of a joint in bind pose undoes the original inverse bind pose multiplication,
    `inverse bind pose * bind pose = identity`. However, multiplying by a different
    pose results in the vertices being offset from the bind pose by the delta between
    the two poses.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将皮肤空间网格的顶点乘以绑定姿势中关节的世界空间变换可以撤消原始的逆绑定姿势乘法，`逆绑定姿势 * 绑定姿势 = 单位矩阵`。然而，乘以不同的姿势会导致顶点相对于绑定姿势的偏移。
- en: 'Let''s explore how a vertex is moved into skin space visually. For example,
    multiplying all the vertices in the Godot mannequin forearm by the inverse bind
    pose of the forearm bone puts only the forearm triangles into skin space. This
    leaves the mesh looking as it does in the following figure:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看顶点如何在皮肤空间中移动。例如，将Godot模特前臂中的所有顶点乘以前臂骨骼的逆绑定姿势，只将前臂三角形放入皮肤空间。这使得网格看起来如下图所示：
- en: '![Figure 10.4: The lower-arm mesh transformed by the inverse bind pose'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4：逆绑定姿势转换的下臂网格'
- en: '](img/Figure_10.4_B16191.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.4_B16191.jpg)'
- en: 'Figure 10.4: The lower-arm mesh transformed by the inverse bind pose'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：逆绑定姿势转换的下臂网格
- en: 'To transform the vertices from skin space back to model space, apply the transformation
    of each bone in the pose sequentially until the target bone is reached. The following
    figure demonstrates the six steps that need to be taken from the root bone to
    the forearm bone:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要将顶点从皮肤空间转换回模型空间，需要依次应用姿势中每个骨骼的变换，直到达到目标骨骼。下图演示了从根骨骼到前臂骨骼需要进行的六个步骤：
- en: '![Figure 10.5: Visualizing the transform chain to the lower arm'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5：可视化到下臂的变换链'
- en: '](img/Figure_10.5_B16191.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.5_B16191.jpg)'
- en: 'Figure 10.5: Visualizing the transform chain to the lower arm'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：可视化到下臂的变换链
- en: In code, all the transforms that need to be taken to reach a bone can be accumulated
    using matrix multiplication. Alternatively, if you use the `Transform` structs,
    you can use the combine method. Moving the vertex back into model space is done
    only once with the accumulated matrix or transform.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，可以使用矩阵乘法累积需要进行的所有变换。或者，如果使用`Transform`结构，可以使用combine方法。将顶点移回模型空间只需使用累积的矩阵或变换一次。
- en: Transforming the mesh into skin space is done by multiplying each vertex by
    the inverse bind pose of the joint it belongs to. How can you get the inverse
    bind pose matrix of a bone? Using the bind pose, find the world transform of the
    bone, turn it into a matrix, and invert the matrix.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将每个顶点乘以其所属关节的逆绑定姿势来将网格转换为皮肤空间。如何获得骨骼的逆绑定姿势矩阵？使用绑定姿势，找到骨骼的世界变换，将其转换为矩阵，然后求逆矩阵。
- en: 'The following figure shows the Godot mannequin in skin space. Seeing a mesh
    such as this indicates an error in the skinning pipeline. The most common reason
    for seeing a mesh such as this is that there has been an error in the multiplication
    order of the inverse bind pose and animated pose:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了Godot模型在皮肤空间中的情况。看到这样的网格表明了蒙皮管道中的错误。出现这种网格的最常见原因是逆绑定姿势和动画姿势的乘法顺序出现错误：
- en: '![Figure 10.6: The full mesh multiplied by the inverse bind pose'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6：整个网格乘以逆绑定姿势'
- en: '](img/Figure_10.6_B16191.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.6_B16191.jpg)'
- en: 'Figure 10.6: The full mesh multiplied by the inverse bind pose'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：整个网格乘以逆绑定姿势
- en: The skinning implementation discussed so far is called rigid skinning. With
    rigid skinning, each vertex is influenced by only one bone. In the following section,
    you will begin to explore smooth skinning, which makes skinned meshes look better
    by assigning multiple bone influences to a single vertex.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的蒙皮实现称为刚性蒙皮。使用刚性蒙皮时，每个顶点只受一个骨骼的影响。在接下来的部分中，您将开始探索平滑蒙皮，通过将多个骨骼的影响分配给单个顶点来使蒙皮网格看起来更好。
- en: The rigid skinning pipeline
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚性蒙皮管道
- en: 'Let''s explore the pipeline that each vertex must go through. The following
    figure shows the transformation pipeline of a static mesh compared to a rigid
    skinned mesh. The order of steps in the following diagram is left to right, following
    the arrows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索每个顶点必须经历的管道。下图显示了静态网格与刚性蒙皮网格的变换管道。以下图中的步骤顺序从左到右，沿着箭头进行：
- en: '![Figure 10.7: The vertex skinning pipelines'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7：顶点蒙皮管道'
- en: '](img/Figure_10.7_B16191.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.7_B16191.jpg)'
- en: 'Figure 10.7: The vertex skinning pipelines'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：顶点蒙皮管道
- en: 'The **rigid skinned vertex pipeline** shown in the preceding figure works as
    follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中显示的**刚性蒙皮顶点管道**的工作方式如下：
- en: Move the vertex into skin space by multiplying it by the inverse bind pose matrix
    of the joint it is assigned to.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将顶点乘以其所分配的关节的逆绑定姿势矩阵将其移动到皮肤空间中。
- en: Multiply the skinned vertex by the animated joint's world matrix. This results
    in the vertex being in local space again, but it is deformed to the animated pose.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将蒙皮顶点乘以动画关节的世界矩阵。这将导致顶点再次处于本地空间，但它会被变形到动画姿势。
- en: Once the vertex is in the animated local position, put it through the normal
    model view projection transformation.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦顶点处于动画本地位置，就将其通过正常的模型视图投影变换。
- en: Exploring smooth skinning
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索平滑蒙皮
- en: The problem with rigid skinning is bending joints. Since each vertex belongs
    to one bone, vertices that are in joints such as the elbow do not bend naturally.
    Breaks in a mesh at joints such as in the elbow can be avoided by assigning different
    vertices of a triangle to different bones. The resulting mesh doesn't maintain
    its volume well and looks awkward.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 刚性蒙皮的问题在于弯曲关节。由于每个顶点属于一个骨骼，因此在肘部等关节处的顶点不会自然弯曲。在肘部等关节处的网格断裂可以通过将三角形的不同顶点分配给不同的骨骼来避免。由此产生的网格无法很好地保持其体积，并且看起来很尴尬。
- en: Rigid skinning isn't free; it introduces additional matrix multiplications to
    each vertex. This can be optimized down to just one additional multiplication,
    which is covered in the next chapter. In the following section, you will explore
    smooth skinning.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 刚性蒙皮并不是免费的；它为每个顶点引入了额外的矩阵乘法。这可以优化为只有一个额外的乘法，这将在下一章中介绍。在接下来的部分中，您将探索平滑蒙皮。
- en: Exploring smooth skinning
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索平滑蒙皮
- en: 'The primary problem with rigid skinning is that it can create visual breaks
    in a mesh, as shown in the following figure. Even if these artifacts are addressed,
    deformation around bendable joints does not look good when smooth-skinned:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 刚性蒙皮的主要问题是它可能在网格中产生视觉断裂，如下图所示。即使这些伪影得到了解决，平滑蒙皮时可弯曲关节周围的变形看起来也不好：
- en: '![Figure 10.8: A visible artifact of rigid skinning'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8：刚性蒙皮的可见伪影'
- en: '](img/Figure_10.8_B16191.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.8_B16191.jpg)'
- en: 'Figure 10.8: A visible artifact of rigid skinning'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：刚性蒙皮的可见伪影
- en: Smooth skinning has fewer artifacts and maintains its volume better than rigid
    skinning. The idea behind smooth skinning is that more than one bone can influence
    a vertex. Each influence also has a weight. The weight is used to blend the skinned
    vertices into a combined, final vertex. All weights must add up to 1.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 平滑蒙皮比刚性蒙皮具有更少的伪影，并且能更好地保持其体积。平滑蒙皮的理念是一个顶点可以受到多个骨骼的影响。每个影响还有一个权重。权重用于将蒙皮顶点混合成一个组合的最终顶点。所有权重必须加起来等于1。
- en: Think of smooth skinning as skinning a mesh multiple times and blending the
    results. How many influences a bone can have has a big impact here. Generally,
    after four bones, the influence of each additional bone is not visible. This is
    convenient as it lets you use the `ivec4` and `vec4` structs to add influences
    and weights to vertices.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将顶点视为在网格上进行多次蒙皮并混合结果。一个骨骼可以有多少影响在这里有很大的影响。一般来说，超过四根骨骼后，每根额外的骨骼的影响就不可见了。这很方便，因为它可以让您使用`ivec4`和`vec4`结构向顶点添加影响和权重。
- en: 'The following figure shows a mesh that is skinned with the middle vertices
    attached to the top bone on the left and the bottom bone on the right. These are
    the two skinned positions that need to be blended. If each pose has a weight of
    `0.5`, the final interpolated vertex position will be halfway between the vertices.
    This is shown in the middle diagram of the following figure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个网格，其中中间顶点附在左侧的顶部骨骼和右侧的底部骨骼上。这是需要混合的两个蒙皮位置。如果每个姿势的权重为`0.5`，最终插值顶点位置将在两个顶点之间。这在下图的中间图中显示：
- en: '![Figure 10.9: Assigning multiple joints to a vertex'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9：将多个关节分配给一个顶点'
- en: '](img/Figure_10.9_B16191.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.9_B16191.jpg)'
- en: 'Figure 10.9: Assigning multiple joints to a vertex'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：将多个关节分配给一个顶点
- en: Averaging joint influences on a vertex is called smooth skinning, or **linear
    blend skinning** (**LBS**). It has a few artifacts, but it's the standard way
    to skin characters. Currently, LBS is the most popular way to implement skinned
    animations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点上平均关节影响被称为平滑蒙皮，或线性混合蒙皮（LBS）。它有一些缺陷，但这是皮肤角色的标准方式。目前，LBS是实现蒙皮动画最流行的方式。
- en: 'After adding support for smooth skinning, the final vertex structure now looks
    like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加对平滑蒙皮的支持后，最终的顶点结构现在如下所示：
- en: The position (`vec3`)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置（`vec3`）
- en: The normal (`vec3`)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 法线（`vec3`）
- en: The texture coordinate (`vec2`)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理坐标（`vec2`）
- en: The joint influences (`ivec4`)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关节影响（`ivec4`）
- en: The influence weights (`vec4`)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响权重（`vec4`）
- en: Important information
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: glTF supports attaching skinned meshes to arbitrary nodes and those nodes can
    be animated. This adds an extra step to calculating the skin matrix. To avoid
    this extra step, we will ignore the mesh pivot and assume that all the mesh node
    global transforms are at the origin. This is a safe assumption to make so long
    as a single glTF file is assumed to only contain one skinned mesh.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: glTF支持将蒙皮网格附加到任意节点，并且这些节点可以进行动画。这增加了计算蒙皮矩阵的额外步骤。为了避免这一额外步骤，我们将忽略网格中心点，并假设所有网格节点的全局变换都在原点。只要假定单个glTF文件只包含一个蒙皮网格，这就是一个安全的假设。
- en: Smooth skinning is currently the standard form used in game animation. Most
    games use four bones per vertex and work similarly to what you will implement
    in this chapter. In the following section, you will implement a `Skeleton` class
    to help keep track of some of the different data needed to skin a mesh.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 平滑蒙皮目前是游戏动画中使用的标准形式。大多数游戏每个顶点使用四个骨骼，并且与本章中将要实现的方式类似。在接下来的部分，你将实现一个`Skeleton`类来帮助跟踪皮肤网格所需的一些不同数据。
- en: Implementing skeletons
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现骨骼
- en: When animating a model, there are several things to keep track of, such as the
    animated pose or inverse bind pose. The concept of a skeleton is to combine data
    that is shared between animated models into a single structure.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在对模型进行动画时，有几件事情需要跟踪，比如动画姿势或逆绑定姿势。骨骼的概念是将在动画模型之间共享的数据组合成一个单一的结构。
- en: Both the bind pose and inverse bind pose are shared among all instances of a
    character. That is, if there are 15 characters on screen, each of them has a unique
    animated pose, but they all share the same rest pose, bind pose, inverse bind
    pose, and joint names.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 角色的绑定姿势和逆绑定姿势在所有角色实例之间共享。也就是说，如果屏幕上有15个角色，它们每个都有一个独特的动画姿势，但它们都共享相同的静止姿势、绑定姿势、逆绑定姿势和关节名称。
- en: In the following sections, you will implement a new class—the `Skeleton` class.
    This `Skeleton` class contains all the shared data that two animated meshes might
    need. It also keeps track of the rest pose, bind pose, inverse bind pose, and
    joint names. Some engines call the skeleton an armature or a rig.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，你将实现一个新的类——`Skeleton`类。这个`Skeleton`类包含两个动画网格可能需要的所有共享数据。它还跟踪静止姿势、绑定姿势、逆绑定姿势和关节名称。一些引擎将骨骼称为骨架或绑定。
- en: The Skeleton class declaration
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 骨骼类声明
- en: 'The `Skeleton` class contains the rest pose and bind pose of a character, the
    name for every joint of the character, and—most importantly—the inverse bind pose.
    Since the inverse bind pose involves inverting matrices, it should only be calculated
    once. Follow these steps to declare the new `Skeleton` class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Skeleton`类包含角色的静止姿势和绑定姿势，角色的每个关节的名称，以及最重要的逆绑定姿势。由于逆绑定姿势涉及矩阵求逆，因此应该只计算一次。按照以下步骤声明新的`Skeleton`类：'
- en: 'Create a new file, `Skeleton.h`. Declare the `Skeleton` class in this file.
    Add a rest pose, a bind pose, the inverse bind pose, and the joint names for the
    current animated model to the `Skeleton` class. The inverse bind pose should be
    implemented as a vector of matrices:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`Skeleton.h`。在这个文件中声明`Skeleton`类。在`Skeleton`类中添加当前动画模型的静止姿势、绑定姿势、逆绑定姿势和关节名称。逆绑定姿势应该实现为一个矩阵的向量：
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add a helper function, `UpdateInverseBindPose`. This function updates the inverse
    bind pose matrix any time that the bind pose is set:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个辅助函数`UpdateInverseBindPose`。这个函数在设置绑定姿势时更新逆绑定姿势矩阵：
- en: '[PRE1]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Declare a default constructor and a convenience constructor. Also, declare
    methods to set the rest pose, bind pose, and joint names of the skeleton and helper
    functions to retrieve references to all the variables of the skeleton:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个默认构造函数和一个便利构造函数。还要声明方法来设置骨骼的静止姿势、绑定姿势和关节名称，以及辅助函数来检索骨骼的所有变量的引用：
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Think of the `Skeleton` class as a helper class—it puts the bind pose, inverse
    bind pose, rest pose, and joint names into an easy-to-manage object. The skeleton
    is shared; you can have many characters, each with a unique animated pose, but
    they can all share the same skeleton. In the following section, you will implement
    the `Skeleton` class.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Skeleton`类视为一个辅助类——它将绑定姿势、逆绑定姿势、静止姿势和关节名称放入一个易于管理的对象中。骨骼是共享的；你可以有许多角色，每个角色都有一个独特的动画姿势，但它们都可以共享相同的骨骼。在接下来的部分，你将实现`Skeleton`类。
- en: The Skeleton class implementation
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 骨骼类的实现
- en: 'The inverse bind pose is stored in the skeleton as an array of matrices. Any
    time the bind pose of the skeleton is updated, the inverse bind pose should be
    re-calculated as well. To find the inverse bind pose, find the world space matrix
    of every joint in the skeleton, then invert the world space joint matrix. Create
    a new file, `Skeleton.cpp`. Then, implement the skeleton constructors. Take the
    following steps to do so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 逆绑定姿势存储在骨骼中作为矩阵数组。每当骨骼的绑定姿势更新时，逆绑定姿势也应该重新计算。要找到逆绑定姿势，找到骨骼中每个关节的世界空间矩阵，然后求逆世界空间关节矩阵。创建一个新文件`Skeleton.cpp`。然后，实现骨骼构造函数。采取以下步骤来实现：
- en: 'Create two constructors—the default constructor does not do anything. The other
    convenience constructor takes a rest pose, a bind pose, and the joint names. It
    calls the `Set` method:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个构造函数——默认构造函数不执行任何操作。另一个便利构造函数接受一个静止姿势、一个绑定姿势和关节名称。它调用`Set`方法：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create the `Set` method, which should set the internal pose, bind pose, and
    joint names of the skeleton. Once the bind pose is set, call the `UpdateInverseBindPose`
    function to populate the inverse bind pose matrix palette:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Set`方法，应该设置骨骼的内部姿势、绑定姿势和关节名称。一旦绑定姿势设置好，调用`UpdateInverseBindPose`函数来填充逆绑定姿势矩阵调色板：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Implement the `UpdateInverseBindPose` function next. Make sure that the matrix
    vector has the right size, then loop through all of the joints in the bind pose.
    Get the world space transform of each joint, convert it into a matrix, and invert
    the matrix. This inverted matrix is the inverse bind pose matrix for the joint:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来实现`UpdateInverseBindPose`函数。确保矩阵向量的大小正确，然后循环遍历绑定姿势中的所有关节。获取每个关节的世界空间变换，将其转换为矩阵，并对矩阵进行反转。这个反转的矩阵就是关节的逆绑定姿势矩阵：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implement the simple getter and setter functions in the `Skeleton` class:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Skeleton`类中实现简单的getter和setter函数：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is possible to get around returning references by providing explicit getter
    functions, such as `Transform GetBindPoseTransform(unsigned int index)`. This
    makes more sense to do after you have worked through the next chapter, where you
    learn how to optimize the animation data. For now, it's more valuable to have
    access to these references and not modify them.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供显式的getter函数来避免返回引用是可能的，比如`Transform GetBindPoseTransform(unsigned int index)`。在你学习如何优化动画数据的下一章之后再这样做更有意义。现在，能够访问这些引用并且不修改它们更有价值。
- en: To generate an inverse bind pose matrix, you don't have to convert the transform
    into a matrix and then invert it; you could invert the transform and then convert
    it into a matrix. The performance delta between the two is minimal.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 生成逆绑定姿势矩阵时，你不必将变换转换为矩阵然后再反转它；你可以反转变换然后将其转换为矩阵。两者之间的性能差异是微不足道的。
- en: The `Skeleton` class keeps track of the bind pose, inverse bind pose, and joint
    names of an animated model. This data can be shared between all the animated instances
    of a model. In the next section, you will implement bind pose loading from glTF
    files. The glTF format does not store the actual bind pose.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Skeleton`类跟踪动画模型的绑定姿势、逆绑定姿势和关节名称。这些数据可以在模型的所有动画实例之间共享。在下一节中，你将实现从glTF文件加载绑定姿势。glTF格式不存储实际的绑定姿势。'
- en: glTF – loading the bind pose
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: glTF - 加载绑定姿势
- en: You are now ready to load the bind pose from a glTF file, but there is a problem.
    glTF files don't store the bind pose. Instead, for each skin that a glTF file
    contains, it stores a matrix array that holds the inverse bind pose matrix for
    each joint that affects the skin.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好从glTF文件中加载绑定姿势了，但是有一个问题。glTF文件不存储绑定姿势。相反，对于glTF文件包含的每个蒙皮，它存储一个矩阵数组，其中包含影响蒙皮的每个关节的逆绑定姿势矩阵。
- en: Storing the inverse bind pose matrices like this is good for optimization, which
    will make more sense in the next chapter, but for now, it is something we have
    to deal with. So, how do you get the bind pose?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样存储逆绑定姿势矩阵对于优化是有好处的，这在下一章中会更有意义，但现在我们必须处理这个问题。那么，如何获取绑定姿势呢？
- en: To get the bind pose, load the rest pose and convert each transform in the rest
    pose into a world space transform. This makes sure that if a skin didn't provide
    an inverse bind pose matrix for a joint, a good default value is available.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 获取绑定姿势，加载休息姿势并将休息姿势中的每个变换转换为世界空间变换。这样可以确保如果皮肤没有为关节提供逆绑定姿势矩阵，就可以使用一个良好的默认值。
- en: Next, loop through each skinned mesh in the `.gltf` file. For each skinned mesh,
    invert the inverse bind pose matrix of each joint. Inverting the inverse bind
    pose matrix results in the bind pose matrix. Convert the bind pose matrix into
    a transform that can be used in the bind pose.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，循环遍历`.gltf`文件中的每个蒙皮网格。对于每个蒙皮网格，反转每个关节的逆绑定姿势矩阵。反转逆绑定姿势矩阵会得到绑定姿势矩阵。将绑定姿势矩阵转换为可以在绑定姿势中使用的变换。
- en: 'This works, but all the joint transforms are in world space. You need to convert
    each joint so that it is local to the parent of the joint. Take the following
    steps to implement the `LoadBindPose` function in `GLTFLoader.cpp`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是有效的，但是所有关节变换都是在世界空间中。你需要将每个关节转换为相对于其父级的位置。按照以下步骤实现`GLTFLoader.cpp`中的`LoadBindPose`函数：
- en: 'Start implementing the `LoadBindPose` function by building a vector of transforms.
    Populate the vector of transforms with the global transform of each joint in the
    rest pose:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过构建一个变换向量来开始实现`LoadBindPose`函数。用休息姿势中每个关节的全局变换填充变换向量：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Loop through every skinned mesh in the glTF file. Read the `inverse_bind_matrices`
    accessor into a large vector of float values. The vector needs to contain the
    `contain numJoints * 16` elements since each matrix is a 4x4 matrix:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历glTF文件中的每个蒙皮网格。将`inverse_bind_matrices`访问器读入一个大的浮点值向量中。该向量需要包含`contain numJoints
    * 16`个元素，因为每个矩阵都是一个4x4矩阵：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For each joint in the skin, get the inverse bind matrix. Invert the inverse
    bind pose matrix to get the bind pose matrix. Convert the bind pose matrix into
    a transform. Store this world space transform in the `worldBindPose` vector:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于蒙皮中的每个关节，获取逆绑定矩阵。反转逆绑定姿势矩阵以获得绑定姿势矩阵。将绑定姿势矩阵转换为变换。将这个世界空间变换存储在`worldBindPose`向量中：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Convert each joint so that it is relative to its parent. To move a joint into
    the space of another joint—that is, to make it relative to another joint—combine
    the world transform of the joint with the inverse world transform of its parent:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个关节转换为相对于其父级的位置。将一个关节移动到另一个关节的空间中，即使它相对于另一个关节，将关节的世界变换与其父级的逆世界变换相结合：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Reconstructing the bind pose is not ideal, but it is a quirk of glTF that you
    have to deal with. By using the rest pose as the default joint values, any joint
    that does not have an inverse bind pose matrix still has a valid default orientation
    and size.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 重建绑定姿势并不理想，但这是glTF的一个怪癖，你必须处理它。通过使用休息姿势作为默认关节值，任何没有逆绑定姿势矩阵的关节仍然具有有效的默认方向和大小。
- en: In this section, you learned how to load the bind pose of an animated mesh from
    a glTF file. In the next section, you will create a convenience function to load
    a skeleton from a glTF file with only one function call.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何从glTF文件中加载动画网格的初始姿势。在下一节中，您将创建一个方便的函数，通过一个函数调用从glTF文件中加载骨骼。
- en: glTF – loading a skeleton
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: glTF——加载骨骼
- en: We need to implement one more loading function—the `LoadSkeleton` function.
    This is a convenience function that loads a skeleton without having to call three
    separate functions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现另一个加载函数——`LoadSkeleton`函数。这是一个方便的函数，可以在不调用三个单独函数的情况下加载骨架。
- en: 'Implement the `LoadSkeleton` function in `GLTFLoader.cpp`. Don''t forget to
    add the function declaration to `GLTFLoader.h`. The function returns a new skeleton
    by calling the existing `LoadPose`, `LoadBindPose`, and `LoadJointNames` functions:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GLTFLoader.cpp`中实现`LoadSkeleton`函数。不要忘记将函数声明添加到`GLTFLoader.h`中。该函数通过调用现有的`LoadPose`、`LoadBindPose`和`LoadJointNames`函数返回一个新的骨骼：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `LoadSkeleton` function is just a helper function that allows you to initialize
    a skeleton with a single function call. In the next section, you will implement
    a `Mesh` class, which will let you display animated meshes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadSkeleton`函数只是一个辅助函数，允许您通过一个函数调用初始化骨骼。在下一节中，您将实现一个`Mesh`类，它将允许您显示动画网格。'
- en: Implementing meshes
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现网格
- en: The definition of a mesh is dependent on the game (or engine) that implements
    it. It's beyond the scope of this book to implement a comprehensive mesh class.
    Instead, in this section, you will declare a naive version of a mesh that stores
    some data on the CPU and the GPU and provides a way to sync the two together.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 网格的定义取决于实现它的游戏（或引擎）。在本书的范围之外实现一个全面的网格类。相反，在本节中，您将声明一个简单版本的网格，它在CPU和GPU上存储一些数据，并提供一种将两者同步的方法。
- en: The Mesh class declaration
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mesh类声明
- en: What is the most basic implementation of a mesh? Each vertex has a position,
    a normal, and some texture coordinates. To skin the mesh, each vertex also has
    four bones that might influence it and weights to determine how much each bone
    influences the vertex by. Meshes usually use an index array, but this is optional.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 网格的最基本实现是什么？每个顶点都有一个位置、一个法线和一些纹理坐标。为了对网格进行蒙皮，每个顶点还有四个可能影响它的骨骼和权重来确定每个骨骼对顶点的影响程度。网格通常使用索引数组，但这是可选的。
- en: In this section, you will implement both CPU and GPU skinning. To skin a mesh
    on the CPU, you need to keep an additional copy of the pose and normal data, as
    well as a matrix palette to use for skinning.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将同时实现CPU和GPU蒙皮。要在CPU上对网格进行蒙皮，您需要保留姿势和法线数据的额外副本，以及一个用于蒙皮的矩阵调色板。
- en: 'Create a new file, `Mesh.h`, to declare the `Mesh` class in. Follow these steps
    to declare the new `Mesh` class:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`Mesh.h`，声明`Mesh`类。按照以下步骤声明新的`Mesh`类：
- en: 'Start declaring the `Mesh` class. It should maintain a copy of the mesh data
    on the CPU as well as on the GPU. Store vectors for the position, normal, tex
    coordinates, weights, and influences that define each vertex. Include an optional
    vector for indices:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始声明`Mesh`类。它应该在CPU和GPU上都维护网格数据的副本。存储位置、法线、纹理坐标、权重和影响力的向量来定义每个顶点。包括一个可选的索引向量：
- en: '[PRE12]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Each of the vectors listed in the preceding code also needs to be set appropriate
    attributes. Create `Attribute` pointers for each one, as well as an index buffer
    pointer:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面代码中列出的每个向量也需要设置适当的属性。为每个创建`Attribute`指针，以及一个索引缓冲区指针：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add an additional copy of the pose and normal data, as well as a matrix palette
    to use for CPU skinning:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个额外的姿势和法线数据的副本，以及一个用于CPU蒙皮的矩阵调色板：
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add declarations for the constructor, copy constructor, and assignment operator,
    as well as the destructor:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为构造函数、拷贝构造函数和赋值运算符以及析构函数添加声明：
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Declare getter functions for all the attributes that the mesh contains. These
    functions return the vector references. The vector references are not read-only;
    you use these when loading meshes to populate the mesh data:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为网格包含的所有属性声明getter函数。这些函数返回向量引用。向量引用不是只读的；在加载网格时使用这些引用来填充网格数据：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Declare the `CPUSkin` function, which applies CPU mesh-skinning. To skin a
    mesh, you need both a skeleton and an animated pose. Declare the `UpdateOpenGLBuffers`
    function, which syncs the vectors holding data to the GPU:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`CPUSkin`函数，应用CPU网格蒙皮。要对网格进行蒙皮，您需要骨架和动画姿势。声明`UpdateOpenGLBuffers`函数，将持有数据的向量同步到GPU：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Declare functions to bind, draw, and unbind the mesh:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明绑定、绘制和解绑网格的函数：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This `Mesh` class is not production-ready, but it's easy to work with and will
    work for the rest of this book. In the next section, you will start implementing
    the `Mesh` class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Mesh`类还不是生产就绪的，但它很容易使用，并且将在本书的其余部分中使用。在下一节中，您将开始实现`Mesh`类。
- en: The Mesh class implementation
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mesh类实现
- en: The `Mesh` class contains two copies of the same data. It keeps all the vertex
    data on the CPU side in vectors and on the GPU side in vertex buffer objects.
    The intended use of this class is to edit the CPU-side vertices, then sync the
    changes to the GPU with the `UpdateOpenGLBuffers` functions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mesh`类包含相同数据的两个副本。它在CPU端使用向量保留所有顶点数据，并在GPU端使用顶点缓冲对象。这个类的预期用途是编辑CPU端的顶点，然后使用`UpdateOpenGLBuffers`函数将更改同步到GPU。'
- en: 'Create a new file, `Mesh.cpp`; you will implement the `Mesh` class in this
    file. Follow these steps to implement the `Mesh` class:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件`Mesh.cpp`；您将在此文件中实现`Mesh`类。按照以下步骤实现`Mesh`类：
- en: 'Implement the default constructor, which needs to make sure all the attributes
    (and the index buffer) are allocated:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现默认构造函数，需要确保所有属性（和索引缓冲区）都被分配：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement the copy constructor. Create the buffers in the same way that you
    did for the constructor, then call the assignment operator:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现拷贝构造函数。以与构造函数相同的方式创建缓冲区，然后调用赋值运算符：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Implement the assignment operator, which will copy out the CPU-side members
    (all of the vectors) and then call the `UpdateOpenGLBuffers` function to upload
    the attribute data to the GPU:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现赋值运算符，它将复制CPU端的成员（所有向量），然后调用`UpdateOpenGLBuffers`函数将属性数据上传到GPU：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Implement the destructor, making sure you delete all the data that the constructors
    had allocated:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现析构函数，确保删除构造函数分配的所有数据：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Implement the `Mesh` getter functions. These functions return references to
    vectors. The references are expected to be edited after they are returned:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Mesh`获取函数。这些函数返回向量的引用。预期在返回后对这些引用进行编辑：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Implement the `UpdateOpenGLBuffers` function by calling `Set` on each of the
    attribute objects. If one of the CPU-side vectors has a size of `0`, then there
    is nothing to set:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在每个属性对象上调用`Set`函数来实现`UpdateOpenGLBuffers`函数。如果CPU端的向量之一的大小为`0`，则没有需要设置的内容：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement the `Bind` function. This takes integers that are bind slot indices.
    If the bind slot is valid (that is, it''s `0` or greater), the `BindTo` function
    of the attribute is called:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Bind`函数。这需要绑定槽索引的整数。如果绑定槽有效（即为`0`或更大），则调用属性的`BindTo`函数：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Implement the `Draw` and `DrawInstanced` functions, which call the appropriate
    global `::Draw` and `::DrawInstanced` functions:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Draw`和`DrawInstanced`函数，这些函数调用适当的全局`::Draw`和`::DrawInstanced`函数：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Implement the `UnBind` function, which also takes integer bind slots for arguments
    but calls `UnBindFrom` on the attribute objects:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`UnBind`函数，该函数还接受整数绑定槽作为参数，但在属性对象上调用`UnBindFrom`：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `Mesh` class contains vectors to hold the CPU data and attributes to copy
    that data to the GPU. It provides a simple interface to render an entire mesh.
    In the following section, you will learn how to implement CPU skinning to animate
    a mesh.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mesh`类包含用于保存CPU数据的向量和用于将数据复制到GPU的属性。它提供了一个简单的接口来渲染整个网格。在接下来的部分中，您将学习如何实现CPU蒙皮以对网格进行动画处理。'
- en: Implementing CPU skinning
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现CPU蒙皮
- en: It is easier to understand skinning by implementing it on the CPU first, without
    having to worry about shaders. In this section, you will create a CPU-skinning
    reference implementation. GPU skinning is covered later on in this chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先在CPU上实现蒙皮，而无需担心着色器，可以更容易地理解蒙皮。在本节中，您将创建一个CPU蒙皮参考实现。GPU蒙皮将在本章后面介绍。
- en: 'Important information:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息：
- en: CPU skinning is useful if the platform you are developing for has a limited
    number of uniform registers or a small uniform buffer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在开发的平台具有有限数量的统一寄存器或小的统一缓冲区，则CPU蒙皮非常有用。
- en: When implementing CPU skinning, you need to keep two copies of the animated
    mesh. The `mPosition` and `mNormal` vectors do not change. The result of the skinned
    positions and normals is stored in `mSkinnedPosition` and `mSkinnedNormal`. These
    vectors are then synced to the position and normal attributes to draw.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现CPU蒙皮时，您需要保留动画网格的两个副本。`mPosition` 和 `mNormal` 向量不会改变。蒙皮后的位置和法线的结果存储在 `mSkinnedPosition`
    和 `mSkinnedNormal` 中。然后将这些向量同步到位置和法线属性以进行绘制。
- en: To skin a vertex, you need to calculate the skin transform. The skin transform
    needs to transform the vertex by the inverse bind pose, then by the current animated
    pose. You can do this by calling the inverse function on the bind pose transform,
    then combine it with the pose transform.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要对顶点进行蒙皮，您需要计算蒙皮变换。蒙皮变换需要通过逆绑定姿势对顶点进行变换，然后再通过当前的动画姿势进行变换。您可以通过在绑定姿势变换上调用逆函数，然后将其与姿势变换组合来实现这一点。
- en: For each vertex, `ivec4` in the `mInfluences` vector contains the joint IDs
    that affect the vertex. You need to transform the vertex by all four joints, which
    means you skin the mesh four times—once to each bone that influences the vertex.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个顶点，存储在`mInfluences`向量中的`ivec4`包含影响顶点的关节ID。您需要通过所有四个关节对顶点进行变换，这意味着您需要对影响顶点的每个骨骼进行四次蒙皮。
- en: Not every joint contributes in the same way to the final vertex. For each vertex,
    `vec4` stored in `mWeights` contains a scalar value of `0` to `1`. These values
    are used to blend the skinned vertices together. If a joint does not influence
    the vertex, its weight is `0` and it has no effect on the final skinned mesh.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个关节对最终顶点的贡献都相同。对于每个顶点，存储在`mWeights`中的`vec4`包含一个从`0`到`1`的标量值。这些值用于混合蒙皮顶点。如果一个关节不影响顶点，则其权重为`0`，对最终蒙皮网格没有影响。
- en: The content of the weights is expected to be normalized in a way that if all
    the weights are added together, they equal `1`. This way, the weights can be used
    to blend, since they all add up to an influence of `1`. For example, (`0.5`, `0.5`,
    `0`, `0`) would be valid, but (`0.6`, `0.5`, `0`, `0`) would not.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 权重的内容预期被归一化，以便如果所有权重相加，它们等于`1`。这样，权重可以用于混合，因为它们总和为`1`。例如，(`0.5`, `0.5`, `0`,
    `0`) 是有效的，但 (`0.6`, `0.5`, `0`, `0`) 不是。
- en: 'Follow these steps to implement CPU skinning:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现CPU蒙皮：
- en: 'Start implementing the `CPUSkin` function. Make sure the skinned vectors have
    enough storage space and get the bind pose from the skeleton. Next, loop through
    each vertex:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始实现`CPUSkin`函数。确保蒙皮向量有足够的存储空间，并从骨骼获取绑定姿势。接下来，循环遍历每个顶点：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Calculate the skin transform. Transform both the first vertex and normal influences:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算蒙皮变换。对第一个顶点和法线影响进行变换：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Repeat this process for the other three joints that might influence the current
    vertex:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对可能影响当前顶点的其他三个关节重复此过程：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: By this point, you have skinned the vertex four times—once to each bone that
    influences it. Next, you need to combine these into the final vertex.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到这一步，您已经对顶点进行了四次蒙皮——分别对每个影响它的骨骼进行一次。接下来，您需要将这些合并成最终的顶点。
- en: 'Blend the skinned positions and normal using `mWeights`. Set the position and
    normal attributes as the newly updated skinned positions and normals:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`mWeights`混合蒙皮位置和法线。将位置和法线属性设置为新更新的蒙皮位置和法线：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let's unpack what's happening here. This is the basic skinning algorithm. Every
    vertex has a `vec4` value called weights and an `ivec4` value called influences.
    Each vertex has four joints that influence it and four weights. A weight could
    be `0` if the joint has no influence on the vertex.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这里发生了什么。这是基本的蒙皮算法。每个顶点都有一个名为权重的`vec4`值和一个名为影响的`ivec4`值。每个顶点有四个影响它的关节和四个权重。如果关节对顶点没有影响，权重可能是`0`。
- en: The `x`, `y`, `z`, and `w` components of the `ivec4` influences are indices
    in the animated pose and inverse bind pose matrix arrays. The `x`, `y`, `z`, and
    `w` components of the `vec4` weights are scalar weights to apply to the same component
    of the `ivec4` influences.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`ivec4`的`x`、`y`、`z`和`w`分量影响动画姿势和逆绑定姿势矩阵数组中的索引。`vec4`的`x`、`y`、`z`和`w`分量是要应用于`ivec4`影响的相同分量的标量权重。'
- en: Loop through all the vertices. For each vertex, transform the position and the
    normal of the vertex by the skin transform of each joint that affects the vertex.
    The skin transform is the combination of the inverse bind pose and the pose transformations.
    This means you will end up skinning the vertex four times. Scale each transformed
    position or normal by the weight of the joint it belongs to and add all four values
    together. The resulting sum is the skinned position or normal.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 循环遍历所有顶点。对于每个顶点，通过影响该顶点的每个关节的蒙皮变换，变换顶点的位置和法线。蒙皮变换是逆绑定姿势和姿势变换的组合。这意味着你最终会对顶点进行四次蒙皮。按关节的权重缩放每个变换后的位置或法线，并将所有四个值相加。得到的总和就是蒙皮后的位置或法线。
- en: This is the skinning algorithm; it stays the same no matter how it is expressed.
    There are several ways to represent the joint transformations, such as using `Transform`
    objects, matrices, and dual quaternions. No matter what the representation is,
    the algorithm stays the same. In the following section, you will learn how to
    implement the skinning algorithm using matrices instead of `Transform` objects.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是蒙皮算法；无论如何表达，它都是相同的。有几种表示关节变换的方式，比如使用`Transform`对象、矩阵和双四元数。无论表示是什么，算法都是一样的。在接下来的部分，你将学习如何使用矩阵而不是`Transform`对象来实现蒙皮算法。
- en: Skinning with matrices
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用矩阵进行蒙皮
- en: The common way to skin a vertex is to linearly blend matrices into a single
    skin matrix, then transform the vertex by this skin matrix. To do this, use the
    inverse bind pose stored in the skeleton and get the matrix palette from the pose.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对顶点进行蒙皮的常见方法是将矩阵线性混合成单个蒙皮矩阵，然后通过这个蒙皮矩阵变换顶点。为此，使用存储在骨骼中的逆绑定姿势，并从姿势中获取矩阵调色板。
- en: To build a skin matrix, multiply the pose matrix by the inverse bind pose. Remember,
    the vertex should be transformed by the inverse bind pose first, then the animated
    pose. With right-to-left multiplication, this puts the inverse bind pose on the
    right side.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个蒙皮矩阵，将姿势矩阵乘以逆绑定姿势。记住，顶点应该先被逆绑定姿势变换，然后是动画姿势。通过从右到左的乘法，这将把逆绑定姿势放在右侧。
- en: Multiply the matrices together for each joint that affects the current vertex,
    then scale the resulting matrix by the weight of the vertex. Once all the matrices
    are scaled, add them together. The resulting matrix is the skin matrix that can
    be used to transform both the vertex position and normal.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对影响当前顶点的每个关节的矩阵进行相乘，然后按顶点的权重对结果矩阵进行缩放。一旦所有矩阵都被缩放，将它们相加。得到的矩阵就是可以用来变换顶点位置和法线的蒙皮矩阵。
- en: 'The following code re-implements the `CPUSkin` function using matrix palette
    skinning. This code is very similar to the shader code that you will need to implement
    to run skinning on the GPU:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码重新实现了使用矩阵调色板蒙皮的`CPUSkin`函数。这段代码与你需要实现的在GPU上运行蒙皮的着色器代码非常相似：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The code for skinning with matrices looks a little different, but it's still
    the same skinning algorithm. Instead of transforming each vertex four times and
    scaling the results, the matrices are scaled and added together. The result is
    a single skin matrix.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矩阵进行蒙皮的代码看起来有点不同，但蒙皮算法仍然是相同的。不再是对每个顶点进行四次变换并缩放结果，而是对矩阵进行缩放并相加。结果是一个单一的蒙皮矩阵。
- en: Even though the vertex is only transformed once, four new matrix multiplications
    are introduced. The number of required operations is about the same, so why implement
    matrix palette skinning? When you implement GPU skinning, it's easy to use GLSL's
    built-in matrices.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 即使顶点只被变换一次，也引入了四次新的矩阵乘法。所需操作的数量大致相同，那么为什么要实现矩阵调色板蒙皮？当你实现GPU蒙皮时，使用GLSL的内置矩阵就很容易了。
- en: 'In this section, you implemented a `Mesh` class. The Mesh class uses the following
    vertex format:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你实现了一个`Mesh`类。Mesh类使用以下顶点格式：
- en: The position (`vec3`)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置（`vec3`）
- en: The normal (`vec3`)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通（`vec3`）
- en: The texture coordinates `(vec2`)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理坐标（`vec2`）
- en: The influences (`ivec4`)
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响（`ivec4`）
- en: The weights (`vec4`)
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权重（`vec4`）
- en: With this definition, you can render a skinned mesh. In the following section,
    you will learn how to load a mesh from a glTF file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个定义，你可以渲染一个蒙皮网格。在接下来的部分，你将学习如何从glTF文件中加载网格。
- en: glTF – loading meshes
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: glTF - 加载网格
- en: Now that you have a functional `Mesh` class, you can, in theory, skin the mesh
    on the CPU. However, there is one problem—you can't actually load a mesh from
    a glTF file yet. Let's address this next.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个功能性的`Mesh`类，理论上，你可以在CPU上对网格进行蒙皮。然而，有一个问题——你实际上还不能从glTF文件中加载网格。让我们接下来解决这个问题。
- en: Start by creating a new helper function, `MeshFromAttributes`. This is only
    a helper function, so there is no need to expose it to the header file. glTF stores
    a mesh as a collection of primitives and each primitive is a collection of attributes.
    These attributes contain the same information as our attribute class, such as
    positions, normals, weights, and so on.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的辅助函数`MeshFromAttributes`。这只是一个辅助函数，所以不需要将其暴露给头文件。glTF将网格存储为一组基元，每个基元都是一组属性。这些属性包含与我们的属性类相同的信息，如位置、法线、权重等。
- en: The `MeshFromAttribute` helper function takes a mesh and a `cgltf_attribute`
    function, along with some additional data required for parsing. The attribute
    contains one of our mesh components, such as the position, normal, UV coordinate,
    weights, or influences. This attribute provides the appropriate mesh data.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: “MeshFromAttribute”辅助函数接受一个网格和一个“cgltf_attribute”函数，以及解析所需的一些附加数据。该属性包含我们网格组件之一，例如位置、法线、UV坐标、权重或影响。此属性提供适当的网格数据。
- en: All values are read in as floating-point numbers, but the joint influences that
    affect the vertex are stored as integers. Don't cast the float to an int directly;
    there is a chance that due to a precision issue, the cast will return the wrong
    number. Instead, convert the float into an integer by adding 0.5 then casting.
    That way, the integer truncation always brings it to the correct number.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 所有值都以浮点数形式读取，但影响顶点的关节影响以整数形式存储。不要直接将浮点数转换为整数；由于精度问题，转换可能会返回错误的数字。相反，通过加上0.5然后进行转换，将浮点数转换为整数。这样，整数截断总是将其带到正确的数字。
- en: gLTF stores the indices that affect a joint relative to the joints array of
    the skin that is being parsed, not the node hierarchy. The `joints` array, in
    turn, is a pointer to a node. You can this node pointer and use the `GetNodeIndex`
    function to convert it into an index in the node hierarchy.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: gLTF将影响关节的索引存储为相对于正在解析的皮肤的关节数组，而不是节点层次结构。而“关节”数组又是指向节点的指针。您可以使用此节点指针，并使用“GetNodeIndex”函数将其转换为节点层次结构中的索引。
- en: 'Follow these steps to implement mesh loading from a glTF file:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤从glTF文件中实现网格加载：
- en: 'Implement the `MeshFromAttribute` function in the `GLTFHelpers` namespace.
    Start the implementation by figuring out how many attributes the current component
    has:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“GLTFHelpers”命名空间中实现“MeshFromAttribute”函数。通过确定当前组件具有多少属性来开始实现：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Parse the data out of the provided accessor using the `GetScalarValues` helper
    function. Create references to the position, normal, texture coordinate, influences,
    and weights vectors of the mesh; the `MeshFromAttribute` function will write to
    these references:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“GetScalarValues”辅助函数从提供的访问器中解析数据。创建对网格的位置、法线、纹理坐标、影响和权重向量的引用；“MeshFromAttribute”函数将写入这些引用：
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Loop through all the values in the current accessor and assign them to the
    appropriate vector based on the accessor type. The position, texture coordinates,
    and weights components can all be found by reading the data from the values vector
    and assigning them directly to the appropriate vector in the mesh:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历当前访问器中的所有值，并根据访问器类型将它们分配到适当的向量中。通过从值向量中读取数据并直接将其分配到网格中的适当向量中，可以找到位置、纹理坐标和权重分量：
- en: '[PRE35]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After reading in the normal, check its squared length. If the normal is invalid,
    return a valid vector and consider logging an error. If the normal is valid, normalize
    it before pushing it into the normals vector:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在读取法线后，检查其平方长度。如果法线无效，则返回有效向量并考虑记录错误。如果法线有效，则在将其推入法线向量之前对其进行归一化：
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Read in the joints that influence the current vertex. These joints are stored
    as floating-point numbers. Convert them into integers:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取影响当前顶点的关节。这些关节存储为浮点数。将它们转换为整数：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Use the `GetNodeIndex` helper function to convert the joint indices so that
    they go from being relative to the `joints` array to being relative to the skeleton
    hierarchy:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“GetNodeIndex”辅助函数将关节索引转换，使其从相对于“关节”数组变为相对于骨骼层次结构：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Make sure that even the invalid nodes have a value of `0`. Any negative joint
    indices will break the skinning implementation:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保即使无效节点也具有“0”的值。任何负关节索引都会破坏蒙皮实现：
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A **mesh** in gLTF is made up of **primitives**. A primitive contains attributes
    such as positions and normals. Every primitive in glTF is expressed as a mesh
    in the framework you've created so far since it doesn't have a concept of sub-meshes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: gLTF中的**网格**由**原始**组成。原始包含诸如位置和法线之类的属性。自从迄今为止创建的框架中没有子网格的概念，因此glTF中的每个原始都表示为网格。
- en: 'With the `MeshFromAttribute` function now finished, implement the `LoadMeshes`
    function next. This is the function used to load the actual mesh data; it needs
    to be declared in `GLTFLoader.h` and implemented in `GLTFLoader.cpp`. Follow these
    steps to implement the `LoadMeshes` function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在“MeshFromAttribute”函数已完成，接下来实现“LoadMeshes”函数。这是用于加载实际网格数据的函数；它需要在“GLTFLoader.h”中声明，并在“GLTFLoader.cpp”中实现。按照以下步骤实现“LoadMeshes”函数：
- en: 'To implement the `LoadMeshes` function, first, loop through all of the nodes
    in the glTF file. Only process nodes that have both a mesh and a skin; any other
    nodes should be skipped:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现“LoadMeshes”函数，首先循环遍历glTF文件中的所有节点。只处理具有网格和皮肤的节点；应跳过任何其他节点：
- en: '[PRE40]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Loop through all the primitives in the glTF file. Create a new mesh for each
    primitive. Loop through all the attributes in the primitive and populate the mesh
    data by calling the `MeshFromAttribute` helper function:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历glTF文件中的所有原始。为每个原始创建一个新网格。通过调用“MeshFromAttribute”辅助函数循环遍历原始中的所有属性，并通过调用“MeshFromAttribute”辅助函数填充网格数据：
- en: '[PRE41]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Check whether the primitive contains indices. If it does, the index buffer
    of the mesh needs to be filled out as well:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查原始是否包含索引。如果是，网格的索引缓冲区也需要填充：
- en: '[PRE42]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The mesh is complete. Call the `UpdateOpenGLBuffers` function to make sure
    the mesh can be rendered and return the resulting vector of meshes:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网格已完成。调用“UpdateOpenGLBuffers”函数以确保网格可以呈现，并返回结果网格的向量：
- en: '[PRE43]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Since glTF stores an entire scene, not just a mesh, it supports multiple meshes—each
    one is made up of primitives, which are the actual triangles. Primitives in glTF
    can be thought of as sub-meshes. The glTF loader presented here assumes that a
    file contains a single model only. In the next section, you will learn how to
    move mesh skinning from the CPU to the GPU using shaders.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于glTF存储整个场景，而不仅仅是一个网格，它支持多个网格——每个网格由原语组成，原语是实际的三角形。在glTF中，原语可以被视为子网格。这里介绍的glTF加载器假设一个文件只包含一个模型。在下一节中，您将学习如何使用着色器将网格蒙皮从CPU移动到GPU。
- en: Implementing GPU skinning
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现GPU蒙皮
- en: You created some basic shaders in [*Chapter 6*](B16191_06_Final_JC_ePub.xhtml#_idTextAnchor104),
    *Building an Abstract Renderer and OpenGL*—the `static.vert` shader and the `lit.frag`
    shader. The `static.vert` shader can be used to display a static, unskinned mesh,
    which is loaded with the `LoadMeshes` function. The `static.vert` shader can even
    display a CPU skinned mesh.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您在[*第6章*](B16191_06_Final_JC_ePub.xhtml#_idTextAnchor104)中创建了一些基本的着色器，*构建抽象渲染器和OpenGL*——`static.vert`着色器和`lit.frag`着色器。`static.vert`着色器可用于显示静态的、未经蒙皮的网格，该网格是使用`LoadMeshes`函数加载的。`static.vert`着色器甚至可以显示CPU蒙皮网格。
- en: 'Create a new file, `skinned.vert`. Follow these steps to implement a vertex
    shader that can perform matrix palette skinning. The code is very similar to the
    one used for `static.vert`; the differences are highlighted:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，`skinned.vert`。按照以下步骤实现一个可以执行矩阵调色板蒙皮的顶点着色器。代码与用于`static.vert`的代码非常相似；不同之处已经突出显示：
- en: 'Each vertex gets two new components—the joint indices that affect the vertex
    and the weight of each joint. These new components can be stored in `ivec4` and
    `vec4`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个顶点都会得到两个新的分量——影响顶点的关节索引和每个关节的权重。这些新的分量可以存储在`ivec4`和`vec4`中：
- en: '[PRE44]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, add two matrix arrays to the shader—each array is `120` in length. This
    length is arbitrary; the shader only needs as many new uniform matrices as the
    skinned mesh has joints. You could configure this automatically by generating
    a new shader string in code every time a skeleton with a new number of bones is
    loaded:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在着色器中添加两个矩阵数组——每个数组的长度为`120`。这个长度是任意的；着色器只需要与蒙皮网格的关节数量一样多的新统一矩阵。您可以通过在代码中每次加载具有新骨骼数量的骨架时生成新的着色器字符串来自动配置这一点：
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When the main function of the shader runs, calculate a skin matrix. The skin
    matrix is generated the same way as the CPU skinning-example skin matrix. It uses
    the same logic, just in a shader executing on the GPU:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当着色器的主函数运行时，计算一个蒙皮矩阵。蒙皮矩阵的生成方式与CPU蒙皮示例的蒙皮矩阵相同。它使用相同的逻辑，只是在GPU上执行的着色器中：
- en: '[PRE46]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The mesh should deform before it is placed in the world. Multiply the vertex
    position and normal by the skin matrix before applying the model matrix. All the
    relevant code is highlighted here:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网格在放置在世界之前应该发生变形。在应用模型矩阵之前，将顶点位置和法线乘以蒙皮矩阵。所有相关的代码都在这里突出显示：
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: To add skinning support to the vertex shader, you add two new attributes to
    each vertex that represent up to four joints that can affect the vertex. By using
    the joint and weight attributes, a skin matrix is constructed. To skin the mesh,
    multiply the vertex or normal by the skin matrix before applying the rest of the
    vertex transformation pipeline.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要将蒙皮支持添加到顶点着色器中，您需要为每个顶点添加两个新属性，表示最多四个可以影响顶点的关节。通过使用关节和权重属性，构建一个蒙皮矩阵。要对网格进行蒙皮，需要在应用顶点变换管线的其余部分之前，将顶点或法线乘以蒙皮矩阵。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the difference between a bind pose and a rest pose.
    You also created a `Skeleton` class that contains them both. You learned about
    the general concept of skinning—both rigid (one bone per vertex) and smooth (multiple
    bones per vertex) skinning.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了绑定姿势和静止姿势之间的区别。您还创建了一个包含它们两者的`Skeleton`类。您了解了蒙皮的一般概念——刚性（每个顶点一个骨骼）和平滑（每个顶点多个骨骼）蒙皮。
- en: In this chapter, we implemented a primitive mesh class and we covered the process
    of skinning a mesh on both the CPU and GPU, as well as loading a bind pose out
    of a glTF file that does not store bind pose data.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了一个基本的原始网格类，并介绍了在CPU和GPU上对网格进行蒙皮的过程，以及从不存储绑定姿势数据的glTF文件中加载绑定姿势。
- en: You can now apply the skills you learned. With the skinning code complete, you
    can display fully animated models. The models can be loaded from glTF files, which
    is an open file format specification.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以应用所学的技能。完成蒙皮代码后，您可以显示完全动画的模型。这些模型可以从glTF文件中加载，这是一种开放的文件格式规范。
- en: In the downloadable samples for this book, `Chapter10/Sample01` contains a sample
    that draws the rest pose, bind pose, and current animated pose. `Chapter10/Sample02`
    demonstrates how to use both GPU and CPU skinning.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的可下载示例中，`Chapter10/Sample01`包含一个示例，绘制了静止姿势、绑定姿势和当前动画姿势。`Chapter10/Sample02`演示了如何同时使用GPU和CPU蒙皮。
- en: In the next chapter, you will learn how to optimize various aspects of the animation
    pipeline. This includes the pose generation and skinning and caching transform
    parent lookups steps.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何优化动画流水线的各个方面。这包括姿势生成和蒙皮以及缓存变换父级查找步骤。
