- en: Gathering Platform and Compiler Information
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集平台和编译器信息
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Detecting an OS and compiler
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测操作系统和编译器
- en: Detecting int128 support
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测int128的支持
- en: Detecting and bypassing disabled RTTI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测和绕过禁用的RTTI
- en: Writing metafunctions using simpler methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更简单的方法编写元函数
- en: Reducing code size and increasing the performance of user-defined types (UDTs)
    in C++11
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少代码大小并提高C++11中用户定义类型（UDTs）的性能
- en: The portable way to export and import functions and classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导出和导入函数和类的可移植方式
- en: Detecting the Boost version and getting latest features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测Boost版本并获取最新功能
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Different projects and companies have different coding requirements. Some of
    them forbid exceptions or RTTI, while some forbid C++11\. If you are willing to
    write portable code that can be used by a wide range of projects, this chapter
    is for you.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的项目和公司有不同的编码要求。有些禁止异常或RTTI，而有些禁止C++11。如果您愿意编写可供广泛项目使用的可移植代码，那么这一章就是为您准备的。
- en: Want to make your code as fast as possible and use the latest C++ features?
    You'll definitely need a tool for detecting compiler features.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 想要尽可能快地编写代码并使用最新的C++功能吗？您肯定需要一个工具来检测编译器功能。
- en: Some compilers have unique features that may greatly simplify your life. If
    you are targeting a single compiler, you can save many hours and use those features.
    No need to implement their analogs from scratch!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器具有独特的功能，可以极大地简化您的生活。如果您只针对一个编译器，可以节省很多时间并使用这些功能。无需从头开始实现它们的类似物！
- en: This chapter is devoted to different helper macros used to detect compiler,
    platform, and Boost features. These macro are widely used across Boost libraries
    and are essential for writing portable code that is able to work with any compiler
    flags.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门介绍了用于检测编译器、平台和Boost功能的不同辅助宏。这些宏广泛用于Boost库，并且对于编写能够使用任何编译器标志的可移植代码至关重要。
- en: Detecting an OS and compiler
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测操作系统和编译器
- en: 'I''m guessing you''ve seen a bunch of ugly macros to detect the compiler on
    which the code is compiled. Something like this is a typical practice in C word:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜你可能见过很多丑陋的宏来检测代码编译的编译器。像这样的东西在C语言中是一种典型的做法：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, try to come up with a good macro to detect the GCC compiler. Try to make
    that macro usage as short as possible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，试着想出一个好的宏来检测GCC编译器。尽量使宏的使用尽可能简短。
- en: Take a look at the following recipe to verify your guess.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下的步骤来验证你的猜测。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only basic knowledge of C++ is required.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要基本的C++知识。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The recipe is simple and consists of a single a header and a single macro.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤很简单，只包括一个头文件和一个宏。
- en: 'The header:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 头文件：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The macro:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 宏：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The header `<boost/predef/compiler.h>` knows all the possible compilers and
    has a macro for each of those. So if the current compiler is GCC, then macro `BOOST_COMP_GNUC`
    is defined to `1` and all the other macros for other compilers are defined to
    `0`. If we are not on a GCC compiler, then the `BOOST_COMP_GNUC` macro is defined
    to `0`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件`<boost/predef/compiler.h>`知道所有可能的编译器，并为每个编译器都有一个宏。因此，如果当前编译器是GCC，那么宏`BOOST_COMP_GNUC`被定义为`1`，而其他编译器的所有其他宏都被定义为`0`。如果我们不在GCC编译器上，那么`BOOST_COMP_GNUC`宏被定义为`0`。
- en: 'Thanks to this approach, you do not need to check for the macro itself being
    defined:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，您无需检查宏本身是否已定义：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Macros of the `Boost.Predef` library are always defined, and that saves you
    from typing `defined()` or `def` in `#ifdef`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Predef`库的宏总是被定义的，这样就不需要在`#ifdef`中输入`defined()`或`def`。'
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Boost.Predef` library also has macros for detecting OS, architecture,
    standard library implementation, and some hardware abilities. Approach with macros
    that are always defined; this allows you to write complex expressions much shorter:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boost.Predef`库还有用于检测操作系统、架构、标准库实现和一些硬件能力的宏。使用总是被定义的宏的方法；这使您能够更简洁地编写复杂的表达式：'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, the best part. The `Boost.Predef` library is usable on C, C++, and Objective-C
    compilers. If you like it, use it in your non C++ projects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最好的部分。`Boost.Predef`库可用于C、C++和Objective-C编译器。如果您喜欢它，可以在非C++项目中使用它。
- en: C++17 has no `Boost.Predef` library functionality.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: C++17没有`Boost.Predef`库的功能。
- en: See also
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Read the official documentation of `Boost.Predef` for more information about
    its abilities at [http://boost.org/libs/predef](http://boost.org/libs/predef)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读`Boost.Predef`的官方文档，了解更多关于其在[http://boost.org/libs/predef](http://boost.org/libs/predef)的能力。
- en: The next recipe will introduce you to the `Boost.Config` library, that is much
    order, slightly less beautiful, but much more functional
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个步骤将向您介绍`Boost.Config`库，它的顺序更多，稍微不那么美观，但功能更加强大
- en: Detecting int128 support
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测int128的支持
- en: Some compilers have support for extended arithmetic types such as 128-bit floats
    or integers. Let's take a quick glance at how to use them using Boost.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器支持扩展算术类型，如128位浮点数或整数。让我们快速了解如何使用Boost来使用它们。
- en: We'll be creating a method that accepts three parameters and returns the multiplied
    value of those methods. If compiler supports 128-bit integers, then we use them.
    If compiler supports `long long`, then we use it; otherwise, we need to issue
    a compile-time error.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个接受三个参数并返回这些方法的乘积值的方法。如果编译器支持128位整数，那么我们就使用它们。如果编译器支持`long long`，那么我们就使用它；否则，我们需要发出编译时错误。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only the basic knowledge of C++ is required.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要基本的C++知识。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: What do we need to work with 128-bit integers? Macros that show that they are
    available and a few `typedefs` to have portable type names across platforms.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要什么来处理128位整数？显示它们可用的宏和一些`typedefs`以在各个平台上拥有可移植的类型名称。
- en: 'Include a header:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括一个头文件：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we need to detect int128 support:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要检测int128的支持：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add some `typedefs` and implement the method as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些`typedefs`并按以下方式实现该方法：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For compilers that do not support the int128 type and have no `long long`,
    we may produce compile time error:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于不支持int128类型且没有`long long`的编译器，我们可能会产生编译时错误：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we need to provide some implementation for compilers without int128 support
    using `int64`:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为不支持int128的编译器使用`int64`提供一些实现：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The header `<boost/config.hpp>` contains a lot of macros to describe compiler
    and platform features. In this example, we used `BOOST_HAS_INT128` to detect support
    of 128-bit integers and `BOOST_NO_LONG_LONG` to detect support of 64-bit integers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件`<boost/config.hpp>`包含许多宏来描述编译器和平台特性。在此示例中，我们使用`BOOST_HAS_INT128`来检测对128位整数的支持，使用`BOOST_NO_LONG_LONG`来检测对64位整数的支持。
- en: 'As we may see from the example, Boost has `typedefs` for 64-bit signed and
    unsigned integers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从示例中看到的，Boost具有64位有符号和无符号整数的`typedefs`：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It also has `typedefs` for 128-bit signed and unsigned integers:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有128位有符号和无符号整数的`typedefs`：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's more...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: C++11 has support of 64-bit types via the `long long int` and `unsigned long
    long int` built-in types. Unfortunately, not all compilers support C++11, so `BOOST_NO_LONG_LONG`
    may be useful for you.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: C++11通过`long long int`和`unsigned long long int`内置类型支持64位类型。不幸的是，并非所有编译器都支持C++11，因此`BOOST_NO_LONG_LONG`可能对您有用。
- en: 128-bit integers are not a part of C++17, so `typedefs` and macros from Boost
    are one of the ways to write portable code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 128位整数不是C++17的一部分，因此Boost中的`typedefs`和宏是编写可移植代码的一种方式。
- en: There's an ongoing work in C++ standardization committee on adding integers
    of compile-time specified width. When that work will be finished, you would be
    able to create 128-bit, 512-bit, and even 8388608-bit (1 MB big) integers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准化委员会正在进行工作，以添加编译时指定宽度的整数。当这项工作完成时，您将能够创建128位、512位甚至8388608位（1 MB大）的整数。
- en: See also
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Read the recipe *Detecting and bypassing disabled RTTI *for more information
    about `Boost.Config`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读有关“检测和绕过禁用的RTTI”更多关于`Boost.Config`的信息。
- en: Read the official documentation of `Boost.Config` at [http://boost.org/libs/config](http://boost.org/libs/config) for
    more information about its abilities.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读官方文档[http://boost.org/libs/config](http://boost.org/libs/config)以获取有关其功能的更多信息。
- en: There is a library in Boost that allows constructing types of unlimited precision.
    Follow the link [http://boost.org/libs/multiprecision](http://boost.org/libs/multiprecision) and
    take a look at the `Boost.Multiprecision` library.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Boost中有一个允许构造无限精度类型的库。点击链接[http://boost.org/libs/multiprecision](http://boost.org/libs/multiprecision)并查看`Boost.Multiprecision`库。
- en: Detecting and bypassing disabled RTTI
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测和绕过禁用的RTTI
- en: Some companies and libraries have specific requirements for their C++ code,
    such as successful compilation without RTTI.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一些公司和库对其C++代码有特定要求，例如成功编译而无需RTTI。
- en: In this small recipe, we'll not just detect disabled RTTI, but also write a
    Boost like library from scratch that stores information about types, and compares
    types at runtime, even without `typeid`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小配方中，我们不仅会检测禁用的RTTI，还会从头开始编写一个类似Boost的库，用于存储类型信息，并在运行时比较类型，即使没有`typeid`。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++ RTTI usage is required for this recipe.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，需要基本的C++ RTTI使用知识。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Detecting disabled RTTI, storing information about types, and comparing types
    at runtime are tricks that are widely used across Boost libraries.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 检测禁用的RTTI，存储类型信息，并在运行时比较类型是Boost库中广泛使用的技巧。
- en: 'To do this, we first need to include the following header:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们首先需要包含以下头文件：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s first look at the situation where RTTI is enabled and the C++11 `std::type_index`
    class is available:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先看一下启用了RTTI并且C++11的`std::type_index`类可用的情况：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Otherwise, we need to construct our own `type_index` class:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们需要构造自己的`type_index`类：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The final step is to define the `type_id` function:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是定义`type_id`函数：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can compare types:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以比较类型：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The macro `BOOST_NO_RTTI` is be defined if RTTI is disabled, and the macro `BOOST_NO_CXX11_HDR_TYPEINDEX`
    is be defined when the compiler has no `<typeindex>` header and no `std::type_index`
    class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果禁用了RTTI，则宏`BOOST_NO_RTTI`将被定义，如果编译器没有`<typeindex>`头文件和没有`std::type_index`类，则宏`BOOST_NO_CXX11_HDR_TYPEINDEX`将被定义。
- en: The handwritten `type_index` structure from *step 3* of the previous section
    only holds the pointer to some string; nothing really interesting here.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节*步骤3*中手写的`type_index`结构只保存指向某个字符串的指针；这里没有什么真正有趣的东西。
- en: Take a look at the `BOOST_CURRENT_FUNCTION` macro. It returns the full name
    of the current function, including template parameters, arguments, and the return
    type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`BOOST_CURRENT_FUNCTION`宏。它返回当前函数的完整名称，包括模板参数、参数和返回类型。
- en: 'For example, `type_id<double>()` is represented as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`type_id<double>()`表示如下：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So, for any other type, `BOOST_CURRENT_FUNCTION` returns a different string,
    and that's why the `type_index` variable from the example does not compare equal
    to it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于任何其他类型，`BOOST_CURRENT_FUNCTION`返回不同的字符串，这就是为什么示例中的`type_index`变量不等于它的原因。
- en: 'Congratulations! We''ve just reinvented most of the `Boost.TypeIndex` library
    functionality. Remove all the code from *steps 1 to 4* and slightly change the
    code in *step 5* to use the `Boost.TypeIndex` library:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们刚刚重新发明了大部分`Boost.TypeIndex`库的功能。删除*步骤1到4*中的所有代码，并稍微更改*步骤5*中的代码以使用`Boost.TypeIndex`库：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There's more...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Of course `Boost.TypeIndex` is slightly more than that; it allows you to get
    human readable type name in a platform independent way, works around platform-related
    issues, allows to invent your own RTTI implementation, to have a constexpr RTTI,
    and other stuff.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`Boost.TypeIndex`略微超出了这个范围；它允许您以与平台无关的方式获取可读的类型名称，解决与平台相关的问题，允许发明自己的RTTI实现，拥有constexpr
    RTTI等等。
- en: Different compilers have different macros for getting a full function name.
    Using macros from Boost is the most portable solution. The `BOOST_CURRENT_FUNCTION`
    macro returns the name at compile time, so it implies minimal runtime penalty.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编译器有不同的宏用于获取完整的函数名。使用Boost的宏是最通用的解决方案。`BOOST_CURRENT_FUNCTION`宏在编译时返回名称，因此它意味着最小的运行时惩罚。
- en: C++11 has a `__func__` magic identifier that is evaluated to the name of the
    current function. However, result of `__func__` is only the function name, while
    `BOOST_CURRENT_FUNCTION` tries hard to also show function parameters, including
    template ones.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: C++11有一个`__func__`魔术标识符，它被评估为当前函数的名称。然而，`__func__`的结果只是函数名，而`BOOST_CURRENT_FUNCTION`则努力显示函数参数，包括模板参数。
- en: See also
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Read the upcoming recipes for more information on `Boost.Config`
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读即将发布的食谱，了解更多关于`Boost.Config`的信息
- en: Browse to [http://github.com/boostorg/type_index](http://github.com/boostorg/type_index)
    to view the source codes of the `Boost.TypeIndex` library
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览[http://github.com/boostorg/type_index](http://github.com/boostorg/type_index)以查看`Boost.TypeIndex`库的源代码
- en: Read the official documentation of `Boost.Config` at [http://boost.org/libs/config](http://boost.org/libs/config)
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读[http://boost.org/libs/config](http://boost.org/libs/config)上的`Boost.Config`的官方文档
- en: Read the official documentation of the `Boost.TypeIndex` library at [http://boost.org/libs/type_index](http://boost.org/libs/type_index)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读[http://boost.org/libs/type_index](http://boost.org/libs/type_index)上的`Boost.TypeIndex`库的官方文档
- en: Recipe *Getting human readable type name* in [Chapter 01](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Starting to Write Your Application* will introduce you to some of the other capabilities
    of the `Boost.TypeIndex`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第01章](part0029.html#RL0A0-712b4ba1126a4c7c89e1d44de61b4bdd)的食谱*获取可读的类型名称*，*开始编写您的应用程序*将向您介绍`Boost.TypeIndex`的其他功能'
- en: Writing metafunctions using simpler methods
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更简单的方法编写元函数
- en: '[Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd), *Compile-time
    Tricks*, and [Chapter 8](part0425.html#CL9V20-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Metaprogramming*, were devoted to metaprogramming. If you were trying to use
    techniques from those chapters, you may have noticed that writing a metafunction
    can take a lot of time. So, it may be a good idea to experiment with metafunctions
    using more user-friendly methods, such as C++11 `constexpr`, before writing a
    portable implementation.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd)，*编译时技巧*，和[第8章](part0425.html#CL9V20-712b4ba1126a4c7c89e1d44de61b4bdd)，*元编程*，都致力于元编程。如果您尝试使用这些章节中的技术，您可能已经注意到编写元函数可能需要很长时间。因此，在编写可移植实现之前，使用更用户友好的方法，如C++11的`constexpr`，进行元函数的实验可能是一个好主意。'
- en: In this recipe, we'll take a look at how to detect `constexpr` support.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将看看如何检测`constexpr`的支持。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The `constexpr` functions are functions that can be evaluated at compile-time.
    That is all we need to know for this recipe.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`函数是可以在编译时评估的函数。这就是我们需要了解的全部内容。'
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how we can detect compiler support for the `constexpr` feature:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何检测编译器对`constexpr`功能的支持：
- en: 'Just like in other recipes from this chapter, we start with the following header:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像本章的其他食谱一样，我们从以下头文件开始：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Write the `constexpr` function:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`constexpr`函数：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s print an error if C++11 features are missing:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果缺少C++11功能，则打印错误：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That''s it. Now, we are free to write code such as the following:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样。现在，我们可以自由地编写以下代码：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `BOOST_NO_CXX11_CONSTEXPR` macro is defined when C++11 `constexpr` is available.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当C++11的`constexpr`可用时，定义了`BOOST_NO_CXX11_CONSTEXPR`宏。
- en: The `constexpr` keyword tells the compiler that the function can be evaluated
    at compile time if all the inputs for that function are compile-time constants.
    C++11 imposes a lot of limitations on what a `constexpr` function can do. C++14
    removed some of the limitations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`constexpr`关键字告诉编译器，如果该函数的所有输入都是编译时常量，那么该函数可以在编译时评估。C++11对`constexpr`函数的功能施加了许多限制。C++14取消了一些限制。'
- en: The `BOOST_NO_CXX11_HDR_ARRAY` macro is defined when the C++11 `std::array`
    class and the `<array>` header are available.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当C++11的`std::array`类和`<array>`头文件可用时，定义了`BOOST_NO_CXX11_HDR_ARRAY`宏。
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'However, there are other usable and interesting macros for `constexpr` too,
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于`constexpr`，还有其他可用和有趣的宏，如下所示：
- en: The `BOOST_CONSTEXPR` macro expands to `constexpr` or does not expand
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_CONSTEXPR`宏扩展为`constexpr`或不扩展'
- en: The `BOOST_CONSTEXPR_OR_CONST` macro expands to `constexpr` or `const`
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_CONSTEXPR_OR_CONST`宏扩展为`constexpr`或`const`'
- en: The `BOOST_STATIC_CONSTEXPR` macro is the same as `static BOOST_CONSTEXPR_OR_CONST`
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BOOST_STATIC_CONSTEXPR`宏与`static BOOST_CONSTEXPR_OR_CONST`相同'
- en: 'Using those macros, it is possible to write code that takes advantage of C++11
    constant expression features if they are available:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些宏，如果可用的话，可以编写利用C++11常量表达式特性的代码：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we can use `integral_constant` as shown in the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像下面的代码中所示使用`integral_constant`：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the example, `BOOST_CONSTEXPR operator T()` is called to get the array size.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，调用`BOOST_CONSTEXPR operator T()`来获取数组大小。
- en: The C++11 constant expressions may improve compilation speed and diagnostic
    information in case of error. It's a good feature to use. If your function requires
    **relaxed constexpr** from C++14, then you may use `BOOST_CXX14_CONSTEXPR` macro.
    It expands to `constexpr` only if relaxed constexpr is available and expands to
    nothing otherwise.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: C++11的常量表达式可以提高编译速度和错误诊断信息。这是一个很好的功能。如果您的函数需要来自C++14的**relaxed constexpr**，那么您可以使用`BOOST_CXX14_CONSTEXPR`宏。如果放松的constexpr可用，则它扩展为`constexpr`，否则不扩展。
- en: See also
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More information about `constexpr` usage can be read at [http://en.cppreference.com/w/cpp/language/constexpr](http://en.cppreference.com/w/cpp/language/constexpr)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`constexpr`用法的更多信息，请阅读[http://en.cppreference.com/w/cpp/language/constexpr](http://en.cppreference.com/w/cpp/language/constexpr)
- en: Read the official documentation of `Boost.Config` for more information about
    macros at [http://boost.org/libs/config](http://boost.org/libs/config)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读官方文档`Boost.Config`，了解有关宏的更多信息[http://boost.org/libs/config](http://boost.org/libs/config)
- en: Reducing code size and increasing performance of user-defined types (UDTs) in
    C++11
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减小C++11中用户定义类型（UDTs）的代码大小并提高性能
- en: C++11 has very specific logic when **user-defined types** (**UDTs**) are used
    in standard library containers. Some containers use move assignment and move construction
    only if the move constructor does not throw exceptions or there is no copy constructor.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当标准库容器中使用**用户定义类型**（UDTs）时，C++11具有非常具体的逻辑。一些容器仅在移动构造函数不抛出异常或不存在复制构造函数时才使用移动赋值和移动构造。
- en: Let's see how we can ensure the compiler that the out class `move_nothrow` 
    has a non-throwing `move` assignment operator and a non-throwing `move` constructor.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何确保编译器知道`move_nothrow`类具有不抛出异常的`move`赋值运算符和不抛出异常的`move`构造函数。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Basic knowledge of C++11 rvalue references is required for this recipe. Knowledge
    of standard library containers will also serve you well.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程需要基本的C++11右值引用知识。对标准库容器的了解也会对你有所帮助。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's take a look at how we can improve our C++ classes using Boost.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Boost改进我们的C++类。
- en: 'All we need to do is mark the `move_nothrow` assignment operator and `move_nothrow`
    constructor with the `BOOST_NOEXCEPT` macro:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要使用`BOOST_NOEXCEPT`宏标记`move_nothrow`赋值运算符和`move_nothrow`构造函数：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we may use the class with `std::vector` in C++11 without any modifications:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在C++11中使用`std::vector`类而无需进行任何修改：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we remove `BOOST_NOEXCEPT` from the `move` constructor, we''ll get the following
    error because we provided no definition for the copy constructor:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们从`move`构造函数中移除`BOOST_NOEXCEPT`，我们将收到以下错误，因为我们没有为复制构造函数提供定义：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `BOOST_NOEXCEPT` macro expands to `noexcept` on compilers that support it.
    The standard library containers use type traits to detect if the constructor throws
    an exception or not. Type traits make their decision mainly based on `noexcept`
    specifiers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_NOEXCEPT`宏在支持它的编译器上扩展为`noexcept`。标准库容器使用类型特征来检测构造函数是否抛出异常。类型特征主要基于`noexcept`说明符做出决定。'
- en: Why do we get an error without `BOOST_NOEXCEPT`? Compiler's type trait returns
    that `move_nothrow` throws, so `std::vector` tries to use the copy constructor
    of `move_nothrow`, which is not defined.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么没有`BOOST_NOEXCEPT`会出错？编译器的类型特征返回`move_nothrow`会抛出异常，因此`std::vector`尝试使用`move_nothrow`的复制构造函数，但该构造函数未定义。
- en: There's more...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `BOOST_NOEXCEPT` macro also reduces binary size irrespective of whether
    the definition of the `noexcept` function or method is in a separate source file
    or not.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_NOEXCEPT`宏还可以减小二进制大小，无论`noexcept`函数或方法的定义是否在单独的源文件中。'
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That's because in the latter case, the compiler knows that the function does
    not throw exceptions and so there is no need to generate code that handles them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在后一种情况下，编译器知道函数不会抛出异常，因此无需生成处理异常的代码。
- en: If a function marked as `noexcept` does throw an exception, your program will
    terminate without calling destructors for the constructed objects.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标记为`noexcept`的函数确实抛出异常，您的程序将在不调用已构造对象的析构函数的情况下终止。
- en: See also
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: A document describing why `move` constructors are allowed to throw exceptions
    and how containers must move objects is available at [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`move`构造函数允许抛出异常以及容器必须移动对象的文档可在[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html)上找到。
- en: Read the official documentation of `Boost.Config` for more examples of `BOOST_NOEXCEPT`
    such as macros existing in Boost at [http://boost.org/libs/config](http://boost.org/libs/config)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读`Boost.Config`的官方文档，了解更多`BOOST_NOEXCEPT`的示例，例如Boost中存在的宏[http://boost.org/libs/config](http://boost.org/libs/config)
- en: The portable way to export and import functions and classes
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出和导入函数和类的可移植方式
- en: 'Almost all modern languages have the ability to make libraries, a collection
    of classes, and methods that have a well-defined interface. C++ is no exception
    to this rule. We have two types of libraries: runtime (also called shared or dynamic)
    and static. But, writing libraries is not a simple task in C++. Different platforms
    have different methods for describing which symbols must be exported from the
    shared library.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有现代语言都有制作库的能力，即一组具有明确定义接口的类和方法。C++也不例外。我们有两种类型的库：运行时（也称为共享或动态）和静态。但是，在C++中编写库并不是一项简单的任务。不同的平台有不同的方法来描述必须从共享库中导出哪些符号。
- en: Let's take a look at how to manage symbol visibility in a portable way using
    Boost.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Boost以一种可移植的方式管理符号可见性。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Experience in creating dynamic and static libraries may be useful in this recipe.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，创建动态和静态库的经验可能会有所帮助。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The code for this recipe consists of two parts. The first part is the library
    itself. The second part is the code that uses that library. Both parts use the
    same header, in which the library methods are declared. Managing symbol visibility
    in a portable way using Boost is simple and can be done using the following steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的代码由两部分组成。第一部分是库本身。第二部分是使用该库的代码。这两部分都使用相同的头文件，在其中声明了库方法。使用Boost以一种可移植的方式管理符号可见性很简单，可以通过以下步骤完成：
- en: 'In the header file, we need definitions from the following header file:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中，我们需要以下头文件的定义：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following code must also be added to the header file:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码也必须添加到头文件中：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, all the declarations must use the `MY_LIBRARY_API` macro:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，所有声明都必须使用`MY_LIBRARY_API`宏：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Exceptions must be declared with `BOOST_SYMBOL_VISIBLE`; otherwise, they can
    be caught only using `catch(...)` in the code that uses the library:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异常必须使用`BOOST_SYMBOL_VISIBLE`声明；否则，它们只能在使用库的代码中使用`catch(...)`捕获：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Library source files must include the header file:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库源文件必须包括头文件：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Definitions of methods must also be in the source files of the library:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法的定义也必须在库的源文件中：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we can use the library as shown in the following code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以像下面的代码一样使用库：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All the work is done in *step 2*. There, we are defining the macro `MY_LIBRARY_API`,
    which we apply to classes and methods that we wish to export from our library.
    In *step 2*, we check for `MY_LIBRARY_LINK_DYNAMIC`. If it is not defined, we
    are building a static library and there is no need to define `MY_LIBRARY_API`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工作都在*步骤2*中完成。在那里，我们定义了宏`MY_LIBRARY_API`，并将其应用于我们希望从库中导出的类和方法。在*步骤2*中，我们检查了`MY_LIBRARY_LINK_DYNAMIC`。如果未定义，我们正在构建一个静态库，不需要定义`MY_LIBRARY_API`。
- en: The developer must take care of `MY_LIBRARY_LINK_DYNAMIC`! It will not define
    itself. If we are making a dynamic library, we need to make our build system to
    define it,
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员必须注意`MY_LIBRARY_LINK_DYNAMIC`！它不会自己定义。如果我们正在制作一个动态库，我们需要让我们的构建系统来定义它，
- en: 'If `MY_LIBRARY_LINK_DYNAMIC` is defined, we are building a runtime library,
    and that''s where the workarounds start. You, as the developer, must tell the
    compiler that we are now exporting function to the user. The user must tell the
    compiler that he/she is importing methods from the library. To have a single header
    file for both the import and export library, we use the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了`MY_LIBRARY_LINK_DYNAMIC`，我们正在构建一个运行时库，这就是解决方法的开始。作为开发人员，您必须告诉编译器我们现在正在向用户导出函数。用户必须告诉编译器他/她正在从库中导入方法。为了拥有一个单一的头文件，既可以用于导入也可以用于导出库，我们使用以下代码：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When exporting the library (or, in other words, compiling it), we must define
    `MY_LIBRARY_COMPILATION`. This leads to `MY_LIBRARY_API` being defined to `BOOST_SYMBOL_EXPORT`.
    For example, see *step 5*, where we defined `MY_LIBRARY_COMPILATION` before including
    `my_library.hpp`. If `MY_LIBRARY_COMPILATION` is not defined, the header is included
    by the user, who doesn't know anything about that macro. And, if the header is
    included by the user, the symbols must be imported from the library.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在导出库（或者说编译库）时，我们必须定义`MY_LIBRARY_COMPILATION`。这会导致`MY_LIBRARY_API`被定义为`BOOST_SYMBOL_EXPORT`。例如，参见*步骤5*，在包含`my_library.hpp`之前我们定义了`MY_LIBRARY_COMPILATION`。如果未定义`MY_LIBRARY_COMPILATION`，则用户包含了头文件，而用户对该宏一无所知。如果用户包含了头文件，则必须从库中导入符号。
- en: The `BOOST_SYMBOL_VISIBLE` macro must be used only for those classes that are
    not exported but are used by RTTI. Examples of such classes are exceptions and
    classes being cast using `dynamic_cast`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_SYMBOL_VISIBLE`宏只能用于那些未导出但被RTTI使用的类。这类示例包括异常和使用`dynamic_cast`进行转换的类。'
- en: There's more...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Some compilers export all the symbols by default but provide flags to disable
    such behavior. For example, GCC and Clang on Linux provide `-fvisibility=hidden`.
    It is highly recommended to use those flags because it leads to smaller binary
    size, faster loading of dynamic libraries, and better logical structuring of binary.
    Some inter-procedural optimizations can perform better when fewer symbols are
    exported. C++17 has no standard way for describing visibilities. Hopefully someday,
    a portable way to work with visibility will appear in C++, but until then, we
    have to use macros from Boost.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编译器默认导出所有符号，但提供了禁用此行为的标志。例如，Linux上的GCC和Clang提供了`-fvisibility=hidden`。强烈建议使用这些标志，因为它可以导致更小的二进制文件大小，更快的动态库加载，以及更好的二进制逻辑结构。一些程序间优化在导出较少符号时可以表现更好。C++17没有描述可见性的标准方式。希望有一天，C++中会出现一种可移植的可见性处理方式，但在那之前，我们必须使用Boost中的宏。
- en: See also
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Read this chapter from the beginning to get more examples of `Boost.Config`
    usage
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始阅读本章，以获取更多关于`Boost.Config`使用的示例
- en: Consider reading the official documentation of `Boost.Config` for the full list
    of the `Boost.Config` macro and their description at [http://boost.org/libs/config](http://boost.org/libs/config)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请阅读`Boost.Config`的官方文档，以获取完整的`Boost.Config`宏列表及其描述，网址为[http://boost.org/libs/config](http://boost.org/libs/config)。
- en: Detecting the Boost version and getting latest features
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测Boost版本并获取最新功能
- en: Boost is being actively developed, so each release contains new features and
    libraries. Some people wish to have libraries that compile for different versions
    of Boost and also want to use some of the features of the new versions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Boost正在积极开发，因此每个版本都包含新功能和库。一些人希望有针对不同版本的Boost编译的库，并且还想使用新版本的一些功能。
- en: Let's take a look at the `boost::lexical_cast` change log. According to it,
    Boost 1.53 has a `lexical_cast(const CharType* chars, std::size_t count)` function
    overload. Our task for this recipe will be to use that function overload for new
    versions of Boost and work around that missing function overload for older versions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`boost::lexical_cast`的变更日志。根据它，Boost 1.53有一个`lexical_cast(const CharType*
    chars, std::size_t count)`函数重载。我们这个示例的任务是为新版本的Boost使用该函数重载，并为旧版本解决缺少的函数重载。
- en: Getting ready
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Only basic knowledge of C++ and the `Boost.LexicalCast` library is required.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要基本的C++和`Boost.LexicalCast`库的知识。
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Well, all we need to do is get info about the version of Boost and use it to
    write optimal code. This can be done as shown in the following steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们需要做的就是获取有关Boost版本的信息，并使用它来编写最佳代码。这可以按以下步骤完成：
- en: 'We need to include the headers containing the Boost version and `boost::lexical_cast`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要包含包含Boost版本和`boost::lexical_cast`的头文件：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We use the new feature of `Boost.LexicalCast` if it is available:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可用，我们使用`Boost.LexicalCast`的新功能：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Otherwise, we are required to copy data to `std::string` first:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们需要先将数据复制到`std::string`中：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we can use the code as shown here:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以像这里展示的代码一样使用：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `BOOST_VERSION` macro contains the Boost version written in the following
    format: a single number for the major version, followed by three numbers for the
    minor version, and then two numbers for the patch level. For example, Boost 1.73.1
    will contain the `107301` number in the `BOOST_VERSION` macro.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`BOOST_VERSION`宏包含Boost版本，格式如下：主版本号为一个数字，次版本号为三个数字，修订级别为两个数字。例如，Boost 1.73.1将在`BOOST_VERSION`宏中包含`107301`数字。'
- en: So, we check the Boost version in *step 2* and choose the correct implementation
    of the `to_int` function according to the abilities of `Boost.LexicalCast`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在*步骤2*中，我们检查Boost版本，并根据`Boost.LexicalCast`的能力选择`to_int`函数的正确实现。
- en: There's more...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Having a version macro is a common practice for big libraries. Some of the Boost
    libraries allow you to specify the version of the library to use; see `Boost.Thread`
    and its `BOOST_THREAD_VERSION` macro for an example.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有版本宏是大型库的常见做法。一些Boost库允许您指定要使用的库的版本；请参阅`Boost.Thread`及其`BOOST_THREAD_VERSION`宏以获取示例。
- en: 'By the way, C++ has a version macro too. Value of the `__cplusplus` macro allows
    you to distinguish pre-C++11 from C++11, C++11 from C++14, or C++17\. Currently
    it can be defined to one of the following values: `199711L`, `201103L`, `201402L`,
    or `201703L`. Macro value stands for year and month when the committee approved
    the standard.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，C++也有一个版本宏。`__cplusplus`宏的值允许您区分C++11之前的版本和C++11，C++11和C++14，或C++17。目前，它可以定义为以下值之一：`199711L`，`201103L`，`201402L`或`201703L`。宏值代表委员会批准标准的年份和月份。
- en: See also
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Read the recipe *Creating an execution thread* in [Chapter 5](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Multithreading*, for more information about `BOOST_THREAD_VERSION` and how it
    affects the `Boost.Thread` library, or read the documentation at [http://boost.org/libs/thread](http://boost.org/libs/thread)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读[第5章](part0262.html#7PRJC0-712b4ba1126a4c7c89e1d44de61b4bdd)中的*创建执行线程*配方，了解有关`BOOST_THREAD_VERSION`及其对`Boost.Thread`库的影响的更多信息，或阅读[http://boost.org/libs/thread](http://boost.org/libs/thread)的文档。
- en: Read this chapter from the beginning or consider reading the official documentation
    of `Boost.Config` at [http://boost.org/libs/config](http://boost.org/libs/config)
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始阅读本章，或考虑阅读[Boost.Config](http://boost.org/libs/config)的官方文档
