- en: Chapter 11. Monsters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。怪物
- en: We'll add in a bunch of opponents for the player.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为玩家添加一些对手。
- en: What I've done in this chapter is added a landscape to the example. The player
    will walk along the path sculpted out for him and then he will encounter an army.
    There is an NPC before he reaches the army that will offer advice.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我所做的是给示例添加了一片风景。玩家将沿着为他雕刻出的路径行走，然后他将遇到一支军队。在他到达军队之前有一个NPC会提供建议。
- en: '![Monsters](img/00160.jpeg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![怪物](img/00160.jpeg)'
- en: 'The scene: starting to look like a game'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 场景：开始看起来像一款游戏
- en: Landscape
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 景观
- en: We haven't covered how to sculpt the landscape in this book yet, but we'll do
    that here. First, you must have a landscape to work with. Start a new file by
    navigating to **File** | **New**. You can choose an empty level or a level with
    a sky. I chose the one without the sky in this example.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有在本书中介绍如何雕刻风景，但我们将在这里介绍。首先，你必须有一个可以工作的风景。通过导航到**文件** | **新建**来开始一个新文件。你可以选择一个空关卡或一个带有天空的关卡。在这个例子中，我选择了没有天空的那个。
- en: 'To create a landscape, we have to work from the **Modes** panel. Make sure
    that the **Modes** panel is displayed by navigating to **Window** | **Modes**:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建风景，我们必须从**模式**面板开始工作。确保通过导航到**窗口** | **模式**来显示**模式**面板：
- en: '![Landscape](img/00161.jpeg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![风景](img/00161.jpeg)'
- en: Displaying the modes panel
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 显示模式面板
- en: 'A landscape can be created in three steps, which are shown in the following
    screenshot, followed by the corresponding steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 创建风景可以分三步完成，如下面的屏幕截图所示，然后是相应的步骤：
- en: '![Landscape](img/00162.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![风景](img/00162.jpeg)'
- en: Click on the landscape icon (the picture of the mountains) in the **Modes**
    panel.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**模式**面板中的景观图标（山脉的图片）。
- en: Click on the **Manage** button.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**管理**按钮。
- en: Next, click on the **Create** button in the lower right-hand corner of the screen.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击屏幕右下角的**创建**按钮。
- en: 'You should now have a landscape to work with. It will appear as a gray, tiled
    area in the main window:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该有一个可以工作的风景。它将出现在主窗口中的灰色、拼贴区域：
- en: '![Landscape](img/00163.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![景观](img/00163.jpeg)'
- en: 'The first thing you will want to do with your landscape scene is add some color
    to it. What''s a landscape without colors? Right-click anywhere on your gray,
    tiled landscape object. In the **Details** panel at the right, you will see that
    it is populated with information, as shown in the following screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先想对你的风景场景做的事情是给它添加一些颜色。没有颜色的风景是什么？在你的灰色、拼贴的风景对象上右击。在右侧的**详细信息**面板中，你会看到它充满了信息，如下面的屏幕截图所示：
- en: '![Landscape](img/00164.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![风景](img/00164.jpeg)'
- en: Scroll down until you see the **Landscape Material** property. You can select
    the **M_Ground_Grass** material for a realistic-looking ground.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动直到你看到**景观材质**属性。你可以选择**M_Ground_Grass**材质来创建一个看起来逼真的地面。
- en: Next, add a light to the scene. You should probably use a directional light
    so that all of the ground has some light on it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向场景中添加一个光源。你可能想使用一个方向光源，这样所有的地面都会有一些光照。
- en: Sculpting the landscape
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 雕刻风景
- en: 'A flat landscape can be boring. We will at least add some curves and hills
    to the place. To do so, click on the **Sculpt** button in the **Modes** panel:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 平坦的风景可能会很无聊。我们至少会给这个地方添加一些曲线和山丘。要做到这一点，请点击**模式**面板中的**雕刻**按钮：
- en: '![Sculpting the landscape](img/00165.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![雕刻风景](img/00165.jpeg)'
- en: To change the landscape, click on the Sculpt button
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改风景，请点击**雕刻**按钮
- en: The strength and size of your brush are determined by the **Brush Size** and
    **Tool Strength** parameters in the **Modes** window.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您画笔的强度和大小由**模式**窗口中的**画笔大小**和**工具强度**参数决定。
- en: 'Click on your landscape and drag the mouse to change the height of the turf.
    Once you''re happy with what you''ve got, click on the **Play** button to try
    it out. The resultant output can be seen in the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 点击您的风景并拖动鼠标以改变草地的海拔。一旦你对结果满意，点击**播放**按钮来尝试它。结果可以在以下屏幕截图中看到：
- en: '![Sculpting the landscape](img/00166.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![雕刻风景](img/00166.jpeg)'
- en: 'Play around with your landscape and create a scene. What I did was lower the
    landscape around a flat ground plane, so the player has a well-defined flat area
    to walk on, as shown in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的风景上玩一玩，创建一个场景。我所做的是降低平坦地面周围的风景，这样玩家就有了一个定义明确的平坦区域可以行走，如下面的屏幕截图所示：
- en: '![Sculpting the landscape](img/00167.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![雕刻风景](img/00167.jpeg)'
- en: Feel free to do whatever you like with your landscape. You can use what I'm
    doing here as inspiration, if you like. I will recommend that you import assets
    from **ContentExamples** or from **StrategyGame** in order to use them inside
    your game. To do this, refer to the *Importing assets* section in [Chapter 10](part0072_split_000.html#24L8G2-dd4a3f777fc247568443d5ffb917736d
    "Chapter 10. Inventory System and Pickup Items"), *Inventory System and Pickup
    Items*. When you're done importing assets, we can proceed to bring monsters into
    your world.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 随意对你的景观进行任何你喜欢的操作。如果你喜欢，你可以用我在这里做的作为灵感。我建议你从**ContentExamples**或从**StrategyGame**导入资源，以便在游戏中使用。为此，请参考[第10章](part0072_split_000.html#24L8G2-dd4a3f777fc247568443d5ffb917736d
    "第10章。库存系统和拾取物品")中的*导入资源*部分，*库存系统和拾取物品*。当你完成资源导入后，我们可以继续将怪物引入你的世界。
- en: Monsters
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 怪物
- en: 'We''ll start programming monsters in the same way we programmed NPCs and `PickupItem`.
    First, we''ll write a base class (by deriving from character) to represent the
    `Monster` class. Then, we''ll derive a bunch of blueprints for each monster type.
    Every monster will have a couple of properties in common that determine its behavior.
    These are the common properties:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与编程NPC和`PickupItem`相同的方式开始编程怪物。首先，我们将编写一个基类（通过从`Character`派生）来表示`Monster`类。然后，我们将为每种怪物类型派生许多蓝图。每个怪物都将有一些共同属性，这些属性决定了它的行为。这些是共同属性：
- en: A `float` variable for speed.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示速度的`float`变量。
- en: A `float` variable for the `HitPoints` value (I usually use floats for HP, so
    we can easily model HP leeching effects such as walking through a pool of lava).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示`HitPoints`值的`float`变量（我通常使用浮点数表示HP，这样我们就可以轻松地模拟HP吸血效果，例如走过一池熔岩）。
- en: An `int32` variable for the experience gained in defeating the monster.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示击败怪物获得的经验值的`int32`变量。
- en: A `UClass` function for the loot dropped by the monster.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于怪物掉落物品的`UClass`函数。
- en: A `float` variable for `BaseAttackDamage` done on each attack.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次攻击时对`BaseAttackDamage`进行的`float`变量。
- en: A `float` variable for `AttackTimeout`, which is the amount of time for which
    the monster rests between attacking.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个表示攻击超时的`float`变量，即怪物在攻击之间的休息时间。
- en: 'Two `USphereComponents` object: One of them is `SightSphere`—how far he can
    see. The other is `AttackRangeSphere`, which is how far his attack reaches. The
    `AttackRangeSphere` object is always smaller than `SightSphere`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个`USphereComponents`对象：其中一个为`SightSphere`——他能看到多远。另一个是`AttackRangeSphere`，表示他的攻击能到达多远。`AttackRangeSphere`对象总是小于`SightSphere`。
- en: Derive from the `Character` class to create your class for `Monster`. You can
    do this in UE4 by going to **File** | **Add Code To Project...** and then selecting
    the **Character** option from the menu for your base class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Character`类派生以创建你的`Monster`类。你可以在UE4中通过转到**文件** | **将代码添加到项目...**，然后从菜单中选择你的基类**Character**选项来完成此操作。
- en: 'Fill out the `Monster` class with the base properties. Make sure that you declare
    `UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = MonsterProperties)` so
    that the properties of the monsters can be changed in the blueprints:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Monster`类中填写基础属性。确保声明`UPROPERTY(EditAnywhere, BlueprintReadWrite, Category
    = MonsterProperties)`，这样可以在蓝图上更改怪物的属性：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will need some bare minimum code in your `Monster` constructor to get the
    monster''s properties initialized. Use the following code in the `Monster.cpp`
    file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在`Monster`构造函数中添加一些基本的代码来初始化怪物的属性。在`Monster.cpp`文件中使用以下代码：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compile and run the code. Open Unreal Editor and derive a blueprint based on
    your `Monster` class (call it `BP_Monster`). Now we can start configuring your
    monster's `Monster` properties.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行代码。打开Unreal编辑器，基于你的`Monster`类（命名为`BP_Monster`）创建一个蓝图。现在我们可以开始配置你的怪物属性。
- en: For the skeletal mesh, we won't use the `HeroTPP` model for the monster because
    we need the monster to be able to do melee attacks and the `HeroTPP` model does
    not come with a melee attack. However, some of the models in the **Mixamo Animation
    Pack** file have melee attack animations. So download the **Mixamo Animation Pack**
    file from the UE4 marketplace (free).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于骨骼网格，我们不会为怪物使用`HeroTPP`模型，因为我们需要怪物能够进行近战攻击，而`HeroTPP`模型并不包含近战攻击。然而，**Mixamo
    Animation Pack**文件中的一些模型包含近战攻击动画。因此，请从UE4市场下载**Mixamo Animation Pack**文件（免费）。
- en: '![Monsters](img/00168.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![怪物](img/00168.jpeg)'
- en: Inside the pack are some pretty gross models that I'd avoid, but others are
    quite good
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在包中有些相当令人厌恶的模型，我会避免使用，但也有一些相当不错
- en: 'Next, you should add the **Mixamo Animation Pack** file to your project, as
    shown in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您应该将**Mixamo Animation Pack**文件添加到您的项目中，如下面的截图所示：
- en: '![Monsters](img/00169.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![怪物](img/00169.jpeg)'
- en: Now, create a blueprint called `BP_Monster` based on your `Monster` class. Edit
    the blueprint's class properties and select **Mixamo_Adam** (it is actually typed
    as **Maximo_Adam** in the current issue of the package) as the skeletal mesh.
    Also, select **MixamoAnimBP_Adam** as the animation blueprint.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基于您的`Monster`类创建一个名为`BP_Monster`的蓝图。编辑蓝图类属性并选择**Mixamo_Adam**（实际上在当前包的版本中写作**Maximo_Adam**）作为骨骼网格。同时，选择**MixamoAnimBP_Adam**作为动画蓝图。
- en: '![Monsters](img/00170.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![怪物](img/00170.jpeg)'
- en: Select the Maximo_Adam Skeletal Mesh and MixamoAnimBP_Adam for Anim Blueprint
    Generated Class
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 选择Maximo_Adam骨骼网格和MixamoAnimBP_Adam作为动画蓝图生成的类
- en: We will modify the animation blueprint to correctly incorporate the melee attack
    animation later.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改动画蓝图，以便正确地结合近战攻击动画。
- en: While you're editing your `BP_Monster` blueprint, change the sizes of the `SightSphere`
    and `AttackRangeSphere` objects to values that make sense to you. I made my monster's
    `AttackRangeSphere` object just big enough to be about an arm's reach (60 units)
    and his `SightSphere` object to be 25 times bigger than that (about 1,500 units).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编辑`BP_Monster`蓝图时，将`SightSphere`和`AttackRangeSphere`对象的大小调整为对您有意义的值。我将我的怪物的`AttackRangeSphere`对象设置得刚好足够接近手臂的长度（60单位），而将`SightSphere`对象设置为大约是其25倍大（大约1,500单位）。
- en: Remember that the monster will start moving towards the player once the player
    enters the monster's `SightSphere`, and the monster will start attacking the player
    once the player is inside the monster's `AttackRangeSphere` object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一旦玩家进入怪物的`SightSphere`，怪物就会开始向玩家移动，一旦玩家在怪物的`AttackRangeSphere`对象内部，怪物就会开始攻击玩家。
- en: '![Monsters](img/00171.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![怪物](img/00171.jpeg)'
- en: Mixamo Adam with his AttackRangeSphere object highlighted in orange
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Mixamo Adam及其AttackRangeSphere对象以橙色突出显示
- en: Place a few of your **BP_Monster** instances inside your game; compile and run.
    Without any code to drive the `Monster` character to move, your monsters should
    just stand there idly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的游戏中放置一些**BP_Monster**实例；编译并运行。如果没有代码来驱动`Monster`角色移动，您的怪物应该只是在那里无所事事地站立。
- en: Basic monster intelligence
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本怪物智能
- en: 'In our game, we will add only a basic intelligence to the `Monster` characters.
    The monsters will know how to do two basic things:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们将只向`Monster`角色添加基本智能。怪物将知道如何做两件基本的事情：
- en: Track the player and follow him
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪玩家并跟随他
- en: Attack the player
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击玩家
- en: The monster will not do anything else. You can have the monster taunt the player
    when the player is first seen as well, but we'll leave that as an exercise for
    you.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 怪物不会做其他任何事情。您还可以让怪物在第一次看到玩家时挑衅玩家，但我们将把这个留作您的练习。
- en: Moving the monster – steering behavior
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动怪物 - 导航行为
- en: Monsters in very basic games don't usually have complex motion behaviors. Usually
    they just walk towards the target and attack it. We'll program that type of monster
    in this game, but mind you, you can get more interesting play with monsters that
    position themselves advantageously on the terrain to perform ranged attacks and
    so on. We're not going to program that here, but it's something to think about.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常基本的游戏中，怪物通常不会有复杂的运动行为。通常它们只是走向目标并攻击它。我们将在这个游戏中编程这种类型的怪物，但请注意，您可以通过让怪物在战场上占据有利位置进行远程攻击等方式获得更有趣的游戏体验。我们不会在这里编程这些，但这是一个值得思考的问题。
- en: In order to get the `Monster` character to move towards the player, we need
    to dynamically update the direction of the `Monster` character moving in each
    frame. To update the direction that the monster is facing, we write code in the
    `Monster::Tick()` method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让`Monster`角色向玩家移动，我们需要在每个帧中动态更新`Monster`角色移动的方向。为了更新怪物面对的方向，我们在`Monster::Tick()`方法中编写代码。
- en: 'The `Tick` function runs in every frame of the game. The signature of the `Tick`
    function is:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tick`函数在游戏的每一帧中运行。`Tick`函数的签名是：'
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You need to add this function''s prototype to your `AMonster` class in your
    `Monster.h` file. If we override `Tick`, we can place our own custom behavior
    that the `Monster` character should do in each frame. Here''s some basic code
    that will move the monster toward the player during each frame:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将此函数的原型添加到您的`Monster`类中，在您的`Monster.h`文件中。如果我们重写`Tick`，我们就可以在每个帧中放置`Monster`角色应该执行的自己的自定义行为。以下是一些基本的代码，它将在每个帧中将怪物移动到玩家附近：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For `AddMovementInput` to work, you must have a controller selected under the
    **AIController Class** panel in your blueprint, as shown in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`AddMovementInput`正常工作，你必须在蓝图中的**AIController Class**面板下选择一个控制器，如下面的截图所示：
- en: '![Moving the monster – steering behavior](img/00172.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![移动怪物 – 导航行为](img/00172.jpeg)'
- en: If you have selected `None`, calls to `AddMovementInput` won't have any effect.
    To prevent this, select either the `AIController` class or the `PlayerController`
    class as your **AIController Class**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了`None`，对`AddMovementInput`的调用将没有任何效果。为了避免这种情况，请选择`AIController`类或`PlayerController`类作为你的**AIController
    Class**。
- en: 'The preceding code is very simple. It comprises the most basic form of enemy
    intelligence: simply move toward the player by an incrementally small amount in
    each frame.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常简单。它构成了最基本形式的敌人智能：在每个帧中通过增量小量向玩家移动。
- en: '![Moving the monster – steering behavior](img/00173.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![移动怪物 – 导航行为](img/00173.jpeg)'
- en: Our not-so-intelligent army of monsters chasing the player
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不那么聪明的怪物军队正在追逐玩家
- en: The result in a series of frames will be that the monster tracks and follows
    the player around the level. To understand how this works, you must remember that
    the `Tick` function is called on average about 60 times per second. What this
    means is that in each frame, the monster moves a tiny bit closer to the player.
    Since the monster moves in very small steps, his action looks smooth and continuous
    (while in reality, he is making small jumps and leaps in each frame).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在一系列帧的结果中，怪物将跟踪并跟随玩家在关卡中移动。要理解这是如何工作的，你必须记住`Tick`函数平均每秒大约被调用60次。这意味着在每个帧中，怪物都会向玩家靠近一小步。由于怪物以非常小的步伐移动，他的动作看起来很平滑和连续（而在现实中，他在每个帧中都在进行小跳跃和跳跃）。
- en: '![Moving the monster – steering behavior](img/00174.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![移动怪物 – 导航行为](img/00174.jpeg)'
- en: 'Discrete nature of tracking: a monster''s motion over three superimposed frames'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪的离散性：怪物在三个叠加帧中的运动
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The reason why the monster moves about 60 times a second is because of a hardware
    constraint. The refresh rate of a typical monitor is 60 Hz, so it acts as a practical
    limiter on how many updates per second are useful. Updating at a frame rate faster
    than the refresh rate is possible, but it is not necessarily useful for games
    since you will only see a new picture once every 1/60 of a second on most hardware.
    Some advanced physics modeling simulations do almost 1,000 updates a second, but
    arguably, you don't need that kind of resolution for a game and you should reserve
    the extra CPU time for something that the player will enjoy instead, such as better
    AI algorithms. Some newer hardware boasts of a refresh rate up to 120 Hz (look
    up gaming monitors, but don't tell your parents I asked you to blow all your money
    on one).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 怪物每秒移动大约60次的原因是由于硬件限制。典型显示器的刷新率为60 Hz，因此它实际上限制了每秒有多少次更新是有用的。以比刷新率更快的帧率更新是可能的，但对于游戏来说，这并不一定有用，因为在大多数硬件上，你每秒只能看到一次新的画面。一些高级的物理建模模拟每秒可以更新近1,000次，但可以说，对于游戏来说，你不需要那么高的分辨率，你应该将额外的CPU时间留给玩家会喜欢的功能，比如更好的AI算法。一些较新的硬件声称刷新率高达120
    Hz（查找游戏显示器，但不要告诉你的父母我让你花所有钱买一个）。
- en: The discrete nature of monster motion
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 怪物运动的离散性
- en: Computer games are discrete in nature. In the preceding screenshot of superimposed
    sequences of frames, the player is seen as moving straight up the screen, in tiny
    steps. The motion of the monster is also in small steps. In each frame, the monster
    takes one small discrete step towards the player. The monster is following an
    apparently curved path as he moves directly toward where the player is in each
    frame.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机游戏本质上是离散的。在前面的叠加序列帧的截图中，玩家被看到以微小的步伐直线向上移动屏幕。怪物的运动也是以小步伐进行的。在每个帧中，怪物都会向玩家迈出一小步。当怪物在每一帧直接向玩家所在的位置移动时，他似乎在沿着一条曲线路径移动。
- en: 'To move the monster toward the player, we first have to get the player''s position.
    Since the player is accessible in a global function, `UGameplayStatics::GetPlayerPawn`,
    we simply retrieve our pointer to the player using this function. Next we find
    the vector pointing from the `Monster` (`GetActorLocation()`) function that points
    to the player (`avatar->GetActorLocation()`). We need to find the vector that
    points from the monster to the avatar. To do this, you have to subtract the location
    of the monster from the location of the avatar, as shown in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要将怪物移动到玩家身边，我们首先需要获取玩家的位置。由于玩家可以通过全局函数 `UGameplayStatics::GetPlayerPawn` 访问，我们只需使用此函数检索我们的玩家指针。接下来，我们找到从
    `Monster` (`GetActorLocation()`) 函数指向玩家 (`avatar->GetActorLocation()`) 的向量。我们需要找到从怪物指向玩家的向量。为此，你必须从怪物的位置减去玩家的位置，如下面的截图所示：
- en: '![The discrete nature of monster motion](img/00175.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![怪物运动的离散性质](img/00175.jpeg)'
- en: 'It''s a simple math rule to remember but often easy to get wrong. To get the
    right vector, always subtract the source (the starting point) vector from the
    target (the terminal point) vector. In our system, we have to subtract the `Monster`
    vector from the `Avatar` vector. This works because subtracting the `Monster`
    vector from the system moves the `Monster` vector to the origin and the `Avatar`
    vector will be to the lower left-hand side of the `Monster` vector:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的数学规则，但很容易出错。要得到正确的向量，始终从目标（终点）向量中减去源（起点）向量。在我们的系统中，我们必须从 `Avatar` 向量中减去
    `Monster` 向量。这是因为从系统中减去 `Monster` 向量将 `Monster` 向量移动到原点，而 `Avatar` 向量将位于 `Monster`
    向量的左下角：
- en: '![The discrete nature of monster motion](img/00176.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![怪物运动的离散性质](img/00176.jpeg)'
- en: Subtracting the Monster vector from the system moves the Monster vector to (0,0)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从系统中减去怪物向量将怪物向量移动到 (0,0)
- en: 'Be sure to try out your code. At this point, the monsters will be running toward
    your player and crowding around him. With the preceding code that is outlined,
    they won''t attack; they''ll just follow him around, as shown in the following
    screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要尝试运行你的代码。到目前为止，怪物将会朝向你的玩家跑来，并围绕他聚集。按照前面的代码，它们不会攻击；它们只是跟随他，如下面的截图所示：
- en: '![The discrete nature of monster motion](img/00177.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![怪物运动的离散性质](img/00177.jpeg)'
- en: Monster SightSphere
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 怪物视野球体
- en: Right now, the monsters are not paying attention to the `SightSphere` component.
    That is, wherever the player is in the world, the monsters will move toward him
    in the current setup. We want to change that now.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，怪物没有注意到 `SightSphere` 组件。也就是说，无论玩家在世界中的哪个位置，在当前设置下，怪物都会朝向他移动。我们现在想改变这一点。
- en: To do so, all we have to do is have `Monster` respect the `SightSphere` restriction.
    If the player is inside the monster's `SightSphere` object, the monster will give
    chase. Otherwise, the monsters will be oblivious to the player's location and
    not chase the player.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们只需要让 `Monster` 尊重 `SightSphere` 限制。如果玩家位于怪物的 `SightSphere` 对象内，怪物将会追逐。否则，怪物将不会注意到玩家的位置，也不会追逐玩家。
- en: 'Checking to see if an object is inside a sphere is simple. In the following
    screenshot, the point **p** is inside the sphere if the distance **d** between
    **p** and the centroid **c** is less than the sphere radius, **r**:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 检查一个对象是否在球体内很简单。在下面的截图中，如果点 **p** 与质心 **c** 之间的距离 **d** 小于球体半径 **r**，则 **p**
    在球体内：
- en: '![Monster SightSphere](img/00178.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![怪物视野球体](img/00178.jpeg)'
- en: P is inside the sphere when d is less than r
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当 d 小于 r 时，P 在球体内
- en: 'So, in our code, the preceding screenshot translates to the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的代码中，上述截图转换为以下代码：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code adds additional intelligence to the `Monster` character.
    The `Monster` character can now stop chasing the player if the player is outside
    the monster''s `SightSphere` object. This is how the result will look:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码为 `Monster` 角色添加了额外的智能。现在，如果玩家位于怪物的 `SightSphere` 对象之外，`Monster` 角色可以停止追逐玩家。结果将如下所示：
- en: '![Monster SightSphere](img/00179.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![怪物视野球体](img/00179.jpeg)'
- en: 'A good thing to do here will be to wrap up the distance comparison into a simple
    inline function. We can provide these two inline member functions in the `Monster`
    header as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一个好的做法是将距离比较封装成一个简单的内联函数。我们可以在 `Monster` 头文件中提供这两个内联成员函数，如下所示：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These functions return the value `true` when the passed parameter, `d`, is inside
    the spheres in question.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在传递的参数 `d` 在所讨论的球体内时返回值 `true`。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: An `inline` function means that the function is more like a macro than a function.
    Macros are copied and pasted to the calling location, while functions are jumped
    to by C++ and executed at their location. Inline functions are good because they
    give good performance while keeping the code easy to read and they are reusable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数意味着这个函数更像是一个宏而不是一个函数。宏被复制粘贴到调用位置，而函数是通过C++跳转到其位置并执行的。内联函数的好处是它们提供了良好的性能，同时保持了代码的易读性，并且是可重用的。
- en: Monster attacks on the player
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 怪物对玩家的攻击
- en: There are a few different types of attacks that monsters can do. Depending on
    the type of the `Monster` character, a monster's attack might be melee (close
    range) or ranged (projectile weapon).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 怪物可以执行几种不同的攻击类型。根据`Monster`角色的类型，怪物的攻击可能是近战（近距离）或远程（投射武器）。
- en: The `Monster` character will attack the player whenever the player is in his
    `AttackRangeSphere`. If the player is out of the range of the monster's `AttackRangeSphere`
    but the player is in the `SightSphere` object of the monster, then the monster
    will move closer to the player until the player is in the monster's `AttackRangeSphere`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家在怪物的`AttackRangeSphere`内时，`Monster`角色会攻击玩家。如果玩家在怪物的`AttackRangeSphere`范围之外，但玩家在怪物的`SightSphere`对象内，那么怪物会移动到玩家附近，直到玩家进入怪物的`AttackRangeSphere`。
- en: Melee attacks
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 近战攻击
- en: The dictionary definition of *melee* is a confused mass of people. A melee attack
    is one that is done at a close range. Picture a bunch of *zerglings* battling
    it out with a bunch of *ultralisks* (if you're a *StarCraft* player, you'll know
    that both zerglings and ultralisks are melee units). Melee attacks are basically
    close range, hand-to-hand combat. To do a melee attack, you need a melee attack
    animation that turns on when the monster begins his melee attack. To do this,
    you need to edit the animation blueprint in *Persona*, UE4's animation editor.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: “近战”的字典定义是一群混乱的人群。近战攻击是在近距离进行的攻击。想象一下一群*zerglings*和一群*ultralisks*在战斗（如果你是《星际争霸》玩家，你会知道zerglings和ultralisks都是近战单位）。近战攻击基本上是近距离的肉搏战。要进行近战攻击，你需要一个在怪物开始近战攻击时启动的近战攻击动画。为此，你需要编辑*Persona*中的动画蓝图，这是UE4的动画编辑器。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Zak Parrish''s *Persona* series is an excellent place to get started with in
    order to program animations in blueprints: [https://www.youtube.com/watch?v=AqYmC2wn7Cg&list=PL6VDVOqa_mdNW6JEu9UAS_s40OCD_u6yp&index=8](https://www.youtube.com/watch?v=AqYmC2wn7Cg&list=PL6VDVOqa_mdNW6JEu9UAS_s40OCD_u6yp&index=8).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Zak Parrish的*Persona*系列是一个很好的起点，可以用来在蓝图中进行动画编程：[https://www.youtube.com/watch?v=AqYmC2wn7Cg&list=PL6VDVOqa_mdNW6JEu9UAS_s40OCD_u6yp&index=8](https://www.youtube.com/watch?v=AqYmC2wn7Cg&list=PL6VDVOqa_mdNW6JEu9UAS_s40OCD_u6yp&index=8).
- en: For now, we will just program the melee attack and then worry about modifying
    the animation in blueprints later.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需编程近战攻击，然后稍后再修改蓝图中的动画。
- en: Defining a melee weapon
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义近战武器
- en: There are going to be three parts to defining our melee weapon. The first part
    is the C++ code that represents it. The second is the model, and the third is
    to connect the code and model together using a UE4 blueprint.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 定义我们的近战武器将分为三个部分。第一部分是代表它的C++代码。第二部分是模型，第三部分是使用UE4蓝图将代码和模型连接起来。
- en: Coding for a melee weapon in C++
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: C++中的近战武器编程
- en: 'We will define a new class, `AMeleeWeapon` (derived from `AActor`), to represent
    hand-held combat weapons. I will attach a couple of blueprint-editable properties
    to the `AMeleeWeapon` class, and the `AMeleeWeapon` class will look as shown in
    the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个新的类，`AMeleeWeapon`（从`AActor`派生），来表示手持近战武器。我将在`AMeleeWeapon`类中附加一些蓝图可编辑的属性，`AMeleeWeapon`类将如下所示：
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice how I used a bounding box for `ProxBox`, and not a bounding sphere. This
    is because swords and axes will be better approximated by boxes rather than spheres.
    There are two member functions, `Rest()` and `Swing()`, which let `MeleeWeapon`
    know what state the actor is in (resting or swinging). There's also a `TArray<AActor*>
    ThingsHit` property inside this class that keeps track of the actors hit by this
    melee weapon on each swing. We are programming it so that the weapon can only
    hit each thing once per swing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我如何为`ProxBox`使用了一个边界框，而不是边界球体。这是因为剑和斧头更适合用边界框而不是球体来近似。这个类中有两个成员函数，`Rest()`和`Swing()`，它们让`MeleeWeapon`知道演员处于什么状态（休息或挥动）。在这个类内部还有一个`TArray<AActor*>
    ThingsHit`属性，它跟踪每次挥动时被这把近战武器击中的演员。我们正在编程，使得武器在每次挥动中只能击中每个东西一次。
- en: 'The `AMeleeWeapon.cpp` file will contain just a basic constructor and some
    simple code to send damages to `OtherActor` when our sword hits him. We will also
    implement the `Rest()` and `Swing()` functions to clear the list of things hit.
    The `MeleeWeapon.cpp` file has the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`AMeleeWeapon.cpp` 文件将只包含一个基本的构造函数和一些简单的代码，用于当我们的剑击中敌人时向 `OtherActor` 发送伤害。我们还将实现
    `Rest()` 和 `Swing()` 函数来清除被击中的物品列表。`MeleeWeapon.cpp` 文件有以下代码：'
- en: '[PRE7]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Downloading a sword
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 下载剑模型
- en: 'To complete this exercise, we need a sword to put into the model''s hand. I
    added a sword to the project called *Kilic* from [http://tf3dm.com/3d-model/sword-95782.html](http://tf3dm.com/3d-model/sword-95782.html)
    by Kaan Gülhan. The following is a list of other places where you will get free
    models:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个练习，我们需要一把剑放入模型的手中。我从 [http://tf3dm.com/3d-model/sword-95782.html](http://tf3dm.com/3d-model/sword-95782.html)
    的 Kaan Gülhan 的项目中添加了一把名为 *Kilic* 的剑。以下是你将获得免费模型的其他地方列表：
- en: '[http://www.turbosquid.com/](http://www.turbosquid.com/)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.turbosquid.com/](http://www.turbosquid.com/)'
- en: '[http://tf3dm.com/](http://tf3dm.com/)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://tf3dm.com/](http://tf3dm.com/)'
- en: '[http://archive3d.net/](http://archive3d.net/)'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://archive3d.net/](http://archive3d.net/)'
- en: '[http://www.3dtotal.com/](http://www.3dtotal.com/)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.3dtotal.com/](http://www.3dtotal.com/)'
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Secret tip**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**秘密提示**'
- en: It might appear at first on [TurboSquid.com](http://TurboSquid.com) that there
    are no free models. In fact, the secret is that you have to search in the price
    range $0-$0 to find them. $0 means free.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [TurboSquid.com](http://TurboSquid.com) 上，一开始可能看起来没有免费模型。实际上，秘密在于你必须搜索价格范围
    $0-$0 来找到它们。$0 表示免费。
- en: '![Downloading a sword](img/00180.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![下载剑模型](img/00180.jpeg)'
- en: TurboSquid's search for free swords
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: TurboSquid 搜索免费剑模型
- en: I had to edit the *kilic* sword mesh slightly to fix the initial sizing and
    rotation. You can import any mesh in the **Filmbox** (**FBX**) format into your
    game. The kilic sword model is in the sample code package for [Chapter 11](part0076_split_000.html#28FAO1-dd4a3f777fc247568443d5ffb917736d
    "Chapter 11. Monsters"), *Monsters*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我不得不稍微编辑一下 *kilic* 剑网格以修复初始尺寸和旋转。你可以将任何 **Filmbox** （**FBX**） 格式的网格导入到你的游戏中。kilic
    剑模型位于第 11 章（part0076_split_000.html#28FAO1-dd4a3f777fc247568443d5ffb917736d "第
    11 章. 怪物"）的示例代码包中，*怪物*。
- en: To import your sword into the UE4 editor, right-click on any folder you want
    to add the model to. Navigate to **New Asset** | **Import to** | **Game** | **Models...**,
    and from the file explorer that pops up, select the new asset you want to import.
    If a **Models** folder doesn't exist, you can create one by simply right-clicking
    on the tree view at the left and selecting **New Folder** in the pane on the left-hand
    side of the **Content Browser** tab. I selected the `kilic.fbx` asset from my
    desktop.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要将你的剑导入到 UE4 编辑器中，右键单击你想要添加模型的任何文件夹。导航到 **新建资产** | **导入到** | **游戏** | **模型...**，然后从弹出的文件资源管理器中选择你想要导入的新资产。如果不存在
    **模型** 文件夹，你可以通过在左侧的树视图中右键单击并选择 **内容浏览器** 选项卡左侧面板中的 **新建文件夹** 来创建一个。我选择了来自桌面的
    `kilic.fbx` 资产。
- en: '![Downloading a sword](img/00181.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![下载剑模型](img/00181.jpeg)'
- en: Importing to your project
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将模型导入到你的项目中
- en: Creating a blueprint for your melee weapon
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为你的近战武器创建蓝图
- en: 'Inside the UE4 editor, create a blueprint based off of `AMeleeWeapon` called
    `BP_MeleeSword`. Configure `BP_MeleeSword` to use the *kilic* blade model (or
    any blade model you choose), as shown in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UE4 编辑器内部，创建一个基于 `AMeleeWeapon` 的蓝图，命名为 `BP_MeleeSword`。配置 `BP_MeleeSword`
    以使用 *kilic* 刀刃模型（或你选择的任何刀刃模型），如下面的截图所示：
- en: '![Creating a blueprint for your melee weapon](img/00182.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![为你的近战武器创建蓝图](img/00182.jpeg)'
- en: 'The `ProxBox` class will determine whether something was hit by the weapon,
    so we will modify the `ProxBox` class such that it just encloses the blade of
    the sword, as shown in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProxBox` 类将确定是否被武器击中，因此我们将修改 `ProxBox` 类，使其仅包围剑的刀刃，如下面的截图所示：'
- en: '![Creating a blueprint for your melee weapon](img/00183.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![为你的近战武器创建蓝图](img/00183.jpeg)'
- en: 'Also, under the **Collision Presets** panel, it is important to select the
    **NoCollision** option for the mesh (not **BlockAll**). This is illustrated in
    the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 **碰撞预设** 面板下，选择网格的 **无碰撞** 选项（而不是 **阻止所有**）非常重要。以下截图展示了这一点：
- en: '![Creating a blueprint for your melee weapon](img/00184.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![为你的近战武器创建蓝图](img/00184.jpeg)'
- en: If you select **BlockAll**, then the game engine will automatically resolve
    all the interpenetration between the sword and the characters by pushing away
    things that the sword touches whenever it is swung. The result is that your characters
    will appear to go flying whenever a sword is swung.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择**BlockAll**，那么游戏引擎将自动解决剑和角色之间的所有穿透问题，通过在挥剑时推开剑接触到的任何东西。结果是，每当挥剑时，你的角色看起来就像要飞起来一样。
- en: Sockets
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插槽
- en: A socket in UE4 is a receptacle on one skeletal mesh for another `Actor`. You
    can place a socket anywhere on a skeletal mesh body. After you have correctly
    placed the socket, you can attach another `Actor` to this socket in UE4 code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中，插槽是一个骨骼网格上的用于另一个`Actor`的容器。你可以在骨骼网格身体上的任何位置放置插槽。在你正确放置插槽后，你可以在UE4代码中将另一个`Actor`附加到这个插槽上。
- en: For example, if we want to put a sword in our monster's hand, we'd just have
    to create a socket in our monster's hand. We can attach a helmet to the player
    by creating a socket on his head.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在怪物手中放置一把剑，我们只需在怪物手中创建一个插槽即可。我们可以在玩家头部创建一个插槽来为玩家戴上头盔。
- en: Creating a skeletal mesh socket in the monster's hand
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在怪物手中创建骨骼网格插槽
- en: To attach a socket to the monster's hand, we have to edit the skeletal mesh
    that the monster is using. Since we used the `Mixamo_Adam` skeletal mesh for the
    monster, we have to open and edit this skeletal mesh.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要将插槽附加到怪物手中，我们必须编辑怪物使用的骨骼网格。由于我们为怪物使用了`Mixamo_Adam`骨骼网格，我们必须打开并编辑这个骨骼网格。
- en: To do so, double-click on the **Mixamo_Adam** skeletal mesh in the **Content
    Browser** tab (this will appear as the T-pose) to open the skeletal mesh editor.
    If you don't see **Mixamo Adam** in your **Content Browser** tab, make sure that
    you have imported the **Mixamo Animation Pack** file into your project from the
    Unreal Launcher app.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，在**内容浏览器**选项卡中双击**Mixamo_Adam**骨骼网格（这将显示为T姿势）以打开骨骼网格编辑器。如果你在**内容浏览器**选项卡中没有看到**Mixamo
    Adam**，请确保你已经从Unreal Launcher应用程序中将**Mixamo Animation Pack**文件导入到你的项目中。
- en: '![Creating a skeletal mesh socket in the monster''s hand](img/00185.jpeg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![在怪物手中创建骨骼网格插槽](img/00185.jpeg)'
- en: Edit the Maximo_Adam mesh by double-clicking on the Maximo_Adam skeletal mesh
    object
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过双击Maximo_Adam骨骼网格对象来编辑Maximo_Adam网格
- en: 'Click on **Skeleton** at the top-right corner of the screen. Scroll down the
    tree of bones in the left-hand side panel until you find the **RightHand** bone.
    We will attach a socket to this bone. Right-click on the **RightHand** bone and
    select **Add Socket**, as shown in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 点击屏幕右上角的**骨骼**。在左侧面板中的骨骼树中向下滚动，直到找到**RightHand**骨骼。我们将在这个骨骼上添加一个插槽。在**RightHand**骨骼上右键单击并选择**添加插槽**，如下面的截图所示：
- en: '![Creating a skeletal mesh socket in the monster''s hand](img/00186.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![在怪物手中创建骨骼网格插槽](img/00186.jpeg)'
- en: 'You can leave the default name (**RightHandSocket**) or rename the socket if
    you like, as shown in the following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以保留默认名称（**RightHandSocket**）或者如果你喜欢的话，可以重命名插槽，如下面的截图所示：
- en: '![Creating a skeletal mesh socket in the monster''s hand](img/00187.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![在怪物手中创建骨骼网格插槽](img/00187.jpeg)'
- en: Next, we need to add a sword to the actor's hand.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在演员的手中添加一把剑。
- en: Attaching the sword to the model
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将剑附加到模型
- en: 'With the Adam skeletal mesh open, find the **RightHandSocket** option in the
    tree view. Since Adam swings with his right hand, you should attach the sword
    to his right hand. Drag and drop your sword model into the **RightHandSocket**
    option. You should see Adam grip the sword in the image of the model at the right-hand
    side of the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开亚当骨骼网格后，在树视图中找到**RightHandSocket**选项。由于亚当用右手挥剑，你应该将剑附加到他的右手。将你的剑模型拖放到**RightHandSocket**选项中。你应该在以下截图右侧的模型图像中看到亚当握住剑：
- en: '![Attaching the sword to the model](img/00188.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![将剑附加到模型](img/00188.jpeg)'
- en: Now, click on **RightHandSocket** and zoom in on Adam's hand. We need to adjust
    the positioning of the socket in the preview so that the sword fits in it correctly.
    Use the move and rotate manipulators to line the sword up so that it fits in his
    hand correctly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击**RightHandSocket**并放大亚当的手。我们需要调整预览中插槽的位置，以便剑能够正确地放入其中。使用移动和旋转操纵杆调整剑的位置，使其正确地放入他的手中。
- en: '![Attaching the sword to the model](img/00189.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![将剑附加到模型](img/00189.jpeg)'
- en: Positioning the socket in the right hand so that the sword rests correctly
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将插槽定位在右手，使剑正确放置
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '**A real-world tip**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**现实世界技巧**'
- en: If you have several sword models that you want to switch in and out of the same
    **RightHandSocket**, you will need to ensure quite a bit of uniformity (lack of
    anomalies) between the different swords that are supposed to go in that same socket.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在同一个**RightHandSocket**中切换多个剑模型，你需要确保这些剑之间有相当程度的统一性（没有异常）。
- en: You can preview your animations with the sword in the hand by going to the **Animation**
    tab in the top-right corner of the screen.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过转到屏幕右上角的**动画**选项卡来预览手持剑的动画。
- en: '![Attaching the sword to the model](img/00190.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![将剑附加到模型上](img/00190.jpeg)'
- en: Equipping the model with a sword
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为模型装备剑
- en: However, if you launch your game, Adam won't be holding a sword. That's because
    adding the sword to the socket in *Persona* is for preview purposes only.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你启动游戏，亚当将不会手持剑。这是因为将剑添加到*Persona*中的插槽只是为了预览。
- en: Code to equip the player with a sword
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为玩家装备剑的代码
- en: To equip your player with a sword from the code and permanently bind it to the
    actor, instantiate an `AMeleeWeapon` instance and attach it to `RightHandSocket`
    after the monster instance is initialized. We do this in `PostInitializeComponents()`
    since in this function the `Mesh` object will have been fully initialized already.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要从代码中为玩家装备剑并将其永久绑定到actor，实例化一个`AMeleeWeapon`实例，并在怪物实例初始化后将其附加到`RightHandSocket`。我们在`PostInitializeComponents()`中这样做，因为在这个函数中，`Mesh`对象已经完全初始化。
- en: 'In the `Monster.h` file, add a hook to select the **Blueprint** class name
    (`UClass`) of a melee weapon to use. Also add a hook for a variable to actually
    store the `MeleeWeapon` instance using the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Monster.h`文件中，添加一个钩子来选择用于的近战武器的**蓝图**类名（`UClass`）。同时添加一个钩子来存储`MeleeWeapon`实例的变量，使用以下代码：
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, select the `BP_MeleeSword` blueprint in your monster's blueprint class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的怪物蓝图类中选择`BP_MeleeSword`蓝图。
- en: 'In the C++ code, you need to instantiate the weapon. To do so, we need to declare
    and implement a `PostInitializeComponents` function for the `Monster` class. In
    `Monster.h`, add a prototype declaration:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++代码中，你需要实例化这个武器。为此，我们需要为`Monster`类声明并实现一个`PostInitializeComponents`函数。在`Monster.h`文件中，添加一个原型声明：
- en: '[PRE9]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`PostInitializeComponents` runs after the monster object''s constructor has
    completed and all the components of the object are initialized (including the
    blueprint construction). So it is the perfect time to check whether the monster
    has a `MeleeWeapon` blueprint attached to it or not and to instantiate this weapon
    if it does. The following code is added to instantiate the weapon in the `Monster.cpp`
    implementation of `AMonster::PostInitializeComponents()`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostInitializeComponents`在怪物对象的构造函数完成后运行，并且所有对象组件都已初始化（包括蓝图构造）。因此，这是检查怪物是否附有`MeleeWeapon`蓝图以及实例化该武器的完美时机。以下代码添加到`Monster.cpp`实现中的`AMonster::PostInitializeComponents()`以实例化武器：'
- en: '[PRE10]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The monsters will now start with swords in hand if `BPMeleeWeapon` is selected
    for that monster's blueprint.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为该怪物的蓝图选择了`BPMeleeWeapon`，那么怪物现在将手持剑开始。
- en: '![Code to equip the player with a sword](img/00191.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![为玩家装备剑的代码](img/00191.jpeg)'
- en: Monsters holding weapons
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 持有武器的怪物
- en: Triggering the attack animation
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发攻击动画
- en: By default, there is no connection between our C++ `Monster` class and triggering
    the attack animation; in other words, the `MixamoAnimBP_Adam` class has no way
    of knowing when the monster is in the attack state.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的C++ `Monster`类与触发攻击动画之间没有连接；换句话说，`MixamoAnimBP_Adam`类没有方法知道怪物是否处于攻击状态。
- en: Therefore, we need to update the animation blueprint of the Adam skeleton (`MixamoAnimBP_Adam`)
    to include a query in the `Monster` class variable listing and check whether the
    monster is in an attacking state. We haven't worked with animation blueprints
    (or blueprints in general) in this book before, but follow it step by step and
    you should see it come together.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要更新亚当骨骼的动画蓝图（`MixamoAnimBP_Adam`），以包括在`Monster`类变量列表中的查询，并检查怪物是否处于攻击状态。我们在这本书中之前还没有处理过动画蓝图（或蓝图），但按照步骤一步一步来，你应该会看到它整合在一起。
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I will introduce blueprints terminology gently here, but I will encourage you
    to have a look at Zak Parrish's tutorial series at [https://www.youtube.com/playlist?list=PLZlv_N0_O1gbYMYfhhdzfW1tUV4jU0YxH](https://www.youtube.com/playlist?list=PLZlv_N0_O1gbYMYfhhdzfW1tUV4jU0YxH)
    for your first introduction to blueprints.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里会温和地介绍蓝图术语，但我鼓励你查看Zak Parrish的教程系列，以了解蓝图的入门知识：[https://www.youtube.com/playlist?list=PLZlv_N0_O1gbYMYfhhdzfW1tUV4jU0YxH](https://www.youtube.com/playlist?list=PLZlv_N0_O1gbYMYfhhdzfW1tUV4jU0YxH)。
- en: Blueprint basics
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 蓝图基础
- en: A UE4 blueprint is a visual realization of the code (not to be confused with
    how sometimes people say that a C++ class is a metaphorical blueprint of a class
    instance). In UE4 blueprints, instead of actually writing code, you drag and drop
    elements onto a graph and connect them to achieve desired play. By connecting
    the right nodes to the right elements, you can program anything you want in your
    game.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: UE4蓝图是代码的视觉实现（不要与人们有时所说的C++类是类实例的隐喻性蓝图混淆）。在UE4蓝图中，你不需要实际编写代码，而是将元素拖放到图上，并将它们连接起来以实现所需的播放。通过将正确的节点连接到正确的元素，你可以在游戏中编程任何你想要的东西。
- en: Tip
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This book does not encourage the use of blueprints since we are trying to encourage
    you to write your own code instead. Animations, however, are best worked with
    blueprints, because that is what artists and designers will know.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不鼓励使用蓝图，因为我们正在努力鼓励你编写自己的代码。然而，动画最好用蓝图来完成，因为这是艺术家和设计师所熟悉的。
- en: 'Let''s start writing a sample blueprint to get a feel how they work. First,
    click on the blueprint menu bar at the top and select **Open Level Blueprint**,
    as shown in the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个示例蓝图，以了解它们是如何工作的。首先，点击顶部的蓝图菜单栏，然后选择**打开关卡蓝图**，如下面的截图所示：
- en: '![Blueprint basics](img/00192.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图基础](img/00192.jpeg)'
- en: 'The **Level Blueprint** option executes automatically when you begin the level.
    Once you open this window, you should see a blank slate to create your gameplay
    on, as shown here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**关卡蓝图**选项在开始关卡时自动执行。一旦你打开这个窗口，你应该会看到一个空白画布，你可以在这里创建你的游戏玩法，如下所示：'
- en: '![Blueprint basics](img/00193.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图基础](img/00193.jpeg)'
- en: 'Right-click anywhere on the graph paper. Start typing `begin` and click on
    the **Event Begin Play** option from the drop-down list that appears. Ensure that
    the **Context Sensitive** checkbox is checked, as shown in the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在图纸上任何地方右键单击。开始键入`begin`，然后从出现的下拉列表中选择**事件开始播放**选项。确保勾选了**上下文相关**复选框，如下面的截图所示：
- en: '![Blueprint basics](img/00194.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图基础](img/00194.jpeg)'
- en: 'Immediately after you click on the **Event Begin Play** option, a red box will
    appear on your screen. It has a single white pin at the right-hand side. This
    is called the execution pin, as shown here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 立即点击**事件开始播放**选项后，你的屏幕上会出现一个红色框。它右侧有一个单独的白色引脚。这被称为执行引脚，如下所示：
- en: '![Blueprint basics](img/00195.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图基础](img/00195.jpeg)'
- en: 'The first thing that you need to know about animation blueprints is the white
    pin execution path (the white line). If you''ve seen a blueprint graph before,
    you must have noticed a white line going through the graph, as shown in the following
    diagram:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 关于动画蓝图，你需要知道的第一件事是白色引脚执行路径（即白色线条）。如果你之前见过蓝图图，你一定注意到了一条穿过图的白色线条，如下面的图所示：
- en: '![Blueprint basics](img/00196.jpeg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图基础](img/00196.jpeg)'
- en: The white pin execution path is pretty much equivalent to having lines of code
    lined up and run one after the other. The white line determines which nodes will
    get executed and in what order. If a node does not have a white execution pin
    attached to it, then that node will not get executed at all.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 白色引脚执行路径基本上等同于有一行行代码依次运行。白色线条决定了哪些节点将被执行以及执行顺序。如果一个节点没有连接白色执行引脚，那么该节点将根本不会执行。
- en: 'Drag off the white execution pin from **Event Begin Play**. Start by typing
    `draw debug box` in the **Executable actions** dialog. Select the first thing
    that pops up (**f** **Draw Debug Box**), as shown here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从**事件开始播放**拖出白色执行引脚。首先在**可执行动作**对话框中键入`draw debug box`。选择弹出的第一个选项（**f** **绘制调试框**），如下所示：
- en: '![Blueprint basics](img/00197.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图基础](img/00197.jpeg)'
- en: 'Fill in some details for how you want the box to look. Here, I selected the
    color blue for the box, the center of the box at (0, 0, 100), the size of the
    box to be (200, 200, 200), and a duration of 180 seconds (be sure to enter a duration
    that is long enough to see the result), as shown in the following screenshot:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 填写一些关于你想要盒子看起来怎样的细节。在这里，我选择了蓝色作为盒子的颜色，盒子的中心在 (0, 0, 100)，盒子的大小为 (200, 200, 200)，持续时间为
    180 秒（务必输入足够长的时间以看到结果），如下面的截图所示：
- en: '![Blueprint basics](img/00198.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图基础](img/00198.jpeg)'
- en: Now click on the **Play** button to realize the graph. Remember that you have
    to find the world's origin to see the debug box.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击 **播放** 按钮以实现图表。记住，你必须找到世界原点才能看到调试框。
- en: 'Find the world''s origin by placing a golden egg at (0, 0, (some z value)),
    as shown in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将一个金色鸡蛋放置在 (0, 0, (某个 z 值)) 来找到世界原点，如下面的截图所示：
- en: '![Blueprint basics](img/00199.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图基础](img/00199.jpeg)'
- en: 'This is how the box will look in the level:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是盒子在关卡中的样子：
- en: '![Blueprint basics](img/00200.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图基础](img/00200.jpeg)'
- en: A debug box rendered at the origin
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在原点渲染的调试框
- en: Modifying the animation blueprint for Mixamo Adam
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改 Mixamo Adam 的动画蓝图
- en: To integrate our attack animation, we have to modify the blueprint. Under **Content
    Browser**, open up `MixamoAnimBP_Adam`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成我们的攻击动画，我们必须修改蓝图。在 **内容浏览器** 中打开 `MixamoAnimBP_Adam`。
- en: 'The first thing you''ll notice is that the graph has two sections: a top section
    and a bottom section. The top section is marked "**Basic Character movement**...,"
    while the bottom section says "**Mixamo Example Character Animation**...." Basic
    character movement is in charge of the walking and running movements of the model.
    We will be working in the **Mixamo Example Character Animation with Attack and
    Jump** section, which is responsible for the attack animation. We will be working
    in the latter section of the graph, shown in the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到图表分为两个部分：一个顶部部分和一个底部部分。顶部部分标记为 "**基本角色移动**..."，而底部部分说 "**Mixamo 示例角色动画**...."
    基本角色移动负责模型的行走和跑步动作。我们将工作在 **带有攻击和跳跃的 Mixamo 示例角色动画** 部分，该部分负责攻击动画。我们将工作在图表的后半部分，如下面的截图所示：
- en: '![Modifying the animation blueprint for Mixamo Adam](img/00201.jpeg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![修改 Mixamo Adam 的动画蓝图](img/00201.jpeg)'
- en: When you first open the graph, it starts out by zooming in on a section near
    the bottom. To scroll up, right-click the mouse and drag it upwards. You can also
    zoom out using the mouse wheel or by holding down the *Alt* key and the right
    mouse button while moving the mouse up.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次打开图表时，它最初会放大靠近底部的某个部分。要向上滚动，右键单击鼠标并向上拖动。你还可以使用鼠标滚轮或按住 *Alt* 键和右鼠标按钮同时向上移动鼠标来缩小。
- en: Before proceeding, you might want to duplicate the **MixamoAnimBP_Adam** resource
    so that you don't damage the original, in case you need to go back and change
    something later. This allows you to easily go back and correct things if you find
    that you've made a mistake in one of your modifications, without having to reinstall
    a fresh copy of the whole animation package into your project.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可能想要复制 **MixamoAnimBP_Adam** 资源，以免损坏原始资源，以防你需要稍后返回并更改某些内容。这允许你在发现你在修改中犯了一个错误时，可以轻松返回并纠正，而无需在你的项目中重新安装整个动画包的新副本。
- en: '![Modifying the animation blueprint for Mixamo Adam](img/00202.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![修改 Mixamo Adam 的动画蓝图](img/00202.jpeg)'
- en: Making a duplicate of the MixamoAnimBP_Adam resource to avoid damaging the original
    asset
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 制作 MixamoAnimBP_Adam 资源的副本以避免损坏原始资产
- en: Tip
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When assets are added to a project from the Unreal Launcher, a copy of the original
    asset is made, so you can modify **MixamoAnimBP_Adam** in your project now and
    get a fresh copy of the original assets in a new project later.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 Unreal Launcher 向项目中添加资产时，会创建原始资产的副本，因此你现在可以修改项目中的 **MixamoAnimBP_Adam**，并在稍后在新项目中获取原始资产的新副本。
- en: We're going to do only a few things to make Adam swing the sword when he is
    attacking. Let's do it in order.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只做几件事情，让 Adam 在攻击时挥舞剑。让我们按顺序来做。
- en: Deleting the node that says **Attacking?**:![Modifying the animation blueprint
    for Mixamo Adam](img/00203.jpeg)
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除标记为 **攻击？** 的节点：![修改 Mixamo Adam 的动画蓝图](img/00203.jpeg)
- en: Rearrange the nodes, as follows, with the **Enable Attack** node by itself at
    the bottom:![Modifying the animation blueprint for Mixamo Adam](img/00204.jpeg)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新排列节点，如下所示，将 **启用攻击** 节点单独放在底部：![修改 Mixamo Adam 的动画蓝图](img/00204.jpeg)
- en: Next we're going to handle the monster that this animation is animating. Scroll
    up the graph a bit and drag the blue dot marked as **Return Value** in the **Try
    Get Pawn Owner** dialog. Drop it into your graph, and when the pop-up menu appears,
    select **Cast to Monster** (ensure that **Context Sensitive** is checked, or the
    **Cast to Monster** option will not appear). The **Try Get Pawn Owner** option
    gets the `Monster` instance that owns the animation, which is just the `AMonster`
    class object, as shown in the following screenshot:![Modifying the animation blueprint
    for Mixamo Adam](img/00205.jpeg)
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将处理这个动画所动画化的怪物。将图表向上滚动一点，并将**尝试获取Pawn所有者**对话框中标记为**返回值**的蓝色点拖动到您的图表中。当弹出菜单出现时，选择**投射到怪物**（确保已勾选**上下文相关**，否则**投射到怪物**选项将不会出现）。**尝试获取Pawn所有者**选项获取拥有动画的`Monster`实例，它只是`AMonster`类对象，如图所示：![修改Mixamo
    Adam的动画蓝图](img/00205.jpeg)
- en: Click on **+** in the **Sequence** dialog and drag another execution pin from
    the **Sequence** group to the **Cast to Monster** node instance, as shown in the
    following screenshot. This ensures that the **Cast to Monster** instance actually
    gets executed.![Modifying the animation blueprint for Mixamo Adam](img/00206.jpeg)
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**序列**对话框中点击**+**，并将来自**序列**组的另一个执行引脚拖动到**投射到怪物**节点实例上，如图所示。这确保了**投射到怪物**实例实际上会被执行。![修改Mixamo
    Adam的动画蓝图](img/00206.jpeg)
- en: The next step is to pull out the pin from the **As Monster** terminal of the
    **Cast to Monster** node and look for the **Is in Attack Range Of Player** property:![Modifying
    the animation blueprint for Mixamo Adam](img/00207.jpeg)
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是从**投射到怪物**节点的**As Monster**端子拉出引脚，并查找**是否在玩家攻击范围内**属性：![修改Mixamo Adam的动画蓝图](img/00207.jpeg)
- en: Take the white execution pin from the **Cast to Monster** node at the left-hand
    side and drop it into the **Is in Attack Range Of Player** node at the right-hand
    side:![Modifying the animation blueprint for Mixamo Adam](img/00208.jpeg)
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将来自**投射到怪物**节点左侧的白色执行引脚拖放到右侧的**是否在玩家攻击范围内**节点上：![修改Mixamo Adam的动画蓝图](img/00208.jpeg)
- en: This ensures a transfer of control from the **Cast to Monster** operation to
    the **Is in Attack Range Of Player** node.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这确保了从**投射到怪物**操作到**是否在玩家攻击范围内**节点的控制权转移。
- en: Pull the white and red pins over to the **SET** node, as shown here:![Modifying
    the animation blueprint for Mixamo Adam](img/00209.jpeg)
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将白色和红色引脚拖到**SET**节点上，如图所示：![修改Mixamo Adam的动画蓝图](img/00209.jpeg)
- en: Tip
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The equivalent pseudocode of the preceding blueprint is something similar to
    the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 上述蓝图的等效伪代码类似于以下内容：
- en: '[PRE11]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Test your animation. The monster should swing only when he is within the player's
    range.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 测试您的动画。怪物应该只在玩家范围内挥剑。
- en: Code to swing the sword
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挥剑的代码
- en: 'We want to add an animation notify event when the sword is swung. First, declare
    and add a blueprint callable C++ function to your `Monster` class:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在挥剑时添加一个动画通知事件。首先，在您的`Monster`类中声明并添加一个蓝图可调用的C++函数：
- en: '[PRE12]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `BlueprintCallable` statement means that it will be possible to call this
    function from blueprints. In other words, `SwordSwung()` will be a C++ function
    that we can invoke from a blueprints node, as shown here:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlueprintCallable`语句意味着它将可以从蓝图中进行调用。换句话说，`SwordSwung()`将是一个我们可以从蓝图节点调用的C++函数，如图所示：'
- en: '[PRE13]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next open the **Mixamo_Adam_Sword_Slash** animation by double-clicking on it
    from your **Content Browser** (it should be in **MixamoAnimPack/Mixamo_Adam/Anims/Mixamo_Adam_Sword_Slash**).
    Scrub the animation to the point where Adam starts swinging his sword. Right-click
    on the animation bar and select **New Notify** under **Add Notify...**, as shown
    in the following screenshot:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过双击**内容浏览器**中的**Mixamo_Adam_Sword_Slash**动画来打开它（它应该在**MixamoAnimPack/Mixamo_Adam/Anims/Mixamo_Adam_Sword_Slash**）。将动画拖动到Adam开始挥剑的位置。右键单击动画栏，在**添加通知...**下选择**新建通知**，如图所示：
- en: '![Code to swing the sword](img/00210.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![挥剑的代码](img/00210.jpeg)'
- en: 'Name the notification `SwordSwung`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 将通知命名为`SwordSwung`：
- en: '![Code to swing the sword](img/00211.jpeg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![挥剑的代码](img/00211.jpeg)'
- en: 'The notification name should appear in your animation''s timeline, shown as
    follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通知名称应出现在您的动画时间轴上，如下所示：
- en: '![Code to swing the sword](img/00212.jpeg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![挥剑的代码](img/00212.jpeg)'
- en: 'Save the animation and then open up your version of **MixamoAnimBP_Adam** again.
    Underneath the **SET** group of nodes, create the following graph:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 保存动画后，再次打开你的**MixamoAnimBP_Adam**版本。在**SET**节点组下方，创建以下图：
- en: '![Code to swing the sword](img/00213.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![挥剑的代码](img/00213.jpeg)'
- en: The **AnimNotify_SwordSwung** node appears when you right-click in the graph
    (with **Context Sensitive** turned on) and start typing `SwordSwung`. The **Cast
    To Monster** node is again fed in from the **Try Get Pawn Owner** node as in step
    2 of the *Modifying the animation blueprint for Mixamo Adam* section. Finally,
    **Sword Swung** is our blueprint-callable C++ function in the `AMonster` class.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在图中右键单击（**上下文相关**已打开）并开始键入`SwordSwung`时，会出现**AnimNotify_SwordSwung**节点。**Cast
    To Monster**节点再次从**Try Get Pawn Owner**节点中输入，正如*修改Mixamo Adam动画蓝图*部分的第2步中所述。最后，**Sword
    Swung**是我们`AMonster`类中的蓝图可调用的C++函数。
- en: If you start the game now, your monsters will execute their attack animation
    whenever they actually attack. When the sword's bounding box comes in contact
    with you, you should see your HP bar go down a bit (recall that the HP bar was
    added at the end of [Chapter 8](part0056_split_000.html#1LCVG1-dd4a3f777fc247568443d5ffb917736d
    "Chapter 8. Actors and Pawns"), *Actors and Pawns*, as an exercise).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在开始游戏，你的怪物将在它们实际攻击时执行攻击动画。当剑的边界框与你接触时，你应该看到你的生命值条下降一点（回想一下，生命值条是在[第8章](part0056_split_000.html#1LCVG1-dd4a3f777fc247568443d5ffb917736d
    "第8章。演员和实体")，*演员和实体*部分作为练习添加的）。
- en: '![Code to swing the sword](img/00214.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![挥剑的代码](img/00214.jpeg)'
- en: Monsters attacking the player
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 怪物攻击玩家
- en: Projectile or ranged attacks
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹射或远程攻击
- en: Ranged attacks usually involve a projectile of some sort. Projectiles are things
    such as bullets, but they can also include things such as lightning magic attacks
    or fireball attacks. To program a projectile attack, you should spawn a new object
    and only apply the damage to the player if the projectile reaches the player.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 远程攻击通常涉及某种弹射物。弹射物可以是子弹，也可以是闪电魔法攻击或火球攻击等。要编程弹射攻击，你应该生成一个新的对象，并且只有当弹射物到达玩家时才对玩家造成伤害。
- en: 'To implement a basic bullet in UE4, we should derive a new object type. I derived
    a `ABullet` class from the `AActor` class, as shown in the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要在UE4中实现基本的子弹，我们应该派生一个新的对象类型。我从`AActor`类派生了一个`ABullet`类，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ABullet` class has a couple of important members in it, as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`ABullet`类中有几个重要的成员，如下所示：'
- en: A `float` variable for the damage that a bullet does on contact
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于子弹接触时造成的伤害的`float`变量
- en: A `Mesh` variable for the body of the bullet
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子弹的`Mesh`变量
- en: A `ProxSphere` variable to detect when the bullet finally hits something
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于检测子弹最终击中某物的`ProxSphere`变量
- en: A function to be run when `Prox` near an object is detected
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当检测到`Prox`接近一个对象时要运行的功能
- en: 'The constructor for the `ABullet` class should have the initialization of the
    `Mesh` and `ProxSphere` variables. In the constructor, we set `RootComponent`
    to being the `Mesh` variable and then attach the `ProxSphere` variable to the
    `Mesh` variable. The `ProxSphere` variable will be used for collision checking,
    and collision checking for the `Mesh` variable should be turned off, as shown
    in the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`ABullet`类的构造函数应该初始化`Mesh`和`ProxSphere`变量。在构造函数中，我们将`RootComponent`设置为`Mesh`变量，然后将`ProxSphere`变量附加到`Mesh`变量上。`ProxSphere`变量将用于碰撞检测，并且应该关闭`Mesh`变量的碰撞检测，如下面的代码所示：'
- en: '[PRE15]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We initialized the `Damage` variable to `1` in the constructor, but this can
    be changed in the UE4 editor once we create a blueprint out of the `ABullet` class.
    Next, the `ABullet::Prox_Implementation()` function should deal damages to the
    actor hit if we collide with the other actor''s `RootComponent`, using the following
    code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构造函数中将`Damage`变量初始化为`1`，但一旦我们从`ABullet`类创建蓝图，就可以在UE4编辑器中更改它。接下来，`ABullet::Prox_Implementation()`函数应该在我们与其他演员的`RootComponent`发生碰撞时对被击中的演员造成伤害，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Bullet physics
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子弹物理
- en: To make bullets fly through the level, you can use UE4's physics engine.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要让子弹在关卡中飞行，你可以使用UE4的物理引擎。
- en: Create a blueprint based on the `ABullet` class. I selected **Shape_Sphere**
    for the mesh. The bullet's mesh should not have collision physics enabled; instead
    we'll enable physics on the bullet's bounding sphere.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 基于`ABullet`类创建一个蓝图。我选择了**Shape_Sphere**作为网格。子弹的网格不应该启用碰撞物理；相反，我们将启用子弹边界球的物理。
- en: 'Configuring the bullet to behave properly is mildly tricky, so we''ll cover
    this in four steps, as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 配置子弹以正确行为稍微有些棘手，所以我们将在以下四个步骤中介绍：
- en: Select **[ROOT] ProxSphere** in the **Components** tab. The `ProxSphere` variable
    should be the root component and should appear at the top of the hierarchy.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**组件**选项卡中选择**[ROOT] ProxSphere**。`ProxSphere`变量应该是根组件，并且应该出现在层次结构的顶部。
- en: In the **Details** tab, check both **Simulate Physics** and **Simulation Generates
    Hit Events**.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息**选项卡中，勾选**模拟物理**和**模拟生成碰撞事件**。
- en: From the **Collision Presets** dropdown, select **Custom…**.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**碰撞预设**下拉菜单中选择**自定义…**。
- en: Check the **Collision Responses** boxes as shown; check **Block** for most types
    (**WorldStatic**, **WorldDynamic**, and so on) and check **Overlap** only for
    **Pawn**:![Bullet physics](img/00215.jpeg)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式检查**碰撞响应**框；对于大多数类型（**WorldStatic**、**WorldDynamic**等）检查**Block**，仅对于**Pawn**检查**Overlap**：![子弹物理](img/00215.jpeg)
- en: The **Simulate Physics** checkbox makes the `ProxSphere` property experience
    gravity and the impulse forces exerted on it. An impulse is a momentary thrust
    of force, which we'll use to drive the shot of the bullet. If you do not check
    the **Simulation Generate Hit Events** checkbox, then the ball will drop on the
    floor. What **BlockAll Collision Preset** does is ensure that the ball can't pass
    through anything.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟物理**复选框使`ProxSphere`属性感受到重力和作用在其上的冲量力。冲量是一瞬间的力推，我们将用它来驱动子弹的射击。如果你不勾选**模拟生成碰撞事件**复选框，那么球体将掉落在地板上。**BlockAll
    Collision Preset**的作用是确保球体不能穿过任何东西。'
- en: 'If you drag and drop a couple of these `BP_Bullet` objects from the **Content
    Browser** tab directly into the world now, they will simply fall to the floor.
    You can kick them once they are on the the floor. The following screenshot shows
    the ball object on the floor:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在从**内容浏览器**选项卡直接拖放几个这些`BP_Bullet`对象到世界中，它们将简单地掉落到地板上。一旦它们在地板上，你可以踢它们一下。以下截图显示了地板上的球体对象：
- en: '![Bullet physics](img/00216.jpeg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![子弹物理](img/00216.jpeg)'
- en: However, we don't want our bullets falling on the floor. We want them to be
    shot. So let's put our bullets in the `Monster` class.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不想我们的子弹掉落在地板上。我们希望它们被射出。所以让我们把子弹放入`Monster`类中。
- en: Adding bullets to the monster class
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向怪物类添加子弹
- en: 'Add a member to the `Monster` class that receives a blueprint instance reference.
    That''s what the `UClass` object type is for. Also, add a blueprint configurable
    float property to adjust the force that shoots the bullet, as shown in the following
    code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 向`Monster`类添加一个接收蓝图实例引用的成员。这就是`UClass`对象类型的作用。另外，添加一个蓝图可配置的浮点属性来调整射击子弹的力，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Compile and run the C++ project and open your `BP_Monster` blueprint. You can
    now select a blueprint class under `BPBullet`, as shown in the following screenshot:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行C++项目，打开你的`BP_Monster`蓝图。你现在可以在`BPBullet`下选择一个蓝图类，如下面的截图所示：
- en: '![Adding bullets to the monster class](img/00217.jpeg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![向怪物类添加子弹](img/00217.jpeg)'
- en: Once you've selected a blueprint class type to instantiate when the monster
    shoots, you have to program the monster to shoot when the player is in his range.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了怪物射击时要实例化的蓝图类类型，你必须编写代码使怪物在玩家在其范围内时射击。
- en: 'Where does the monster shoot from? Actually, he should shoot from a bone. If
    you''re not familiar with the terminology, bones are just reference points in
    the model mesh. A model mesh is usually made up of many "bones." To see some bones,
    open up the **Mixamo_Adam** mesh by double-clicking on the asset in the **Content
    Browser** tab, as shown in the following screenshot:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 怪物是从哪里射击的？实际上，他应该从骨骼中射击。如果你不熟悉术语，骨骼只是模型网格中的参考点。模型网格通常由许多“骨骼”组成。要查看一些骨骼，双击**内容浏览器**选项卡中的**Mixamo_Adam**网格，如下面的截图所示：
- en: '![Adding bullets to the monster class](img/00218.jpeg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![向怪物类添加子弹](img/00218.jpeg)'
- en: Go to the **Skeleton** tab and you will see all the monster's bones in a tree
    view list in the left-hand side. What we want to do is select a bone from which
    bullets will be emitted. Here I've selected the `LeftHand` option.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到**骨骼**选项卡，你将在左侧的树形视图列表中看到所有怪物的骨骼。我们想要做的是选择一个子弹将从中发射出来的骨骼。在这里，我选择了`LeftHand`选项。
- en: Tip
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: An artist will normally insert an additional bone into the model mesh to emit
    the particle, which is likely to be on the tip of the nozzle of a gun.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术家通常会向模型网格中插入一个额外的骨骼来发射粒子，这很可能是枪管尖端的粒子。
- en: Working from the base model mesh, we can get the `Mesh` bone's location and
    have the monster emit the `Bullet` instances from that bone in the code.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 从基础模型网格开始，我们可以获取`Mesh`骨骼的位置，并在代码中让怪物从该骨骼发射`Bullet`实例。
- en: 'The complete monster `Tick` and `Attack` functions can be obtained using the
    following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码获取完整的怪物`Tick`和`Attack`函数：
- en: '[PRE18]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `AMonster::Attack` function is relatively simple. Of course, we first need
    to add a prototype declaration in the `Monster.h` file in order to write our function
    in the `.cpp` file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`AMonster::Attack`函数相对简单。当然，我们首先需要在`Monster.h`文件中添加原型声明，以便在`.cpp`文件中编写我们的函数：'
- en: '[PRE19]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In `Monster.cpp`, we implement the `Attack` function, as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Monster.cpp`中，我们实现`Attack`函数，如下所示：
- en: '[PRE20]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We leave the code that implements the melee attack as it is. Assuming that the
    monster is not holding a melee weapon, we then check whether the `BPBullet` member
    is set. If the `BPBullet` member is set, it means that the monster will create
    and fire an instance of the `BPBullet` blueprinted class.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留实现近战攻击的代码不变。假设怪物没有持有近战武器，然后检查`BPBullet`成员是否已设置。如果`BPBullet`成员已设置，这意味着怪物将创建并发射`BPBullet`蓝图类的实例。
- en: 'Pay special attention to the following line:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意以下行：
- en: '[PRE21]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is how we add a new actor to the world. The `SpawnActor()` function puts
    an instance of `UCLASS` that you pass, at `spawnLoc`, with some initial orientation.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们向世界中添加新演员的方法。`SpawnActor()`函数将你传递的`UCLASS`实例放置在`spawnLoc`，并带有一些初始方向。
- en: After we spawn the bullet, we call the `AddImpulse()` function on its `ProxSphere`
    variable to rocket it forward.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们生成子弹后，我们调用其`ProxSphere`变量的`AddImpulse()`函数以将其向前推进。
- en: Player knockback
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家击退
- en: 'To add a knockback to the player, I added a member variable to the `Avatar`
    class called `knockback`. A knockback happens whenever the avatar gets hurt:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给玩家添加击退效果，我在`Avatar`类中添加了一个名为`knockback`的成员变量。每当角色受到伤害时，就会发生击退：
- en: '[PRE22]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to figure out the direction to knock the player back when he gets
    hit, we need to add some code to `AAvatar::TakeDamage`. Compute the direction
    vector from the attacker towards the player and store this vector in the `knockback`
    variable:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定玩家被击中时击退的方向，我们需要在`AAvatar::TakeDamage`中添加一些代码。计算攻击者指向玩家的方向向量，并将此向量存储在`knockback`变量中：
- en: '[PRE23]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In `AAvatar::Tick`, we apply the knockback to the avatar''s position:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AAvatar::Tick`中，我们将击退应用于角色的位置：
- en: '[PRE24]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since the knockback vector reduces in size with each frame, it becomes weaker
    over time, unless the knockback vector gets renewed with another hit.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于击退向量的大小会随着每一帧的更新而减小，因此它会随着时间的推移而变弱，除非击退向量通过另一次击中而得到更新。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored how to instantiate monsters on the screen that
    run after the player and attack him. In the next chapter, we will give the player
    the ability to defend himself by allowing him to cast spells that damage the monsters.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何在屏幕上实例化追逐玩家并攻击他的怪物。在下一章中，我们将赋予玩家自我防御的能力，允许他施展伤害怪物的法术。
