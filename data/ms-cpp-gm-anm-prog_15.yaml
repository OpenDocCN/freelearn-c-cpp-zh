- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Loading a Game Map
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载游戏地图
- en: Welcome to *Chapter 11*! In the previous chapter, we added facial expressions
    to the instances. After a brief introduction of morph target animations, we extended
    the application to load morph meshes and added UI elements to control the face
    animations of an instance. Also, a new graph node type was added to allow using
    face animations in node trees. Finally, we implemented additive blending to move
    the heads of the instances independently of any skeletal and face animations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到**第11章**！在前一章中，我们为实例添加了面部表情。在简要介绍了形态目标动画之后，我们将应用扩展到加载形态网格，并为控制实例的面部动画添加了UI元素。此外，还添加了一种新的图节点类型，允许在节点树中使用面部动画。最后，我们实现了加法混合，以便独立于任何骨骼和面部动画移动实例的头。
- en: 'In this chapter, we will take a short break from character control and add
    a game level and level assets to the virtual world. We will start by exploring
    reasons why level data should be handled differently than models and instances;
    plus, we will look at suitable file formats to import level data with the Open
    Asset Importer Library and where to find game levels. Then, we will load level
    data and assets from files into the application and update the quadtree to become
    an octree. As the last step, we will add the level-related data to the renderer
    to draw the game map to the screen, giving us an idea of what the home for the
    inhabitants of our virtual world will look like. In this chapter, we will cover
    the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将暂时从角色控制中休息一下，并将游戏级别和级别资产添加到虚拟世界中。我们将首先探讨为什么级别数据应该与模型和实例的处理方式不同；此外，我们还将查看使用Open
    Asset Importer Library导入级别数据的合适文件格式以及在哪里可以找到游戏级别。然后，我们将从文件中加载级别数据和资产到应用程序中，并更新四叉树以成为八叉树。作为最后一步，我们将添加与级别相关的数据到渲染器中，以便将游戏地图绘制到屏幕上，让我们对虚拟世界居民的家有一个概念。在本章中，我们将涵盖以下主题：
- en: Differences between map and model data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图数据与模型数据之间的差异
- en: Choosing a file format for a map
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为地图选择文件格式
- en: Importing a game map
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入游戏地图
- en: Sending the map data to the GPU
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将地图数据发送到GPU
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example code for this chapter is available in the `chapter11` folder, in
    the `01_opengl_level` subfolder for OpenGL and the `02_vulkan_level` subfolder
    for Vulkan.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码位于`chapter11`文件夹中，在`01_opengl_level`子文件夹中为OpenGL，在`02_vulkan_level`子文件夹中为Vulkan。
- en: Differences between map and model data
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图数据与模型数据之间的差异
- en: There are some interesting differences between handling models and level data,
    allowing us to apply optimizations in data handling. In the code for this book,
    we will do these optimizations after loading the level data. For larger levels,
    doing a precalculation during level creation is the better approach.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理模型和级别数据之间存在一些有趣的差异，使我们能够在数据处理中应用优化。在本书的代码中，我们将在加载级别数据后进行这些优化。对于较大的级别，在级别创建期间进行预计算是更好的方法。
- en: Let’s take a closer look at some of the differences.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看一些差异。
- en: Level data does not move around
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 级别数据不会移动
- en: 'The most significant difference between models and levels is simple: while
    the properties of a model instance can change, such as position, rotation, and
    speed, and they play animations, react to events, and so on, a level’s architecture
    typically remains unchanged.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模型和级别之间最显著的区别很简单：虽然模型实例的属性可以改变，例如位置、旋转和速度，并且它们播放动画、对事件做出反应等，但级别的架构通常保持不变。
- en: 'Non-movable and non-animated polygons of a level have a big advantage: some
    data can be precalculated, either at creation time or at loading time for collision
    detection or lighting, for example. At runtime, only a lookup into the precalculated
    data is needed. Plus, we do not have to upload the data in every frame to the
    GPU again. All triangles can be processed at loading time and then uploaded once
    into GPU memory, residing there until the level data may be removed from the application
    by the user.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 级别中不可移动和不可动画的多边形具有一个很大的优势：一些数据可以在创建时或在加载时预先计算，例如用于碰撞检测或照明。在运行时，只需要查找预先计算的数据。此外，我们不需要在每一帧都将数据上传到GPU。所有三角形都可以在加载时处理，然后一次性上传到GPU内存中，直到用户可能从应用程序中删除级别数据。
- en: What about doors, buttons, elevators, or anything that does move in a level?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，门、按钮、电梯或任何在级别中移动的东西怎么办？
- en: Movable parts of a level, such as sliding or revolving doors, elevators, buttons
    and switches, locker doors, mechanical platforms... in short, anything that can
    move inside a level, are usually modeled and used like an animated model instead
    of static level data.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 水平面的可移动部分，如滑动门、旋转门、电梯、按钮和开关、储物柜门、机械平台等，简而言之，任何可以在水平面内移动的东西，通常都是用动画模型来建模和使用，而不是静态水平数据。
- en: Just think of a revolving door as a 3D model of a door, having a single node
    placed on the hinges. And on interaction, the model rotates around the hinge.
    Or, for a sliding door, the door model is translated a specific amount to one
    side, opening the passage to another room. In contrast to those doors, a static
    wall or a static floor in a level will never move or rotate.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将旋转门想象成一个门的三维模型，门轴上有一个单独的节点。在交互时，模型围绕门轴旋转。或者，对于滑动门，门模型向一侧移动特定距离，打开通往另一个房间的通道。与这些门相比，一个水平面上的静态墙壁或静态地板永远不会移动或旋转。
- en: Doing split collision detection for static data also helps us to improve performance.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对静态数据进行分割碰撞检测也有助于我们提高性能。
- en: Using a separate collision detection for level data
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用单独的碰撞检测来处理水平数据
- en: For collision detection, we can add a quadtree or octree containing only the
    level data. This tree must be recreated when the level is loaded and can be kept
    read-only during runtime, skipping costly operations of adding and removing instances.
    We then use the AABBs of the instances to check the level-data tree if an instance
    is colliding with level geometry. Using different tree structures for instance
    and level data also allows us to configure the trees according to the specific
    needs. A level octree may need entirely different values for maximum depth and
    number of triangles per node due to many triangles in the map, while there are
    only a few instances running around in the virtual world. In addition to the improvements
    for static data, a game level may contain other data that is not needed for models.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于碰撞检测，我们可以添加一个仅包含水平数据的四叉树或八叉树。当加载水平面时，必须重新创建此树，并且在运行时可以保持只读状态，跳过添加和删除实例的昂贵操作。然后我们使用实例的AABB来检查水平数据树，以确定实例是否与水平几何体发生碰撞。使用不同的树结构来处理实例和水平数据也允许我们根据特定需求配置树。由于地图中有许多三角形，水平八叉树可能需要完全不同的最大深度和每个节点的三角形数量，而在虚拟世界中运行的实例却只有几个。除了对静态数据的改进之外，游戏水平面可能还包含其他不需要用于模型的数据。
- en: Level data may contain additional data
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 水平数据可能包含额外的数据
- en: Both CPU and GPU time are scarce resources at runtime, and any data that can
    be made available in lookup tables or calculated in a shader can save precious
    milliseconds when creating the next frame. We saw the effect in [*Chapter 2*](Chapter_2.xhtml)
    while moving parts of the animation calculation to a compute shader, and again
    in [*Chapter 7*](Chapter_7.xhtml) after adding animation lookup tables to GPU
    memory. In both chapters, a significant frame time boost was achieved for the
    same number of instances on the screen.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，CPU和GPU时间都是稀缺资源，任何可以放在查找表或通过着色器计算的数据都可以在创建下一帧时节省宝贵的时间。我们在[*第2章*](Chapter_2.xhtml)中将动画计算的部分移动到计算着色器中看到了这种效果，同样在[*第7章*](Chapter_7.xhtml)中添加动画查找表到GPU内存后也看到了这种效果。在这两章中，屏幕上相同数量的实例都实现了显著的帧时间提升。
- en: For level data, similar accelerations can be done. Four examples of such additional
    data are spatial division, lightmaps, navigation meshes, and hierarchical level
    of detail. Let’s take a brief look at these extra data types. Links to more detailed
    explanations can be found in the *Additional resources* section at the end of
    the chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于水平数据，也可以进行类似的加速。以下是一些此类附加数据的例子：空间划分、光照贴图、导航网格和层次细节级别。让我们简要地看看这些额外数据类型。更详细的信息可以在本章末尾的[*附加资源*](Additional_resources)部分找到。
- en: Spatial division
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空间划分
- en: We talked about the spatial division of a level when diving into collision detection
    in [*Chapter 8*](Chapter_8.xhtml). Saving spatial division data to the level file
    is needed to avoid doing the same calculations at loading time, or even at runtime
    of the game.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[*第8章*](Chapter_8.xhtml)中深入讨论碰撞检测时，我们讨论了水平面的空间划分。将空间划分数据保存到水平文件中是必要的，以避免在加载时或游戏运行时进行相同的计算。
- en: Creating **Binary Space Partition** (**BSP**) trees or dividing the virtual
    world into an octree may take a long time, depending on the number of triangles
    in a level and the overall level complexity. This kind of computation can be moved
    to level creation time, adding only an optimized lookup version to the final level
    file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建**二叉空间划分**（**BSP**）树或将虚拟世界划分为八叉树可能需要很长时间，这取决于一个级别中的三角形数量以及整个级别的复杂性。这种计算可以移至级别创建时间，只需在最终级别文件中添加一个优化的查找版本即可。
- en: Lightmaps
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 光照贴图
- en: Even though the principle of lightmaps was introduced in **id Software**’s **Quake**
    nearly thirty years ago, this technique is still in use today. During level creation,
    the light effects of static lights are “baked” into a texture, with bright pixels
    depicting the parts of the level geometry where the light of a static light source
    shines onto a surface, and dark pixels where shadows are on the level surface.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管光照贴图的原则在**id Software**的**Quake**中近三十年前就已经提出，但这种技术至今仍在使用。在级别创建过程中，静态光源的光照效果被“烘焙”到纹理中，明亮的像素表示静态光源的光照到表面的级别几何形状的部分，而暗像素表示级别表面上的阴影。
- en: The lightmap texture is then added as a secondary texture, darkening the areas
    where the light from a light source does not reach the level geometry and simulating
    a shadow. Using a lightmap can drastically speed up light calculations by keeping
    a reasonable visual effect, since less expensive per-pixel calculations are needed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将光照贴图纹理作为二级纹理添加，使那些来自光源的光无法到达级别几何形状的区域变暗，并模拟出阴影。使用光照贴图可以通过保持合理的视觉效果来显著加快光照计算，因为需要的每像素计算成本较低。
- en: Navigation mesh
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导航网格
- en: A **navmesh**, or **navigation mesh**, is an addition for enemies, NPCs, or
    any other computer-controlled objects. The level geometry will be overlayed with
    an extra mesh made of triangles or other polygons, but only in those places where
    computer-controlled objects should be able to move around. A navmesh accelerates
    pathfinding for the objects and can help to prevent collision checks when placed
    correctly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**导航网格**，或**导航网格**，是为敌人、NPC或任何其他由计算机控制的对象添加的附加功能。级别几何形状将被覆盖在一个额外的三角形或其他多边形组成的网格上，但仅限于计算机控制对象能够移动的地方。导航网格可以加速对象的路径查找，并且当放置正确时，可以帮助防止碰撞检查。'
- en: We will come back to navigation meshes in [*Chapter 13*](Chapter_13.xhtml),
    when we add simple navigation to the instances.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第13章*](Chapter_13.xhtml)中回到导航网格，当我们向实例添加简单的导航时。
- en: Hierarchical level-of-detail
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分层细节级别
- en: Model files can include so-called level-of-detail meshes. When drawing models
    that are far away from the camera, the mesh complexity can be lowered without
    affecting the visual quality as the model will cover only a few pixels of the
    screen. By using different mesh resolutions, the overall number of triangles to
    draw the models can be reduced.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 模型文件可以包括所谓的细节级别网格。当绘制远离摄像机的模型时，网格复杂性可以降低，而不会影响视觉质量，因为模型将只覆盖屏幕上的一小部分像素。通过使用不同的网格分辨率，绘制模型所需的三角形总数可以减少。
- en: Level data can leverage level-of-detail meshes even more, replacing groups of
    objects with a simpler representation. For example, instead of drawing a large
    number of visually indistinguishable rocks at a great distance, the **Hierarchical
    Level-of-Detail** (**HLOD**) version of the same area could be merged to a single
    mesh with adjusted textures, delivering a similar visual quality with a fraction
    of the polygons and textures.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 级别数据可以利用细节级别网格更多，用更简单的表示替换对象组。例如，而不是在远处绘制大量视觉上无法区分的岩石，同一区域的**分层细节级别**（**HLOD**）版本可以合并到一个带有调整纹理的单个网格中，以较少的多边形和纹理提供类似的视觉质量。
- en: Level data may be partial or incomplete
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 级别数据可能是不完整或不完整的。
- en: Your fancy animated 3D model should be fully available all the time, not only
    half of the model, or even less. But for level data, the sheer size of a level
    could be too much for a PC or console to handle at once, especially when taking
    the additional level data into account, like for lighting, navigation, or collision
    detection. But also texture size and quality, or the number and distribution of
    computer-controlled characters can raise the memory requirements by and large.
    Plus, the currently loaded level part could have much more detail, using the available
    resources to draw the visible area instead of keeping invisible and unused data
    in memory.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您的精美动画3D模型应该始终完全可用，而不仅仅是模型的一半，甚至更少。但对于关卡数据来说，一个关卡的大小可能对PC或游戏机来说一次性处理过于庞大，尤其是在考虑额外的关卡数据时，如光照、导航或碰撞检测。此外，纹理大小和质量，或者计算机控制角色的数量和分布，总体上会增加内存需求。此外，当前加载的关卡部分可能具有更多细节，使用可用资源绘制可见区域，而不是在内存中保留不可见和未使用的数据。
- en: Keeping the immersion for the player alive is part of the level design. The
    level may be hidden behind a winding passage, where none of the two-level parts
    is visible, allowing the game engine to discard the area where the player is coming
    from and loading the part they are heading to. Another widely used example for
    level switches is to use elevators and load new level data as the next floor of
    a building, spaceship, or similar.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 保持玩家的沉浸感是关卡设计的一部分。关卡可能隐藏在蜿蜒的通道后面，其中两个关卡部分都不可见，允许游戏引擎丢弃玩家来自的区域，并加载他们前往的部分。另一个广泛使用的关卡切换示例是使用电梯，并在建筑、宇宙飞船或类似结构的下一层加载新的关卡数据。
- en: By using precomputed data wisely, the time to render a single frame could be
    reduced to deliver a greater experience to the player. Or the visual details could
    be adjusted with the now unused CPU power, allowing to show more objects on the
    screen, or more detailed objects, while still maintaining the same frame time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过明智地使用预计算数据，可以将渲染单个帧的时间减少，从而为玩家提供更丰富的体验。或者，可以使用现在未使用的CPU功率调整视觉细节，允许在屏幕上显示更多对象，或者更详细的对象，同时仍然保持相同的帧时间。
- en: After the differences between maps and instances are clear, let’s see which
    file formats are mostly used for level data, and how to get game maps.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图和实例之间的差异变得清晰之后，让我们看看哪些文件格式主要用于关卡数据，以及如何获取游戏地图。
- en: Choosing a file format for a map
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择地图的文件格式
- en: The Open Asset Importer Library knows several old and new formats for 3D character
    models, but – sadly – support for level data is pretty limited.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Open Asset Importer库了解多种旧的和新的3D角色模型格式，但遗憾的是，对关卡数据的支持相当有限。
- en: We will explore file formats of level files mostly found on the internet first,
    and then look at alternatives if the available formats do not fit our needs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探索互联网上最常见的关卡文件格式，然后如果现有格式不符合我们的需求，我们将考虑替代方案。
- en: Using levels in file formats supported by Assimp
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用由Assimp支持的文件格式的关卡
- en: A couple of file formats are used to create game level data, either by creating
    data from scratch or by using buildings and landscapes from other games as templates.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 几种文件格式用于创建游戏关卡数据，无论是从头开始创建数据还是使用其他游戏中的建筑和景观作为模板。
- en: 'If you want to get some game maps to import, you should check out these websites:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想获取一些游戏地图进行导入，应该查看这些网站：
- en: '**Sketchfab**: [https://sketchfab.com/](https://sketchfab.com/)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sketchfab**: [https://sketchfab.com/](https://sketchfab.com/)'
- en: '**Free3D**: [https://free3d.com](https://free3d.com)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Free3D**: [https://free3d.com](https://free3d.com)'
- en: On both sites, an enormous number of free and paid animated and non-animated
    models, levels, and assets can be searched and downloaded. Several models come
    with a Creative Commons license, allowing you to use models in free and even commercial
    projects.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个网站上，可以搜索和下载大量免费和付费的动画和非动画模型、关卡和资产。一些模型附带Creative Commons许可证，允许您在免费项目甚至商业项目中使用模型。
- en: 'Usually, you will find levels in the following formats:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会发现以下格式的关卡：
- en: 'Khronos Group glTF (`.gltf`/`.glb`): The open source glTF format can not only
    be used for models like the animated `Woman` and `Man` models we are using in
    the chapters, but also entire levels can be exported as glTF files.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Khronos Group glTF (`.gltf`/`.glb`): 开源glTF格式不仅可以用于我们章节中使用的动画`女性`和`男性`模型，还可以将整个关卡导出为glTF文件。'
- en: 'Collada (`.dae`): Collada is an old but fully open XML-based file format. Collada
    is also managed by the Khronos Group, and even an ISO standard for the file format
    has been created.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Collada（`.dae`）：Collada是一个老式的但完全基于XML的文件格式。Collada也由Khronos Group管理，甚至已经为该文件格式创建了一个ISO标准。
- en: 'Wavefront (`.obj` + `.mtl`): Many levels can be found in the Wavefront file
    format. Files in Wavefront format are pure text (no binary components) and the
    format is well documented and widely supported.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wavefront（`.obj` + `.mtl`）：许多关卡都可以在Wavefront文件格式中找到。Wavefront格式的文件是纯文本（没有二进制组件）且格式有很好的文档记录和广泛的支持。
- en: 'Universal Scene Description (`.usd`/`.usdz`): The **Universal Scene Description**
    (**USD**) format is quite new compared to the other file formats. USD is also
    open source and well documented, but the support in Assimp is still experimental
    due to the complexity of the file format.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用场景描述（`.usd`/`.usdz`）：与其它文件格式相比，**通用场景描述**（**USD**）格式相当新。USD也是开源的，并且有很好的文档记录，但由于文件格式的复杂性，Assimp中的支持仍然是实验性的。
- en: 'Autodesk FBX (`.fbx`): The “Filmbox” format is proprietary and mostly undocumented,
    but tools such as Blender and Assimp can read and write this file format. Using
    FBX is more or less at your own risk as it is possible that only specific versions
    are working as expected.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autodesk FBX（`.fbx`）：“Filmbox”格式是专有的且大部分未记录，但Blender和Assimp等工具可以读取和写入此文件格式。使用FBX的风险自负，因为它可能只有特定版本才能按预期工作。
- en: If none of these models fits your needs, you may have to extend a file format,
    or even build a custom file format.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些模型中没有一种符合你的需求，你可能需要扩展文件格式，甚至构建一个自定义文件格式。
- en: Extending existing formats or creating a custom format
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展现有格式或创建自定义格式
- en: Creating new game levels from scratch or modifying existing game levels may
    require additional information that is not available in the original file format,
    such as baked-in light maps, tree data, navigation meshes, or level-of-detail
    data. See the *Level data may contain additional data* section for more information.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从头创建新的游戏关卡或修改现有游戏关卡可能需要一些原始文件格式中不包含的额外信息，例如内嵌的光照贴图、树木数据、导航网格或细节级别数据。有关更多信息，请参阅*关卡数据可能包含额外数据*部分。
- en: File formats such as glTF have the built-in ability to create extensions, while
    other file formats may be hard or impossible to extend without breaking existing
    importers. In such a case, you could invent your own file format from scratch
    or use a combination of one of the standard file formats for level data and add
    a custom format to store additional data.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于glTF这样的文件格式具有内置的创建扩展的能力，而其他文件格式可能很难或无法扩展而不破坏现有的导入器。在这种情况下，你可以从头开始创建自己的文件格式，或者使用标准文件格式之一来存储关卡数据，并添加一个自定义格式来存储额外数据。
- en: 'A custom file format was created earlier in this book in the *Adding a YAML
    parser* section of [*Chapter 5*](Chapter_5.xhtml): the YAML configuration file
    to store all settings of the models, instances, cameras, collision detection,
    and node trees. Although we are relying on a standard textual format to store
    the data on disk, the contents of the file are tailored to fit the needs of our
    example application. Storing the same data in a binary format would also be possible,
    for instance, when decoding the text information will take too long.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的*添加YAML解析器*部分中，之前已经创建了一个自定义文件格式：用于存储模型、实例、相机、碰撞检测和节点树的所有设置的YAML配置文件。尽管我们依赖于标准文本格式来在磁盘上存储数据，但文件内容是根据我们示例应用程序的需求定制的。以二进制格式存储相同的数据也是可能的，例如，当解码文本信息需要花费太多时间时。
- en: But creating an entirely new file format should the last resort since you will
    have to write all the code to read and write the data, keep track of different
    versions of the file format during read and write operations, and maybe even support
    different operating systems and hardware architectures. Maintaining such an organically
    grown file format can become a nightmare.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但创建全新的文件格式应该是最后的手段，因为你将不得不编写所有读取和写入数据的代码，在读写操作中跟踪文件格式的不同版本，甚至可能还需要支持不同的操作系统和硬件架构。维护这样一个自然生长的文件格式可能会变得非常困难。
- en: A better way is to use standard formats and bundle all files into an archive,
    for instance, into a ZIP file. You don’t have to care about missing files when
    the level is distributed to players or other developers, but at the same time,
    you do not need to reinvent the wheel by creating a new, all-encompassing file
    format.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是使用标准格式并将所有文件打包到一个存档中，例如ZIP文件。当关卡分发到玩家或其他开发者时，你不必担心缺失的文件，但与此同时，你也不需要通过创建一个新的、全面的文件格式来重新发明轮子。
- en: Such archives are more common than you might think. Formats such as WAD from
    the original DOOM and PAK/PK2/PK3 for the Quake series were created to collect
    all game data in a single file, and these file types even support patching as
    files in new archives replace files of the same name in old archives.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的存档比你想象的要常见。例如，DOOM原始版本中的WAD格式和Quake系列中的PAK/PK2/PK3格式都是为了将所有游戏数据收集到一个文件中而创建的，这些文件类型甚至支持补丁，因为新存档中的同名文件会替换旧存档中的同名文件。
- en: Building your own levels
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 构建你自己的关卡
- en: What if you can’t find a suitable game level map on the internet? You still
    have the option to create a small map by yourself, for instance, with Blender.
    Creating a map is out of the scope of this book, but you will find suitable tutorials
    and videos on the internet. You can find links to two example videos in the *Additional
    resources* section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在互联网上找不到合适的游戏关卡地图，你仍然可以选择自己创建一个小地图，例如使用Blender。创建地图超出了本书的范围，但你可以在互联网上找到合适的教程和视频。你可以在*附加资源*部分找到两个示例视频的链接。
- en: After we explored the reasons why separating model and level data in the application,
    we will now implement new code for loading and processing level data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨了为什么在应用程序中分离模型和关卡数据的原因之后，我们现在将实现加载和处理关卡数据的新代码。
- en: Importing a game map
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入游戏地图
- en: As the first step to load a level, we will add a new C++ class named `AssimpLevel`.
    You can think of the `AssimpLevel` class as a mix of the two classes, `AssimpModel`
    and `AssimpInstance`, containing the static vertex data of the model class and
    dynamic properties such as the position, rotation, or scale of the instance class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 作为加载关卡的第一步，我们将添加一个名为`AssimpLevel`的新C++类。你可以将`AssimpLevel`类视为`AssimpModel`和`AssimpInstance`两个类的混合体，包含模型类的静态顶点数据以及实例类的动态属性，如位置、旋转或缩放。
- en: The `AssimpLevel` class consists of two new files, `AssimpLevel.h` and `AssimpLevel.cpp`.
    Both files are in the `model` folder, but we will borrow most of the methods and
    members from the two classes, `AssimpModel` and `AssimpInstance`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`AssimpLevel`类由两个新文件组成，`AssimpLevel.h`和`AssimpLevel.cpp`。这两个文件都在`model`文件夹中，但我们将借用`AssimpModel`和`AssimpInstance`两个类的大多数方法和成员。'
- en: Let’s do a brief walkthrough of the `AssimpLevel` class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地浏览一下`AssimpLevel`类。
- en: Adding a C++ class to hold the level data
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个C++类来存储关卡数据
- en: Since the level and model/instance data are so similar, we can reuse parts of
    the functionality we already have in the `AssimpModel` and `AssimpInstance` classes,
    such as loading the model file or doing matrix operations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关卡和模型/实例数据非常相似，我们可以重用`AssimpModel`和`AssimpInstance`类中已有的功能的一部分，例如加载模型文件或执行矩阵运算。
- en: 'For the static data, we can copy the following methods and members from the
    `AssimpModel` class, exchanging the `model` part in the name with `level` to be
    consistent with the class name:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于静态数据，我们可以从`AssimpModel`类复制以下方法和成员，将名称中的`model`部分替换为`level`以与类名保持一致：
- en: The `loadModel()` method, but without bones, animations, and lookup table creation
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadModel()`方法，但不包括骨骼、动画和查找表创建'
- en: The `processNode()` method, again without the bone-specific part
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`processNode()`方法，再次不包括骨骼特定的部分'
- en: The entire `draw()` method
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整个`draw()`方法
- en: The `getTriangleCount()`, `getModelFileName()`, and `getModelFileNamePath()`methods
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getTriangleCount()`、`getModelFileName()`和`getModelFileNamePath()`方法'
- en: The `setModelSettings()` and `getModelSettings()` methods
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setModelSettings()`和`getModelSettings()`方法'
- en: The `mTriangleCount` and `mVertexCount` member variables
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mTriangleCount`和`mVertexCount`成员变量'
- en: The `mRootNode`, `mNodeList`, `mRootTransformMatrix`, `mModelMeshes`, `mVertexBuffers`,
    and `mModelSettings` member variables to store the viable level data
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储有效关卡数据的`mRootNode`、`mNodeList`、`mRootTransformMatrix`、`mModelMeshes`、`mVertexBuffers`和`mModelSettings`成员变量
- en: The `mTextures` and `mPlaceholderTexture` member variables for the textures
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mTextures`和`mPlaceholderTexture`成员变量用于纹理'
- en: 'For the dynamic data, the following methods and members can be copied from
    the `AssimpInstance` class, again replacing the word `model` with `level` in the
    names:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于动态数据，以下方法和成员可以从`AssimpInstance`类中复制，再次在名称中将`model`替换为`level`：
- en: The `updateModelRootMatrix()` and `getWorldTransformMatrix()` methods
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updateModelRootMatrix()`和`getWorldTransformMatrix()`方法'
- en: The `mLocalTranslationMatrix`, `mLocalRotationMatrix`, `mLocalScaleMatrix`,
    `mLocalSwapAxisMatrix`, `mLocalTransformMatrix`, and `mModelRootMatrix` member
    variables
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员变量`mLocalTranslationMatrix`、`mLocalRotationMatrix`、`mLocalScaleMatrix`、`mLocalSwapAxisMatrix`、`mLocalTransformMatrix`和`mModelRootMatrix`
- en: 'To have all the variable level data in one location, we create the `LevelSettings.h`
    file in the `model` folder, containing the `LevelSettings` `struct`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有变量级别数据集中在一个位置，我们在`model`文件夹中创建了`LevelSettings.h`文件，其中包含`LevelSettings`
    `struct`：
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, these level settings are also a mix of data taken partially
    from model settings (filenames) and instance settings (position, rotation, scale,
    axis swap). The `LevelSettings` data type will be used to simplify the level settings
    in the user interface and to save and load level-related data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这些级别设置也是部分从模型设置（文件名）和实例设置（位置、旋转、缩放、轴交换）中取出的混合。`LevelSettings`数据类型将被用于简化用户界面中的级别设置以及保存和加载与级别相关的数据。
- en: 'We also make the loaded level data available to other parts of the application
    by adding a vector of `AssimpLevel` shared pointers called `micLevels` and the
    `micSelectedlevel` int that holds the currently selected level from the vector:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过添加名为`micLevels`的`AssimpLevel`共享指针向量和名为`micSelectedlevel`的整数，后者保存当前从向量中选择的级别，将加载的级别数据提供给应用程序的其他部分：
- en: '[PRE1]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The main work to manage the `AssimpLevel` objects in the `micLevels` vector
    will be handled by the renderer class, so we add methods and callbacks as the
    second step.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 管理在`micLevels`向量中的`AssimpLevel`对象的主要工作将由渲染器类处理，因此我们作为第二步添加方法和回调。
- en: Adding callbacks and renderer code
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加回调和渲染器代码
- en: 'Similarities between the new level functionality and existing model functions
    also continue in the callbacks. Three new callback definitions named `levelCheckCallback`,
    `levelAddCallback`, and `levelDeleteCallback` must be added to the `Callbacks.h`
    file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 新的级别功能与现有模型函数之间的相似性也体现在回调中。必须将三个新的回调定义`levelCheckCallback`、`levelAddCallback`和`levelDeleteCallback`添加到`Callbacks.h`文件中：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For the models, we have the same set of callbacks. The first callback, `levelCheckCallback`,
    is used to check if a level file with the same name is already loaded, and the
    other two callbacks, `levelAddCallback` and `levelDeleteCallback`, are used to
    load a new level from a file and to delete an existing level object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模型，我们有一组相同的回调函数。第一个回调函数`levelCheckCallback`用于检查是否存在同名级别的文件，而其他两个回调函数`levelAddCallback`和`levelDeleteCallback`则用于从文件中加载新的级别并删除现有的级别对象。
- en: 'Like for most of the callbacks, we will also make the functions available in
    the `ModelInstanceCamData` struct in `ModelInstanceCamData.h`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数回调函数，我们也将函数在`ModelInstanceCamData.h`中的`ModelInstanceCamData`结构体中可用：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the renderer class, four new methods are added to handle the level management.
    And again, the new methods, `hasLevel()`, `getLevel()`, `addLevel()`, and `deleteLevel()`,
    are mostly copies from the equivalent model methods:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器类中，添加了四个新方法来处理级别管理。同样，新方法`hasLevel()`、`getLevel()`、`addLevel()`和`deleteLevel()`主要复制自等效模型方法：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: While `hasLevel()` is examining the `micLevels` vector to see if a level with
    the same file name is already loaded, `getLevel()` returns a shared pointer to
    the existing `AssimpLevel` object, or a `nullptr` if no level with the requested
    file name exists.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当`hasLevel()`正在检查`micLevels`向量以查看是否已加载同名级别的文件时，`getLevel()`返回现有`AssimpLevel`对象的共享指针，如果不存在请求的文件名对应的级别，则返回`nullptr`。
- en: As the names suggest, `addLevel()` will try to load a level data file from local
    storage and add the new `AssimpLevel` object to `micLevels`, and `deleteLevel()`
    will delete the requested level from `micLevels` if it exists.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`addLevel()`将尝试从本地存储加载级别数据文件并将新的`AssimpLevel`对象添加到`micLevels`中，而`deleteLevel()`如果存在，将从`micLevels`中删除请求的级别。
- en: 'We also add a `null` level to stop `micLevels` being empty:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个`null`级别以防止`micLevels`为空：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The connection between the three new callbacks and the `hasLevel()`, `addLevel()`,
    and `deleteLevel()` methods is created in the `init()` method of the renderer,
    allowing us to use the level calls in the `UserInterface` class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染器的 `init()` 方法中创建三个新回调与 `hasLevel()`、`addLevel()` 和 `deleteLevel()` 方法的连接，使我们能够在
    `UserInterface` 类中使用级别调用。
- en: So, let’s go for the third step on the path to level data management and add
    new elements to the user interface.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续第三步，在级别数据管理的路径上添加新的用户界面元素。
- en: Extending the UI with level property controls
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用级别属性控件扩展 UI
- en: Just like for the `AssimpLevel` class, we can simply copy and adjust existing
    control elements from other parts of the `createSettingsWindow()` method in the
    `UserInterface` class to create the new `CollapsingHeader` named **Levels**.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对 `AssimpLevel` 类一样，我们可以简单地从 `UserInterface` 类的 `createSettingsWindow()` 方法的其他部分复制并调整现有的控制元素，以创建名为
    **Levels** 的新 **CollapsingHeader**。
- en: 'In *Figure 11.1*, the resulting user interface part for the level data is shown:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 11.1* 中，显示了级别数据的用户界面部分的结果：
- en: '![](img/Figure_11.1_B22428.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_11.1_B22428.png)'
- en: 'Figure 11.1: User interface controls for the level data'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：级别数据的用户界面控件
- en: The **Levels** combo box is filled from the file names of the levels within
    the `micLevels` vector in the `ModelInstanceCamData` struct. The **Delete Level**
    button for the level data has the same function as the **Delete Model** button
    from the **Models** section of the UI, removing the currently selected level,
    and the controls for axis swap, position, rotation, and scaling are taken from
    the **Instances** UI section, along with the **Reset Values to Zero** button to
    set all controls to default values.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**Levels** 组合框从 `ModelInstanceCamData` 结构体中的 `micLevels` 向量内的级别文件名称填充。级别数据的
    **删除级别** 按钮与 UI 的 **模型** 部分的 **删除模型** 按钮具有相同的功能，删除当前选定的级别，并且轴交换、位置、旋转和缩放的控制来自
    **实例** UI 部分，以及 **重置值到零** 按钮以将所有控件设置为默认值。'
- en: 'In addition to the new control elements, a new main menu entry named **Levels**
    is created. *Figure 11.2* shows all the elements of the main menu at this point:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了新的控制元素外，还创建了一个名为 **Levels** 的新主菜单项。*图 11.2* 显示了此时主菜单的所有元素：
- en: '![](img/Figure_11.2_B22428.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_11.2_B22428.png)'
- en: 'Figure 11.2: The new Levels main menu entry'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：新的 Levels 主菜单项
- en: Clicking on **Load Level...** opens the well-known ImGui-based file dialog,
    configured with a list of supported file formats for level data. See *Choosing
    a file format for a map* section about the extensions in the filter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **加载级别...** 将打开著名的基于 ImGui 的文件对话框，配置了支持级别数据的文件格式列表。有关过滤器中的扩展名，请参阅 *选择地图的文件格式*
    部分。
- en: The **Delete Model** and **Load Level...** UI elements utilize the callbacks
    to add and delete an `AssimpLevel` object from the application, creating a seamless
    workflow for the user when adding level data to the virtual world.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除模型** 和 **加载级别...** UI 元素使用回调函数从应用程序中添加和删除一个 `AssimpLevel` 对象，当向虚拟世界添加级别数据时，为用户创建了一个无缝的工作流程。'
- en: The significant difference between level data and model instances in terms of
    user experience is the missing visual selection and modification functionality
    for the level data. Since you will adjust the level data a few times until you
    are happy with position, rotation, and scale, the extra code to continuously move
    the level data around like instances will be used only once or twice. It is even
    more probable that a visual selection harms the workflow if the level data is
    selected when the desired instance is missed by some pixels.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户体验方面，级别数据和模型实例之间的显著区别是缺少对级别数据的视觉选择和修改功能。由于您将调整级别数据几次，直到对位置、旋转和缩放满意，因此用于像实例一样连续移动级别数据的额外代码将只使用一次或两次。如果当期望的实例因像素偏差而错过时选择级别数据，视觉选择甚至更有可能损害工作流程。
- en: As the last step of level data management, we will add the names of the loaded
    level files and the per-level settings to the YAML config file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 作为级别数据管理的最后一步，我们将加载的级别文件名称和每级设置添加到 YAML 配置文件中。
- en: Saving and loading the level configuration
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存和加载级别配置
- en: Storing the loaded levels and the level settings in the YAM configuration file
    is quick and straightforward.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 将加载的级别和级别设置存储在 YAM 配置文件中既快又简单。
- en: After adding an Emitter output operator overload for the `LevelSettings` data
    type, we can copy and adjust the emitting code block for models or cameras in
    the `createConfigFile()` method of the `YamlParser` class in the `tools` folder
    to save the level data. In addition, we must also emit the selected level number
    in the `settings` map of our configuration file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 `LevelSettings` 数据类型添加了 Emitter 输出操作符重载之后，我们可以复制并调整 `tools` 文件夹中 `YamlParser`
    类的 `createConfigFile()` 方法中用于模型或相机的发射代码块，以保存级别数据。此外，我们还必须在配置文件的 `settings` 映射中发射所选的级别编号。
- en: 'Also, two new methods named `getLevelConfigs()` and `getSelectedLevelNum()`
    are added to the `YamlParser` class:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还向 `YamlParser` 类添加了两个名为 `getLevelConfigs()` 和 `getSelectedLevelNum()` 的新方法：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Both methods follow the same process as the model and camera counterparts. The
    first method, `getLevelConfigs()`, tries to load the level data from the YAML
    file, and `getSelectedLevelNum()` returns the index of the selected level at the
    time the configuration was saved.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法遵循与模型和相机类似的过程。第一种方法 `getLevelConfigs()` 尝试从 YAML 文件中加载级别数据，而 `getSelectedLevelNum()`
    返回在保存配置时所选级别的索引。
- en: In the `YamlParserTypes.h` file, a simple pair of `encode()` and `decode()`
    methods for the `LevelSettings` data type must be added to read back the data
    from the YAML file. We should also increase the `mYamlConfigFileVersion` value
    as the configuration structure has changed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `YamlParserTypes.h` 文件中，必须为 `LevelSettings` 数据类型添加一对简单的 `encode()` 和 `decode()`
    方法，以便从 YAML 文件中读取数据。我们还应该增加 `mYamlConfigFileVersion` 的值，因为配置结构已更改。
- en: Now we can add level data from a file, place the level in the virtual world,
    and store and reload the configuration. Adding the level data to the undo/redo
    stack is left as an exercise for you, but the basic principle level data undo/redo
    is identical to the undo/redo functionality for models.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以从文件中添加级别数据，将级别放置在虚拟世界中，并存储和重新加载配置。将级别数据添加到撤销/重做堆栈的工作留给你作为练习，但基本原理级别的撤销/重做与模型的撤销/重做功能相同。
- en: Since the level data may contain overlapping elements, such as bridges, tunnels,
    or multiple floors of a building, instances could be on the same location in two
    dimensions. The existing collision detection would be triggered even if the instances
    are walking at different heights in the level, causing false reactions to non-existing
    collisions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于级别数据可能包含重叠的元素，例如桥梁、隧道或建筑物的多层，实例可能在二维空间中的同一位置。即使实例在级别中行走的高度不同，现有的碰撞检测也会被触发，导致对不存在的碰撞产生错误反应。
- en: We have to extend the quadtree to become an octree to support collision detection
    in all three dimensions. Let’s check out how to upgrade the quadtree.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将四叉树扩展为八叉树以支持三维空间中的碰撞检测。让我们看看如何升级四叉树。
- en: Converting the quadtree to an octree
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将四叉树转换为八叉树
- en: Updating the quadtree to an octree is astonishingly simple, and most of the
    work can be triggered by using the `Rename` function of the `Refactoring` functionality
    of the IDE. For brevity, we will just do a brief walkthrough of the required changes
    here. Please check the example code in the subfolders within the `chapter11` folder
    for the full octree code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将四叉树更新为八叉树非常简单，大部分工作可以通过使用 IDE 的重构功能中的 `Rename` 函数来触发。为了简洁，我们在这里只简要说明所需更改。请检查
    `chapter11` 文件夹内的子文件夹中的示例代码，以获取完整的八叉树代码。
- en: First, we change the name of the `quadtree` folder to `octree`. In the `CMakeLists.txt`
    file, the two occurrences of `quadtree` must be also renamed `octree` to match
    the folder name. And we rename the `QuadTree` class `Octree` and change `BoundingBox2D`
    to `BoundingBox3D`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 `quadtree` 文件夹的名称更改为 `octree`。在 `CMakeLists.txt` 文件中，必须将两个 `quadtree`
    的出现也重命名为 `octree` 以匹配文件夹名称。然后我们将 `QuadTree` 类重命名为 `Octree`，并将 `BoundingBox2D`
    改为 `BoundingBox3D`。
- en: 'Next, we extend the `Octree` class by using eight instead of four children.
    *Figure 11.3* shows the quadrant IDs of the octree:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用八个而不是四个子节点来扩展 `Octree` 类。*图 11.3* 展示了八叉树的象限 ID：
- en: '![](img/Figure_11.3_B22428.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_11.3_B22428.png)'
- en: 'Figure 11.3: Quadrant IDs in the octree'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：八叉树中的象限 ID
- en: The four existing child quadrant IDs, 0 to 3, will be used for the four front-facing
    octants, and the four back-facing octants will receive the new IDs 4 to 7\. Moving
    the four new octants to the back of the octree cuboid allows us to retain most
    of the logic from the quadtree. Adding the new logic to find the correct octant
    becomes merely an act of copying and pasting the code, taking front- and back-facing
    octants into account.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 四个现有的子象限ID，0到3，将用于四个面向前方的八分体，而四个面向后方的八分体将接收新的ID 4到7。将四个新的八分体移动到八叉树立方体的后面，使我们能够保留大部分来自四叉树的逻辑。添加新的逻辑以找到正确的八分体只是一个复制和粘贴代码的行为，同时考虑到面向前和面向后的八分体。
- en: Then, we update all `QuadTree`-related `include` statements, classes, and method
    calls in the code to `Octree`, and all `BoundingBox2D` occurrences to `BoundingBox3D`.
    The bounding box upgrade includes the change of all `glm::vec2` types of the old
    `BoundingBox2D` parameters to use `glm::vec3` instead. We also change the name
    of `getTopLeft()` to `getFrontTopLeft()` and add the `getBack()` method to reflect
    the availability of the third dimension.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将代码中所有与`QuadTree`相关的`include`语句、类和方法调用更新为`Octree`，并将所有`BoundingBox2D`出现更改为`BoundingBox3D`。边界框升级包括将旧`BoundingBox2D`参数的所有`glm::vec2`类型更改为使用`glm::vec3`。我们还更改了`getTopLeft()`的名称为`getFrontTopLeft()`，并添加了`getBack()`方法以反映第三维度的可用性。
- en: Finally, all callback function types in the code will be renamed from `quadTree`
    to `octree` to reflect the functionality change in all other places in the code
    too.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码中所有回调函数类型将从`quadTree`重命名为`octree`，以反映代码中其他所有位置的函数变化。
- en: Now we can use the octree to detect collisions in three dimensions. Sadly, the
    **Instance Positions** window still shows a top-down view of the instances, and
    we are unable to see if any instances are placed at different heights. We must
    adjust the rendering of the mini window containing the instances so that we can
    see any instances placed at different heights.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用八叉树来检测三维中的碰撞。遗憾的是，**实例位置**窗口仍然显示实例的俯视图，我们无法看到是否有实例放置在不同的高度。我们必须调整包含实例的迷你窗口的渲染，以便我们可以看到放置在不同高度的任何实例。
- en: Creating an interactive octree view
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建交互式八叉树视图
- en: 'The new octree view is created in three steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 新的八叉树视图创建分为三个步骤：
- en: For a better overview of the octree and the instances, the new view can be scaled,
    rotated, and translated by using the mouse. It may still take some extra rotations
    to align the octree with the camera view, but that is hard to do due to the orthogonal
    display and the symmetry of the octree. Fading out far away parts of the octree
    or highlighting the octant containing the camera may help to focus on the current
    area of interest. On the other hand, using a perspective projected octree may
    make it easier to find the right alignment, but the perspective will distort the
    distances between the instances, and we just create a copy of the main level rendering.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好地了解八叉树和实例，可以使用鼠标进行缩放、旋转和平移来调整新的视图。可能还需要一些额外的旋转来使八叉树与相机视图对齐，但由于正交显示和八叉树的对称性，这很难做到。淡出八叉树远处的部分或突出显示包含相机的八分体可能有助于集中注意当前感兴趣的区域。另一方面，使用透视投影的八叉树可能更容易找到正确的对齐，但透视会扭曲实例之间的距离，我们只是创建了一个主要级别渲染的副本。
- en: The lines of the octree quadrants and the instances are collected into a temporary
    data structure. We will use an `OGLLineMesh` here as this data type contains just
    the bare minimum; we need to draw ImGui lines.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 八叉树象限和实例的线条收集到一个临时数据结构中。我们将在这里使用`OGLLineMesh`，因为这个数据类型只包含最基本的内容；我们需要绘制ImGui线条。
- en: 'To achieve the desired view, all points of the octree quadrants and the instance
    bounding boxes must be transformed by the scaling, rotation, and translation from
    the first step. This transformation is done in the same way as we did for the
    cameras and instances: by creating a matrix and a matrix-vector multiplication
    for each point. There should be no surprises in the matrix operations; only the
    translation may need an explanation.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了达到期望的视图，必须将八叉树象限的所有点和实例边界框通过第一步中的缩放、旋转和平移进行变换。这种变换与我们对相机和实例所做的方式相同：为每个点创建一个矩阵和一个矩阵-向量乘法。矩阵运算中不应有任何意外；可能只有平移需要解释。
- en: Let’s step through the interactive part first.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先逐步了解交互部分。
- en: Adding interactivity
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加交互性
- en: 'To be able to change the octree view with the mouse button and mouse movements,
    we need three new private variables named `mOctreeZoomFactor`, `mOctreeRotation`,
    and `mOctreeTranslation` in the `UserInterface` class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够通过鼠标按钮和鼠标移动来更改八叉树视图，我们需要在 `UserInterface` 类中添加三个新的私有变量，分别命名为 `mOctreeZoomFactor`、`mOctreeRotation`
    和 `mOctreeTranslation`：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The names of the variables are self-explanatory, so we do not need to dive into
    the details here.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的名称是自解释的，因此我们不需要深入细节。
- en: 'Right after creating the **Instance Positions** window in the `createPositionsWindow()`
    method of the `UserInterface` class, we add a check to see if the current window
    has been hovered over:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UserInterface` 类的 `createPositionsWindow()` 方法中创建 **实例位置** 窗口后，我们添加一个检查以查看当前窗口是否被悬停：
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Without the check, the mouse buttons and motions would trigger the octree view
    changes in all windows, leading to unwanted results.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 没有检查，鼠标按钮和动作会在所有窗口中触发八叉树视图变化，导致不希望的结果。
- en: 'Then, we get a reference to the internal `io` structure of ImGui:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获取 ImGui 内部 `io` 结构的引用：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In ImGui’s `io` structure, many internal states are available, like changes
    made to the mouse wheel or the mouse position.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ImGui 的 `io` 结构中，有许多内部状态可用，如鼠标滚轮或鼠标位置所做的更改。
- en: We use the mouse wheel here to adjust the zoom factor of the octree view. Setting
    upper and lower bounds for the zoom factor helps to avoid losing the overview.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用鼠标滚轮来调整八叉树视图的缩放因子。为缩放因子设置上下限有助于避免失去整体概览。
- en: 'Next, we check if the right mouse button has been pressed and rotate the view
    according to the mouse movement while the right mouse button is still pressed:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否按下了右鼠标按钮，并在右鼠标按钮仍然按下的同时根据鼠标移动旋转视图：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using the right mouse button to change the rotation is also used for the camera,
    so this kind of view change should be known from working with the application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用右鼠标按钮来更改旋转也用于相机，因此这种视图变化应该从与应用程序一起工作时了解。
- en: 'Finally, we check for the middle mouse button, moving the octree around with
    the mouse motion:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们检查中间鼠标按钮，通过鼠标移动移动八叉树：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you wonder why we don’t use the left mouse button here: Pressing the left
    mouse button above an ImGui window activates the internal window movement. We
    have only the right and middle mouse buttons left to achieve two different view
    changes.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么这里不使用左鼠标按钮：在 ImGui 窗口上方按下左鼠标按钮会激活内部窗口移动。我们只剩下右键和中间鼠标按钮来实现两种不同的视图变化。
- en: Once we have the transformation we want to see, we can get the lines from the
    octree and the instances.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了想要看到的变换，我们就可以从八叉树和实例中获取线条。
- en: Collecting the lines
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 收集线条
- en: 'To store the lines before drawing, we add a `private` variable named `mOctreeLines`
    to the `UserInterface` class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在绘制之前存储线条，我们在 `UserInterface` 类中添加一个名为 `mOctreeLines` 的 `private` 变量：
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After clearing the vertices vector inside `mOctreeLines`, we get the octree
    lines:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在清除 `mOctreeLines` 内部的顶点向量后，我们得到八叉树线：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For every octree quadrant, we get a `BoundingBox3D` object, containing the
    minimum and maximum point positions. A conversion to an `AABB` is simple:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个八叉树象限，我们获取一个 `BoundingBox3D` 对象，包含最小和最大点位置。将其转换为 AABB 是简单的：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we use the `getAABBLines()` method to create all lines for the AABB as
    an `OGLLineMesh` and add the lines to the `mOctreeLines` mesh:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `getAABBLines()` 方法创建所有 AABB 线作为 `OGLLineMesh`，并将线条添加到 `mOctreeLines`
    网格中：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Next, we get AABB lines for every instance, coloring colliding instances red
    and all other instances yellow. The currently selected instance also gets an additional
    green border to be able to stop the instance easily.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为每个实例获取 AABB 线，将碰撞的实例着色为红色，其他所有实例着色为黄色。当前选中的实例还会额外获得一个绿色边框，以便能够轻松停止实例。
- en: At the end of the loops over both the octants and the instances, `mOctreeLines`
    contains vertices of all lines that should be drawn to the ImGui window. We now
    need to transform the vertices to match the selected scaling, rotation, and translation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在对八分体和实例的循环结束后，`mOctreeLines` 包含了应该绘制到 ImGui 窗口的所有线的顶点。我们现在需要将这些顶点转换以匹配所选的缩放、旋转和平移。
- en: Calculating the view and drawing the lines
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算视图和绘制线条
- en: 'Since storing intermediate results is faster than allocating and calculating
    a new transformation matrix for the octree lines in every frame, we add three
    more `private` member variables named `mScaleMat`, `mRotationMat`, and `mOctreeViewMat`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存储中间结果比在每一帧中为八叉树线分配和计算新的变换矩阵要快，我们添加了三个名为 `mScaleMat`、`mRotationMat` 和 `mOctreeViewMat`
    的 `private` 成员变量：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, scaling and the two rotations are applied to create the final view matrix:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应用缩放和两个旋转以创建最终的视图矩阵：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we loop over the vertices in `mOctreeLines` in groups of two since we need
    a starting point and ending point for each line:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们以两组为单位遍历 `mOctreeLines` 中的顶点，因为每条线需要一个起点和终点：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Inside the loop, we extract the vertex pair for each line and transform the
    vertex positions by multiplication with the `mOctreeViewMat`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们提取每条线的顶点对，并通过与 `mOctreeViewMat` 相乘来变换顶点位置：
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we add the point coordinates to the center of the drawing and add the
    translational part:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将点坐标添加到绘制中心，并添加平移部分：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We don’t need a separate translation matrix here because the movement of the
    octree lines is only related to the ImGui window, not the position of the vertices
    in 3D.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不需要单独的平移矩阵，因为八叉树线的移动仅与 ImGui 窗口有关，而不是三维中顶点的位置。
- en: 'At the end of the loop, we draw an ImGui line from the start point to the end
    point using the colors of the line and a fixed alpha value:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环结束时，我们使用线的颜色和固定的 alpha 值，从起点到终点绘制一个 ImGui 线：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we start the application after these changes, the octree view can be rotated
    by pressing the right mouse button, moved around by pressing the middle mouse
    button, and zoomed in and out by using the mouse wheel.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这些更改之后启动应用程序，可以通过按下鼠标右键旋转八叉树视图，通过按下鼠标中键移动，以及使用鼠标滚轮进行缩放和缩小：
- en: '*Figure 11.4* shows a view of the octree in the **Instance Positions** window:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11.4* 展示了在 **实例位置** 窗口中的八叉树视图：'
- en: '![](img/Figure_11.4_B22428.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4_B22428](img/Figure_11.4_B22428.png)'
- en: 'Figure 11.4: A rotated octree with instances and two subdivision levels'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：一个旋转的八叉树，包含实例和两个细分级别
- en: You can see the bounding boxes for all instances in three dimensions. Colliding
    instances are drawn in red, all other instances are yellow (the same colors as
    for the AABB debug lines), and the currently selected instance has an extra outline
    in green.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到所有实例在三维空间中的边界框。碰撞实例用红色绘制，所有其他实例用黄色（与 AABB 调试线的颜色相同），当前选定的实例有额外的绿色轮廓。
- en: Another important fact to see is the subdivision level of the octree. At the
    root level of the octree, one subdivision is divided into eight octants – this
    has happened because of the number of instances. In the far lower right octant,
    another subdivision was needed to limit the instance count per octant.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要看到的重要事实是八叉树的细分级别。在八叉树的根级别，一次细分被分成八个八分体——这是由于实例数量的原因。在远右下角的八分体中，需要另一个细分来限制每个八分体的实例数量。
- en: When the application is running, the movement of the instances and changes in
    the octree subdivision can be seen in real time. And the view can be changed to
    focus on any interesting area of the octree.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，可以实时看到实例的移动和八叉树细分的更改。并且可以更改视图以聚焦于八叉树的任何有趣区域。
- en: One drawback of the default octree implementation is the growing overhead. A
    subdivision may produce a lot of empty nodes, especially if the threshold per
    node is small and the tree depth is high. For our implementation, each subdivision
    into eight octants adds a memory overhead of roughly one kilobyte in memory usage,
    even if we need to store only one or two instance AABBs in one of the child octants.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 默认八叉树实现的一个缺点是不断增长的额外开销。细分可能会产生许多空节点，特别是如果每个节点的阈值较小且树深度较高时。对于我们的实现，每次将八叉树细分到八个八分体时，都会在内存使用上增加大约一千字节的开销，即使我们只需要在其中一个子八分体中存储一个或两个实例的
    AABB。
- en: Also, each subdivision adds another step to the traversal costs. Even though
    the traversal complexity grows only on a logarithmic basis, the overhead in memory
    and traversal time may become significant in larger levels. In this case, a data
    structure such as a sparse voxel octree could be used instead. A link to a paper
    describing the principles of sparse voxel octrees is available in the *Additional
    resources* section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每次细分都会增加遍历成本的一个步骤。尽管遍历复杂度仅以对数为基础增长，但在较大级别中，内存和遍历时间上的开销可能会变得显著。在这种情况下，可以使用诸如稀疏体素八叉树之类的数据结构。在
    *附加资源* 部分提供了一个描述稀疏体素八叉树原理的论文链接。
- en: A shortcoming of the current level loading is a missing “feeling” about the
    dimensions of the loaded level data. If the level is not flat but contains areas
    with different heights, it is hard to imagine the edges of the level data.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当前级别加载的一个缺点是缺少对加载的级别数据尺寸的“感觉”。如果级别不是平的，而是包含不同高度的区域，那么想象级别数据的边缘是很困难的。
- en: To get a better orientation, we will also add an AABB for the level data.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更好的方向，我们还将为级别数据添加一个AABB。
- en: Building an AABB for the level data
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为级别数据构建AABB
- en: Axis-aligned bounding boxes are a great tool to avoid estimating or guessing
    the dimensions of an object. We are using model instance AABBs as a solution to
    detect collisions by allowing the application to compare the maximum extents of
    two instances.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 轴对齐边界框是避免估计或猜测对象尺寸的一个很好的工具。我们使用模型实例AABB作为解决方案，通过允许应用程序比较两个实例的最大范围来检测碰撞。
- en: While unused areas between the vertices of the instances and the bounding box
    are a trade-off between speed and complexity for collision detection, the situation
    is different for level data. The AABB lines will help us to see the maximum extent
    of the level in all three dimensions, especially when the level data has large
    unused areas.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实例顶点和边界框之间的未使用区域在碰撞检测的速度和复杂性之间是一个权衡，但对于级别数据来说，情况是不同的。AABB线将帮助我们看到级别在所有三个维度上的最大范围，特别是当级别数据有大量未使用区域时。
- en: 'Creating the AABB is done quick and simple. First, we add a new private member
    variable called `mLevelAABB` in the `AssimpLevel.h` file to store the AABB:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 创建AABB的过程既快又简单。首先，我们在 `AssimpLevel.h` 文件中添加一个新的私有成员变量 `mLevelAABB` 来存储AABB：
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To generate and retrieve the bounding box data, we add two new public methods,
    `generateAABB()` and `getAABB()`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成和检索边界框数据，我们添加了两个新的公共方法，`generateAABB()` 和 `getAABB()`：
- en: '[PRE23]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Splitting the generation of the AABB data from the retrieval is a clever idea
    as the levels may contain a lot of meshes and vertices. A recalculation is only
    needed if we adjust the level properties such as the scaling or position since
    the level data does not move or change other properties by itself.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将AABB数据的生成与检索分开是一个巧妙的主意，因为级别可能包含大量的网格和顶点。只有在调整级别属性（如缩放或位置）时才需要重新计算，因为级别数据本身不会移动或改变其他属性。
- en: 'We already have the transformation matrix for the level data, so calculating
    the bounding box for the level in `generateAABB()` is only a loop over all vertices
    of all meshes:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了级别数据的变换矩阵，因此计算 `generateAABB()` 中级别的边界框只需要遍历所有网格的所有顶点：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A crucial step here is changing the `w` element of the vertex position. We are
    using the last element of the position to transport one texture coordinate to
    the shader. For a correct matrix multiplication, we must set the last element
    of position to `1.0f`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的一个关键步骤是改变顶点位置中的 `w` 元素。我们使用位置的最后元素来传输一个纹理坐标到着色器。为了正确的矩阵乘法，我们必须将位置的最后元素设置为
    `1.0f`。
- en: 'To trigger an automatic update of the level AABB during property changes of
    the level, we add a simple callback to `Callbacks.h`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在级别属性变化时触发级别AABB的自动更新，我们在 `Callbacks.h` 中添加了一个简单的回调：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `ModelInstanceCamData` `struct`, another callback function is added:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ModelInstanceCamData` 结构体中，添加了另一个回调函数：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We bind the `micLevelGenerateAABBCallbackFunction` callback to the `generateLevelAABB()`
    method in the `init()` method of the renderer, along with the other level data
    callbacks.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在渲染器的 `init()` 方法中将 `micLevelGenerateAABBCallbackFunction` 回调绑定到 `generateLevelAABB()`
    方法，以及其他级别数据回调。
- en: To get a nice interactive display in the user interface, we add a Boolean named
    `settingChangedForAABB` to the **Levels** section. On every slider or checkbox
    change, or when pressing the **Reset Values to Zero** button, we trigger a recalculation
    of the level’s AABB.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在用户界面中获得良好的交互式显示，我们在 **Levels** 部分添加了一个名为 `settingChangedForAABB` 的布尔值。在每次滑块或复选框更改时，或者在按下
    **重置值到零** 按钮时，我们触发级别AABB的重新计算。
- en: And what about other static level elements? These objects are called **assets**
    and can be added to a level. Assets also need collision checks to prevent the
    instances from running right through each other, but assets are mostly not animated;
    they remain in the place intended by the level designers.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 那其他静态级别元素呢？这些对象被称为 **assets**，并且可以被添加到级别中。资产也需要碰撞检查以防止实例直接穿过彼此，但资产大多数情况下不是动画化的；它们保持在级别设计师意图的位置。
- en: We will use a shortcut here and utilize the non-animated models to mimic static
    level assets. For dynamic assets, such as buttons or doors, animated models can
    be used; see the *Level data does not move around* section for a brief explanation.
    In the *Practical sessions* section, a task to add dynamic assets to the virtual
    world is available.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将使用快捷方式，并利用非动画模型来模拟静态级别资产。对于动态资产，如按钮或门，可以使用动画模型；请参阅*级别数据不会移动*部分以获得简要说明。在*实际操作*部分，有一个将动态资产添加到虚拟世界的任务。
- en: So, let’s see what changes are needed for the non-animated models.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看非动画模型需要哪些更改。
- en: Using non-animated models as assets
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用非动画模型作为资产
- en: To avoid adding a new `AssimpAsset` class with mostly the same functionality
    as the non-animated models, we will extend the current `AssimpModel` class and
    the renderer a bit.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免添加一个与大多数非动画模型具有相同功能的新`AssimpAsset`类，我们将稍微扩展当前的`AssimpModel`类和渲染器。
- en: 'For the model class, we change the `getAABB()` method to return either a dynamic
    AABB for models with animations or a static AABB for models without animations:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模型类，我们将`getAABB()`方法改为返回具有动画的模型的动态AABB或没有动画的模型的静态AABB：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The new method, `getAnimatedAABB()`, is just a new name for the old `getAABB()`
    method, and it calculates the AABB from the lookup data as before. The other new
    method, `getNonAnimatedAABB()`, is mostly the `updateModelRootMatrix()` method
    from the `AssimpInstance` class.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`getAnimatedAABB()`方法只是旧`getAABB()`方法的新名称，它仍然像以前一样从查找数据中计算AABB。另一个新方法`getNonAnimatedAABB()`主要是`AssimpInstance`类中的`updateModelRootMatrix()`方法。
- en: 'First, we calculate a separate matrix for scaling, rotation, axis swap, and
    translation:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算一个用于缩放、旋转、轴交换和平移的单独矩阵：
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, the transformation matrices and the root transformation matrix from the
    model file are combined into a single transform matrix:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将模型文件中的变换矩阵和根变换矩阵组合成一个单一的变换矩阵：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To create the bounding box data, all vertices of the model mesh are transformed
    to the new positions and the positions are added to a local variable named `modelAABB`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建边界框数据，将模型网格的所有顶点转换到新位置，并将位置添加到名为`modelAABB`的局部变量中：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For the `w` element of the vertex position, the same adjustment as for the level
    data AABB is needed. By setting the last value to `1.0f`, we guarantee a correct
    matrix multiplication when computing the final position.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于顶点位置中的`w`元素，需要与级别数据AABB相同的调整。通过将最后一个值设置为`1.0f`，我们确保在计算最终位置时进行正确的矩阵乘法。
- en: With the resulting AABB, the extents of the non-animated instance vertices are
    able to detect AABB collisions with animated models and to draw the debug lines.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用得到的AABB，非动画实例顶点的范围能够检测与动画模型的AABB碰撞并绘制调试线。
- en: Performance considerations for asset AABBs
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 资产AABB的性能考虑
- en: Currently, the AABB for non-animated instances is calculated for every instance
    in every frame, like the AABB for the animated instances. If the calculation becomes
    a bottleneck, for example, if a lot of static assets are placed in the virtual
    world, changing the AABB computation only on property changes in the UI can be
    done easily.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，非动画实例的AABB在每一帧的每个实例上都会计算，就像动画实例的AABB一样。如果计算成为瓶颈，例如，如果虚拟世界中放置了大量的静态资产，可以在UI属性更改时轻松地仅更改AABB计算。
- en: Once the level data has been loaded and processed and the AABBs are calculated,
    we are ready to draw the level triangles to the screen.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦级别数据被加载和处理，AABB被计算，我们就准备好将级别三角形绘制到屏幕上。
- en: Let’s extend the renderer to add the level data to the rendering process.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展渲染器以将级别数据添加到渲染过程中。
- en: Sending the level data to the GPU
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将级别数据发送到GPU
- en: With every addition of new features, it becomes simpler to reuse code in the
    application. In the case of level data, mesh data is encapsulated in the `AssimpLevel`
    class, and drawing the level’s triangles can be done in a small loop over all
    loaded levels.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新功能的不断增加，在应用程序中重用代码变得更加简单。在级别数据的情况下，网格数据封装在`AssimpLevel`类中，并且可以通过遍历所有加载的级别的小循环来绘制级别的三角形。
- en: As the first step, we create a new shader to draw the level data.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们创建一个新的着色器来绘制级别数据。
- en: Creating a new shader
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的着色器
- en: 'Since we need to draw the level triangles only once, using a separate shader
    for the level data is a clever idea. Add the `private` shader named `mAssimpLevelShader`
    to the header file of the renderer class:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只需要绘制等级三角形一次，因此为等级数据使用单独的着色器是一个巧妙的主意。将名为 `mAssimpLevelShader` 的 `private`
    着色器添加到渲染器类的头文件中：
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The shader will use the two new files, `assimp_level.vert` for the vertex shader
    and `assimp_level.frag` for the fragment shader. We load the files along with
    the other shaders in the `init()` method of the renderer:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器将使用两个新文件，`assimp_level.vert` 用于顶点着色器，`assimp_level.frag` 用于片段着色器。我们在渲染器的
    `init()` 方法中加载这些文件以及其他着色器：
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The fragment shader file, `assimp_level.frag`, is just a copy of the `assimp.frag`
    file without any changes. For the vertex shader file, `assimp_level.vert`, we
    can copy the `assimp.vert` file and keep the `in` and `out` layout portion and
    the `Matrices` uniform buffer.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器文件 `assimp_level.frag` 只是 `assimp.frag` 文件的副本，没有任何更改。对于顶点着色器文件 `assimp_level.vert`，我们可以复制
    `assimp.vert` 文件，并保留 `in` 和 `out` 布局部分以及 `Matrices` 通用缓冲区。
- en: 'We don’t need the selection buffer since no visual selection has been implemented
    for the level data, and we can change the buffer at binding point `1` to contain
    only a single 4x4 matrix:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于等级数据尚未实现视觉选择，我们不需要选择缓冲区，并且可以将绑定点 `1` 的缓冲区更改为仅包含单个 4x4 矩阵：
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Uploading only small data elements like a single matrix to a uniform buffer
    on the GPU is not the best idea as every upload may add a small delay to the frame.
    For a real game, or a game engine, the world transform matrix would be part of
    a bigger buffer, but for the sake of simplicity we just do the single upload here.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 仅将小型数据元素，如单个矩阵，上传到 GPU 上的统一缓冲区并不是最佳方案，因为每次上传都可能给帧添加一小段延迟。对于真正的游戏或游戏引擎，世界变换矩阵将是更大缓冲区的一部分，但为了简单起见，我们在这里只进行单次上传。
- en: 'In the `main()` method of the vertex shader, we use the `worldTransformMat`
    to transform the position and normal vertices to the final position given by the
    matrix created from the level properties:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器的 `main()` 方法中，我们使用 `worldTransformMat` 将位置和法线顶点变换到由等级属性创建的矩阵给出的最终位置：
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, in the `draw()` method of the renderer, we loop over all levels and skip
    the null level by checking for the existence of any triangles:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在渲染器的 `draw()` 方法中，我们遍历所有等级，并通过检查是否存在任何三角形来跳过空等级：
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As the last step of the level display process, the vertex drawing is triggered:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在等级显示过程的最后一步，触发顶点绘制：
- en: '[PRE36]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We use the new `mAssimpLevelShader`, upload the transformation matrix of the
    level to the shader, and call the `draw()` method of the `AssimpLevel` object.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用新的 `mAssimpLevelShader`，将等级的变换矩阵上传到着色器，并调用 `AssimpLevel` 对象的 `draw()` 方法。
- en: Drawing the level AABB on the screen requires a few more methods and member
    variables in the renderer.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上绘制等级 AABB 需要在渲染器中添加更多方法和成员变量。
- en: Drawing the level AABB
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制等级 AABB
- en: 'The level AABB vertices are stored in a new `private` member variable named
    `mAllLevelAABB` in the renderer class:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 等级 AABB 顶点存储在渲染器类中的一个名为 `mAllLevelAABB` 的新 `private` 成员变量中：
- en: '[PRE37]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Also, two new private methods named `generateLevelAABB()` and `drawLevelAABB()`
    are added to the renderer class:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还向渲染器类中添加了两个名为 `generateLevelAABB()` 和 `drawLevelAABB()` 的新私有方法：
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We also split generating and drawing the AABB lines here to avoid costly calculations
    in every frame we draw.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里也将生成和绘制 AABB 线分开，以避免在每帧绘制时进行昂贵的计算。
- en: 'Generating the level AABB in `generateLevelAABB()` is done in a simple loop.
    After clearing the level AABB data, we loop over all loaded levels:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `generateLevelAABB()` 中生成等级 AABB 是通过一个简单的循环完成的。在清除等级 AABB 数据后，我们遍历所有已加载的等级：
- en: '[PRE39]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The check for a level without triangles skips the null level since there is
    nothing to draw to the screen. Then, we generate the AABB of each level and add
    the minimum and maximum extents of each level to `mAllLevelAABB`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 检查没有三角形的等级会跳过空等级，因为屏幕上没有东西可以绘制。然后，我们为每个等级生成 AABB 并将每个等级的最小和最大范围添加到 `mAllLevelAABB`：
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The resulting AABB contains all the level data of all the loaded levels. If
    you want to have separate AABBs for each level, you could use a vector of AABBs
    instead the single AABB.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 AABB 包含所有已加载等级的所有等级数据。如果您想为每个等级单独拥有 AABB，则可以使用 AABB 向量而不是单个 AABB。
- en: 'Drawing the level AABB in the `drawLevelAABB()` method needs little explanation:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `drawLevelAABB()` 方法中绘制等级 AABB 需要很少的解释：
- en: '[PRE41]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We use the `getAABBLines()` method of the AABB to create the line data, upload
    the lines to the `mLineVertexBuffer`, call `use()` on `LineShader`, and then call
    `bindAndDraw()` on the `mLineVertexBuffer` object to draw the axis-aligned bounding
    box of the level data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 AABB 的 `getAABBLines()` 方法创建线数据，将线上传到 `mLineVertexBuffer`，在 `LineShader`
    上调用 `use()`，然后对 `mLineVertexBuffer` 对象调用 `bindAndDraw()` 以绘制级别数据的轴对齐边界框。
- en: 'Then, in the `draw()` method of the renderer, we call `drawLevelAABB()` when
    `rdDrawLevelAABB` is set to `true`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在渲染器的 `draw()` 方法中，当 `rdDrawLevelAABB` 设置为 `true` 时，我们调用 `drawLevelAABB()`：
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The color has been chosen randomly, you may change the color value or even add
    a 3-element float slider to the UI to control the color value.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色是随机选择的，你可以更改颜色值，甚至可以向 UI 添加一个 3 元素浮点滑块来控制颜色值。
- en: 'Showing the level AABB lines on screen is done by a new Boolean variable called
    `rdDrawLevelAABB` in the `OGLRenderData` `struct` in the `OGLRenderData.h` file:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上显示级别 AABB 线是通过在 `OGLRenderData.h` 文件中的 `OGLRenderData` `struct` 中的新布尔变量
    `rdDrawLevelAABB` 实现的：
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For the Vulkan version of the code, the variable will be created in the `VKRenderData`
    struct in the `VkRenderData.h` file.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码的 Vulkan 版本，该变量将在 `VkRenderData.h` 文件中的 `VKRenderData` `struct` 中创建。
- en: In the `UserInterface` class, we add a checkbox for `rdDrawLevelAABB` in the
    **Levels** section of the `createSettingsWindow()` method, allowing us to toggle
    the level’s AABB lines.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UserInterface` 类中，我们在 `createSettingsWindow()` 方法的 `Levels` 部分添加了一个复选框 `rdDrawLevelAABB`，允许我们切换级别的
    AABB 线。
- en: 'That’s all! In *Figure 11.5*, an example map from Sketchfab has been loaded
    next to the woman model, and the level’s AABB was activated:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！在 *图 11.5* 中，一个来自 Sketchfab 的示例地图被加载在女性模型旁边，并且激活了级别的 AABB：
- en: '![](img/Figure_11.5_B22428.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_11.5_B22428.png)'
- en: 'Figure 11.5: Example map (unscaled) and an instance of the woman model (source:
    Counter Strike 1.6 map “de_dust” by Zarudko at https://skfb.ly/6QYJw)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：示例地图（未缩放）和女性模型的实例（来源：Counter Strike 1.6 地图“de_dust”由 Zarudko 制作，链接：https://skfb.ly/6QYJw）
- en: 'As a gamer, you may know this map: It’s “de_dust” from Counter Strike 1.6\.
    The map is available at Sketchfab in several versions and formats, along with
    other popular game maps.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名玩家，你可能知道这个地图：它是 Counter Strike 1.6 中的“de_dust”。这个地图在 Sketchfab 上有多个版本和格式，以及其他流行的游戏地图。
- en: The bounding box around the level data helps us to see the dimensions of the
    level. Especially for unused areas like in the front right of *Figure 11.5*, finding
    the boundaries of the level data would be hard without the AABB lines.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕级别数据的边界框帮助我们看到级别的尺寸。特别是对于如图 11.5 前右部所示的未使用区域，没有 AABB 线，很难找到级别数据边界。
- en: You will also notice the unusual size ratio between the level map and the model
    instance. The map and model have been loaded with their default scaling values,
    and the size values have been chosen arbitrarily by the author of the files. Resizing
    one or both objects is easy thanks to the scaling slider for model and level data,
    but getting a reasonable ratio between levels, models, and other objects from
    various sources and artists can become challenging.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到地图实例之间不寻常的大小比例。地图和模型已经使用它们的默认缩放值加载，大小值是由文件作者任意选择的。由于模型和级别数据的缩放滑块，调整一个或两个对象的大小很容易，但要从不同来源和艺术家那里获取合理的级别、模型和其他对象的比例可能具有挑战性。
- en: To create a plausible virtual world, the sizes of the game character models
    must match the sizes of furniture, buildings, environmental objects, and so on.
    Even a small mismatch in the proportions of different objects will be visible
    when comparing game characters and objects with the real world. A good way to
    adjust the different elements is to use one fixed-size object with a known size,
    such as a block from Minecraft, which has a (virtual) edge length of one meter,
    or even a simple line of a defined length in the virtual world. By resizing all
    objects to their real-world sizes compared to the known object, models from different
    sources can be made to match visually.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个合理的虚拟世界，游戏角色模型的大小必须与家具、建筑、环境对象等的大小相匹配。即使不同对象的比例有微小的不匹配，当比较游戏角色和现实世界中的对象时，也会变得明显。调整不同元素的一个好方法是使用一个已知大小的固定大小对象，例如一个边长为一米的
    Minecraft 块，或者虚拟世界中一个定义长度的简单线条。通过将所有对象调整到与已知对象的真实世界大小相比，来自不同来源的模型可以在视觉上匹配。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added static level data to the virtual world. After exploring
    the differences between level maps and models, we looked at suitable file formats
    for level data and how to find cool game maps. Then, we added support for level
    data to the application and replaced the quadtree with an octree to support collision
    detection in three dimensions. Finally, we added the new level data and a level
    AABB to the renderer. We will extend the level data in the next two chapters to
    create a virtual world where the instances can roam around freely and by themselves.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将静态层级数据添加到虚拟世界中。在探索了层级图和模型之间的差异后，我们研究了适合层级数据的文件格式以及如何找到酷炫的游戏地图。然后，我们将对层级数据的支持添加到应用程序中，并用八叉树替换四叉树以支持三维碰撞检测。最后，我们将新的层级数据和层级AABB添加到渲染器中。在接下来的两个章节中，我们将扩展层级数据，以创建一个实例可以自由漫游的虚拟世界。
- en: In the next chapter, we will continue the collision detection from [*Chapter
    8*](Chapter_8.xhtml). First, we will extend the existing code to support collisions
    between instances and the level geometry. To ensure the instances are always on
    the ground, we will introduce gravity in the virtual world. As the last step,
    we add inverse kinematics to the legs of the instances, allowing the model to
    climb stairs or slopes with natural motion.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续从[*第8章*](Chapter_8.xhtml)的碰撞检测。首先，我们将扩展现有代码以支持实例和层级几何之间的碰撞。为了确保实例始终在地面，我们将在虚拟世界中引入重力。作为最后一步，我们将逆运动学添加到实例的腿部，允许模型以自然运动爬楼梯或斜坡。
- en: Practical sessions
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践课程
- en: 'Here are some additions you could make to the code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些你可以添加到代码中的改进：
- en: Add a door or a button to the level.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向层级中添加一个门或按钮。
- en: Since the animated level data is more like an animated character model placed
    at a fixed position in the level than static level data, you could try to add
    doors, switches, or buttons to the level, and instead of waving back on interaction,
    the button could play a “pressed” animation, and a door could revolve around the
    hinge or slide to one side.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于动画层级数据更像是放置在层级固定位置的动画角色模型，而不是静态层级数据，你可以尝试在层级中添加门、开关或按钮，并且在与交互时，按钮可以播放“按下”动画，门可以绕着铰链旋转或向一侧滑动。
- en: Add dynamic level loading.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加动态层级加载。
- en: You could use the information about the current position of the playable character
    to decide when to load or unload parts of the level. Maybe add a new mapping of
    coordinates where a specified level data file is loaded, and another coordinate
    where the level data is removed from the application. If you have added animated
    level objects from the first task to the dynamic level part, make sure to save
    the status of these objects on unloading and restore the state when reloading
    the level data. The player could open a door or activate a switch, and upon returning
    to the level part, the player could see the object in the exact same state as
    they left it. To prevent crashes or data corruption caused by assets that are
    not fully loaded or destroyed, use atomic operations or locking mechanisms such
    as mutexes. Also, loading and level data and assets may need synchronization to
    restore the correct state of all elements.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用关于可玩角色当前位置的信息来决定何时加载或卸载层级的一部分。也许可以添加一个新的坐标映射，其中指定加载层级数据文件，另一个坐标用于从应用程序中移除层级数据。如果你已经从第一个任务中添加了动画层级对象到动态层级部分，确保在卸载时保存这些对象的状态，并在重新加载层级数据时恢复状态。玩家可以打开门或激活开关，当返回到层级部分时，玩家可以看到对象处于他们离开时的确切状态。为了防止由于未完全加载或销毁的资产导致的崩溃或数据损坏，请使用原子操作或互斥锁等锁定机制。此外，加载和层级数据以及资产可能需要同步以恢复所有元素的正确状态。
- en: 'Expert difficulty: Load dynamic level parts asynchronously.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专家难度：异步加载动态层级部分。
- en: Loading a level file, processing the data, and adding the vertex data takes
    some time, resulting in a visible hitch in the application. Use `std::async` or
    a full worker thread to trigger the loading when a condition to load is met, for
    instance, when the player is at a specific world position. Be aware that adding
    any asynchronous code requires extra measures against data races.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 加载层级文件、处理数据和添加顶点数据需要一些时间，导致应用程序中出现明显的卡顿。当满足加载条件时，例如玩家位于特定的世界位置时，使用`std::async`或完整的工人线程来触发加载。请注意，添加任何异步代码都需要采取额外措施以防止数据竞争。
- en: Additional resources
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 补充资源
- en: 'Efficient sparse voxel octrees: [https://www.nvidia.com/docs/IO/88972/nvr-2010-001.pdf](https://www.nvidia.com/docs/IO/88972/nvr-2010-001.pdf)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效的稀疏体素八叉树：[https://www.nvidia.com/docs/IO/88972/nvr-2010-001.pdf](https://www.nvidia.com/docs/IO/88972/nvr-2010-001.pdf)
- en: 'Blender map creation 1: [https://www.youtube.com/watch?v=IKkOLeAuEHI](https://www.youtube.com/watch?v=IKkOLeAuEHI)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blender 地图创建 1：[https://www.youtube.com/watch?v=IKkOLeAuEHI](https://www.youtube.com/watch?v=IKkOLeAuEHI)
- en: 'Blender map creation 2: [https://www.youtube.com/watch?v=hdyBgQ77Sdg](https://www.youtube.com/watch?v=hdyBgQ77Sdg)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blender 地图创建 2：[https://www.youtube.com/watch?v=hdyBgQ77Sdg](https://www.youtube.com/watch?v=hdyBgQ77Sdg)
- en: 'What is a lightmap?: [http://wiki.polycount.com/wiki/Light_map](http://wiki.polycount.com/wiki/Light_map)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是光照贴图？：[http://wiki.polycount.com/wiki/Light_map](http://wiki.polycount.com/wiki/Light_map)
- en: 'Navigation mesh explanation: [https://medium.com/@mscansian/a-with-navigation-meshes-246fd9e72424](https://medium.com/@mscansian/a-with-navigation-meshes-246fd9e72424)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航网格解释：[https://medium.com/@mscansian/a-with-navigation-meshes-246fd9e72424](https://medium.com/@mscansian/a-with-navigation-meshes-246fd9e72424)
- en: 'HLOD: [https://gamma.cs.unc.edu/HLOD/](https://gamma.cs.unc.edu/HLOD/)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HLOD：[https://gamma.cs.unc.edu/HLOD/](https://gamma.cs.unc.edu/HLOD/)
- en: 'How to write glTF custom extensions: [https://gltf-transform.dev/extensions](https://gltf-transform.dev/extensions)'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写 glTF 自定义扩展：[https://gltf-transform.dev/extensions](https://gltf-transform.dev/extensions)
- en: 'itch.io Assets: [https://itch.io/game-assets](https://itch.io/game-assets)'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: itch.io 资产：[https://itch.io/game-assets](https://itch.io/game-assets)
- en: 'Sketchfab for models, maps, and assets: [https://sketchfab.com](https://sketchfab.com)'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sketchfab 用于模型、地图和资产：[https://sketchfab.com](https://sketchfab.com)
- en: 'Free3D: [https://free3d.com](https://free3d.com)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Free3D：[https://free3d.com](https://free3d.com)
- en: 'Counter Strike 1.6 map “de_dust” by Zarudko: [https://skfb.ly/6QYJw](https://skfb.ly/6QYJw)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zarudko 制作的 Counter Strike 1.6 地图“de_dust”：[https://skfb.ly/6QYJw](https://skfb.ly/6QYJw)
- en: Join our community on Discord
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间，与作者和其他读者进行讨论：[https://packt.link/cppgameanimation](https://packt.link/cppgameanimation)
- en: '![A qr code with black squares  AI-generated content may be incorrect.](img/QR_code_Discord.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![带有黑色方块的二维码 AI生成的内容可能不正确。](img/QR_code_Discord.png)'
