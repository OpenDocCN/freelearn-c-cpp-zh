- en: '*Chapter 1*: Saving Resources When Building LLVM'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：构建 LLVM 时节省资源'
- en: LLVM is the state-of-the-art compiler optimization and code generation framework
    adopted by many amazing industrial and academic projects, such as the **Just-In-Time**
    (**JIT**) compiler in JavaScript engines and **machine learning** (**ML**) frameworks.
    It is a useful toolbox for building programming languages and binary file tools.
    However, despite the project's robustness, its learning resources are scattered,
    and it doesn't have the best documentation either. Due to this, it has a pretty
    steep learning curve, even for developers with some LLVM experience. This book
    aims to tackle these issues by providing you with knowledge of common and important
    domains in LLVM in a pragmatic fashion – showing you some useful engineering tips,
    pointing out lesser-known but handy features, and illustrating useful examples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM 是许多令人惊叹的工业和学术项目采用的先进编译器优化和代码生成框架，例如 JavaScript 引擎中的 **即时编译器**（**JIT**）和
    **机器学习**（**ML**）框架。它是构建编程语言和二进制文件工具的有用工具箱。然而，尽管该项目非常稳健，但其学习资源分散，而且文档也不是最好的。正因为如此，即使是有些
    LLVM 经验的开发者，其学习曲线也相当陡峭。本书旨在通过以实用方式向您提供 LLVM 中常见和重要领域知识来解决这些问题——向您展示一些有用的工程技巧，指出一些不太为人所知但实用的功能，并举例说明有用的示例。
- en: As an **LLVM** developer, building LLVM from source has always been the first
    thing you should do. Given the scale of LLVM nowadays, this task can take hours
    to finish. Even worse, rebuilding the project to reflect changes might also take
    a long time and hinder your productivity. Therefore, it's crucial to know how
    to use the right tools and how to find the best build configurations for your
    project for the sake of saving various resources, especially your precious time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 **LLVM** 开发者，从源代码构建 LLVM 总是您应该做的第一件事。鉴于 LLVM 当前的规模，这项任务可能需要数小时才能完成。更糟糕的是，重建项目以反映更改也可能需要很长时间，从而阻碍您的生产力。因此，了解如何使用正确的工具以及如何为您的项目找到最佳的构建配置，以节省各种资源，尤其是您宝贵的时间，这一点至关重要。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Cutting down building resources with better tooling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过更好的工具减少构建资源
- en: Saving building resources by tweaking CMake arguments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调整 CMake 参数节省构建资源
- en: Learning how to use GN, an alternative LLVM build system, and its pros and cons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用 GN，一个替代的 LLVM 构建系统，以及其优缺点
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'At the time of writing this book, LLVM only has a few software requirements:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，LLVM 只有一些软件要求：
- en: A C/C++ compiler that supports C++14
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 C++14 的 C/C++ 编译器
- en: CMake
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake
- en: One of the build systems supported by CMake, such as GNU Make or Ninja
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake 支持的构建系统之一，例如 GNU Make 或 Ninja
- en: Python (2.7 is fine too, but I strongly recommend using 3.x)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python（2.7 也行，但我强烈建议使用 3.x）
- en: zlib
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: zlib
- en: The exact versions of these items change from time to time. Check out [https://llvm.org/docs/GettingStarted.html#software](https://llvm.org/docs/GettingStarted.html#software)
    for more details.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目的确切版本会不时发生变化。有关更多详细信息，请参阅 [https://llvm.org/docs/GettingStarted.html#software](https://llvm.org/docs/GettingStarted.html#software)。
- en: 'This chapter assumes you have built an LLVM before. If that''s not the case,
    perform the following steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您之前已经构建过 LLVM。如果不是这样，请执行以下步骤：
- en: 'Grab a copy of the LLVM source tree from GitHub:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 GitHub 获取 LLVM 源代码树副本：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Usually, the default branch should build without errors. If you want to use
    release versions that are more stable, such as release version 10.x, use the following
    command:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，默认分支应该无错误地构建。如果您想使用更稳定的发布版本，例如 10.x 版本的发布版本，请使用以下命令：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, you should create a build folder where you''re going to invoke the
    CMake command. All the building artifacts will also be placed inside this folder.
    This can be done using the following command:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您应该创建一个构建文件夹，您将在其中调用 CMake 命令。所有构建工件也将放置在这个文件夹中。可以使用以下命令完成此操作：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Cutting down building resources with better tooling
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过更好的工具减少构建资源
- en: 'As we mentioned at the beginning of this chapter, if you build LLVM with the
    default (CMake) configurations, by invoking **CMake** and building the project
    in the following way, there is a high chance that the whole process will take
    *hours* to finish:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所述，如果您使用默认（CMake）配置构建 LLVM，通过以下方式调用 **CMake** 并构建项目，整个过程可能需要 *数小时* 才能完成：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This can be avoided by simply using better tools and changing some environments.
    In this section, we will cover some guidelines to help you choose the right tools
    and configurations that can both speed up your building time and improve memory
    footprints.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过简单地使用更好的工具和更改一些环境来避免。在本节中，我们将介绍一些指导原则，以帮助您选择正确的工具和配置，这些工具和配置既可以加快您的构建时间，又可以改善内存占用。
- en: Replacing GNU Make with Ninja
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用 Ninja 替换 GNU Make
- en: The first improvement we can do is using the **Ninja** build tool ([https://ninja-build.org](https://ninja-build.org))
    rather than GNU Make, which is the default build system generated by CMake on
    major Linux/Unix platforms.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第一个改进是使用 **Ninja** 构建工具 ([https://ninja-build.org](https://ninja-build.org))
    而不是 GNU Make，这是 CMake 在主要 Linux/Unix 平台上生成的默认构建系统。
- en: 'Here are the steps you can use to set up Ninja on your system:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些步骤可以帮助你在系统上设置 Ninja：
- en: 'On Ubuntu, for example, you can install Ninja by using this command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，在 Ubuntu 上，你可以使用以下命令安装 Ninja：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Ninja is also available in most Linux distributions.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ninja 也适用于大多数 Linux 发行版。
- en: 'Then, when you''re invoking CMake for your LLVM build, add an extra argument:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，当你在构建 LLVM 时调用 CMake，请添加一个额外的参数：
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, use the following build command instead:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下构建命令代替：
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Ninja runs *significantly* faster than GNU Make on large code bases such as
    LLVM. One of the secrets behind Ninja's blazing fast running speed is that while
    the majority of build scripts such as `Makefile` are designed to be written manually,
    the syntax of Ninja's build script, `build.ninja`, is more similar to assembly
    code, which should *not* be edited by developers but generated by other higher-level
    build systems such as CMake. The fact that Ninja uses an assembly-like build script
    allows it to do many optimizations under the hood and get rid of many redundancies,
    such as slower parsing speeds, when invoking the build. Ninja also has a good
    reputation for generating better dependencies among build targets.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型代码库如 LLVM 上，Ninja 比 GNU Make 运行得**显著**更快。Ninja 运行速度极快的一个秘密是，尽管大多数构建脚本如 `Makefile`
    都是设计为手动编写的，但 Ninja 的构建脚本 `build.ninja` 的语法更类似于汇编代码，这应该**不应该**由开发者编辑，而应该由其他高级构建系统如
    CMake 生成。Ninja 使用类似汇编的构建脚本的事实使得它能够在幕后进行许多优化，并消除许多冗余，例如在调用构建时的较慢解析速度。Ninja 在生成构建目标之间的依赖关系方面也有很好的声誉。
- en: 'Ninja makes clever decisions in terms of its *degree of parallelization*; that
    is, how many jobs you want to execute in parallel. So, usually, you don''t need
    to worry about this. If you want to explicitly assign the number of worker threads,
    the same command-line option used by GNU Make still works here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Ninja 在其**并行化程度**方面做出了聪明的决策；也就是说，你想要并行执行多少个作业。所以，通常你不需要担心这一点。如果你想显式地分配工作线程的数量，GNU
    Make 使用的相同命令行选项在这里仍然有效：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's now see how you can avoid using the BFD linker.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何避免使用 BFD 链接器。
- en: Avoiding the use of the BFD linker
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用 BFD 链接器
- en: 'The second improvement we can do is using linkers *other than* the BFD linker,
    which is the default linker used in most Linux systems. The BFD linker, despite
    being the most mature linker on Unix/Linux systems, is not optimized for speed
    or memory consumption. This would create a performance bottleneck, especially
    for large projects such as LLVM. This is because, unlike the compiling phase,
    it''s pretty hard for the linking phase to do file-level parallelization. Not
    to mention the fact that the BFD linker''s peak memory consumption when building
    LLVM usually takes about 20 GB, causing a burden on computers with small amounts
    of memory. Fortunately, there are at least two linkers in the wild that provide
    both good single-thread performance and low memory consumption: the **GNU gold
    linker** and LLVM''s own linker, **LLD**.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第二个改进是使用**除了** BFD 链接器之外的链接器，这是大多数 Linux 系统中使用的默认链接器。尽管 BFD 链接器是 Unix/Linux
    系统上最成熟的链接器，但它并不是针对速度或内存消耗进行优化的。这会创建一个性能瓶颈，尤其是在像 LLVM 这样的大型项目中。这是因为，与编译阶段不同，链接阶段很难在文件级别上进行并行化。更不用说
    BFD 链接器在构建 LLVM 时的峰值内存消耗通常约为 20 GB，这会给内存较少的计算机带来负担。幸运的是，至少有两种链接器在野外提供良好的单线程性能和低内存消耗：**GNU
    gold 链接器**和 LLVM 自带的链接器 **LLD**。
- en: The gold linker was originally developed by Google and donated to GNU's `binutils`.
    You should have it sitting in the `binutils` package by default in modern Linux
    distributions. LLD is one of LLVM's subprojects with even faster linking speed
    and an experimental parallel linking technique. Some of the Linux distributions
    (newer Ubuntu versions, for example) already have LLD in their package repository.
    You can also download the prebuilt version from LLVM's official website.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 金链接器最初由谷歌开发，捐赠给了GNU的`binutils`。在现代Linux发行版中，您应该默认在`binutils`软件包中找到它。LLD是LLVM的子项目之一，具有更快的链接速度和实验性的并行链接技术。一些Linux发行版（例如较新的Ubuntu版本）已经在其软件仓库中包含了LLD。您也可以从LLVM的官方网站下载预构建版本。
- en: To use the gold linker or LLD to build your LLVM source tree, add an extra CMake
    argument with the name of the linker you want to use.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用gold链接器或LLD构建您的LLVM源代码树，请添加一个额外的CMake参数，指定您想要使用的链接器名称。
- en: 'For the gold linker, use the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于gold链接器，使用以下命令：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, for LLD, use the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于LLD，使用以下命令：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Limiting the number of parallel threads for Linking
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 限制链接的并行线程数量
- en: Limiting the number of parallel threads for linking is another way to reduce
    (peak) memory consumption. You can achieve this by assigning the `LLVM_PARALLEL_LINK_JOBS=<N>`
    CMake variable, where `N` is the desired number of working threads.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 限制链接的并行线程数量是减少（峰值）内存消耗的另一种方法。您可以通过分配`LLVM_PARALLEL_LINK_JOBS=<N>` CMake变量来实现这一点，其中`N`是期望的工作线程数。
- en: With that, we've learned that by simply using different tools, the building
    time could be reduced *significantly*. In the next section, we're going to improve
    this building speed by tweaking LLVM's CMake arguments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用不同的工具，我们可以显著减少构建时间。在下一节中，我们将通过调整LLVM的CMake参数来提高构建速度。
- en: Tweaking CMake arguments
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整CMake参数
- en: This section will show you some of the most common CMake arguments in LLVM's
    build system that can help you customize your build and achieve maximum efficiency.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示LLVM构建系统中的一些最常见CMake参数，这些参数可以帮助您自定义构建并实现最大效率。
- en: Before we start, you should have a build folder that has been CMake-configured.
    Most of the following subsections will modify a file in the build folder; that
    is, `CMakeCache.txt`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，您应该有一个已经通过CMake配置的构建文件夹。以下大部分子部分将修改构建文件夹中的一个文件；即`CMakeCache.txt`文件。
- en: Choosing the right build type
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择正确的构建类型
- en: 'LLVM uses several predefined build types provided by CMake. The most common
    types among them are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM使用CMake提供的几个预定义的构建类型。其中最常见的是以下几种：
- en: '`Release`: This is the default build type if you didn''t specify any. It will
    adopt the highest optimization level (usually -O3) and eliminate most of the debug
    information. Usually, this build type will make the building speed slightly slower.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Release`：如果您没有指定任何构建类型，这是默认的构建类型。它将采用最高的优化级别（通常是-O3）并消除大部分调试信息。通常，这种构建类型会使构建速度略微变慢。'
- en: '`Debug`: This build type will compile without any optimization applied (that
    is, -O0). It preserves all the debug information. Note that this will generate
    a *huge* number of artifacts and usually take up ~20 GB of space, so please be
    sure you have enough storage space when using this build type. This will usually
    make the building speed slightly faster since no optimization is being performed.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Debug`：这种构建类型将不应用任何优化（即-O0）。它保留所有调试信息。请注意，这将生成大量的工件，通常需要占用约20GB的空间，因此在使用此构建类型时，请确保您有足够的存储空间。由于没有进行优化，这通常会使构建速度略微加快。'
- en: '`RelWithDebInfo`: This build type applies as much compiler optimization as
    possible (usually -O2) and preserves all the debug information. This is an option
    balanced between space consumption, runtime speed, and debuggability.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RelWithDebInfo`：这种构建类型尽可能多地应用编译器优化（通常是-O2）并保留所有调试信息。这是一个在空间消耗、运行时速度和可调试性之间取得平衡的选项。'
- en: 'You can choose one of them using the `CMAKE_BUILD_TYPE` CMake variable. For
    example, to use the `RelWithDebInfo` type, you can use the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`CMAKE_BUILD_TYPE` CMake变量选择其中之一。例如，要使用`RelWithDebInfo`类型，可以使用以下命令：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is recommended to use `RelWithDebInfo` first (if you're going to debug LLVM
    later). Modern compilers have gone a long way to improve the debug information's
    quality in optimized program binaries. So, always give it a try first to avoid
    unnecessary storage waste; you can always go back to the `Debug` type if things
    don't work out.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 建议首先使用`RelWithDebInfo`（如果你打算稍后调试LLVM）。现代编译器在优化程序二进制中的调试信息质量方面已经取得了长足的进步。因此，始终先尝试它以避免不必要的存储浪费；如果事情没有按预期进行，你始终可以回到`Debug`类型。
- en: In addition to configuring build types, `LLVM_ENABLE_ASSERTIONS` is another
    CMake (Boolean) argument that controls whether assertions (that is, the `assert(bool
    predicate)` function, which will terminate the program if the predicate argument
    is not true) are enabled. By default, this flag will only be true if the build
    type is `Debug`, but you can always turn it on manually to enforce stricter checks,
    even in other build types.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配置构建类型外，`LLVM_ENABLE_ASSERTIONS`是另一个控制是否启用断言（即`assert(bool predicate)`函数，如果谓词参数不为真，则终止程序）的CMake（布尔）参数。默认情况下，此标志仅在构建类型为`Debug`时为真，但你始终可以手动将其打开以强制执行更严格的检查，即使在其他构建类型中也是如此。
- en: Avoiding building all targets
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免构建所有目标
- en: 'The number of LLVM''s supported targets (hardware) has grown rapidly in the
    past few years. At the time of writing this book, there are nearly 20 officially
    supported targets. Each of them deals with non-trivial tasks such as native code
    generation, so it takes a significant amount of time to build. However, the chances
    that you''re going to be working on *all* of these targets at the same time are
    low. Thus, you can select a subset of targets to build using the `LLVM_TARGETS_TO_BUILD`
    CMake argument. For example, to build the X86 target only, we can use the following
    command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，LLVM支持的硬件目标数量迅速增长。在撰写本书时，有近20个官方支持的目标。每个目标都处理非平凡的任务，例如原生代码生成，因此构建需要花费相当多的时间。然而，你同时处理**所有**这些目标的几率很低。因此，你可以使用`LLVM_TARGETS_TO_BUILD`
    CMake参数选择构建目标的一个子集。例如，要仅构建X86目标，我们可以使用以下命令：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also specify multiple targets using a semicolon-separated list, as
    follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用分号分隔的列表指定多个目标，如下所示：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Surround the list of targets with double quotes!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 用双引号括起目标列表！
- en: In some shells, such as `BASH`, a semicolon is an ending symbol for a command.
    So, the rest of the CMake command will be cut off if you don't surround the list
    of targets with *double-quotes*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些shell中，例如`BASH`，分号是命令的结束符号。所以，如果你不用双引号括起目标列表，CMake命令的其余部分将被截断。
- en: Let's see how building shared libraries can help tweak CMake arguments.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看构建共享库如何帮助调整CMake参数。
- en: Building as shared libraries
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建为共享库
- en: 'One of the most iconic features of LLVM is its `*.a` in Unix/Linux and `*.lib`
    in Windows). However, in this case, static libraries have the following drawbacks:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM最标志性的特性之一是其Unix/Linux中的`*.a`和Windows中的`*.lib`。然而，在这种情况下，静态库有以下缺点：
- en: Linking against static libraries usually takes more time than linking against
    dynamic libraries (`*.so` in Unix/Linux and `*.dll` in Windows).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态库的链接通常比动态库（Unix/Linux中的`*.so`和Windows中的`*.dll`）的链接花费更多时间。
- en: If multiple executables link against the same set of libraries, like many of
    the LLVM tools do, the total size of these executables will be *significantly*
    larger when you adopt the static library approach compared to its dynamic library
    counterpart. This is because each of the executables has a copy of those libraries.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果多个可执行文件链接到同一组库，例如许多LLVM工具所做的那样，当你采用静态库方法时，与动态库对应方法相比，这些可执行文件的总大小将**显著**更大。这是因为每个可执行文件都有这些库的副本。
- en: When you're debugging LLVM programs with debuggers (GDB, for example), they
    usually spend quite some time loading the statically linked executables at the
    very beginning, hindering the debugging experience.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你使用调试器（例如GDB）调试LLVM程序时，它们通常会在开始时花费相当多的时间加载静态链接的可执行文件，这会阻碍调试体验。
- en: 'Thus, it''s recommended to build every LLVM component as a dynamic library
    during the development phase by using the `BUILD_SHARED_LIBS` CMake argument:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，建议在开发阶段使用`BUILD_SHARED_LIBS` CMake参数将每个LLVM组件构建为动态库：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will save you a significant amount of storage space and speed up the building
    process.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您节省大量的存储空间并加快构建过程。
- en: Splitting the debug info
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离调试信息
- en: 'When you''re building a program in debug mode – adding the `-g` flag when using
    you''re GCC and Clang, for example – by default, the generated binary contains
    a section that stores `cm``AKE_BUILD_TYPE=Debug` variable – the compiled libraries
    and executables come with a huge amount of debug information that takes up a lot
    of disk space. This causes the following problems:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在调试模式下构建程序时——例如，使用GCC和Clang时添加`-g`标志——默认情况下，生成的二进制文件包含一个存储`cm``AKE_BUILD_TYPE=Debug`变量的部分——编译的库和可执行文件附带大量调试信息，这些信息占据了大量的磁盘空间。这导致以下问题：
- en: Due to the design of C/C++, several *duplicates* of the same debug information
    might be embedded in different object files (for example, the debug information
    for a header file might be embedded in every library that includes it), which
    wastes lots of disk space.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于C/C++的设计，相同的调试信息可能会嵌入到不同的对象文件中（例如，头文件的调试信息可能嵌入到包含它的每个库中），这浪费了大量的磁盘空间。
- en: The linker needs to load object files AND their associated debug information
    into memory during the linking stage, meaning that memory pressure will increase
    if the object file contains a non-trivial amount of debug information.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接器需要在链接阶段将对象文件及其相关的调试信息加载到内存中，这意味着如果对象文件包含非平凡的调试信息量，内存压力将会增加。
- en: To solve these problems, the build system in LLVM provides allows us to *split*
    debug information into separate files from the original object files. By detaching
    debug information from object files, the debug info of the same source file is
    condensed into one place, thus avoiding unnecessary duplicates being created and
    saving lots of disk space. In addition, since debug info is not part of the object
    files anymore, the linker no longer needs to load them into memory and thus saves
    lots of memory resources. Last but not least, this feature can also improve our
    *incremental* building speed – that is, rebuild the project after a (small) code
    change – since we only need to update the modified debug information in a single
    place.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，LLVM的构建系统提供了一种方法，允许我们将调试信息从原始对象文件中*分割*到单独的文件中。通过将调试信息从对象文件中分离出来，同一源文件的调试信息被压缩到一个地方，从而避免了不必要的重复创建并节省了大量磁盘空间。此外，由于调试信息不再是对象文件的一部分，链接器不再需要将它们加载到内存中，从而节省了大量内存资源。最后但同样重要的是，这个特性还可以提高我们的*增量*构建速度——即，在（小的）代码更改后重新构建项目——因为我们只需要更新单个地方的修改后的调试信息。
- en: 'To use this feature, please use the `LLVM_USE_SPLIT_DWARF` cmake variable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此功能，请使用`LLVM_USE_SPLIT_DWARF` CMake变量：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that this CMake variable only works for compilers that use the DWARF debug
    format, including GCC and Clang.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个CMake变量仅适用于使用DWARF调试格式的编译器，包括GCC和Clang。
- en: Building an optimized version of llvm-tblgen
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建优化版本的`llvm-tblgen`
- en: '`llvm-tblgen`. In other words, the running time of `llvm-tblgen` will affect
    the building time of LLVM itself. Therefore, if you''re not developing the TableGen
    part, it''s always a good idea to build an optimized version of `llvm-tblgen`,
    regardless of the global build type (that is, `CMAKE_BUILD_TYPE`), making `llvm-tblgen`
    run faster and shortening the overall building time.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`llvm-tblgen`。换句话说，`llvm-tblgen`的运行时间将影响LLVM本身的构建时间。因此，如果你没有开发TableGen部分，无论全局构建类型（即`CMAKE_BUILD_TYPE`）如何，始终构建一个优化版本的`llvm-tblgen`都是一个好主意，这样可以使`llvm-tblgen`运行得更快，并缩短整体构建时间。'
- en: 'The following CMake command, for example, will create build configurations
    that build a debug version of everything *except* the `llvm-tblgen` executable,
    which will be built as an optimized version:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下CMake命令将创建构建配置，构建除`llvm-tblgen`可执行文件外的所有内容的调试版本，该可执行文件将作为优化版本构建：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Lastly, you'll see how you can use Clang and the new PassManager.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将看到如何使用Clang和新的PassManager。
- en: Using the new PassManager and Clang
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用新的PassManager和Clang
- en: '**Clang** is LLVM''s official C-family frontend (including C, C++, and Objective-C).
    It uses LLVM''s libraries to generate machine code, which is organized by one
    of the most important subsystems in LLVM – **PassManager**. PassManager puts together
    all the tasks (that is, the Passes) required for optimization and code generation.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**Clang**是LLVM的官方C族前端（包括C、C++和Objective-C）。它使用LLVM的库生成机器代码，这些代码由LLVM中最重要的子系统之一——**PassManager**组织。PassManager将所有优化和代码生成所需的任务（即Passes）组合在一起。'
- en: 'In [*Chapter 9*](B14590_09_Final_JC_ePub.xhtml#_idTextAnchor127), *Working
    with PassManager and AnalysisManager*, will introduce LLVM''s *new* PassManager,
    which builds from the ground up to replace the existing one somewhere in the future.
    The new PassManager has a faster runtime speed compared to the legacy PassManager.
    This advantage indirectly brings better runtime performance for Clang. Therefore,
    the idea here is pretty simple: if we build LLVM''s source tree using Clang, with
    the new PassManager enabled, the compilation speed will be faster. Most of the
    mainstream Linux distribution package repositories already contain Clang. It''s
    recommended to use Clang 6.0 or later if you want a more stable PassManager implementation.
    Use the `LLVM_USE_NEWPM` CMake variable to build LLVM with the new PassManager,
    as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B14590_09_Final_JC_ePub.xhtml#_idTextAnchor127) *与PassManager和AnalysisManager一起工作*中，将介绍LLVM的*新*
    PassManager，它从头开始构建，以在未来某个时候替换现有的PassManager。与传统的PassManager相比，新的PassManager具有更快的运行速度。这种优势间接地为Clang带来了更好的运行性能。因此，这里的想法非常简单：如果我们使用Clang并启用新的PassManager来构建LLVM的源代码树，编译速度将会更快。大多数主流Linux发行版的软件包仓库已经包含了Clang。如果您想获得更稳定的PassManager实现，建议使用Clang
    6.0或更高版本。使用`LLVM_USE_NEWPM` CMake变量来使用新的PassManager构建LLVM，如下所示：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: LLVM is a huge project that takes a lot of time to build. The previous two sections
    introduced some useful tricks and tips for improving its building speed. In the
    next section, we're going to introduce an *alternative* build system to build
    LLVM. It has some advantages over the default CMake build system, which means
    it will be more suitable in some scenarios.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM是一个庞大的项目，构建它需要花费很多时间。前两节介绍了一些提高其构建速度的有用技巧和提示。在下一节中，我们将介绍一个*替代*的构建系统来构建LLVM。它相对于默认的CMake构建系统有一些优势，这意味着在某些场景下它将更加适合。
- en: Using GN for a faster turnaround time
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GN以获得更快的周转时间
- en: 'CMake is portable and flexible, and it has been battle-tested by many industrial
    projects. However, it has some serious issues when it comes to reconfigurations.
    As we saw in the previous sections, you can modify some of the CMake arguments
    once build files have been generated by editing the `CMakeCache.txt` file in the
    build folder. When you invoke the `build` command again, CMake will reconfigure
    the build files. If you edit the `CMakeLists.txt` files in your source folders,
    the same reconfiguration will also kick in. There are primarily two drawbacks
    of CMake''s reconfiguration process:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: CMake是可移植和灵活的，并且已经被许多工业项目所实战检验。然而，在重新配置方面，它有一些严重的问题。正如我们在前几节中看到的，一旦构建文件生成，您可以通过编辑构建文件夹中的`CMakeCache.txt`文件来修改一些CMake参数。当您再次调用`build`命令时，CMake将重新配置构建文件。如果您编辑源文件夹中的`CMakeLists.txt`文件，相同的重新配置也会启动。CMake的重新配置过程主要有两个缺点：
- en: In some systems, the CMake configuration process is pretty slow. Even for reconfiguration,
    which theoretically only runs part of the process, it still takes a long time
    sometimes.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些系统中，CMake配置过程相当慢。即使是重新配置，理论上只运行部分过程，有时仍然需要很长时间。
- en: Sometimes, CMake will fail to resolve the dependencies among different variables
    and build targets, so your changes will not reflect this. In the worst case, it
    will just silently fail and take you a long time to dig out the problem.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，CMake将无法解决不同变量和构建目标之间的依赖关系，因此您的更改将不会反映出来。在最坏的情况下，它将默默地失败，让您花费很长时间来找出问题。
- en: '**Generate Ninja**, better known as **GN**, is a build file generator used
    by many of Google''s projects, such as Chromium. GN generates Ninja files from
    its own description language. It has a good reputation for having a fast configuration
    time and reliable argument management. LLVM has brought GN support as an alternative
    (and experimental) building method since late 2018 (around version 8.0.0). GN
    is especially useful if your developments make changes to build files, or if you
    want to try out different building options in a short period.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**生成Ninja**，也称为**GN**，是Google许多项目（如Chromium）使用的构建文件生成器。GN从其自己的描述语言生成Ninja文件。它因其快速的配置时间和可靠的参数管理而享有良好的声誉。自2018年底（大约版本8.0.0）以来，LLVM已经引入了GN支持，作为一种（实验性的）替代构建方法。如果您的开发更改了构建文件，或者您想在短时间内尝试不同的构建选项，GN特别有用。'
- en: 'Perform the following steps to use GN to build LLVM:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GN构建LLVM的步骤如下：
- en: 'LLVM''s GN support is sitting in the `llvm/utils/gn` folder. After switching
    to that folder, run the following `get.py` script to download GN''s executable
    locally:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LLVM的GN支持位于`llvm/utils/gn`文件夹中。切换到该文件夹后，运行以下`get.py`脚本来本地下载GN的可执行文件：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Use `gn.py` in the *same* folder to generate build files (the local version
    of `gn.py` is just a wrapper around the real `gn`, to set up the essential environment):'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件夹中使用 `gn.py` 生成构建文件（本地的 `gn.py` 只是真实 `gn` 的包装，用于设置基本环境）：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, you can switch into the build folder and launch Ninja:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以切换到构建文件夹并启动 Ninja：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, you can use the `-C` Ninja option:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您可以使用 `-C` Ninja 选项：
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You probably already know that the initial build file generation process is
    super fast. Now, if you want to change some of the build arguments, please navigate
    to the `args.gn` file under the build folder (`out/x64.release/args.gn`, in this
    case); for example, if you want to change the build type to `debug` and change
    the targets to build (that is, the `LLVM_TARGETS_TO_BUILD` CMake argument) into
    `X86` and `AArch64`. It is recommended to use the following command to launch
    an editor to edit `args.gn`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经知道，初始构建文件生成过程非常快。现在，如果您想更改一些构建参数，请导航到构建文件夹下的 `args.gn` 文件（在这个例子中是 `out/x64.release/args.gn`）；例如，如果您想将构建类型更改为
    `debug` 并将目标构建（即 `LLVM_TARGETS_TO_BUILD` CMake 参数）改为 `X86` 和 `AArch64`。建议使用以下命令来启动编辑器编辑
    `args.gn`：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the editor of `args.gn`, input the following contents:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `args.gn` 编辑器中输入以下内容：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once you've saved and exited the editor, GN will do some syntax checking and
    regenerate the build files (of course, you can edit `args.gn` without using the
    `gn` command and the build files won't be regenerated until you invoke the `ninja`
    command). This regeneration/reconfiguration will also be fast. Most importantly,
    there won't be any infidelity behavior. Thanks to GN's language design, relationships
    between different build arguments can be easily analyzed with little ambiguity.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并退出编辑器后，GN 将进行一些语法检查并重新生成构建文件（当然，您可以在不使用 `gn` 命令的情况下编辑 `args.gn`，并且构建文件不会重新生成，直到您调用
    `ninja` 命令）。这种重新生成/重新配置也将很快。最重要的是，不会有任何不一致的行为。多亏了 GN 的语言设计，不同构建参数之间的关系可以很容易地分析，几乎没有歧义。
- en: 'The list of GN''s build arguments can be found by running this command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行此命令可以找到 GN 的构建参数列表：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Unfortunately, at the time of writing this book, there are still plenty of CMake
    arguments that haven't been ported to GN. GN is *not* a replacement for LLVM's
    existing CMake build system, but it is an *alternative*. Nevertheless, GN is still
    a decent building method if you want a fast turnaround time in your developments
    that involve many build configuration changes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在撰写本书时，仍有大量 CMake 参数尚未移植到 GN。GN 并非 LLVM 现有 CMake 构建系统的替代品，而是一个替代方案。尽管如此，如果您在涉及许多构建配置更改的开发中希望快速迭代，GN
    仍然是一个不错的构建方法。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: LLVM is a useful framework when it comes to building tools for code optimization
    and code generation. However, the size and complexity of its code base induces
    a non-trivial amount of build time. This chapter provided some tips for speeding
    up the build time of the LLVM source tree, including using different building
    tools, choosing the right CMake arguments, and even adopting a build system other
    than CMake. These skills cut down on unnecessary resource wasting and improve
    your productivity when developing with LLVM.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到构建用于代码优化和代码生成的工具时，LLVM 是一个有用的框架。然而，其代码库的大小和复杂性导致构建时间相当可观。本章提供了一些加快 LLVM
    源树构建时间的技巧，包括使用不同的构建工具、选择正确的 CMake 参数，甚至采用除 CMake 之外的构建系统。这些技能减少了不必要的资源浪费，并在使用
    LLVM 进行开发时提高了您的生产力。
- en: In the next chapter, we will dig into LLVM's CMake-based building infrastructure
    and show you how to build system features and guidelines that are crucial in many
    different development environments.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨基于 CMake 的 LLVM 构建基础设施，并展示如何构建在许多不同开发环境中至关重要的系统特性和指南。
- en: Further reading
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: You can check out the complete list of CMake variables that are used by LLVM
    at [https://llvm.org/docs/CMake.html#frequently-used-CMake-variables](https://llvm.org/docs/CMake.html#frequently-used-CMake-variables).
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在 [https://llvm.org/docs/CMake.html#frequently-used-CMake-variables](https://llvm.org/docs/CMake.html#frequently-used-CMake-variables)
    查看由 LLVM 使用的完整 CMake 变量列表。
- en: You can learn more about GN at [https://gn.googlesource.com/gn](https://gn.googlesource.com/gn).
    The quick start guides at [https://gn.googlesource.com/gn/+/master/docs/quick_start.md](https://gn.googlesource.com/gn/+/master/docs/quick_start.md)
    are also very helpful.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[https://gn.googlesource.com/gn](https://gn.googlesource.com/gn)了解更多关于GN的信息。[https://gn.googlesource.com/gn/+/master/docs/quick_start.md](https://gn.googlesource.com/gn/+/master/docs/quick_start.md)上的快速入门指南也非常有帮助。
