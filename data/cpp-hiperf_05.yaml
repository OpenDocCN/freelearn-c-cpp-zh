- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法
- en: 'The use of containers from the standard library is widely employed among C++
    programmers. It''s rare to find C++ code bases without references to `std::vector`
    or `std::string`, for example. However, in my experience, standard library algorithms
    are much less frequently used, even though they offer the same kind of benefits
    as containers:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中容器的使用在C++程序员中被广泛采用。很少能找到没有引用`std::vector`或`std::string`等的C++代码库。然而，在我的经验中，标准库算法的使用频率要低得多，尽管它们提供了与容器相同类型的好处：
- en: They can be used as building blocks when solving complex problems
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在解决复杂问题时可以用作构建块
- en: They are well documented (including references, books, and videos)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有很好的文档（包括参考资料、书籍和视频）
- en: Many C++ programmers are already familiar with them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多C++程序员已经熟悉它们
- en: Their space and runtime costs are known (complexity guarantees)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的空间和运行时成本是已知的（复杂度保证）
- en: Their implementations are well crafted and efficient
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的实现非常精心和高效
- en: If this wasn't enough, C++ features such as lambdas, execution policies, concepts,
    and ranges have all made the standard algorithms more powerful and, at the same
    time, friendlier to use.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不够，C++的特性，比如lambda、执行策略、概念和范围，都使标准算法更加强大，同时也更加友好。
- en: In this chapter, we will take a look at how we can write efficient algorithms
    in C++ using the **Algorithm library**. You will learn the benefits of using the
    standard library algorithms as building blocks in your application, both performance-wise
    and readability-wise.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看看如何使用算法库在C++中编写高效的算法。您将学习在应用程序中使用标准库算法作为构建块的好处，无论是性能还是可读性方面。
- en: 'In this chapter, you will learn about:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: The algorithms in the C++ standard library
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++标准库中的算法
- en: Iterators and ranges – the glue between the containers and the algorithms
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器和范围-容器和算法之间的粘合剂
- en: How to implement a generic algorithm that can operate on standard containers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现一个可以操作标准容器的通用算法
- en: Best practices when using C++ standard algorithms
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C++标准算法的最佳实践
- en: Let's begin by taking a look at the standard library algorithms and how they
    came to be what they are today.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下标准库算法，以及它们如何成为今天的样子。
- en: Introducing the standard library algorithms
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍标准库算法
- en: Integrating the standard library algorithms into your C++ vocabulary is important.
    In this introduction, I will present a set of common problems that can be solved
    effectively by using the standard library algorithms.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将标准库算法集成到您的C++词汇表中是很重要的。在本介绍中，我将介绍一组可以通过使用标准库算法有效解决的常见问题。
- en: C++20 comes with a dramatic change to the Algorithm library by the introduction
    of the **Ranges library** and the language feature of *C++ concepts*. So, before
    we start, we need a brief background of the history of the C++ standard library.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C++20通过引入Ranges库和*C++概念*的语言特性对算法库进行了重大改变。因此，在我们开始之前，我们需要简要了解C++标准库的历史背景。
- en: Evolution of the standard library algorithms
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库算法的演变
- en: You have probably heard about STL algorithms or STL containers. And hopefully,
    you have heard about the new **Ranges library** introduced with C++20\. There
    have been a lot of additions to the standard library in C++20\. And before going
    further, I need to clear up some terminology. We'll start with the STL.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经听说过STL算法或STL容器。希望您也已经听说了C++20引入的新的Ranges库。在C++20中，标准库有很多新增内容。在继续之前，我需要澄清一些术语。我们将从STL开始。
- en: The **STL**, or the **Standard Template Library**, was initially the name of
    a library added to the C++ standard library in the 1990s. It contained algorithms,
    containers, iterators, and function objects. The name has been sticky, and we
    have become accustomed to hearing and talking about the STL algorithms and containers.
    The C++ standard does not mention the STL however; instead, it talks about the
    *standard library* and their individual components such as the **Iterator library**
    and the **Algorithm library**. I will try to avoid using the name STL in this
    book and instead talk about the standard library or individual libraries when
    needed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: STL，或者标准模板库，最初是在上世纪90年代添加到C++标准库中的一个库的名称。它包含算法、容器、迭代器和函数对象。这个名字一直很粘人，我们已经习惯了听到和谈论STL算法和容器。然而，C++标准并没有提到STL；相反，它谈到了标准库及其各个组件，比如迭代器库和算法库。在本书中，我会尽量避免使用STL这个名字，而是在需要时谈论标准库或单独的库。
- en: 'Now on to the Ranges library and what I will call the **constrained algorithms**.
    The Ranges library is a library added to the standard library in C++20 that introduced
    a completely new header called `<ranges>`, which we will talk more about in the
    next chapter. But the addition of the Ranges library also had a big impact on
    the `<algorithm>` header by introducing overloaded versions of all previously
    existing algorithms. I will refer to these algorithms as the *constrained algorithms*
    because they are constrained using C++ concepts. So, the `<algorithm>` header
    now includes the old iterator-based algorithms and the new algorithms constrained
    with C++ concepts that can operate on ranges. This means that the algorithms we
    will discuss in this chapter come in two flavors, as demonstrated in the following
    example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看Ranges库以及我将称之为*受限算法*。Ranges库是C++20中添加到标准库的一个库，引入了一个全新的头文件`<ranges>`，我们将在下一章中更多地谈论它。但是，Ranges库的添加也对`<algorithm>`头文件产生了很大影响，通过引入所有先前存在的算法的重载版本。我将这些算法称为*受限算法*，因为它们使用了C++概念进行限制。因此，`<algorithm>`头文件现在包括了旧的基于迭代器的算法和可以操作范围的使用C++概念限制的新算法。这意味着我们将在本章讨论的算法有两种风味，如下例所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that both versions of `sort()` live in the `<algorithm>` header but they
    are distinguished by different namespaces and signatures. This chapter will use
    both flavors, but in general, I recommend using the new constrained algorithms
    whenever possible. The benefits will hopefully become apparent after reading this
    chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`sort()`的两个版本都位于`<algorithm>`头文件中，但它们由不同的命名空间和签名区分。本章将使用这两种版本，但一般来说，我建议尽可能使用新的约束算法。在阅读本章后，这些好处将会变得明显。
- en: Now you are ready to start learning about how you can use ready-made algorithms
    to solve common problems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好开始学习如何使用现成的算法来解决常见问题了。
- en: Solving everyday problems
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决日常问题
- en: I will list here some common scenarios and useful algorithms just to give you
    a taste of the algorithms that are available in the standard library. The are
    many algorithms in the library, and I will only present a few in this section.
    For a quick but complete overview of the standard library algorithms, I recommend
    the talk from *CppCon 2018, 105 STL Algorithms in Less Than an Hour*, by Jonathan
    Boccara, available at [https://sched.co/FnJh](https://sched.co/FnJh).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里列出了一些常见的场景和有用的算法，只是为了让你对标准库中可用的算法有所了解。标准库中有许多算法，在本节中我只会介绍其中的一些。对于标准库算法的快速但完整的概述，我推荐Jonathan
    Boccara在*CppCon 2018*上的演讲，题为*Less Than an Hour*，可在[https://sched.co/FnJh](https://sched.co/FnJh)上找到。
- en: Iterating over a sequence
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历序列
- en: 'It''s useful to have a short helper function that can print the elements of
    a sequence. The following generic function works with any container that holds
    elements that can be printed to an output stream using `operator<<()`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个有用的短小的辅助函数，可以打印序列的元素。下面的通用函数适用于任何容器，其中包含可以使用`operator<<()`打印到输出流的元素：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `print()` function is using `for_each()`, which is an algorithm imported
    from the `<algorithm>` header. `for_each()` calls the function that we provide
    once for each element in the range. The return value of the function we provide
    is ignored and has no effect on the sequence we pass to `for_each()`. We can use
    `for_each()` for side effects such as printing to `stdout` (which we do in this
    example).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()`函数使用了`for_each()`，这是从`<algorithm>`头文件导入的算法。`for_each()`为我们提供的函数为范围中的每个元素调用一次。我们提供的函数的返回值被忽略，并且对我们传递给`for_each()`的序列没有影响。我们可以使用`for_each()`来进行诸如打印到`stdout`之类的副作用（就像在这个例子中所做的那样）。'
- en: 'A similar, very general algorithm is `transform()`. It also calls a function
    for each element in a sequence, but instead of ignoring the return value, it stores
    the return value of the function in an output sequence, like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类似的非常通用的算法是`transform()`。它也为序列中的每个元素调用一个函数，但它不会忽略返回值，而是将函数的返回值存储在输出序列中，就像这样：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With our `print()` function in place and a demonstration of some of the most
    general algorithms, we will move on to look at some algorithms for generating
    elements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的`print()`函数和一些最常见的算法演示，我们将继续看一些用于生成元素的算法。
- en: Generating elements
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成元素
- en: 'Sometimes we need to assign a sequence of elements with some initial values
    or reset an entire sequence. The following example fills a vector with the value
    -1:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要为一系列元素分配一些初始值或重置整个序列。下面的例子用值-1填充了一个向量：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next algorithm, `generate()`, calls a function for each element and stores
    the return value at the current element:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个算法`generate()`为每个元素调用一个函数，并将返回值存储在当前元素中：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, the `std::rand()` function is called once for each
    element.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`std::rand()`函数被每个元素调用了一次。
- en: 'The last generating algorithm I will mention is `std::iota()` from the `<numeric>`
    header. It generates values in increasing order. The start value must be specified
    as a second argument. Here is a short example that generates values between 0
    and 5:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我要提到的最后一个生成算法是`<numeric>`头文件中的`std::iota()`。它按递增顺序生成值。起始值必须作为第二个参数指定。下面是一个生成0到5之间值的简短示例：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This sequence is already sorted, but it more commonly happens that you have
    an unordered collection of elements that needs sorting, which we will look at
    next.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列已经排序好了，但更常见的情况是你有一个无序的元素集合需要排序，接下来我们会看一下。
- en: Sorting elements
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元素排序
- en: 'Sorting elements is a very common operation. There are sorting-algorithm alternatives
    that are good to know about, but in this introduction, I will only show the most
    conventional version, simply named `sort()`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 排序元素是一个非常常见的操作。有一些好的排序算法替代方案是值得了解的，但在这个介绍中，我只会展示最常规的版本，简单地命名为`sort()`：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As mentioned, this is not the only way to sort, and sometimes we can use a partial
    sorting algorithm to gain performance. We will talk more abort sorting later in
    this chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这不是唯一的排序方式，有时我们可以使用部分排序算法来提高性能。我们将在本章后面更多地讨论排序。
- en: Finding elements
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找元素
- en: Another very common task is to find out whether a specific value is in a collection
    or not. Maybe we want to know how many instances of some specific value there
    are in a collection. These algorithms that search for values can be implemented
    more efficiently if we know that the collection is already sorted. You saw this
    in *Chapter 3*, *Analyzing and Measuring Performance*, where we compared linear
    search with binary search.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常常见的任务是找出特定值是否在集合中。也许我们想知道集合中有多少个特定值的实例。如果我们知道集合已经排序，那么搜索值的这些算法可以更有效地实现。你在*第3章*，*分析和测量性能*中看到了这一点，我们比较了线性搜索和二分搜索。
- en: 'Here we begin with the `find()` algorithm, which doesn''t require a sorted
    collection:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从不需要排序的`find()`算法开始：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the element we are looking for could not be found, `find()` returns the `end()`
    iterator of the collection. In the worst case, `find()` needs to inspect all elements
    in the sequence, therefore it runs in *O(n)* time.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到我们要找的元素，`find()`会返回集合的`end()`迭代器。在最坏的情况下，`find()`需要检查序列中的所有元素，因此它的运行时间为*O(n)*。
- en: Finding using binary search
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用二分查找进行查找
- en: 'If we know that the collection is already sorted, we can use one of the binary
    search algorithms: `binary_search()`, `equal_range()`, `upper_bound()`, or `lower_bound()`.
    If we are using these functions with containers that provide random access to
    their elements, they are all guaranteed to run in *O(log n)* time. You will gain
    a better understanding of how algorithms can provide complexity guarantees, even
    though they are operating on different containers, when we talk about iterators
    and ranges later in this chapter (there''s a section coming up named, funnily
    enough, *Iterators and Ranges*).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道集合已经排序，我们可以使用二分搜索算法之一：`binary_search()`、`equal_range()`、`upper_bound()`或`lower_bound()`。如果我们将这些函数与提供对其元素进行随机访问的容器一起使用，它们都保证在*O(log
    n)*时间内运行。当我们在本章后面讨论迭代器和范围时（有一个名为*Iterators and Ranges*的部分即将到来），你将更好地理解算法如何提供复杂度保证，即使它们在不同的容器上操作。
- en: 'In the following examples, we will use a sorted `std::vector` with the following
    elements:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用一个排序的`std::vector`，其中包含以下元素：
- en: '![](img/B15619_05_01.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_05_01.png)'
- en: 'Figure 5.1: An sorted std::vector with seven elements'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：一个包含七个元素的排序std::vector
- en: 'The `binary_search()` function returns `true` or `false` depending on whether
    the value we searched for could be found:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`binary_search()`函数根据我们搜索的值是否能找到返回`true`或`false`：'
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Before calling `binary_search()`, you should be absolutely sure that the collection
    is sorted. We can easily assert this in our code with the use of `is_sorted()`
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`binary_search()`之前，你应该绝对确定集合是排序的。我们可以在代码中使用`is_sorted()`轻松断言这一点，如下所示：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This check will run in *O(n)*, but will only be called when asserts are activated
    and hence will not affect the performance of your final program.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个检查将在*O(n)*时间内运行，但只有在激活断言时才会被调用，因此不会影响最终程序的性能。
- en: 'The sorted collection we are working with contains multiple 3s. What if we
    want to know the position of the first 3 or last 3 in the collection? In that
    case, we can use `lower_bound()` for finding the first 3, or `upper_bound()` for
    finding the element past the last 3:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在处理的排序集合包含多个3。如果我们想知道集合中第一个3或最后一个3的位置，我们可以使用`lower_bound()`来找到第一个3，或者使用`upper_bound()`来找到最后一个3之后的元素：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code will output `2` since that is the index of the first 3\. To get the
    index of an element from an iterator, we use `std::distance()` from the `<iterator>`
    header.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将输出`2`，因为这是第一个3的索引。要从迭代器获取元素的索引，我们使用`<iterator>`头文件中的`std::distance()`。
- en: 'In the same manner, we can use `upper_bound()` to get an iterator to the element
    *past* the last 3:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以使用`upper_bound()`来获取一个迭代器，指向最后一个3之后的元素：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you want both the upper bound and lower bound, you can instead use `equal_range()`,
    which returns the subrange of the collection containing the 3s:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要上下界，你可以使用`equal_range()`，它返回包含3的子范围：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now let's explore some other useful algorithms for inspecting a collection.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们探索一些用于检查集合的其他有用算法。
- en: Testing for certain conditions
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试特定条件
- en: There are three very handy algorithms called `all_of()`, `any_of()`, and `none_of()`.
    They all take a range, a unary predicate (a function that takes one argument and
    returns `true` or `false`), and an optional projection function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个非常方便的算法叫做`all_of()`、`any_of()`和`none_of()`。它们都接受一个范围、一个一元谓词（接受一个参数并返回`true`或`false`的函数）和一个可选的投影函数。
- en: 'Let''s say we have a list of numbers and a small lambda that determines whether
    a number is negative or not:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个数字列表和一个小lambda函数，确定一个数字是否为负数：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can check if none of the numbers are negative by using `none_of()`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`none_of()`来检查是否没有任何数字是负数：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Further, we can ask if all elements in the list are negative by using `all_of()`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用`all_of()`来询问列表中的所有元素是否都是负数：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, we can see whether the list contains at least one negative number using
    `any_of()`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`any_of()`来查看列表是否至少包含一个负数：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It's easy to forget about these small, handy building blocks that reside in
    the standard library. But once you get into the habit of using them, you will
    never look back and start writing these by hand again.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忘记标准库中存在的这些小而方便的构建块。但一旦你养成使用它们的习惯，你就再也不会回头手写这些了。
- en: Counting elements
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算元素
- en: 'The most obvious way to count the number of elements that equals some value
    is to call `count()`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 计算等于某个值的元素数量最明显的方法是调用`count()`：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `count()` algorithm runs in linear time. However, if we know that the sequence
    is sorted and we are using a vector or some other random-access data structure,
    we could instead use `equal_range()`, which will run in *O(log n)* time. The following
    is an example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()`算法运行时间为线性。然而，如果我们知道序列是排序的，并且我们使用的是向量或其他随机访问数据结构，我们可以使用`equal_range()`，它将在*O(log
    n)*时间内运行。以下是一个例子：'
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `equal_range()` function finds the subrange that contains all elements with
    the value we want to count. Once the subrange is found, we can retrieve the length
    of the subrange using `size()` from the `<ranges>` header.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`equal_range()`函数找到包含我们要计数的所有元素的子范围。一旦找到子范围，我们可以使用`<ranges>`头文件中的`size()`来检索子范围的长度。'
- en: Minimum, maximum, and clamping
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小值、最大值和夹紧
- en: 'I want to mention a set of small but extremely useful algorithms that are essential
    knowledge for a seasoned C++ programmer. The functions `std::min()`, `std::max()`,
    and `std::clamp()` are sometimes forgotten and instead we too often find ourselves
    writing code like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我想提到一组小但非常有用的算法，这些算法对于经验丰富的C++程序员来说是必不可少的知识。`std::min()`、`std::max()`和`std::clamp()`函数有时会被遗忘，而我们经常发现自己编写这样的代码：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The code ensures that the value of `y` is within a certain limit. This code
    works, but we can avoid the mutable variable and the `if` statement by using `std::min()`
    as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码确保`y`的值在某个限制范围内。这段代码可以工作，但我们可以避免使用可变变量和`if`语句，而是使用`std::min()`，如下所示：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Both the mutable variable and the `if` statement that clutter our code have
    been eliminated by instead using `std::min()`. We can use `std::max()` for similar
    scenarios. If we want to limit a value to within both a minimum and a maximum
    value, we might do it like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`std::min()`，我们消除了代码中的可变变量和`if`语句。对于类似的情况，我们可以使用`std::max()`。如果我们想要将一个值限制在最小值和最大值之间，我们可以这样做：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'But, since C++17, we now have `std::clamp()` that does this for us in one function.
    So instead, we could just use `clamp()` as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，自C++17以来，我们现在有了`std::clamp()`，它可以在一个函数中为我们完成这个操作。因此，我们可以像下面这样使用`clamp()`：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Sometimes we need to find the extreme values in an unsorted collection of elements.
    For this purpose, we can use `minmax()`, which (unsurprisingly) returns the minimum
    and maximum values of a sequence. Combined with structured binding, we can print
    the extreme values as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要在未排序的元素集合中找到极值。为此，我们可以使用`minmax()`，它（不出所料地）返回序列的最小值和最大值。结合结构化绑定，我们可以按如下方式打印极值：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can also find the position of the minimum or maximum element by using `min_element()`
    or `max_element()`. Instead of returning the value, it returns an iterator pointing
    at the element we are looking for. In the following example, we are finding the
    minimum element:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`min_element()`或`max_element()`找到最小或最大元素的位置。它不返回值，而是返回一个指向我们要查找的元素的迭代器。在下面的例子中，我们正在寻找最小元素：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This was a brief introduction to some of the most common algorithms from the
    standard library. The runtime cost of algorithms is specified in the C++ standard
    and all library implementations need to adhere to these, even though the exact
    implementation can vary between different platforms. To understand how the complexity
    guarantees can be withheld for generic algorithms working with many different
    types of containers, we need to take a closer look at iterators and ranges.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对标准库中一些最常见算法的简要介绍。算法的运行时成本在C++标准中有规定，所有库实现都需要遵守这些规定，尽管确切的实现可能在不同的平台之间有所不同。为了理解如何保持与许多不同类型的容器一起工作的通用算法的复杂性保证，我们需要更仔细地研究迭代器和范围。
- en: Iterators and ranges
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器和范围
- en: As seen in the previous examples, the standard library algorithms operate on
    iterators and ranges rather than container types. This section will focus on iterators
    and the new concept of ranges introduced in C++20\. Using containers and algorithms
    correctly becomes easy once you have grasped iterators and ranges.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的例子所示，标准库算法操作的是迭代器和范围，而不是容器类型。本节将重点介绍迭代器和C++20中引入的新概念范围。一旦掌握了迭代器和范围，正确使用容器和算法就变得容易了。
- en: Introducing iterators
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍迭代器
- en: Iterators form the basis of the standard library algorithms and ranges. Iterators
    are the glue between data structures and algorithms. As you have already seen,
    C++ containers store their elements in very different ways. Iterators provide
    a generic way to navigate through the elements in a sequence. By having algorithms
    operate on iterators rather than container types, the algorithms become more generic
    and flexible since they do not depend on the type of container and the way the
    containers arrange their elements in memory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器构成了标准库算法和范围的基础。迭代器是数据结构和算法之间的粘合剂。正如你已经看到的，C++容器以非常不同的方式存储它们的元素。迭代器提供了一种通用的方式来遍历序列中的元素。通过让算法操作迭代器而不是容器类型，算法变得更加通用和灵活，因为它们不依赖于容器的类型以及容器在内存中排列元素的方式。
- en: 'At its core, an iterator is an object that represents a position in a sequence.
    It has two main responsibilities:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，迭代器是表示序列中位置的对象。它有两个主要责任：
- en: Navigating in the sequence
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在序列中导航
- en: Reading and writing the value at its current position
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前位置读取和写入值
- en: The iterator abstraction is not at all a C++ exclusive concept, rather it exists
    in most programming languages. What differentiates the C++ implementation of the
    iterator concept from other programming languages is that C++ mimics the syntax
    of raw memory pointers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器抽象根本不是C++独有的概念，而是存在于大多数编程语言中。C++实现迭代器概念的不同之处在于，C++模仿了原始内存指针的语法。
- en: Basically, an iterator could be considered an object with the same properties
    as a raw pointer; it can be stepped to the next element and dereferenced (if pointing
    to a valid address). The algorithms only use a few of the operations that a pointer
    allows, although the iterator may internally be a heavy object traversing a tree-like
    `std::map`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，迭代器可以被认为是具有与原始指针相同属性的对象；它可以移动到下一个元素并解引用（如果指向有效地址）。算法只使用指针允许的一些操作，尽管迭代器可能在内部是一个遍历类似树状的`std::map`的重对象。
- en: Most of the algorithms found directly under the `std` namespace operate only
    on iterators, not containers (that is, `std::vector`, `std::map`, and so on).
    Many algorithms return iterators rather than values.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在`std`命名空间下找到的大多数算法只对迭代器进行操作，而不是容器（即`std::vector`，`std::map`等）。许多算法返回的是迭代器而不是值。
- en: To be able to navigate in a sequence without going out of bounds, we need a
    generic way to tell when the iterator has reached the end of a sequence. That
    is what we have sentinel values for.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在序列中导航而不越界，我们需要一种通用的方法来告诉迭代器何时到达序列的末尾。这就是我们有哨兵值的原因。
- en: Sentinel values and past-the-end iterators
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哨兵值和超出末尾的迭代器
- en: A **sentinel value** (or simply a sentinel) is a special value that indicates
    the end of a sequence. Sentinel values make it possible to iterate a sequence
    of values without knowing the size of the sequence in advance. An example usage
    of sentinel values are C-style strings that are null-terminated (in this case,
    the sentinel is the `'\0'` character). Instead of keeping track of the length
    of null-terminated strings, the pointer to the beginning of the string and the
    sentinel at the end is enough to define a sequence of characters.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**哨兵值**（或简称哨兵）是指示序列结束的特殊值。哨兵值使得可以在不知道序列大小的情况下迭代一系列值。哨兵值的一个示例用法是C风格的以null结尾的字符串（在这种情况下，哨兵是`''\0''`字符）。不需要跟踪以null结尾的字符串的长度，字符串开头的指针和末尾的哨兵就足以定义一系列字符。'
- en: 'The constrained algorithms use an iterator to define the first element in a
    sequence and a sentinel to indicate the end of the sequence. The only requirement
    of the sentinel is that it can be compared against the iterator, which in practice
    means that `operator==()` and `operator!=()` should be defined to accept combinations
    of a sentinel and an iterator:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 约束算法使用迭代器来定义序列中的第一个元素，并使用哨兵来指示序列的结束。哨兵的唯一要求是它可以与迭代器进行比较，实际上意味着`operator==()`和`operator!=()`应该被定义为接受哨兵和迭代器的组合：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that you know what a sentinel is, how would we create a sentinel to indicate
    the end of a sequence? The trick here is to use something called a **past-the-end**
    **iterator** as a sentinel. It is simply an iterator that points to an element
    *after* (or past) the last element in the sequence we define. Take a look at the
    following code snippet and diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了哨兵是什么，我们如何创建一个哨兵来指示序列的结束呢？这里的诀窍是使用一个叫做**past-the-end** **iterator**的迭代器作为哨兵。它只是一个指向我们定义的序列中最后一个元素之后（或过去）的迭代器。看一下下面的代码片段和图表：
- en: '|'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '| ![](img/B15619_05_02.png) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/B15619_05_02.png) |'
- en: 'As seen in the preceding diagram, the `last` iterator now points to an imagined
    element after `''d''`. This makes it possible to iterate over all the elements
    in the sequence by using a loop:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，“last”迭代器现在指向了一个想象中的“d”元素之后。这使得可以通过循环迭代序列中的所有元素：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can use the past-the-end sentinel to compare it against our iterator, `it`,
    but we cannot dereference the sentinel since it doesn''t point to an element of
    the range. This concept of past-the-end iterators has a long history and even
    works for built-in C arrays:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用past-the-end哨兵与我们的迭代器`it`进行比较，但是我们不能对哨兵进行解引用，因为它不指向范围的元素。这种past-the-end迭代器的概念有着悠久的历史，甚至适用于内置的C数组：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Again, note that `end` actually points out of bounds, so we are not allowed
    to dereference it, but we are allowed to read the pointer value and compare it
    with our `it` variable.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，`end`实际上指向了越界，因此我们不允许对其进行解引用，但是我们允许读取指针值并将其与我们的`it`变量进行比较。
- en: Ranges
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围
- en: 'A range is a replacement for the iterator-sentinel pairs that we have used
    when referring to a sequence of elements. The `<range>` header contains multiple
    concepts that define requirements for different kinds of ranges, for example,
    `input_range`, `random_access_range`, and so forth. These are all refinements
    of the most basic concept called `range`, which is defined like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 范围是指我们在引用一系列元素时使用的迭代器-哨兵对的替代品。`<range>`头文件包含了定义不同种类范围要求的多个概念，例如`input_range`，`random_access_range`等等。这些都是最基本概念`range`的细化，它的定义如下：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This means that any type that exposes `begin()` and `end()` functions is considered
    a range (given that these functions return iterators).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任何暴露`begin()`和`end()`函数的类型都被认为是范围（假设这些函数返回迭代器）。
- en: For C++ standard containers, the `begin()` and `end()` functions will return
    iterators of the same type, whereas for C++20 ranges, this is not true in general.
    A range with identical iterator and sentinel types fulfills the concept of `std::ranges::common_range`.
    The new C++20 views (covered in the next chapter) return iterator-sentinel pairs
    that can be of different types. However, they can be transformed to a view that
    has the same type for the iterator and sentinel using `std::views::common`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++标准容器，`begin()`和`end()`函数将返回相同类型的迭代器，而对于C++20范围，这通常不成立。具有相同迭代器和哨兵类型的范围满足`std::ranges::common_range`的概念。新的C++20视图（在下一章中介绍）返回可以是不同类型的迭代器-哨兵对。但是，它们可以使用`std::views::common`转换为具有相同迭代器和哨兵类型的视图。
- en: 'The constrained algorithms found in the `std::ranges` namespace can operate
    on ranges instead of iterator pairs. And since all standard containers (`vector`,
    `map`, `list`, and so on) fulfill the range concept, we can pass ranges directly
    to the constrained algorithms as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`std::ranges`命名空间中找到的约束算法可以操作范围而不是迭代器对。由于所有标准容器（`vector`，`map`，`list`等）都满足范围概念，因此我们可以直接将范围传递给约束算法，如下所示：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Ranges are an abstraction of something iterable (something that can be looped
    over), and to some extent, they hide the immediate use of C++ iterators. However,
    iterators are still a major part of the C++ standard library and are also used
    extensively in the Ranges library.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 范围是可迭代的东西的抽象（可以循环遍历的东西），在某种程度上，它们隐藏了对C++迭代器的直接使用。然而，迭代器仍然是C++标准库的一个重要部分，并且在Ranges库中也被广泛使用。
- en: The next thing you need to understand is the different kinds of iterators that
    exist.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要理解的下一件事是存在的不同种类的迭代器。
- en: Iterator categories
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器类别
- en: Now that you have a better understanding of how a range is defined and how we
    can know when we have reached the end of a sequence, it's time to look more closely
    at the operations that iterators can support in order to navigate, read, and write
    values.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对范围的定义以及如何知道何时到达序列的末尾有了更好的理解，是时候更仔细地看一下迭代器可以支持的操作，以便导航，读取和写入值。
- en: 'Iterator navigation in a sequence can be done with the following operations:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列中进行迭代器导航可以使用以下操作：
- en: 'Step forward: `std::next(it)` or `++it`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向前移动：`std::next(it)`或`++it`
- en: 'Step backward: `std::prev(it)` or `--it`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向后移动：`std::prev(it)`或`--it`
- en: 'Jump to an arbitrary position: `std::advance(it, n)` or `it += n`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳转到任意位置：`std::advance(it, n)`或`it += n`
- en: 'Reading and writing a value at the position that the iterator represents is
    done by *dereferencing* the iterator. Here is how it looks:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*解引用*迭代器来读取和写入迭代器表示的位置的值。下面是它的样子：
- en: 'Read: `auto value = *it`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读：`auto value = *it`
- en: 'Write: `*it = value`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入：`*it = value`
- en: 'These are the most common operations for iterators that are exposed by containers.
    But in addition, iterators might operate on data sources where a write or read
    implies a step forward. Examples of such data sources could be user input, a network
    connection, or a file. These data sources require the following operations:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是容器公开的迭代器的最常见操作。但此外，迭代器可能在数据源上操作，其中写入或读取意味着向前移动。这些数据源的示例可能是用户输入，网络连接或文件。这些数据源需要以下操作：
- en: 'Read only *and* step forward: `auto value = *it; ++it;`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读和向前移动：`auto value = *it; ++it;`
- en: 'Write only *and* step forward: `*it = value; ++it;`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只写和向前移动：`*it = value; ++it;`
- en: These operations are only possible to express with two succeeding expressions.
    The post-condition of the first expression is that the second expression must
    be valid. This also means that we can only read or write a value to a position
    once. If we want to read or write a new value, we must first advance the iterator
    to the next position.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作只能用两个连续的表达式来表示。第一个表达式的后置条件是第二个表达式必须有效。这也意味着我们只能读取或写入一个值到一个位置一次。如果我们想要读取或写入一个新值，我们必须先将迭代器推进到下一个位置。
- en: Not all iterators support all of the operations in the preceding list. For example,
    some iterators can only *read* values and *step forward*, whereas others can both
    *read*, *write*, and *jump* to arbitrary positions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有迭代器都支持前述列表中的所有操作。例如，一些迭代器只能*读取*值和*向前移动*，而其他一些既可以*读取*，*写入*，又可以*跳转*到任意位置。
- en: 'Now if we think about a few basic algorithms, it becomes obvious that the requirements
    on the iterators vary between different algorithms:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们考虑一些基本算法，就会显而易见地发现迭代器的要求在不同的算法之间有所不同：
- en: If an algorithm counts the number of occurrences of a value, it requires the
    *read* and *step forward* operations
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果算法计算值的出现次数，则需要*读取*和*向前移动*操作
- en: If an algorithm fills a container with a value, it requires the *write* and
    *step forward* operations
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果算法用一个值填充容器，则需要*写入*和*向前移动*操作
- en: A binary search algorithm on a sorted collection requires the *read* and *jump*
    operations
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于排序集合上的二分搜索算法需要*读取*和*跳转*操作
- en: 'Some algorithms can be implemented more efficiently depending on what operations
    the iterators support. Just like containers, all algorithms in the standard library
    have complexity guarantees (using big O notation). For an algorithm to fulfill
    a certain complexity guarantee, it puts *requirements* on the iterators it operates
    on. These requirements are categorized into six basic iterator categories that
    relate to each other as shown in the following diagram:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一些算法可以根据迭代器支持的操作来更有效地实现。就像容器一样，标准库中的所有算法都有复杂度保证（使用大O表示法）。为了满足某个复杂度保证，算法对其操作的迭代器提出了*要求*。这些要求被归类为六种基本迭代器类别，它们之间的关系如下图所示：
- en: '![](img/B15619_05_03.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_05_03.png)'
- en: 'Figure 5.2: The six iterator categories and their relation to each other'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：六种迭代器类别及其相互关系
- en: The arrows indicate that an iterator category also has all the capabilities
    of the category it points at. For example, if an algorithm requires a forward
    iterator, we can just as well pass it a bidirectional iterator, since a bidirectional
    iterator has all the capabilities of a forward iterator.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头表示迭代器类别还具有它所指向的类别的所有功能。例如，如果一个算法需要一个前向迭代器，我们同样可以传递一个双向迭代器，因为双向迭代器具有前向迭代器的所有功能。
- en: 'The six requirements are formally specified by the following concepts:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这六个要求由以下概念正式指定：
- en: '`std::input_iterator`: Supports *read only and step forward* (once). One-pass
    algorithms such as `std::count()` can use input iterators. `std::istream_iterator`
    is an example of an input iterator.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::input_iterator`：支持*只读和向前移动*（一次）。一次性算法如`std::count()`可以使用输入迭代器。`std::istream_iterator`是输入迭代器的一个例子。'
- en: '`std::output_iterator`: Supports *write only and step forward* (once). Note
    that an output iterator can only write, not read. `std::ostream_iterator` is an
    example of an output iterator.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::output_iterator`：支持*只写和向前移动*（一次）。请注意，输出迭代器只能写入，不能读取。`std::ostream_iterator`是输出迭代器的一个例子。'
- en: '`std::forward_iterator`: Supports *read* and *write* and *step forward*. The
    value at the current position can be read or written multiple times. Singly linked
    lists such as `std::forward_list` expose forward iterators.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::forward_iterator`：支持*读取*，*写入*和*向前移动*。当前位置的值可以多次读取或写入。例如`std::forward_list`公开前向迭代器。'
- en: '`std::bidirectional_iterator`: Supports *read, write, step forward*, and *step
    backward*. The doubly linked `std::list` exposes bidirectional iterators.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::bidirectional_iterator`：支持*读取*，*写入*，*向前移动*和*向后移动*。双向链表`std::list`公开双向迭代器。'
- en: '`std::random_access_iterator`: Supports *read*, *write*, *step forward*, *step
    backward*, and *jump* to an arbitrary position in constant time. The elements
    inside `std::deque` can be accessed with random access iterators.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::random_access_iterator`：支持*读取*，*写入*，*向前移动*，*向后移动*和在常数时间内*跳转*到任意位置。`std::deque`中的元素可以使用随机访问迭代器访问。'
- en: '`std::contiguous_iterator`: The same as random access iterators, but also guarantees
    that the underlying data is a contiguous block of memory, such as `std::string`,
    `std::vector`, `std::array`, `std::span`, and the (rarely used) `std::valarray`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::contiguous_iterator`：与随机访问迭代器相同，但也保证底层数据是连续的内存块，例如`std::string`，`std::vector`，`std::array`，`std::span`和（很少使用的）`std::valarray`。'
- en: The iterator categories are very important for understanding the time-complexity
    requirements of the algorithms. Having a good understanding of the underlying
    data structures makes it fairly easy to know what iterators typically belong to
    which containers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器类别对于理解算法的时间复杂度要求非常重要。对底层数据结构有很好的理解，可以很容易地知道哪些迭代器通常属于哪些容器。
- en: We are now ready to dig a little deeper into the common patterns used by most
    of the standard library algorithms.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备深入了解大多数标准库算法使用的常见模式。
- en: Features of the standard algorithms
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准算法的特性
- en: To get a better understanding of the standard algorithms, it's good to know
    a bit about the features and common patterns used by all algorithms in the `<algorithm>`
    header. As already stated, the algorithms under the `std` and `std::ranges` namespaces
    have a lot in common. We will start here with the general principles that are
    true for both the `std` algorithms and the constrained algorithms under `std::range`.
    Then, in the next section, we will move on to discuss the features that are specific
    to the constrained algorithms found under `std::ranges`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解标准算法，了解一些`<algorithm>`头文件中所有算法使用的特性和常见模式是很有帮助的。正如已经提到的，`std`和`std::ranges`命名空间下的算法有很多共同之处。我们将从这里开始讨论适用于`std`算法和`std::range`下受限算法的通用原则。然后，在下一节中，我们将继续讨论`std::ranges`下特有的特性。
- en: Algorithms do not change the size of the container
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法不会改变容器的大小
- en: Functions from `<algorithm>` can only modify the elements in a specified range;
    elements are never added or deleted from the underlying container. Therefore,
    these functions never alter the size of the container that they operate on.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`<algorithm>`的函数只能修改指定范围内的元素；元素永远不会被添加或删除到底层容器中。因此，这些函数永远不会改变它们操作的容器的大小。
- en: 'For example, `std::remove()` or `std::unique()` do not actually remove elements
    from a container (despite their names). Rather, it moves the elements that should
    be kept to the front of the container and then returns a sentinel that defines
    the new end of the valid range of elements:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`std::remove()`或`std::unique()`实际上并不会从容器中删除元素（尽管它们的名字是这样）。相反，它们将应该保留的元素移动到容器的前面，然后返回一个标记，定义了元素的有效范围的新结尾：
- en: '| Code example | Resulting vector |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 代码示例 | 结果向量 |'
- en: '|'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| ![](img/B15619_05_04.png) |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/B15619_05_04.png) |'
- en: '|'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '| ![](img/B15619_05_05.png) |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/B15619_05_05.png) |'
- en: C++20 added new versions of the `std::erase()` and `std::erase_if()` functions
    to the `<vector>` header, which erases values immediately from the vector without
    the need to first call `remove()` followed by `erase()`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: C++20在`<vector>`头文件中添加了`std::erase()`和`std::erase_if()`函数的新版本，它们可以立即从向量中删除值，而无需先调用`remove()`再调用`erase()`。
- en: The fact that standard library algorithms never change the size of a container
    means that we need to allocate data ourselves when calling algorithms that produce
    output.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库算法永远不会改变容器的大小，这意味着在调用产生输出的算法时，我们需要自己分配数据。
- en: Algorithms with output require allocated data
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有输出的算法需要已分配的数据
- en: Algorithms that write data to an output iterator, such as `std::copy()` or `std::transform()`,
    require already allocated data reserved for the output. As the algorithms only
    use iterators as arguments, they cannot allocate data by themselves. To enlarge
    the container the algorithms operate on, they rely on the iterator being capable
    of enlarging the container it iterates.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 向输出迭代器写入数据的算法，如`std::copy()`或`std::transform()`，需要为输出预留已分配的数据。由于算法只使用迭代器作为参数，它们无法自行分配数据。为了扩大算法操作的容器，它们依赖于迭代器能够扩大它们迭代的容器。
- en: 'If an iterator to an empty container is passed to the algorithms for output,
    the program will likely crash. The following example, where `squared` is empty,
    illustrates the problem:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将指向空容器的迭代器传递给输出算法，程序很可能会崩溃。下面的示例展示了这个问题，其中`squared`是空的：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Instead, you have to do either of the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你必须执行以下操作之一：
- en: Preallocate the required size for the resulting container, or
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为结果容器预先分配所需的大小，或者
- en: Use an insert iterator, which inserts elements into a container while iterating
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用插入迭代器，它在迭代时向容器中插入元素
- en: 'The following snippet shows how to use preallocated space:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何使用预分配的空间：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you are operating on `std::vector` and know the expected size of the resulting
    container, you can use the `reserve()` member function before executing the algorithm
    in order to avoid unnecessary allocations. Otherwise, the vector may reallocate
    new chunks of memory several times during the algorithm.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在操作`std::vector`并且知道结果容器的预期大小，可以在执行算法之前使用`reserve()`成员函数来预留空间，以避免不必要的分配。否则，在算法执行期间，向量可能会多次重新分配新的内存块。
- en: Algorithms use operator==() and operator<() by default
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法默认使用`operator==()`和`operator<()`
- en: For comparison, an algorithm relies on the fundamental `==` and `<` operators,
    as in the case of an integer. To be able to use your own classes with algorithms,
    `operator==()` and `operator<()` must either be provided by the class or as an
    argument to the algorithm.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 作为比较，算法依赖于基本的`==`和`<`运算符，就像整数的情况一样。为了能够在算法中使用自定义类，类必须提供`operator==()`和`operator<()`，或者作为算法的参数提供。
- en: 'By using the three-way comparison operator, `operator<=>()`, we can have the
    necessary operators generated by the compiler. The following example shows a simple
    `Flower` class, where `operator==()` is utilized by `std::find()`, and `operator<()`
    is utilized by `std::max_element()`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用三路比较运算符`operator<=>()`，我们可以让编译器生成必要的运算符。下面的示例展示了一个简单的`Flower`类，其中`std::find()`使用了`operator==()`，而`std::max_element()`使用了`operator<()`：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Apart from using the default comparison functions for the current type, it's
    also possible to use a custom comparator function, which we will explore next.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用当前类型的默认比较函数之外，还可以使用自定义比较函数，接下来我们将探讨这一点。
- en: Custom comparator functions
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义比较函数
- en: 'Sometimes we need to compare objects without using the default comparison operators,
    for example, when sorting or finding a string by length. In those cases, a custom
    function can be provided as an additional argument. While the original algorithm
    uses a value (for example, `std::find()`), the version with a specific operator
    has the same name with `_if` attached at the end (`std::find_if()`, `std::count_if()`,
    and so on):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要比较对象而不使用默认的比较运算符，例如在排序或按长度查找字符串时。在这些情况下，可以提供自定义函数作为额外参数。原始算法使用值（例如`std::find()`），具有特定运算符的版本在名称末尾附加了`_if`（`std::find_if()`、`std::count_if()`等）：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Constrained algorithms use projections
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受限算法使用投影
- en: 'The constrained algorithms under `std::ranges` provide us with a handy feature
    called **projections**, which decreases the need for writing custom comparison
    functions. The preceding example in the previous section could be rewritten using
    the standard predicate `std::less` combined with a custom projection:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::ranges`下的受限算法为我们提供了一个称为**投影**的方便功能，它减少了编写自定义比较函数的需求。前一节中的前面示例可以使用标准谓词`std::less`结合自定义投影进行重写：'
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It''s also possible to pass a lambda as a projection parameter, which can be
    handy when you want to combine multiple properties in a projection:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将lambda作为投影参数传递，这在想要在投影中组合多个属性时非常方便：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The possibility to pass a projection object to the standard algorithms is a
    very welcome feature and really simplifies the use of custom comparisons.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 向标准算法传递投影对象的可能性是一个非常受欢迎的功能，真正简化了自定义比较的使用。
- en: Algorithms require move operators not to throw
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法要求移动操作不抛出异常
- en: All algorithms use `std::swap()` and `std::move()` when moving elements around,
    but only if the move constructor and move assignment are marked `noexcept`. Therefore,
    it is important to have these implemented for heavy objects when using algorithms.
    If they are not available and exception free, the elements will be copied instead.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所有算法在移动元素时都使用`std::swap()`和`std::move()`，但只有在移动构造函数和移动赋值标记为`noexcept`时才会使用。因此，在使用算法时，对于重型对象来说，实现这些是很重要的。如果它们不可用且无异常，则元素将被复制而不是移动。
- en: Note that if you implement a move constructor and a move assignment operator
    in your class, `std::swap()` will utilize them and, therefore, a specified `std::swap()`
    overload is not needed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您在类中实现了移动构造函数和移动赋值运算符，`std::swap()`将利用它们，因此不需要指定`std::swap()`重载。
- en: Algorithms have complexity guarantees
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法具有复杂性保证
- en: The complexity of each algorithm in the standard library is specified using
    big O notation. Algorithms are created with performance in mind. Therefore, they
    do not allocate memory nor do they have a time complexity higher than *O(n log
    n)*. Algorithms that do not fit these criteria are not included even if they are
    fairly common operations.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中每个算法的复杂度都使用大O表示法进行了规定。算法是以性能为目标创建的。因此，它们既不分配内存，也不具有高于*O(n log n)*的时间复杂度。即使它们是相当常见的操作，也不包括不符合这些标准的算法。
- en: Note the exceptions of `stable_sort()`, `inplace_merge()`, and `stable_partition()`.
    Many implementations tend to temporarily allocate memory during these operations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`stable_sort()`、`inplace_merge()`和`stable_partition()`的异常。许多实现在这些操作期间倾向于临时分配内存。
- en: 'For example, let''s consider an algorithm that tests whether a non-sorted range
    contains duplicates. One option is to implement it by iterating through the range
    and search the rest of the range for a duplicate. This will result in an algorithm
    with *O(n*²*)* complexity:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个测试非排序范围是否包含重复项的算法。一种选择是通过迭代范围并搜索范围的其余部分来实现它。这将导致一个*O(n*²*)*复杂度的算法：
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Another option is to make a copy of the full range, sort it, and look for adjacent
    equal elements. This will result in a time complexity of *O(n log n)*, the complexity
    of `std::sort()`. However, since it needs to make a copy of the full range, it
    still doesn''t qualify as a building block algorithm. Allocating means that we
    cannot trust it not to throw:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是复制整个范围，对其进行排序，并查找相邻的相等元素。这将导致*O(n log n)*的时间复杂度，即`std::sort()`的复杂度。然而，由于它需要复制整个范围，因此仍然不符合构建块算法的条件。分配意味着我们不能相信它不会抛出异常：
- en: '[PRE41]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The complexity guarantees have been a part of the C++ standard library from
    the very beginning and are one of the major reasons behind its great success.
    Algorithms in the C++ standard library are designed and implemented with performance
    in mind.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性保证从C++标准库的一开始就是其巨大成功的主要原因之一。C++标准库中的算法是以性能为目标设计和实现的。
- en: Algorithms perform just as well as C library function equivalents
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法的性能与C库函数等价物一样好
- en: The standard C library comes with a number of low-level algorithms, including
    `memcpy()`, `memmove()`, `memcmp()`, and `memset()`. In my experience, sometimes
    people use these functions instead of their equivalents in the standard Algorithm
    library. The reason is that people tend to believe that the C library functions
    are faster and, therefore, accept the trade-off in type safety.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C库配备了许多低级算法，包括`memcpy()`、`memmove()`、`memcmp()`和`memset()`。根据我的经验，有时人们使用这些函数而不是标准算法库中的等价物。原因是人们倾向于相信C库函数更快，因此接受类型安全的折衷。
- en: This is not true for modern standard library implementation; the equivalent
    algorithms, `std::copy()`, `std::equal()`, and `std::fill()`, resort to these
    low-level C functions where plausible; hence, they provide both performance and
    type safety.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于现代标准库实现来说是不正确的；等价算法`std::copy()`、`std::equal()`和`std::fill()`在可能的情况下会使用这些低级C函数；因此，它们既提供性能又提供类型安全。
- en: Sure, there might be exceptions where the C++ compiler is not able to detect
    that it is safe to resort to the low-level C-functions. For example, if a type
    is not trivially copyable, `std::copy()` cannot use `memcpy()`. But that's for
    good reason; hopefully, the author of a class that is not trivially copyable had
    good reasons for designing the class in such a way, and we (or the compiler) should
    not ignore that by not calling the appropriate constructors.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也许会有例外情况，C++编译器无法检测到可以安全地使用低级C函数的情况。例如，如果一个类型不是平凡可复制的，`std::copy()`就不能使用`memcpy()`。但这是有充分理由的；希望一个不是平凡可复制的类的作者有充分的理由以这种方式设计类，我们（或编译器）不应该忽视这一点，而不调用适当的构造函数。
- en: Sometimes, functions from the C++ Algorithm library even outperform their C
    library equivalents. The most prominent example is `std::sort()` versus `qsort()`
    from the C library. A big difference between `std::sort()` and `qsort()` is that
    `qsort()` is a *function* and `std::sort()` is a *function template*. When `qsort()`
    calls the comparison function, which is provided as a function pointer, it is
    generally a lot slower than calling an ordinary comparison function that may be
    inlined by the compiler when using `std::sort()`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，C++算法库中的函数甚至比它们的C库等效函数表现得更好。最突出的例子是`std::sort()`与C库中的`qsort()`。`std::sort()`和`qsort()`之间的一个重大区别是，`qsort()`是一个*函数*，而`std::sort()`是一个*函数模板*。当`qsort()`调用比较函数时，由于它是作为函数指针提供的，通常比使用`std::sort()`时调用的普通比较函数慢得多，后者可能会被编译器内联。
- en: We will spend the remainder of this chapter going through some best practices
    when using the standard algorithms and implementing custom algorithms.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将介绍在使用标准算法和实现自定义算法时的一些最佳实践。
- en: Writing and using generic algorithms
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写和使用通用算法
- en: The Algorithm library contains generic algorithms. To keep things as concrete
    as possible here, I will show an example of how a generic algorithm can be implemented.
    This will provide you with some insights into how to use the standard algorithms
    and at the same time demonstrate that implementing a generic algorithm is not
    that hard. I will intentionally avoid explaining all the details about the example
    code here, because we will spend a lot of time on generic programming later on
    in this book.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 算法库包含通用算法。为了尽可能具体，我将展示一个通用算法的实现示例。这将为您提供一些关于如何使用标准算法的见解，同时演示实现通用算法并不那么困难。我故意避免在这里解释示例代码的所有细节，因为我们将在本书的后面花费大量时间进行通用编程。
- en: In the examples that follow, we will transform a simple non-generic algorithm
    into a full-fledged generic algorithm.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将把一个简单的非通用算法转换为一个完整的通用算法。
- en: Non-generic algorithms
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非通用算法
- en: 'A generic algorithm is an algorithm that can be used with various ranges of
    elements, not only one specific type, such as `std::vector`. The following algorithm
    is an example of a non-generic algorithm that only works with `std::vector<int>`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通用算法是一种可以与各种元素范围一起使用的算法，而不仅仅是一种特定类型，比如`std::vector`。以下算法是一个非通用算法的例子，它只能与`std::vector<int>`一起使用：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To find the element we are looking for, we rely on the interface of `std::vector`
    that provides us with the `size()` function and the subscript operator (`operator[]()`).
    However, not all containers provide us with these functions, and I don't recommend
    you write raw loops like this anyway. Instead, we need to create a function template
    that operates on iterators.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到我们要找的元素，我们依赖于`std::vector`的接口，它为我们提供了`size()`函数和下标运算符（`operator[]()`）。然而，并非所有容器都提供这些函数，我也不建议您以这种方式编写原始循环。相反，我们需要创建一个在迭代器上操作的函数模板。
- en: Generic algorithms
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用算法
- en: 'By replacing the `std::vector` with two iterators, and the `int` with a template
    parameter, we can transform our algorithm to a generic version. The following
    version of `contains()` can be used with any container:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用两个迭代器替换`std::vector`，用一个模板参数替换`int`，我们可以将我们的算法转换为通用版本。以下版本的`contains()`可以与任何容器一起使用：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To use it with, for example, `std::vector`, you would have to pass the `begin()`
    and `end()` iterators:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将其与`std::vector`一起使用，您需要传递`begin()`和`end()`迭代器：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We could improve this algorithm by offering a version that accepts a range
    instead of two separate iterator parameters:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提供一个接受范围而不是两个单独迭代器参数的版本来改进这个算法：
- en: '[PRE45]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This algorithm does not force the client to provide the `begin()` and `end()`
    iterators because we have moved that inside the function. We are using the **abbreviated
    function template** syntax from C++20 to avoid spelling out explicitly that this
    is a function template. As a last step, we could add constraints to our parameter
    types:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法不强制客户端提供`begin()`和`end()`迭代器，因为我们已经将其移到函数内部。我们使用了C++20的**缩写函数模板**语法，以避免明确说明这是一个函数模板。最后一步，我们可以为我们的参数类型添加约束：
- en: '[PRE46]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see, there is really not that much code needed to create a robust
    generic algorithm. The only requirement on the data structure we pass to the algorithm
    is that it can expose `begin()` and `end()` iterators. You will learn more about
    constraints and concepts in *Chapter 8*, *Compile-Time Programming*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，创建一个强大的通用算法实际上并不需要太多的代码。我们传递给算法的数据结构唯一的要求是它可以公开`begin()`和`end()`迭代器。您将在*第8章*“编译时编程”中了解更多关于约束和概念的知识。
- en: Data structures that can be used by generic algorithms
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可以被通用算法使用的数据结构
- en: 'This leads us to the insight that new custom data structures we create can
    be used by the standard generic algorithms as long as they expose the `begin()`
    and `end()` iterators or a range. As a simple example, we could implement a two-dimensional
    `Grid` structure where rows are exposed as a pair of iterators, like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们意识到，只要我们的新自定义数据结构公开`begin()`和`end()`迭代器或一个范围，它们就可以被标准通用算法使用。举个简单的例子，我们可以实现一个二维`Grid`结构，其中行被公开为一对迭代器，就像这样：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following diagram illustrates the layout of the `Grid` structure with the
    iterator pairs:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了带有迭代器对的`Grid`结构的布局：
- en: '![](img/B15619_05_06.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_05_06.png)'
- en: 'Figure 5.3: Two-dimensional grid built upon a one-dimensional vector'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：建立在一维向量上的二维网格
- en: 'A possible implementation of `get_row()` would return a `std::pair` holding
    iterators that represent the beginning and the end of the row:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_row()`的可能实现将返回一个包含代表行的开始和结束的迭代器的`std::pair`：'
- en: '[PRE48]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The iterator pair representing a row can then be utilized by standard library
    algorithms. In the following example, we are using `std::generate()` and `std::count()`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 表示行的迭代器对然后可以被标准库算法使用。在下面的示例中，我们使用`std::generate()`和`std::count()`：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'While this works, it is a bit clumsy to work with `std::pair`, and it also
    requires the client to know how to handle the iterator pair. There is nothing
    that explicitly says that the `first` and `second` members actually denote a half-open
    range. Wouldn''t it be nice if it could expose a strongly typed range instead?
    Fortunately, the Ranges library that we will explore in the next chapter provides
    us with a view type called `std::ranges::subrange`. Now, the `get_row()` function
    could be implemented like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样可以工作，但使用`std::pair`有点笨拙，而且还要求客户端知道如何处理迭代器对。没有明确说明`first`和`second`成员实际上表示半开范围。如果它能暴露一个强类型的范围会不会很好呢？幸运的是，我们将在下一章中探讨的Ranges库为我们提供了一个名为`std::ranges::subrange`的视图类型。现在，`get_row()`函数可以这样实现：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We could be even lazier and use the handy view that is tailor-made for this
    scenario, called `std::views::counted()`
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以更懒，使用为这种情况量身定制的方便视图，称为`std::views::counted()`
- en: '[PRE51]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'A row returned from the `Grid` class could now be used with any of the constrained
    algorithms that accept ranges instead of iterator pairs:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Grid`类返回的行现在可以与接受范围而不是迭代器对的受限算法中的任何一个一起使用：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: That completes our example of writing and using a generic algorithm that supports
    both iterator pairs and a range. Hopefully, this has given you some insights about
    how to write data structures and algorithms in a generic way to avoid the combinatorial
    explosion that would occur if we had to write specialized algorithms for all types
    of data structures.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们编写和使用支持迭代器对和范围的通用算法的示例。希望这给您一些关于如何以通用方式编写数据结构和算法以避免组合爆炸的见解，如果我们不得不为所有类型的数据结构编写专门的算法，那么组合爆炸就会发生。
- en: Best practices
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Let's consider practices that will help you out when working with the algorithms
    we've been discussing. I will start by highlighting the importance of actually
    exploiting the standard algorithms.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些在使用我们讨论的算法时会对您有所帮助的实践。我将首先强调实际利用标准算法的重要性。
- en: Using the constrained algorithms
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用受限算法
- en: 'The constrained algorithms under `std::ranges` introduced with C++20 offer
    some benefits over the iterator-based algorithms under `std`. The constrained
    algorithms do the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++20中引入的`std::ranges`下的受限算法比`std`下的基于迭代器的算法提供了一些优势。受限算法执行以下操作：
- en: Support projections, which simplifies custom comparisons of elements.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持投影，简化元素的自定义比较。
- en: Support ranges instead of iterator pairs. There is no need to pass `begin()`
    and `end()` iterators as separate arguments.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持范围而不是迭代器对。无需将`begin()`和`end()`迭代器作为单独的参数传递。
- en: Are easy to use correctly and provide descriptive error messages during compilation
    as a result of being constrained by C++ concepts.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于正确使用，并且由于受C++概念的限制，在编译期间提供描述性错误消息。
- en: It's my recommendation to start using the constrained algorithms over the iterator-based
    algorithms.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议开始使用受限算法而不是基于迭代器的算法。
- en: You may have noticed that this book uses iterator-based algorithms in a lot
    of places. The reason for this is that not all standard library implementations
    support the constrained algorithms at the time of writing this book.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，本书在许多地方使用了基于迭代器的算法。这样做的原因是，在撰写本书时，并非所有标准库实现都支持受限算法。
- en: Sorting only for the data you need to retrieve
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅对需要检索的数据进行排序
- en: 'The Algorithm library contains three basic sorting algorithms: `sort()`, `partial_sort()`,
    and `nth_element()`. In addition, it also contains a few variants of those, including
    `stable_sort()`, but we will focus on these three as, in my experience, it is
    easy to forget that, in many cases, a complete sort can be avoided by using `nth_element()`
    or `partial_sort()` instead.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 算法库包含三种基本排序算法：`sort()`、`partial_sort()`和`nth_element()`。此外，它还包含其中的一些变体，包括`stable_sort()`，但我们将专注于这三种，因为根据我的经验，在许多情况下，可以通过使用`nth_element()`或`partial_sort()`来避免完全排序。
- en: 'While `sort()` sorts the entire range, `partial_sort()` and `nth_element()`
    could be thought of as algorithms for inspecting parts of that sorted range. In
    many cases, you are only interested in a certain part of the sorted range, for
    example:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`sort()`对整个范围进行排序，但`partial_sort()`和`nth_element()`可以被视为检查该排序范围的部分的算法。在许多情况下，您只对排序范围的某一部分感兴趣，例如：
- en: If you want to calculate the median of a range, you require the value in the
    middle of the sorted range.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要计算范围的中位数，则需要排序范围中间的值。
- en: 'If you want to create a body scanner that can be used by the mean 80% by height
    of a population, you require two values in the sorted range: the value located
    10% from the tallest person, and the value located 10% from the shortest person.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想创建一个可以被人口平均身高的80%使用的身体扫描仪，您需要在排序范围内找到两个值：距离最高者10%的值和距离最矮者10%的值。
- en: 'The following diagram illustrates how `std::nth_element` and `std::partial_sort`
    process a range, compared to a fully sorted range:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了`std::nth_element`和`std::partial_sort`如何处理范围，与完全排序的范围相比：
- en: '|'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE53]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '| ![](img/B15619_05_07.png) |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/B15619_05_07.png) |'
- en: '|'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE54]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '| *![](img/B15619_05_08.png)* |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| *![](img/B15619_05_08.png)* |'
- en: '|'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '| *![](img/B15619_05_09.png)* |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| *![](img/B15619_05_09.png)* |'
- en: '|'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '| *![](img/B15619_05_10.png)* |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| *![](img/B15619_05_10.png)* |'
- en: 'Figure 5.1: Sorted and non-sorted elements of a range using different algorithms'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：使用不同算法对范围的排序和非排序元素
- en: 'The following table shows their algorithmic complexity; note that *m* denotes
    the sub-range which is being fully sorted:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了它们的算法复杂度；请注意，*m*表示正在完全排序的子范围：
- en: '| Algorithm | Complexity |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 算法 | 复杂度 |'
- en: '| `std::sort()` | *O(n log n)* |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `std::sort()` | *O(n log n)* |'
- en: '| `std::partial_sort()` | *O(n log m)* |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `std::partial_sort()` | *O(n log m)* |'
- en: '| `std::nth_element()` | *O(n)* |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `std::nth_element()` | *O(n)* |'
- en: 'Table 5.2: Algorithmic complexity'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2：算法复杂度
- en: Use cases
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用例
- en: 'Now that you have insights into `std:nth_element()` and `std::partial_sort()`,
    let''s see how we can combine them to inspect parts of a range as if the entire
    range were sorted:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了`std:nth_element()`和`std::partial_sort()`，让我们看看如何将它们结合起来检查范围的部分，就好像整个范围都已排序：
- en: '|'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE57]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '| ![](img/B15619_05_07.png) |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| ![](img/B15619_05_07.png) |'
- en: '|'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE58]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '| *![](img/B15619_05_12.png)* |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| *![](img/B15619_05_12.png)* |'
- en: '|'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '| *![](img/B15619_05_13.png)* |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| *![](img/B15619_05_13.png)* |'
- en: '|'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE60]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '| *![](img/B15619_05_14.png)* |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| *![](img/B15619_05_14.png)* |'
- en: 'Figure 5.3: Combining algorithms and corresponding partially ordered results'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：组合算法和相应的部分排序结果
- en: As you can see, by using combinations of `std::sort()`, `std::nth_element()`,
    and `std::partial_sort()`, there are many ways to avoid sorting the entire range
    when not absolutely needed. This is an effective way to gain performance.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，通过使用`std::sort()`、`std::nth_element()`和`std::partial_sort()`的组合，有许多方法可以在绝对不需要对整个范围进行排序时避免这样做。这是提高性能的有效方法。
- en: Performance evaluation
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能评估
- en: 'Let''s see how `std::nth_element()` and `std::partial_sort()` measure up against
    `std::sort()`. We''ve measured this with a `std::vector` with 10,000,000 random
    `int` elements:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`std::nth_element()`和`std::partial_sort()`与`std::sort()`相比如何。我们使用了一个包含1000万个随机`int`元素的`std::vector`进行了测量：
- en: '| Operation | Code, where `r` is the range operated on | Time (Speedup) |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 代码，其中`r`是操作的范围 | 时间（加速） |'
- en: '| Sort |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| 排序 |'
- en: '[PRE61]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '| 760 ms (1.0x) |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 760毫秒（1.0x）|'
- en: '| Find median |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 寻找中位数 |'
- en: '[PRE62]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '| 83 ms (9.2x) |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 83毫秒（9.2x）|'
- en: '| Sort first tenth of range |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 对范围的前十分之一进行排序 |'
- en: '[PRE63]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '| 378 ms (2.0x) |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 378毫秒（2.0x）|'
- en: 'Table 5.3: Benchmark results for partial sort algorithms'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.3：部分排序算法的基准结果
- en: Use standard algorithms over raw for-loops
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标准算法而不是原始的for循环
- en: It's easy to forget that complex algorithms can be implemented by combining
    algorithms from the standard library. Maybe because of an old habit of trying
    to solve problems by hand and immediately starting to handcraft `for`-loops and
    working through the problem using an imperative approach. If this sounds familiar
    to you, my recommendation is to get to know the standard algorithms well enough
    so that you start considering them as the first choice.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忘记复杂的算法可以通过组合标准库中的算法来实现。也许是因为习惯于手工解决问题并立即开始手工制作`for`循环并使用命令式方法解决问题。如果这听起来对您来说很熟悉，我的建议是要充分了解标准算法，以至于您开始将它们作为首选。
- en: 'I promote the use of standard library algorithms over raw `for`-loops, for
    a number of reasons:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我推荐使用标准库算法而不是原始的`for`循环，原因有很多：
- en: Standard algorithms deliver performance. Even though some of the algorithms
    in the standard library may seem trivial, they are often optimally designed in
    ways that are not obvious at first glance.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准算法提供了性能。即使标准库中的一些算法看起来很琐碎，它们通常以不明显的方式进行了最优设计。
- en: Standard algorithms provide safety. Even simpler algorithms may have corner
    cases, which are easy to overlook.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准算法提供了安全性。即使是更简单的算法也可能有一些特殊情况，很容易忽视。
- en: Standard algorithms are future-proof; a given algorithm can be replaced by a
    more suitable algorithm if you want to take advantage of SIMD extensions, parallelism,
    or even the GPU at a later stage (see *Chapter 14*, *Parallel Algorithms*).
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准算法是未来的保障；如果您想利用SIMD扩展、并行性甚至是以后的GPU，可以用更合适的算法替换给定的算法（参见*第14章*，*并行算法*）。
- en: Standard algorithms are thoroughly documented.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准算法有详细的文档。
- en: In addition, by using algorithms instead of `for`-loops, the intention of each
    operation is clearly indicated by the name of the algorithm. The readers of your
    code do not need to inspect details inside raw `for`-loop to determine what your
    code does if you use standard algorithms as building blocks.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过使用算法而不是`for`循环，每个操作的意图都可以通过算法的名称清楚地表示出来。如果您使用标准算法作为构建块，您的代码的读者不需要检查原始的`for`循环内部的细节来确定您的代码的作用。
- en: Once you get into the habit of thinking in terms of algorithms, you'll realize
    that many `for`-loops are most often a variation of a few simple algorithms such
    as `std::transform()`, `std::any_of()`, `std::copy_if()`, and `std::find()`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您养成了以算法思考的习惯，您会意识到许多`for`循环通常是一些简单算法的变体，例如`std::transform()`、`std::any_of()`、`std::copy_if()`和`std::find()`。
- en: Using algorithms will also make the code cleaner. You can often implement functions
    without nested code blocks and at the same time avoid mutable variables. This
    will be demonstrated in the following example.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用算法还将使代码更清晰。您通常可以实现函数而不需要嵌套代码块，并且同时避免可变变量。这将在下面的示例中进行演示。
- en: 'Example 1: Readability issues and mutable variables'
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例1：可读性问题和可变变量
- en: Our first example is from a real-world code base, although variable names have
    been disguised. As it is only a cut-out, you don't have to understand the logic
    of the code. The example here is just to show you how the complexity is lowered
    when using algorithms compared with nested `for`-loops.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个示例来自一个真实的代码库，尽管变量名已经被伪装。由于这只是一个剪切，您不必理解代码的逻辑。这个例子只是为了向您展示与嵌套的`for`循环相比，使用算法时复杂度降低的情况。
- en: 'The original version looked like this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 原始版本如下：
- en: '[PRE64]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In the `for`-loop version, it''s hard to grasp when or why `conflicting` is
    set to `true`, whereas in the following versions of the algorithm, you can instinctively
    see that it happens if `info` fulfills a predicate. Further, the standard algorithm
    version uses no mutable variables and can be written using a combination of a
    short lambda and `any_of()`. Here is how it looks:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`-循环版本中，很难理解`conflicting`何时或为什么被设置为`true`，而在算法的后续版本中，你可以直观地看到，如果`info`满足谓词，它就会发生。此外，标准算法版本不使用可变变量，并且可以使用短lambda和`any_of()`的组合来编写。它看起来是这样的：
- en: '[PRE65]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Although it may overstate the point, imagine if we were to track a bug or parallelize
    it, the standard algorithm version using a lambda and `any_of()` would be far
    easier to understand and reason about.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能有些言过其实，但想象一下，如果我们要追踪一个bug或者并行化它，使用lambda和`any_of()`的标准算法版本将更容易理解和推理。
- en: 'Example 2: Unfortunate exceptions and performance problems'
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例2：不幸的异常和性能问题
- en: To further state the importance of using algorithms rather than `for`-loops,
    I'd like to show a few not-so-obvious problems that you may bump into when using
    handcrafted `for`-loops rather than standard algorithms.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步说明使用算法而不是`for`-循环的重要性，我想展示一些不那么明显的问题，当使用手工制作的`for`-循环而不是标准算法时，你可能会遇到的问题。
- en: 'Let''s say we need a function that moves the first *n* elements from the front
    of a container to the back, like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要一个函数，将容器前面的第n个元素移动到后面，就像这样：
- en: '![](img/B15619_05_15.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_05_15.png)'
- en: 'Figure 5.4: Moving the first three elements to the back of a range'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：将前三个元素移动到范围的后面
- en: 'Approach 1: Use a traditional for-loop'
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法1：使用传统的for循环
- en: 'A naive approach would be to copy the first *n* elements to the back while
    iterating over them and then erasing the first *n* elements:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 一个天真的方法是在迭代它们时将前n个元素复制到后面，然后删除前n个元素：
- en: '![](img/B15619_05_16.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15619_05_16.png)'
- en: 'Figure 5.5: Allocating and deallocating in order to move elements to the back
    of a range'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：分配和释放以将元素移动到范围的后面
- en: 'Here''s the corresponding implementation:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相应的实现：
- en: '[PRE66]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: At first glance, it might look plausible, but inspecting it reveals a severe
    problem—if the container reallocates during the iteration due to `emplace_back()`,
    the iterator `it` will no longer be valid. As the algorithm tries to access an
    invalid iterator, the algorithm will go into undefined behavior and, in the best
    case, crash.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这可能看起来是合理的，但仔细检查会发现一个严重的问题——如果容器在迭代过程中重新分配了内存，由于`emplace_back()`，迭代器`it`将不再有效。由于算法试图访问无效的迭代器，算法将进入未定义的行为，并且在最好的情况下会崩溃。
- en: 'Approach 2: Safe for-loop (safe at the expense of performance)'
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法2：安全的for循环（以性能为代价的安全）
- en: 'As undefined behaviors are an obvious problem, we''ll have to rewrite the algorithm.
    We are still using a handcrafted `for`-loop, but we''ll utilize the index instead
    of the iterator:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由于未定义的行为是一个明显的问题，我们将不得不重写算法。我们仍然使用手工制作的`for`-循环，但我们将利用索引而不是迭代器：
- en: '[PRE67]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The solution works; it doesn''t crash anymore. But now, it has a subtle performance
    problem. The algorithm is significantly slower on `std::list` than on `std::vector`.
    The reason is that `std::next(it, n)` used with `std::list::iterator` is *O(n)*,
    and *O(1)* on a `std::vector::iterator`. As `std::next(it, n)` is invoked in every
    step of the `for`-loop, this algorithm will have a time complexity of *O(n*²*)*
    on containers such as `std::list`. Apart from this performance limitation, the
    preceding code also has the following limitations:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案有效；不再崩溃。但现在，它有一个微妙的性能问题。该算法在`std::list`上比在`std::vector`上慢得多。原因是`std::next(it,
    n)`与`std::list::iterator`一起使用是*O(n)*，而在`std::vector::iterator`上是*O(1)*。由于`std::next(it,
    n)`在`for`-循环的每一步中都被调用，这个算法在诸如`std::list`的容器上将具有*O(n*²*)*的时间复杂度。除了这个性能限制，前面的代码还有以下限制：
- en: It doesn't work with containers of a static size, such as `std::array`, due
    to `emplace_back()`
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`emplace_back()`，它不适用于静态大小的容器，比如`std::array`
- en: It might throw an exception, since `emplace_back()` may allocate memory and
    fail (this is probably rare though)
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会抛出异常，因为`emplace_back()`可能会分配内存并失败（尽管这可能很少见）
- en: 'Approach 3: Find and use a suitable standard library algorithm'
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法3：查找并使用合适的标准库算法
- en: 'When we have reached this stage, we should browse through the standard library
    and see whether it contains a suitable algorithm to be used as a building block.
    Conveniently, the `<algorithm>` header provides an algorithm called `std::rotate()`,
    which does exactly what we are looking for while avoiding all the disadvantages
    mentioned before. Here is our final version using the `std::rotate()` algorithm:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们达到这个阶段时，我们应该浏览标准库，看看它是否包含一个适合用作构建块的算法。方便的是，`<algorithm>`头文件提供了一个名为`std::rotate()`的算法，它正好可以解决我们正在寻找的问题，同时避免了前面提到的所有缺点。这是我们使用`std::rotate()`算法的最终版本：
- en: '[PRE68]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s have a look at the advantages of using `std::rotate()`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看使用`std::rotate()`的优势：
- en: The algorithm does not throw exceptions, as it does not allocate memory (the
    contained object might throw exceptions though)
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该算法不会抛出异常，因为它不会分配内存（尽管包含的对象可能会抛出异常）
- en: It works with containers whose size cannot be changed, such as `std::array`
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它适用于大小无法更改的容器，比如`std::array`
- en: Performance is *O(n)* regardless of the container it operates on
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能是*O(n)*，无论它在哪个容器上操作
- en: The implementation may very well be optimized with specific hardware in mind
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现很可能针对特定硬件进行优化
- en: Maybe you find this comparison between `for`-loops and standard algorithms unfair
    because there are other solutions to this problem that are both elegant and efficient.
    Still, in the real world, it's not uncommon to see implementations like the ones
    you just saw, when there are algorithms in the standard library just waiting to
    solve your problems.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会觉得这种`for`-循环和标准算法之间的比较是不公平的，因为这个问题还有其他解决方案，既优雅又高效。然而，在现实世界中，当标准库中有算法等待解决你的问题时，看到像你刚刚看到的这样的实现并不罕见。
- en: 'Example 3: Exploiting the standard library optimizations'
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 例3：利用标准库的优化
- en: 'This last example highlights the fact that even algorithms that may seem very
    simple might contain optimizations you wouldn''t consider. Let''s have a look
    at `std::find()`, for example. At a glance, it seems that the obvious implementation
    couldn''t be optimized further. Here is a possible implementation of the `std::find()`
    algorithm:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的例子突显了一个事实，即即使看起来非常简单的算法可能包含你不会考虑的优化。例如，让我们来看一下`std::find()`。乍一看，似乎明显的实现无法进一步优化。这是`std::find()`算法的可能实现：
- en: '[PRE69]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: However, looking through the GNU libstdc++ implementation, when being used with
    `random_access_iterator` (in other words, `std::vector`, `std::string`, `std::deque`,
    and `std::array`), the libc++ implementers have unrolled the main loop into chunks
    of four loops at a time, resulting in the comparison (`it != last`) being executed
    one-fourth as many times.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过查看GNU libstdc++的实现，当与`random_access_iterator`一起使用时（换句话说，`std::vector`，`std::string`，`std::deque`和`std::array`），libc++实现者已经将主循环展开成一次四个循环的块，导致比较（`it
    != last`）执行的次数减少四分之一。
- en: 'Here is the optimized version of `std::find()` taken from the libstdc++ library:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从libstdc++库中取出的`std::find()`的优化版本：
- en: '[PRE70]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note that it is actually `std::find_if()`, not `std::find()`, that utilizes
    this loop-unrolling optimization. But `std::find()` is implemented using `std::find_if()`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，实际上使用的是`std::find_if()`，而不是`std::find()`，它利用了这种循环展开优化。但`std::find()`是使用`std::find_if()`实现的。
- en: In addition to `std::find()`, a multitude of algorithms in libstdc++ are implemented
    using `std::find_if()`, for example, `any_of()`, `all_of()`, `none_of()`, `find_if_not()`,
    `search()`, `is_partitioned()`, `remove_if()`, and `is_permutation()`, which means
    that all of these are slightly faster than a handcrafted `for`-loop.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`std::find()`，libstdc++中还使用`std::find_if()`实现了大量算法，例如`any_of()`，`all_of()`，`none_of()`，`find_if_not()`，`search()`，`is_partitioned()`，`remove_if()`和`is_permutation()`，这意味着所有这些都比手工制作的`for`-循环稍微快一点。
- en: 'And by slightly, I really mean slightly; the speedup is roughly 1.07x, as shown
    in the following table:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微地，我真的是指稍微；加速大约是1.07倍，如下表所示：
- en: '| Find an integer in a `std::vector` of 10,000,000 elements |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 在包含1000万个元素的`std::vector`中查找整数 |'
- en: '| Algorithm | Time | Speedup |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 算法 | 时间 | 加速 |'
- en: '| `find_slow()` | 3.06 ms | 1.00x |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `find_slow()` | 3.06 毫秒 | 1.00x |'
- en: '| `find_fast()` | 3.26 ms | 1.07x |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `find_fast()` | 3.26 毫秒 | 1.07x |'
- en: 'Table 5.5: find_fast() uses optimizations found in libstdc++. The benchmark
    shows that find_fast() is slightly faster than find_slow().'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.5：find_fast()使用在libstdc++中找到的优化。基准测试表明find_fast()比find_slow()稍微快一点。
- en: However, even though the benefit is almost negligible, using standard algorithms,
    you get it for free.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使好处几乎可以忽略不计，使用标准算法，你可以免费获得它。
- en: '"Compare with zero" optimization'
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '"与零比较"优化'
- en: In addition to the loop unrolling, a very subtle optimization is that `trip_count`
    is iterated backward in order to compare with zero instead of a value. On some
    CPUs, comparing with zero is slightly faster than any other value, as it uses
    another assembly instruction (on the x86 platform, it uses `test` instead of `cmp`).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 除了循环展开之外，一个非常微妙的优化是`trip_count`是向后迭代以与零比较而不是一个值。在一些CPU上，与零比较比任何其他值稍微快一点，因为它使用另一个汇编指令（在x86平台上，它使用`test`而不是`cmp`）。
- en: 'The following table shows the difference in assembly output using gcc 9.2:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了使用gcc 9.2的汇编输出的差异：
- en: '| Action | C++ | Assembler x86 |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 动作 | C++ | 汇编x86 |'
- en: '| Compare with zero |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 与零比较 |'
- en: '[PRE71]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '|'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE72]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '|'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Compare with the other value |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| 与另一个值比较 |'
- en: '[PRE73]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '|'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE74]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '|'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Table 5.6: The difference in assembly output'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.6：汇编输出的差异
- en: Even though this kind of optimization is encouraged in the standard library
    implementation, do not rearrange your handmade loops in order to benefit from
    this optimization unless it's a (very) hot spot. Doing so will heavily reduce
    the readability of your code; let the algorithms handle these kinds of optimizations
    instead.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管标准库实现鼓励这种优化，但不要重新排列你手工制作的循环以从这种优化中受益，除非它是一个（非常）热点。这样做会严重降低你代码的可读性；让算法来处理这些优化。
- en: This was the end of my recommendations about using algorithms rather than `for`-loops.
    If you are not already using the standard algorithms, I hope that I have given
    you some arguments to convince you to give it a try. Now we will move on to my
    very last suggestion on using algorithms effectively.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于使用算法而不是`for`-循环的建议的结束。如果你还没有使用标准算法，我希望我已经给了你一些理由来说服你尝试一下。现在我们将继续我的最后一个关于有效使用算法的建议。
- en: Avoiding container copies
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免容器拷贝
- en: 'We will finish this chapter by highlighting a common problem when trying to
    combine multiple algorithms from the Algorithm library: it''s hard to avoid unnecessary
    copies of the underlying containers.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过突出一个常见问题来结束这一章，即尝试从算法库中组合多个算法时很难避免底层容器的不必要拷贝。
- en: 'An example will clarify what I mean here. Let''s say we have some sort of `Student`
    class to represent a student in a particular year and with a particular exam score,
    like this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子将澄清我的意思。假设我们有某种`Student`类来代表特定年份和特定考试分数的学生，就像这样：
- en: '[PRE75]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If we want to find the student in the second year with the highest score in
    a big collection of students, we would probably use `max_element()` on `score_`,
    but as we only want to take the students from the second year into account, it
    gets tricky. Essentially, we want to compose a new algorithm out of a combination
    of `copy_if()` and `max_element()`, but composing algorithms is not possible with
    the Algorithm library. Instead, we would have to make a copy of all the students
    in the second year to a new container and then iterate the new container to find
    the maximum score:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在一个庞大的学生集合中找到二年级成绩最高的学生，我们可能会在`score_`上使用`max_element()`，但由于我们只想考虑二年级的学生，这就变得棘手了。基本上，我们想要将`copy_if()`和`max_element()`结合起来组成一个新的算法，但是在算法库中组合算法是不可能的。相反，我们需要将所有二年级学生复制到一个新的容器中，然后迭代新容器以找到最高分数：
- en: '[PRE76]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This is one of the places where it is tempting to start writing a custom algorithm
    from scratch without taking advantage of the standard algorithms. But as you will
    see in the next chapter, there is no need to abandon the standard library for
    tasks like this. The ability to compose algorithms is one of the key motivations
    for using the Ranges library, which we will cover next.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个诱人的地方，可以开始从头开始编写自定义算法，而不利用标准算法的优势。但正如您将在下一章中看到的，没有必要放弃标准库来执行这样的任务。组合算法的能力是使用Ranges库的主要动机之一，我们将在下一章中介绍。
- en: Summary
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to use the basic concepts in the Algorithm
    library, the advantages of using them as building blocks instead of handwritten
    `for`-loops, and why using the standard Algorithm library is beneficial for optimizing
    your code at a later stage. We also discussed the guarantees and trade-offs of
    the standard algorithms, meaning that you can, from now on, use them with confidence.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用算法库中的基本概念，以及使用它们作为构建模块而不是手写的`for`循环的优势，以及为什么在以后优化代码时使用标准算法库是有益的。我们还讨论了标准算法的保证和权衡，这意味着您从现在开始可以放心地使用它们。
- en: By using the advantages of the algorithms instead of manual `for`-loops, your
    code base is well prepared for the parallelization techniques that will be discussed
    in the coming chapters of this book. One key feature that the standard algorithms
    are missing is the possibility to compose algorithms, something that was highlighted
    when we tried to avoid unnecessary container copies. In the next chapter, you
    will learn how to use views from the C++ Ranges library to overcome this limitation
    of standard algorithms.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用算法的优势而不是手动的`for`循环，您的代码库已经为本书接下来的章节中将讨论的并行化技术做好了准备。标准算法缺少的一个关键特性是组合算法的可能性，这一点在我们试图避免不必要的容器复制时得到了强调。在下一章中，您将学习如何使用C++
    Ranges库中的视图来克服标准算法的这一限制。
