- en: Chapter 17
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章
- en: Process Execution
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程执行
- en: We are now ready to talk about the software systems consisting of more than
    one process in their overall architecture. These systems are usually called multi-process
    or multiple-process systems. This chapter, together with the next chapter, is
    trying to cover the concepts of multi-processing and conduct a pros-and-cons analysis
    in order to compare it with multithreading, which we covered in *Chapter 15*,
    *Thread Execution*, and *Chapter 16*, *Thread Synchronization*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好讨论由多个进程组成的整体架构的软件系统。这些系统通常被称为多进程或多个进程系统。本章以及下一章试图涵盖多进程的概念，并进行利弊分析，以便与我们在第15章“线程执行”、第16章“线程同步”中讨论的多线程进行比较。
- en: In this chapter, our focus is the available APIs and techniques to start a new
    process and how process execution actually happens, and in the next chapter, we'll
    go through concurrent environments consisting of more than one process. We are
    going to explain how various states can be shared among a number of processes
    and what common ways of accessing shared state in a multi-processing environment
    are.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的重点是可用的API和技术来启动一个新的进程以及进程执行实际上是如何发生的，在下一章中，我们将探讨由多个进程组成的并发环境。我们将解释各种状态如何在多个进程之间共享，以及在多进程环境中访问共享状态的常见方式。
- en: A proportion of this chapter is based on comparing multi-processing and multithreading
    environments. In addition, we briefly talk about single-host multi-processing
    systems and distributed multi-processing systems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一部分基于比较多进程和多线程环境。此外，我们还简要地讨论了单主机多进程系统和分布式多进程系统。
- en: Process execution APIs
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程执行API
- en: Every program is executed as a process. Before we have a process, we just have
    an executable binary file that contains some memory segments and probably lots
    of machine-level instructions. Conversely, every process is an individual instance
    of a program being executed. Therefore, a single compiled program (or an executable
    binary file) can be executed multiple times through different processes. In fact,
    that's why our focus is on the processes in this chapter, rather than upon the
    programs themselves.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序都是以进程的形式执行的。在我们拥有进程之前，我们只有一个包含一些内存段和可能大量机器级指令的可执行二进制文件。相反，每个进程都是一个正在执行的程序的独立实例。因此，单个编译程序（或可执行二进制文件）可以通过不同的进程多次执行。事实上，这就是为什么我们关注的是进程，而不是程序本身。
- en: In two previous chapters, we talked about threads in single-process software,
    but to follow our objective in this chapter, we are going to be talking about
    software with multiple processes. But first, we need to know how, and by using
    which API, a new process can be spawned.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个章节中，我们讨论了单进程软件中的线程，但为了实现本章的目标，我们将讨论具有多个进程的软件。但首先，我们需要了解如何以及通过哪个API来生成一个新的进程。
- en: Note that our main focus is on executing processes in Unix-like operating systems
    since all of them follow the Unix onion architecture and expose very well-known
    and similar APIs. Other operating systems can have their own ways for executing
    processes, but since most of them, more or less, follow the Unix onion architecture,
    we expect to see similar methods for process execution.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们主要关注在类Unix操作系统中执行进程，因为它们都遵循Unix洋葱架构并公开非常知名且相似的API。其他操作系统可能有它们自己执行进程的方式，但由于它们大多数或多或少遵循Unix洋葱架构，我们期望看到类似的过程执行方法。
- en: In a Unix-like operating system, there are not many ways to execute a process
    at the system call level. If you remember the *kernel ring* from *Chapter 11*,
    *System Calls and Kernel*, it is the most inner ring after the *hardware ring*,
    and it provides the *system call interface* to outer rings, *shell*, and *user*,
    in order to let them execute various kernel-specific functionalities. Two of these
    exposed system calls are dedicated to process creation and process execution;
    respectively, `fork` and `exec` (`execve` in Linux though). In *process creation*,
    we spawn a new process, but in *process execution* we use an existing process
    as the host, and we replace it with a new program; therefore, no new process is
    spawned in process execution.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在类Unix操作系统中，在系统调用级别执行进程的方法并不多。如果你还记得*第11章*，*系统调用 与 内核*中的*内核环*，它是在*硬件环*之后的内部环，它为外部环、*shell*和*用户*提供*系统调用接口*，以便它们执行各种内核特定的功能。其中两个暴露的系统调用是专门用于进程创建和进程执行的；分别是`fork`和`exec`（Linux中的`execve`）。在*进程创建*中，我们创建一个新进程，但在*进程执行*中，我们使用一个现有进程作为宿主，并用一个新的程序替换它；因此，在进程执行中不会创建新的进程。
- en: As a result of using these systems calls, a program is always executed as a
    new process, but this process is not always spawned! The `fork` system call spawns
    a new process while the `exec` system call replaces the caller (the host) process
    with a new one. We talk about the differences between the `fork` and `exec` system
    calls later. Before that, let's see how these system calls are exposed to the
    outer rings.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用这些系统调用，程序总是以新进程的形式执行，但这个过程并不总是被创建！`fork`系统调用创建一个新进程，而`exec`系统调用则用一个新的进程替换调用者（宿主）进程。我们将在后面讨论`fork`和`exec`系统调用的区别。在那之前，让我们看看这些系统调用是如何暴露给外部环的。
- en: As we explained in *Chapter 10*, *Unix – History and Architecture*, we have
    two standards for Unix-like operating systems, specifically about the interface
    they should expose from their shell ring. These standards are **Single Unix Specification**
    (**SUS**) and **POSIX**. For more information regarding these standards, along
    with their similarities and differences, please refer to *Chapter 10*, *Unix –
    History and Architecture*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在*第10章*，*Unix – 历史 与 架构*中所述，我们有两个针对类Unix操作系统的标准，特别是关于它们应该从其shell环中暴露的接口。这些标准是**单一Unix规范**（**SUS**）和**POSIX**。有关这些标准的更多信息，包括它们的相似之处和不同之处，请参阅*第10章*，*Unix
    – 历史 与 架构*。
- en: The interface that should be exposed from the shell ring is thoroughly specified
    in the POSIX interface, and indeed, there are parts in the standard that deal
    with process execution and process management.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 应从shell环中暴露的接口在POSIX接口中得到了详细规定，实际上，标准中确实有部分内容涉及进程执行和进程管理。
- en: 'Therefore, we would expect to find headers and functions for process creation
    and process execution within POSIX. Such functions do indeed exist, and we find
    them in different headers that provide the desired functionality. Following is
    a list of POSIX functions responsible for process creation and process execution:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们预计在POSIX中会找到用于进程创建和进程执行的头部和函数。这些函数确实存在，并且我们可以在提供所需功能的不同头部文件中找到它们。以下是负责进程创建和进程执行的POSIX函数列表：
- en: The function `fork` that can be found in the `unistd.h` header file is responsible
    for process creation.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在`unistd.h`头文件中找到的`fork`函数负责进程创建。
- en: The `posix_spawn` and `posix_spawnp` functions that can be found in the `spawn.h`
    header file. These functions are responsible for process creation.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在`spawn.h`头文件中找到的`posix_spawn`和`posix_spawnp`函数。这些函数负责进程创建。
- en: The group of `exec*` functions, for example, `execl` and `execlp`, that can
    be found in the `unistd.h` header file. These functions are responsible for process
    execution.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，在`unistd.h`头文件中可以找到的`exec*`函数组，如`execl`和`execlp`。这些函数负责进程执行。
- en: Note that the preceding functions should not be mistaken for the `fork` and
    `exec` system calls. These functions are part of the POSIX interface exposed from
    the shell ring while the system calls are exposed from the kernel ring. While
    most Unix-like operating systems are POSIX-compliant, we can have a non-Unix-like
    system that is also POSIX-compliant. Then, the preceding functions exist in that
    system, but the underlying mechanism for spawning a process can be different at
    the system call level.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的函数不应与 `fork` 和 `exec` 系统调用混淆。这些函数是来自 shell 环境暴露的 POSIX 接口的一部分，而系统调用则是来自内核环暴露的。虽然大多数
    Unix-like 操作系统都是 POSIX 兼容的，但我们也可以有一个非 Unix-like 系统也是 POSIX 兼容的。那么，前面的函数存在于该系统中，但系统调用级别的进程创建的底层机制可能不同。
- en: A tangible example is using Cygwin or MinGW to make Microsoft Windows POSIX-compliant.
    By installing these programs, you can write and compile standard C programs that
    are using the POSIX interface, and Microsoft Windows becomes partially POSIX-compliant,
    but there are no `fork` or `exec` system calls in Microsoft Windows! This is in
    fact very confusing and very important at the same time, and you should know that
    the shell ring does not necessarily expose the same interface that is exposed
    by the kernel ring.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具体的例子是使用 Cygwin 或 MinGW 使 Microsoft Windows 兼容 POSIX。通过安装这些程序，你可以编写和编译使用 POSIX
    接口的标准 C 程序，从而使 Microsoft Windows 部分兼容 POSIX，但在 Microsoft Windows 中没有 `fork` 或
    `exec` 系统调用！这实际上既令人困惑又非常重要，你应该知道 shell 环境并不一定暴露与内核环暴露相同的接口。
- en: '**Note**:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'You can find the implementation details of the `fork` function in Cygwin here:
    https://github.com/openunix/cygwin/blob/master/winsup/cygwin/fork.cc. Note that
    it doesn''t call the `fork` system call that usually exists in Unix-like kernels;
    instead, it includes headers from the Win32 API and calls functions that are well-known
    functions regarding process creation and process management.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Cygwin 中找到 `fork` 函数的实现细节：https://github.com/openunix/cygwin/blob/master/winsup/cygwin/fork.cc。注意，它并没有调用通常存在于
    Unix-like 内核中的 `fork` 系统调用；相反，它包含了 Win32 API 的头文件，并调用了一些关于进程创建和进程管理的知名函数。
- en: According to the POSIX standard, the C standard library is not the only thing
    that is exposed from the shell ring on a Unix-like system. When using a Terminal,
    there are prewritten shell utility programs that are used to provide a complex
    usage of the C standard API. About the process creation, whenever the user enters
    a command in the Terminal, a new process is created.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 POSIX 标准，Unix-like 系统上的 shell 环境暴露出来的不仅仅是 C 标准库。当使用终端时，有一些预先编写的 shell 实用程序被用来提供复杂的
    C 标准API的使用。关于进程创建，每当用户在终端中输入一个命令时，就会创建一个新的进程。
- en: Even a simple `ls` or `sed` command spawns a new process that might only last
    less than a second. You should know that these utility programs are mostly written
    in C language and they are consuming the same exact POSIX interface which you
    would have been using when writing your own programs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是简单的 `ls` 或 `sed` 命令也会启动一个新的进程，这个进程可能只持续不到一秒钟。你应该知道，这些实用程序大多是用 C 语言编写的，并且它们正在消耗与你在编写自己的程序时所使用的相同的精确
    POSIX 接口。
- en: Shell scripts are also executed in a separate process but in a slightly different
    fashion. We will discuss them in future sections on how a process is executed
    within a Unix-like system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 脚本也是在单独的进程中执行的，但方式略有不同。我们将在未来的章节中讨论如何在 Unix-like 系统中执行进程。
- en: Process creation happens in the kernel, especially in monolithic kernels. Whenever
    a user process spawns a new process or even a new thread, the request is received
    by the system call interface, and it gets passed down to the kernel ring. There,
    a new *task* is created for the incoming request, either a process or a thread.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 进程创建发生在内核中，尤其是在单核内核中。每当用户进程启动一个新的进程或甚至一个新的线程时，请求会被系统调用接口接收，并传递到内核环。在那里，为传入的请求创建一个新的
    *任务*，无论是进程还是线程。
- en: Monolithic kernels like Linux or FreeBSD keep track of the tasks (process and
    threads) within their kernel, and this makes it reasonable to have processes being
    created in the kernel itself.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 Linux 或 FreeBSD 这样的单核内核会跟踪内核内的任务（进程和线程），这使得在内核本身创建进程变得合理。
- en: Note that whenever a new task is created within the kernel, it is placed in
    the queue of the *task scheduler unit* and it might take a bit of time for it
    to obtain the CPU and begin execution.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每当内核中创建一个新的任务时，它会被放入 *任务调度单元* 的队列中，并且它可能需要一点时间才能获得 CPU 并开始执行。
- en: In order to create a new process, a parent process is needed. That's why every
    process has a parent. In fact, each process can have only one parent. The chain
    of parents and grandparents goes back to the first user process, which is usually
    called *init*, and the kernel process is its parent.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个新的进程，需要一个父进程。这就是为什么每个进程都有一个父进程。实际上，每个进程只能有一个父进程。父亲和祖父母的链条可以追溯到第一个用户进程，通常称为
    *init*，而内核进程是其父进程。
- en: It is the ancestor to all other processes within a Unix-like system and exists
    until the system shuts down. Regularly, the init process becomes the parent of
    all *orphan processes* that have had their parent processes terminated, so that
    no process can be left without a parent process.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它是 Unix-like 系统中所有其他进程的祖先，存在于系统关闭之前。通常，init 进程成为所有 *孤儿进程* 的父进程，这些进程的父进程已经终止，这样就不会有进程没有父进程。
- en: This parent-child relationship ends up in a big process tree. This tree can
    be examined by the command utility *pstree*. We are going to show how to use this
    utility in future examples.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种父子关系最终会形成一个大的进程树。这个树可以通过命令工具 *pstree* 来检查。我们将在未来的示例中展示如何使用这个工具。
- en: Now, we know the API that can execute a new process, and we need to give some
    real C examples on how these methods actually work. We start with the fork API,
    which eventually calls the `fork` system call.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道了可以执行新进程的 API，我们需要给出一些实际的 C 语言示例来说明这些方法是如何实际工作的。我们首先从 fork API 开始，它最终调用
    `fork` 系统调用。
- en: Process creation
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程创建
- en: As we mentioned in the previous section, the fork API can be used to spawn a
    new process. We also explained that a new process can only be created as a child
    of a running process. Here, we see a few examples of how a process can fork a
    new child using the fork API.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中提到的，fork API 可以用来创建一个新的进程。我们还解释了，新的进程只能作为正在运行进程的子进程来创建。在这里，我们看到了一些示例，展示了进程如何使用
    fork API 来创建新的子进程。
- en: In order to spawn a new child process, a parent process needs to call the `fork`
    function. The declaration of the `fork` function can be included from the `unistd.h`
    header file which is part of the POSIX headers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个新的子进程，父进程需要调用 `fork` 函数。`fork` 函数的声明可以从 `unistd.h` 头文件中包含，它是 POSIX 头文件的一部分。
- en: When the `fork` function is called, an exact copy of the caller process (which
    is called the parent process) is created, and both processes continue to run concurrently
    starting from the very next instruction after the `fork` invocation statement.
    Note that the child (or forked) process inherits many things from the parent process
    including all the memory segments together with their content. Therefore, it has
    access to the same variables in the Data, Stack, and Heap segments, and also the
    program instructions found in the Text segment. We talk about other inherited
    things in the upcoming paragraphs, after talking about the example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `fork` 函数时，会创建调用进程（称为父进程）的一个精确副本，并且两个进程从 `fork` 调用语句之后的下一个指令开始并发运行。请注意，子进程（或被
    fork 的进程）从父进程继承了包括所有内存段及其内容在内的大量内容。因此，它有权访问数据、堆栈和堆段中的相同变量，以及文本段中的程序指令。我们将在接下来的段落中讨论其他继承的内容，在讨论示例之后。
- en: 'Since we have two different processes now, the `fork` function returns twice;
    once in the parent process and another time in the child process. In addition,
    the `fork` function returns different values to each process. It returns 0 to
    the child process, and it returns the PID of the forked (or child) process to
    the parent process. *Example 17.1* shows how `fork` works in one of its simplest
    usages:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有两个不同的进程，`fork` 函数会返回两次；一次在父进程中，另一次在子进程中。此外，`fork` 函数对每个进程返回不同的值。它对子进程返回
    0，对父进程返回 forked（或子）进程的 PID。*示例 17.1* 展示了 `fork` 在其最简单用法中的工作方式：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Code Box 17-1 [ExtremeC_examples_chapter17_1.c]: Create a child process using
    the fork API'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '代码框 17-1 [ExtremeC_examples_chapter17_1.c]: 使用 fork API 创建子进程'
- en: In the preceding code box, we have used `printf` to print out some logs in order
    to track the activity of the processes. As you see, we have invoked the `fork`
    function in order to spawn a new process. As is apparent, it doesn't accept any
    argument, and therefore, its usage is very easy and straightforward.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码框中，我们使用了 `printf` 来打印一些日志，以便跟踪进程的活动。正如你所见，我们调用了 `fork` 函数来创建一个新的进程。显然，它不接受任何参数，因此其使用非常简单直接。
- en: Upon calling the `fork` function, a new process is forked (or cloned) from the
    caller process, which is now the parent process, and after that, they continue
    to work concurrently as two different processes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`fork`函数后，一个新的进程从调用进程（现在是父进程）中分叉（或克隆）出来，之后，它们作为两个不同的进程继续并发工作。
- en: Surely, the call to the `fork` function will cause further invocations on the
    system call level, and only then, the responsible logic in the kernel can create
    a new forked process.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对`fork`函数的调用将在系统调用级别上引发进一步的调用，然后，内核中的负责逻辑才能创建一个新的分叉进程。
- en: Just before the `return` statement, we have used an infinite loop to keep both
    processes running and prevent them from exiting. Note that the processes should
    reach this infinite loop eventually because they have exactly the same instructions
    in their Text segments.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在`return`语句之前，我们使用了一个无限循环来保持两个进程同时运行并防止它们退出。请注意，进程最终应该达到这个无限循环，因为它们在文本段中具有完全相同的指令。
- en: 'We want to keep the processes running intentionally in order to be able to
    see them in the list of processes shown by the `pstree` and `top` commands. Before
    that, we need to compile the preceding code and see how the new process is forked,
    as shown in *Shell Box 17-1*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有意保持进程运行，以便能够在`pstree`和`top`命令显示的进程列表中看到它们。在此之前，我们需要编译前面的代码，看看新的进程是如何通过*Shell
    Box 17-1*进行分叉的：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Shell Box 17-1: Building and running example 17.1'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 17-1：构建和运行示例 17.1
- en: As you can see, the parent process prints its PID, and that is `10852`. Note
    that the PID is going to change in each run. After forking the child process,
    the parent process prints the PID returned by the `fork` function, and it is `10853`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，父进程打印其PID，那是`10852`。请注意，PID将在每次运行时改变。在分叉子进程后，父进程打印`fork`函数返回的PID，它是`10853`。
- en: On the next line, the child process prints its PID, which is again `10853` and
    it is in accordance with what the parent has received from the `fork` function.
    And finally, both processes enter the infinite loop, giving us some time to observe
    them in the probing utilities.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，子进程打印其PID，再次是`10853`，这与父进程从`fork`函数接收到的相符。最后，两个进程都进入无限循环，给我们一些时间在探测工具中观察它们。
- en: As you see in *Shell Box 17-1*, the forked process inherits the same `stdout`
    file descriptor and the same terminal from its parent. Therefore, it can print
    to the same output that its parent writes to. A forked process inherits all the
    open file descriptors at the time of the `fork` function call from its parent
    process.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在*Shell Box 17-1*中看到的那样，分叉进程从其父进程继承了相同的`stdout`文件描述符和相同的终端。因此，它可以打印到其父进程写入的相同输出。分叉进程从其父进程继承了在`fork`函数调用时的所有打开文件描述符。
- en: 'In addition, there are also other inherited attributes, which can be found
    in `fork`''s manual pages. The `fork`''s manual page for Linux can be found here:
    http://man7.org/linux/man-pages/man2/fork.2.html.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有其他继承属性，可以在`fork`的手册页中找到。Linux的`fork`手册页可以在以下链接中找到：http://man7.org/linux/man-pages/man2/fork.2.html。
- en: If you open the link and look through the attributes, you are going to see that
    there are attributes that are shared between the parent and forked processes,
    and there are other attributes that are different and specific to each process,
    for example, PID, parent PID, threads, and so on.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开链接并查看属性，你会看到有一些属性是父进程和分叉进程之间共享的，还有一些属性是不同的，并且针对每个进程，例如，PID、父PID、线程等。
- en: The parent-child relationship between processes can be easily seen using a utility
    program like `pstree`. Every process has a parent process, and all of the processes
    contribute to building a big tree. Remember that each process has exactly one
    parent, and a single process cannot have two parents.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像`pstree`这样的实用程序可以很容易地看到进程之间的父子关系。每个进程都有一个父进程，所有进程共同构建了一个大树。请记住，每个进程只有一个父进程，一个进程不能有两个父进程。
- en: 'While the processes in the preceding example are stuck within their infinite
    loops, we can use the `pstree` utility command to see the list of all processes
    within the system displayed as a tree. The following is the output of the `pstree`
    usage in a Linux machine. Note that the `pstree` command is installed on Linux
    systems by default, but it might need to be installed in other Unix-like operating
    systems:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前一个例子中的过程陷入了无限循环，但我们可以使用`pstree`实用命令来查看系统中所有进程的列表，这些进程以树状结构显示。以下是在Linux机器上使用`pstree`的输出。请注意，`pstree`命令默认安装在Linux系统上，但在其他类Unix操作系统中可能需要安装：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Shell Box 17-2: Use pstree to find the processes spawned as part of example
    17.1'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Shell框17-2：使用`pstree`查找作为示例17.1一部分生成的进程
- en: As can be seen in the last line of *Shell Box 17-2*, we have two processes with
    PIDs `10852` and `10853` that are in the parent-child relationship. Note that
    process `10852` has a parent with PID `2337`, which is a *bash* process.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如*Shell框17-2*的最后行所示，我们有两个进程，其PID分别为`10852`和`10853`，它们处于父子关系。请注意，进程`10852`的父进程PID为`2337`，这是一个*bash*进程。
- en: It's interesting to note that on the line before the last line, we can see the
    `pstree` process itself as the child of the bash process with PID `2084`. Both
    of the bash processes belong to the same *tmux* terminal emulator with PID `2083`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在最后一行之前的一行中，我们可以看到`pstree`进程本身作为PID为`2084`的bash进程的子进程。这两个bash进程都属于同一个PID为`2083`的*tmux*终端模拟器。
- en: In Linux, the very first process is the *scheduler* process, which is part of
    the kernel image, and it has the PID 0\. The next process, which is usually called
    *init*, has the PID 1, and it is the first user process which is created by the
    scheduler process. It exists from system startup until its shutdown. All other
    user processes are directly or indirectly the children of the `init` process.
    The processes which lose their parent processes become orphan processes, and they
    become abducted by the init process as its direct children.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，第一个进程是*调度器*进程，它是内核镜像的一部分，其PID为0。下一个进程，通常称为*init*，其PID为1，它是调度器进程创建的第一个用户进程。它从系统启动存在直到系统关闭。所有其他用户进程都是`init`进程的直接或间接子进程。失去父进程的进程成为孤儿进程，它们被`init`进程作为其直接子进程收养。
- en: 'However, in the newer versions of almost all famous distributions of Linux,
    the init process has been replaced by the *systemd daemon*, and that''s why you
    see `systemd(1)` on the first line in *Shell Box 17-2*. The following link is
    a great source to read more about the differences between `init` and `systemd`
    and why Linux distro developers have made such a decision: https://www.tecmint.com/systemd-replaces-init-in-linux.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在几乎所有著名Linux发行版的较新版本中，`init`进程已被*systemd守护进程*取代，这就是为什么您在*Shell框17-2*的第一行看到`systemd(1)`的原因。以下链接是一个很好的资源，可以阅读更多关于`init`和`systemd`之间的差异以及为什么Linux发行版开发者做出了这样的决定：[https://www.tecmint.com/systemd-replaces-init-in-linux](https://www.tecmint.com/systemd-replaces-init-in-linux)。
- en: When using the fork API, the parent and forked processes are executed concurrently.
    This means that we should be able to detect some behaviors of concurrent systems.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`fork`API时，父进程和派生进程是并发执行的。这意味着我们应该能够检测到并发系统的某些行为。
- en: The best-known behavior that can be observed is some interleavings. If you are
    not familiar with this term or you have not heard it before, it is strongly recommended
    to have a read of *Chapter 13*, *Concurrency*, and *Chapter 14*, *Synchronization*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到的最著名的行为是一些交错。如果您不熟悉这个术语或者以前没有听说过，强烈建议您阅读*第13章*，*并发*，和*第14章*，*同步*。
- en: 'The following example, *example 17.2*, shows how the parent and forked processes
    can have non-deterministic interleavings. We are going to print some strings and
    observe how some various interleavings can happen in two successive runs:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例，*示例17.2*，展示了父进程和派生进程可以具有非确定性的交错。我们将打印一些字符串，并观察在两次连续运行中可能发生的各种交错：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Code Box 17-2 [ExtremeC_examples_chapter17_2.c]: Two processes that print some
    lines to the standard output'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框17-2 [ExtremeC_examples_chapter17_2.c]：两个进程向标准输出打印一些行
- en: 'The preceding code is very similar to the code we wrote for *example 17.1*.
    It creates a forked process, and after that, the parent and forked processes print
    some lines of text to the standard output. The parent process prints `AAA` 5 times,
    and the forked process prints `BBBBBB` five times. The following is the output
    of the two consecutive runs of the same compiled executable:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与我们为*示例 17.1*编写的代码非常相似。它创建了一个分支进程，然后父进程和分支进程向标准输出打印一些文本行。父进程打印`AAA`五次，分支进程打印`BBBBBB`五次。以下是对同一编译可执行文件连续两次运行的输出：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Shell Box 17-3: Output of two successive runs of example 17.2'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 17-3：示例 17.2 连续两次运行的输出
- en: It is clear from the preceding output that we have different interleavings.
    This means we can be potentially suffering from a race condition here if we define
    our invariant constraint according to what we see in the standard output. This
    would eventually lead to all the issues we faced while writing multithreaded code,
    and we need to use similar methods to overcome these issues. In the next chapter,
    we will discuss such solutions in greater detail.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中很明显，我们有不同的交错。这意味着如果我们根据标准输出的内容定义我们的不变约束，我们可能会在这里遭受潜在的竞争条件。这最终会导致我们在编写多线程代码时遇到的所有问题，我们需要使用类似的方法来克服这些问题。在下一章中，我们将更详细地讨论这些解决方案。
- en: In the following section, we are going to talk about process execution and how
    it can be achieved using `exec*` functions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论进程执行以及如何使用`exec*`函数实现它。
- en: Process execution
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程执行
- en: Another way to execute a new process is by using the family of `exec*` functions.
    This group of functions takes a different approach to execute a new process in comparison
    to the fork API. The philosophy behind `exec*` functions is to create a simple
    base process first and then, at some point, load the target executable and replace
    it as a new *process image* with the base process. A process image is the loaded
    version of a executable that has its memory segments allocated, and it is ready
    to be executed. In the future sections, we will discuss the different steps of
    loading an executable, and we will explain process images in greater depth.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 执行新进程的另一种方式是使用`exec*`函数家族。与fork API相比，这个函数族在执行新进程时采取不同的方法。`exec*`函数背后的哲学是首先创建一个简单的基进程，然后在某个时刻，加载目标可执行文件并将其作为新的*进程映像*替换基进程。进程映像是可执行文件的加载版本，其内存段已分配，并准备好执行。在未来的章节中，我们将讨论加载可执行文件的不同步骤，并更深入地解释进程映像。
- en: Therefore, while using the `exec*` functions, no new process is created, and
    a process substitution happens. This is the most important difference between
    `fork` and `exec*` functions. Instead of forking a new process, the base process
    is totally substituted with a new set of memory segments and code instructions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用`exec*`函数时，不会创建新的进程，而是发生进程替换。这是`fork`和`exec*`函数之间最重要的区别。不是通过分支新的进程，而是将基础进程完全替换为一个新的内存段和代码指令集。
- en: '*Code Box 17-3*, containing *example 17.3*, shows how the `execvp` function,
    one of the functions in the family of `exec*` functions, is used to start an echo
    process. The `execvp` function is one of the functions in the group of `exec*`
    functions that inherits the environment variable `PATH` from the parent process
    and searches for the executables as the parent process did:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码框 17-3*，包含*示例 17.3*，展示了`execvp`函数，它是`exec*`函数家族中的一个函数，是如何用来启动一个echo进程的。`execvp`函数是`exec*`函数组中的一个函数，它从父进程继承了环境变量`PATH`，并像父进程一样搜索可执行文件：'
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Code Box 17-3 [ExtremeC_examples_chapter17_3.c]: Demonstration of how execvp
    works'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 17-3 [ExtremeC_examples_chapter17_3.c]：展示`execvp`的工作原理
- en: As you see in the preceding code box, we have invoked the function `execvp`.
    As we explained before, the `execvp` function inherits the environment variable
    `PATH`, together with the way it looks for the existing executables, from the
    base process. It accepts two arguments; the first is the name of the executable
    file or the script which should be loaded and executed, and the second is the
    list of arguments that should be passed to the executable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在先前的代码框中看到的那样，我们调用了`execvp`函数。正如我们之前解释的那样，`execvp`函数从基础进程继承了环境变量`PATH`，以及它查找现有可执行文件的方式。它接受两个参数；第一个是要加载和执行的可执行文件或脚本的名称，第二个是要传递给可执行文件的参数列表。
- en: Note that we are passing `echo` and not an absolute path. Therefore, `execvp`
    should locate the `echo` executable first. These executable files can be anywhere
    in a Unix-like operating system, from `/usr/bin` to `/usr/local/bin` or even other
    places. The absolute location of the `echo` can be found by going through all directory
    paths found in the `PATH` environment variable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们传递的是`echo`而不是绝对路径。因此，`execvp`应该首先定位`echo`可执行文件。这些可执行文件可以位于类Unix操作系统的任何位置，从`/usr/bin`到`/usr/local/bin`或甚至其他地方。可以通过遍历`PATH`环境变量中找到的所有目录路径来找到`echo`的绝对位置。
- en: 'The `exec*` functions can execute a range of executable files. Following is
    a list of some file formats that can be executed by `exec*` functions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec*`函数可以执行一系列可执行文件。以下是一些可以通过`exec*`函数执行的一些文件格式列表：'
- en: ELF executable files
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ELF可执行文件
- en: Script files with a *shebang* line indicating the *interpreter* of the script
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含指示脚本*解释器*的*shebang*行的脚本文件
- en: Traditional `a.out` format binary files
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统`a.out`格式的二进制文件
- en: ELF FDPIC executable files
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ELF FDPIC可执行文件
- en: After finding the `echo` executable file, the `execvp` does the rest. It calls
    the `exec` (`execve` in Linux) system call with a prepared set of arguments and
    subsequently, the kernel prepares a process image from the found executable file.
    When everything is ready, the kernel replaces the current process image with the
    prepared one, and the base process is gone forever. Now, the control returns to
    the new process, and it becomes executing from its `main` function, just like
    a normal execution.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 找到`echo`可执行文件后，`execvp`完成剩余的工作。它使用一组准备好的参数调用`exec`（在Linux中为`execve`）系统调用，然后内核从找到的可执行文件中准备进程映像。当一切准备就绪时，内核用准备好的映像替换当前进程映像，基本进程永远消失。现在，控制权返回到新进程，它从其`main`函数开始执行，就像正常执行一样。
- en: As a result of this process, the `printf` statement after the `execvp` function
    call statement cannot be executed if the `execvp` has been successful, because
    now we have a whole new process with new memory segments and new instructions.
    If the `execvp` statement wasn't successful, then the `printf` should have been
    executed, which is a sign for the failure of `execvp` function call.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个过程，如果在`execvp`函数调用语句之后，`printf`语句无法被执行，因为现在我们有一个全新的进程，拥有新的内存段和新的指令。如果`execvp`语句没有成功，那么`printf`应该被执行，这是`execvp`函数调用失败的标志。
- en: 'Like we said before, we have a group of `exec*` functions, and the `execvp`
    function is only one of them. While all of them behave similarly, they have slight
    differences. Next, you can find a comparison of these functions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，我们有一组`exec*`函数，而`execvp`函数只是其中之一。虽然它们的行为相似，但它们之间有一些细微的差别。接下来，你可以找到这些函数的比较：
- en: '`execl(const char* path, const char* arg0, ..., NULL)`: Accepts an absolute
    path to the executable file and a series of arguments that should be passed to
    the new process. They must end with a null string, `0` or `NULL`. If we wanted
    to rewrite *example 17.3* using `execl`, we would use `execl("/usr/bin/echo",
    "echo", "Hello", "World", NULL)`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execl(const char* path, const char* arg0, ..., NULL)`: 接受指向可执行文件的绝对路径以及一系列应该传递给新进程的参数。它们必须以空字符串、`0`或`NULL`结尾。如果我们想使用`execl`重写*示例17.3*，我们会使用`execl("/usr/bin/echo",
    "echo", "Hello", "World", NULL)`。'
- en: '`execlp(const char* file, const char* arg0, ..., NULL)`: Accepts a relative
    path as its first argument, but since it has access to the `PATH` environment
    variable, it can locate the executable file easily. Then, it accepts a series
    of arguments that should be passed to the new process. They must end with a null
    string, `0` or `NULL`. If we wanted to rewrite *example 17.3* using `execlp`,
    we would use `execlp("echo", "echo," "Hello," "World," NULL)`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execlp(const char* file, const char* arg0, ..., NULL)`: 接受一个相对路径作为其第一个参数，但由于它可以访问`PATH`环境变量，它可以轻松地定位可执行文件。然后，它接受一系列应该传递给新进程的参数。它们必须以空字符串、`0`或`NULL`结尾。如果我们想使用`execlp`重写*示例17.3*，我们会使用`execlp("echo",
    "echo," "Hello," "World," NULL)`。'
- en: '`excele(const char* path, const char* arg0, ..., NULL, const char* env0, ...,
    NULL)`: Accepts an absolute path to the executable file as its first argument.
    Then, it accepts a series of arguments that should be passed to the new process
    followed by a null string. Following that, it accepts a series of strings representing
    the environment variables. They must also end with a null string. If we wanted
    to rewrite *example 17.3* using `execle`, we would use `execle("/usr/bin/echo",
    "echo", "Hello", "World", NULL, "A=1", "B=2", NULL)`. Note that in this call we
    have passed two new environment variables, `A` and `B`, to the new process.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execle(const char* path, const char* arg0, ..., NULL, const char* env0, ...,
    NULL)`: 作为其第一个参数接受指向可执行文件的绝对路径。然后，它接受一系列应传递给新进程的参数，后面跟一个空字符串。随后，它接受一系列表示环境变量的字符串。它们也必须以空字符串结尾。如果我们想使用
    `execle` 重写 *示例 17.3*，我们将使用 `execle("/usr/bin/echo", "echo", "Hello", "World",
    NULL, "A=1", "B=2", NULL)`。请注意，在这个调用中，我们向新进程传递了两个新的环境变量，`A` 和 `B`。'
- en: '`execv(const char* path, const char* args[])`: Accepts an absolute path to
    the executable file and an array of the arguments that should be passed to the
    new process. The last element in the array must be a null string, `0` or `NULL`.
    If we wanted to rewrite *example 17.3* using `execl`, we would use `execl("/usr/bin/echo",
    args)` in which `args` is declared like this: `char* args[] = {"echo", "Hello",
    "World", NULL}`.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execv(const char* path, const char* args[])`: 接受指向可执行文件的绝对路径以及应传递给新进程的参数数组。数组中的最后一个元素必须是一个空字符串，`0`
    或 `NULL`。如果我们想使用 `execl` 重写 *示例 17.3*，我们将使用 `execl("/usr/bin/echo", args)`，其中
    `args` 的声明如下：`char* args[] = {"echo", "Hello", "World", NULL}`。'
- en: '`execvp(const char* file, const char* args[])`: It accepts a relative path
    as its first argument, but since it has access to the `PATH` environment variable,
    it can locate the executable file easily. Then, it accepts an array of the arguments
    that should be passed to the new process. The last element in the array must be
    a null string, `0` or `NULL`. This is the function that we used in *example 17.3*.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execvp(const char* file, const char* args[])`: 它接受一个相对路径作为其第一个参数，但由于它可以访问
    `PATH` 环境变量，因此可以轻松地定位可执行文件。然后，它接受一个数组，该数组包含应传递给新进程的参数。数组中的最后一个元素必须是一个空字符串，`0`
    或 `NULL`。这是我们在 *示例 17.3* 中使用的函数。'
- en: When `exec*` functions are successful, the previous process is gone, and a new
    process is created instead. Therefore, there isn't a second process at all. For
    this reason, we cannot demonstrate interleavings as we did for the `fork` API.
    In the next section, we compare the `fork` API and the `exec*` functions for executing
    a new program.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `exec*` 函数成功时，之前的进程就消失了，取而代之的是一个新的进程。因此，根本就没有第二个进程。因此，我们无法像对 `fork` API 那样演示交错。在下一节中，我们将比较
    `fork` API 和 `exec*` 函数以执行新程序。
- en: Comparing process creation and process execution
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较进程创建和进程执行
- en: 'Based on our discussion and the given examples in previous sections, we can
    make the following comparison between the two methods used for executing a new
    program:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我们之前的讨论和前几节给出的示例，我们可以对用于执行新程序的两个方法进行比较：
- en: A successful invocation of the `fork` function results in two separate processes;
    a parent process that has called the `fork` function and a forked (or child) process.
    But a successful invocation of any `exec*` function results in having the caller
    process substituted by a new process image and therefore no new process is created.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功调用 `fork` 函数会导致两个独立进程的结果；一个调用 `fork` 函数的父进程和一个分叉的（或子）进程。但任何 `exec*` 函数的成功调用都会导致调用进程被新的进程映像替换，因此不会创建新的进程。
- en: Calling the `fork` function duplicates all memory contents of the parent process,
    and the forked process sees the same memory contents and variables. But calling
    the `exec*` functions destroys the memory layout of the base process and creates
    a new layout based on the loaded executable.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `fork` 函数会复制父进程的所有内存内容，分叉进程会看到相同的内存内容和变量。但调用 `exec*` 函数会破坏基本进程的内存布局，并基于加载的可执行文件创建一个新的布局。
- en: A forked process has access to certain attributes of the parent process, for
    example, open file descriptors but using `exec*` functions. The new process doesn't
    know anything about it, and it doesn't inherit anything from the base process.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个分叉进程可以访问父进程的某些属性，例如，打开的文件描述符，但使用 `exec*` 函数。新的进程对此一无所知，并且它不会从基本进程继承任何内容。
- en: In both APIs, we end up with a new process that has only one main thread. The
    threads in the parent process are not forked using the fork API.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这两个API中，我们最终得到一个只有一个主线程的新进程。父进程中的线程不是使用`fork` API进行克隆的。
- en: The `exec*` API can be used to run scripts and external executable files, but
    the `fork` API can be used only to create a new process that is actually the same
    C program.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`exec*` API运行脚本和外部可执行文件，但只能使用`fork` API创建一个实际上是相同C程序的新进程。
- en: In the next section, we'll talk about the steps that most kernels take to load
    and execute a new process. These steps and their details vary from one kernel
    to another, but we try to cover the general steps taken by most known kernels
    to execute a process.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论大多数内核加载和执行新进程所采取的步骤。这些步骤及其细节因内核而异，但我们尽力涵盖大多数已知内核执行进程所采取的一般步骤。
- en: Process execution steps
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程执行步骤
- en: To have a process executed from an executable file, the user space and the kernel
    space take some general steps in most operating systems. As we noted in the previous
    section, executable files are mostly executable object files, for example, ELF,
    Mach, or script files that need an interpreter to execute them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要从可执行文件执行进程，大多数操作系统中的用户空间和内核空间需要采取一些通用步骤。正如我们在上一节中提到的，可执行文件大多是可执行对象文件，例如ELF、Mach或需要解释器来执行它们的脚本文件。
- en: From the user ring's point of view, a system call like `exec` should be invoked.
    Note that we don't explain the `fork` system call here because it is not actually
    an execution. It is more of a cloning operation of the currently running process.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户环的角度来看，应该调用像`exec`这样的系统调用。请注意，我们在这里不解释`fork`系统调用，因为它实际上不是执行。它更多的是当前运行进程的克隆操作。
- en: When the user space invokes the `exec` system call, a new request for the execution
    of the executable file is created within the kernel. The kernel tries to find
    a handler for the specified executable file based on its type and according to that
    handler, it uses a *loader program* to load the contents of the executable file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户空间调用`exec`系统调用时，内核内部会创建一个新的执行可执行文件请求。内核试图根据其类型找到指定的可执行文件的处理程序，并根据该处理程序，使用*加载程序*来加载可执行文件的内容。
- en: 'Note that for the script files, the executable binary of the interpreter program
    that is usually specified in the *shebang line* on the first line of the script.
    The loader program has the following duties in order to execute a process:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于脚本文件，解释程序的可执行二进制文件通常在脚本的第一行的*shebang行*中指定。为了执行进程，加载程序有以下职责：
- en: It checks the execution context and the permissions of the user that has requested
    the execution.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检查请求执行的用户的执行上下文和权限。
- en: It allocates the memory for the new process from the main memory.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从主内存为新进程分配内存。
- en: It copies the binary contents of the executable file into the allocated memory.
    This mostly involves the Data, and Text segments.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将可执行文件的二进制内容复制到分配的内存中。这主要涉及数据和文本段。
- en: It allocates a memory region for the Stack segment and prepares the initial
    memory mappings.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为栈段分配一个内存区域，并准备初始内存映射。
- en: The main thread and its Stack memory region are created.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建主线程及其栈内存区域。
- en: It copies the command-line arguments as a *stack frame* on top of the Stack
    region of the main thread.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将命令行参数作为*栈帧*复制到主线程栈区域的顶部。
- en: It initializes the vital registers that are needed for the execution.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它初始化执行所需的必要寄存器。
- en: It executes the first instruction of the program entry point.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它执行程序入口点的第一条指令。
- en: In the case of script files, the path to the script files is copied as the command-line
    argument of the interpreter process. The preceding general steps are taken by
    most kernels, but the implementation details can vary greatly from a kernel to
    another.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本文件的情况下，脚本文件的路径被复制为解释器进程的命令行参数。大多数内核都采取这些一般步骤，但实现细节可能因内核而异。
- en: 'For more information on a specific operating system, you need to go to its
    documentation or simply search for it on Google. The following articles from LWN
    are a great start for those seeking more details about the pro[cess execution
    in Linux: https:/](https://lwn.net/Articles/631631/)/lwn.[net/Articles/631631/
    and https:/](https://lwn.net/Articles/630727/)/lwn.net/Articles/630727/.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于特定操作系统的信息，你需要查看其文档或简单地通过谷歌搜索。以下来自LWN的文章是那些寻求更多关于Linux进程执行细节的人的绝佳起点：[https://lwn.net/Articles/631631/](https://lwn.net/Articles/631631/)
    和 [https://lwn.net/Articles/630727/](https://lwn.net/Articles/630727/)。
- en: In the next section, we'll start to talk about concurrency-related topics. We
    prepare the ground for the next chapter, which is going to talk about multi-processing-specific
    synchronization techniques in great depth. We start here by discussing shared
    states, which can be used in multi-process software systems.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始讨论与并发相关的话题。我们为下一章做准备，下一章将深入探讨多进程特定的同步技术。我们首先从讨论共享状态开始，这些状态可以在多进程软件系统中使用。
- en: Shared states
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享状态
- en: As with threads, we can have some shared states between processes. The only
    difference is that the threads are able to access the same memory space owned
    by their owner process, but processes cannot have that luxury. Therefore, other
    mechanisms should be employed to share a state among a number of processes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与线程一样，我们可以在进程之间有一些共享状态。唯一的区别是线程能够访问它们所属进程拥有的相同内存空间，但进程没有这样的奢侈。因此，应该采用其他机制来在多个进程之间共享状态。
- en: In this section, we are going to discuss these techniques and as part of this
    chapter, we focus on some of them that function as storage. In the first section,
    we will be discussing different techniques and trying to group them based on their
    nature.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论这些技术，作为本章的一部分，我们将重点关注其中一些作为存储功能的技术。在第一部分，我们将讨论不同的技术，并尝试根据它们的性质对它们进行分组。
- en: Sharing techniques
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享技术
- en: If you look at the ways you can share a state (a variable or an array) between
    two processes, it turns out that it can be done in a limited number of ways. Theoretically,
    there are two main categories of sharing a state between a number of processes,
    but in a real computer system, each of these categories has some subcategories.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看你可以在两个进程之间共享状态（一个变量或一个数组）的方法，你会发现这可以通过有限的方式完成。理论上，在多个进程之间共享状态主要有两大类，但在实际的计算机系统中，每一类都有一些子类别。
- en: You either have to put a state in a "place" that can be accessed by a number
    of processes, or you must have your state *sent* or *transferred* as a message,
    signal, or event to other processes. Similarly, you either have to *pull* or *retrieve*
    an existing state from a "place," or *receive* it as a message, signal, or event.
    The first approach needs storage or a *medium* like a memory buffer or a filesystem,
    and the second approach requires you to have a messaging mechanism or a *channel*
    in place between the processes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你要么必须将状态放在一个可以被多个进程访问的“地方”，要么你必须将你的状态*发送*或*传输*为消息、信号或事件给其他进程。同样，你要么必须*拉取*或*检索*一个现有的状态从一个“地方”，要么*接收*它作为消息、信号或事件。第一种方法需要存储或一种*介质*，如内存缓冲区或文件系统，而第二种方法要求你在进程之间有一个消息机制或*通道*。
- en: As an example for the first approach, we can have a shared memory region as
    a medium with an array inside that can be accessed by a number of processes to
    read and modify the array. As an example for the second approach, we can have
    a computer network as the channel to allow some messages to be transmitted between
    a number of processes located on different hosts in that network.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一种方法的例子，我们可以有一个共享内存区域作为介质，其中包含一个数组，多个进程可以访问并修改这个数组。作为第二种方法的例子，我们可以有一个计算机网络作为通道，允许网络中不同主机上的多个进程之间传输一些消息。
- en: Our current discussion on how to share states between some processes is not
    in fact limited to just processes; it can be applied to threads as well. Threads
    can also have signaling between themselves to share a state or propagate an event.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前关于如何在一些进程之间共享状态的讨论实际上并不局限于进程；它也可以应用于线程。线程之间也可以进行信号传递以共享状态或传播事件。
- en: In different terminology, the techniques found in the first group that requires
    a *medium* such as storage to share states are called *pull-based* techniques.
    That's because the processes that want to read states have to pull them from storage.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的术语中，第一组中发现的、需要像存储这样的**介质**来共享状态的技巧被称为**基于拉取**的技巧。这是因为想要读取状态的进程必须从存储中拉取它们。
- en: The techniques in the second group that require a *channel* to transmit states
    are called *push-based* techniques. That's because the states are pushed (or delivered)
    through the channel to the receiving process and it doesn't need to pull them
    from a medium. We will be using these terms from now on to refer to these techniques.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组中需要**通道**来传输状态的技巧被称为**基于推送**的技巧。这是因为状态是通过通道推送到接收进程的，它不需要从中拉取。从现在开始，我们将使用这些术语来指代这些技巧。
- en: The variety in push-based techniques has led to various distributed architectures
    in the modern software industry. The pull-based techniques are considered to be
    legacy in comparison to push-based techniques, and you can see it in many enterprise
    applications where a single central database is used to share various states throughout
    the entire system.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 基于推送的技术多样性导致了现代软件行业中各种分布式架构的出现。与基于推送的技术相比，基于拉取的技术被认为是遗留的，你可以在许多企业应用中看到这一点，在这些应用中，单个中央数据库被用来在整个系统中共享各种状态。
- en: However, the push-based approach is gaining momentum these days and has led
    to techniques such as *event sourcing* and a number of other similar distributed
    approaches used for keeping all parts of a big software system consistent with
    each other without having all data stored in a central place.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，基于推送的方法目前正在兴起，并导致了诸如**事件溯源**和其他一些类似的分布式方法的出现，这些方法用于保持大型软件系统的各个部分之间的一致性，而无需将所有数据存储在中央位置。
- en: Between the two approaches discussed, we are particularly interested in the
    first approach throughout this chapter. We will focus more upon the second approach
    in *Chapter 19*, *Single-Host IPC and Sockets*, and *Chapter 20*, *Socket Programming*.
    In those chapters we are going to introduce the various channels available to
    transmit messages between processes as part of **Inter-Process Communication**
    (**IPC**) techniques. Only then will we be able to explore the various push-based
    techniques and give some real examples for the observed concurrency issues and
    the control mechanisms that can be employed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论的两种方法中，我们特别关注本章中的第一种方法。我们将在第19章“单主机IPC和套接字”，第20章“套接字编程”中更多地关注第二种方法。在这些章节中，我们将介绍作为**进程间通信（IPC**）技术一部分的用于在进程之间传输消息的各种通道。只有在这种情况下，我们才能探索各种基于推送的技术，并给出一些观察到的并发问题和可以采用的控制机制的实例。
- en: 'The following is a list of pull-based techniques that are supported by the
    POSIX standard and can be used widely in all POSIX-compliant operating systems:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由POSIX标准支持的基于拉取的技术列表，可以在所有POSIX兼容的操作系统上广泛使用：
- en: '**Shared memory**: This is simply a region in the main memory that is shared
    and accessible to a number of processes, and they can use it to store variables
    and arrays just like an ordinary memory block. A shared memory object is not a
    file on disk, but it is the actual memory. It can exist as a standalone object
    in the operating system even when there is no process using it. Shared memory
    objects can be removed whether by a process when not needed anymore or by rebooting
    the system. Therefore, in terms of surviving reboots, shared memory objects can
    be thought of as temporary objects.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享内存**：这只是一个在主内存中的共享区域，可以被多个进程访问，它们可以像普通内存块一样使用它来存储变量和数组。共享内存对象不是磁盘上的文件，但它确实是内存。即使没有进程使用它，它也可以作为操作系统中的独立对象存在。当不再需要时，共享内存对象可以被进程移除，或者通过重启系统来移除。因此，从重启生存性的角度来看，共享内存对象可以被视为临时对象。'
- en: '**Filesystem**: Processes can use files to share states. This technique is
    one of the oldest techniques to share some states throughout a software system
    among a number of processes. Eventually, difficulties with synchronizing access
    to the shared files, together with many other valid reasons, have led to the invention
    of **Database Management Systems** (**DBMSes**), but still, the shared files are
    being used in certain use cases.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件系统**：进程可以使用文件来共享状态。这是一种在软件系统中在多个进程之间共享某些状态的最古老的技术之一。最终，同步访问共享文件的问题，以及许多其他有效的原因，导致了**数据库管理系统**（DBMS）的发明，但仍然，在某些用例中仍在使用共享文件。'
- en: '**Network services**: Once available to all processes, processes can use network
    storage or a network service to store and retrieve a shared state. In this scenario,
    the processes do not know exactly what is going on behind the scenes. They just
    use a network service through a well-defined API that allows them to perform certain
    operations on a shared state. As some examples, we can name **Network Filesystems**
    (**NFS**) or DBMSes. They offer network services that allow maintaining states
    through a well-defined model and a set of companion operations. To give a more
    specific example, we can mention *Relational DBMSes,* which allow you to store
    your states in a relational model through using SQL commands.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络服务**：一旦对所有进程可用，进程可以使用网络存储或网络服务来存储和检索共享状态。在这种情况下，进程并不确切知道幕后发生了什么。他们只是通过一个定义良好的API使用网络服务，该API允许他们对共享状态执行某些操作。例如，我们可以提到**网络文件系统**（NFS）或数据库管理系统（DBMS）。它们提供网络服务，允许通过定义良好的模型和一系列伴随操作来维护状态。更具体的例子，我们可以提到*关系型数据库管理系统*，它允许您通过使用SQL命令在关系模型中存储您的状态。'
- en: In the following subsections, we will be discussing each of the above methods
    found as part of the POSIX interface. We start with POSIX shared memory, and we
    show how it can lead to familiar data races known from *Chapter 16*, *Thread Synchronization*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将讨论作为POSIX接口一部分的上述每种方法。我们首先从POSIX共享内存开始，展示它如何导致从*第16章*，*线程同步*中熟悉的数据竞争。
- en: POSIX shared memory
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POSIX共享内存
- en: Supported by POSIX standard, shared memory is one of the widely used techniques
    to share a piece of information among a number of processes. Unlike threads that
    can access the same memory space, processes do not have this power and access
    to the memory of other processes is prohibited by the operating system. Therefore,
    we need a mechanism in order to share a portion of memory between two processes,
    and shared memory is exactly that technique.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由POSIX标准支持，共享内存是广泛用于在多个进程之间共享信息的技术之一。与可以访问相同内存空间的线程不同，进程没有这种能力，操作系统禁止进程访问其他进程的内存。因此，我们需要一种机制来在两个进程之间共享内存的一部分，共享内存正是这种技术。
- en: 'In the following examples, we go through the details of creating and using
    a shared memory object, and we start our discussion by creating a shared memory
    region. The following code shows how to create and populate a shared memory object
    within a POSIX-compliant system:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将详细介绍创建和使用共享内存对象的过程，我们的讨论从创建共享内存区域开始。以下代码展示了如何在POSIX兼容系统中创建和填充共享内存对象：
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Code Box 17-4 [ExtremeC_examples_chapter17_4.c]: Creating and writing to a
    POSIX shared memory object'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框17-4 [ExtremeC_examples_chapter17_4.c]：创建和写入POSIX共享内存对象
- en: The preceding code creates a shared memory object named `/shm0` with 16 bytes
    in it. Then it populates the shared memory with the literal `ABC\n` and finally,
    it quits by *unmapping* the shared memory region. Note that the shared memory
    object remains in place even when the process quits. Future processes can open
    and read the same shared memory object over and over again. A shared memory object
    is destructed either by rebooting the system or by getting *unlinked* (removed)
    by a process.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个名为`/shm0`的共享内存对象，其中包含16个字节。然后它使用字面量`ABC\n`填充共享内存，最后通过*取消映射*共享内存区域来退出。请注意，即使进程退出，共享内存对象仍然保留。未来的进程可以反复打开和读取相同的共享内存对象。共享内存对象要么通过系统重启来销毁，要么通过进程将其*取消链接*（移除）。
- en: '**Note**:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: In FreeBSD, the names of the shared memory objects should start with `/`. This
    is not mandatory in Linux or macOS, but we did the same for both of them to remain
    compatible with FreeBSD.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在FreeBSD中，共享内存对象的名称应该以“/”开头。在Linux或macOS中这不是强制性的，但我们为了与FreeBSD保持兼容，对它们也做了同样的处理。
- en: In the preceding code, we firstly open a shared memory object using the `shm_open`
    function. It accepts a name and the modes that the shared memory object should
    be created with. `O_CREAT` and `O_RDWR` mean that the shared memory should be
    created, and it can be used for both reading and writing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先使用 `shm_open` 函数打开一个共享内存对象。它接受一个名称和共享内存对象应创建的模式。`O_CREAT` 和 `O_RDWR`
    表示应创建共享内存，并且它可以用于读取和写入操作。
- en: Note the creation won't fail if the shared memory object already exists. The
    last argument indicates the permissions of the shared memory object. `0600` means
    that it is available for reading and write operations performed by the processes
    that are initiated only by the owner of the shared memory object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果共享内存对象已经存在，创建操作不会失败。最后一个参数表示共享内存对象的权限。`0600` 表示它仅对启动共享内存对象的拥有者进程的读取和写入操作可用。
- en: On the following lines, we define the size of the shared memory region by truncating
    it using `ftruncate` function. Note that this is a necessary step if you're about
    to create a new shared memory object. For the preceding shared memory object,
    we have defined 16 bytes to be allocated and then truncated.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几行中，我们通过使用 `ftruncate` 函数截断共享内存区域的大小来定义共享内存区域的大小。请注意，如果您即将创建一个新的共享内存对象，这是一个必要的步骤。对于前面的共享内存对象，我们已定义了
    16 字节进行分配，然后进行了截断。
- en: As we proceed, we map the shared memory object to a region accessible by the
    process using the `mmap` function. As a result of this, we have a pointer to the
    mapped memory and that can be used to access the shared memory region behind.
    This is also a necessary step that makes the shared memory accessible to our C
    program.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的进行，我们使用 `mmap` 函数将共享内存对象映射到进程可访问的区域。因此，我们有一个指向映射内存的指针，可以用来访问后面的共享内存区域。这也是一个必要的步骤，使得共享内存对我们的
    C 程序可访问。
- en: The function `mmap` is usually used to map a file or a shared memory region
    (originally allocated from the kernel's memory space) to an address space that
    is accessible to the caller process. Then, the mapped address space can be accessed
    as a regular memory region using ordinary pointers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `mmap` 通常用于将文件或共享内存区域（最初从内核的内存空间分配）映射到调用进程可访问的地址空间。然后，映射的地址空间可以使用普通指针作为常规内存区域进行访问。
- en: As you can see, the region is mapped as a writable region indicated by `PROT_WRITE`
    and as a shared region among processes indicated by the `MAP_SHARED` argument.
    `MAP_SHARED` simply means any changes to the mapped area will be visible to other
    processes mapping the same region.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该区域被映射为一个可写区域，由 `PROT_WRITE` 指示，并且作为进程间的共享区域，由 `MAP_SHARED` 参数指示。`MAP_SHARED`
    简单地意味着对映射区域的任何更改都将对映射相同区域的其它进程可见。
- en: Instead of `MAP_SHARED`, we could have `MAP_PRIVATE`; this means that the changes
    to the mapped region are not propagated to other processes and are, rather, private
    to the mapper process. This usage is not common unless you want to use the shared
    memory inside a process only.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `MAP_SHARED`，我们还可以使用 `MAP_PRIVATE`；这意味着对映射区域的更改不会传播到其他进程，而是对映射进程是私有的。除非您只想在进程内部使用共享内存，否则这种用法并不常见。
- en: After mapping the shared memory region, the preceding code writes a null-terminated
    string `ABC\n` into the shared memory. Note the new line feed character at the
    end of the string. As the final steps, the process unmaps the shared memory region
    by calling the `munmap` function and then it closes the file descriptor assigned
    to the shared memory object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射共享内存区域后，前面的代码将一个以空字符终止的字符串 `ABC\n` 写入共享内存。注意字符串末尾的新行换行符。作为最后一步，进程通过调用 `munmap`
    函数取消映射共享内存区域，然后关闭分配给共享内存对象的文件描述符。
- en: '**Note**:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: Every operating system offers a different way to create an *unnamed* or *anonymous
    shared memory* object. In FreeBSD, it is enough to pass `SHM_ANON` as the path
    of the shared memory object to the `shm_open` function. In Linux, one can create
    an anonymous file using a `memfd_create` function instead of creating a shared
    memory object and use the returned file descriptor to create a mapped region.
    An anonymous shared memory is private to the owner process and cannot be used
    to share states among a number of processes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统都提供了一种不同的方式来创建一个未命名的或匿名的共享内存对象。在 FreeBSD 中，只需将 `SHM_ANON` 作为共享内存对象的路径传递给
    `shm_open` 函数即可。在 Linux 中，可以使用 `memfd_create` 函数创建一个匿名文件，而不是创建共享内存对象，并使用返回的文件描述符创建一个映射区域。匿名共享内存仅对拥有进程是私有的，不能用于在多个进程之间共享状态。
- en: The preceding code can be compiled on macOS, FreeBSD, and Linux systems. In
    Linux systems, shared memory objects can be seen inside the directory `/dev/shm`.
    Note that this directory doesn't have a regular filesystem and those you see are
    not files on a disk device. Instead, `/dev/shm` uses the `shmfs` filesystem. It
    is meant to expose the temporary objects created inside the memory through a mounted
    directory, and it is only available in Linux.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以在macOS、FreeBSD和Linux系统上编译。在Linux系统中，共享内存对象可以在目录`/dev/shm`中看到。请注意，这个目录不是一个常规的文件系统，你看到的东西不是磁盘设备上的文件。相反，`/dev/shm`使用`shmfs`文件系统。它的目的是通过挂载的目录来暴露内存中创建的临时对象，并且它仅在Linux中可用。
- en: 'Let''s compile and run *example 17.4* in Linux and examine the contents of
    the `/dev/shm` directory. In Linux, it is mandatory to link the final binary with
    the `rt` library in order to use shared memory facilities, and that''s why you
    see the option `-lrt` in the following shell box:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Linux中编译并运行*示例17.4*，并检查`/dev/shm`目录的内容。在Linux中，必须将最终二进制文件与`rt`库链接，才能使用共享内存功能，这就是为什么你在下面的shell框中看到`-lrt`选项的原因：
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Shell Box 17-4: Building and running example 17.4 and checking if the shared
    memory object is created'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 17-4：构建和运行示例17.4并检查共享内存对象是否创建
- en: As you can see on the first line, there are no shared memory objects in the
    `/dev/shm` directory. On the second line, we build *example 17.4*, and on the
    third line, we execute the produced executable file. Then we check `/dev/shm`,
    and we see that we've got a new shared memory object, `shm0`, there.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在第一行所见，`/dev/shm`目录中没有共享内存对象。在第二行，我们构建了*示例17.4*，在第三行，我们执行了生成的可执行文件。然后我们检查`/dev/shm`，我们看到那里有一个新的共享内存对象，`shm0`。
- en: The output of the program also confirms the creation of the shared memory object.
    Another important thing about the preceding shell box is the file descriptor `3`,
    which is assigned to the shared memory object.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出也确认了共享内存对象的创建。前一个shell框中另一个重要的事情是文件描述符`3`，它被分配给了共享内存对象。
- en: For every file you open, a new file descriptor is opened in each process. This
    file is not necessarily on disk, and it can be a shared memory object, standard
    output, and so on. In each process, file descriptors start from 0 and go up to
    a maximum allowed number.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你打开的每个文件，每个进程都会打开一个新的文件描述符。这个文件不一定在磁盘上，它可以是共享内存对象、标准输出等等。在每个进程中，文件描述符从0开始，直到最大允许的数字。
- en: Note that in each process, the file descriptors `0`, `1`, and `2` are preassigned
    to the `stdout`, `stdin`, and `stderr` streams, respectively. These file descriptors
    are opened for every new process before having its `main` function run. That's
    basically why the shared memory object in the preceding example gets `3` as its
    file descriptor.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在每个进程中，文件描述符`0`、`1`和`2`分别预分配给了`stdout`、`stdin`和`stderr`流。在`main`函数运行之前，为每个新进程打开了这些文件描述符。这就是为什么前一个例子中的共享内存对象得到`3`作为其文件描述符的原因。
- en: '**Note**:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: On macOS systems, you can use the `pics` utility to check active IPC objects
    in the system. It can show you the active message queues and shared memories.
    It shows you the active semaphores as well.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS系统上，你可以使用`pics`实用程序检查系统中的活动IPC对象。它可以显示活动的消息队列和共享内存。它还显示了活动的信号量。
- en: 'The `/dev/shm` directory has another interesting property. You can use the
    `cat` utility to see the contents of shared memory objects, but again this is
    only available in Linux. Let''s use it on our created `shm0` object. As you see
    in the following shell box, the contents of the shared memory object are displayed.
    It is the string `ABC` plus a new line feed character `\n`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/shm`目录还有一个有趣的属性。你可以使用`cat`实用程序查看共享内存对象的内容，但同样，这仅在Linux中可用。让我们在我们的创建的`shm0`对象上使用它。如你在下面的shell框中看到的，共享内存对象的内容被显示出来。它是字符串`ABC`加上一个换行符`\n`：'
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Shell Box 17-5 Using the cat program to see the content of the shared memory
    object created as part of example 17.4
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 17-5 使用cat程序查看作为示例17.4部分创建的共享内存对象的内容
- en: As we explained before, a shared memory object exists as long as it is being
    used by at least one process. Even if one of the processes has already asked the
    operating system to delete (or *unlink*) the shared memory, it won't be actually
    deleted until the last process has used it. Even when there is no process unlinking
    a shared memory object, it would be deleted when a reboot happens. Shared memory
    objects cannot survive reboots, and the processes should create them again in
    order to use them for communication.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的，只要至少有一个进程在使用，共享内存对象就会存在。即使其中一个进程已经请求操作系统删除（或*解除链接*）共享内存，它实际上也不会被删除，直到最后一个进程使用它。即使没有进程解除链接共享内存对象，当系统重启时，它也会被删除。共享内存对象无法在重启后存活，进程应该再次创建它们以用于通信。
- en: 'The following example shows how a process can open and read from an already
    existing shared memory object and how it can unlink it finally. *Example 17.5*
    reads from the shared memory object created in *example 17.4*. Therefore, it can
    be considered as complementary to what we did in *example 17.4*:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了进程如何打开并读取已存在的共享内存对象，以及如何最终解除链接它。*Example 17.5*从*example 17.4*中创建的共享内存对象中读取。因此，它可以被视为与我们在*example
    17.4*中做的事情的补充：
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Code Box 17-5 [ExtremeC_examples_chapter17_5.c]: Reading from the shared memory
    object created as part of example 17.4'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 17-5 [ExtremeC_examples_chapter17_5.c]：从作为示例 17.4 部分创建的共享内存对象中读取
- en: As the first statement in the `main` function, we have opened an existing shared
    memory object named `/shm0`. If there is no such shared memory object, we will
    generate an error. As you can see, we have opened the shared memory object as
    read-only, meaning that we are not going to write anything to the shared memory.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`main`函数中的第一条语句，我们打开了一个名为`/shm0`的现有共享内存对象。如果没有这样的共享内存对象，我们将生成一个错误。如您所见，我们以只读方式打开了共享内存对象，这意味着我们不会向共享内存中写入任何内容。
- en: On the following lines, we map the shared memory region. Again, we have indicated
    that the mapped region is read-only by passing the `PROT_READ` argument. After
    that, we finally get a pointer to the shared memory region, and we use it to print
    its contents. When we're done with the shared memory, we unmap the region. Following
    this, the assigned file descriptor is closed, and lastly the shared memory object
    is registered for removal by unlinking it through using the `shm_unlink` function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几行中，我们映射了共享内存区域。同样，我们通过传递`PROT_READ`参数表明映射的区域是只读的。之后，我们最终得到了共享内存区域的指针，并使用它来打印其内容。当我们完成共享内存的使用后，我们取消映射该区域。随后，关闭分配的文件描述符，最后通过使用`shm_unlink`函数解除链接共享内存对象。
- en: After this point, when all other processes that are using the same shared memory
    are done with it, the shared memory object gets removed from the system. Note
    that the shared memory object exists as long as there is a process using it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点之后，当所有使用相同共享内存的其他进程完成使用后，共享内存对象将从系统中删除。请注意，只要有一个进程在使用，共享内存对象就会存在。
- en: 'The following is the output of running the preceding code. Note the contents
    of `/dev/shm` before and after running *example 17.5*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在运行前面代码后的输出。注意在运行*example 17.5*前后`/dev/shm`的内容：
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Shell Box 17-6: Reading from the shared memory object created in example 17.4
    and finally removing it'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 框 17-6：从示例 17.4 中创建的共享内存对象中读取，并最终删除它
- en: Data race example using shared memory
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用共享内存的数据竞争示例
- en: Now, it's time to demonstrate a data race using the combination of the fork
    API and shared memory. It would be analogous to the examples given in *Chapter
    15*, *Thread Execution*, to demonstrate a data race among a number of threads.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候演示使用 fork API 和共享内存的组合来产生数据竞争了。这可以与*第 15 章*中给出的示例类似，以演示多个线程之间的数据竞争。
- en: 'In *example 17.6*, we have a counter variable that is placed inside a shared
    memory region. The example forks a child process out of the main running process,
    and both of them try to increment the shared counter. The final output shows a
    clear data race over the shared counter:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在*example 17.6*中，我们有一个放置在共享内存区域内的计数器变量。该示例从主运行进程中派生出一个子进程，它们都尝试增加共享计数器。最终的输出显示了共享计数器上的明显数据竞争：
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Code Box 17-6 [ExtremeC_examples_chapter17_6.c]: Demonstration of a data race
    using a POSIX shared memory and the fork API'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 代码框 17-6 [ExtremeC_examples_chapter17_6.c]：使用 POSIX 共享内存和 fork API 演示数据竞争
- en: There are three functions in the preceding code other than the `main` function.
    The function `init_shared_resource` creates the shared memory object. The reason
    that I've named this function `init_shared_resource` instead of `init_shared_memory`
    is the fact that we could use another pull-based technique in the preceding example
    and having a general name for this function allows the `main` function to remain
    unchanged in the future examples.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，除了 `main` 函数之外，还有三个函数。函数 `init_shared_resource` 创建共享内存对象。我之所以将此函数命名为
    `init_shared_resource` 而不是 `init_shared_memory`，是因为在前面的示例中我们可以使用另一种基于拉取的技术，并且为这个函数取一个通用的名字，使得
    `main` 函数在未来示例中保持不变。
- en: The function `shutdown_shared_resource` destructs the shared memory and unlinks
    it. In addition, the function `inc_counter` increments the shared counter by 1.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `shutdown_shared_resource` 销毁共享内存并解除链接。此外，函数 `inc_counter` 通过 1 增加共享计数器。
- en: The `main` function truncates and maps the shared memory region just like we
    did in *example 17.4*. After having the shared memory region mapped, the forking
    logic beings. By calling the `fork` function, a new process is spawned, and both
    processes (the forked process and the forking process) try to increment the counter
    by calling the `inc_counter` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数截断并映射共享内存区域，就像我们在 *example 17.4* 中所做的那样。在将共享内存区域映射后，分叉逻辑开始。通过调用 `fork`
    函数，会创建一个新的进程，并且两个进程（分叉进程和分叉进程）都会尝试通过调用 `inc_counter` 函数来增加计数器。'
- en: When the parent process writes to the shared counter, it waits for the child
    process to finish, and only after that, it tries to unmap, close, and unlink the
    shared memory object. Note that the unmapping and the closure of the file descriptor
    happen in both processes, but only the parent process unlinks the shared memory
    object.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当父进程向共享计数器写入时，它会等待子进程完成，然后才尝试取消映射、关闭和解除链接共享内存对象。请注意，取消映射和文件描述符的关闭在两个进程中都会发生，但只有父进程会解除链接共享内存对象。
- en: As you can see as part of *Code Box 17-6*, we have used some unusual `usleep`
    calls in the `inc_counter` function. The reason is to force the scheduler to take
    back the CPU core from one process and give it to another process. Without these
    `usleep` function calls, the CPU core is not usually transferred between the processes,
    and you cannot see the effect of different interleavings very often.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在 *Code Box 17-6* 中所看到的那样，我们在 `inc_counter` 函数中使用了某些不寻常的 `usleep` 调用。原因是强制调度器从某个进程收回
    CPU 核心并将其分配给另一个进程。如果没有这些 `usleep` 函数调用，CPU 核心通常不会在进程之间转移，而且很难经常看到不同交织的效果。
- en: One of the reasons for such an effect is having a small number of instructions
    in each process. If the number of instructions per process increases significantly,
    one can see the non-deterministic behavior of interleavings even without sleep
    calls. As an example, having a loop in each process that counts for 10,000 times
    and increments the shared counter in each iteration is very likely to reveal the
    data race. You can try this yourself.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 导致这种效果的一个原因是每个进程中的指令数量较少。如果每个进程的指令数量显著增加，即使没有睡眠调用，也可以看到交织的非确定性行为。例如，在每个进程中有一个循环，计数
    10,000 次，并在每次迭代中增加共享计数器，这很可能揭示数据竞争。您可以自己尝试一下。
- en: As the final note about the preceding code, the parent process creates and opens
    the shared memory object and assigns a file descriptor to it before forking the
    child process. The forked process doesn't open the shared memory object, but it
    can use the same file descriptor. The fact that all open file descriptors are
    inherited from the parent process helped the child process to continue and use
    the file descriptor, referring to the same shared memory object.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面代码的最后一个注意事项，父进程在创建和打开共享内存对象并将其分配给文件描述符之前，会进行子进程的创建和分叉。分叉后的进程不会打开共享内存对象，但它可以使用相同的文件描述符。所有打开的文件描述符都是从父进程继承的事实，帮助子进程继续使用文件描述符，并引用相同的共享内存对象。
- en: 'The following in *Shell Box 17-7* is the output of running *example 17.6* for
    a number of times. As you can see, we have a clear data race over the shared counter.
    There are moments when the parent or the child process updates the counter without
    obtaining the latest modified value, and this results in printing `1` by both processes:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Shell Box 17-7* 中的以下内容是多次运行 *example 17.6* 的输出。正如您所看到的，我们在共享计数器上存在明显的数据竞争。有时父进程或子进程在未获取最新修改值的情况下更新计数器，这导致两个进程都打印出
    `1`：
- en: '[PRE12]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Shell Box 17-7: Running example 17.6 and demonstration of the data race happening
    over the shared counter'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Shell Box 17-7：运行示例 17.6 并演示在共享计数器上发生的数据竞争
- en: In this section, we showed how to create and use shared memory. We also demonstrated
    a data race example and the way concurrent processes behave while accessing a
    shared memory region. In the following section, we're going to talk about the
    filesystem as another widely used pull-based method to share a state among a number
    of processes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了如何创建和使用共享内存。我们还演示了一个数据竞争的例子以及并发进程在访问共享内存区域时的行为。在下一节中，我们将讨论文件系统作为另一种广泛使用的基于拉的共享状态方法，在多个进程之间共享状态。
- en: File system
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统
- en: POSIX exposes a similar API for working with files in a filesystem. As long
    as the file descriptors are involved and they are used to refer to various system
    objects, the same API as that introduced for working with shared memory can be
    used.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 提供了一个类似的 API 来处理文件系统中的文件。只要涉及到文件描述符，并且它们被用来引用各种系统对象，就可以使用与用于共享内存相同的 API。
- en: We use file descriptors to refer to actual files in a filesystem like **ext4**,
    together with shared memory, pipes, and so on; therefore, the same semantic for
    opening, reading, writing, mapping them to a local memory region, and so on can
    be employed. Therefore, we'd expect to see similar discussion and perhaps similar
    C code regarding the filesystem as we had for the shared memory. We see this in
    *example 17.7*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用文件描述符来引用文件系统中的实际文件，如 **ext4**，以及共享内存、管道等；因此，可以采用相同的语义来打开、读取、写入，将它们映射到本地内存区域等。因此，我们预计会看到与共享内存类似的讨论，也许还有类似的
    C 代码。这在 *示例 17.7* 中可以看到。
- en: '**Note**:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：'
- en: 'We usually map file descriptors. There are some exceptional cases, however,
    where *socket descriptors* can be mapped. Socket descriptors are similar to file
    descriptors but are used for network or Unix sockets. This link provides an interesting
    use case for mapping the kernel buffer behind a TCP socket which is referred to
    as a *zero-copy receive mechanism*: https://lwn.net/Articles/752188/.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常映射文件描述符。然而，也有一些特殊情况，其中 *套接字描述符* 可以被映射。套接字描述符类似于文件描述符，但用于网络或 Unix 套接字。这个链接提供了一个有趣的映射
    TCP 套接字背后的内核缓冲区的用例，这被称为 *零拷贝接收机制*：https://lwn.net/Articles/752188/。
- en: 'Note that it''s correct that the API employed for using the filesystem is very
    similar to the one we used for shared memory, but it doesn''t mean that their
    implementation is similar as well. In fact, a file object in a filesystem backed
    by a hard disk is fundamentally different from a shared memory object. Let''s
    briefly discuss some differences:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，用于使用文件系统的 API 与我们用于共享内存的 API 非常相似，但这并不意味着它们的实现也相似。事实上，由硬盘支持的文件系统中的文件对象与共享内存对象在本质上是有区别的。让我们简要讨论一些区别：
- en: A shared memory object is basically in the memory space of the kernel process
    while a file in a filesystem is located on a disk. At most, such a file has some
    allocated buffers for reading and writing operations.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内存对象基本上位于内核进程的内存空间中，而文件系统中的文件位于磁盘上。这样的文件最多只有一些用于读写操作的分配缓冲区。
- en: The states written to shared memory are wiped out by rebooting the system, but
    the states written to a shared file, if it is backed by a hard disk or permanent
    storage, can be retained after the reboot.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入共享内存的状态在系统重启后会被清除，但写入共享文件的状态，如果它由硬盘或永久存储支持，重启后可以保留。
- en: Generally, accessing shared memory is far faster than accessing the filesystem.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常情况下，访问共享内存比访问文件系统要快得多。
- en: 'The following code is the same data race example that we gave for the shared
    memory in the previous section. Since the API used for the filesystem is pretty
    similar to the API we used for the shared memory, we only need to change two functions
    from *example 17.6*; `init_shared_resource` and `shutdown_shared_resource`. The
    rest will be the same. This is a great achievement that is accomplished by using
    the same POSIX API operating on the file descriptors. Let''s get into the code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是我们在上一节中为共享内存给出的相同数据竞争示例。由于文件系统的 API 与我们用于共享内存的 API 非常相似，我们只需要从 *example
    17.6* 中更改两个函数；`init_shared_resource` 和 `shutdown_shared_resource`。其余的将保持不变。这是通过使用相同的
    POSIX API 在文件描述符上操作而取得的一项伟大成就。让我们来看看代码：
- en: '[PRE13]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code Box 17-7 [ExtremeC_examples_chapter17_7.c]: Demonstration of a data race
    using regular files and the fork API'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Code Box 17-7 [ExtremeC_examples_chapter17_7.c]：使用常规文件和 fork API 演示数据竞争
- en: As you see, the majority of the preceding code is obtained from *example 17.6*.
    The rest is a substitute for using the `open` and `remove` functions instead of
    the `shm_open` and `shm_unlink` functions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，前面的大部分代码来自 *示例 17.6*。其余的是使用 `open` 和 `remove` 函数代替 `shm_open` 和 `shm_unlink`
    函数的替代方案。
- en: Note that the file `data.bin` is created in the current directory since we've
    not given an absolute path to the `open` function. Running the preceding code
    also produces the same data race over the shared counter. It can be examined similarly
    to our approach for *example 17.6*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，文件 `data.bin` 是在当前目录中创建的，因为我们没有给 `open` 函数提供一个绝对路径。运行前面的代码也会产生相同的共享计数器数据竞争。它可以像我们对
    *示例 17.6* 的方法一样进行检查。
- en: So far, we have seen that we can use shared memory and shared files to store
    a state and access it from a number of processes concurrently. Now, it's time
    to talk about multithreading and multi-processing in a greater sense and compare
    them thoroughly.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到我们可以使用共享内存和共享文件来存储状态，并从多个进程中并发地访问它。现在，是时候更深入地讨论多线程和多进程，并彻底比较它们了。
- en: Multithreading versus multi-processing
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程与多进程
- en: After discussing multithreading and multi-processing in *Chapter 14*, *Synchronization*,
    together with concepts we have covered throughout the recent chapters, we are
    in a good position to compare them and give a high-level description of situations
    in which each of the approaches should be employed. Suppose that we are going
    to design a piece of software that aims to process a number of input requests
    concurrently. We discuss this in the context of three different situations. Let's
    start with the first one.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 14 章* 中讨论了多线程和多进程，以及我们在最近几章中介绍的概念之后，我们现在处于一个很好的位置来比较它们，并给出一个高级描述，说明在哪些情况下应该采用每种方法。假设我们正在设计一个旨在并发处理多个输入请求的软件。我们将在三种不同的情况下讨论这个问题。让我们从第一种情况开始。
- en: Multithreading
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线程
- en: The first situation is when you can write a piece of software that has only
    one process, and all the requests go into the same process. All the logic should
    be written as part of the same process, and as a result, you get a fat process
    that does everything in your system. Since this is single-process software, if
    you want to handle many requests concurrently, you need to do it in a multithreaded
    way by creating threads to handle multiple requests. Further, it can be a better
    design decision to go for a *thread pool* that has a limited number of threads.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况是当你可以编写一个只有单个进程的软件时，所有请求都进入同一个进程。所有逻辑都应该作为同一进程的一部分来编写，结果你得到一个庞大的进程，它执行系统中的一切。由于这是单进程软件，如果你想并发处理许多请求，你需要通过创建线程来以多线程的方式处理多个请求。此外，选择一个具有有限线程数的
    *线程池* 可能是一个更好的设计决策。
- en: There are the following considerations regarding concurrency and synchronization
    which should be taken care of. Note that we don't talk about using event loops
    or asynchronous I/O in this situation, while it can still be a valid alternative
    to multithreading.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发和同步方面有以下考虑事项需要注意。请注意，我们在这里不讨论使用事件循环或异步 I/O，尽管它仍然可以是多线程的有效替代方案。
- en: If the number of requests increases significantly, the limited number of threads
    within the thread pool should be increased to overcome the demand. This literally
    means upgrading the hardware and resources on the machine on which the main process
    is running. This is called *scaling up* or *vertical scaling*. It means that you
    upgrade the hardware you have on a single machine to be able to respond to more
    requests. In addition to the possible downtime that clients experience while upgrading
    to the new hardware (though it can be prevented), the upgrade is costly, and you
    have to do another scale up when the number of requests grows again.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的数量显著增加，线程池中有限的线程数量应该增加以克服需求。这实际上意味着升级运行主进程的机器的硬件和资源。这被称为 *向上扩展* 或 *垂直扩展*。这意味着你升级单台机器上的硬件，以便能够响应更多的请求。除了客户在升级到新硬件期间可能经历的可能的停机时间（尽管可以防止这种情况发生）之外，升级是昂贵的，而且当请求的数量再次增长时，你必须进行另一次扩展。
- en: If processing the requests ends up in manipulating a shared state or a data
    store, synchronization techniques can be implemented easily, by knowing the fact
    that threads have access to the same memory space. Of course, this is needed whether
    they have a shared data structure that should be maintained or they have access
    to remote data storage that is not transactional.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理请求最终涉及到操作共享状态或数据存储，可以通过知道线程可以访问相同的内存空间这一事实，轻松地实现同步技术。当然，无论它们是否有一个需要维护的共享数据结构，或者它们是否有访问非事务性的远程数据存储，这都是必要的。
- en: All the threads are running on the same machine, and thus they can use all the
    techniques used for sharing a state that we explained so far, used by both threads
    and processes. This is a great feature and mitigates a lot of pain when it comes
    to thread synchronization.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 所有线程都在同一台机器上运行，因此它们可以使用我们之前解释的用于共享状态的相同技术，这些技术由线程和进程使用。这是一个很棒的功能，并且在处理线程同步时减轻了很多痛苦。
- en: Let's talk about the next situation, when we can have more than one process
    but all of them are on the same machine.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈下一个情况，当我们可以有一个以上的进程，但它们都在同一台机器上。
- en: Single-host multi-processing
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单主机多进程
- en: In this situation, we write a piece of software that has multiple processes,
    but all are deployed on a single machine. All of these processes can be either
    single-threaded, or they can have a thread pool inside that allows each of them
    to handle more than one request at a time.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们编写了一个具有多个进程的软件，但所有这些进程都部署在单个机器上。所有这些进程可以是单线程的，或者它们可以在内部有一个线程池，允许每个进程一次处理多个请求。
- en: When the number of requests increases, one can create new processes instead
    of creating more threads. This is usually called *scaling out* or *horizontal
    scaling*. When you have only one single machine, however, you must scale it up,
    or in other words, you must upgrade its hardware. This can cause the same issues
    we mentioned for the scaling up of a multithreaded program in the previous subsection.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求的数量增加时，可以创建新的进程而不是创建更多的线程。这通常被称为*横向扩展*或*水平扩展*。然而，当你只有一台单机时，你必须向上扩展，换句话说，你必须升级其硬件。这可能会引起我们在前一个子节中提到的多线程程序向上扩展时提到的问题。
- en: When it comes to concurrency, the processes are being executed in a concurrent
    environment. They can only use the multi-processing ways of sharing a state or
    synchronizing the processes. Surely, it is not as convenient as writing multithreaded
    code. In addition, processes can use both pull-based or push-based techniques
    to share states.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到并发时，进程是在并发环境中执行的。它们只能使用多进程方式共享状态或同步进程。当然，这并不像编写多线程代码那样方便。此外，进程可以使用基于拉或基于推的技术来共享状态。
- en: Multi-processing on a single machine is not very effective, and it seems multithreading
    is more convenient when it comes to the effort of coding.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在单台机器上实现多进程并不十分有效，而且当涉及到编码的劳动强度时，似乎多线程更为方便。
- en: The next subsection talks about the distributed multi-processing environment,
    which is the best design to create modern software.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将讨论分布式多进程环境，这是创建现代软件的最佳设计。
- en: Distributed multi-processing
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式多进程
- en: In the final situation, we have written a program that is run as multiple processes,
    running on multiple hosts, all connected to each other through a network, and
    on a single host we can have more than one process running. The following features
    can be seen in such a deployment.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终的情况下，我们编写了一个程序，作为多个进程运行，这些进程运行在多个主机上，所有主机都通过网络相互连接，并且在单个主机上可以运行多个进程。在这种部署中可以看到以下特点。
- en: When faced with significant growth in the number of requests, this system can
    be scaled out without limits. This is a great feature that enables you to use
    commodity hardware when you face such high peaks. Using the clusters of commodity
    hardware instead of powerful servers was one of the ideas that enabled Google
    to run its *Page Rank* and *Map* *Reduce* algorithms on a cluster of machines.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当面临请求数量的显著增长时，这个系统可以无限扩展。这是一个很棒的功能，使你能够在面对如此高的峰值时使用通用硬件。使用通用硬件的集群而不是强大的服务器是谷歌能够在机器集群上运行其*PageRank*和*Map*
    *Reduce*算法的其中一个想法。
- en: 'The techniques discussed in this chapter barely help because they have an important
    prerequisite: that all the processes are running within the same machine. Therefore,
    a completely different set of algorithms and techniques should be employed to
    make the processes synchronized and make shared states available to all processes
    within the system. *Latency*, *fault tolerance*, *availability*, *data consistency*,
    and many more factors should be studied and tuned regarding such a distributed
    system.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的技术几乎无助于解决问题，因为它们有一个重要的先决条件：即所有进程都在同一台机器上运行。因此，应该采用一组完全不同的算法和技术来使进程同步，并使共享状态对系统中的所有进程可用。应该研究和调整诸如*延迟*、*容错性*、*可用性*、*数据一致性*等多个因素，以适应这样的分布式系统。
- en: Processes on different hosts use network sockets to communicate in a push-based
    manner, but the processes on the same host may use local IPC techniques, for example,
    message queues, shared memory, pipes, and so on, to transfer messages and share
    state.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 不同主机上的进程使用网络套接字以基于推送的方式通信，但同一主机上的进程可能使用本地IPC技术，例如消息队列、共享内存、管道等，以传输消息和共享状态。
- en: As a final word in this section, in the modern software industry, we prefer
    scaling out rather than scaling up. This will give rise to many new ideas and
    technologies for data storage, synchronization, message passing, and so on. It
    can even have an impact on the hardware design to make it suitable for horizontal
    scaling.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后，在现代软件行业中，我们更倾向于横向扩展而不是纵向扩展。这将引发许多关于数据存储、同步、消息传递等方面的新想法和技术。它甚至可能对硬件设计产生影响，使其适合横向扩展。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored multi-processing systems and the various techniques
    that can be used to share a state among a number of processes. The following topics
    were covered in this chapter:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了多进程系统以及可以用于在多个进程之间共享状态的各种技术。本章涵盖了以下主题：
- en: We introduced the POSIX APIs used for process execution. We explained how the
    `fork` API and `exec*` functions work.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了用于进程执行的POSIX API。我们解释了`fork` API和`exec*`函数的工作原理。
- en: We explained the steps that a kernel takes to execute a process.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了内核执行进程所采取的步骤。
- en: We discussed the ways that a state can be shared among a number of processes.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了状态如何在多个进程之间共享的方法。
- en: We introduced the pull-based and push-based techniques as the two top-level
    categories for all other available techniques.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们介绍了基于拉取和基于推送的技术作为所有其他可用技术的两个顶级类别。
- en: Shared memory and shared files on a filesystem are among common techniques to
    share a state in a pull-based manner.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统上的共享内存和共享文件是常见的基于拉取方式共享状态的技术。
- en: We explained the differences and similarities of multithreading and multi-processing
    deployments and the concepts of vertical and horizontal scaling in a distributed
    software system.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们解释了多线程和多进程部署之间的差异和相似之处，以及分布式软件系统中的垂直和水平扩展的概念。
- en: In the next chapter, we are going to talk about concurrency in single-host multi-processing
    environments. It will consist of discussions about concurrency issues and the
    ways to synchronize a number of processes in order to protect a shared resource.
    The topics are very similar to the ones you encountered in *Chapter 16*, *Thread
    Synchronization*, but their focus is on the processes rather than the threads.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论单主机多进程环境中的并发问题。这包括对并发问题的讨论以及同步多个进程以保护共享资源的方法。这些主题与你在*第16章*，*线程同步*中遇到的主题非常相似，但它们的焦点在于进程而不是线程。
