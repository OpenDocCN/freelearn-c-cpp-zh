- en: Creating Objects with the Prototype Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原型模式创建对象
- en: We saw in the last chapter how using a Dynamic Factory can help us decouple
    our high-level modules, such as the `M5StageManager` or `M5ObjectManager` from
    the implementation details of our derived `M5Stage` or `M5Component` classes.
    We did this by pushing those dependencies into derived builder classes that would
    be used by a Dynamic Factory. This allowed us the freedom to change our derived
    stage and component classes without needing to modify our higher level modules.
    C++ template classes made using the Dynamic Factory very easy, since we were not
    required to create a derived class builder for every stage and component.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何使用动态工厂帮助我们解耦高级模块，例如 `M5StageManager` 或 `M5ObjectManager`，以及我们派生出的
    `M5Stage` 或 `M5Component` 类的实现细节。我们通过将这些依赖项推入将被动态工厂使用的派生构建器类中来实现这一点。这使我们能够在不修改高级模块的情况下自由地更改派生的阶段和组件类。由于我们不需要为每个阶段和组件创建派生类构建器，C++
    模板类使得使用动态工厂变得非常容易。
- en: However, we are required to create a builder for each `M5Object` type we want,
    since they will contain a set of components that are unique to each object. Unfortunately,
    these builders may require frequent changes as we playtest, balance, and modify
    our game design. Each time these builders change, the game will be need to be
    recompiled.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须为每个我们想要的 `M5Object` 类型创建一个构建器，因为它们将包含一组每个对象独特的组件。不幸的是，这些构建器可能需要频繁更改，因为我们进行游戏测试、平衡和修改游戏设计。每次这些构建器更改时，游戏都需要重新编译。
- en: The goal would be to have our game object types be completely defined in a file.
    This would give the game designer the ability to test, tweak, and balance the
    game without needing to touch C++ code or ever recompile. Of course, all of this
    could be done in a level editor tool, which could also be given to players, allowing
    them to create additional game content.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是让我们的游戏对象类型完全在文件中定义。这将使游戏设计师能够在不接触 C++ 代码或重新编译的情况下测试、调整和平衡游戏。当然，所有这些都可以在关卡编辑器工具中完成，这个工具也可以提供给玩家，让他们能够创建额外的游戏内容。
- en: In this chapter, we will explore the Prototype pattern and how it can help us
    define objects completely within a text file. We will do this by first looking
    at a simple example of the pattern, then looking at how the Mach5 Engine, and
    the `M5ObjectManager` specifically, makes use of this pattern to read game object
    definitions from a file. Along the way, we will look at some language features
    of C++ that will help us write better, safer code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨原型模式以及它如何帮助我们完全在文本文件中定义对象。我们将首先查看该模式的一个简单示例，然后查看 Mach5 引擎以及 `M5ObjectManager`
    如何具体使用该模式从文件中读取游戏对象定义。在这个过程中，我们将查看一些有助于我们编写更好、更安全代码的 C++ 语言特性。
- en: Your objectives
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的目标
- en: 'Here is an outline of the topics we will cover and your tasks for this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将在本章中涵盖的主题以及你的任务概述：
- en: Learn the trouble with using a factory for game objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用工厂为游戏对象带来的麻烦
- en: Implement the Prototype pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 Prototype 模式
- en: Learn how the Mach5 engine uses the Prototype pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 Mach5 引擎如何使用原型模式
- en: Implement components within the Mach5 Engine
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Mach5 引擎中实现组件
- en: Learn how to define objects completely in a file
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在文件中完全定义对象
- en: The trouble with using a factory for game objects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工厂为游戏对象带来的麻烦
- en: 'In [Chapter 5](part0096.html#2RHM00-04600e4b10ea45a2839ef4fc3675aeb7), *Decoupling
    Code via the Factory Method Pattern* we learned how to use a Dynamic Factory to
    decouple our stages, components, and objects from higher level modules. We did
    this by placing the dependencies of each derived class into a separate builder
    class instead of a high-level module. Let''s look at an example of creating a
    derived type stage builder:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0096.html#2RHM00-04600e4b10ea45a2839ef4fc3675aeb7)，“通过工厂方法模式解耦代码”中，我们学习了如何使用动态工厂来解耦我们的阶段、组件和对象与高级模块。我们通过将每个派生类的依赖项放入一个单独的构建器类中而不是高级模块中来实现这一点。让我们看看创建派生类型阶段构建器的例子：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The reason we did this is so that changes to the `SplashStage` class only affect
    this file as opposed to the `M5StageManager`, for example. This means any changes
    to derived stage or stage builder classes cannot break other code, because the
    other code will only be using an `M5Stage` pointer. Changes to this class could
    still break other code, particularly if this stage was removed from the game altogether.
    However, by minimizing dependencies, we reduce the chances that other code will
    need to be changed in the future.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做的原因是，`SplashStage`类的更改只会影响这个文件，而不是像`M5StageManager`这样的文件。这意味着对派生阶段或阶段构建器类的任何更改都不会破坏其他代码，因为其他代码只会使用`M5Stage`指针。对这个类的更改仍然可能破坏其他代码，尤其是如果这个阶段完全从游戏中移除。然而，通过最小化依赖关系，我们减少了未来需要更改其他代码的可能性。
- en: 'In the Mach5 Engine, the `M5Stage` derived classes only need a default constructor.
    This is by design to keep the builder classes as simple as possible. Each stage
    class will read its own required data from a file. The logic for which file to
    read is written into the constructor. The same simple default constructor design
    is used in the `M5Component` derived classes as well. What this means is that
    instead of needing to create a builder class for each stage or component, we can
    instead use the power of C++ templates:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mach5引擎中，`M5Stage`派生类只需要一个默认构造函数。这是为了尽可能简化构建器类。每个阶段类将从文件中读取其所需的数据。读取哪个文件的逻辑被写入构造函数中。同样简单的默认构造函数设计也用于`M5Component`派生类。这意味着我们不需要为每个阶段或组件创建构建器类，而是可以使用C++模板的力量：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By using C++ templates, we can reduce the number of small classes that need
    to be manually created while still gaining the decoupling benefits of the factory.
    Of course, it is always possible that a few stages or components will need more
    complex constructors or builder classes. In that case, we can easily create the
    required classes when the need arises. Unfortunately, we don't get the option
    of using templates with our object types.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用C++模板，我们可以减少需要手动创建的小类数量，同时仍然获得工厂的解耦优势。当然，总有可能一些阶段或组件需要更复杂的构造函数或构建器类。在这种情况下，当需要时，我们可以轻松地创建所需的类。不幸的是，我们无法选择在对象类型上使用模板。
- en: Using builders with objects
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构建器与对象一起使用
- en: 'Our game objects are mostly just collections of components. Each object type
    will have different components and component data based on the decisions of the
    designer. As the development progresses, those collections are likely to change.
    Remember, even though each individual component has a builder in the factory,
    the object will need to somehow instantiate the separate components. Let''s look
    at shortened examples of using builders for the `Player` and `Raider` objects:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏对象大多是组件的集合。每个对象类型将根据设计师的决定拥有不同的组件和组件数据。随着开发的进行，这些集合很可能会发生变化。记住，尽管每个单独的组件在工厂中都有一个构建器，但对象需要以某种方式实例化这些单独的组件。让我们看看使用构建器为`Player`和`Raider`对象创建简化的示例：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In these two simple examples, we can see why each object builder needs to be
    different. Each specific object type will have a unique set of components. These
    examples only use two components each, but we haven't considered our physics colliders,
    any weapon components, or additional behaviors. Even in these short examples,
    both object types use a `GfxComponent` but the differences in data, such as texture,
    mean that we need different code. Since there is only one object class, as opposed
    to a hierarchy of derived classes, there is no way to let the object manage the
    creation of the necessary components.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个简单的示例中，我们可以看到为什么每个对象构建器需要不同。每个特定的对象类型将有一组独特的组件。这些示例每个只使用两个组件，但我们还没有考虑我们的物理碰撞器、任何武器组件或额外的行为。即使在这些简短的示例中，这两种对象类型都使用了`GfxComponent`，但由于数据（如纹理）的不同，我们需要不同的代码。由于只有一个对象类，而不是派生类层次结构，因此无法让对象管理必要组件的创建。
- en: To deal with this, we will either need a builder class for each object type
    or one object builder with a `switch` statement and a case for each object type.
    The problem with both solutions is that the list of components and the data for
    each component is likely to change often. Now, instead of being worried about
    high-level modules and dependencies, we have two new problems to be worried about.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可能需要为每个对象类型提供一个构建器类，或者提供一个具有`switch`语句和每个对象类型案例的单个对象构建器。这两种解决方案的问题在于组件列表和每个组件的数据很可能会经常变化。现在，我们不再担心高级模块和依赖关系，而是有两个新的问题需要担心。
- en: The first problem is constant, and possibly long, compile times. We already
    know that as development continues, the game design will change. This could mean
    not only changing components, but also changing values inside those components.
    At some point, especially toward the end of development, the game may be complete,
    but not quite balanced. During this phase, game objects and the code responsible
    for them will be constantly tweaked. Changes in health, damage, speed, and other
    attributes could be changed frequently causing the code to be recompiled.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是编译时间恒定且可能很长。我们已经知道，随着开发工作的继续，游戏设计将会发生变化。这可能意味着不仅需要更改组件，还需要更改这些组件内的值。在某个阶段，尤其是在开发后期，游戏可能已经完成，但并不完全平衡。在这个阶段，游戏对象及其相应的代码将不断进行调整。健康、伤害、速度和其他属性的更改可能会频繁发生，导致代码需要重新编译。
- en: There are a lot of factors that can affect how long it takes to compile a project.
    In the best-case scenario, we would only change one file, and recompiling could
    be very fast. However, even a short build time such as 10 seconds can get annoying
    if the only thing that changed is a speed value from 10 to 11\. Something as simple
    as balancing a single unit can take all day, and then still need additional tweaks
    as other units get balanced. Our goal here is to make modifying the object and
    seeing the results of the modification as fast as possible.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 影响项目编译时间长短的因素有很多。在最佳情况下，我们可能只需更改一个文件，重新编译的速度会非常快。然而，即使只有从10到11的速度值这样的微小变化，如果唯一改变的就是这一点，那么10秒的编译时间也可能变得令人烦恼。平衡单个单位这样简单的事情可能需要一整天的时间，而且在其他单位平衡后，还需要进行额外的调整。我们的目标是将修改对象和查看修改结果的速度尽可能快。
- en: The second problem that comes up is related to who is responsible for making
    these balance changes. One scenario is that the programmer is responsible because
    all balance changes are code changes. This is a bad situation because, as we already
    mentioned, balancing can take a long time, and now both the designer and the programmer
    are involved. The designer may not be able to properly explain the desired result
    to the programmer, so they must sit together tweaking and compiling, repeatedly.
    It would be better if the designer was free to balance, and the programmer was
    free to fix bugs or optimize code where needed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是关于谁负责进行这些平衡更改。一种情况是程序员负责，因为所有的平衡更改都是代码更改。这是一个不好的情况，因为我们已经提到，平衡可能需要很长时间，现在设计师和程序员都参与了进来。设计师可能无法正确地向程序员解释期望的结果，因此他们必须坐在一起调整和编译，反复进行。如果设计师可以自由地进行平衡，而程序员可以自由地修复错误或优化所需的代码，那就更好了。
- en: The other scenario is that the designer is responsible for making these balance
    changes to the code. The problem here is that the designer may not be as familiar
    with the engine, or with the programming language. It is very possible that the
    designer doesn't have programming experience at all, so they would not be familiar
    with IDEs or version control systems. The chance of introducing bugs or breaking
    the project could be very high.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况是设计师负责对代码进行平衡更改。这里的问题是设计师可能对引擎或编程语言不太熟悉。完全有可能设计师根本没有任何编程经验，因此他们可能不熟悉集成开发环境（IDE）或版本控制系统。引入错误或破坏项目的可能性非常高。
- en: Solution - reading from files
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案 - 从文件读取
- en: Our solution to both problems is to move all hard-coded values into text or
    binary files that will be read by the engine at runtime. Since we are using a
    component-based system in our game, this means being able to define which components
    belong to an object in the file as well. The benefit of this approach is that
    these files could be created with a level editor or some other content creation
    tool by a designer. For now, we won't focus on how these files get created, but
    instead on how they are read into our engine and how we can use them in place
    of an object builder class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决这两个问题的方案是将所有硬编码的值移动到文本或二进制文件中，这些文件将在运行时由引擎读取。由于我们在游戏中使用的是基于组件的系统，这意味着我们可以在文件中定义哪些组件属于一个对象。这种方法的优点是，这些文件可以通过关卡编辑器或其他内容创建工具由设计师创建。目前，我们不会关注这些文件是如何创建的，而是关注它们是如何被读取到我们的引擎中，以及我们如何可以使用它们来替代对象构建器类。
- en: Now that we have decided to define our objects in files, we need to think about
    when they will be read by our engine. There are a few different solutions to our
    problem. The first solution is to simply have our builder read a file every time
    we need a new Raider, Bullet, or Asteroid. This is a common first thought, but
    is a very bad idea. Reading files from the hard disk is very slow compared to
    accessing data already in RAM. Depending on the factors, it can be anywhere from
    10,000 to 50,000 times slower or more. This is like a normal 5 minute drive to
    the store taking 173 days, 14 hours, and 40 minutes. If you started your drive
    on January 1st, you would arrive at the store on June 21st.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经决定在文件中定义我们的对象，我们就需要考虑我们的引擎何时会读取它们。针对我们的问题有几个不同的解决方案。第一个解决方案是每次我们需要一个新的Raider、Bullet或Asteroid时，让我们的构建器简单地读取一个文件。这是一个常见的初步想法，但这是一个非常糟糕的想法。与访问已经存在于RAM中的数据相比，从硬盘读取文件非常慢。根据因素的不同，它可能慢10,000到50,000倍或更多。这就像一个正常的5分钟车程需要173天14小时40分钟。如果你从1月1日开始驾驶，你会在6月21日到达商店。
- en: This doesn't mean that we should never read files from the hard disk. It just
    means that we need to be more strategic about it. Using this solution would mean
    we could be reading the exact same file many times during the same frame. This
    would be like taking that half-year trip to the store to buy eggs, going home,
    then immediately going back to the store to buy milk. Instead of reading the same
    file many times we should read it once and store the data into RAM. Since it is
    so slow, we should avoid reading and writing files during gameplay and instead
    load as much from our files during load time as we can.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们永远不应该从硬盘读取文件。这仅仅意味着我们需要更加策略性地处理它。使用这个解决方案意味着我们可以在同一帧中多次读取完全相同的文件。这就像进行半年的旅行去商店买鸡蛋，回家后立即又回到商店买牛奶。我们不应该多次读取相同的文件，而应该只读取一次并将数据存储到RAM中。由于这个过程非常慢，我们应该避免在游戏过程中读取和写入文件，而应该尽可能在加载时间从文件中加载更多内容。
- en: In large scale games, such as *Rockstar's Grand Theft Auto 3*, there is too
    much data to keep in RAM all at once. A game like this will be constantly reading
    data from files that aren't currently in memory, and releasing resources that
    are no longer in use. This is done by reading files on separate threads so the
    main gameplay isn't paused or slowed down. There is a lot of work involved in
    this file streaming process, including making sure that key gameplay elements
    are in memory when the player needs them so gameplay isn't affected. However,
    even games that stream data like this don't waste time reading files repeatedly
    once they are in memory.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模游戏中，例如*Rockstar的《侠盗猎车手3》*，需要一次性保存在RAM中的数据太多。这类游戏会不断从不在内存中的文件读取数据，并释放不再使用的资源。这是通过在单独的线程上读取文件来实现的，这样就不会暂停或减慢主游戏玩法。这个文件流过程涉及大量工作，包括确保当玩家需要时关键游戏元素已经在内存中，以免影响游戏玩法。然而，即使像这样流式传输数据的游戏，一旦数据在内存中，也不会浪费时间重复读取文件。
- en: We won't be worrying about threads for now. So, a more common solution for us
    would be to read the file once during a load screen to create the object types
    we need, then simply to copy these objects whenever we need a new instance of
    them. This will allow us to focus on the pattern, as well as solve key issues
    related to this problem, without worrying about the difficulties involved in multithreaded
    architecture.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不会担心线程。因此，对我们来说，一个更常见的解决方案是在加载屏幕期间读取文件一次，创建我们需要的对象类型，然后只需在需要新实例时复制这些对象。这将使我们能够专注于模式，同时解决与此问题相关的关键问题，而无需担心多线程架构的困难。
- en: Even without using threads, we still have a problem. How do we copy the object
    that contains components without knowing the types? Typically, when creating new
    objects, we need the new keyword, which means we also need a constructor to call.
    Of course, we have an `enum` for the type, which means we could use a switch statement
    and call the correct copy constructor. However, we already know that switch statements
    can be difficult to maintain and should be avoided.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不使用线程，我们仍然有问题。我们不知道组件的类型，如何复制包含组件的对象？通常，在创建新对象时，我们需要new关键字，这意味着我们还需要调用构造函数。当然，我们有一个用于类型的`enum`，这意味着我们可以使用switch语句并调用正确的复制构造函数。然而，我们已经知道switch语句可能很难维护，应该避免使用。
- en: The component factory will create a new component of the correct type, but we
    would still need to write a copy function that can copy the data once it has been
    created. It would be nice if we had a function that would construct and copy the
    data, based on the type of object it is. We need a constructor that works like
    a virtual function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 组件工厂将创建正确类型的新组件，但我们仍然需要编写一个复制函数，以便在创建后能够复制数据。如果有一个函数可以根据对象的类型构建和复制数据，那就太好了。我们需要一个像虚拟函数一样工作的构造函数。
- en: The Prototype pattern explained
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型模式解释
- en: The Prototype pattern gives us a way to copy a class without knowing the actual
    type of that class. This is often referred to as a virtual constructor because
    we can use it to create and copy a derived class while only using a base class
    pointer or reference. This pattern is most powerful when used with object hierarchies,
    but it doesn't only need to be used with virtual functions. Another purpose of
    the Prototype pattern is simply to create a prototypical (or archetypical) instance
    of an object and to use that to copy from.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式为我们提供了一种复制类的方法，而无需知道该类的实际类型。这通常被称为虚拟构造函数，因为我们可以使用它来创建和复制派生类，同时只使用基类指针或引用。当与对象层次结构一起使用时，这种模式最为强大，但它不仅需要与虚拟函数一起使用。原型模式的另一个目的是简单地创建一个原型（或原型）实例的对象，并使用它进行复制。
- en: 'Imagine that we are creating a level editor. In the middle of the tool we would
    have the map of the level. Here we can place tiles, power-ups, enemies, and players.
    Along the side of the map, we would have all the objects and tiles used in our
    game that can be placed on the map. This can be seen in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在创建一个关卡编辑器。在工具的中间，我们会有一张关卡地图。在这里，我们可以放置瓦片、升级、敌人和玩家。在地图的旁边，我们会有一系列用于我们游戏中的对象和瓦片，这些都可以放置在地图上。以下截图可以展示这一点：
- en: '![](img/00043.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00043.jpeg)'
- en: Figure 6 1 - Example of a Simple Level Editor
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1 - 简单关卡编辑器的示例
- en: Since we are striving for clean code, we have a clear separation between the
    part of the code that handles drawing, the part of the code that handles clicking
    and manipulating the objects on the side, and the part of the code that defines
    our specific object type. However, when we click and drag an object from the side,
    we would make a new instance of the object that was clicked and would draw it
    at the mouse location, and eventually on the map where the user places it. Based
    on the Dependency Inversion Principle, we know we don't want our high-level modules
    depending on our low-level objects. Instead, they should both depend on abstractions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们追求代码的整洁，我们在处理绘图、处理点击和操作侧边对象以及定义我们特定对象类型的代码部分之间有明确的分离。然而，当我们从侧边点击并拖动一个对象时，我们会创建一个新实例的对象，并在鼠标位置绘制它，最终在用户放置它的地图上绘制。根据依赖倒置原则，我们知道我们不希望我们的高级模块依赖于我们的低级对象。相反，它们都应该依赖于抽象。
- en: Prototype versus Archetype
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 原型与原型的对比
- en: Before we learn more about this pattern we should talk a little about word choice.
    In the Mach5 Engine, the files we will be reading and creating, as well as the
    enumerations we will be using, are called archetypes instead of prototypes. An
    Archetype is a perfect, unchanging, ideal example of a thing. A prototype is typically
    an early, usually unrefined version of something that later versions can depart
    from. While both words could be correct, the authors use the word Archetype to
    refer to the object definitions in the files, even though the pattern is called
    the Prototype pattern.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更深入地了解这个模式之前，我们应该稍微谈谈一下词汇选择。在Mach5引擎中，我们将读取和创建的文件以及我们将使用的枚举被称为原型，而不是原型。原型是一个完美、不变、理想的事物的例子。原型通常是某个东西的早期版本，通常是未完善的，后来的版本可以偏离。虽然这两个词都可以正确使用，但作者使用“原型”一词来指代文件中的对象定义，尽管这个模式被称为原型模式。
- en: The virtual constructor
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟构造函数
- en: 'The Prototype pattern is simple. It involves giving an object for which you
    might want to copy a `Clone` method, and letting the object know about the details
    of how to perform the clone. The actual name of the method isn''t important. `Clone`
    is just one common example. This is most powerful when used with object hierarchies
    in which you want to copy an object, but don''t know the type of derived object
    you might be holding. Simply add a `Clone` method to the interface of a hierarchy
    and have the derived classes each implement the method. Let''s look at a simple
    example to start off:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式很简单。它涉及提供一个对象，你可能想要复制它的`Clone`方法，并让对象了解如何执行复制。实际的方法名称并不重要。"Clone"只是其中一个常见的例子。当与对象层次结构一起使用时，这最有用，其中你想要复制一个对象，但不知道你持有的派生对象的类型。只需在层次结构的接口中添加一个`Clone`方法，并让派生类各自实现该方法。让我们从一个简单的例子开始：
- en: '![](img/00044.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00044.jpeg)'
- en: 'In the following code, we have our interface object, `Shape`. We will just
    be talking about simple shapes in this example. Since this class will be used
    as an interface, we must mark the destructor as virtual so the correct destructor
    will get called when derived classes are deleted. Next, we have two pure virtual
    methods. The `Draw` method could be any action that we need virtual behavior with.
    In this simple case, we will just be using printed statements instead of drawing
    shapes on the screen. The `Clone` method will be our virtual constructor. This
    method will know how to copy itself and return a new instance:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们有我们的接口对象`Shape`。在这个例子中，我们只讨论简单的形状。由于这个类将用作接口，我们必须将析构函数标记为虚拟的，以便在删除派生类时调用正确的析构函数。接下来，我们有两个纯虚函数。`Draw`方法可以是任何我们需要虚拟行为的操作。在这个简单的情况下，我们只是使用打印语句而不是在屏幕上绘制形状。`Clone`方法将是我们的虚拟构造函数。这个方法将知道如何复制自身并返回一个新实例：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s look at the derived class examples:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看派生类的示例：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Of course, our derived classes know how to draw themselves. To keep things
    simple, the `Draw` methods are just printing to the console. The important part
    here is that each `Draw` method has a different behavior; in this case, a hardcoded
    string to print. The `Clone` methods are where the real magic happens--each one
    returns a new instance of itself. Specifically, they are calling their own copy
    constructors. This will allow the client to hold a pointer to any `Shape`, and
    get a copy of the correct derived type without knowing or caring which constructor
    to call. Let''s look at an example of this using code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的派生类知道如何绘制自身。为了保持简单，`Draw`方法只是打印到控制台。这里的重要部分是每个`Draw`方法都有不同的行为；在这种情况下，打印一个硬编码的字符串。`Clone`方法才是真正的魔法所在--每个方法都返回自身的一个新实例。具体来说，它们正在调用自己的拷贝构造函数。这将允许客户端持有任何`Shape`的指针，并获得正确的派生类型的副本，而无需知道或关心要调用哪个构造函数。让我们通过代码示例来看看这一点：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first few lines are simply initializing the random number generator and
    the array of shapes. In the array, you can see that we create a new instance of
    a `Circle`, `Square`, and `Triangle`. These will be our prototype `Shapes` to
    clone.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行只是初始化随机数生成器和形状数组。在数组中，你可以看到我们创建了一个新的`Circle`、`Square`和`Triangle`实例。这些将成为我们要克隆的原型`Shapes`。
- en: The next section is a loop to show the `Clone` method at work. We use a random
    index into the array and clone an object. Since it is random, we can't know which
    `Shape` will be cloned. This is simulating a random click by the user. Once we
    clone the `Shape`, we are free to call `Draw` or any other interface method we
    need. At the end of the loop, we delete the cloned `Shape` but, of course, that
    doesn't delete our prototype `Shape` from the array because it was a copy of the
    object. After the loop, we go through our prototype array and delete each of those
    shapes as well.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是一个循环，用于展示`Clone`方法的工作。我们使用数组的随机索引来克隆一个对象。由于它是随机的，我们无法知道哪个`Shape`将被克隆。这模拟了用户的随机点击。一旦我们克隆了`Shape`，我们就可以自由地调用`Draw`或其他任何接口方法。循环结束时，我们删除了克隆的`Shape`，但当然，这不会删除数组中的原型`Shape`，因为它是对象的一个副本。循环之后，我们遍历原型数组，并删除这些形状。
- en: 'The following is the output for the preceding code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出是前面代码的结果：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The problem with constructors
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数的问题
- en: Now that we have seen a little about virtual constructors and the Prototype
    pattern, let's look at exactly what problem we are trying to solve.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对虚拟构造函数和原型模式有了一些了解，让我们看看我们正在试图解决的具体问题。
- en: To understand the problem of construction, we first need to understand the difference
    between a class and an object of that class. Classes are what the programmer creates.
    They are the code template or recipe that the program uses to create objects.
    In C++, we cannot create classes at runtime. We don't have a way to introduce
    new code while the program is running.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解构造问题，我们首先需要理解类和该类的对象之间的区别。类是程序员创建的。它们是程序使用的代码模板或配方，用于创建对象。在C++中，我们无法在运行时创建类。我们没有在程序运行时引入新代码的方法。
- en: This is because C++ is a statically typed language. This means that the language
    tries to prevent operations if they can't be performed on that type at compile
    time. For example, we can't divide a float by a `void*` because the C++ compiler
    checks a compile time if the operation makes sense, and will issue an error if
    it doesn't.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为C++是一种静态类型语言。这意味着如果编译时无法在该类型上执行操作，则语言会尝试防止这些操作。例如，我们不能将一个浮点数除以一个`void*`，因为C++编译器会在编译时检查操作是否有意义，如果无意义，则会报错。
- en: 'This static typing in C++ is why we are forced to declare a type for every
    variable. It is also why we are required to specify the constructor in a case
    like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的这种静态类型是为什么我们必须为每个变量声明一个类型。这也是为什么在这种情况下我们需要指定构造函数的原因：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this case, the compiler must know the class that we are trying to create.
    Unfortunately, in C++, classes do not have first class status. That means we can''t
    pass a class as an argument to a function or use a class as a return value. We
    can''t copy a class, save it in a variable, or create one at runtime. Some languages
    do have these features. Here is an example of what you could do if classes had
    first class status in C++:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器必须知道我们试图创建的类。不幸的是，在C++中，类没有一等公民地位。这意味着我们不能将类作为函数的参数传递或将其用作返回值。我们不能复制一个类，将其保存在变量中，或在运行时创建它。一些语言确实具有这些功能。以下是在C++中如果类具有一等公民地位时你可以做的事情的例子：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While this might be useful, we would be trading some type safety for flexibility.
    The static type checking that the C++ compiler performs has the chance to catch
    problems before they become bugs at runtime. This is a good thing. We should enjoy
    the type checking C++ provides. We should also recognize when it has an impact
    on our code flexibility.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能很有用，但我们将会以一些类型安全性为代价来换取灵活性。C++编译器执行的静态类型检查有机会在问题成为运行时错误之前捕获它们。这是好事。我们应该享受C++提供的类型检查。我们也应该认识到它对我们的代码灵活性有何影响。
- en: Even though C++ is a statically typed language, we have ways of getting around
    this problem. One such way was with the factories that we created in the last
    chapter. We were forced to write the factories ourselves, but we still can choose
    which class gets created at runtime, while getting the benefits of static typing
    for all other classes and types. Factories are just one way we can avoid the rigidity
    of classes not having first class status. The virtual constructor is another way.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C++是一种静态类型语言，但我们有方法绕过这个问题。其中一种方法是我们在上章中创建的工厂。我们被迫自己编写工厂，但我们仍然可以选择在运行时创建哪个类，同时获得所有其他类和类型的静态类型的好处。工厂只是我们避免类没有一等公民地位刚性的方法之一。虚拟构造函数是另一种方法。
- en: The benefits of a virtual constructor
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟构造函数的好处
- en: Using a virtual constructor can be very powerful. The biggest benefit is that
    we can now treat classes as if they had first class status. We can make copies
    of an object without knowing the exact type of the object. We can use the Prototype
    pattern in our level editor example, but we could also use it in our game. Anytime
    we need to make a copy without truly knowing the type, we can use this pattern.
    As we said before, C++ is a statically typed language, meaning the compiler will
    make sure we are using the correct types at compile time. This static type checking
    helps us write safer code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟构造函数可以非常强大。最大的好处是现在我们可以将类视为一等公民。我们可以复制一个对象而无需知道其确切类型。我们可以在我们的级别编辑器示例中使用原型模式，也可以在我们的游戏中使用它。任何时候我们需要复制而不知道确切类型时，我们都可以使用这个模式。正如我们之前所说，C++是一种静态类型语言，这意味着编译器将确保我们在编译时使用正确的类型。这种静态类型检查帮助我们编写更安全的代码。
- en: By using Dynamic Factories and virtual constructors, we are bypassing this type
    checking a little. The compiler is still doing the type checking on the pointers
    we are working with, but we are choosing our derived class at runtime. This has
    the chance to lead to bugs that are difficult to find if we somehow mix up the
    types we are cloning. That doesn't mean we shouldn't use the patterns; it is just
    good to understand that we are giving up a little safety for flexibility.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用动态工厂和虚拟构造函数，我们绕过了这种类型检查。编译器仍然在我们处理的指针上进行类型检查，但我们是在运行时选择派生类。这可能导致我们如果在克隆时混淆了类型，会引发难以找到的bug。这并不意味着我们不应该使用这些模式；只是了解我们在灵活性上做出了一些牺牲是好的。
- en: We don't need to know the type
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们不需要知道类型
- en: As we said, the biggest benefit of using the Prototype pattern is that we can
    make copies without knowing the type. This means we can make a copy of a function
    parameter or function return type without caring about the derived class involved.
    This also means that we can share a pointer with another class or method and we
    don't need to care if the type is modified.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说的，使用原型模式的最大好处之一是我们可以在不知道类型的情况下创建副本。这意味着我们可以在不关心涉及到的派生类的情况下创建函数参数或函数返回类型的副本。这也意味着我们可以与另一个类或方法共享指针，我们不需要关心类型是否被修改。
- en: 'In the following example, we have a `SpawnShape` class with the ability to
    spawn a specific type of shape. By using the Prototype pattern, the class doesn''t
    need to care what type it is spawning. The constructor takes a pointer to some
    shape and then it just needs to call the `Clone` method. If the base class pointer
    is pointing to a `Circle`, then a circle will be created. However, if we have
    a pointer to a `Triangle`, then a triangle will be created. Here is an example
    that shows the Prototype pattern in action:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们有一个具有生成特定类型形状能力的`SpawnShape`类。通过使用原型模式，该类不需要关心它正在生成什么类型。构造函数接受一个指向某个形状的指针，然后只需要调用`Clone`方法。如果基类指针指向一个`Circle`，则将创建一个圆。然而，如果我们有一个指向`Triangle`的指针，则将创建一个三角形。以下是一个展示原型模式如何工作的示例：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our `SpawnShape` class doesn''t care if it is spawning a `Circle`, `Square`,
    or `Triangle`, or any new shape we might create later. It can make copies without
    knowing the real type of the shape. If we add a public `SetShape` method, we could
    even change the type that spawns at runtime. Compare this with a more rigid example
    that can only spawn `Circles`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SpawnShape`类不关心它是在生成`Circle`、`Square`还是`Triangle`，或者我们以后可能创建的任何新形状。它可以复制形状而不需要知道形状的真实类型。如果我们添加一个公共的`SetShape`方法，我们甚至可以在运行时更改生成的类型。与只能生成`Circles`的更严格示例相比：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the second example (not using the Prototype pattern) we are forced to use
    the copy constructor of the derived class, in this case the `Circle`. If we want
    to spawn a `Square` or a `Triangle`, we would need to create a `SquareSpawner`
    or `TriangleSpawner`. That is a lot of repeated code. It could get worse as we
    add even more shapes. By using the Prototype pattern, we can reduce the number
    of classes we need.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子（不使用原型模式）中，我们被迫使用派生类的复制构造函数，在这种情况下是`Circle`。如果我们想生成`Square`或`Triangle`，我们需要创建一个`SquareSpawner`或`TriangleSpawner`。这会产生大量的重复代码。如果我们添加更多的形状，情况可能会变得更糟。通过使用原型模式，我们可以减少所需的类数量。
- en: No need to subclass
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无需子类化
- en: The reduction in classes is another big benefit of using a virtual constructor.
    In the case above, we only needed a single `SpawnShape` instead of duplicating
    our spawn class or making derived versions. Consider our factory builder classes
    that we saw before. We were forced to create an abstract base class and create
    derived classes for every new `M5Component` and `M5Stage` that we used. C++ templates
    helped us autogenerate that code, but the code still exists.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类的减少是使用虚拟构造函数的另一个重大好处。在上面的例子中，我们只需要一个`SpawnShape`，而不是复制我们的生成类或创建派生版本。考虑我们之前看到的工厂构建类。我们被迫为每个新的`M5Component`和`M5Stage`创建一个抽象基类和派生类。C++模板帮助我们自动生成代码，但代码仍然存在。
- en: By using a virtual constructor, we don't need derived builder classes for every
    `M5Stage`, `M5Component`, `Shape`, or other inheritance hierarchy. We can let
    the objects copy themselves. Does that mean we should remove our factories and
    always use the Prototype pattern? It depends.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用虚拟构造函数，我们不需要为每个`M5Stage`、`M5Component`、`Shape`或其他继承层次结构创建派生构建类。我们可以让对象自己复制。这意味着我们应该移除我们的工厂并始终使用原型模式吗？这取决于。
- en: Remember that with the Prototype pattern, we must first instantiate an object
    before it can be cloned. This is fine with shapes or components because these
    types are very small. However, the `M5Stage` derived classes may be very big and
    they also may cause side effects. This means that the constructor of a stage may
    add objects to the `M5ObjectManager` or may load textures or another large resource.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在使用原型模式时，我们必须首先实例化一个对象，然后才能进行克隆。这对于形状或组件来说是可以的，因为这些类型非常小。然而，`M5Stage` 派生类可能非常大，它们也可能引起副作用。这意味着阶段的构造函数可能会向
    `M5ObjectManager` 添加对象，或者加载纹理或其他大型资源。
- en: Since using C++ templates made creating our builders so easy, we can keep using
    them for stages and components. However, we want to avoid making builders for
    the `M5Object` because those builders are very likely to change during development.
    By using virtual constructors and creating prototypes (or archetypes) that can
    clone themselves, the rest of our code will not be affected by changes to our
    types.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用 C++ 模板使得创建我们的构建器变得如此简单，我们可以继续在阶段和组件中使用它们。然而，我们希望避免为 `M5Object` 创建构建器，因为这些构建器在开发过程中很可能发生变化。通过使用虚拟构造函数并创建可以克隆自己的原型（或原型），我们的其余代码将不会受到类型更改的影响。
- en: It's easy to make exact copies
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作精确副本很容易
- en: Here, the concept of a prototype doesn't need to be used with virtual functions.
    We may have a group of objects, for example, easy, hard, and insane enemies that
    we want to copy. These objects may be the exact same class type, but they could
    have very different values for health, speed, and damage. In this case, we have
    our prototypical example that we want to copy from. Of course, in this case we
    could also just use a copy constructor, but it is possible, as in the case of
    the Mach5 Engine, that the copy constructor doesn't exist.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，原型概念不需要与虚拟函数一起使用。例如，我们可能有一组对象，例如简单、困难和疯狂敌人，我们想要复制。这些对象可能是完全相同的类类型，但它们可能有非常不同的健康、速度和伤害值。在这种情况下，我们有我们想要从中复制的典型示例。当然，在这种情况下，我们也可以简单地使用复制构造函数，但在像
    Mach5 引擎这样的情况下，复制构造函数可能不存在。
- en: Either way, since we don't need to create derived builder classes, we can add
    prototypes at runtime. Take the above example of the easy, hard, and insane enemy
    types. We could have just a single file that defines the health of an easy enemy
    with a value of `50`, for example. Then at runtime we could create a hard enemy
    prototype with a health of `100` and an insane enemy with a health of `200`. We
    could always just double the values of health and damage for each hard and insane
    enemy, or the file could contain the scale factor for the hard and insane versions.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，由于我们不需要创建派生构建器类，我们可以在运行时添加原型。以上面提到的简单、困难和疯狂敌人类型为例。我们可能只有一个文件定义了简单敌人的健康值为
    `50`，例如。然后在运行时，我们可以创建一个健康值为 `100` 的困难敌人原型和一个健康值为 `200` 的疯狂敌人原型。我们总是可以简单地加倍每个困难和疯狂敌人的健康和伤害值，或者文件可以包含困难版本和疯狂版本的缩放因子。
- en: Another example where we might want to modify the data would be if we had an
    enemy base that spawned enemies after a set time (like our `ShapeSpawner` from
    above). In this example, the base might increase the health and damage of the
    object over time. So, the base might initially create enemies with health of `50`,
    but after each spawn, the health is increased by `5`. So, the second enemy has
    a health of `55`. The third enemy has a health of `60`. Since each base has a
    specific instance, each base would be spawning enemies with different health values.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我们可能想要修改数据的例子是，如果我们有一个敌基地在设定时间后生成敌人（就像我们上面的 `ShapeSpawner`）。在这个例子中，基地可能会随着时间的推移增加对象的健康和伤害。因此，基地最初可能会创建健康值为
    `50` 的敌人，但每次生成后，健康值会增加 `5`。所以，第二个敌人的健康值为 `55`。第三个敌人的健康值为 `60`。由于每个基地都有一个特定的实例，每个基地都会生成具有不同健康值的敌人。
- en: The object could also be modified via an in-game level editor. Imagine the benefit
    of play testing a level only to realize that enemies are killed too easily. With
    the Prototype pattern and an in-game level editor, we could pause the game, edit
    attributes of an object type, and continue playing. This method wouldn't require
    programmers, or recompile times. It doesn't even require a game restart. Of course,
    this same effect could also be done with a separate level editor or by just modifying
    the Archetype files and reloading the files at runtime. In these situations, we
    can see that creating copies of a specific instance is very easy and very useful.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对象也可以通过游戏内关卡编辑器进行修改。想象一下，在仅进行游戏测试时意识到敌人太容易被杀死的好处。使用原型模式和游戏内关卡编辑器，我们可以暂停游戏，编辑对象类型的属性，然后继续游戏。这种方法不需要程序员，也不需要重新编译时间。甚至不需要重新启动游戏。当然，同样的效果也可以通过单独的关卡编辑器或仅通过修改原型文件并在运行时重新加载文件来实现。在这些情况下，我们可以看到创建特定实例的副本非常简单且非常有用。
- en: Examples of the clone method in Mach5
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mach5中`clone`方法示例
- en: So far, we have seen simple examples of how the Prototype pattern is implemented.
    If you thought that the examples were easy, you are in luck--it doesn't get much
    harder than that. We also discussed a few ways in which an object instance and
    a virtual constructor can be useful in a game. Now let's look at how the Mach
    5 Engine uses the Prototype pattern in the `M5Component` and `M5Object` classes.
    Since the `M5Object` class uses the `M5Component Clone` method, let's look at
    the components first.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了原型模式的简单实现示例。如果你认为这些示例很简单，那么你很幸运——它不会比这更难。我们还讨论了几种在游戏中使用对象实例和虚拟构造函数的方法。现在让我们看看Mach
    5引擎如何在`M5Component`和`M5Object`类中使用原型模式。由于`M5Object`类使用了`M5Component Clone`方法，让我们先看看组件。
- en: 'In [Chapter 3](part0064.html#1T1400-04600e4b10ea45a2839ef4fc3675aeb7), *Improving
    on the Decorator Pattern with the Component Object Model*, we examined almost
    all the methods and member variables in the `M5Component` class. However, the
    method we didn''t talk about was the `Clone` method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0064.html#1T1400-04600e4b10ea45a2839ef4fc3675aeb7)，“使用组件对象模型改进装饰器模式”中，我们检查了`M5Component`类中的几乎所有方法和成员变量。然而，我们没有讨论的方法是`Clone`方法：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the `M5Component` class implements a pure virtual `Clone` method
    just like we saw above in the `Shape` class. Since the `M5Component` class is
    used only as an abstract base class, we don't want to provide any default behaviors
    for cloning. Cloning only makes sense for derived classes. This part of the component
    was shown again so we can understand what the interface for overloading this method
    should be.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`M5Component`类实现了一个纯虚`Clone`方法，就像我们在上面的`Shape`类中看到的那样。由于`M5Component`类仅用作抽象基类，我们不希望为克隆提供任何默认行为。克隆只对派生类有意义。这部分组件再次展示出来，这样我们就可以理解重载此方法的接口应该是什么。
- en: The Gfx and collider components
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gfx和碰撞组件
- en: Now that we have seen the interface, let's look at two very important components.
    These are important because they allow game objects to interact with two of the
    other core pieces of our engine, graphics and physics.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了接口，让我们看看两个非常重要的组件。这些组件之所以重要，是因为它们允许游戏对象与我们的引擎中的两个其他核心部分进行交互，即图形和物理。
- en: 'The first one we will look at is the `GfxComponent` class. This class allows
    the game object to have a visual representation in the game. It contains the two
    minimum pieces of information to draw an object in the game:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看的是`GfxComponent`类。这个类允许游戏对象在游戏中有一个视觉表示。它包含绘制游戏中物体所需的最基本信息：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The two pieces of information we need to draw an object are which texture to
    draw and which space to draw in. Of course, we need a texture to draw, but the
    draw space may be a bit more confusing. It is just an `enum` letting us know which
    type of graphics projection should be used with the object. For now, it is enough
    to know that the HUD draw space is always on top and isn't affected by camera
    movement or camera zoom. Of course, there could be more data, such as texture
    color and texture coordinates. These could be added in a derived class if we wanted.
    Here we are just showing the basics.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绘制一个物体所需的两条信息是绘制哪种纹理以及绘制在哪个空间中。当然，我们需要一个纹理来绘制，但绘制空间可能有点令人困惑。它只是一个`enum`，告诉我们应该使用哪种图形投影类型与物体一起使用。目前，只需知道HUD绘制空间始终位于顶部，不受相机移动或相机缩放的影响即可。当然，可能还有更多数据，例如纹理颜色和纹理坐标。如果我们想的话，这些可以在派生类中添加。这里我们只是展示基本内容。
- en: 'There are a few functions used to set these values, as well as a `FromFile`
    function that we talked about a little before. The `Update` function doesn''t
    do anything for this component because there is nothing to update. The `Draw`
    function will be called by the graphics engine, making each `M5Component` responsible
    for drawing itself. However, the most important function for this chapter is the
    `Clone`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个函数用于设置这些值，以及之前提到过的 `FromFile` 函数。对于这个组件，`Update` 函数不做任何事情，因为没有需要更新的内容。`Draw`
    函数将由图形引擎调用，使每个 `M5Component` 负责绘制自己。然而，本章最重要的函数仍然是 `Clone`：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this function, we simply create a new `GfxComponent` and copy the relevant
    data from this object to the newly created one. What you don''t see is that in
    the `GfxComponent` constructor, the component type is set by calling the `M5Component`
    component constructor which, of course, also gives this component a unique ID.
    The last thing we do is register this component with the graphics engine depending
    on the draw space. This class automatically unregisters itself when it is destroyed:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们只是创建一个新的 `GfxComponent` 并从该对象复制相关数据到新创建的一个中。你没有看到的是，在 `GfxComponent`
    构造函数中，通过调用 `M5Component` 组件构造函数来设置组件类型，当然，这也给这个组件赋予了一个唯一的 ID。我们最后做的事情是根据绘制空间将这个组件注册到图形引擎中。这个类在销毁时会自动取消注册：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have seen the `GfxComponent`, let''s look at the most basic of
    all physics colliders. The Mach5 Engine `ColliderComponent` is as simple as possible
    for a 2D game. For now, it is only concerned with circle versus circle collisions.
    It could easily be extended to test for rectangle collision as well:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了 `GfxComponent`，让我们来看看所有物理碰撞器中最基本的。Mach5 引擎的 `ColliderComponent` 对于
    2D 游戏来说尽可能简单。目前，它只关注圆形与圆形的碰撞。它很容易扩展以测试矩形碰撞：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This class is a lot like the previous one because it is connected to one of
    the core pieces of the game engine. Just like all components, `FromFile` must
    be overloaded to read component data from an `.ini` file. `Update` must also be
    overloaded but, just like with the `GfxComponent`, this doesn''t do anything in
    this simple version. If the class used oriented bounding boxes, the `Update` function
    could be used to update the corner points of the oriented box. The `TestCollision`
    function is also important. It is called by the **Physics Engine** to test if
    this object is colliding with another object. If it is, the two objects are added
    to a list of colliding pairs that can be resolved later. Again, the most important
    function for this chapter is the `Clone`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与之前的类非常相似，因为它与游戏引擎的核心组件之一相连。就像所有组件一样，`FromFile` 必须被重载以从 `.ini` 文件中读取组件数据。`Update`
    也必须被重载，但就像 `GfxComponent` 一样，在这个简单版本中它并不做任何事情。如果这个类使用了有向边界框，`Update` 函数就可以用来更新有向框的角点。`TestCollision`
    函数也非常重要。它被 **物理引擎** 调用来测试这个对象是否与另一个对象发生碰撞。如果是，这两个对象将被添加到一个可以稍后解决的碰撞对列表中。再次强调，本章最重要的函数是
    `Clone`：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Just like the `GfxComponent`, this component first creates a new version of
    itself, then copies the important information into the new component. Before returning
    the new component, it first registers itself with the physics engine. Since it
    is registered, it must be unregistered when it is destroyed, so we do that in
    the destructor:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `GfxComponent` 一样，这个组件首先创建一个自己的新版本，然后将重要信息复制到新组件中。在返回新组件之前，它首先将自己注册到物理引擎中。由于它已经注册，所以在销毁时必须取消注册，所以我们就在析构函数中这样做：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There are a few things to point out with both classes. First, notice that we
    don't clone the `m_type`, the `m_id`, or the `isDead` variables. This isn't necessary.
    The type is set by the constructor in the `M5Component` base class when we call
    the constructor. The `id` is also set in the base class, but it is important to
    point out that the purpose of the `m_id` is to be unique. It wouldn't serve the
    correct purpose if we also copied the `id`. Instead, we are copying the rest of
    the important data but we recognize that this is a separate component, not just
    an exact copy. For the same reason, we also don't copy the `isDead` variable.
    We are creating a new component that is like the old one, but still a unique component.
    If we copied the `isDead`, this component would be deleted in this frame or the
    next.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个类中，有几个要点需要指出。首先，请注意我们并没有克隆`m_type`、`m_id`或`isDead`变量。这并不是必要的。类型是由`M5Component`基类中的构造函数设置的，当我们调用构造函数时。`id`也是在基类中设置的，但重要的是要指出，`m_id`的目的就是要唯一。如果我们也复制了`id`，那么它就不会发挥正确的作用。相反，我们正在复制其他重要的数据，但我们认识到这是一个独立的组件，而不仅仅是一个精确的副本。出于同样的原因，我们也没有复制`isDead`变量。我们正在创建一个类似于旧组件的新组件，但仍然是一个独立的组件。如果我们复制了`isDead`，那么这个组件在这个帧或下一个帧中就会被删除。
- en: Next, both classes register themselves with engines in the clone method instead
    of the constructor. This is because of how they are intended to be used. Our object
    manager will hold a collection of these pre-created prototype components at the
    start of the game so they are ready to be cloned. We don't want these initial
    components to pollute the graphics or physics engine.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这两个类在克隆方法中而不是构造函数中将自己注册到引擎中。这是因为它们的预期用途。我们的对象管理器将在游戏开始时保存这些预先创建的原型组件，以便它们可以随时被克隆。我们不希望这些初始组件污染图形或物理引擎。
- en: However, we are assuming that an object is being cloned and it also needs to
    live in the game world, so we register at that time. This seems like the most
    standard reason for cloning. It is better for the user to only worry about cloning,
    than to worry about cloning, registering, and then unregistering. If the user
    wishes to do something non-standard, they are free to unregister after cloning.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们假设一个对象正在被克隆，并且它也需要存在于游戏世界中，所以我们当时进行了注册。这似乎是最标准的克隆原因。对于用户来说，只关心克隆，而不是担心克隆、注册然后注销，会更好。如果用户希望进行非标准操作，他们可以在克隆后自由注销。
- en: Cloning an object
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆对象
- en: 'We have seen a few examples of how `M5Component` derived classes use the Prototype
    pattern. We will look at a few more important ones a little later, but for now
    let''s look at how the `M5Object` class uses these `Clone` methods, and how the
    `M5Object` itself is cloned. Recall that the `M5Object` also had a `Clone` method.
    Even though this class isn''t part of a hierarchy, it can still use the concept
    of the Prototype pattern to create cloneable instances. Here is the `Clone` method
    of the `M5Object`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几个`M5Component`派生类如何使用原型模式的例子。我们稍后会看看更多重要的例子，但现在让我们看看`M5Object`类是如何使用这些`Clone`方法的，以及`M5Object`本身是如何被克隆的。回想一下，`M5Object`也有一个`Clone`方法。尽管这个类不是层次结构的一部分，但它仍然可以使用原型模式的概念来创建可克隆的实例。以下是`M5Object`的`Clone`方法：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The important thing when we clone is that we copy all the relevant data from
    the old object. This includes not only things like the position and velocity but
    also all the components. So, we start off the function by both creating a new
    instance of the object we will be creating and passing the correct type to the
    constructor. This will set the `m_type` and `m_id` variables. Remember, even though
    we are cloning, we want to make sure that each object has a unique ID. Next, we
    copy the data. Just as with components, we don't need to copy the `isDead` value.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们克隆时，重要的是要复制旧对象的所有相关数据。这不仅包括像位置和速度这样的东西，还包括所有组件。因此，我们在函数开始时创建了一个新实例，并将正确的类型传递给构造函数。这将设置`m_type`和`m_id`变量。记住，尽管我们在克隆，但我们想确保每个对象都有一个唯一的ID。接下来，我们复制数据。就像组件一样，我们不需要复制`isDead`值。
- en: Finally, we have a loop to clone all components in the current object. This
    shows the power of the Prototype pattern. We don't need to know the types of each
    component--all we need to do is loop, call `Clone` to make our copy, then add
    that copy to the newly created object. Remember that the `AddComponent` method
    will change the `m_pObj` in each component. This will ensure that all components
    point to their correct owners.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个循环来克隆当前对象中的所有组件。这展示了原型模式的强大之处。我们不需要知道每个组件的类型——我们只需要循环，调用 `Clone` 来创建副本，然后将这个副本添加到新创建的对象中。记住，`AddComponent`
    方法会改变每个组件中的 `m_pObj`。这将确保所有组件都指向它们正确的所有者。
- en: In the end, the Prototype pattern is easy. Each component's `Clone` method is
    simple, and using them to clone an object is simple. Even using these cloned objects
    in the `M5ObjectManager` is easy. We will look at that in the next few pages,
    but first let's talk about a few details that some readers may have noticed. The
    first is that we didn't use a copy constructor in any of the Mach5 `Clone` methods,
    even though we did in the `Shape` example. The next is that the return types of
    the `GfxComponent` and `CollideComponent` are different from the return type in
    the `M5Component` interface.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，原型模式很简单。每个组件的 `Clone` 方法都很简单，使用它们来克隆对象也很简单。甚至在使用这些克隆对象在 `M5ObjectManager`
    中也很容易。我们将在接下来的几页中查看这一点，但首先让我们谈谈一些读者可能注意到的细节。第一个是我们没有在任何 Mach5 `Clone` 方法中使用拷贝构造函数，尽管我们在
    `Shape` 示例中使用了它。下一个是 `GfxComponent` 和 `CollideComponent` 的返回类型与 `M5Component`
    接口中的返回类型不同。
- en: Choosing a copy constructor
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择拷贝构造函数
- en: As we said, and as you saw in the code examples above, we didn't use copy constructors
    in any of the component `Clone` methods. We also didn't use them in the `Clone`
    method of `M5Object`. By default, classes have copy constructors and assignment
    operators generated by the compiler. In the `Shape` example above, we used the
    compiler generated copy constructor in our `Clone` methods.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，并且正如你在上面的代码示例中看到的，我们在任何组件的 `Clone` 方法中都没有使用拷贝构造函数。我们也没有在 `M5Object`
    的 `Clone` 方法中使用它们。默认情况下，类会由编译器生成拷贝构造函数和赋值运算符。在上面的 `Shape` 示例中，我们在 `Clone` 方法中使用了编译器生成的拷贝构造函数。
- en: However, in the Mach5 Engine there is an important choice to consider. What
    should the copy constructor do about the `m_id` variable value? Remember that
    this ID is supposed to be unique for every object and every component. However,
    if we use the compiler generated copy constructor, each variable, including `m_id`,
    will be copied by value. This would mean that any time we use the copy constructor,
    we would have two objects with the exact same ID.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Mach5 引擎中，有一个重要的选择需要考虑。拷贝构造函数应该如何处理 `m_id` 变量的值？记住，这个 ID 应该对每个对象和每个组件都是唯一的。然而，如果我们使用编译器生成的拷贝构造函数，包括
    `m_id` 在内的每个变量都将按值复制。这意味着每次我们使用拷贝构造函数时，我们都会有两个具有完全相同标识符的对象。
- en: Sometimes this is what we want, such as if we wanted to have a vector of objects
    instead of pointers to objects, for example. When using standard vectors (and
    other containers), the copy constructor gets called when adding to the container.
    If we were to add an object, we probably would want it to copy the ID. It is also
    possible that we would want to shift the position of the object around the container.
    Most likely, we would want it to keep the same ID.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们确实希望这样，例如，如果我们想要有一个对象向量而不是对象指针，例如。当使用标准向量（和其他容器）时，在向容器添加元素时会调用拷贝构造函数。如果我们添加一个对象，我们可能希望它复制标识符。也可能我们希望将对象在容器周围的位置移动。最可能的是，我们希望它保持相同的标识符。
- en: However, this is not the behavior we want in our `Clone` methods. We want each
    clone to be a separate entity with a different unique ID. Of course, we could
    write our own copy constructor and give a different ID to each newly created object
    or component, just as we do in the default constructors. Unfortunately, if we
    did that using standard containers we would be generating new IDs for every time
    they internally called the copy constructor. In this case, the IDs wouldn't match
    up to the correct objects or components.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是我们希望在 `Clone` 方法中看到的行为。我们希望每个克隆都是一个独立的实体，具有不同的唯一标识符。当然，我们可以编写自己的拷贝构造函数，并为每个新创建的对象或组件分配一个不同的标识符，就像我们在默认构造函数中所做的那样。不幸的是，如果我们使用标准容器这样做，我们会在它们内部每次调用拷贝构造函数时生成新的标识符。在这种情况下，标识符就不会与正确的对象或组件匹配。
- en: In the Mach5 Engine we use containers of pointers instead of containers of objects
    or components, so the authors decided to remove the copy constructors (and assignment
    operators) all together. This will remove all confusion about the process. If
    you want a copy, you call the `Clone` method, because you can't call the copy
    constructor. It is fine to make a different decision. In a different engine that
    uses containers of objects instead of pointers, a different decision would probably
    be made.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mach5 引擎中，我们使用指针容器而不是对象或组件容器，因此作者决定完全删除复制构造函数（和赋值运算符）。这将消除所有关于该过程的混淆。如果你想复制，你可以调用
    `Clone` 方法，因为你不能调用复制构造函数。做出不同的决定是可以的。在另一个使用对象容器而不是指针容器的不同引擎中，可能会做出不同的决定。
- en: 'In the Mach5 Engine, we remove these methods from the object by making them
    private so that they can''t be called. In C++ 11, you can mark them as deleted
    so the compiler won''t generate them for you. The assignment operators will already
    be removed because these classes contain `const` data that can''t be reassigned:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mach5 引擎中，我们通过将它们设置为私有来从对象中删除这些方法，这样就不能调用它们。在 C++ 11 中，你可以将它们标记为已删除，这样编译器就不会为你生成它们。赋值运算符已经删除，因为这些类包含不能重新分配的
    `const` 数据：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Covariant return types
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协变返回类型
- en: 'Astute readers will also have noticed that the return types of each `Clone`
    method in the Mach5 Engine are actually different. The base `M5Component` class
    returns an `M5Component*`, however the derived classes return pointers to their
    own class types. This is a feature of C++ (as well as some other languages) known
    as covariant return types. Let''s look at this feature using the `Shape` class
    from above:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的读者也会注意到，Mach5 引擎中每个 `Clone` 方法的返回类型实际上都是不同的。基类 `M5Component` 返回 `M5Component*`，然而派生类返回它们自己类类型的指针。这是
    C++（以及一些其他语言）中称为协变返回类型的一个特性。让我们使用上面提到的 `Shape` 类来查看这个特性：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If the `Clone` method of the `Circle` class returns a `Shape*`, the compiler
    won''t allow us to directly assign the result to a `Circle*`. We would need to
    do either a `static_cast` or `dynamic_cast`, meaning we would have to write code
    like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Circle` 类的 `Clone` 方法返回 `Shape*`，编译器将不允许我们直接将结果赋值给 `Circle*`。我们需要进行 `static_cast`
    或 `dynamic_cast`，这意味着我们必须编写如下代码：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In both cases, the `Clone` method will return a circle. However, there is no
    way for the compiler to know this, so we are forced to do the cast. The standard
    rule for using virtual functions is that the function signature must be the same,
    including the return type. With covariant return types, the compiler will allow
    us to replace the base class of a return type with a more specific type in the
    inheritance hierarchy:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`Clone` 方法将返回一个圆。然而，编译器无法知道这一点，所以我们被迫进行类型转换。使用虚函数的标准规则是函数签名必须相同，包括返回类型。使用协变返回类型，编译器将允许我们在继承层次结构中将返回类型的基类替换为更具体类型：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By using covariant return types, we can eliminate the need for unnecessary casting
    in cases where we clone an object that needs to access properties of its true
    type. It is worth noting that this feature only works with pointers or references.
    That means if the `Clone` method of `Shape` was returning a shape, instead of
    `Shape*`, we wouldn't have the option of doing this.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用协变返回类型，我们可以在克隆需要访问其实际类型属性的对象时消除不必要的类型转换。值得注意的是，这个特性仅适用于指针或引用。这意味着如果 `Shape`
    的 `Clone` 方法返回的是形状，而不是 `Shape*`，我们就不会有这种选择。
- en: Loading archetypes from a file
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中加载原型
- en: Now that we have seen the Prototype pattern in detail and discussed how it is
    used with the components of the Mach5 Engine, let's look at how we can use it
    to load object data from a file. To do that, we will need to first look at the
    object files, then look at specific methods in the `M5ObjectManager` used to load
    and create these objects.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经详细了解了原型模式，并讨论了它是如何与 Mach5 引擎的组件一起使用的，让我们看看我们如何使用它从文件中加载数据对象。为此，我们首先需要查看对象文件，然后查看
    `M5ObjectManager` 中用于加载和创建这些对象的特定方法。
- en: Archetype files
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型文件
- en: The first thing we need to do is look at how we define our object archetype
    within a file. The Mach5 Engine uses `.ini` files for archetypes, levels, and
    anything related to initialization of the engine. A more standard file format
    would be XML or JSON if you wanted to keep them as human readable and modifiable.
    If you didn't want them to be modified by users, the files could always be saved
    as binary.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是查看我们如何在文件中定义我们的对象原型。Mach5引擎使用`.ini`文件作为原型、关卡以及与引擎初始化相关的一切。如果您想保持它们作为人类可读和可修改的，一个更标准的文件格式将是XML或JSON。如果您不希望用户修改它们，文件始终可以保存为二进制格式。
- en: 'We have chosen `.ini` files because they are easy to read by both humans and
    a computer program. They only have a few simple rules, so they are easy to explain
    in just a few sentences. They only contain named sections which are defined by
    square brackets `[ ]`, and key value pairs in the form of `key = value`. The only
    exception is the global section, which doesn''t have a name and therefore no square
    brackets. Let''s look at a basic example of an Archetype file. This is an example
    of `Player.ini`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择`.ini`文件，因为它们既易于人类阅读，也易于计算机程序读取。它们只有几条简单的规则，所以只需几句话就可以解释清楚。它们只包含由方括号`[ ]`定义的命名部分，以及形式为`key
    = value`的键值对。唯一的例外是全球部分，它没有名称，因此没有方括号。让我们看看一个基本的原型文件示例。这是一个`Player.ini`的示例：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, the global section of the `Player.ini` file contains values
    for everything variable that is defined in `M5Object`. Except for the components
    key, everything is read in the `FromFile` method of the `M5Object`. In this case,
    most of our starting values are zero. This is because things like the starting
    position for the player object will depend on the level, so this data will be
    modified after creation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Player.ini`文件的全局部分包含在`M5Object`中定义的所有可变值的值。除了组件键之外，所有内容都是在`M5Object`的`FromFile`方法中读取的。在这种情况下，我们的大部分起始值都是零。这是因为像玩家对象的起始位置这样的东西将取决于关卡，因此这些数据将在创建后进行修改。
- en: The more important part is the components. The components key contains a list
    of components that the object will use. These strings will be used by the `M5ObjectManager`
    to create a component and then read the specific component data defined in each
    section. This allows us to reuse components, such as the `ColliderComponent`,
    because each object that uses them can have different component data. In this
    case, the player object will have a radius of `5`, but a bullet might have a radius
    of `1`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是组件。组件键包含一个对象将使用的组件列表。这些字符串将由`M5ObjectManager`用于创建组件，然后读取每个部分中定义的特定组件数据。这使我们能够重用组件，例如`ColliderComponent`，因为使用它们的每个对象都可以有不同的组件数据。在这种情况下，玩家对象将有一个半径为`5`，但子弹可能有一个半径为`1`。
- en: The object manager
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象管理器
- en: 'The `M5ObjectManager` is a singleton class that is responsible for, among other
    things, loading archetypes and creating objects. There are a lot of members and
    methods in this class so looking at everything would take too long. In this section,
    we will only go over the methods specifically related to loading and creating
    an object from an Archetype file. Remember that since the class is a singleton,
    we have global access. For that reason, every member and method is static:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`M5ObjectManager`是一个单例类，它负责加载原型和创建对象等任务。这个类中有许多成员和方法，所以查看所有内容会花费太多时间。在本节中，我们只将介绍与从原型文件加载和创建对象相关的特定方法。请记住，由于该类是单例，我们具有全局访问权限。因此，每个成员和方法都是静态的：'
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here we have the most important members and methods to show how objects are
    loaded from a file. What we haven't shown here are methods related to destroying
    or searching for specific objects. If you are interested in those functions, feel
    free to review the full source code that comes with this book.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了最重要的成员和方法，以展示如何从文件中加载对象。我们没有展示的是与销毁或搜索特定对象相关的方法。如果您对这些功能感兴趣，请随时查阅本书附带的全源代码。
- en: In the public section, the `AddArcheType` method will be used to read an archetype
    file, create the object, and store it for later. The `RemoveArcheType` method
    is used to delete the object when it is no longer needed. Finally, the `CreateObject`
    method will be used to clone one of the previously loaded archetypes. In the private
    section, we have a few types defined for creating easier names. You can see we
    are using the templated Dynamic Factory that we created in [Chapter 5](part0096.html#2RHM00-04600e4b10ea45a2839ef4fc3675aeb7),
    *Decoupling Code via the Factory Method Pattern*. We also have a map of the loaded
    Archetype objects.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共部分，`AddArcheType` 方法将被用来读取原型文件，创建对象，并将其存储以供以后使用。`RemoveArcheType` 方法用于在不再需要对象时删除它。最后，`CreateObject`
    方法将用于克隆之前加载的其中一个原型。在私有部分，我们定义了一些类型以简化命名。您可以看到我们正在使用我们在第 5 章[第 5 章](part0096.html#2RHM00-04600e4b10ea45a2839ef4fc3675aeb7)中创建的模板化动态工厂，即通过工厂方法模式解耦代码。我们还有一个已加载的原型对象的映射。
- en: 'Let''s take a closer look at these methods:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这些方法：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This might seem like a difficult function, but this is where the magic happens.
    Let's start at the beginning. This function takes two parameters, an enumeration
    ID specifying the type to create, and a file name to associate with that `enum`
    ID. Next, we need to check if this `M5Archetypes` ID has been loaded before. If
    it has, there must be an error. After checking for the `enum` error, we read the
    `.ini` file. If the file does not exist, the `ReadFile` method will assert.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可能看起来很复杂，但这里正是魔法发生的地方。让我们从开始的地方说起。这个函数接受两个参数，一个枚举 ID，用于指定要创建的类型，以及一个与该 `enum`
    ID 关联的文件名。接下来，我们需要检查这个 `M5Archetypes` ID 是否之前已经被加载过。如果已经加载过，那么肯定存在错误。在检查枚举错误之后，我们读取
    `.ini` 文件。如果文件不存在，`ReadFile` 方法将断言。
- en: If there haven't been any errors, we create a brand new `M5Object`, and pass
    the `M5ArcheTypes` ID to the constructor. This simply sets the type of the object,
    but doesn't do anything else. To set the data for the object, we call the `FromFile`
    method to read the global section from the `.ini` file. This will set the position,
    scale, rotation, and everything else in the object except the actual component,
    which needs to be handled differently.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有出现任何错误，我们将创建一个新的 `M5Object`，并将 `M5ArcheTypes` ID 传递给构造函数。这仅仅设置了对象的类型，但没有做其他任何事情。为了设置对象的数据，我们调用
    `FromFile` 方法来从 `.ini` 文件中读取全局部分。这将设置对象的位置、缩放、旋转以及对象中的其他一切，除了实际组件，这需要以不同的方式处理。
- en: The trouble with the components is that the file contains the component names
    as strings but, for the sake of performance during the game, we want to avoid
    doing string comparisons. This means we need to somehow convert these strings
    to an `enum` value. This is the purpose of the `StringToComponent` function. This
    function is an `if`/`else` chain that will return the correct enum based on the
    parameter. Functions like this can be a problem to maintain. We will discuss in
    a later chapter about how to use Windows batch files to automate this process.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的问题在于，文件中包含的组件名称是作为字符串存储的，但为了游戏中的性能考虑，我们希望避免进行字符串比较。这意味着我们需要以某种方式将这些字符串转换为
    `enum` 值。这就是 `StringToComponent` 函数的目的。这个函数是一个 `if`/`else` 链，它将根据参数返回正确的枚举值。这样的函数可能会在维护上出现问题。我们将在后面的章节中讨论如何使用
    Windows 批处理文件来自动化这个过程。
- en: After we read the object data from the file, we read the component list from
    the file. This is a list of component names separated by a space. There are lots
    of ways we could extract each individual component name, but one of the easiest
    ways is to use an STL `stringstream` object. This allows us to extract separate
    strings from the stream, just like `std::cin`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从文件读取对象数据之后，我们接着从文件中读取组件列表。这是一个由空格分隔的组件名称列表。我们可以有很多种方法来提取每个单独的组件名称，但其中最简单的方法之一是使用
    STL 的 `stringstream` 对象。这允许我们从流中提取单独的字符串，就像 `std::cin` 一样。
- en: After creating our `stringstream` object, we loop through the stream and extract
    the name. We then use `s_componentFactory` to build the correct component, after
    it has been converted to a `M5ComponentTypes` enum. After the correct component
    is built, we pass the `.ini` file to the component's `FromFile` method to let
    the derived component read its own data. Then we make sure to add the component
    to the object. Finally, after all components have been read, we add the type and
    object pointer to our `s_archetypes` map.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的 `stringstream` 对象后，我们遍历流并提取名称。然后，我们将转换后的 `M5ComponentTypes` 枚举使用 `s_componentFactory`
    来构建正确的组件。在构建正确的组件后，我们将 `.ini` 文件传递给组件的 `FromFile` 方法，让派生组件读取其自己的数据。然后我们确保将组件添加到对象中。最后，在读取所有组件后，我们将类型和对象指针添加到我们的
    `s_archetypes` 映射中。
- en: 'This may seem like a complicated way of loading objects. However, this function
    doesn''t need to know about any derived component types, or which components go
    with a specific object type. If our archetype `.ini` files change, we don''t need
    to recompile this code. We are free to add, remove, or change objects in our game
    and our high-level module, the `M5ObjectManager`, doesn''t need to change:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像是一种加载对象复杂的方法。然而，这个函数不需要了解任何派生组件类型，或者哪些组件与特定对象类型相关联。如果我们的原型 `.ini` 文件发生变化，我们不需要重新编译此代码。我们可以自由地添加、删除或更改游戏和我们的高级模块
    `M5ObjectManager` 中的对象，而无需更改：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `RemoveArcheType` method is much simpler than the `AddArcheType`. All we
    need to do here is make sure the type to delete exists in the map, which we do
    by first finding and using a debug assert if it isn't there. Then we delete the
    prototype object and erase the iterator within the map.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveArcheType` 方法比 `AddArcheType` 简单得多。我们在这里需要做的只是确保要删除的类型存在于映射中，我们通过首先找到并使用调试断言（如果它不存在）来实现这一点。然后我们删除原型对象并在映射中擦除迭代器。'
- en: 'The `RemoveArcheType` method doesn''t need to be called since all archetype
    objects will be deleted when the game exits. However, this could be used if the
    user wanted to minimize which archetypes existed throughout the game. By default,
    the Mach5 Engine automatically loads all archetype `.ini` files before the game
    begins:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveArcheType` 方法不需要被调用，因为所有原型对象将在游戏退出时被删除。然而，如果用户想要最小化游戏中存在的原型，这可以用来实现。默认情况下，Mach5
    引擎在游戏开始前自动加载所有原型 `.ini` 文件：'
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, we have the method that allows the user to create Archetype objects.
    Here, the user supplies the `M5ArcheTypes` type that they want to create. First,
    the method does the standard error checking that we are familiar with. Then, after
    finding the correct iterator, we make use of the Prototype pattern's `Clone` method
    to copy all data and components from the Archetype object. After creating the
    object, we automatically add it to the list of active game objects and return
    the pointer to the user so they can modify things such as position and velocity
    if needed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个允许用户创建原型对象的方法。在这里，用户提供他们想要创建的 `M5ArcheTypes` 类型。首先，该方法执行我们熟悉的常规错误检查。然后，在找到正确的迭代器后，我们利用原型模式的
    `Clone` 方法来复制从原型对象中所有数据和组件。在创建对象后，我们自动将其添加到活动游戏对象列表中，并将指针返回给用户，以便他们可以根据需要修改位置和速度等属性。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused a lot on creating flexible code. Since we are using
    the Component Object Model with our game objects, we want to make sure that, as
    our objects change, they handle that change well. This means we don't want to
    modify lots of other files as we playtest and balance our objects.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们重点介绍了创建灵活的代码。由于我们正在使用组件对象模型与游戏对象一起使用，我们想要确保，随着对象的变化，它们能够很好地处理这种变化。这意味着我们不想在游戏测试和平衡对象时修改大量其他文件。
- en: We said at the beginning of this chapter that the goal for our game objects
    is to completely define them in a file. Since we are using components in our objects,
    we want to define the components that are used by the objects within the file
    as well. By defining objects in a file, our programmers are free to work on other
    code and the designers can work on balance and play testing without fear of breaking
    the game or introducing bugs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章开头说过，我们游戏对象的目标是在文件中完全定义它们。由于我们在对象中使用组件，我们希望在文件中定义对象使用的组件。通过在文件中定义对象，我们的程序员可以自由地工作在其他代码上，设计师可以平衡和游戏测试，而无需担心破坏游戏或引入错误。
- en: After looking at a simple example of the Prototype pattern, we looked at how
    it is used in the Mach5 Engine. We saw both the `M5Component` class and the `M5Object`
    use a `Clone` method to make copying objects easy. These of course, were used
    by the `M5ObjectManager` to allow the user to create objects based on the `M5ArcheTypes`
    enum.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看原型模式的简单示例之后，我们探讨了它在 Mach5 引擎中的应用。我们看到了 `M5Component` 类和 `M5Object` 类都使用 `Clone`
    方法来简化对象的复制。当然，这些方法是由 `M5ObjectManager` 使用的，以便用户可以根据 `M5ArcheTypes` 枚举创建对象。
- en: Now that creating objects can be done through a file, we should focus on a problem
    that is more difficult to see. Since we are using lots of object pointers that
    will have lots of component pointers, we should talk about a few problems related
    to memory. This is what we will cover in the next chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建对象可以通过文件完成，我们应该关注一个更难看到的问题。由于我们使用了大量的对象指针，这些指针将会有很多组件指针，我们应该讨论一些与内存相关的问题。这就是我们在下一章将要涉及的内容。
