- en: Advanced Use of STL Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STL算法的高级用法
- en: 'We will cover the following recipes in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Implementing a trie class using STL algorithms
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用STL算法实现trie类
- en: Implementing a search input suggestion generator with tries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用trie实现搜索输入建议生成器
- en: Implementing the Fourier transform formula with STL numeric algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用STL数值算法实现傅里叶变换公式
- en: Calculating the error sum of two vectors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算两个向量的误差和
- en: Implementing an ASCII Mandelbrot renderer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用STL算法实现ASCII Mandelbrot渲染器
- en: Building our own algorithm - split
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们自己的算法 - split
- en: Composing useful algorithms from standard algorithms - gather
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从标准算法中组合有用的算法 - gather
- en: Removing consecutive whitespace between words
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除单词之间的连续空格
- en: Compressing and decompressing strings
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩和解压字符串
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'In the last chapter, we visited basic STL algorithms and performed simple tasks
    with them in order to get a feeling of the typical STL interface: most STL algorithms
    accept one or more ranges in the form of iterator pairs as input/output parameters.
    They often also accept predicate functions, custom comparison functions, or transformation
    functions. In the end, they mostly return iterators again because these can often
    be fed into some other algorithm afterward.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们访问了基本的STL算法，并使用它们执行了简单的任务，以便对典型的STL接口有所了解：大多数STL算法接受形式为迭代器对的一个或多个范围作为输入/输出参数。它们通常还接受谓词函数、自定义比较函数或转换函数。最后，它们大多再次返回迭代器，因为这些迭代器通常可以随后被输入到其他一些算法中。
- en: While STL algorithms aim to be minimal, their interfaces also try to be as general
    as possible. This enables maximum code reuse potential but does not always look
    too pretty. An experienced C++ coder who knows all algorithms has a better time
    reading other people's code if it tries to express as many ideas using STL algorithms
    as possible. This leads to a maximized common ground of comprehension between
    coder and reader. A programmer's brain can simply parse the name of a well-known
    algorithm more quickly than it can understand a complex loop, which does a mainly
    similar, but in some detail a slightly different, job.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然STL算法旨在尽可能简化，但它们的接口也尽可能通用。这样可以最大程度地实现代码重用，但并不总是看起来太美观。一个有经验的C++程序员，如果尽可能使用STL算法来表达尽可能多的想法，阅读其他人的代码会更轻松。这导致了程序员和读者之间理解的最大化共同基础。程序员的大脑可以更快地解析一个众所周知的算法名称，而不是理解一个复杂的循环，它主要做着类似的事情，但在某些细节上略有不同。
- en: At this point, we are using STL data structures so intuitively that we can nicely
    avoid pointers, raw arrays, and other crude legacy structures. The next step is
    lifting our comprehension of STL algorithms up to the levels where we can avoid
    the use of handcrafted loop-control-structure complexes by expressing them in
    terms of well-known STL algorithms. Often, this is a real improvement because
    code becomes simply shorter and more readable while at the same time being more
    general and data-structure agnostic. It is practically always possible to avoid
    writing handcrafted loops and taking an algorithm out of the `std` namespace instead,
    but sometimes, it admittedly leads to *awkward code*. We are not going to differentiate
    between what is awkward and what is not; we'll only explore the possibilities.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用STL数据结构如此直观，以至于我们可以很好地避免指针、原始数组和其他粗糙的遗留结构。下一步是将我们对STL算法的理解提升到可以避免使用手工编写的循环控制结构复杂性的水平，而是用众所周知的STL算法来表达它们。通常，这是一个真正的改进，因为代码变得更简洁、更易读，同时更通用和数据结构无关。实际上，几乎总是可以避免编写手工循环，并将算法从`std`命名空间中取出，但有时，这确实会导致*笨拙的代码*。我们不打算区分什么是笨拙的，什么不是；我们只会探索可能性。
- en: In this chapter, we will use STL algorithms in creative ways in order to look
    for new horizons and to see how things can be implemented with modern C++. On
    the way, we will implement our own STL-like algorithms, which can easily be combined
    with existing data structures and other algorithms designed in the same way. We
    will also *combine* existing STL algorithms to get *new* algorithms, which were
    not there before. Such combined algorithms allow for more complex algorithms on
    top of the existing ones, while they are themselves extremely short and readable
    this way. While on this little trip, we will also see where exactly STL algorithms
    suffer from reusability or prettiness. Only when we know *all* the ways well can
    we best decide which way is the right one.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将以创造性的方式使用STL算法，以寻找新的视角，并看看如何用现代C++实现事物。在这个过程中，我们将实现我们自己的类似STL的算法，这些算法可以轻松地与现有数据结构和以相同方式设计的其他算法结合使用。我们还将*组合*现有的STL算法，以获得*新*的算法，这些算法以前不存在。这样组合的算法允许在现有算法的基础上实现更复杂的算法，同时它们本身以这种方式极其简短和易读。在这个小旅程中，我们还将看到STL算法在可重用性或美观性方面的具体问题。只有当我们充分了解所有的方式时，我们才能最好地决定哪种方式是正确的。
- en: Implementing a trie class using STL algorithms
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用STL算法实现trie类
- en: The so-called **trie** data structure poses an interesting way to store data
    in an easily searchable manner. When segmenting sentences of text into lists of
    words, it is often possible to combine the first few words that some sentences
    have in common.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓的**trie**数据结构提出了一种将数据以易于搜索的方式存储的有趣方法。在将文本句子分割成单词列表时，通常可以将一些句子共有的前几个单词合并起来。
- en: 'Let''s have a look at the following diagram, where the sentences `"hi how are
    you"` and `"hi how do you do"` are saved in a tree-like data structure. The first
    words they have in common are `"hi how"`, and then they differ and split up like
    a tree:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的图表，在这里，句子`"hi how are you"`和`"hi how do you do"`被保存在类似树状的数据结构中。它们共有的第一个单词是`"hi
    how"`，然后它们不同并分裂成树状：
- en: '![](img/b42b8317-e512-4bac-bc05-cb4ce62421b7.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b42b8317-e512-4bac-bc05-cb4ce62421b7.png)'
- en: Because the trie data structure combines common prefixes, it is also called
    *prefix tree*. It is very easy to implement such a data structure with what the
    STL gives us already. This section concentrates on implementing our own trie class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因为trie数据结构结合了常见的前缀，所以它也被称为*前缀树*。使用STL已经给我们的东西实现这样的数据结构非常容易。本节集中在实现我们自己的trie类。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will implement our own prefix tree only made from STL data
    structures and algorithms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现我们自己的前缀树，只使用STL数据结构和算法。
- en: 'We will include all the headers from the STL parts we use and declare that
    we use the `std` namespace by default:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将包括我们使用的STL部分的所有头文件，并声明我们默认使用`std`命名空间：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The entire program revolves around a trie for which we have to implement a
    class first. In our implementation, a trie is basically a recursive map of maps.
    Every trie node contains a map, which maps from an instance of the payload type
    `T` to the next trie node:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个程序围绕着一个trie，我们首先必须实现一个类。在我们的实现中，trie基本上是一个递归的映射。每个trie节点包含一个映射，它将有效载荷类型`T`的实例映射到下一个trie节点：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The code for inserting new item sequences is simple. The user provides a begin/end
    iterator pair and we loop through it recursively. If the user input sequence is
    `{1, 2, 3}`, then we look up `1` in the subtrie and then look up `2` in the next
    subtrie, in order to get the subtrie for `3`. If any of those subtries did not
    exist before, they are implicitly added by the `[]` operator of `std::map`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入新项目序列的代码很简单。用户提供一个begin/end迭代器对，我们通过递归循环遍历它。如果用户输入序列是`{1, 2, 3}`，那么我们在子trie中查找`1`，然后在下一个子trie中查找`2`，以获取`3`的子trie。如果这些子trie中的任何一个以前不存在，它们将被`std::map`的`[]`运算符隐式添加：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We also define convenience functions, which enable the user to just provide
    a container of items, which are then automatically queried for iterators:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还定义了方便的函数，使用户只需提供一个项目容器，然后自动查询迭代器：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In order to allow the user to write `my_trie.insert({"a", "b", "c"});`, we
    must help the compiler a bit to correctly deduce all the types from that line,
    so we add a function, which overloads the insert interface with an `initializer_list`
    parameter:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了允许用户编写`my_trie.insert({"a", "b", "c"});`，我们必须帮助编译器正确推断出那一行的所有类型，所以我们添加了一个函数，它重载了带有`initializer_list`参数的插入接口：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will also want to see what''s in a trie, so we need a `print` function.
    In order to print, we can do a depth-first-search through the trie. On the way
    from the root node down to the first leaf, we record all payload items we have
    seen already. This way, we have a complete sequence together once we reach the
    leaf, which is trivially printable. We see that we reached a leaf when `tries.empty()`
    is `true`. After the recursive `print` call, we pop off the last added payload
    item again:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还想看看trie中有什么，所以我们需要一个`print`函数。为了打印，我们可以通过trie进行深度优先搜索。从根节点到第一个叶子的路上，我们记录我们已经看到的所有有效载荷项目。这样，一旦到达叶子，我们就有了一个完整的序列，这是微不足道的可打印的。当`tries.empty()`为`true`时，我们看到我们到达了一个叶子。递归`print`调用之后，我们再次弹出最后添加的有效载荷项目：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The recursive `print` function passes around a reference to a printable list
    of payload items, but the user should call it without any parameters. Therefore,
    we define a parameterless `print` function, which constructs the helper list object:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归的`print`函数传递一个可打印的有效载荷项目列表的引用，但用户应该在没有任何参数的情况下调用它。因此，我们定义了一个无参数的`print`函数，它构造了辅助列表对象：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now that we can construct and print tries, we may want to search for subtries.
    The idea is that if the trie contains sequences such as `{a, b, c}` and `{a, b,
    d, e}`, and we give it a sequence, `{a, b}`, for search, it would return us the
    subtrie that contains the `{c}` and `{d, e}` parts. If we find the subtrie, we
    return a `const` reference to it. The possibility exists that there is no such
    subtrie in case the trie does not contain the sequence we are searching for. In
    such cases, we still need to return *something*. The `std::optional` is a nice
    helper because we can return an *empty* optional object if there is no match:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以构建和打印tries，我们可能想要搜索子tries。这个想法是，如果trie包含序列，比如`{a, b, c}`和`{a, b, d, e}`，并且我们给它一个序列`{a,
    b}`进行搜索，它会返回包含`{c}`和`{d, e}`部分的子trie。如果我们找到了子trie，我们会返回一个`const`引用。有可能trie中没有这样的子trie，如果trie不包含我们要搜索的序列。在这种情况下，我们仍然需要返回*something*。`std::optional`是一个很好的帮助类，因为如果没有匹配，我们可以返回一个*empty*
    optional对象：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similar to the `insert` method, we provide a one-parameter version of the `subtrie`
    method, which automatically takes iterators from the input container:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`insert`方法类似，我们提供了`subtrie`方法的单参数版本，它会自动从输入容器中获取迭代器：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That''s already it. Let''s put the new trie class to use in our main function
    by instantiating a trie specialized on `std::string` objects and fill it with
    some example content:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样。让我们在主函数中使用新的trie类，通过实例化一个专门用于`std::string`对象的trie，并填充一些示例内容：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s first print the whole trie:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先打印整个trie：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we obtain the subtrie for all the input sentences that start with `"hi"`,
    and print it:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们获得了所有以`"hi"`开头的输入句子的子trie，并打印它：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Compiling and running the program shows that it does indeed return us only
    the two sentences that start with `"hi"`, when we query the trie for exactly that
    subtrie:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序显示，当我们查询trie时，它确实只返回以`"hi"`开头的两个句子：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Interestingly, the code for word sequence *insertion* is shorter and simpler
    than the code for *looking up* a given word sequence in a subtrie. So, let''s
    first have a look at the insertion code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，单词序列*插入*的代码比在子trie中查找给定单词序列的代码更短更简单。所以，让我们先看一下插入代码：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The pair of iterators, `it` and `end_it`, represent the word sequence to be
    inserted. The `tries[*it]` element looks up the first word in the sequence in
    the subtrie, and then, `.insert(next(it), end_it)` restarts the same function
    on that lower subtrie, with the iterator one word *further* advanced. The `if
    (it == end_it) { return; }` line just aborts the recursion. The empty `return`
    statement does *nothing*, which is a bit weird at first. All the insertion happens
    in the `tries[*it]` statement. The bracket operator `[]` of `std::map` either
    returns an existing item for the given key or it *creates* one with that key.
    The associated value (the mapped type is a trie in this recipe) is constructed
    from its default constructor. This way, we are *implicitly creating* a new trie
    branch whenever we are looking up unknown words.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器对`it`和`end_it`表示要插入的单词序列。`tries[*it]`元素在子trie中查找序列中的第一个单词，然后，`.insert(next(it),
    end_it)`重新启动相同的函数，该函数在较低的子trie上，迭代器向前移动一个单词。`if (it == end_it) { return; }`行只是中止递归。空的`return`语句什么都不做，这一点起初有点奇怪。所有的插入都发生在`tries[*it]`语句中。`std::map`的方括号操作符`[]`要么返回给定键的现有项，要么使用该键*创建*一个项。关联值（映射类型是本食谱中的trie）是从其默认构造函数构造的。这样，每当我们查找未知单词时，我们都会*隐式创建*一个新的trie分支。
- en: 'Looking up in a subtrie looks more complicated because we were not able to
    *hide* so much in implicit code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在子trie中查找看起来更复杂，因为我们无法在隐式代码中*隐藏*太多内容：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code basically revolves around the `auto found (tries.find(*it));` statement.
    Instead of looking up the next deeper trie node using the bracket operator (`[]`),
    we use `find`. If we use the `[]` operator for lookups, the trie will *create*
    missing items for us, which is *not* what we want when just looking up whether
    an item exists! (By the way, try doing that. The class method is `const`, so this
    will not even be possible. This can be quite a life saver, which helps us in preventing
    bugs.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码基本上围绕着`auto found (tries.find(*it));`语句。我们使用`find`来查找下一个更深的trie节点，而不是使用方括号操作符(`[]`)。如果我们在查找时使用`[]`操作符，trie将为我们*创建*缺失的项，这*不*是我们在查找项是否存在时想要的！（顺便说一句，试着这样做。类方法是`const`，所以这甚至不可能。这可以挽救生命，帮助我们防止错误。）
- en: Another scary looking detail is the return type, `optional<reference_wrapper<const
    trie>>`. We chose `std::optional` as the wrapper because it is possible that there
    is no such subtrie for the input sequence we are looking for. If we only inserted
    `"hello my friend"`, there will be no `"goodbye my friend"` sequence to look up.
    In such cases, we just return `{}`, which gives the caller an empty optional object.
    This still does not explain why we use `reference_wrapper` instead of just writing
    `optional<const trie &>`. The point here is that an optional instance with a member
    variable of the `trie&` type is not reassignable and hence would not compile.
    Implementing a reference using `reference_wrapper` leads to reassignable objects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个看起来可怕的细节是返回类型，`optional<reference_wrapper<const trie>>`。我们选择`std::optional`作为包装器，因为可能没有这样的子trie与我们正在寻找的输入序列相匹配。如果我们只插入了`"hello
    my friend"`，那么就不会有`"goodbye my friend"`序列可以查找。在这种情况下，我们只返回`{}`，这会给调用者一个空的optional对象。这仍然不能解释为什么我们使用`reference_wrapper`而不只是写`optional<const
    trie &>`。这里的重点是，具有`trie&`类型成员变量的可选实例是不可重新分配的，因此不会编译。使用`reference_wrapper`实现引用会导致可重新分配的对象。
- en: Implementing a search input suggestion generator with tries
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用trie实现搜索输入建议生成器
- en: When entering something into a search engine on the Internet, the interface
    often tries to guess how the full search query will look. This guessing is usually
    based on popular search queries from the past. Sometimes, such search engine guesses
    are quite funny because it appears that people type weird queries into search
    engines.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网搜索引擎中输入内容时，界面通常会尝试猜测完整的搜索查询是什么样子。这种猜测通常基于过去的热门搜索查询。有时，这样的搜索引擎猜测很有趣，因为人们似乎在搜索引擎中输入了奇怪的查询。
- en: '![](img/ca1d8fff-6f82-468a-8a56-2b41b86e20f9.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca1d8fff-6f82-468a-8a56-2b41b86e20f9.png)'
- en: In this section, we are going to use the trie class that we implemented in the
    previous recipe and build a little search query suggestion engine.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用前面食谱中实现的trie类，并构建一个小型的搜索查询建议引擎。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In this section, we will implement a terminal app, which accepts some input
    and then tries to guess what the user might want to look for, based on a cheap
    text file database:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个终端应用程序，它接受一些输入，然后尝试根据一个简单的文本文件数据库猜测用户可能想要查找的内容：
- en: 'As always, includes come first, and we define that we use the `std` namespace:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，首先是包含部分，我们定义使用`std`命名空间：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We use the trie implementation from the trie recipe:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用了trie食谱中的trie实现：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s add a little helper function that prints a line that prompts the user
    to enter some text:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个小的辅助函数，打印一行提示用户输入一些文本：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the main function, we open a text file, which acts as our sentence database.
    We read that text file line by line and feed those lines into a trie:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，我们打开一个文本文件，它充当我们的句子数据库。我们逐行读取该文本文件，并将这些行输入到trie中：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have constructed the trie from the content in the text file, we
    need to implement an interface for the user to query it. We prompt the user to
    enter some text and wait for a whole line of input:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经从文本文件中的内容构建了trie，我们需要为用户实现一个查询接口。我们提示用户输入一些文本，并等待输入一整行：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With that text input, we query the trie in order to get a subtrie from it.
    If we have such an input sequence in the text file already, then we can print
    how the input can be continued, just as in the search engine suggestion feature.
    If we do not find a matching subtrie, we just tell the user:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个文本输入，我们查询trie以从中获取一个子trie。如果我们在文本文件中已经有这样的输入序列，那么我们可以打印出输入如何继续，就像搜索引擎建议功能一样。如果我们找不到匹配的子trie，我们只是告诉用户：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Afterward, we print the prompt text again and wait for the next line of user
    input. That's it.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们再次打印提示文本，并等待用户输入下一行。就是这样。
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Before thinking about launching the program, we need to fill some content into
    `db.txt`. The input can be really anything, and it does not even need to be sorted.
    Each line of text will be one trie sequence:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在考虑启动程序之前，我们需要将一些内容填入`db.txt`。输入可以是任何内容，甚至不需要排序。每行文本将是一个trie序列：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We need to create `db.txt` before we can run the program. Its content could
    look like this:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行程序之前，我们需要创建`db.txt`。它的内容可能是这样的：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Compiling and running the program and entering some input looks like the following:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序并输入一些内容看起来像这样：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'How a trie works was explained in the last recipe, but how we fill it and how
    we query it looks a bit strange here. Let''s have a closer look at the code snippet
    that fills the empty trie with the content of the text database file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: trie的工作原理在上一个示例中已经解释过了，但是我们如何填充它以及如何查询它在这里看起来有点奇怪。让我们仔细看一下填充空trie的代码片段：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The loop fills the string `line` with the content of the text file, line by
    line. Then, we copy the string into an `istringstream` object. From such an input
    stream object, we can create an `istream_iterator`, which is useful because our
    trie does not only accept a container instance for looking up subtries but also
    primarily iterators. This way, we do not need to construct a vector or a list
    of words and can directly consume the string. The last piece of unnecessary memory
    allocations could be avoided by *moving* the content of `line` into `iss`. Unfortunately,
    `std::istringstream` does not provide a constructor that accepts `std::string`
    values to be *moved*. It will *copy* its input string, nevertheless.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 循环将字符串`line`逐行填充文本文件的内容。然后，我们将字符串复制到一个`istringstream`对象中。从这样的输入流对象，我们可以创建一个`istream_iterator`，这很有用，因为我们的trie不仅接受一个容器实例来查找子trie，而且主要是迭代器。这样，我们就不需要构造一个单词的向量或列表，可以直接使用字符串。通过*移动*`line`的内容到`iss`中，可以避免最后一块不必要的内存分配。不幸的是，`std::istringstream`没有提供接受`std::string`值来*移动*的构造函数。尽管如此，它仍然会*复制*它的输入字符串。
- en: When reading the user's input to look it up in the trie, we use exactly the
    same strategy but we do not use an input *file* stream. We use `std::cin`, instead.
    This works completely identically for our use case because `trie::subtrie` works
    with iterators just as `trie::insert` does.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取用户的输入以在trie中查找时，我们使用完全相同的策略，但我们不使用输入*文件*流。相反，我们使用`std::cin`。对于我们的用例，这完全相同，因为`trie::subtrie`与`trie::insert`一样使用迭代器。
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is possible to add *counter variables* to each node of the trie. This way,
    it is possible to count *how often* a prefix occurs in some input. From that,
    we could *sort* our suggestions by their occurrence frequency, which is actually
    what search engines do. Word suggestions for smartphone touchscreen text input
    could also be implemented this way.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在trie的每个节点上添加*计数变量*。这样，就可以计算某个输入中前缀出现的频率。从而，我们可以根据它们的出现频率对我们的建议进行排序，这实际上就是搜索引擎所做的。智能手机触摸屏文本输入的单词建议也可以用这种方式实现。
- en: This modification is left as an exercise for the reader.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修改留给读者作为一个练习。
- en: Implementing the Fourier transform formula with STL numeric algorithms
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用STL数值算法实现傅立叶变换公式
- en: The **Fourier transformation** is a very important and famous formula in signal
    processing. It was invented nearly 200 years ago, but with computers, the number
    of use cases for it really skyrocketed. It is used in audio/image/video compression,
    audio filters, medical imaging devices, cell phone apps that identify music tracks
    while listening to them on the fly, and so on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**傅立叶变换**是信号处理中非常重要和著名的公式。它是近200年前发明的，但随着计算机的出现，它的用例数量真的飙升了。它被用于音频/图像/视频压缩、音频滤波器、医学成像设备、手机应用程序在听音乐时实时识别音轨等等。'
- en: 'Because of the vastness of general numeric application scenarios (not only
    because of the Fourier transformation of course), the STL also tries to be useful
    in the context of numeric computation. The Fourier transformation is only one
    example among them but a tricky one too. The formula itself looks like the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一般数值应用场景的广泛性（当然不仅仅是傅立叶变换），STL也试图在数值计算的上下文中提供帮助。傅立叶变换只是其中的一个例子，但也是一个棘手的例子。公式本身看起来像这样：
- en: '![](img/ecd82744-2cc6-4b76-9f93-5f03df78a598.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecd82744-2cc6-4b76-9f93-5f03df78a598.jpg)'
- en: 'The transformation it describes is basically a *sum*. Each element of the sum
    is the multiplication of a data point of the input signal vector, and the expression
    *exp(-2 * i * ...)*. The maths behind this is a bit scary for everyone who does
    not know about complex numbers (or who just does not like maths), but it is also
    not really necessary to completely understand the maths in order to *implement*
    it. When having a close look at the formula, it says that the sum symbol loops
    over every data point of the signal (which is `N` elements long) using the loop
    variable `j`. The variable `k` is another loop variable because the Fourier transformation
    is not for calculating a single value, but a vector of values. In this vector,
    every data point represents the intensity and phase of a certain repetitive wave
    frequency, which is or is not a part of the original signal. When implementing
    this with manual loops, we will end up with code similar to the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它描述的转换基本上是一个*总和*。总和的每个元素都是输入信号向量的数据点与表达式*exp(-2 * i * ...)*的乘积。这背后的数学对于不了解复数（或者只是不喜欢数学）的每个人来说都有点可怕，但是要*实现*它也不是完全必要完全理解数学。仔细观察公式，它说总和符号循环遍历信号的每个数据点（长度为`N`）使用循环变量`j`。变量`k`是另一个循环变量，因为傅立叶变换不是用来计算单个值的，而是用来计算一系列值的。在这个向量中，每个数据点代表了某个重复波频率的强度和相位，这个频率是原始信号的一部分或者不是。当使用手动循环来实现这个时，我们最终会得到类似以下的代码：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `csignal` type may be an `std::vector` vector of complex numbers. For complex
    numbers, there is an `std::complex` STL class, which helps represent those. The
    `std::polar` function basically does the *exp(-i * 2 * ...)* part.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`csignal` 类型可以是复数的 `std::vector` 向量。对于复数，有一个 `std::complex` STL 类，可以帮助表示它们。`std::polar`
    函数基本上执行 *exp(-i * 2 * ...)* 部分。'
- en: This works well already, but we are going to implement it using STL tools.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经很好了，但我们将使用 STL 工具来实现它。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we are going to implement the Fourier transformation and its
    backward transformation and then play around with it to transform some signals:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现傅立叶变换及其反向变换，然后玩弄一下，以转换一些信号：
- en: 'First, we include all the headers and declare that we use the `std` namespace:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包括所有的头文件，并声明我们使用 `std` 命名空间：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A data point of a signal is a complex number and shall be represented by `std::complex`,
    specialized on the `double` type. This way, the type alias `cmplx` stands for
    two coupled `double` values, which represent the *real* and the *imaginary* parts
    of a complex number. A whole signal is a vector of such items, which we alias
    to the `csignal` type:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 信号的数据点是一个复数，应该由 `std::complex` 表示，专门针对 `double` 类型。这样，类型别名 `cmplx` 代表两个耦合的 `double`
    值，它们代表复数的 *实部* 和 *虚部*。整个信号是这些项目的向量，我们将其别名为 `csignal` 类型：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In order to iterate over an up-counting numeric sequence, we take the *numeric
    iterator* from the numeric iterator recipe. The variables `k` and `j` in the formula
    shall iterate over such sequences:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了迭代一个递增的数字序列，我们从数字迭代器配方中获取 *numeric iterator*。公式中的变量 `k` 和 `j` 将迭代这样的序列：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The Fourier transformation function shall just take a signal and return a new
    signal. The returned signal represents the Fourier transformation of the input
    signal. As the back transformation from a Fourier transformed signal back to the
    original signal is very similar, we provide an optional `bool` parameter, which
    chooses the transformation direction. Note that `bool` parameters are generally
    bad practice, especially if we use multiple `bool` parameters in a function signature.
    Here we just have one for brevity.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 傅立叶变换函数应该只接受一个信号并返回一个新的信号。返回的信号表示输入信号的傅立叶变换。由于从傅立叶变换信号到原始信号的反变换非常相似，我们提供了一个可选的
    `bool` 参数，用于选择变换方向。请注意，`bool` 参数通常是不好的做法，特别是如果我们在函数签名中使用多个 `bool` 参数。这里我们只是为了简洁起见使用了一个。
- en: 'The first thing we do is allocate a new signal vector with the size of the
    initial signal:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是分配一个具有初始信号大小的新信号向量：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There are two factors in the formula, which always look the same. Let''s pack
    them in their own variables:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公式中有两个因素，它们总是看起来一样。让我们把它们打包到它们自己的变量中：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `std::accumulate` algorithm is a fitting choice for executing formulas
    that sum up items. We are going to use `accumulate` on a range of up-counting
    numeric values. From these values, we can form the individual summands of each
    step. The `std::accumulate` algorithm calls a binary function on every step. The
    first parameter of this function is the current value of the part of `sum` that
    was already calculated in the previous steps, and its second parameter is the
    next value from the range. We look up the value of signal `s` at the current position
    and multiply it with the complex factor, `pol`. Then, we return the new partly
    sum. The binary function is wrapped into *another* lambda expression because we
    are going to use different values of `j` for every `accumulate` call. Because
    this is a two-dimensional loop algorithm, the inner lambda is for the inner loop
    and the outer lambda is for the outer loop:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`std::accumulate` 算法是执行求和公式的合适选择。我们将在一个递增的数字值范围上使用 `accumulate`。从这些值中，我们可以形成每一步的单独的加数。`std::accumulate`
    算法在每一步调用一个二元函数。这个函数的第一个参数是在前面的步骤中已经计算出的 `sum` 的一部分的当前值，它的第二个参数是范围中的下一个值。我们查找信号
    `s` 在当前位置的值，并将其与复数因子 `pol` 相乘。然后，我们返回新的部分和。二元函数被包装成 *另一个* lambda 表达式，因为我们将为每个
    `accumulate` 调用使用不同的 `j` 值。因为这是一个二维循环算法，内部 lambda 是内部循环，外部 lambda 是外部循环：'
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The inner loop part of the Fourier transform is now executed by `std::accumulate`.
    For every `j` position of the algorithm, we calculate the sum of all the summands
    for positions *i = 0...N*. This idea is wrapped into a lambda expression, which
    we will execute for every data point in the resulting Fourier transformation vector:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 傅立叶变换的内部循环部分现在由 `std::accumulate` 执行。对于算法的每个 `j` 位置，我们计算 *i = 0...N* 的所有加数的和。这个想法被包装成一个
    lambda 表达式，我们将为结果傅立叶变换向量中的每个数据点执行它：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'None of the Fourier code has been executed until this point. We only prepared
    a lot of functional code, which we''ll put to action now. An `std::transform`
    call will generate values *j = 0...N*, which is our outer loop. The transformed
    values all go to the vector `t`, which we then return to the caller:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，傅立叶代码还没有执行。我们只是准备了很多功能代码，现在我们将把它们付诸实践。`std::transform` 调用将生成值 *j = 0...N*，这是我们的外部循环。转换后的值都进入向量
    `t`，然后我们将其返回给调用者：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We are going to implement some functions that help us set up function objects
    for signal generation. The first one is a cosine signal generator. It returns
    a lambda expression that can generate a cosine signal with the period length that
    was provided as a parameter. The signal itself can be of arbitrary length, but
    it has a fixed period length. A period length of `N` means that the signal will
    repeat itself after `N` steps. The lambda expression does not accept any parameters.
    We can call it repeatedly, and for every call, it returns us the signal data point
    of the next point in time:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将实现一些函数，帮助我们设置用于信号生成的函数对象。第一个是余弦信号生成器。它返回一个可以生成给定周期长度的余弦信号的 lambda 表达式。信号本身可以是任意长度，但周期长度是固定的。周期长度为
    `N` 意味着信号在 `N` 步之后会重复。lambda 表达式不接受任何参数。我们可以重复调用它，每次调用都会返回下一个时间点的信号数据点：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Another signal we are going to generate is the square wave. It oscillates between
    the values `-1` and `+1` and has no other values than those. The formula looks
    complicated, but it simply transforms the linearly up-counting value `n` to `+1`
    and `-1`, with an oscillating period length of `period_len`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要生成的另一个信号是方波。它在值`-1`和`+1`之间振荡，没有其他值。这个公式看起来很复杂，但它只是将线性递增的值`n`转换为`+1`和`-1`，振荡周期长度为`period_len`。
- en: 'Note that we initialize `n` to a different value from `0` this time. This way,
    our square wave starts at the phase where its output values begin at `+1`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次我们将`n`初始化为与`0`不同的值。这样，我们的方波从其输出值开始于`+1`的相位开始：
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Generating an actual signal from such generators can be achieved by allocating
    a new vector and filling it with the values generated from repeating signal generator
    function calls. The `std::generate` does this job. It accepts a begin/end iterator
    pair and a generator function. For every valid iterator position, it does `*it
    = gen()`. By wrapping this code into a function, we can easily generate signal
    vectors:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这样的生成器生成实际信号可以通过分配一个新向量并用从重复信号生成器函数调用生成的值填充它来实现。`std::generate`完成了这项工作。它接受一个开始/结束迭代器对和一个生成器函数。对于每个有效的迭代器位置，它执行`*it
    = gen()`。通过将这段代码封装到一个函数中，我们可以轻松地生成信号向量：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the end, we need to print the resulting signals. We can simply print a signal
    by copying its values into an output stream iterator, but we need to transform
    the data first because the data points of our signals are complex value pairs.
    At this point, we are only interested in the real value part of every data point;
    hence, we throw it through an `std::transform` call, which extracts only this
    part:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要打印生成的信号。我们可以通过将其值复制到输出流迭代器中来简单地打印信号，但我们需要先转换数据，因为我们的信号数据点是复数值对。在这一点上，我们只对每个数据点的实值部分感兴趣；因此，我们通过`std::transform`调用将其抛出，仅提取这部分：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The Fourier formula is now implemented, but we have no signals to transform
    yet. That is what we do in the main function. Let's first define a standard signal
    length to which all the signals comply.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 傅立叶公式现在已经实现了，但我们还没有要转换的信号。这就是我们在主函数中要做的事情。让我们首先定义一个所有信号都符合的标准信号长度。
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s now generate signals, transform them, and print them, which happens
    in the next three steps. The first step is to generate a cosine signal and a square
    wave signal. Both have the same total signal length and period length:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们生成信号，对它们进行变换并打印它们，这发生在接下来的三个步骤中。第一步是生成余弦信号和方波信号。两者都具有相同的总信号长度和周期长度：
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We have a cosine function and a square wave signal now. In order to generate
    a third one in the middle between them, we take the square wave signal and calculate
    its Fourier transform (saved in the `trans_sqw` vector). The Fourier transform
    of a square wave has a specific form, and we are going to manipulate it a bit.
    All items from index `10` till `(signal_length - 10)` are set to `0.0`. The rest
    remains *untouched*. Transforming this altered Fourier transformation back to
    the signal time representation will give us a different signal. We will see how
    that looks in the end:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了余弦函数和方波信号。为了在它们之间生成第三个信号，我们取方波信号并计算其傅立叶变换（保存在`trans_sqw`向量中）。方波的傅立叶变换具有特定的形式，我们将对其进行一些操作。从索引`10`到`(signal_length
    - 10)`的所有项都设置为`0.0`。其余部分保持不变。将这个改变后的傅立叶变换转换回信号时间表示将给我们一个不同的信号。最后我们将看到它是什么样子的：
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we have three signals: `cosine`, `mid`, and `square_wave`. For every signal,
    we print the signal itself and its Fourier transformation. The output of the whole
    program will consist of six very long lines of printed double value lists:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了三个信号：`cosine`、`mid`和`square_wave`。对于每个信号，我们打印信号本身及其傅立叶变换。整个程序的输出将包括六行非常长的打印的双值列表：
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Compiling and running the program leads to the terminal getting filled with
    lots of numeric values. If we plot the output, we get the following image:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会导致终端被大量的数字值填满。如果我们绘制输出，我们会得到以下图像：
- en: '![](img/e2b5e05b-3c87-44b4-aebd-ada36d752a21.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2b5e05b-3c87-44b4-aebd-ada36d752a21.png)'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This program contains two complicated sections. One is the Fourier transformation
    itself, and the other is the generation of signals with mutable lambda expressions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序包含两个复杂的部分。一个是傅立叶变换本身，另一个是使用可变lambda表达式生成信号。
- en: 'Let''s concentrate on the Fourier transformation first. The core of the raw
    loop implementation (which we did not use for our implementation but had a look
    at in the introduction) looks like the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先专注于傅立叶变换。原始循环实现的核心（我们没有在我们的实现中使用，但在介绍中看过）如下所示：
- en: '[PRE43]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With the STL algorithms, `std::transform` and `std::accumulate`, we wrote code,
    which can be summarized to the following pseudo code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过STL算法`std::transform`和`std::accumulate`，我们编写了代码，可以总结为以下伪代码：
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The result is exactly the same compared with the loop variant. This is arguably
    an example situation where the strict use of STL algorithms does *not* lead to
    better code. Nevertheless, this algorithm implementation is agnostic over the
    data structure choice. It would also work on lists (although that would not make
    too much sense in our situation). Another upside is that the C++17 STL algorithms
    are easy to *parallelize* (which we examine in another chapter of this book),
    whereas raw loops have to be restructured to support multiprocessing (unless we
    use external libraries like *OpenMP* for example, but these do actually restructure
    the loops for us).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与循环变体完全相同。这可以说是一个例子，严格使用STL算法并不会导致更好的代码。尽管如此，这种算法实现对数据结构的选择是不可知的。它也可以在列表上工作（尽管在我们的情况下这没有太多意义）。另一个好处是C++17的STL算法很容易*并行化*（我们将在本书的另一章中进行讨论），而原始循环必须重构以支持多处理（除非我们使用外部库，例如*OpenMP*，但这些实际上为我们重构了循环）。
- en: 'The other complicated part was the signal generation. Let''s have another look
    at `gen_cosine`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个复杂的部分是信号生成。让我们再看一下`gen_cosine`：
- en: '[PRE45]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Each instance of the lambda expression represents a function object that modifies
    its own state on every call. Its state consists of the variables, `period_len`
    and `n`. The `n` variable is the one which is modified on every call. The signal
    has a different value at every time point, and `n++` represents the increasing
    time points. In order to get an actual signal vector out of it, we created the
    helper `signal_from_generator`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每个lambda表达式的实例都代表一个函数对象，它在每次调用时修改自己的状态。它的状态包括变量`period_len`和`n`。`n`变量是在每次调用时修改的变量。信号在每个时间点上都有不同的值，`n++`代表不断增加的时间点。为了从中获得实际的信号向量，我们创建了辅助`signal_from_generator`：
- en: '[PRE46]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This helper allocates a signal vector with a length of choice and calls `std::generate`
    to fill it with data points. For every item of the vector `r`, it calls the function
    object `gen` once, which is just the kind of self-modifying function object we
    can create with `gen_cosine`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个辅助函数分配一个指定长度的信号向量，并调用`std::generate`来填充它的数据点。对于向量`r`的每个项目，它调用函数对象`gen`一次，这正是我们可以使用`gen_cosine`创建的自修改函数对象的类型。
- en: Unfortunately, the STL way does *not* make this code more elegant. As soon as
    the ranges library joins the STL club (which is hopefully the case with C++20),
    this will most probably change.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，STL的方式并没有使这段代码更加优雅。一旦ranges库加入STL俱乐部（希望在C++20中实现），这种情况很可能会改变。
- en: Calculating the error sum of two vectors
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算两个向量的误差和
- en: There are different possibilities to calculate the numerical *error* between
    a target value and an actual value. Measuring the difference between signals consisting
    of many data points usually involves loops and subtraction of corresponding data
    points, and so on.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的可能性来计算目标值和实际值之间的数值*误差*。测量由许多数据点组成的信号之间的差异通常涉及循环和相应数据点的减法等。
- en: 'One simple formula to calculate this error between a signal `a` and a signal
    `b` is the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 计算信号`a`和信号`b`之间的误差的一个简单公式如下：
- en: '![](img/a1db597b-9f14-48c2-bd5f-0a24b3019643.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1db597b-9f14-48c2-bd5f-0a24b3019643.jpg)'
- en: For every *i*, it calculates *a[i] - b[i]*, squares that difference (this way,
    negative and positive differences become comparable), and, finally, sums those
    values up. This is again a situation where one could use a loop, but for fun reasons,
    we will do it with an STL algorithm. The good thing is that we get data-structure
    independence for free this way. Our algorithm will work on vectors and on list-like
    data structures, where no direct indexing is possible.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个*i*，它计算*a[i] - b[i]*，对这个差值进行平方（这样，负数和正数的差异可以进行比较），最后将这些值相加。这又是一个可以使用循环的情况，但出于有趣的原因，我们将使用STL算法来完成。好处是以这种方式获得了数据结构的独立性。我们的算法将适用于向量和类似列表的数据结构，其中不可能进行直接索引。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we are going to create two signals and calculate their error
    sum:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建两个信号并计算它们的误差和：
- en: 'As always, the include statements come first. Then, we declare that we use
    the `std` namespace:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，首先是包含语句。然后，我们声明我们使用`std`命名空间：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We are going to calculate the error sum of two signals. The two signals will
    be a sine wave and a copy of it, but with a different value type--the original
    sine wave is saved in a vector of `double` variables and its copy is saved in
    a vector of `int` variables. Because copying a value from a `double` variable
    to an `int` variable cuts its decimal part after the point, we have some *loss*.
    Let''s name the vector of `double` values `as`, which stands for *analog signal*
    and the vector of `int` values `ds`, which stands for *digital signal*. The error
    sum will then later tell us how large the loss actually is:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将计算两个信号的误差和。两个信号将是正弦波和它的副本，但值类型不同--原始正弦波保存在`double`变量的向量中，其副本保存在`int`变量的向量中。因为将值从`double`变量复制到`int`变量会在小数点后截断其小数部分，我们会有一些*损失*。让我们将`double`值的向量命名为`as`，代表*模拟信号*，将`int`值的向量命名为`ds`，代表*数字信号*。然后，误差和将告诉我们实际损失有多大：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In order to generate a sine wave signal, we implement a little lambda expression
    with a *mutable* counter value `n`. We can call it as often as we want, and for
    every call, it will return us the value for the next point in time of a sine wave.
    The `std::generate` call fills the signal vector with the generated signal, and
    the `std::copy` call copies all the values from the vector of `double` variables
    to the vector of `int` variables afterward:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了生成正弦波信号，我们使用一个带有*mutable*计数器值`n`的小lambda表达式。我们可以随时调用它，每次调用它都会返回正弦波的下一个时间点的值。`std::generate`调用用生成的信号填充信号向量，`std::copy`调用随后将所有`double`变量的值复制到`int`变量的向量中：
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s first print the signals, as this way, they can be plotted later:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打印信号，这样它们以后可以绘制：
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now to the actual error sum, we use `std::inner_product` because it can easily
    be adapted to calculate the difference between every two corresponding elements
    of our signal vectors. It will iterate through both the ranges, pick items at
    the same corresponding positions in the ranges, calculate the difference between
    them, square it, and accumulate the results:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在来看实际的误差和，我们使用`std::inner_product`，因为它可以很容易地适应计算信号向量的每两个对应元素之间的差异。它将遍历两个范围，选择在范围中相应位置的项目，计算它们之间的差异，对其进行平方，并累积结果：
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Compiling and running the program gives us two long lines of signal output
    and a third line, which contains a single output value, which is the error between
    both the signals. The error is `40.889`. If we calculate the error in a continuous
    manner, first for the first pair of items, then for the first two pairs of items,
    then for the first three pairs of items, and so on, then we get the accumulated
    error curve, which is visible on the plotted graph as shown:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会给我们两行信号输出和第三行，其中包含一个单一的输出值，即两个信号之间的误差。误差是`40.889`。如果我们连续计算误差，首先是第一对项目，然后是前两对项目，然后是前三对项目，依此类推，那么我们得到的是累积误差曲线，它在绘制的图表上可见，如下所示：
- en: '![](img/33d6fd3e-c17d-4f36-a4fc-69a3a83d4804.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33d6fd3e-c17d-4f36-a4fc-69a3a83d4804.png)'
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we stuffed the task of looping through two vectors, getting
    the difference between their corresponding values, squaring them, and finally
    summing them up into one `std::inner_product` call. On the way, the only code
    we crafted ourselves was the lambda expression `[](double a, double b) { return
    pow(a - b, 2); }`, which takes the difference of its arguments and squares it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将循环遍历两个向量的任务，获取它们对应值的差异，对它们进行平方，最后将它们加总到一个`std::inner_product`调用中。在这个过程中，我们自己编写的唯一代码是lambda表达式`[](double
    a, double b) { return pow(a - b, 2); }`，它获取其参数的差值并对其进行平方。
- en: 'A glance at a possible implementation of `std::inner_product` shows us why
    and how this works:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对`std::inner_product`可能的实现的一瞥告诉我们为什么以及如何工作：
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The algorithm accepts a pair of begin/end iterators of the first range, and
    another begin iterator of the second range. In our case, they are the vectors
    from which we want to calculate the error sum. The next character is the initial
    value `val`. We have initialized it to `0.0`. Then, the algorithm accepts two
    binary functions, namely `bin_op1` and `bin_op2`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法接受第一个范围的一对begin/end迭代器，以及第二个范围的另一个begin迭代器。在我们的情况下，它们是我们想要计算误差和的向量。下一个字符是初始值`val`。我们将其初始化为`0.0`。然后，该算法接受两个二元函数，即`bin_op1`和`bin_op2`。
- en: At this point, we might realize that this algorithm is really similar to `std::accumulate`.
    The only difference is that `std::accumulate` works on only *one* range. If we
    exchange the `bin_op2(*it1, *it2)` statement with `*it`, then we have basically
    restored the `accumulate` algorithm. We can, therefore, regard `std::inner_product`
    as a version of `std::accumulate` that *zips* a pair of input ranges.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可能意识到这个算法与`std::accumulate`非常相似。唯一的区别是`std::accumulate`只适用于*一个*范围。如果我们用`*it`语句替换`bin_op2(*it1,
    *it2)`，那么我们基本上恢复了`accumulate`算法。因此，我们可以将`std::inner_product`视为`std::accumulate`的一个版本，它*zip*了一对输入范围。
- en: In our case, the *zipper* function is `pow(a - b, 2)`, and that's it. For the
    other function, `bin_op1`, we chose `std::plus<double>` because we want all the
    squares to be summed together.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，*zipper*函数是`pow(a - b, 2)`，就是这样。对于另一个函数`bin_op1`，我们选择了`std::plus<double>`，因为我们希望所有的平方都被加在一起。
- en: Implementing an ASCII Mandelbrot renderer
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现ASCII Mandelbrot渲染器
- en: 'In 1975, the mathematician Benoît Mandelbrot coined the term **fractal**. A
    fractal is a mathematical figure or set, which has certain interesting mathematical
    properties, but in the end, it just looks like a piece of art. Fractals also look
    *infinitely* *repetitive* when being zoomed in. One of the most popular fractals
    is the *Mandelbrot set*, which can be seen on the following poster:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 1975年，数学家Benoît Mandelbrot创造了术语**分形**。分形是一个数学图形或集合，它具有某些有趣的数学特性，但最终看起来就像一件艺术品。当放大时，分形也看起来*无限*
    *重复*。最流行的分形之一是*Mandelbrot集*，可以在以下海报上看到：
- en: '![](img/f18ecb5f-e3af-4184-b68c-1c99bd5cd4c5.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f18ecb5f-e3af-4184-b68c-1c99bd5cd4c5.jpg)'
- en: 'A picture of the Mandelbrot set can be generated by iterating a specific formula:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Mandelbrot集的图像可以通过迭代特定的公式生成：
- en: '![](img/628bf694-e1cc-48c2-a1dd-d110a7d8fa6d.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/628bf694-e1cc-48c2-a1dd-d110a7d8fa6d.jpg)'
- en: The variables *z* and *c* are *complex* numbers. The Mandelbrot set consists
    of all such values of *c* for which the formula *converges* if it is applied often
    enough. This is the colored part of the poster. Some values converge earlier,
    some converge later, so they can be visualized with different colors. Some do
    not converge at all--these are painted black.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 变量*z*和*c*是*复数*。Mandelbrot集由*c*的所有这样的值组成，如果应用足够多次公式，它就会*收敛*。这是海报的彩色部分。一些值会更早地收敛，一些会更晚地收敛，因此它们可以用不同的颜色来可视化。有些根本不会收敛--这些被涂成黑色。
- en: The STL comes with the useful `std::complex` class, and we will try to implement
    the formula without explicit loops, just for the sake of getting to know the STL
    better.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: STL附带有有用的`std::complex`类，我们将尝试实现这个公式，而不使用显式循环，只是为了更好地了解STL。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we are going to print the same image from the wall poster
    as a little piece of ASCII art in the terminal:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在终端中打印与墙海报相同的图像的一小部分ASCII艺术：
- en: 'First, we include all the headers and declare that we use the `std` namespace:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包括所有的头文件，并声明我们使用`std`命名空间：
- en: '[PRE53]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The Mandelbrot set and formula operate on complex numbers. So, we define a type
    alias, `cmplx` to be of class `std::complex`, specializing on double values.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mandelbrot集和公式操作复数。因此，我们定义了一个类型别名`cmplx`，它是`std::complex`类，专门针对双精度值。
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It is possible to hack together all the code for an ASCII Mandelbrot image
    in something around 20 lines of code, but we will implement each logical step
    in a separate form, and then assemble all the steps in the end. The first step
    is implementing a function that scales from integer coordinates to floating point
    coordinates. What we have in the beginning is columns and rows of character positions
    on the terminal. What we want are complex-typed coordinates in the coordinate
    system of the Mandelbrot set. For this, we implement a function that accepts parameters
    that describe the geometry of the user terminal coordinate system, and the system
    we want to transform to. Those values are used to build a lambda expression, which
    is returned. The lambda expression accepts an `int` coordinate and returns a `double`
    coordinate:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以将所有ASCII Mandelbrot图像的代码拼凑在大约20行左右，但我们将分别实现每个逻辑步骤，然后在最后组装所有步骤。第一步是实现一个从整数坐标到浮点坐标的缩放函数。我们一开始在终端上有字符位置的列和行。我们想要的是Mandelbrot集合坐标系中的复数类型坐标。为此，我们实现一个接受描述用户终端坐标系几何形状和我们要转换到的坐标系的参数的函数。这些值用于构建一个lambda表达式，然后返回。lambda表达式接受一个`int`坐标并返回一个`double`坐标：
- en: '[PRE55]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now we can transform points on one dimension, but the Mandelbrot set exists
    in a two-dimensional coordinate system. In order to translate from one `(x, y)`
    coordinate system to another, we combine an x-scaler and a y-scaler and construct
    a `cmplx` instance from their output:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在一维坐标上进行变换，但Mandelbrot集合存在于二维坐标系中。为了从一个`(x, y)`坐标系转换到另一个，我们结合了一个x缩放器和一个y缩放器，并从它们的输出构造了一个`cmplx`实例：
- en: '[PRE56]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After being able to transform coordinates to the right dimensions, we can now
    implement the Mandelbrot formula. The function that we''re implementing now knows
    absolutely nothing about the concept of terminal windows or linear plane transformations,
    so we can concentrate on the Mandelbrot math. We square `z` and add `c` to it
    in a loop until its `abs` value is smaller than `2`. For some coordinates, this
    never happens, so we also break out of the loop if the number of iterations exceeds
    `max_iterations`. In the end, we return the number of iterations we had to do
    until the `abs` value converged:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在能够将坐标转换为正确尺寸之后，我们现在可以实现Mandelbrot公式。我们正在实现的函数绝对不知道终端窗口或线性平面变换的概念，因此我们可以专注于Mandelbrot数学。我们对`z`进行平方并在循环中添加`c`，直到其`abs`值小于`2`。对于某些坐标，这永远不会发生，因此如果迭代次数超过`max_iterations`，我们也会跳出循环。最后，我们返回我们必须进行的迭代次数，直到`abs`值收敛：
- en: '[PRE57]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can now begin with the main function, where we define the terminal dimensions
    and instantiate a function object, `scale`, which scales our coordinate values
    for both axes:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以开始主函数，其中我们定义终端尺寸并实例化一个函数对象`scale`，它为两个轴的坐标值进行缩放：
- en: '[PRE58]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In order to have a one-dimensional iteration over the whole image, we write
    another transformation function that accepts a one-dimensional `i` coordinate.
    It calculates `(x, y)` coordinates from that, based on our assumed line of characters
    width. After breaking `i` down to the row and column numbers, it transforms them
    with our `scale` function and returns the complex coordinate.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了对整个图像进行一维迭代，我们编写另一个转换函数，它接受一个一维`i`坐标。它根据我们假设的字符宽度计算出`(x, y)`坐标。在将`i`分解为行和列号后，它使用我们的`scale`函数进行转换并返回复杂坐标。
- en: '[PRE59]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'What we can do now is transform from one-dimensional coordinates (the `int`
    type), via two-dimensional coordinates (the `(int, int)` type), to Mandelbrot
    set coordinates (the `cmplx` type), and then calculate the number of iterations
    from there (the `int` type again). Let''s combine all that in one function, which
    sets up this call chain for us:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以从一维坐标（`int`类型）通过二维坐标（`(int, int)`类型）转换到Mandelbrot集合坐标（`cmplx`类型），然后从那里计算迭代次数（再次是`int`类型）。让我们将所有这些组合在一个函数中，为我们设置这个调用链：
- en: '[PRE60]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now we can set up all the data. We assume that our resulting ASCII image is
    `w` characters wide and `h` characters high. This can be saved in a one-dimensional
    vector that has `w * h` elements. We fill this vector using `std::iota` with the
    value range, *0 ... (w*h - 1)*. These numbers can be used as an input source for
    our constructed transformation function range, which we just encapsulated in `to_iteration_count`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以设置所有数据。我们假设我们的ASCII图像的宽度为`w`个字符，高度为`h`个字符。这可以保存在一个具有`w * h`个元素的一维向量中。我们使用`std::iota`填充这个向量，其值范围为*0
    ... (w*h - 1)*。这些数字可以作为我们构造的转换函数范围的输入源，我们刚刚封装在`to_iteration_count`中：
- en: '[PRE61]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'That''s basically it. We now have the `v` vector, which we initialized with
    one-dimensional coordinates, but which then got overwritten by Mandelbrot iteration
    counters. From this, we can now print a pretty image. We could just make the terminal
    window `w` characters wide, then we would not need to print line break symbols
    in between. But we can also kind of *creatively misuse* `std::accumulate` to do
    the line breaks for us. The `std::accumulate` uses a binary function to reduce
    a range. We provide it a binary function, which accepts an output iterator (and
    which we will link to the terminal in the next step), and a single value from
    the range. We print this value as a `*` character if the number of iterations
    is higher than 50\. Otherwise, we just print a space character. If we are on a
    *row end* (because the counter variable `n` is evenly divisible by `w`), we print
    a line break symbol:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本上就是这样。我们现在有了`v`向量，我们用一维坐标初始化了它，但后来被Mandelbrot迭代计数器覆盖了。从这里，我们现在可以打印一个漂亮的图像。我们可以将终端窗口设置为`w`个字符宽，然后我们就不需要在中间打印换行符了。但我们也可以*创造性地滥用*`std::accumulate`来为我们做换行。`std::accumulate`使用二进制函数来减少一个范围。我们提供一个二进制函数，它接受一个输出迭代器（我们将在下一步中链接到终端），以及范围中的单个值。如果迭代次数大于50，我们将打印这个值作为`*`字符。否则，我们只打印一个空格字符。如果我们在*行末*（因为计数变量`n`可以被`w`整除），我们打印一个换行符号：
- en: '[PRE62]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'By calling `std:accumulate` on the input range, combined with our binary print
    function and an `ostream_iterator`, we can flush the calculated Mandelbrot set
    out to the terminal window:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在输入范围上调用`std:accumulate`，结合我们的二进制打印函数和`ostream_iterator`，我们可以将计算出的Mandelbrot集刷新到终端窗口：
- en: '[PRE63]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Compiling and running the program leads to the following output, which looks
    like the initial detailed Mandelbrot image, but in a simplified form:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序会产生以下输出，看起来像最初详细的Mandelbrot图像，但是以简化的形式：
- en: '![](img/eb4a8203-0f69-4c38-b98e-213ea3541018.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb4a8203-0f69-4c38-b98e-213ea3541018.png)'
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The whole calculation took part during an `std::transform` call over a one-dimensional
    array:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 整个计算是在一维数组上的`std::transform`调用中进行的：
- en: '[PRE64]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'So, what exactly happened, and why does it work this way? The `to_iteration_count`
    function is basically a call chain from `i_to_xy`, over `scale` to `mandelbrot_iterations`.
    The following diagram illustrates the transformation steps:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，到底发生了什么，为什么会这样工作呢？`to_iteration_count`函数基本上是从`i_to_xy`到`scale`再到`mandelbrot_iterations`的调用链。以下图表说明了转换步骤：
- en: '![](img/cd9a2b82-10aa-4236-b3bd-a087eb34f71f.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd9a2b82-10aa-4236-b3bd-a087eb34f71f.png)'
- en: This way, we can use the index of a one-dimensional array as input, and get
    the number of Mandelbrot formula iterations at the point of the two-dimensional
    plane, which this array point represents. The good thing is that these three transformations
    are completely agnostic about each other. Code with such a separation of concerns
    can be tested very nicely because each component can be tested individually without
    the others. This way, it is easy to find and fix bugs, or just reason about its
    correctness.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以使用一维数组的索引作为输入，并得到该数组点表示的二维平面上Mandelbrot公式迭代的次数。好处是这三个转换完全不知道彼此。具有这种关注点分离的代码可以非常好地进行测试，因为每个组件都可以单独测试，而不受其他组件的影响。这样，很容易找到和修复错误，或者只是推理其正确性。
- en: Building our own algorithm - split
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们自己的算法 - split
- en: In some situations, the existing STL algorithms are not enough. But nothing
    hinders us from implementing our own. Before solving a specific problem, we should
    think about it firmly in order to realize that many problems can be solved in
    generic ways. If we regularly pile up some new library code while solving our
    own problems, then we are also helping our fellow programmers when they have similar
    problems to solve. Key is to know when it is generic enough and when not to go
    for more genericity than needed--else we end up with a new general purpose language.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，现有的STL算法是不够的。但是没有什么能阻止我们实现自己的算法。在解决特定问题之前，我们应该坚决思考一下，以认识到许多问题可以以通用方式解决。如果我们在解决自己的问题时经常堆积一些新的库代码，那么当我们的同行遇到类似的问题时，我们也在帮助他们。关键是要知道何时足够通用，何时不要追求比所需更通用--否则我们最终会得到一个新的通用语言。
- en: In this recipe, we are implementing an algorithm, which we will call `split`.
    It can split any range of items at each occurrence of a specific value, and it
    copies the chunks that result from that into an output range.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在实现一个算法，我们将其称为`split`。它可以在特定值的每次出现时拆分任何项目范围，并将由此产生的块复制到输出范围中。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we are going to implement our own STL-like algorithm called
    `split`, and then we check it out by splitting an example string:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现我们自己的类似STL的算法，称为`split`，然后我们通过拆分示例字符串来检查它：
- en: 'First things first, we include some STL library parts and declare that we use
    the `std` namespace:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包含一些STL库部分，并声明我们使用`std`命名空间：
- en: '[PRE65]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The whole algorithm this section revolves around is `split`. It accepts a begin/end
    pair of input iterators, and an output iterator, which makes it similar to `std::copy`
    or `std::transform` at first. The other parameters are `split_val` and `bin_func`.
    The `split_val` parameter is the value we are searching for in the input range,
    which represents a splitting point at which we cut the input interval. The `bin_func`
    parameter is a function that transforms a pair of iterators that mark the beginning
    and the end of such a split chunk subrange. We iterate through the input range
    using `std::find`, so we jump from occurrence to occurrence of `split_val` values.
    When splitting a long string into its individual words, we would jump from space
    character to space character. On every split value, we stop by to form a chunk
    and feed it into the output range:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一节围绕的整个算法是`split`。它接受一对输入迭代器的开始/结束，并一个输出迭代器，这使它与`std::copy`或`std::transform`类似。其他参数是`split_val`和`bin_func`。`split_val`参数是我们在输入范围中搜索的值，它表示我们切割输入区间的分割点。`bin_func`参数是一个函数，它从一对标记分割块子范围的迭代器开始和结束进行转换。我们使用`std::find`遍历输入范围，因此我们从`split_val`值的出现跳到另一个出现。当将长字符串分割成其各个单词时，我们会从空格字符跳到空格字符。在每个分割值上，我们停下来形成一个块并将其馈送到输出范围中：
- en: '[PRE66]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let''s use the new algorithm. We construct a string that we want to split.
    The item that marks the end of the last chunk, and the beginning of the next chunk,
    shall be the dash character `''-''`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用新的算法。我们构造一个我们想要拆分的字符串。标记最后一个块的结束和下一个块的开始的项目将是破折号字符“'-'”：
- en: '[PRE67]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Whenever the algorithm calls its `bin_func` on a pair of iterators, we want
    to construct a new string from it:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当算法在一对迭代器上调用其`bin_func`时，我们希望从中构造一个新的字符串：
- en: '[PRE68]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The output range will be an `std::list` of strings. We can now call the `split`
    algorithm, which has a similar design compared to all the other STL algorithms:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出范围将是字符串的`std::list`。现在我们可以调用`split`算法，它与所有其他STL算法相比具有类似的设计：
- en: '[PRE69]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In order to see what we got, let''s print the new chunked list of strings:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了看到我们得到了什么，让我们打印新的分块字符串列表：
- en: '[PRE70]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Compiling and running the program yields the following output. It contains
    no dashes anymore and shows that it has isolated the individual words (which are,
    of course, only single characters in our example string):'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生以下输出。它不再包含破折号，并显示它已经隔离了单词（在我们的示例字符串中当然只有单个字符）：
- en: '[PRE71]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: How it works...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `split` algorithm works in a similar manner to `std::transform` because
    it accepts a pair of begin/end iterators of an input range and an output iterator.
    It does something with the input range, which, in the end, results in assignments
    to the output iterator. Apart from that, it accepts an item value called `split_val`
    and a binary function. Let''s revisit the whole implementation to fully understand
    it:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`split`算法的工作方式类似于`std::transform`，因为它接受一个输入范围的起始/结束迭代器对和一个输出迭代器。它对输入范围进行某些操作，最终将结果赋值给输出迭代器。除此之外，它还接受一个名为`split_val`的项目值和一个二元函数。让我们重新审视整个实现以充分理解它：'
- en: '[PRE72]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The loop demands to iterate until the end of the input range. During each iteration,
    an `std::find` call is used to find the next element in the input range, which
    equals to `split_val`. In our case, that element is the dash character (`'-'`)
    because we want to split our input string at all the dash positions. The next
    dash position is now saved in `slice_end`. After the loop iteration, the `it`
    iterator is put on the next item past that split position. This way, the loop
    jumps directly from dash to dash, instead of over every individual item.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 循环要求迭代直到输入范围的末尾。在每次迭代期间，使用`std::find`调用来查找输入范围中下一个等于`split_val`的元素。在我们的情况下，该元素是破折号字符（`'-'`），因为我们想要在所有破折号位置分割我们的输入字符串。下一个破折号位置现在保存在`slice_end`中。循环迭代后，`it`迭代器被放在该分割位置的下一个项目上。这样，循环直接从破折号跳到破折号，而不是每个单独的项目上。
- en: 'In this constellation, the iterator `it` points to the beginning of the last
    slice, while `slice_end` points to the end of the last slice. Both these iterators,
    in combination, mark the beginning and end of the subrange that represents exactly
    one slice between two dash symbols. In a string, `"foo-bar-baz"`, this would mean
    that we have three loop iterations and we get a pair of iterators every time,
    which surround one word. But we do not actually want iterators but `substrings`.
    The binary function, `bin_func`, does just that for us. When we called `split`,
    we gave it the following binary function:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，迭代器`it`指向最后一个切片的开头，而`slice_end`指向最后一个切片的结尾。这两个迭代器结合起来标记了表示两个破折号符号之间的子范围的开始和结束。在字符串`"foo-bar-baz"`中，这意味着我们有三次循环迭代，每次我们得到一对迭代器，围绕着一个单词。但实际上我们不想要迭代器，而是`子字符串`。二元函数`bin_func`正是为我们做这件事。当我们调用`split`时，我们给它了以下二元函数：
- en: '[PRE73]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `split` function throws every pair of iterators through `bin_func`, before
    feeding it into the output iterator. And we actually get string instances out
    of `bin_func`, which results in `"foo"`, `"bar"`, and `"baz"`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`split`函数通过`bin_func`将每对迭代器传递，然后将其输入输出迭代器。实际上，我们从`bin_func`中得到了字符串实例，结果是`"foo"`、`"bar"`和`"baz"`：'
- en: There's more...
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: An interesting alternative to implementing our own algorithm for splitting strings
    would be implementing an *iterator* that does the same. We are not going to implement
    such an iterator at this point, but let's have a brief look at such a scenario.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 实现字符串分割的一个有趣的替代方法是实现一个*迭代器*来完成相同的功能。我们暂时不会实现这样的迭代器，但让我们简要地看一下这种情况。
- en: The iterator would need to jump between delimiters on every increment. Whenever
    it is dereferenced, it needs to create a string object from the iterator positions
    it currently points to, which it could do using a binary function such as `binfunc`,
    which we used before.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器需要在每次增量时在分隔符之间跳跃。每当它被解引用时，它需要从它当前指向的迭代器位置创建一个字符串对象，它可以使用之前使用的`binfunc`这样的二元函数来完成。
- en: 'If we had an iterator class called `split_iterator`, instead of an algorithm
    `split`, the user code would look as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个名为`split_iterator`的迭代器类，而不是一个名为`split`的算法，用户代码将如下所示：
- en: '[PRE74]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The downside of this approach is that implementing an iterator is usually more
    *complicated* than a single function. Also, there are many subtle edges in iterator
    code that can lead to bugs, so an iterator solution needs more tedious testing.
    On the other hand, it is very simple to combine such an iterator with the other
    STL algorithms.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，实现迭代器通常比单个函数更加*复杂*。此外，迭代器代码中有许多微妙的边缘情况可能导致错误，因此迭代器解决方案需要更多的繁琐测试。另一方面，将这样的迭代器与其他STL算法结合起来非常简单。
- en: Composing useful algorithms from standard algorithms - gather
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从标准算法组合有用的算法 - gather
- en: A very nice example for the composability of STL algorithms is `gather`. Sean
    Parent, principal scientist at Adobe Systems at the time, popularized this algorithm
    because it is both useful and short. The way it is implemented, it is the ideal
    poster child for the idea of STL algorithm composition.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: STL算法的可组合性的一个很好的例子是`gather`。当时在Adobe Systems担任首席科学家的Sean Parent因为这个算法既有用又简短而使其广为流传。它的实现方式使它成为STL算法组合理念的理想典范。
- en: The `gather` algorithm operates on ranges of arbitrary item types. It modifies
    the order of the items in such a way that specific items are gathered around a
    specific position, chosen by the caller.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`gather`算法操作任意项目类型的范围。它以特定的方式修改项目的顺序，使特定项目围绕着由调用者选择的特定位置聚集起来。'
- en: How to do it...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we will implement the `gather` algorithm and a bonus variation
    of it. Afterward, we see how it can be put to use:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现`gather`算法以及它的一个额外变体。之后，我们将看看如何使用它：
- en: 'First, we add all the STL include statements. Then, we declare that we use
    the `std` namespace:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加所有的STL包含语句。然后，我们声明我们使用`std`命名空间：
- en: '[PRE75]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `gather` algorithm is a nice example of standard algorithm composition.
    `gather` accepts a begin/end iterator pair, and another iterator `gather_pos`,
    which points somewhere in between. The last parameter is a predicate function.
    Using this predicate function, the algorithm will push all that items that *do*
    satisfy the predicate near the `gather_pos` iterator. The implementation of the
    item movement is done by `std::stable_partition`. The return value of the `gather`
    algorithm is a pair of iterators. These iterators are returned from the `stable_partition`
    calls, and this way, they mark the beginning and the end of the now gathered range:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gather`算法是标准算法组合的一个很好的例子。`gather`接受一个起始/结束迭代器对，以及另一个迭代器`gather_pos`，它指向中间某个位置。最后一个参数是一个谓词函数。使用这个谓词函数，算法将所有满足谓词的项目推到靠近`gather_pos`迭代器的位置。项目移动的实现由`std::stable_partition`完成。`gather`算法的返回值是一对迭代器。这些迭代器是从`stable_partition`调用返回的，这样，它们标记了现在聚集范围的开始和结束：'
- en: '[PRE76]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Another variant of gather is `gather_sort`. It basically works the same way
    as `gather`, but it does not accept a unary predicate function; it accepts a binary
    comparison function instead. This way, it is possible to gather the values near
    `gather_pos`, which appear *smallest* or *largest*:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gather`的另一个变体是`gather_sort`。它基本上与`gather`的工作方式相同，但它不接受一元谓词函数；它接受一个二元比较函数。这样，就可以聚集出现在`gather_pos`附近的*最小*或*最大*的值：'
- en: '[PRE77]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let''s put those algorithms to use. We start with a predicate, which tells
    if a given character argument is the `''a''` character. We construct a string,
    which consists of wildly interleaved `''a''` and `''_''` characters:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把这些算法投入使用。我们首先使用一个谓词，告诉我们给定的字符参数是否是`'a'`字符。我们构造一个字符串，其中包含交错的`'a'`和`'_'`字符：
- en: '[PRE78]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We construct an iterator, which points to the middle of our new string. Let''s
    call `gather` on it and see what happens. The `''a''` characters should be gathered
    around the middle afterward:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们构造一个迭代器，它指向新字符串的中间。让我们在其上调用`gather`，看看会发生什么。之后，`'a'`字符应该被聚集在中间周围：
- en: '[PRE79]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Let''s call `gather` again, but this time, the `gather_pos` iterator is not
    in the middle but the beginning:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次调用`gather`，但这次`gather_pos`迭代器不在中间而是在开头：
- en: '[PRE80]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In a third call, we gather items around the end iterator:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第三次调用中，我们聚集了结束迭代器周围的项目：
- en: '[PRE81]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'With a last call of `gather`, we try to gather all the `''a''` characters around
    the middle again. This will not work as expected, and we will later see why:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一次调用`gather`，我们尝试再次聚集所有`'a'`字符周围的中间位置。这将不会按预期工作，稍后我们将看到原因：
- en: '[PRE82]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We construct another string with underscore characters and some number values.
    On that input sequence, we apply `gather_sort`. The `gather_pos` iterator is the
    middle of the string, and the binary comparison function is `std::less<char>`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用下划线字符和一些数字值构造另一个字符串。在该输入序列上，我们应用`gather_sort`。`gather_pos`迭代器是字符串的中间，二元比较函数是`std::less<char>`：
- en: '[PRE83]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Compiling and running the program yields the following interesting output. The
    first three lines look like expected, but the fourth line looks like `gather`
    did *nothing* to the string.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生以下有趣的输出。前三行看起来像预期的样子，但第四行看起来像`gather`对字符串*没有*做任何操作。
- en: 'In the last line, we can see the result of the `gather_short` function. The
    numbers appear sorted towards either direction:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们可以看到`gather_short`函数的结果。数字朝着任一方向排序：
- en: '[PRE84]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: How it works...
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Initially, the `gather` algorithm is hard to grasp because it is very short
    but has a seemingly complex task. Therefore, let''s step through it:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`gather`算法很难理解，因为它非常简短，但任务似乎很复杂。因此，让我们逐步进行：
- en: '![](img/fcb79a46-e8cb-4732-aee3-ba7818d713d7.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fcb79a46-e8cb-4732-aee3-ba7818d713d7.png)'
- en: The initial state is a range of items, for which we present a predicate function.
    In the diagram, all items for which our predicate function returns `true`, are
    painted in *gray*. The iterators `a` and `c` mark the whole range, and iterator
    `b` points to a *pivot* element. The pivot element is the element around which
    we want to *gather* all the gray items.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始状态是一系列项目，我们为其提供一个谓词函数。在图表中，我们的谓词函数返回`true`的所有项目都以*灰色*绘制。迭代器`a`和`c`标记整个范围，迭代器`b`指向*枢轴*元素。枢轴元素是我们想要*聚集*所有灰色项目的元素周围。
- en: The `gather` algorithm calls `std::stable_partition` on the range `[a, b)` and
    while doing that, it uses a *negated* version of the predicate. It negates the
    predicate because `std::stable_partition` moves all items for which the predicate
    returns `true` to the *front*. We want exactly the *opposite* to happen.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gather`算法在范围`[a，b)`上调用`std::stable_partition`，在执行此操作时，它使用谓词的*否定*版本。它否定谓词，因为`std::stable_partition`将谓词返回`true`的所有项目移动到*前面*。我们希望发生*相反*的情况。'
- en: Another `std::stable_partition` call is done but, this time, on the range, `[b,
    c)`, and *without* negating the predicate. The gray items are moved to the front
    of the input range, which means they are all moved towards the pivot element pointed
    at by `b`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个`std::stable_partition`调用被执行，但这次是在范围`[b，c)`上，并且*不*否定谓词。灰色项目被移动到输入范围的前面，这意味着它们都朝着被`b`指向的枢轴元素移动。
- en: The items are now gathered around `b` and the algorithm returns iterators to
    the beginning and the end of the now consecutive range of gray items.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在项目围绕`b`聚集，算法返回迭代器，指向现在连续的灰色项目的开始和结束。
- en: We called `gather` multiple times on the same range. At first, we gathered all
    the items around the middle of the range. Then we gathered the items around `begin()`
    and then around `end()` of the range. These cases are interesting because they
    always lead *one* of the `std::stable_partition` calls to operate on an *empty*
    range, which results in *no action*.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在相同的范围上多次调用`gather`。起初，我们聚集了范围中间的所有项目。然后我们聚集了范围的`begin()`周围，然后是范围的`end()`周围。这些情况很有趣，因为它们总是导致*一个*`std::stable_partition`调用在*空*范围上操作，这导致*没有动作*。
- en: We did the last call to gather again with the parameters `(begin, end, middle)`
    of the range, and that did not work. Why? At first, this looks like a bug, but
    actually, it is not.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用范围的参数`(begin, end, middle)`对`gather`进行最后一次调用，但没有起作用。为什么？乍一看，这似乎是一个错误，但实际上并不是。
- en: Imagine the character range, `"aabb"`, together with a predicate function, `is_character_a`,
    which is only true for the `'a'` items--if we call it with a third iterator pointing
    to the middle of the character range, we would observe the same *bug*. The reason
    is that the first `stable_partition` call would operate on the subrange, `"aa"`,
    and the other `stable_partition` call operates on the range, `"bb"`. This series
    of calls cannot result in `"baab"`, which we initially naively hoped.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下字符范围`"aabb"`，以及一个谓词函数`is_character_a`，它只对`'a'`项为真--如果我们用一个指向字符范围中间的第三个迭代器调用它，我们会观察到相同的*错误*。原因是第一个`stable_partition`调用将在子范围`"aa"`上操作，而另一个`stable_partition`调用将在范围`"bb"`上操作。这一系列的调用不能导致最初我们天真地希望的`"baab"`。
- en: In order to get what we want in the last case, we could use `std::rotate(begin,
    begin + 1, end);`
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在最后一种情况下得到我们想要的结果，我们可以使用`std::rotate(begin, begin + 1, end);`
- en: The `gather_sort` modification is basically the same as `gather`. The only difference
    is that it does not accept a unary *predicate* function but a binary *comparison*
    function, just like `std::sort`. And instead of calling `std::stable_partition`
    twice, it calls `std::stable_sort` twice.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`gather_sort`修改基本上与`gather`相同。唯一的区别是它不接受一个一元的*谓词*函数，而是一个二元的*比较*函数，就像`std::sort`一样。而且它不是调用`std::stable_partition`两次，而是调用`std::stable_sort`两次。'
- en: The negation of the comparison function cannot be done with `not_fn`, just like
    we did in the `gather` algorithm because `not_fn` does not work on binary functions.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 比较函数的否定不能使用`not_fn`来完成，就像我们在`gather`算法中所做的那样，因为`not_fn`不能用于二元函数。
- en: Removing consecutive whitespace between words
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除单词之间的连续空格
- en: Because strings are often read from user input, they may contain wild formatting
    and often need to be sanitized. One example of this is strings containing too
    many whitespace.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字符串通常是从用户输入中读取的，它们可能包含狂野的格式，通常需要被清理。其中一个例子是包含太多空格的字符串。
- en: In this section, we will implement a slick whitespace filtering algorithm, which
    removes excess whitespace from strings but leaves single whitespace characters
    untouched. We call that algorithm `remove_multi_whitespace`, and its interface
    will look very STL-like.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个巧妙的空格过滤算法，它从字符串中删除多余的空格，但保留单个空格字符。我们称这个算法为`remove_multi_whitespace`，它的接口看起来非常类似STL。
- en: How to do it...
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we will implement the `remove_multi_whitespace` algorithm
    and check out how it works:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现`remove_multi_whitespace`算法并查看它是如何工作的：
- en: 'As always, we do some includes first and then declare that we use the `std`
    namespace by default:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，我们首先进行一些包含，然后声明我们默认使用`std`命名空间：
- en: '[PRE85]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We implement a new STL-style algorithm called `remove_multi_whitespace`. This
    algorithm removes clustered occurrences of whitespace, but no single spaces. This
    means that a string line `"a b"` stays unchanged, but a string like
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了一个新的STL风格的算法，称为`remove_multi_whitespace`。这个算法删除了空格的聚集出现，但不删除单个空格。这意味着字符串`"a
    b"`保持不变，但像`"a b"`这样的字符串
- en: '`"a b"` is shrunk to `"a b"`. In order to accomplish this, we use `std::unique`
    with a custom binary predicate function. The `std::unqiue` walks through an iterable
    range and always looks at consecutive pairs of payload items. Then it asks the
    predicate functions whether two items are equal. If they are, then `std::unique`
    removes one of them. Afterward, the range does not contain subranges with equal
    items sitting next to each other. Predicate functions that are usually applied
    in this context tell whether two items are equal. What we do, is give `std::unique`
    a predicate, which tells if there are two consecutive *spaces* in order to get
    those removed. Just like `std::unique`, we accept a pair of begin/end iterators,
    and then return an iterator pointing to the new end of the range:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`"a b"`被缩减为`"a b"`。为了实现这一点，我们使用了一个自定义的二元谓词函数来调用`std::unique`。`std::unique`遍历一个可迭代范围，并总是查看连续的负载项对。然后它询问谓词函数两个项是否相等。如果是，那么`std::unique`会删除其中一个。之后，范围不再包含相邻的相等项的子范围。通常在这种情况下应用的谓词函数告诉两个项是否相等。我们所做的是给`std::unique`一个谓词，它告诉是否有两个连续的*空格*，以便将它们删除。就像`std::unique`一样，我们接受一对begin/end迭代器，然后返回一个指向范围新结尾的迭代器：'
- en: '[PRE86]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'That is already it. Let''s construct a string that contains some unnecessary
    whitespace:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样了。让我们构造一个包含一些不必要空格的字符串：
- en: '[PRE87]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, we use the *erase-remove idiom* on the string in order to get rid of the
    excess whitespace characters:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用*erase-remove idiom*来处理字符串，以摆脱多余的空格字符：
- en: '[PRE88]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Compiling and running the program yields the following output:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生以下输出：
- en: '[PRE89]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: How it works...
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We solved the whole complexity of the problem without any loop or manual comparison
    of items. We only provided a predicate function, which tells if two given characters
    are *whitespace* characters. Then we fed that predicate into `std::unique` and
    *poof*, all the excess whitespace vanished. While this chapter also contains some
    recipes where we had to fight a bit more to express our programs with STL algorithms,
    this algorithm is a *really* nice and short example.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解决了问题的整个复杂性，没有任何循环或手动比较项目。我们只提供了一个谓词函数，告诉我们给定的两个字符是否是*空格*字符。然后我们将该谓词输入到`std::unique`中，*噗*，所有多余的空格都消失了。虽然本章还包含一些我们必须更努力地使用STL算法来表达我们的程序的示例，但这个算法是一个*真正*好的、简短的例子。
- en: 'How does this interesting combination work in detail? Let''s have a look at
    a possible implementation of `std::unique` first:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有趣的组合是如何详细工作的呢？让我们首先看一下`std::unique`的可能实现：
- en: '[PRE90]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The loop steps over the range items, while they do not satisfy the predicate
    condition. At the point where an item satisfies the predicate, it moves such an
    item one item past the old position, where the predicate fired the last time.
    The version of `std::unique` that does not accept an additional predicate function
    checks whether two neighbor items are equal. This way, it wipes out *repeated*
    characters as it can , for example, transform `"abbbbbbc"` to `"abc"`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 循环遍历范围项，直到它们不满足谓词条件。在满足谓词的位置，它将这样的项移动到上一次触发谓词的旧位置之后的一个项。不接受额外谓词函数的`std::unique`版本检查两个相邻项是否相等。这样，它可以，例如，将`"abbbbbbc"`转换为`"abc"`，从而消除*重复*字符。
- en: What we want is not wiping out *all* characters which are repetitive, but repetitive
    *whitespace*. Therefore, our predicate does not say *"both argument characters
    are equal"*, but "*both argument characters are whitespace characters"*.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的不是清除*所有*重复的字符，而是重复的*空格*。因此，我们的谓词不是说“两个参数字符相等”，而是“两个参数字符都是空格字符”。
- en: 'One last thing to note is that neither `std::unique` nor `remove_multi_whitespace`
    really removes character items from the underlying string. They only move characters
    within the string according to their semantics and tell where its new end is.
    The removal of all now-obsolete characters from the new end till the old end must
    still be done. This is why we wrote the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是，`std::unique`和`remove_multi_whitespace`都不会真正从基础字符串中删除字符项。它们只是根据语义在字符串中移动字符，并告诉它的新结尾在哪里。必须仍然删除从新结尾到旧结尾的所有现在过时的字符。这就是为什么我们写了以下内容：
- en: '[PRE91]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This adheres to the *erase-remove* idiom, which we already know from vectors
    and lists.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循*擦除-移除*惯用法，我们已经从向量和列表中了解到。
- en: Compressing and decompressing strings
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压缩和解压缩字符串
- en: This section deals with a relatively popular task in coding interviews. The
    basic idea is a function, which takes a string like `"aaaaabbbbbbbccc"` and transforms
    it to a shorter string `"a5b7c3"`. It is `"a5"` because there are five `'a'` characters.
    And then it is `"b7"` because there are seven `'b'` characters. This is a very
    simple *compression* algorithm. For normal text, it is of reduced utility because
    normal language is usually not so repetitive that its text representation would
    become shorter with this compression scheme. However, it is relatively easy to
    implement even if we have to do it on a whiteboard without a computer. The tricky
    part is that it is easy to write a buggy code if the program is not structured
    very well from the beginning. Dealing with strings is generally not a hard thing,
    but the chances of implementing buffer overflow bugs lurk around *a lot* here
    if legacy C-style formatting functions are used.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分涉及编码面试中相对流行的任务。基本思想是一个函数，它接受一个字符串，比如`"aaaaabbbbbbbccc"`，并将其转换为一个更短的字符串`"a5b7c3"`。它是`"a5"`，因为有五个`'a'`字符。然后是`"b7"`，因为有七个`'b'`字符。这是一个非常简单的*压缩*算法。对于普通文本来说，它的效用减少了，因为正常语言通常不会重复到使其文本表示使用这种压缩方案变得更短。然而，即使我们不得不在白板上手动实现，它相对容易实现。棘手的部分是，如果程序一开始的结构不是很好，很容易编写有bug的代码。处理字符串通常不是一件难事，但是如果使用了传统的C风格格式化函数，那么在这里实现缓冲区溢出错误的机会就会*很多*。
- en: Let's try an STL approach to implementing string compression and decompression
    using this simple scheme.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用这种简单方案来实现字符串压缩和解压缩的STL方法。
- en: How to do it...
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this section, we will implement simple `compress` and `decompress` functions
    for strings:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将为字符串实现简单的`compress`和`decompress`函数：
- en: 'We include some STL libraries first, then we declare that we use the `std`
    namespace:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们包括一些STL库，然后声明我们使用`std`命名空间：
- en: '[PRE92]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'For our cheap compression algorithm, we try to find chunks of text containing
    ranges of the same characters, and we compress those individually. Whenever we
    start at one string position, we want to find the first position where it contains
    a different character. We use `std::find` to find the first character in the range,
    which is different than the character at the current position. Afterward, we return
    a tuple containing an iterator to that first different item, the character variable
    `c`, which fills the range at hand, and the number of occurrences that this subrange
    contains:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的廉价压缩算法，我们试图找到包含相同字符范围的文本块，并单独压缩它们。每当我们从一个字符串位置开始时，我们希望找到包含不同字符的第一个位置。我们使用`std::find`来找到范围中第一个与当前位置的字符不同的字符。之后，我们返回一个元组，其中包含指向第一个不同项的迭代器，填充当前范围的字符变量`c`，以及此子范围包含的出现次数：
- en: '[PRE93]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `compress` algorithm continuously calls the `occurrences` function. This
    way, we jump from one same character group to another. The `r << c << n` line
    pushes the character into the output stream and then the number of occurrences
    it has in this part of the input string. The output is a string stream that automatically
    grows with our output. In the end, we return a string object from it, which contains
    the compressed string:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`compress`算法不断调用`occurrences`函数。这样，我们从一个相同的字符组跳到另一个字符组。`r << c << n`行将字符推入输出流，然后是它在输入字符串的这一部分中的出现次数。输出是一个自动随着输出增长的字符串流。最后，我们从中返回一个字符串对象，其中包含压缩后的字符串：'
- en: '[PRE94]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `decompress` method works similarly, but it is much simpler. It continuously
    tries to get a character value out of the input stream and, then, the following
    number. From those two values, it can construct a string containing the character
    as often as the number says. In the end, we again return a string from the output
    stream. By the way, this `decompress` function is *not safe*. It can be exploited
    easily. Can you guess, how? We will have a look at this problem later:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`decompress`方法的工作方式类似，但更简单。它不断尝试从输入流中获取字符值，然后获取接下来的数字。根据这两个值，它可以构造一个包含字符的字符串，次数由数字表示。最后，我们再次从输出流返回一个字符串。顺便说一下，这个`decompress`函数是*不安全*的。它很容易被利用。你能猜到怎么做吗？我们稍后会看一下这个问题：'
- en: '[PRE95]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In our main function, we construct a simple string with a lot of repetition,
    on which the algorithm works very well. Let''s print the compressed version, and
    then the compressed and again decompressed version. In the end, we should get
    the same string as we initially constructed:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的主函数中，我们构造了一个有很多重复的简单字符串，算法在这个字符串上运行得非常好。让我们打印压缩版本，然后是压缩和再次解压缩版本。最后，我们应该得到与最初构造的相同的字符串：
- en: '[PRE96]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Compiling and running the program yields the following output:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译和运行程序产生以下输出：
- en: '[PRE97]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: How it works...
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: 'This program basically revolves around two functions: `compress` and `decompress`.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序基本上围绕着两个函数：`compress`和`decompress`。
- en: 'The decompress function is really simple because it only consists of variable
    declarations, a line of code, which actually does something, and the following
    return statement. The code line which does something is the following one:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 解压函数非常简单，因为它只包括变量声明、一行实际执行操作的代码和接下来的返回语句。实际执行操作的代码行是以下代码：
- en: '[PRE98]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: It continuously reads the character, `c`, and the counter variable, `n`, out
    of the string stream, `ss`. The `stringstream` class hides a lot of string parsing
    magic from us at this point. While that succeeds, it constructs a decompressed
    string chunk into the string stream, from which the final result string can be
    returned back to the caller of `decompress`. If `c = 'a'` and `n = 5`, the expression
    `string(n, c)` will result in a string with the content, `"aaaaa"`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 它不断地从字符串流`ss`中读取字符`c`和计数器变量`n`。此时，`stringstream`类为我们隐藏了很多字符串解析的魔法。当这成功时，它将构造一个解压后的字符串块到字符串流中，从中可以将最终结果字符串返回给`decompress`的调用者。如果`c
    = 'a'`且`n = 5`，表达式`string(n, c)`将得到一个内容为"aaaaa"的字符串。
- en: 'The compress function is more complex. We also wrote a little helper function
    for it. We called that helper function `occurences`. So, let''s first have a glance
    at `occurrences`. The following diagram shows how it works:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩函数更复杂。我们还为它编写了一个小的辅助函数。我们称这个辅助函数为`occurences`。所以，让我们先看一下`occurrences`。以下图表显示了它的工作原理：
- en: '![](img/888717aa-d626-4a9c-a675-414518c45197.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/888717aa-d626-4a9c-a675-414518c45197.png)'
- en: 'The `occurences` function accepts two parameters: an iterator pointing to the
    beginning of a character sequence within a range and the end iterator of that
    range. Using `find_if`, it finds the first character that is different from the
    character initially being pointed at. In the diagram, this is the iterator, `diff`.
    The difference between that new position and the old iterator position is the
    number of equal items (`diff - it` equals **6** in the diagram). After calculating
    this information, the `diff` iterator can be reused in order to execute the next
    search. Therefore, we pack `diff`, the character of the subrange, and the length
    of the subrange into a tuple and return it.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`occurences`函数接受两个参数：指向范围内字符序列开头的迭代器和该范围的结束迭代器。使用`find_if`，它找到第一个与最初指向的字符不同的字符。在图表中，这是迭代器`diff`。新位置和旧迭代器位置之间的差异就是相等项的数量（在图表中，`diff
    - it`等于**6**）。计算出这些信息后，`diff`迭代器可以被重用以执行下一次搜索。因此，我们将`diff`、子范围的字符和子范围的长度打包到一个元组中并返回它。'
- en: 'With the information lined up like this, we can jump from subrange to subrange
    and push the intermediate results into the compressed target string:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 将信息排列如此，我们可以从子范围跳到子范围，并将中间结果推入压缩目标字符串中：
- en: '[PRE99]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: There's more...
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In step 4, we mentioned that the `decompress` function is not safe. Indeed,
    it can easily be *exploited*.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们提到`decompress`函数是不安全的。的确，它很容易被*利用*。
- en: 'Imagine the following input string: `"a00000"`. Compressing it will result
    in the substring `"a1"` because there is only one character, `''a''`. That is
    followed by five times `''0''`, which will result in `"05"`. Together, this results
    in the compressed string `"a105"`. Unfortunately, this compressed string says
    *"105 times the character `''a''`"*. This has nothing to do with our initial input
    string. Even worse, if we decompress it, we get from a six-character string to
    a 105-character string. Imagine the same with larger numbers--the user can easily
    *blow up* our heap usage because our algorithm is not prepared for such inputs.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下以下输入字符串："a00000"。压缩它将导致子字符串"a1"，因为只有一个字符'a'。接下来是五次'0'，这将导致"05"。这样，压缩后的字符串就是"a105"。不幸的是，这个压缩后的字符串表示"字符'a'出现105次"。这与我们最初的输入字符串无关。更糟糕的是，如果我们解压它，从一个六个字符的字符串变成一个105个字符的字符串。想象一下数字更大的情况——用户很容易就能够使我们的堆使用量*爆炸*，因为我们的算法没有准备好处理这样的输入。
- en: In order to prevent this, the `compress` function could, for example, reject
    input with numbers, or it could mask them in a special way. And the `decompress`
    algorithm could take another conditional, which puts an upper bound on the resulting
    string size. I am leaving this as an exercise for you.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，`compress`函数可以，例如，拒绝带有数字的输入，或者可以以特殊方式掩盖它们。`decompress`算法可以采取另一个条件，对结果字符串大小设置一个上限。我把这留给你作为练习。
