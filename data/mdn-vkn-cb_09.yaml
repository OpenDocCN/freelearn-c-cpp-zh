- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Debugging and Performance Measurement Techniques
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和性能测量技术
- en: Debugging failures and reverse engineering an implementation, as well as measuring
    the performance of a system once it has been authored, are as important as writing
    new code. Vulkan is a vast and complicated API and, more than ever, knowing how
    to debug it is paramount. In this chapter, we will explore several recipes on
    how to debug and inspect your implementation. We will also demonstrate how to
    measure the performance of your implementation once you can display an image onscreen.
    After all, graphics programming is all about extracting the last drop of performance
    from the hardware and Vulkan was designed to help you do just that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 调试失败和逆向工程实现，以及测量系统一旦编写完成后的性能，与编写新代码一样重要。Vulkan是一个庞大而复杂的API，而且比以往任何时候都更需要知道如何调试它。在本章中，我们将探讨几个关于如何调试和检查你的实现的方法。我们还将演示如何在屏幕上显示图像后如何测量你的实现性能。毕竟，图形编程的全部内容都是从硬件中提取最后一滴性能，而Vulkan就是为了帮助你做到这一点而设计的。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Frame debugging
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帧调试
- en: Naming Vulkan objects for easy debugging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为方便调试命名Vulkan对象
- en: Printing values from shaders in Vulkan
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Vulkan中从着色器打印值
- en: Intercepting validation layer messages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 截获验证层消息
- en: Retrieving debug information from shaders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从着色器检索调试信息
- en: Measuring performance in Vulkan with timestamp queries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用时间戳查询在Vulkan中测量性能
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need to make sure you have VS 2022 installed along
    with the Vulkan SDK. Please revisit [*Chapter 1*](B18491_01.xhtml#_idTextAnchor019)*,
    Vulkan Core Concepts*, under the *Technical requirements* section for details
    on setting up. Additionally, you will need RenderDoc and Tracy for this chapter.
    The steps to download and install these tools will be provided in the corresponding
    recipes within this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一章，你需要确保你已经安装了VS 2022以及Vulkan SDK。请查阅**第1章**[*技术要求*](B18491_01.xhtml#_idTextAnchor019)部分下的**Vulkan核心概念**，以获取设置细节。此外，你还需要RenderDoc和Tracy来编写这一章。下载和安装这些工具的步骤将在本章相应的菜谱中提供。
- en: Frame debugging
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帧调试
- en: Capturing and replaying a frame is very important for debugging graphics applications.
    Different than a live capture, in which results are captured and displayed as
    your application is running, capturing means recording all the commands sent to
    the GPU along with their data. This includes all the draw calls, shaders, textures,
    buffers, and other resources used to render the frame. Replaying a frame means
    executing those recorded commands again. Frame replay is a powerful feature for
    debugging because it allows developers to closely examine the rendering process,
    step by step, and see exactly what’s happening at each stage. If a bug or graphical
    glitch occurs, frame replay can help pin down exactly where and why it’s happening.
    There are multiple tools for frame debugging, such as RenderDoc, PIX, NVIDIA’s
    Nsight Graphics, and AMD Radeon GPU Profiler.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获和回放帧对于调试图形应用程序非常重要。与实时捕获不同，实时捕获是在应用程序运行时捕获并显示结果，而捕获意味着记录发送到GPU的所有命令及其数据。这包括所有绘制调用、着色器、纹理、缓冲区以及其他用于渲染帧的资源。回放帧意味着再次执行这些记录的命令。帧回放是调试的一个强大功能，因为它允许开发者逐步仔细检查渲染过程，并确切地看到每个阶段发生的情况。如果出现错误或图形故障，帧回放可以帮助确定错误发生的确切位置和原因。有多种帧调试工具，如RenderDoc、PIX、NVIDIA的Nsight
    Graphics和AMD Radeon GPU Profiler。
- en: In this recipe, we will focus on how to use **RenderDoc** since it is open source,
    cross-platform, and works on almost all GPUs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将重点关注如何使用**RenderDoc**，因为它开源、跨平台，并且几乎在所有GPU上都能工作。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As a first step, you need to download RenderDoc from [https://renderdoc.org/builds](https://renderdoc.org/builds).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，你需要从[https://renderdoc.org/builds](https://renderdoc.org/builds)下载RenderDoc。
- en: 'RenderDoc’s UI contains the following main components:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: RenderDoc的UI包含以下主要组件：
- en: '**Timeline**: This is typically found on the top row of RenderDoc’s user interface.
    The timeline provides a graphical representation of all the API calls (events)
    that occurred during the frame you’ve captured. It’s color-coded to indicate different
    types of events (such as draw calls or compute dispatches), making it easy to
    get a high-level overview of what’s happening in your frame. You can select any
    event in the timeline to view more detailed information in **Event Browser** (on
    the left side of the UI) and the various tabs on the right side of the UI.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间线**：通常位于RenderDoc用户界面的顶部行。时间线提供了您捕获的帧中发生的所有API调用（事件）的图形表示。它使用颜色编码来指示不同类型的事件（如绘制调用或计算调度），这使得您能够轻松地获得帧中发生情况的总体概述。您可以在时间线中选择任何事件，在UI左侧的**事件浏览器**和UI右侧的各个选项卡中查看更多详细信息。'
- en: '**Event Browser**: Located on the left side of the UI, **Event Browser** provides
    a detailed, hierarchical view of all the events in your frame. It shows the order
    of the API calls and allows you to navigate through them easily. When you select
    an event in **Event Browser**, RenderDoc will highlight the corresponding event
    in the timeline and update the tabs on the right side of the UI with information
    related to that event.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件浏览器**：位于UI的左侧，**事件浏览器**提供了您帧中所有事件的详细、分层视图。它显示了API调用的顺序，并允许您轻松地浏览它们。当您在**事件浏览器**中选择一个事件时，RenderDoc将在时间线中突出显示相应的事件，并更新UI右侧的选项卡，以显示与该事件相关的信息。'
- en: '**Tabs** (**Texture Viewer**, **Mesh Viewer**, **Pipeline State**, and so on):
    These tabs are found on the right side of the UI, and they provide detailed information
    about the currently selected event. Each tab focuses on a different aspect of
    the rendering process:'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项卡**（**纹理查看器**、**网格查看器**、**管线状态**等）：这些选项卡位于UI的右侧，并提供有关当前选中事件的详细信息。每个选项卡都专注于渲染过程中的不同方面：'
- en: '**Texture Viewer**: This tab allows you to view all of the textures that are
    used in your frame. You can inspect each texture’s properties, visualize their
    contents, and see how they are used in your shaders.'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理查看器**：此选项卡允许您查看您的帧中使用的所有纹理。您可以检查每个纹理的属性，可视化其内容，并查看它们在您的着色器中的使用方式。'
- en: '**Mesh Viewer**: This tab provides a visual and numerical view of the vertex
    and index buffers used by a draw call. You can inspect the raw buffer data, view
    the resulting geometry, and see how the vertices are transformed by your vertex
    shader.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格查看器**：此选项卡提供了对由绘制调用使用的顶点和索引缓冲区的视觉和数值视图。您可以检查原始缓冲区数据，查看生成的几何形状，并查看顶点如何通过您的顶点着色器进行变换。'
- en: '**Pipeline State**: This tab shows the complete state of the GPU pipeline for
    the selected event. You can see all the bound resources (such as buffers and textures),
    inspect the shaders being used, and view the configuration of the various pipeline
    stages.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管线状态**：此选项卡显示了所选事件的GPU管线完整状态。您可以看到所有已绑定资源（如缓冲区和纹理），检查正在使用的着色器，并查看各个管线阶段的配置。'
- en: '*Figure 9**.1* shows RenderDoc’s main UI elements with a captured frame opened
    for inspection.'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图9**.1*显示了带有打开用于检查的捕获帧的RenderDoc主UI元素。'
- en: '![Figure 9.1 – RenderDoc main screen](img/B18491_09_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – RenderDoc主屏幕](img/B18491_09_01.jpg)'
- en: Figure 9.1 – RenderDoc main screen
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – RenderDoc主屏幕
- en: In the next section, we will demonstrate how to use RenderDoc using executables
    from [*Chapter 1*](B18491_01.xhtml#_idTextAnchor019), *Vulkan Core Concepts*,
    and [*Chapter 3*](B18491_03.xhtml#_idTextAnchor217), *Implementing* *GPU-Driven
    Rendering*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将演示如何使用来自[*第1章*](B18491_01.xhtml#_idTextAnchor019)，*Vulkan核心概念*和[*第3章*](B18491_03.xhtml#_idTextAnchor217)，*实现*
    *GPU驱动渲染*的执行文件使用RenderDoc。
- en: How to do it…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Capturing a frame (or frames) with RenderDoc can be done programmatically or
    interactively, using the user interface. The next steps will explain how to capture
    frames from your application using RenderDoc’s user interface:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RenderDoc捕获帧（或多个帧）可以通过编程方式或交互方式完成，使用用户界面。以下步骤将解释如何使用RenderDoc的用户界面从您的应用程序中捕获帧：
- en: As a first step, you can launch the application by selecting the application
    to launch in the **Launch Application** tab. Once the application is launched,
    click **Capture Frame(s) Immediately**. This will capture the current frame of
    the application, which we can inspect. Once the frame is captured, double-clicking
    it will open it for inspection. You can also save the frame on disk to open it
    later.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，你可以在**启动应用程序**标签中选择要启动的应用程序。一旦应用程序启动，点击**立即捕获帧(s**)。这将捕获应用程序的当前帧，我们可以检查它。一旦捕获了帧，双击它将打开它以进行检查。你还可以将帧保存到磁盘上以供以后打开。
- en: After the capture, we can select the draw call in `vkCmdDraw` (EID 7). Once
    you select it, you will see all the input and output textures used by this draw
    call in the **Texture Viewer** tab as depicted in *Figure 9**.2*.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在捕获之后，我们可以在 `vkCmdDraw` (EID 7) 中选择绘制调用。一旦选择，你将在**纹理查看器**标签中看到此绘制调用所使用的所有输入和输出纹理，如图
    *图 9.2* 所示。
- en: When you’re interested in exploring the mesh data, the **Mesh Viewer** tab is
    your go-to tool. This feature provides a comprehensive view of both input and
    output vertex data, offering a deeper understanding of how your mesh is structured.
    Let’s say a specific vertex is giving you trouble, or you simply want to understand
    its behavior better. To achieve this, you need to select the vertex in question.
    A right-click will then reveal an option named **Debug this vertex**. Selecting
    this option will lead you to the vertex shader that was used in rendering your
    mesh. Note that the shader’s source code will only be available if the SPIR-V
    has been generated with debug symbols.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你对探索网格数据感兴趣时，**网格查看器**标签是你的首选工具。此功能提供了对输入和输出顶点数据的全面视图，有助于更深入地理解你的网格结构。假设有一个特定的顶点让你感到困扰，或者你只是想更好地理解其行为。为了实现这一点，你需要选择相关的顶点。然后右键单击将显示一个名为**调试此顶点**的选项。选择此选项将带你到渲染你的网格所使用的顶点着色器。请注意，着色器的源代码只有在
    SPIR-V 生成时带有调试符号才会可用。
- en: '![Figure 9.2 – RenderDoc Texture Viewer](img/B18491_09_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – RenderDoc 纹理查看器](img/B18491_09_02.jpg)'
- en: Figure 9.2 – RenderDoc Texture Viewer
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – RenderDoc 纹理查看器
- en: The **Pipeline State** tab is a crucial component in the RenderDoc UI. It offers
    an extensive view of the various stages, and their states, involved in the graphics
    pipeline, serving as a powerful tool for analyzing and debugging your rendering
    process. In the vertex shader stage, you can inspect the operations applied to
    each vertex. This includes transformations to position vertices in the correct
    3D space, as well as calculations to determine vertex colors or texture coordinates.
    You can also select V**iew** S**hader** to inspect the shader source code used
    during this draw call. Moving on to the fragment shader stage, the **Pipeline
    State** tab allows you to scrutinize how each fragment (potential pixel) is processed.
    This includes operations such as determining its final color based on lighting,
    texture, and/or other factors. Debugging this stage can help you resolve issues
    related to color computations, texture mapping, and more.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**管线状态**标签是 RenderDoc UI 中的关键组件。它提供了对图形管线中各个阶段及其状态的广泛视图，作为分析调试渲染过程的有力工具。在顶点着色器阶段，你可以检查应用于每个顶点的操作。这包括将顶点定位在正确的
    3D 空间中的变换，以及确定顶点颜色或纹理坐标的计算。你还可以选择**视图着色器**来检查在此绘制调用期间使用的着色器源代码。继续到片段着色器阶段，**管线状态**标签允许你仔细检查每个片段（潜在的像素）是如何处理的。这包括基于光照、纹理和/或其它因素确定其最终颜色的操作。调试此阶段可以帮助你解决与颜色计算、纹理映射等问题相关的问题。'
- en: To debug a specific fragment, you’ll need to select a pixel in **Texture Viewer**.
    You can do this by clicking on the pixel you’re interested in. The values of this
    pixel represent the output of the fragment shader for that specific pixel. After
    selecting a pixel, you can debug the fragment shader that produced it. To do this,
    right-click on the pixel and select the **Debug** button shown inside the **Pixel
    Context** window. This will open a new **Shader Viewer** tab, where you can step
    through the shader code line by line. For each line, you can inspect the values
    of your variables and see how they change as the shader executes.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要调试特定的片段，你需要在**纹理查看器**中选择一个像素。你可以通过点击你感兴趣的像素来完成此操作。此像素的值代表该特定像素的片段着色器的输出。选择像素后，你可以调试生成它的片段着色器。为此，在**像素上下文**窗口中右键单击像素并选择显示的**调试**按钮。这将打开一个新的**着色器查看器**标签，在那里你可以逐行执行着色器代码。对于每一行，你可以检查变量的值并查看它们在着色器执行过程中的变化。
- en: The compute shader stage is used for performing general-purpose computations
    on the GPU. Here, you can inspect and debug the operations that aren’t directly
    related to rendering, such as physics simulations or culling. In the next step,
    we will demonstrate using the executable from [*Chapter 3*](B18491_03.xhtml#_idTextAnchor217),
    *Implementing GPU-Driven Rendering*, in the *Frustum culling using compute* *shaders*
    recipe.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 计算着色器阶段用于在GPU上执行通用计算。在这里，您可以检查和调试与渲染无关的操作，例如物理模拟或剔除。在下一步中，我们将演示如何使用来自[*第3章*](B18491_03.xhtml#_idTextAnchor217)，*实现GPU驱动渲染*，*使用计算着色器进行视锥剔除*食谱的可执行文件。
- en: 'To understand how to debug the compute shader, we will first need to launch
    `Chapter03_GPU_Culling.exe` from RenderDoc. Once the application is up, we will
    take a capture. Next, navigate to the `vkCmdDispatch` call. Selecting this call
    in **Event Browser** will display the associated pipeline used by this call in
    the **Pipeline State** tab, as demonstrated in *Figure 9**.3*:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要了解如何调试计算着色器，我们首先需要从RenderDoc启动`Chapter03_GPU_Culling.exe`。一旦应用程序启动，我们将进行捕获。接下来，导航到`vkCmdDispatch`调用。在**事件浏览器**中选择此调用将在**管道状态**选项卡中显示此调用使用的相关管道，如图*图9*.3*所示：
- en: '![Figure 9.3 – Compute shader as seen in RenderDoc](img/B18491_09_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 在RenderDoc中看到的计算着色器](img/B18491_09_03.jpg)'
- en: Figure 9.3 – Compute shader as seen in RenderDoc
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 在RenderDoc中看到的计算着色器
- en: 'When it comes to culling, we launch as many threads as there are meshes. Then,
    on the GPU, we’re simply discarding any mesh that isn’t visible in the frustum.
    Let’s assume we’re interested in understanding why mesh number 5 is outside the
    frustum. To debug this, click the **Debug** button and specify the thread ID in
    the **Debug Compute Shader** window. This window allows you to specify either
    a global thread ID or a thread group and a local thread ID. In our case, to debug
    mesh number 5, you would enter 5 in the global X dimension (in the **Dispatch
    Thread ID** section). Once you click the **Debug** button, a new window containing
    the shader source code will be launched. Here, you can inspect and debug the compute
    shader, enabling you to understand why a particular mesh was discarded. The process
    is demonstrated in *Figure 9**.4*:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当涉及到剔除时，我们启动与网格数量相同的线程。然后，在GPU上，我们简单地丢弃任何不在视锥体内的网格。假设我们感兴趣的是了解为什么网格编号5在视锥体之外。为了调试这个问题，点击**调试**按钮并在**调试计算着色器**窗口中指定线程ID。此窗口允许您指定全局线程ID或线程组和局部线程ID。在我们的情况下，要调试网格编号5，您需要在全局X维度中输入5（在**调度线程ID**部分）。一旦您点击**调试**按钮，将启动一个包含着色器源代码的新窗口。在这里，您可以检查和调试计算着色器，使您能够了解为什么特定的网格被丢弃。这个过程如图*图9*.4*所示：
- en: '![Figure 9.4 – Debugging a compute shader in RenderDoc](img/B18491_09_04.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 在RenderDoc中调试计算着色器](img/B18491_09_04.jpg)'
- en: Figure 9.4 – Debugging a compute shader in RenderDoc
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 在RenderDoc中调试计算着色器
- en: This recipe is a very brief introduction to *one* frame debugging tool. Keep
    in mind other tools exist and operate in different ways.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱是对*一个*帧调试工具的简要介绍。请注意，其他工具也存在并且以不同的方式运行。
- en: See also
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'For a comprehensive understanding of how to utilize RenderDoc, we highly recommend
    viewing the following video tutorials. These will provide you with detailed insights
    into its usage:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了全面了解如何使用RenderDoc，我们强烈建议观看以下视频教程。这些教程将为您提供详细的见解：
- en: '[https://youtu.be/7eznPe3TyAY](https://youtu.be/7eznPe3TyAY)'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://youtu.be/7eznPe3TyAY](https://youtu.be/7eznPe3TyAY)'
- en: '[https://youtu.be/EMFG5wmng-M](https://youtu.be/EMFG5wmng-M)'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://youtu.be/EMFG5wmng-M](https://youtu.be/EMFG5wmng-M)'
- en: '[https://renderdoc.org/docs/getting_started/quick_start.html](https://renderdoc.org/docs/getting_started/quick_start.html)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://renderdoc.org/docs/getting_started/quick_start.html](https://renderdoc.org/docs/getting_started/quick_start.html)'
- en: Naming Vulkan objects for easy debugging
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Vulkan对象命名以方便调试
- en: 'Using Vulkan means you need to create and manage many Vulkan objects. By default,
    those objects are identified by their handle, a numerical ID. Although numerical
    IDs are easy to maintain from an application perspective, they are meaningless
    to humans. Consider the following error message, provided by the validation layer:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Vulkan意味着您需要创建和管理许多Vulkan对象。默认情况下，这些对象通过其句柄，一个数字ID来标识。虽然数字ID从应用程序的角度来看很容易维护，但对人类来说没有意义。考虑以下由验证层提供的错误消息：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding message is useful, but finding which image has been created with
    the wrong number of layers is hard.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的信息很有用，但找到创建错误层数量的图像很困难。
- en: 'If, on the other hand, we give that image a name, the validation layer message
    becomes the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们给这个图像起一个名字，验证层消息将变为以下内容：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the name of the object is now part of the error message. That makes
    it much easier to know where to look in your code and fix the error.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对象的名称现在已成为错误消息的一部分。这使得知道在代码中查找错误位置并修复错误变得容易得多。
- en: In this recipe, you will learn how to use a Vulkan extension to give human-readable
    or meaningful names to all Vulkan objects.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用Vulkan扩展为所有Vulkan对象赋予可读的或有意义的名称。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To be able to assign names to a Vulkan object, you first need to enable the
    `VK_EXT_debug_utils` instance extension. This extension’s name needs to be provided
    during the creation of the Vulkan instance as either a string, `VK_EXT_debug_utils`,
    or using the `VK_EXT_DEBUG_UTILS_EXTENSION_NAME` macro. The following code snippet
    initializes a Vulkan instance with debug utilities enabled:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够为Vulkan对象分配名称，你首先需要启用`VK_EXT_debug_utils`实例扩展。在创建Vulkan实例时，需要提供该扩展的名称，可以是字符串`VK_EXT_debug_utils`或使用`VK_EXT_DEBUG_UTILS_EXTENSION_NAME`宏。以下代码片段初始化了一个启用了调试工具的Vulkan实例：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now you are ready to start naming your Vulkan object. Let’s see how in the next
    section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好开始给你的Vulkan对象命名了。让我们在下一节中看看如何操作。
- en: How to do it…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once the extension has been enabled, here are the steps to name your objects:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用扩展，命名对象的步骤如下：
- en: 'Once the extension has been enabled, you may add a name to any Vulkan object,
    given its handle, by calling the `vkSetDebugUtilsObjectNameEXT` function:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦启用扩展，你可以通过调用`vkSetDebugUtilsObjectNameEXT`函数，为给定句柄的任何Vulkan对象添加名称：
- en: '[PRE3]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The object type (`type`) is one of the values of the `VkObject` enumeration
    and must match the object’s type (`VK_OBJECT_TYPE_IMAGE` for a Vulkan Image, for
    example). The handle is the object’s handle, which needs to be cast to type `uint64_t`.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对象类型（`type`）是`VkObject`枚举的值之一，必须与对象的类型匹配（例如，对于Vulkan图像，为`VK_OBJECT_TYPE_IMAGE`）。句柄是对象的句柄，需要将其转换为类型`uint64_t`。
- en: This function is only available if the extension is also available, so make
    sure to guard it in an `#ifdef` block and check whether the extension has been
    enabled for the instance.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数仅在扩展也可用时才可用，因此请确保在`#ifdef`块中保护它，并检查是否已为实例启用了扩展。
- en: 'In the repository, the `VulkanCore::Context:: setVkObjectname` method wraps
    this function in a templated class and does the casting for you. Also, it’s worth
    mentioning that names aren’t only displayed on validation error messages. They
    also appear in frame capture and debugging tools.'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在仓库中，`VulkanCore::Context:: setVkObjectname` 方法将这个函数封装在一个模板类中，并为你进行类型转换。此外，值得一提的是，名称不仅显示在验证错误消息中，它们还出现在帧捕获和调试工具中。'
- en: '![Figure 9.5 - Examples of how object names appear in RenderDoc](img/B18491_09_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 - RenderDoc中对象名称的显示示例](img/B18491_09_05.jpg)'
- en: Figure 9.5 - Examples of how object names appear in RenderDoc
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 - RenderDoc中对象名称的显示示例
- en: '*Figure 9**.5* shows how object names are displayed in RenderDoc. In the screenshot,
    one of the swapchain images is named **Image: Swapchain image 1**. The depth buffer
    is named **Image:** **depth buffer**.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.5* 展示了在RenderDoc中对象名称的显示方式。在截图上，其中一个swapchain图像被命名为**Image: Swapchain image
    1**。深度缓冲区被命名为**Image:** **depth buffer**。'
- en: Printing values from shaders in Vulkan
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Vulkan中从着色器打印值
- en: As graphics programmers, we must all agree that debugging shaders is one of
    the most frustrating aspects of our jobs. Even though some frame capture software
    provides shader debugging, it may still be difficult to find the exact pixel you
    would like to debug, or you may need another piece of information about a set
    of pixels instead of just inspecting them one by one.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为图形程序员，我们所有人都必须同意，调试着色器是我们工作中最令人沮丧的方面之一。尽管一些帧捕获软件提供了着色器调试功能，但仍然可能很难找到你想要调试的确切像素，或者你可能需要关于一组像素的另一条信息，而不仅仅是逐个检查它们。
- en: Thankfully, Vulkan provides a way to print values directly from shaders. The
    information can be inspected directly on RenderDoc, for example, or retrieved
    from the validation error messages (please refer to the *Retrieving debugging
    information from shaders* recipe for more details on how to do this).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Vulkan提供了一种直接从着色器打印值的方法。信息可以直接在RenderDoc上检查，例如，或从验证错误消息中检索（有关如何操作的更多详细信息，请参阅*从着色器检索调试信息*菜谱）。
- en: In this recipe, you will learn how to print values from your shader code using
    a simple function that is like `printf`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用类似于`printf`的简单函数从你的着色器代码中打印值。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To utilize the functionality of printing values from shaders, it’s a prerequisite
    to enable the `VK_KHR_shader_non_semantic_info` device extension. This can be
    achieved by adding either the `VK_KHR_shader_non_semantic_info` string or the
    `VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME` macro to the `VkDeviceCreateInfo`
    structure during the creation of a Vulkan device. This process is demonstrated
    in the following code snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用从着色器中打印值的功能，启用`VK_KHR_shader_non_semantic_info`设备扩展是先决条件。这可以通过在创建Vulkan设备时将`VK_KHR_shader_non_semantic_info`字符串或`VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME`宏添加到`VkDeviceCreateInfo`结构中来实现。这个过程在以下代码片段中得到了演示：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that the extension has been enabled, let’s see what the steps are to print
    values directly from shaders.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在扩展已经启用，让我们看看直接从着色器中打印值的步骤。
- en: How to do it…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once the extension has been enabled, you will also need to add a GLSL extension
    to your shaders:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦扩展被启用，你还需要将一个GLSL扩展添加到你的着色器中：
- en: 'Enable the `GL_EXT_debug_printf` extension in your shader code:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的着色器代码中启用`GL_EXT_debug_printf`扩展：
- en: '[PRE5]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: debugPrintfEXT("gl_VertexIndex = %i", gl_VertexIndex);
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: debugPrintfEXT("gl_VertexIndex = %i", gl_VertexIndex);
- en: '[PRE6]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The function provides specifiers for vector values as well. Here’s an example
    of a call that prints all components of a `vec3` variable:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该函数还提供了向量值的指定符。以下是一个打印`vec3`变量所有分量的调用示例：
- en: '[PRE7]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding function call prints the `x`, `y`, and `z` components of `position`
    as a floating-point value with 3 decimals.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的函数调用以浮点数形式打印`position`的`x`、`y`和`z`分量，保留3位小数。
- en: 'Here’s the abridged version of the vertex shader used in [*Chapter 1*](B18491_01.xhtml#_idTextAnchor019),
    *Vulkan Core Concepts*, with the added `debugPrintfEXT` call to print the `gl_VertexIndex`
    value:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[*第1章*](B18491_01.xhtml#_idTextAnchor019)，*Vulkan核心概念*中使用的顶点着色器的简略版本，增加了`debugPrintfEXT`调用以打印`gl_VertexIndex`值：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Figure 9**.6* shows how the printed values can be inspected in RenderDoc:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.6*展示了如何在RenderDoc中检查打印的值：'
- en: '![Figure 9.6 – debugPrintfEXT values visible in RenderDoc](img/B18491_09_06.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – RenderDoc中可见的debugPrintfEXT值](img/B18491_09_06.jpg)'
- en: Figure 9.6 – debugPrintfEXT values visible in RenderDoc
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – RenderDoc中可见的debugPrintfEXT值
- en: Intercepting validation layer messages
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 截获验证层消息
- en: In some circumstances, validation errors are so plentiful that it becomes impossible
    to know where the cause of the problem is. For that reason, it would be ideal
    to interrupt the execution of your program as soon as an error is detected, especially
    when debugging your application. The debug utility extension (`VK_EXT_debug_utils`)
    allows you to install a callback function that is invoked whenever an error is
    detected.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，验证错误如此之多，以至于无法知道问题的原因。因此，当检测到错误时立即中断程序的执行将是非常理想的，尤其是在调试应用程序时。调试实用工具扩展（`VK_EXT_debug_utils`）允许你在检测到错误时安装一个回调函数。
- en: In this recipe, you will learn how to install a debug callback to intercept
    error messages emitted by the validation layer and make your debugging sessions
    more productive.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何安装一个调试回调来截获验证层发出的错误消息，并使你的调试会话更加高效。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To be able to set a callback whenever an error occurs, you need to enable the
    `VK_EXT_debug_utils` extension. Please refer to the *Getting ready* section of
    the *Naming Vulkan objects for easier debugging* recipe to learn how to enable
    this extension when creating a Vulkan instance.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够在错误发生时设置回调，你需要启用`VK_EXT_debug_utils`扩展。请参考*命名Vulkan对象以简化调试*菜谱中的*准备工作*部分，了解如何在创建Vulkan实例时启用此扩展。
- en: How to do it…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Before installing and using the callback, you need to define one. After that,
    and once the extension has been enabled and a Vulkan instance object has been
    created, you need to install the callback using a special Vulkan function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装和使用回调之前，你需要定义一个。之后，一旦扩展被启用并且创建了一个Vulkan实例对象，你需要使用特殊的Vulkan函数来安装回调：
- en: 'Define a callback function with the following signature:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个具有以下签名的回调函数：
- en: '[PRE9]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s the function used as a callback provided in the repository:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是存储库中提供的用作回调的函数：
- en: '[PRE10]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Your callback can decide how to treat the message, if at all, based on its type
    (general message, validation message, performance message) or its severity (verbose,
    info, warning, or error). The `pCallbackData` parameter (of type `VkDebugUtilsMessengerCallbackDataEXT`)
    provides a plethora of different information you can use, while the `pUserData`
    parameter may contain your own data, which is provided when installing the callback.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您的回调可以根据消息的类型（一般消息、验证消息、性能消息）或其严重性（详细、信息、警告或错误）来决定如何处理消息。`pCallbackData`参数（类型为`VkDebugUtilsMessengerCallbackDataEXT`）提供了大量您可以使用的信息，而`pUserData`参数可能包含您自己的数据，该数据在安装回调时提供。
- en: 'Install the callback once you have a valid Vulkan instance by creating an instance
    of the `VkDebugUtilsMessengerCreateInfoEXT` structure:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建`VkDebugUtilsMessengerCreateInfoEXT`结构体的实例，在您拥有有效的Vulkan实例后安装回调：
- en: '[PRE11]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Make sure to destroy the messenger once you are done with your Vulkan instance.
    This is necessary because, in Vulkan, any resources created need to be explicitly
    destroyed when they’re no longer needed to avoid memory leaks and to free up system
    resources:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在完成您的Vulkan实例后销毁信使。这是必要的，因为在Vulkan中，任何创建的资源在不再需要时都需要显式销毁，以避免内存泄漏并释放系统资源：
- en: '[PRE12]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The debug callback is very useful and should always be used. Make sure to have
    one as soon as possible and know how to use it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 调试回调非常有用，应该始终使用。确保尽快拥有一个，并了解如何使用它。
- en: Retrieving debug information from shaders
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从着色器中检索调试信息
- en: One of the most difficult tasks in graphics programming is writing tests. Be
    those smoke, integration, end-to-end, or unit tests, how do you ensure that the
    output of your engine is really what you would expect? Except for simple tests,
    screenshot-like types of tests are prone to several problems. One particularly
    difficult problem is testing shader code – since you don’t usually have access
    to the hardware, testing shader code is very painful.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图形编程中最困难的任务之一是编写测试。无论是烟雾测试、集成测试、端到端测试还是单元测试，您如何确保您引擎的输出确实是您所期望的？除了简单的测试外，类似于截图的测试类型容易遇到几个问题。一个特别困难的问题是测试着色器代码——因为您通常无法访问硬件，测试着色器代码非常痛苦。
- en: Thankfully, Vulkan has a mechanism that allows you to capture the value output
    from shaders with the `debugPrintfEXT` function directly from the validation layer.
    This mechanism isn’t new and could be enabled using the `Vulkan SDK 1.3.275`,
    the `VK_EXT_layer_settings` instance extension allows you to enable this mechanism
    directly from your application without manually having to edit any other configuration.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Vulkan有一个机制，允许您通过`debugPrintfEXT`函数直接从验证层捕获着色器输出的值。这个机制并不新颖，可以通过`Vulkan
    SDK 1.3.275`启用，`VK_EXT_layer_settings`实例扩展允许您直接从您的应用程序中启用此机制，而无需手动编辑任何其他配置。
- en: In this recipe, you will learn how to enable this feature and retrieve the output
    of `debugPrintfEXT` calls from shaders.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将学习如何启用此功能并从着色器中检索`debugPrintfEXT`调用的输出。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need `Vulkan SDK version 1.3.275`. Although all the
    code in the repository was tested with `SDK version 1.3.265`, the `VK_EXT_layer_settings`
    extension was only available with `SDK 1.3.275`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，您需要`Vulkan SDK版本1.3.275`。尽管存储库中的所有代码都已使用`SDK版本1.3.265`进行测试，但`VK_EXT_layer_settings`扩展仅在`SDK
    1.3.275`中可用。
- en: How to do it…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Enabling this feature is easy and requires only a few steps. Let’s get to them:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此功能很容易，只需几个步骤。让我们来看看它们：
- en: 'The `VK_EXT_layer_settings` extension introduces a way for you to change individual
    layer settings. Each setting must be set using an instance of the `VKLayerSettingEXT`
    structure, defined as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VK_EXT_layer_settings`扩展为您提供了更改单个层设置的方法。每个设置都必须使用`VKLayerSettingEXT`结构体的实例设置，该结构体定义如下：'
- en: '[PRE13]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To enable the feature that allows you to receive output from shaders, you need
    to enable a few settings of the `VK_LAYER_KHRONOS_validation` layer. Let’s start
    by creating a constant with the layer name for which we’ll change the settings:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用允许您接收着色器输出的功能，您需要启用`VK_LAYER_KHRONOS_validation`层的几个设置。让我们首先创建一个包含层名称的常量，我们将为此更改设置：
- en: '[PRE14]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we create arrays to store the values of the settings we’ll use:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建数组来存储我们将使用的设置值：
- en: '[PRE15]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `debug_action` setting was changed to `VK_DBG_LAYER_ACTION_BREAK` so that
    the callback is called whenever there’s a new value from `debugPrintfEXT`. The
    `validate_gpu_based` setting is set to receive the `debugPrintEXT` values (`GPU_BASED_DEBUG_PRINTF`)
    and the `printf_to_stdout` setting (set to `VK_FALSE`) specifies we don’t want
    those values to go to `stdout`; we want to receive them in the callback.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将`debug_action`设置更改为`VK_DBG_LAYER_ACTION_BREAK`，以便每当从`debugPrintfEXT`收到新值时，都会调用回调。将`validate_gpu_based`设置设置为接收`debugPrintEXT`值（`GPU_BASED_DEBUG_PRINTF`）和`printf_to_stdout`设置（设置为`VK_FALSE`）指定我们不想将这些值发送到`stdout`；我们希望在回调中接收它们。
- en: 'We create instances of the `VkLayerSettingEXT` structure for each setting we
    would like to change. Here, we are changing the following settings of the `layer_name`
    layer: `debug_action`, `validate_gpu_based`, and `printf_to_stdout`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为每个想要更改的设置创建一个`VkLayerSettingEXT`结构的实例。在这里，我们正在更改`layer_name`层的以下设置：`debug_action`、`validate_gpu_based`和`printf_to_stdout`：
- en: '[PRE16]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then we add those settings to an instance of the `VkLayerSettingsCreateInfoEXT`
    structure:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将这些设置添加到`VkLayerSettingsCreateInfoEXT`结构的实例中：
- en: '[PRE17]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we add this instance to the `pNext` chain of the `VkInstanceCreateInfo`
    structure used to create the Vulkan instance:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将此实例添加到创建Vulkan实例时使用的`VkInstanceCreateInfo`结构的`pNext`链中：
- en: '[PRE18]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When enabled for [*Chapter 1*](B18491_01.xhtml#_idTextAnchor019), *Vulkan Core
    Concepts,* code in the repository, the message received by the callback looks
    something like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当[*第1章*](B18491_01.xhtml#_idTextAnchor019)“Vulkan核心概念”启用时，回调接收到的消息大致如下：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It is possible to enable a verbose output, in which case the preceding message
    would look like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以启用详细输出，在这种情况下，前面的消息将看起来像这样：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Hopefully, this feature will help you write tests for obscure corners of your
    code that weren’t even possible to test before.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个功能能帮助你编写测试，测试那些以前甚至无法测试的代码的隐蔽角落。
- en: Measuring performance in Vulkan with timestamp queries
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用时间戳查询在Vulkan中测量性能
- en: Measuring the performance of CPU and GPU workloads side by side is invaluable.
    The **Tracy profiler** allows you to do just that in a cross-platform way with
    minimal intrusion. And it’s easy to use, all within a small C++ library.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉平台方式以最小侵入性测量CPU和GPU工作负载的性能是非常宝贵的。**Tracy分析器**允许你这样做，并且使用起来非常简单，全部都在一个小型的C++库中。
- en: In this recipe, you will learn how to integrate Tracy Profiler into your app
    and instrument it to collect GPU performance information.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何将Tracy分析器集成到你的应用程序中，并对其进行调试以收集GPU性能信息。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The first thing to do is to download Tracy from [https://github.com/wolfpld/tracy](https://github.com/wolfpld/tracy)
    and include it in your project. You should also download the Tracy client/server
    to collect and inspect the data.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首件事是下载Tracy从[https://github.com/wolfpld/tracy](https://github.com/wolfpld/tracy)，并将其包含到你的项目中。你还应该下载Tracy客户端/服务器以收集和检查数据。
- en: How to do it…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Instrumenting your code to use with Tracy is easy and requires only a few steps.
    To be able to collect data about the GPU performance, you will need a Tracy/Vulkan
    context along with a dedicated command buffer for it to calibrate the timestamps.
    After that, instrumenting your code is straightforward:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Tracy对代码进行调试以方便使用只需要几个步骤。为了能够收集关于GPU性能的数据，你需要一个Tracy/Vulkan上下文以及一个用于校准时间戳的专用命令缓冲区。之后，对代码进行调试就变得简单直接：
- en: 'First, include the Tracy header file in your application:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将Tracy头文件包含到你的应用程序中：
- en: '[PRE21]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Second, you need a Tracy/Vulkan context that can be created by using a macro
    provided by the Tracy library. There are two options: one that creates a context
    with calibrated timestamps and one that creates a context without calibrated timestamps.
    Vulkan provides ways to correlate the time an operation happened on timelines
    of different time domains. Without calibration, Tracy can only guess when an operation
    on the device happened in relation to the ones that took place on the CPU. Here’s
    how you can initialize the context that better suits your needs:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，你需要一个Tracy/Vulkan上下文，可以使用Tracy库提供的宏来创建。有两种选择：一种创建带有校准时间戳的上下文，另一种创建不带校准时间戳的上下文。Vulkan提供了关联不同时间域操作发生时间的方法。没有校准，Tracy只能猜测设备上的操作相对于在CPU上发生的操作发生的时间。以下是如何初始化更适合你需求的上下文的方法：
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The command buffer used here is a dedicated one and it should not be shared
    with any other operations.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里使用的命令缓冲区是专用的，它不应该与其他任何操作共享。
- en: 'Collecting GPU information is now easy. All you must do is use one of the macros
    provided by Tracy, such as the following:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集 GPU 信息现在变得容易。你所要做的就是使用 Tracy 提供的宏之一，例如以下内容：
- en: '[PRE23]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the `commandBuffer` variable used in this macro is the command buffer
    you wish to capture data from, the one being recorded. This command buffer is
    *different* than the one provided during the construction of the Tracy context.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在这个宏中使用的 `commandBuffer` 变量是你希望从其中捕获数据的命令缓冲区，即正在记录的命令缓冲区。这个命令缓冲区与在构建 Tracy
    上下文时提供的命令缓冲区不同。
- en: This macro should be added whenever you would like to instrument your GPU execution.
    For example, you might want to add this macro to a scope where you issue the draw
    call (such as `vkCmdDraw`). You will then get information about that command being
    processed in the GPU. In the repository, you can find examples of how this macro
    is used.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个宏应该在你想仪器化你的 GPU 执行时添加。例如，你可能想在发出绘制调用（如 `vkCmdDraw`）的作用域中添加这个宏。这样你将获得关于该命令在
    GPU 上处理的详细信息。在仓库中，你可以找到这个宏的使用示例。
- en: Tracy also provides macros that allow you to identify the zone with a color
    or name, such as `TracyVkNamedZone`, `TracyVkNamedZoneC`, and so on.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Tracy 还提供了允许你使用颜色或名称标识区域的宏，例如 `TracyVkNamedZone`、`TracyVkNamedZoneC` 等。
- en: 'Occasionally, you need to tell Tracy to collect the timestamps from the command
    buffer by calling `TracyVkCollect`. This macro can be called at the end of a frame:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时，你需要告诉 Tracy 通过调用 `TracyVkCollect` 来收集命令缓冲区的时间戳。这个宏可以在帧的末尾调用：
- en: '[PRE24]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After exiting the render loop, and before shutting down your application, you
    need to destroy the Tracy context by calling `TracyVkDestroy`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在退出渲染循环并在关闭应用程序之前，你需要通过调用 `TracyVkDestroy` 来销毁 Tracy 上下文：
- en: '[PRE25]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last step is to build your project with `TRACY_ENABLE` defined. If using
    CMake, you can do this by adding the following parameters when generating the
    project’s build files:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是在定义了 `TRACY_ENABLE` 的情况下构建你的项目。如果你使用 CMake，可以在生成项目构建文件时添加以下参数：
- en: '[PRE26]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now all you must do is compile your code and run it. Make sure to start the
    Tracy client beforehand and start a connection. The Tracy client will automatically
    detect your application and start collecting data once it starts.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你必须做的就是编译你的代码并运行它。确保在开始之前启动 Tracy 客户端并建立连接。Tracy 客户端将自动检测你的应用程序并在启动时开始收集数据。
- en: If you instrument your code to collect CPU data using Tracy, which you can do
    using macros such as `ZoneScoped`, `ZoneScopedC`, and so on, you will see the
    results side by side after collection. *Figure 9**.7* shows the result of capturing
    one of the executables from [*Chapter 2*](B18491_02.xhtml#_idTextAnchor126), *Working
    with Modern Vulkan*. Note the CPU and GPU zones in the screenshot.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你使用 Tracy 仪器化你的代码以收集 CPU 数据，你可以使用例如 `ZoneScoped`、`ZoneScopedC` 等宏来实现，收集后你将看到并排的结果。*图
    9.7* 展示了从 [*第 2 章*](B18491_02.xhtml#_idTextAnchor126)，*使用现代 Vulkan* 中捕获的一个可执行文件的结果。注意截图中的
    CPU 和 GPU 区域。
- en: '![Figure 9.7 – Tracy profiler capture with GPU and CPU information side by
    side](img/B18491_09_07.jpg)'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 9.7 – Tracy 分析器捕获，GPU 和 CPU 信息并排显示](img/B18491_09_07.jpg)'
- en: Figure 9.7 – Tracy profiler capture with GPU and CPU information side by side
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – Tracy 分析器捕获，GPU 和 CPU 信息并排显示
- en: Tracy is a very simple-to-use library that provides invaluable information about
    your application. It provides nanosecond resolution along with CPU and GPU performance
    tracking and is cross-platform. If you don’t already have other performance-measuring
    libraries or facilities in your code base, Tracy can get you up and running in
    no time.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Tracy 是一个非常易于使用的库，它提供了关于你的应用程序的无价信息。它提供了纳秒级分辨率，以及 CPU 和 GPU 性能跟踪，并且是跨平台的。如果你在代码库中还没有其他性能测量库或设施，Tracy
    可以让你迅速开始使用。
